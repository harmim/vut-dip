// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$42;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$33;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$43;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$35;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$39;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$32;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$34;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$40;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$22;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$31;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$29;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$36;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$27;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$24;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$26;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$28;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$11;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$10;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$14;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$15;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$16;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$48;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$20;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$19;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$18;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$0;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$17;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous$49;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$13;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$47;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$1;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$3;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$25;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$8;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$23;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$12;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$46;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$9;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$50;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$2;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$21;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$7;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$6;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$5;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$4;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$37;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$38;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous$30;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$41;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 129
union anonymous$45;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$44;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-current_recording
// file g15macro.c line 110
struct current_recording;

// tag-g15canvas
// file /usr/include/libg15render.h line 46
struct g15canvas;

// tag-gkeys_s
// file g15macro.c line 99
struct gkeys_s;

// tag-keypress_s
// file g15macro.c line 81
struct keypress_s;

// tag-keysequence_s
// file g15macro.c line 94
struct keysequence_s;

// tag-mstates_s
// file g15macro.c line 104
struct mstates_s;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#ifndef NULL
#define NULL ((void*)0)
#endif

// Lkeys_thread
// file g15macro.c line 532
void * Lkeys_thread();
// XChangeKeyboardMapping
// file /usr/include/X11/Xlib.h line 2051
extern signed int XChangeKeyboardMapping(struct _XDisplay *, signed int, signed int, unsigned long int *, signed int);
// XCheckMaskEvent
// file /usr/include/X11/Xlib.h line 2103
extern signed int XCheckMaskEvent(struct _XDisplay *, signed long int, union _XEvent *);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XGetInputFocus
// file /usr/include/X11/Xlib.h line 2638
extern signed int XGetInputFocus(struct _XDisplay *, unsigned long int *, signed int *);
// XGrabKeyboard
// file /usr/include/X11/Xlib.h line 2720
extern signed int XGrabKeyboard(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, unsigned long int);
// XKeycodeToKeysym
// file /usr/include/X11/Xlib.h line 1687
extern unsigned long int XKeycodeToKeysym(struct _XDisplay *, unsigned char, signed int);
// XKeysymToKeycode
// file /usr/include/X11/Xlib.h line 2773
extern unsigned char XKeysymToKeycode(struct _XDisplay *, unsigned long int);
// XKeysymToString
// file /usr/include/X11/Xlib.h line 1518
extern char * XKeysymToString(unsigned long int);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSendEvent
// file /usr/include/X11/Xlib.h line 3135
extern signed int XSendEvent(struct _XDisplay *, unsigned long int, signed int, signed long int, union _XEvent *);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous$24 *)))(struct _XDisplay *, struct anonymous$24 *);
// XStringToKeysym
// file /usr/include/X11/Xlib.h line 1710
extern unsigned long int XStringToKeysym(const char *);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XTestFakeKeyEvent
// file /usr/include/X11/extensions/XTest.h line 55
extern signed int XTestFakeKeyEvent(struct _XDisplay *, unsigned int, signed int, unsigned long int);
// XUngrabKeyboard
// file /usr/include/X11/Xlib.h line 3476
extern signed int XUngrabKeyboard(struct _XDisplay *, unsigned long int);
// calc_mkey_offset
// file g15macro.c line 326
signed int calc_mkey_offset();
// change_keymap
// file g15macro.c line 480
void change_keymap(signed int offset);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// configure_mmediakeys
// file g15macro.c line 495
void configure_mmediakeys();
// dump_config
// file g15macro.c line 403
void dump_config(struct _IO_FILE *configfile);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fake_keyevent
// file g15macro.c line 230
void fake_keyevent(signed int keycode, signed int keydown, unsigned long int modifiers);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// g15_send
// file /usr/include/g15daemon_client.h line 67
signed int g15_send(signed int, char *, unsigned int);
// g15_send_cmd
// file /usr/include/g15daemon_client.h line 71
unsigned long int g15_send_cmd(signed int, unsigned char, unsigned char);
// g15daemon_gettime_ms
// file g15macro.c line 618
unsigned int g15daemon_gettime_ms();
// g15daemon_version
// file /usr/include/g15daemon_client.h line 55
const char * g15daemon_version();
// g15macro_log
// file g15macro.c line 217
static signed int g15macro_log(const char *fmt, ...);
// g15macro_sighandler
// file g15macro.c line 754
void g15macro_sighandler(signed int sig);
// g15r_initCanvas
// file /usr/include/libg15render.h line 136
void g15r_initCanvas(struct g15canvas *);
// g15r_loadWbmpSplash
// file /usr/include/libg15render.h line 115
signed int g15r_loadWbmpSplash(struct g15canvas *, char *);
// g15r_renderString
// file /usr/include/libg15render.h line 151
void g15r_renderString(struct g15canvas *, unsigned char *, signed int, signed int, unsigned int, unsigned int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handle_mkey_switch
// file g15macro.c line 509
void handle_mkey_switch(unsigned int mkey);
// helptext
// file g15macro.c line 765
void helptext();
// macro_playback
// file g15macro.c line 344
void macro_playback(unsigned long int keystate);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// map_gkey
// file g15macro.c line 191
signed int map_gkey(signed int keystate);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 321
extern signed int mkdir(const char *, unsigned int);
// myx_error_handler
// file g15macro.c line 750
signed int myx_error_handler(struct _XDisplay *dpy, struct anonymous$24 *err);
// new_g15_screen
// file /usr/include/g15daemon_client.h line 60
signed int new_g15_screen(signed int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_init
// file /usr/include/pthread.h line 298
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setschedpolicy
// file /usr/include/pthread.h line 342
extern signed int pthread_attr_setschedpolicy(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 386
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 261
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 765
extern signed int pthread_mutex_destroy(union anonymous$44 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_init(union anonymous$44 *, const union anonymous$45 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous$44 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous$44 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// record_cancel
// file g15macro.c line 281
void record_cancel();
// record_cleanup
// file g15macro.c line 270
void record_cleanup();
// record_complete
// file g15macro.c line 289
void record_complete(unsigned long int keystate);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// restore_config
// file g15macro.c line 440
void restore_config(char *filename);
// save_macros
// file g15macro.c line 431
void save_macros(char *filename);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// xevent_thread
// file g15macro.c line 700
static void * xevent_thread();
// xkey_handler
// file g15macro.c line 624
void xkey_handler(union _XEvent *event);

struct anonymous$42
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$40 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$35 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$33
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$43 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$42 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$43
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$35
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$39
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$32
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$34
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$40
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$35 *visuals;
};

struct anonymous$22
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$31
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$29
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$27
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$37
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$41
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$22 _kill;
  // _timer
  struct anonymous$27 _timer;
  // _rt
  struct anonymous$29 _rt;
  // _sigchld
  struct anonymous$31 _sigchld;
  // _sigfault
  struct anonymous$32 _sigfault;
  // _sigpoll
  struct anonymous$37 _sigpoll;
  // _sigsys
  struct anonymous$39 _sigsys;
};

struct anonymous$36
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$41 _sifields;
};

struct anonymous$24
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$11
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$10
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$14
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$15
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$16
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$20
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$19
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$18
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$0
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$17
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$13
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$1
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$3
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$8
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$12
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$9
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$2
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$30
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$21
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$30 data;
};

struct anonymous$7
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$6
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$5
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$4
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

union anonymous$38
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$36 *, void *);
};

union anonymous$45
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$44
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$3 xany;
  // xkey
  struct anonymous$4 xkey;
  // xbutton
  struct anonymous$5 xbutton;
  // xmotion
  struct anonymous$6 xmotion;
  // xcrossing
  struct anonymous$7 xcrossing;
  // xfocus
  struct anonymous$8 xfocus;
  // xexpose
  struct anonymous$9 xexpose;
  // xgraphicsexpose
  struct anonymous$10 xgraphicsexpose;
  // xnoexpose
  struct anonymous$11 xnoexpose;
  // xvisibility
  struct anonymous$12 xvisibility;
  // xcreatewindow
  struct anonymous$13 xcreatewindow;
  // xdestroywindow
  struct anonymous$14 xdestroywindow;
  // xunmap
  struct anonymous$15 xunmap;
  // xmap
  struct anonymous$16 xmap;
  // xmaprequest
  struct anonymous$17 xmaprequest;
  // xreparent
  struct anonymous$18 xreparent;
  // xconfigure
  struct anonymous$19 xconfigure;
  // xgravity
  struct anonymous$20 xgravity;
  // xresizerequest
  struct anonymous$46 xresizerequest;
  // xconfigurerequest
  struct anonymous$47 xconfigurerequest;
  // xcirculate
  struct anonymous$48 xcirculate;
  // xcirculaterequest
  struct anonymous$49 xcirculaterequest;
  // xproperty
  struct anonymous$50 xproperty;
  // xselectionclear
  struct anonymous xselectionclear;
  // xselectionrequest
  struct anonymous$0 xselectionrequest;
  // xselection
  struct anonymous$1 xselection;
  // xcolormap
  struct anonymous$2 xcolormap;
  // xclient
  struct anonymous$21 xclient;
  // xmapping
  struct anonymous$23 xmapping;
  // xerror
  struct anonymous$24 xerror;
  // xkeymap
  struct anonymous$25 xkeymap;
  // xgeneric
  struct anonymous$26 xgeneric;
  // xcookie
  struct anonymous$28 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct keypress_s
{
  // keycode
  unsigned long int keycode;
  // time_ms
  unsigned long int time_ms;
  // pressed
  unsigned char pressed;
  // modifiers
  unsigned long int modifiers;
  // mouse_x
  unsigned int mouse_x;
  // mouse_y
  unsigned int mouse_y;
  // buttons
  unsigned int buttons;
};

struct current_recording
{
  // recorded_keypress
  struct keypress_s recorded_keypress[1024l];
};

struct g15canvas
{
  // buffer
  unsigned char buffer[1048l];
  // mode_xor
  signed int mode_xor;
  // mode_cache
  signed int mode_cache;
  // mode_reverse
  signed int mode_reverse;
};

struct keysequence_s
{
  // recorded_keypress
  struct keypress_s recorded_keypress[1024l];
  // record_steps
  unsigned int record_steps;
};

struct gkeys_s
{
  // recorded
  unsigned int recorded;
  // keysequence
  struct keysequence_s keysequence;
};

struct mstates_s
{
  // gkeys
  struct gkeys_s gkeys[18l];
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$38 __sigaction_handler;
  // sa_mask
  struct anonymous$34 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// canvas
// file g15macro.c line 62
struct g15canvas *canvas;
// config_fd
// file g15macro.c line 61
signed int config_fd = 0;
// config_mutex
// file g15macro.c line 68
union anonymous$44 config_mutex;
// current_recording
// file g15macro.c line 112
struct current_recording current_recording;
// debug
// file g15macro.c line 73
signed int debug = 0;
// display_timeout
// file g15macro.c line 71
signed int display_timeout = 500;
// dpy
// file g15macro.c line 64
static struct _XDisplay *dpy;
// g15screen_fd
// file g15macro.c line 60
signed int g15screen_fd;
// gkeycodes
// file g15macro.c line 118
const signed int gkeycodes[18l] = { 177, 152, 190, 208, 129, 130, 231, 209, 210, 136, 220, 143, 246, 251, 137, 138, 133, 183 };
// gkeydefaults
// file g15macro.c line 131
const signed long int gkeydefaults[54l] = { (const signed long int)0x1008FF44, (const signed long int)0x1008FF45, (const signed long int)0x1008FF46, (const signed long int)0x1008FF47, (const signed long int)0x1008FF48, (const signed long int)0x1008FF49, (const signed long int)0x1008FF4A, (const signed long int)0x1008FF4B, (const signed long int)0x1008FF4C, (const signed long int)0x1008FF4D, (const signed long int)0x1008FF4E, (const signed long int)0x1008FF4F, (const signed long int)0x1008FF60, (const signed long int)0x1008FF54, (const signed long int)0x1008FF7E, (const signed long int)0x1008FF89, (const signed long int)0x1008FF8E, (const signed long int)0x1008FF8F, (const signed long int)0xffca, (const signed long int)0xffcb, (const signed long int)0xffcc, (const signed long int)0xffcd, (const signed long int)0xffce, (const signed long int)0xffcf, (const signed long int)0xffd0, (const signed long int)0xffd1, (const signed long int)0xffd2, (const signed long int)0xffd3, (const signed long int)0xffd4, (const signed long int)0xffd5, (const signed long int)0xffd6, (const signed long int)0xffd7, (const signed long int)0xffd8, (const signed long int)0xffd9, (const signed long int)0xffda, (const signed long int)0xffdb, (const signed long int)0x01de, (const signed long int)0x01e0, (const signed long int)0x01e3, (const signed long int)0x01e5, (const signed long int)0x01e6, (const signed long int)0x01e8, (const signed long int)0x01ea, (const signed long int)0x01ec, (const signed long int)0x01ef, (const signed long int)0x01f0, (const signed long int)0x01f1, (const signed long int)0x01f2, (const signed long int)0x01f5, (const signed long int)0x01fb, (const signed long int)0x01f8, (const signed long int)0x01f9, (const signed long int)0x01b9, (const signed long int)0x01ff };
// gkeystring
// file g15macro.c line 116
const char *gkeystring[19l] = { "G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8", "G9", "G10", "G11", "G12", "G13", "G14", "G15", "G16", "G17", "G18", "Unknown" };
// have_xtest
// file g15macro.c line 72
signed int have_xtest = 0;
// leaving
// file g15macro.c line 70
signed int leaving = 0;
// mkey_state
// file g15macro.c line 78
static signed int mkey_state = 0;
// mled_state
// file g15macro.c line 77
static unsigned int mled_state = (unsigned int)1;
// mmedia_codes
// file g15macro.c line 120
const signed int mmedia_codes[6l] = { 164, 162, 144, 153, 174, 176 };
// mmedia_defaults
// file g15macro.c line 122
const signed long int mmedia_defaults[6l] = { (const signed long int)0x1008FF15, (const signed long int)0x1008FF14, (const signed long int)0x1008FF16, (const signed long int)0x1008FF17, (const signed long int)0x1008FF11, (const signed long int)0x1008FF13 };
// mstates
// file g15macro.c line 108
struct mstates_s *mstates[3l];
// rec_index
// file g15macro.c line 114
unsigned int rec_index = (unsigned int)0;
// recording
// file g15macro.c line 79
static signed int recording = 0;
// recstring
// file g15macro.c line 75
unsigned char recstring[1024l];
// root_win
// file g15macro.c line 65
static unsigned long int root_win;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// x11mutex
// file g15macro.c line 67
union anonymous$44 x11mutex;

// Lkeys_thread
// file g15macro.c line 532
void * Lkeys_thread()
{
  unsigned long int keystate = (unsigned long int)0;
  struct pollfd fds;
  char ver[5l];
  signed int foo = 0;
  const char *return_value_g15daemon_version$1;
  return_value_g15daemon_version$1=g15daemon_version();
  strncpy(ver, return_value_g15daemon_version$1, (unsigned long int)3);
  float g15v;
  sscanf(ver, "%f", &g15v);
  g15macro_log("Using version %.2f as keypress protocol\n", g15v);
  signed int fg_check;
  unsigned long int return_value_g15_send_cmd$3;
  while(leaving == 0)
  {
    if(g15v * 10.000000f <= 18.000000f)
      keystate=g15_send_cmd(g15screen_fd, (unsigned char)107, (unsigned char)foo);

    else
    {
      fds.fd = g15screen_fd;
      fds.events = (signed short int)0x001;
      fds.revents = (signed short int)0;
      keystate = (unsigned long int)0;
      signed int return_value_poll$2;
      return_value_poll$2=poll(&fds, (unsigned long int)1, 1000);
      if(return_value_poll$2 >= 1)
        read(g15screen_fd, (void *)&keystate, sizeof(unsigned long int) /*8ul*/ );

    }
    if(!(keystate == 0ul))
    {
      g15macro_log("Received Keystate == %lu\n", keystate);
      switch(keystate)
      {
        case (unsigned long int)67108864:
        {
          return_value_g15_send_cmd$3=g15_send_cmd(g15screen_fd, (unsigned char)118, (unsigned char)foo);
          fg_check = (signed int)return_value_g15_send_cmd$3;
          if(!(fg_check == 0))
            leaving = 1;

          break;
        }
        case (unsigned long int)2097152:
        {
          if(recording == 0)
          {
            unsigned long int return_value_g15_send_cmd$4;
            return_value_g15_send_cmd$4=g15_send_cmd(g15screen_fd, (unsigned char)118, (unsigned char)foo);
            if(return_value_g15_send_cmd$4 == 0ul)
            {
              usleep((unsigned int)1000);
              g15_send_cmd(g15screen_fd, (unsigned char)112, (unsigned char)foo);
              g15macro_log("Switching to LCD foreground\n");
            }

            usleep((unsigned int)1000);
            g15_send_cmd(g15screen_fd, (unsigned char)0x20, (unsigned char)((unsigned int)8 | mled_state));
            g15r_initCanvas(canvas);
            unsigned long int return_value_strlen$5;
            return_value_strlen$5=strlen("Recording");
            g15r_renderString(canvas, (unsigned char *)"Recording", 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$5 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)1);
            g15_send(g15screen_fd, (char *)canvas->buffer, (unsigned int)1048);
            g15macro_log("Recording Enabled\n");
            recording = 1;
            pthread_mutex_lock(&x11mutex);
            XGrabKeyboard(dpy, root_win, 1, 1, 1, (unsigned long int)0L);
            pthread_mutex_unlock(&x11mutex);
            memset((void *)&current_recording, 0, sizeof(struct current_recording) /*49152ul*/ );
          }

          else
            record_cancel();
          break;
        }
        case (unsigned long int)262144:
        {
          handle_mkey_switch((unsigned int)262144);
          break;
        }
        case (unsigned long int)524288:
        {
          handle_mkey_switch((unsigned int)524288);
          break;
        }
        case (unsigned long int)1048576:
        {
          handle_mkey_switch((unsigned int)1048576);
          break;
        }
        default:
          if(keystate >= 1ul && !(keystate >= 131073ul))
          {
            if(recording == 1)
              record_complete(keystate);

            else
              macro_playback(keystate);
          }

      }
      keystate = (unsigned long int)0;
    }

  }
  return (void *)0;
}

// calc_mkey_offset
// file g15macro.c line 326
signed int calc_mkey_offset()
{
  signed int mkey_offset = 0;
  switch(mkey_state)
  {
    case 0:
    {
      mkey_offset = 0;
      break;
    }
    case 1:
    {
      mkey_offset = 18;
      break;
    }
    case 2:
    {
      mkey_offset = 36;
      break;
    }
    default:
      mkey_offset = 0;
  }
  return mkey_offset;
}

// change_keymap
// file g15macro.c line 480
void change_keymap(signed int offset)
{
  signed int i = 0;
  signed int j = 0;
  pthread_mutex_lock(&x11mutex);
  i = offset;
  for( ; !(i >= 18 + offset); j = j + 1)
  {
    unsigned long int newmap[1l];
    newmap[(signed long int)0] = (unsigned long int)gkeydefaults[(signed long int)i];
    XChangeKeyboardMapping(dpy, gkeycodes[(signed long int)j], 1, newmap, 1);
    i = i + 1;
  }
  XFlush(dpy);
  pthread_mutex_unlock(&x11mutex);
}

// configure_mmediakeys
// file g15macro.c line 495
void configure_mmediakeys()
{
  unsigned long int newmap[1l];
  signed int i = 0;
  pthread_mutex_lock(&x11mutex);
  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    newmap[(signed long int)0] = (unsigned long int)mmedia_defaults[(signed long int)i];
    XChangeKeyboardMapping(dpy, mmedia_codes[(signed long int)i], 1, newmap, 1);
  }
  XFlush(dpy);
  pthread_mutex_unlock(&x11mutex);
}

// dump_config
// file g15macro.c line 403
void dump_config(struct _IO_FILE *configfile)
{
  signed int i = 0;
  signed int gkey = 0;
  unsigned long int key;
  pthread_mutex_lock(&config_mutex);
  signed int orig_mkeystate = mkey_state;
  mkey_state = 0;
  for( ; !(mkey_state >= 3); mkey_state = mkey_state + 1)
  {
    fprintf(configfile, "\n\nCodes for MKey %i\n", mkey_state + 1);
    gkey = 0;
    for( ; !(gkey >= 18); gkey = gkey + 1)
    {
      fprintf(configfile, "Key %s:", gkeystring[(signed long int)gkey]);
      if(mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.record_steps == 0u)
      {
        signed int mkey_offset = 0;
        mkey_offset=calc_mkey_offset();
        char *return_value_XKeysymToString$1;
        return_value_XKeysymToString$1=XKeysymToString((unsigned long int)gkeydefaults[(signed long int)(gkey + mkey_offset)]);
        fprintf(configfile, "\t%s\n", return_value_XKeysymToString$1);
      }

      else
      {
        fprintf(configfile, "\n");
        i = 0;
        for( ; !((unsigned int)i >= mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.record_steps); i = i + 1)
        {
          key=XKeycodeToKeysym(dpy, (unsigned char)mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].keycode, 0);
          char *return_value_XKeysymToString$2;
          return_value_XKeysymToString$2=XKeysymToString(key);
          fprintf(configfile, "\t%s %s %u\n", return_value_XKeysymToString$2, mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].pressed != 0 ? "Down" : "Up", (unsigned int)mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].modifiers);
        }
      }
    }
  }
  mkey_state = orig_mkeystate;
  pthread_mutex_unlock(&config_mutex);
}

// fake_keyevent
// file g15macro.c line 230
void fake_keyevent(signed int keycode, signed int keydown, unsigned long int modifiers)
{
  if(recording == 0 && !(have_xtest == 0))
  {
    pthread_mutex_lock(&x11mutex);
    XTestFakeKeyEvent(dpy, (unsigned int)keycode, keydown, (unsigned long int)0L);
    XSync(dpy, 0);
    pthread_mutex_unlock(&x11mutex);
    usleep((unsigned int)1500);
  }

  else
  {
    struct anonymous$4 event;
    unsigned long int current_focus;
    signed int dummy = 0;
    signed int key = 0;
    pthread_mutex_lock(&x11mutex);
    XGetInputFocus(dpy, &current_focus, &dummy);
    unsigned long int return_value_XKeycodeToKeysym$1;
    return_value_XKeycodeToKeysym$1=XKeycodeToKeysym(dpy, (unsigned char)keycode, 0);
    key = (signed int)return_value_XKeycodeToKeysym$1;
    if(!(keydown == 0))
      event.type = 2;

    else
      event.type = 3;
    event.keycode = (unsigned int)keycode;
    event.serial = (unsigned long int)0;
    event.send_event = 0;
    event.display = dpy;
    event.y_root = 0;
    event.x_root = event.y_root;
    event.y = event.x_root;
    event.x = event.y;
    event.time = (unsigned long int)0L;
    event.same_screen = 1;
    event.subwindow = (unsigned long int)0L;
    event.window = current_focus;
    event.root = root_win;
    event.state = (unsigned int)modifiers;
    XSendEvent(dpy, current_focus, 0, (signed long int)0, (union _XEvent *)&event);
    XSync(dpy, 0);
    pthread_mutex_unlock(&x11mutex);
  }
}

// g15daemon_gettime_ms
// file g15macro.c line 618
unsigned int g15daemon_gettime_ms()
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
}

// g15macro_log
// file g15macro.c line 217
static signed int g15macro_log(const char *fmt, ...)
{
  if(!(debug == 0))
  {
    printf("G15Macro: ");
    void **argp = (void **)&fmt;
    vprintf(fmt, argp);
    argp = ((void **)NULL);
  }

  return 0;
}

// g15macro_sighandler
// file g15macro.c line 754
void g15macro_sighandler(signed int sig)
{
  if(sig == 2 || sig == 3 || sig == 13 || sig == 15)
    leaving = 1;

}

// handle_mkey_switch
// file g15macro.c line 509
void handle_mkey_switch(unsigned int mkey)
{
  signed int mkey_offset = 0;
  switch(mkey)
  {
    case (unsigned int)262144:
    {
      mled_state = (unsigned int)1;
      mkey_state = 0;
      break;
    }
    case (unsigned int)524288:
    {
      mled_state = (unsigned int)2;
      mkey_state = 1;
      break;
    }
    case (unsigned int)1048576:
    {
      mled_state = (unsigned int)4;
      mkey_state = 2;
    }
  }
  mkey_offset=calc_mkey_offset();
  if(!(recording == 0))
    record_cancel();

  g15_send_cmd(g15screen_fd, (unsigned char)0x20, (unsigned char)mled_state);
  change_keymap(mkey_offset);
}

// helptext
// file g15macro.c line 765
void helptext()
{
  printf("G15Macro %s\n", (const void *)"1.0.3");
  printf("\n--user (-u) \"username\" run as user \"username\"\n");
  printf("--dump (-d) dump current configuration to stdout\n");
  printf("--debug (-g) print debugging information\n");
  printf("--version (-v) print version and exit\n");
  printf("--keysonly (-k) configure multimedia and extra keys then exit\n");
  printf("--help (-h) this help text\n\n");
}

// macro_playback
// file g15macro.c line 344
void macro_playback(unsigned long int keystate)
{
  signed int i = 0;
  unsigned long int key;
  signed int keyevent;
  signed int gkey;
  gkey=map_gkey((signed int)keystate);
  if(gkey >= 0)
  {
    if(mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.record_steps == 0u)
    {
      signed int mkey_offset = 0;
      mkey_offset=calc_mkey_offset();
      pthread_mutex_lock(&config_mutex); //added mutex
      pthread_mutex_lock(&x11mutex);
      unsigned char return_value_XKeysymToKeycode$1;
      return_value_XKeysymToKeycode$1=XKeysymToKeycode(dpy, (unsigned long int)gkeydefaults[(signed long int)(gkey + mkey_offset)]);
      keyevent = (signed int)return_value_XKeysymToKeycode$1;
      pthread_mutex_unlock(&x11mutex);
      pthread_mutex_unlock(&config_mutex); //added mutex
      fake_keyevent(keyevent, 1, (unsigned long int)0L);
      fake_keyevent(keyevent, 0, (unsigned long int)0L);
      char *return_value_XKeysymToString$2;
      return_value_XKeysymToString$2=XKeysymToString((unsigned long int)gkeydefaults[(signed long int)(gkey + mkey_offset)]);
      g15macro_log("Key: \t%s\n", return_value_XKeysymToString$2);
      goto __CPROVER_DUMP_L8;
    }

    g15macro_log("Macro Playback: for key %s\n", gkeystring[(signed long int)gkey]);
    pthread_mutex_lock(&config_mutex);
    i = 0;
    for( ; !((unsigned int)i >= mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.record_steps); i = i + 1)
    {
      fake_keyevent((signed int)mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].keycode, (signed int)mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].pressed, mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].modifiers);
      pthread_mutex_lock(&x11mutex);
      key=XKeycodeToKeysym(dpy, (unsigned char)mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].keycode, 0);
      pthread_mutex_unlock(&x11mutex);
      char *return_value_XKeysymToString$3;
      return_value_XKeysymToString$3=XKeysymToString(key);
      g15macro_log("\t%s %s\n", return_value_XKeysymToString$3, mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].pressed != 0 ? "Down" : "Up");
      if(key == 65507ul || key == 65508ul || key == 65511ul || key == 65512ul || key == 65513ul || key == 65514ul || key == 65515ul || key == 65516ul || key == 65517ul || key == 65518ul)
      {
        usleep((unsigned int)(mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress[(signed long int)i].time_ms * (unsigned long int)1000));
        goto __CPROVER_DUMP_L6;
      }

      usleep((unsigned int)1000);

    __CPROVER_DUMP_L6:
      ;
    }
    pthread_mutex_unlock(&config_mutex);
    g15macro_log("Macro Playback Complete\n");
  }


__CPROVER_DUMP_L8:
  ;
}

// main
// file g15macro.c line 775
signed int main(signed int argc, char **argv)
{
  unsigned long int Xkeys;
  unsigned long int Lkeys;
  struct sigaction new_action;
  signed int dummy = 0;
  signed int i = 0;
  unsigned char user[256l];
  struct passwd *username;
  char configpath[1024l];
  char splashpath[1024l];
  unsigned int dump = (unsigned int)0;
  unsigned int keysonly = (unsigned int)0;
  struct _IO_FILE *config;
  unsigned int convert = (unsigned int)0;
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  strncpy(configpath, return_value_getenv$1, (unsigned long int)1024);
  memset((void *)user, 0, (unsigned long int)256);
  i = 0;
  _Bool tmp_if_expr$4;
  signed int return_value_strncmp$3;
  _Bool tmp_if_expr$7;
  signed int return_value_strncmp$6;
  _Bool tmp_if_expr$10;
  signed int return_value_strncmp$9;
  _Bool tmp_if_expr$13;
  signed int return_value_strncmp$12;
  _Bool tmp_if_expr$16;
  signed int return_value_strncmp$15;
  _Bool tmp_if_expr$19;
  signed int return_value_strncmp$18;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(argv[(signed long int)i], "-u", (unsigned long int)2);
    if(return_value_strncmp$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_strncmp$3=strncmp(argv[(signed long int)i], "--user", (unsigned long int)6);
      tmp_if_expr$4 = !(return_value_strncmp$3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      if(!(argv[(signed long int)(1 + i)] == ((char *)NULL)))
      {
        strncpy((char *)user, argv[(signed long int)(i + 1)], (unsigned long int)128);
        i = i + 1;
      }

    }

    signed int return_value_strncmp$5;
    return_value_strncmp$5=strncmp(argv[(signed long int)i], "-d", (unsigned long int)2);
    if(return_value_strncmp$5 == 0)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strncmp$6=strncmp(argv[(signed long int)i], "--dump", (unsigned long int)6);
      tmp_if_expr$7 = !(return_value_strncmp$6 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      dump = (unsigned int)1;

    signed int return_value_strncmp$8;
    return_value_strncmp$8=strncmp(argv[(signed long int)i], "-h", (unsigned long int)2);
    if(return_value_strncmp$8 == 0)
      tmp_if_expr$10 = (_Bool)1;

    else
    {
      return_value_strncmp$9=strncmp(argv[(signed long int)i], "--help", (unsigned long int)6);
      tmp_if_expr$10 = !(return_value_strncmp$9 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$10)
    {
      helptext();
      exit(0);
    }

    signed int return_value_strncmp$11;
    return_value_strncmp$11=strncmp(argv[(signed long int)i], "-k", (unsigned long int)2);
    if(return_value_strncmp$11 == 0)
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      return_value_strncmp$12=strncmp(argv[(signed long int)i], "--keysonly", (unsigned long int)10);
      tmp_if_expr$13 = !(return_value_strncmp$12 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$13)
      keysonly = (unsigned int)1;

    signed int return_value_strncmp$14;
    return_value_strncmp$14=strncmp(argv[(signed long int)i], "-g", (unsigned long int)2);
    if(return_value_strncmp$14 == 0)
      tmp_if_expr$16 = (_Bool)1;

    else
    {
      return_value_strncmp$15=strncmp(argv[(signed long int)i], "--debug", (unsigned long int)7);
      tmp_if_expr$16 = !(return_value_strncmp$15 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$16)
    {
      printf("Debugging Enabled\n");
      debug = 1;
    }

    signed int return_value_strncmp$17;
    return_value_strncmp$17=strncmp(argv[(signed long int)i], "-v", (unsigned long int)2);
    if(return_value_strncmp$17 == 0)
      tmp_if_expr$19 = (_Bool)1;

    else
    {
      return_value_strncmp$18=strncmp(argv[(signed long int)i], "--version", (unsigned long int)9);
      tmp_if_expr$19 = !(return_value_strncmp$18 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$19)
    {
      printf("G15Macro version %s\n\n", (const void *)"1.0.3");
      exit(0);
    }

  }
  unsigned long int return_value_strlen$23;
  return_value_strlen$23=strlen((char *)user);
  char *return_value_getenv$21;
  if(!(return_value_strlen$23 == 0ul))
  {
    username=getpwnam((char *)user);
    if(username == ((struct passwd *)NULL))
    {
      unsigned int return_value_geteuid$20;
      return_value_geteuid$20=geteuid();
      username=getpwuid(return_value_geteuid$20);
      printf("BEWARE: running as effective uid %i\n", username->pw_uid);
    }

    else
    {
      signed int return_value_setuid$22;
      return_value_setuid$22=setuid(username->pw_uid);
      if(return_value_setuid$22 == 0)
      {
        setgid(username->pw_gid);
        strncpy(configpath, username->pw_dir, (unsigned long int)1024);
        printf("running as user %s\n", username->pw_name);
      }

      else
      {
        return_value_getenv$21=getenv("USER");
        printf("Unable to run as user \"%s\" - you dont have permissions for that.\nRunning as \"%s\"\n", username->pw_name, return_value_getenv$21);
      }
    }
  }

  do
  {
    char *return_value_getenv$24;
    return_value_getenv$24=getenv("DISPLAY");
    dpy=XOpenDisplay(return_value_getenv$24);
    if(dpy == ((struct _XDisplay *)NULL))
    {
      char *return_value_getenv$25;
      return_value_getenv$25=getenv("DISPLAY");
      printf("Unable to open display %s - retrying\n", return_value_getenv$25);
      sleep((unsigned int)2);
    }

  }
  while(dpy == ((struct _XDisplay *)NULL));
  XSetErrorHandler(myx_error_handler);
  configure_mmediakeys();
  change_keymap(0);
  XFlush(dpy);
  unsigned long int return_value_strlen$26;
  unsigned long int return_value_strlen$27;
  void *return_value_malloc$28;
  void *return_value_malloc$29;
  void *return_value_malloc$30;
  char *return_value_getenv$35;
  unsigned long int return_value_strlen$36;
  unsigned long int return_value_strlen$37;
  void *return_value_malloc$38;
  union pthread_attr_t attr;
  signed int thread_policy;
  unsigned long int return_value_g15_send_cmd$41;
  signed int return_value_usleep$39;
  if(!(keysonly >= 1u))
  {
    return_value_strlen$26=strlen(configpath);
    strncat(configpath, "/.g15macro", (unsigned long int)1024 - return_value_strlen$26);
    return_value_strlen$27=strlen(configpath);
    strncat(configpath, "/g15macro-data", (unsigned long int)1024 - return_value_strlen$27);
    config_fd=open(configpath, 00 | 04010000);
    return_value_malloc$28=malloc(sizeof(struct mstates_s) /*885024ul*/ );
    mstates[(signed long int)0] = (struct mstates_s *)return_value_malloc$28;
    return_value_malloc$29=malloc(sizeof(struct mstates_s) /*885024ul*/ );
    mstates[(signed long int)1] = (struct mstates_s *)return_value_malloc$29;
    return_value_malloc$30=malloc(sizeof(struct mstates_s) /*885024ul*/ );
    mstates[(signed long int)2] = (struct mstates_s *)return_value_malloc$30;
    if(config_fd >= 1)
    {
      printf("Converting old data\n");
      read(config_fd, (void *)mstates[(signed long int)0], sizeof(struct mstates_s) /*885024ul*/ );
      read(config_fd, (void *)mstates[(signed long int)1], sizeof(struct mstates_s) /*885024ul*/ );
      read(config_fd, (void *)mstates[(signed long int)2], sizeof(struct mstates_s) /*885024ul*/ );
      close(config_fd);
      char *return_value_getenv$31;
      return_value_getenv$31=getenv("HOME");
      strncpy(configpath, return_value_getenv$31, (unsigned long int)1024);
      unsigned long int return_value_strlen$32;
      return_value_strlen$32=strlen(configpath);
      strncat(configpath, "/.g15macro", (unsigned long int)1024 - return_value_strlen$32);
      char configbak[1024l];
      strcpy(configbak, configpath);
      unsigned long int return_value_strlen$33;
      return_value_strlen$33=strlen(configpath);
      strncat(configpath, "/g15macro-data", (unsigned long int)1024 - return_value_strlen$33);
      unsigned long int return_value_strlen$34;
      return_value_strlen$34=strlen(configpath);
      strncat(configbak, "/g15macro-data.old", (unsigned long int)1024 - return_value_strlen$34);
      rename(configpath, configbak);
      convert = (unsigned int)1;
    }

    else
    {
      memset((void *)mstates[(signed long int)0], 0, sizeof(struct mstates_s *[3l]) /*24ul*/ );
      memset((void *)mstates[(signed long int)1], 0, sizeof(struct mstates_s *[3l]) /*24ul*/ );
      memset((void *)mstates[(signed long int)2], 0, sizeof(struct mstates_s *[3l]) /*24ul*/ );
    }
    return_value_getenv$35=getenv("HOME");
    strncpy(configpath, return_value_getenv$35, (unsigned long int)1024);
    return_value_strlen$36=strlen(configpath);
    strncat(configpath, "/.g15macro", (unsigned long int)1024 - return_value_strlen$36);
    mkdir(configpath, (unsigned int)0777);
    return_value_strlen$37=strlen(configpath);
    strncat(configpath, "/g15macro.conf", (unsigned long int)1024 - return_value_strlen$37);
    config=fopen(configpath, "a");
    fclose(config);
    do
    {
      g15screen_fd=new_g15_screen(3);
      if(!(g15screen_fd >= 0))
      {
        printf("Sorry, cant connect to the G15daemon - retrying\n");
        sleep((unsigned int)2);
      }

    }
    while(!(g15screen_fd >= 0));
    if(convert == 0u)
      restore_config(configpath);

    if(!(dump == 0u))
    {
      printf("G15Macro Dumping Codes...");
      dump_config(stderr);
      exit(0);
    }

    g15_send_cmd(g15screen_fd, (unsigned char)0x10, (unsigned char)dummy);
    usleep((unsigned int)1000);
    g15_send_cmd(g15screen_fd, (unsigned char)0x20, (unsigned char)mled_state);
    usleep((unsigned int)1000);
    return_value_malloc$38=malloc(sizeof(struct g15canvas) /*1060ul*/ );
    canvas = (struct g15canvas *)return_value_malloc$38;
    if(!(canvas == ((struct g15canvas *)NULL)))
      g15r_initCanvas(canvas);

    else
    {
      printf("Unable to initialise the libg15render canvas\nExiting\n");
      return 1;
    }
    root_win = (&((struct anonymous$33 *)dpy)->screens[(signed long int)((struct anonymous$33 *)dpy)->default_screen])->root;
    if(root_win == 0ul)
    {
      printf("Cant find root window\n");
      return 1;
    }

    have_xtest = 0;
    printf("XTest disabled by configure option.  Using XSendEvent instead.\n");
    new_action.__sigaction_handler.sa_handler = g15macro_sighandler;
    new_action.sa_flags = 0;
    sigaction(2, &new_action, (struct sigaction *)(void *)0);
    sigaction(3, &new_action, (struct sigaction *)(void *)0);
    sigaction(15, &new_action, (struct sigaction *)(void *)0);
    sigaction(13, &new_action, (struct sigaction *)(void *)0);
    snprintf((char *)splashpath, (unsigned long int)1024, "%s/%s", (const void *)"/usr/share", (const void *)"g15macro/splash/g15macro.wbmp");
    g15r_loadWbmpSplash(canvas, splashpath);
    g15_send(g15screen_fd, (char *)canvas->buffer, (unsigned int)1048);
    g15_send_cmd(g15screen_fd, (unsigned char)110, (unsigned char)dummy);
    usleep((unsigned int)1000);
    pthread_mutex_init(&x11mutex, (const union anonymous$45 *)(void *)0);
    pthread_mutex_init(&config_mutex, (const union anonymous$45 *)(void *)0);
    pthread_attr_init(&attr);
    thread_policy = 1;
    pthread_attr_setschedpolicy(&attr, thread_policy);
    pthread_attr_setstacksize(&attr, (unsigned long int)(32 * 1024));
    pthread_create(&Xkeys, &attr, (void * (*)(void *))xevent_thread, (void *)0);
    pthread_create(&Lkeys, &attr, (void * (*)(void *))Lkeys_thread, (void *)0);
    while((_Bool)1)
    {
      if(!(display_timeout >= -1))
        display_timeout = -1;

      else
        display_timeout = display_timeout - 1;
      if(!(recording == 0))
        display_timeout = 500;

      if(!(display_timeout >= 1))
      {
        signed int fg_check;
        unsigned long int return_value_g15_send_cmd$40;
        return_value_g15_send_cmd$40=g15_send_cmd(g15screen_fd, (unsigned char)118, (unsigned char)dummy);
        fg_check = (signed int)return_value_g15_send_cmd$40;
        if(fg_check == 1)
          do
          {
            g15_send_cmd(g15screen_fd, (unsigned char)112, (unsigned char)dummy);
            return_value_g15_send_cmd$41=g15_send_cmd(g15screen_fd, (unsigned char)118, (unsigned char)dummy);
          }
          while(return_value_g15_send_cmd$41 == 1ul);

        usleep((unsigned int)(500 * 1000));
      }

      return_value_usleep$39=usleep((unsigned int)1000);
      if(!(leaving == 0) || !(return_value_usleep$39 == 0))
        break;

    }
    if(!(recording == 0))
    {
      recording = 0;
      XUngrabKeyboard(dpy, (unsigned long int)0L);
    }

    save_macros(configpath);
    g15_send_cmd(g15screen_fd, (unsigned char)0x20, (unsigned char)0);
    pthread_join(Xkeys, (void **)(void *)0);
    pthread_join(Lkeys, (void **)(void *)0);
    pthread_mutex_destroy(&x11mutex);
    pthread_mutex_destroy(&config_mutex);
    change_keymap(0);
    close(g15screen_fd);
  }


close_and_exit:
  ;
  return 0;
}

// map_gkey
// file g15macro.c line 191
signed int map_gkey(signed int keystate)
{
  signed int retval = -1;
  switch(keystate)
  {
    case 1:
    {
      retval = 0;
      break;
    }
    case 2:
    {
      retval = 1;
      break;
    }
    case 4:
    {
      retval = 2;
      break;
    }
    case 8:
    {
      retval = 3;
      break;
    }
    case 16:
    {
      retval = 4;
      break;
    }
    case 32:
    {
      retval = 5;
      break;
    }
    case 64:
    {
      retval = 6;
      break;
    }
    case 128:
    {
      retval = 7;
      break;
    }
    case 256:
    {
      retval = 8;
      break;
    }
    case 512:
    {
      retval = 9;
      break;
    }
    case 1024:
    {
      retval = 10;
      break;
    }
    case 2048:
    {
      retval = 11;
      break;
    }
    case 4096:
    {
      retval = 12;
      break;
    }
    case 8192:
    {
      retval = 13;
      break;
    }
    case 16384:
    {
      retval = 14;
      break;
    }
    case 32768:
    {
      retval = 15;
      break;
    }
    case 65536:
    {
      retval = 16;
      break;
    }
    case 131072:
      retval = 17;
  }
  return retval;
}

// myx_error_handler
// file g15macro.c line 750
signed int myx_error_handler(struct _XDisplay *dpy, struct anonymous$24 *err)
{
  return 0;
}

// record_cancel
// file g15macro.c line 281
void record_cancel()
{
  memset((void *)canvas->buffer, 0, (unsigned long int)1048);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen("Recording");
  g15r_renderString(canvas, (unsigned char *)"Recording", 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$1 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)4);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen("Canceled");
  g15r_renderString(canvas, (unsigned char *)"Canceled", 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$2 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)18);
  g15_send(g15screen_fd, (char *)canvas->buffer, (unsigned int)1048);
  record_cleanup();
}

// record_cleanup
// file g15macro.c line 270
void record_cleanup()
{
  g15_send_cmd(g15screen_fd, (unsigned char)0x20, (unsigned char)mled_state);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen((char *)recstring);
  memset((void *)recstring, 0, return_value_strlen$1);
  rec_index = (unsigned int)0;
  recording = 0;
  pthread_mutex_lock(&x11mutex);
  XUngrabKeyboard(dpy, (unsigned long int)0L);
  XFlush(dpy);
  pthread_mutex_unlock(&x11mutex);
}

// record_complete
// file g15macro.c line 289
void record_complete(unsigned long int keystate)
{
  char tmpstr[1024l];
  signed int gkey;
  gkey=map_gkey((signed int)keystate);
  pthread_mutex_lock(&config_mutex);
  if(rec_index == 0u)
    memset((void *)mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress, 0, sizeof(struct keysequence_s) /*49160ul*/ );

  else
    memcpy((void *)mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.recorded_keypress, (const void *)&current_recording, sizeof(struct keysequence_s) /*49160ul*/ );
  mstates[(signed long int)mkey_state]->gkeys[(signed long int)gkey].keysequence.record_steps = rec_index;
  pthread_mutex_unlock(&config_mutex);
  memset((void *)canvas->buffer, 0, (unsigned long int)1048);
  if(!(rec_index == 0u))
  {
    strcpy(tmpstr, "For key ");
    signed int return_value_map_gkey$1;
    return_value_map_gkey$1=map_gkey((signed int)keystate);
    strcat(tmpstr, gkeystring[(signed long int)return_value_map_gkey$1]);
    g15macro_log("Recording Complete %s\n", (const void *)tmpstr);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen("Recording");
    g15r_renderString(canvas, (unsigned char *)"Recording", 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$2 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)4);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen("Complete");
    g15r_renderString(canvas, (unsigned char *)"Complete", 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$3 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)18);
  }

  else
  {
    strcpy(tmpstr, "From Key ");
    signed int return_value_map_gkey$4;
    return_value_map_gkey$4=map_gkey((signed int)keystate);
    strcat(tmpstr, gkeystring[(signed long int)return_value_map_gkey$4]);
    g15macro_log("Macro deleted %s\n", (const void *)tmpstr);
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen("Macro");
    g15r_renderString(canvas, (unsigned char *)"Macro", 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$5 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)4);
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen("Deleted");
    g15r_renderString(canvas, (unsigned char *)"Deleted", 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$6 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)18);
  }
  unsigned long int return_value_strlen$7;
  return_value_strlen$7=strlen(tmpstr);
  g15r_renderString(canvas, (unsigned char *)tmpstr, 0, 2, (unsigned int)((unsigned long int)80 - (return_value_strlen$7 / (unsigned long int)2) * (unsigned long int)8), (unsigned int)32);
  g15_send(g15screen_fd, (char *)canvas->buffer, (unsigned int)1048);
  record_cleanup();
}

// restore_config
// file g15macro.c line 440
void restore_config(char *filename)
{
  struct _IO_FILE *f;
  char tmpstring[1024l];
  unsigned int key = (unsigned int)0;
  unsigned int mkey = (unsigned int)0;
  unsigned int i = (unsigned int)0;
  unsigned int keycode;
  f=fopen(filename, "r");
  printf("restoring codes\n");
  pthread_mutex_lock(&config_mutex);
  signed int return_value_feof$1;
  do
  {
    memset((void *)tmpstring, 0, (unsigned long int)1024);
    fgets(tmpstring, 1024, f);
    if((signed int)tmpstring[0l] == 67)
    {
      sscanf(tmpstring, "Codes for MKey %i\n", &mkey);
      mkey = mkey - 1u;
      i = (unsigned int)0;
    }

    if((signed int)tmpstring[0l] == 75)
    {
      sscanf(tmpstring, "Key G%i:", &key);
      key = key - 1u;
      i = (unsigned int)0;
    }

    if((signed int)tmpstring[0l] == 9)
    {
      char codestr[64l];
      char pressed[20l];
      unsigned int modifiers = (unsigned int)0;
      sscanf(tmpstring, "\t%s %s %i\n", (char *)&codestr, (char *)&pressed, &modifiers);
      unsigned long int return_value_XStringToKeysym$2;
      return_value_XStringToKeysym$2=XStringToKeysym(codestr);
      unsigned char return_value_XKeysymToKeycode$3;
      return_value_XKeysymToKeycode$3=XKeysymToKeycode(dpy, return_value_XStringToKeysym$2);
      keycode = (unsigned int)return_value_XKeysymToKeycode$3;
      mstates[(signed long int)mkey]->gkeys[(signed long int)key].keysequence.recorded_keypress[(signed long int)i].keycode = (unsigned long int)keycode;
      signed int return_value_strncmp$4;
      return_value_strncmp$4=strncmp(pressed, "Up", (unsigned long int)2);
      mstates[(signed long int)mkey]->gkeys[(signed long int)key].keysequence.recorded_keypress[(signed long int)i].pressed = (unsigned char)(return_value_strncmp$4 != 0 ? 1 : 0);
      mstates[(signed long int)mkey]->gkeys[(signed long int)key].keysequence.recorded_keypress[(signed long int)i].modifiers = (unsigned long int)modifiers;
      i = i + 1u;
      mstates[(signed long int)mkey]->gkeys[(signed long int)key].keysequence.record_steps = i;
    }

    return_value_feof$1=feof(f);
  }
  while(return_value_feof$1 == 0);
  pthread_mutex_unlock(&config_mutex);
  fclose(f);
}

// save_macros
// file g15macro.c line 431
void save_macros(char *filename)
{
  struct _IO_FILE *configfile;
  configfile=fopen(filename, "w");
  dump_config(configfile);
  fclose(configfile);
}

// xevent_thread
// file g15macro.c line 700
static void * xevent_thread()
{
  union _XEvent event;
  signed long int event_mask = 1L << 0 | 1L << 1 | 1L << 21 | 1L << 19;
  signed int retval = 0;
  pthread_mutex_lock(&x11mutex);
  pthread_mutex_lock(&config_mutex); //added mutex
  XSelectInput(dpy, root_win, event_mask);
  pthread_mutex_unlock(&config_mutex); //added mutex
  pthread_mutex_unlock(&x11mutex);
  while(leaving == 0)
  {
    pthread_mutex_lock(&x11mutex);
    memset((void *)&event, 0, sizeof(union _XEvent) /*192ul*/ );
    retval=XCheckMaskEvent(dpy, event_mask, &event);
    pthread_mutex_unlock(&x11mutex);
    if(retval == 1)
      switch(event.type)
      {
        case 2:
        {
          xkey_handler(&event);
          break;
        }
        case 3:
        {
          xkey_handler(&event);
          break;
        }
        case 9:

        case 10:

        case 7:

        case 8:

        case 19:

        case 18:

        case 20:

        case 22:

        case 16:

        case 17:
          break;
        case 21:
        {
          if(!(recording == 0))
          {
            pthread_mutex_lock(&x11mutex);
            XGrabKeyboard(dpy, root_win, 1, 1, 1, (unsigned long int)0L);
            XFlush(dpy);
            pthread_mutex_unlock(&x11mutex);
          }

          break;
        }
        default:
          g15macro_log("Unhandled event (%i) received\n", event.type);
      }

    else
      usleep((unsigned int)25000);
  }
  return (void *)0;
}

// xkey_handler
// file g15macro.c line 624
void xkey_handler(union _XEvent *event)
{
  unsigned char keytext[256l];
  unsigned int keycode = event->xkey.keycode;
  signed int press = 1;
  if(event->type == 3)
  {
    pthread_mutex_lock(&x11mutex);
    unsigned long int key;
    key=XKeycodeToKeysym(dpy, (unsigned char)keycode, 0);
    pthread_mutex_unlock(&x11mutex);
    press = 0;
  }

  unsigned int return_value_g15daemon_gettime_ms$1;
  static unsigned long int lasttime;
  if(!(recording == 0))
  {
    current_recording.recorded_keypress[(signed long int)rec_index].keycode = (unsigned long int)keycode;
    current_recording.recorded_keypress[(signed long int)rec_index].pressed = (unsigned char)press;
    current_recording.recorded_keypress[(signed long int)rec_index].modifiers = (unsigned long int)event->xkey.state;
    if(rec_index == 0u)
      current_recording.recorded_keypress[(signed long int)rec_index].time_ms = (unsigned long int)0;

    else
    {
      return_value_g15daemon_gettime_ms$1=g15daemon_gettime_ms();
      current_recording.recorded_keypress[(signed long int)rec_index].time_ms = (unsigned long int)return_value_g15daemon_gettime_ms$1 - lasttime;
    }
    if(!(rec_index >= 1024u))
    {
      rec_index = rec_index + 1u;
      pthread_mutex_lock(&x11mutex);
      XUngrabKeyboard(dpy, (unsigned long int)0L);
      pthread_mutex_unlock(&x11mutex);
      fake_keyevent((signed int)keycode, press, (unsigned long int)event->xkey.state);
      pthread_mutex_lock(&x11mutex);
      XGrabKeyboard(dpy, root_win, 1, 1, 1, (unsigned long int)0L);
      XFlush(dpy);
      unsigned long int return_value_XKeycodeToKeysym$2;
      return_value_XKeycodeToKeysym$2=XKeycodeToKeysym(dpy, (unsigned char)keycode, 0);
      char *return_value_XKeysymToString$3;
      return_value_XKeysymToString$3=XKeysymToString(return_value_XKeycodeToKeysym$2);
      strcpy((char *)keytext, return_value_XKeysymToString$3);
      pthread_mutex_unlock(&x11mutex);
      signed int return_value_strcmp$4;
      return_value_strcmp$4=strcmp((char *)keytext, "space");
      if(return_value_strcmp$4 == 0)
        strcpy((char *)keytext, " ");

      signed int return_value_strcmp$5;
      return_value_strcmp$5=strcmp((char *)keytext, "period");
      if(return_value_strcmp$5 == 0)
        strcpy((char *)keytext, ".");

      if(press == 1)
      {
        strcat((char *)recstring, (char *)keytext);
        g15macro_log("Adding %s to Macro\n", (const void *)keytext);
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen((char *)recstring);
        g15r_renderString(canvas, (unsigned char *)recstring, 0, 1, (unsigned int)((unsigned long int)80 - (return_value_strlen$6 / (unsigned long int)2) * (unsigned long int)5), (unsigned int)22);
        g15_send(g15screen_fd, (char *)canvas->buffer, (unsigned int)1048);
      }

    }

    else
    {
      pthread_mutex_lock(&x11mutex);
      XUngrabKeyboard(dpy, (unsigned long int)0L);
      pthread_mutex_unlock(&x11mutex);
      recording = 0;
      rec_index = (unsigned int)0;
    }
  }

  else
    rec_index = (unsigned int)0;
  unsigned int return_value_g15daemon_gettime_ms$7;
  return_value_g15daemon_gettime_ms$7=g15daemon_gettime_ms();
  lasttime = (unsigned long int)return_value_g15daemon_gettime_ms$7;
}

