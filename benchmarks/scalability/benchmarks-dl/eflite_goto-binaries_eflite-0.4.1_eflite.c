// #anon_enum$CST_AUDIO_LINEAR16=0$CST_AUDIO_LINEAR8=1$CST_AUDIO_MULAW=2
// file /usr/include/flite/cst_audio.h line 56
enum anonymous$2 { CST_AUDIO_LINEAR16=0, CST_AUDIO_LINEAR8=1, CST_AUDIO_MULAW=2 };

// #anon_enum$L_SPEAK_PUNCTUATION=0$L_MAX=1
// file language.h line 18
enum anonymous$14 { L_SPEAK_PUNCTUATION=0, L_MAX=1 };

// #anon_enum$NONE=0$SPEECH=1$TONE=2
// file fs.c line 141
enum anonymous$12 { NONE=0, SPEECH=1, TONE=2 };

// #anon_enum$S_SPEED=0$S_PITCH=1$S_VOLUME=2$S_MAX=3
// file synthesizer.h line 36
enum anonymous$9 { S_SPEED=0, S_PITCH=1, S_VOLUME=2, S_MAX=3 };

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$16;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$7;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 534
struct anonymous$6;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 536
struct anonymous$5;

// tag-#anon#ST[EN#anon_enum$NONE=0$SPEECH=1$TONE=2#{U32}$U32$'type'||U32'$pad0'||*{V}$V$'data'|]
// file fs.c line 143
struct anonymous$13;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 140
struct anonymous$4;

// tag-#anon#ST[S32'lang'||U32'$pad0'||*{S8}$S8$'name'|]
// file synthesizer.h line 29
struct anonymous$8;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 129
union anonymous$3;

// tag-#anon#UN[F32'fval'||S32'ival'||*{V}$V$'vval'|]
// file /usr/include/flite/cst_val.h line 70
union anonymous$10;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 138
union anonymous$1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$0;

// tag-#anon#UN[SYM#tag-cst_val_cons_struct#'cc'||SYM#tag-cst_val_atom_struct#'a'|]
// file /usr/include/flite/cst_val.h line 79
union anonymous$11;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$15;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 753
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-client
// file es.h line 5
struct client;

// tag-cst_audiodev_struct
// file /usr/include/flite/cst_audio.h line 64
struct cst_audiodev_struct;

// tag-cst_features_struct
// file /usr/include/flite/cst_features.h line 53
struct cst_features_struct;

// tag-cst_featvalpair_struct
// file /usr/include/flite/cst_features.h line 47
struct cst_featvalpair_struct;

// tag-cst_rateconv_struct
// file /usr/include/flite/cst_wave.h line 104
struct cst_rateconv_struct;

// tag-cst_utterance_struct
// file /usr/include/flite/cst_item.h line 48
struct cst_utterance_struct;

// tag-cst_val_atom_struct
// file /usr/include/flite/cst_val.h line 62
struct cst_val_atom_struct;

// tag-cst_val_cons_struct
// file /usr/include/flite/cst_val.h line 57
struct cst_val_cons_struct;

// tag-cst_val_struct
// file /usr/include/flite/cst_val.h line 58
struct cst_val_struct;

// tag-cst_voice_struct
// file /usr/include/flite/cst_voice.h line 49
struct cst_voice_struct;

// tag-cst_wave_struct
// file /usr/include/flite/cst_wave.h line 50
struct cst_wave_struct;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lang_state
// file language.h line 23
struct lang_state;

// tag-lang_struct
// file language.h line 25
struct lang_struct;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-setting
// file es.h line 13
struct setting;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-synth_state
// file synthesizer.h line 44
struct synth_state;

// tag-synth_struct
// file synthesizer.h line 46
struct synth_struct;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 399
extern signed int __fxstat(signed int, signed int, struct stat *);
// __pthread_register_cancel
// file /usr/include/pthread.h line 691
extern void __pthread_register_cancel(struct anonymous$6 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 703
extern void __pthread_unregister_cancel(struct anonymous$6 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 744
extern void __pthread_unwind_next(struct anonymous$6 *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __sigsetjmp
// file /usr/include/pthread.h line 754
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 401
extern signed int __xstat(signed int, const char *, struct stat *);
// ac_destroy
// file fs.c line 489
static void ac_destroy(struct anonymous$13 *ac);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous, unsigned int *);
// add_command
// file fs.c line 772
static void add_command(struct synth_struct *s, signed int id, unsigned char *buffer);
// add_tone_command
// file fs.c line 822
void add_tone_command(struct synth_struct *s, signed int freq, signed int dur, signed int vol);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1);
// atoi$link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link2(const char *__nptr$link2);
// audio_close
// file /usr/include/flite/cst_audio.h line 75
signed int audio_close(struct cst_audiodev_struct *);
// audio_drain
// file /usr/include/flite/cst_audio.h line 78
signed int audio_drain(struct cst_audiodev_struct *);
// audio_flush
// file /usr/include/flite/cst_audio.h line 77
signed int audio_flush(struct cst_audiodev_struct *);
// audio_open
// file /usr/include/flite/cst_audio.h line 74
struct cst_audiodev_struct * audio_open(signed int, signed int, enum anonymous$2);
// audio_write
// file /usr/include/flite/cst_audio.h line 76
signed int audio_write(struct cst_audiodev_struct *, void *, signed int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 284
extern signed int chmod(const char *, unsigned int);
// client_init
// file es.c line 459
void client_init(struct client *client);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_audiodev
// file fs.c line 499
static void close_audiodev();
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// cst_free
// file /usr/include/flite/cst_alloc.h line 80
void cst_free(void *);
// cst_safe_alloc
// file /usr/include/flite/cst_alloc.h line 51
void * cst_safe_alloc(signed int);
// cst_wave_free
// file fs.c line 479
static void cst_wave_free(struct cst_wave_struct *w);
// cst_wave_rescale
// file /usr/include/flite/cst_wave.h line 101
void cst_wave_rescale(struct cst_wave_struct *, signed int);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// determine_playlen
// file fs.c line 508
static inline void determine_playlen(signed int speed, struct cst_wave_struct *wptr, signed int type, signed int *pl, signed int *s);
// do_tone
// file es.h line 43
void do_tone(struct synth_struct *s, signed int freq, signed int dur, signed int vol, signed int flags);
// es_addtext
// file es.c line 392
void es_addtext(struct client *client, char *buf);
// es_synthesize
// file es.c line 386
void es_synthesize();
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feat_set_float
// file /usr/include/flite/cst_features.h line 76
void feat_set_float(struct cst_features_struct *, const char *, float);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// finish
// file es.c line 298
void finish(signed int sig);
// flite_init
// file /usr/include/flite/flite.h line 71
signed int flite_init();
// flite_text_to_wave
// file /usr/include/flite/flite.h line 90
struct cst_wave_struct * flite_text_to_wave(const char *, struct cst_voice_struct *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 467
static inline signed int fstat(signed int __fd, struct stat *__statbuf);
// generate_tone
// file es.h line 45
struct cst_wave_struct * generate_tone(signed int freq, signed int dur, signed int vol);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// handle
// file es.c line 625
signed int handle(struct client *client);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// is_dir
// file es.c line 745
signed int is_dir(char *name);
// language_open
// file fs.c line 1033
struct lang_struct * language_open(void *context, char * (*lookup)(void *, const char *));
// language_open::lookup$object
// 
char * lookup$object(void *, const char *);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lookup_int
// file es.c line 377
signed int lookup_int(char *name, signed int defval);
// lookup_string
// file es.c line 356
char * lookup_string(void *context, const char *name);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse
// file es.c line 494
void parse(struct client *client, char *buf);
// passthrough
// file es.c line 693
void passthrough(char *infile, signed int outfd);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// play
// file fs.c line 528
static void * play(void *s);
// play::1::1::1::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// play::1::1::2::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// play::1::1::5::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// play::1::1::6::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_init
// file /usr/include/pthread.h line 298
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_cancel
// file /usr/include/pthread.h line 524
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 984
extern signed int pthread_cond_destroy(union anonymous$1 *);
// pthread_cond_init
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_init(union anonymous$1 *, const union anonymous$3 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 988
extern signed int pthread_cond_signal(union anonymous$1 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_wait(union anonymous$1 *, union anonymous$0 *);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 253
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 261
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_init(union anonymous$0 *, const union anonymous$3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous$0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous$0 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 817
extern signed int pthread_mutexattr_init(union anonymous$3 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 517
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 521
extern signed int pthread_setcanceltype(signed int, signed int *);
// pthread_testcancel
// file /usr/include/pthread.h line 529
extern void pthread_testcancel(void);
// punct_add
// file es.c line 465
static signed int punct_add(struct client *client, const char *str);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// register_cmu_us_kal
// file fs.c line 186
extern struct cst_voice_struct * register_cmu_us_kal(const char *);
// remove_dectalk_codes
// file es.c line 478
static void remove_dectalk_codes(char *buf);
// reset_text_buffer
// file fs.c line 211
static inline void reset_text_buffer(void);
// reset_wave_buffer
// file fs.c line 218
static inline void reset_wave_buffer(void);
// s_clear
// file fs.c line 873
static signed int s_clear(struct synth_struct *s);
// s_close
// file fs.c line 417
static signed int s_close(struct synth_struct *s);
// s_flush
// file fs.c line 836
static signed int s_flush(struct synth_struct *s);
// s_get_param
// file fs.c line 971
static signed int s_get_param(struct synth_struct *s, enum anonymous$9 par, signed int *value);
// s_set_param
// file fs.c line 986
static signed int s_set_param(struct synth_struct *s, enum anonymous$9 par, signed int value);
// s_synth
// file fs.c line 816
static signed int s_synth(struct synth_struct *s, unsigned char *buffer);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$16 *, struct anonymous$16 *, struct anonymous$16 *, struct timeval *);
// setting_add
// file es.c line 309
void setting_add(char *name, char *value);
// settings_init
// file es.c line 325
signed int settings_init();
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sockconnect
// file es.h line 37
signed int sockconnect(const char *name);
// sockconnect_tcp
// file soccon.c line 36
static signed int sockconnect_tcp(const char *port);
// sockconnect_unix
// file soccon.c line 14
signed int sockconnect_unix(const char *fname);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sockopen
// file es.h line 40
signed int sockopen(const char *name);
// sockopen_tcp
// file sockopen.c line 40
signed int sockopen_tcp(const char *name);
// sockopen_unix
// file sockopen.c line 15
signed int sockopen_unix(const char *fname);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcasecmp
// file /usr/include/string.h line 534
extern signed int strcasecmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 413
extern char * strerror(signed int);
// string_is_complete
// file es.c line 612
static signed int string_is_complete(char *buf, signed int size);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 538
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 342
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// synth_open
// file fs.c line 347
struct synth_struct * synth_open(void *context, char * (*lookup)(void *, const char *));
// synth_open::lookup$object
// 
char * lookup$object(void *, const char *);
// synthesize
// file fs.c line 654
static void * synthesize(void *s);
// terror
// file es.c line 684
void terror(const char *s);
// text_thread_testcancel
// file fs.c line 643
static inline void text_thread_testcancel();
// text_unlock
// file fs.c line 307
static void text_unlock(void *function_name);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// verify_language
// file fs.c line 463
static void verify_language(struct synth_struct *s);
// wave_unlock
// file fs.c line 286
static void wave_unlock(void *function_name);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$16
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$7
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$5
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$6
{
  // __cancel_jmp_buf
  struct anonymous$5 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$13
{
  // type
  enum anonymous$12 type;
  // data
  void *data;
};

struct anonymous$4
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$8
{
  // lang
  signed int lang;
  // name
  char *name;
};

union anonymous$3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$10
{
  // fval
  float fval;
  // ival
  signed int ival;
  // vval
  void *vval;
};

union anonymous$1
{
  // __data
  struct anonymous$4 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct cst_val_cons_struct
{
  // car
  struct cst_val_struct *car;
  // cdr
  struct cst_val_struct *cdr;
};

struct cst_val_atom_struct
{
  // type
  signed short int type;
  // ref_count
  signed short int ref_count;
  // v
  union anonymous$10 v;
};

union anonymous$11
{
  // cc
  struct cst_val_cons_struct cc;
  // a
  struct cst_val_atom_struct a;
};

union anonymous$15
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$7 __saved_mask;
};

struct client
{
  // fd
  signed int fd;
  // param
  signed int param[3l];
  // punct
  char punct[256l];
};

struct cst_audiodev_struct
{
  // sps
  signed int sps;
  // real_sps
  signed int real_sps;
  // channels
  signed int channels;
  // real_channels
  signed int real_channels;
  // fmt
  enum anonymous$2 fmt;
  // real_fmt
  enum anonymous$2 real_fmt;
  // byteswap
  signed int byteswap;
  // rateconv
  struct cst_rateconv_struct *rateconv;
  // platform_data
  void *platform_data;
};

struct cst_features_struct
{
  // head
  struct cst_featvalpair_struct *head;
  // ctx
  void *ctx;
};

struct cst_featvalpair_struct
{
  // name
  const char *name;
  // val
  struct cst_val_struct *val;
  // next
  struct cst_featvalpair_struct *next;
};

struct cst_rateconv_struct
{
  // channels
  signed int channels;
  // up
  signed int up;
  // down
  signed int down;
  // gain
  double gain;
  // lag
  signed int lag;
  // sin
  signed int *sin;
  // sout
  signed int *sout;
  // coep
  signed int *coep;
  // insize
  signed int insize;
  // outsize
  signed int outsize;
  // incount
  signed int incount;
  // len
  signed int len;
  // fsin
  double fsin;
  // fgk
  double fgk;
  // fgg
  double fgg;
  // inbaseidx
  signed int inbaseidx;
  // inoffset
  signed int inoffset;
  // cycctr
  signed int cycctr;
  // outidx
  signed int outidx;
};

struct cst_utterance_struct
{
  // features
  struct cst_features_struct *features;
  // ffunctions
  struct cst_features_struct *ffunctions;
  // relations
  struct cst_features_struct *relations;
  // ctx
  void *ctx;
};

struct cst_val_struct
{
  // c
  union anonymous$11 c;
};

struct cst_voice_struct
{
  // name
  const char *name;
  // features
  struct cst_features_struct *features;
  // ffunctions
  struct cst_features_struct *ffunctions;
  // utt_init
  struct cst_utterance_struct * (*utt_init)(struct cst_utterance_struct *, struct cst_voice_struct *);
};

struct cst_wave_struct
{
  // type
  const char *type;
  // sample_rate
  signed int sample_rate;
  // num_samples
  signed int num_samples;
  // num_channels
  signed int num_channels;
  // samples
  signed short int *samples;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lang_struct
{
  // state
  struct lang_state *state;
  // lang
  struct anonymous$8 *lang;
  // synth
  struct synth_struct *synth;
  // s_buf
  char *s_buf;
  // s_buf_used
  signed int s_buf_used;
  // s_buf_size
  signed int s_buf_size;
  // close
  signed int (*close)(struct lang_struct *);
  // change_synth
  signed int (*change_synth)(struct lang_struct *, struct synth_struct *);
  // speak_string
  signed int (*speak_string)(struct lang_struct *, unsigned char *);
  // get_param
  signed int (*get_param)(struct lang_struct *, enum anonymous$14, signed int *);
  // set_param
  signed int (*set_param)(struct lang_struct *, enum anonymous$14, signed int);
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct setting
{
  // name
  char *name;
  // value
  char *value;
  // next
  struct setting *next;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct synth_state
{
  // param
  signed int param[3l];
  // initialized
  signed int initialized;
};

struct synth_struct
{
  // state
  struct synth_state *state;
  // lang
  struct anonymous$8 *lang;
  // name
  char *name;
  // lib_handle
  void *lib_handle;
  // close
  signed int (*close)(struct synth_struct *);
  // synth
  signed int (*synth)(struct synth_struct *, unsigned char *);
  // flush
  signed int (*flush)(struct synth_struct *);
  // clear
  signed int (*clear)(struct synth_struct *);
  // index_set
  signed int (*index_set)(struct synth_struct *);
  // index_wait
  signed int (*index_wait)(struct synth_struct *, signed int, signed int);
  // get_param
  signed int (*get_param)(struct synth_struct *, enum anonymous$9, signed int *);
  // set_param
  signed int (*set_param)(struct synth_struct *, enum anonymous$9, signed int);
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// ac
// file fs.c line 163
static struct anonymous$13 *ac;
// ac_head
// file fs.c line 165
static signed int ac_head;
// ac_size
// file fs.c line 164
static signed int ac_size;
// ac_synthpos
// file fs.c line 166
static signed int ac_synthpos;
// ac_tail
// file fs.c line 165
static signed int ac_tail;
// ascii
// file es.c line 24
char *ascii[256l] = { "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "bang", "quote", "number", "dollar", "percent", "and", "apostrophe", "left paren", "right paren", "star", "plus", "comma", "dash", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less than", "equals", "greater than", "question", "at", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "left bracket", "backslash", "right bracket", "caret", "underline", "accent", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "left brace", "bar", "right brace", "tilda", "cap delta", "cap cedila", "u de arisis", "e accent a u", "a circumflex", "a de arisis", "accented a", "a with small circle accent", "cedila", "e circumflex", "e de arisis", "accented e", "i de arisis", "circumflex", "accented i", "cap a de arisis", "cap a with small circle accent", "cap e accent a u", "small a e", "cap a e", "o circumflex", "o de arisis", "accented o", "u circumflex", "accented u", "y de arisis", "cap o de arisis", "cap u de arisis", "cents sign", "pounds", "yen", "p sub t", "fancy f", "a accent a u", "i accent a u", "o accent a u", "u accent a u", "tilded n", "tilded cap n", "bar under a", "bar under o", "up side down question mark", "short horizontal with short left down", 
    "short horizontal with short right down", 
    "e half", "one quarter", "up side down exclamation point", "much less than", "much greater than", "dark shading", "medium shading", "light shading", "vertical bar", "vertical with centered left joint", "vertical with centered double left joint", 
    "double vertical with centered left joint", 
    "upper right corner with double vertical", 
    "upper right corner with double horizontal", 
    "double vertical with centered double left joint", 
    "double vertical", "double upper right corner", "double lower right corner", "lower right corner with double vertical", 
    "lower right corner with double horizontal", 
    "upper right corner", "lower left corner", "horizontal with centered up joint", "horizontal with centered down joint", "vertical with centered right joint", "horizontal", "cross bars", "vertical bar with centered double right joint", 
    "double vertical with centered right joint", 
    "double lower left corner", "double upper left corner", "double horizontal with centered double up joint", 
    "double horizontal with centered double down joint", 
    "double vertical with centered double right joint", 
    "double horizontal", "double cross form", "double horizontal with centered up joint", 
    "horizontal with centered up joint", "double horizontal with centered down joint", 
    "horizontal with centered double down joint", 
    "lower left corner with double vertical", 
    "lower left corner with double horizontal", 
    "per left corner with double horizontal", 
    "upper left corner with double vertical", 
    "cross with double vertical", "cross with double horizontal", "lower right corner", "upper left corner", "filled square", "filled lower half", "filled left half", "filled right half", "filled upper half", "alpha", "beta", "cap gamma", "pi", "cap sigma", "sigma", "mu", "tau", "cap phi", "theta", "cap omega", "delta", "infinity", "phi", "epsilon", "intersection", "is identical to", "plus minus", "greater than or equal", "less than or equal", "upper part of integral", "lower part of integral", "divide", "approximately equal", "degrees", "small dot", "tiny dot", "square root", "exponent n", "exponent 2", "filled square", "ascii 255" };
// audiodev
// file fs.c line 182
struct cst_audiodev_struct *audiodev = (struct cst_audiodev_struct *)(void *)0;
// buf
// file es.c line 287
static char *buf = (char *)(void *)0;
// bufsize
// file es.c line 288
static signed int bufsize = 200;
// client
// file es.c line 289
struct client *client = (struct client *)(void *)0;
// current_language
// file fs.c line 137
static signed int current_language = -1;
// debug_fp
// file fs.c line 139
static struct _IO_FILE *debug_fp = (struct _IO_FILE *)(void *)0;
// default_param
// file es.c line 284
static signed int default_param[3l];
// lang
// file fs.c line 1018
struct lang_struct lang;
// languages
// file fs.c line 1012
struct anonymous$8 languages[3l] = { { .lang=0, .name="British English" }, { .lang=1, .name="German" }, { .lang=2, .name="no language" } };
// lang
// file fs.c line 1018
struct lang_struct lang = { .state=(struct lang_state *)(void *)0, .lang=&languages[(signed long int)0],
    .synth=(struct synth_struct *)(void *)0,
    .s_buf=(char *)(void *)0,
    .s_buf_used=0, .s_buf_size=0,
    .close=(signed int (*)(struct lang_struct *))(void *)0, .change_synth=(signed int (*)(struct lang_struct *, struct synth_struct *))(void *)0,
    .speak_string=(signed int (*)(struct lang_struct *, unsigned char *))(void *)0,
    .get_param=(signed int (*)(struct lang_struct *, enum anonymous$14, signed int *))(void *)0,
    .set_param=(signed int (*)(struct lang_struct *, enum anonymous$14, signed int))(void *)0 };
// lang$link1
// file es.c line 283
static struct lang_struct *lang$link1;
// longopts
// file es.c line 753
static struct option longopts[2l] = { { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 }, 
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// mt_attr
// file fs.c line 184
static union anonymous$3 mt_attr;
// numclients
// file es.c line 285
static signed int numclients = 0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// private_state
// file fs.c line 104
static struct synth_state private_state[2l];
// punct_all
// file es.c line 294
char *punct_all = (char *)(void *)0;
// punct_some
// file es.c line 293
char *punct_some = (char *)(void *)0;
// ref_count
// file fs.c line 138
static signed int ref_count = 0;
// settings
// file es.c line 292
struct setting *settings = (struct setting *)(void *)0;
// sock
// file es.c line 291
signed int sock = -1;
// sockname
// file es.c line 290
char *sockname = (char *)(void *)0;
// state
// file fs.c line 106
static struct synth_struct state[2l];
// state
// file fs.c line 106
static struct synth_struct state[2l] = { { .state=&private_state[(signed long int)0], .lang=&languages[(signed long int)0],
    .name="FLite/US English",
    .lib_handle=(void *)0, .close=s_close,
    .synth=s_synth, .flush=s_flush, .clear=s_clear,
    .index_set=(signed int (*)(struct synth_struct *))(void *)0, .index_wait=(signed int (*)(struct synth_struct *, signed int, signed int))(void *)0,
    .get_param=s_get_param,
    .set_param=s_set_param }, 
    { .state=&private_state[(signed long int)1], .lang=&languages[(signed long int)1],
    .name="FLite/German",
    .lib_handle=(void *)0, .close=s_close,
    .synth=s_synth, .flush=s_flush, .clear=s_clear,
    .index_set=(signed int (*)(struct synth_struct *))(void *)0, .index_wait=(signed int (*)(struct synth_struct *, signed int, signed int))(void *)0,
    .get_param=s_get_param,
    .set_param=s_set_param } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// ta
// file fs.c line 183
static union pthread_attr_t ta;
// text
// file fs.c line 177
static char *text;
// text_buffered
// file es.c line 286
static signed int text_buffered = 0;
// text_condition
// file fs.c line 175
static union anonymous$1 text_condition;
// text_head
// file fs.c line 179
static signed int text_head;
// text_mutex
// file fs.c line 174
static union anonymous$0 text_mutex;
// text_size
// file fs.c line 178
static signed int text_size;
// text_synthpos
// file fs.c line 180
static signed int text_synthpos;
// text_tail
// file fs.c line 179
static signed int text_tail;
// text_thread
// file fs.c line 171
static unsigned long int text_thread;
// text_thread_active
// file fs.c line 172
static signed int text_thread_active;
// text_thread_cancel
// file fs.c line 173
static signed int text_thread_cancel;
// time_left
// file fs.c line 167
static float time_left = (float)0;
// tone_flags
// file es.c line 296
static signed int tone_flags = 3;
// tone_volume
// file es.c line 295
static signed int tone_volume;
// v
// file fs.c line 155
static struct cst_voice_struct *v = (struct cst_voice_struct *)(void *)0;
// wave_condition
// file fs.c line 161
static union anonymous$1 wave_condition;
// wave_mutex
// file fs.c line 160
static union anonymous$0 wave_mutex;
// wave_thread
// file fs.c line 158
static unsigned long int wave_thread;
// wave_thread_active
// file fs.c line 159
static signed int wave_thread_active;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// ac_destroy
// file fs.c line 489
static void ac_destroy(struct anonymous$13 *ac)
{
  if((signed int)ac->type == SPEECH || (signed int)ac->type == TONE)
    cst_wave_free((struct cst_wave_struct *)ac->data);

  ac->type = (enum anonymous$12)NONE;
}

// add_command
// file fs.c line 772
static void add_command(struct synth_struct *s, signed int id, unsigned char *buffer)
{
  signed int len;
  /* assertion s->state->initialized */
  assert(s->state->initialized != 0);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen((char *)buffer);
  len = (signed int)return_value_strlen$1;
  if(!(text_thread_active == 0))
    pthread_mutex_lock(&text_mutex);

  if(3 + len + text_tail >= text_size)
  {
    text_size = text_size << 1;
    text_size = text_size + len;
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)text, (unsigned long int)text_size);
    text = (char *)return_value_realloc$2;
    if(text == ((char *)NULL))
    {
      fprintf(stderr, "Out of memory: text_size=%d\n", text_size);
      exit(1);
    }

  }

  signed int tmp_post$3 = text_tail;
  text_tail = text_tail + 1;
  text[(signed long int)tmp_post$3] = (char)id;
  strcpy(text + (signed long int)text_tail, (char *)buffer);
  text_tail = text_tail + len + 1;
  text[(signed long int)text_tail] = (char)0;
  if(text_thread_active == 0)
  {
    text_thread_active = 1;
    pthread_create(&text_thread, &ta, synthesize, (void *)s);
  }

  else
  {
    pthread_cond_signal(&text_condition);
    pthread_mutex_unlock(&text_mutex);
  }
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// add_tone_command
// file fs.c line 822
void add_tone_command(struct synth_struct *s, signed int freq, signed int dur, signed int vol)
{
  char add_tone_command$$1$$buf[40l];
  sprintf(add_tone_command$$1$$buf, "%d %d %d", freq, dur, vol);
  add_command(s, 2, (unsigned char *)add_tone_command$$1$$buf);
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1)
{
  signed long int return_value_strtol$1$link1;
  return_value_strtol$1$link1=strtol(__nptr$link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link1;
}

// atoi$link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link2(const char *__nptr$link2)
{
  signed long int return_value_strtol$1$link2;
  return_value_strtol$1$link2=strtol(__nptr$link2, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link2;
}

// client_init
// file es.c line 459
void client_init(struct client *client)
{
  memcpy((void *)&client->param, (const void *)&default_param, sizeof(signed int) /*4ul*/  * (unsigned long int)3);
  memset((void *)client->punct, 0, sizeof(char [256l]) /*256ul*/ );
}

// close_audiodev
// file fs.c line 499
static void close_audiodev()
{
  if(!(audiodev == ((struct cst_audiodev_struct *)NULL)))
  {
    audio_close(audiodev);
    audiodev = (struct cst_audiodev_struct *)(void *)0;
  }

}

// cst_wave_free
// file fs.c line 479
static void cst_wave_free(struct cst_wave_struct *w)
{
  if(!(w == ((struct cst_wave_struct *)NULL)))
  {
    cst_free((void *)w->samples);
    cst_free((void *)w);
  }

}

// determine_playlen
// file fs.c line 508
static inline void determine_playlen(signed int speed, struct cst_wave_struct *wptr, signed int type, signed int *pl, signed int *s)
{
  signed int playlen;
  signed int skip;
  if(type == SPEECH)
  {
    skip = (187 * wptr->sample_rate) / speed;
    playlen = wptr->num_samples - skip * 2;
    if(playlen >= 1 && !(playlen >= 500))
      playlen = playlen + (skip * 2) / 3;

  }

  else
  {
    skip = 0;
    playlen = wptr->num_samples;
  }
  if(!(playlen >= 0))
    playlen = 0;

  *pl = playlen;
  *s = skip;
}

// do_tone
// file es.h line 43
void do_tone(struct synth_struct *s, signed int freq, signed int dur, signed int vol, signed int flags)
{
  if(!((0x02 & flags) == 0))
    add_tone_command(s, freq, dur, vol);

}

// es_addtext
// file es.c line 392
void es_addtext(struct client *client, char *buf)
{
  signed int i;
  signed int val;
  char obuf[1024l];
  unsigned char *p;
  unsigned char *q;
  i = 0;
  if(!(i >= 3))
  {
    lang$link1->synth->get_param(lang$link1->synth, (enum anonymous$9)i, &val);
    if(!(val == client->param[(signed long int)i]))
    {
      if(!(text_buffered == 0))
        es_synthesize();

      lang$link1->synth->set_param(lang$link1->synth, (enum anonymous$9)i, client->param[(signed long int)i]);
    }

    i = i + 1;
  }

  q = (unsigned char *)obuf;
  p = (unsigned char *)buf;
  unsigned char *tmp_post$1;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  for( ; !(*p == 0); p = p + 1l)
  {
    if(q - (unsigned char *)obuf >= 897l)
    {
      *q = (unsigned char)0;
      lang$link1->synth->synth(lang$link1->synth, (unsigned char *)obuf);
      q = (unsigned char *)obuf;
    }

    if(client->punct[(signed long int)(signed int)*p] == 0)
    {
      tmp_post$1 = q;
      q = q + 1l;
      *tmp_post$1 = *p;
    }

    else
    {
      if(!((unsigned char *)obuf >= q))
      {
        if(!((signed int)q[-1l] == 32))
        {
          tmp_post$2 = q;
          q = q + 1l;
          *tmp_post$2 = (unsigned char)32;
        }

      }

      strcpy((char *)q, ascii[(signed long int)(signed int)*p]);
      for( ; !(*q == 0); q = q + 1l)
        ;
      tmp_post$3 = q;
      q = q + 1l;
      *tmp_post$3 = (unsigned char)32;
    }
  }
  *q = (unsigned char)0;
  lang$link1->synth->synth(lang$link1->synth, (unsigned char *)obuf);
  text_buffered = 1;
}

// es_synthesize
// file es.c line 386
void es_synthesize()
{
  lang$link1->synth->flush(lang$link1->synth);
  text_buffered = 0;
}

// finish
// file es.c line 298
void finish(signed int sig)
{
  signed int i = 0;
  for( ; !(i >= numclients); i = i + 1)
    close((client + (signed long int)i)->fd);
  close(sock);
  unlink(sockname);
  if(!(lang$link1 == ((struct lang_struct *)NULL)))
    lang$link1->synth->close(lang$link1->synth);

  exit(0);
}

// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 467
static inline signed int fstat(signed int __fd, struct stat *__statbuf)
{
  signed int return_value___fxstat$1;
  return_value___fxstat$1=__fxstat(1, __fd, __statbuf);
  return return_value___fxstat$1;
}

// generate_tone
// file es.h line 45
struct cst_wave_struct * generate_tone(signed int freq, signed int dur, signed int vol)
{
  float max = (float)(((double)2 * 3.141592653589793238 * (double)freq * (double)dur) / (double)1000);
  float step = (float)(((double)2 * 3.141592653589793238 * (double)freq) / (double)8000);
  float n;
  signed int i;
  struct cst_wave_struct *wptr;
  void *return_value_cst_safe_alloc$1;
  return_value_cst_safe_alloc$1=cst_safe_alloc((signed int)(sizeof(struct cst_wave_struct) /*32ul*/  * (unsigned long int)1));
  wptr = (struct cst_wave_struct *)return_value_cst_safe_alloc$1;
  if(wptr == ((struct cst_wave_struct *)NULL))
    return wptr;

  else
  {
    wptr->num_samples = (signed int)(max / step);
    void *return_value_cst_safe_alloc$2;
    return_value_cst_safe_alloc$2=cst_safe_alloc((signed int)(sizeof(signed short int) /*2ul*/  * (unsigned long int)wptr->num_samples));
    wptr->samples = (signed short int *)return_value_cst_safe_alloc$2;
    if(wptr->samples == ((signed short int *)NULL))
    {
      free((void *)wptr);
      return (struct cst_wave_struct *)(void *)0;
    }

    else
    {
      wptr->num_channels = 1;
      wptr->sample_rate = 8000;
      i = 0;
      n = (float)0;
      for( ; !(i >= wptr->num_samples); i = i + 1)
      {
        double return_value_sin$3;
        return_value_sin$3=sin((double)n);
        wptr->samples[(signed long int)i] = (signed short int)(return_value_sin$3 * (double)vol);
        n = n + step;
      }
      return wptr;
    }
  }
}

// handle
// file es.c line 625
signed int handle(struct client *client)
{
  signed int i;
  signed int j;
  signed int size;
  char *p;
  signed int in_braces = 0;
  signed int result;
  signed long int return_value_read$1;
  return_value_read$1=read(client->fd, (void *)buf, (unsigned long int)(bufsize - 1));
  size = (signed int)return_value_read$1;
  signed int return_value_string_is_complete$2;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(size == 0)
    return 1;

  else
  {
    buf[(signed long int)size] = (char)0;
    do
    {
      return_value_string_is_complete$2=string_is_complete(buf, size);
      if(!(return_value_string_is_complete$2 == 0))
        break;

      bufsize = bufsize + 200;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)buf, (unsigned long int)bufsize);
      buf = (char *)return_value_realloc$3;
      if(buf == ((char *)NULL))
        exit(1);

      signed long int return_value_read$4;
      return_value_read$4=read(client->fd, (void *)(buf + (signed long int)size), (unsigned long int)200);
      result = (signed int)return_value_read$4;
      if(!(result >= 1))
      {
        buf[(signed long int)size] = (char)0;
        break;
      }

      size = size + result;
      buf[(signed long int)size] = (char)0;
    }
    while((_Bool)1);
    p = buf;
    j = 0;
    i = j;
    for( ; !(i >= size); i = i + 1)
    {
      if((signed int)buf[(signed long int)i] == 13)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)buf[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
      if(in_braces == 0 && tmp_if_expr$6)
      {
        if((signed int)*p == 108)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)*p == 113 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          if((signed int)p[1l] == 32)
          {
            j = size - 2;
            for( ; j >= i; j = j - 1)
              if((signed int)buf[(signed long int)j] == 123)
                in_braces = 1;

              else
                if((signed int)buf[(signed long int)j] == 125)
                  in_braces = 0;

                else
                  if(in_braces == 0)
                  {
                    if((signed int)buf[(signed long int)j] == 13)
                    {
                      if((signed int)buf[(signed long int)(1 + j)] == 115)
                      {
                        if((signed int)buf[(signed long int)(2 + j)] == 13)
                          i = j + 2;

                      }

                    }

                  }

          }

        }

        in_braces = 0;
        buf[(signed long int)i] = (char)in_braces;
        if(!(j >= i))
          parse(client, p);

        p = buf + (signed long int)i + (signed long int)1;
      }

      else
        if((signed int)buf[(signed long int)i] == 123)
          in_braces = 1;

        else
          if((signed int)buf[(signed long int)i] == 125)
            in_braces = 0;

    }
    return 0;
  }
}

// is_dir
// file es.c line 745
signed int is_dir(char *name)
{
  struct stat st;
  stat(name, &st);
  return (signed int)((st.st_mode & (unsigned int)0170000) == (unsigned int)0040000);
}

// language_open
// file fs.c line 1033
struct lang_struct * language_open(void *context, char * (*lookup)(void *, const char *))
{
  lang.synth=synth_open(context, lookup);
  return &lang;
}

// lookup_int
// file es.c line 377
signed int lookup_int(char *name, signed int defval)
{
  char *val;
  val=lookup_string((void *)0, name);
  if(val == ((char *)NULL))
    return defval;

  else
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(val);
    return return_value_atoi$1;
  }
}

// lookup_string
// file es.c line 356
char * lookup_string(void *context, const char *name)
{
  struct setting *p;
  if(settings == ((struct setting *)NULL))
  {
    signed int return_value_settings_init$1;
    return_value_settings_init$1=settings_init();
    if(return_value_settings_init$1 == -1)
    {
      fprintf(stderr, "Fatal:  Cannot initialize settings\n");
      exit(1);
    }

  }

  p = settings;
  while(!(p == ((struct setting *)NULL)))
  {
    signed int return_value_strcasecmp$2;
    return_value_strcasecmp$2=strcasecmp(p->name, name);
    if(return_value_strcasecmp$2 == 0)
      return p->value;

    p = p->next;
  }
  return (char *)(void *)0;
}

// main
// file es.c line 759
signed int main(signed int argc, char **argv)
{
  struct anonymous$16 fds;
  signed int i;
  signed int maxclients = 0;
  char *infile = (char *)(void *)0;
  char *context = (char *)(void *)0;
  signed int max;
  signed int local_fd;
  signed int child;
  char *input = (char *)(void *)0;
  signed int more_opts = 1;
  signed int debug = 0;
  signed int daemon_only = 0;
  while(!(more_opts == 0))
  {
    signed int return_value_getopt_long$1;
    return_value_getopt_long$1=getopt_long(argc, argv, "Ddf:vc:", (struct option *)&longopts, (signed int *)(void *)0);
    switch(return_value_getopt_long$1)
    {
      case 68:
      {
        daemon_only = 1;
        break;
      }
      case 100:
      {
        debug = 1;
        break;
      }
      case 102:
      {
        input = optarg;
        break;
      }
      case 99:
      {
        context = optarg;
        break;
      }
      case 118:
      {
        printf("Eflite 0.4.1\n");
        exit(0);
      }
      default:
        more_opts = 0;
    }
  }
  signed int tmp_statement_expression$3;
  signed int return_value_is_dir$2;
  if(!(input == ((char *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$4;
    return_value___builtin_strcmp$4=__builtin_strcmp(input, "-");
    tmp_statement_expression$3 = return_value___builtin_strcmp$4;
    if(!(tmp_statement_expression$3 == 0))
    {
      return_value_is_dir$2=is_dir(input);
      if(return_value_is_dir$2 == 0)
        infile = input;

    }

  }

  void *return_value_malloc$5;
  return_value_malloc$5=malloc((unsigned long int)bufsize);
  buf = (char *)return_value_malloc$5;
  if(buf == ((char *)NULL))
    exit(1);

  _Bool tmp_if_expr$9;
  unsigned long int return_value_strlen$8;
  if(context == ((char *)NULL))
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_strlen$8=strlen(context);
    tmp_if_expr$9 = return_value_strlen$8 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$9)
  {
    sockname=lookup_string((void *)0, "socketfile");
    if(sockname == ((char *)NULL))
      sockname = "/tmp/es.socket";

  }

  else
  {
    signed int return_value_snprintf$6;
    return_value_snprintf$6=snprintf(buf, (unsigned long int)bufsize, "/tmp/es_%s.socket", context);
    if(return_value_snprintf$6 >= bufsize)
    {
      perror("Context argument too long.");
      exit(1);
    }

    char *return_value___strdup$7;
    return_value___strdup$7=__strdup(buf);
    sockname = return_value___strdup$7;
    if(sockname == ((char *)NULL))
    {
      perror("Could not allocate space");
      exit(1);
    }

  }
  local_fd=sockconnect(sockname);
  if(!(daemon_only == 0))
  {
    if(!(local_fd == -1))
      exit(1);

  }

  else
  {
    if(!(local_fd == -1))
      passthrough(infile, local_fd);

    if(debug == 0)
    {
      child=fork();
      if(!(child == 0))
      {
        usleep((unsigned int)200000);
        local_fd=sockconnect(sockname);
        if(local_fd == -1)
          exit(1);

        passthrough(infile, local_fd);
        exit(0);
      }

    }

  }
  punct_some=lookup_string((void *)0, "punct_some");
  if(punct_some == ((char *)NULL))
    punct_some = "@#$%^&_[]{}\\|";

  punct_all=lookup_string((void *)0, "punct_all");
  if(punct_all == ((char *)NULL))
    punct_all = "!@#$%^&*()-=_+[]\\|{};':\",./<>?";

  tone_volume=lookup_int("tone_volume", 8192);
  signed int return_value_lookup_int$10;
  return_value_lookup_int$10=lookup_int("speaker_tones", 1);
  if(return_value_lookup_int$10 == 0)
    tone_flags = tone_flags & 0xfe;

  signed int return_value_lookup_int$11;
  return_value_lookup_int$11=lookup_int("soundcard_tones", 1);
  if(return_value_lookup_int$11 == 0)
    tone_flags = tone_flags & 0xfd;

  unlink(sockname);
  sock=sockopen(sockname);
  if(sock == -1)
    exit(1);

  chmod(sockname, (unsigned int)0666);
  signal(2, finish);
  signal(15, finish);
  lang$link1=language_open((void *)0, lookup_string);
  if(lang$link1 == ((struct lang_struct *)NULL))
    exit(1);

  if(debug == 0)
    daemon(0, 0);

  i = 0;
  if(!(i >= 3))
  {
    lang$link1->synth->get_param(lang$link1->synth, (enum anonymous$9)i, &default_param[(signed long int)i]);
    i = i + 1;
  }

  default_param[(signed long int)S_VOLUME]=lookup_int("speech_volume", default_param[(signed long int)S_VOLUME]);
  signed int tmp_post$13;
  do
  {

  __CPROVER_DUMP_L33:
    ;
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
    max = sock;
    (&fds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
    i = 0;
    for( ; !(i >= numclients); i = i + 1)
    {
      if(!(max >= (client + (signed long int)i)->fd))
        max = (client + (signed long int)i)->fd;

      (&fds)->fds_bits[(signed long int)((client + (signed long int)i)->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)((client + (signed long int)i)->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << (client + (signed long int)i)->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
    }
    select(max + 1, &fds, (struct anonymous$16 *)(void *)0, (struct anonymous$16 *)(void *)0, (struct timeval *)(void *)0);
    if(!((fds.fds_bits[(signed long int)(sock / 8)] & 1l << sock % 8) == 0l))
    {
      if(numclients == maxclients)
      {
        maxclients = maxclients + 1;
        void *return_value_realloc$12;
        return_value_realloc$12=realloc((void *)client, (unsigned long int)maxclients * sizeof(struct client) /*272ul*/ );
        client = (struct client *)return_value_realloc$12;
      }

      tmp_post$13 = numclients;
      numclients = numclients + 1;
      (client + (signed long int)tmp_post$13)->fd=accept(sock, (struct sockaddr *)0, ((unsigned int *)NULL));
      client_init(&client[(signed long int)i]);
    }

    else
    {
      i = 0;
      for( ; !(i >= numclients); i = i + 1)
        if(!((fds.fds_bits[(signed long int)((client + (signed long int)i)->fd / 8)] & 1l << (client + (signed long int)i)->fd % 8) == 0l))
        {
          signed int return_value_handle$14;
          return_value_handle$14=handle(&client[(signed long int)i]);
          if(!(return_value_handle$14 == 0))
          {
            close((client + (signed long int)i)->fd);
            numclients = numclients - 1;
            memmove((void *)(client + (signed long int)i), (const void *)(client + (signed long int)i + (signed long int)1), sizeof(struct client) /*272ul*/  * (unsigned long int)(numclients - i));
            if(numclients == 0)
              finish(0);

          }

          break;
        }

    }
  }
  while((_Bool)1);
}

// parse
// file es.c line 494
void parse(struct client *client, char *buf)
{
  signed int i;
  signed int count;
  char *token[10l];
  signed int parse$$1$$state;
  signed int tmp;
  char *p;
  if((signed int)*buf == 108)
  {
    if((signed int)buf[1l] == 32)
    {
      p = buf + (signed long int)2;
      if((signed int)*p == 123)
      {
        if(!(p[1l] == 0))
          p = p + 1l;

      }

      tmp = client->param[(signed long int)1];
      if((signed int)*p >= 65)
      {
        if(!((signed int)*p >= 91))
        {
          client->param[(signed long int)1] = client->param[(signed long int)1] * 12;
          client->param[(signed long int)1] = client->param[(signed long int)1] / 10;
        }

      }

      es_addtext(client, ascii[(signed long int)(unsigned char)*p]);
      es_synthesize();
      client->param[(signed long int)1] = tmp;
    }

  }

  memset((void *)token, 0, sizeof(char *[10l]) /*80ul*/ );
  for( ; (signed int)*buf == 32; buf = buf + 1l)
    ;
  count = 0;
  parse$$1$$state = count;
  i = parse$$1$$state;
  signed int tmp_post$1;
  signed int tmp_post$2;
  for( ; !(buf[(signed long int)i] == 0); i = i + 1)
    switch(parse$$1$$state)
    {
      case 0:
      {
        if((signed int)buf[(signed long int)i] == 32)
        {
          buf[(signed long int)i] = (char)0;
          parse$$1$$state = 1;
          break;
        }

        break;
      }
      case 1:
      {
        if((signed int)buf[(signed long int)i] == 123)
        {
          if(!(count >= 9))
          {
            tmp_post$1 = count;
            count = count + 1;
            token[(signed long int)tmp_post$1] = buf + (signed long int)i + (signed long int)1;
          }

          parse$$1$$state = 2;
        }

        else
          if(!((signed int)buf[(signed long int)i] == 32))
          {
            if(!(count >= 9))
            {
              tmp_post$2 = count;
              count = count + 1;
              token[(signed long int)tmp_post$2] = buf + (signed long int)i;
            }

            parse$$1$$state = 0;
          }

        break;
      }
      case 2:
        if((signed int)buf[(signed long int)i] == 125)
        {
          buf[(signed long int)i] = (char)0;
          parse$$1$$state = 1;
        }

    }
  signed int tmp_statement_expression$31;
  unsigned long int __s1_len;
  unsigned long int parse$$1$$3$$__s2_len;
  signed int return_value___builtin_strcmp$32;
  return_value___builtin_strcmp$32=__builtin_strcmp(buf, "q");
  tmp_statement_expression$31 = return_value___builtin_strcmp$32;
  _Bool tmp_if_expr$33;
  if(tmp_statement_expression$31 == 0)
    tmp_if_expr$33 = token[(signed long int)0] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$33 = (_Bool)0;
  signed int tmp_statement_expression$29;
  signed int tmp_statement_expression$26;
  _Bool tmp_if_expr$28;
  signed int tmp_statement_expression$20;
  _Bool tmp_if_expr$24;
  signed int tmp_statement_expression$22;
  _Bool tmp_if_expr$25;
  signed int tmp_statement_expression$14;
  _Bool tmp_if_expr$18;
  signed int tmp_statement_expression$16;
  _Bool tmp_if_expr$19;
  signed int tmp_statement_expression$12;
  signed int tmp_statement_expression$10;
  signed int tmp_statement_expression$7;
  _Bool tmp_if_expr$9;
  signed int return_value_strcasecmp$6;
  if(tmp_if_expr$33)
  {
    remove_dectalk_codes(token[(signed long int)0]);
    es_addtext(client, token[(signed long int)0]);
  }

  else
  {
    unsigned long int parse$$1$$5$$__s1_len;
    unsigned long int parse$$1$$5$$__s2_len;
    signed int return_value___builtin_strcmp$30;
    return_value___builtin_strcmp$30=__builtin_strcmp(buf, "d");
    tmp_statement_expression$29 = return_value___builtin_strcmp$30;
    if(tmp_statement_expression$29 == 0)
      es_synthesize();

    else
    {
      unsigned long int parse$$1$$7$$__s1_len;
      unsigned long int parse$$1$$7$$__s2_len;
      signed int return_value___builtin_strcmp$27;
      return_value___builtin_strcmp$27=__builtin_strcmp(buf, "tts_say");
      tmp_statement_expression$26 = return_value___builtin_strcmp$27;
      if(tmp_statement_expression$26 == 0)
        tmp_if_expr$28 = token[(signed long int)0] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$28 = (_Bool)0;
      if(tmp_if_expr$28)
      {
        remove_dectalk_codes(token[(signed long int)0]);
        es_addtext(client, token[(signed long int)0]);
        es_synthesize();
      }

      else
      {
        unsigned long int parse$$1$$9$$__s1_len;
        unsigned long int parse$$1$$9$$__s2_len;
        signed int return_value___builtin_strcmp$21;
        return_value___builtin_strcmp$21=__builtin_strcmp(buf, "r");
        tmp_statement_expression$20 = return_value___builtin_strcmp$21;
        if(tmp_statement_expression$20 == 0)
          tmp_if_expr$24 = (_Bool)1;

        else
        {
          unsigned long int parse$$1$$10$$__s1_len;
          unsigned long int parse$$1$$10$$__s2_len;
          signed int return_value___builtin_strcmp$23;
          return_value___builtin_strcmp$23=__builtin_strcmp(buf, "tts_set_speech_rate");
          tmp_statement_expression$22 = return_value___builtin_strcmp$23;
          tmp_if_expr$24 = !(tmp_statement_expression$22 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$24)
          tmp_if_expr$25 = token[(signed long int)0] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$25 = (_Bool)0;
        if(tmp_if_expr$25)
        {
          if(!(text_buffered == 0))
            es_synthesize(client);

          signed int return_value_atoi$3;
          return_value_atoi$3=atoi(token[(signed long int)0]);
          client->param[(signed long int)S_SPEED] = (return_value_atoi$3 * 23) / 4;
        }

        else
        {
          unsigned long int parse$$1$$12$$__s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$15;
          return_value___builtin_strcmp$15=__builtin_strcmp(buf, "v");
          tmp_statement_expression$14 = return_value___builtin_strcmp$15;
          if(tmp_statement_expression$14 == 0)
            tmp_if_expr$18 = (_Bool)1;

          else
          {
            unsigned long int parse$$1$$13$$__s1_len;
            unsigned long int parse$$1$$13$$__s2_len;
            signed int return_value___builtin_strcmp$17;
            return_value___builtin_strcmp$17=__builtin_strcmp(buf, "tts_set_speech_volume");
            tmp_statement_expression$16 = return_value___builtin_strcmp$17;
            tmp_if_expr$18 = !(tmp_statement_expression$16 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$18)
            tmp_if_expr$19 = token[(signed long int)0] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$19 = (_Bool)0;
          if(tmp_if_expr$19)
          {
            if(!(text_buffered == 0))
              es_synthesize(client);

            client->param[(signed long int)S_VOLUME]=atoi(token[(signed long int)0]);
          }

          else
          {
            unsigned long int parse$$1$$15$$__s1_len;
            unsigned long int parse$$1$$15$$__s2_len;
            signed int return_value___builtin_strcmp$13;
            return_value___builtin_strcmp$13=__builtin_strcmp(buf, "reset");
            tmp_statement_expression$12 = return_value___builtin_strcmp$13;
            if(tmp_statement_expression$12 == 0)
              client_init(client);

            else
            {
              unsigned long int parse$$1$$17$$__s1_len;
              unsigned long int parse$$1$$17$$__s2_len;
              signed int return_value___builtin_strcmp$11;
              return_value___builtin_strcmp$11=__builtin_strcmp(buf, "s");
              tmp_statement_expression$10 = return_value___builtin_strcmp$11;
              if(tmp_statement_expression$10 == 0)
                lang$link1->synth->clear(lang$link1->synth);

              else
              {
                unsigned long int parse$$1$$19$$__s1_len;
                unsigned long int parse$$1$$19$$__s2_len;
                signed int return_value___builtin_strcmp$8;
                return_value___builtin_strcmp$8=__builtin_strcmp(buf, "tts_set_punctuations");
                tmp_statement_expression$7 = return_value___builtin_strcmp$8;
                if(tmp_statement_expression$7 == 0)
                  tmp_if_expr$9 = token[(signed long int)0] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$9 = (_Bool)0;
                if(tmp_if_expr$9)
                {
                  memset((void *)client->punct, 0, sizeof(char [256l]) /*256ul*/ );
                  signed int return_value_strcasecmp$4;
                  return_value_strcasecmp$4=strcasecmp(token[(signed long int)0], "none");
                  if(!(return_value_strcasecmp$4 == 0))
                    punct_add(client, punct_some);

                  signed int return_value_strcasecmp$5;
                  return_value_strcasecmp$5=strcasecmp(token[(signed long int)0], "all");
                  if(return_value_strcasecmp$5 == 0)
                    punct_add(client, punct_all);

                }

                else
                {
                  return_value_strcasecmp$6=strcasecmp(buf, "t");
                  if(return_value_strcasecmp$6 == 0)
                  {
                    if(!(token[0l] == ((char *)NULL)))
                    {
                      if(!(token[1l] == ((char *)NULL)))
                      {
                        signed int freq;
                        freq=atoi(token[(signed long int)0]);
                        signed int dur;
                        dur=atoi(token[(signed long int)1]);
                        do_tone(lang$link1->synth, freq, dur, tone_volume, tone_flags);
                      }

                    }

                  }

                }
              }
            }
          }
        }
      }
    }
  }
}

// passthrough
// file es.c line 693
void passthrough(char *infile, signed int outfd)
{
  char passthrough$$1$$buf[500l];
  signed int size;
  signed int fd;
  signal(17, finish);
  if(!(infile == ((char *)NULL)))
  {
    fd=open(infile, 00);
    if(fd == -1)
      terror("open");

  }

  else
    fd = 0;
  signed int tmp_if_expr$4;
  signed int return_value_open$3;
  while((_Bool)1)
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)passthrough$$1$$buf, sizeof(char [500l]) /*500ul*/ );
    size = (signed int)return_value_read$1;
    if(size == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 9)
        exit(0);

      else
        terror("read");
    }

    if(size == 0)
    {
      signed int is_fifo;
      struct stat passthrough$$1$$3$$2$$stat;
      fstat(fd, &passthrough$$1$$3$$2$$stat);
      is_fifo = (signed int)((passthrough$$1$$3$$2$$stat.st_mode & (unsigned int)0170000) == (unsigned int)0010000);
      close(fd);
      if(!(is_fifo == 0))
      {
        if(!(infile == ((char *)NULL)))
        {
          return_value_open$3=open(infile, 00);
          tmp_if_expr$4 = return_value_open$3;
        }

        else
          tmp_if_expr$4 = 0;
        fd = tmp_if_expr$4;
        continue;
      }

      exit(0);
    }

    if((signed int)passthrough$$1$$buf[0l] == 3)
      break;

    signed long int return_value_write$5;
    return_value_write$5=write(outfd, (const void *)passthrough$$1$$buf, (unsigned long int)size);
    if(!(return_value_write$5 == (signed long int)size))
      terror("write");

  }
  exit(0);
}

// play
// file fs.c line 528
static void * play(void *s)
{
  signed int playlen;
  signed int skip;
  struct cst_wave_struct *wptr;
  signed int type;
  signed int *sparam = ((struct synth_struct *)s)->state->param;
  while((_Bool)1)
  {
    do
    {
      struct anonymous$6 play$$1$$1$$1$$__cancel_buf;
      void (*play$$1$$1$$1$$__cancel_routine)(void *) = wave_unlock;
      void *play$$1$$1$$1$$__cancel_arg = (void *)"play";
      signed int play$$1$$1$$1$$__not_first_call;
      play$$1$$1$$1$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)play$$1$$1$$1$$__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)play$$1$$1$$1$$__not_first_call == 0l))
      {
        play$$1$$1$$1$$__cancel_routine(play$$1$$1$$1$$__cancel_arg);
        __pthread_unwind_next(&play$$1$$1$$1$$__cancel_buf);
      }

      __pthread_register_cancel(&play$$1$$1$$1$$__cancel_buf);
      do
      {
        pthread_mutex_lock(&wave_mutex);
        pthread_testcancel();
        while(ac_head >= ac_synthpos)
        {
          pthread_testcancel();
          pthread_setcancelstate(1, (signed int *)(void *)0);
          pthread_cond_wait(&wave_condition, &wave_mutex);
          pthread_setcancelstate(0, (signed int *)(void *)0);
        }
        pthread_testcancel();
        wptr = (struct cst_wave_struct *)(ac + (signed long int)ac_head)->data;
        type = (signed int)(ac + (signed long int)ac_head)->type;
        pthread_mutex_unlock(&wave_mutex);

      __CPROVER_DUMP_L7:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&play$$1$$1$$1$$__cancel_buf);
    }
    while((_Bool)0);
    pthread_testcancel();
    do
    {
      struct anonymous$6 play$$1$$1$$2$$__cancel_buf;
      void (*__cancel_routine)(void *) = wave_unlock;
      void *__cancel_arg = (void *)"play";
      signed int __not_first_call;
      __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)play$$1$$1$$2$$__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)__not_first_call == 0l))
      {
        __cancel_routine(__cancel_arg);
        __pthread_unwind_next(&play$$1$$1$$2$$__cancel_buf);
      }

      __pthread_register_cancel(&play$$1$$1$$2$$__cancel_buf);
      do
      {
        pthread_mutex_lock(&wave_mutex);
        pthread_testcancel();
        /* assertion audiodev == ((void *)0) */
        assert(audiodev == (struct cst_audiodev_struct *)(void *)0);
        audiodev=audio_open(wptr->sample_rate, wptr->num_channels, (enum anonymous$2)CST_AUDIO_LINEAR16);
        pthread_mutex_unlock(&wave_mutex);

      __CPROVER_DUMP_L12:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&play$$1$$1$$2$$__cancel_buf);
    }
    while((_Bool)0);
    if(audiodev == ((struct cst_audiodev_struct *)NULL))
      exit(1);

    determine_playlen(sparam[(signed long int)S_SPEED], wptr, type, &playlen, &skip);
    if(playlen >= 1)
    {
      if(!(sparam[2l] == 1000))
        cst_wave_rescale(wptr, (sparam[(signed long int)S_VOLUME] << 16) / 1000);

      pthread_testcancel();
      audio_write(audiodev, (void *)(wptr->samples + (signed long int)skip), playlen * 2);
      pthread_testcancel();
    }

    audio_flush(audiodev);
    pthread_setcanceltype(0, (signed int *)(void *)0);
    pthread_testcancel();
    do
    {
      struct anonymous$6 __cancel_buf;
      void (*play$$1$$1$$5$$__cancel_routine)(void *) = text_unlock;
      void *play$$1$$1$$5$$__cancel_arg = (void *)"play";
      signed int play$$1$$1$$5$$__not_first_call;
      play$$1$$1$$5$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)play$$1$$1$$5$$__not_first_call == 0l))
      {
        play$$1$$1$$5$$__cancel_routine(play$$1$$1$$5$$__cancel_arg);
        __pthread_unwind_next(&__cancel_buf);
      }

      __pthread_register_cancel(&__cancel_buf);
      do
      {
        pthread_mutex_lock(&text_mutex);
        pthread_mutex_lock(&wave_mutex); //added mutex
        pthread_testcancel();
        time_left = time_left - (float)playlen / (float)wptr->sample_rate;
        pthread_cond_signal(&text_condition);
        pthread_mutex_unlock(&wave_mutex); //added mutex
        pthread_mutex_unlock(&text_mutex);

      __CPROVER_DUMP_L20:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&__cancel_buf);
    }
    while((_Bool)0);
    do
    {
      struct anonymous$6 play$$1$$1$$6$$__cancel_buf;
      void (*play$$1$$1$$6$$__cancel_routine)(void *) = wave_unlock;
      void *play$$1$$1$$6$$__cancel_arg = (void *)"play";
      signed int play$$1$$1$$6$$__not_first_call;
      play$$1$$1$$6$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)play$$1$$1$$6$$__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)play$$1$$1$$6$$__not_first_call == 0l))
      {
        play$$1$$1$$6$$__cancel_routine(play$$1$$1$$6$$__cancel_arg);
        __pthread_unwind_next(&play$$1$$1$$6$$__cancel_buf);
      }

      __pthread_register_cancel(&play$$1$$1$$6$$__cancel_buf);
      do
      {
        pthread_mutex_lock(&wave_mutex);
        pthread_testcancel();
        close_audiodev();
        ac_destroy(&ac[(signed long int)ac_head]);
        ac_head = ac_head + 1;
        if(ac_head == ac_tail)
          reset_wave_buffer();

        else
          if(!(ac_size >> 1 >= ac_head))
          {
            memmove((void *)ac, (const void *)(ac + (signed long int)ac_head), (unsigned long int)(ac_tail - ac_head) * sizeof(struct anonymous$13) /*16ul*/ );
            ac_tail = ac_tail - ac_head;
            if(ac_synthpos >= 1)
              ac_synthpos = ac_synthpos - ac_head;

            ac_head = 0;
          }

        pthread_mutex_unlock(&wave_mutex);

      __CPROVER_DUMP_L28:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&play$$1$$1$$6$$__cancel_buf);
    }
    while((_Bool)0);
  }
}

// punct_add
// file es.c line 465
static signed int punct_add(struct client *client, const char *str)
{
  unsigned char *p = (unsigned char *)str;
  for( ; !(*p == 0); p = p + 1l)
    client->punct[(signed long int)(signed int)*p] = (char)1;
  return 0;
}

// remove_dectalk_codes
// file es.c line 478
static void remove_dectalk_codes(char *buf)
{
  signed int in_brackets = 0;
  for( ; !(*buf == 0); buf = buf + 1l)
    switch((signed int)*buf)
    {
      case 91:
      {
        *buf = (char)32;
        in_brackets = 1;
        break;
      }
      case 93:
      {
        *buf = (char)32;
        in_brackets = 0;
        break;
      }
      default:
        if(!(in_brackets == 0))
          *buf = (char)32;

    }
}

// reset_text_buffer
// file fs.c line 211
static inline void reset_text_buffer(void)
{
  text_tail = 0;
  text_head = text_tail;
  text_synthpos = 0;
  text[(signed long int)0] = (char)0;
}

// reset_wave_buffer
// file fs.c line 218
static inline void reset_wave_buffer(void)
{
  ac_synthpos = 0;
  ac_tail = ac_synthpos;
  ac_head = ac_tail;
  time_left = (float)0;
}

// s_clear
// file fs.c line 873
static signed int s_clear(struct synth_struct *s)
{
  signed int i;
  signed int ret;
  if(!(wave_thread_active == 0))
  {
    pthread_mutex_lock(&wave_mutex);
    pthread_cond_signal(&wave_condition);
    pthread_cancel(wave_thread);
    if(!(audiodev == ((struct cst_audiodev_struct *)NULL)))
      audio_drain(audiodev);

    pthread_mutex_unlock(&wave_mutex);
  }

  if(!(text_thread_active == 0))
  {
    pthread_mutex_lock(&text_mutex);
    text_thread_cancel = 1;
    pthread_cond_signal(&text_condition);
    pthread_mutex_unlock(&text_mutex);
  }

  if(!(text_thread_active == 0))
  {
    ret=pthread_join(text_thread, (void **)(void *)0);
    /* assertion ret == 0 */
    assert(ret == 0);
  }

  if(!(wave_thread_active == 0))
  {
    ret=pthread_join(wave_thread, (void **)(void *)0);
    /* assertion ret == 0 */
    assert(ret == 0);
  }

  close_audiodev();
  i = 0;
  for( ; !(i >= ac_tail); i = i + 1)
    if(!((signed int)(ac + (signed long int)i)->type == NONE))
      ac_destroy(&ac[(signed long int)i]);

  reset_text_buffer();
  reset_wave_buffer();
  wave_thread_active = 0;
  text_thread_active = wave_thread_active;
  text_thread_cancel = 0;
  ret=pthread_cond_destroy(&wave_condition);
  if(!(ret == 0))
  {
    fprintf(stderr, "s_clear: Wave condition corrupted and not recoverable.");
    exit(4);
  }

  pthread_cond_init(&wave_condition, (const union anonymous$3 *)(void *)0);
  return 0;
}

// s_close
// file fs.c line 417
static signed int s_close(struct synth_struct *s)
{
  ref_count = ref_count - 1;
  if(ref_count == 0)
  {
    signed int ret;
    if(!(text_thread_active == 0))
    {
      while(text_tail >= 1)
        usleep((unsigned int)100000);
      pthread_mutex_lock(&text_mutex);
      text_thread_cancel = 1;
      pthread_cond_signal(&text_condition);
      pthread_mutex_unlock(&text_mutex);
      ret=pthread_join(text_thread, (void **)(void *)0);
      /* assertion ret == 0 */
      assert(ret == 0);
    }

    if(!(wave_thread_active == 0))
    {
      while(ac_tail >= 1)
        usleep((unsigned int)100000);
      pthread_mutex_lock(&wave_mutex);
      pthread_cond_signal(&wave_condition);
      pthread_cancel(wave_thread);
      pthread_mutex_unlock(&wave_mutex);
      ret=pthread_join(wave_thread, (void **)(void *)0);
      /* assertion ret == 0 */
      assert(ret == 0);
    }

    if(!(text == ((char *)NULL)))
      free((void *)text);

    if(!(ac == ((struct anonymous$13 *)NULL)))
      free((void *)ac);

    text = (char *)(void *)0;
    ac = (struct anonymous$13 *)(void *)0;
  }

  return 0;
}

// s_flush
// file fs.c line 836
static signed int s_flush(struct synth_struct *s)
{
  if(text_thread_active == 0)
    return 0;

  else
  {
    pthread_mutex_lock(&text_mutex);
    text_synthpos = text_tail;
    pthread_mutex_unlock(&text_mutex);
    if(wave_thread_active == 0)
    {
      pthread_mutex_lock(&wave_mutex);
      wave_thread_active = 1;
      ac_synthpos = ac_tail;
      pthread_create(&wave_thread, &ta, play, (void *)s);
      pthread_mutex_unlock(&wave_mutex);
    }

    else
    {
      pthread_mutex_lock(&wave_mutex);
      if(!(ac_synthpos >= ac_tail))
      {
        ac_synthpos = ac_tail;
        pthread_cond_signal(&wave_condition);
      }

      pthread_mutex_unlock(&wave_mutex);
    }
    return 0;
  }
}

// s_get_param
// file fs.c line 971
static signed int s_get_param(struct synth_struct *s, enum anonymous$9 par, signed int *value)
{
  if((signed int)par >= 0 && !((signed int)par >= S_MAX))
  {
    *value = s->state->param[(signed long int)par];
    return 0;
  }

  else
    return 1;
}

// s_set_param
// file fs.c line 986
static signed int s_set_param(struct synth_struct *s, enum anonymous$9 par, signed int value)
{
  verify_language(s);
  double return_value_exp$1;
  double return_value_exp$2;
  switch((signed int)par)
  {
    case S_SPEED:
    {
      feat_set_float(v->features, "duration_stretch", (float)1000 / (float)value);
      break;
    }
    case S_PITCH:
    {
      return_value_exp$1=exp((double)((float)value / (float)1000));
      return_value_exp$2=exp((double)1);
      feat_set_float(v->features, "int_f0_target_mean", (float)((return_value_exp$1 * (double)100) / return_value_exp$2));
      break;
    }
    case S_VOLUME:
      break;
    default:
      return 1;
  }
  s->state->param[(signed long int)par] = value;
  return 0;
}

// s_synth
// file fs.c line 816
static signed int s_synth(struct synth_struct *s, unsigned char *buffer)
{
  add_command(s, 1, buffer);
  return 0;
}

// setting_add
// file es.c line 309
void setting_add(char *name, char *value)
{
  struct setting *p = settings;
  void *return_value_malloc$1;
  if(p == ((struct setting *)NULL))
  {
    return_value_malloc$1=malloc(sizeof(struct setting) /*24ul*/ );
    settings = (struct setting *)return_value_malloc$1;
    p = settings;
  }

  else
  {
    for( ; !(p->next == ((struct setting *)NULL)); p = p->next)
      ;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct setting) /*24ul*/ );
    p->next = (struct setting *)return_value_malloc$2;
    p = p->next;
  }
  char *return_value___strdup$3;
  return_value___strdup$3=__strdup(name);
  p->name = return_value___strdup$3;
  char *return_value___strdup$4;
  return_value___strdup$4=__strdup(value);
  p->value = return_value___strdup$4;
  p->next = (struct setting *)(void *)0;
}

// settings_init
// file es.c line 325
signed int settings_init()
{
  struct _IO_FILE *fp;
  char settings_init$$1$$buf[513l];
  char *p;
  p=getenv("HOME");
  snprintf(settings_init$$1$$buf, sizeof(char [513l]) /*513ul*/ , "%s/.es.conf", p);
  fp=fopen(settings_init$$1$$buf, "r");
  if(fp == ((struct _IO_FILE *)NULL))
    fp=fopen("/etc/es.conf", "r");

  char *return_value_fgets$1;
  _Bool tmp_if_expr$2;
  char *tmp_post$5;
  if(fp == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    do
    {
      return_value_fgets$1=fgets(settings_init$$1$$buf, 512, fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      p = settings_init$$1$$buf;
      for( ; (signed int)*p >= 32; p = p + 1l)
        ;
      if((signed int)*p == 13)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)*p == 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        *p = (char)0;

      p = settings_init$$1$$buf;
      signed int return_value_strncasecmp$4;
      return_value_strncasecmp$4=strncasecmp(settings_init$$1$$buf, "env ", (unsigned long int)4);
      if(return_value_strncasecmp$4 == 0)
      {
        char *return_value___strdup$3;
        return_value___strdup$3=__strdup(settings_init$$1$$buf + (signed long int)4);
        putenv(return_value___strdup$3);
        continue;
      }

      for( ; !(*p == 0); p = p + 1l)
        if((signed int)*p == 61)
          break;

      if((signed int)*p == 61)
      {
        tmp_post$5 = p;
        p = p + 1l;
        *tmp_post$5 = (char)0;
        setting_add(settings_init$$1$$buf, p);
      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// sockconnect
// file es.h line 37
signed int sockconnect(const char *name)
{
  signed int return_value_sockconnect_tcp$1;
  signed int return_value_sockconnect_unix$2;
  if(name == ((const char *)NULL))
    return -1;

  else
  {
    char *return_value___builtin_strchr$3;
    return_value___builtin_strchr$3=__builtin_strchr(name, 58);
    if(!(return_value___builtin_strchr$3 == ((char *)NULL)))
    {
      return_value_sockconnect_tcp$1=sockconnect_tcp(name);
      return return_value_sockconnect_tcp$1;
    }

    else
    {
      return_value_sockconnect_unix$2=sockconnect_unix(name);
      return return_value_sockconnect_unix$2;
    }
  }
}

// sockconnect_tcp
// file soccon.c line 36
static signed int sockconnect_tcp(const char *port)
{
  char host[1024l];
  signed int portnum;
  signed int fd;
  struct sockaddr_in servaddr;
  char *p;
  signed int len;
  p=strstr(port, ":");
  portnum=atoi$link1(p + (signed long int)1);
  len = (signed int)(p - port);
  if(len >= 1024)
  {
    fprintf(stderr, "syntheport long\n");
    exit(1);
  }

  memcpy((void *)host, (const void *)port, (unsigned long int)len);
  host[(signed long int)len] = (char)0;
  fd=socket(2, 1, 0);
  if(!(fd >= 0))
  {
    perror("socket");
    exit(1);
  }

  memset((void *)&servaddr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  servaddr.sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)portnum;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  servaddr.sin_port = tmp_statement_expression$1;
  servaddr.sin_addr.s_addr=inet_addr(host);
  signed int return_value_connect$2;
  return_value_connect$2=connect(fd, (struct sockaddr *)&servaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_connect$2 >= 0))
    return -1;

  else
    return fd;
}

// sockconnect_unix
// file soccon.c line 14
signed int sockconnect_unix(const char *fname)
{
  struct sockaddr_un addr;
  signed int sockconnect_unix$$1$$sock;
  if(fname == ((const char *)NULL))
    return -1;

  else
  {
    sockconnect_unix$$1$$sock=socket(1, 1, 0);
    if(sockconnect_unix$$1$$sock == -1)
    {
      perror("socket");
      return -1;
    }

    else
    {
      addr.sun_family = (unsigned short int)1;
      __builtin_strncpy(addr.sun_path, fname, sizeof(char [108l]) /*108ul*/ );
      signed int return_value_connect$1;
      return_value_connect$1=connect(sockconnect_unix$$1$$sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
      if(return_value_connect$1 == -1)
      {
        close(sockconnect_unix$$1$$sock);
        return -1;
      }

      else
        return sockconnect_unix$$1$$sock;
    }
  }
}

// sockopen
// file es.h line 40
signed int sockopen(const char *name)
{
  signed int return_value_sockopen_tcp$1;
  signed int return_value_sockopen_unix$2;
  if(name == ((const char *)NULL))
    return -1;

  else
  {
    char *return_value___builtin_strchr$3;
    return_value___builtin_strchr$3=__builtin_strchr(name, 58);
    if(!(return_value___builtin_strchr$3 == ((char *)NULL)))
    {
      return_value_sockopen_tcp$1=sockopen_tcp(name);
      return return_value_sockopen_tcp$1;
    }

    else
    {
      return_value_sockopen_unix$2=sockopen_unix(name);
      return return_value_sockopen_unix$2;
    }
  }
}

// sockopen_tcp
// file sockopen.c line 40
signed int sockopen_tcp(const char *name)
{
  signed int port;
  signed int sockopen_tcp$$1$$sock;
  sockopen_tcp$$1$$sock=socket(2, 1, 0);
  struct sockaddr_in serv_addr;
  const char *p;
  char *return_value___builtin_strchr$1;
  return_value___builtin_strchr$1=__builtin_strchr(name, 58);
  p = return_value___builtin_strchr$1;
  if(p == ((const char *)NULL))
  {
    fprintf(stderr, "Argh! Internal error!\n");
    exit(1);
  }

  port=atoi$link2(p + (signed long int)1);
  memset((void *)&serv_addr, 0, sizeof(struct sockaddr) /*16ul*/ );
  serv_addr.sin_family = (unsigned short int)2;
  serv_addr.sin_addr.s_addr=__bswap_32((unsigned int)0x00000000);
  unsigned short int tmp_statement_expression$2;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$2 = __v;
  serv_addr.sin_port = tmp_statement_expression$2;
  signed int return_value_bind$3;
  return_value_bind$3=bind(sockopen_tcp$$1$$sock, (struct sockaddr *)&serv_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_bind$3 >= 0))
  {
    fprintf(stderr, "Error in binding to port %d.\n", port);
    exit(1);
  }

  signed int return_value_listen$4;
  return_value_listen$4=listen(sockopen_tcp$$1$$sock, 5);
  if(return_value_listen$4 == -1)
  {
    perror("listen");
    exit(1);
  }

  return sockopen_tcp$$1$$sock;
}

// sockopen_unix
// file sockopen.c line 15
signed int sockopen_unix(const char *fname)
{
  signed int sockopen_unix$$1$$sock;
  struct sockaddr_un addr;
  sockopen_unix$$1$$sock=socket(1, 1, 0);
  if(sockopen_unix$$1$$sock == -1)
    return -1;

  else
  {
    addr.sun_family = (unsigned short int)1;
    __builtin_strncpy(addr.sun_path, fname, sizeof(char [108l]) /*108ul*/ );
    signed int return_value_bind$1;
    return_value_bind$1=bind(sockopen_unix$$1$$sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(return_value_bind$1 == -1)
    {
      close(sockopen_unix$$1$$sock);
      return -1;
    }

    else
    {
      signed int return_value_listen$2;
      return_value_listen$2=listen(sockopen_unix$$1$$sock, 512);
      if(return_value_listen$2 == -1)
      {
        close(sockopen_unix$$1$$sock);
        return -1;
      }

      else
        return sockopen_unix$$1$$sock;
    }
  }
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// string_is_complete
// file es.c line 612
static signed int string_is_complete(char *buf, signed int size)
{
  signed int i;
  if(!((signed int)buf[(signed long int)(size + -1)] == 13))
  {
    if((signed int)buf[(signed long int)(size + -1)] == 10)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    i = size - 2;
    for( ; i >= 0; i = i - 1)
    {
      if((signed int)buf[(signed long int)i] == 125)
        return 1;

      if((signed int)buf[(signed long int)i] == 123)
        return 0;

    }
    return 1;
  }
}

// synth_open
// file fs.c line 347
struct synth_struct * synth_open(void *context, char * (*lookup)(void *, const char *))
{
  struct synth_struct *s;
  char *language;
  language=lookup(context, "language");
  signed int langi;
  debug_fp = stderr;
  if(language == ((char *)NULL))
    language = "english";

  if(ref_count == 0)
  {
    unlink("log");
    flite_init();
    v=register_cmu_us_kal((const char *)(void *)0);
    pthread_attr_init(&ta);
    pthread_mutexattr_init(&mt_attr);
    pthread_mutex_init(&text_mutex, &mt_attr);
    pthread_cond_init(&text_condition, (const union anonymous$3 *)(void *)0);
    text_thread_active = 0;
    text_thread_cancel = 0;
    text_size = 4096;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)text_size);
    text = (char *)return_value_malloc$1;
    text_synthpos = 0;
    text_tail = text_synthpos;
    text_head = text_tail;
    wave_thread_active = 0;
    ac_size = 64;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)ac_size * sizeof(struct anonymous$13) /*16ul*/ );
    ac = (struct anonymous$13 *)return_value_malloc$2;
    ac_synthpos = 0;
    ac_tail = ac_synthpos;
    ac_head = ac_tail;
    if(text == ((char *)NULL) || ac == ((struct anonymous$13 *)NULL))
      return (struct synth_struct *)(void *)0;

    pthread_mutex_init(&wave_mutex, &mt_attr);
    pthread_cond_init(&wave_condition, (const union anonymous$3 *)(void *)0);
    time_left = (float)0;
  }

  ref_count = ref_count + 1;
  signed int return_value_strcasecmp$4;
  return_value_strcasecmp$4=strcasecmp(language, "english");
  signed int return_value_strcasecmp$3;
  if(return_value_strcasecmp$4 == 0)
  {
    langi = 0;
    s = &state[(signed long int)langi];
  }

  else
  {
    return_value_strcasecmp$3=strcasecmp(language, "german");
    if(return_value_strcasecmp$3 == 0)
    {
      langi = 1;
      s = &state[(signed long int)langi];
    }

    else
    {
      langi = -1;
      s = (struct synth_struct *)(void *)0;
    }
  }
  if(!(s == ((struct synth_struct *)NULL)))
  {
    if(s->state->initialized == 0)
    {
      s->state->param[(signed long int)S_SPEED] = 1000;
      s->state->param[(signed long int)S_PITCH] = 1000;
      s->state->param[(signed long int)S_VOLUME] = 1000;
      s->state->initialized = 1;
    }

  }

  return s;
}

// synthesize
// file fs.c line 654
static void * synthesize(void *s)
{
  struct cst_wave_struct *wptr = (struct cst_wave_struct *)(void *)0;
  signed int command;
  signed int *sparam = ((struct synth_struct *)s)->state->param;
  signed int freq;
  signed int dur;
  signed int vol;
  signed int return_value_sscanf$1;
  signed int tmp_post$3;
  while((_Bool)1)
  {
    signed int playlen;
    signed int skip;
    pthread_mutex_lock(&wave_mutex); //added mutex
    pthread_mutex_lock(&text_mutex);
    while((_Bool)1)
    {
      if(!(text[(signed long int)text_head] == 0))
      {
        if(!(time_left > 30.000000f) || !(ac_tail + -ac_head >= 6))
          goto __CPROVER_DUMP_L4;

      }

      text_thread_testcancel();
      pthread_cond_wait(&text_condition, &text_mutex);
    }

  __CPROVER_DUMP_L4:
    ;
    text_thread_testcancel();
    unsigned long int command_length;
    command_length=strlen(text + (signed long int)text_head);
    /* assertion command_length < text_tail - text_head */
    assert(command_length < (unsigned long int)(text_tail - text_head));
    const signed long int command_length$array_size0 = (signed long int)(command_length + (unsigned long int)1);
    char synthesize$$1$$1$$buf[command_length$array_size0];
    strcpy(synthesize$$1$$1$$buf, text + (signed long int)text_head);
    pthread_mutex_unlock(&text_mutex);
    pthread_mutex_unlock(&wave_mutex); //added mutex
    command = (signed int)synthesize$$1$$1$$buf[(signed long int)0];
    switch(command)
    {
      case 1:
      {
        wptr=flite_text_to_wave(synthesize$$1$$1$$buf + (signed long int)1, v);
        break;
      }
      case 2:
      {
        return_value_sscanf$1=sscanf(synthesize$$1$$1$$buf + (signed long int)1, "%d %d %d", &freq, &dur, &vol);
        if(!(return_value_sscanf$1 == 3))
          break;

        wptr=generate_tone(freq, dur, vol);
        break;
      }
      default:
        return (void *)0;
    }
    determine_playlen(sparam[(signed long int)S_SPEED], wptr, command, &playlen, &skip);
    pthread_mutex_lock(&text_mutex); //added mutex
    pthread_mutex_lock(&wave_mutex);
    if(ac_size == 1 + ac_tail)
    {
      ac_size = ac_size << 1;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)ac, (unsigned long int)ac_size * sizeof(struct anonymous$13) /*16ul*/ );
      ac = (struct anonymous$13 *)return_value_realloc$2;
      if(ac == ((struct anonymous$13 *)NULL))
      {
        fprintf(stderr, "Out of memory, ac_size=%d\n", ac_size);
        exit(1);
      }

    }

    (ac + (signed long int)ac_tail)->type = (enum anonymous$12)command;
    tmp_post$3 = ac_tail;
    ac_tail = ac_tail + 1;
    (ac + (signed long int)tmp_post$3)->data = (void *)wptr;
    pthread_mutex_lock(&text_mutex);
    time_left = time_left + (float)playlen / (float)wptr->sample_rate;
    if(!(text_head >= text_synthpos))
    {
      ac_synthpos = ac_tail;
      pthread_cond_signal(&wave_condition);
    }

    pthread_mutex_unlock(&wave_mutex);
    pthread_mutex_unlock(&wave_mutex); //added mutex
    text_head = text_head + (signed int)(command_length + (unsigned long int)1);
    if(text_head == text_tail)
      reset_text_buffer();

    else
      if(!(text_size >> 1 >= text_head))
      {
        memcpy((void *)text, (const void *)(text + (signed long int)text_head), (unsigned long int)((text_tail - text_head) + 1));
        text_tail = text_tail - text_head;
        if(text_synthpos >= 1)
          text_synthpos = text_synthpos - text_head;

        text_head = 0;
      }

    pthread_mutex_unlock(&text_mutex);
  }
  /* assertion 0 */
  assert(0 != 0);
}

// terror
// file es.c line 684
void terror(const char *s)
{
  signed int errnum;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errnum = *return_value___errno_location$1;
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(errnum);
  fprintf(stderr, "%s: %s\n", s, return_value_strerror$2);
  exit(errnum);
}

// text_thread_testcancel
// file fs.c line 643
static inline void text_thread_testcancel()
{
  if(!(text_thread_cancel == 0))
  {
    pthread_mutex_unlock(&text_mutex);
    text_thread_cancel = 0;
    pthread_exit(NULL);
  }

}

// text_unlock
// file fs.c line 307
static void text_unlock(void *function_name)
{
  pthread_mutex_unlock(&text_mutex);
}

// verify_language
// file fs.c line 463
static void verify_language(struct synth_struct *s)
{
  signed int value = -1;
}

// wave_unlock
// file fs.c line 286
static void wave_unlock(void *function_name)
{
  pthread_mutex_unlock(&wave_mutex);
}

