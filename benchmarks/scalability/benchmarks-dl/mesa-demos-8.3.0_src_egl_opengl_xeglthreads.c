// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'visualid'||S32'screen'||S32'depth'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'colormap_size'||S32'bits_per_rgb'|]
// file /usr/include/X11/Xutil.h line 287
struct anonymous$35;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$38;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$23;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$40;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$42;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$36;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$29;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$31;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$32;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$9;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$8;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$12;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$13;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$14;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$21;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$18;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$17;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$16;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$24;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$15;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous$22;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$11;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$20;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$25;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$1;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$30;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$6;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$28;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$10;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$19;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$7;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$41;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$26;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$27;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$5;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$4;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$3;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$2;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous$0;

// tag-#anon#ST[S32'x'||S32'y'|]
// file /usr/include/X11/Xutil.h line 88
struct anonymous$44;

// tag-#anon#ST[S64'flags'||S32'x'||S32'y'||S32'width'||S32'height'||S32'min_width'||S32'min_height'||S32'max_width'||S32'max_height'||S32'width_inc'||S32'height_inc'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'min_aspect'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'max_aspect'||S32'base_width'||S32'base_height'||S32'win_gravity'||U32'$pad0'|]
// file /usr/include/X11/Xutil.h line 81
struct anonymous$45;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'$pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous$34;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous$43;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$37;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$33;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$39;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-winthread
// file xeglthreads.c line 68
struct winthread;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// Error
// file xeglthreads.c line 101
static void Error(const char *msg);
// MakeNewTexture
// file xeglthreads.c line 118
static void MakeNewTexture(struct winthread *wt);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous$42 *, signed int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous$42 *, unsigned long int, struct anonymous$34 *);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XDisplayName
// file /usr/include/X11/Xlib.h line 1515
extern char * XDisplayName(const char *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous$35 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous$35 *, signed int *);
// XInitThreads
// file /usr/include/X11/Xlib.h line 1734
extern signed int XInitThreads(void);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous$2 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XSetNormalHints
// file /usr/include/X11/Xutil.h line 596
extern signed int XSetNormalHints(struct _XDisplay *, unsigned long int, struct anonymous$45 *);
// XSetStandardProperties
// file /usr/include/X11/Xutil.h line 617
extern signed int XSetStandardProperties(struct _XDisplay *, unsigned long int, const char *, const char *, unsigned long int, char **, signed int, struct anonymous$45 *);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// clean_up
// file xeglthreads.c line 576
static void clean_up(void);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// create_window
// file xeglthreads.c line 461
static void create_window(struct winthread *wt, void *shareCtx);
// draw_loop
// file xeglthreads.c line 244
static void draw_loop(struct winthread *wt);
// draw_object
// file xeglthreads.c line 163
static void draw_object(void);
// eglBindAPI
// file /usr/include/EGL/egl.h line 202
unsigned int eglBindAPI(unsigned int);
// eglChooseConfig
// file /usr/include/EGL/egl.h line 121
unsigned int eglChooseConfig(void *, const signed int *, void **, signed int, signed int *);
// eglCreateContext
// file /usr/include/EGL/egl.h line 123
void * eglCreateContext(void *, void *, void *, const signed int *);
// eglCreateWindowSurface
// file /usr/include/EGL/egl.h line 126
void * eglCreateWindowSurface(void *, void *, unsigned long int, const signed int *);
// eglDestroyContext
// file /usr/include/EGL/egl.h line 127
unsigned int eglDestroyContext(void *, void *);
// eglGetConfigAttrib
// file /usr/include/EGL/egl.h line 129
unsigned int eglGetConfigAttrib(void *, void *, signed int, signed int *);
// eglGetCurrentContext
// file /usr/include/EGL/egl.h line 235
void * eglGetCurrentContext(void);
// eglGetDisplay
// file /usr/include/EGL/egl.h line 133
void * eglGetDisplay(struct _XDisplay *);
// eglInitialize
// file /usr/include/EGL/egl.h line 136
unsigned int eglInitialize(void *, signed int *, signed int *);
// eglMakeCurrent
// file /usr/include/EGL/egl.h line 137
unsigned int eglMakeCurrent(void *, void *, void *, void *);
// eglSwapBuffers
// file /usr/include/EGL/egl.h line 141
unsigned int eglSwapBuffers(void *, void *);
// eglTerminate
// file /usr/include/EGL/egl.h line 142
unsigned int eglTerminate(void *);
// event_loop
// file xeglthreads.c line 369
static void event_loop(struct _XDisplay *dpy);
// event_loop_multi
// file xeglthreads.c line 428
static void event_loop_multi(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glClear
// file /usr/include/GL/gl.h line 752
void glClear(unsigned int);
// glColor3f
// file /usr/include/GL/gl.h line 992
void glColor3f(float, float, float);
// glDisable
// file /usr/include/GL/gl.h line 798
void glDisable(unsigned int);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glFrustum
// file /usr/include/GL/gl.h line 872
void glFrustum(double, double, double, double, double, double);
// glGetString
// file /usr/include/GL/gl.h line 831
const unsigned char * glGetString(unsigned int);
// glGetTexLevelParameteriv
// file /usr/include/GL/gl.h line 1284
void glGetTexLevelParameteriv(unsigned int, signed int, unsigned int, signed int *);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glPopMatrix
// file /usr/include/GL/gl.h line 881
void glPopMatrix(void);
// glPushMatrix
// file /usr/include/GL/gl.h line 879
void glPushMatrix(void);
// glRotatef
// file /usr/include/GL/gl.h line 893
void glRotatef(float, float, float, float);
// glScalef
// file /usr/include/GL/gl.h line 897
void glScalef(float, float, float);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glTexSubImage2D
// file /usr/include/GL/gl.h line 1330
void glTexSubImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTranslatef
// file /usr/include/GL/gl.h line 900
void glTranslatef(float, float, float);
// glVertex3f
// file /usr/include/GL/gl.h line 940
void glVertex3f(float, float, float);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// keypress
// file xeglthreads.c line 322
static void keypress(union _XEvent *event, struct winthread *wt);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$33 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$33 *, const union anonymous$37 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$33 *, union anonymous$39 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$39 *, const union anonymous$37 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$39 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$39 *);
// resize
// file xeglthreads.c line 230
static void resize(struct winthread *wt, signed int w, signed int h);
// signal_redraw
// file xeglthreads.c line 109
static void signal_redraw(void);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// thread_function
// file xeglthreads.c line 564
static void * thread_function(void *p);
// usage
// file xeglthreads.c line 593
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);

struct anonymous$35
{
  // visual
  struct anonymous$42 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous$38
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$42 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$23
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$40 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$38 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$40
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$42
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$36
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$42 *visuals;
};

struct anonymous$29
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$9
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$8
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$12
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$13
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$14
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$21
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$18
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$17
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$16
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$24
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$15
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$11
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$20
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$1
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$6
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$10
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$19
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$7
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$43
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$43 data;
};

struct anonymous$5
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$4
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$3
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$2
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$0
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$44
{
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$45
{
  // flags
  signed long int flags;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // min_width
  signed int min_width;
  // min_height
  signed int min_height;
  // max_width
  signed int max_width;
  // max_height
  signed int max_height;
  // width_inc
  signed int width_inc;
  // height_inc
  signed int height_inc;
  // min_aspect
  struct anonymous$44 min_aspect;
  // max_aspect
  struct anonymous$44 max_aspect;
  // base_width
  signed int base_width;
  // base_height
  signed int base_height;
  // win_gravity
  signed int win_gravity;
};

struct anonymous$34
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

union anonymous$37
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$33
{
  // __data
  struct anonymous$36 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$39
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$1 xany;
  // xkey
  struct anonymous$2 xkey;
  // xbutton
  struct anonymous$3 xbutton;
  // xmotion
  struct anonymous$4 xmotion;
  // xcrossing
  struct anonymous$5 xcrossing;
  // xfocus
  struct anonymous$6 xfocus;
  // xexpose
  struct anonymous$7 xexpose;
  // xgraphicsexpose
  struct anonymous$8 xgraphicsexpose;
  // xnoexpose
  struct anonymous$9 xnoexpose;
  // xvisibility
  struct anonymous$10 xvisibility;
  // xcreatewindow
  struct anonymous$11 xcreatewindow;
  // xdestroywindow
  struct anonymous$12 xdestroywindow;
  // xunmap
  struct anonymous$13 xunmap;
  // xmap
  struct anonymous$14 xmap;
  // xmaprequest
  struct anonymous$15 xmaprequest;
  // xreparent
  struct anonymous$16 xreparent;
  // xconfigure
  struct anonymous$17 xconfigure;
  // xgravity
  struct anonymous$18 xgravity;
  // xresizerequest
  struct anonymous$19 xresizerequest;
  // xconfigurerequest
  struct anonymous$20 xconfigurerequest;
  // xcirculate
  struct anonymous$21 xcirculate;
  // xcirculaterequest
  struct anonymous$22 xcirculaterequest;
  // xproperty
  struct anonymous$41 xproperty;
  // xselectionclear
  struct anonymous$0 xselectionclear;
  // xselectionrequest
  struct anonymous$24 xselectionrequest;
  // xselection
  struct anonymous$25 xselection;
  // xcolormap
  struct anonymous$26 xcolormap;
  // xclient
  struct anonymous$27 xclient;
  // xmapping
  struct anonymous$28 xmapping;
  // xerror
  struct anonymous$29 xerror;
  // xkeymap
  struct anonymous$30 xkeymap;
  // xgeneric
  struct anonymous$31 xgeneric;
  // xcookie
  struct anonymous$32 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct winthread
{
  // Dpy
  struct _XDisplay *Dpy;
  // Index
  signed int Index;
  // Thread
  unsigned long int Thread;
  // Win
  unsigned long int Win;
  // Display
  void *Display;
  // Context
  void *Context;
  // Surface
  void *Surface;
  // Angle
  float Angle;
  // WinWidth
  signed int WinWidth;
  // WinHeight
  signed int WinHeight;
  // NewSize
  unsigned char NewSize;
  // Initialized
  unsigned char Initialized;
  // MakeNewTexture
  unsigned char MakeNewTexture;
};


// Animate
// file xeglthreads.c line 93
static unsigned char Animate = (unsigned char)1;
// CondMutex
// file xeglthreads.c line 97
static union anonymous$39 CondMutex;
// CondVar
// file xeglthreads.c line 96
static union anonymous$33 CondVar;
// ExitFlag
// file xeglthreads.c line 87
static volatile unsigned char ExitFlag = (volatile unsigned char)0;
// Locking
// file xeglthreads.c line 90
static unsigned char Locking = (unsigned char)0;
// MultiDisplays
// file xeglthreads.c line 89
static unsigned char MultiDisplays = (unsigned char)0;
// Mutex
// file xeglthreads.c line 95
static union anonymous$39 Mutex;
// NumWinThreads
// file xeglthreads.c line 86
static signed int NumWinThreads = 0;
// TexObj
// file xeglthreads.c line 92
static unsigned int TexObj = (unsigned int)12;
// Texture
// file xeglthreads.c line 91
static unsigned char Texture = (unsigned char)0;
// WinThreads
// file xeglthreads.c line 85
static struct winthread WinThreads[100l];
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// Error
// file xeglthreads.c line 101
static void Error(const char *msg)
{
  fprintf(stderr, "Error: %s\n", msg);
  exit(1);
}

// MakeNewTexture
// file xeglthreads.c line 118
static void MakeNewTexture(struct winthread *wt)
{
  float image[128l][128l][4l];
  signed int width;
  signed int i;
  signed int j = 0;
  static float step = (float)0.0;
  for( ; !(j >= 128); j = j + 1)
  {
    i = 0;
    for( ; !(i >= 128); i = i + 1)
    {
      float dt = (float)((5.0 * ((double)j - 0.5 * (double)128)) / (double)128);
      float ds = (float)((5.0 * ((double)i - 0.5 * (double)128)) / (double)128);
      float r = dt * dt + ds * ds + step;
      double return_value_cos$1;
      return_value_cos$1=cos((double)r);
      image[(signed long int)j][(signed long int)i][(signed long int)2] = (float)(0.75 + 0.25 * return_value_cos$1);
      image[(signed long int)j][(signed long int)i][(signed long int)1] = image[(signed long int)j][(signed long int)i][(signed long int)2];
      image[(signed long int)j][(signed long int)i][(signed long int)0] = image[(signed long int)j][(signed long int)i][(signed long int)1];
      image[(signed long int)j][(signed long int)i][(signed long int)3] = (float)1.0;
    }
  }
  step = step + (float)0.5;
  glBindTexture((unsigned int)0x0DE1, TexObj);
  glGetTexLevelParameteriv((unsigned int)0x0DE1, 0, (unsigned int)0x1000, &width);
  if(!(width == 0))
  {
    /* assertion width == 128 */
    assert(width == 128);
    glTexSubImage2D((unsigned int)0x0DE1, 0, 0, 0, 128, 128, (unsigned int)0x1908, (unsigned int)0x1406, (const void *)image);
  }

  else
  {
    glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
    glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
    glTexImage2D((unsigned int)0x0DE1, 0, 0x1908, 128, 128, 0, (unsigned int)0x1908, (unsigned int)0x1406, (const void *)image);
  }
}

// clean_up
// file xeglthreads.c line 576
static void clean_up(void)
{
  signed int i = 0;
  for( ; !(i >= NumWinThreads); i = i + 1)
    pthread_join(WinThreads[(signed long int)i].Thread, (void **)(void *)0);
  i = 0;
  for( ; !(i >= NumWinThreads); i = i + 1)
  {
    eglDestroyContext(WinThreads[(signed long int)i].Display, WinThreads[(signed long int)i].Context);
    XDestroyWindow(WinThreads[(signed long int)i].Dpy, WinThreads[(signed long int)i].Win);
  }
}

// create_window
// file xeglthreads.c line 461
static void create_window(struct winthread *wt, void *shareCtx)
{
  unsigned long int win;
  void *ctx;
  void *surf;
  signed int attribs[11l] = { 0x3024, 1, 0x3023, 1, 0x3022, 1, 0x3025, 1, 0x3040, 0x0008, 0x3038 };
  void *config;
  signed int num_configs;
  signed int vid;
  signed int scrnum;
  struct anonymous$34 attr;
  unsigned long int mask;
  unsigned long int root;
  struct anonymous$35 *visinfo;
  struct anonymous$35 visTemplate;
  signed int num_visuals;
  signed int width = 160;
  signed int height = 160;
  signed int xpos = (wt->Index % 8) * (width + 10);
  signed int ypos = (wt->Index / 8) * (width + 20);
  scrnum = ((struct anonymous$23 *)wt->Dpy)->default_screen;
  root = (&((struct anonymous$23 *)wt->Dpy)->screens[(signed long int)scrnum])->root;
  unsigned int return_value_eglChooseConfig$1;
  return_value_eglChooseConfig$1=eglChooseConfig(wt->Display, attribs, &config, 1, &num_configs);
  if(num_configs == 0 || return_value_eglChooseConfig$1 == 0u)
    Error("Unable to choose an EGL config");

  /* assertion config */
  assert(config != NULL);
  /* assertion num_configs > 0 */
  assert(num_configs > 0);
  unsigned int return_value_eglGetConfigAttrib$2;
  return_value_eglGetConfigAttrib$2=eglGetConfigAttrib(wt->Display, config, 0x302E, &vid);
  if(return_value_eglGetConfigAttrib$2 == 0u)
    Error("Unable to get visual id of EGL config\n");

  visTemplate.visualid = (unsigned long int)vid;
  visinfo=XGetVisualInfo(wt->Dpy, (signed long int)0x1, &visTemplate, &num_visuals);
  if(visinfo == ((struct anonymous$35 *)NULL))
    Error("Unable to find RGB, Z, double-buffered visual");

  attr.background_pixel = (unsigned long int)0;
  attr.border_pixel = (unsigned long int)0;
  attr.colormap=XCreateColormap(wt->Dpy, root, visinfo->visual, 0);
  attr.event_mask = 1L << 17 | 1L << 15 | 1L << 0;
  mask = (unsigned long int)(1L << 1 | 1L << 3 | 1L << 13 | 1L << 11);
  win=XCreateWindow(wt->Dpy, root, xpos, ypos, (unsigned int)width, (unsigned int)height, (unsigned int)0, visinfo->depth, (unsigned int)1, visinfo->visual, mask, &attr);
  if(win == 0ul)
    Error("Couldn't create window");

  XFree((void *)visinfo);
  struct anonymous$45 sizehints;
  sizehints.x = xpos;
  sizehints.y = ypos;
  sizehints.width = width;
  sizehints.height = height;
  sizehints.flags = 1L << 1 | 1L << 0;
  XSetNormalHints(wt->Dpy, win, &sizehints);
  XSetStandardProperties(wt->Dpy, win, "xeglthreads", "xeglthreads", (unsigned long int)0L, (char **)(void *)0, 0, &sizehints);
  eglBindAPI((unsigned int)0x30A2);
  ctx=eglCreateContext(wt->Display, config, shareCtx, (const signed int *)(void *)0);
  if(ctx == NULL)
    Error("Couldn't create EGL context");

  surf=eglCreateWindowSurface(wt->Display, config, win, (const signed int *)(void *)0);
  if(surf == NULL)
    Error("Couldn't create EGL surface");

  XMapWindow(wt->Dpy, win);
  XSync(wt->Dpy, 0);
  wt->Win = win;
  wt->Context = ctx;
  wt->Surface = surf;
  wt->Angle = (float)0.0;
  wt->WinWidth = width;
  wt->WinHeight = height;
  wt->NewSize = (unsigned char)1;
}

// draw_loop
// file xeglthreads.c line 244
static void draw_loop(struct winthread *wt)
{
  while(ExitFlag == 0)
  {
    if(!(Locking == 0))
    {
      pthread_mutex_lock(&Mutex);

      pthread_mutex_lock(&CondMutex); // introduced
      pthread_mutex_lock(&CondMutex); // introduced
    }

    if(wt->Initialized == 0)
    {
      eglMakeCurrent(wt->Display, wt->Surface, wt->Surface, wt->Context);
      const unsigned char *return_value_glGetString$1;
      return_value_glGetString$1=glGetString((unsigned int)0x1F01);
      printf("xeglthreads: %d: GL_RENDERER = %s\n", wt->Index, (char *)return_value_glGetString$1);
      if(!(Texture == 0))
        MakeNewTexture(wt);

      wt->Initialized = (unsigned char)1;
    }

    if(!(Locking == 0))
      pthread_mutex_unlock(&Mutex);

    eglBindAPI((unsigned int)0x30A2);
    void *return_value_eglGetCurrentContext$3;
    return_value_eglGetCurrentContext$3=eglGetCurrentContext();
    if(!(return_value_eglGetCurrentContext$3 == wt->Context))
    {
      void *return_value_eglGetCurrentContext$2;
      return_value_eglGetCurrentContext$2=eglGetCurrentContext();
      printf("xeglthreads: current context %p != %p\n", return_value_eglGetCurrentContext$2, wt->Context);
    }

    glEnable((unsigned int)0x0B71);
    if(!(wt->NewSize == 0))
    {
      float w = (float)wt->WinWidth / (float)wt->WinHeight;
      glViewport(0, 0, wt->WinWidth, wt->WinHeight);
      glMatrixMode((unsigned int)0x1701);
      glLoadIdentity();
      glFrustum((double)-w, (double)w, -1.0, 1.0, 1.5, (double)10);
      glMatrixMode((unsigned int)0x1700);
      glLoadIdentity();
      glTranslatef((float)0, (float)0, (float)-2.5);
      wt->NewSize = (unsigned char)0;
    }

    if(!(wt->MakeNewTexture == 0))
    {
      MakeNewTexture(wt);
      wt->MakeNewTexture = (unsigned char)0;
    }

    glClear((unsigned int)(0x00004000 | 0x00000100));
    glPushMatrix();
    glRotatef(wt->Angle, (float)0, (float)1, (float)0);
    glRotatef(wt->Angle, (float)1, (float)0, (float)0);
    glScalef((float)0.7, (float)0.7, (float)0.7);
    draw_object();
    glPopMatrix();
    if(!(Locking == 0))
      pthread_mutex_lock(&Mutex);

    eglSwapBuffers(wt->Display, wt->Surface);
    if(!(Locking == 0))
      pthread_mutex_unlock(&Mutex);

    if(!(Animate == 0))
      usleep((unsigned int)5000);

    else
    {
      pthread_mutex_lock(&CondMutex);
      pthread_cond_wait(&CondVar, &CondMutex);
      pthread_mutex_unlock(&CondMutex);
    }
    wt->Angle = wt->Angle + (float)1.0;
  }
  eglMakeCurrent(wt->Display, (void *)0, (void *)0, (void *)0);
}

// draw_object
// file xeglthreads.c line 163
static void draw_object(void)
{
  glPushMatrix();
  glScalef((float)0.75, (float)0.75, (float)0.75);
  glColor3f((float)1, (float)0, (float)0);
  if(!(Texture == 0))
  {
    glBindTexture((unsigned int)0x0DE1, TexObj);
    glEnable((unsigned int)0x0DE1);
  }

  else
    glDisable((unsigned int)0x0DE1);
  glBegin((unsigned int)0x0007);
  glColor3f((float)0, (float)1, (float)1);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)-1, (float)-1, (float)-1);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)-1, (float)1, (float)-1);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)-1, (float)1, (float)1);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)-1, (float)-1, (float)1);
  glColor3f((float)1, (float)0, (float)0);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)1, (float)-1, (float)-1);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)1, (float)1, (float)-1);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)1, (float)1, (float)1);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)1, (float)-1, (float)1);
  glColor3f((float)1, (float)0, (float)1);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)-1, (float)-1, (float)-1);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)1, (float)-1, (float)-1);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)1, (float)-1, (float)1);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)-1, (float)-1, (float)1);
  glColor3f((float)0, (float)1, (float)0);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)-1, (float)1, (float)-1);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)1, (float)1, (float)-1);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)1, (float)1, (float)1);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)-1, (float)1, (float)1);
  glColor3f((float)1, (float)1, (float)0);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)-1, (float)-1, (float)-1);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)1, (float)-1, (float)-1);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)1, (float)1, (float)-1);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)-1, (float)1, (float)-1);
  glColor3f((float)0, (float)0, (float)1);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)-1, (float)-1, (float)1);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)1, (float)-1, (float)1);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)1, (float)1, (float)1);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)-1, (float)1, (float)1);
  glEnd();
  glPopMatrix();
}

// event_loop
// file xeglthreads.c line 369
static void event_loop(struct _XDisplay *dpy)
{
  union _XEvent event;
  signed int i;
  /* assertion !MultiDisplays */
  assert(!(MultiDisplays != 0));
  while(ExitFlag == 0)
  {
    if(!(Locking == 0))
      while((_Bool)1)
      {
        signed int k;
        pthread_mutex_lock(&Mutex);
        k=XPending(dpy);
        if(!(k == 0))
        {
          XNextEvent(dpy, &event);
          pthread_mutex_unlock(&Mutex);
          break;
        }

        pthread_mutex_unlock(&Mutex);
        usleep((unsigned int)5000);
      }

    else
      XNextEvent(dpy, &event);
    switch(event.type)
    {
      case 22:
      {
        i = 0;
        for( ; !(i >= NumWinThreads); i = i + 1)
        {
          struct winthread *wt = &WinThreads[(signed long int)i];
          if(event.xconfigure.window == wt->Win)
          {
            resize(wt, event.xconfigure.width, event.xconfigure.height);
            break;
          }

        }
        break;
      }
      case 2:
      {
        i = 0;
        for( ; !(i >= NumWinThreads); i = i + 1)
        {
          struct winthread *event_loop$$1$$1$$3$$2$$1$$wt = &WinThreads[(signed long int)i];
          if(event.xkey.window == event_loop$$1$$1$$3$$2$$1$$wt->Win)
          {
            keypress(&event, event_loop$$1$$1$$3$$2$$1$$wt);
            break;
          }

        }
      }
      default:
        ;
    }
  }
}

// event_loop_multi
// file xeglthreads.c line 428
static void event_loop_multi(void)
{
  union _XEvent event;
  signed int w = 0;
  /* assertion MultiDisplays */
  assert(MultiDisplays != 0);
  while(ExitFlag == 0)
  {
    struct winthread *wt = &WinThreads[(signed long int)w];
    signed int return_value_XPending$1;
    return_value_XPending$1=XPending(wt->Dpy);
    if(!(return_value_XPending$1 == 0))
    {
      XNextEvent(wt->Dpy, &event);
      switch(event.type)
      {
        case 22:
        {
          resize(wt, event.xconfigure.width, event.xconfigure.height);
          break;
        }
        case 2:
          keypress(&event, wt);
      }
    }

    w = (w + 1) % NumWinThreads;
    usleep((unsigned int)5000);
  }
}

// keypress
// file xeglthreads.c line 322
static void keypress(union _XEvent *event, struct winthread *wt)
{
  char buf[100l];
  unsigned long int keySym;
  struct _XComposeStatus stat;
  XLookupString(&event->xkey, buf, (signed int)sizeof(char [100l]) /*100ul*/ , &keySym, &stat);
  switch(keySym)
  {
    case (unsigned long int)0xff1b:
    {
      if(Animate == 0)
        signal_redraw();

      ExitFlag = (volatile unsigned char)1;
      break;
    }
    case (unsigned long int)0x0074:

    case (unsigned long int)0x0054:
    {
      if(!(Texture == 0))
      {
        wt->MakeNewTexture = (unsigned char)1;
        if(Animate == 0)
          signal_redraw();

      }

      goto __CPROVER_DUMP_L8;
    }
    case (unsigned long int)0x0061:

    case (unsigned long int)0x0041:
    {
      Animate = (unsigned char)!(Animate != 0);
      if(!(Animate == 0))
        signal_redraw();

      goto __CPROVER_DUMP_L8;
    }
    case (unsigned long int)0x0073:

    case (unsigned long int)0x0053:
      if(Animate == 0)
        signal_redraw();

    default:

      __CPROVER_DUMP_L8:
        ;
  }
}

// main
// file xeglthreads.c line 613
signed int main(signed int argc, char **argv)
{
  char *displayName = (char *)(void *)0;
  signed int numThreads = 2;
  struct _XDisplay *dpy = (struct _XDisplay *)(void *)0;
  void **egl_dpy = (void **)(void *)0;
  signed int i;
  signed int threadStat;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(argc == 1)
    usage();

  else
  {
    signed int main$$1$$2$$i = 1;
    for( ; !(main$$1$$2$$i >= argc); main$$1$$2$$i = main$$1$$2$$i + 1)
    {
      signed int return_value_strcmp$5;
      return_value_strcmp$5=strcmp(argv[(signed long int)main$$1$$2$$i], "-display");
      if(return_value_strcmp$5 == 0 && !(1 + main$$1$$2$$i >= argc))
      {
        displayName = argv[(signed long int)(main$$1$$2$$i + 1)];
        main$$1$$2$$i = main$$1$$2$$i + 1;
      }

      else
      {
        return_value_strcmp$4=strcmp(argv[(signed long int)main$$1$$2$$i], "-p");
        if(return_value_strcmp$4 == 0)
          MultiDisplays = (unsigned char)1;

        else
        {
          return_value_strcmp$3=strcmp(argv[(signed long int)main$$1$$2$$i], "-l");
          if(return_value_strcmp$3 == 0)
            Locking = (unsigned char)1;

          else
          {
            return_value_strcmp$2=strcmp(argv[(signed long int)main$$1$$2$$i], "-t");
            if(return_value_strcmp$2 == 0)
              Texture = (unsigned char)1;

            else
            {
              return_value_strcmp$1=strcmp(argv[(signed long int)main$$1$$2$$i], "-n");
              if(return_value_strcmp$1 == 0 && !(1 + main$$1$$2$$i >= argc))
              {
                numThreads=atoi(argv[(signed long int)(main$$1$$2$$i + 1)]);
                if(!(numThreads >= 1))
                  numThreads = 1;

                else
                  if(numThreads >= 101)
                    numThreads = 100;

                main$$1$$2$$i = main$$1$$2$$i + 1;
              }

              else
              {
                usage();
                exit(1);
              }
            }
          }
        }
      }
    }
  }
  if(!(Locking == 0))
    printf("xeglthreads: Using explicit locks around Xlib calls.\n");

  else
    printf("xeglthreads: No explict locking.\n");
  if(!(MultiDisplays == 0))
    printf("xeglthreads: Per-thread display connections.\n");

  else
    printf("xeglthreads: Single display connection.\n");
  if(MultiDisplays == 0)
  {
    if(Locking == 0)
    {
      threadStat=XInitThreads();
      if(!(threadStat == 0))
        printf("XInitThreads() returned %d (success)\n", (signed int)threadStat);

      else
        printf("XInitThreads() returned 0 (failure- this program may fail)\n");
    }

    dpy=XOpenDisplay(displayName);
    if(dpy == ((struct _XDisplay *)NULL))
    {
      char *return_value_XDisplayName$6;
      return_value_XDisplayName$6=XDisplayName(displayName);
      fprintf(stderr, "Unable to open display %s\n", return_value_XDisplayName$6);
      return -1;
    }

    void *return_value_eglGetDisplay$7;
    return_value_eglGetDisplay$7=eglGetDisplay(dpy);
    egl_dpy = (void **)return_value_eglGetDisplay$7;
    if(egl_dpy == ((void **)NULL))
    {
      fprintf(stderr, "Unable to get EGL display\n");
      XCloseDisplay(dpy);
      return -1;
    }

    unsigned int return_value_eglInitialize$8;
    return_value_eglInitialize$8=eglInitialize((void *)egl_dpy, (signed int *)(void *)0, (signed int *)(void *)0);
    if(return_value_eglInitialize$8 == 0u)
    {
      fprintf(stderr, "Unable to initialize EGL display\n");
      return -1;
    }

  }

  pthread_mutex_init(&Mutex, (const union anonymous$37 *)(void *)0);
  pthread_mutex_init(&CondMutex, (const union anonymous$37 *)(void *)0);
  pthread_cond_init(&CondVar, (const union anonymous$37 *)(void *)0);
  printf("xeglthreads: creating windows\n");
  NumWinThreads = numThreads;
  i = 0;
  void *tmp_if_expr$10;
  for( ; !(i >= numThreads); i = i + 1)
  {
    void *share;
    if(!(MultiDisplays == 0))
    {
      WinThreads[(signed long int)i].Dpy=XOpenDisplay(displayName);
      /* assertion WinThreads[i].Dpy */
      assert(WinThreads[(signed long int)i].Dpy != ((struct _XDisplay *)NULL));
      WinThreads[(signed long int)i].Display=eglGetDisplay(WinThreads[(signed long int)i].Dpy);
      unsigned int return_value_eglInitialize$9;
      return_value_eglInitialize$9=eglInitialize(WinThreads[(signed long int)i].Display, (signed int *)(void *)0, (signed int *)(void *)0);
      /* assertion eglInitialize(WinThreads[i].Display, ((void *)0), ((void *)0)) */
      assert(return_value_eglInitialize$9 != 0u);
    }

    else
    {
      WinThreads[(signed long int)i].Dpy = dpy;
      WinThreads[(signed long int)i].Display = (void *)egl_dpy;
    }
    WinThreads[(signed long int)i].Index = i;
    WinThreads[(signed long int)i].Initialized = (unsigned char)0;
    if(i >= 1 && !(Texture == 0))
      tmp_if_expr$10 = WinThreads[(signed long int)0].Context;

    else
      tmp_if_expr$10 = NULL;
    share = tmp_if_expr$10;
    create_window(&WinThreads[(signed long int)i], share);
  }
  printf("xeglthreads: creating threads\n");
  i = 0;
  for( ; !(i >= numThreads); i = i + 1)
  {
    pthread_create(&WinThreads[(signed long int)i].Thread, (const union pthread_attr_t *)(void *)0, thread_function, (void *)&WinThreads[(signed long int)i]);
    printf("xeglthreads: Created thread %p\n", (void *)WinThreads[(signed long int)i].Thread);
  }
  if(!(MultiDisplays == 0))
    event_loop_multi();

  else
    event_loop(dpy);
  clean_up();
  if(!(MultiDisplays == 0))
  {
    i = 0;
    for( ; !(i >= numThreads); i = i + 1)
    {
      eglTerminate(WinThreads[(signed long int)i].Display);
      XCloseDisplay(WinThreads[(signed long int)i].Dpy);
    }
  }

  else
  {
    eglTerminate((void *)egl_dpy);
    XCloseDisplay(dpy);
  }
  return 0;
}

// resize
// file xeglthreads.c line 230
static void resize(struct winthread *wt, signed int w, signed int h)
{
  wt->NewSize = (unsigned char)1;
  wt->WinWidth = w;
  wt->WinHeight = h;
  if(Animate == 0)
    signal_redraw();

}

// signal_redraw
// file xeglthreads.c line 109
static void signal_redraw(void)
{
  pthread_mutex_lock(&CondMutex);

  pthread_mutex_lock(&Mutex); // introduced
  pthread_mutex_unlock(&Mutex); // introduced

  pthread_cond_broadcast(&CondVar);
  pthread_mutex_unlock(&CondMutex);
}

// thread_function
// file xeglthreads.c line 564
static void * thread_function(void *p)
{
  struct winthread *wt = (struct winthread *)p;
  draw_loop(wt);
  return (void *)0;
}

// usage
// file xeglthreads.c line 593
static void usage(void)
{
  printf("xeglthreads: test of EGL/GL thread safety (any key = exit)\n");
  printf("Usage:\n");
  printf("  xeglthreads [options]\n");
  printf("Options:\n");
  printf("   -display DISPLAYNAME  Specify display string\n");
  printf("   -n NUMTHREADS  Number of threads to create\n");
  printf("   -p  Use a separate display connection for each thread\n");
  printf("   -l  Use application-side locking\n");
  printf("   -t  Enable texturing\n");
  printf("Keyboard:\n");
  printf("   Esc  Exit\n");
  printf("   t    Change texture image (requires -t option)\n");
  printf("   a    Toggle animation\n");
  printf("   s    Step rotation (when not animating)\n");
}

