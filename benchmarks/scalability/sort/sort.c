/* Generated by Frama-C */
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef unsigned int wint_t;
typedef long __blkcnt_t;
typedef long __blksize_t;
typedef long _off_t;
typedef int __pid_t;
typedef short __dev_t;
typedef unsigned short __uid_t;
typedef unsigned short __gid_t;
typedef unsigned short __ino_t;
typedef __uint32_t __mode_t;
typedef _off_t __off_t;
typedef long _fpos_t;
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
typedef int __nl_item;
typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef __uint32_t uint32_t;
typedef __int64_t int64_t;
typedef __uint64_t uint64_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef unsigned long __sigset_t;
typedef __suseconds_t suseconds_t;
typedef long time_t;
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
typedef __sigset_t sigset_t;
typedef unsigned int u_int;
typedef __blkcnt_t blkcnt_t;
typedef __blksize_t blksize_t;
typedef __ino_t ino_t;
typedef __off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;
typedef __pid_t pid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __int64_t sbintime_t;
typedef __uint32_t pthread_t;
typedef __uint32_t pthread_mutex_t;
typedef __uint32_t pthread_cond_t;
struct bintime {
   time_t sec ;
   uint64_t frac ;
};
typedef unsigned int __ULong;
typedef int _LOCK_RECURSIVE_T;
typedef _LOCK_RECURSIVE_T _flock_t;
struct _reent;
struct __locale_t;
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_read)(struct _reent *, void *, char *, int ) ;
   int (*_write)(struct _reent *, void *, char const *, int ) ;
   _fpos_t (*_seek)(struct _reent *, void *, _fpos_t , int ) ;
   int (*_close)(struct _reent *, void *) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   _off_t _offset ;
   struct _reent *_data ;
   _flock_t _lock ;
   _mbstate_t _mbstate ;
   int _flags2 ;
};
typedef struct __sFILE __FILE;
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
struct __anonstruct__reent_9 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
   int _h_errno ;
};
struct __anonstruct__unused_10 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
union __anonunion__new_8 {
   struct __anonstruct__reent_9 _reent ;
   struct __anonstruct__unused_10 _unused ;
};
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _unspecified_locale_info ;
   struct __locale_t *_locale ;
   int __sdidinit ;
   void (*__cleanup)(struct _reent *) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_8 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
typedef struct __locale_t *locale_t;
typedef void (*_sig_func_ptr)(int );
struct sigaction {
   void (*sa_handler)(int ) ;
   sigset_t sa_mask ;
   int sa_flags ;
};
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
   long st_spare4[2] ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_p_sign_posn ;
};
enum __anonenum_24 {
    PLURAL_REDUCER = 1000000
};
enum __anonenum_25 {
    DEFAULT_MXFAST = ((unsigned int)64 * sizeof(size_t)) / (unsigned int)4
};
typedef __FILE FILE;
enum __anonenum_27 {
    GETOPT_HELP_CHAR = (-0x7f - 1) - 2,
    GETOPT_VERSION_CHAR = (-0x7f - 1) - 3
};
struct infomap {
   char const *program ;
   char const *node ;
};
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    shell_escape_quoting_style = 3,
    shell_escape_always_quoting_style = 4,
    c_quoting_style = 5,
    c_maybe_quoting_style = 6,
    escape_quoting_style = 7,
    locale_quoting_style = 8,
    clocale_quoting_style = 9,
    custom_quoting_style = 10
};
enum __anonenum_fadvice_t_28 {
    FADVISE_NORMAL = 0,
    FADVISE_SEQUENTIAL = 1,
    FADVISE_NOREUSE = 2,
    FADVISE_DONTNEED = 3,
    FADVISE_WILLNEED = 4,
    FADVISE_RANDOM = 5
};
typedef enum __anonenum_fadvice_t_28 fadvice_t;
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
typedef struct hash_tuning Hash_tuning;
struct hash_table;
typedef struct hash_table Hash_table;
struct heap;
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
enum nproc_query {
    NPROC_ALL = 0,
    NPROC_CURRENT = 1,
    NPROC_CURRENT_OVERRIDABLE = 2
};
struct randread_source;
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[] ;
};
union __anonunion_temp_29 {
   size_t i ;
   void *p ;
};
union __anonunion_chunkfun_30 {
   void *(*plain)(size_t ) ;
   void *(*extra)(void *, size_t ) ;
};
union __anonunion_freefun_31 {
   void (*plain)(void *) ;
   void (*extra)(void *, void *) ;
};
struct obstack {
   size_t chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_29 temp ;
   size_t alignment_mask ;
   union __anonunion_chunkfun_30 chunkfun ;
   union __anonunion_freefun_31 freefun ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
struct Tokens {
   size_t n_tok ;
   char **tok ;
   size_t *tok_len ;
   struct obstack o_data ;
   struct obstack o_tok ;
   struct obstack o_tok_len ;
};
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = LONGINT_INVALID_SUFFIX_CHAR | LONGINT_OVERFLOW,
    LONGINT_INVALID = 4
};
typedef enum strtol_error strtol_error;
struct rlimit {
   size_t rlim_cur ;
};
typedef __nl_item nl_item;
enum __anonenum_32 {
    _NL_CTYPE_CODESET_NAME = 0,
    D_T_FMT = 1,
    D_FMT = 2,
    T_FMT = 3,
    T_FMT_AMPM = 4,
    AM_STR = 5,
    PM_STR = 6,
    DAY_1 = 7,
    DAY_2 = 8,
    DAY_3 = 9,
    DAY_4 = 10,
    DAY_5 = 11,
    DAY_6 = 12,
    DAY_7 = 13,
    ABDAY_1 = 14,
    ABDAY_2 = 15,
    ABDAY_3 = 16,
    ABDAY_4 = 17,
    ABDAY_5 = 18,
    ABDAY_6 = 19,
    ABDAY_7 = 20,
    MON_1 = 21,
    MON_2 = 22,
    MON_3 = 23,
    MON_4 = 24,
    MON_5 = 25,
    MON_6 = 26,
    MON_7 = 27,
    MON_8 = 28,
    MON_9 = 29,
    MON_10 = 30,
    MON_11 = 31,
    MON_12 = 32,
    ABMON_1 = 33,
    ABMON_2 = 34,
    ABMON_3 = 35,
    ABMON_4 = 36,
    ABMON_5 = 37,
    ABMON_6 = 38,
    ABMON_7 = 39,
    ABMON_8 = 40,
    ABMON_9 = 41,
    ABMON_10 = 42,
    ABMON_11 = 43,
    ABMON_12 = 44,
    ERA = 45,
    ERA_D_FMT = 46,
    ERA_D_T_FMT = 47,
    ERA_T_FMT = 48,
    ALT_DIGITS = 49,
    RADIXCHAR = 50,
    THOUSEP = 51,
    YESEXPR = 52,
    NOEXPR = 53,
    YESSTR = 54,
    NOSTR = 55,
    CRNCYSTR = 56,
    D_MD_ORDER = 57,
    _NL_TIME_DATE_FMT = 84
};
enum __anonenum_33 {
    SUBTHREAD_LINES_HEURISTIC = 128 * 1024
};
enum __anonenum_34 {
    DEFAULT_MAX_THREADS = 8
};
enum __anonenum_35 {
    SORT_OUT_OF_ORDER = 1,
    SORT_FAILURE = 2
};
enum __anonenum_36 {
    MAX_FORK_TRIES_COMPRESS = 4,
    MAX_FORK_TRIES_DECOMPRESS = 9
};
enum __anonenum_37 {
    MERGE_END = 0,
    MERGE_ROOT = 1
};
enum blanktype {
    bl_start = 0,
    bl_end = 1,
    bl_both = 2
};
struct line {
   char *text ;
   size_t length ;
   char *keybeg ;
   char *keylim ;
};
struct buffer {
   char *buf ;
   size_t used ;
   size_t nlines ;
   size_t alloc ;
   size_t left ;
   size_t line_bytes ;
   _Bool eof ;
};
struct keyfield {
   size_t sword ;
   size_t schar ;
   size_t eword ;
   size_t echar ;
   _Bool const *ignore ;
   char const *translate ;
   _Bool skipsblanks ;
   _Bool skipeblanks ;
   _Bool numeric ;
   _Bool random ;
   _Bool general_numeric ;
   _Bool human_numeric ;
   _Bool month ;
   _Bool reverse ;
   _Bool version ;
   _Bool traditional_used ;
   struct keyfield *next ;
};
struct month {
   char const *name ;
   int val ;
};
struct merge_node {
   struct line *lo ;
   struct line *hi ;
   struct line *end_lo ;
   struct line *end_hi ;
   struct line **dest ;
   size_t nlo ;
   size_t nhi ;
   struct merge_node *parent ;
   struct merge_node *lo_child ;
   struct merge_node *hi_child ;
   unsigned int level ;
   _Bool queued ;
   pthread_mutex_t lock ;
};
struct merge_node_queue {
   struct heap *priority_queue ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
};
enum __anonenum_38 {
    TAB_DEFAULT = 0x7f + 1
};
struct __anonstruct_39 {
   int _gl_dummy ;
};
enum __anonenum_40 {
    CHECK_OPTION = 0x7f + 1,
    COMPRESS_PROGRAM_OPTION = 129,
    DEBUG_PROGRAM_OPTION = 130,
    FILES0_FROM_OPTION = 131,
    NMERGE_OPTION = 132,
    RANDOM_SOURCE_OPTION = 133,
    SORT_OPTION = 134,
    PARALLEL_OPTION = 135
};
struct cs_status {
   _Bool valid ;
   sigset_t sigs ;
};
enum __anonenum_41 {
    UNCOMPRESSED = 0,
    UNREAPED = 1,
    REAPED = 2
};
struct tempnode {
   struct tempnode * volatile next ;
   pid_t pid ;
   char state ;
   char name[] ;
};
struct sortfile {
   char const *name ;
   struct tempnode *temp ;
};
enum __anonenum_42 {
    INIT_PROCTAB_SIZE = 47
};
struct __anonstruct_43 {
   int _gl_dummy ;
};
struct __anonstruct_44 {
   int _gl_dummy ;
};
struct __anonstruct_45 {
   int _gl_dummy ;
};
struct __anonstruct_46 {
   int _gl_dummy ;
};
struct __anonstruct_47 {
   int _gl_dummy ;
};
struct __anonstruct_48 {
   int _gl_dummy ;
};
struct __anonstruct_49 {
   int _gl_dummy ;
};
struct __anonstruct_50 {
   int _gl_dummy ;
};
struct __anonstruct_51 {
   int _gl_dummy ;
};
struct __anonstruct_52 {
   int _gl_dummy ;
};
struct thread_args {
   struct line *lines ;
   size_t nthreads ;
   size_t const total_lines ;
   struct merge_node * const node ;
   struct merge_node_queue * const queue ;
   FILE *tfp ;
   char const *output_temp ;
};
struct __anonstruct_53 {
   int _gl_dummy ;
};
struct __anonstruct_54 {
   int _gl_dummy ;
};
struct __anonstruct_55 {
   int _gl_dummy ;
};
enum __anonenum_56 {
    nsigs = 42
};
struct __anonstruct_57 {
   int _gl_dummy ;
};
struct __anonstruct_58 {
   int _gl_dummy ;
};
struct __anonstruct_59 {
   int _gl_dummy ;
};
struct __anonstruct_60 {
   int _gl_dummy ;
};
struct __anonstruct_61 {
   int _gl_dummy ;
};
struct __anonstruct_62 {
   int _gl_dummy ;
};
struct __anonstruct_63 {
   int _gl_dummy ;
};
struct __anonstruct_64 {
   int _gl_dummy ;
};
struct __anonstruct_65 {
   int _gl_dummy ;
};
struct __anonstruct_66 {
   int _gl_dummy ;
};
struct __anonstruct_67 {
   int _gl_dummy ;
};
extern char *optarg;

extern int optind;

int getopt_long(int __argc, char * const *__argv, char const *__shortopts,
                struct option const *__longopts, int *__longind);

 __attribute__((__noreturn__)) void _exit(int __status);

int close(int __fildes);

int dup2(int __fildes, int __fildes2);

int euidaccess(char const *__path, int __mode);

int execvp(char const *__file, char * const *__argv);

int fchownat(int __dirfd, char const *__path, uid_t __owner, gid_t __group,
             int __flags);

pid_t fork(void);

int pipe2(int * /*[2]*/ __fildes, int flags);

int unlink(char const *__path);

int write(int __fd, void const *__buf, size_t __nbyte);

int ftruncate(int __fd, off_t __length);

__inline static void bintime_addx(struct bintime *_bt, uint64_t _x)
{
  uint64_t _u;
  _u = _bt->frac;
  _bt->frac += _x;
  if (_u > _bt->frac) (_bt->sec) ++;
  return;
}

__inline static void bintime_add(struct bintime *_bt,
                                 struct bintime const *_bt2)
{
  uint64_t _u;
  _u = _bt->frac;
  _bt->frac += _bt2->frac;
  if (_u > _bt->frac) (_bt->sec) ++;
  _bt->sec += _bt2->sec;
  return;
}

__inline static void bintime_sub(struct bintime *_bt,
                                 struct bintime const *_bt2)
{
  uint64_t _u;
  _u = _bt->frac;
  _bt->frac -= _bt2->frac;
  if (_u < _bt->frac) (_bt->sec) --;
  _bt->sec -= _bt2->sec;
  return;
}

__inline static void bintime_mul(struct bintime *_bt, u_int _x)
{
  uint64_t _p1;
  uint64_t _p2;
  _p1 = (unsigned long)(((unsigned long long)_bt->frac & 0xffffffffull) * (unsigned long long)_x);
  _p2 = (_bt->frac >> 32) * (uint64_t)_x + (_p1 >> 32);
  _bt->sec = (long)((unsigned long)_bt->sec * (unsigned long)_x);
  _bt->sec = (long)((uint64_t)_bt->sec + (_p2 >> 32));
  _bt->frac = (unsigned long)((unsigned long long)(_p2 << 32) | ((unsigned long long)_p1 & 0xffffffffull));
  return;
}

__inline static void bintime_shift(struct bintime *_bt, int _exp)
{
  if (_exp > 0) {
    _bt->sec <<= _exp;
    _bt->sec = (long)((unsigned long)_bt->sec | (_bt->frac >> (64 - _exp)));
    _bt->frac <<= _exp;
  }
  else
    if (_exp < 0) {
      _bt->frac >>= - _exp;
      _bt->frac |= (unsigned long)_bt->sec << (64 + _exp);
      _bt->sec >>= - _exp;
    }
  return;
}

__inline static int sbintime_getsec(sbintime_t _sbt)
{
  int __retres;
  __retres = (int)(_sbt >> 32);
  return __retres;
}

__inline static sbintime_t bttosbt(struct bintime const _bt)
{
  sbintime_t __retres;
  __retres = (long)((uint64_t)(_bt.sec << 32) + (_bt.frac >> 32));
  return __retres;
}

__inline static struct bintime sbttobt(sbintime_t _sbt)
{
  struct bintime _bt;
  _bt.sec = _sbt >> 32;
  _bt.frac = (unsigned long)(_sbt << 32);
  return _bt;
}

__inline static int64_t sbttons(sbintime_t _sbt)
{
  int64_t __retres;
  uint64_t ns;
  ns = (unsigned long)_sbt;
  if (ns >= (uint64_t)((long)1 << 32)) ns = (ns >> 32) * (uint64_t)1000000000;
  else ns = (unsigned long)0;
  __retres = (long)(ns + ((unsigned long)1000000000 * ((unsigned long)_sbt & (unsigned long)0xffffffffu) >> 32));
  return __retres;
}

__inline static sbintime_t nstosbt(int64_t _ns)
{
  sbintime_t sb = (long)0;
  if (_ns >= (long)1 << 32) {
    sb = (_ns / (int64_t)1000000000) * ((long)1 << 32);
    _ns %= (long)1000000000;
  }
  sb = (long)((unsigned long long)sb + (((unsigned long long)_ns * 9223372037ull + (unsigned long long)0x7fffffff) >> 31));
  return sb;
}

__inline static int64_t sbttous(sbintime_t _sbt)
{
  int64_t __retres;
  __retres = (sbintime_t)1000000 * _sbt >> 32;
  return __retres;
}

__inline static sbintime_t ustosbt(int64_t _us)
{
  sbintime_t sb = (long)0;
  if (_us >= (long)1 << 32) {
    sb = (_us / (int64_t)1000000) * ((long)1 << 32);
    _us %= (long)1000000;
  }
  sb = (long)((unsigned long long)sb + (((unsigned long long)_us * 9223372036855ull + (unsigned long long)0x7fffffff) >> 31));
  return sb;
}

__inline static int64_t sbttoms(sbintime_t _sbt)
{
  int64_t __retres;
  __retres = (sbintime_t)1000 * _sbt >> 32;
  return __retres;
}

__inline static sbintime_t mstosbt(int64_t _ms)
{
  sbintime_t sb = (long)0;
  if (_ms >= (long)1 << 32) {
    sb = (_ms / (int64_t)1000) * ((long)1 << 32);
    _ms %= (long)1000;
  }
  sb = (long)((unsigned long long)sb + (((unsigned long long)_ms * 9223372036854776ull + (unsigned long long)0x7fffffff) >> 31));
  return sb;
}

__inline static void bintime2timespec(struct bintime const *_bt,
                                      struct timespec *_ts)
{
  _ts->tv_sec = _bt->sec;
  _ts->tv_nsec = (long)((unsigned long)1000000000 * (unsigned long)((unsigned int)(
                        _bt->frac >> 32)) >> 32);
  return;
}

__inline static void timespec2bintime(struct timespec const *_ts,
                                      struct bintime *_bt)
{
  _bt->sec = _ts->tv_sec;
  _bt->frac = (unsigned long)_ts->tv_nsec * (unsigned long)18446744073LL;
  return;
}

__inline static void bintime2timeval(struct bintime const *_bt,
                                     struct timeval *_tv)
{
  _tv->tv_sec = _bt->sec;
  _tv->tv_usec = (long)((unsigned long)1000000 * (unsigned long)((unsigned int)(
                        _bt->frac >> 32)) >> 32);
  return;
}

__inline static void timeval2bintime(struct timeval const *_tv,
                                     struct bintime *_bt)
{
  _bt->sec = _tv->tv_sec;
  _bt->frac = (unsigned long)_tv->tv_usec * (unsigned long)18446744073709LL;
  return;
}

__inline static struct timespec sbttots(sbintime_t _sbt)
{
  struct timespec _ts;
  _ts.tv_sec = _sbt >> 32;
  _ts.tv_nsec = sbttons((long)((unsigned int)_sbt));
  return _ts;
}

__inline static sbintime_t tstosbt(struct timespec _ts)
{
  sbintime_t __retres;
  sbintime_t tmp;
  tmp = nstosbt(_ts.tv_nsec);
  ;
  __retres = (_ts.tv_sec << 32) + tmp;
  return __retres;
}

__inline static struct timeval sbttotv(sbintime_t _sbt)
{
  struct timeval _tv;
  _tv.tv_sec = _sbt >> 32;
  _tv.tv_usec = sbttous((long)((unsigned int)_sbt));
  return _tv;
}

__inline static sbintime_t tvtosbt(struct timeval _tv)
{
  sbintime_t __retres;
  sbintime_t tmp;
  tmp = ustosbt(_tv.tv_usec);
  ;
  __retres = (_tv.tv_sec << 32) + tmp;
  return __retres;
}

extern struct _reent *_impure_ptr;

pid_t waitpid(pid_t, int *, int);

int pthread_sigmask(int, sigset_t const *, sigset_t *);

int sigaction(int, struct sigaction const *, struct sigaction *);

_sig_func_ptr signal(int, void (*)(int ));

int raise(int);

 __attribute__((__noreturn__)) void __assert_func(char const *, int,
                                                  char const *, char const *);

int fstat(int __fd, struct stat *__sbuf);

int stat(char const * __restrict __path, struct stat * __restrict __sbuf);

int fchmodat(int, char const *, mode_t, int);

int fstatat(int, char const *, struct stat *, int);

void *memchr(void const *, int, size_t);

int memcmp(void const *, void const *, size_t);

void *memcpy(void *, void const *, size_t);

void *memmove(void *, void const *, size_t);

void *memset(void *, int, size_t);

int strcmp(char const *, char const *);

size_t strlen(char const *);

int strncmp(char const *, char const *, size_t);

size_t strxfrm(char *, char const *, size_t);

char *stpcpy(char *, char const *);

extern int *__errno(void);

int atexit(void (*__func)(void));

 __attribute__((__noreturn__)) void exit(int __status);

void free(void *);

char *getenv(char const *__string);

void *malloc(size_t) __attribute__((__warn_unused_result__, __malloc__,
                                    __alloc_size__(1)));

void qsort(void *__base, size_t __nmemb, size_t __size,
           int (*_compar)(void const *, void const *));

extern char const *Version;

extern int volatile exit_failure;

__inline static void initialize_exit_failure(int status)
{
  if (status != 1) exit_failure = status;
  return;
}

extern int open(char const *, int, void * const *__va_params);

extern int openat(int, char const *, int, void * const *__va_params);

extern int closedir(DIR *__dirp) __attribute__((__nonnull__(1)));

DIR *fdopendir(int);

struct dirent *readdir(DIR *);

__inline static struct timespec make_timespec__fc_inline(time_t s, long ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}

__inline static int __attribute__((__pure__)) timespec_cmp__fc_inline
(struct timespec a, struct timespec b)
{
  int __attribute__((__pure__)) __retres;
  __retres = (int __attribute__((__pure__)))(2 * ((a.tv_sec > b.tv_sec) - (
                                                  a.tv_sec < b.tv_sec)) + (
                                             (a.tv_nsec > b.tv_nsec) - (
                                             a.tv_nsec < b.tv_nsec)));
  return __retres;
}

__inline static int __attribute__((__pure__)) timespec_sign__fc_inline
(struct timespec a)
{
  int __attribute__((__pure__)) __retres;
  __retres = (int __attribute__((__pure__)))(((a.tv_sec > (time_t)0) - (
                                              a.tv_sec < (time_t)0)) + (
                                             ! a.tv_sec & ! (! a.tv_nsec)));
  return __retres;
}

__inline static double timespectod__fc_inline(struct timespec a)
{
  double __retres;
  __retres = (double)a.tv_sec + (double)a.tv_nsec / 1e9;
  return __retres;
}

extern char const _ctype_[];

__inline static char const *__locale_ctype_ptr_l(locale_t _l)
{
  char const *__retres;
  __retres = _ctype_;
  return __retres;
}

__inline static unsigned char to_uchar(char ch)
{
  unsigned char __retres;
  __retres = (unsigned char)ch;
  return __retres;
}

__inline static _Bool field_sep(unsigned char ch)
{
  _Bool __retres;
  int tmp_1;
  int tmp_0;
  {
    int tmp;
    unsigned char __x = ch;
    if ((int)*(& _ctype_[sizeof(*("" + __x))] + (int)__x) & 0200) tmp = 1;
    else
      if ((int)__x == '\t') tmp = 1; else tmp = 0;
    tmp_0 = tmp;
  }
  if (tmp_0) tmp_1 = 1;
  else
    if ((int)ch == '\n') tmp_1 = 1; else tmp_1 = 0;
  __retres = (_Bool)(tmp_1 != 0);
  return __retres;
}

char *setlocale(int, char const *);

struct lconv *localeconv(void);

extern int ( /* missing proto */ dcgettext)(char const *x_0, char const *x_1,
                                            int x_2);

__inline static char const *pgettext_aux(char const *domain,
                                         char const *msg_ctxt_id,
                                         char const *msgid, int category)
{
  char const *__retres;
  int tmp;
  tmp = dcgettext(domain,msg_ctxt_id,category);
  char const *translation = (char const *)tmp;
  if (translation == msg_ctxt_id) {
    __retres = msgid;
    goto return_label;
  }
  else {
    __retres = translation;
    goto return_label;
  }
  return_label: return __retres;
}

extern int ( /* missing proto */ dcngettext)(char const *x_0,
                                             char const *x_1,
                                             char const *x_2,
                                             unsigned long x_3, int x_4);

__inline static char const *npgettext_aux(char const *domain,
                                          char const *msg_ctxt_id,
                                          char const *msgid,
                                          char const *msgid_plural,
                                          unsigned long n, int category)
{
  char const *__retres;
  int tmp;
  tmp = dcngettext(domain,msg_ctxt_id,msgid_plural,n,category);
  char const *translation = (char const *)tmp;
  if (translation == msg_ctxt_id) goto _LOR;
  else
    if (translation == msgid_plural) {
      char const *tmp_0;
      _LOR: ;
      if (n == (unsigned long)1) tmp_0 = msgid; else tmp_0 = msgid_plural;
      __retres = tmp_0;
      goto return_label;
    }
    else {
      __retres = translation;
      goto return_label;
    }
  return_label: return __retres;
}

__inline static char const *dcpgettext_expr(char const *domain,
                                            char const *msgctxt,
                                            char const *msgid, int category)
{
  char const *__retres;
  size_t tmp;
  size_t tmp_0;
  char const *translation;
  char buf[1024];
  char *tmp_2;
  tmp = strlen(msgctxt);
  size_t msgctxt_len = tmp + (size_t)1;
  tmp_0 = strlen(msgid);
  size_t msgid_len = tmp_0 + (size_t)1;
  if (msgctxt_len + msgid_len <= (size_t)sizeof(buf)) tmp_2 = buf;
  else tmp_2 = (char *)malloc(msgctxt_len + msgid_len);
  char *msg_ctxt_id = tmp_2;
  if (msg_ctxt_id != (char *)0) {
    int found_translation;
    int tmp_3;
    memcpy((void *)msg_ctxt_id,(void const *)msgctxt,msgctxt_len - (size_t)1);
    *(msg_ctxt_id + (msgctxt_len - (size_t)1)) = (char)'\004';
    memcpy((void *)(msg_ctxt_id + msgctxt_len),(void const *)msgid,msgid_len);
    tmp_3 = dcgettext(domain,(char const *)msg_ctxt_id,category);
    translation = (char const *)tmp_3;
    found_translation = (void *)translation != (void *)msg_ctxt_id;
    if (msg_ctxt_id != buf) free((void *)msg_ctxt_id);
    if (found_translation) {
      __retres = translation;
      goto return_label;
    }
  }
  __retres = msgid;
  return_label: return __retres;
}

__inline static char const *dcnpgettext_expr(char const *domain,
                                             char const *msgctxt,
                                             char const *msgid,
                                             char const *msgid_plural,
                                             unsigned long n, int category)
{
  char const *__retres;
  size_t tmp;
  size_t tmp_0;
  char const *translation;
  char buf[1024];
  char *tmp_2;
  char const *tmp_5;
  tmp = strlen(msgctxt);
  size_t msgctxt_len = tmp + (size_t)1;
  tmp_0 = strlen(msgid);
  size_t msgid_len = tmp_0 + (size_t)1;
  if (msgctxt_len + msgid_len <= (size_t)sizeof(buf)) tmp_2 = buf;
  else tmp_2 = (char *)malloc(msgctxt_len + msgid_len);
  char *msg_ctxt_id = tmp_2;
  if (msg_ctxt_id != (char *)0) {
    int found_translation;
    int tmp_3;
    int tmp_4;
    memcpy((void *)msg_ctxt_id,(void const *)msgctxt,msgctxt_len - (size_t)1);
    *(msg_ctxt_id + (msgctxt_len - (size_t)1)) = (char)'\004';
    memcpy((void *)(msg_ctxt_id + msgctxt_len),(void const *)msgid,msgid_len);
    tmp_3 = dcngettext(domain,(char const *)msg_ctxt_id,msgid_plural,n,
                       category);
    translation = (char const *)tmp_3;
    if ((void *)translation == (void *)msg_ctxt_id) tmp_4 = 0;
    else
      if (translation == msgid_plural) tmp_4 = 0; else tmp_4 = 1;
    found_translation = tmp_4;
    if (msg_ctxt_id != buf) free((void *)msg_ctxt_id);
    if (found_translation) {
      __retres = translation;
      goto return_label;
    }
  }
  if (n == (unsigned long)1) tmp_5 = msgid; else tmp_5 = msgid_plural;
  __retres = tmp_5;
  return_label: return __retres;
}

__inline static unsigned long select_plural(uintmax_t n)
{
  uintmax_t tmp;
  if ((long long)n <= 0x7fffffffffffffffL * (long long)2UL + (long long)1UL)
    tmp = n;
  else tmp = n % (unsigned long)PLURAL_REDUCER + (unsigned long)PLURAL_REDUCER;
  return tmp;
}

 _Noreturn void xalloc_die(void);

void *xmalloc(size_t s) __attribute__((__malloc__, __alloc_size__(1)));

void *xcalloc(size_t n, size_t s) __attribute__((__malloc__,
                                                 __alloc_size__(1,2)));

void *xrealloc(void *p, size_t s) __attribute__((__alloc_size__(2)));

void *xmemdup(void const *p, size_t s) __attribute__((__alloc_size__(2)));

void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__,
                                                  __alloc_size__(1,2)));

extern int ( /* missing proto */ __builtin_mul_overflow_p)(unsigned long x_0,
                                                           unsigned long x_1,
                                                           long x_2);

void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__,
                                                  __alloc_size__(1,2)));
void *xnmalloc(size_t n, size_t s)
{
  int tmp;
  void *tmp_0;
  tmp = __builtin_mul_overflow_p(n,s,(long)1);
  if (tmp) xalloc_die();
  tmp_0 = xmalloc(n * s);
  return tmp_0;
}

void *xnrealloc(void *p, size_t n, size_t s) __attribute__((__alloc_size__(2,3)));

void *xnrealloc(void *p, size_t n, size_t s) __attribute__((__alloc_size__(2,3)));
void *xnrealloc(void *p, size_t n, size_t s)
{
  int tmp;
  void *tmp_0;
  tmp = __builtin_mul_overflow_p(n,s,(long)1);
  if (tmp) xalloc_die();
  tmp_0 = xrealloc(p,n * s);
  return tmp_0;
}

__inline static void *x2nrealloc__fc_inline(void *p, size_t *pn, size_t s)
{
  void *tmp_1;
  size_t n = *pn;
  if (! p) {
    int tmp;
    if (! n) {
      n = (size_t)DEFAULT_MXFAST / s;
      n += (size_t)(! n);
    }
    tmp = __builtin_mul_overflow_p(n,s,(long)1);
    if (tmp) xalloc_die();
  }
  else {
    unsigned long long tmp_0;
    if ((unsigned long long)0x7fffffffffffffffL < 0xffffffffffffffffUL)
      tmp_0 = (unsigned long long)0x7fffffffffffffffL;
    else tmp_0 = 0xffffffffffffffffUL;
    ;
    if (((tmp_0 / (unsigned long long)3) * (unsigned long long)2) / (unsigned long long)s <= (unsigned long long)n)
      xalloc_die();
    n += n / (size_t)2 + (size_t)1;
  }
  *pn = n;
  tmp_1 = xrealloc(p,n * s);
  return tmp_1;
}

char *xcharalloc(size_t n) __attribute__((__malloc__, __alloc_size__(1)));

char *xcharalloc(size_t n) __attribute__((__malloc__, __alloc_size__(1)));
char *xcharalloc(size_t n)
{
  char *__retres;
  void *tmp_1;
  if (sizeof(char) == (unsigned int)1) tmp_1 = xmalloc(n);
  else tmp_1 = xnmalloc(n,(unsigned long)sizeof(char));
  __retres = (char *)tmp_1;
  return __retres;
}

int fclose(FILE *);

int ( /* format attribute */ fprintf)(FILE *, char const *,
                                      void * const *__va_params);

int ( /* format attribute */ printf)(char const *, void * const *__va_params);

FILE *fdopen(int, char const *);

int fileno(FILE *);

int fflush_unlocked(FILE *);

int fputc_unlocked(int, FILE *);

size_t fread_unlocked(void *, size_t _size, size_t _n, FILE *);

size_t fwrite_unlocked(void const *, size_t _size, size_t _n, FILE *);

int fputs_unlocked(char const *, FILE *);

int __srget_r(struct _reent *, FILE *);

int __swbuf_r(struct _reent *, int, FILE *);

__inline static int __sputc_r(struct _reent *_ptr, int _c, FILE *_p)
{
  int __retres;
  (_p->_w) --;
  if (_p->_w >= 0) goto _LOR;
  else
    if (_p->_w >= _p->_lbfsize) {
      if ((int)((char)_c) != '\n') {
        unsigned char *tmp;
        unsigned char tmp_0;
        _LOR:
        { /* sequence */
          tmp = _p->_p;
          (_p->_p) ++;
          tmp_0 = (unsigned char)_c;
        }
        *tmp = tmp_0;
        __retres = (int)tmp_0;
        goto return_label;
      }
      else goto _LAND;
    }
    else {
      int tmp_1;
      _LAND: tmp_1 = __swbuf_r(_ptr,_c,_p);
      __retres = tmp_1;
      goto return_label;
    }
  return_label: return __retres;
}

__inline static int _getchar_unlocked(void)
{
  struct _reent *_ptr;
  int tmp_1;
  _ptr = _impure_ptr;
  ((_ptr->_stdin)->_r) --;
  if ((_ptr->_stdin)->_r < 0) tmp_1 = __srget_r(_ptr,_ptr->_stdin);
  else {
    unsigned char *tmp_0;
    tmp_0 = (_ptr->_stdin)->_p;
    ((_ptr->_stdin)->_p) ++;
    tmp_1 = (int)*tmp_0;
  }
  return tmp_1;
}

__inline static int _putchar_unlocked(int _c)
{
  struct _reent *_ptr;
  int tmp;
  _ptr = _impure_ptr;
  tmp = __sputc_r(_ptr,_c,_ptr->_stdout);
  return tmp;
}

__inline static int chownat__fc_inline(int fd, char const *file, uid_t owner,
                                       gid_t group)
{
  int tmp;
  tmp = fchownat(fd,file,owner,group,0);
  return tmp;
}

__inline static int lchownat__fc_inline(int fd, char const *file,
                                        uid_t owner, gid_t group)
{
  int tmp;
  tmp = fchownat(fd,file,owner,group,2);
  return tmp;
}

__inline static int chmodat__fc_inline(int fd, char const *file, mode_t mode)
{
  int tmp;
  tmp = fchmodat(fd,file,mode,0);
  return tmp;
}

__inline static int lchmodat__fc_inline(int fd, char const *file, mode_t mode)
{
  int tmp;
  tmp = fchmodat(fd,file,mode,2);
  return tmp;
}

__inline static int statat__fc_inline(int fd, char const *name,
                                      struct stat *st)
{
  int tmp;
  tmp = fstatat(fd,name,st,0);
  return tmp;
}

__inline static int lstatat__fc_inline(int fd, char const *name,
                                       struct stat *st)
{
  int tmp;
  tmp = fstatat(fd,name,st,2);
  return tmp;
}

__inline static _Bool dot_or_dotdot(char const *file_name)
{
  _Bool __retres;
  if ((int)*(file_name + 0) == '.') {
    int tmp;
    char sep = *(file_name + (((int)*(file_name + 1) == '.') + 1));
    if (! sep) tmp = 1;
    else
      if ((int)sep == '/') tmp = 1; else tmp = 0;
    __retres = (_Bool)(tmp != 0);
    goto return_label;
  }
  else {
    __retres = (_Bool)0;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static struct dirent const *readdir_ignoring_dot_and_dotdot(
                                                                    DIR *dirp)
{
  struct dirent const *__retres;
  while (1) {
    {
      struct dirent const *dp = readdir(dirp);
      if (dp == (struct dirent const *)0) {
        __retres = dp;
        goto return_label;
      }
      else {
        _Bool tmp_0;
        tmp_0 = dot_or_dotdot(dp->d_name);
        if (! tmp_0) {
          __retres = dp;
          goto return_label;
        }
      }
    }
  }
  return_label: return __retres;
}

__inline static _Bool is_empty_dir(int fd_cwd, char const *dir)
{
  _Bool __retres;
  DIR *dirp;
  struct dirent const *dp;
  int saved_errno;
  int *tmp_0;
  int *tmp_1;
  int *tmp_2;
  int tmp_3;
  void *__va_args[1] = {(void *)0};
  int fd =
    openat(fd_cwd,dir,(((0 | 0x200000) | 0x8000) | 0x100000) | 0x4000,
           (void * const *)(__va_args));
  if (fd < 0) {
    __retres = (_Bool)0;
    goto return_label;
  }
  dirp = fdopendir(fd);
  if (dirp == (DIR *)0) {
    close(fd);
    __retres = (_Bool)0;
    goto return_label;
  }
  tmp_0 = __errno();
  *tmp_0 = 0;
  dp = readdir_ignoring_dot_and_dotdot(dirp);
  tmp_1 = __errno();
  saved_errno = *tmp_1;
  closedir(dirp);
  tmp_2 = __errno();
  *tmp_2 = saved_errno;
  if (dp != (struct dirent const *)0) {
    __retres = (_Bool)0;
    goto return_label;
  }
  if (saved_errno == 0) tmp_3 = 1; else tmp_3 = 0;
  __retres = (_Bool)(tmp_3 != 0);
  return_label: return __retres;
}

void close_stdout(void);

extern void version_etc(FILE *stream, char const *command_name,
                        char const *package, char const *version,
                        void * const *__va_params) __attribute__((__sentinel__));

extern char const *program_name;

extern void set_program_name(char const *argv0);

__inline static size_t gcd(size_t u, size_t v) __attribute__((__const__));
__inline static size_t gcd(size_t u, size_t v)
{
  while (1) {
    {
      size_t t = u % v;
      u = v;
      v = t;
    }
    if (! v) break;
  }
  return u;
}

__inline static size_t lcm(size_t u, size_t v) __attribute__((__const__));
__inline static size_t lcm(size_t u, size_t v)
{
  size_t __retres;
  size_t tmp;
  tmp = gcd(u,v);
  ;
  __retres = u * (v / tmp);
  return __retres;
}

__inline static void *ptr_align(void const *ptr, size_t alignment)
{
  void *__retres;
  char const *p0 = (char const *)ptr;
  char const *p1 = (p0 + alignment) - 1;
  __retres = (void *)(p1 - (unsigned long)p1 % alignment);
  return __retres;
}

__inline static _Bool __attribute__((__pure__)) is_nul(void const *buf,
                                                       size_t length)
{
  _Bool __attribute__((__pure__)) __retres;
  unsigned char word;
  int tmp;
  unsigned char const *p = (unsigned char const *)buf;
  if (! length) {
    __retres = (_Bool __attribute__((__pure__)))1;
    goto return_label;
  }
  while (length & (unsigned long)(sizeof(word) - (unsigned int)1)) {
    if (*p) {
      __retres = (_Bool __attribute__((__pure__)))0;
      goto return_label;
    }
    p ++;
    length --;
    if (! length) {
      __retres = (_Bool __attribute__((__pure__)))1;
      goto return_label;
    }
  }
  while (1) {
    memcpy((void *)(& word),(void const *)p,(unsigned long)sizeof(word));
    if (word) {
      __retres = (_Bool __attribute__((__pure__)))0;
      goto return_label;
    }
    p += sizeof(word);
    length -= (size_t)sizeof(word);
    if (! length) {
      __retres = (_Bool __attribute__((__pure__)))1;
      goto return_label;
    }
    if ((length & (unsigned long)15) == 0) break;
  }
  tmp = memcmp(buf,(void const *)p,length);
  __retres = (_Bool __attribute__((__pure__)))(tmp == 0);
  return_label: return __retres;
}

extern int ( /* missing proto */ gettext)(char const *x_0);

__inline static void emit_stdin_note(void)
{
  int tmp;
  ;
  tmp = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  fputs_unlocked((char const *)tmp,_impure_ptr->_stdout);
  return;
}

__inline static void emit_mandatory_arg_note(void)
{
  int tmp;
  ;
  tmp = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  fputs_unlocked((char const *)tmp,_impure_ptr->_stdout);
  return;
}

__inline static void emit_size_note(void)
{
  int tmp;
  ;
  tmp = gettext("\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\nUnits are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\n");
  fputs_unlocked((char const *)tmp,_impure_ptr->_stdout);
  return;
}

__inline static void emit_blocksize_note(char const *program)
{
  int tmp;
  ;
  tmp = gettext("\nDisplay values are in units of the first available SIZE from --block-size,\nand the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\nOtherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n");
  {
    char const *__va_arg0 = program;
    void *__va_args[1] = {& __va_arg0};
    printf((char const *)tmp,(void * const *)(__va_args));
  }
  return;
}

__inline static void emit_backup_suffix_note(void)
{
  int tmp;
  int tmp_0;
  ;
  tmp = gettext("\nThe backup suffix is \'~\', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\nThe version control method may be selected via the --backup option or through\nthe VERSION_CONTROL environment variable.  Here are the values:\n\n");
  fputs_unlocked((char const *)tmp,_impure_ptr->_stdout);
  ;
  tmp_0 = gettext("  none, off       never make backups (even if --backup is given)\n  numbered, t     make numbered backups\n  existing, nil   numbered if numbered backups exist, simple otherwise\n  simple, never   always make simple backups\n");
  fputs_unlocked((char const *)tmp_0,_impure_ptr->_stdout);
  return;
}

__inline static void emit_ancillary_info(char const *program)
{
  int tmp_0;
  int tmp_4;
  char const *tmp_5;
  int tmp_6;
  struct infomap const infomap[7] =
    {{.program = "[", .node = "test invocation"},
     {.program = "coreutils", .node = "Multi-call invocation"},
     {.program = "sha224sum", .node = "sha2 utilities"},
     {.program = "sha256sum", .node = "sha2 utilities"},
     {.program = "sha384sum", .node = "sha2 utilities"},
     {.program = "sha512sum", .node = "sha2 utilities"},
     {.program = (char const *)0, .node = (char const *)0}};
  char const *node = program;
  struct infomap const *map_prog = infomap;
  while (1) {
    if (map_prog->program) {
      int tmp;
      tmp = strcmp(program,map_prog->program);
      if (tmp == 0) break;
    }
    else break;
    map_prog ++;
  }
  if (map_prog->node) node = map_prog->node;
  tmp_0 = gettext("\n%s online help: <%s>\n");
  {
    char const *__va_arg0 = "GNU coreutils";
    char const *__va_arg1 = "https://www.gnu.org/software/coreutils/";
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    printf((char const *)tmp_0,(void * const *)(__va_args));
  }
  char const *lc_messages = setlocale(6,(char const *)0);
  if (lc_messages) {
    int tmp_3;
    tmp_3 = strncmp(lc_messages,"en_",
                    (unsigned long)(sizeof("en_") - (unsigned int)1));
    if (tmp_3) {
      int tmp_2;
      ;
      tmp_2 = gettext("Report any translation bugs to <https://translationproject.org/team/>\n");
      fputs_unlocked((char const *)tmp_2,_impure_ptr->_stdout);
    }
  }
  ;
  tmp_4 = gettext("Full documentation <%s%s>\n");
  {
    char const *__va_arg0_18 = "https://www.gnu.org/software/coreutils/";
    char const *__va_arg1_20 = program;
    void *__va_args_22[2] = {& __va_arg0_18, & __va_arg1_20};
    printf((char const *)tmp_4,(void * const *)(__va_args_22));
  }
  if (node == program) tmp_5 = " invocation"; else tmp_5 = "";
  ;
  tmp_6 = gettext("or available locally via: info \'(coreutils) %s%s\'\n");
  {
    char const *__va_arg0_24 = node;
    char const *__va_arg1_26 = tmp_5;
    void *__va_args_28[2] = {& __va_arg0_24, & __va_arg1_26};
    printf((char const *)tmp_6,(void * const *)(__va_args_28));
  }
  return;
}

char *imaxtostr(intmax_t, char *) __attribute__((__warn_unused_result__));

char *inttostr(int, char *) __attribute__((__warn_unused_result__));

char *uinttostr(unsigned int, char *) __attribute__((__warn_unused_result__));

char *umaxtostr(uintmax_t, char *) __attribute__((__warn_unused_result__));

__inline static char *timetostr(time_t t, char *buf)
{
  char *tmp_1;
  if (! ((long)0 < (long)(-1))) tmp_1 = imaxtostr(t,buf);
  else tmp_1 = umaxtostr((unsigned long)t,buf);
  return tmp_1;
}

__inline static char *bad_cast(char const *s)
{
  char *__retres;
  __retres = (char *)s;
  return __retres;
}

extern int ( /* missing proto */ S_TYPEISSHM)(struct stat const *x_0);

extern int ( /* missing proto */ S_TYPEISTMO)(struct stat const *x_0);

__inline static _Bool usable_st_size(struct stat const *sb)
{
  _Bool __retres;
  int tmp_1;
  if ((sb->st_mode & (unsigned int)0170000) == (unsigned int)0100000)
    tmp_1 = 1;
  else
    if ((sb->st_mode & (unsigned int)0170000) == (unsigned int)0120000)
      tmp_1 = 1;
    else {
      int tmp;
      tmp = S_TYPEISSHM(sb);
      if (tmp) tmp_1 = 1;
      else {
        int tmp_0;
        tmp_0 = S_TYPEISTMO(sb);
        if (tmp_0) tmp_1 = 1; else tmp_1 = 0;
      }
    }
  __retres = (_Bool)(tmp_1 != 0);
  return __retres;
}

 __attribute__((__noreturn__)) void usage(int status);

__inline static char *stzncpy(char * __restrict dest,
                              char const * __restrict src, size_t len)
{
  char const *src_end = src + len;
  while (1) {
    char *tmp;
    char const *tmp_0;
    if (src < src_end) {
      if (! *src) break;
    }
    else break;
    tmp = dest;
    dest ++;
    tmp_0 = src;
    src ++;
    *tmp = *tmp_0;
  }
  *dest = (char)0;
  return dest;
}

__inline static char *se_const(char const *sctx)
{
  char *__retres;
  __retres = (char *)sctx;
  return __retres;
}

__inline static _Bool is_ENOTSUP(int err)
{
  _Bool __retres;
  int tmp;
  if (err == 95) tmp = 1;
  else
    if (134 != 95)
      if (err == 134) tmp = 1; else tmp = 0;
    else tmp = 0;
  __retres = (_Bool)(tmp != 0);
  return __retres;
}

char *quotearg_n_style(int n, enum quoting_style s, char const *arg);

char *quotearg_style(enum quoting_style s, char const *arg);

char *quotearg_n_style_colon(int n, enum quoting_style s, char const *arg);

char const *quote_n(int n, char const *arg);

char const *quote(char const *arg);

extern void (*argmatch_die)(void);

ptrdiff_t __xargmatch_internal(char const *context, char const *arg,
                               char const * const *arglist,
                               void const *vallist, size_t valsize,
                               void (*exit_fn)(void));

extern void ( /* format attribute */ error)(int __status, int __errnum,
                                            char const *__format,
                                            void * const *__va_params);

void fadvise(FILE *fp, fadvice_t advice);

int filevercmp(char const *s1, char const *s2) __attribute__((__pure__));

extern _Bool hard_locale(int category);

Hash_table *hash_initialize(size_t, Hash_tuning const *,
                            size_t (*)(void const *, size_t ),
                            _Bool (*)(void const *, void const *),
                            void (*)(void *)) __attribute__((__warn_unused_result__));

void *hash_insert(Hash_table *, void const *) __attribute__((__warn_unused_result__));

void *hash_delete(Hash_table *, void const *);

struct heap *heap_alloc(int (*)(void const *, void const *), size_t);

void heap_free(struct heap *);

int heap_insert(struct heap *heap, void *item);

void *heap_remove_top(struct heap *heap);

extern void md5_init_ctx(struct md5_ctx *ctx);

extern void md5_process_bytes(void const *buffer, size_t len,
                              struct md5_ctx *ctx);

extern void *md5_finish_ctx(struct md5_ctx *ctx, void * __restrict resbuf);

extern int mbsnwidth(char const *buf, size_t nbytes, int flags);

extern unsigned long num_processors(enum nproc_query query);

double physmem_total(void);

double physmem_available(void);

int posix2_version(void);

struct randread_source *randread_new(char const *, size_t);

void randread(struct randread_source *, void *, size_t);

int randread_free(struct randread_source *);

void readtokens0_init(struct Tokens *t);

void readtokens0_free(struct Tokens *t);

_Bool readtokens0(FILE *in, struct Tokens *t);

int mkostemp_safer(char *, int);

int strnumcmp(char const *, char const *, int, int);

int xmemcoll0(char const *, size_t, char const *, size_t);

int xnanosleep(double);

strtol_error xstrtoumax(char const *, char **, int, uintmax_t *, char const *);

 _Noreturn void xstrtol_fatal(enum strtol_error, int, char,
                              struct option const *, char const *);

char *nl_langinfo(nl_item);

static int decimal_point;
static int thousands_sep;
static _Bool hard_LC_COLLATE;
static _Bool hard_LC_TIME;
static char eolchar = (char)'\n';
static struct line saved_line;
static _Bool blanks[(0x7f * 2 + 1) + 1];
static _Bool nonprinting[(0x7f * 2 + 1) + 1];
static _Bool nondictionary[(0x7f * 2 + 1) + 1];
static char fold_toupper[(0x7f * 2 + 1) + 1];
static struct month monthtab[12] =
  {{.name = "APR", .val = 4},
   {.name = "AUG", .val = 8},
   {.name = "DEC", .val = 12},
   {.name = "FEB", .val = 2},
   {.name = "JAN", .val = 1},
   {.name = "JUL", .val = 7},
   {.name = "JUN", .val = 6},
   {.name = "MAR", .val = 3},
   {.name = "MAY", .val = 5},
   {.name = "NOV", .val = 11},
   {.name = "OCT", .val = 10},
   {.name = "SEP", .val = 9}};
static size_t merge_buffer_size =
  (unsigned long)((unsigned int)(256 * 1024));
static size_t sort_size;
static char const **temp_dirs;
static size_t temp_dir_count;
static size_t temp_dir_alloc;
static _Bool reverse;
static _Bool stable;
static int tab = TAB_DEFAULT;
static _Bool unique;
static _Bool have_read_stdin;
static struct keyfield *keylist;
static char const *compress_program;
static _Bool debug;
static unsigned int nmerge = (unsigned int)16;
static  __attribute__((__noreturn__)) void async_safe_die(int errnum,
                                                          char const *errstr);

static  __attribute__((__noreturn__)) void async_safe_die(int errnum,
                                                          char const *errstr);
static void async_safe_die(int errnum, char const *errstr)
{
  {
    int tmp_2;
    size_t tmp_1;
    tmp_1 = strlen(errstr);
    ;
    tmp_2 = write(2,(void const *)errstr,tmp_1);
    int __x = tmp_2;
    int tmp = __x;
  }
  if (errnum) {
    char errbuf[(((sizeof(errnum) * (unsigned int)8 - (unsigned int)(! 0)) * (unsigned int)146 + (unsigned int)484) / (unsigned int)485 + (unsigned int)(! 0)) + (unsigned int)1];
    char *p = inttostr(errnum,errbuf);
    {
      int __x_0 = write(2,(void const *)": errno ",(unsigned long)8);
      int tmp_4 = __x_0;
    }
    {
      int tmp_9;
      size_t tmp_8;
      tmp_8 = strlen((char const *)p);
      ;
      tmp_9 = write(2,(void const *)p,tmp_8);
      int __x_1 = tmp_9;
      int tmp_6 = __x_1;
    }
  }
  {
    int __x_2 = write(2,(void const *)"\n",(unsigned long)1);
    int tmp_10 = __x_2;
  }
  _exit(SORT_FAILURE);
  return;
}

static  __attribute__((__noreturn__)) void sort_die(char const *message,
                                                    char const *file);

// extern int ( /* missing proto */ __builtin_unreachable)(void);

static  __attribute__((__noreturn__)) void sort_die(char const *message,
                                                    char const *file);
static void sort_die(char const *message, char const *file)
{
  if (! (! sizeof(struct __anonstruct_39))) {
    char *tmp_1;
    char const *tmp_0;
    int *tmp_2;
    if (file) tmp_0 = file;
    else {
      int tmp;
      tmp = gettext("standard output");
      tmp_0 = (char const *)tmp;
    }
    tmp_1 = quotearg_n_style_colon(0,shell_escape_quoting_style,tmp_0);
    ;
    tmp_2 = __errno();
    {
      char const *__va_arg0 = message;
      char *__va_arg1 = tmp_1;
      void *__va_args[2] = {& __va_arg0, & __va_arg1};
      error(SORT_FAILURE,*tmp_2,"%s: %s",(void * const *)(__va_args));
    }
    __builtin_unreachable();
  }
  else {
    char *tmp_5;
    char const *tmp_4;
    int *tmp_6;
    if (file) tmp_4 = file;
    else {
      int tmp_3;
      tmp_3 = gettext("standard output");
      tmp_4 = (char const *)tmp_3;
    }
    tmp_5 = quotearg_n_style_colon(0,shell_escape_quoting_style,tmp_4);
    ;
    tmp_6 = __errno();
    {
      char const *__va_arg0_15 = message;
      char *__va_arg1_17 = tmp_5;
      void *__va_args_19[2] = {& __va_arg0_15, & __va_arg1_17};
      error(SORT_FAILURE,*tmp_6,"%s: %s",(void * const *)(__va_args_19));
    }
    __builtin_unreachable();
  }
  return;
}

 __attribute__((__noreturn__)) void usage(int status);
void usage(int status)
{
  if (status != 0) {
    int tmp;
    ;
    tmp = gettext("Try \'%s --help\' for more information.\n");
    ;
    {
      char const *__va_arg0 = program_name;
      void *__va_args[1] = {& __va_arg0};
      fprintf(_impure_ptr->_stderr,(char const *)tmp,
              (void * const *)(__va_args));
    }
  }
  else {
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    int tmp_8;
    int tmp_9;
    int tmp_10;
    int tmp_11;
    int tmp_12;
    int tmp_13;
    int tmp_14;
    int tmp_15;
    int tmp_16;
    int tmp_17;
    int tmp_18;
    int tmp_19;
    ;
    ;
    tmp_0 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    {
      char const *__va_arg0_26 = program_name;
      char const *__va_arg1 = program_name;
      void *__va_args_29[2] = {& __va_arg0_26, & __va_arg1};
      printf((char const *)tmp_0,(void * const *)(__va_args_29));
    }
    ;
    tmp_1 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked((char const *)tmp_1,_impure_ptr->_stdout);
    emit_stdin_note();
    emit_mandatory_arg_note();
    ;
    tmp_2 = gettext("Ordering options:\n\n");
    fputs_unlocked((char const *)tmp_2,_impure_ptr->_stdout);
    ;
    tmp_3 = gettext("  -b, --ignore-leading-blanks  ignore leading blanks\n  -d, --dictionary-order      consider only blanks and alphanumeric characters\n  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked((char const *)tmp_3,_impure_ptr->_stdout);
    ;
    tmp_4 = gettext("  -g, --general-numeric-sort  compare according to general numerical value\n  -i, --ignore-nonprinting    consider only printable characters\n  -M, --month-sort            compare (unknown) < \'JAN\' < ... < \'DEC\'\n");
    fputs_unlocked((char const *)tmp_4,_impure_ptr->_stdout);
    ;
    tmp_5 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked((char const *)tmp_5,_impure_ptr->_stdout);
    ;
    tmp_6 = gettext("  -n, --numeric-sort          compare according to string numerical value\n  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n      --random-source=FILE    get random bytes from FILE\n  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked((char const *)tmp_6,_impure_ptr->_stdout);
    ;
    tmp_7 = gettext("      --sort=WORD             sort according to WORD:\n                                general-numeric -g, human-numeric -h, month -M,\n                                numeric -n, random -R, version -V\n  -V, --version-sort          natural sort of (version) numbers within text\n\n");
    fputs_unlocked((char const *)tmp_7,_impure_ptr->_stdout);
    ;
    tmp_8 = gettext("Other options:\n\n");
    fputs_unlocked((char const *)tmp_8,_impure_ptr->_stdout);
    ;
    tmp_9 = gettext("      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n                            for more use temp files\n");
    fputs_unlocked((char const *)tmp_9,_impure_ptr->_stdout);
    ;
    tmp_10 = gettext("  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n      --compress-program=PROG  compress temporaries with PROG;\n                              decompress them with PROG -d\n");
    fputs_unlocked((char const *)tmp_10,_impure_ptr->_stdout);
    ;
    tmp_11 = gettext("      --debug               annotate the part of the line used to sort,\n                              and warn about questionable usage to stderr\n      --files0-from=F       read input from the files specified by\n                            NUL-terminated names in file F;\n                            If F is - then read names from standard input\n");
    fputs_unlocked((char const *)tmp_11,_impure_ptr->_stdout);
    ;
    tmp_12 = gettext("  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked((char const *)tmp_12,_impure_ptr->_stdout);
    ;
    tmp_13 = gettext("  -o, --output=FILE         write result to FILE instead of standard output\n  -s, --stable              stabilize sort by disabling last-resort comparison\n  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked((char const *)tmp_13,_impure_ptr->_stdout);
    tmp_14 = gettext("  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n                              multiple options specify multiple directories\n      --parallel=N          change the number of sorts run concurrently to N\n  -u, --unique              with -c, check for strict ordering;\n                              without -c, output only the first of an equal run\n");
    {
      char const *__va_arg0_31 = "/tmp";
      void *__va_args_33[1] = {& __va_arg0_31};
      printf((char const *)tmp_14,(void * const *)(__va_args_33));
    }
    ;
    tmp_15 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked((char const *)tmp_15,_impure_ptr->_stdout);
    ;
    tmp_16 = gettext("      --help     display this help and exit\n");
    fputs_unlocked((char const *)tmp_16,_impure_ptr->_stdout);
    ;
    tmp_17 = gettext("      --version  output version information and exit\n");
    fputs_unlocked((char const *)tmp_17,_impure_ptr->_stdout);
    ;
    tmp_18 = gettext("\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\nfield number and C a character position in the field; both are origin 1, and\nthe stop position defaults to the line\'s end.  If neither -t nor -b is in\neffect, characters in a field are counted from the beginning of the preceding\nwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\nwhich override global ordering options for that key.  If no key is given, use\nthe entire line as the key.  Use --debug to diagnose incorrect key usage.\n\nSIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked((char const *)tmp_18,_impure_ptr->_stdout);
    ;
    tmp_19 = gettext("% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n\n*** WARNING ***\nThe locale specified by the environment affects sort order.\nSet LC_ALL=C to get the traditional sort order that uses\nnative byte values.\n");
    fputs_unlocked((char const *)tmp_19,_impure_ptr->_stdout);
    emit_ancillary_info("sort");
  }
  exit(status);
  return;
}

static char const short_options[31] =
  {(char)'-',
   (char)'b',
   (char)'c',
   (char)'C',
   (char)'d',
   (char)'f',
   (char)'g',
   (char)'h',
   (char)'i',
   (char)'k',
   (char)':',
   (char)'m',
   (char)'M',
   (char)'n',
   (char)'o',
   (char)':',
   (char)'r',
   (char)'R',
   (char)'s',
   (char)'S',
   (char)':',
   (char)'t',
   (char)':',
   (char)'T',
   (char)':',
   (char)'u',
   (char)'V',
   (char)'y',
   (char)':',
   (char)'z',
   (char)'\000'};
static struct option const long_options[31] =
  {{.name = "ignore-leading-blanks",
    .has_arg = 0,
    .flag = (int *)0,
    .val = 'b'},
   {.name = "check", .has_arg = 2, .flag = (int *)0, .val = CHECK_OPTION},
   {.name = "compress-program",
    .has_arg = 1,
    .flag = (int *)0,
    .val = COMPRESS_PROGRAM_OPTION},
   {.name = "debug",
    .has_arg = 0,
    .flag = (int *)0,
    .val = DEBUG_PROGRAM_OPTION},
   {.name = "dictionary-order", .has_arg = 0, .flag = (int *)0, .val = 'd'},
   {.name = "ignore-case", .has_arg = 0, .flag = (int *)0, .val = 'f'},
   {.name = "files0-from",
    .has_arg = 1,
    .flag = (int *)0,
    .val = FILES0_FROM_OPTION},
   {.name = "general-numeric-sort",
    .has_arg = 0,
    .flag = (int *)0,
    .val = 'g'},
   {.name = "ignore-nonprinting", .has_arg = 0, .flag = (int *)0, .val = 'i'},
   {.name = "key", .has_arg = 1, .flag = (int *)0, .val = 'k'},
   {.name = "merge", .has_arg = 0, .flag = (int *)0, .val = 'm'},
   {.name = "month-sort", .has_arg = 0, .flag = (int *)0, .val = 'M'},
   {.name = "numeric-sort", .has_arg = 0, .flag = (int *)0, .val = 'n'},
   {.name = "human-numeric-sort", .has_arg = 0, .flag = (int *)0, .val = 'h'},
   {.name = "version-sort", .has_arg = 0, .flag = (int *)0, .val = 'V'},
   {.name = "random-sort", .has_arg = 0, .flag = (int *)0, .val = 'R'},
   {.name = "random-source",
    .has_arg = 1,
    .flag = (int *)0,
    .val = RANDOM_SOURCE_OPTION},
   {.name = "sort", .has_arg = 1, .flag = (int *)0, .val = SORT_OPTION},
   {.name = "output", .has_arg = 1, .flag = (int *)0, .val = 'o'},
   {.name = "reverse", .has_arg = 0, .flag = (int *)0, .val = 'r'},
   {.name = "stable", .has_arg = 0, .flag = (int *)0, .val = 's'},
   {.name = "batch-size",
    .has_arg = 1,
    .flag = (int *)0,
    .val = NMERGE_OPTION},
   {.name = "buffer-size", .has_arg = 1, .flag = (int *)0, .val = 'S'},
   {.name = "field-separator", .has_arg = 1, .flag = (int *)0, .val = 't'},
   {.name = "temporary-directory", .has_arg = 1, .flag = (int *)0, .val = 'T'},
   {.name = "unique", .has_arg = 0, .flag = (int *)0, .val = 'u'},
   {.name = "zero-terminated", .has_arg = 0, .flag = (int *)0, .val = 'z'},
   {.name = "parallel",
    .has_arg = 1,
    .flag = (int *)0,
    .val = PARALLEL_OPTION},
   {.name = "help", .has_arg = 0, .flag = (int *)0, .val = GETOPT_HELP_CHAR},
   {.name = "version",
    .has_arg = 0,
    .flag = (int *)0,
    .val = GETOPT_VERSION_CHAR},
   {.name = (char const *)0, .has_arg = 0, .flag = (int *)0, .val = 0}};
static char const * const check_args[4] =
  {"quiet", "silent", "diagnose-first", (char const *)0};
static char const check_types[3] = {(char)'C', (char)'C', (char)'c'};
static char const * const sort_args[7] =
  {"general-numeric",
   "human-numeric",
   "month",
   "numeric",
   "random",
   "version",
   (char const *)0};
static char const sort_types[6] =
  {(char)'g', (char)'h', (char)'M', (char)'n', (char)'R', (char)'V'};
static sigset_t caught_signals;
static void cs_enter(struct cs_status *status)
{
  int ret =
    pthread_sigmask(1,(sigset_t const *)(& caught_signals),& status->sigs);
  status->valid = (_Bool)(ret == 0);
  return;
}

static void cs_leave(struct cs_status const *status)
{
  if (status->valid) pthread_sigmask(0,& status->sigs,(sigset_t *)0);
  return;
}

static struct tempnode * volatile temphead;
static struct tempnode * volatile *temptail = & temphead;
static Hash_table *proctab;
static size_t proctab_hasher(void const *entry, size_t tabsize)
{
  size_t __retres;
  struct tempnode const *node = (struct tempnode const *)entry;
  __retres = (unsigned long)node->pid % tabsize;
  return __retres;
}

static _Bool proctab_comparator(void const *e1, void const *e2)
{
  _Bool __retres;
  struct tempnode const *n1 = (struct tempnode const *)e1;
  struct tempnode const *n2 = (struct tempnode const *)e2;
  __retres = (_Bool)(n1->pid == n2->pid);
  return __retres;
}

static pid_t nprocs;
static _Bool delete_proc(pid_t pid);

static pid_t reap(pid_t pid)
{
  int status;
  pid_t tmp_1;
  int tmp;
  pid_t tmp_0;
  if (pid) tmp = 0; else tmp = 1;
  if (pid) tmp_0 = pid; else tmp_0 = -1;
  tmp_1 = waitpid(tmp_0,& status,tmp);
  pid_t cpid = tmp_1;
  if (cpid < 0)
    if (! (! sizeof(struct __anonstruct_43))) {
      char *tmp_2;
      int tmp_3;
      int *tmp_4;
      tmp_2 = quotearg_style(shell_escape_always_quoting_style,
                             compress_program);
      tmp_3 = gettext("waiting for %s [-d]");
      tmp_4 = __errno();
      {
        char *__va_arg0 = tmp_2;
        void *__va_args[1] = {& __va_arg0};
        error(SORT_FAILURE,*tmp_4,(char const *)tmp_3,
              (void * const *)(__va_args));
      }
      __builtin_unreachable();
    }
    else {
      char *tmp_5;
      int tmp_6;
      int *tmp_7;
      tmp_5 = quotearg_style(shell_escape_always_quoting_style,
                             compress_program);
      tmp_6 = gettext("waiting for %s [-d]");
      tmp_7 = __errno();
      {
        char *__va_arg0_21 = tmp_5;
        void *__va_args_23[1] = {& __va_arg0_21};
        error(SORT_FAILURE,*tmp_7,(char const *)tmp_6,
              (void * const *)(__va_args_23));
      }
      __builtin_unreachable();
    }
  else
    if (0 < cpid)
      if (0 < pid) goto _LOR_0;
      else {
        _Bool tmp_12;
        tmp_12 = delete_proc(cpid);
        if (tmp_12) {
          _LOR_0:
          {
            if (! ((status & 0xff) == 0)) goto _LOR;
            else
              if ((status >> 8) & 0xff)
                _LOR:
                if (! (! sizeof(struct __anonstruct_44))) {
                  char *tmp_8;
                  int tmp_9;
                  tmp_8 = quotearg_style(shell_escape_always_quoting_style,
                                         compress_program);
                  tmp_9 = gettext("%s [-d] terminated abnormally");
                  {
                    char *__va_arg0_25 = tmp_8;
                    void *__va_args_27[1] = {& __va_arg0_25};
                    error(SORT_FAILURE,0,(char const *)tmp_9,
                          (void * const *)(__va_args_27));
                  }
                  __builtin_unreachable();
                }
                else {
                  char *tmp_10;
                  int tmp_11;
                  tmp_10 = quotearg_style(shell_escape_always_quoting_style,
                                          compress_program);
                  tmp_11 = gettext("%s [-d] terminated abnormally");
                  {
                    char *__va_arg0_29 = tmp_10;
                    void *__va_args_31[1] = {& __va_arg0_29};
                    error(SORT_FAILURE,0,(char const *)tmp_11,
                          (void * const *)(__va_args_31));
                  }
                  __builtin_unreachable();
                }
            nprocs --;
          }
        }
      }
  return cpid;
}

static void register_proc(struct tempnode *temp)
{
  void *tmp;
  if (! proctab) {
    proctab = hash_initialize((unsigned long)INIT_PROCTAB_SIZE,
                              (Hash_tuning const *)0,& proctab_hasher,
                              & proctab_comparator,(void (*)(void *))0);
    if (! proctab) xalloc_die();
  }
  temp->state = (char)UNREAPED;
  tmp = hash_insert(proctab,(void const *)temp);
  if (! tmp) xalloc_die();
  return;
}

static _Bool delete_proc(pid_t pid)
{
  _Bool __retres;
  struct tempnode test;
  test.pid = pid;
  struct tempnode *node = hash_delete(proctab,(void const *)(& test));
  if (! node) {
    __retres = (_Bool)0;
    goto return_label;
  }
  node->state = (char)REAPED;
  __retres = (_Bool)1;
  return_label: return __retres;
}

static void wait_proc(pid_t pid)
{
  _Bool tmp;
  tmp = delete_proc(pid);
  if (tmp) reap(pid);
  return;
}

static void reap_exited(void)
{
  while (1) {
    if (0 < nprocs) {
      pid_t tmp;
      tmp = reap(0);
      if (! tmp) break;
    }
    else break;
    continue;
  }
  return;
}

static void reap_some(void)
{
  reap(-1);
  reap_exited();
  return;
}

static void reap_all(void)
{
  while (0 < nprocs) reap(-1);
  return;
}

static void cleanup(void)
{
  struct tempnode const *node;
  node = (struct tempnode const *)temphead;
  while (node) {
    unlink(node->name);
    node = (struct tempnode const *)node->next;
  }
  temphead = (struct tempnode *)0;
  return;
}

static void exit_cleanup(void)
{
  if (temphead) {
    struct cs_status cs;
    cs_enter(& cs);
    cleanup();
    cs_leave((struct cs_status const *)(& cs));
  }
  close_stdout();
  return;
}

static struct tempnode *create_temp_file(int *pfd,
                                         _Bool survive_fd_exhaustion);

static char const create_temp_file_slashbase[12] =
  {(char)'/',
   (char)'s',
   (char)'o',
   (char)'r',
   (char)'t',
   (char)'X',
   (char)'X',
   (char)'X',
   (char)'X',
   (char)'X',
   (char)'X',
   (char)'\000'};
static size_t create_temp_file_temp_dir_index;
static struct tempnode *create_temp_file(int *pfd,
                                         _Bool survive_fd_exhaustion)
{
  int fd;
  int saved_errno;
  struct cs_status cs;
  int *tmp_1;
  int *tmp_2;
  char const *temp_dir = *(temp_dirs + create_temp_file_temp_dir_index);
  size_t len = strlen(temp_dir);
  struct tempnode *node = xmalloc((unsigned long)1000);
  char *file = node->name;
  memcpy((void *)file,(void const *)temp_dir,len);
  memcpy((void *)(file + len),(void const *)(create_temp_file_slashbase),
         (unsigned long)sizeof(create_temp_file_slashbase));
  node->next = (struct tempnode *)0;
  create_temp_file_temp_dir_index ++;
  ;
  if (create_temp_file_temp_dir_index == temp_dir_count) create_temp_file_temp_dir_index = (unsigned long)0;
  cs_enter(& cs);
  fd = mkostemp_safer(file,0x40000);
  if (0 <= fd) {
    *temptail = node;
    temptail = & node->next;
  }
  tmp_1 = __errno();
  saved_errno = *tmp_1;
  cs_leave((struct cs_status const *)(& cs));
  tmp_2 = __errno();
  *tmp_2 = saved_errno;
  if (fd < 0) {
    if (survive_fd_exhaustion) {
      int *tmp_9;
      tmp_9 = __errno();
      ;
      if (! (*tmp_9 == 24)) goto _LAND;
    }
    else
      _LAND:
      if (! (! sizeof(struct __anonstruct_45))) {
        char *tmp_3;
        int tmp_4;
        int *tmp_5;
        tmp_3 = quotearg_style(shell_escape_always_quoting_style,temp_dir);
        tmp_4 = gettext("cannot create temporary file in %s");
        tmp_5 = __errno();
        {
          char *__va_arg0 = tmp_3;
          void *__va_args[1] = {& __va_arg0};
          error(SORT_FAILURE,*tmp_5,(char const *)tmp_4,
                (void * const *)(__va_args));
        }
        __builtin_unreachable();
      }
      else {
        char *tmp_6;
        int tmp_7;
        int *tmp_8;
        tmp_6 = quotearg_style(shell_escape_always_quoting_style,temp_dir);
        tmp_7 = gettext("cannot create temporary file in %s");
        tmp_8 = __errno();
        {
          char *__va_arg0_24 = tmp_6;
          void *__va_args_26[1] = {& __va_arg0_24};
          error(SORT_FAILURE,*tmp_8,(char const *)tmp_7,
                (void * const *)(__va_args_26));
        }
        __builtin_unreachable();
      }
    free((void *)node);
    node = (struct tempnode *)0;
  }
  *pfd = fd;
  return node;
}

static int get_outstatus_outstat_errno;
static struct stat get_outstatus_outstat;
static struct stat *get_outstatus(void)
{
  struct stat *tmp_1;
  if (get_outstatus_outstat_errno == 0) {
    int tmp;
    tmp = fstat(1,& get_outstatus_outstat);
    if (tmp == 0) get_outstatus_outstat_errno = -1;
    else {
      int *tmp_0;
      tmp_0 = __errno();
      get_outstatus_outstat_errno = *tmp_0;
    }
  }
  if (get_outstatus_outstat_errno < 0) tmp_1 = & get_outstatus_outstat;
  else tmp_1 = (struct stat *)0;
  return tmp_1;
}

static FILE *stream_open(char const *file, char const *how)
{
  FILE *fp;
  if ((int)*how == 'r') {
    int tmp_1;
    tmp_1 = strcmp(file,"-");
    if (tmp_1 == 0) {
      have_read_stdin = (_Bool)1;
      fp = _impure_ptr->_stdin;
    }
    else {
      void *__va_args[1] = {(void *)0};
      int fd = open(file,0 | 0x40000,(void * const *)(__va_args));
      if (fd < 0) fp = (FILE *)0; else fp = fdopen(fd,how);
    }
    fadvise(fp,FADVISE_SEQUENTIAL);
  }
  else
    if ((int)*how == 'w') {
      if (file) {
        int tmp_9;
        tmp_9 = ftruncate(1,(long)0);
        if (tmp_9 != 0) {
          int *tmp_2;
          tmp_2 = __errno();
          int ftruncate_errno = *tmp_2;
          struct stat *outst = get_outstatus();
          if (! outst) goto _LOR;
          else
            if ((outst->st_mode & (unsigned int)0170000) == (unsigned int)0100000)
              goto _LOR;
            else {
              int tmp_8;
              tmp_8 = S_TYPEISSHM((struct stat const *)outst);
              if (tmp_8)
                _LOR:
                if (! (! sizeof(struct __anonstruct_46))) {
                  char *tmp_4;
                  int tmp_5;
                  tmp_4 = quotearg_n_style_colon(0,
                                                 shell_escape_quoting_style,
                                                 file);
                  tmp_5 = gettext("%s: error truncating");
                  ;
                  {
                    char *__va_arg0 = tmp_4;
                    void *__va_args_21[1] = {& __va_arg0};
                    error(SORT_FAILURE,ftruncate_errno,(char const *)tmp_5,
                          (void * const *)(__va_args_21));
                  }
                  __builtin_unreachable();
                }
                else {
                  char *tmp_6;
                  int tmp_7;
                  tmp_6 = quotearg_n_style_colon(0,
                                                 shell_escape_quoting_style,
                                                 file);
                  tmp_7 = gettext("%s: error truncating");
                  ;
                  {
                    char *__va_arg0_23 = tmp_6;
                    void *__va_args_25[1] = {& __va_arg0_23};
                    error(SORT_FAILURE,ftruncate_errno,(char const *)tmp_7,
                          (void * const *)(__va_args_25));
                  }
                  __builtin_unreachable();
                }
            }
        }
      }
      fp = _impure_ptr->_stdout;
    }
    else
      if (! (! "unexpected mode passed to stream_open")) __assert_func
                                                         ("sort_modified.c",
                                                          977,"stream_open",
                                                          "!\"unexpected mode passed to stream_open\"");
  return fp;
}

static FILE *xfopen(char const *file, char const *how)
{
  FILE *fp = stream_open(file,how);
  if (! fp) {
    int tmp_0;
    ;
    tmp_0 = gettext("open failed");
    sort_die((char const *)tmp_0,file);
  }
  return fp;
}

static void xfclose(FILE *fp, char const *file)
{
  int tmp;
  tmp = fileno(fp);
  switch (tmp) {
    int tmp_1;
    int tmp_3;
    case 0: ;
    if (((int)fp->_flags & 0x0020) != 0) fp->_flags = (short)((int)fp->_flags & ~ (
                                                              0x0040 | 0x0020));
    break;
    case 1: tmp_1 = fflush_unlocked(fp);
    if (tmp_1 != 0) {
      int tmp_0;
      ;
      tmp_0 = gettext("fflush failed");
      sort_die((char const *)tmp_0,file);
    }
    break;
    default: tmp_3 = fclose(fp);
    if (tmp_3 != 0) {
      int tmp_2;
      ;
      tmp_2 = gettext("close failed");
      sort_die((char const *)tmp_2,file);
    }
    break;
  }
  return;
}

static void move_fd(int oldfd, int newfd)
{
  if (oldfd != newfd) {
    dup2(oldfd,newfd);
    close(oldfd);
  }
  return;
}

static pid_t pipe_fork(int * /*[2]*/ pipefds, size_t tries)
{
  pid_t __retres;
  struct tempnode *saved_temphead;
  int saved_errno;
  struct cs_status cs;
  int tmp;
  double wait_retry = 0.25;
  pid_t pid = -1;
  tmp = pipe2(pipefds,0x40000);
  if (tmp < 0) {
    __retres = -1;
    goto return_label;
  }
  if (nmerge + (unsigned int)1 < (unsigned int)nprocs) reap_some();
  while (1) {
    size_t tmp_3;
    tmp_3 = tries;
    tries --;
    ;
    if (! tmp_3) break;
    {
      int *tmp_0;
      int *tmp_1;
      cs_enter(& cs);
      saved_temphead = temphead;
      temphead = (struct tempnode *)0;
      pid = fork();
      tmp_0 = __errno();
      saved_errno = *tmp_0;
      if (pid) temphead = saved_temphead;
      cs_leave((struct cs_status const *)(& cs));
      tmp_1 = __errno();
      *tmp_1 = saved_errno;
      if (0 <= pid) break;
      else {
        int *tmp_2;
        tmp_2 = __errno();
        ;
        if (*tmp_2 != 11) break;
        else {
          xnanosleep(wait_retry);
          wait_retry *= (double)2;
          reap_exited();
        }
      }
    }
  }
  if (pid < 0) {
    int *tmp_4;
    int *tmp_5;
    tmp_4 = __errno();
    saved_errno = *tmp_4;
    close(*(pipefds + 0));
    close(*(pipefds + 1));
    tmp_5 = __errno();
    *tmp_5 = saved_errno;
  }
  else
    if (pid == 0) {
      close(0);
      close(1);
    }
    else nprocs ++;
  __retres = pid;
  return_label: return __retres;
}

static struct tempnode *maybe_create_temp(FILE **pfp,
                                          _Bool survive_fd_exhaustion)
{
  struct tempnode *__retres;
  int tempfd;
  struct tempnode *node = create_temp_file(& tempfd,survive_fd_exhaustion);
  if (! node) {
    __retres = (struct tempnode *)0;
    goto return_label;
  }
  node->state = (char)UNCOMPRESSED;
  if (compress_program) {
    int pipefds[2];
    node->pid = pipe_fork(pipefds,(unsigned long)MAX_FORK_TRIES_COMPRESS);
    if (0 < node->pid) {
      close(tempfd);
      close(pipefds[0]);
      tempfd = pipefds[1];
      register_proc(node);
    }
    else
      if (node->pid == 0) {
        int *tmp_0;
        close(pipefds[1]);
        move_fd(tempfd,1);
        move_fd(pipefds[0],0);
        {
          char * const argv[2] = {(char *)compress_program, (char *)0};
          execvp(compress_program,argv);
        }
        tmp_0 = __errno();
        async_safe_die(*tmp_0,"couldn\'t execute compress program");
      }
  }
  *pfp = fdopen(tempfd,"w");
  if (! *pfp) {
    int tmp_1;
    ;
    tmp_1 = gettext("couldn\'t create temporary file");
    sort_die((char const *)tmp_1,(char const *)(node->name));
  }
  __retres = node;
  return_label: return __retres;
}

static struct tempnode *create_temp(FILE **pfp)
{
  struct tempnode *tmp;
  tmp = maybe_create_temp(pfp,(_Bool)0);
  return tmp;
}

static FILE *open_temp(struct tempnode *temp)
{
  FILE *__retres;
  int tempfd;
  int pipefds[2];
  FILE *fp = (FILE *)0;
  if ((int)temp->state == UNREAPED) wait_proc(temp->pid);
  {
    void *__va_args[1] = {(void *)0};
    tempfd = open((char const *)(temp->name),0,(void * const *)(__va_args));
  }
  if (tempfd < 0) {
    __retres = (FILE *)0;
    goto return_label;
  }
  pid_t child = pipe_fork(pipefds,(unsigned long)MAX_FORK_TRIES_DECOMPRESS);
  switch (child) {
    int *tmp_6;
    int *tmp_7;
    int *tmp_8;
    case -1: { /* sequence */
               tmp_6 = __errno();
               ;
             }
    if (*tmp_6 != 24)
      if (! (! sizeof(struct __anonstruct_47))) {
        char *tmp_0;
        int tmp_1;
        int *tmp_2;
        tmp_0 = quotearg_style(shell_escape_always_quoting_style,
                               compress_program);
        tmp_1 = gettext("couldn\'t create process for %s -d");
        tmp_2 = __errno();
        {
          char *__va_arg0 = tmp_0;
          void *__va_args_22[1] = {& __va_arg0};
          error(SORT_FAILURE,*tmp_2,(char const *)tmp_1,
                (void * const *)(__va_args_22));
        }
        __builtin_unreachable();
      }
      else {
        char *tmp_3;
        int tmp_4;
        int *tmp_5;
        tmp_3 = quotearg_style(shell_escape_always_quoting_style,
                               compress_program);
        tmp_4 = gettext("couldn\'t create process for %s -d");
        tmp_5 = __errno();
        {
          char *__va_arg0_24 = tmp_3;
          void *__va_args_26[1] = {& __va_arg0_24};
          error(SORT_FAILURE,*tmp_5,(char const *)tmp_4,
                (void * const *)(__va_args_26));
        }
        __builtin_unreachable();
      }
    close(tempfd);
    tmp_7 = __errno();
    *tmp_7 = 24;
    break;
    case 0: close(pipefds[0]);
    move_fd(tempfd,0);
    move_fd(pipefds[1],1);
    {
      char * const argv[3] =
        {(char *)compress_program, (char *)"-d", (char *)0};
      execvp(compress_program,argv);
    }
    tmp_8 = __errno();
    async_safe_die(*tmp_8,"couldn\'t execute compress program (with -d)");
    default: temp->pid = child;
    register_proc(temp);
    close(tempfd);
    close(pipefds[1]);
    fp = fdopen(pipefds[0],"r");
    if (! fp) {
      int *tmp_9;
      int *tmp_10;
      tmp_9 = __errno();
      int saved_errno = *tmp_9;
      close(pipefds[0]);
      tmp_10 = __errno();
      *tmp_10 = saved_errno;
    }
    break;
  }
  __retres = fp;
  return_label: return __retres;
}

static void add_temp_dir(char const *dir)
{
  size_t tmp_1;
  if (temp_dir_count == temp_dir_alloc)
    if (! (! sizeof(struct __anonstruct_48))) temp_dirs = (char const **)x2nrealloc__fc_inline
                                              ((void *)temp_dirs,
                                               & temp_dir_alloc,
                                               (unsigned long)sizeof(*temp_dirs));
    else temp_dirs = (char const **)x2nrealloc__fc_inline((void *)temp_dirs,
                                                          & temp_dir_alloc,
                                                          (unsigned long)sizeof(*temp_dirs));
  tmp_1 = temp_dir_count;
  temp_dir_count ++;
  *(temp_dirs + tmp_1) = dir;
  return;
}

static void zaptemp(char const *name)
{
  struct tempnode * volatile *pnode;
  struct tempnode *node;
  struct tempnode *next;
  int unlink_status;
  struct cs_status cs;
  int *tmp;
  int unlink_errno = 0;
  pnode = & temphead;
  while (1) {
    node = *pnode;
    ;
    if (! ((void *)(node->name) != (void *)name)) break;
    goto __Cont;
    __Cont: pnode = & node->next;
  }
  if ((int)node->state == UNREAPED) wait_proc(node->pid);
  next = node->next;
  cs_enter(& cs);
  unlink_status = unlink(name);
  tmp = __errno();
  unlink_errno = *tmp;
  *pnode = next;
  cs_leave((struct cs_status const *)(& cs));
  if (unlink_status != 0) {
    char *tmp_0;
    int tmp_1;
    tmp_0 = quotearg_n_style_colon(0,shell_escape_quoting_style,name);
    tmp_1 = gettext("warning: cannot remove: %s");
    ;
    {
      char *__va_arg0 = tmp_0;
      void *__va_args[1] = {& __va_arg0};
      error(0,unlink_errno,(char const *)tmp_1,(void * const *)(__va_args));
    }
  }
  if (! next) temptail = pnode;
  free((void *)node);
  return;
}

static int struct_month_cmp(void const *m1, void const *m2)
{
  int tmp;
  struct month const *month1 = (struct month const *)m1;
  struct month const *month2 = (struct month const *)m2;
  tmp = strcmp(month1->name,month2->name);
  return tmp;
}

static void inittables(void)
{
  size_t i;
  i = (unsigned long)0;
  while (i < (size_t)((0x7f * 2 + 1) + 1)) {
    {
      int tmp_0;
      int tmp_2;
      blanks[i] = field_sep((unsigned char)i);
      nonprinting[i] = (_Bool)(! ((int)*(& _ctype_[sizeof(*("" + i))] + (int)i) & (
                                  (((020 | 01) | 02) | 04) | 0200)));
      if (! ((int)*(& _ctype_[sizeof(*("" + i))] + (int)i) & ((01 | 02) | 04))) {
        _Bool tmp;
        tmp = field_sep((unsigned char)i);
        if (tmp) tmp_0 = 0; else tmp_0 = 1;
      }
      else tmp_0 = 0;
      nondictionary[i] = (_Bool)(tmp_0 != 0);
      {
        int tmp_1;
        size_t __x = i;
        if (((int)*(& _ctype_[sizeof(*("" + __x))] + (int)__x) & (01 | 02)) == 02)
          tmp_1 = ((int)__x - 'a') + 'A';
        else tmp_1 = (int)__x;
        tmp_2 = tmp_1;
      }
      fold_toupper[i] = (char)tmp_2;
    }
    i ++;
  }
  if (hard_LC_TIME) {
    i = (unsigned long)0;
    while (i < (size_t)12) {
      {
        char const *s;
        size_t s_len;
        size_t j;
        size_t k;
        char *name;
        s = (char const *)nl_langinfo((int)((size_t)ABMON_1 + i));
        s_len = strlen(s);
        name = (char *)xmalloc(s_len + (size_t)1);
        monthtab[i].name = (char const *)name;
        monthtab[i].val = (int)(i + (size_t)1);
        k = (unsigned long)0;
        j = k;
        while (j < s_len) {
          int tmp_8;
          {
            int tmp_7;
            unsigned char __x_0 = to_uchar(*(s + j));
            if ((int)*(& _ctype_[sizeof(*("" + __x_0))] + (int)__x_0) & 0200)
              tmp_7 = 1;
            else
              if ((int)__x_0 == '\t') tmp_7 = 1; else tmp_7 = 0;
            tmp_8 = tmp_7;
          }
          if (! tmp_8) {
            size_t tmp_3;
            unsigned char tmp_4;
            tmp_3 = k;
            k ++;
            tmp_4 = to_uchar(*(s + j));
            *(name + tmp_3) = fold_toupper[tmp_4];
          }
          j ++;
        }
        *(name + k) = (char)0;
      }
      i ++;
    }
    qsort((void *)(monthtab),(unsigned long)12,
          (unsigned long)sizeof(monthtab[0]),& struct_month_cmp);
  }
  return;
}

static void specify_nmerge(int oi, char c, char const *s)
{
  uintmax_t n;
  struct rlimit rlimit;
  size_t tmp_0;
  enum strtol_error e = xstrtoumax(s,(char **)0,10,& n,"");
  if (-1 == 0) tmp_0 = rlimit.rlim_cur; else tmp_0 = (unsigned long)64;
  unsigned int max_nmerge = (unsigned int)(tmp_0 - (size_t)3);
  if (e == (unsigned int)LONGINT_OK) {
    nmerge = (unsigned int)n;
    if ((uintmax_t)nmerge != n) e = LONGINT_OVERFLOW;
    else
      if (nmerge < (unsigned int)2) {
        char const *tmp_1;
        int tmp_2;
        tmp_1 = quote(s);
        ;
        tmp_2 = gettext("invalid --%s argument %s");
        {
          char const *__va_arg0 = long_options[oi].name;
          char const *__va_arg1 = tmp_1;
          void *__va_args[2] = {& __va_arg0, & __va_arg1};
          error(0,0,(char const *)tmp_2,(void * const *)(__va_args));
        }
        if (! (! sizeof(struct __anonstruct_49))) {
          char const *tmp_3;
          int tmp_4;
          tmp_3 = quote("2");
          ;
          tmp_4 = gettext("minimum --%s argument is %s");
          {
            char const *__va_arg0_27 = long_options[oi].name;
            char const *__va_arg1_29 = tmp_3;
            void *__va_args_31[2] = {& __va_arg0_27, & __va_arg1_29};
            error(SORT_FAILURE,0,(char const *)tmp_4,
                  (void * const *)(__va_args_31));
          }
          __builtin_unreachable();
        }
        else {
          char const *tmp_5;
          int tmp_6;
          tmp_5 = quote("2");
          ;
          tmp_6 = gettext("minimum --%s argument is %s");
          {
            char const *__va_arg0_33 = long_options[oi].name;
            char const *__va_arg1_35 = tmp_5;
            void *__va_args_37[2] = {& __va_arg0_33, & __va_arg1_35};
            error(SORT_FAILURE,0,(char const *)tmp_6,
                  (void * const *)(__va_args_37));
          }
          __builtin_unreachable();
        }
      }
      else
        if (max_nmerge < nmerge) e = LONGINT_OVERFLOW;
        else goto return_label;
  }
  if (e == (unsigned int)LONGINT_OVERFLOW) {
    char max_nmerge_buf[(((sizeof(max_nmerge) * (unsigned int)8 - (unsigned int)(! 1)) * (unsigned int)146 + (unsigned int)484) / (unsigned int)485 + (unsigned int)(! 1)) + (unsigned int)1];
    char const *tmp_7;
    int tmp_8;
    tmp_7 = quote(s);
    ;
    tmp_8 = gettext("--%s argument %s too large");
    {
      char const *__va_arg0_39 = long_options[oi].name;
      char const *__va_arg1_41 = tmp_7;
      void *__va_args_43[2] = {& __va_arg0_39, & __va_arg1_41};
      error(0,0,(char const *)tmp_8,(void * const *)(__va_args_43));
    }
    if (! (! sizeof(struct __anonstruct_50))) {
      char *tmp_9;
      int tmp_10;
      tmp_9 = uinttostr(max_nmerge,max_nmerge_buf);
      ;
      tmp_10 = gettext("maximum --%s argument with current rlimit is %s");
      {
        char const *__va_arg0_45 = long_options[oi].name;
        char *__va_arg1_47 = tmp_9;
        void *__va_args_49[2] = {& __va_arg0_45, & __va_arg1_47};
        error(SORT_FAILURE,0,(char const *)tmp_10,
              (void * const *)(__va_args_49));
      }
      __builtin_unreachable();
    }
    else {
      char *tmp_11;
      int tmp_12;
      tmp_11 = uinttostr(max_nmerge,max_nmerge_buf);
      ;
      tmp_12 = gettext("maximum --%s argument with current rlimit is %s");
      {
        char const *__va_arg0_51 = long_options[oi].name;
        char *__va_arg1_53 = tmp_11;
        void *__va_args_55[2] = {& __va_arg0_51, & __va_arg1_53};
        error(SORT_FAILURE,0,(char const *)tmp_12,
              (void * const *)(__va_args_55));
      }
      __builtin_unreachable();
    }
  }
  else xstrtol_fatal(e,oi,c,long_options,s);
  return_label: return;
}

static void specify_sort_size(int oi, char c, char const *s)
{
  uintmax_t n;
  char *suffix;
  enum strtol_error e = xstrtoumax(s,& suffix,10,& n,"EgGkKmMPtTYZ");
  if (e == (unsigned int)LONGINT_OK)
    if ((unsigned int)*(suffix + -1) - (unsigned int)'0' <= (unsigned int)9)
      if ((unsigned long long)n <= 0xffffffffffffffffUL / (unsigned long long)1024)
        n *= (uintmax_t)1024;
      else e = LONGINT_OVERFLOW;
  if (e == (unsigned int)LONGINT_INVALID_SUFFIX_CHAR)
    if ((unsigned int)*(suffix + -1) - (unsigned int)'0' <= (unsigned int)9)
      if (! *(suffix + 1))
        switch ((int)*(suffix + 0)) {
          case 'b': e = LONGINT_OK;
          break;
          case '%':
          {
            double tmp_0;
            tmp_0 = physmem_total();
            double mem = (tmp_0 * (double)n) / (double)100;
            if (mem < (double)0xffffffffffffffffUL) {
              n = (unsigned long)mem;
              e = LONGINT_OK;
            }
            else e = LONGINT_OVERFLOW;
          }
          break;
        }
  if (e == (unsigned int)LONGINT_OK) {
    if (n < sort_size) goto return_label;
    sort_size = n;
    if (sort_size == n) {
      if (sort_size > (size_t)(nmerge * ((unsigned int)2 + sizeof(struct line))))
        sort_size = sort_size;
      else sort_size = (unsigned long)(nmerge * ((unsigned int)2 + sizeof(struct line)));
      goto return_label;
    }
    e = LONGINT_OVERFLOW;
  }
  xstrtol_fatal(e,oi,c,long_options,s);
  return_label: return;
}

static size_t specify_nthreads(int oi, char c, char const *s)
{
  size_t __retres;
  uintmax_t nthreads;
  enum strtol_error e = xstrtoumax(s,(char **)0,10,& nthreads,"");
  if (e == (unsigned int)LONGINT_OVERFLOW) {
    __retres = (unsigned long)0xffffffffffffffffUL;
    goto return_label;
  }
  if (e != (unsigned int)LONGINT_OK) xstrtol_fatal(e,oi,c,long_options,s);
  if (0xffffffffffffffffUL < (unsigned long long)nthreads) nthreads = (unsigned long)0xffffffffffffffffUL;
  if (nthreads == (uintmax_t)0)
    if (! (! sizeof(struct __anonstruct_51))) {
      int tmp_0;
      tmp_0 = gettext("number in parallel must be nonzero");
      {
        void *__va_args[1] = {(void *)0};
        error(SORT_FAILURE,0,(char const *)tmp_0,(void * const *)(__va_args));
      }
      __builtin_unreachable();
    }
    else {
      int tmp_1;
      tmp_1 = gettext("number in parallel must be nonzero");
      {
        void *__va_args_11[1] = {(void *)0};
        error(SORT_FAILURE,0,(char const *)tmp_1,
              (void * const *)(__va_args_11));
      }
      __builtin_unreachable();
    }
  __retres = nthreads;
  return_label: return __retres;
}

static size_t default_sort_size(void)
{
  struct rlimit rlimit;
  double tmp_1;
  size_t tmp_2;
  size_t size = (unsigned long)0xffffffffffffffffUL;
  if (-1 == 0)
    if (rlimit.rlim_cur < size) size = rlimit.rlim_cur;
  size /= (size_t)2;
  double avail = physmem_available();
  double total = physmem_total();
  if (avail > total / (double)8) tmp_1 = avail;
  else tmp_1 = total / (double)8;
  double mem = tmp_1;
  if (total * 0.75 < (double)size) size = (unsigned long)(total * 0.75);
  if (mem < (double)size) size = (unsigned long)mem;
  if (size > (size_t)(nmerge * ((unsigned int)2 + sizeof(struct line))))
    tmp_2 = size;
  else tmp_2 = (unsigned long)(nmerge * ((unsigned int)2 + sizeof(struct line)));
  return tmp_2;
}

static size_t sort_buffer_size_size_bound;
static size_t sort_buffer_size(FILE * const *fps, size_t nfps,
                               char * const *files, size_t nfiles,
                               size_t line_bytes)
{
  size_t __retres;
  size_t worst_case_per_input_byte = line_bytes + (size_t)1;
  size_t size = worst_case_per_input_byte + (size_t)1;
  {
    size_t i = (unsigned long)0;
    while (i < nfiles) {
      {
        struct stat st;
        off_t file_size;
        size_t worst_case;
        int tmp_6;
        if (i < nfps) {
          int tmp_1;
          int tmp_0;
          tmp_0 = fileno(*(fps + i));
          tmp_1 = fstat(tmp_0,& st);
          tmp_6 = tmp_1;
        }
        else {
          int tmp_5;
          int tmp_2;
          tmp_2 = strcmp((char const *)*(files + i),"-");
          if (tmp_2 == 0) tmp_5 = fstat(0,& st);
          else tmp_5 = stat((char const *)*(files + i),& st);
          tmp_6 = tmp_5;
        }
        if (tmp_6 != 0) {
          int tmp;
          ;
          tmp = gettext("stat failed");
          sort_die((char const *)tmp,(char const *)*(files + i));
        }
        if ((st.st_mode & (unsigned int)0170000) == (unsigned int)0100000)
          file_size = st.st_size;
        else {
          if (sort_size) {
            __retres = sort_size;
            goto return_label;
          }
          file_size = (long)(128 * 1024);
        }
        if (! sort_buffer_size_size_bound) {
          sort_buffer_size_size_bound = sort_size;
          if (! sort_buffer_size_size_bound) sort_buffer_size_size_bound = default_sort_size
                                             ();
        }
        worst_case = (size_t)file_size * worst_case_per_input_byte + (size_t)1;
        if ((size_t)file_size != worst_case / worst_case_per_input_byte) {
          __retres = sort_buffer_size_size_bound;
          goto return_label;
        }
        else
          if (sort_buffer_size_size_bound - size <= worst_case) {
            __retres = sort_buffer_size_size_bound;
            goto return_label;
          }
        size += worst_case;
      }
      i ++;
    }
  }
  __retres = size;
  return_label: return __retres;
}

static void initbuf(struct buffer *buf, size_t line_bytes, size_t alloc)
{
  size_t tmp_0;
  size_t tmp;
  while (1) {
    alloc += (unsigned long)sizeof(struct line) - alloc % (unsigned long)sizeof(struct line);
    buf->buf = (char *)malloc(alloc);
    if (buf->buf) break;
    alloc /= (size_t)2;
    if (alloc <= line_bytes + (size_t)1) xalloc_die();
  }
  buf->line_bytes = line_bytes;
  buf->alloc = alloc;
  tmp_0 = (unsigned long)0;
  buf->nlines = tmp_0;
  tmp = tmp_0;
  buf->left = tmp;
  buf->used = tmp;
  buf->eof = (_Bool)0;
  return;
}

__inline static struct line *buffer_linelim(struct buffer const *buf)
{
  struct line *__retres;
  void *linelim = (void *)(buf->buf + buf->alloc);
  __retres = (struct line *)linelim;
  return __retres;
}

static char *begfield(struct line const *line, struct keyfield const *key)
{
  char *ptr = line->text;
  char *lim = (ptr + line->length) - 1;
  size_t sword = key->sword;
  size_t schar = key->schar;
  if (tab != TAB_DEFAULT)
    while (1) {
      if (ptr < lim) {
        size_t tmp;
        tmp = sword;
        sword --;
        ;
        if (! tmp) break;
      }
      else break;
      while (1) {
        if (ptr < lim) {
          if (! ((int)*ptr != tab)) break;
        }
        else break;
        ptr ++;
      }
      if (ptr < lim) ptr ++;
    }
  else
    while (1) {
      if (ptr < lim) {
        size_t tmp_2;
        tmp_2 = sword;
        sword --;
        ;
        if (! tmp_2) break;
      }
      else break;
      while (1) {
        if (ptr < lim) {
          unsigned char tmp_0;
          tmp_0 = to_uchar(*ptr);
          ;
          if (! blanks[tmp_0]) break;
        }
        else break;
        ptr ++;
      }
      while (1) {
        if (ptr < lim) {
          unsigned char tmp_1;
          tmp_1 = to_uchar(*ptr);
          ;
          if (blanks[tmp_1]) break;
        }
        else break;
        ptr ++;
      }
    }
  if (key->skipsblanks)
    while (1) {
      if (ptr < lim) {
        unsigned char tmp_3;
        tmp_3 = to_uchar(*ptr);
        ;
        if (! blanks[tmp_3]) break;
      }
      else break;
      ptr ++;
    }
  if (lim < ptr + schar) ptr = lim; else ptr += schar;
  return ptr;
}

static char *limfield(struct line const *line, struct keyfield const *key)
{
  char *ptr = line->text;
  char *lim = (ptr + line->length) - 1;
  size_t eword = key->eword;
  size_t echar = key->echar;
  if (echar == (size_t)0) eword ++;
  if (tab != TAB_DEFAULT)
    while (1) {
      if (ptr < lim) {
        size_t tmp;
        tmp = eword;
        eword --;
        ;
        if (! tmp) break;
      }
      else break;
      while (1) {
        if (ptr < lim) {
          if (! ((int)*ptr != tab)) break;
        }
        else break;
        ptr ++;
      }
      if (ptr < lim)
        if (eword) ptr ++;
        else
          if (echar) ptr ++;
    }
  else
    while (1) {
      if (ptr < lim) {
        size_t tmp_2;
        tmp_2 = eword;
        eword --;
        ;
        if (! tmp_2) break;
      }
      else break;
      while (1) {
        if (ptr < lim) {
          unsigned char tmp_0;
          tmp_0 = to_uchar(*ptr);
          ;
          if (! blanks[tmp_0]) break;
        }
        else break;
        ptr ++;
      }
      while (1) {
        if (ptr < lim) {
          unsigned char tmp_1;
          tmp_1 = to_uchar(*ptr);
          ;
          if (blanks[tmp_1]) break;
        }
        else break;
        ptr ++;
      }
    }
  if (echar != (size_t)0) {
    if (key->skipeblanks)
      while (1) {
        if (ptr < lim) {
          unsigned char tmp_3;
          tmp_3 = to_uchar(*ptr);
          ;
          if (! blanks[tmp_3]) break;
        }
        else break;
        ptr ++;
      }
    if (lim < ptr + echar) ptr = lim; else ptr += echar;
  }
  return ptr;
}

static _Bool fillbuf(struct buffer *buf, FILE *fp, char const *file)
{
  _Bool __retres;
  struct keyfield const *key = (struct keyfield const *)keylist;
  char eol = eolchar;
  size_t line_bytes = buf->line_bytes;
  size_t mergesize =
    merge_buffer_size - (size_t)((unsigned int)2 + sizeof(struct line));
  if (buf->eof) {
    __retres = (_Bool)0;
    goto return_label;
  }
  if (buf->used != buf->left) {
    memmove((void *)buf->buf,
            (void const *)((buf->buf + buf->used) - buf->left),buf->left);
    buf->used = buf->left;
    buf->nlines = (unsigned long)0;
  }
  while (1) {
    {
      char *tmp_0;
      struct line *tmp_6;
      char *ptr = buf->buf + buf->used;
      struct line *linelim = buffer_linelim((struct buffer const *)buf);
      struct line *line = linelim - buf->nlines;
      size_t avail =
        (unsigned long)(((char *)linelim - buf->nlines * line_bytes) - ptr);
      if (buf->nlines) tmp_0 = line->text + line->length;
      else tmp_0 = buf->buf;
      char *line_start = tmp_0;
      while (line_bytes + (size_t)1 < avail) {
        char *p;
        size_t readsize = (avail - (size_t)1) / (line_bytes + (size_t)1);
        size_t bytes_read =
          fread_unlocked((void *)ptr,(unsigned long)1,readsize,fp);
        char *ptrlim = ptr + bytes_read;
        avail -= bytes_read;
        if (bytes_read != readsize) {
          if (((int)fp->_flags & 0x0040) != 0) {
            int tmp_2;
            ;
            tmp_2 = gettext("read failed");
            sort_die((char const *)tmp_2,file);
          }
          if (((int)fp->_flags & 0x0020) != 0) {
            buf->eof = (_Bool)1;
            if (buf->buf == ptrlim) {
              __retres = (_Bool)0;
              goto return_label;
            }
            if (line_start != ptrlim)
              if ((int)*(ptrlim + -1) != (int)eol) {
                char *tmp_3;
                tmp_3 = ptrlim;
                ptrlim ++;
                *tmp_3 = eol;
              }
          }
        }
        while (1) {
          p = (char *)memchr((void const *)ptr,(int)eol,
                             (unsigned long)(ptrlim - ptr));
          if (! p) break;
          *p = (char)0;
          ptr = p + 1;
          line --;
          line->text = line_start;
          line->length = (unsigned long)(ptr - line_start);
          if (mergesize > line->length) mergesize = mergesize;
          else mergesize = line->length;
          avail -= line_bytes;
          if (key) {
            if ((unsigned long long)key->eword == 0xffffffffffffffffUL)
              line->keylim = p;
            else line->keylim = limfield((struct line const *)line,key);
            if ((unsigned long long)key->sword != 0xffffffffffffffffUL)
              line->keybeg = begfield((struct line const *)line,key);
            else {
              if (key->skipsblanks)
                while (1) {
                  unsigned char tmp_5;
                  tmp_5 = to_uchar(*line_start);
                  ;
                  if (! blanks[tmp_5]) break;
                  line_start ++;
                }
              line->keybeg = line_start;
            }
          }
          line_start = ptr;
        }
        ptr = ptrlim;
        if (buf->eof) break;
      }
      buf->used = (unsigned long)(ptr - buf->buf);
      tmp_6 = buffer_linelim((struct buffer const *)buf);
      buf->nlines = (unsigned long)(tmp_6 - line);
      if (buf->nlines != (size_t)0) {
        buf->left = (unsigned long)(ptr - line_start);
        merge_buffer_size = mergesize + (size_t)((unsigned int)2 + sizeof(struct line));
        __retres = (_Bool)1;
        goto return_label;
      }
      {
        size_t line_alloc = buf->alloc / (size_t)sizeof(struct line);
        buf->buf = (char *)x2nrealloc__fc_inline((void *)buf->buf,
                                                 & line_alloc,
                                                 (unsigned long)sizeof(struct line));
        buf->alloc = line_alloc * (size_t)sizeof(struct line);
      }
    }
  }
  return_label: return __retres;
}

static char const unit_order[(0x7f * 2 + 1) + 1] =
  {(char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)6,
   (char)0,
   (char)3,
   (char)0,
   (char)0,
   (char)0,
   (char)1,
   (char)0,
   (char)2,
   (char)0,
   (char)0,
   (char)5,
   (char)0,
   (char)0,
   (char)0,
   (char)4,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)8,
   (char)7,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)1,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0};
static unsigned char traverse_raw_number(char const **number)
{
  unsigned char __retres;
  unsigned char ch;
  char const *p = *number;
  unsigned char max_digit = (unsigned char)0;
  _Bool ends_with_thousands_sep = (_Bool)0;
  while (1) {
    char const *tmp;
    tmp = p;
    p ++;
    ch = (unsigned char)*tmp;
    if (! ((unsigned int)ch - (unsigned int)'0' <= (unsigned int)9))
      break;
    if ((int)max_digit < (int)ch) max_digit = ch;
    ends_with_thousands_sep = (_Bool)((int)*p == thousands_sep);
    if (ends_with_thousands_sep) p ++;
  }
  if (ends_with_thousands_sep) {
    *number = p - 2;
    __retres = max_digit;
    goto return_label;
  }
  if ((int)ch == decimal_point)
    while (1) {
      char const *tmp_0;
      tmp_0 = p;
      p ++;
      ch = (unsigned char)*tmp_0;
      if (! ((unsigned int)ch - (unsigned int)'0' <= (unsigned int)9))
        break;
      if ((int)max_digit < (int)ch) max_digit = ch;
    }
  *number = p - 1;
  __retres = max_digit;
  return_label: return __retres;
}

static int __attribute__((__pure__)) find_unit_order(char const *number)
{
  int __attribute__((__pure__)) __retres;
  _Bool minus_sign = (_Bool)((int)*number == '-');
  char const *p = number + (int)minus_sign;
  unsigned char max_digit = traverse_raw_number(& p);
  if ('0' < (int)max_digit) {
    int tmp_0;
    unsigned char ch = (unsigned char)*p;
    int order = (int)unit_order[ch];
    if (minus_sign) tmp_0 = - order; else tmp_0 = order;
    __retres = (int __attribute__((__pure__)))tmp_0;
    goto return_label;
  }
  else {
    __retres = (int __attribute__((__pure__)))0;
    goto return_label;
  }
  return_label: return __retres;
}

static int human_numcompare(char const *a, char const *b)
{
  int __attribute__((__pure__)) tmp_1;
  int __attribute__((__pure__)) tmp_2;
  int tmp_4;
  while (1) {
    unsigned char tmp;
    tmp = to_uchar(*a);
    ;
    if (! blanks[tmp]) break;
    a ++;
  }
  while (1) {
    unsigned char tmp_0;
    tmp_0 = to_uchar(*b);
    ;
    if (! blanks[tmp_0]) break;
    b ++;
  }
  tmp_1 = find_unit_order(a);
  tmp_2 = find_unit_order(b);
  int diff = (int)(tmp_1 - tmp_2);
  if (diff) tmp_4 = diff;
  else tmp_4 = strnumcmp(a,b,decimal_point,thousands_sep);
  return tmp_4;
}

static int numcompare(char const *a, char const *b)
{
  int tmp_1;
  while (1) {
    unsigned char tmp;
    tmp = to_uchar(*a);
    ;
    if (! blanks[tmp]) break;
    a ++;
  }
  while (1) {
    unsigned char tmp_0;
    tmp_0 = to_uchar(*b);
    ;
    if (! blanks[tmp_0]) break;
    b ++;
  }
  tmp_1 = strnumcmp(a,b,decimal_point,thousands_sep);
  return tmp_1;
}

extern int ( /* missing proto */ strtold)(char const *x_0, void *x_1);

static int nan_compare(char const *sa, char const *sb)
{
  long double a;
  int tmp;
  long double b;
  int tmp_0;
  int tmp_1;
  memset((void *)(& a),0,(unsigned long)sizeof(a));
  tmp = strtold(sa,(void *)0);
  a = (long double)tmp;
  memset((void *)(& b),0,(unsigned long)sizeof(b));
  tmp_0 = strtold(sb,(void *)0);
  b = (long double)tmp_0;
  tmp_1 = memcmp((void const *)(& a),(void const *)(& b),
                 (unsigned long)sizeof(a));
  return tmp_1;
}

static int general_numcompare(char const *sa, char const *sb)
{
  int __retres;
  char *ea;
  char *eb;
  int tmp;
  int tmp_0;
  int tmp_7;
  tmp = strtold(sa,(void *)(& ea));
  long double a = (long double)tmp;
  tmp_0 = strtold(sb,(void *)(& eb));
  long double b = (long double)tmp_0;
  if ((void *)sa == (void *)ea) {
    int tmp_1;
    if ((void *)sb == (void *)eb) tmp_1 = 0; else tmp_1 = -1;
    __retres = tmp_1;
    goto return_label;
  }
  if ((void *)sb == (void *)eb) {
    __retres = 1;
    goto return_label;
  }
  if (a < b) tmp_7 = -1;
  else {
    int tmp_6;
    if (a > b) tmp_6 = 1;
    else {
      int tmp_5;
      if (a == b) tmp_5 = 0;
      else {
        int tmp_4;
        if (b == b) tmp_4 = -1;
        else {
          int tmp_3;
          if (a == a) tmp_3 = 1; else tmp_3 = nan_compare(sa,sb);
          tmp_4 = tmp_3;
        }
        tmp_5 = tmp_4;
      }
      tmp_6 = tmp_5;
    }
    tmp_7 = tmp_6;
  }
  __retres = tmp_7;
  return_label: return __retres;
}

static int getmonth(char const *month, char **ea)
{
  int __retres;
  size_t lo = (unsigned long)0;
  size_t hi = (unsigned long)12;
  while (1) {
    unsigned char tmp;
    tmp = to_uchar(*month);
    ;
    if (! blanks[tmp]) break;
    month ++;
  }
  while (1) {
    {
      size_t ix = (lo + hi) / (size_t)2;
      char const *m = month;
      char const *n = monthtab[ix].name;
      while (1) {
        {
          unsigned char tmp_4;
          unsigned char tmp_3;
          unsigned char tmp_5;
          if (! *n) {
            if (ea) *ea = (char *)m;
            __retres = monthtab[ix].val;
            goto return_label;
          }
          tmp_3 = to_uchar(*m);
          ;
          tmp_4 = to_uchar(fold_toupper[tmp_3]);
          tmp_5 = to_uchar(*n);
          if ((int)tmp_4 < (int)tmp_5) {
            hi = ix;
            break;
          }
          else {
            unsigned char tmp_1;
            unsigned char tmp_0;
            unsigned char tmp_2;
            tmp_0 = to_uchar(*m);
            ;
            tmp_1 = to_uchar(fold_toupper[tmp_0]);
            tmp_2 = to_uchar(*n);
            if ((int)tmp_1 > (int)tmp_2) {
              lo = ix + (size_t)1;
              break;
            }
          }
        }
        m ++;
        n ++;
      }
    }
    if (! (lo < hi)) break;
  }
  __retres = 0;
  return_label: return __retres;
}

static struct md5_ctx random_md5_state;
static void random_md5_state_init(char const *random_source)
{
  unsigned char buf[16];
  int tmp_3;
  struct randread_source *r =
    randread_new(random_source,(unsigned long)sizeof(buf));
  if (! r) {
    char const *tmp_0;
    int tmp_1;
    if (random_source) tmp_0 = random_source; else tmp_0 = "getrandom";
    tmp_1 = gettext("open failed");
    sort_die((char const *)tmp_1,tmp_0);
  }
  randread(r,(void *)(buf),(unsigned long)sizeof(buf));
  tmp_3 = randread_free(r);
  if (tmp_3 != 0) {
    int tmp_2;
    ;
    tmp_2 = gettext("close failed");
    sort_die((char const *)tmp_2,random_source);
  }
  md5_init_ctx(& random_md5_state);
  md5_process_bytes((void const *)(buf),(unsigned long)sizeof(buf),
                    & random_md5_state);
  return;
}

static size_t xstrxfrm(char * __restrict dest, char const * __restrict src,
                       size_t destsize)
{
  int *tmp;
  int *tmp_8;
  tmp = __errno();
  *tmp = 0;
  size_t translated_size = strxfrm(dest,src,destsize);
  tmp_8 = __errno();
  if (*tmp_8) {
    int tmp_1;
    int *tmp_2;
    int tmp_3;
    tmp_1 = gettext("string transformation failed");
    tmp_2 = __errno();
    {
      void *__va_args[1] = {(void *)0};
      error(0,*tmp_2,(char const *)tmp_1,(void * const *)(__va_args));
    }
    tmp_3 = gettext("set LC_ALL=\'C\' to work around the problem");
    {
      void *__va_args_17[1] = {(void *)0};
      error(0,0,(char const *)tmp_3,(void * const *)(__va_args_17));
    }
    if (! (! sizeof(struct __anonstruct_52))) {
      char *tmp_4;
      int tmp_5;
      tmp_4 = quotearg_n_style(0,locale_quoting_style,src);
      tmp_5 = gettext("the untransformed string was %s");
      {
        char *__va_arg0 = tmp_4;
        void *__va_args_20[1] = {& __va_arg0};
        error(SORT_FAILURE,0,(char const *)tmp_5,
              (void * const *)(__va_args_20));
      }
      __builtin_unreachable();
    }
    else {
      char *tmp_6;
      int tmp_7;
      tmp_6 = quotearg_n_style(0,locale_quoting_style,src);
      tmp_7 = gettext("the untransformed string was %s");
      {
        char *__va_arg0_22 = tmp_6;
        void *__va_args_24[1] = {& __va_arg0_22};
        error(SORT_FAILURE,0,(char const *)tmp_7,
              (void * const *)(__va_args_24));
      }
      __builtin_unreachable();
    }
  }
  return translated_size;
}

static int compare_random(char * __restrict texta, size_t lena,
                          char * __restrict textb, size_t lenb)
{
  char stackbuf[4000];
  uint32_t dig[2][(unsigned int)16 / sizeof(uint32_t)];
  struct md5_ctx s[2];
  int xfrm_diff = 0;
  char *buf = stackbuf;
  size_t bufsize = (unsigned long)sizeof(stackbuf);
  void *allocated = (void *)0;
  s[1] = random_md5_state;
  s[0] = s[1];
  if (hard_LC_COLLATE) {
    char const *lima = (char const *)(texta + lena);
    char const *limb = (char const *)(textb + lenb);
    while (1) {
      {
        size_t tmp_0;
        size_t tmp_4;
        size_t guess_bufsize = (size_t)3 * (lena + lenb) + (size_t)2;
        if (bufsize < guess_bufsize) {
          if (guess_bufsize > (bufsize * (size_t)3) / (size_t)2) bufsize = guess_bufsize;
          else bufsize = (bufsize * (size_t)3) / (size_t)2;
          free(allocated);
          allocated = malloc(bufsize);
          buf = (char *)allocated;
          if (! buf) {
            buf = stackbuf;
            bufsize = (unsigned long)sizeof(stackbuf);
          }
        }
        if ((void *)texta < (void *)lima) {
          size_t tmp;
          tmp = xstrxfrm(buf,(char const *)texta,bufsize);
          tmp_0 = tmp + (size_t)1;
        }
        else tmp_0 = (unsigned long)0;
        size_t sizea = tmp_0;
        _Bool a_fits = (_Bool)(sizea <= bufsize);
        if ((void *)textb < (void *)limb) {
          size_t tmp_3;
          size_t tmp_1;
          char *tmp_2;
          if (a_fits) tmp_1 = bufsize - sizea; else tmp_1 = (unsigned long)0;
          ;
          if (a_fits) tmp_2 = buf + sizea; else tmp_2 = (char *)0;
          tmp_3 = xstrxfrm(tmp_2,(char const *)textb,tmp_1);
          tmp_4 = tmp_3 + (size_t)1;
        }
        else tmp_4 = (unsigned long)0;
        size_t sizeb = tmp_4;
        if (a_fits) {
          if (! (sizea + sizeb <= bufsize)) goto _LAND;
        }
        else {
          _LAND:
          {
            bufsize = sizea + sizeb;
            if ((unsigned long long)bufsize < 0xffffffffffffffffUL / (unsigned long long)3)
              bufsize = (bufsize * (size_t)3) / (size_t)2;
            free(allocated);
            allocated = xmalloc(bufsize);
            buf = (char *)allocated;
            if ((void *)texta < (void *)lima) strxfrm(buf,
                                                      (char const *)texta,
                                                      sizea);
            if ((void *)textb < (void *)limb) strxfrm(buf + sizea,
                                                      (char const *)textb,
                                                      sizeb);
          }
        }
        if ((void *)texta < (void *)lima) {
          size_t tmp_5;
          tmp_5 = strlen((char const *)texta);
          texta += tmp_5 + (size_t)1;
        }
        if ((void *)textb < (void *)limb) {
          size_t tmp_6;
          tmp_6 = strlen((char const *)textb);
          textb += tmp_6 + (size_t)1;
        }
        if (! ((void *)texta < (void *)lima))
          if (! ((void *)textb < (void *)limb)) {
            lena = sizea;
            texta = buf;
            lenb = sizeb;
            textb = buf + sizea;
            break;
          }
        md5_process_bytes((void const *)buf,sizea,s);
        md5_process_bytes((void const *)(buf + sizea),sizeb,& s[1]);
        if (! xfrm_diff) {
          size_t tmp_7;
          if (sizea < sizeb) tmp_7 = sizea; else tmp_7 = sizeb;
          ;
          ;
          xfrm_diff = memcmp((void const *)buf,(void const *)(buf + sizea),
                             tmp_7);
          if (! xfrm_diff) xfrm_diff = (sizea > sizeb) - (sizea < sizeb);
        }
      }
    }
  }
  md5_process_bytes((void const *)texta,lena,s);
  md5_finish_ctx(s,(void *)(dig[0]));
  md5_process_bytes((void const *)textb,lenb,& s[1]);
  md5_finish_ctx(& s[1],(void *)(dig[1]));
  int diff =
    memcmp((void const *)(dig[0]),(void const *)(dig[1]),
           (unsigned long)sizeof(dig[0]));
  if (! diff) {
    if (! xfrm_diff) {
      size_t tmp_9;
      if (lena < lenb) tmp_9 = lena; else tmp_9 = lenb;
      ;
      ;
      xfrm_diff = memcmp((void const *)texta,(void const *)textb,tmp_9);
      if (! xfrm_diff) xfrm_diff = (lena > lenb) - (lena < lenb);
    }
    diff = xfrm_diff;
  }
  free(allocated);
  return diff;
}

static size_t debug_width(char const *text, char const *lim)
{
  int tmp;
  tmp = mbsnwidth(text,(unsigned long)(lim - text),0);
  size_t width = (unsigned long)tmp;
  while (text < lim) {
    char const *tmp_0;
    tmp_0 = text;
    text ++;
    width += (size_t)((int)*tmp_0 == '\t');
  }
  return width;
}

static void mark_key(size_t offset, size_t width)
{
  while (1) {
    size_t tmp;
    tmp = offset;
    offset --;
    ;
    if (! tmp) break;
    _putchar_unlocked(' ');
  }
  if (! width) {
    int tmp_0;
    tmp_0 = gettext("^ no match for key\n");
    {
      void *__va_args[1] = {(void *)0};
      printf((char const *)tmp_0,(void * const *)(__va_args));
    }
  }
  else {
    while (1) {
      _putchar_unlocked('_');
      width --;
      if (! width) break;
    }
    _putchar_unlocked('\n');
  }
  return;
}

__inline static _Bool key_numeric(struct keyfield const *key)
{
  _Bool __retres;
  int tmp;
  if (key->numeric) tmp = 1;
  else
    if (key->general_numeric) tmp = 1;
    else
      if (key->human_numeric) tmp = 1; else tmp = 0;
  __retres = (_Bool)(tmp != 0);
  return __retres;
}

static void debug_key(struct line const *line, struct keyfield const *key)
{
  char *text = line->text;
  char *beg = text;
  char *lim = (text + line->length) - 1;
  if (key) {
    if ((unsigned long long)key->sword != 0xffffffffffffffffUL) beg = begfield
                                                                (line,key);
    if ((unsigned long long)key->eword != 0xffffffffffffffffUL) lim = limfield
                                                                (line,key);
    if (key->skipsblanks) {
      if ((unsigned long long)key->sword == 0xffffffffffffffffUL) goto _LOR_0;
      else goto _LAND;
    }
    else {
      _LAND: ;
      if (key->month) goto _LOR_0;
      else {
        _Bool tmp_5;
        tmp_5 = key_numeric(key);
        if (tmp_5) {
          _LOR_0:
          {
            char saved = *lim;
            *lim = (char)0;
            while (1) {
              unsigned char tmp;
              tmp = to_uchar(*beg);
              ;
              if (! blanks[tmp]) break;
              beg ++;
            }
            char *tighter_lim = beg;
            if (lim < beg) tighter_lim = lim;
            else
              if (key->month) getmonth((char const *)beg,& tighter_lim);
              else
                if (key->general_numeric) {
                  int __x =
                    strtold((char const *)beg,(void *)(& tighter_lim));
                  int tmp_2 = __x;
                }
                else
                  if (key->numeric) goto _LOR;
                  else
                    if (key->human_numeric) {
                      _LOR:
                      {
                        int tmp_2_0;
                        if (beg < lim)
                          if ((int)*beg == '-') tmp_2_0 = 1;
                          else tmp_2_0 = 0;
                        else tmp_2_0 = 0;
                        char const *p = (char const *)(beg + tmp_2_0);
                        unsigned char max_digit = traverse_raw_number(& p);
                        if ('0' <= (int)max_digit) {
                          int tmp_4;
                          unsigned char ch = (unsigned char)*p;
                          if (key->human_numeric)
                            if (unit_order[ch]) tmp_4 = 1; else tmp_4 = 0;
                          else tmp_4 = 0;
                          tighter_lim = (char *)p + tmp_4;
                        }
                      }
                    }
                    else tighter_lim = lim;
            *lim = saved;
            lim = tighter_lim;
          }
        }
      }
    }
  }
  size_t offset = debug_width((char const *)text,(char const *)beg);
  size_t width = debug_width((char const *)beg,(char const *)lim);
  mark_key(offset,width);
  return;
}

static void debug_line(struct line const *line)
{
  struct keyfield const *key = (struct keyfield const *)keylist;
  while (1) {
    debug_key(line,key);
    if (key) {
      key = (struct keyfield const *)key->next;
      if (! key)
        if (unique) break;
        else
          if (stable) break;
    }
    else break;
  }
  return;
}

static _Bool default_key_compare(struct keyfield const *key)
{
  _Bool __retres;
  int tmp_0;
  if (key->ignore) tmp_0 = 0;
  else
    if (key->translate) tmp_0 = 0;
    else
      if (key->skipsblanks) tmp_0 = 0;
      else
        if (key->skipeblanks) tmp_0 = 0;
        else {
          _Bool tmp;
          tmp = key_numeric(key);
          if (tmp) tmp_0 = 0;
          else
            if (key->month) tmp_0 = 0;
            else
              if (key->version) tmp_0 = 0;
              else
                if (key->random) tmp_0 = 0; else tmp_0 = 1;
        }
  __retres = (_Bool)(tmp_0 != 0);
  return __retres;
}

static void key_to_opts(struct keyfield const *key, char *opts)
{
  if (key->skipsblanks) goto _LOR;
  else
    if (key->skipeblanks) {
      char *tmp;
      _LOR: { /* sequence */
              tmp = opts;
              opts ++;
              *tmp = (char)'b';
            }
    }
  if ((void *)key->ignore == (void *)(nondictionary)) {
    char *tmp_0;
    tmp_0 = opts;
    opts ++;
    *tmp_0 = (char)'d';
  }
  if (key->translate) {
    char *tmp_1;
    tmp_1 = opts;
    opts ++;
    *tmp_1 = (char)'f';
  }
  if (key->general_numeric) {
    char *tmp_2;
    tmp_2 = opts;
    opts ++;
    *tmp_2 = (char)'g';
  }
  if (key->human_numeric) {
    char *tmp_3;
    tmp_3 = opts;
    opts ++;
    *tmp_3 = (char)'h';
  }
  if ((void *)key->ignore == (void *)(nonprinting)) {
    char *tmp_4;
    tmp_4 = opts;
    opts ++;
    *tmp_4 = (char)'i';
  }
  if (key->month) {
    char *tmp_5;
    tmp_5 = opts;
    opts ++;
    *tmp_5 = (char)'M';
  }
  if (key->numeric) {
    char *tmp_6;
    tmp_6 = opts;
    opts ++;
    *tmp_6 = (char)'n';
  }
  if (key->random) {
    char *tmp_7;
    tmp_7 = opts;
    opts ++;
    *tmp_7 = (char)'R';
  }
  if (key->reverse) {
    char *tmp_8;
    tmp_8 = opts;
    opts ++;
    *tmp_8 = (char)'r';
  }
  if (key->version) {
    char *tmp_9;
    tmp_9 = opts;
    opts ++;
    *tmp_9 = (char)'V';
  }
  *opts = (char)0;
  return;
}

extern int ( /* missing proto */ ngettext)(char const *x_0, char const *x_1,
                                           unsigned long x_2);

static void key_warnings(struct keyfield const *gkey, _Bool gkey_only)
{
  struct keyfield const *key;
  _Bool tmp_23;
  struct keyfield ugkey = *gkey;
  unsigned long keynum = (unsigned long)1;
  key = (struct keyfield const *)keylist;
  while (key) {
    {
      int tmp_12;
      int tmp_15;
      _Bool tmp_14;
      int tmp_16;
      if (key->traditional_used) {
        size_t tmp_11_0;
        char tmp[(((sizeof(uintmax_t) * (unsigned int)8 - (unsigned int)(! 1)) * (unsigned int)146 + (unsigned int)484) / (unsigned int)485 + (unsigned int)(! 1)) + (unsigned int)1];
        char obuf[((((sizeof(tmp_11_0) * (unsigned int)8 - (unsigned int)(! 1)) * (unsigned int)146 + (unsigned int)484) / (unsigned int)485 + (unsigned int)(! 1)) + (unsigned int)1) * (unsigned int)2 + (unsigned int)4];
        char nbuf[((((sizeof(tmp_11_0) * (unsigned int)8 - (unsigned int)(! 1)) * (unsigned int)146 + (unsigned int)484) / (unsigned int)485 + (unsigned int)(! 1)) + (unsigned int)1) * (unsigned int)2 + (unsigned int)5];
        char *tmp_0;
        char *tmp_1;
        char *tmp_2;
        char *tmp_3;
        char const *tmp_8;
        char const *tmp_9;
        int tmp_10;
        size_t sword = key->sword;
        size_t eword = key->eword;
        char *po = obuf;
        char *pn = nbuf;
        if ((unsigned long long)sword == 0xffffffffffffffffUL) sword ++;
        tmp_0 = umaxtostr(sword,tmp);
        tmp_1 = stpcpy(po,"+");
        po = stpcpy(tmp_1,(char const *)tmp_0);
        tmp_2 = umaxtostr(sword + (size_t)1,tmp);
        tmp_3 = stpcpy(pn,"-k ");
        pn = stpcpy(tmp_3,(char const *)tmp_2);
        if ((unsigned long long)key->eword != 0xffffffffffffffffUL) {
          char *tmp_4;
          char *tmp_5;
          char *tmp_6;
          char *tmp_7;
          tmp_4 = umaxtostr(eword + (size_t)1,tmp);
          tmp_5 = stpcpy(po," -");
          stpcpy(tmp_5,(char const *)tmp_4);
          tmp_6 = umaxtostr((eword + (size_t)1) + (size_t)((unsigned long long)key->echar == 0xffffffffffffffffUL),
                            tmp);
          tmp_7 = stpcpy(pn,",");
          stpcpy(tmp_7,(char const *)tmp_6);
        }
        tmp_8 = quote_n(1,(char const *)(nbuf));
        tmp_9 = quote_n(0,(char const *)(obuf));
        tmp_10 = gettext("obsolescent key %s used; consider %s instead");
        {
          char const *__va_arg0 = tmp_9;
          char const *__va_arg1 = tmp_8;
          void *__va_args[2] = {& __va_arg0, & __va_arg1};
          error(0,0,(char const *)tmp_10,(void * const *)(__va_args));
        }
      }
      if ((unsigned long long)key->sword != 0xffffffffffffffffUL)
        if (key->eword < key->sword) tmp_12 = 1; else tmp_12 = 0;
      else tmp_12 = 0;
      _Bool zero_width = (_Bool)(tmp_12 != 0);
      if (zero_width) {
        int tmp_13;
        ;
        tmp_13 = gettext("key %lu has zero width and will be ignored");
        {
          unsigned long __va_arg0_50 = keynum;
          void *__va_args_52[1] = {& __va_arg0_50};
          error(0,0,(char const *)tmp_13,(void * const *)(__va_args_52));
        }
      }
      tmp_14 = key_numeric(key);
      if (tmp_14) tmp_15 = 1;
      else
        if (key->month) tmp_15 = 1; else tmp_15 = 0;
      _Bool implicit_skip = (_Bool)(tmp_15 != 0);
      if (key->eword == (size_t)0)
        if (key->echar != (size_t)0) tmp_16 = 1; else tmp_16 = 0;
      else tmp_16 = 0;
      _Bool line_offset = (_Bool)(tmp_16 != 0);
      if (! zero_width)
        if (! gkey_only)
          if (tab == TAB_DEFAULT)
            if (! line_offset)
              if (! key->skipsblanks) {
                if (! implicit_skip) goto _LOR; else goto _LAND_0;
              }
              else
                _LAND_0:
                if (! key->skipsblanks) {
                  if (key->schar) goto _LOR; else goto _LAND;
                }
                else
                  _LAND:
                  if (! key->skipeblanks)
                    if (key->echar) {
                      int tmp_17;
                      _LOR:
                      { /* sequence */
                        ;
                        tmp_17 = gettext("leading blanks are significant in key %lu; consider also specifying \'b\'");
                      }
                      {
                        unsigned long __va_arg0_54 = keynum;
                        void *__va_args_56[1] = {& __va_arg0_54};
                        error(0,0,(char const *)tmp_17,
                              (void * const *)(__va_args_56));
                      }
                    }
      if (! gkey_only) {
        _Bool tmp_19;
        tmp_19 = key_numeric(key);
        if (tmp_19) {
          size_t sword_0 = key->sword + (size_t)1;
          size_t eword_0 = key->eword + (size_t)1;
          if (! sword_0) sword_0 ++;
          if (! eword_0) goto _LOR_0;
          else
            if (sword_0 < eword_0) {
              int tmp_18;
              _LOR_0:
              { /* sequence */
                ;
                tmp_18 = gettext("key %lu is numeric and spans multiple fields");
              }
              {
                unsigned long __va_arg0_58 = keynum;
                void *__va_args_60[1] = {& __va_arg0_58};
                error(0,0,(char const *)tmp_18,
                      (void * const *)(__va_args_60));
              }
            }
        }
      }
      if (ugkey.ignore)
        if (ugkey.ignore == key->ignore) ugkey.ignore = (_Bool const *)0;
      if (ugkey.translate)
        if (ugkey.translate == key->translate) ugkey.translate = (char const *)0;
      ugkey.skipsblanks = (_Bool)(((int)ugkey.skipsblanks & ! key->skipsblanks) != 0);
      ugkey.skipeblanks = (_Bool)(((int)ugkey.skipeblanks & ! key->skipeblanks) != 0);
      ugkey.month = (_Bool)(((int)ugkey.month & ! key->month) != 0);
      ugkey.numeric = (_Bool)(((int)ugkey.numeric & ! key->numeric) != 0);
      ugkey.general_numeric = (_Bool)(((int)ugkey.general_numeric & ! key->general_numeric) != 0);
      ugkey.human_numeric = (_Bool)(((int)ugkey.human_numeric & ! key->human_numeric) != 0);
      ugkey.random = (_Bool)(((int)ugkey.random & ! key->random) != 0);
      ugkey.version = (_Bool)(((int)ugkey.version & ! key->version) != 0);
      ugkey.reverse = (_Bool)(((int)ugkey.reverse & ! key->reverse) != 0);
    }
    key = (struct keyfield const *)key->next;
    keynum ++;
  }
  tmp_23 = default_key_compare((struct keyfield const *)(& ugkey));
  if (tmp_23) {
    if (ugkey.reverse)
      if (stable) goto _LOR_2;
      else
        if (unique) {
          _LOR_2: ;
          if (keylist) {
            _LOR_1:
            {
              char opts[sizeof(short_options)];
              int tmp_22;
              unsigned long tmp_21;
              size_t tmp_20;
              _Bool ugkey_reverse = ugkey.reverse;
              if (! stable)
                if (! unique) ugkey.reverse = (_Bool)0;
              key_to_opts((struct keyfield const *)(& ugkey),opts);
              tmp_20 = strlen((char const *)(opts));
              tmp_21 = select_plural(tmp_20);
              tmp_22 = ngettext("option \'-%s\' is ignored",
                                "options \'-%s\' are ignored",tmp_21);
              {
                char *__va_arg0_62 = opts;
                void *__va_args_64[1] = {& __va_arg0_62};
                error(0,0,(char const *)tmp_22,
                      (void * const *)(__va_args_64));
              }
              ugkey.reverse = ugkey_reverse;
            }
          }
        }
  }
  else goto _LOR_1;
  if (ugkey.reverse)
    if (! stable)
      if (! unique)
        if (keylist) {
          int tmp_24;
          tmp_24 = gettext("option \'-r\' only applies to last-resort comparison");
          {
            void *__va_args_66[1] = {(void *)0};
            error(0,0,(char const *)tmp_24,(void * const *)(__va_args_66));
          }
        }
  return;
}

static int keycompare(struct line const *a, struct line const *b)
{
  int __retres;
  int diff;
  int tmp_27;
  struct keyfield *key = keylist;
  char *texta = a->keybeg;
  char *textb = b->keybeg;
  char *lima = a->keylim;
  char *limb = b->keylim;
  while (1) {
    {
      char const *translate = key->translate;
      _Bool const *ignore = key->ignore;
      if (texta > lima) lima = texta; else lima = lima;
      if (textb > limb) limb = textb; else limb = limb;
      size_t lena = (unsigned long)(lima - texta);
      size_t lenb = (unsigned long)(limb - textb);
      if (hard_LC_COLLATE) goto _LOR_0;
      else {
        _Bool tmp_24;
        tmp_24 = key_numeric((struct keyfield const *)key);
        if (tmp_24) goto _LOR_0;
        else
          if (key->month) goto _LOR_0;
          else
            if (key->random) goto _LOR_0;
            else
              if (key->version) {
                _LOR_0:
                {
                  char *ta;
                  char *tb;
                  size_t tlena;
                  size_t tlenb;
                  char stackbuf[4000];
                  char enda = (char)0;
                  char endb = (char)0;
                  void *allocated = (void *)0;
                  if (ignore) goto _LOR;
                  else
                    if (translate) {
                      _LOR:
                      {
                        size_t i;
                        size_t size =
                          ((lena + (size_t)1) + lenb) + (size_t)1;
                        if (size <= (size_t)sizeof(stackbuf)) {
                          ta = stackbuf;
                          allocated = (void *)0;
                        }
                        else {
                          allocated = xmalloc(size);
                          ta = (char *)allocated;
                        }
                        tb = (ta + lena) + 1;
                        i = (unsigned long)0;
                        tlena = i;
                        while (i < lena) {
                          if (ignore) {
                            unsigned char tmp_1;
                            tmp_1 = to_uchar(*(texta + i));
                            ;
                            if (! *(ignore + tmp_1)) goto _LAND;
                          }
                          else {
                            size_t tmp;
                            _LAND:
                            { /* sequence */
                              tmp = tlena;
                              tlena ++;
                              if (translate) {
                                unsigned char tmp_0;
                                tmp_0 = to_uchar(*(texta + i));
                                *(ta + tmp) = *(translate + tmp_0);
                              }
                              else *(ta + tmp) = *(texta + i);
                            }
                          }
                          i ++;
                        }
                        *(ta + tlena) = (char)0;
                        i = (unsigned long)0;
                        tlenb = i;
                        while (i < lenb) {
                          if (ignore) {
                            unsigned char tmp_4;
                            tmp_4 = to_uchar(*(textb + i));
                            ;
                            if (! *(ignore + tmp_4)) goto _LAND_0;
                          }
                          else {
                            size_t tmp_2;
                            _LAND_0:
                            { /* sequence */
                              tmp_2 = tlenb;
                              tlenb ++;
                              if (translate) {
                                unsigned char tmp_3;
                                tmp_3 = to_uchar(*(textb + i));
                                *(tb + tmp_2) = *(translate + tmp_3);
                              }
                              else *(tb + tmp_2) = *(textb + i);
                            }
                          }
                          i ++;
                        }
                        *(tb + tlenb) = (char)0;
                      }
                    }
                    else {
                      ta = texta;
                      tlena = lena;
                      enda = *(ta + tlena);
                      *(ta + tlena) = (char)0;
                      tb = textb;
                      tlenb = lenb;
                      endb = *(tb + tlenb);
                      *(tb + tlenb) = (char)0;
                    }
                  if (key->numeric) diff = numcompare((char const *)ta,
                                                      (char const *)tb);
                  else
                    if (key->general_numeric) diff = general_numcompare
                                              ((char const *)ta,
                                               (char const *)tb);
                    else
                      if (key->human_numeric) diff = human_numcompare
                                              ((char const *)ta,
                                               (char const *)tb);
                      else
                        if (key->month) {
                          int tmp_5;
                          int tmp_6;
                          tmp_5 = getmonth((char const *)ta,(char **)0);
                          tmp_6 = getmonth((char const *)tb,(char **)0);
                          diff = tmp_5 - tmp_6;
                        }
                        else
                          if (key->random) diff = compare_random(ta,tlena,tb,
                                                                 tlenb);
                          else
                            if (key->version) diff = filevercmp((char const *)ta,
                                                                (char const *)tb);
                            else
                              if (tlena == (size_t)0) diff = - (tlenb != (size_t)0);
                              else
                                if (tlenb == (size_t)0) diff = 1;
                                else diff = xmemcoll0((char const *)ta,
                                                      tlena + (size_t)1,
                                                      (char const *)tb,
                                                      tlenb + (size_t)1);
                  if (ignore) free(allocated);
                  else
                    if (translate) free(allocated);
                    else {
                      *(ta + tlena) = enda;
                      *(tb + tlenb) = endb;
                    }
                }
              }
              else
                if (ignore)
                  if (translate) {
                    while (1) {
                      {
                        unsigned char tmp_10;
                        unsigned char tmp_9;
                        unsigned char tmp_12;
                        unsigned char tmp_11;
                        while (1) {
                          if (texta < lima) {
                            unsigned char tmp_7;
                            tmp_7 = to_uchar(*texta);
                            ;
                            if (! *(ignore + tmp_7)) break;
                          }
                          else break;
                          texta ++;
                        }
                        while (1) {
                          if (textb < limb) {
                            unsigned char tmp_8;
                            tmp_8 = to_uchar(*textb);
                            ;
                            if (! *(ignore + tmp_8)) break;
                          }
                          else break;
                          textb ++;
                        }
                        if (texta < lima) {
                          if (! (textb < limb)) break;
                        }
                        else break;
                        tmp_9 = to_uchar(*texta);
                        ;
                        tmp_10 = to_uchar(*(translate + tmp_9));
                        tmp_11 = to_uchar(*textb);
                        ;
                        tmp_12 = to_uchar(*(translate + tmp_11));
                        diff = (int)tmp_10 - (int)tmp_12;
                        if (diff) goto not_equal;
                        texta ++;
                        textb ++;
                      }
                    }
                    diff = (texta < lima) - (textb < limb);
                  }
                  else {
                    while (1) {
                      {
                        unsigned char tmp_15;
                        unsigned char tmp_16;
                        while (1) {
                          if (texta < lima) {
                            unsigned char tmp_13;
                            tmp_13 = to_uchar(*texta);
                            ;
                            if (! *(ignore + tmp_13)) break;
                          }
                          else break;
                          texta ++;
                        }
                        while (1) {
                          if (textb < limb) {
                            unsigned char tmp_14;
                            tmp_14 = to_uchar(*textb);
                            ;
                            if (! *(ignore + tmp_14)) break;
                          }
                          else break;
                          textb ++;
                        }
                        if (texta < lima) {
                          if (! (textb < limb)) break;
                        }
                        else break;
                        tmp_15 = to_uchar(*texta);
                        tmp_16 = to_uchar(*textb);
                        diff = (int)tmp_15 - (int)tmp_16;
                        if (diff) goto not_equal;
                        texta ++;
                        textb ++;
                      }
                    }
                    diff = (texta < lima) - (textb < limb);
                  }
                else
                  if (lena == (size_t)0) diff = - (lenb != (size_t)0);
                  else
                    if (lenb == (size_t)0) goto greater;
                    else {
                      if (translate)
                        while (1) {
                          if (texta < lima) {
                            if (! (textb < limb)) break;
                          }
                          else break;
                          {
                            unsigned char tmp_19;
                            unsigned char tmp_18;
                            char *tmp_17;
                            unsigned char tmp_22;
                            unsigned char tmp_21;
                            char *tmp_20;
                            tmp_17 = texta;
                            texta ++;
                            ;
                            tmp_18 = to_uchar(*tmp_17);
                            ;
                            tmp_19 = to_uchar(*(translate + tmp_18));
                            tmp_20 = textb;
                            textb ++;
                            ;
                            tmp_21 = to_uchar(*tmp_20);
                            ;
                            tmp_22 = to_uchar(*(translate + tmp_21));
                            diff = (int)tmp_19 - (int)tmp_22;
                            if (diff) goto not_equal;
                          }
                        }
                      else {
                        size_t tmp_23;
                        if (lena < lenb) tmp_23 = lena; else tmp_23 = lenb;
                        ;
                        ;
                        diff = memcmp((void const *)texta,
                                      (void const *)textb,tmp_23);
                        if (diff) goto not_equal;
                      }
                      if (lena < lenb) diff = -1; else diff = lena != lenb;
                    }
      }
      if (diff) goto not_equal;
      key = key->next;
      if (! key) break;
      if ((unsigned long long)key->eword != 0xffffffffffffffffUL) {
        lima = limfield(a,(struct keyfield const *)key);
        limb = limfield(b,(struct keyfield const *)key);
      }
      else {
        lima = (a->text + a->length) - 1;
        limb = (b->text + b->length) - 1;
      }
      if ((unsigned long long)key->sword != 0xffffffffffffffffUL) {
        texta = begfield(a,(struct keyfield const *)key);
        textb = begfield(b,(struct keyfield const *)key);
      }
      else {
        texta = a->text;
        textb = b->text;
        if (key->skipsblanks) {
          while (1) {
            if (texta < lima) {
              unsigned char tmp_25;
              tmp_25 = to_uchar(*texta);
              ;
              if (! blanks[tmp_25]) break;
            }
            else break;
            texta ++;
          }
          while (1) {
            if (textb < limb) {
              unsigned char tmp_26;
              tmp_26 = to_uchar(*textb);
              ;
              if (! blanks[tmp_26]) break;
            }
            else break;
            textb ++;
          }
        }
      }
    }
  }
  __retres = 0;
  goto return_label;
  greater: diff = 1;
  not_equal: ;
  if (key->reverse) tmp_27 = - diff; else tmp_27 = diff;
  __retres = tmp_27;
  return_label: return __retres;
}

static int compare(struct line const *a, struct line const *b)
{
  int __retres;
  int diff;
  size_t alen;
  size_t blen;
  int tmp_0;
  if (keylist) {
    diff = keycompare(a,b);
    if (diff) {
      __retres = diff;
      goto return_label;
    }
    else
      if (unique) {
        __retres = diff;
        goto return_label;
      }
      else
        if (stable) {
          __retres = diff;
          goto return_label;
        }
  }
  alen = a->length - (size_t)1;
  blen = b->length - (size_t)1;
  if (alen == (size_t)0) diff = - (blen != (size_t)0);
  else
    if (blen == (size_t)0) diff = 1;
    else
      if (hard_LC_COLLATE) diff = xmemcoll0((char const *)a->text,
                                            alen + (size_t)1,
                                            (char const *)b->text,
                                            blen + (size_t)1);
      else {
        size_t tmp;
        if (alen < blen) tmp = alen; else tmp = blen;
        ;
        ;
        diff = memcmp((void const *)a->text,(void const *)b->text,tmp);
        if (! diff)
          if (alen < blen) diff = -1; else diff = alen != blen;
      }
  if (reverse) tmp_0 = - diff; else tmp_0 = diff;
  __retres = tmp_0;
  return_label: return __retres;
}

static void write_line(struct line const *line, FILE *fp,
                       char const *output_file)
{
  char *buf = line->text;
  size_t n_bytes = line->length;
  char *ebuf = buf + n_bytes;
  if (! output_file) {
    if (debug) {
      char const *c = (char const *)buf;
      while ((void *)c < (void *)ebuf) {
        char const *tmp;
        int tmp_1;
        tmp = c;
        c ++;
        char wc = *tmp;
        if ((int)wc == '\t') wc = (char)'>';
        else
          if ((void *)c == (void *)ebuf) wc = (char)'\n';
        tmp_1 = fputc_unlocked((int)wc,fp);
        if (tmp_1 == -1) {
          int tmp_0;
          ;
          tmp_0 = gettext("write failed");
          sort_die((char const *)tmp_0,output_file);
        }
      }
      debug_line(line);
    }
    else goto _LAND;
  }
  else {
    _LAND:
    {
      size_t tmp_3;
      *(ebuf + -1) = eolchar;
      tmp_3 = fwrite_unlocked((void const *)buf,(unsigned long)1,n_bytes,fp);
      ;
      if (tmp_3 != n_bytes) {
        int tmp_2;
        ;
        tmp_2 = gettext("write failed");
        sort_die((char const *)tmp_2,output_file);
      }
      *(ebuf + -1) = (char)0;
    }
  }
  return;
}

static _Bool check(char const *file_name, char checkonly)
{
  struct buffer buf;
  struct line temp;
  size_t tmp_0;
  FILE *fp = xfopen(file_name,"r");
  size_t alloc = (unsigned long)0;
  uintmax_t line_number = (unsigned long)0;
  struct keyfield const *key = (struct keyfield const *)keylist;
  _Bool nonunique = (_Bool)(! unique);
  _Bool ordered = (_Bool)1;
  if (merge_buffer_size > sort_size) tmp_0 = merge_buffer_size;
  else tmp_0 = sort_size;
  initbuf(& buf,(unsigned long)sizeof(struct line),tmp_0);
  temp.text = (char *)0;
  while (1) {
    _Bool tmp_9;
    tmp_9 = fillbuf(& buf,fp,file_name);
    if (! tmp_9) break;
    {
      struct line const *line =
        buffer_linelim((struct buffer const *)(& buf));
      struct line const *linebase = line - buf.nlines;
      if (alloc) {
        int tmp_7;
        tmp_7 = compare((struct line const *)(& temp),line - 1);
        ;
        if ((int)nonunique <= tmp_7) {
          found_disorder:
          {
            if ((int)checkonly == 'c') {
              uintmax_t tmp_6_0;
              struct line *tmp_2;
              char hr_buf[(((sizeof(tmp_6_0) * (unsigned int)8 - (unsigned int)(! 1)) * (unsigned int)146 + (unsigned int)484) / (unsigned int)485 + (unsigned int)(! 1)) + (unsigned int)1];
              char *tmp_3;
              int tmp_4;
              int tmp_5;
              struct line const *disorder_line = line - 1;
              tmp_2 = buffer_linelim((struct buffer const *)(& buf));
              uintmax_t disorder_line_number =
                (uintmax_t)(tmp_2 - disorder_line) + line_number;
              tmp_3 = umaxtostr(disorder_line_number,hr_buf);
              ;
              ;
              tmp_4 = gettext("%s: %s:%s: disorder: ");
              ;
              {
                char const *__va_arg0 = program_name;
                char const *__va_arg1 = file_name;
                char *__va_arg2 = tmp_3;
                void *__va_args[3] = {& __va_arg0, & __va_arg1, & __va_arg2};
                fprintf(_impure_ptr->_stderr,(char const *)tmp_4,
                        (void * const *)(__va_args));
              }
              tmp_5 = gettext("standard error");
              ;
              ;
              write_line(disorder_line,_impure_ptr->_stderr,
                         (char const *)tmp_5);
            }
            ordered = (_Bool)0;
            break;
          }
        }
      }
      while (1) {
        int tmp_8;
        line --;
        ;
        if (! (linebase < line)) break;
        tmp_8 = compare(line,line - 1);
        ;
        if ((int)nonunique <= tmp_8) goto found_disorder;
      }
      line_number += buf.nlines;
      if (alloc < line->length) {
        while (1) {
          alloc *= (size_t)2;
          if (! alloc) {
            alloc = line->length;
            break;
          }
          if (! (alloc < line->length)) break;
        }
        free((void *)temp.text);
        temp.text = (char *)xmalloc(alloc);
      }
      memcpy((void *)temp.text,(void const *)line->text,line->length);
      temp.length = line->length;
      if (key) {
        temp.keybeg = temp.text + (line->keybeg - line->text);
        temp.keylim = temp.text + (line->keylim - line->text);
      }
    }
  }
  xfclose(fp,file_name);
  free((void *)buf.buf);
  free((void *)temp.text);
  return ordered;
}

static size_t open_input_files(struct sortfile *files, size_t nfiles,
                               FILE ***pfps)
{
  size_t __retres;
  FILE **tmp_0;
  FILE **tmp;
  int i;
  tmp = (FILE **)xnmalloc(nfiles,(unsigned long)sizeof(*tmp_0));
  *pfps = tmp;
  FILE **fps = tmp;
  i = 0;
  while ((size_t)i < nfiles) {
    if ((files + i)->temp) {
      if ((int)((files + i)->temp)->state != UNCOMPRESSED) *(fps + i) = open_temp
                                                           ((files + i)->temp);
      else goto _LAND;
    }
    else _LAND: *(fps + i) = stream_open((files + i)->name,"r");
    if (! *(fps + i)) break;
    i ++;
  }
  __retres = (unsigned long)i;
  return __retres;
}

static void mergefps(struct sortfile *files, size_t ntemps, size_t nfiles,
                     FILE *ofp, char const *output_file, FILE **fps)
{
  struct buffer *tmp_0;
  struct line saved;
  struct line const **tmp_2;
  struct line const **tmp_4;
  size_t *tmp_6;
  size_t i;
  size_t j;
  size_t t;
  struct buffer *buffer = xnmalloc(nfiles,(unsigned long)sizeof(*tmp_0));
  struct line const *savedline = (struct line const *)0;
  size_t savealloc = (unsigned long)0;
  struct line const **cur = xnmalloc(nfiles,(unsigned long)sizeof(*tmp_2));
  struct line const **base = xnmalloc(nfiles,(unsigned long)sizeof(*tmp_4));
  size_t *ord = xnmalloc(nfiles,(unsigned long)sizeof(*tmp_6));
  struct keyfield const *key = (struct keyfield const *)keylist;
  saved.text = (char *)0;
  i = (unsigned long)0;
  while (i < nfiles) {
    size_t tmp_7;
    _Bool tmp_9;
    if (merge_buffer_size > sort_size / nfiles) tmp_7 = merge_buffer_size;
    else tmp_7 = sort_size / nfiles;
    ;
    initbuf(buffer + i,(unsigned long)sizeof(struct line),tmp_7);
    tmp_9 = fillbuf(buffer + i,*(fps + i),(files + i)->name);
    if (tmp_9) {
      struct line const *linelim =
        buffer_linelim((struct buffer const *)(buffer + i));
      *(cur + i) = linelim - 1;
      *(base + i) = linelim - (buffer + i)->nlines;
      i ++;
    }
    else {
      xfclose(*(fps + i),(files + i)->name);
      if (i < ntemps) {
        ntemps --;
        zaptemp((files + i)->name);
      }
      free((void *)(buffer + i)->buf);
      nfiles --;
      j = i;
      while (j < nfiles) {
        *(files + j) = *(files + (j + (size_t)1));
        *(fps + j) = *(fps + (j + (size_t)1));
        j ++;
      }
    }
  }
  i = (unsigned long)0;
  while (i < nfiles) {
    *(ord + i) = i;
    i ++;
  }
  i = (unsigned long)1;
  while (i < nfiles) {
    int tmp_10;
    tmp_10 = compare(*(cur + *(ord + (i - (size_t)1))),*(cur + *(ord + i)));
    if (0 < tmp_10) {
      t = *(ord + (i - (size_t)1));
      *(ord + (i - (size_t)1)) = *(ord + i);
      *(ord + i) = t;
      i = (unsigned long)0;
    }
    i ++;
  }
  while (nfiles) {
    struct line const *smallest = *(cur + *(ord + 0));
    if (unique) {
      if (savedline) {
        int tmp_11;
        tmp_11 = compare(savedline,smallest);
        if (tmp_11) {
          savedline = (struct line const *)0;
          write_line((struct line const *)(& saved),ofp,output_file);
        }
      }
      if (! savedline) {
        savedline = (struct line const *)(& saved);
        if (savealloc < smallest->length) {
          while (1) {
            if (! savealloc) {
              savealloc = smallest->length;
              break;
            }
            savealloc *= (size_t)2;
            ;
            if (! (savealloc < smallest->length)) break;
          }
          free((void *)saved.text);
          saved.text = (char *)xmalloc(savealloc);
        }
        saved.length = smallest->length;
        memcpy((void *)saved.text,(void const *)smallest->text,saved.length);
        if (key) {
          saved.keybeg = saved.text + (smallest->keybeg - smallest->text);
          saved.keylim = saved.text + (smallest->keylim - smallest->text);
        }
      }
    }
    else write_line(smallest,ofp,output_file);
    if (*(base + *(ord + 0)) < smallest) *(cur + *(ord + 0)) = smallest - 1;
    else {
      _Bool tmp_13;
      tmp_13 = fillbuf(buffer + *(ord + 0),*(fps + *(ord + 0)),
                       (files + *(ord + 0))->name);
      if (tmp_13) {
        struct line const *linelim_0 =
          buffer_linelim((struct buffer const *)(buffer + *(ord + 0)));
        *(cur + *(ord + 0)) = linelim_0 - 1;
        *(base + *(ord + 0)) = linelim_0 - (buffer + *(ord + 0))->nlines;
      }
      else {
        i = (unsigned long)1;
        while (i < nfiles) {
          if (*(ord + i) > *(ord + 0)) (*(ord + i)) --;
          i ++;
        }
        nfiles --;
        xfclose(*(fps + *(ord + 0)),(files + *(ord + 0))->name);
        if (*(ord + 0) < ntemps) {
          ntemps --;
          zaptemp((files + *(ord + 0))->name);
        }
        free((void *)(buffer + *(ord + 0))->buf);
        i = *(ord + 0);
        while (i < nfiles) {
          *(fps + i) = *(fps + (i + (size_t)1));
          *(files + i) = *(files + (i + (size_t)1));
          *(buffer + i) = *(buffer + (i + (size_t)1));
          *(cur + i) = *(cur + (i + (size_t)1));
          *(base + i) = *(base + (i + (size_t)1));
          i ++;
        }
        i = (unsigned long)0;
        while (i < nfiles) {
          *(ord + i) = *(ord + (i + (size_t)1));
          i ++;
        }
        continue;
      }
    }
    {
      size_t count_of_smaller_lines;
      size_t lo = (unsigned long)1;
      size_t hi = nfiles;
      size_t probe = lo;
      size_t ord0 = *(ord + 0);
      while (lo < hi) {
        int cmp = compare(*(cur + ord0),*(cur + *(ord + probe)));
        if (cmp < 0) hi = probe;
        else
          if (cmp == 0)
            if (ord0 < *(ord + probe)) hi = probe;
            else lo = probe + (size_t)1;
          else lo = probe + (size_t)1;
        probe = (lo + hi) / (size_t)2;
      }
      count_of_smaller_lines = lo - (size_t)1;
      j = (unsigned long)0;
      while (j < count_of_smaller_lines) {
        *(ord + j) = *(ord + (j + (size_t)1));
        j ++;
      }
      *(ord + count_of_smaller_lines) = ord0;
    }
  }
  if (unique)
    if (savedline) {
      write_line((struct line const *)(& saved),ofp,output_file);
      free((void *)saved.text);
    }
  xfclose(ofp,output_file);
  free((void *)fps);
  free((void *)buffer);
  free((void *)ord);
  free((void *)base);
  free((void *)cur);
  return;
}

static size_t mergefiles(struct sortfile *files, size_t ntemps,
                         size_t nfiles, FILE *ofp, char const *output_file)
{
  FILE **fps;
  size_t nopened = open_input_files(files,nfiles,& fps);
  if (nopened < nfiles)
    if (nopened < (size_t)2) {
      int tmp_0;
      ;
      tmp_0 = gettext("open failed");
      sort_die((char const *)tmp_0,(files + nopened)->name);
    }
  mergefps(files,ntemps,nopened,ofp,output_file,fps);
  return nopened;
}

static void mergelines(struct line * __restrict t, size_t nlines,
                       struct line const * __restrict lo)
{
  size_t nlo = nlines / (size_t)2;
  size_t nhi = nlines - nlo;
  struct line *hi = t - nlo;
  while (1) {
    int tmp;
    tmp = compare(lo - 1,(struct line const *)(hi - 1));
    if (tmp <= 0) {
      t --;
      lo --;
      *t = *lo;
      nlo --;
      if (! nlo) goto return_label;
    }
    else {
      t --;
      hi --;
      *t = *hi;
      nhi --;
      if (! nhi) {
        while (1) {
          t --;
          lo --;
          *t = *lo;
          nlo --;
          if (! nlo) break;
        }
        goto return_label;
      }
    }
  }
  return_label: return;
}

static void sequential_sort(struct line * __restrict lines, size_t nlines,
                            struct line * __restrict temp, _Bool to_temp)
{
  if (nlines == (size_t)2) {
    int tmp;
    tmp = compare((struct line const *)(lines + -1),
                  (struct line const *)(lines + -2));
    int swap = 0 < tmp;
    if (to_temp) {
      *(temp + -1) = *(lines + (-1 - swap));
      *(temp + -2) = *(lines + (-2 + swap));
    }
    else
      if (swap) {
        *(temp + -1) = *(lines + -1);
        *(lines + -1) = *(lines + -2);
        *(lines + -2) = *(temp + -1);
      }
  }
  else {
    size_t tmp_0;
    struct line *dest;
    struct line const *sorted_lo;
    size_t nlo = nlines / (size_t)2;
    size_t nhi = nlines - nlo;
    struct line *lo = lines;
    struct line *hi = lines - nlo;
    ;
    if (to_temp) tmp_0 = nlo; else tmp_0 = (unsigned long)0;
    ;
    ;
    ;
    sequential_sort(hi,nhi,temp - tmp_0,to_temp);
    if ((size_t)1 < nlo) sequential_sort(lo,nlo,temp,(_Bool)(! to_temp));
    else
      if (! to_temp) *(temp + -1) = *(lo + -1);
    if (to_temp) {
      dest = temp;
      sorted_lo = (struct line const *)lines;
    }
    else {
      dest = lines;
      sorted_lo = (struct line const *)temp;
    }
    mergelines(dest,nlines,sorted_lo);
  }
  return;
}

static struct merge_node *init_node(struct merge_node * __restrict parent,
                                    struct merge_node * __restrict node_pool,
                                    struct line *dest, size_t nthreads,
                                    size_t total_lines, _Bool is_lo_child);

extern int ( /* missing proto */ pthread_mutex_init)(pthread_mutex_t *x_0,
                                                     void *x_1);

static struct merge_node *merge_tree_init(size_t nthreads, size_t nlines,
                                          struct line *dest)
{
  struct merge_node *tmp_0;
  struct line *tmp_3;
  struct line *tmp_2;
  struct line *tmp_1;
  size_t tmp_4;
  struct merge_node *merge_tree =
    xmalloc((size_t)((unsigned int)2 * sizeof(*tmp_0)) * nthreads);
  struct merge_node *root = merge_tree;
  tmp_3 = (struct line *)0;
  root->end_hi = tmp_3;
  tmp_2 = tmp_3;
  root->end_lo = tmp_2;
  tmp_1 = tmp_2;
  root->hi = tmp_1;
  root->lo = tmp_1;
  root->dest = (struct line **)0;
  tmp_4 = nlines;
  root->nhi = tmp_4;
  root->nlo = tmp_4;
  root->parent = (struct merge_node *)0;
  root->level = (unsigned int)MERGE_END;
  root->queued = (_Bool)0;
  pthread_mutex_init(& root->lock,(void *)0);
  init_node(root,root + 1,dest,nthreads,nlines,(_Bool)0);
  return merge_tree;
}

extern int ( /* missing proto */ pthread_mutex_destroy)(pthread_mutex_t *x_0);

static void merge_tree_destroy(size_t nthreads, struct merge_node *merge_tree)
{
  size_t n_nodes = nthreads * (size_t)2;
  struct merge_node *node = merge_tree;
  while (1) {
    size_t tmp;
    tmp = n_nodes;
    n_nodes --;
    ;
    if (! tmp) break;
    pthread_mutex_destroy(& node->lock);
    node ++;
  }
  free((void *)merge_tree);
  return;
}

static struct merge_node *init_node(struct merge_node * __restrict parent,
                                    struct merge_node * __restrict node_pool,
                                    struct line *dest, size_t nthreads,
                                    size_t total_lines, _Bool is_lo_child)
{
  size_t tmp;
  struct line **tmp_0;
  struct merge_node *tmp_1;
  struct line *tmp_2;
  struct line *tmp_3;
  if (is_lo_child) tmp = parent->nlo; else tmp = parent->nhi;
  size_t nlines = tmp;
  size_t nlo = nlines / (size_t)2;
  size_t nhi = nlines - nlo;
  struct line *lo = dest - total_lines;
  struct line *hi = lo - nlo;
  if (is_lo_child) tmp_0 = & parent->end_lo; else tmp_0 = & parent->end_hi;
  struct line **parent_end = tmp_0;
  tmp_1 = node_pool;
  node_pool ++;
  struct merge_node *node = tmp_1;
  tmp_2 = lo;
  node->end_lo = tmp_2;
  node->lo = tmp_2;
  tmp_3 = hi;
  node->end_hi = tmp_3;
  node->hi = tmp_3;
  node->dest = parent_end;
  node->nlo = nlo;
  node->nhi = nhi;
  node->parent = parent;
  node->level = parent->level + (unsigned int)1;
  node->queued = (_Bool)0;
  pthread_mutex_init(& node->lock,(void *)0);
  if (nthreads > (size_t)1) {
    size_t lo_threads = nthreads / (size_t)2;
    size_t hi_threads = nthreads - lo_threads;
    node->lo_child = node_pool;
    node_pool = init_node(node,node_pool,lo,lo_threads,total_lines,(_Bool)1);
    node->hi_child = node_pool;
    node_pool = init_node(node,node_pool,hi,hi_threads,total_lines,(_Bool)0);
  }
  else {
    node->lo_child = (struct merge_node *)0;
    node->hi_child = (struct merge_node *)0;
  }
  return node_pool;
}

static int compare_nodes(void const *a, void const *b)
{
  int __retres;
  struct merge_node const *nodea = (struct merge_node const *)a;
  struct merge_node const *nodeb = (struct merge_node const *)b;
  if (nodea->level == nodeb->level) {
    __retres = nodea->nlo + nodea->nhi < nodeb->nlo + nodeb->nhi;
    goto return_label;
  }
  __retres = nodea->level < nodeb->level;
  return_label: return __retres;
}

extern int ( /* missing proto */ pthread_mutex_lock)(pthread_mutex_t *x_0);

__inline static void lock_node(struct merge_node *node)
{
  pthread_mutex_lock(& node->lock);
  return;
}

extern int ( /* missing proto */ pthread_mutex_unlock)(pthread_mutex_t *x_0);

__inline static void unlock_node(struct merge_node *node)
{
  pthread_mutex_unlock(& node->lock);
  return;
}

extern int ( /* missing proto */ pthread_cond_destroy)(pthread_cond_t *x_0);

static void queue_destroy(struct merge_node_queue *queue)
{
  heap_free(queue->priority_queue);
  pthread_cond_destroy(& queue->cond);
  pthread_mutex_destroy(& queue->mutex);
  return;
}

extern int ( /* missing proto */ pthread_cond_init)(pthread_cond_t *x_0,
                                                    void *x_1);

static void queue_init(struct merge_node_queue *queue, size_t nthreads)
{
  queue->priority_queue = heap_alloc(& compare_nodes,(size_t)2 * nthreads);
  pthread_mutex_init(& queue->mutex,(void *)0);
  pthread_cond_init(& queue->cond,(void *)0);
  return;
}

extern int ( /* missing proto */ pthread_cond_signal)(pthread_cond_t *x_0);

static void queue_insert(struct merge_node_queue *queue,
                         struct merge_node *node)
{
  pthread_mutex_lock(& queue->mutex);
  heap_insert(queue->priority_queue,(void *)node);
  node->queued = (_Bool)1;
  pthread_cond_signal(& queue->cond);
  pthread_mutex_unlock(& queue->mutex);
  return;
}

extern int ( /* missing proto */ pthread_cond_wait)(pthread_cond_t *x_0,
                                                    pthread_mutex_t *x_1);

static struct merge_node *queue_pop(struct merge_node_queue *queue)
{
  struct merge_node *node;
  pthread_mutex_lock(& queue->mutex);
  while (1) {
    node = (struct merge_node *)heap_remove_top(queue->priority_queue);
    if (node) break;
    pthread_cond_wait(& queue->cond,& queue->mutex);
  }
  pthread_mutex_unlock(& queue->mutex);
  lock_node(node);
  node->queued = (_Bool)0;
  return node;
}

static void write_unique(struct line const *line, FILE *tfp,
                         char const *temp_output)
{
  if (unique) {
    if (saved_line.text) {
      int tmp;
      tmp = compare(line,(struct line const *)(& saved_line));
      if (! tmp) goto return_label;
    }
    saved_line = *line;
  }
  write_line(line,tfp,temp_output);
  return_label: return;
}

static void mergelines_node(struct merge_node * __restrict node,
                            size_t total_lines, FILE *tfp,
                            char const *temp_output)
{
  size_t merged_lo;
  size_t merged_hi;
  struct line *lo_orig = node->lo;
  struct line *hi_orig = node->hi;
  size_t to_merge =
    (total_lines >> (unsigned int)2 * (node->level + (unsigned int)1)) + (size_t)1;
  if (node->level > (unsigned int)MERGE_ROOT) {
    struct line *dest = *(node->dest);
    while (1) {
      int tmp;
      if (node->lo != node->end_lo)
        if (node->hi != node->end_hi) {
          size_t tmp_0;
          tmp_0 = to_merge;
          to_merge --;
          ;
          if (! tmp_0) break;
        }
        else break;
      else break;
      tmp = compare((struct line const *)(node->lo - 1),
                    (struct line const *)(node->hi - 1));
      if (tmp <= 0) {
        dest --;
        (node->lo) --;
        *dest = *(node->lo);
      }
      else {
        dest --;
        (node->hi) --;
        *dest = *(node->hi);
      }
    }
    merged_lo = (unsigned long)(lo_orig - node->lo);
    merged_hi = (unsigned long)(hi_orig - node->hi);
    if (node->nhi == merged_hi)
      while (1) {
        if (node->lo != node->end_lo) {
          size_t tmp_1;
          tmp_1 = to_merge;
          to_merge --;
          ;
          if (! tmp_1) break;
        }
        else break;
        dest --;
        (node->lo) --;
        *dest = *(node->lo);
      }
    else
      if (node->nlo == merged_lo)
        while (1) {
          if (node->hi != node->end_hi) {
            size_t tmp_2;
            tmp_2 = to_merge;
            to_merge --;
            ;
            if (! tmp_2) break;
          }
          else break;
          dest --;
          (node->hi) --;
          *dest = *(node->hi);
        }
    *(node->dest) = dest;
  }
  else {
    while (1) {
      if (node->lo != node->end_lo)
        if (node->hi != node->end_hi) {
          size_t tmp_4;
          tmp_4 = to_merge;
          to_merge --;
          ;
          if (! tmp_4) break;
        }
        else break;
      else break;
      {
        int tmp_3;
        tmp_3 = compare((struct line const *)(node->lo - 1),
                        (struct line const *)(node->hi - 1));
        if (tmp_3 <= 0) {
          ;
          ;
          (node->lo) --;
          write_unique((struct line const *)node->lo,tfp,temp_output);
        }
        else {
          ;
          ;
          (node->hi) --;
          write_unique((struct line const *)node->hi,tfp,temp_output);
        }
      }
    }
    merged_lo = (unsigned long)(lo_orig - node->lo);
    merged_hi = (unsigned long)(hi_orig - node->hi);
    if (node->nhi == merged_hi)
      while (1) {
        if (node->lo != node->end_lo) {
          size_t tmp_5;
          tmp_5 = to_merge;
          to_merge --;
          ;
          if (! tmp_5) break;
        }
        else break;
        ;
        ;
        (node->lo) --;
        write_unique((struct line const *)node->lo,tfp,temp_output);
      }
    else
      if (node->nlo == merged_lo)
        while (1) {
          if (node->hi != node->end_hi) {
            size_t tmp_6;
            tmp_6 = to_merge;
            to_merge --;
            ;
            if (! tmp_6) break;
          }
          else break;
          ;
          ;
          (node->hi) --;
          write_unique((struct line const *)node->hi,tfp,temp_output);
        }
  }
  merged_lo = (unsigned long)(lo_orig - node->lo);
  merged_hi = (unsigned long)(hi_orig - node->hi);
  node->nlo -= merged_lo;
  node->nhi -= merged_hi;
  return;
}

static void queue_check_insert(struct merge_node_queue *queue,
                               struct merge_node *node)
{
  if (! node->queued) {
    int tmp_1;
    _Bool lo_avail = (_Bool)(node->lo - node->end_lo != 0);
    _Bool hi_avail = (_Bool)(node->hi - node->end_hi != 0);
    if (lo_avail) {
      int tmp;
      if (hi_avail) tmp = 1;
      else
        if (! node->nhi) tmp = 1; else tmp = 0;
      tmp_1 = tmp;
    }
    else {
      int tmp_0;
      if (hi_avail)
        if (! node->nlo) tmp_0 = 1; else tmp_0 = 0;
      else tmp_0 = 0;
      tmp_1 = tmp_0;
    }
    if (tmp_1) queue_insert(queue,node);
  }
  return;
}

static void queue_check_insert_parent(struct merge_node_queue *queue,
                                      struct merge_node *node)
{
  if (node->level > (unsigned int)MERGE_ROOT) {
    lock_node(node->parent);
    queue_check_insert(queue,node->parent);
    unlock_node(node->parent);
  }
  else
    if (node->nlo + node->nhi == (size_t)0) queue_insert(queue,node->parent);
  return;
}

static void merge_loop(struct merge_node_queue *queue, size_t total_lines,
                       FILE *tfp, char const *temp_output)
{
  while (1) {
    {
      struct merge_node *node = queue_pop(queue);
      if (node->level == (unsigned int)MERGE_END) {
        unlock_node(node);
        queue_insert(queue,node);
        break;
      }
      mergelines_node(node,total_lines,tfp,temp_output);
      queue_check_insert(queue,node);
      queue_check_insert_parent(queue,node);
      unlock_node(node);
    }
  }
  return;
}

static void sortlines(struct line * __restrict lines, size_t nthreads,
                      size_t total_lines, struct merge_node *node,
                      struct merge_node_queue *queue, FILE *tfp,
                      char const *temp_output);

static void *sortlines_thread(void *data)
{
  void *__retres;
  struct thread_args const *args = (struct thread_args const *)data;
  sortlines(args->lines,args->nthreads,args->total_lines,args->node,
            args->queue,args->tfp,args->output_temp);
  __retres = (void *)0;
  return __retres;
}

extern int ( /* missing proto */ pthread_join)(unsigned int x_0, void *x_1);

extern int ( /* missing proto */ pthread_create)(pthread_t *x_0, void *x_1,
                                                 void *(*x_2)(void *data),
                                                 struct thread_args *x_3);

static void sortlines(struct line * __restrict lines, size_t nthreads,
                      size_t total_lines, struct merge_node *node,
                      struct merge_node_queue *queue, FILE *tfp,
                      char const *temp_output)
{
  pthread_t thread;
  size_t nlines = node->nlo + node->nhi;
  size_t lo_threads = nthreads / (size_t)2;
  size_t hi_threads = nthreads - lo_threads;
  struct thread_args args =
    {.lines = lines,
     .nthreads = lo_threads,
     .total_lines = total_lines,
     .node = node->lo_child,
     .queue = queue,
     .tfp = tfp,
     .output_temp = temp_output};
  if (nthreads > (size_t)1) {
    if ((size_t)SUBTHREAD_LINES_HEURISTIC <= nlines) {
      int tmp;
      tmp = pthread_create(& thread,(void *)0,& sortlines_thread,& args);
      if (tmp == 0) {
        sortlines(lines - node->nlo,hi_threads,total_lines,node->hi_child,
                  queue,tfp,temp_output);
        pthread_join(thread,(void *)0);
      }
      else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      size_t nlo = node->nlo;
      size_t nhi = node->nhi;
      struct line *temp = lines - total_lines;
      if ((size_t)1 < nhi) sequential_sort(lines - nlo,nhi,
                                           temp - nlo / (size_t)2,(_Bool)0);
      if ((size_t)1 < nlo) sequential_sort(lines,nlo,temp,(_Bool)0);
      node->lo = lines;
      node->hi = lines - nlo;
      node->end_lo = lines - nlo;
      node->end_hi = (lines - nlo) - nhi;
      queue_insert(queue,node);
      merge_loop(queue,total_lines,tfp,temp_output);
    }
  }
  return;
}

static void avoid_trashing_input(struct sortfile *files, size_t ntemps,
                                 size_t nfiles, char const *outfile)
{
  struct tempnode *tempcopy = (struct tempnode *)0;
  {
    size_t i = ntemps;
    while (i < nfiles) {
      {
        int tmp;
        _Bool same;
        struct stat instat;
        tmp = strcmp((files + i)->name,"-");
        _Bool is_stdin = (_Bool)(tmp == 0);
        if (outfile) {
          int tmp_5;
          tmp_5 = strcmp(outfile,(files + i)->name);
          if (tmp_5 == 0) {
            if (! is_stdin) same = (_Bool)1; else goto _LAND_0;
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0:
          {
            int tmp_4;
            int tmp_3;
            struct stat *outst = get_outstatus();
            if (! outst) break;
            if (is_stdin) tmp_3 = fstat(0,& instat);
            else tmp_3 = stat((files + i)->name,& instat);
            if (tmp_3 == 0)
              if ((int)instat.st_ino == (int)outst->st_ino)
                if ((int)instat.st_dev == (int)outst->st_dev) tmp_4 = 1;
                else tmp_4 = 0;
              else tmp_4 = 0;
            else tmp_4 = 0;
            same = (_Bool)(tmp_4 != 0);
          }
        }
        if (same) {
          if (! tempcopy) {
            FILE *tftp;
            tempcopy = create_temp(& tftp);
            mergefiles(files + i,(unsigned long)0,(unsigned long)1,tftp,
                       (char const *)(tempcopy->name));
          }
          (files + i)->name = (char const *)(tempcopy->name);
          (files + i)->temp = tempcopy;
        }
      }
      i ++;
    }
  }
  return;
}

static void check_inputs(char * const *files, size_t nfiles)
{
  size_t i = (unsigned long)0;
  while (i < nfiles) {
    {
      int tmp;
      int tmp_1;
      tmp = strcmp((char const *)*(files + i),"-");
      if (tmp == 0) goto __Cont;
      tmp_1 = euidaccess((char const *)*(files + i),4);
      if (tmp_1 != 0) {
        int tmp_0;
        ;
        tmp_0 = gettext("cannot read");
        sort_die((char const *)tmp_0,(char const *)*(files + i));
      }
    }
    __Cont: i ++;
  }
  return;
}

static void check_output(char const *outfile)
{
  if (outfile) {
    int oflags = 0;
    int __va_arg0 =
      ((((0000400 | 0000200) | 0000040) | 0000020) | 0000004) | 0000002;
    void *__va_args[1] = {& __va_arg0};
    int outfd = open(outfile,oflags,(void * const *)(__va_args));
    if (outfd < 0) {
      int tmp_0;
      ;
      tmp_0 = gettext("open failed");
      sort_die((char const *)tmp_0,outfile);
    }
    move_fd(outfd,1);
  }
  return;
}

static void merge(struct sortfile *files, size_t ntemps, size_t nfiles,
                  char const *output_file)
{
  while ((size_t)nmerge < nfiles) {
    size_t in;
    size_t out;
    size_t remainder;
    size_t cheap_slots;
    in = (unsigned long)0;
    out = in;
    while ((size_t)nmerge <= nfiles - in) {
      {
        FILE *tfp;
        size_t tmp_1;
        size_t tmp_0;
        size_t tmp_2;
        struct tempnode *temp = create_temp(& tfp);
        ;
        ;
        ;
        if (ntemps < (size_t)nmerge) tmp_0 = ntemps;
        else tmp_0 = (unsigned long)nmerge;
        ;
        tmp_1 = mergefiles(files + in,tmp_0,(unsigned long)nmerge,tfp,
                           (char const *)(temp->name));
        size_t num_merged = tmp_1;
        if (ntemps < num_merged) tmp_2 = ntemps; else tmp_2 = num_merged;
        ntemps -= tmp_2;
        (files + out)->name = (char const *)(temp->name);
        (files + out)->temp = temp;
        in += num_merged;
      }
      out ++;
    }
    remainder = nfiles - in;
    cheap_slots = (unsigned long)nmerge - out % (unsigned long)nmerge;
    if (cheap_slots < remainder) {
      FILE *tfp_0;
      size_t tmp_5;
      size_t tmp_4;
      size_t tmp_6;
      size_t tmp_7;
      size_t nshortmerge = (remainder - cheap_slots) + (size_t)1;
      struct tempnode *temp_0 = create_temp(& tfp_0);
      ;
      ;
      ;
      if (ntemps < nshortmerge) tmp_4 = ntemps; else tmp_4 = nshortmerge;
      ;
      tmp_5 = mergefiles(files + in,tmp_4,nshortmerge,tfp_0,
                         (char const *)(temp_0->name));
      size_t num_merged_0 = tmp_5;
      if (ntemps < num_merged_0) tmp_6 = ntemps; else tmp_6 = num_merged_0;
      ntemps -= tmp_6;
      (files + out)->name = (char const *)(temp_0->name);
      tmp_7 = out;
      out ++;
      (files + tmp_7)->temp = temp_0;
      in += num_merged_0;
    }
    memmove((void *)(files + out),(void const *)(files + in),
            (nfiles - in) * (size_t)sizeof(*files));
    ntemps += out;
    nfiles -= in - out;
  }
  avoid_trashing_input(files,ntemps,nfiles,output_file);
  while (1) {
    {
      FILE **fps;
      FILE *tfp_1;
      struct tempnode *temp_1;
      size_t tmp_13;
      size_t tmp_14;
      size_t nopened = open_input_files(files,nfiles,& fps);
      if (nopened == nfiles) {
        int *tmp_11;
        FILE *ofp = stream_open(output_file,"w");
        if (ofp) {
          mergefps(files,ntemps,nfiles,ofp,output_file,fps);
          break;
        }
        tmp_11 = __errno();
        ;
        if (*tmp_11 != 24) goto _LOR;
        else
          if (nopened <= (size_t)2) {
            int tmp_10;
            _LOR: { /* sequence */
                    ;
                    tmp_10 = gettext("open failed");
                  }
            sort_die((char const *)tmp_10,output_file);
          }
      }
      else
        if (nopened <= (size_t)2) {
          int tmp_12;
          ;
          tmp_12 = gettext("open failed");
          sort_die((char const *)tmp_12,(files + nopened)->name);
        }
      while (1) {
        nopened --;
        xfclose(*(fps + nopened),(files + nopened)->name);
        temp_1 = maybe_create_temp(& tfp_1,(_Bool)(! (nopened <= (size_t)2)));
        if (! (! temp_1)) break;
      }
      ;
      ;
      ;
      ;
      if (ntemps < nopened) tmp_13 = ntemps; else tmp_13 = nopened;
      ;
      mergefps(files + 0,tmp_13,nopened,tfp_1,(char const *)(temp_1->name),
               fps);
      if (ntemps < nopened) tmp_14 = ntemps; else tmp_14 = nopened;
      ntemps -= tmp_14;
      (files + 0)->name = (char const *)(temp_1->name);
      (files + 0)->temp = temp_1;
      memmove((void *)(files + 1),(void const *)(files + nopened),
              (nfiles - nopened) * (size_t)sizeof(*files));
      ntemps ++;
      nfiles -= nopened - (size_t)1;
    }
  }
  return;
}

static void sort(char * const *files, size_t nfiles, char const *output_file,
                 size_t nthreads)
{
  struct buffer buf;
  buf.buf = (char *)0;
  size_t ntemps = (unsigned long)0;
  _Bool output_file_created = (_Bool)0;
  buf.alloc = (unsigned long)0;
  while (nfiles) {
    char const *temp_output;
    FILE *tfp;
    size_t bytes_per_line;
    char const *file = (char const *)*files;
    FILE *fp = xfopen(file,"r");
    if (nthreads > (size_t)1) {
      size_t tmp_0 = (unsigned long)1;
      size_t mult = (unsigned long)1;
      while (tmp_0 < nthreads) {
        tmp_0 *= (size_t)2;
        mult ++;
      }
      bytes_per_line = mult * (size_t)sizeof(struct line);
    }
    else bytes_per_line = (unsigned long)((sizeof(struct line) * (unsigned int)3) / (unsigned int)2);
    if (! buf.alloc) {
      size_t tmp_1;
      tmp_1 = sort_buffer_size((FILE * const *)(& fp),(unsigned long)1,files,
                               nfiles,bytes_per_line);
      ;
      initbuf(& buf,bytes_per_line,tmp_1);
    }
    buf.eof = (_Bool)0;
    files ++;
    nfiles --;
    while (1) {
      _Bool tmp_4;
      tmp_4 = fillbuf(& buf,fp,file);
      if (! tmp_4) break;
      {
        struct line *line;
        if (buf.eof)
          if (nfiles)
            if (bytes_per_line + (size_t)1 < (buf.alloc - buf.used) -
                                             bytes_per_line * buf.nlines) {
              buf.left = buf.used;
              break;
            }
        saved_line.text = (char *)0;
        line = buffer_linelim((struct buffer const *)(& buf));
        if (buf.eof) {
          if (! nfiles) {
            if (! ntemps) {
              if (! buf.left) {
                xfclose(fp,file);
                tfp = xfopen(output_file,"w");
                temp_output = output_file;
                output_file_created = (_Bool)1;
              }
              else goto _LAND_1;
            }
            else goto _LAND_1;
          }
          else goto _LAND_1;
        }
        else {
          _LAND_1:
          {
            struct tempnode *tmp_2;
            ntemps ++;
            tmp_2 = create_temp(& tfp);
            temp_output = (char const *)(tmp_2->name);
          }
        }
        if ((size_t)1 < buf.nlines) {
          struct merge_node_queue queue;
          queue_init(& queue,nthreads);
          struct merge_node *merge_tree =
            merge_tree_init(nthreads,buf.nlines,line);
          sortlines(line,nthreads,buf.nlines,merge_tree + 1,& queue,tfp,
                    temp_output);
          merge_tree_destroy(nthreads,merge_tree);
          queue_destroy(& queue);
        }
        else write_unique((struct line const *)(line - 1),tfp,temp_output);
        xfclose(tfp,temp_output);
        if (output_file_created) goto finish;
      }
    }
    xfclose(fp,file);
  }
  finish: free((void *)buf.buf);
  if (! output_file_created) {
    struct sortfile *tmp_6;
    struct tempnode *node = temphead;
    struct sortfile *tempfiles =
      xnmalloc(ntemps,(unsigned long)sizeof(*tmp_6));
    {
      size_t i = (unsigned long)0;
      while (node) {
        (tempfiles + i)->name = (char const *)(node->name);
        (tempfiles + i)->temp = node;
        node = node->next;
        i ++;
      }
    }
    merge(tempfiles,ntemps,ntemps,output_file);
    free((void *)tempfiles);
  }
  reap_all();
  return;
}

static void insertkey(struct keyfield *key_arg)
{
  struct keyfield **p;
  struct keyfield *tmp_0;
  struct keyfield *key =
    xmemdup((void const *)key_arg,(unsigned long)sizeof(*tmp_0));
  p = & keylist;
  while (*p) {
    goto __Cont;
    __Cont: p = & (*p)->next;
  }
  *p = key;
  key->next = (struct keyfield *)0;
  return;
}

static  __attribute__((__noreturn__)) void badfieldspec(char const *spec,
                                                        char const *msgid);

static  __attribute__((__noreturn__)) void badfieldspec(char const *spec,
                                                        char const *msgid);
static void badfieldspec(char const *spec, char const *msgid)
{
  if (! (! sizeof(struct __anonstruct_53))) {
    char const *tmp;
    int tmp_0;
    int tmp_1;
    tmp = quote(spec);
    tmp_0 = gettext(msgid);
    tmp_1 = gettext("%s: invalid field specification %s");
    {
      int __va_arg0 = tmp_0;
      char const *__va_arg1 = tmp;
      void *__va_args[2] = {& __va_arg0, & __va_arg1};
      error(SORT_FAILURE,0,(char const *)tmp_1,(void * const *)(__va_args));
    }
    __builtin_unreachable();
  }
  else {
    char const *tmp_2;
    int tmp_3;
    int tmp_4;
    tmp_2 = quote(spec);
    tmp_3 = gettext(msgid);
    tmp_4 = gettext("%s: invalid field specification %s");
    {
      int __va_arg0_13 = tmp_3;
      char const *__va_arg1_15 = tmp_2;
      void *__va_args_17[2] = {& __va_arg0_13, & __va_arg1_15};
      error(SORT_FAILURE,0,(char const *)tmp_4,
            (void * const *)(__va_args_17));
    }
    __builtin_unreachable();
  }
  return;
}

static  __attribute__((__noreturn__)) void incompatible_options(char const *opts);

static  __attribute__((__noreturn__)) void incompatible_options(char const *opts);
static void incompatible_options(char const *opts)
{
  if (! (! sizeof(struct __anonstruct_54))) {
    int tmp;
    ;
    tmp = gettext("options \'-%s\' are incompatible");
    {
      char const *__va_arg0 = opts;
      void *__va_args[1] = {& __va_arg0};
      error(SORT_FAILURE,0,(char const *)tmp,(void * const *)(__va_args));
    }
    __builtin_unreachable();
  }
  else {
    int tmp_0;
    ;
    tmp_0 = gettext("options \'-%s\' are incompatible");
    {
      char const *__va_arg0_7 = opts;
      void *__va_args_9[1] = {& __va_arg0_7};
      error(SORT_FAILURE,0,(char const *)tmp_0,(void * const *)(__va_args_9));
    }
    __builtin_unreachable();
  }
  return;
}

static void check_ordering_compatibility(void)
{
  struct keyfield *key;
  key = keylist;
  while (key) {
    if (1 < ((((int)key->numeric + (int)key->general_numeric) + (int)key->human_numeric) + (int)key->month) + (
            ((int)key->version | (int)key->random) | ! (! key->ignore))) {
      char opts[sizeof(short_options)];
      _Bool tmp_0;
      _Bool tmp;
      tmp_0 = (_Bool)0;
      key->reverse = tmp_0;
      tmp = tmp_0;
      key->skipeblanks = tmp;
      key->skipsblanks = tmp;
      key_to_opts((struct keyfield const *)key,opts);
      incompatible_options((char const *)(opts));
    }
    key = key->next;
  }
  return;
}

static char const *parse_field_count(char const *string, size_t *val,
                                     char const *msgid)
{
  char const *__retres;
  char *suffix;
  uintmax_t n;
  strtol_error tmp;
  tmp = xstrtoumax(string,& suffix,10,& n,"");
  switch (tmp) {
    case (strtol_error)LONGINT_OK:
    case (strtol_error)LONGINT_INVALID_SUFFIX_CHAR:
    *val = n;
    if (*val == n) break;
    case (strtol_error)LONGINT_OVERFLOW:
    case (strtol_error)(LONGINT_OVERFLOW | LONGINT_INVALID_SUFFIX_CHAR):
    *val = (unsigned long)0xffffffffffffffffUL;
    break;
    case (strtol_error)LONGINT_INVALID: ;
    if (msgid)
      if (! (! sizeof(struct __anonstruct_55))) {
        char const *tmp_0;
        int tmp_1;
        int tmp_2;
        tmp_0 = quote(string);
        tmp_1 = gettext(msgid);
        tmp_2 = gettext("%s: invalid count at start of %s");
        {
          int __va_arg0 = tmp_1;
          char const *__va_arg1 = tmp_0;
          void *__va_args[2] = {& __va_arg0, & __va_arg1};
          error(SORT_FAILURE,0,(char const *)tmp_2,
                (void * const *)(__va_args));
        }
        __builtin_unreachable();
      }
      else {
        char const *tmp_3;
        int tmp_4;
        int tmp_5;
        tmp_3 = quote(string);
        tmp_4 = gettext(msgid);
        tmp_5 = gettext("%s: invalid count at start of %s");
        {
          int __va_arg0_17 = tmp_4;
          char const *__va_arg1_19 = tmp_3;
          void *__va_args_21[2] = {& __va_arg0_17, & __va_arg1_19};
          error(SORT_FAILURE,0,(char const *)tmp_5,
                (void * const *)(__va_args_21));
        }
        __builtin_unreachable();
      }
    __retres = (char const *)0;
    goto return_label;
  }
  __retres = (char const *)suffix;
  return_label: return __retres;
}

static void sighandler(int sig)
{
  if (! 1) signal(sig,(void (*)(int ))1);
  cleanup();
  signal(sig,(void (*)(int ))0);
  raise(sig);
  return;
}

static char *set_ordering(char const *s, struct keyfield *key,
                          enum blanktype blanktype)
{
  char *__retres;
  while (*s) {
    switch ((int)*s) {
      case 'b': ;
      if (blanktype == (unsigned int)bl_start) key->skipsblanks = (_Bool)1;
      else
        if (blanktype == (unsigned int)bl_both) key->skipsblanks = (_Bool)1;
      if (blanktype == (unsigned int)bl_end) key->skipeblanks = (_Bool)1;
      else
        if (blanktype == (unsigned int)bl_both) key->skipeblanks = (_Bool)1;
      break;
      case 'd': key->ignore = (_Bool const *)(nondictionary);
      break;
      case 'f': key->translate = (char const *)(fold_toupper);
      break;
      case 'g': key->general_numeric = (_Bool)1;
      break;
      case 'h': key->human_numeric = (_Bool)1;
      break;
      case 'i':
      if (! key->ignore) key->ignore = (_Bool const *)(nonprinting);
      break;
      case 'M': key->month = (_Bool)1;
      break;
      case 'n': key->numeric = (_Bool)1;
      break;
      case 'R': key->random = (_Bool)1;
      break;
      case 'r': key->reverse = (_Bool)1;
      break;
      case 'V': key->version = (_Bool)1;
      break;
      default: ;
      __retres = (char *)s;
      goto return_label;
    }
    s ++;
  }
  __retres = (char *)s;
  return_label: return __retres;
}

static struct keyfield *key_init(struct keyfield *key)
{
  memset((void *)key,0,(unsigned long)sizeof(*key));
  key->eword = (unsigned long)0xffffffffffffffffUL;
  return key;
}

extern int ( /* missing proto */ bindtextdomain)(char const *x_0,
                                                 char const *x_1);

extern int ( /* missing proto */ textdomain)(char const *x_0);

int main(int argc, char **argv);

static int const main_sig[11] = {14, 1, 2, 13, 3, 15, 23, 27, 26, 24, 25};
static char main_opts[10] =
  {(char)'X',
   (char)' ',
   (char)'-',
   (char)'-',
   (char)'d',
   (char)'e',
   (char)'b',
   (char)'u',
   (char)'g',
   (char)'\000'};
static char main_opts_0[3] = {(char)0, (char)'o', (char)0};
/*@ assigns \result, *;
    assigns \result
      \from (indirect: *), (indirect: *( + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns * \from *, (indirect: *( + (0 ..))), *(param0 + (0 ..));
 */
int ( /* format attribute */ fprintf_va_1)(FILE *, char const *, char *param0);

int main(int argc, char **argv)
{
  int __retres;
  struct keyfield *key;
  struct keyfield key_buf;
  struct keyfield gkey;
  char const *s;
  char *tmp;
  int tmp_1;
  char **files;
  struct Tokens tok;
  _Bool locale_ok;
  int tmp_3;
  char *tmp_2;
  _Bool gkey_only = (_Bool)0;
  int c = 0;
  char checkonly = (char)0;
  _Bool mergeonly = (_Bool)0;
  char *random_source = (char *)0;
  _Bool need_random = (_Bool)0;
  size_t nthreads = (unsigned long)0;
  size_t nfiles = (unsigned long)0;
  tmp = getenv("POSIXLY_CORRECT");
  _Bool posixly_correct = (_Bool)(tmp != (char *)0);
  int posix_ver = posix2_version();
  if (200112 <= posix_ver)
    if (posix_ver < 200809) tmp_1 = 0; else tmp_1 = 1;
  else tmp_1 = 1;
  _Bool traditional_usage = (_Bool)(tmp_1 != 0);
  char *files_from = (char *)0;
  char const *outfile = (char const *)0;
  set_program_name((char const *)*(argv + 0));
  tmp_2 = setlocale(0,"");
  if (tmp_2) tmp_3 = 1; else tmp_3 = 0;
  locale_ok = (_Bool)(tmp_3 != 0);
  bindtextdomain("coreutils","/usr/local/share/locale");
  textdomain("coreutils");
  initialize_exit_failure(SORT_FAILURE);
  hard_LC_COLLATE = hard_locale(1);
  hard_LC_TIME = hard_locale(5);
  {
    unsigned char tmp_5;
    unsigned char tmp_6;
    struct lconv const *locale = localeconv();
    tmp_5 = to_uchar(*(locale->decimal_point + 0));
    decimal_point = (int)tmp_5;
    if (! decimal_point) decimal_point = '.';
    else
      if (*(locale->decimal_point + 1)) decimal_point = '.';
    tmp_6 = to_uchar(*(locale->thousands_sep));
    thousands_sep = (int)tmp_6;
    if (! thousands_sep) thousands_sep = -1;
    else
      if (*(locale->thousands_sep + 1)) thousands_sep = -1;
  }
  have_read_stdin = (_Bool)0;
  inittables();
  {
    size_t i;
    struct sigaction act;
    caught_signals = (unsigned long)0;
    i = (unsigned long)0;
    while (i < (size_t)nsigs) {
      sigaction(main_sig[i],(struct sigaction const *)0,& act);
      if (act.sa_handler != (void (*)(int ))1) caught_signals |= (unsigned long)(
                                               1 << main_sig[i]);
      i ++;
    }
    act.sa_handler = & sighandler;
    act.sa_mask = caught_signals;
    act.sa_flags = 0;
    i = (unsigned long)0;
    while (i < (size_t)nsigs) {
      if ((caught_signals & (unsigned long)(1 << main_sig[i])) != (unsigned long)0)
        sigaction(main_sig[i],(struct sigaction const *)(& act),
                  (struct sigaction *)0);
      i ++;
    }
  }
  signal(20,(void (*)(int ))0);
  atexit(& exit_cleanup);
  key_init(& gkey);
  gkey.sword = (unsigned long)0xffffffffffffffffUL;
  files = (char **)xnmalloc((unsigned long)argc,
                            (unsigned long)sizeof(*files));
  while (1) {
    {
      int oi = -1;
      if (c == -1) goto _LOR;
      else
        if (posixly_correct) {
          if (nfiles != (size_t)0) {
            if (traditional_usage) {
              if (! checkonly) {
                if (optind != argc) {
                  if ((int)*(*(argv + optind) + 0) == '-') {
                    if ((int)*(*(argv + optind) + 1) == 'o') {
                      if (*(*(argv + optind) + 2)) goto _LAND_0;
                      else
                        if (optind + 1 != argc) goto _LAND_0; else goto _LOR;
                    }
                    else goto _LOR;
                  }
                  else goto _LOR;
                }
                else goto _LOR;
              }
              else goto _LOR;
            }
            else goto _LOR;
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0:
          c = getopt_long(argc,(char * const *)argv,short_options,
                          long_options,& oi);
          if (c == -1) {
            _LOR:
            {
              size_t tmp_7;
              int tmp_8;
              if (argc <= optind) break;
              tmp_7 = nfiles;
              nfiles ++;
              tmp_8 = optind;
              optind ++;
              *(files + tmp_7) = *(argv + tmp_8);
            }
          }
          else
            switch (c) {
              ptrdiff_t tmp_15;
              size_t tmp_20;
              case 1: key = (struct keyfield *)0;
              if ((int)*(optarg + 0) == '+') {
                int tmp_9;
                int tmp_10;
                if (optind != argc)
                  if ((int)*(*(argv + optind) + 0) == '-')
                    if ((unsigned int)*(*(argv + optind) + 1) - (unsigned int)'0' <= (unsigned int)9)
                      tmp_9 = 1;
                    else tmp_9 = 0;
                  else tmp_9 = 0;
                else tmp_9 = 0;
                _Bool minus_pos_usage = (_Bool)(tmp_9 != 0);
                if (minus_pos_usage)
                  if (! posixly_correct) tmp_10 = 1; else tmp_10 = 0;
                else tmp_10 = 0;
                traditional_usage = (_Bool)(((int)traditional_usage | tmp_10) != 0);
                if (traditional_usage) {
                  key = key_init(& key_buf);
                  s = parse_field_count((char const *)(optarg + 1),
                                        & key->sword,(char const *)0);
                  if (s)
                    if ((int)*s == '.') s = parse_field_count(s + 1,
                                                              & key->schar,
                                                              (char const *)0);
                  if (! key->sword)
                    if (! key->schar) key->sword = (unsigned long)0xffffffffffffffffUL;
                  if (! s) key = (struct keyfield *)0;
                  else {
                    char *tmp_13;
                    tmp_13 = set_ordering(s,key,bl_start);
                    if (*tmp_13) key = (struct keyfield *)0;
                    else {
                      if (minus_pos_usage) {
                        int tmp_11;
                        char *tmp_12;
                        tmp_11 = optind;
                        optind ++;
                        char const *optarg1 = (char const *)*(argv + tmp_11);
                        s = parse_field_count(optarg1 + 1,& key->eword,
                                              "invalid number after \'-\'");
                        if (! s) __assert_func("sort_modified.c",4365,"main",
                                               "s");
                        if ((int)*s == '.') s = parse_field_count(s + 1,
                                                                  & key->echar,
                                                                  "invalid number after \'.\'");
                        if (! key->echar)
                          if (key->eword) (key->eword) --;
                        tmp_12 = set_ordering(s,key,bl_end);
                        if (*tmp_12) badfieldspec(optarg1,
                                                  "stray character in field spec");
                      }
                      key->traditional_used = (_Bool)1;
                      insertkey(key);
                    }
                  }
                }
              }
              if (! key) {
                size_t tmp_14;
                tmp_14 = nfiles;
                nfiles ++;
                *(files + tmp_14) = optarg;
              }
              break;
              case SORT_OPTION:
              { /* sequence */
                tmp_15 = __xargmatch_internal("--sort",(char const *)optarg,
                                              sort_args,
                                              (void const *)(sort_types),
                                              (unsigned long)sizeof(sort_types[0]),
                                              argmatch_die);
                c = (int)sort_types[tmp_15];
              }
              case 'b': case 'd': case 'f': case 'g': case 'h': case 'i':
              case 'M': case 'n': case 'r': case 'R': case 'V':
              {
                char str[2];
                str[0] = (char)c;
                str[1] = (char)0;
                set_ordering((char const *)(str),& gkey,bl_both);
              }
              break;
              case CHECK_OPTION:
              if (optarg) {
                ptrdiff_t tmp_16;
                tmp_16 = __xargmatch_internal("--check",(char const *)optarg,
                                              check_args,
                                              (void const *)(check_types),
                                              (unsigned long)sizeof(check_types[0]),
                                              argmatch_die);
                c = (int)check_types[tmp_16];
              }
              else c = 'c';
              case 'c': case 'C': ;
              if (checkonly)
                if ((int)checkonly != c) incompatible_options("cC");
              checkonly = (char)c;
              break;
              case COMPRESS_PROGRAM_OPTION: ;
              if (compress_program) {
                int tmp_19;
                tmp_19 = strcmp(compress_program,(char const *)optarg);
                if (! (tmp_19 == 0))
                  if (! (! sizeof(struct __anonstruct_57))) {
                    int tmp_17;
                    tmp_17 = gettext("multiple compress programs specified");
                    {
                      void *__va_args[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_17,
                            (void * const *)(__va_args));
                    }
                    __builtin_unreachable();
                  }
                  else {
                    int tmp_18;
                    tmp_18 = gettext("multiple compress programs specified");
                    {
                      void *__va_args_125[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_18,
                            (void * const *)(__va_args_125));
                    }
                    __builtin_unreachable();
                  }
              }
              compress_program = (char const *)optarg;
              break;
              case DEBUG_PROGRAM_OPTION: debug = (_Bool)1;
              break;
              case FILES0_FROM_OPTION: files_from = optarg;
              break;
              case 'k': key = key_init(& key_buf);
              s = parse_field_count((char const *)optarg,& key->sword,
                                    "invalid number at field start");
              tmp_20 = key->sword;
              (key->sword) --;
              ;
              if (! tmp_20) badfieldspec((char const *)optarg,
                                         "field number is zero");
              if ((int)*s == '.') {
                size_t tmp_21;
                s = parse_field_count(s + 1,& key->schar,
                                      "invalid number after \'.\'");
                tmp_21 = key->schar;
                (key->schar) --;
                ;
                if (! tmp_21) badfieldspec((char const *)optarg,
                                           "character offset is zero");
              }
              if (! key->sword)
                if (! key->schar) key->sword = (unsigned long)0xffffffffffffffffUL;
              s = (char const *)set_ordering(s,key,bl_start);
              if ((int)*s != ',') {
                key->eword = (unsigned long)0xffffffffffffffffUL;
                key->echar = (unsigned long)0;
              }
              else {
                size_t tmp_22;
                s = parse_field_count(s + 1,& key->eword,
                                      "invalid number after \',\'");
                tmp_22 = key->eword;
                (key->eword) --;
                ;
                if (! tmp_22) badfieldspec((char const *)optarg,
                                           "field number is zero");
                if ((int)*s == '.') s = parse_field_count(s + 1,& key->echar,
                                                          "invalid number after \'.\'");
                s = (char const *)set_ordering(s,key,bl_end);
              }
              if (*s) badfieldspec((char const *)optarg,
                                   "stray character in field spec");
              insertkey(key);
              break;
              case 'm': mergeonly = (_Bool)1;
              break;
              case NMERGE_OPTION:
              specify_nmerge(oi,(char)c,(char const *)optarg);
              break;
              case 'o': ;
              if (outfile) {
                int tmp_25;
                tmp_25 = strcmp(outfile,(char const *)optarg);
                if (! (tmp_25 == 0))
                  if (! (! sizeof(struct __anonstruct_58))) {
                    int tmp_23;
                    tmp_23 = gettext("multiple output files specified");
                    {
                      void *__va_args_127[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_23,
                            (void * const *)(__va_args_127));
                    }
                    __builtin_unreachable();
                  }
                  else {
                    int tmp_24;
                    tmp_24 = gettext("multiple output files specified");
                    {
                      void *__va_args_129[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_24,
                            (void * const *)(__va_args_129));
                    }
                    __builtin_unreachable();
                  }
              }
              outfile = (char const *)optarg;
              break;
              case RANDOM_SOURCE_OPTION: ;
              if (random_source) {
                int tmp_28;
                tmp_28 = strcmp((char const *)random_source,
                                (char const *)optarg);
                if (! (tmp_28 == 0))
                  if (! (! sizeof(struct __anonstruct_59))) {
                    int tmp_26;
                    tmp_26 = gettext("multiple random sources specified");
                    {
                      void *__va_args_131[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_26,
                            (void * const *)(__va_args_131));
                    }
                    __builtin_unreachable();
                  }
                  else {
                    int tmp_27;
                    tmp_27 = gettext("multiple random sources specified");
                    {
                      void *__va_args_133[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_27,
                            (void * const *)(__va_args_133));
                    }
                    __builtin_unreachable();
                  }
              }
              random_source = optarg;
              break;
              case 's': stable = (_Bool)1;
              break;
              case 'S': specify_sort_size(oi,(char)c,(char const *)optarg);
              break;
              case 't':
              {
                char newtab = *(optarg + 0);
                if (! newtab)
                  if (! (! sizeof(struct __anonstruct_60))) {
                    int tmp_29;
                    tmp_29 = gettext("empty tab");
                    {
                      void *__va_args_135[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_29,
                            (void * const *)(__va_args_135));
                    }
                    __builtin_unreachable();
                  }
                  else {
                    int tmp_30;
                    tmp_30 = gettext("empty tab");
                    {
                      void *__va_args_137[1] = {(void *)0};
                      error(SORT_FAILURE,0,(char const *)tmp_30,
                            (void * const *)(__va_args_137));
                    }
                    __builtin_unreachable();
                  }
                if (*(optarg + 1)) {
                  int tmp_35;
                  tmp_35 = strcmp((char const *)optarg,"\\0");
                  if (tmp_35 == 0) newtab = (char)0;
                  else
                    if (! (! sizeof(struct __anonstruct_61))) {
                      char const *tmp_31;
                      int tmp_32;
                      tmp_31 = quote((char const *)optarg);
                      tmp_32 = gettext("multi-character tab %s");
                      {
                        char const *__va_arg0 = tmp_31;
                        void *__va_args_140[1] = {& __va_arg0};
                        error(SORT_FAILURE,0,(char const *)tmp_32,
                              (void * const *)(__va_args_140));
                      }
                      __builtin_unreachable();
                    }
                    else {
                      char const *tmp_33;
                      int tmp_34;
                      tmp_33 = quote((char const *)optarg);
                      tmp_34 = gettext("multi-character tab %s");
                      {
                        char const *__va_arg0_142 = tmp_33;
                        void *__va_args_144[1] = {& __va_arg0_142};
                        error(SORT_FAILURE,0,(char const *)tmp_34,
                              (void * const *)(__va_args_144));
                      }
                      __builtin_unreachable();
                    }
                }
                if (tab != TAB_DEFAULT)
                  if (tab != (int)newtab)
                    if (! (! sizeof(struct __anonstruct_62))) {
                      int tmp_36;
                      tmp_36 = gettext("incompatible tabs");
                      {
                        void *__va_args_146[1] = {(void *)0};
                        error(SORT_FAILURE,0,(char const *)tmp_36,
                              (void * const *)(__va_args_146));
                      }
                      __builtin_unreachable();
                    }
                    else {
                      int tmp_37;
                      tmp_37 = gettext("incompatible tabs");
                      {
                        void *__va_args_148[1] = {(void *)0};
                        error(SORT_FAILURE,0,(char const *)tmp_37,
                              (void * const *)(__va_args_148));
                      }
                      __builtin_unreachable();
                    }
                tab = (int)newtab;
              }
              break;
              case 'T': add_temp_dir((char const *)optarg);
              break;
              case PARALLEL_OPTION:
              nthreads = specify_nthreads(oi,(char)c,(char const *)optarg);
              break;
              case 'u': unique = (_Bool)1;
              break;
              case 'y': ;
              if (optarg == *(argv + (optind - 1))) {
                char const *p;
                p = (char const *)optarg;
                while ((unsigned int)*p - (unsigned int)'0' <= (unsigned int)9) {
                  goto __Cont;
                  __Cont: p ++;
                }
                optind -= (int)*p != 0;
              }
              break;
              case 'z': eolchar = (char)0;
              break;
              case GETOPT_HELP_CHAR: usage(0);
              break;
              case GETOPT_VERSION_CHAR:
              {
                char const *__va_arg0_150 = "Mike Haertel";
                char const *__va_arg1 = "Paul Eggert";
                char *__va_arg2 = (char *)0;
                void *__va_args_154[3] =
                  {& __va_arg0_150, & __va_arg1, & __va_arg2};
                version_etc(_impure_ptr->_stdout,"sort","GNU coreutils",
                            Version,(void * const *)(__va_args_154));
              }
              exit(0);
              break;
              default: usage(SORT_FAILURE);
            }
        }
    }
  }
  if (files_from) {
    _Bool tmp_46;
    if (nfiles) {
      char *tmp_38;
      int tmp_39;
      int tmp_40;
      tmp_38 = quotearg_style(shell_escape_always_quoting_style,
                              (char const *)*(files + 0));
      tmp_39 = gettext("extra operand %s");
      {
        char *__va_arg0_156 = tmp_38;
        void *__va_args_158[1] = {& __va_arg0_156};
        error(0,0,(char const *)tmp_39,(void * const *)(__va_args_158));
      }
      tmp_40 = gettext("file operands cannot be combined with --files0-from");
      ;
      fprintf(_impure_ptr->_stderr,"%s\n",(char *)tmp_40); /* fprintf_va_1 */
      usage(SORT_FAILURE);
    }
    FILE *stream = xfopen((char const *)files_from,"r");
    readtokens0_init(& tok);
    tmp_46 = readtokens0(stream,& tok);
    if (! tmp_46)
      if (! (! sizeof(struct __anonstruct_63))) {
        char *tmp_42;
        int tmp_43;
        tmp_42 = quotearg_style(shell_escape_always_quoting_style,
                                (char const *)files_from);
        tmp_43 = gettext("cannot read file names from %s");
        {
          char *__va_arg0_160 = tmp_42;
          void *__va_args_162[1] = {& __va_arg0_160};
          error(SORT_FAILURE,0,(char const *)tmp_43,
                (void * const *)(__va_args_162));
        }
        __builtin_unreachable();
      }
      else {
        char *tmp_44;
        int tmp_45;
        tmp_44 = quotearg_style(shell_escape_always_quoting_style,
                                (char const *)files_from);
        tmp_45 = gettext("cannot read file names from %s");
        {
          char *__va_arg0_164 = tmp_44;
          void *__va_args_166[1] = {& __va_arg0_164};
          error(SORT_FAILURE,0,(char const *)tmp_45,
                (void * const *)(__va_args_166));
        }
        __builtin_unreachable();
      }
    xfclose(stream,(char const *)files_from);
    if (tok.n_tok) {
      free((void *)files);
      files = tok.tok;
      nfiles = tok.n_tok;
      {
        size_t i_0 = (unsigned long)0;
        while (i_0 < nfiles) {
          {
            int tmp_55;
            tmp_55 = strcmp((char const *)*(files + i_0),"-");
            if (tmp_55 == 0)
              if (! (! sizeof(struct __anonstruct_64))) {
                char *tmp_47;
                int tmp_48;
                tmp_47 = quotearg_style(shell_escape_always_quoting_style,
                                        (char const *)*(files + i_0));
                tmp_48 = gettext("when reading file names from stdin, no file name of %s allowed");
                {
                  char *__va_arg0_168 = tmp_47;
                  void *__va_args_170[1] = {& __va_arg0_168};
                  error(SORT_FAILURE,0,(char const *)tmp_48,
                        (void * const *)(__va_args_170));
                }
                __builtin_unreachable();
              }
              else {
                char *tmp_49;
                int tmp_50;
                tmp_49 = quotearg_style(shell_escape_always_quoting_style,
                                        (char const *)*(files + i_0));
                tmp_50 = gettext("when reading file names from stdin, no file name of %s allowed");
                {
                  char *__va_arg0_172 = tmp_49;
                  void *__va_args_174[1] = {& __va_arg0_172};
                  error(SORT_FAILURE,0,(char const *)tmp_50,
                        (void * const *)(__va_args_174));
                }
                __builtin_unreachable();
              }
            else
              if ((int)*(*(files + i_0) + 0) == 0) {
                unsigned long file_number = i_0 + (size_t)1;
                if (! (! sizeof(struct __anonstruct_65))) {
                  char *tmp_51;
                  int tmp_52;
                  ;
                  tmp_51 = quotearg_n_style_colon(0,
                                                  shell_escape_quoting_style,
                                                  (char const *)files_from);
                  tmp_52 = gettext("%s:%lu: invalid zero-length file name");
                  {
                    char *__va_arg0_176 = tmp_51;
                    unsigned long __va_arg1_178 = file_number;
                    void *__va_args_180[2] =
                      {& __va_arg0_176, & __va_arg1_178};
                    error(SORT_FAILURE,0,(char const *)tmp_52,
                          (void * const *)(__va_args_180));
                  }
                  __builtin_unreachable();
                }
                else {
                  char *tmp_53;
                  int tmp_54;
                  ;
                  tmp_53 = quotearg_n_style_colon(0,
                                                  shell_escape_quoting_style,
                                                  (char const *)files_from);
                  tmp_54 = gettext("%s:%lu: invalid zero-length file name");
                  {
                    char *__va_arg0_182 = tmp_53;
                    unsigned long __va_arg1_184 = file_number;
                    void *__va_args_186[2] =
                      {& __va_arg0_182, & __va_arg1_184};
                    error(SORT_FAILURE,0,(char const *)tmp_54,
                          (void * const *)(__va_args_186));
                  }
                  __builtin_unreachable();
                }
              }
          }
          i_0 ++;
        }
      }
    }
    else
      if (! (! sizeof(struct __anonstruct_66))) {
        char *tmp_56;
        int tmp_57;
        tmp_56 = quotearg_style(shell_escape_always_quoting_style,
                                (char const *)files_from);
        tmp_57 = gettext("no input from %s");
        {
          char *__va_arg0_188 = tmp_56;
          void *__va_args_190[1] = {& __va_arg0_188};
          error(SORT_FAILURE,0,(char const *)tmp_57,
                (void * const *)(__va_args_190));
        }
        __builtin_unreachable();
      }
      else {
        char *tmp_58;
        int tmp_59;
        tmp_58 = quotearg_style(shell_escape_always_quoting_style,
                                (char const *)files_from);
        tmp_59 = gettext("no input from %s");
        {
          char *__va_arg0_192 = tmp_58;
          void *__va_args_194[1] = {& __va_arg0_192};
          error(SORT_FAILURE,0,(char const *)tmp_59,
                (void * const *)(__va_args_194));
        }
        __builtin_unreachable();
      }
  }
  key = keylist;
  while (key) {
    {
      _Bool tmp_60;
      tmp_60 = default_key_compare((struct keyfield const *)key);
      if (tmp_60)
        if (! key->reverse) {
          key->ignore = gkey.ignore;
          key->translate = gkey.translate;
          key->skipsblanks = gkey.skipsblanks;
          key->skipeblanks = gkey.skipeblanks;
          key->month = gkey.month;
          key->numeric = gkey.numeric;
          key->general_numeric = gkey.general_numeric;
          key->human_numeric = gkey.human_numeric;
          key->version = gkey.version;
          key->random = gkey.random;
          key->reverse = gkey.reverse;
        }
      need_random = (_Bool)(((int)need_random | (int)key->random) != 0);
    }
    key = key->next;
  }
  if (! keylist) {
    _Bool tmp_61;
    tmp_61 = default_key_compare((struct keyfield const *)(& gkey));
    if (! tmp_61) {
      gkey_only = (_Bool)1;
      insertkey(& gkey);
      need_random = (_Bool)(((int)need_random | (int)gkey.random) != 0);
    }
  }
  check_ordering_compatibility();
  if (debug) {
    if (checkonly) goto _LOR_0;
    else
      if (outfile) {
        _LOR_0:
        {
          if (checkonly) main_opts[0] = checkonly;
          else main_opts[0] = (char)'o';
          incompatible_options((char const *)(main_opts));
        }
      }
    if (locale_ok) {
      int tmp_63;
      char *tmp_62;
      tmp_62 = setlocale(1,"");
      if (tmp_62) tmp_63 = 1; else tmp_63 = 0;
      locale_ok = (_Bool)(tmp_63 != 0);
    }
    if (! locale_ok) {
      int tmp_64;
      tmp_64 = gettext("failed to set locale");
      {
        int __va_arg0_196 = tmp_64;
        void *__va_args_198[1] = {& __va_arg0_196};
        error(0,0,"%s",(void * const *)(__va_args_198));
      }
    }
    if (hard_LC_COLLATE) {
      char const *tmp_66;
      char *tmp_65;
      int tmp_67;
      tmp_65 = setlocale(1,(char const *)0);
      tmp_66 = quote((char const *)tmp_65);
      tmp_67 = gettext("text ordering performed using %s sorting rules");
      {
        char const *__va_arg0_200 = tmp_66;
        void *__va_args_202[1] = {& __va_arg0_200};
        error(0,0,(char const *)tmp_67,(void * const *)(__va_args_202));
      }
    }
    else {
      int tmp_68;
      tmp_68 = gettext("text ordering performed using simple byte comparison");
      {
        int __va_arg0_204 = tmp_68;
        void *__va_args_206[1] = {& __va_arg0_204};
        error(0,0,"%s",(void * const *)(__va_args_206));
      }
    }
    key_warnings((struct keyfield const *)(& gkey),gkey_only);
  }
  reverse = gkey.reverse;
  if (need_random) random_md5_state_init((char const *)random_source);
  if (temp_dir_count == (size_t)0) {
    char const *tmp_70;
    char const *tmp_dir = getenv("TMPDIR");
    if (tmp_dir) tmp_70 = tmp_dir; else tmp_70 = "/tmp";
    add_temp_dir(tmp_70);
  }
  if (nfiles == (size_t)0) {
    nfiles = (unsigned long)1;
    free((void *)files);
    files = (char **)xmalloc((unsigned long)sizeof(*files));
    *files = (char *)"-";
  }
  if ((size_t)0 < sort_size)
    if (sort_size > (size_t)(nmerge * ((unsigned int)2 + sizeof(struct line))))
      sort_size = sort_size;
    else sort_size = (unsigned long)(nmerge * ((unsigned int)2 + sizeof(struct line)));
  if (checkonly) {
    int tmp_76;
    _Bool tmp_75;
    if (nfiles > (size_t)1)
      if (! (! sizeof(struct __anonstruct_67))) {
        char *tmp_71;
        int tmp_72;
        ;
        tmp_71 = quotearg_style(shell_escape_always_quoting_style,
                                (char const *)*(files + 1));
        tmp_72 = gettext("extra operand %s not allowed with -%c");
        {
          char *__va_arg0_208 = tmp_71;
          int __va_arg1_210 = (int)checkonly;
          void *__va_args_212[2] = {& __va_arg0_208, & __va_arg1_210};
          error(SORT_FAILURE,0,(char const *)tmp_72,
                (void * const *)(__va_args_212));
        }
        __builtin_unreachable();
      }
      else {
        char *tmp_73;
        int tmp_74;
        ;
        tmp_73 = quotearg_style(shell_escape_always_quoting_style,
                                (char const *)*(files + 1));
        tmp_74 = gettext("extra operand %s not allowed with -%c");
        {
          char *__va_arg0_214 = tmp_73;
          int __va_arg1_216 = (int)checkonly;
          void *__va_args_218[2] = {& __va_arg0_214, & __va_arg1_216};
          error(SORT_FAILURE,0,(char const *)tmp_74,
                (void * const *)(__va_args_218));
        }
        __builtin_unreachable();
      }
    if (outfile) {
      main_opts_0[0] = checkonly;
      incompatible_options((char const *)(main_opts_0));
    }
    tmp_75 = check((char const *)*(files + 0),checkonly);
    if (tmp_75) tmp_76 = 0; else tmp_76 = SORT_OUT_OF_ORDER;
    __retres = tmp_76;
    goto return_label;
  }
  check_inputs((char * const *)files,nfiles);
  check_output(outfile);
  if (mergeonly) {
    struct sortfile *tmp_78;
    struct sortfile *sortfiles =
      xcalloc(nfiles,(unsigned long)sizeof(*tmp_78));
    {
      size_t i_1 = (unsigned long)0;
      while (i_1 < nfiles) {
        (sortfiles + i_1)->name = (char const *)*(files + i_1);
        i_1 ++;
      }
    }
    merge(sortfiles,(unsigned long)0,nfiles,outfile);
    free((void *)sortfiles);
  }
  else {
    if (! nthreads) {
      unsigned long np = num_processors(NPROC_CURRENT_OVERRIDABLE);
      if (np < (unsigned long)DEFAULT_MAX_THREADS) nthreads = np;
      else nthreads = (unsigned long)DEFAULT_MAX_THREADS;
    }
    size_t nthreads_max =
      (unsigned long)(0xffffffffffffffffUL / (unsigned long long)((unsigned int)2 * sizeof(struct merge_node)));
    if (nthreads < nthreads_max) nthreads = nthreads;
    else nthreads = nthreads_max;
    sort((char * const *)files,nfiles,outfile,nthreads);
  }
  if (files_from) readtokens0_free(& tok); else free((void *)files);
  if (have_read_stdin) {
    int tmp_81;
    tmp_81 = fclose(_impure_ptr->_stdin);
    if (tmp_81 == -1) {
      int tmp_80;
      tmp_80 = gettext("close failed");
      sort_die((char const *)tmp_80,"-");
    }
  }
  __retres = 0;
  return_label: return __retres;
}


