/* Generated by Frama-C */
typedef unsigned long size_t;
typedef unsigned int __u_int;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[((unsigned long)15 * sizeof(int) - (unsigned long)4 * sizeof(void *)) - sizeof(size_t)] ;
};
typedef __u_int u_int;
typedef __time_t time_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_13 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion_12 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_13 __wseq32 ;
};
struct __anonstruct___g1_start32_15 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion_14 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_15 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion_12 __anonCompField1 ;
   union __anonunion_14 __anonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_16 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_16 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_17 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_17 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_18 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_18 pthread_mutex_t;
union __anonunion_pthread_cond_t_19 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_19 pthread_cond_t;
enum __anonenum_25 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = _SC_UIO_MAXIOV,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248
};
enum __anonenum_27 {
    _ISupper = (1 << 0) << 8,
    _ISlower = (1 << 1) << 8,
    _ISalpha = (1 << 2) << 8,
    _ISdigit = (1 << 3) << 8,
    _ISxdigit = (1 << 4) << 8,
    _ISspace = (1 << 5) << 8,
    _ISprint = (1 << 6) << 8,
    _ISgraph = (1 << 7) << 8,
    _ISblank = (1 << 8) >> 8,
    _IScntrl = (1 << 9) >> 8,
    _ISpunct = (1 << 10) >> 8,
    _ISalnum = (1 << 11) >> 8
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
enum __anonenum_30 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
};
struct _pattern_ {
   u_int p_type ;
   char p_c ;
   char *p_ccl ;
   int p_col ;
   struct _pattern_ *p_next ;
   struct _pattern_ *p_alt ;
};
typedef struct _pattern_ PATTERN;
struct bm_pattern {
   short p_m ;
   short p_r[128] ;
   short *p_R ;
   char *p_pat ;
};
typedef struct bm_pattern BM_PATTERN;
struct work_st {
   char *path ;
   int tp ;
   struct work_st *next ;
};
typedef struct work_st work_t;
struct out_st {
   char *line ;
   int line_count ;
   long byte_count ;
   struct out_st *next ;
};
typedef struct out_st out_t;
extern struct _IO_FILE *stderr;

extern int fclose(FILE *__stream);

extern FILE *fopen(char const * __restrict __filename,
                   char const * __restrict __modes);

extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict __stream,
                                                 char * __restrict __buf,
                                                 int __modes, size_t __n) __attribute__((
__leaf__));

extern char *fgets(char * __restrict __s, int __n, FILE * __restrict __stream);

extern  __attribute__((__nothrow__)) void *memset(void *__s, int __c,
                                                  size_t __n) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict __dest,
                                                  char const * __restrict __src) __attribute__((
__nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) char *strcat(char * __restrict __dest,
                                                  char const * __restrict __src) __attribute__((
__nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) char *strdup(char const *__s) __attribute__((
__nonnull__(1), __malloc__, __leaf__));

extern  __attribute__((__nothrow__)) char *strchr(char const *__s, int __c) __attribute__((
__pure__, __nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) char *strrchr(char const *__s, int __c) __attribute__((
__pure__, __nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) size_t strlen(char const *__s) __attribute__((
__pure__, __nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) char *strerror(int __errnum) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) int atoi(char const *__nptr) __attribute__((
__pure__, __nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) long strtol(char const * __restrict __nptr,
                                                 char ** __restrict __endptr,
                                                 int __base) __attribute__((
__nonnull__(1), __leaf__));

// extern int ( /* missing proto */ __builtin_bswap32)(unsigned int x_0);

__inline static unsigned int __bswap_32(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32(__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

// extern int ( /* missing proto */ __builtin_bswap64)(unsigned long x_0);

__inline static __uint64_t __bswap_64(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64(__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

__inline static __uint16_t __uint16_identity(__uint16_t __x)
{
  return __x;
}

__inline static __uint32_t __uint32_identity(__uint32_t __x)
{
  return __x;
}

__inline static __uint64_t __uint64_identity(__uint64_t __x)
{
  return __x;
}

extern  __attribute__((__nothrow__)) void *malloc(size_t __size) __attribute__((
__malloc__, __leaf__));

extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb,
                                                  size_t __size) __attribute__((
__malloc__, __leaf__));

extern  __attribute__((__nothrow__)) void free(void *__ptr) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) char *getenv(char const *__name) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) long sysconf(int __name) __attribute__((
__leaf__));

extern char *optarg;

extern int optind;

extern  __attribute__((__nothrow__)) int getopt(int ___argc,
                                                char * const *___argv,
                                                char const *__shortopts) __attribute__((
__nonnull__(2,3), __leaf__));

extern  __attribute__((__nothrow__)) int *__errno_location(void) __attribute__((
__leaf__, __const__));

extern  __attribute__((__nothrow__)) unsigned short const **__ctype_b_loc
(void) __attribute__((__leaf__, __const__));

extern  __attribute__((__nothrow__)) int tolower(int __c) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) time_t time(time_t *__timer) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) int stat(char const * __restrict __file,
                                              struct stat * __restrict __buf) __attribute__((
__nonnull__(1,2), __leaf__));

extern DIR *opendir(char const *__name) __attribute__((__nonnull__(1)));

extern int closedir(DIR *__dirp) __attribute__((__nonnull__(1)));

extern int readdir_r(DIR * __restrict __dirp,
                     struct dirent * __restrict __entry,
                     struct dirent ** __restrict __result) __attribute__((
__nonnull__(1,2,3), __deprecated__));

char const *Tgrep_Version = "Special-V1-POSIX";
extern  __attribute__((__nothrow__)) int sched_yield(void) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict __newthread,
                                                        pthread_attr_t const * __restrict __attr,
                                                        void *(*__start_routine)
                                                        (void *),
                                                        void * __restrict __arg) __attribute__((
__nonnull__(1,3)));

extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(
                                                                    pthread_attr_t *__attr,
                                                                    int __detachstate) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex,
                                                            pthread_mutexattr_t const *__mutexattr) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex) __attribute__((
__nonnull__(1)));

extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex) __attribute__((
__nonnull__(1)));

extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict __cond,
                                                           pthread_condattr_t const * __restrict __cond_attr) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond) __attribute__((
__nonnull__(1)));

extern int pthread_cond_wait(pthread_cond_t * __restrict __cond,
                             pthread_mutex_t * __restrict __mutex) __attribute__((
__nonnull__(1,2)));

static char *_metachars = (char *)"$^.*+[(|@d";
static unsigned int all_metas =
  (unsigned int)(((((((((0x0001 | 0x0002) | 0x0004) | 0x0008) | 0x0010) | 0x0020) | 0x0040) | 0x0080) | 0x0100) | 0x0200);
static char *match(char *s, PATTERN *pat, char *start);

void freepat(PATTERN *pat);

char *pmatch(PATTERN *pattern, char *string_0, int *len)
{
  char *__retres;
  char *end;
  char *start;
  start = string_0;
  while (*string_0) {
    end = match(string_0,pattern,start);
    if (end) {
      if (len) *len = (int)(end - string_0);
      __retres = string_0;
      goto return_label;
    }
    string_0 ++;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

/*@ assigns \result;
    assigns \result \from (indirect: *(__format + (0 ..)));
 */
int printf_va_1(char const * __restrict __format);

static char *match(char *s, PATTERN *pat, char *start)
{
  char *__retres;
  char *startclosure;
  char *end;
  while (pat) {
    switch (pat->p_type) {
      char *tmp;
      int tmp_0;
      char *tmp_2;
      char *tmp_1;
      case (u_int)0x0400: { /* sequence */
                            tmp = s;
                            s ++;
                            ;
                          }
      if ((int)pat->p_c == (int)*tmp) goto __Cont;
      break;
      case (u_int)0x0002: ;
      if (s == start) goto __Cont;
      break;
      case (u_int)0x0001: ;
      if ((int)*s == '\000') goto __Cont;
      else
        if ((int)*s == '\n') goto __Cont;
      break;
      case (u_int)0x0004: ;
      if ((int)*s != '\000')
        if ((int)*s != '\n') {
          s ++;
          goto __Cont;
        }
      break;
      case (u_int)0x0008: case (u_int)0x0010:
      if (pat->p_type == (u_int)0x0010) startclosure = s + 1;
      else startclosure = s;
      while (1) {
        if (*s) {
          end = match(s,pat->p_alt,start);
          if (! end) break;
        }
        else break;
        s = end;
      }
      while (s >= startclosure) {
        end = match(s,pat->p_next,start);
        if (end) {
          __retres = end;
          goto return_label;
        }
        s --;
      }
      break;
      case (u_int)0x0040: s = match(s,pat->p_alt,start);
      if (s) goto __Cont;
      break;
      case (u_int)0x0080: end = match(s,pat->p_next,start);
      if (end) {
        __retres = end;
        goto return_label;
      }
      else {
        end = match(s,pat->p_alt,start);
        if (end) {
          __retres = end;
          goto return_label;
        }
      }
      break;
      case (u_int)0x0200: { /* sequence */
                            tmp_0 = tolower((int)*s);
                            ;
                          }
      if ((int)pat->p_c == tmp_0) {
        s ++;
        goto __Cont;
      }
      break;
      case (u_int)0x0020: { /* sequence */
                            tmp_1 = s;
                            s ++;
                            ;
                            ;
                          }
      tmp_2 = strchr((char const *)pat->p_ccl,(int)*tmp_1);
      if (tmp_2) goto __Cont;
      break;
      case (u_int)0x0800: ;
      if ((int)*s != '\000') {
        char *tmp_3;
        tmp_3 = strchr((char const *)pat->p_ccl,(int)*s);
        if (! tmp_3) {
          s ++;
          goto __Cont;
        }
      }
      break;
      case (u_int)0x0100: ;
      if ((long)pat->p_col == (s - start) + (long)1) goto __Cont;
      break;
      default: printf("match: can\'t happen\n"); /* printf_va_1 */
    }
    __retres = (char *)0;
    goto return_label;
    __Cont: pat = pat->p_next;
  }
  __retres = s;
  return_label: return __retres;
}

PATTERN *makepat(char *string_0, char *metas)
{
  PATTERN *__retres;
  PATTERN *pattern;
  PATTERN *oldpat;
  register PATTERN *pat;
  char *temp;
  char *ccl;
  register char *s;
  unsigned int orig_metas;
  unsigned int on_metas;
  unsigned int paren;
  int i;
  if (! string_0) {
    __retres = (PATTERN *)0;
    goto return_label;
  }
  else
    if (! *string_0) {
      __retres = (PATTERN *)0;
      goto return_label;
    }
  if (metas != (char *)0) {
    register char *sp;
    orig_metas = (unsigned int)0;
    while (*metas) {
      sp = strchr((char const *)_metachars,(int)*metas);
      if (! sp) {
        __retres = (PATTERN *)0;
        goto return_label;
      }
      orig_metas |= (unsigned int)(1 << (sp - _metachars));
      metas ++;
    }
  }
  else orig_metas = all_metas;
  on_metas = orig_metas;
  s = string_0;
  pattern = (PATTERN *)calloc((unsigned long)1,sizeof(PATTERN));
  pat = pattern;
  oldpat = pat;
  temp = (char *)malloc((unsigned long)128 * sizeof(char));
  while (*s) {
    switch ((int)*s) {
      int tmp_6;
      char *tmp_8;
      case '\\': s ++;
      tmp_6 = tolower((int)*s);
      if (tmp_6 == 'c') {
        pat->p_type = (unsigned int)0x0400;
        s ++;
        pat->p_c = *s;
      }
      else {
        int tmp_5;
        tmp_5 = tolower((int)*s);
        if (tmp_5 == 'o') {
          register char *sp_0;
          s ++;
          ;
          ;
          sp_0 = strchr((char const *)_metachars,(int)*s);
          if (! sp_0) goto fail;
          on_metas |= (unsigned int)(1 << (sp_0 - _metachars));
          goto __Cont;
        }
        else {
          char *tmp_2;
          tmp_2 = strchr("01234567",(int)*(s + 0));
          if (tmp_2) {
            char *tmp_3;
            tmp_3 = strchr("01234567",(int)*(s + 1));
            if (tmp_3) {
              char *tmp_4;
              tmp_4 = strchr("01234567",(int)*(s + 2));
              if (tmp_4) {
                long tmp_1;
                pat->p_type = (unsigned int)0x0400;
                tmp_1 = strtol((char const *)s,(char **)0,8);
                pat->p_c = (char)tmp_1;
                s += 2;
              }
              else goto _LAND_0;
            }
            else goto _LAND_0;
          }
          else {
            _LAND_0: {
                       pat->p_type = (unsigned int)0x0400;
                       pat->p_c = *s;
                     }
          }
        }
      }
      break;
      case '$': if (! (on_metas & (unsigned int)0x0001)) goto normal;
      if ((int)*(s + 1) != '\000')
        if ((int)*(s + 1) != '|')
          if ((int)*(s + 1) != ')')
            if ((int)*(s + 1) != '\n') goto fail;
      pat->p_type = (unsigned int)0x0001;
      break;
      case '^': if (! (on_metas & (unsigned int)0x0002)) goto normal;
      if (s != string_0)
        if ((int)*(s + -1) != '|')
          if ((int)*(s + -1) != '(') goto fail;
      pat->p_type = (unsigned int)0x0002;
      break;
      case '.': if (! (on_metas & (unsigned int)0x0004)) goto normal;
      pat->p_type = (unsigned int)0x0004;
      break;
      case '*': if (! (on_metas & (unsigned int)0x0008)) goto normal;
      pat->p_type = (unsigned int)0x0008;
      goto closure;
      case '+': if (! (on_metas & (unsigned int)0x0010)) goto normal;
      pat->p_type = (unsigned int)0x0010;
      closure: ;
      if (pat == pattern) goto fail;
      else
        if (oldpat->p_type & (unsigned int)(0x0008 | 0x0010)) goto fail;
      pat->p_alt = pat;
      {
        PATTERN tmp_7 = *pat;
        *pat = *oldpat;
        *oldpat = tmp_7;
      }
      pat->p_next = (struct _pattern_ *)0;
      pat = oldpat;
      break;
      case '[': if (! (on_metas & (unsigned int)0x0020)) goto normal;
      if ((int)*(s + 1) == '^') {
        pat->p_type = (unsigned int)0x0800;
        s ++;
      }
      else pat->p_type = (unsigned int)0x0020;
      tmp_8 = (char *)malloc((unsigned long)128 * sizeof(char));
      pat->p_ccl = tmp_8;
      ccl = tmp_8;
      while (1) {
        s ++;
        ;
        if ((int)*s == '\\') {
          int tmp_12;
          s ++;
          tmp_12 = tolower((int)*s);
          if (tmp_12 == 'c') {
            char *tmp_10;
            tmp_10 = ccl;
            ccl ++;
            s ++;
            *tmp_10 = *s;
          }
          else {
            char *tmp_11;
            tmp_11 = ccl;
            ccl ++;
            *tmp_11 = *s;
          }
        }
        else
          if ((int)*s == '-') {
            if (ccl == pat->p_ccl) goto _LOR;
            else
              if ((int)*(s + 1) == ']') {
                char *tmp_13;
                _LOR: { /* sequence */
                        tmp_13 = ccl;
                        ccl ++;
                        *tmp_13 = *s;
                      }
              }
              else {
                ccl --;
                s ++;
                ;
                if ((int)*ccl >= (int)*s) goto fail;
                while ((int)*ccl < (int)*s) {
                  *(ccl + 1) = (char)((int)*ccl + 1);
                  ccl ++;
                }
                ccl ++;
              }
          }
          else
            if ((int)*s == ']') {
              *ccl = (char)'\000';
              break;
            }
            else
              if ((int)*s == '\000') goto fail;
              else {
                char *tmp_14;
                tmp_14 = ccl;
                ccl ++;
                *tmp_14 = *s;
              }
      }
      break;
      case '(': if (! (on_metas & (unsigned int)0x0040)) goto normal;
      i = -1;
      paren = (unsigned int)1;
      while (1) {
        s ++;
        ;
        if ((int)*s == '\\') {
          char *tmp_15;
          int tmp_17;
          i ++;
          tmp_15 = s;
          s ++;
          *(temp + i) = *tmp_15;
          tmp_17 = tolower((int)*s);
          if (tmp_17 == 'c') {
            char *tmp_16;
            i ++;
            tmp_16 = s;
            s ++;
            *(temp + i) = *tmp_16;
          }
        }
        else
          if ((int)*s == '(') paren ++;
          else
            if ((int)*s == ')') {
              paren --;
              if (paren) goto _LAND_1; else break;
            }
            else {
              _LAND_1: ;
              if ((int)*s == '\000') goto fail;
            }
        i ++;
        *(temp + i) = *s;
      }
      i ++;
      *(temp + i) = (char)'\000';
      pat->p_alt = makepat(temp,metas);
      pat->p_type = (unsigned int)0x0040;
      break;
      case '|': if (! (on_metas & (unsigned int)0x0080)) goto normal;
      s ++;
      ;
      if (*s) {
        struct _pattern_ *tmp_18;
        tmp_18 = makepat(s,metas);
        pat->p_alt = tmp_18;
        if (! tmp_18) goto fail;
      }
      pat->p_type = (unsigned int)0x0080;
      if (pat != pattern) {
        oldpat->p_next = (struct _pattern_ *)0;
        pat->p_next = pattern;
      }
      goto ret;
      case '@': if (! (on_metas & (unsigned int)0x0100)) goto normal;
      s ++;
      ;
      if ((int)*s != '(') goto fail;
      i = 0;
      s ++;
      while (1) {
        unsigned short const **tmp_20;
        char *tmp_19;
        tmp_20 = __ctype_b_loc();
        ;
        if (! ((int)*(*tmp_20 + (int)*s) & (int)((unsigned short)_ISdigit)))
          break;
        tmp_19 = s;
        s ++;
        *(temp + i) = *tmp_19;
        i ++;
      }
      if ((int)*s != ')') goto fail;
      pat->p_col = atoi((char const *)temp);
      if (pat->p_col == 0) goto fail;
      pat->p_type = (unsigned int)0x0100;
      break;
      normal: default: ;
      if (on_metas & (unsigned int)0x0200) {
        int tmp_21;
        pat->p_type = (unsigned int)0x0200;
        tmp_21 = tolower((int)*s);
        pat->p_c = (char)tmp_21;
      }
      else {
        pat->p_type = (unsigned int)0x0400;
        pat->p_c = *s;
      }
      break;
    }
    oldpat = pat;
    pat = (PATTERN *)calloc((unsigned long)1,sizeof(PATTERN));
    oldpat->p_next = pat;
    on_metas = orig_metas;
    __Cont: s ++;
  }
  oldpat->p_next = (struct _pattern_ *)0;
  free((void *)pat);
  ret: free((void *)temp);
  __retres = pattern;
  goto return_label;
  fail: freepat(pattern);
  __retres = (PATTERN *)0;
  return_label: return __retres;
}

void freepat(PATTERN *pat)
{
  if (pat->p_next) freepat(pat->p_next);
  if (pat->p_alt) freepat(pat->p_alt);
  if (pat->p_ccl) free((void *)pat->p_ccl);
  free((void *)pat);
  return;
}

char *bm_pmatch(BM_PATTERN *pat, char *s);

BM_PATTERN *bm_makepat(char *p);

void bm_freepat(BM_PATTERN *pattern);

BM_PATTERN *bm_makepat(char *p)
{
  BM_PATTERN *__retres;
  register int i;
  register int j;
  register int k;
  register int l;
  short m;
  short *r;
  short *R;
  char *s;
  int unify;
  BM_PATTERN *pat;
  size_t tmp_0;
  char *tmp_1;
  pat = (BM_PATTERN *)calloc((unsigned long)1,sizeof(BM_PATTERN));
  if (! pat) {
    __retres = (BM_PATTERN *)0;
    goto return_label;
  }
  tmp_0 = strlen((char const *)p);
  pat->p_m = (short)tmp_0;
  tmp_1 = strdup((char const *)p);
  pat->p_pat = tmp_1;
  if (! tmp_1) {
    free((void *)pat);
    __retres = (BM_PATTERN *)0;
    goto return_label;
  }
  pat->p_R = (short *)calloc((unsigned long)((int)pat->p_m + 1),
                             sizeof(short));
  r = pat->p_r;
  R = pat->p_R;
  m = pat->p_m;
  if (! R) {
    free((void *)pat->p_pat);
    free((void *)pat);
    __retres = (BM_PATTERN *)0;
    goto return_label;
  }
  i = 0;
  while (i < 128) {
    s = strrchr((char const *)p,i);
    if (s) *(r + i) = (short)(((long)m - (s - p)) - (long)1);
    else *(r + i) = m;
    i ++;
  }
  j = 0;
  while (j < (int)m) {
    k = j;
    while (1) {
      if (k > 0)
        if ((int)*(p + (k - 1)) == (int)*(p + j)) {
          k --;
          continue;
        }
      l = ((k + (int)m) - j) - 1;
      i = (int)m - 1;
      unify = 0;
      while (1)
        if (i == j) goto _LOR;
        else
          if (l < 1) {
            _LOR: {
                    unify = 1;
                    break;
                  }
          }
          else
            if ((int)*(p + i) != (int)*(p + l)) {
              unify = 0;
              break;
            }
            else {
              i --;
              l --;
            }
      if (unify == 1) {
        *(R + j) = (short)((int)m - k);
        break;
      }
      else {
        k --;
        continue;
      }
    }
    j ++;
  }
  __retres = pat;
  return_label: return __retres;
}

char *bm_pmatch(BM_PATTERN *pat, char *s)
{
  char *__retres;
  register short i;
  register short j;
  register short n;
  short m;
  short *r;
  short *R;
  char *p;
  char *S;
  char *Pend;
  size_t tmp;
  tmp = strlen((char const *)s);
  n = (short)tmp;
  p = pat->p_pat;
  r = pat->p_r;
  R = pat->p_R;
  m = pat->p_m;
  i = (short)((int)m - 1);
  S = s;
  Pend = pat->p_pat + i;
  s = S + i;
  while (1) {
    if ((int)i >= (int)n) {
      __retres = (char *)0;
      goto return_label;
    }
    else {
      j = (short)((int)m - 1);
      p = Pend;
    }
    while (1) {
      if ((int)j == -1) {
        __retres = s;
        goto return_label;
      }
      if ((int)*s == (int)*p) {
        j = (short)((int)j - 1);
        i = (short)((int)i - 1);
        s --;
        p --;
      }
      else {
        int tmp_0;
        if ((int)*(R + j) > (int)*(r + *s)) tmp_0 = (int)*(R + j);
        else tmp_0 = (int)*(r + *s);
        i = (short)((int)i + tmp_0);
        s = S + i;
        break;
      }
    }
  }
  return_label: return __retres;
}

void bm_freepat(BM_PATTERN *pattern)
{
  free((void *)pattern->p_pat);
  free((void *)pattern->p_R);
  free((void *)pattern);
  return;
}

BM_PATTERN *bm_pat;
PATTERN *pm_pat[10];
int main(int argc, char **argv);

int add_work(char *path, int tp);

void *search_thr(void *arg);

int continue_line(char *rline, FILE *fin, out_t *out, work_t *wt, int *lc,
                  long *bc);

void *cascade(void *arg);

int print_local_output(out_t *out, work_t *wt);

int add_output_local(out_t **out, work_t *wt, int lc, long bc, char *line);

void prnt_stats(void);

void notrun(void);

void uncase(char *s);

void usage(void);

int regexp_usage(void);

void pthread_setconcurrency_np(int con);

int pthread_getconcurrency_np(void);

void pthread_yield_np(void);

pthread_attr_t detached_attr;
pthread_mutex_t output_print_lk;
pthread_mutex_t global_count_lk;
int global_count = 0;
work_t *work_q = (work_t *)0;
pthread_cond_t work_q_cv;
pthread_mutex_t work_q_lk;
pthread_mutex_t debug_lock;
work_t *search_q = (work_t *)0;
pthread_mutex_t search_q_lk;
pthread_cond_t search_q_cv;
int search_pool_cnt = 0;
int search_thr_limit = 0;
work_t *cascade_q = (work_t *)0;
pthread_mutex_t cascade_q_lk;
pthread_cond_t cascade_q_cv;
int cascade_pool_cnt = 0;
int cascade_thr_limit = 0;
int running = 0;
pthread_mutex_t running_lk;
pthread_mutex_t stat_lk;
time_t st_start = (long)0;
int st_dir_search = 0;
int st_file_search = 0;
int st_line_search = 0;
int st_cascade = 0;
int st_cascade_pool = 0;
int st_cascade_destroy = 0;
int st_search = 0;
int st_pool = 0;
int st_maxrun = 0;
int st_worknull = 0;
int st_workfds = 0;
int st_worklimit = 0;
int st_destroy = 0;
int all_done = 0;
int work_cnt = 0;
int current_open_files = 0;
int tglimit = 99999;
int progress_offset = 1;
int progress = 0;
unsigned int flags = (unsigned int)0;
int regexp_cnt = 0;
char *string[10];
int debug = 0;
int use_pmatch = 0;
char file_pat[255];
PATTERN *pm_file_pat;
int pthread_create0(pthread_t *thread, pthread_attr_t const *attr,
                    void *(*start_routine)(void *), void *arg)
{
  int err;
  int retry = 10;
  while (1) {
    int tmp_1;
    int tmp;
    tmp = pthread_create(thread,attr,start_routine,arg);
    if (tmp) {
      int tmp_0;
      tmp_0 = retry;
      retry --;
      ;
      if (tmp_0) tmp_1 = 1; else tmp_1 = 0;
    }
    else tmp_1 = 0;
    err = tmp_1;
    if (! err) break;
    sched_yield();
  }
  return err;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_1(FILE * __restrict __stream, char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: param0);
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), param0;
 */
int fprintf_va_2(FILE * __restrict __stream,
                 char const * __restrict __format, int param0);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_3(FILE * __restrict __stream, char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_4(FILE * __restrict __stream, char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_5(FILE * __restrict __stream, char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_6(FILE * __restrict __stream, char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_7(FILE * __restrict __stream,
                 char const * __restrict __format, char *param0);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_8(FILE * __restrict __stream, char const * __restrict __format);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_2(char const * __restrict __format, int param0);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_9(FILE * __restrict __stream, char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_10(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_11(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_12(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_13(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_3(char const * __restrict __format, int param0);

int main(int argc, char **argv)
{
  int __retres;
  int c;
  struct stat sbuf;
  pthread_t tid;
  work_t *work;
  long max_open_files = 0l;
  long ncpus = 0l;
  char *e = (char *)0;
  char *d = (char *)0;
  int debug_file = 0;
  int err = 0;
  int i = 0;
  int pm_file_len = 0;
  int restart_cnt = 10;
  flags = (unsigned int)0x00200;
  while (1) {
    c = getopt(argc,(char * const *)argv,"d:e:bchilnsvwruf:p:BCSZzHP:");
    if (! (c != -1)) break;
    switch (c) {
      void *tmp_1;
      size_t tmp_0;
      char *tmp;
      size_t tmp_2;
      case 'B': flags |= (unsigned int)0x01000;
      e = getenv("TGLIMIT");
      if (e) tglimit = atoi((char const *)e);
      else {
        if (! (flags & (unsigned int)0x00040)) fprintf(stderr,
                                                       "env TGLIMIT not set, overriding -B\n"); /* fprintf_va_1 */
        flags &= (unsigned int)(~ 0x01000);
      }
      break;
      case 'p': flags |= (unsigned int)0x02000;
      strcpy(file_pat,(char const *)optarg);
      pm_file_pat = makepat(file_pat,(char *)0);
      break;
      case 'P': flags |= (unsigned int)0x20000;
      progress_offset = atoi((char const *)optarg);
      break;
      case 'S': flags |= (unsigned int)0x08000;
      break;
      case 'b': flags |= (unsigned int)0x00001;
      break;
      case 'c': flags |= (unsigned int)0x00002;
      break;
      case 'h': flags |= (unsigned int)0x00004;
      break;
      case 'i': flags |= (unsigned int)0x00008;
      break;
      case 'l': flags |= (unsigned int)0x00010;
      break;
      case 'n': flags |= (unsigned int)0x00020;
      break;
      case 's': flags |= (unsigned int)0x00040;
      break;
      case 'v': flags |= (unsigned int)0x00080;
      break;
      case 'w': flags |= (unsigned int)0x00100;
      break;
      case 'r': flags &= (unsigned int)(~ 0x00200);
      break;
      case 'C': flags |= (unsigned int)0x10000;
      break;
      case 'e': ;
      if (regexp_cnt == 10) {
        fprintf(stderr,"Max number of regexp\'s (%d) exceeded!\n",10); /* fprintf_va_2 */
        exit(1);
      }
      flags |= (unsigned int)0x04000;
      tmp_0 = strlen((char const *)optarg);
      tmp_1 = malloc(tmp_0 + (size_t)1);
      tmp = (char *)tmp_1;
      string[regexp_cnt] = tmp;
      if (tmp == (char *)0) {
        fprintf(stderr,"tgrep: No space for search string(s)\n"); /* fprintf_va_3 */
        exit(1);
      }
      tmp_2 = strlen((char const *)optarg);
      ;
      memset((void *)string[regexp_cnt],0,tmp_2 + (size_t)1);
      strcpy(string[regexp_cnt],(char const *)optarg);
      regexp_cnt ++;
      break;
      case 'z': case 'Z': regexp_usage();
      break;
      case 'H': case '?': default: usage();
    }
  }
  if (flags & (unsigned int)0x08000) st_start = time((time_t *)0);
  if (! (flags & (unsigned int)0x04000)) {
    void *tmp_4;
    size_t tmp_3;
    size_t tmp_5;
    if (argc - optind < 1) {
      fprintf(stderr,
              "tgrep: Must supply a search string(s) and file list or directory\n"); /* fprintf_va_4 */
      usage();
    }
    tmp_3 = strlen((char const *)*(argv + optind));
    tmp_4 = malloc(tmp_3 + (size_t)1);
    string[0] = (char *)tmp_4;
    if (string[0] == (char *)0) {
      fprintf(stderr,"tgrep: No space for search string(s)\n"); /* fprintf_va_5 */
      exit(1);
    }
    tmp_5 = strlen((char const *)*(argv + optind));
    ;
    memset((void *)string[0],0,tmp_5 + (size_t)1);
    strcpy(string[0],(char const *)*(argv + optind));
    regexp_cnt = 1;
    optind ++;
  }
  if (flags & (unsigned int)0x00008) {
    i = 0;
    while (i < regexp_cnt) {
      uncase(string[i]);
      i ++;
    }
  }
  if (flags & (unsigned int)0x04000) {
    i = 0;
    while (i < regexp_cnt) {
      pm_pat[i] = makepat(string[i],(char *)0);
      i ++;
    }
    use_pmatch = 1;
  }
  else bm_pat = bm_makepat(string[0]);
  flags |= (unsigned int)0x00800;
  max_open_files = sysconf(_SC_OPEN_MAX);
  ncpus = sysconf(_SC_NPROCESSORS_ONLN);
  if ((max_open_files - (long)6) - (long)debug_file < (long)1) {
    fprintf(stderr,
            "tgrep: You MUST have at lest ONE fd that can be used, check limit (>10)\n"); /* fprintf_va_6 */
    exit(1);
  }
  search_thr_limit = (int)((max_open_files - (long)6) - (long)debug_file);
  cascade_thr_limit = search_thr_limit / 2;
  current_open_files = search_thr_limit;
  pthread_attr_init(& detached_attr);
  pthread_attr_setdetachstate(& detached_attr,PTHREAD_CREATE_DETACHED);
  pthread_mutex_init(& global_count_lk,(pthread_mutexattr_t const *)0);
  pthread_mutex_init(& output_print_lk,(pthread_mutexattr_t const *)0);
  pthread_mutex_init(& work_q_lk,(pthread_mutexattr_t const *)0);
  pthread_mutex_init(& running_lk,(pthread_mutexattr_t const *)0);
  pthread_cond_init(& work_q_cv,(pthread_condattr_t const *)0);
  pthread_mutex_init(& search_q_lk,(pthread_mutexattr_t const *)0);
  pthread_cond_init(& search_q_cv,(pthread_condattr_t const *)0);
  pthread_mutex_init(& cascade_q_lk,(pthread_mutexattr_t const *)0);
  pthread_cond_init(& cascade_q_cv,(pthread_condattr_t const *)0);
  if (argc == optind)
    if (flags & (unsigned int)0x02000) goto _LOR;
    else
      if (flags & (unsigned int)0x00200) {
        _LOR:
        {
          add_work((char *)".",2);
          flags &= (unsigned int)(~ 0x00800);
        }
      }
  while (optind < argc) {
    {
      int st;
      restart_cnt = 10;
      flags &= (unsigned int)(~ 0x00800);
      while (1) {
        st = stat((char const *)*(argv + optind),& sbuf);
        if (! st) break;
        {
          int *tmp_6;
          tmp_6 = __errno_location();
          ;
          if (*tmp_6 == 4) {
            restart_cnt --;
            if (restart_cnt) continue;
          }
          if (! (flags & (unsigned int)0x00040)) break;
        }
      }
      if (st) goto __Cont;
      switch (sbuf.st_mode & (unsigned int)0170000) {
        case (unsigned int)0100000: ;
        if (flags & (unsigned int)0x02000) {
          pmatch(pm_file_pat,*(argv + optind),& pm_file_len);
          add_work(*(argv + optind),1);
        }
        else add_work(*(argv + optind),1);
        break;
        case (unsigned int)0040000: ;
        if (flags & (unsigned int)0x00200) add_work(*(argv + optind),2);
        else
          if (! (flags & (unsigned int)0x00040)) fprintf(stderr,
                                                         "tgrep: Can\'t search directory %s, -r option is on. Directory ignored.\n",
                                                         *(argv + optind)); /* fprintf_va_7 */
        break;
      }
    }
    __Cont: optind ++;
  }
  pthread_setconcurrency_np(3);
  if (flags & (unsigned int)0x00800) {
    fprintf(stderr,"tgrep: stdin option is not coded at this time\n"); /* fprintf_va_8 */
    exit(0);
    search_thr((void *)0);
    if (flags & (unsigned int)0x00002) {
      pthread_mutex_lock(& global_count_lk);
      printf("%d\n",global_count); /* printf_va_2 */
      pthread_mutex_unlock(& global_count_lk);
    }
    if (flags & (unsigned int)0x08000) prnt_stats();
    exit(0);
  }
  pthread_mutex_lock(& work_q_lk);
  if (! work_q) {
    if (! (flags & (unsigned int)0x00040)) fprintf(stderr,
                                                   "tgrep: No files to search.\n"); /* fprintf_va_9 */
    exit(0);
  }
  pthread_mutex_unlock(& work_q_lk);
  while (1) {
    pthread_mutex_lock(& work_q_lk);
    while (1) {
      if (work_q == (work_t *)0) goto _LOR_0;
      else
        if (current_open_files == 0) goto _LOR_0;
        else
          if (tglimit <= 0) {
            _LOR_0: ;
            if (! (all_done == 0)) break;
          }
          else break;
      if (flags & (unsigned int)0x08000) {
        pthread_mutex_lock(& stat_lk);
        if (work_q == (work_t *)0) st_worknull ++;
        if (current_open_files == 0) st_workfds ++;
        if (tglimit <= 0) st_worklimit ++;
        pthread_mutex_unlock(& stat_lk);
      }
      pthread_cond_wait(& work_q_cv,& work_q_lk);
    }
    if (all_done != 0) {
      pthread_mutex_unlock(& work_q_lk);
      goto OUT;
    }
    work = work_q;
    work_q = work->next;
    work->next = (struct work_st *)0;
    current_open_files --;
    pthread_mutex_unlock(& work_q_lk);
    tid = (unsigned long)0;
    switch (work->tp) {
      case 2: pthread_mutex_lock(& cascade_q_lk);
      if (cascade_pool_cnt) {
        if (flags & (unsigned int)0x08000) {
          pthread_mutex_lock(& stat_lk);
          st_cascade_pool ++;
          pthread_mutex_unlock(& stat_lk);
        }
        work->next = cascade_q;
        cascade_q = work;
        pthread_cond_signal(& cascade_q_cv);
        pthread_mutex_unlock(& cascade_q_lk);
      }
      else {
        pthread_mutex_unlock(& cascade_q_lk);
        err = pthread_create0(& tid,
                              (pthread_attr_t const *)(& detached_attr),
                              & cascade,(void *)work);
        if (flags & (unsigned int)0x08000) {
          pthread_mutex_lock(& stat_lk);
          st_cascade ++;
          pthread_mutex_unlock(& stat_lk);
        }
      }
      break;
      case 1: pthread_mutex_lock(& search_q_lk);
      if (search_pool_cnt) {
        if (flags & (unsigned int)0x08000) {
          pthread_mutex_lock(& stat_lk);
          st_pool ++;
          pthread_mutex_unlock(& stat_lk);
        }
        work->next = search_q;
        search_q = work;
        pthread_cond_signal(& search_q_cv);
        pthread_mutex_unlock(& search_q_lk);
      }
      else {
        int tmp_7;
        pthread_mutex_unlock(& search_q_lk);
        err = pthread_create0(& tid,
                              (pthread_attr_t const *)(& detached_attr),
                              & search_thr,(void *)work);
        tmp_7 = pthread_getconcurrency_np();
        pthread_setconcurrency_np(tmp_7 + 1);
        if (flags & (unsigned int)0x08000) {
          pthread_mutex_lock(& stat_lk);
          st_search ++;
          pthread_mutex_unlock(& stat_lk);
        }
      }
      break;
      default:
      fprintf(stderr,"tgrep: Internal error, work_t->tp no valid\n"); /* fprintf_va_10 */
      exit(1);
    }
    if (err) {
      prnt_stats();
      fprintf(stderr,"Cound not create new thread!\n"); /* fprintf_va_11 */
      exit(1);
    }
  }
  OUT: ;
  if (flags & (unsigned int)0x20000)
    if (progress) fprintf(stderr,".\n"); /* fprintf_va_12 */
    else fprintf(stderr,"\n"); /* fprintf_va_13 */
  if (flags & (unsigned int)0x00002) {
    pthread_mutex_lock(& global_count_lk);
    printf("%d\n",global_count); /* printf_va_3 */
    pthread_mutex_unlock(& global_count_lk);
  }
  if (flags & (unsigned int)0x08000) prnt_stats();
  __retres = 0;
  return __retres;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_14(FILE * __restrict __stream,
                  char const * __restrict __format, char *param0);

int add_work(char *path, int tp)
{
  int __retres;
  work_t *wt;
  void *tmp_2;
  size_t tmp_1;
  char *tmp_0;
  wt = (work_t *)malloc(sizeof(work_t));
  if (wt == (work_t *)0) goto ERROR;
  tmp_1 = strlen((char const *)path);
  tmp_2 = malloc(tmp_1 + (size_t)1);
  tmp_0 = (char *)tmp_2;
  wt->path = tmp_0;
  if (tmp_0 == (char *)0) goto ERROR;
  strcpy(wt->path,(char const *)path);
  wt->tp = tp;
  wt->next = (struct work_st *)0;
  if (flags & (unsigned int)0x08000) {
    pthread_mutex_lock(& stat_lk);
    if (wt->tp == 2) st_dir_search ++; else st_file_search ++;
    pthread_mutex_unlock(& stat_lk);
  }
  pthread_mutex_lock(& work_q_lk);
  work_cnt ++;
  wt->next = work_q;
  work_q = wt;
  pthread_cond_signal(& work_q_cv);
  pthread_mutex_unlock(& work_q_lk);
  __retres = 0;
  goto return_label;
  ERROR:
  if (! (flags & (unsigned int)0x00040)) fprintf(stderr,
                                                 "tgrep: Could not add %s to work queue. Ignored\n",
                                                 path); /* fprintf_va_14 */
  __retres = -1;
  return_label: return __retres;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_15(FILE * __restrict __stream,
                  char const * __restrict __format, char *param0,
                  char *param1);

void *search_thr(void *arg)
{
  void *__retres;
  char fin_buf[8192 * 4];
  work_t std;
  FILE *fin = (FILE *)0;
  work_t *wt = (work_t *)0;
  int line_count = 0;
  char rline[128] = {(char)'\000'};
  char cline[128] = {(char)'\000'};
  char *line = (char *)0;
  int pm_len = 0;
  long byte_count = (long)0;
  long next_line = (long)0;
  int show_line = 0;
  register int slen = 0;
  register int i = 0;
  out_t *out = (out_t *)0;
  pthread_yield_np();
  wt = (work_t *)arg;
  while (1) {
    {
      char *iter_line;
      line_count = 0;
      byte_count = 0l;
      next_line = 0l;
      show_line = 0;
      pthread_mutex_lock(& running_lk);
      running ++;
      pthread_mutex_unlock(& running_lk);
      pthread_mutex_lock(& work_q_lk);
      tglimit --;
      pthread_mutex_unlock(& work_q_lk);
      fin = fopen((char const *)wt->path,"r");
      if (fin == (FILE *)0) {
        if (! (flags & (unsigned int)0x00040)) {
          char *tmp_0;
          int *tmp;
          ;
          tmp = __errno_location();
          tmp_0 = strerror(*tmp);
          ;
          fprintf(stderr,"tgrep: %s. File \"%s\" not searched.\n",tmp_0,
                  wt->path); /* fprintf_va_15 */
        }
        goto ERROR;
      }
      setvbuf(fin,fin_buf,0,(unsigned long)(8192 * 4));
      while (1) {
        char *tmp_4;
        tmp_4 = fgets(rline,127,fin);
        if (! (tmp_4 != (char *)0)) break;
        {
          size_t tmp_1;
          if (flags & (unsigned int)0x08000) {
            pthread_mutex_lock(& stat_lk);
            st_line_search ++;
            pthread_mutex_unlock(& stat_lk);
          }
          iter_line = rline;
          while (1) {
            if ((int)*iter_line >= 32)
              if ((int)*iter_line <= 126) {
                if (! (iter_line - rline < (long)127)) break;
              }
              else break;
            else break;
            iter_line ++;
          }
          *iter_line = (char)'\000';
          tmp_1 = strlen((char const *)(rline));
          slen = (int)tmp_1;
          next_line += (long)slen;
          line_count ++;
          if ((int)rline[slen - 1] == '\n') rline[slen - 1] = (char)'\000';
          if (flags & (unsigned int)0x00008) {
            strcpy(cline,(char const *)(rline));
            uncase(cline);
            line = cline;
          }
          else line = rline;
          show_line = 1;
          if (use_pmatch) {
            i = 0;
            while (i < regexp_cnt) {
              {
                char *tmp_2;
                tmp_2 = pmatch(pm_pat[i],line,& pm_len);
                if (tmp_2) {
                  if (! (flags & (unsigned int)0x00080)) {
                    add_output_local(& out,wt,line_count,byte_count,rline);
                    continue_line(rline,fin,out,wt,& line_count,& byte_count);
                  }
                  else show_line = 0;
                  if (flags & (unsigned int)0x00010) goto OUT_OF_LOOP;
                  else goto OUT_AND_DONE;
                }
              }
              i ++;
            }
          }
          else {
            char *tmp_3;
            tmp_3 = bm_pmatch(bm_pat,line);
            if (tmp_3) {
              if (! (flags & (unsigned int)0x00080)) {
                add_output_local(& out,wt,line_count,byte_count,rline);
                continue_line(rline,fin,out,wt,& line_count,& byte_count);
              }
              else show_line = 0;
              if (flags & (unsigned int)0x00010) goto OUT_OF_LOOP;
            }
          }
          OUT_AND_DONE: ;
          if (flags & (unsigned int)0x00080)
            if (show_line) {
              add_output_local(& out,wt,line_count,byte_count,rline);
              show_line = 0;
            }
          byte_count = next_line;
        }
      }
      OUT_OF_LOOP: fclose(fin);
      print_local_output(out,wt);
      out = (out_t *)0;
      ERROR: ;
      free((void *)wt->path);
      free((void *)wt);
      notrun();
      pthread_mutex_lock(& search_q_lk);
      if (search_pool_cnt > search_thr_limit) {
        pthread_mutex_unlock(& search_q_lk);
        if (flags & (unsigned int)0x08000) {
          pthread_mutex_lock(& stat_lk);
          st_destroy ++;
          pthread_mutex_unlock(& stat_lk);
        }
        break;
      }
      else {
        search_pool_cnt ++;
        while (! search_q) pthread_cond_wait(& search_q_cv,& search_q_lk);
        search_pool_cnt --;
        wt = search_q;
        if (search_q->next) search_q = search_q->next;
        else search_q = (work_t *)0;
        pthread_mutex_unlock(& search_q_lk);
      }
    }
  }
  __retres = (void *)0;
  return __retres;
}

int continue_line(char *rline, FILE *fin, out_t *out, work_t *wt, int *lc,
                  long *bc)
{
  int __retres;
  int len;
  char *line;
  char nline[128];
  int cnt = 0;
  if (! (flags & (unsigned int)0x10000)) {
    __retres = 0;
    goto return_label;
  }
  line = rline;
  while (1) {
    {
      size_t tmp;
      tmp = strlen((char const *)line);
      len = (int)tmp;
      if ((int)*(line + (len - 1)) == '\\') {
        char *tmp_0;
        size_t tmp_1;
        int *tmp_2;
        tmp_0 = fgets(nline,127,fin);
        if (tmp_0 == (char *)0) {
          __retres = cnt;
          goto return_label;
        }
        line = nline;
        tmp_1 = strlen((char const *)line);
        len = (int)tmp_1;
        if ((int)*(line + (len - 1)) == '\n') *(line + (len - 1)) = (char)'\000';
        *bc += (long)len;
        tmp_2 = lc;
        lc ++;
        ;
        add_output_local(& out,wt,*lc,*bc,line);
        cnt ++;
        continue;
      }
      break;
    }
  }
  __retres = cnt;
  return_label: return __retres;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_16(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_17(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_18(FILE * __restrict __stream,
                  char const * __restrict __format, char *param0,
                  char *param1);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_19(FILE * __restrict __stream,
                  char const * __restrict __format, char *param0,
                  char *param1);

void *cascade(void *arg)
{
  void *__retres;
  char fullpath[1025];
  DIR *dp;
  char dir_buf[sizeof(struct dirent) + (unsigned long)4096];
  struct stat sbuf;
  char *fpath;
  work_t *wt;
  int restart_cnt = 10;
  struct dirent *dent = (struct dirent *)(dir_buf);
  struct dirent *result = (struct dirent *)0;
  int fl = 0;
  int dl = 0;
  int pm_file_len = 0;
  pthread_yield_np();
  wt = (work_t *)arg;
  while (1) {
    fl = 0;
    dl = 0;
    restart_cnt = 10;
    pm_file_len = 0;
    pthread_mutex_lock(& running_lk);
    running ++;
    pthread_mutex_unlock(& running_lk);
    pthread_mutex_lock(& work_q_lk);
    tglimit --;
    pthread_mutex_unlock(& work_q_lk);
    if (! wt) {
      if (! (flags & (unsigned int)0x00040)) fprintf(stderr,
                                                     "tgrep: Bad work node passed to cascade\n"); /* fprintf_va_16 */
      goto DONE;
    }
    fpath = wt->path;
    if (! fpath) {
      if (! (flags & (unsigned int)0x00040)) fprintf(stderr,
                                                     "tgrep: Bad path name passed to cascade\n"); /* fprintf_va_17 */
      goto DONE;
    }
    dp = opendir((char const *)fpath);
    if (dp == (DIR *)0) {
      if (! (flags & (unsigned int)0x00040)) {
        char *tmp_0;
        int *tmp;
        tmp = __errno_location();
        tmp_0 = strerror(*tmp);
        ;
        ;
        fprintf(stderr,"tgrep: Can\'t open dir %s, %s. Ignored.\n",fpath,
                tmp_0); /* fprintf_va_18 */
      }
      goto DONE;
    }
    while (1) {
      int tmp_6;
      tmp_6 = readdir_r(dp,dent,& result);
      if (tmp_6 == 0) {
        if (! (result != (struct dirent *)0)) break;
      }
      else break;
      {
        size_t tmp_1;
        size_t tmp_2;
        restart_cnt = 10;
        if ((int)dent->d_name[0] == '.') {
          if ((int)dent->d_name[1] == '.')
            if ((int)dent->d_name[2] == '\000') continue;
          if ((int)dent->d_name[1] == '\000') continue;
        }
        tmp_1 = strlen((char const *)fpath);
        fl = (int)tmp_1;
        tmp_2 = strlen((char const *)(dent->d_name));
        dl = (int)tmp_2;
        if ((fl + 1) + dl > 1024) {
          fprintf(stderr,"tgrep: Path %s/%s is too long. MaxPath = 1024\n",
                  fpath,dent->d_name); /* fprintf_va_19 */
          continue;
        }
        strcpy(fullpath,(char const *)fpath);
        strcat(fullpath,"/");
        strcat(fullpath,(char const *)(dent->d_name));
        while (1) {
          int tmp_4;
          tmp_4 = stat((char const *)(fullpath),& sbuf);
          if (! tmp_4) break;
          {
            int *tmp_3;
            tmp_3 = __errno_location();
            ;
            if (*tmp_3 == 4) {
              restart_cnt --;
              if (restart_cnt) continue;
            }
            if (! (flags & (unsigned int)0x00040)) goto ERROR;
          }
        }
        switch (sbuf.st_mode & (unsigned int)0170000) {
          case (unsigned int)0100000: ;
          if (flags & (unsigned int)0x02000) {
            char *tmp_5;
            tmp_5 = pmatch(pm_file_pat,dent->d_name,& pm_file_len);
            if (tmp_5) add_work(fullpath,1);
          }
          else add_work(fullpath,1);
          break;
          case (unsigned int)0040000: ;
          add_work(fullpath,2);
          break;
        }
      }
    }
    ERROR: closedir(dp);
    DONE: free((void *)wt->path);
    free((void *)wt);
    notrun();
    pthread_mutex_lock(& cascade_q_lk);
    if (cascade_pool_cnt > cascade_thr_limit) {
      pthread_mutex_unlock(& cascade_q_lk);
      if (flags & (unsigned int)0x08000) {
        pthread_mutex_lock(& stat_lk);
        st_cascade_destroy ++;
        pthread_mutex_unlock(& stat_lk);
      }
      break;
    }
    else {
      cascade_pool_cnt ++;
      while (! cascade_q) pthread_cond_wait(& cascade_q_cv,& cascade_q_lk);
      cascade_pool_cnt --;
      wt = cascade_q;
      if (cascade_q->next) cascade_q = cascade_q->next;
      else cascade_q = (work_t *)0;
      pthread_mutex_unlock(& cascade_q_lk);
    }
  }
  __retres = (void *)0;
  return __retres;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_20(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: *(param0 + (0 ..)));
 */
int printf_va_4(char const * __restrict __format, char *param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: *(param0 + (0 ..)));
 */
int printf_va_5(char const * __restrict __format, char *param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_6(char const * __restrict __format, long param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_7(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: *(param0 + (0 ..)));
 */
int printf_va_8(char const * __restrict __format, char *param0);

int print_local_output(out_t *out, work_t *wt)
{
  int __retres;
  out_t *pp;
  out_t *op;
  int out_count = 0;
  int printed = 0;
  pp = out;
  pthread_mutex_lock(& output_print_lk);
  if (pp)
    if (flags & (unsigned int)0x20000) {
      progress ++;
      if (progress >= progress_offset) {
        progress = 0;
        fprintf(stderr,"."); /* fprintf_va_20 */
      }
    }
  while (pp) {
    out_count ++;
    if (! (flags & (unsigned int)0x00002))
      if (flags & (unsigned int)0x00010) {
        if (! printed) {
          printed = 1;
          printf("%s\n",wt->path); /* printf_va_4 */
        }
      }
      else {
        if (! (flags & (unsigned int)0x00004)) printf("%s :",wt->path); /* printf_va_5 */
        if (flags & (unsigned int)0x00001) printf("%ld:",
                                                  pp->byte_count / (long)512 + (long)1); /* printf_va_6 */
        if (flags & (unsigned int)0x00020) printf("%d:",pp->line_count); /* printf_va_7 */
        printf("%s\n",pp->line); /* printf_va_8 */
      }
    op = pp;
    pp = pp->next;
    free((void *)op->line);
    free((void *)op);
  }
  pthread_mutex_unlock(& output_print_lk);
  pthread_mutex_lock(& global_count_lk);
  global_count += out_count;
  pthread_mutex_unlock(& global_count_lk);
  __retres = 0;
  return __retres;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: *(param3 + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), *(param3 + (0 ..)),
            param2, param1, *(param0 + (0 ..));
 */
int fprintf_va_21(FILE * __restrict __stream,
                  char const * __restrict __format, char *param0, int param1,
                  int param2, char *param3);

int add_output_local(out_t **out, work_t *wt, int lc, long bc, char *line)
{
  int __retres;
  out_t *ot;
  out_t *oo;
  out_t *op;
  void *tmp_2;
  size_t tmp_1;
  char *tmp_0;
  ot = (out_t *)malloc(sizeof(out_t));
  if (ot == (out_t *)0) goto ERROR;
  tmp_1 = strlen((char const *)line);
  tmp_2 = malloc(tmp_1 + (size_t)1);
  tmp_0 = (char *)tmp_2;
  ot->line = tmp_0;
  if (tmp_0 == (char *)0) goto ERROR;
  strcpy(ot->line,(char const *)line);
  ot->line_count = lc;
  ot->byte_count = bc;
  if (! *out) {
    *out = ot;
    ot->next = (struct out_st *)0;
    __retres = 0;
    goto return_label;
  }
  oo = *out;
  op = oo;
  while (oo) {
    op = oo;
    oo = oo->next;
  }
  op->next = ot;
  ot->next = (struct out_st *)0;
  __retres = 0;
  goto return_label;
  ERROR:
  if (! (flags & (unsigned int)0x00040)) fprintf(stderr,
                                                 "tgrep: Output lost. No space. [%s: line %d byte %d match : %s\n",
                                                 wt->path,lc,(int)bc,line); /* fprintf_va_21 */
  __retres = 1;
  return_label: return __retres;
}

/*@ assigns \result;
    assigns \result \from (indirect: *(__format + (0 ..)));
 */
int printf_va_9(char const * __restrict __format);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_10(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_11(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_12(char const * __restrict __format, double param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_13(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_14(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_15(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_16(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_17(char const * __restrict __format, double param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_18(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_19(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_20(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_21(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_22(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_23(char const * __restrict __format, double param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_24(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_25(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_26(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_27(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_28(char const * __restrict __format, int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: param0);
 */
int printf_va_29(char const * __restrict __format, int param0, int param1,
                 double param2);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param1),
            (indirect: param0);
 */
int printf_va_30(char const * __restrict __format, int param0, double param1);

/*@ assigns \result, *(__s + (0 ..));
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
    assigns *(__s + (0 ..)) \from (indirect: *(__format + (0 ..))), param0;
 */
int sprintf_va_1(char * __restrict __s, char const * __restrict __format,
                 int param0);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
 */
int printf_va_31(char const * __restrict __format, char *param0, int param1,
                 double param2);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(__format + (0 ..))), (indirect: param0);
 */
int printf_va_32(char const * __restrict __format, double param0);

/*@ assigns \result;
    assigns \result \from (indirect: *(__format + (0 ..)));
 */
int printf_va_33(char const * __restrict __format);

void prnt_stats(void)
{
  float a;
  float b;
  float c;
  char tl[80];
  float t = (float)0.0;
  time_t st_end = (long)0;
  st_end = time((time_t *)0);
  printf("\n----------------- Tgrep Stats. --------------------\n"); /* printf_va_9 */
  printf("Number of directories searched:           %d\n",st_dir_search); /* printf_va_10 */
  printf("Number of files searched:                 %d\n",st_file_search); /* printf_va_11 */
  c = (float)(st_dir_search + st_file_search) / (float)(st_end - st_start);
  printf("Dir/files per second:                     %3.2f\n",(double)c); /* printf_va_12 */
  printf("Number of lines searched:                 %d\n",st_line_search); /* printf_va_13 */
  printf("Number of matching lines to target:       %d\n",global_count); /* printf_va_14 */
  printf("Number of cascade threads created:        %d\n",st_cascade); /* printf_va_15 */
  printf("Number of cascade threads from pool:      %d\n",st_cascade_pool); /* printf_va_16 */
  a = (float)st_cascade_pool;
  b = (float)st_dir_search;
  printf("Cascade thread pool hit rate:             %3.2f%%\n",
         (double)((a / b) * (float)100)); /* printf_va_17 */
  printf("Cascade pool overall size:                %d\n",cascade_pool_cnt); /* printf_va_18 */
  printf("Cascade pool size limit:                  %d\n",cascade_thr_limit); /* printf_va_19 */
  printf("Number of cascade threads destroyed:      %d\n",st_cascade_destroy); /* printf_va_20 */
  printf("Number of search threads created:         %d\n",st_search); /* printf_va_21 */
  printf("Number of search threads from pool:       %d\n",st_pool); /* printf_va_22 */
  a = (float)st_pool;
  b = (float)st_file_search;
  printf("Search thread pool hit rate:              %3.2f%%\n",
         (double)((a / b) * (float)100)); /* printf_va_23 */
  printf("Search pool overall size:                 %d\n",search_pool_cnt); /* printf_va_24 */
  printf("Search pool size limit:                   %d\n",search_thr_limit); /* printf_va_25 */
  printf("Number of search threads destroyed:       %d\n",st_destroy); /* printf_va_26 */
  printf("Max # of threads running concurrently:     %d\n",st_maxrun); /* printf_va_27 */
  printf("Total run time, in seconds.               %d\n",
         (int)(st_end - st_start)); /* printf_va_28 */
  a = (float)st_workfds;
  b = (float)(st_dir_search + st_file_search);
  c = (a / b) * (float)100;
  t += c;
  printf("Work stopped due to no FD\'s:  (%.3d)       %d Times, %3.2f%%\n",
         search_thr_limit,st_workfds,(double)c); /* printf_va_29 */
  a = (float)st_worknull;
  b = (float)(st_dir_search + st_file_search);
  c = (a / b) * (float)100;
  t += c;
  printf("Work stopped due to no work on Q:         %d Times, %3.2f%%\n",
         st_worknull,(double)c); /* printf_va_30 */
  if (tglimit == 99999) strcpy(tl,"Unlimited");
  else sprintf(tl,"   %.3d   ",tglimit); /* sprintf_va_1 */
  a = (float)st_worklimit;
  b = (float)(st_dir_search + st_file_search);
  c = (a / b) * (float)100;
  t += c;
  printf("Work stopped due to TGLIMIT:  (%.9s) %d Times, %3.2f%%\n",tl,
         st_worklimit,(double)c); /* printf_va_31 */
  printf("Work continued to be handed out:          %3.2f%%\n",
         100.00 - (double)t); /* printf_va_32 */
  printf("----------------------------------------------------\n"); /* printf_va_33 */
  return;
}

void notrun(void)
{
  pthread_mutex_lock(& work_q_lk);
  work_cnt --;
  tglimit ++;
  current_open_files ++;
  pthread_mutex_lock(& running_lk);
  if (flags & (unsigned int)0x08000) {
    pthread_mutex_lock(& stat_lk);
    if (running > st_maxrun) st_maxrun = running;
    pthread_mutex_unlock(& stat_lk);
  }
  running --;
  if (work_cnt == 0)
    if (running == 0) all_done = 1;
  pthread_mutex_unlock(& running_lk);
  pthread_cond_signal(& work_q_cv);
  pthread_mutex_unlock(& work_q_lk);
  return;
}

void uncase(char *s)
{
  char *p;
  p = s;
  while ((int)*p != '\000') {
    int tmp;
    tmp = tolower((int)*p);
    *p = (char)tmp;
    p ++;
  }
  return;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_22(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_23(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_24(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_25(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_26(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_27(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_28(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_29(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_30(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_31(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_32(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_33(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_34(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_35(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_36(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_37(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_38(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_39(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_40(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_41(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_42(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_43(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_44(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_45(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_46(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_47(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_48(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_49(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_50(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_51(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_52(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_53(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_54(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_55(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_56(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_57(FILE * __restrict __stream,
                  char const * __restrict __format, char *param0);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_58(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_59(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_60(FILE * __restrict __stream,
                  char const * __restrict __format);

void usage(void)
{
  fprintf(stderr,"usage: tgrep <options> pattern <{file,dir}>...\n"); /* fprintf_va_22 */
  fprintf(stderr,"\n"); /* fprintf_va_23 */
  fprintf(stderr,"Where:\n"); /* fprintf_va_24 */
  fprintf(stderr,"          -b = show block count (512 byte block)\n"); /* fprintf_va_25 */
  fprintf(stderr,"          -c = print only a line count\n"); /* fprintf_va_26 */
  fprintf(stderr,"          -h = Do NOT print file names\n"); /* fprintf_va_27 */
  fprintf(stderr,"          -i = case insensitive\n"); /* fprintf_va_28 */
  fprintf(stderr,"          -l = print file name only\n"); /* fprintf_va_29 */
  fprintf(stderr,"          -n = print the line number with the line\n"); /* fprintf_va_30 */
  fprintf(stderr,"          -s = Suppress error messages\n"); /* fprintf_va_31 */
  fprintf(stderr,"          -v = print all but matching lines\n"); /* fprintf_va_32 */
  fprintf(stderr,
          "          -r = Do not search for files in all sub-directories\n"); /* fprintf_va_33 */
  fprintf(stderr,"          -C = show continued lines (\"\\\")\n"); /* fprintf_va_34 */
  fprintf(stderr,"          -p = File name regexp pattern. (Quote it)\n"); /* fprintf_va_35 */
  fprintf(stderr,
          "          -P = show progress. -P 1 prints a DOT on stderr\n               for each file it finds, -P 10 prints a DOT\n               on stderr for each 10 files it finds, etc...\n"); /* fprintf_va_36 */
  fprintf(stderr,"          -e = expression search.(regexp) More then one\n"); /* fprintf_va_37 */
  fprintf(stderr,"          -B = limit the number of threads to TGLIMIT\n"); /* fprintf_va_38 */
  fprintf(stderr,"          -S = Print thread stats when done.\n"); /* fprintf_va_39 */
  fprintf(stderr,"          -Z = Print help on the regexp used.\n"); /* fprintf_va_40 */
  fprintf(stderr,"\n"); /* fprintf_va_41 */
  fprintf(stderr,"Notes:\n"); /* fprintf_va_42 */
  fprintf(stderr,"      If you start tgrep with only a directory name\n"); /* fprintf_va_43 */
  fprintf(stderr,
          "      and no file names, you must not have the -r option\n"); /* fprintf_va_44 */
  fprintf(stderr,"      set or you will get no output.\n"); /* fprintf_va_45 */
  fprintf(stderr,"      To search stdin (piped input), you must set -r\n"); /* fprintf_va_46 */
  fprintf(stderr,"      Tgrep will search ALL files in ALL \n"); /* fprintf_va_47 */
  fprintf(stderr,"      sub-directories. (like */* */*/* */*/*/* etc..)\n"); /* fprintf_va_48 */
  fprintf(stderr,"      if you supply a directory name.\n"); /* fprintf_va_49 */
  fprintf(stderr,"      If you do not supply a file, or directory name,\n"); /* fprintf_va_50 */
  fprintf(stderr,"      and the -r option is not set, the current \n"); /* fprintf_va_51 */
  fprintf(stderr,"      directory \".\" will be used.\n"); /* fprintf_va_52 */
  fprintf(stderr,"      All the other options should work \"like\" grep\n"); /* fprintf_va_53 */
  fprintf(stderr,"      The -p patten is regexp, tgrep will search only\n"); /* fprintf_va_54 */
  fprintf(stderr,"      the file names that match the patten\n"); /* fprintf_va_55 */
  fprintf(stderr,"\n"); /* fprintf_va_56 */
  fprintf(stderr,"      Tgrep Version %s\n",(char *)Tgrep_Version); /* fprintf_va_57 */
  fprintf(stderr,"\n"); /* fprintf_va_58 */
  fprintf(stderr,"      Copy Right By Ron Winacott, 1993-1995.\n"); /* fprintf_va_59 */
  fprintf(stderr,"\n"); /* fprintf_va_60 */
  exit(0);
  return;
}

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_61(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_62(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_63(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_64(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_65(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_66(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_67(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_68(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_69(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_70(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_71(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_72(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_73(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_74(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_75(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_76(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_77(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_78(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_79(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_80(FILE * __restrict __stream,
                  char const * __restrict __format);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..))),
            (indirect: param0);
    assigns *__stream
      \from *__stream, (indirect: *(__format + (0 ..))), param0;
 */
int fprintf_va_81(FILE * __restrict __stream,
                  char const * __restrict __format, int param0);

/*@ assigns \result, *__stream;
    assigns \result
      \from (indirect: *__stream), (indirect: *(__format + (0 ..)));
    assigns *__stream \from *__stream, (indirect: *(__format + (0 ..)));
 */
int fprintf_va_82(FILE * __restrict __stream,
                  char const * __restrict __format);

int regexp_usage(void)
{
  int __retres;
  fprintf(stderr,
          "usage: tgrep <options> -e \"pattern\" <-e ...> <{file,dir}>...\n"); /* fprintf_va_61 */
  fprintf(stderr,"\n"); /* fprintf_va_62 */
  fprintf(stderr,"metachars:\n"); /* fprintf_va_63 */
  fprintf(stderr,"    . - match any character\n"); /* fprintf_va_64 */
  fprintf(stderr,"    * - match 0 or more occurrences of pervious char\n"); /* fprintf_va_65 */
  fprintf(stderr,"    + - match 1 or more occurrences of pervious char.\n"); /* fprintf_va_66 */
  fprintf(stderr,"    ^ - match at begining of string\n"); /* fprintf_va_67 */
  fprintf(stderr,"    $ - match end of string\n"); /* fprintf_va_68 */
  fprintf(stderr,"    [ - start of character class\n"); /* fprintf_va_69 */
  fprintf(stderr,"    ] - end of character class\n"); /* fprintf_va_70 */
  fprintf(stderr,"    ( - start of a new pattern\n"); /* fprintf_va_71 */
  fprintf(stderr,"    ) - end of a new pattern\n"); /* fprintf_va_72 */
  fprintf(stderr,"    @(n)c - match <c> at column <n>\n"); /* fprintf_va_73 */
  fprintf(stderr,"    | - match either pattern\n"); /* fprintf_va_74 */
  fprintf(stderr,"    \\ - escape any special characters\n"); /* fprintf_va_75 */
  fprintf(stderr,"    \\c - escape any special characters\n"); /* fprintf_va_76 */
  fprintf(stderr,"    \\o - turn on any special characters\n"); /* fprintf_va_77 */
  fprintf(stderr,"\n"); /* fprintf_va_78 */
  fprintf(stderr,"To match two diffrerent patterns in the same command\n"); /* fprintf_va_79 */
  fprintf(stderr,
          "Use the or function. \nie: tgrep -e \"(pat1)|(pat2)\" file\nThis will match any line with \"pat1\" or \"pat2\" in it.\n"); /* fprintf_va_80 */
  fprintf(stderr,"You can also use up to %d -e expresions\n",10); /* fprintf_va_81 */
  fprintf(stderr,"RegExp Pattern matching brought to you by Marc Staveley\n"); /* fprintf_va_82 */
  exit(0);
  return __retres;
}

void pthread_setconcurrency_np(int con)
{
  return;
}

int pthread_getconcurrency_np(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

void pthread_yield_np(void)
{
  return;
}


