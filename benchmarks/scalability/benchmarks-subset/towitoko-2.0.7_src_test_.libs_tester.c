// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#}$SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#$'atr'||S32'convention'||U32'$pad0'||U64'baudrate'||SYM#tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]#'timings'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#}$SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#$'atr'||S32'convention'||U32'$pad0'||U64'baudrate'||SYM#tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]#'timings'|]#$'icc'||*{V}$V$'protocol'||SYM#tag-#anon#ST[F64'f'||F64'd'||F64'n'||U8't'||U56'$pad0'|]#'parameters'|]
// file pps.h line 51
struct anonymous$0;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#}$SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#$'atr'||S32'convention'||U32'$pad0'||U64'baudrate'||SYM#tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]#'timings'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#}$SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#$'atr'||S32'convention'||U32'$pad0'||U64'baudrate'||SYM#tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]#'timings'|]#$'icc'||U16'ifsc'||U16'ifsd'||U16'bgt'||U16'bwt'||U16'cwt'||U16'$pad0'||S32'edc'||U8'ns'||U56'$pad1'|]
// file protocol_t1.h line 46
struct anonymous$18;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#}$SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#$'atr'||S32'convention'||U32'$pad0'||U64'baudrate'||SYM#tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]#'timings'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#}$SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#$'atr'||S32'convention'||U32'$pad0'||U64'baudrate'||SYM#tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]#'timings'|]#$'icc'||U64'wwt'|]
// file protocol_t0.h line 47
struct anonymous$11;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U8'H1'||U8'H2'||U8'H3'||U8'H4'|]#}$SYM#tag-#anon#ST[U8'H1'||U8'H2'||U8'H3'||U8'H4'|]#$'atr'||S32'type'||U32'length'||U8'pagemode'||ARR3{U8}$U8$'pin'||S32'pin_ok'||S32'pin_needed'||S32'active'||U64'baudrate'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U8'H1'||U8'H2'||U8'H3'||U8'H4'|]#}$SYM#tag-#anon#ST[U8'H1'||U8'H2'||U8'H3'||U8'H4'|]#$'atr'||S32'type'||U32'length'||U8'pagemode'||ARR3{U8}$U8$'pin'||S32'pin_ok'||S32'pin_needed'||S32'active'||U64'baudrate'|]#$'icc'||U32'path'||U32'length'|]
// file protocol_sync.h line 44
struct anonymous;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#}$SYM#tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]#$'atr'||S32'convention'||U32'$pad0'||U64'baudrate'||SYM#tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]#'timings'|]
// file icc_async.h line 52
struct anonymous$5;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{SYM#tag-#anon#ST[U8'H1'||U8'H2'||U8'H3'||U8'H4'|]#}$SYM#tag-#anon#ST[U8'H1'||U8'H2'||U8'H3'||U8'H4'|]#$'atr'||S32'type'||U32'length'||U8'pagemode'||ARR3{U8}$U8$'pin'||S32'pin_ok'||S32'pin_needed'||S32'active'||U64'baudrate'|]
// file icc_sync.h line 56
struct anonymous$22;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{V}$V$'icc'||*{V}$V$'protocol'||S32'icc_type'||S32'protocol_type'|]
// file ct_slot.h line 48
struct anonymous$2;

// tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||ARR2{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{V}$V$'icc'||*{V}$V$'protocol'||S32'icc_type'||S32'protocol_type'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{V}$V$'icc'||*{V}$V$'protocol'||S32'icc_type'||S32'protocol_type'|]#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{V}$V$'icc'||*{V}$V$'protocol'||S32'icc_type'||S32'protocol_type'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]#$'ifd'||*{V}$V$'icc'||*{V}$V$'protocol'||S32'icc_type'||S32'protocol_type'|]#$$'slots'||S32'num_slots'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mutex'|]
// file cardterminal.h line 47
struct anonymous$3;

// tag-#anon#ST[*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]#$'io'||U8'slot'||U8'type'||U8'firmware'||U40'$pad0'|]
// file ifd_towitoko.h line 99
struct anonymous$6;

// tag-#anon#ST[*{SYM#tag-CT_List_Node#}$SYM#tag-CT_List_Node#$'first'||*{SYM#tag-CT_List_Node#}$SYM#tag-CT_List_Node#$'last'||S32'elements'||U32'$pad0'|]
// file ct_list.h line 42
struct anonymous$21;

// tag-#anon#ST[*{U8}$U8$'command'||U64'length'|]
// file apdu.h line 59
struct anonymous$13;

// tag-#anon#ST[*{U8}$U8$'data'||U32'length'||U32'$pad0'|]
// file t1_block.h line 55
struct anonymous$15;

// tag-#anon#ST[*{U8}$U8$'response'||U64'length'|]
// file apdu.h line 67
struct anonymous$14;

// tag-#anon#ST[*{V}$V$'data'||U16'data_length'||U48'$pad0'||*{S32(*{V}$V$|U16|U16|*{U8}$U8$)->S32}$S32(*{V}$V$|U16|U16|*{U8}$U8$)->S32$'get_data'||U16'address'||U16'tag'||U16'length'||U16'value'|]
// file tlv_object.h line 69
struct anonymous$23;

// tag-#anon#ST[F64'f'||F64'd'||F64'n'||U8't'||U56'$pad0'|]
// file pps.h line 42
struct anonymous$12;

// tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]#$'props'||U32'com'||ARR256{U8}$U8$'PnP_id'||U32'PnP_id_size'||S32'usbserial'||U32'$pad1'|]
// file io_serial.h line 62
struct anonymous$9;

// tag-#anon#ST[SYM#tag-_DEVICE_CAPABILITIES#'device_capabilities'||SYM#tag-_ICC_STATE#'icc_state'||SYM#tag-_PROTOCOL_OPTIONS#'protocol_options'|]
// file ifdhandler.c line 57
struct anonymous$8;

// tag-#anon#ST[U16'pn'||ARR16{S8}$S8$'port'||U16'$pad0'||S32'status'||ARR33{U8}$U8$'atr'||U8'$pad1'||U16'atr_size'||U8'cla'||U24'$pad2'||U64'thread'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mutex'|]
// file tester.c line 51
struct anonymous$20;

// tag-#anon#ST[U32'block_delay'||U32'char_delay'||U32'block_timeout'||U32'char_timeout'|]
// file ifd_towitoko.h line 89
struct anonymous$4;

// tag-#anon#ST[U32'length'||U8'TS'||U8'T0'||U16'$pad0'||ARR7{ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$}$ARR4{SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#}$SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#$$'ib'||SYM#tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]#'TCK'||U32'pn'||ARR15{U8}$U8$'hb'||U8'$pad1'||U32'hbn'|]
// file atr.h line 78
struct anonymous$7;

// tag-#anon#ST[U64'input_bitrate'||U64'output_bitrate'||U32'bits'||U32'stopbits'||S32'parity'||S32'dtr'||S32'rts'||U32'$pad0'|]
// file io_serial.h line 49
struct anonymous$10;

// tag-#anon#ST[U8'H1'||U8'H2'||U8'H3'||U8'H4'|]
// file atr_sync.h line 69
struct anonymous$19;

// tag-#anon#ST[U8'value'||U24'$pad0'||S32'present'|]
// file atr.h line 83
struct anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$17;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$16;

// tag-CT_List_Node
// file ct_list.h line 34
struct CT_List_Node;

// tag-_DEVICE_CAPABILITIES
// file ifdhandler.h line 21
struct _DEVICE_CAPABILITIES;

// tag-_ICC_STATE
// file ifdhandler.h line 44
struct _ICC_STATE;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PROTOCOL_OPTIONS
// file ifdhandler.h line 54
struct _PROTOCOL_OPTIONS;

// tag-_SCARD_IO_HEADER
// file ifdhandler.h line 69
struct _SCARD_IO_HEADER;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

#ifndef NULL
#define NULL ((void*)0)
#endif

// APDU_Cmd_Case
// file apdu.h line 85
extern signed int APDU_Cmd_Case(struct anonymous$13 *apdu);
// APDU_Cmd_Cla
// file apdu.h line 88
extern unsigned char APDU_Cmd_Cla(struct anonymous$13 *apdu);
// APDU_Cmd_Data
// file apdu.h line 112
extern unsigned char * APDU_Cmd_Data(struct anonymous$13 *apdu);
// APDU_Cmd_Delete
// file apdu.h line 82
extern void APDU_Cmd_Delete(struct anonymous$13 *apdu);
// APDU_Cmd_Header
// file apdu.h line 109
extern unsigned char * APDU_Cmd_Header(struct anonymous$13 *apdu);
// APDU_Cmd_Ins
// file apdu.h line 91
extern unsigned char APDU_Cmd_Ins(struct anonymous$13 *apdu);
// APDU_Cmd_Lc
// file apdu.h line 100
extern unsigned long int APDU_Cmd_Lc(struct anonymous$13 *apdu);
// APDU_Cmd_Le
// file apdu.h line 103
extern unsigned long int APDU_Cmd_Le(struct anonymous$13 *apdu);
// APDU_Cmd_Le_Available
// file apdu.c line 210
extern signed int APDU_Cmd_Le_Available(struct anonymous$13 *apdu);
// APDU_Cmd_New
// file apdu.h line 79
extern struct anonymous$13 * APDU_Cmd_New(unsigned char *data, unsigned long int length);
// APDU_Cmd_P1
// file apdu.h line 94
extern unsigned char APDU_Cmd_P1(struct anonymous$13 *apdu);
// APDU_Cmd_P2
// file apdu.h line 97
extern unsigned char APDU_Cmd_P2(struct anonymous$13 *apdu);
// APDU_Cmd_Raw
// file apdu.h line 115
extern unsigned char * APDU_Cmd_Raw(struct anonymous$13 *apdu);
// APDU_Cmd_RawLen
// file apdu.h line 118
extern unsigned long int APDU_Cmd_RawLen(struct anonymous$13 *apdu);
// APDU_Rsp_AppendData
// file apdu.h line 148
extern signed int APDU_Rsp_AppendData(struct anonymous$14 *apdu1, struct anonymous$14 *apdu2);
// APDU_Rsp_Data
// file apdu.c line 328
extern unsigned char * APDU_Rsp_Data(struct anonymous$14 *apdu);
// APDU_Rsp_DataLen
// file apdu.h line 133
extern unsigned long int APDU_Rsp_DataLen(struct anonymous$14 *apdu);
// APDU_Rsp_Delete
// file apdu.h line 124
extern void APDU_Rsp_Delete(struct anonymous$14 *apdu);
// APDU_Rsp_New
// file apdu.h line 121
extern struct anonymous$14 * APDU_Rsp_New(unsigned char *data, unsigned long int length);
// APDU_Rsp_Raw
// file apdu.c line 334
extern unsigned char * APDU_Rsp_Raw(struct anonymous$14 *apdu);
// APDU_Rsp_RawLen
// file apdu.c line 340
extern unsigned long int APDU_Rsp_RawLen(struct anonymous$14 *apdu);
// APDU_Rsp_SW1
// file apdu.h line 127
extern unsigned char APDU_Rsp_SW1(struct anonymous$14 *apdu);
// APDU_Rsp_SW2
// file apdu.h line 130
extern unsigned char APDU_Rsp_SW2(struct anonymous$14 *apdu);
// APDU_Rsp_TruncateData
// file apdu.c line 346
extern void APDU_Rsp_TruncateData(struct anonymous$14 *apdu, unsigned long int length);
// ATR_Delete
// file atr.c line 325
extern void ATR_Delete(struct anonymous$7 *atr);
// ATR_GetCheckByte
// file atr.c line 571
extern signed int ATR_GetCheckByte(struct anonymous$7 *atr, unsigned char *check_byte);
// ATR_GetConvention
// file atr.c line 331
extern signed int ATR_GetConvention(struct anonymous$7 *atr, signed int *convention);
// ATR_GetFsMax
// file atr.c line 581
extern signed int ATR_GetFsMax(struct anonymous$7 *atr, unsigned long int *fsmax);
// ATR_GetHistoricalBytes
// file atr.c line 521
extern signed int ATR_GetHistoricalBytes(struct anonymous$7 *atr, unsigned char *hist, unsigned int *length);
// ATR_GetIntegerValue
// file atr.c line 390
extern signed int ATR_GetIntegerValue(struct anonymous$7 *atr, signed int name, unsigned char *value);
// ATR_GetInterfaceByte
// file atr.c line 372
extern signed int ATR_GetInterfaceByte(struct anonymous$7 *atr, unsigned int number, signed int character, unsigned char *value);
// ATR_GetNextByte
// file atr.c line 598
static signed int ATR_GetNextByte(struct anonymous$9 *io, unsigned int timeout, unsigned char *byte, signed int invert);
// ATR_GetNumberOfProtocols
// file atr.c line 350
extern signed int ATR_GetNumberOfProtocols(struct anonymous$7 *atr, unsigned int *number_protocols);
// ATR_GetParameter
// file atr.c line 466
extern signed int ATR_GetParameter(struct anonymous$7 *atr, signed int name, double *parameter);
// ATR_GetProtocolType
// file atr.c line 357
extern signed int ATR_GetProtocolType(struct anonymous$7 *atr, unsigned int number_protocol, unsigned char *protocol_type);
// ATR_GetRaw
// file atr.c line 532
extern signed int ATR_GetRaw(struct anonymous$7 *atr, unsigned char *buffer, unsigned int *length);
// ATR_GetSize
// file atr.c line 343
extern signed int ATR_GetSize(struct anonymous$7 *atr, unsigned int *size);
// ATR_InitFromArray
// file atr.c line 90
extern signed int ATR_InitFromArray(struct anonymous$7 *atr, unsigned char *atr_buffer, unsigned int length);
// ATR_InitFromStream
// file atr.c line 203
extern signed int ATR_InitFromStream(struct anonymous$7 *atr, struct anonymous$9 *io, unsigned int timeout);
// ATR_New
// file atr.c line 79
extern struct anonymous$7 * ATR_New(void);
// ATR_Sync_Delete
// file atr_sync.h line 106
extern void ATR_Sync_Delete(struct anonymous$19 *atr);
// ATR_Sync_GetCategoryIndicator
// file atr_sync.h line 100
extern unsigned char ATR_Sync_GetCategoryIndicator(struct anonymous$19 *atr);
// ATR_Sync_GetDirDataReference
// file atr_sync.h line 102
extern unsigned char ATR_Sync_GetDirDataReference(struct anonymous$19 *atr);
// ATR_Sync_GetHistoricalBytes
// file atr_sync.c line 134
extern void ATR_Sync_GetHistoricalBytes(struct anonymous$19 *atr, unsigned char *buffer, unsigned int *length);
// ATR_Sync_GetLengthOfDataUnits
// file atr_sync.h line 94
extern unsigned int ATR_Sync_GetLengthOfDataUnits(struct anonymous$19 *atr);
// ATR_Sync_GetNumberOfDataUnits
// file atr_sync.h line 92
extern unsigned int ATR_Sync_GetNumberOfDataUnits(struct anonymous$19 *atr);
// ATR_Sync_GetProtocolParameter
// file atr_sync.c line 87
extern unsigned char ATR_Sync_GetProtocolParameter(struct anonymous$19 *atr);
// ATR_Sync_GetProtocolType
// file atr_sync.h line 86
extern unsigned char ATR_Sync_GetProtocolType(struct anonymous$19 *atr);
// ATR_Sync_GetRaw
// file atr_sync.c line 154
extern void ATR_Sync_GetRaw(struct anonymous$19 *atr, unsigned char *buffer, unsigned int *length);
// ATR_Sync_GetReadToEnd
// file atr_sync.c line 128
extern signed int ATR_Sync_GetReadToEnd(struct anonymous$19 *atr);
// ATR_Sync_GetStructureID
// file atr_sync.c line 81
extern unsigned char ATR_Sync_GetStructureID(struct anonymous$19 *atr);
// ATR_Sync_Init
// file atr_sync.h line 84
extern signed int ATR_Sync_Init(struct anonymous$19 *atr, unsigned char *buffer, unsigned int length);
// ATR_Sync_New
// file atr_sync.h line 82
extern struct anonymous$19 * ATR_Sync_New(void);
// CT_List_AddCardTerminal
// file ct_list.c line 46
extern signed int CT_List_AddCardTerminal(struct anonymous$21 *list, struct anonymous$3 *ct, unsigned short int ctn);
// CT_List_Delete
// file ct_list.c line 143
extern void CT_List_Delete(struct anonymous$21 *list);
// CT_List_GetCardTerminal
// file ct_list.c line 76
extern struct anonymous$3 * CT_List_GetCardTerminal(struct anonymous$21 *list, unsigned short int ctn);
// CT_List_GetNumberOfElements
// file ct_list.c line 92
extern signed int CT_List_GetNumberOfElements(struct anonymous$21 *list);
// CT_List_New
// file ct_list.c line 31
extern struct anonymous$21 * CT_List_New(void);
// CT_List_RemoveCardTerminal
// file ct_list.c line 101
extern signed int CT_List_RemoveCardTerminal(struct anonymous$21 *list, unsigned short int ctn);
// CT_Slot_Check
// file ct_slot.h line 72
extern char CT_Slot_Check(struct anonymous$2 *slot, signed int timeout, signed int *card, signed int *change);
// CT_Slot_Clear
// file ct_slot.c line 505
static void CT_Slot_Clear(struct anonymous$2 *slot);
// CT_Slot_Close
// file ct_slot.h line 108
extern char CT_Slot_Close(struct anonymous$2 *slot);
// CT_Slot_Command
// file ct_slot.c line 345
extern char CT_Slot_Command(struct anonymous$2 *slot, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// CT_Slot_Delete
// file ct_slot.h line 112
extern void CT_Slot_Delete(struct anonymous$2 *slot);
// CT_Slot_GetAtr
// file ct_slot.h line 96
extern void * CT_Slot_GetAtr(struct anonymous$2 *slot);
// CT_Slot_GetICC
// file ct_slot.c line 404
extern void * CT_Slot_GetICC(struct anonymous$2 *slot);
// CT_Slot_GetICCType
// file ct_slot.h line 88
extern signed int CT_Slot_GetICCType(struct anonymous$2 *slot);
// CT_Slot_GetType
// file ct_slot.h line 104
extern void CT_Slot_GetType(struct anonymous$2 *slot, unsigned char *buffer, signed int len);
// CT_Slot_Init
// file ct_slot.h line 68
extern char CT_Slot_Init(struct anonymous$2 *slot, struct anonymous$9 *io, signed int sn);
// CT_Slot_IsLast
// file ct_slot.h line 100
extern signed int CT_Slot_IsLast(struct anonymous$2 *slot);
// CT_Slot_New
// file ct_slot.h line 64
extern struct anonymous$2 * CT_Slot_New();
// CT_Slot_Probe
// file ct_slot.h line 76
extern char CT_Slot_Probe(struct anonymous$2 *slot, unsigned char *userdata, unsigned int length);
// CT_Slot_Release
// file ct_slot.h line 80
extern char CT_Slot_Release(struct anonymous$2 *slot);
// CT_close
// file ../../src/ct-api/ctapi.h line 25
char CT_close(unsigned short int ctn);
// CT_data
// file ../../src/ct-api/ctapi.h line 29
char CT_data(unsigned short int ctn, unsigned char *dad, unsigned char *sad, unsigned short int lc, unsigned char *cmd, unsigned short int *lr, unsigned char *rsp);
// CT_init
// file ../../src/ct-api/ctapi.h line 20
char CT_init(unsigned short int ctn, unsigned short int pn);
// CardTerminal_Clear
// file cardterminal.c line 879
static void CardTerminal_Clear(struct anonymous$3 *ct);
// CardTerminal_Close
// file cardterminal.c line 220
extern char CardTerminal_Close(struct anonymous$3 *ct);
// CardTerminal_Command
// file cardterminal.c line 164
extern char CardTerminal_Command(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// CardTerminal_Delete
// file cardterminal.c line 256
extern void CardTerminal_Delete(struct anonymous$3 *ct);
// CardTerminal_EjectICC
// file cardterminal.c line 771
static char CardTerminal_EjectICC(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// CardTerminal_GetMutex
// file cardterminal.c line 272
extern union anonymous$16 * CardTerminal_GetMutex(struct anonymous$3 *ct);
// CardTerminal_GetSlot
// file cardterminal.c line 262
extern struct anonymous$2 * CardTerminal_GetSlot(struct anonymous$3 *ct, signed int number);
// CardTerminal_GetStatus
// file cardterminal.c line 681
static char CardTerminal_GetStatus(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// CardTerminal_Init
// file cardterminal.c line 77
extern char CardTerminal_Init(struct anonymous$3 *ct, unsigned short int pn);
// CardTerminal_New
// file cardterminal.c line 64
extern struct anonymous$3 * CardTerminal_New(void);
// CardTerminal_RequestICC
// file cardterminal.c line 511
static char CardTerminal_RequestICC(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// CardTerminal_ResetCT
// file cardterminal.c line 283
static char CardTerminal_ResetCT(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Change
// file tester.c line 636
unsigned short int Change(unsigned short int ctn);
// ChangePin
// file tester.c line 995
void ChangePin(unsigned short int ctn);
// Close
// file tester.c line 676
void Close(unsigned short int ctn);
// EnterPin
// file tester.c line 956
void EnterPin(unsigned short int ctn);
// GetMemoryLength
// file tester.c line 529
unsigned int GetMemoryLength(unsigned char *atr, unsigned int length);
// GetResponse
// file tester.c line 767
void GetResponse(unsigned short int ctn);
// ICC_Async_BeginTransmission
// file icc_async.c line 157
extern signed int ICC_Async_BeginTransmission(struct anonymous$5 *icc);
// ICC_Async_Clear
// file icc_async.c line 300
static void ICC_Async_Clear(struct anonymous$5 *icc);
// ICC_Async_Close
// file icc_async.c line 256
extern signed int ICC_Async_Close(struct anonymous$5 *icc);
// ICC_Async_Delete
// file icc_async.c line 281
extern void ICC_Async_Delete(struct anonymous$5 *icc);
// ICC_Async_EndTransmission
// file icc_async.c line 231
extern signed int ICC_Async_EndTransmission(struct anonymous$5 *icc);
// ICC_Async_GetAtr
// file icc_async.c line 244
extern struct anonymous$7 * ICC_Async_GetAtr(struct anonymous$5 *icc);
// ICC_Async_GetBaudrate
// file icc_async.c line 149
extern signed int ICC_Async_GetBaudrate(struct anonymous$5 *icc, unsigned long int *baudrate);
// ICC_Async_GetClockRate
// file icc_async.c line 275
extern unsigned long int ICC_Async_GetClockRate(struct anonymous$5 *icc);
// ICC_Async_GetIFD
// file icc_async.c line 250
extern struct anonymous$6 * ICC_Async_GetIFD(struct anonymous$5 *icc);
// ICC_Async_GetTimings
// file icc_async.c line 130
extern signed int ICC_Async_GetTimings(struct anonymous$5 *icc, struct anonymous$4 *timings);
// ICC_Async_Init
// file icc_async.c line 61
extern signed int ICC_Async_Init(struct anonymous$5 *icc, struct anonymous$6 *ifd);
// ICC_Async_InvertBuffer
// file icc_async.c line 291
static void ICC_Async_InvertBuffer(unsigned int size, unsigned char *buffer);
// ICC_Async_New
// file icc_async.c line 47
extern struct anonymous$5 * ICC_Async_New(void);
// ICC_Async_Receive
// file icc_async.c line 202
extern signed int ICC_Async_Receive(struct anonymous$5 *icc, unsigned int size, unsigned char *data);
// ICC_Async_SetBaudrate
// file icc_async.c line 141
extern signed int ICC_Async_SetBaudrate(struct anonymous$5 *icc, unsigned long int baudrate);
// ICC_Async_SetTimings
// file icc_async.c line 119
extern signed int ICC_Async_SetTimings(struct anonymous$5 *icc, struct anonymous$4 *timings);
// ICC_Async_Switch
// file icc_async.c line 219
extern signed int ICC_Async_Switch(struct anonymous$5 *icc);
// ICC_Async_Transmit
// file icc_async.c line 174
extern signed int ICC_Async_Transmit(struct anonymous$5 *icc, unsigned int size, unsigned char *data);
// ICC_Sync_BeginTransmission
// file icc_sync.c line 419
signed int ICC_Sync_BeginTransmission(struct anonymous$22 *icc);
// ICC_Sync_ChangePin
// file icc_sync.c line 381
signed int ICC_Sync_ChangePin(struct anonymous$22 *icc, unsigned char *pin);
// ICC_Sync_Clear
// file icc_sync.c line 666
static void ICC_Sync_Clear(struct anonymous$22 *icc);
// ICC_Sync_Close
// file icc_sync.c line 175
signed int ICC_Sync_Close(struct anonymous$22 *icc);
// ICC_Sync_CreateAtr
// file icc_sync.c line 633
static struct anonymous$19 * ICC_Sync_CreateAtr(struct anonymous$22 *icc);
// ICC_Sync_Delete
// file icc_sync.c line 85
extern void ICC_Sync_Delete(struct anonymous$22 *icc);
// ICC_Sync_EnterPin
// file icc_sync.c line 330
signed int ICC_Sync_EnterPin(struct anonymous$22 *icc, unsigned char *pin, unsigned int *trials);
// ICC_Sync_GetAtr
// file icc_sync.c line 469
struct anonymous$19 * ICC_Sync_GetAtr(struct anonymous$22 *icc);
// ICC_Sync_GetBaudrate
// file icc_sync.c line 437
signed int ICC_Sync_GetBaudrate(struct anonymous$22 *icc, unsigned long int *baudrate);
// ICC_Sync_GetIFD
// file icc_sync.c line 463
struct anonymous$6 * ICC_Sync_GetIFD(struct anonymous$22 *icc);
// ICC_Sync_GetLength
// file icc_sync.c line 445
unsigned int ICC_Sync_GetLength(struct anonymous$22 *icc);
// ICC_Sync_GetPagemode
// file icc_sync.c line 457
unsigned char ICC_Sync_GetPagemode(struct anonymous$22 *icc);
// ICC_Sync_GetType
// file icc_sync.c line 451
signed int ICC_Sync_GetType(struct anonymous$22 *icc);
// ICC_Sync_Init
// file icc_sync.c line 91
signed int ICC_Sync_Init(struct anonymous$22 *icc, struct anonymous$6 *ifd);
// ICC_Sync_New
// file icc_sync.c line 71
extern struct anonymous$22 * ICC_Sync_New(void);
// ICC_Sync_ProbeCardType
// file icc_sync.c line 479
static signed int ICC_Sync_ProbeCardType(struct anonymous$22 *icc);
// ICC_Sync_ProbeMemoryLength
// file icc_sync.c line 564
static signed int ICC_Sync_ProbeMemoryLength(struct anonymous$22 *icc);
// ICC_Sync_ProbePagemode
// file icc_sync.c line 622
static signed int ICC_Sync_ProbePagemode(struct anonymous$22 *icc);
// ICC_Sync_Read
// file icc_sync.c line 194
signed int ICC_Sync_Read(struct anonymous$22 *icc, unsigned short int address, unsigned int length, unsigned char *data);
// ICC_Sync_SetBaudrate
// file icc_sync.c line 430
signed int ICC_Sync_SetBaudrate(struct anonymous$22 *icc, unsigned long int baudrate);
// ICC_Sync_Write
// file icc_sync.c line 226
signed int ICC_Sync_Write(struct anonymous$22 *icc, unsigned short int address, unsigned int length, unsigned char *data);
// IFDHCloseChannel
// file ifdhandler.c line 181
signed long int IFDHCloseChannel(unsigned long int Lun);
// IFDHControl
// file ifdhandler.c line 534
signed long int IFDHControl(unsigned long int Lun, unsigned char *TxBuffer, unsigned long int TxLength, unsigned char *RxBuffer, unsigned long int *RxLength);
// IFDHCreateChannel
// file ifdhandler.c line 88
signed long int IFDHCreateChannel(unsigned long int Lun, unsigned long int Channel);
// IFDHGetCapabilities
// file ifdhandler.c line 224
signed long int IFDHGetCapabilities(unsigned long int Lun, unsigned long int Tag, unsigned long int *Length, unsigned char *Value);
// IFDHICCPresence
// file ifdhandler.c line 589
signed long int IFDHICCPresence(unsigned long int Lun);
// IFDHPowerICC
// file ifdhandler.c line 354
signed long int IFDHPowerICC(unsigned long int Lun, unsigned long int Action, unsigned char *Atr, unsigned long int *AtrLength);
// IFDHSetCapabilities
// file ifdhandler.c line 273
signed long int IFDHSetCapabilities(unsigned long int Lun, unsigned long int Tag, unsigned long int Length, unsigned char *Value);
// IFDHSetProtocolParameters
// file ifdhandler.c line 284
signed long int IFDHSetProtocolParameters(unsigned long int Lun, unsigned long int Protocol, unsigned char Flags, unsigned char PTS1, unsigned char PTS2, unsigned char PTS3);
// IFDHTransmitToICC
// file ifdhandler.c line 477
signed long int IFDHTransmitToICC(unsigned long int Lun, struct _SCARD_IO_HEADER SendPci, unsigned char *TxBuffer, unsigned long int TxLength, unsigned char *RxBuffer, unsigned long int *RxLength, struct _SCARD_IO_HEADER *RecvPci);
// IFD_Towitoko_ActivateICC
// file ifd_towitoko.h line 130
extern signed int IFD_Towitoko_ActivateICC(struct anonymous$6 *ifd);
// IFD_Towitoko_ChangePin
// file ifd_towitoko.c line 1405
extern signed int IFD_Towitoko_ChangePin(struct anonymous$6 *ifd, signed int icc_type, unsigned char *pin);
// IFD_Towitoko_Checksum
// file ifd_towitoko.c line 1610
static unsigned char IFD_Towitoko_Checksum(unsigned char *command, unsigned int size, unsigned char initial);
// IFD_Towitoko_Clear
// file ifd_towitoko.c line 1672
static void IFD_Towitoko_Clear(struct anonymous$6 *ifd);
// IFD_Towitoko_Close
// file ifd_towitoko.c line 157
extern signed int IFD_Towitoko_Close(struct anonymous$6 *ifd);
// IFD_Towitoko_DeactivateICC
// file ifd_towitoko.h line 131
extern signed int IFD_Towitoko_DeactivateICC(struct anonymous$6 *ifd);
// IFD_Towitoko_Delete
// file ifd_towitoko.c line 76
extern void IFD_Towitoko_Delete(struct anonymous$6 *ifd);
// IFD_Towitoko_EnterPin
// file ifd_towitoko.c line 1195
extern signed int IFD_Towitoko_EnterPin(struct anonymous$6 *ifd, signed int icc_type, unsigned char *pin, unsigned int trial);
// IFD_Towitoko_GetBaudrate
// file ifd_towitoko.c line 306
extern signed int IFD_Towitoko_GetBaudrate(struct anonymous$6 *ifd, unsigned long int *baudrate);
// IFD_Towitoko_GetClockRate
// file ifd_towitoko.h line 153
extern unsigned long int IFD_Towitoko_GetClockRate(struct anonymous$6 *ifd);
// IFD_Towitoko_GetDescription
// file ifd_towitoko.c line 1514
extern void IFD_Towitoko_GetDescription(struct anonymous$6 *ifd, unsigned char *desc, unsigned int length);
// IFD_Towitoko_GetFirmware
// file ifd_towitoko.c line 1546
extern unsigned char IFD_Towitoko_GetFirmware(struct anonymous$6 *ifd);
// IFD_Towitoko_GetMaxBaudrate
// file ifd_towitoko.c line 1573
extern unsigned long int IFD_Towitoko_GetMaxBaudrate(struct anonymous$6 *ifd);
// IFD_Towitoko_GetNumSlots
// file ifd_towitoko.c line 1558
extern unsigned int IFD_Towitoko_GetNumSlots(struct anonymous$6 *ifd);
// IFD_Towitoko_GetReaderInfo
// file ifd_towitoko.c line 1628
static signed int IFD_Towitoko_GetReaderInfo(struct anonymous$6 *ifd);
// IFD_Towitoko_GetSlot
// file ifd_towitoko.c line 1552
extern unsigned char IFD_Towitoko_GetSlot(struct anonymous$6 *ifd);
// IFD_Towitoko_GetStatus
// file ifd_towitoko.c line 417
extern signed int IFD_Towitoko_GetStatus(struct anonymous$6 *ifd, unsigned char *result);
// IFD_Towitoko_GetType
// file ifd_towitoko.c line 1508
extern unsigned char IFD_Towitoko_GetType(struct anonymous$6 *ifd);
// IFD_Towitoko_Init
// file ifd_towitoko.c line 82
extern signed int IFD_Towitoko_Init(struct anonymous$6 *ifd, struct anonymous$9 *io, unsigned char slot);
// IFD_Towitoko_New
// file ifd_towitoko.c line 63
extern struct anonymous$6 * IFD_Towitoko_New(void);
// IFD_Towitoko_NumTrials
// file ifd_towitoko.c line 1658
static unsigned int IFD_Towitoko_NumTrials(unsigned char b);
// IFD_Towitoko_PrepareCommand
// file ifd_towitoko.c line 1583
static signed int IFD_Towitoko_PrepareCommand(struct anonymous$6 *ifd, unsigned char *command, unsigned char size);
// IFD_Towitoko_ReadBuffer
// file ifd_towitoko.c line 1022
extern signed int IFD_Towitoko_ReadBuffer(struct anonymous$6 *ifd, unsigned int length, unsigned char *data);
// IFD_Towitoko_ReadErrorCounter
// file ifd_towitoko.c line 1128
extern signed int IFD_Towitoko_ReadErrorCounter(struct anonymous$6 *ifd, signed int icc_type, unsigned int *trials);
// IFD_Towitoko_Receive
// file ifd_towitoko.h line 136
extern signed int IFD_Towitoko_Receive(struct anonymous$6 *ifd, struct anonymous$4 *timings, unsigned int size, unsigned char *buffer);
// IFD_Towitoko_ResetAsyncICC
// file ifd_towitoko.h line 134
extern signed int IFD_Towitoko_ResetAsyncICC(struct anonymous$6 *ifd, struct anonymous$7 **atr);
// IFD_Towitoko_ResetSyncICC
// file ifd_towitoko.c line 758
extern signed int IFD_Towitoko_ResetSyncICC(struct anonymous$6 *ifd, struct anonymous$19 **atr);
// IFD_Towitoko_SetBaudrate
// file ifd_towitoko.h line 123
extern signed int IFD_Towitoko_SetBaudrate(struct anonymous$6 *ifd, unsigned long int baudrate);
// IFD_Towitoko_SetLED
// file ifd_towitoko.h line 126
extern signed int IFD_Towitoko_SetLED(struct anonymous$6 *ifd, unsigned char color);
// IFD_Towitoko_SetParity
// file ifd_towitoko.h line 125
extern signed int IFD_Towitoko_SetParity(struct anonymous$6 *ifd, unsigned char parity);
// IFD_Towitoko_SetReadAddress
// file ifd_towitoko.c line 792
extern signed int IFD_Towitoko_SetReadAddress(struct anonymous$6 *ifd, signed int icc_type, unsigned short int address);
// IFD_Towitoko_SetWriteAddress
// file ifd_towitoko.c line 887
extern signed int IFD_Towitoko_SetWriteAddress(struct anonymous$6 *ifd, signed int icc_type, unsigned short int address, unsigned char pagemode);
// IFD_Towitoko_Switch
// file ifd_towitoko.h line 137
extern signed int IFD_Towitoko_Switch(struct anonymous$6 *ifd);
// IFD_Towitoko_Transmit
// file ifd_towitoko.h line 135
extern signed int IFD_Towitoko_Transmit(struct anonymous$6 *ifd, struct anonymous$4 *timings, unsigned int size, unsigned char *buffer);
// IFD_Towitoko_WriteBuffer
// file ifd_towitoko.c line 1073
extern signed int IFD_Towitoko_WriteBuffer(struct anonymous$6 *ifd, unsigned int length, unsigned char *data);
// IO_Serial_Bitrate
// file io_serial.c line 671
static signed int IO_Serial_Bitrate(signed int bitrate);
// IO_Serial_Clear
// file io_serial.c line 829
static void IO_Serial_Clear(struct anonymous$9 *io);
// IO_Serial_ClearPropertiesCache
// file io_serial.c line 874
static void IO_Serial_ClearPropertiesCache(struct anonymous$9 *io);
// IO_Serial_Close
// file io_serial.c line 637
extern signed int IO_Serial_Close(struct anonymous$9 *io);
// IO_Serial_Delete
// file io_serial.c line 658
extern void IO_Serial_Delete(struct anonymous$9 *io);
// IO_Serial_DeviceName
// file io_serial.c line 887
static void IO_Serial_DeviceName(unsigned int com, signed int usbserial, char *filename, unsigned int length);
// IO_Serial_GetCom
// file io_serial.c line 529
extern unsigned int IO_Serial_GetCom(struct anonymous$9 *io);
// IO_Serial_GetPnPId
// file io_serial.c line 522
extern void IO_Serial_GetPnPId(struct anonymous$9 *io, unsigned char *pnp_id, unsigned int *length);
// IO_Serial_GetProperties
// file io_serial.c line 120
extern signed int IO_Serial_GetProperties(struct anonymous$9 *io, struct anonymous$10 *props);
// IO_Serial_GetPropertiesCache
// file io_serial.c line 852
static signed int IO_Serial_GetPropertiesCache(struct anonymous$9 *io, struct anonymous$10 *props);
// IO_Serial_Init
// file io_serial.c line 92
extern signed int IO_Serial_Init(struct anonymous$9 *io, unsigned int com, signed int usbserial, signed int pnp);
// IO_Serial_InitPnP
// file io_serial.c line 961
static signed int IO_Serial_InitPnP(struct anonymous$9 *io);
// IO_Serial_New
// file io_serial.c line 80
extern struct anonymous$9 * IO_Serial_New(void);
// IO_Serial_Read
// file io_serial.h line 90
extern signed int IO_Serial_Read(struct anonymous$9 *io, unsigned int timeout, unsigned int size, unsigned char *data);
// IO_Serial_SetProperties
// file io_serial.c line 395
extern signed int IO_Serial_SetProperties(struct anonymous$9 *io, struct anonymous$10 *props);
// IO_Serial_SetPropertiesCache
// file io_serial.c line 840
static void IO_Serial_SetPropertiesCache(struct anonymous$9 *io, struct anonymous$10 *props);
// IO_Serial_WaitToRead
// file io_serial.c line 734
static signed int IO_Serial_WaitToRead(signed int hnd, unsigned int delay_ms, unsigned int timeout_ms);
// IO_Serial_WaitToWrite
// file io_serial.c line 781
static signed int IO_Serial_WaitToWrite(signed int hnd, unsigned int delay_ms, unsigned int timeout_ms);
// IO_Serial_Write
// file io_serial.c line 585
extern signed int IO_Serial_Write(struct anonymous$9 *io, unsigned int delay, unsigned int size, unsigned char *data);
// Initialize
// file tester.c line 558
void Initialize(void);
// Monitor
// file tester.c line 409
void * Monitor(void *arg);
// PPS_Delete
// file pps.c line 160
extern void PPS_Delete(struct anonymous$0 *pps);
// PPS_Exchange
// file pps.c line 170
static signed int PPS_Exchange(struct anonymous$0 *pps, unsigned char *params, unsigned int *length);
// PPS_GetLength
// file pps.c line 238
static unsigned int PPS_GetLength(unsigned char *block);
// PPS_GetPCK
// file pps.c line 349
static unsigned char PPS_GetPCK(unsigned char *block, unsigned int length);
// PPS_GetProtocol
// file pps.c line 148
extern void * PPS_GetProtocol(struct anonymous$0 *pps);
// PPS_GetProtocolParameters
// file pps.c line 153
extern struct anonymous$12 * PPS_GetProtocolParameters(struct anonymous$0 *pps);
// PPS_InitICC
// file pps.c line 255
static signed int PPS_InitICC(struct anonymous$0 *pps);
// PPS_InitProtocol
// file pps.c line 277
static signed int PPS_InitProtocol(struct anonymous$0 *pps);
// PPS_Match
// file pps.c line 223
static signed int PPS_Match(unsigned char *request, unsigned int len_request, unsigned char *confirm, unsigned int len_confirm);
// PPS_New
// file pps.c line 68
extern struct anonymous$0 * PPS_New(struct anonymous$5 *icc);
// PPS_Perform
// file pps.c line 88
extern signed int PPS_Perform(struct anonymous$0 *pps, unsigned char *params, unsigned int *length);
// PPS_SelectFirstProtocol
// file pps.c line 327
static void PPS_SelectFirstProtocol(struct anonymous$0 *pps);
// PrintArray
// file tester.c line 539
void PrintArray(unsigned char *buffer, unsigned int length);
// PrintReport
// file tester.c line 257
void PrintReport(void);
// Protocol_Sync_BadCommand
// file protocol_sync.c line 655
static signed int Protocol_Sync_BadCommand(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_Sync_ChangeVerifyData
// file protocol_sync.c line 592
static signed int Protocol_Sync_ChangeVerifyData(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_Sync_Clear
// file protocol_sync.c line 674
static void Protocol_Sync_Clear(struct anonymous *ps);
// Protocol_Sync_Close
// file protocol_sync.c line 127
extern signed int Protocol_Sync_Close(struct anonymous *ps);
// Protocol_Sync_Command
// file protocol_sync.c line 95
extern signed int Protocol_Sync_Command(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_Sync_Delete
// file protocol_sync.c line 135
extern void Protocol_Sync_Delete(struct anonymous *ps);
// Protocol_Sync_GetData
// file protocol_sync.c line 668
static signed int Protocol_Sync_GetData(void *data, unsigned short int address, unsigned short int length, unsigned char *buffer);
// Protocol_Sync_Init
// file protocol_sync.c line 83
extern signed int Protocol_Sync_Init(struct anonymous *ps, struct anonymous$22 *icc);
// Protocol_Sync_New
// file protocol_sync.c line 70
extern struct anonymous * Protocol_Sync_New(void);
// Protocol_Sync_ReadBinary
// file protocol_sync.c line 424
static signed int Protocol_Sync_ReadBinary(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_Sync_SelectFile
// file protocol_sync.c line 145
static signed int Protocol_Sync_SelectFile(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_Sync_UpdateBinary
// file protocol_sync.c line 493
static signed int Protocol_Sync_UpdateBinary(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_Sync_Verify
// file protocol_sync.c line 545
static signed int Protocol_Sync_Verify(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Case1
// file protocol_t0.c line 185
static signed int Protocol_T0_Case1(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Case2E
// file protocol_t0.c line 412
static signed int Protocol_T0_Case2E(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Case2S
// file protocol_t0.c line 207
static signed int Protocol_T0_Case2S(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Case3E
// file protocol_t0.c line 497
static signed int Protocol_T0_Case3E(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Case3S
// file protocol_t0.c line 218
static signed int Protocol_T0_Case3S(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Case4E
// file protocol_t0.c line 633
static signed int Protocol_T0_Case4E(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Case4S
// file protocol_t0.c line 328
static signed int Protocol_T0_Case4S(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Clear
// file protocol_t0.c line 949
static void Protocol_T0_Clear(struct anonymous$11 *t0);
// Protocol_T0_Close
// file protocol_t0.c line 167
extern signed int Protocol_T0_Close(struct anonymous$11 *t0);
// Protocol_T0_Command
// file protocol_t0.c line 123
extern signed int Protocol_T0_Command(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Delete
// file protocol_t0.c line 175
extern void Protocol_T0_Delete(struct anonymous$11 *t0);
// Protocol_T0_ExchangeTPDU
// file protocol_t0.c line 733
static signed int Protocol_T0_ExchangeTPDU(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T0_Init
// file protocol_t0.c line 87
extern signed int Protocol_T0_Init(struct anonymous$11 *t0, struct anonymous$5 *icc, struct anonymous$12 *params);
// Protocol_T0_New
// file protocol_t0.c line 74
extern struct anonymous$11 * Protocol_T0_New(void);
// Protocol_T1_Clear
// file protocol_t1.c line 459
static void Protocol_T1_Clear(struct anonymous$18 *t1);
// Protocol_T1_Close
// file protocol_t1.c line 358
extern signed int Protocol_T1_Close(struct anonymous$18 *t1);
// Protocol_T1_Command
// file protocol_t1.c line 170
extern signed int Protocol_T1_Command(struct anonymous$18 *t1, struct anonymous$13 *cmd, struct anonymous$14 **rsp);
// Protocol_T1_Delete
// file protocol_t1.c line 366
extern void Protocol_T1_Delete(struct anonymous$18 *t1);
// Protocol_T1_Init
// file protocol_t1.c line 75
extern signed int Protocol_T1_Init(struct anonymous$18 *t1, struct anonymous$5 *icc, struct anonymous$12 *params);
// Protocol_T1_New
// file protocol_t1.c line 62
extern struct anonymous$18 * Protocol_T1_New(void);
// Protocol_T1_ReceiveBlock
// file protocol_t1.c line 405
static signed int Protocol_T1_ReceiveBlock(struct anonymous$18 *t1, struct anonymous$15 **block);
// Protocol_T1_SendBlock
// file protocol_t1.c line 376
static signed int Protocol_T1_SendBlock(struct anonymous$18 *t1, struct anonymous$15 *block);
// Protocol_T1_UpdateBWT
// file protocol_t1.c line 472
static signed int Protocol_T1_UpdateBWT(struct anonymous$18 *t1, unsigned short int bwt);
// ReadBinary
// file tester.c line 849
void ReadBinary(unsigned short int ctn);
// ReadData
// file tester.c line 1043
void ReadData(unsigned short int ctn);
// ReadPort
// file tester.c line 501
unsigned short int ReadPort(char *port);
// SelectClass
// file tester.c line 708
void SelectClass(unsigned short int ctn);
// SelectFile
// file tester.c line 727
void SelectFile(unsigned short int ctn);
// SendPPS
// file tester.c line 919
void SendPPS(unsigned short int ctn);
// T1_Block_Delete
// file t1_block.h line 103
extern void T1_Block_Delete(struct anonymous$15 *block);
// T1_Block_GetInf
// file t1_block.h line 94
extern unsigned char * T1_Block_GetInf(struct anonymous$15 *block);
// T1_Block_GetLen
// file t1_block.h line 91
extern unsigned char T1_Block_GetLen(struct anonymous$15 *block);
// T1_Block_GetMore
// file t1_block.h line 85
extern signed int T1_Block_GetMore(struct anonymous$15 *block);
// T1_Block_GetNR
// file t1_block.c line 193
extern unsigned char T1_Block_GetNR(struct anonymous$15 *block);
// T1_Block_GetNS
// file t1_block.h line 82
extern unsigned char T1_Block_GetNS(struct anonymous$15 *block);
// T1_Block_GetType
// file t1_block.h line 79
extern unsigned char T1_Block_GetType(struct anonymous$15 *block);
// T1_Block_LRC
// file t1_block.c line 237
static unsigned char T1_Block_LRC(unsigned char *data, unsigned int length);
// T1_Block_New
// file t1_block.h line 67
extern struct anonymous$15 * T1_Block_New(unsigned char *buffer, unsigned int length);
// T1_Block_NewIBlock
// file t1_block.h line 70
extern struct anonymous$15 * T1_Block_NewIBlock(unsigned char len, unsigned char *inf, unsigned char ns, signed int more);
// T1_Block_NewRBlock
// file t1_block.h line 73
extern struct anonymous$15 * T1_Block_NewRBlock(unsigned char type, unsigned char nr);
// T1_Block_NewSBlock
// file t1_block.h line 76
extern struct anonymous$15 * T1_Block_NewSBlock(unsigned char type, unsigned char len, unsigned char *inf);
// T1_Block_Raw
// file t1_block.h line 97
extern unsigned char * T1_Block_Raw(struct anonymous$15 *block);
// T1_Block_RawLen
// file t1_block.h line 100
extern unsigned int T1_Block_RawLen(struct anonymous$15 *block);
// TLV_Object_CompareValue
// file tlv_object.h line 93
extern signed int TLV_Object_CompareValue(struct anonymous$23 *tlv, unsigned char *value, unsigned short int *length);
// TLV_Object_Delete
// file tlv_object.h line 87
extern void TLV_Object_Delete(struct anonymous$23 *tlv);
// TLV_Object_GetAddress
// file tlv_object.h line 103
extern unsigned short int TLV_Object_GetAddress(struct anonymous$23 *tlv);
// TLV_Object_GetLength
// file tlv_object.c line 159
extern unsigned short int TLV_Object_GetLength(struct anonymous$23 *tlv);
// TLV_Object_GetObjectBySec
// file tlv_object.c line 251
extern struct anonymous$23 * TLV_Object_GetObjectBySec(struct anonymous$23 *tlv, unsigned short int sec);
// TLV_Object_GetObjectByTag
// file tlv_object.h line 98
extern struct anonymous$23 * TLV_Object_GetObjectByTag(struct anonymous$23 *tlv, unsigned short int tag);
// TLV_Object_GetRawLength
// file tlv_object.h line 102
extern unsigned short int TLV_Object_GetRawLength(struct anonymous$23 *tlv);
// TLV_Object_GetTag
// file tlv_object.h line 90
extern unsigned short int TLV_Object_GetTag(struct anonymous$23 *tlv);
// TLV_Object_GetValue
// file tlv_object.h line 92
extern signed int TLV_Object_GetValue(struct anonymous$23 *tlv, unsigned char *value, unsigned short int *length);
// TLV_Object_Iterate
// file tlv_object.h line 97
extern signed int TLV_Object_Iterate(struct anonymous$23 *tlv, struct anonymous$23 **iterator);
// TLV_Object_New
// file tlv_object.h line 86
extern struct anonymous$23 * TLV_Object_New(void *data, signed int (*get_data)(void *, unsigned short int, unsigned short int, unsigned char *), unsigned short int data_length, unsigned short int address);
// TLV_Object_New::get_data$object
// 
signed int get_data$object(void *, unsigned short int, unsigned short int, unsigned char *);
// TLV_Object_Shift
// file tlv_object.h line 96
extern signed int TLV_Object_Shift(struct anonymous$23 **tlv);
// UpdateBinary
// file tester.c line 805
void UpdateBinary(unsigned short int ctn);
// VerifyKey
// file tester.c line 888
void VerifyKey(unsigned short int ctn);
// WriteData
// file tester.c line 1132
void WriteData(unsigned short int ctn);
// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __ctype_tolower_loc
// file /usr/include/ctype.h line 81
extern const signed int ** __ctype_tolower_loc(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cfgetispeed
// file /usr/include/termios.h line 51
extern unsigned int cfgetispeed(struct termios *);
// cfgetospeed
// file /usr/include/termios.h line 48
extern unsigned int cfgetospeed(struct termios *);
// cfsetispeed
// file /usr/include/termios.h line 57
extern signed int cfsetispeed(struct termios *, unsigned int);
// cfsetospeed
// file /usr/include/termios.h line 54
extern signed int cfsetospeed(struct termios *, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 44
static inline signed int getchar(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file tlv_object.c line 184 function TLV_Object_CompareValue
signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// menu_loop
// file tester.c line 143
void menu_loop(void);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$16 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$16 *, const union anonymous$17 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$16 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$16 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// scanf
// file /usr/include/stdio.h line 431
extern signed int scanf(const char *, ...);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// tcflush
// file /usr/include/termios.h line 90
extern signed int tcflush(signed int, signed int);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$12
{
  // f
  double f;
  // d
  double d;
  // n
  double n;
  // t
  unsigned char t;
};

struct anonymous$0
{
  // icc
  struct anonymous$5 *icc;
  // protocol
  void *protocol;
  // parameters
  struct anonymous$12 parameters;
};

struct anonymous$18
{
  // icc
  struct anonymous$5 *icc;
  // ifsc
  unsigned short int ifsc;
  // ifsd
  unsigned short int ifsd;
  // bgt
  unsigned short int bgt;
  // bwt
  unsigned short int bwt;
  // cwt
  unsigned short int cwt;
  // edc
  signed int edc;
  // ns
  unsigned char ns;
};

struct anonymous$11
{
  // icc
  struct anonymous$5 *icc;
  // wwt
  unsigned long int wwt;
};

struct anonymous
{
  // icc
  struct anonymous$22 *icc;
  // path
  unsigned int path;
  // length
  unsigned int length;
};

struct anonymous$4
{
  // block_delay
  unsigned int block_delay;
  // char_delay
  unsigned int char_delay;
  // block_timeout
  unsigned int block_timeout;
  // char_timeout
  unsigned int char_timeout;
};

struct anonymous$5
{
  // ifd
  struct anonymous$6 *ifd;
  // atr
  struct anonymous$7 *atr;
  // convention
  signed int convention;
  // baudrate
  unsigned long int baudrate;
  // timings
  struct anonymous$4 timings;
};

struct anonymous$22
{
  // ifd
  struct anonymous$6 *ifd;
  // atr
  struct anonymous$19 *atr;
  // type
  signed int type;
  // length
  unsigned int length;
  // pagemode
  unsigned char pagemode;
  // pin
  unsigned char pin[3l];
  // pin_ok
  signed int pin_ok;
  // pin_needed
  signed int pin_needed;
  // active
  signed int active;
  // baudrate
  unsigned long int baudrate;
};

struct anonymous$2
{
  // ifd
  struct anonymous$6 *ifd;
  // icc
  void *icc;
  // protocol
  void *protocol;
  // icc_type
  signed int icc_type;
  // protocol_type
  signed int protocol_type;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$16
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$3
{
  // io
  struct anonymous$9 *io;
  // slots
  struct anonymous$2 *slots[2l];
  // num_slots
  signed int num_slots;
  // mutex
  union anonymous$16 mutex;
};

struct anonymous$6
{
  // io
  struct anonymous$9 *io;
  // slot
  unsigned char slot;
  // type
  unsigned char type;
  // firmware
  unsigned char firmware;
};

struct anonymous$21
{
  // first
  struct CT_List_Node *first;
  // last
  struct CT_List_Node *last;
  // elements
  signed int elements;
};

struct anonymous$13
{
  // command
  unsigned char *command;
  // length
  unsigned long int length;
};

struct anonymous$15
{
  // data
  unsigned char *data;
  // length
  unsigned int length;
};

struct anonymous$14
{
  // response
  unsigned char *response;
  // length
  unsigned long int length;
};

struct anonymous$23
{
  // data
  void *data;
  // data_length
  unsigned short int data_length;
  // get_data
  signed int (*get_data)(void *, unsigned short int, unsigned short int, unsigned char *);
  // address
  unsigned short int address;
  // tag
  unsigned short int tag;
  // length
  unsigned short int length;
  // value
  unsigned short int value;
};

struct anonymous$9
{
  // fd
  signed int fd;
  // props
  struct anonymous$10 *props;
  // com
  unsigned int com;
  // PnP_id
  unsigned char PnP_id[256l];
  // PnP_id_size
  unsigned int PnP_id_size;
  // usbserial
  signed int usbserial;
};

struct _DEVICE_CAPABILITIES
{
  // Vendor_Name
  char *Vendor_Name;
  // IFD_Type
  char *IFD_Type;
  // IFD_Version
  unsigned long int IFD_Version;
  // IFD_Serial
  char *IFD_Serial;
  // IFD_Channel_ID
  unsigned long int IFD_Channel_ID;
  // Asynch_Supported
  unsigned long int Asynch_Supported;
  // Default_Clock
  unsigned long int Default_Clock;
  // Max_Clock
  unsigned long int Max_Clock;
  // Default_Data_Rate
  unsigned long int Default_Data_Rate;
  // Max_Data_Rate
  unsigned long int Max_Data_Rate;
  // Max_IFSD
  unsigned long int Max_IFSD;
  // Synch_Supported
  unsigned long int Synch_Supported;
  // Power_Mgmt
  unsigned long int Power_Mgmt;
  // Card_Auth_Devices
  unsigned long int Card_Auth_Devices;
  // User_Auth_Device
  unsigned long int User_Auth_Device;
  // Mechanics_Supported
  unsigned long int Mechanics_Supported;
  // Vendor_Features
  unsigned long int Vendor_Features;
};

struct _ICC_STATE
{
  // ICC_Presence
  unsigned char ICC_Presence;
  // ICC_Interface_Status
  unsigned char ICC_Interface_Status;
  // ATR
  unsigned char ATR[33l];
  // ATR_Length
  unsigned long int ATR_Length;
  // ICC_Type
  unsigned char ICC_Type;
};

struct _PROTOCOL_OPTIONS
{
  // Protocol_Type
  unsigned long int Protocol_Type;
  // Current_Clock
  unsigned long int Current_Clock;
  // Current_F
  unsigned long int Current_F;
  // Current_D
  unsigned long int Current_D;
  // Current_N
  unsigned long int Current_N;
  // Current_W
  unsigned long int Current_W;
  // Current_IFSC
  unsigned long int Current_IFSC;
  // Current_IFSD
  unsigned long int Current_IFSD;
  // Current_BWT
  unsigned long int Current_BWT;
  // Current_CWT
  unsigned long int Current_CWT;
  // Current_EBC
  unsigned long int Current_EBC;
};

struct anonymous$8
{
  // device_capabilities
  struct _DEVICE_CAPABILITIES device_capabilities;
  // icc_state
  struct _ICC_STATE icc_state;
  // protocol_options
  struct _PROTOCOL_OPTIONS protocol_options;
};

struct anonymous$20
{
  // pn
  unsigned short int pn;
  // port
  char port[16l];
  // status
  signed int status;
  // atr
  unsigned char atr[33l];
  // atr_size
  unsigned short int atr_size;
  // cla
  unsigned char cla;
  // thread
  unsigned long int thread;
  // mutex
  union anonymous$16 mutex;
};

struct anonymous$1
{
  // value
  unsigned char value;
  // present
  signed int present;
};

struct anonymous$7
{
  // length
  unsigned int length;
  // TS
  unsigned char TS;
  // T0
  unsigned char T0;
  // ib
  struct anonymous$1 ib[7l][4l];
  // TCK
  struct anonymous$1 TCK;
  // pn
  unsigned int pn;
  // hb
  unsigned char hb[15l];
  // hbn
  unsigned int hbn;
};

struct anonymous$10
{
  // input_bitrate
  unsigned long int input_bitrate;
  // output_bitrate
  unsigned long int output_bitrate;
  // bits
  unsigned int bits;
  // stopbits
  unsigned int stopbits;
  // parity
  signed int parity;
  // dtr
  signed int dtr;
  // rts
  signed int rts;
};

struct anonymous$19
{
  // H1
  unsigned char H1;
  // H2
  unsigned char H2;
  // H3
  unsigned char H3;
  // H4
  unsigned char H4;
};

union anonymous$17
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct CT_List_Node
{
  // ctn
  unsigned short int ctn;
  // ct
  struct anonymous$3 *ct;
  // next
  struct CT_List_Node *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _SCARD_IO_HEADER
{
  // Protocol
  unsigned long int Protocol;
  // Length
  unsigned long int Length;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};


// atr_d_table
// file atr.c line 56
double atr_d_table[16l] = { (double)0, (double)1, (double)2, (double)4, (double)8, (double)16, (double)0, (double)0, (double)0, (double)0, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625 };
// atr_f_table
// file atr.c line 50
unsigned int atr_f_table[16l] = { (unsigned int)0, (unsigned int)372, (unsigned int)558, (unsigned int)744, (unsigned int)1116, (unsigned int)1488, (unsigned int)1860, (unsigned int)0, (unsigned int)0, (unsigned int)512, (unsigned int)768, (unsigned int)1024, (unsigned int)1536, (unsigned int)2048, (unsigned int)0, (unsigned int)0 };
// atr_fs_table
// file atr.c line 33
static unsigned long int atr_fs_table[16l] = { (unsigned long int)0, (unsigned long int)5000000L, (unsigned long int)6000000L, (unsigned long int)8000000L, (unsigned long int)12000000L, (unsigned long int)16000000L, (unsigned long int)20000000L, (unsigned long int)0, (unsigned long int)0, (unsigned long int)5000000L, (unsigned long int)7500000L, (unsigned long int)10000000L, (unsigned long int)15000000L, (unsigned long int)20000000L, (unsigned long int)0, (unsigned long int)0 };
// atr_i_table
// file atr.c line 62
unsigned int atr_i_table[4l] = { (unsigned int)25, (unsigned int)50, (unsigned int)100, (unsigned int)0 };
// atr_num_ib_table
// file atr.c line 40
static unsigned int atr_num_ib_table[16l] = { (unsigned int)0, (unsigned int)1, (unsigned int)1, (unsigned int)2, (unsigned int)1, (unsigned int)2, (unsigned int)2, (unsigned int)3, (unsigned int)1, (unsigned int)2, (unsigned int)2, (unsigned int)3, (unsigned int)2, (unsigned int)3, (unsigned int)3, (unsigned int)4 };
// ct_list
// file tester.c line 64
struct anonymous$20 ct_list[4l];
// ct_list$link1
// file ctapi.c line 40
static struct anonymous$21 *ct_list$link1 = (struct anonymous$21 *)(void *)0;
// ct_list_mutex
// file ctapi.c line 43
static union anonymous$16 ct_list_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ifdh_context
// file ifdhandler.c line 70
static struct anonymous$8 *ifdh_context[4l][1l] = { { (struct anonymous$8 *)(void *)0 }, { (struct anonymous$8 *)(void *)0 }, { (struct anonymous$8 *)(void *)0 }, { (struct anonymous$8 *)(void *)0 } };
// ifdh_context_mutex
// file ifdhandler.c line 76
static union anonymous$16 ifdh_context_mutex[4l] = { { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, 
    { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, 
    { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, 
    { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;

// APDU_Cmd_Case
// file apdu.h line 85
extern signed int APDU_Cmd_Case(struct anonymous$13 *apdu)
{
  unsigned char B1;
  unsigned short int B2B3;
  unsigned long int L;
  signed int res;
  unsigned long int tmp_if_expr$1;
  if(apdu->length + 18446744073709551612ul >= 1ul)
    tmp_if_expr$1 = apdu->length - (unsigned long int)4;

  else
    tmp_if_expr$1 = (unsigned long int)0;
  L = tmp_if_expr$1;
  if(L == 0ul)
    res = 0x0001;

  else
  {
    B1 = apdu->command[(signed long int)4];
    if(L == (unsigned long int)(1 + (signed int)B1) && !((signed int)B1 == 0))
      res = 0x0002;

    else
      if(L == 1ul)
        res = 0x0003;

      else
        if(L == (unsigned long int)(2 + (signed int)B1) && !((signed int)B1 == 0))
          res = 0x0004;

        else
          if((signed int)B1 == 0 && L >= 3ul)
          {
            B2B3 = (unsigned short int)((signed int)(unsigned short int)apdu->command[(signed long int)5] << 8 | (signed int)apdu->command[(signed long int)6]);
            if(L == (unsigned long int)(3 + (signed int)B2B3) && !((signed int)B2B3 == 0))
              res = 0x0102;

            else
              if(L == 3ul)
                res = 0x0103;

              else
                if(L == (unsigned long int)(5 + (signed int)B2B3) && !((signed int)B2B3 == 0))
                  res = 0x0104;

                else
                  res = 5;
          }

          else
            res = 5;
  }
  return res;
}

// APDU_Cmd_Cla
// file apdu.h line 88
extern unsigned char APDU_Cmd_Cla(struct anonymous$13 *apdu)
{
  return apdu->command[(signed long int)0];
}

// APDU_Cmd_Data
// file apdu.h line 112
extern unsigned char * APDU_Cmd_Data(struct anonymous$13 *apdu)
{
  signed int c;
  unsigned char *res;
  c=APDU_Cmd_Case(apdu);
  if(c == 0x0001 || c == 0x0003 || c == 0x0103)
    res = (unsigned char *)(void *)0;

  else
    if(c == 0x0002 || c == 0x0004)
      res = apdu->command + (signed long int)5;

    else
      if(c == 0x0102 || c == 0x0104)
        res = apdu->command + (signed long int)7;

      else
        res = (unsigned char *)(void *)0;
  return res;
}

// APDU_Cmd_Delete
// file apdu.h line 82
extern void APDU_Cmd_Delete(struct anonymous$13 *apdu)
{
  free((void *)apdu->command);
  free((void *)apdu);
}

// APDU_Cmd_Header
// file apdu.h line 109
extern unsigned char * APDU_Cmd_Header(struct anonymous$13 *apdu)
{
  return apdu->command;
}

// APDU_Cmd_Ins
// file apdu.h line 91
extern unsigned char APDU_Cmd_Ins(struct anonymous$13 *apdu)
{
  return apdu->command[(signed long int)1];
}

// APDU_Cmd_Lc
// file apdu.h line 100
extern unsigned long int APDU_Cmd_Lc(struct anonymous$13 *apdu)
{
  signed int c;
  unsigned long int res;
  c=APDU_Cmd_Case(apdu);
  if(c == 0x0001 || c == 0x0003 || c == 0x0103)
    res = (unsigned long int)0;

  else
    if(c == 0x0002 || c == 0x0004)
      res = (unsigned long int)apdu->command[(signed long int)4];

    else
      if(c == 0x0102 || c == 0x0104)
        res = (unsigned long int)apdu->command[(signed long int)5] << 8 | (unsigned long int)apdu->command[(signed long int)6];

      else
        res = (unsigned long int)0;
  return res;
}

// APDU_Cmd_Le
// file apdu.h line 103
extern unsigned long int APDU_Cmd_Le(struct anonymous$13 *apdu)
{
  signed int c;
  unsigned long int res;
  c=APDU_Cmd_Case(apdu);
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  unsigned long int tmp_if_expr$3;
  unsigned long int tmp_if_expr$4;
  if(c == 0x0001 || c == 0x0002 || c == 0x0102)
    res = (unsigned long int)0;

  else
    if(c == 0x0003)
    {
      if((signed int)apdu->command[4l] == 0)
        tmp_if_expr$1 = 256;

      else
        tmp_if_expr$1 = (signed int)apdu->command[(signed long int)4];
      res = (unsigned long int)tmp_if_expr$1;
    }

    else
      if(c == 0x0004)
      {
        if((signed int)apdu->command[-1l + (signed long int)apdu->length] == 0)
          tmp_if_expr$2 = 256;

        else
          tmp_if_expr$2 = (signed int)apdu->command[(signed long int)(apdu->length - (unsigned long int)1)];
        res = (unsigned long int)tmp_if_expr$2;
      }

      else
        if(c == 0x0103)
        {
          if(((unsigned long int)apdu->command[5l] << 8 | (unsigned long int)apdu->command[6l]) == 0ul)
            tmp_if_expr$3 = (unsigned long int)65536;

          else
            tmp_if_expr$3 = (unsigned long int)apdu->command[(signed long int)5] << 8 | (unsigned long int)apdu->command[(signed long int)6];
          res = tmp_if_expr$3;
        }

        else
          if(c == 0x0104)
          {
            if(((unsigned long int)apdu->command[-2l + (signed long int)apdu->length] << 8 | (unsigned long int)apdu->command[-1l + (signed long int)apdu->length]) == 0ul)
              tmp_if_expr$4 = (unsigned long int)65536;

            else
              tmp_if_expr$4 = (unsigned long int)apdu->command[(signed long int)(apdu->length - (unsigned long int)2)] << 8 | (unsigned long int)apdu->command[(signed long int)(apdu->length - (unsigned long int)1)];
            res = tmp_if_expr$4;
          }

          else
            res = (unsigned long int)0;
  return res;
}

// APDU_Cmd_Le_Available
// file apdu.c line 210
extern signed int APDU_Cmd_Le_Available(struct anonymous$13 *apdu)
{
  signed int c;
  signed int res;
  c=APDU_Cmd_Case(apdu);
  if(c == 0x0003)
    res = (signed int)((signed int)apdu->command[(signed long int)4] == 0);

  else
    if(c == 0x0004)
      res = (signed int)((signed int)apdu->command[(signed long int)(apdu->length - (unsigned long int)1)] == 0);

    else
      if(c == 0x0103)
        res = (signed int)(((unsigned long int)apdu->command[(signed long int)5] << 8 | (unsigned long int)apdu->command[(signed long int)6]) == (unsigned long int)0);

      else
        if(c == 0x0104)
          res = (signed int)(((unsigned long int)apdu->command[(signed long int)(apdu->length - (unsigned long int)2)] << 8 | (unsigned long int)apdu->command[(signed long int)(apdu->length - (unsigned long int)1)]) == (unsigned long int)0);

        else
          res = 0;
  return res;
}

// APDU_Cmd_New
// file apdu.h line 79
extern struct anonymous$13 * APDU_Cmd_New(unsigned char *data, unsigned long int length)
{
  struct anonymous$13 *apdu;
  if(length >= 65546ul)
    return (struct anonymous$13 *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$13) /*16ul*/ );
    apdu = (struct anonymous$13 *)return_value_malloc$1;
    if(!(apdu == ((struct anonymous$13 *)NULL)))
    {
      apdu->length = (unsigned long int)4 > length ? (unsigned long int)4 : length;
      void *return_value_calloc$2;
      return_value_calloc$2=calloc(apdu->length, sizeof(unsigned char) /*1ul*/ );
      apdu->command = (unsigned char *)return_value_calloc$2;
      if(!(apdu->command == ((unsigned char *)NULL)))
      {
        memcpy((void *)apdu->command, (const void *)data, length);
        if(!(length >= apdu->length))
          memset((void *)(apdu->command + (signed long int)length), 0, apdu->length - length);

      }

      else
      {
        free((void *)apdu);
        apdu = (struct anonymous$13 *)(void *)0;
      }
    }

    return apdu;
  }
}

// APDU_Cmd_P1
// file apdu.h line 94
extern unsigned char APDU_Cmd_P1(struct anonymous$13 *apdu)
{
  return apdu->command[(signed long int)2];
}

// APDU_Cmd_P2
// file apdu.h line 97
extern unsigned char APDU_Cmd_P2(struct anonymous$13 *apdu)
{
  return apdu->command[(signed long int)3];
}

// APDU_Cmd_Raw
// file apdu.h line 115
extern unsigned char * APDU_Cmd_Raw(struct anonymous$13 *apdu)
{
  return apdu->command;
}

// APDU_Cmd_RawLen
// file apdu.h line 118
extern unsigned long int APDU_Cmd_RawLen(struct anonymous$13 *apdu)
{
  return apdu->length;
}

// APDU_Rsp_AppendData
// file apdu.h line 148
extern signed int APDU_Rsp_AppendData(struct anonymous$14 *apdu1, struct anonymous$14 *apdu2)
{
  unsigned char *response;
  unsigned long int length;
  signed int ret;
  unsigned long int return_value_APDU_Rsp_DataLen$1;
  return_value_APDU_Rsp_DataLen$1=APDU_Rsp_DataLen(apdu1);
  unsigned long int return_value_APDU_Rsp_RawLen$2;
  return_value_APDU_Rsp_RawLen$2=APDU_Rsp_RawLen(apdu2);
  length = return_value_APDU_Rsp_DataLen$1 + return_value_APDU_Rsp_RawLen$2;
  if(length >= 3ul && !(length >= 65539ul))
  {
    void *return_value_realloc$3;
    return_value_realloc$3=realloc((void *)apdu1->response, length);
    response = (unsigned char *)return_value_realloc$3;
    if(!(response == ((unsigned char *)NULL)))
    {
      unsigned long int return_value_APDU_Rsp_DataLen$4;
      return_value_APDU_Rsp_DataLen$4=APDU_Rsp_DataLen(apdu1);
      unsigned char *return_value_APDU_Rsp_Raw$5;
      return_value_APDU_Rsp_Raw$5=APDU_Rsp_Raw(apdu2);
      unsigned long int return_value_APDU_Rsp_RawLen$6;
      return_value_APDU_Rsp_RawLen$6=APDU_Rsp_RawLen(apdu2);
      memcpy((void *)(response + (signed long int)return_value_APDU_Rsp_DataLen$4), (const void *)return_value_APDU_Rsp_Raw$5, return_value_APDU_Rsp_RawLen$6);
      apdu1->response = response;
      apdu1->length = length;
      ret = 0;
    }

    else
      ret = 5;
  }

  else
    ret = 5;
  return ret;
}

// APDU_Rsp_Data
// file apdu.c line 328
extern unsigned char * APDU_Rsp_Data(struct anonymous$14 *apdu)
{
  return apdu->response;
}

// APDU_Rsp_DataLen
// file apdu.h line 133
extern unsigned long int APDU_Rsp_DataLen(struct anonymous$14 *apdu)
{
  return apdu->length - (unsigned long int)2;
}

// APDU_Rsp_Delete
// file apdu.h line 124
extern void APDU_Rsp_Delete(struct anonymous$14 *apdu)
{
  free((void *)apdu->response);
  free((void *)apdu);
}

// APDU_Rsp_New
// file apdu.h line 121
extern struct anonymous$14 * APDU_Rsp_New(unsigned char *data, unsigned long int length)
{
  struct anonymous$14 *apdu;
  if(!(length >= 2ul))
    return (struct anonymous$14 *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$14) /*16ul*/ );
    apdu = (struct anonymous$14 *)return_value_malloc$1;
    if(!(apdu == ((struct anonymous$14 *)NULL)))
    {
      apdu->length = length;
      void *return_value_calloc$2;
      return_value_calloc$2=calloc(length, sizeof(unsigned char) /*1ul*/ );
      apdu->response = (unsigned char *)return_value_calloc$2;
      if(!(apdu->response == ((unsigned char *)NULL)))
        memcpy((void *)apdu->response, (const void *)data, length);

      else
      {
        free((void *)apdu);
        apdu = (struct anonymous$14 *)(void *)0;
      }
    }

    return apdu;
  }
}

// APDU_Rsp_Raw
// file apdu.c line 334
extern unsigned char * APDU_Rsp_Raw(struct anonymous$14 *apdu)
{
  return apdu->response;
}

// APDU_Rsp_RawLen
// file apdu.c line 340
extern unsigned long int APDU_Rsp_RawLen(struct anonymous$14 *apdu)
{
  return apdu->length;
}

// APDU_Rsp_SW1
// file apdu.h line 127
extern unsigned char APDU_Rsp_SW1(struct anonymous$14 *apdu)
{
  return apdu->response[(signed long int)(apdu->length - (unsigned long int)2)];
}

// APDU_Rsp_SW2
// file apdu.h line 130
extern unsigned char APDU_Rsp_SW2(struct anonymous$14 *apdu)
{
  return apdu->response[(signed long int)(apdu->length - (unsigned long int)1)];
}

// APDU_Rsp_TruncateData
// file apdu.c line 346
extern void APDU_Rsp_TruncateData(struct anonymous$14 *apdu, unsigned long int length)
{
  if(length >= 1ul)
  {
    if(!((signed long int)length >= -2l + (signed long int)apdu->length))
    {
      apdu->response[(signed long int)length]=APDU_Rsp_SW1(apdu);
      apdu->response[(signed long int)(length + (unsigned long int)1)]=APDU_Rsp_SW2(apdu);
      apdu->length = length + (unsigned long int)2;
    }

  }

}

// ATR_Delete
// file atr.c line 325
extern void ATR_Delete(struct anonymous$7 *atr)
{
  free((void *)atr);
}

// ATR_GetCheckByte
// file atr.c line 571
extern signed int ATR_GetCheckByte(struct anonymous$7 *atr, unsigned char *check_byte)
{
  if(atr->TCK.present == 0)
    return 1;

  else
  {
    *check_byte = atr->TCK.value;
    return 0;
  }
}

// ATR_GetConvention
// file atr.c line 331
extern signed int ATR_GetConvention(struct anonymous$7 *atr, signed int *convention)
{
  if((signed int)atr->TS == 0x3B)
    *convention = 0;

  else
    if((signed int)atr->TS == 0x3F)
      *convention = 1;

    else
      return 2;
  return 0;
}

// ATR_GetFsMax
// file atr.c line 581
extern signed int ATR_GetFsMax(struct anonymous$7 *atr, unsigned long int *fsmax)
{
  unsigned char FI;
  signed int return_value_ATR_GetIntegerValue$1;
  return_value_ATR_GetIntegerValue$1=ATR_GetIntegerValue(atr, 0, &FI);
  if(return_value_ATR_GetIntegerValue$1 == 0)
    *fsmax = atr_fs_table[(signed long int)FI];

  else
    *fsmax = atr_fs_table[(signed long int)1];
  return 0;
}

// ATR_GetHistoricalBytes
// file atr.c line 521
extern signed int ATR_GetHistoricalBytes(struct anonymous$7 *atr, unsigned char *hist, unsigned int *length)
{
  if(atr->hbn == 0u)
    return 1;

  else
  {
    *length = atr->hbn;
    memcpy((void *)hist, (const void *)atr->hb, (unsigned long int)atr->hbn);
    return 0;
  }
}

// ATR_GetIntegerValue
// file atr.c line 390
extern signed int ATR_GetIntegerValue(struct anonymous$7 *atr, signed int name, unsigned char *value)
{
  signed int ret;
  if(name == 0)
  {
    if(!(atr->ib[0l][0l].present == 0))
    {
      *value = (unsigned char)(((signed int)atr->ib[(signed long int)0][(signed long int)0].value & 0xF0) >> 4);
      ret = 0;
    }

    else
      ret = 1;
  }

  else
    if(name == 1)
    {
      if(!(atr->ib[0l][0l].present == 0))
      {
        *value = (unsigned char)((signed int)atr->ib[(signed long int)0][(signed long int)0].value & 0x0F);
        ret = 0;
      }

      else
        ret = 1;
    }

    else
      if(name == 2)
      {
        if(!(atr->ib[0l][1l].present == 0))
        {
          *value = (unsigned char)(((signed int)atr->ib[(signed long int)0][(signed long int)1].value & 0x60) >> 5);
          ret = 0;
        }

        else
          ret = 1;
      }

      else
        if(name == 3)
        {
          if(!(atr->ib[0l][1l].present == 0))
          {
            *value = (unsigned char)((signed int)atr->ib[(signed long int)0][(signed long int)1].value & 0x1F);
            ret = 0;
          }

          else
            ret = 1;
        }

        else
          if(name == 5)
          {
            if(!(atr->ib[1l][1l].present == 0))
            {
              *value = atr->ib[(signed long int)1][(signed long int)1].value;
              ret = 0;
            }

            else
              ret = 1;
          }

          else
            if(name == 4)
            {
              if(!(atr->ib[0l][2l].present == 0))
              {
                *value = atr->ib[(signed long int)0][(signed long int)2].value;
                ret = 0;
              }

              else
                ret = 1;
            }

            else
              ret = 1;
  return ret;
}

// ATR_GetInterfaceByte
// file atr.c line 372
extern signed int ATR_GetInterfaceByte(struct anonymous$7 *atr, unsigned int number, signed int character, unsigned char *value)
{
  if(!(atr->pn >= number) || !(number >= 1u))
    return 1;

  else
  {
    if(!(atr->ib[(signed long int)(4294967295u + number)][(signed long int)character].present == 0) && (character == 0 || character == 1 || character == 2 || character == 3))
    {
      *value = atr->ib[(signed long int)(number - (unsigned int)1)][(signed long int)character].value;
      goto __CPROVER_DUMP_L4;
    }

    return 1;

  __CPROVER_DUMP_L4:
    ;
    return 0;
  }
}

// ATR_GetNextByte
// file atr.c line 598
static signed int ATR_GetNextByte(struct anonymous$9 *io, unsigned int timeout, unsigned char *byte, signed int invert)
{
  signed int ret;
  ret=IO_Serial_Read(io, timeout, (unsigned int)1, byte);
  if(!(invert == 0))
    *byte = (unsigned char)~((signed int)*byte << 7 & 0x80 | (signed int)*byte << 5 & 0x40 | (signed int)*byte << 3 & 0x20 | (signed int)*byte << 1 & 0x10 | (signed int)*byte >> 1 & 0x08 | (signed int)*byte >> 3 & 0x04 | (signed int)*byte >> 5 & 0x02 | (signed int)*byte >> 7 & 0x01);

  return ret;
}

// ATR_GetNumberOfProtocols
// file atr.c line 350
extern signed int ATR_GetNumberOfProtocols(struct anonymous$7 *atr, unsigned int *number_protocols)
{
  *number_protocols = atr->pn;
  return 0;
}

// ATR_GetParameter
// file atr.c line 466
extern signed int ATR_GetParameter(struct anonymous$7 *atr, signed int name, double *parameter)
{
  unsigned char FI;
  unsigned char DI;
  unsigned char II;
  unsigned char PI1;
  unsigned char PI2;
  unsigned char N;
  signed int return_value_ATR_GetIntegerValue$4;
  if(name == 0)
  {
    signed int return_value_ATR_GetIntegerValue$1;
    return_value_ATR_GetIntegerValue$1=ATR_GetIntegerValue(atr, 0, &FI);
    if(return_value_ATR_GetIntegerValue$1 == 0)
      *parameter = (double)atr_f_table[(signed long int)FI];

    else
      *parameter = (double)372;
    return 0;
  }

  else
    if(name == 1)
    {
      signed int return_value_ATR_GetIntegerValue$2;
      return_value_ATR_GetIntegerValue$2=ATR_GetIntegerValue(atr, 1, &DI);
      if(return_value_ATR_GetIntegerValue$2 == 0)
        *parameter = (double)atr_d_table[(signed long int)DI];

      else
        *parameter = (double)1;
      return 0;
    }

    else
      if(name == 2)
      {
        signed int return_value_ATR_GetIntegerValue$3;
        return_value_ATR_GetIntegerValue$3=ATR_GetIntegerValue(atr, 2, &II);
        if(return_value_ATR_GetIntegerValue$3 == 0)
          *parameter = (double)atr_i_table[(signed long int)II];

        else
          *parameter = (double)50;
        return 0;
      }

      else
        if(name == 3)
        {
          signed int return_value_ATR_GetIntegerValue$5;
          return_value_ATR_GetIntegerValue$5=ATR_GetIntegerValue(atr, 5, &PI2);
          if(return_value_ATR_GetIntegerValue$5 == 0)
            *parameter = (double)PI2;

          else
          {
            return_value_ATR_GetIntegerValue$4=ATR_GetIntegerValue(atr, 3, &PI1);
            if(return_value_ATR_GetIntegerValue$4 == 0)
              *parameter = (double)PI1;

            else
              *parameter = (double)5;
          }
          return 0;
        }

        else
          if(name == 4)
          {
            signed int return_value_ATR_GetIntegerValue$6;
            return_value_ATR_GetIntegerValue$6=ATR_GetIntegerValue(atr, 4, &N);
            if(return_value_ATR_GetIntegerValue$6 == 0)
              *parameter = (double)N;

            else
              *parameter = (double)0;
            return 0;
          }

  return 1;
}

// ATR_GetProtocolType
// file atr.c line 357
extern signed int ATR_GetProtocolType(struct anonymous$7 *atr, unsigned int number_protocol, unsigned char *protocol_type)
{
  if(!(atr->pn >= number_protocol) || !(number_protocol >= 2u))
    return 1;

  else
  {
    if(!(atr->ib[(signed long int)(number_protocol + 4294967294u)][3l].present == 0))
      *protocol_type = (unsigned char)((signed int)atr->ib[(signed long int)(number_protocol - (unsigned int)2)][(signed long int)3].value & 0x0F);

    else
      *protocol_type = (unsigned char)0;
    return 0;
  }
}

// ATR_GetRaw
// file atr.c line 532
extern signed int ATR_GetRaw(struct anonymous$7 *atr, unsigned char *buffer, unsigned int *length)
{
  unsigned int i;
  unsigned int j;
  buffer[(signed long int)0] = atr->TS;
  buffer[(signed long int)1] = atr->T0;
  j = (unsigned int)2;
  i = (unsigned int)0;
  unsigned int tmp_post$1;
  unsigned int tmp_post$2;
  unsigned int tmp_post$3;
  unsigned int tmp_post$4;
  for( ; !(i >= atr->pn); i = i + 1u)
  {
    if(!(atr->ib[(signed long int)i][0l].present == 0))
    {
      tmp_post$1 = j;
      j = j + 1u;
      buffer[(signed long int)tmp_post$1] = atr->ib[(signed long int)i][(signed long int)0].value;
    }

    if(!(atr->ib[(signed long int)i][1l].present == 0))
    {
      tmp_post$2 = j;
      j = j + 1u;
      buffer[(signed long int)tmp_post$2] = atr->ib[(signed long int)i][(signed long int)1].value;
    }

    if(!(atr->ib[(signed long int)i][2l].present == 0))
    {
      tmp_post$3 = j;
      j = j + 1u;
      buffer[(signed long int)tmp_post$3] = atr->ib[(signed long int)i][(signed long int)2].value;
    }

    if(!(atr->ib[(signed long int)i][3l].present == 0))
    {
      tmp_post$4 = j;
      j = j + 1u;
      buffer[(signed long int)tmp_post$4] = atr->ib[(signed long int)i][(signed long int)3].value;
    }

  }
  if(atr->hbn >= 1u)
  {
    memcpy((void *)&buffer[(signed long int)j], (const void *)atr->hb, (unsigned long int)atr->hbn);
    j = j + atr->hbn;
  }

  unsigned int tmp_post$5;
  if(!(atr->TCK.present == 0))
  {
    tmp_post$5 = j;
    j = j + 1u;
    buffer[(signed long int)tmp_post$5] = atr->TCK.value;
  }

  *length = j;
  return 0;
}

// ATR_GetSize
// file atr.c line 343
extern signed int ATR_GetSize(struct anonymous$7 *atr, unsigned int *size)
{
  *size = atr->length;
  return 0;
}

// ATR_InitFromArray
// file atr.c line 90
extern signed int ATR_InitFromArray(struct anonymous$7 *atr, unsigned char *atr_buffer, unsigned int length)
{
  unsigned char TDi;
  unsigned char buffer[33l];
  unsigned int pointer = (unsigned int)0;
  unsigned int pn = (unsigned int)0;
  if(!(length >= 2u))
    return 2;

  else
  {
    if((signed int)*atr_buffer == 0x03)
    {
      pointer = (unsigned int)0;
      for( ; !(pointer >= length); pointer = pointer + 1u)
        buffer[(signed long int)pointer] = (unsigned char)~((signed int)atr_buffer[(signed long int)pointer] << 7 & 0x80 | (signed int)atr_buffer[(signed long int)pointer] << 5 & 0x40 | (signed int)atr_buffer[(signed long int)pointer] << 3 & 0x20 | (signed int)atr_buffer[(signed long int)pointer] << 1 & 0x10 | (signed int)atr_buffer[(signed long int)pointer] >> 1 & 0x08 | (signed int)atr_buffer[(signed long int)pointer] >> 3 & 0x04 | (signed int)atr_buffer[(signed long int)pointer] >> 5 & 0x02 | (signed int)atr_buffer[(signed long int)pointer] >> 7 & 0x01);
    }

    else
      memcpy((void *)buffer, (const void *)atr_buffer, (unsigned long int)length);
    atr->TS = buffer[(signed long int)0];
    TDi = buffer[(signed long int)1];
    atr->T0 = TDi;
    pointer = (unsigned int)1;
    atr->hbn = (unsigned int)((signed int)TDi & 0x0F);
    atr->TCK.present = 0;
    while(!(pointer >= length))
    {
      if(atr_num_ib_table[(signed long int)((0xF0 & (signed int)TDi) >> 4)] + pointer >= length)
        return 2;

      if((0xEF | (signed int)TDi) == 0xFF)
      {
        pointer = pointer + 1u;
        atr->ib[(signed long int)pn][(signed long int)0].value = buffer[(signed long int)pointer];
        atr->ib[(signed long int)pn][(signed long int)0].present = 1;
      }

      else
        atr->ib[(signed long int)pn][(signed long int)0].present = 0;
      if((0xDF | (signed int)TDi) == 0xFF)
      {
        pointer = pointer + 1u;
        atr->ib[(signed long int)pn][(signed long int)1].value = buffer[(signed long int)pointer];
        atr->ib[(signed long int)pn][(signed long int)1].present = 1;
      }

      else
        atr->ib[(signed long int)pn][(signed long int)1].present = 0;
      if((0xBF | (signed int)TDi) == 0xFF)
      {
        pointer = pointer + 1u;
        atr->ib[(signed long int)pn][(signed long int)2].value = buffer[(signed long int)pointer];
        atr->ib[(signed long int)pn][(signed long int)2].present = 1;
      }

      else
        atr->ib[(signed long int)pn][(signed long int)2].present = 0;
      if((0x7F | (signed int)TDi) == 0xFF)
      {
        pointer = pointer + 1u;
        atr->ib[(signed long int)pn][(signed long int)3].value = buffer[(signed long int)pointer];
        TDi = atr->ib[(signed long int)pn][(signed long int)3].value;
        atr->ib[(signed long int)pn][(signed long int)3].present = 1;
        atr->TCK.present = (signed int)(((signed int)TDi & 0x0F) != 0);
        if(pn >= 7u)
          return 2;

        pn = pn + 1u;
      }

      else
      {
        atr->ib[(signed long int)pn][(signed long int)3].present = 0;
        break;
      }
    }
    atr->pn = pn + (unsigned int)1;
    if(atr->hbn + pointer >= length)
      return 2;

    else
    {
      memcpy((void *)atr->hb, (const void *)(buffer + (signed long int)pointer + (signed long int)1), (unsigned long int)atr->hbn);
      pointer = pointer + atr->hbn;
      if(!(atr->TCK.present == 0))
      {
        if(1u + pointer >= length)
          return 2;

        pointer = pointer + 1u;
        atr->TCK.value = buffer[(signed long int)pointer];
      }

      atr->length = pointer + (unsigned int)1;
      return 0;
    }
  }
}

// ATR_InitFromStream
// file atr.c line 203
extern signed int ATR_InitFromStream(struct anonymous$7 *atr, struct anonymous$9 *io, unsigned int timeout)
{
  unsigned char TDi;
  unsigned int pointer = (unsigned int)0;
  unsigned int pn = (unsigned int)0;
  unsigned int i;
  signed int invert = 0;
  signed int return_value_ATR_GetNextByte$1;
  return_value_ATR_GetNextByte$1=ATR_GetNextByte(io, timeout, &atr->TS, invert);
  signed int return_value_ATR_GetNextByte$7;
  if(return_value_ATR_GetNextByte$1 == 0)
    return 3;

  else
  {
    if((signed int)atr->TS == 0x03)
    {
      atr->TS = (unsigned char)0x3F;
      invert = 1;
    }

    if(!((signed int)atr->TS == 0x3B))
    {
      if((signed int)atr->TS == 0x3F)
        goto __CPROVER_DUMP_L3;

      return 2;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_ATR_GetNextByte$2;
      return_value_ATR_GetNextByte$2=ATR_GetNextByte(io, timeout, &atr->T0, invert);
      if(return_value_ATR_GetNextByte$2 == 0)
        return 2;

      else
      {
        TDi = atr->T0;
        pointer = (unsigned int)1;
        atr->hbn = (unsigned int)((signed int)TDi & 0x0F);
        atr->TCK.present = 0;
        while((_Bool)1)
        {
          if((0xEF | (signed int)TDi) == 0xFF)
          {
            pointer = pointer + 1u;
            signed int return_value_ATR_GetNextByte$3;
            return_value_ATR_GetNextByte$3=ATR_GetNextByte(io, timeout, &atr->ib[(signed long int)pn][(signed long int)0].value, invert);
            if(return_value_ATR_GetNextByte$3 == 0)
              return 2;

            atr->ib[(signed long int)pn][(signed long int)0].present = 1;
          }

          else
            atr->ib[(signed long int)pn][(signed long int)0].present = 0;
          if((0xDF | (signed int)TDi) == 0xFF)
          {
            pointer = pointer + 1u;
            signed int return_value_ATR_GetNextByte$4;
            return_value_ATR_GetNextByte$4=ATR_GetNextByte(io, timeout, &atr->ib[(signed long int)pn][(signed long int)1].value, invert);
            if(return_value_ATR_GetNextByte$4 == 0)
              return 2;

            atr->ib[(signed long int)pn][(signed long int)1].present = 1;
          }

          else
            atr->ib[(signed long int)pn][(signed long int)1].present = 0;
          if((0xBF | (signed int)TDi) == 0xFF)
          {
            pointer = pointer + 1u;
            signed int return_value_ATR_GetNextByte$5;
            return_value_ATR_GetNextByte$5=ATR_GetNextByte(io, timeout, &atr->ib[(signed long int)pn][(signed long int)2].value, invert);
            if(return_value_ATR_GetNextByte$5 == 0)
              return 2;

            atr->ib[(signed long int)pn][(signed long int)2].present = 1;
          }

          else
            atr->ib[(signed long int)pn][(signed long int)2].present = 0;
          if((0x7F | (signed int)TDi) == 0xFF)
          {
            pointer = pointer + 1u;
            signed int return_value_ATR_GetNextByte$6;
            return_value_ATR_GetNextByte$6=ATR_GetNextByte(io, timeout, &atr->ib[(signed long int)pn][(signed long int)3].value, invert);
            if(return_value_ATR_GetNextByte$6 == 0)
              return 2;

            TDi = atr->ib[(signed long int)pn][(signed long int)3].value;
            atr->ib[(signed long int)pn][(signed long int)3].present = 1;
            atr->TCK.present = (signed int)(((signed int)TDi & 0x0F) != 0);
            if(pn >= 7u)
              return 2;

            pn = pn + 1u;
          }

          else
          {
            atr->ib[(signed long int)pn][(signed long int)3].present = 0;
            break;
          }
        }
        atr->pn = pn + (unsigned int)1;
        i = (unsigned int)0;
        for( ; !(i >= atr->hbn); i = i + 1u)
        {
          return_value_ATR_GetNextByte$7=ATR_GetNextByte(io, timeout, &atr->hb[(signed long int)i], invert);
          if(return_value_ATR_GetNextByte$7 == 0)
            return 2;

        }
        pointer = pointer + atr->hbn;
        if(!(atr->TCK.present == 0))
        {
          pointer = pointer + 1u;
          signed int return_value_ATR_GetNextByte$8;
          return_value_ATR_GetNextByte$8=ATR_GetNextByte(io, timeout, &atr->TCK.value, invert);
          if(return_value_ATR_GetNextByte$8 == 0)
            return 2;

        }

        atr->length = pointer + (unsigned int)1;
        return 0;
      }
    }
  }
}

// ATR_New
// file atr.c line 79
extern struct anonymous$7 * ATR_New(void)
{
  struct anonymous$7 *atr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$7) /*264ul*/ );
  atr = (struct anonymous$7 *)return_value_malloc$1;
  return atr;
}

// ATR_Sync_Delete
// file atr_sync.h line 106
extern void ATR_Sync_Delete(struct anonymous$19 *atr)
{
  free((void *)atr);
}

// ATR_Sync_GetCategoryIndicator
// file atr_sync.h line 100
extern unsigned char ATR_Sync_GetCategoryIndicator(struct anonymous$19 *atr)
{
  return atr->H3;
}

// ATR_Sync_GetDirDataReference
// file atr_sync.h line 102
extern unsigned char ATR_Sync_GetDirDataReference(struct anonymous$19 *atr)
{
  return atr->H4;
}

// ATR_Sync_GetHistoricalBytes
// file atr_sync.c line 134
extern void ATR_Sync_GetHistoricalBytes(struct anonymous$19 *atr, unsigned char *buffer, unsigned int *length)
{
  buffer[(signed long int)0] = atr->H3;
  buffer[(signed long int)1] = atr->H4;
  *length = (unsigned int)2;
}

// ATR_Sync_GetLengthOfDataUnits
// file atr_sync.h line 94
extern unsigned int ATR_Sync_GetLengthOfDataUnits(struct anonymous$19 *atr)
{
  unsigned int exp;
  unsigned int ret;
  unsigned int i;
  exp = (unsigned int)((signed int)atr->H2 & 0x07);
  ret = (unsigned int)1;
  i = (unsigned int)0;
  for( ; !(i >= exp); i = i + 1u)
    ret = ret * (unsigned int)2;
  return ret;
}

// ATR_Sync_GetNumberOfDataUnits
// file atr_sync.h line 92
extern unsigned int ATR_Sync_GetNumberOfDataUnits(struct anonymous$19 *atr)
{
  unsigned int exp;
  unsigned int ret;
  unsigned int i;
  exp = (unsigned int)((signed int)atr->H2 >> 3 & 0x0F);
  if(exp == 0u)
    return (unsigned int)0;

  else
  {
    ret = (unsigned int)64;
    i = (unsigned int)0;
    for( ; !(i >= exp); i = i + 1u)
      ret = ret * (unsigned int)2;
    return ret;
  }
}

// ATR_Sync_GetProtocolParameter
// file atr_sync.c line 87
extern unsigned char ATR_Sync_GetProtocolParameter(struct anonymous$19 *atr)
{
  return atr->H2;
}

// ATR_Sync_GetProtocolType
// file atr_sync.h line 86
extern unsigned char ATR_Sync_GetProtocolType(struct anonymous$19 *atr)
{
  return (unsigned char)((signed int)atr->H1 >> 4 & 0x0F);
}

// ATR_Sync_GetRaw
// file atr_sync.c line 154
extern void ATR_Sync_GetRaw(struct anonymous$19 *atr, unsigned char *buffer, unsigned int *length)
{
  buffer[(signed long int)0] = atr->H1;
  buffer[(signed long int)1] = atr->H2;
  buffer[(signed long int)2] = atr->H3;
  buffer[(signed long int)3] = atr->H4;
  *length = (unsigned int)4;
}

// ATR_Sync_GetReadToEnd
// file atr_sync.c line 128
extern signed int ATR_Sync_GetReadToEnd(struct anonymous$19 *atr)
{
  return (signed int)(((signed int)atr->H2 & 0x80) == 0x00);
}

// ATR_Sync_GetStructureID
// file atr_sync.c line 81
extern unsigned char ATR_Sync_GetStructureID(struct anonymous$19 *atr)
{
  return (unsigned char)((signed int)atr->H1 & 0x07);
}

// ATR_Sync_Init
// file atr_sync.h line 84
extern signed int ATR_Sync_Init(struct anonymous$19 *atr, unsigned char *buffer, unsigned int length)
{
  signed int ret;
  if(!(length >= 4u))
    return 2;

  else
  {
    atr->H1 = buffer[(signed long int)0];
    atr->H2 = buffer[(signed long int)1];
    atr->H3 = buffer[(signed long int)2];
    atr->H4 = buffer[(signed long int)3];
    if((0x03 & (signed int)*buffer) == 0x02)
    {
      if((signed int)buffer[2l] == 0x10)
        ret = 0;

      else
        ret = 2;
    }

    else
      ret = 1;
    return ret;
  }
}

// ATR_Sync_New
// file atr_sync.h line 82
extern struct anonymous$19 * ATR_Sync_New(void)
{
  struct anonymous$19 *atr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$19) /*4ul*/ );
  atr = (struct anonymous$19 *)return_value_malloc$1;
  if(!(atr == ((struct anonymous$19 *)NULL)))
  {
    atr->H1 = (unsigned char)0x00;
    atr->H2 = (unsigned char)0x00;
    atr->H3 = (unsigned char)0x00;
    atr->H4 = (unsigned char)0x00;
  }

  return atr;
}

// CT_List_AddCardTerminal
// file ct_list.c line 46
extern signed int CT_List_AddCardTerminal(struct anonymous$21 *list, struct anonymous$3 *ct, unsigned short int ctn)
{
  struct CT_List_Node *node;
  if(list == ((struct anonymous$21 *)NULL))
    return 0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct CT_List_Node) /*24ul*/ );
    node = (struct CT_List_Node *)return_value_malloc$1;
    if(!(node == ((struct CT_List_Node *)NULL)))
    {
      node->ct = ct;
      node->ctn = ctn;
      node->next = (struct CT_List_Node *)(void *)0;
      if(list->first == ((struct CT_List_Node *)NULL))
      {
        list->first = node;
        list->last = node;
      }

      else
      {
        list->last->next = node;
        list->last = node;
      }
      list->elements = list->elements + 1;
    }

    return (signed int)(node != (struct CT_List_Node *)(void *)0);
  }
}

// CT_List_Delete
// file ct_list.c line 143
extern void CT_List_Delete(struct anonymous$21 *list)
{
  struct CT_List_Node *node;
  if(!(list == ((struct anonymous$21 *)NULL)))
  {
    while(!(list->first == ((struct CT_List_Node *)NULL)))
    {
      node = list->first;
      list->first = list->first->next;
      CardTerminal_Delete(node->ct);
      free((void *)node);
    }
    free((void *)list);
  }

}

// CT_List_GetCardTerminal
// file ct_list.c line 76
extern struct anonymous$3 * CT_List_GetCardTerminal(struct anonymous$21 *list, unsigned short int ctn)
{
  struct CT_List_Node *node;
  struct anonymous$3 *ct = (struct anonymous$3 *)(void *)0;
  if(list == ((struct anonymous$21 *)NULL))
    return (struct anonymous$3 *)(void *)0;

  else
  {
    node = list->first;
    for( ; ct == ((struct anonymous$3 *)NULL) && !(node == ((struct CT_List_Node *)NULL)); node = node->next)
      if(node->ctn == ctn)
        ct = node->ct;

    return ct;
  }
}

// CT_List_GetNumberOfElements
// file ct_list.c line 92
extern signed int CT_List_GetNumberOfElements(struct anonymous$21 *list)
{
  if(list == ((struct anonymous$21 *)NULL))
    return 0;

  else
    return list->elements;
}

// CT_List_New
// file ct_list.c line 31
extern struct anonymous$21 * CT_List_New(void)
{
  struct anonymous$21 *aux;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$21) /*24ul*/ );
  aux = (struct anonymous$21 *)return_value_malloc$1;
  if(!(aux == ((struct anonymous$21 *)NULL)))
  {
    aux->first = (struct CT_List_Node *)(void *)0;
    aux->last = (struct CT_List_Node *)(void *)0;
    aux->elements = 0;
  }

  return aux;
}

// CT_List_RemoveCardTerminal
// file ct_list.c line 101
extern signed int CT_List_RemoveCardTerminal(struct anonymous$21 *list, unsigned short int ctn)
{
  struct CT_List_Node *current;
  struct CT_List_Node *previous;
  signed int found;
  if(list == ((struct anonymous$21 *)NULL))
    return 0;

  else
  {
    previous = (struct CT_List_Node *)(void *)0;
    current = list->first;
    found = 0;
    while(found == 0 && !(current == ((struct CT_List_Node *)NULL)))
      if(current->ctn == ctn)
        found = 1;

      else
      {
        previous = current;
        current = current->next;
      }
    if(!(found == 0))
    {
      if(current == list->first)
        list->first = current->next;

      else
        previous->next = current->next;
      if(current == list->last)
        list->last = previous;

      CardTerminal_Delete(current->ct);
      free((void *)current);
      list->elements = list->elements - 1;
    }

    return found;
  }
}

// CT_Slot_Check
// file ct_slot.h line 72
extern char CT_Slot_Check(struct anonymous$2 *slot, signed int timeout, signed int *card, signed int *change)
{
  unsigned char status;
  struct timespec req_ts;
  req_ts.tv_sec = (signed long int)1;
  req_ts.tv_nsec = (signed long int)0;
  signed int return_value_IFD_Towitoko_GetStatus$1;
  return_value_IFD_Towitoko_GetStatus$1=IFD_Towitoko_GetStatus(slot->ifd, &status);
  if(!(return_value_IFD_Towitoko_GetStatus$1 == 0))
    return (char)-10;

  else
  {
    *change = (signed int)(((signed int)status & 0x80) == 0x80);
    while(timeout >= 1 && !((0x40 & (signed int)status) == 0x40))
    {
      timeout = timeout - 1;
      nanosleep(&req_ts, (struct timespec *)(void *)0);
      signed int return_value_IFD_Towitoko_GetStatus$2;
      return_value_IFD_Towitoko_GetStatus$2=IFD_Towitoko_GetStatus(slot->ifd, &status);
      if(!(return_value_IFD_Towitoko_GetStatus$2 == 0))
        return (char)-10;

      *change = *change | (signed int)(((signed int)status & 0x80) == 0x80);
    }
    *card = (signed int)(((signed int)status & 0x40) == 0x40);
    return (char)0;
  }
}

// CT_Slot_Clear
// file ct_slot.c line 505
static void CT_Slot_Clear(struct anonymous$2 *slot)
{
  slot->ifd = (struct anonymous$6 *)(void *)0;
  slot->icc = (void *)0;
  slot->protocol = (void *)0;
  slot->icc_type = -1;
  slot->protocol_type = -1;
}

// CT_Slot_Close
// file ct_slot.h line 108
extern char CT_Slot_Close(struct anonymous$2 *slot)
{
  char ret = (char)0;
  if(slot->protocol_type == 16)
  {
    signed int return_value_Protocol_Sync_Close$1;
    return_value_Protocol_Sync_Close$1=Protocol_Sync_Close((struct anonymous *)slot->protocol);
    if(!(return_value_Protocol_Sync_Close$1 == 0))
      ret = (char)-10;

    Protocol_Sync_Delete((struct anonymous *)slot->protocol);
  }

  else
    if(slot->protocol_type == 0)
    {
      signed int return_value_Protocol_T0_Close$2;
      return_value_Protocol_T0_Close$2=Protocol_T0_Close((struct anonymous$11 *)slot->protocol);
      if(!(return_value_Protocol_T0_Close$2 == 0))
        ret = (char)-10;

      Protocol_T0_Delete((struct anonymous$11 *)slot->protocol);
    }

    else
      if(slot->protocol_type == 1)
      {
        signed int return_value_Protocol_T1_Close$3;
        return_value_Protocol_T1_Close$3=Protocol_T1_Close((struct anonymous$18 *)slot->protocol);
        if(!(return_value_Protocol_T1_Close$3 == 0))
          ret = (char)-10;

        Protocol_T1_Delete((struct anonymous$18 *)slot->protocol);
      }

  if(slot->icc_type == 1)
  {
    signed int return_value_ICC_Sync_Close$4;
    return_value_ICC_Sync_Close$4=ICC_Sync_Close((struct anonymous$22 *)slot->icc);
    if(!(return_value_ICC_Sync_Close$4 == 0))
      ret = (char)-10;

    ICC_Sync_Delete((struct anonymous$22 *)slot->icc);
  }

  else
    if(slot->icc_type == 0)
    {
      signed int return_value_ICC_Async_Close$5;
      return_value_ICC_Async_Close$5=ICC_Async_Close((struct anonymous$5 *)slot->icc);
      if(!(return_value_ICC_Async_Close$5 == 0))
        ret = (char)-10;

      ICC_Async_Delete((struct anonymous$5 *)slot->icc);
    }

  if(!(slot->ifd == ((struct anonymous$6 *)NULL)))
  {
    signed int return_value_IFD_Towitoko_Close$6;
    return_value_IFD_Towitoko_Close$6=IFD_Towitoko_Close(slot->ifd);
    if(!(return_value_IFD_Towitoko_Close$6 == 0))
      ret = (char)-10;

    IFD_Towitoko_Delete(slot->ifd);
  }

  CT_Slot_Clear(slot);
  return ret;
}

// CT_Slot_Command
// file ct_slot.c line 345
extern char CT_Slot_Command(struct anonymous$2 *slot, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[2l];
  char ret;
  if(slot->protocol_type == 16)
  {
    signed int return_value_Protocol_Sync_Command$1;
    return_value_Protocol_Sync_Command$1=Protocol_Sync_Command((struct anonymous *)slot->protocol, cmd, rsp);
    if(!(return_value_Protocol_Sync_Command$1 == 0))
      ret = (char)-10;

    else
      ret = (char)0;
  }

  else
    if(slot->protocol_type == 0)
    {
      signed int return_value_Protocol_T0_Command$2;
      return_value_Protocol_T0_Command$2=Protocol_T0_Command((struct anonymous$11 *)slot->protocol, cmd, rsp);
      if(!(return_value_Protocol_T0_Command$2 == 0))
        ret = (char)-10;

      else
        ret = (char)0;
    }

    else
      if(slot->protocol_type == 1)
      {
        signed int return_value_Protocol_T1_Command$3;
        return_value_Protocol_T1_Command$3=Protocol_T1_Command((struct anonymous$18 *)slot->protocol, cmd, rsp);
        if(!(return_value_Protocol_T1_Command$3 == 0))
          ret = (char)-10;

        else
          ret = (char)0;
      }

      else
        if(slot->protocol_type == -1)
        {
          buffer[(signed long int)0] = (unsigned char)0x6F;
          buffer[(signed long int)1] = (unsigned char)0x00;
          *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
          ret = (char)0;
        }

        else
        {
          *rsp = (struct anonymous$14 *)(void *)0;
          ret = (char)-128;
        }
  return ret;
}

// CT_Slot_Delete
// file ct_slot.h line 112
extern void CT_Slot_Delete(struct anonymous$2 *slot)
{
  free((void *)slot);
}

// CT_Slot_GetAtr
// file ct_slot.h line 96
extern void * CT_Slot_GetAtr(struct anonymous$2 *slot)
{
  struct anonymous$7 *return_value_ICC_Async_GetAtr$1;
  struct anonymous$19 *return_value_ICC_Sync_GetAtr$2;
  if(slot->icc_type == 0)
  {
    return_value_ICC_Async_GetAtr$1=ICC_Async_GetAtr((struct anonymous$5 *)slot->icc);
    return (void *)return_value_ICC_Async_GetAtr$1;
  }

  else
    if(slot->icc_type == 1)
    {
      return_value_ICC_Sync_GetAtr$2=ICC_Sync_GetAtr((struct anonymous$22 *)slot->icc);
      return (void *)return_value_ICC_Sync_GetAtr$2;
    }

  return (void *)0;
}

// CT_Slot_GetICC
// file ct_slot.c line 404
extern void * CT_Slot_GetICC(struct anonymous$2 *slot)
{
  return slot->icc;
}

// CT_Slot_GetICCType
// file ct_slot.h line 88
extern signed int CT_Slot_GetICCType(struct anonymous$2 *slot)
{
  return slot->icc_type;
}

// CT_Slot_GetType
// file ct_slot.h line 104
extern void CT_Slot_GetType(struct anonymous$2 *slot, unsigned char *buffer, signed int len)
{
  IFD_Towitoko_GetDescription(slot->ifd, buffer, (unsigned int)len);
}

// CT_Slot_Init
// file ct_slot.h line 68
extern char CT_Slot_Init(struct anonymous$2 *slot, struct anonymous$9 *io, signed int sn)
{
  slot->ifd=IFD_Towitoko_New();
  if(slot->ifd == ((struct anonymous$6 *)NULL))
    return (char)-11;

  else
  {
    signed int return_value_IFD_Towitoko_Init$1;
    return_value_IFD_Towitoko_Init$1=IFD_Towitoko_Init(slot->ifd, io, (unsigned char)sn);
    if(!(return_value_IFD_Towitoko_Init$1 == 0))
    {
      IFD_Towitoko_Delete(slot->ifd);
      slot->ifd = (struct anonymous$6 *)(void *)0;
      return (char)-10;
    }

    else
      return (char)0;
  }
}

// CT_Slot_IsLast
// file ct_slot.h line 100
extern signed int CT_Slot_IsLast(struct anonymous$2 *slot)
{
  unsigned char return_value_IFD_Towitoko_GetSlot$1;
  return_value_IFD_Towitoko_GetSlot$1=IFD_Towitoko_GetSlot(slot->ifd);
  unsigned int return_value_IFD_Towitoko_GetNumSlots$2;
  return_value_IFD_Towitoko_GetNumSlots$2=IFD_Towitoko_GetNumSlots(slot->ifd);
  return (signed int)((unsigned int)return_value_IFD_Towitoko_GetSlot$1 >= return_value_IFD_Towitoko_GetNumSlots$2 - (unsigned int)1);
}

// CT_Slot_New
// file ct_slot.h line 64
extern struct anonymous$2 * CT_Slot_New()
{
  struct anonymous$2 *slot;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*32ul*/ );
  slot = (struct anonymous$2 *)return_value_malloc$1;
  if(!(slot == ((struct anonymous$2 *)NULL)))
    CT_Slot_Clear(slot);

  return slot;
}

// CT_Slot_Probe
// file ct_slot.h line 76
extern char CT_Slot_Probe(struct anonymous$2 *slot, unsigned char *userdata, unsigned int length)
{
  struct anonymous$0 *pps;
  unsigned char buffer[6l];
  unsigned int buffer_len = (unsigned int)0;
  struct anonymous$22 *return_value_ICC_Sync_New$1;
  return_value_ICC_Sync_New$1=ICC_Sync_New();
  slot->icc = (void *)return_value_ICC_Sync_New$1;
  if(slot->icc == NULL)
    return (char)-11;

  else
  {
    signed int return_value_ICC_Sync_Init$4;
    return_value_ICC_Sync_Init$4=ICC_Sync_Init((struct anonymous$22 *)slot->icc, slot->ifd);
    if(!(return_value_ICC_Sync_Init$4 == 0))
    {
      ICC_Sync_Delete((struct anonymous$22 *)slot->icc);
      struct anonymous$5 *return_value_ICC_Async_New$2;
      return_value_ICC_Async_New$2=ICC_Async_New();
      slot->icc = (void *)return_value_ICC_Async_New$2;
      if(slot->icc == NULL)
        return (char)-11;

      signed int return_value_ICC_Async_Init$3;
      return_value_ICC_Async_Init$3=ICC_Async_Init((struct anonymous$5 *)slot->icc, slot->ifd);
      if(!(return_value_ICC_Async_Init$3 == 0))
      {
        ICC_Async_Delete((struct anonymous$5 *)slot->icc);
        slot->icc = (void *)0;
        slot->icc_type = -1;
        return (char)0;
      }

      slot->icc_type = 0;
    }

    else
      slot->icc_type = 1;
    if(slot->icc_type == 0)
    {
      pps=PPS_New((struct anonymous$5 *)slot->icc);
      if(pps == ((struct anonymous$0 *)NULL))
      {
        ICC_Async_Close((struct anonymous$5 *)slot->icc);
        ICC_Async_Delete((struct anonymous$5 *)slot->icc);
        slot->icc = (void *)0;
        slot->icc_type = -1;
        return (char)-11;
      }

      if(length >= 1u && !(userdata == ((unsigned char *)NULL)))
      {
        buffer_len = length < (unsigned int)6 ? length : (unsigned int)6;
        memcpy((void *)buffer, (const void *)userdata, (unsigned long int)buffer_len);
      }

      signed int return_value_PPS_Perform$5;
      return_value_PPS_Perform$5=PPS_Perform(pps, buffer, &buffer_len);
      if(!(return_value_PPS_Perform$5 == 0))
      {
        PPS_Delete(pps);
        ICC_Async_Close((struct anonymous$5 *)slot->icc);
        ICC_Async_Delete((struct anonymous$5 *)slot->icc);
        slot->icc = (void *)0;
        slot->icc_type = -1;
        slot->protocol_type = -1;
        return (char)-10;
      }

      struct anonymous$12 *return_value_PPS_GetProtocolParameters$6;
      return_value_PPS_GetProtocolParameters$6=PPS_GetProtocolParameters(pps);
      slot->protocol_type = (signed int)return_value_PPS_GetProtocolParameters$6->t;
      slot->protocol=PPS_GetProtocol(pps);
      PPS_Delete(pps);
    }

    else
      if(slot->icc_type == 1)
      {
        struct anonymous *return_value_Protocol_Sync_New$7;
        return_value_Protocol_Sync_New$7=Protocol_Sync_New();
        slot->protocol = (void *)return_value_Protocol_Sync_New$7;
        if(slot->protocol == NULL)
        {
          ICC_Sync_Close((struct anonymous$22 *)slot->icc);
          ICC_Sync_Delete((struct anonymous$22 *)slot->icc);
          slot->icc = (void *)0;
          slot->icc_type = -1;
          return (char)-11;
        }

        signed int return_value_Protocol_Sync_Init$8;
        return_value_Protocol_Sync_Init$8=Protocol_Sync_Init((struct anonymous *)slot->protocol, (struct anonymous$22 *)slot->icc);
        if(!(return_value_Protocol_Sync_Init$8 == 0))
        {
          ICC_Sync_Close((struct anonymous$22 *)slot->icc);
          ICC_Sync_Delete((struct anonymous$22 *)slot->icc);
          slot->icc = (void *)0;
          slot->icc_type = -1;
          Protocol_Sync_Delete((struct anonymous *)slot->protocol);
          slot->protocol = (void *)0;
          slot->protocol_type = -1;
          return (char)-10;
        }

        slot->protocol_type = 16;
      }

    return (char)0;
  }
}

// CT_Slot_Release
// file ct_slot.h line 80
extern char CT_Slot_Release(struct anonymous$2 *slot)
{
  char ret = (char)0;
  if(slot->protocol_type == 16)
  {
    signed int return_value_Protocol_Sync_Close$1;
    return_value_Protocol_Sync_Close$1=Protocol_Sync_Close((struct anonymous *)slot->protocol);
    if(!(return_value_Protocol_Sync_Close$1 == 0))
      ret = (char)-10;

    Protocol_Sync_Delete((struct anonymous *)slot->protocol);
  }

  else
    if(slot->protocol_type == 0)
    {
      signed int return_value_Protocol_T0_Close$2;
      return_value_Protocol_T0_Close$2=Protocol_T0_Close((struct anonymous$11 *)slot->protocol);
      if(!(return_value_Protocol_T0_Close$2 == 0))
        ret = (char)-10;

      Protocol_T0_Delete((struct anonymous$11 *)slot->protocol);
    }

    else
      if(slot->protocol_type == 1)
      {
        signed int return_value_Protocol_T1_Close$3;
        return_value_Protocol_T1_Close$3=Protocol_T1_Close((struct anonymous$18 *)slot->protocol);
        if(!(return_value_Protocol_T1_Close$3 == 0))
          ret = (char)-10;

        Protocol_T1_Delete((struct anonymous$18 *)slot->protocol);
      }

  slot->protocol = (void *)0;
  slot->protocol_type = -1;
  if(slot->icc_type == 1)
  {
    signed int return_value_ICC_Sync_Close$4;
    return_value_ICC_Sync_Close$4=ICC_Sync_Close((struct anonymous$22 *)slot->icc);
    if(!(return_value_ICC_Sync_Close$4 == 0))
      ret = (char)-10;

    ICC_Sync_Delete((struct anonymous$22 *)slot->icc);
  }

  else
    if(slot->icc_type == 0)
    {
      signed int return_value_ICC_Async_Close$5;
      return_value_ICC_Async_Close$5=ICC_Async_Close((struct anonymous$5 *)slot->icc);
      if(!(return_value_ICC_Async_Close$5 == 0))
        ret = (char)-10;

      ICC_Async_Delete((struct anonymous$5 *)slot->icc);
    }

  slot->icc = (void *)0;
  slot->icc_type = -1;
  return ret;
}

// CT_close
// file ../../src/ct-api/ctapi.h line 25
char CT_close(unsigned short int ctn)
{
  struct anonymous$3 *ct;
  char ret;
  pthread_mutex_lock(&ct_list_mutex);
  ct=CT_List_GetCardTerminal(ct_list$link1, ctn);
  if(!(ct == ((struct anonymous$3 *)NULL)))
  {
    ret=CardTerminal_Close(ct);
    CT_List_RemoveCardTerminal(ct_list$link1, ctn);
    signed int return_value_CT_List_GetNumberOfElements$1;
    return_value_CT_List_GetNumberOfElements$1=CT_List_GetNumberOfElements(ct_list$link1);
    if(return_value_CT_List_GetNumberOfElements$1 == 0)
    {
      CT_List_Delete(ct_list$link1);
      ct_list$link1 = (struct anonymous$21 *)(void *)0;
    }

  }

  else
    ret = (char)-8;
  pthread_mutex_unlock(&ct_list_mutex);
  return ret;
}

// CT_data
// file ../../src/ct-api/ctapi.h line 29
char CT_data(unsigned short int ctn, unsigned char *dad, unsigned char *sad, unsigned short int lc, unsigned char *cmd, unsigned short int *lr, unsigned char *rsp)
{
  struct anonymous$3 *ct;
  struct anonymous$2 *slot;
  struct anonymous$13 *apdu_cmd;
  struct anonymous$14 *apdu_rsp = (struct anonymous$14 *)(void *)0;
  signed int remain;
  unsigned char aux;
  char ret;
  pthread_mutex_lock(&ct_list_mutex);
  ct=CT_List_GetCardTerminal(ct_list$link1, ctn);
  pthread_mutex_unlock(&ct_list_mutex);
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$7;
  unsigned long int return_value_APDU_Rsp_RawLen$6;
  signed int tmp_if_expr$10;
  unsigned long int return_value_APDU_Rsp_RawLen$9;
  if(!(ct == ((struct anonymous$3 *)NULL)))
  {
    apdu_cmd=APDU_Cmd_New(cmd, (unsigned long int)lc);
    if(!(apdu_cmd == ((struct anonymous$13 *)NULL)))
    {
      union anonymous$16 *return_value_CardTerminal_GetMutex$1;
      return_value_CardTerminal_GetMutex$1=CardTerminal_GetMutex(ct);
      pthread_mutex_lock(return_value_CardTerminal_GetMutex$1);
      if((signed int)*dad == 1)
      {
        ret=CardTerminal_Command(ct, apdu_cmd, &apdu_rsp);
        *sad = (unsigned char)1;
        *dad = *sad;
      }

      else
      {
        if((signed int)*dad == 0)
          tmp_if_expr$2 = 0;

        else
          tmp_if_expr$2 = (signed int)*dad - 1;
        slot=CardTerminal_GetSlot(ct, tmp_if_expr$2);
        if(!(slot == ((struct anonymous$2 *)NULL)))
        {
          ret=CT_Slot_Command(slot, apdu_cmd, &apdu_rsp);
          signed int return_value_CT_Slot_GetICCType$3;
          return_value_CT_Slot_GetICCType$3=CT_Slot_GetICCType(slot);
          if(!(return_value_CT_Slot_GetICCType$3 == -1))
          {
            aux = *sad;
            *sad = *dad;
            *dad = aux;
          }

          else
          {
            *dad = *sad;
            *sad = (unsigned char)1;
          }
        }

        else
        {
          *dad = *sad;
          *sad = (unsigned char)1;
          apdu_rsp = (struct anonymous$14 *)(void *)0;
          ret = (char)-1;
        }
      }
      union anonymous$16 *return_value_CardTerminal_GetMutex$4;
      return_value_CardTerminal_GetMutex$4=CardTerminal_GetMutex(ct);
      pthread_mutex_unlock(return_value_CardTerminal_GetMutex$4);
      if(!(apdu_rsp == ((struct anonymous$14 *)NULL)))
      {
        unsigned long int return_value_APDU_Rsp_RawLen$5;
        return_value_APDU_Rsp_RawLen$5=APDU_Rsp_RawLen(apdu_rsp);
        if((signed int)(signed short int)return_value_APDU_Rsp_RawLen$5 + -((signed int)*lr) >= 1)
        {
          return_value_APDU_Rsp_RawLen$6=APDU_Rsp_RawLen(apdu_rsp);
          tmp_if_expr$7 = (signed int)(signed short int)return_value_APDU_Rsp_RawLen$6 - (signed int)*lr;
        }

        else
          tmp_if_expr$7 = 0;
        remain = tmp_if_expr$7;
        if(remain >= 1)
          ret = (char)-11;

        unsigned long int return_value_APDU_Rsp_RawLen$8;
        return_value_APDU_Rsp_RawLen$8=APDU_Rsp_RawLen(apdu_rsp);
        if(!((signed int)*lr >= (signed int)(signed short int)return_value_APDU_Rsp_RawLen$8))
          tmp_if_expr$10 = (signed int)*lr;

        else
        {
          return_value_APDU_Rsp_RawLen$9=APDU_Rsp_RawLen(apdu_rsp);
          tmp_if_expr$10 = (signed int)(signed short int)return_value_APDU_Rsp_RawLen$9;
        }
        *lr = (unsigned short int)tmp_if_expr$10;
        unsigned char *return_value_APDU_Rsp_Raw$11;
        return_value_APDU_Rsp_Raw$11=APDU_Rsp_Raw(apdu_rsp);
        memcpy((void *)rsp, (const void *)(return_value_APDU_Rsp_Raw$11 + (signed long int)remain), (unsigned long int)*lr);
        APDU_Rsp_Delete(apdu_rsp);
      }

      else
        *lr = (unsigned short int)0;
      APDU_Cmd_Delete(apdu_cmd);
    }

    else
      ret = (char)-11;
  }

  else
    ret = (char)-8;
  return ret;
}

// CT_init
// file ../../src/ct-api/ctapi.h line 20
char CT_init(unsigned short int ctn, unsigned short int pn)
{
  struct anonymous$3 *ct;
  char ret;
  signed int ct_list_empty;
  pthread_mutex_lock(&ct_list_mutex);
  struct anonymous$3 *return_value_CT_List_GetCardTerminal$2;
  return_value_CT_List_GetCardTerminal$2=CT_List_GetCardTerminal(ct_list$link1, ctn);
  if(return_value_CT_List_GetCardTerminal$2 == ((struct anonymous$3 *)NULL))
  {
    ct=CardTerminal_New();
    if(!(ct == ((struct anonymous$3 *)NULL)))
    {
      ret=CardTerminal_Init(ct, pn);
      if((signed int)ret == 0)
      {
        ct_list_empty = (signed int)(ct_list$link1 == (struct anonymous$21 *)(void *)0);
        if(!(ct_list_empty == 0))
          ct_list$link1=CT_List_New();

        signed int return_value_CT_List_AddCardTerminal$1;
        return_value_CT_List_AddCardTerminal$1=CT_List_AddCardTerminal(ct_list$link1, ct, ctn);
        if(return_value_CT_List_AddCardTerminal$1 == 0)
        {
          CardTerminal_Close(ct);
          CardTerminal_Delete(ct);
          if(!(ct_list_empty == 0))
          {
            CT_List_Delete(ct_list$link1);
            ct_list$link1 = (struct anonymous$21 *)(void *)0;
          }

          ret = (char)-11;
        }

      }

      else
        CardTerminal_Delete(ct);
    }

    else
      ret = (char)-11;
  }

  else
    ret = (char)-8;
  pthread_mutex_unlock(&ct_list_mutex);
  return ret;
}

// CardTerminal_Clear
// file cardterminal.c line 879
static void CardTerminal_Clear(struct anonymous$3 *ct)
{
  signed int i;
  ct->io = (struct anonymous$9 *)(void *)0;
  ct->num_slots = 0;
  i = 0;
  for( ; !(i >= 2); i = i + 1)
    ct->slots[(signed long int)i] = (struct anonymous$2 *)(void *)0;
}

// CardTerminal_Close
// file cardterminal.c line 220
extern char CardTerminal_Close(struct anonymous$3 *ct)
{
  char ret;
  char aux;
  signed int i;
  ret = (char)0;
  i = 0;
  for( ; !(i >= ct->num_slots); i = i + 1)
    if(!(ct->slots[(signed long int)i] == ((struct anonymous$2 *)NULL)))
    {
      aux=CT_Slot_Close(ct->slots[(signed long int)i]);
      if(!((signed int)aux == 0))
        ret = aux;

      CT_Slot_Delete(ct->slots[(signed long int)i]);
    }

  if(!(ct->io == ((struct anonymous$9 *)NULL)))
  {
    signed int return_value_IO_Serial_Close$1;
    return_value_IO_Serial_Close$1=IO_Serial_Close(ct->io);
    if(return_value_IO_Serial_Close$1 == 0)
      ret = (char)-10;

    IO_Serial_Delete(ct->io);
  }

  CardTerminal_Clear(ct);
  pthread_mutex_destroy(&ct->mutex);
  return ret;
}

// CardTerminal_Command
// file cardterminal.c line 164
extern char CardTerminal_Command(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[2l];
  unsigned char cla;
  unsigned char ins;
  signed long int length;
  char ret;
  cla=APDU_Cmd_Cla(cmd);
  if(!((signed int)cla == 0x20))
  {
    length = (signed long int)2;
    buffer[(signed long int)0] = (unsigned char)0x6E;
    buffer[(signed long int)1] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)length);
    ret = (char)0;
  }

  else
  {
    ins=APDU_Cmd_Ins(cmd);
    if((signed int)ins == 0x11)
      ret=CardTerminal_ResetCT(ct, cmd, rsp);

    else
      if((signed int)ins == 0x12)
        ret=CardTerminal_RequestICC(ct, cmd, rsp);

      else
        if((signed int)ins == 0x13)
          ret=CardTerminal_GetStatus(ct, cmd, rsp);

        else
          if((signed int)ins == 0x15)
            ret=CardTerminal_EjectICC(ct, cmd, rsp);

          else
          {
            length = (signed long int)2;
            buffer[(signed long int)0] = (unsigned char)0x6D;
            buffer[(signed long int)1] = (unsigned char)0x00;
            *rsp=APDU_Rsp_New(buffer, (unsigned long int)length);
            ret = (char)0;
          }
  }
  return ret;
}

// CardTerminal_Delete
// file cardterminal.c line 256
extern void CardTerminal_Delete(struct anonymous$3 *ct)
{
  free((void *)ct);
}

// CardTerminal_EjectICC
// file cardterminal.c line 771
static char CardTerminal_EjectICC(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[2l];
  unsigned char p1;
  unsigned char p2;
  signed int sn;
  signed int timeout;
  unsigned int length;
  signed int card;
  signed int change;
  char ret;
  p1=APDU_Cmd_P1(cmd);
  unsigned char *return_value_APDU_Cmd_Data$2;
  if(!((signed int)p1 == 0x01) && !((signed int)p1 == 0x02))
  {
    buffer[(signed long int)0] = (unsigned char)0x6A;
    buffer[(signed long int)1] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
    return (char)0;
  }

  else
  {
    sn = (signed int)p1 == 0x01 ? 0 : 1;
    if(sn >= ct->num_slots)
    {
      buffer[(signed long int)0] = (unsigned char)0x6A;
      buffer[(signed long int)1] = (unsigned char)0x00;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return (char)-1;
    }

    else
    {
      p2=APDU_Cmd_P2(cmd);
      signed int return_value_CT_Slot_GetICCType$1;
      return_value_CT_Slot_GetICCType$1=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
      if(return_value_CT_Slot_GetICCType$1 == -1)
      {
        buffer[(signed long int)0] = (unsigned char)0x90;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return (char)0;
      }

      else
      {
        unsigned long int return_value_APDU_Cmd_Lc$3;
        return_value_APDU_Cmd_Lc$3=APDU_Cmd_Lc(cmd);
        if(return_value_APDU_Cmd_Lc$3 == 1ul)
        {
          return_value_APDU_Cmd_Data$2=APDU_Cmd_Data(cmd);
          timeout = (signed int)*return_value_APDU_Cmd_Data$2;
        }

        else
          timeout = 0;
        ret=CT_Slot_Check(ct->slots[(signed long int)sn], timeout, &card, &change);
        if(!((signed int)ret == 0))
        {
          *rsp = (struct anonymous$14 *)(void *)0;
          return ret;
        }

        else
        {
          ret=CT_Slot_Release(ct->slots[(signed long int)sn]);
          if(!((signed int)ret == 0))
          {
            *rsp = (struct anonymous$14 *)(void *)0;
            return ret;
          }

          else
          {
            if(!(timeout == 0))
            {
              if(!(card == 0))
              {
                buffer[(signed long int)0] = (unsigned char)0x62;
                buffer[(signed long int)1] = (unsigned char)0x00;
                length = (unsigned int)2;
              }

              else
              {
                buffer[(signed long int)0] = (unsigned char)0x90;
                buffer[(signed long int)1] = (unsigned char)0x01;
                length = (unsigned int)2;
              }
            }

            else
            {
              buffer[(signed long int)0] = (unsigned char)0x90;
              buffer[(signed long int)1] = (unsigned char)0x00;
              length = (unsigned int)2;
            }
            *rsp=APDU_Rsp_New(buffer, (unsigned long int)length);
            return ret;
          }
        }
      }
    }
  }
}

// CardTerminal_GetMutex
// file cardterminal.c line 272
extern union anonymous$16 * CardTerminal_GetMutex(struct anonymous$3 *ct)
{
  return &ct->mutex;
}

// CardTerminal_GetSlot
// file cardterminal.c line 262
extern struct anonymous$2 * CardTerminal_GetSlot(struct anonymous$3 *ct, signed int number)
{
  if(!(number >= ct->num_slots))
    return ct->slots[(signed long int)number];

  else
    return (struct anonymous$2 *)(void *)0;
}

// CardTerminal_GetStatus
// file cardterminal.c line 681
static char CardTerminal_GetStatus(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[19l];
  unsigned char p1;
  unsigned char p2;
  signed int card;
  signed int change;
  signed int i;
  unsigned int length;
  char ret = (char)0;
  p1=APDU_Cmd_P1(cmd);
  if(!((signed int)p1 == 0x00))
  {
    length = (unsigned int)2;
    buffer[(signed long int)0] = (unsigned char)0x6A;
    buffer[(signed long int)1] = (unsigned char)0x00;
    ret = (char)0;
  }

  p2=APDU_Cmd_P2(cmd);
  if((signed int)p2 == 0x46)
  {
    length = (unsigned int)17;
    memcpy((void *)buffer, (const void *)"DETWK", (unsigned long int)5);
    if(!(ct->slots[0l] == ((struct anonymous$2 *)NULL)))
      CT_Slot_GetType(ct->slots[(signed long int)0], buffer + (signed long int)5, 5);

    memcpy((void *)(buffer + (signed long int)10), (const void *)"2.0.7", (unsigned long int)5);
    buffer[(signed long int)15] = (unsigned char)0x90;
    buffer[(signed long int)16] = (unsigned char)0x00;
    ret = (char)0;
  }

  else
    if((signed int)p2 == 0x80)
    {
      i = 0;
      for( ; !(i >= ct->num_slots); i = i + 1)
      {
        ret=CT_Slot_Check(ct->slots[(signed long int)i], 0, &card, &change);
        if(!((signed int)ret == 0))
        {
          *rsp = (struct anonymous$14 *)(void *)0;
          return ret;
        }

        signed int return_value_CT_Slot_GetICCType$1;
        return_value_CT_Slot_GetICCType$1=CT_Slot_GetICCType(ct->slots[(signed long int)i]);
        if(!(return_value_CT_Slot_GetICCType$1 == -1))
        {
          if(card == 0 || !(change == 0))
          {
            ret=CT_Slot_Release(ct->slots[(signed long int)i]);
            if(!((signed int)ret == 0))
            {
              *rsp = (struct anonymous$14 *)(void *)0;
              return ret;
            }

          }

        }

        buffer[(signed long int)i] = (unsigned char)(card != 0 ? 0x05 : 0x00);
      }
      length = (unsigned int)(i + 2);
      buffer[(signed long int)i] = (unsigned char)0x90;
      buffer[(signed long int)(i + 1)] = (unsigned char)0x00;
    }

    else
    {
      length = (unsigned int)2;
      buffer[(signed long int)0] = (unsigned char)0x6A;
      buffer[(signed long int)1] = (unsigned char)0x00;
      ret = (char)0;
    }
  *rsp=APDU_Rsp_New(buffer, (unsigned long int)length);
  return ret;
}

// CardTerminal_Init
// file cardterminal.c line 77
extern char CardTerminal_Init(struct anonymous$3 *ct, unsigned short int pn)
{
  char ret;
  signed int i;
  signed int usbserial;
  ct->io=IO_Serial_New();
  signed int tmp_post$3;
  signed int return_value_CT_Slot_IsLast$2;
  if(ct->io == ((struct anonymous$9 *)NULL))
    return (char)-11;

  else
  {
    if((0x8000 & (signed int)pn) == 0x8000)
    {
      usbserial = 1;
      pn = pn & (unsigned short int)0x7FFF;
    }

    else
      usbserial = 0;
    signed int return_value_IO_Serial_Init$1;
    return_value_IO_Serial_Init$1=IO_Serial_Init(ct->io, (unsigned int)((signed int)pn + 1), usbserial, 1);
    if(return_value_IO_Serial_Init$1 == 0)
    {
      IO_Serial_Delete(ct->io);
      ct->io = (struct anonymous$9 *)(void *)0;
      return (char)-10;
    }

    else
    {
      ct->num_slots = 0;
      do
      {
        tmp_post$3 = ct->num_slots;
        ct->num_slots = ct->num_slots + 1;
        i = tmp_post$3;
        ct->slots[(signed long int)i]=CT_Slot_New();
        if(ct->slots[(signed long int)i] == ((struct anonymous$2 *)NULL))
        {
          ret = (char)-11;
          break;
        }

        ret=CT_Slot_Init(ct->slots[(signed long int)i], ct->io, i);
        if(!((signed int)ret == 0))
          break;

        return_value_CT_Slot_IsLast$2=CT_Slot_IsLast(ct->slots[(signed long int)i]);
      }
      while(return_value_CT_Slot_IsLast$2 == 0);
      if(!((signed int)ret == 0))
      {
        for( ; ct->num_slots >= 1; i = i - 1)
        {
          if(!(ct->slots[(signed long int)i] == ((struct anonymous$2 *)NULL)))
          {
            CT_Slot_Delete(ct->slots[(signed long int)i]);
            ct->slots[(signed long int)i] = (struct anonymous$2 *)(void *)0;
          }

          ct->num_slots = ct->num_slots - 1;
        }
        IO_Serial_Close(ct->io);
        IO_Serial_Delete(ct->io);
        ct->io = (struct anonymous$9 *)(void *)0;
      }

      else
        pthread_mutex_init(&ct->mutex, (const union anonymous$17 *)(void *)0);
      return ret;
    }
  }
}

// CardTerminal_New
// file cardterminal.c line 64
extern struct anonymous$3 * CardTerminal_New(void)
{
  struct anonymous$3 *ct;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$3) /*72ul*/ );
  ct = (struct anonymous$3 *)return_value_malloc$1;
  if(!(ct == ((struct anonymous$3 *)NULL)))
    CardTerminal_Clear(ct);

  return ct;
}

// CardTerminal_RequestICC
// file cardterminal.c line 511
static char CardTerminal_RequestICC(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[35l];
  unsigned char p1;
  unsigned char p2;
  unsigned int timeout;
  unsigned int sn;
  unsigned int length;
  signed int card;
  signed int change;
  void *atr;
  char ret;
  p1=APDU_Cmd_P1(cmd);
  unsigned char *return_value_APDU_Cmd_Data$2;
  unsigned char *return_value_APDU_Cmd_Data$4;
  unsigned long int return_value_APDU_Cmd_Lc$5;
  _Bool tmp_if_expr$8;
  signed int return_value_CT_Slot_GetICCType$7;
  if((signed int)p1 == 0x01 || (signed int)p1 == 0x02)
  {
    sn = (unsigned int)((signed int)p1 == 0x01 ? 0 : 1);
    signed int return_value_CT_Slot_GetICCType$1;
    return_value_CT_Slot_GetICCType$1=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
    if(!(return_value_CT_Slot_GetICCType$1 == -1))
    {
      buffer[(signed long int)0] = (unsigned char)0x62;
      buffer[(signed long int)1] = (unsigned char)0x01;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return (char)0;
    }

    unsigned long int return_value_APDU_Cmd_Lc$3;
    return_value_APDU_Cmd_Lc$3=APDU_Cmd_Lc(cmd);
    if(return_value_APDU_Cmd_Lc$3 == 1ul)
    {
      return_value_APDU_Cmd_Data$2=APDU_Cmd_Data(cmd);
      timeout = (unsigned int)return_value_APDU_Cmd_Data$2[(signed long int)0];
    }

    else
      timeout = (unsigned int)0;
    ret=CT_Slot_Check(ct->slots[(signed long int)sn], (signed int)timeout, &card, &change);
    if(!((signed int)ret == 0))
    {
      buffer[(signed long int)0] = (unsigned char)0x64;
      buffer[(signed long int)1] = (unsigned char)0x00;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return ret;
    }

    if(card == 0)
    {
      buffer[(signed long int)0] = (unsigned char)0x62;
      buffer[(signed long int)1] = (unsigned char)0x00;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return (char)0;
    }

    unsigned long int return_value_APDU_Cmd_Lc$6;
    return_value_APDU_Cmd_Lc$6=APDU_Cmd_Lc(cmd);
    if(return_value_APDU_Cmd_Lc$6 >= 2ul)
    {
      return_value_APDU_Cmd_Data$4=APDU_Cmd_Data(cmd);
      return_value_APDU_Cmd_Lc$5=APDU_Cmd_Lc(cmd);
      ret=CT_Slot_Probe(ct->slots[(signed long int)sn], return_value_APDU_Cmd_Data$4, (unsigned int)return_value_APDU_Cmd_Lc$5);
    }

    else
      ret=CT_Slot_Probe(ct->slots[(signed long int)sn], (unsigned char *)(void *)0, (unsigned int)0);
    if(!((signed int)ret == 0))
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      return_value_CT_Slot_GetICCType$7=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
      tmp_if_expr$8 = return_value_CT_Slot_GetICCType$7 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
    {
      buffer[(signed long int)0] = (unsigned char)0x64;
      buffer[(signed long int)1] = (unsigned char)0x00;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return ret;
    }

    p2=APDU_Cmd_P2(cmd);
    if((signed int)p2 == 0x00)
    {
      signed int return_value_CT_Slot_GetICCType$9;
      return_value_CT_Slot_GetICCType$9=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
      if(return_value_CT_Slot_GetICCType$9 == 0)
      {
        buffer[(signed long int)0] = (unsigned char)0x90;
        buffer[(signed long int)1] = (unsigned char)0x01;
        length = (unsigned int)2;
      }

      else
      {
        buffer[(signed long int)0] = (unsigned char)0x90;
        buffer[(signed long int)1] = (unsigned char)0x00;
        length = (unsigned int)2;
      }
    }

    else
      if((signed int)p2 == 0x01)
      {
        atr=CT_Slot_GetAtr(ct->slots[(signed long int)sn]);
        signed int return_value_CT_Slot_GetICCType$10;
        return_value_CT_Slot_GetICCType$10=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
        if(return_value_CT_Slot_GetICCType$10 == 0)
        {
          if(!(atr == NULL))
            ATR_GetRaw((struct anonymous$7 *)atr, buffer, &length);

          else
            length = (unsigned int)0;
          buffer[(signed long int)length] = (unsigned char)0x90;
          buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x01;
          length = length + (unsigned int)2;
        }

        else
        {
          if(!(atr == NULL))
            ATR_Sync_GetRaw((struct anonymous$19 *)atr, buffer, &length);

          else
            length = (unsigned int)0;
          buffer[(signed long int)length] = (unsigned char)0x90;
          buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x00;
          length = length + (unsigned int)2;
        }
      }

      else
        if((signed int)p2 == 0x02)
        {
          atr=CT_Slot_GetAtr(ct->slots[(signed long int)sn]);
          signed int return_value_CT_Slot_GetICCType$11;
          return_value_CT_Slot_GetICCType$11=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
          if(return_value_CT_Slot_GetICCType$11 == 0)
          {
            if(!(atr == NULL))
              ATR_GetHistoricalBytes((struct anonymous$7 *)atr, buffer, &length);

            else
              length = (unsigned int)0;
            buffer[(signed long int)length] = (unsigned char)0x90;
            buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x01;
            length = length + (unsigned int)2;
          }

          else
          {
            if(!(atr == NULL))
              ATR_Sync_GetHistoricalBytes((struct anonymous$19 *)atr, buffer, &length);

            else
              length = (unsigned int)0;
            buffer[(signed long int)length] = (unsigned char)0x90;
            buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x00;
          }
        }

        else
        {
          length = (unsigned int)2;
          buffer[(signed long int)0] = (unsigned char)0x6A;
          buffer[(signed long int)1] = (unsigned char)0x00;
          ret = (char)0;
        }
  }

  else
  {
    length = (unsigned int)2;
    buffer[(signed long int)0] = (unsigned char)0x6A;
    buffer[(signed long int)1] = (unsigned char)0x00;
    ret = (char)0;
  }
  *rsp=APDU_Rsp_New(buffer, (unsigned long int)(signed long int)length);
  return ret;
}

// CardTerminal_ResetCT
// file cardterminal.c line 283
static char CardTerminal_ResetCT(struct anonymous$3 *ct, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[35l];
  unsigned char p1;
  unsigned char p2;
  signed int card;
  signed int change;
  unsigned int sn;
  unsigned int length;
  void *atr;
  char ret = (char)0;
  p1=APDU_Cmd_P1(cmd);
  unsigned char *return_value_APDU_Cmd_Data$1;
  unsigned long int return_value_APDU_Cmd_Lc$2;
  _Bool tmp_if_expr$5;
  signed int return_value_CT_Slot_GetICCType$4;
  if((signed int)p1 == 0x00)
  {
    p2=APDU_Cmd_P2(cmd);
    if(!((signed int)p2 == 0x00) && !((signed int)p2 == 0x01) && !((signed int)p2 == 0x02))
    {
      buffer[(signed long int)0] = (unsigned char)0x6A;
      buffer[(signed long int)1] = (unsigned char)0x00;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return (char)0;
    }

    sn = (unsigned int)0;
    for( ; !(sn >= (unsigned int)ct->num_slots); sn = sn + 1u)
    {
      ret=CT_Slot_Close(ct->slots[(signed long int)sn]);
      if(!((signed int)ret == 0))
      {
        buffer[(signed long int)0] = (unsigned char)0x64;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return ret;
      }

      ret=CT_Slot_Init(ct->slots[(signed long int)sn], ct->io, (signed int)sn);
      if(!((signed int)ret == 0))
      {
        buffer[(signed long int)0] = (unsigned char)0x64;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return ret;
      }

    }
    length = (unsigned int)2;
    buffer[(signed long int)0] = (unsigned char)0x90;
    buffer[(signed long int)1] = (unsigned char)0x00;
  }

  else
    if((signed int)p1 == 0x01 || (signed int)p1 == 0x02)
    {
      sn = (unsigned int)((signed int)p1 == 0x01 ? 0 : 1);
      if(sn >= (unsigned int)ct->num_slots)
      {
        buffer[(signed long int)0] = (unsigned char)0x6A;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return (char)-1;
      }

      ret=CT_Slot_Release(ct->slots[(signed long int)sn]);
      if(!((signed int)ret == 0))
      {
        buffer[(signed long int)0] = (unsigned char)0x64;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return ret;
      }

      ret=CT_Slot_Check(ct->slots[(signed long int)sn], 0, &card, &change);
      if(!((signed int)ret == 0))
      {
        buffer[(signed long int)0] = (unsigned char)0x64;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return ret;
      }

      if(card == 0)
      {
        buffer[(signed long int)0] = (unsigned char)0x64;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return (char)0;
      }

      unsigned long int return_value_APDU_Cmd_Lc$3;
      return_value_APDU_Cmd_Lc$3=APDU_Cmd_Lc(cmd);
      if(return_value_APDU_Cmd_Lc$3 >= 2ul)
      {
        return_value_APDU_Cmd_Data$1=APDU_Cmd_Data(cmd);
        return_value_APDU_Cmd_Lc$2=APDU_Cmd_Lc(cmd);
        ret=CT_Slot_Probe(ct->slots[(signed long int)sn], return_value_APDU_Cmd_Data$1, (unsigned int)return_value_APDU_Cmd_Lc$2);
      }

      else
        ret=CT_Slot_Probe(ct->slots[(signed long int)sn], (unsigned char *)(void *)0, (unsigned int)0);
      if(!((signed int)ret == 0))
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_CT_Slot_GetICCType$4=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
        tmp_if_expr$5 = return_value_CT_Slot_GetICCType$4 == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
      {
        buffer[(signed long int)0] = (unsigned char)0x64;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return ret;
      }

      p2=APDU_Cmd_P2(cmd);
      if((signed int)p2 == 0x00)
      {
        signed int return_value_CT_Slot_GetICCType$6;
        return_value_CT_Slot_GetICCType$6=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
        if(return_value_CT_Slot_GetICCType$6 == 0)
        {
          buffer[(signed long int)0] = (unsigned char)0x90;
          buffer[(signed long int)1] = (unsigned char)0x01;
          length = (unsigned int)2;
        }

        else
        {
          buffer[(signed long int)0] = (unsigned char)0x90;
          buffer[(signed long int)1] = (unsigned char)0x00;
          length = (unsigned int)2;
        }
      }

      else
        if((signed int)p2 == 0x01)
        {
          atr=CT_Slot_GetAtr(ct->slots[(signed long int)sn]);
          signed int return_value_CT_Slot_GetICCType$7;
          return_value_CT_Slot_GetICCType$7=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
          if(return_value_CT_Slot_GetICCType$7 == 0)
          {
            if(!(atr == NULL))
              ATR_GetRaw((struct anonymous$7 *)atr, buffer, &length);

            else
              length = (unsigned int)0;
            buffer[(signed long int)length] = (unsigned char)0x90;
            buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x01;
            length = length + (unsigned int)2;
          }

          else
          {
            if(!(atr == NULL))
              ATR_Sync_GetRaw((struct anonymous$19 *)atr, buffer, &length);

            else
              length = (unsigned int)0;
            buffer[(signed long int)length] = (unsigned char)0x90;
            buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x00;
            length = length + (unsigned int)2;
          }
        }

        else
          if((signed int)p2 == 0x02)
          {
            atr=CT_Slot_GetAtr(ct->slots[(signed long int)sn]);
            signed int return_value_CT_Slot_GetICCType$8;
            return_value_CT_Slot_GetICCType$8=CT_Slot_GetICCType(ct->slots[(signed long int)sn]);
            if(return_value_CT_Slot_GetICCType$8 == 0)
            {
              if(!(atr == NULL))
                ATR_GetHistoricalBytes((struct anonymous$7 *)atr, buffer, &length);

              else
                length = (unsigned int)0;
              buffer[(signed long int)length] = (unsigned char)0x90;
              buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x01;
              length = length + (unsigned int)2;
            }

            else
            {
              if(!(atr == NULL))
                ATR_Sync_GetHistoricalBytes((struct anonymous$19 *)atr, buffer, &length);

              else
                length = (unsigned int)0;
              buffer[(signed long int)length] = (unsigned char)0x90;
              buffer[(signed long int)(length + (unsigned int)1)] = (unsigned char)0x00;
              length = length + (unsigned int)2;
            }
          }

          else
          {
            length = (unsigned int)2;
            buffer[(signed long int)0] = (unsigned char)0x6A;
            buffer[(signed long int)1] = (unsigned char)0x00;
            ret = (char)0;
          }
    }

    else
    {
      length = (unsigned int)2;
      buffer[(signed long int)0] = (unsigned char)0x6A;
      buffer[(signed long int)1] = (unsigned char)0x00;
      ret = (char)0;
    }
  *rsp=APDU_Rsp_New(buffer, (unsigned long int)length);
  return ret;
}

// Change
// file tester.c line 636
unsigned short int Change(unsigned short int ctn)
{
  unsigned short int pn;
  unsigned short int i;
  char port[16l];
  printf("Port number (");
  i = (unsigned short int)0;
  for( ; !((signed int)i >= 4); i = i + 1)
  {
    if(!((signed int)ct_list[(signed long int)i].pn == 0))
      printf("%s", (const void *)ct_list[(signed long int)i].port);

    if(!(1 + (signed int)i >= 4))
    {
      if(!((signed int)ct_list[(signed long int)(1 + (signed int)i)].pn == 0))
        printf(", ");

    }

    else
      printf("): ");
  }
  pn=ReadPort(port);
  i = (unsigned short int)0;
  for( ; !((signed int)i >= 4); i = i + 1)
    if(ct_list[(signed long int)i].pn == pn)
      break;

  if((signed int)i >= 4)
  {
    printf("Invalid port number\n");
    return ctn;
  }

  else
    return i;
}

// ChangePin
// file tester.c line 995
void ChangePin(unsigned short int ctn)
{
  unsigned char change[11l] = { (unsigned char)0x00, (unsigned char)0x24, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x06, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
  unsigned char buffer[32l];
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  signed int dummy;
  char ret;
  printf("PIN (3 bytes): ");
  scanf("%X %X %X", (unsigned int *)buffer, (unsigned int *)(buffer + (signed long int)1), (unsigned int *)(buffer + (signed long int)2));
  dummy=getchar();
  change[(signed long int)5] = buffer[(signed long int)0];
  change[(signed long int)6] = buffer[(signed long int)1];
  change[(signed long int)7] = buffer[(signed long int)2];
  printf("New PIN (3 bytes): ");
  scanf("%X %X %X", (unsigned int *)buffer, (unsigned int *)(buffer + (signed long int)1), (unsigned int *)(buffer + (signed long int)2));
  dummy=getchar();
  change[(signed long int)8] = buffer[(signed long int)0];
  change[(signed long int)9] = buffer[(signed long int)1];
  change[(signed long int)10] = buffer[(signed long int)2];
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)256;
  printf("Command: ");
  PrintArray(change, (unsigned int)11);
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)11, change, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on CHANGE VERIFICATION DATA: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// Close
// file tester.c line 676
void Close(unsigned short int ctn)
{
  char ret;
  if((signed int)ct_list[(signed long int)ctn].pn == 0)
  {
    if(!(ct_list[(signed long int)ctn].status == -1))
      goto __CPROVER_DUMP_L1;

    printf("Port not open\n");
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    pthread_mutex_lock(&ct_list[(signed long int)ctn].mutex);
    ct_list[(signed long int)ctn].pn = (unsigned short int)0;
    ct_list[(signed long int)ctn].status = -1;
    memset((void *)ct_list[(signed long int)ctn].atr, 0, (unsigned long int)33);
    ct_list[(signed long int)ctn].atr_size = (unsigned short int)0;
    pthread_mutex_unlock(&ct_list[(signed long int)ctn].mutex);
    printf("Waiting for terminal monitoring job to stop...\n");
    pthread_join(ct_list[(signed long int)ctn].thread, (void **)(void *)0);
    printf("Closing terminal at %s\n", (const void *)ct_list[(signed long int)ctn].port);
    ret=CT_close(ctn);
    if(!((signed int)ret == 0))
      printf("Error closing terminal at %s\n", (const void *)ct_list[(signed long int)ctn].port);

  }
}

// EnterPin
// file tester.c line 956
void EnterPin(unsigned short int ctn)
{
  unsigned char verify[8l] = { (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x03, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
  unsigned char buffer[32l];
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  signed int dummy;
  char ret;
  printf("PIN (3 bytes): ");
  scanf("%X %X %X", (unsigned int *)buffer, (unsigned int *)(buffer + (signed long int)1), (unsigned int *)(buffer + (signed long int)2));
  dummy=getchar();
  verify[(signed long int)5] = buffer[(signed long int)0];
  verify[(signed long int)6] = buffer[(signed long int)1];
  verify[(signed long int)7] = buffer[(signed long int)2];
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)256;
  printf("Command: ");
  PrintArray(verify, (unsigned int)8);
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)8, verify, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on VERIFY: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// GetMemoryLength
// file tester.c line 529
unsigned int GetMemoryLength(unsigned char *atr, unsigned int length)
{
  if(!(length >= 2u))
    return (unsigned int)0;

  else
    return (unsigned int)((1 << (((signed int)((signed int)atr[(signed long int)1] & 120) >> 3) + 6) * 1) << (signed int)((signed int)atr[(signed long int)1] & 7) / 8);
}

// GetResponse
// file tester.c line 767
void GetResponse(unsigned short int ctn)
{
  unsigned char get_response[5l] = { (unsigned char)0x00, (unsigned char)0xC0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
  char buffer[32l];
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  signed int dummy;
  char ret;
  get_response[(signed long int)0] = ct_list[(signed long int)ctn].cla;
  printf("Response size (hexadecimal): ");
  scanf("%X", (unsigned int *)buffer);
  dummy=getchar();
  get_response[(signed long int)4] = (unsigned char)buffer[(signed long int)0];
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)256;
  printf("Command: ");
  PrintArray(get_response, (unsigned int)5);
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)5, get_response, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on GET RESPONSE: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// ICC_Async_BeginTransmission
// file icc_async.c line 157
extern signed int ICC_Async_BeginTransmission(struct anonymous$5 *icc)
{
  if(icc->convention == 1)
  {
    signed int return_value_IFD_Towitoko_SetParity$1;
    return_value_IFD_Towitoko_SetParity$1=IFD_Towitoko_SetParity(icc->ifd, (unsigned char)0x80);
    if(!(return_value_IFD_Towitoko_SetParity$1 == 0))
      return 1;

  }

  signed int return_value_IFD_Towitoko_SetBaudrate$2;
  return_value_IFD_Towitoko_SetBaudrate$2=IFD_Towitoko_SetBaudrate(icc->ifd, icc->baudrate);
  if(!(return_value_IFD_Towitoko_SetBaudrate$2 == 0))
    return 1;

  else
    return 0;
}

// ICC_Async_Clear
// file icc_async.c line 300
static void ICC_Async_Clear(struct anonymous$5 *icc)
{
  icc->ifd = (struct anonymous$6 *)(void *)0;
  icc->atr = (struct anonymous$7 *)(void *)0;
  icc->baudrate = (unsigned long int)0L;
  icc->convention = 0;
  icc->timings.block_delay = (unsigned int)0;
  icc->timings.char_delay = (unsigned int)0;
  icc->timings.block_timeout = (unsigned int)0;
  icc->timings.char_timeout = (unsigned int)0;
}

// ICC_Async_Close
// file icc_async.c line 256
extern signed int ICC_Async_Close(struct anonymous$5 *icc)
{
  signed int return_value_IFD_Towitoko_DeactivateICC$1;
  return_value_IFD_Towitoko_DeactivateICC$1=IFD_Towitoko_DeactivateICC(icc->ifd);
  if(!(return_value_IFD_Towitoko_DeactivateICC$1 == 0))
    return 1;

  else
  {
    signed int return_value_IFD_Towitoko_SetLED$2;
    return_value_IFD_Towitoko_SetLED$2=IFD_Towitoko_SetLED(icc->ifd, (unsigned char)0x00);
    if(!(return_value_IFD_Towitoko_SetLED$2 == 0))
      return 1;

    else
    {
      ATR_Delete(icc->atr);
      ICC_Async_Clear(icc);
      return 0;
    }
  }
}

// ICC_Async_Delete
// file icc_async.c line 281
extern void ICC_Async_Delete(struct anonymous$5 *icc)
{
  free((void *)icc);
}

// ICC_Async_EndTransmission
// file icc_async.c line 231
extern signed int ICC_Async_EndTransmission(struct anonymous$5 *icc)
{
  if(icc->convention == 1)
  {
    signed int return_value_IFD_Towitoko_SetParity$1;
    return_value_IFD_Towitoko_SetParity$1=IFD_Towitoko_SetParity(icc->ifd, (unsigned char)0x40);
    if(!(return_value_IFD_Towitoko_SetParity$1 == 0))
      return 1;

  }

  return 0;
}

// ICC_Async_GetAtr
// file icc_async.c line 244
extern struct anonymous$7 * ICC_Async_GetAtr(struct anonymous$5 *icc)
{
  return icc->atr;
}

// ICC_Async_GetBaudrate
// file icc_async.c line 149
extern signed int ICC_Async_GetBaudrate(struct anonymous$5 *icc, unsigned long int *baudrate)
{
  *baudrate = icc->baudrate;
  return 0;
}

// ICC_Async_GetClockRate
// file icc_async.c line 275
extern unsigned long int ICC_Async_GetClockRate(struct anonymous$5 *icc)
{
  unsigned long int return_value_IFD_Towitoko_GetClockRate$1;
  return_value_IFD_Towitoko_GetClockRate$1=IFD_Towitoko_GetClockRate(icc->ifd);
  return return_value_IFD_Towitoko_GetClockRate$1;
}

// ICC_Async_GetIFD
// file icc_async.c line 250
extern struct anonymous$6 * ICC_Async_GetIFD(struct anonymous$5 *icc)
{
  return icc->ifd;
}

// ICC_Async_GetTimings
// file icc_async.c line 130
extern signed int ICC_Async_GetTimings(struct anonymous$5 *icc, struct anonymous$4 *timings)
{
  timings->block_delay = icc->timings.block_delay;
  timings->char_delay = icc->timings.char_delay;
  timings->block_timeout = icc->timings.block_timeout;
  timings->char_timeout = icc->timings.char_timeout;
  return 0;
}

// ICC_Async_Init
// file icc_async.c line 61
extern signed int ICC_Async_Init(struct anonymous$5 *icc, struct anonymous$6 *ifd)
{
  signed int return_value_IFD_Towitoko_SetLED$1;
  return_value_IFD_Towitoko_SetLED$1=IFD_Towitoko_SetLED(ifd, (unsigned char)0x01);
  if(!(return_value_IFD_Towitoko_SetLED$1 == 0))
    return 1;

  else
  {
    signed int return_value_IFD_Towitoko_SetBaudrate$2;
    return_value_IFD_Towitoko_SetBaudrate$2=IFD_Towitoko_SetBaudrate(ifd, (unsigned long int)9600);
    if(!(return_value_IFD_Towitoko_SetBaudrate$2 == 0))
      return 1;

    else
    {
      signed int return_value_IFD_Towitoko_ActivateICC$3;
      return_value_IFD_Towitoko_ActivateICC$3=IFD_Towitoko_ActivateICC(ifd);
      if(!(return_value_IFD_Towitoko_ActivateICC$3 == 0))
        return 1;

      else
      {
        signed int return_value_IFD_Towitoko_ResetAsyncICC$4;
        return_value_IFD_Towitoko_ResetAsyncICC$4=IFD_Towitoko_ResetAsyncICC(ifd, &icc->atr);
        if(!(return_value_IFD_Towitoko_ResetAsyncICC$4 == 0))
        {
          icc->atr = (struct anonymous$7 *)(void *)0;
          return 1;
        }

        else
        {
          signed int return_value_ATR_GetConvention$5;
          return_value_ATR_GetConvention$5=ATR_GetConvention(icc->atr, &icc->convention);
          if(!(return_value_ATR_GetConvention$5 == 0))
          {
            ATR_Delete(icc->atr);
            icc->atr = (struct anonymous$7 *)(void *)0;
            icc->convention = 0;
            return 2;
          }

          else
          {
            signed int return_value_IFD_Towitoko_SetLED$6;
            return_value_IFD_Towitoko_SetLED$6=IFD_Towitoko_SetLED(ifd, (unsigned char)0x02);
            if(!(return_value_IFD_Towitoko_SetLED$6 == 0))
            {
              ATR_Delete(icc->atr);
              icc->atr = (struct anonymous$7 *)(void *)0;
              icc->convention = 0;
              return 1;
            }

            else
            {
              icc->baudrate = (unsigned long int)9600;
              icc->ifd = ifd;
              return 0;
            }
          }
        }
      }
    }
  }
}

// ICC_Async_InvertBuffer
// file icc_async.c line 291
static void ICC_Async_InvertBuffer(unsigned int size, unsigned char *buffer)
{
  signed int i = 0;
  for( ; !((unsigned int)i >= size); i = i + 1)
    buffer[(signed long int)i] = (unsigned char)~((signed int)buffer[(signed long int)i] << 7 & 0x80 | (signed int)buffer[(signed long int)i] << 5 & 0x40 | (signed int)buffer[(signed long int)i] << 3 & 0x20 | (signed int)buffer[(signed long int)i] << 1 & 0x10 | (signed int)buffer[(signed long int)i] >> 1 & 0x08 | (signed int)buffer[(signed long int)i] >> 3 & 0x04 | (signed int)buffer[(signed long int)i] >> 5 & 0x02 | (signed int)buffer[(signed long int)i] >> 7 & 0x01);
}

// ICC_Async_New
// file icc_async.c line 47
extern struct anonymous$5 * ICC_Async_New(void)
{
  struct anonymous$5 *icc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$5) /*48ul*/ );
  icc = (struct anonymous$5 *)return_value_malloc$1;
  if(!(icc == ((struct anonymous$5 *)NULL)))
    ICC_Async_Clear(icc);

  return icc;
}

// ICC_Async_Receive
// file icc_async.c line 202
extern signed int ICC_Async_Receive(struct anonymous$5 *icc, unsigned int size, unsigned char *data)
{
  struct anonymous$4 timings;
  timings.block_timeout = icc->timings.block_timeout;
  timings.char_timeout = icc->timings.char_timeout;
  signed int return_value_IFD_Towitoko_Receive$1;
  return_value_IFD_Towitoko_Receive$1=IFD_Towitoko_Receive(icc->ifd, &timings, size, data);
  if(!(return_value_IFD_Towitoko_Receive$1 == 0))
    return 1;

  else
  {
    if(icc->convention == 1)
      ICC_Async_InvertBuffer(size, data);

    return 0;
  }
}

// ICC_Async_SetBaudrate
// file icc_async.c line 141
extern signed int ICC_Async_SetBaudrate(struct anonymous$5 *icc, unsigned long int baudrate)
{
  icc->baudrate = baudrate;
  return 0;
}

// ICC_Async_SetTimings
// file icc_async.c line 119
extern signed int ICC_Async_SetTimings(struct anonymous$5 *icc, struct anonymous$4 *timings)
{
  icc->timings.block_delay = timings->block_delay;
  icc->timings.char_delay = timings->char_delay;
  icc->timings.block_timeout = timings->block_timeout;
  icc->timings.char_timeout = timings->char_timeout;
  return 0;
}

// ICC_Async_Switch
// file icc_async.c line 219
extern signed int ICC_Async_Switch(struct anonymous$5 *icc)
{
  if(icc->baudrate >= 9601ul)
  {
    signed int return_value_IFD_Towitoko_Switch$1;
    return_value_IFD_Towitoko_Switch$1=IFD_Towitoko_Switch(icc->ifd);
    if(!(return_value_IFD_Towitoko_Switch$1 == 0))
      return 1;

  }

  return 0;
}

// ICC_Async_Transmit
// file icc_async.c line 174
extern signed int ICC_Async_Transmit(struct anonymous$5 *icc, unsigned int size, unsigned char *data)
{
  unsigned char *buffer = (unsigned char *)(void *)0;
  unsigned char *sent;
  struct anonymous$4 timings;
  if(icc->convention == 1)
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(unsigned char) /*1ul*/ , (unsigned long int)size);
    buffer = (unsigned char *)return_value_calloc$1;
    memcpy((void *)buffer, (const void *)data, (unsigned long int)size);
    ICC_Async_InvertBuffer(size, buffer);
    sent = buffer;
  }

  else
    sent = data;
  timings.block_delay = icc->timings.block_delay;
  timings.char_delay = icc->timings.char_delay;
  signed int return_value_IFD_Towitoko_Transmit$2;
  return_value_IFD_Towitoko_Transmit$2=IFD_Towitoko_Transmit(icc->ifd, &timings, size, sent);
  if(!(return_value_IFD_Towitoko_Transmit$2 == 0))
    return 1;

  else
  {
    if(icc->convention == 1)
      free((void *)buffer);

    return 0;
  }
}

// ICC_Sync_BeginTransmission
// file icc_sync.c line 419
signed int ICC_Sync_BeginTransmission(struct anonymous$22 *icc)
{
  signed int return_value_IFD_Towitoko_SetBaudrate$1;
  return_value_IFD_Towitoko_SetBaudrate$1=IFD_Towitoko_SetBaudrate(icc->ifd, (unsigned long int)115200L);
  if(!(return_value_IFD_Towitoko_SetBaudrate$1 == 0))
    return 2;

  else
    return 0;
}

// ICC_Sync_ChangePin
// file icc_sync.c line 381
signed int ICC_Sync_ChangePin(struct anonymous$22 *icc, unsigned char *pin)
{
  unsigned int trials;
  signed int ret;
  _Bool tmp_if_expr$1;
  if(icc->type == 1)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = icc->type == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    if(icc->active == 0)
    {
      signed int return_value_IFD_Towitoko_ActivateICC$2;
      return_value_IFD_Towitoko_ActivateICC$2=IFD_Towitoko_ActivateICC(icc->ifd);
      if(!(return_value_IFD_Towitoko_ActivateICC$2 == 0))
        return 2;

      icc->active = 1;
      if(!(icc->pin_ok == 0))
      {
        if(icc->type == 2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = icc->type == 3 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          if(!(icc->pin_needed == 0))
          {
            ret=ICC_Sync_EnterPin(icc, icc->pin, &trials);
            if(!(ret == 0))
              return ret;

          }

        }

      }

    }

    signed int return_value_IFD_Towitoko_ChangePin$4;
    return_value_IFD_Towitoko_ChangePin$4=IFD_Towitoko_ChangePin(icc->ifd, icc->type, pin);
    if(!(return_value_IFD_Towitoko_ChangePin$4 == 0))
      return 2;

    else
    {
      memcpy((void *)icc->pin, (const void *)pin, (unsigned long int)3);
      icc->pin_ok = 1;
      icc->pin_needed = 0;
      return 0;
    }
  }
}

// ICC_Sync_Clear
// file icc_sync.c line 666
static void ICC_Sync_Clear(struct anonymous$22 *icc)
{
  icc->ifd = (struct anonymous$6 *)(void *)0;
  icc->atr = (struct anonymous$19 *)(void *)0;
  icc->type = 0;
  icc->length = (unsigned int)0;
  icc->pagemode = (unsigned char)0x00;
  memset((void *)icc->pin, 0, (unsigned long int)3);
  icc->pin_ok = 0;
  icc->pin_needed = 0;
  icc->active = 0;
  icc->baudrate = (unsigned long int)0L;
}

// ICC_Sync_Close
// file icc_sync.c line 175
signed int ICC_Sync_Close(struct anonymous$22 *icc)
{
  signed int return_value_IFD_Towitoko_DeactivateICC$1;
  return_value_IFD_Towitoko_DeactivateICC$1=IFD_Towitoko_DeactivateICC(icc->ifd);
  if(!(return_value_IFD_Towitoko_DeactivateICC$1 == 0))
    return 2;

  else
  {
    signed int return_value_IFD_Towitoko_SetLED$2;
    return_value_IFD_Towitoko_SetLED$2=IFD_Towitoko_SetLED(icc->ifd, (unsigned char)0x00);
    if(!(return_value_IFD_Towitoko_SetLED$2 == 0))
      return 2;

    else
    {
      if(!(icc->atr == ((struct anonymous$19 *)NULL)))
        ATR_Sync_Delete(icc->atr);

      ICC_Sync_Clear(icc);
      return 0;
    }
  }
}

// ICC_Sync_CreateAtr
// file icc_sync.c line 633
static struct anonymous$19 * ICC_Sync_CreateAtr(struct anonymous$22 *icc)
{
  struct anonymous$19 *atr;
  unsigned char atr_buffer[4l];
  unsigned char protocol;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$10;
  signed int tmp_if_expr$9;
  signed int tmp_if_expr$8;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$5;
  signed int tmp_if_expr$4;
  if(!(icc->atr == ((struct anonymous$19 *)NULL)))
    return icc->atr;

  else
  {
    if(icc->type == 0)
      tmp_if_expr$3 = 0x08;

    else
    {
      if(icc->type == 1)
        tmp_if_expr$2 = 0x08;

      else
      {
        if(icc->type == 2)
          tmp_if_expr$1 = 0x0A;

        else
          tmp_if_expr$1 = icc->type == 3 ? 0x09 : 0x08;
        tmp_if_expr$2 = tmp_if_expr$1;
      }
      tmp_if_expr$3 = tmp_if_expr$2;
    }
    protocol = (unsigned char)tmp_if_expr$3;
    atr_buffer[(signed long int)0] = (unsigned char)((signed int)protocol << 4 | 0x02);
    if((signed long int)icc->length == 256L)
      tmp_if_expr$10 = 0x13;

    else
    {
      if((signed long int)icc->length == 512L)
        tmp_if_expr$9 = 0x1B;

      else
      {
        if((signed long int)icc->length == 1024L)
          tmp_if_expr$8 = 0x23;

        else
        {
          if((signed long int)icc->length == 2048L)
            tmp_if_expr$7 = 0x2B;

          else
          {
            if((signed long int)icc->length == 4096L)
              tmp_if_expr$6 = 0x33;

            else
            {
              if((signed long int)icc->length == 8192L)
                tmp_if_expr$5 = 0x3B;

              else
              {
                if(icc->length == 16384u)
                  tmp_if_expr$4 = 0x43;

                else
                  tmp_if_expr$4 = icc->length == (unsigned int)32768 ? 0x4B : 0x4B;
                tmp_if_expr$5 = tmp_if_expr$4;
              }
              tmp_if_expr$6 = tmp_if_expr$5;
            }
            tmp_if_expr$7 = tmp_if_expr$6;
          }
          tmp_if_expr$8 = tmp_if_expr$7;
        }
        tmp_if_expr$9 = tmp_if_expr$8;
      }
      tmp_if_expr$10 = tmp_if_expr$9;
    }
    atr_buffer[(signed long int)1] = (unsigned char)tmp_if_expr$10;
    atr_buffer[(signed long int)2] = (unsigned char)0x10;
    atr_buffer[(signed long int)3] = (unsigned char)0x84;
    atr=ATR_Sync_New();
    if(!(atr == ((struct anonymous$19 *)NULL)))
      ATR_Sync_Init(atr, atr_buffer, (unsigned int)4);

    return atr;
  }
}

// ICC_Sync_Delete
// file icc_sync.c line 85
extern void ICC_Sync_Delete(struct anonymous$22 *icc)
{
  free((void *)icc);
}

// ICC_Sync_EnterPin
// file icc_sync.c line 330
signed int ICC_Sync_EnterPin(struct anonymous$22 *icc, unsigned char *pin, unsigned int *trials)
{
  unsigned int new_trials;
  _Bool tmp_if_expr$1;
  if(icc->type == 1)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = icc->type == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    if(icc->active == 0)
    {
      signed int return_value_IFD_Towitoko_ActivateICC$2;
      return_value_IFD_Towitoko_ActivateICC$2=IFD_Towitoko_ActivateICC(icc->ifd);
      if(!(return_value_IFD_Towitoko_ActivateICC$2 == 0))
        return 2;

      icc->active = 1;
    }

    signed int return_value_IFD_Towitoko_ReadErrorCounter$3;
    return_value_IFD_Towitoko_ReadErrorCounter$3=IFD_Towitoko_ReadErrorCounter(icc->ifd, icc->type, trials);
    if(!(return_value_IFD_Towitoko_ReadErrorCounter$3 == 0))
      return 2;

    else
      if(*trials == 0u)
        return 5;

      else
      {
        signed int return_value_IFD_Towitoko_EnterPin$4;
        return_value_IFD_Towitoko_EnterPin$4=IFD_Towitoko_EnterPin(icc->ifd, icc->type, pin, *trials);
        if(!(return_value_IFD_Towitoko_EnterPin$4 == 0))
          return 2;

        else
        {
          signed int return_value_IFD_Towitoko_ReadErrorCounter$5;
          return_value_IFD_Towitoko_ReadErrorCounter$5=IFD_Towitoko_ReadErrorCounter(icc->ifd, icc->type, &new_trials);
          if(!(return_value_IFD_Towitoko_ReadErrorCounter$5 == 0))
            return 2;

          else
            if(!(new_trials >= *trials))
            {
              icc->pin_ok = 0;
              *trials = new_trials;
              return 4;
            }

            else
            {
              memcpy((void *)icc->pin, (const void *)pin, (unsigned long int)3);
              icc->pin_ok = 1;
              icc->pin_needed = 0;
              *trials = new_trials;
              return 0;
            }
        }
      }
  }
}

// ICC_Sync_GetAtr
// file icc_sync.c line 469
struct anonymous$19 * ICC_Sync_GetAtr(struct anonymous$22 *icc)
{
  return icc->atr;
}

// ICC_Sync_GetBaudrate
// file icc_sync.c line 437
signed int ICC_Sync_GetBaudrate(struct anonymous$22 *icc, unsigned long int *baudrate)
{
  *baudrate = icc->baudrate;
  return 0;
}

// ICC_Sync_GetIFD
// file icc_sync.c line 463
struct anonymous$6 * ICC_Sync_GetIFD(struct anonymous$22 *icc)
{
  return icc->ifd;
}

// ICC_Sync_GetLength
// file icc_sync.c line 445
unsigned int ICC_Sync_GetLength(struct anonymous$22 *icc)
{
  return icc->length;
}

// ICC_Sync_GetPagemode
// file icc_sync.c line 457
unsigned char ICC_Sync_GetPagemode(struct anonymous$22 *icc)
{
  return icc->pagemode;
}

// ICC_Sync_GetType
// file icc_sync.c line 451
signed int ICC_Sync_GetType(struct anonymous$22 *icc)
{
  return icc->type;
}

// ICC_Sync_Init
// file icc_sync.c line 91
signed int ICC_Sync_Init(struct anonymous$22 *icc, struct anonymous$6 *ifd)
{
  signed int ret;
  signed int return_value_IFD_Towitoko_SetLED$1;
  return_value_IFD_Towitoko_SetLED$1=IFD_Towitoko_SetLED(ifd, (unsigned char)0x01);
  if(!(return_value_IFD_Towitoko_SetLED$1 == 0))
    return 2;

  else
  {
    signed int return_value_IFD_Towitoko_SetBaudrate$2;
    return_value_IFD_Towitoko_SetBaudrate$2=IFD_Towitoko_SetBaudrate(ifd, (unsigned long int)115200L);
    if(!(return_value_IFD_Towitoko_SetBaudrate$2 == 0))
      return 2;

    else
    {
      signed int return_value_IFD_Towitoko_ActivateICC$3;
      return_value_IFD_Towitoko_ActivateICC$3=IFD_Towitoko_ActivateICC(ifd);
      if(!(return_value_IFD_Towitoko_ActivateICC$3 == 0))
        return 2;

      else
      {
        signed int return_value_IFD_Towitoko_ResetSyncICC$4;
        return_value_IFD_Towitoko_ResetSyncICC$4=IFD_Towitoko_ResetSyncICC(ifd, &icc->atr);
        if(!(return_value_IFD_Towitoko_ResetSyncICC$4 == 0))
        {
          icc->atr = (struct anonymous$19 *)(void *)0;
          return 2;
        }

        else
        {
          icc->active = 1;
          icc->baudrate = (unsigned long int)115200L;
          icc->ifd = ifd;
          icc->pin_ok = 0;
          icc->pin_needed = 1;
          ret=ICC_Sync_ProbeCardType(icc);
          if(!(ret == 0))
          {
            ICC_Sync_Clear(icc);
            return ret;
          }

          else
          {
            ret=ICC_Sync_ProbeMemoryLength(icc);
            if(!(ret == 0))
            {
              ICC_Sync_Clear(icc);
              return ret;
            }

            else
            {
              ret=ICC_Sync_ProbePagemode(icc);
              if(!(ret == 0))
              {
                ICC_Sync_Clear(icc);
                return ret;
              }

              else
              {
                if(icc->atr == ((struct anonymous$19 *)NULL))
                  icc->atr=ICC_Sync_CreateAtr(icc);

                signed int return_value_IFD_Towitoko_SetLED$5;
                return_value_IFD_Towitoko_SetLED$5=IFD_Towitoko_SetLED(ifd, (unsigned char)0x02);
                if(!(return_value_IFD_Towitoko_SetLED$5 == 0))
                {
                  ICC_Sync_Clear(icc);
                  return 2;
                }

                else
                {
                  if(!(icc->type == 3))
                  {
                    if(!(icc->active == 0))
                    {
                      signed int return_value_IFD_Towitoko_DeactivateICC$6;
                      return_value_IFD_Towitoko_DeactivateICC$6=IFD_Towitoko_DeactivateICC(icc->ifd);
                      if(!(return_value_IFD_Towitoko_DeactivateICC$6 == 0))
                      {
                        ICC_Sync_Clear(icc);
                        return 2;
                      }

                      icc->active = 0;
                    }

                  }

                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
}

// ICC_Sync_New
// file icc_sync.c line 71
extern struct anonymous$22 * ICC_Sync_New(void)
{
  struct anonymous$22 *icc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$22) /*48ul*/ );
  icc = (struct anonymous$22 *)return_value_malloc$1;
  if(!(icc == ((struct anonymous$22 *)NULL)))
    ICC_Sync_Clear(icc);

  return icc;
}

// ICC_Sync_ProbeCardType
// file icc_sync.c line 479
static signed int ICC_Sync_ProbeCardType(struct anonymous$22 *icc)
{
  unsigned char protocol;
  unsigned char status[1l];
  unsigned char orig[1l];
  unsigned char modif[1l];
  signed int ret;
  if(!(icc->atr == ((struct anonymous$19 *)NULL)))
  {
    ret = 0;
    protocol=ATR_Sync_GetProtocolType(icc->atr);
    if((signed int)protocol == 0x09)
      icc->type = 3;

    else
      if((signed int)protocol == 0x0A)
        icc->type = 2;

      else
        if((signed int)protocol == 0x08)
          icc->type = 0;

        else
          ret = 1;
  }

  else
  {
    IFD_Towitoko_SetReadAddress(icc->ifd, 0, (unsigned short int)0);
    IFD_Towitoko_GetStatus(icc->ifd, status);
    IFD_Towitoko_DeactivateICC(icc->ifd);
    if(!((0x10 & (signed int)status[0l]) == 0x10))
    {
      icc->type = 0;
      ICC_Sync_Read(icc, (unsigned short int)0, (unsigned int)1, orig);
      if((signed int)orig[0l] == 0xFF)
        modif[(signed long int)0] = (unsigned char)0x01;

      else
        if((signed int)orig[0l] == 0x00)
          modif[(signed long int)0] = (unsigned char)0xFE;

        else
          modif[(signed long int)0] = (unsigned char)~((signed int)orig[(signed long int)0]);
      signed int return_value_ICC_Sync_Write$1;
      return_value_ICC_Sync_Write$1=ICC_Sync_Write(icc, (unsigned short int)0, (unsigned int)1, modif);
      if(return_value_ICC_Sync_Write$1 == 0)
        ICC_Sync_Write(icc, (unsigned short int)0, (unsigned int)1, orig);

      else
        icc->type = 1;
      IFD_Towitoko_ActivateICC(icc->ifd);
      ret = 0;
    }

    else
      ret = 1;
  }
  return ret;
}

// ICC_Sync_ProbeMemoryLength
// file icc_sync.c line 564
static signed int ICC_Sync_ProbeMemoryLength(struct anonymous$22 *icc)
{
  signed int ret;
  unsigned int min;
  unsigned int max;
  unsigned char status[1l];
  if(!(icc->atr == ((struct anonymous$19 *)NULL)))
  {
    unsigned int return_value_ATR_Sync_GetNumberOfDataUnits$1;
    return_value_ATR_Sync_GetNumberOfDataUnits$1=ATR_Sync_GetNumberOfDataUnits(icc->atr);
    unsigned int return_value_ATR_Sync_GetLengthOfDataUnits$2;
    return_value_ATR_Sync_GetLengthOfDataUnits$2=ATR_Sync_GetLengthOfDataUnits(icc->atr);
    icc->length = (return_value_ATR_Sync_GetNumberOfDataUnits$1 * return_value_ATR_Sync_GetLengthOfDataUnits$2) / (unsigned int)8;
    ret = 0;
  }

  else
  {
    if(icc->type == 0)
    {
      min = (unsigned int)256L;
      max = (unsigned int)2048L;
    }

    else
      if(icc->type == 1)
      {
        min = (unsigned int)2048L;
        max = (unsigned int)32768L;
      }

      else
      {
        min = (unsigned int)256L;
        max = (unsigned int)2048L;
      }
    icc->length = min;
    for( ; !(icc->length >= max); icc->length = icc->length * (unsigned int)2)
    {
      IFD_Towitoko_SetReadAddress(icc->ifd, icc->type, (unsigned short int)icc->length);
      IFD_Towitoko_GetStatus(icc->ifd, status);
      IFD_Towitoko_DeactivateICC(icc->ifd);
      IFD_Towitoko_ActivateICC(icc->ifd);
      if((0x10 & (signed int)status[0l]) == 0x10)
        break;

    }
    ret = 0;
  }
  return ret;
}

// ICC_Sync_ProbePagemode
// file icc_sync.c line 622
static signed int ICC_Sync_ProbePagemode(struct anonymous$22 *icc)
{
  if(icc->type == 1)
    icc->pagemode = (unsigned char)0x40;

  else
    icc->pagemode = (unsigned char)0x00;
  return 0;
}

// ICC_Sync_Read
// file icc_sync.c line 194
signed int ICC_Sync_Read(struct anonymous$22 *icc, unsigned short int address, unsigned int length, unsigned char *data)
{
  if(icc->active == 0)
  {
    signed int return_value_IFD_Towitoko_ActivateICC$1;
    return_value_IFD_Towitoko_ActivateICC$1=IFD_Towitoko_ActivateICC(icc->ifd);
    if(!(return_value_IFD_Towitoko_ActivateICC$1 == 0))
      return 2;

    icc->active = 1;
  }

  signed int return_value_IFD_Towitoko_SetReadAddress$2;
  return_value_IFD_Towitoko_SetReadAddress$2=IFD_Towitoko_SetReadAddress(icc->ifd, icc->type, address);
  if(!(return_value_IFD_Towitoko_SetReadAddress$2 == 0))
    return 2;

  else
  {
    signed int return_value_IFD_Towitoko_ReadBuffer$3;
    return_value_IFD_Towitoko_ReadBuffer$3=IFD_Towitoko_ReadBuffer(icc->ifd, length, data);
    if(!(return_value_IFD_Towitoko_ReadBuffer$3 == 0))
      return 2;

    else
    {
      if(!(icc->type == 3))
      {
        if(!(icc->active == 0))
        {
          signed int return_value_IFD_Towitoko_DeactivateICC$4;
          return_value_IFD_Towitoko_DeactivateICC$4=IFD_Towitoko_DeactivateICC(icc->ifd);
          if(!(return_value_IFD_Towitoko_DeactivateICC$4 == 0))
            return 2;

          icc->pin_needed = 1;
          icc->active = 0;
        }

      }

      return 0;
    }
  }
}

// ICC_Sync_SetBaudrate
// file icc_sync.c line 430
signed int ICC_Sync_SetBaudrate(struct anonymous$22 *icc, unsigned long int baudrate)
{
  icc->baudrate = baudrate;
  return 0;
}

// ICC_Sync_Write
// file icc_sync.c line 226
signed int ICC_Sync_Write(struct anonymous$22 *icc, unsigned short int address, unsigned int length, unsigned char *data)
{
  unsigned char buffer[256l];
  unsigned char mask;
  unsigned int written;
  unsigned int to_write;
  unsigned int retries;
  unsigned int max_retries;
  unsigned int trials;
  signed int ret;
  _Bool tmp_if_expr$1;
  if(length >= 2u)
  {
    if(icc->type == 0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = icc->type == 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      max_retries = (unsigned int)2;

    else
      max_retries = (unsigned int)1;
  }

  else
    max_retries = (unsigned int)1;
  written = (unsigned int)0;
  _Bool tmp_if_expr$5;
  signed int return_value_memcmp$2;
  _Bool tmp_if_expr$3;
  for( ; !(written >= length); written = written + to_write)
  {
    mask = (unsigned char)((signed int)icc->pagemode - 0x01);
    to_write = ((unsigned int)256 < length - written ? (unsigned int)256 : length - written) < (((unsigned int)address + written | (unsigned int)mask) + (unsigned int)1) - ((unsigned int)address + written) ? ((unsigned int)256 < length - written ? (unsigned int)256 : length - written) : (((unsigned int)address + written | (unsigned int)mask) + (unsigned int)1) - ((unsigned int)address + written);
    retries = (unsigned int)0;
    while((_Bool)1)
    {
      if(icc->active == 0)
      {
        signed int return_value_IFD_Towitoko_ActivateICC$4;
        return_value_IFD_Towitoko_ActivateICC$4=IFD_Towitoko_ActivateICC(icc->ifd);
        if(!(return_value_IFD_Towitoko_ActivateICC$4 == 0))
          return 2;

        icc->active = 1;
        if(!(icc->pin_ok == 0))
        {
          if(icc->type == 2)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = icc->type == 3 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
          {
            if(!(icc->pin_needed == 0))
            {
              ret=ICC_Sync_EnterPin(icc, icc->pin, &trials);
              if(!(ret == 0))
                return ret;

            }

          }

        }

      }

      signed int return_value_IFD_Towitoko_SetWriteAddress$6;
      return_value_IFD_Towitoko_SetWriteAddress$6=IFD_Towitoko_SetWriteAddress(icc->ifd, icc->type, (unsigned short int)((unsigned int)address + written), icc->pagemode);
      if(!(return_value_IFD_Towitoko_SetWriteAddress$6 == 0))
        return 2;

      signed int return_value_IFD_Towitoko_WriteBuffer$7;
      return_value_IFD_Towitoko_WriteBuffer$7=IFD_Towitoko_WriteBuffer(icc->ifd, to_write, data + (signed long int)written);
      if(!(return_value_IFD_Towitoko_WriteBuffer$7 == 0))
        return 2;

      if(!(icc->type == 3))
      {
        if(!(icc->active == 0))
        {
          signed int return_value_IFD_Towitoko_DeactivateICC$8;
          return_value_IFD_Towitoko_DeactivateICC$8=IFD_Towitoko_DeactivateICC(icc->ifd);
          if(!(return_value_IFD_Towitoko_DeactivateICC$8 == 0))
            return 2;

          icc->pin_needed = 1;
          icc->active = 0;
        }

      }

      ret=ICC_Sync_Read(icc, (unsigned short int)((unsigned int)address + written), to_write, buffer);
      if(!(ret == 0))
        return ret;

      return_value_memcmp$2=memcmp((const void *)(data + (signed long int)written), (const void *)buffer, (unsigned long int)to_write);
      if(!(return_value_memcmp$2 == 0))
      {
        retries = retries + 1u;
        tmp_if_expr$3 = retries < max_retries ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

    }
    if(retries == max_retries)
      return 3;

    unsigned char return_value_IFD_Towitoko_GetType$9;
    return_value_IFD_Towitoko_GetType$9=IFD_Towitoko_GetType(icc->ifd);
    if((signed int)return_value_IFD_Towitoko_GetType$9 == 0x90)
    {
      struct timespec req_ts;
      req_ts.tv_sec = (signed long int)0;
      req_ts.tv_nsec = (signed long int)90000000;
      nanosleep(&req_ts, (struct timespec *)(void *)0);
    }

  }
  return 0;
}

// IFDHCloseChannel
// file ifdhandler.c line 181
signed long int IFDHCloseChannel(unsigned long int Lun)
{
  char ret;
  unsigned short int ctn;
  unsigned short int slot;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  ret=CT_close(ctn);
  if((signed int)ret == 0)
  {
    pthread_mutex_lock(&ifdh_context_mutex[(signed long int)ctn]);
    slot = (unsigned short int)0;
    for( ; !((signed int)slot >= 1); slot = slot + 1)
      if(!(ifdh_context[(signed long int)ctn][(signed long int)slot] == ((struct anonymous$8 *)NULL)))
      {
        free((void *)ifdh_context[(signed long int)ctn][(signed long int)slot]);
        ifdh_context[(signed long int)ctn][(signed long int)slot] = (struct anonymous$8 *)(void *)0;
      }

    pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
    rv = (signed long int)0;
  }

  else
    rv = (signed long int)612;
  return rv;
}

// IFDHControl
// file ifdhandler.c line 534
signed long int IFDHControl(unsigned long int Lun, unsigned char *TxBuffer, unsigned long int TxLength, unsigned char *RxBuffer, unsigned long int *RxLength)
{
  char ret;
  unsigned short int ctn;
  unsigned short int slot;
  unsigned short int lc;
  unsigned short int lr;
  unsigned char sad;
  unsigned char dad;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  pthread_mutex_lock(&ifdh_context_mutex[(signed long int)ctn]);
  if(!(ifdh_context[(signed long int)ctn][(signed long int)slot] == ((struct anonymous$8 *)NULL)))
  {
    pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
    dad = (unsigned char)0x01;
    sad = (unsigned char)0x02;
    lr = (unsigned short int)*RxLength;
    lc = (unsigned short int)TxLength;
    ret=CT_data(ctn, &dad, &sad, lc, TxBuffer, &lr, RxBuffer);
    if((signed int)ret == 0)
    {
      *RxLength = (unsigned long int)lr;
      rv = (signed long int)0;
    }

    else
    {
      *RxLength = (unsigned long int)0;
      rv = (signed long int)612;
    }
  }

  else
  {
    pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
    rv = (signed long int)616;
  }
  return rv;
}

// IFDHCreateChannel
// file ifdhandler.c line 88
signed long int IFDHCreateChannel(unsigned long int Lun, unsigned long int Channel)
{
  char ret;
  unsigned short int ctn;
  unsigned short int pn;
  unsigned short int slot;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  pthread_mutex_lock(&ifdh_context_mutex[(signed long int)ctn]);
  if(ifdh_context[(signed long int)ctn][(signed long int)slot] == ((struct anonymous$8 *)NULL))
  {
    if(Channel >= 2097152ul)
      pn = (unsigned short int)((signed int)(unsigned short int)(Channel & (unsigned long int)0x1FFFFF) + 0x8000);

    else
      if(Channel == 66552ul)
        pn = (unsigned short int)0;

      else
        if(Channel == 66296ul)
          pn = (unsigned short int)1;

        else
          if(Channel == 66536ul)
            pn = (unsigned short int)2;

          else
            if(Channel == 66280ul)
              pn = (unsigned short int)3;

            else
              pn = (unsigned short int)((signed int)(unsigned short int)Channel - 1);
    ret=CT_init(ctn, pn);
    if((signed int)ret == 0)
    {
      slot = (unsigned short int)0;
      for( ; !((signed int)slot >= 1); slot = slot + 1)
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct anonymous$8) /*280ul*/ );
        ifdh_context[(signed long int)ctn][(signed long int)slot] = (struct anonymous$8 *)return_value_malloc$1;
        if(!(ifdh_context[(signed long int)ctn][(signed long int)slot] == ((struct anonymous$8 *)NULL)))
          memset((void *)ifdh_context[(signed long int)ctn][(signed long int)slot], 0, sizeof(struct anonymous$8) /*280ul*/ );

      }
      rv = (signed long int)0;
    }

    else
      rv = (signed long int)612;
  }

  else
    rv = (signed long int)0;
  pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
  return rv;
}

// IFDHGetCapabilities
// file ifdhandler.c line 224
signed long int IFDHGetCapabilities(unsigned long int Lun, unsigned long int Tag, unsigned long int *Length, unsigned char *Value)
{
  unsigned short int ctn;
  unsigned short int slot;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  pthread_mutex_lock(&ifdh_context_mutex[(signed long int)ctn]);
  switch(Tag)
  {
    case (unsigned long int)0x0303:
    {
      *Length = ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR_Length;
      memcpy((void *)Value, (const void *)ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR, *Length);
      rv = (signed long int)0;
      break;
    }
    case (unsigned long int)0x0FAE:
    {
      *Length = (unsigned long int)1;
      *Value = (unsigned char)1;
      rv = (signed long int)0;
      break;
    }
    case (unsigned long int)0x0FAF:
    {
      *Length = (unsigned long int)1;
      *Value = (unsigned char)4;
      rv = (signed long int)0;
      break;
    }
    default:
    {
      *Length = (unsigned long int)0;
      rv = (signed long int)600;
    }
  }
  pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
  return rv;
}

// IFDHICCPresence
// file ifdhandler.c line 589
signed long int IFDHICCPresence(unsigned long int Lun)
{
  char ret;
  unsigned short int ctn;
  unsigned short int slot;
  unsigned short int lc;
  unsigned short int lr;
  unsigned char cmd[5l];
  unsigned char rsp[256l];
  unsigned char sad;
  unsigned char dad;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  cmd[(signed long int)0] = (unsigned char)0x20;
  cmd[(signed long int)1] = (unsigned char)0x13;
  cmd[(signed long int)2] = (unsigned char)0x00;
  cmd[(signed long int)3] = (unsigned char)0x80;
  cmd[(signed long int)4] = (unsigned char)0x00;
  dad = (unsigned char)0x01;
  sad = (unsigned char)0x02;
  lc = (unsigned short int)5;
  lr = (unsigned short int)256;
  ret=CT_data(ctn, &dad, &sad, lc, cmd, &lr, rsp);
  if((signed int)ret == 0)
  {
    if(!((signed int)slot >= (signed int)lr + -2))
    {
      if((signed int)rsp[(signed long int)slot] == 0x00)
        rv = (signed long int)616;

      else
        rv = (signed long int)615;
    }

    else
      rv = (signed long int)616;
  }

  else
    rv = (signed long int)612;
  return rv;
}

// IFDHPowerICC
// file ifdhandler.c line 354
signed long int IFDHPowerICC(unsigned long int Lun, unsigned long int Action, unsigned char *Atr, unsigned long int *AtrLength)
{
  char ret;
  unsigned short int ctn;
  unsigned short int slot;
  unsigned short int lc;
  unsigned short int lr;
  unsigned char cmd[5l];
  unsigned char rsp[256l];
  unsigned char sad;
  unsigned char dad;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  pthread_mutex_lock(&ifdh_context_mutex[(signed long int)ctn]);
  if(!(ifdh_context[(signed long int)ctn][(signed long int)slot] == ((struct anonymous$8 *)NULL)))
  {
    if(Action == 500ul)
    {
      cmd[(signed long int)0] = (unsigned char)0x20;
      cmd[(signed long int)1] = (unsigned char)0x12;
      cmd[(signed long int)2] = (unsigned char)((signed int)slot + 1);
      cmd[(signed long int)3] = (unsigned char)0x01;
      cmd[(signed long int)4] = (unsigned char)0x00;
      dad = (unsigned char)0x01;
      sad = (unsigned char)0x02;
      lr = (unsigned short int)256;
      lc = (unsigned short int)5;
      ret=CT_data(ctn, &dad, &sad, (unsigned short int)5, cmd, &lr, rsp);
      if((signed int)ret == 0 && (signed int)lr >= 2)
      {
        ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR_Length = (unsigned long int)lr - (unsigned long int)2;
        memcpy((void *)ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR, (const void *)rsp, (unsigned long int)((signed int)lr - 2));
        *AtrLength = (unsigned long int)lr - (unsigned long int)2;
        memcpy((void *)Atr, (const void *)rsp, (unsigned long int)((signed int)lr - 2));
        rv = (signed long int)0;
      }

      else
        rv = (signed long int)612;
    }

    else
      if(Action == 501ul)
      {
        cmd[(signed long int)0] = (unsigned char)0x20;
        cmd[(signed long int)1] = (unsigned char)0x15;
        cmd[(signed long int)2] = (unsigned char)((signed int)slot + 1);
        cmd[(signed long int)3] = (unsigned char)0x00;
        cmd[(signed long int)4] = (unsigned char)0x00;
        dad = (unsigned char)0x01;
        sad = (unsigned char)0x02;
        lr = (unsigned short int)256;
        lc = (unsigned short int)5;
        ret=CT_data(ctn, &dad, &sad, (unsigned short int)5, cmd, &lr, rsp);
        if((signed int)ret == 0)
        {
          ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR_Length = (unsigned long int)0;
          memset((void *)ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR, 0, (unsigned long int)33);
          *AtrLength = (unsigned long int)0;
          rv = (signed long int)0;
        }

        else
          rv = (signed long int)612;
      }

      else
        if(Action == 502ul)
        {
          cmd[(signed long int)0] = (unsigned char)0x20;
          cmd[(signed long int)1] = (unsigned char)0x11;
          cmd[(signed long int)2] = (unsigned char)((signed int)slot + 1);
          cmd[(signed long int)3] = (unsigned char)0x01;
          cmd[(signed long int)4] = (unsigned char)0x00;
          dad = (unsigned char)0x01;
          sad = (unsigned char)0x02;
          lr = (unsigned short int)256;
          lc = (unsigned short int)5;
          ret=CT_data(ctn, &dad, &sad, (unsigned short int)5, cmd, &lr, rsp);
          if((signed int)ret == 0 && (signed int)lr >= 2)
          {
            ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR_Length = (unsigned long int)lr - (unsigned long int)2;
            memcpy((void *)ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR, (const void *)rsp, (unsigned long int)((signed int)lr - 2));
            *AtrLength = (unsigned long int)lr - (unsigned long int)2;
            memcpy((void *)Atr, (const void *)rsp, (unsigned long int)((signed int)lr - 2));
            rv = (signed long int)0;
          }

          else
            rv = (signed long int)608;
        }

        else
          rv = (signed long int)614;
  }

  else
    rv = (signed long int)616;
  pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
  return rv;
}

// IFDHSetCapabilities
// file ifdhandler.c line 273
signed long int IFDHSetCapabilities(unsigned long int Lun, unsigned long int Tag, unsigned long int Length, unsigned char *Value)
{
  return (signed long int)614;
}

// IFDHSetProtocolParameters
// file ifdhandler.c line 284
signed long int IFDHSetProtocolParameters(unsigned long int Lun, unsigned long int Protocol, unsigned char Flags, unsigned char PTS1, unsigned char PTS2, unsigned char PTS3)
{
  char ret;
  unsigned short int ctn;
  unsigned short int slot;
  unsigned short int lc;
  unsigned short int lr;
  unsigned char cmd[10l];
  unsigned char rsp[256l];
  unsigned char sad;
  unsigned char dad;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  pthread_mutex_lock(&ifdh_context_mutex[(signed long int)ctn]);
  unsigned short int tmp_post$1;
  unsigned short int tmp_post$2;
  unsigned short int tmp_post$3;
  if(!(ifdh_context[(signed long int)ctn][(signed long int)slot] == ((struct anonymous$8 *)NULL)))
  {
    cmd[(signed long int)0] = (unsigned char)0x20;
    cmd[(signed long int)1] = (unsigned char)0x11;
    cmd[(signed long int)2] = (unsigned char)((signed int)slot + 1);
    cmd[(signed long int)3] = (unsigned char)0x01;
    cmd[(signed long int)4] = (unsigned char)0x06;
    cmd[(signed long int)5] = (unsigned char)0xFF;
    cmd[(signed long int)6] = (unsigned char)((unsigned long int)((signed int)Flags << 4) | (unsigned long int)0x0F & Protocol);
    lc = (unsigned short int)7;
    if((0x10 & (signed int)Flags) == 0x10)
    {
      tmp_post$1 = lc;
      lc = lc + 1;
      cmd[(signed long int)tmp_post$1] = PTS1;
    }

    if((0x20 & (signed int)Flags) == 0x20)
    {
      tmp_post$2 = lc;
      lc = lc + 1;
      cmd[(signed long int)tmp_post$2] = PTS2;
    }

    if((0x40 & (signed int)Flags) == 0x40)
    {
      tmp_post$3 = lc;
      lc = lc + 1;
      cmd[(signed long int)tmp_post$3] = PTS3;
    }

    dad = (unsigned char)0x01;
    sad = (unsigned char)0x02;
    lr = (unsigned short int)256;
    ret=CT_data(ctn, &dad, &sad, lc, cmd, &lr, rsp);
    if((signed int)ret == 0 && (signed int)lr >= 2)
    {
      ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR_Length = (unsigned long int)lr - (unsigned long int)2;
      memcpy((void *)ifdh_context[(signed long int)ctn][(signed long int)slot]->icc_state.ATR, (const void *)rsp, (unsigned long int)((signed int)lr - 2));
      rv = (signed long int)0;
    }

    else
      rv = (signed long int)605;
  }

  else
    rv = (signed long int)616;
  pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
  return rv;
}

// IFDHTransmitToICC
// file ifdhandler.c line 477
signed long int IFDHTransmitToICC(unsigned long int Lun, struct _SCARD_IO_HEADER SendPci, unsigned char *TxBuffer, unsigned long int TxLength, unsigned char *RxBuffer, unsigned long int *RxLength, struct _SCARD_IO_HEADER *RecvPci)
{
  char ret;
  unsigned short int ctn;
  unsigned short int slot;
  unsigned short int lc;
  unsigned short int lr;
  unsigned char sad;
  unsigned char dad;
  signed long int rv;
  ctn = (unsigned short int)((signed int)(unsigned short int)(Lun >> 16) % 4);
  slot = (unsigned short int)((signed int)(unsigned short int)(Lun & (unsigned long int)0x0000FFFF) % 1);
  pthread_mutex_lock(&ifdh_context_mutex[(signed long int)ctn]);
  if(!(ifdh_context[(signed long int)ctn][(signed long int)slot] == ((struct anonymous$8 *)NULL)))
  {
    pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
    dad = (unsigned char)((signed int)slot == 0 ? 0x00 : (signed int)slot + 1);
    sad = (unsigned char)0x02;
    lr = (unsigned short int)*RxLength;
    lc = (unsigned short int)TxLength;
    ret=CT_data(ctn, &dad, &sad, lc, TxBuffer, &lr, RxBuffer);
    if((signed int)ret == 0)
    {
      *RxLength = (unsigned long int)lr;
      rv = (signed long int)0;
    }

    else
    {
      *RxLength = (unsigned long int)0;
      rv = (signed long int)612;
    }
  }

  else
  {
    pthread_mutex_unlock(&ifdh_context_mutex[(signed long int)ctn]);
    rv = (signed long int)616;
  }
  return rv;
}

// IFD_Towitoko_ActivateICC
// file ifd_towitoko.h line 130
extern signed int IFD_Towitoko_ActivateICC(struct anonymous$6 *ifd)
{
  unsigned char status[1l];
  unsigned char buffer[3l] = { (unsigned char)0x60, (unsigned char)0x0F, (unsigned char)0x9C };
  IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)3);
  signed int return_value_IO_Serial_Write$1;
  return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)3, buffer);
  if(return_value_IO_Serial_Write$1 == 0)
    return 1;

  else
  {
    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    else
      if(!((signed int)status[0l] == 0x01))
        return 2;

      else
        return 0;
  }
}

// IFD_Towitoko_ChangePin
// file ifd_towitoko.c line 1405
extern signed int IFD_Towitoko_ChangePin(struct anonymous$6 *ifd, signed int icc_type, unsigned char *pin)
{
  unsigned char w21[7l] = { (unsigned char)0x72, (unsigned char)0x6E, (unsigned char)0x01, (unsigned char)0x39, (unsigned char)0x03, (unsigned char)0x0F, (unsigned char)0xA5 };
  unsigned char w22[6l] = { (unsigned char)0x42, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char w31[8l] = { (unsigned char)0x73, (unsigned char)0x67, (unsigned char)0x6E, (unsigned char)0xFE, (unsigned char)0xF3, (unsigned char)0x02, (unsigned char)0x0F, (unsigned char)0xB4 };
  unsigned char w32[4l] = { (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char status[1l];
  if(icc_type == 2)
  {
    IFD_Towitoko_PrepareCommand(ifd, w21, (unsigned char)7);
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)7, w21);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

    w22[(signed long int)1] = pin[(signed long int)0];
    w22[(signed long int)2] = pin[(signed long int)1];
    w22[(signed long int)3] = pin[(signed long int)2];
    IFD_Towitoko_PrepareCommand(ifd, w22, (unsigned char)6);
    signed int return_value_IO_Serial_Write$3;
    return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)6, w22);
    if(return_value_IO_Serial_Write$3 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$4;
    return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$4 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

  }

  else
    if(icc_type == 3)
    {
      IFD_Towitoko_PrepareCommand(ifd, w31, (unsigned char)8);
      signed int return_value_IO_Serial_Write$5;
      return_value_IO_Serial_Write$5=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, w31);
      if(return_value_IO_Serial_Write$5 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$6;
      return_value_IO_Serial_Read$6=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$6 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w32[(signed long int)1] = pin[(signed long int)0];
      IFD_Towitoko_PrepareCommand(ifd, w32, (unsigned char)4);
      signed int return_value_IO_Serial_Write$7;
      return_value_IO_Serial_Write$7=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w32);
      if(return_value_IO_Serial_Write$7 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$8;
      return_value_IO_Serial_Read$8=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$8 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w31[(signed long int)3] = (unsigned char)0xFF;
      IFD_Towitoko_PrepareCommand(ifd, w31, (unsigned char)8);
      signed int return_value_IO_Serial_Write$9;
      return_value_IO_Serial_Write$9=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, w31);
      if(return_value_IO_Serial_Write$9 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$10;
      return_value_IO_Serial_Read$10=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$10 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w32[(signed long int)1] = pin[(signed long int)1];
      IFD_Towitoko_PrepareCommand(ifd, w32, (unsigned char)4);
      signed int return_value_IO_Serial_Write$11;
      return_value_IO_Serial_Write$11=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w32);
      if(return_value_IO_Serial_Write$11 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$12;
      return_value_IO_Serial_Read$12=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$12 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

    }

    else
      return 3;
  return 0;
}

// IFD_Towitoko_Checksum
// file ifd_towitoko.c line 1610
static unsigned char IFD_Towitoko_Checksum(unsigned char *command, unsigned int size, unsigned char initial)
{
  unsigned char checksum;
  unsigned char x7;
  unsigned int i;
  checksum = initial;
  i = (unsigned int)0;
  for( ; !(i >= size); i = i + 1u)
  {
    checksum = (unsigned char)((signed int)checksum ^ (signed int)command[(signed long int)i]);
    x7 = (unsigned char)(((signed int)checksum & 0x80) >> 7);
    checksum = (unsigned char)((signed int)checksum << 1);
    checksum = (unsigned char)((signed int)!(x7 != 0) == 0x01 ? (signed int)checksum | 0x01 : (signed int)checksum & 0xFE);
  }
  return checksum;
}

// IFD_Towitoko_Clear
// file ifd_towitoko.c line 1672
static void IFD_Towitoko_Clear(struct anonymous$6 *ifd)
{
  ifd->io = (struct anonymous$9 *)(void *)0;
  ifd->slot = (unsigned char)0x00;
  ifd->type = (unsigned char)0x00;
  ifd->firmware = (unsigned char)0x00;
}

// IFD_Towitoko_Close
// file ifd_towitoko.c line 157
extern signed int IFD_Towitoko_Close(struct anonymous$6 *ifd)
{
  signed int ret;
  ret=IFD_Towitoko_SetLED(ifd, (unsigned char)0x00);
  if(!(ret == 0))
    return ret;

  else
  {
    IFD_Towitoko_Clear(ifd);
    return 0;
  }
}

// IFD_Towitoko_DeactivateICC
// file ifd_towitoko.h line 131
extern signed int IFD_Towitoko_DeactivateICC(struct anonymous$6 *ifd)
{
  unsigned char status[1l];
  unsigned char buffer[3l] = { (unsigned char)0x61, (unsigned char)0x0F, (unsigned char)0x98 };
  IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)3);
  signed int return_value_IO_Serial_Write$1;
  return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)3, buffer);
  if(return_value_IO_Serial_Write$1 == 0)
    return 1;

  else
  {
    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    else
      if(!((signed int)status[0l] == 0x01))
        return 2;

      else
        return 0;
  }
}

// IFD_Towitoko_Delete
// file ifd_towitoko.c line 76
extern void IFD_Towitoko_Delete(struct anonymous$6 *ifd)
{
  free((void *)ifd);
}

// IFD_Towitoko_EnterPin
// file ifd_towitoko.c line 1195
extern signed int IFD_Towitoko_EnterPin(struct anonymous$6 *ifd, signed int icc_type, unsigned char *pin, unsigned int trial)
{
  unsigned char w21[7l] = { (unsigned char)0x72, (unsigned char)0x6E, (unsigned char)0x00, (unsigned char)0x39, (unsigned char)0x03, (unsigned char)0x0F, (unsigned char)0xB5 };
  unsigned char w22[4l] = { (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char w23[6l] = { (unsigned char)0x42, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char w31[8l] = { (unsigned char)0x73, (unsigned char)0x67, (unsigned char)0x6E, (unsigned char)0xFD, (unsigned char)0xF2, (unsigned char)0x02, (unsigned char)0x0F, (unsigned char)0x8C };
  unsigned char w32[4l] = { (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char status[1l];
  if(icc_type == 2)
  {
    IFD_Towitoko_PrepareCommand(ifd, w21, (unsigned char)7);
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)7, w21);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

    w22[(signed long int)1] = (unsigned char)(trial == (unsigned int)3 ? 0x06 : (trial == (unsigned int)2 ? 0x04 : 0x00));
    IFD_Towitoko_PrepareCommand(ifd, w22, (unsigned char)4);
    signed int return_value_IO_Serial_Write$3;
    return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w22);
    if(return_value_IO_Serial_Write$3 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$4;
    return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$4 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

    w21[(signed long int)2] = (unsigned char)0x01;
    w21[(signed long int)3] = (unsigned char)0x33;
    IFD_Towitoko_PrepareCommand(ifd, w21, (unsigned char)7);
    signed int return_value_IO_Serial_Write$5;
    return_value_IO_Serial_Write$5=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)7, w21);
    if(return_value_IO_Serial_Write$5 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$6;
    return_value_IO_Serial_Read$6=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$6 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

    memcpy((void *)(w23 + (signed long int)1), (const void *)pin, (unsigned long int)3);
    IFD_Towitoko_PrepareCommand(ifd, w23, (unsigned char)6);
    signed int return_value_IO_Serial_Write$7;
    return_value_IO_Serial_Write$7=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)6, w23);
    if(return_value_IO_Serial_Write$7 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$8;
    return_value_IO_Serial_Read$8=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$8 == 0)
      return 1;

    w21[(signed long int)2] = (unsigned char)0x00;
    w21[(signed long int)3] = (unsigned char)0x39;
    IFD_Towitoko_PrepareCommand(ifd, w21, (unsigned char)7);
    signed int return_value_IO_Serial_Write$9;
    return_value_IO_Serial_Write$9=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)7, w21);
    if(return_value_IO_Serial_Write$9 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$10;
    return_value_IO_Serial_Read$10=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$10 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

    w22[(signed long int)1] = (unsigned char)0xFF;
    IFD_Towitoko_PrepareCommand(ifd, w22, (unsigned char)4);
    signed int return_value_IO_Serial_Write$11;
    return_value_IO_Serial_Write$11=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w22);
    if(return_value_IO_Serial_Write$11 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$12;
    return_value_IO_Serial_Read$12=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$12 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

  }

  else
    if(icc_type == 3)
    {
      IFD_Towitoko_PrepareCommand(ifd, w31, (unsigned char)8);
      signed int return_value_IO_Serial_Write$13;
      return_value_IO_Serial_Write$13=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, w31);
      if(return_value_IO_Serial_Write$13 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$14;
      return_value_IO_Serial_Read$14=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$14 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w32[(signed long int)1] = (unsigned char)(trial == (unsigned int)8 ? 0xFE : (trial == (unsigned int)7 ? 0xFC : (trial == (unsigned int)6 ? 0xF8 : (trial == (unsigned int)5 ? 0xF0 : (trial == (unsigned int)4 ? 0xE0 : (trial == (unsigned int)3 ? 0xC0 : (trial == (unsigned int)2 ? 0x80 : 0x00)))))));
      IFD_Towitoko_PrepareCommand(ifd, w32, (unsigned char)4);
      signed int return_value_IO_Serial_Write$15;
      return_value_IO_Serial_Write$15=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w32);
      if(return_value_IO_Serial_Write$15 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$16;
      return_value_IO_Serial_Read$16=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$16 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w31[(signed long int)3] = (unsigned char)0xFE;
      w31[(signed long int)4] = (unsigned char)0xCD;
      IFD_Towitoko_PrepareCommand(ifd, w31, (unsigned char)8);
      signed int return_value_IO_Serial_Write$17;
      return_value_IO_Serial_Write$17=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, w31);
      if(return_value_IO_Serial_Write$17 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$18;
      return_value_IO_Serial_Read$18=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$18 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w32[(signed long int)1] = pin[(signed long int)0];
      IFD_Towitoko_PrepareCommand(ifd, w32, (unsigned char)4);
      signed int return_value_IO_Serial_Write$19;
      return_value_IO_Serial_Write$19=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w32);
      if(return_value_IO_Serial_Write$19 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$20;
      return_value_IO_Serial_Read$20=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$20 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w31[(signed long int)3] = (unsigned char)0xFF;
      IFD_Towitoko_PrepareCommand(ifd, w31, (unsigned char)8);
      signed int return_value_IO_Serial_Write$21;
      return_value_IO_Serial_Write$21=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, w31);
      if(return_value_IO_Serial_Write$21 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$22;
      return_value_IO_Serial_Read$22=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$22 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w32[(signed long int)1] = pin[(signed long int)1];
      IFD_Towitoko_PrepareCommand(ifd, w32, (unsigned char)4);
      signed int return_value_IO_Serial_Write$23;
      return_value_IO_Serial_Write$23=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w32);
      if(return_value_IO_Serial_Write$23 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$24;
      return_value_IO_Serial_Read$24=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$24 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w31[(signed long int)3] = (unsigned char)0xFD;
      w31[(signed long int)4] = (unsigned char)0xF3;
      IFD_Towitoko_PrepareCommand(ifd, w31, (unsigned char)8);
      signed int return_value_IO_Serial_Write$25;
      return_value_IO_Serial_Write$25=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, w31);
      if(return_value_IO_Serial_Write$25 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$26;
      return_value_IO_Serial_Read$26=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$26 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      w32[(signed long int)1] = (unsigned char)0xFF;
      IFD_Towitoko_PrepareCommand(ifd, w32, (unsigned char)4);
      signed int return_value_IO_Serial_Write$27;
      return_value_IO_Serial_Write$27=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)4, w32);
      if(return_value_IO_Serial_Write$27 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$28;
      return_value_IO_Serial_Read$28=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$28 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

    }

    else
      return 3;
  return 0;
}

// IFD_Towitoko_GetBaudrate
// file ifd_towitoko.c line 306
extern signed int IFD_Towitoko_GetBaudrate(struct anonymous$6 *ifd, unsigned long int *baudrate)
{
  struct anonymous$10 props;
  signed int return_value_IO_Serial_GetProperties$1;
  return_value_IO_Serial_GetProperties$1=IO_Serial_GetProperties(ifd->io, &props);
  if(return_value_IO_Serial_GetProperties$1 == 0)
    return 1;

  else
  {
    *baudrate = props.output_bitrate;
    return 0;
  }
}

// IFD_Towitoko_GetClockRate
// file ifd_towitoko.h line 153
extern unsigned long int IFD_Towitoko_GetClockRate(struct anonymous$6 *ifd)
{
  return (unsigned long int)(372L * 9600L);
}

// IFD_Towitoko_GetDescription
// file ifd_towitoko.c line 1514
extern void IFD_Towitoko_GetDescription(struct anonymous$6 *ifd, unsigned char *desc, unsigned int length)
{
  char buffer[3l];
  if((signed int)ifd->type == 0x88)
    memcpy((void *)desc, (const void *)"CE2", (unsigned long int)(length < (unsigned int)3 ? length : (unsigned int)3));

  else
    if((signed int)ifd->type == 0x84)
      memcpy((void *)desc, (const void *)"CE1", (unsigned long int)(length < (unsigned int)3 ? length : (unsigned int)3));

    else
      if((signed int)ifd->type == 0x90)
        memcpy((void *)desc, (const void *)"CDI", (unsigned long int)(length < (unsigned int)3 ? length : (unsigned int)3));

      else
        if((signed int)ifd->type == 0x61)
          memcpy((void *)desc, (const void *)"CDM", (unsigned long int)(length < (unsigned int)3 ? length : (unsigned int)3));

        else
          if((signed int)ifd->type == 0x64)
            memcpy((void *)desc, (const void *)"KZ2", (unsigned long int)(length < (unsigned int)3 ? length : (unsigned int)3));

          else
            if((signed int)ifd->type == 0x80)
              memcpy((void *)desc, (const void *)"KZ1", (unsigned long int)(length < (unsigned int)3 ? length : (unsigned int)3));

            else
              memcpy((void *)desc, (const void *)"UNK", (unsigned long int)(length < (unsigned int)3 ? length : (unsigned int)3));
  snprintf(buffer, (unsigned long int)3, "%02X", ifd->firmware);
  if(length >= 4u)
    memcpy((void *)(desc + (signed long int)3), (const void *)buffer, (unsigned long int)(length - (unsigned int)3 < (unsigned int)2 ? length - (unsigned int)3 : (unsigned int)2));

}

// IFD_Towitoko_GetFirmware
// file ifd_towitoko.c line 1546
extern unsigned char IFD_Towitoko_GetFirmware(struct anonymous$6 *ifd)
{
  return ifd->firmware;
}

// IFD_Towitoko_GetMaxBaudrate
// file ifd_towitoko.c line 1573
extern unsigned long int IFD_Towitoko_GetMaxBaudrate(struct anonymous$6 *ifd)
{
  return (unsigned long int)115200L;
}

// IFD_Towitoko_GetNumSlots
// file ifd_towitoko.c line 1558
extern unsigned int IFD_Towitoko_GetNumSlots(struct anonymous$6 *ifd)
{
  if((signed int)ifd->type == 0x88)
    return (unsigned int)2;

  else
    return (unsigned int)1;
}

// IFD_Towitoko_GetReaderInfo
// file ifd_towitoko.c line 1628
static signed int IFD_Towitoko_GetReaderInfo(struct anonymous$6 *ifd)
{
  unsigned char status[3l];
  unsigned char buffer[2l] = { (unsigned char)0x00, (unsigned char)0x01 };
  buffer[(signed long int)1]=IFD_Towitoko_Checksum(buffer, (unsigned int)1, ifd->slot);
  signed int return_value_IO_Serial_Write$1;
  return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)2, buffer);
  if(return_value_IO_Serial_Write$1 == 0)
    return 1;

  else
  {
    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)3, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    else
    {
      ifd->type = status[(signed long int)0];
      ifd->firmware = status[(signed long int)1];
      return 0;
    }
  }
}

// IFD_Towitoko_GetSlot
// file ifd_towitoko.c line 1552
extern unsigned char IFD_Towitoko_GetSlot(struct anonymous$6 *ifd)
{
  return ifd->slot;
}

// IFD_Towitoko_GetStatus
// file ifd_towitoko.c line 417
extern signed int IFD_Towitoko_GetStatus(struct anonymous$6 *ifd, unsigned char *result)
{
  unsigned char buffer[2l] = { (unsigned char)0x03, (unsigned char)0x07 };
  unsigned char status[2l];
  IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)2);
  signed int return_value_IO_Serial_Write$1;
  return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)2, buffer);
  if(return_value_IO_Serial_Write$1 == 0)
    return 1;

  else
  {
    signed int return_value_IO_Serial_Read$4;
    return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)2, status);
    if(return_value_IO_Serial_Read$4 == 0)
    {
      IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)2);
      signed int return_value_IO_Serial_Write$2;
      return_value_IO_Serial_Write$2=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)2, buffer);
      if(return_value_IO_Serial_Write$2 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$3;
      return_value_IO_Serial_Read$3=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)2, status);
      if(return_value_IO_Serial_Read$3 == 0)
        return 1;

    }

    *result = status[(signed long int)0];
    return 0;
  }
}

// IFD_Towitoko_GetType
// file ifd_towitoko.c line 1508
extern unsigned char IFD_Towitoko_GetType(struct anonymous$6 *ifd)
{
  return ifd->type;
}

// IFD_Towitoko_Init
// file ifd_towitoko.c line 82
extern signed int IFD_Towitoko_Init(struct anonymous$6 *ifd, struct anonymous$9 *io, unsigned char slot)
{
  struct anonymous$10 props;
  signed int ret;
  if(!((signed int)slot == 0x00) && !((signed int)slot == 0x01))
    return 3;

  else
  {
    props.input_bitrate = (unsigned long int)9600;
    props.output_bitrate = (unsigned long int)9600;
    props.bits = (unsigned int)8;
    props.parity = 2;
    props.stopbits = (unsigned int)2;
    props.dtr = 1;
    props.rts = 1;
    signed int return_value_IO_Serial_SetProperties$1;
    return_value_IO_Serial_SetProperties$1=IO_Serial_SetProperties(io, &props);
    if(return_value_IO_Serial_SetProperties$1 == 0)
      return 1;

    else
    {
      ifd->io = io;
      ifd->slot = slot;
      ifd->type = (unsigned char)0x00;
      ret=IFD_Towitoko_SetBaudrate(ifd, (unsigned long int)9600);
      if(!(ret == 0))
      {
        IFD_Towitoko_Clear(ifd);
        return ret;
      }

      else
      {
        ret=IFD_Towitoko_SetParity(ifd, (unsigned char)0x40);
        if(!(ret == 0))
        {
          IFD_Towitoko_Clear(ifd);
          return ret;
        }

        else
        {
          ret=IFD_Towitoko_GetReaderInfo(ifd);
          if(!(ret == 0))
          {
            IFD_Towitoko_Clear(ifd);
            return ret;
          }

          else
          {
            if((signed int)ifd->type == 0x80)
            {
              props.input_bitrate = (unsigned long int)9600;
              props.output_bitrate = (unsigned long int)9600;
              props.bits = (unsigned int)8;
              props.dtr = 1;
              props.rts = 1;
              props.parity = 3;
              props.stopbits = (unsigned int)1;
              signed int return_value_IO_Serial_SetProperties$2;
              return_value_IO_Serial_SetProperties$2=IO_Serial_SetProperties(ifd->io, &props);
              if(return_value_IO_Serial_SetProperties$2 == 0)
              {
                IFD_Towitoko_Clear(ifd);
                return 1;
              }

            }

            return 0;
          }
        }
      }
    }
  }
}

// IFD_Towitoko_New
// file ifd_towitoko.c line 63
extern struct anonymous$6 * IFD_Towitoko_New(void)
{
  struct anonymous$6 *ifd;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$6) /*16ul*/ );
  ifd = (struct anonymous$6 *)return_value_malloc$1;
  if(!(ifd == ((struct anonymous$6 *)NULL)))
    IFD_Towitoko_Clear(ifd);

  return ifd;
}

// IFD_Towitoko_NumTrials
// file ifd_towitoko.c line 1658
static unsigned int IFD_Towitoko_NumTrials(unsigned char b)
{
  unsigned int i;
  unsigned int count = (unsigned int)0;
  i = (unsigned int)0;
  for( ; !(i >= 8u); i = i + 1u)
  {
    count = count + (unsigned int)(((signed int)b & 0x01) == 0x01 ? 1 : 0);
    b = b >> 1;
  }
  return count;
}

// IFD_Towitoko_PrepareCommand
// file ifd_towitoko.c line 1583
static signed int IFD_Towitoko_PrepareCommand(struct anonymous$6 *ifd, unsigned char *command, unsigned char size)
{
  struct anonymous$10 props;
  unsigned char buffer[1l];
  unsigned char initial;
  signed int return_value_IO_Serial_GetProperties$1;
  return_value_IO_Serial_GetProperties$1=IO_Serial_GetProperties(ifd->io, &props);
  if(return_value_IO_Serial_GetProperties$1 == 0)
    return 1;

  else
  {
    if(props.output_bitrate >= 115200ul)
    {
      buffer[(signed long int)0] = (unsigned char)((signed int)size - 1);
      signed int return_value_IO_Serial_Write$2;
      return_value_IO_Serial_Write$2=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)1, buffer);
      if(return_value_IO_Serial_Write$2 == 0)
        return 1;

      initial=IFD_Towitoko_Checksum(buffer, (unsigned int)1, ifd->slot);
    }

    else
      initial = ifd->slot;
    command[(signed long int)((signed int)size - 1)]=IFD_Towitoko_Checksum(command, (unsigned int)((signed int)size - 1), initial);
    return 0;
  }
}

// IFD_Towitoko_ReadBuffer
// file ifd_towitoko.c line 1022
extern signed int IFD_Towitoko_ReadBuffer(struct anonymous$6 *ifd, unsigned int length, unsigned char *data)
{
  unsigned char buffer[2l];
  unsigned char status[1l];
  unsigned int blocks_length;
  unsigned int pointer;
  buffer[(signed long int)0] = (unsigned char)((signed int)(unsigned char)(15 - 1) | 0x10);
  blocks_length = (length / (unsigned int)15) * (unsigned int)15;
  pointer = (unsigned int)0;
  for( ; !(pointer >= blocks_length); pointer = pointer + (unsigned int)15)
  {
    IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)2);
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)2, buffer);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)15, data + (signed long int)pointer);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$3;
    return_value_IO_Serial_Read$3=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$3 == 0)
      return 1;

  }
  if(!(length % 15u == 0u))
  {
    buffer[(signed long int)0] = (unsigned char)((signed int)(unsigned char)(length % (unsigned int)15 - (unsigned int)1) | 0x10);
    IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)2);
    signed int return_value_IO_Serial_Write$4;
    return_value_IO_Serial_Write$4=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)2, buffer);
    if(return_value_IO_Serial_Write$4 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$5;
    return_value_IO_Serial_Read$5=IO_Serial_Read(ifd->io, (unsigned int)1000, length % (unsigned int)15, data + (signed long int)pointer);
    if(return_value_IO_Serial_Read$5 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$6;
    return_value_IO_Serial_Read$6=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$6 == 0)
      return 1;

  }

  return 0;
}

// IFD_Towitoko_ReadErrorCounter
// file ifd_towitoko.c line 1128
extern signed int IFD_Towitoko_ReadErrorCounter(struct anonymous$6 *ifd, signed int icc_type, unsigned int *trials)
{
  unsigned char w21[9l] = { (unsigned char)0x70, (unsigned char)0x64, (unsigned char)0x42, (unsigned char)0x31, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x65, (unsigned char)0x0F, (unsigned char)0x80 };
  unsigned char w22[2l] = { (unsigned char)0x13, (unsigned char)0x27 };
  unsigned char w31[10l] = { (unsigned char)0x70, (unsigned char)0xA0, (unsigned char)0x42, (unsigned char)0xCE, (unsigned char)0xFD, (unsigned char)0xFD, (unsigned char)0x80, (unsigned char)0x50, (unsigned char)0x0F, (unsigned char)0x17 };
  unsigned char w32[2l] = { (unsigned char)0x10, (unsigned char)0x21 };
  unsigned char status[5l];
  if(icc_type == 2)
  {
    IFD_Towitoko_PrepareCommand(ifd, w21, (unsigned char)9);
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)9, w21);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

    IFD_Towitoko_PrepareCommand(ifd, w22, (unsigned char)2);
    signed int return_value_IO_Serial_Write$3;
    return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)2, w22);
    if(return_value_IO_Serial_Write$3 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$4;
    return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)5, status);
    if(return_value_IO_Serial_Read$4 == 0)
      return 1;

    *trials=IFD_Towitoko_NumTrials(status[(signed long int)0]);
  }

  else
    if(icc_type == 3)
    {
      IFD_Towitoko_PrepareCommand(ifd, w31, (unsigned char)10);
      signed int return_value_IO_Serial_Write$5;
      return_value_IO_Serial_Write$5=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)10, w31);
      if(return_value_IO_Serial_Write$5 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$6;
      return_value_IO_Serial_Read$6=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$6 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      IFD_Towitoko_PrepareCommand(ifd, w32, (unsigned char)2);
      signed int return_value_IO_Serial_Write$7;
      return_value_IO_Serial_Write$7=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)2, w32);
      if(return_value_IO_Serial_Write$7 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$8;
      return_value_IO_Serial_Read$8=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)2, status);
      if(return_value_IO_Serial_Read$8 == 0)
        return 1;

      *trials=IFD_Towitoko_NumTrials(status[(signed long int)0]);
    }

  return 0;
}

// IFD_Towitoko_Receive
// file ifd_towitoko.h line 136
extern signed int IFD_Towitoko_Receive(struct anonymous$6 *ifd, struct anonymous$4 *timings, unsigned int size, unsigned char *buffer)
{
  unsigned int char_timeout;
  unsigned int block_timeout;
  if((signed int)ifd->type == 0x80)
    return 4;

  else
  {
    char_timeout = (unsigned int)1000 + timings->char_timeout;
    block_timeout = (unsigned int)1000 + timings->block_timeout;
    if(!(block_timeout == char_timeout))
    {
      signed int return_value_IO_Serial_Read$1;
      return_value_IO_Serial_Read$1=IO_Serial_Read(ifd->io, block_timeout, (unsigned int)1, buffer);
      if(return_value_IO_Serial_Read$1 == 0)
        return 1;

      if(size >= 2u)
      {
        signed int return_value_IO_Serial_Read$2;
        return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, char_timeout, size - (unsigned int)1, buffer + (signed long int)1);
        if(return_value_IO_Serial_Read$2 == 0)
          return 1;

      }

    }

    else
    {
      signed int return_value_IO_Serial_Read$3;
      return_value_IO_Serial_Read$3=IO_Serial_Read(ifd->io, char_timeout, size, buffer);
      if(return_value_IO_Serial_Read$3 == 0)
        return 1;

    }
    return 0;
  }
}

// IFD_Towitoko_ResetAsyncICC
// file ifd_towitoko.h line 134
extern signed int IFD_Towitoko_ResetAsyncICC(struct anonymous$6 *ifd, struct anonymous$7 **atr)
{
  unsigned char buffer1[5l] = { (unsigned char)0x80, (unsigned char)0x6F, (unsigned char)0x00, (unsigned char)0x05, (unsigned char)0x76 };
  unsigned char buffer2[5l] = { (unsigned char)0xA0, (unsigned char)0x6F, (unsigned char)0x00, (unsigned char)0x05, (unsigned char)0x74 };
  signed int i;
  signed int parity;
  signed int ret;
  if((signed int)ifd->type == 0x80)
    return 4;

  else
  {
    buffer1[(signed long int)4]=IFD_Towitoko_Checksum(buffer1, (unsigned int)4, ifd->slot);
    buffer2[(signed long int)4]=IFD_Towitoko_Checksum(buffer2, (unsigned int)4, ifd->slot);
    parity = 0x40;
    ret = 1;
    do
    {
      i = 0;
      for( ; !(i >= 2); i = i + 1)
      {
        signed int return_value_IO_Serial_Write$1;
        return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)5, buffer2);
        if(return_value_IO_Serial_Write$1 == 0)
          break;

        *atr=ATR_New();
        signed int return_value_ATR_InitFromStream$2;
        return_value_ATR_InitFromStream$2=ATR_InitFromStream(*atr, ifd->io, (unsigned int)200);
        if(return_value_ATR_InitFromStream$2 == 0)
        {
          ret = 0;
          break;
        }

        ATR_Delete(*atr);
        *atr = (struct anonymous$7 *)(void *)0;
        signed int return_value_IO_Serial_Write$3;
        return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)5, buffer1);
        if(return_value_IO_Serial_Write$3 == 0)
          break;

        *atr=ATR_New();
        signed int return_value_ATR_InitFromStream$4;
        return_value_ATR_InitFromStream$4=ATR_InitFromStream(*atr, ifd->io, (unsigned int)200);
        if(return_value_ATR_InitFromStream$4 == 0)
        {
          ret = 0;
          break;
        }

        ATR_Delete(*atr);
        *atr = (struct anonymous$7 *)(void *)0;
      }
      if(ret == 0)
      {
        if(parity == 0x80)
        {
          parity = 0x40;
          ret=IFD_Towitoko_SetParity(ifd, (unsigned char)parity);
        }

      }

      else
      {
        parity = parity == 0x40 ? 0x80 : 0x40;
        IFD_Towitoko_SetParity(ifd, (unsigned char)parity);
      }
    }
    while(!(parity == 0x40));
    return ret;
  }
}

// IFD_Towitoko_ResetSyncICC
// file ifd_towitoko.c line 758
extern signed int IFD_Towitoko_ResetSyncICC(struct anonymous$6 *ifd, struct anonymous$19 **atr)
{
  unsigned char buffer[5l] = { (unsigned char)0x70, (unsigned char)0x80, (unsigned char)0x62, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char atr_buffer[8l];
  unsigned char status[1l];
  IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)5);
  signed int return_value_IO_Serial_Write$1;
  return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)5, buffer);
  if(return_value_IO_Serial_Write$1 == 0)
    return 1;

  else
  {
    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    else
      if(!((signed int)status[0l] == 0x01))
        return 2;

      else
      {
        signed int return_value_IFD_Towitoko_ReadBuffer$3;
        return_value_IFD_Towitoko_ReadBuffer$3=IFD_Towitoko_ReadBuffer(ifd, (unsigned int)8, atr_buffer);
        if(!(return_value_IFD_Towitoko_ReadBuffer$3 == 0))
          return 1;

        else
        {
          if(!((signed int)atr_buffer[0l] == 0xFF))
          {
            *atr=ATR_Sync_New();
            if(!(*atr == ((struct anonymous$19 *)NULL)))
              ATR_Sync_Init(*atr, atr_buffer, (unsigned int)4);

          }

          else
            *atr = (struct anonymous$19 *)(void *)0;
          return 0;
        }
      }
  }
}

// IFD_Towitoko_SetBaudrate
// file ifd_towitoko.h line 123
extern signed int IFD_Towitoko_SetBaudrate(struct anonymous$6 *ifd, unsigned long int baudrate)
{
  unsigned char status[1l];
  unsigned char buffer[6l] = { (unsigned char)0x6E, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00 };
  struct anonymous$10 props;
  struct timespec req_ts;
  unsigned long int return_value_IFD_Towitoko_GetMaxBaudrate$1;
  return_value_IFD_Towitoko_GetMaxBaudrate$1=IFD_Towitoko_GetMaxBaudrate(ifd);
  if(!(return_value_IFD_Towitoko_GetMaxBaudrate$1 >= baudrate))
    return 3;

  else
  {
    signed int return_value_IO_Serial_GetProperties$2;
    return_value_IO_Serial_GetProperties$2=IO_Serial_GetProperties(ifd->io, &props);
    if(return_value_IO_Serial_GetProperties$2 == 0)
      return 1;

    else
      if(props.output_bitrate == baudrate)
        return 0;

      else
      {
        if(!(baudrate >= 1201ul))
        {
          buffer[(signed long int)1] = (unsigned char)0x60;
          buffer[(signed long int)3] = (unsigned char)0x07;
        }

        else
          if(!(baudrate >= 2401ul))
          {
            buffer[(signed long int)1] = (unsigned char)0x2E;
            buffer[(signed long int)3] = (unsigned char)0x03;
          }

          else
            if(!(baudrate >= 4801ul))
            {
              buffer[(signed long int)1] = (unsigned char)0x17;
              buffer[(signed long int)3] = (unsigned char)0x05;
            }

            else
              if(!(baudrate >= 6976ul))
              {
                buffer[(signed long int)1] = (unsigned char)0x0F;
                buffer[(signed long int)3] = (unsigned char)0x01;
              }

              else
                if(!(baudrate >= 9601ul))
                {
                  buffer[(signed long int)1] = (unsigned char)0x0B;
                  buffer[(signed long int)3] = (unsigned char)0x02;
                }

                else
                  if(!(baudrate >= 14401ul))
                  {
                    buffer[(signed long int)1] = (unsigned char)0x07;
                    buffer[(signed long int)3] = (unsigned char)0x01;
                  }

                  else
                    if(!(baudrate >= 19201ul))
                    {
                      buffer[(signed long int)1] = (unsigned char)0x05;
                      buffer[(signed long int)3] = (unsigned char)0x02;
                    }

                    else
                      if(!(baudrate >= 28801ul))
                      {
                        buffer[(signed long int)1] = (unsigned char)0x03;
                        buffer[(signed long int)3] = (unsigned char)0x00;
                      }

                      else
                        if(!(baudrate >= 38401ul))
                        {
                          buffer[(signed long int)1] = (unsigned char)0x02;
                          buffer[(signed long int)3] = (unsigned char)0x00;
                        }

                        else
                          if(!(baudrate >= 57601ul))
                          {
                            buffer[(signed long int)1] = (unsigned char)0x01;
                            buffer[(signed long int)3] = (unsigned char)0x00;
                          }

                          else
                            if(!(baudrate >= 115201ul))
                            {
                              buffer[(signed long int)1] = (unsigned char)0x80;
                              buffer[(signed long int)3] = (unsigned char)0x00;
                            }

                            else
                              return 3;
        buffer[(signed long int)2] = (unsigned char)((signed int)buffer[(signed long int)1] ^ 0x5D);
        IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)6);
        signed int return_value_IO_Serial_Write$3;
        return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)6, buffer);
        if(return_value_IO_Serial_Write$3 == 0)
          return 1;

        else
        {
          signed int return_value_IO_Serial_Read$4;
          return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
          if(return_value_IO_Serial_Read$4 == 0)
            return 1;

          else
            if(!((signed int)status[0l] == 0x01))
              return 2;

            else
            {
              props.output_bitrate = baudrate;
              props.input_bitrate = baudrate;
              signed int return_value_IO_Serial_SetProperties$5;
              return_value_IO_Serial_SetProperties$5=IO_Serial_SetProperties(ifd->io, &props);
              if(return_value_IO_Serial_SetProperties$5 == 0)
                return 1;

              else
              {
                req_ts.tv_sec = (signed long int)0;
                req_ts.tv_nsec = 150000000L;
                nanosleep(&req_ts, (struct timespec *)(void *)0);
                return 0;
              }
            }
        }
      }
  }
}

// IFD_Towitoko_SetLED
// file ifd_towitoko.h line 126
extern signed int IFD_Towitoko_SetLED(struct anonymous$6 *ifd, unsigned char color)
{
  unsigned char status[1l];
  unsigned char buffer[5l] = { (unsigned char)0x6F, (unsigned char)0x00, (unsigned char)0x6A, (unsigned char)0x0F, (unsigned char)0x00 };
  if(!((signed int)color == 0x00) && !((signed int)color == 0x01) && !((signed int)color == 0x02) && !((signed int)color == 0x03))
    return 3;

  else
  {
    buffer[(signed long int)1] = color;
    IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)5);
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)5, buffer);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    else
    {
      signed int return_value_IO_Serial_Read$2;
      return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$2 == 0)
        return 1;

      else
        if(!((signed int)status[0l] == 0x01))
          return 2;

        else
          return 0;
    }
  }
}

// IFD_Towitoko_SetParity
// file ifd_towitoko.h line 125
extern signed int IFD_Towitoko_SetParity(struct anonymous$6 *ifd, unsigned char parity)
{
  unsigned char buffer[5l] = { (unsigned char)0x6F, (unsigned char)0x00, (unsigned char)0x6A, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char status[1l];
  struct anonymous$10 props;
  if((signed int)ifd->type == 0x80)
    return 4;

  else
    if(!((signed int)parity == 0x40) && !((signed int)parity == 0x80))
      return 3;

    else
    {
      signed int return_value_IO_Serial_GetProperties$1;
      return_value_IO_Serial_GetProperties$1=IO_Serial_GetProperties(ifd->io, &props);
      if(return_value_IO_Serial_GetProperties$1 == 0)
        return 1;

      else
      {
        if(props.parity == 1)
        {
          props.parity = 2;
          signed int return_value_IO_Serial_SetProperties$2;
          return_value_IO_Serial_SetProperties$2=IO_Serial_SetProperties(ifd->io, &props);
          if(return_value_IO_Serial_SetProperties$2 == 0)
            return 1;

        }

        buffer[(signed long int)1] = parity;
        IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)5);
        signed int return_value_IO_Serial_Write$3;
        return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)5, buffer);
        if(return_value_IO_Serial_Write$3 == 0)
          return 1;

        else
        {
          signed int return_value_IO_Serial_Read$4;
          return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
          if(return_value_IO_Serial_Read$4 == 0)
            return 1;

          else
          {
            if(props.parity == 2 && (signed int)parity == 0x80)
            {
              props.parity = 1;
              signed int return_value_IO_Serial_SetProperties$5;
              return_value_IO_Serial_SetProperties$5=IO_Serial_SetProperties(ifd->io, &props);
              if(return_value_IO_Serial_SetProperties$5 == 0)
                return 1;

            }

            return 0;
          }
        }
      }
    }
}

// IFD_Towitoko_SetReadAddress
// file ifd_towitoko.c line 792
extern signed int IFD_Towitoko_SetReadAddress(struct anonymous$6 *ifd, signed int icc_type, unsigned short int address)
{
  unsigned char status[1l];
  unsigned char i2cShort[10l] = { (unsigned char)0x7C, (unsigned char)0x64, (unsigned char)0x41, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x64, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char i2cLong[11l] = { (unsigned char)0x7C, (unsigned char)0x64, (unsigned char)0x42, (unsigned char)0xA0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x64, (unsigned char)0x40, (unsigned char)0xA1, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char w2[9l] = { (unsigned char)0x70, (unsigned char)0x64, (unsigned char)0x42, (unsigned char)0x30, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x65, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char w3[10l] = { (unsigned char)0x70, (unsigned char)0xA0, (unsigned char)0x42, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x50, (unsigned char)0x0F, (unsigned char)0x00 };
  if(icc_type == 0)
  {
    i2cShort[(signed long int)3] = (unsigned char)((((signed int)address & 0xff00) >> 8) << 1 | 0xA0);
    i2cShort[(signed long int)4] = (unsigned char)((signed int)address & 0x00ff);
    i2cShort[(signed long int)7] = (unsigned char)((((signed int)address & 0xff00) >> 8) << 1 | 0xA0 | 0x01);
    IFD_Towitoko_PrepareCommand(ifd, i2cShort, (unsigned char)10);
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)10, i2cShort);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

  }

  else
    if(icc_type == 1)
    {
      i2cLong[(signed long int)4] = (unsigned char)(((signed int)address & 0xff00) >> 8);
      i2cLong[(signed long int)5] = (unsigned char)((signed int)address & 0x00ff);
      IFD_Towitoko_PrepareCommand(ifd, i2cLong, (unsigned char)11);
      signed int return_value_IO_Serial_Write$3;
      return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)11, i2cLong);
      if(return_value_IO_Serial_Write$3 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$4;
      return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$4 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

    }

    else
      if(icc_type == 2)
      {
        w2[(signed long int)4] = (unsigned char)((signed int)address & 0x00ff);
        IFD_Towitoko_PrepareCommand(ifd, w2, (unsigned char)9);
        signed int return_value_IO_Serial_Write$5;
        return_value_IO_Serial_Write$5=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)9, w2);
        if(return_value_IO_Serial_Write$5 == 0)
          return 1;

        signed int return_value_IO_Serial_Read$6;
        return_value_IO_Serial_Read$6=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
        if(return_value_IO_Serial_Read$6 == 0)
          return 1;

        if(!((signed int)status[0l] == 0x01))
          return 2;

      }

      else
        if(icc_type == 3)
        {
          w3[(signed long int)3] = (unsigned char)((((signed int)address & 0xff00) >> 8) << 6 | 0x0E);
          w3[(signed long int)4] = (unsigned char)((signed int)address & 0x00ff);
          IFD_Towitoko_PrepareCommand(ifd, w3, (unsigned char)10);
          signed int return_value_IO_Serial_Write$7;
          return_value_IO_Serial_Write$7=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)10, w3);
          if(return_value_IO_Serial_Write$7 == 0)
            return 1;

          signed int return_value_IO_Serial_Read$8;
          return_value_IO_Serial_Read$8=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
          if(return_value_IO_Serial_Read$8 == 0)
            return 1;

          if(!((signed int)status[0l] == 0x01))
            return 2;

        }

        else
          return 3;
  return 0;
}

// IFD_Towitoko_SetWriteAddress
// file ifd_towitoko.c line 887
extern signed int IFD_Towitoko_SetWriteAddress(struct anonymous$6 *ifd, signed int icc_type, unsigned short int address, unsigned char pagemode)
{
  unsigned char i2cShort1[10l] = { (unsigned char)0x7C, (unsigned char)0x64, (unsigned char)0x41, (unsigned char)0xA0, (unsigned char)0x00, (unsigned char)0x64, (unsigned char)0x40, (unsigned char)0xA1, (unsigned char)0x0F, (unsigned char)0x36 };
  unsigned char i2cShort2[3l] = { (unsigned char)0x7E, (unsigned char)0x10, (unsigned char)0xDA };
  unsigned char i2cShort3[8l] = { (unsigned char)0x7E, (unsigned char)0x66, (unsigned char)0x6E, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char i2cLong1[11l] = { (unsigned char)0x7C, (unsigned char)0x64, (unsigned char)0x42, (unsigned char)0xA0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x64, (unsigned char)0x40, (unsigned char)0xA1, (unsigned char)0x0F, (unsigned char)0x0B };
  unsigned char i2cLong2[3l] = { (unsigned char)0x7E, (unsigned char)0x10, (unsigned char)0xDA };
  unsigned char i2cLong3[8l] = { (unsigned char)0x7F, (unsigned char)0x66, (unsigned char)0x6E, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xA0, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char w2[7l] = { (unsigned char)0x72, (unsigned char)0x6E, (unsigned char)0x00, (unsigned char)0x38, (unsigned char)0x03, (unsigned char)0x0F, (unsigned char)0x00 };
  unsigned char w3[8l] = { (unsigned char)0x73, (unsigned char)0x67, (unsigned char)0x6E, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x0F, (unsigned char)0x5F };
  unsigned char status[2l];
  if(icc_type == 0)
  {
    IFD_Towitoko_PrepareCommand(ifd, i2cShort1, (unsigned char)10);
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)10, i2cShort1);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

    IFD_Towitoko_PrepareCommand(ifd, i2cShort2, (unsigned char)3);
    signed int return_value_IO_Serial_Write$3;
    return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)3, i2cShort2);
    if(return_value_IO_Serial_Write$3 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$4;
    return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)2, status);
    if(return_value_IO_Serial_Read$4 == 0)
      return 1;

    i2cShort3[(signed long int)3] = (unsigned char)((signed int)address & 0x00ff);
    i2cShort3[(signed long int)4] = (unsigned char)((((signed int)address & 0xff00) >> 8) << 1 | 0xA0);
    i2cShort3[(signed long int)5] = pagemode;
    IFD_Towitoko_PrepareCommand(ifd, i2cShort3, (unsigned char)8);
    signed int return_value_IO_Serial_Write$5;
    return_value_IO_Serial_Write$5=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, i2cShort3);
    if(return_value_IO_Serial_Write$5 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$6;
    return_value_IO_Serial_Read$6=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$6 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

  }

  else
    if(icc_type == 1)
    {
      IFD_Towitoko_PrepareCommand(ifd, i2cLong1, (unsigned char)11);
      signed int return_value_IO_Serial_Write$7;
      return_value_IO_Serial_Write$7=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)11, i2cLong1);
      if(return_value_IO_Serial_Write$7 == 0)
        return 2;

      signed int return_value_IO_Serial_Read$8;
      return_value_IO_Serial_Read$8=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$8 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

      IFD_Towitoko_PrepareCommand(ifd, i2cLong2, (unsigned char)3);
      signed int return_value_IO_Serial_Write$9;
      return_value_IO_Serial_Write$9=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)3, i2cLong2);
      if(return_value_IO_Serial_Write$9 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$10;
      return_value_IO_Serial_Read$10=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)2, status);
      if(return_value_IO_Serial_Read$10 == 0)
        return 1;

      i2cLong3[(signed long int)3] = (unsigned char)((signed int)address & 0x00ff);
      i2cLong3[(signed long int)4] = (unsigned char)(((signed int)address & 0xff00) >> 8);
      IFD_Towitoko_PrepareCommand(ifd, i2cLong3, (unsigned char)8);
      signed int return_value_IO_Serial_Write$11;
      return_value_IO_Serial_Write$11=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, i2cLong3);
      if(return_value_IO_Serial_Write$11 == 0)
        return 1;

      signed int return_value_IO_Serial_Read$12;
      return_value_IO_Serial_Read$12=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
      if(return_value_IO_Serial_Read$12 == 0)
        return 1;

      if(!((signed int)status[0l] == 0x01))
        return 2;

    }

    else
      if(icc_type == 2)
      {
        w2[(signed long int)2] = (unsigned char)((signed int)address & 0x00ff);
        IFD_Towitoko_PrepareCommand(ifd, w2, (unsigned char)7);
        signed int return_value_IO_Serial_Write$13;
        return_value_IO_Serial_Write$13=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)7, w2);
        if(return_value_IO_Serial_Write$13 == 0)
          return 1;

        signed int return_value_IO_Serial_Read$14;
        return_value_IO_Serial_Read$14=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
        if(return_value_IO_Serial_Read$14 == 0)
          return 1;

        if(!((signed int)status[0l] == 0x01))
          return 2;

      }

      else
        if(icc_type == 3)
        {
          w3[(signed long int)3] = (unsigned char)((signed int)address & 0x00ff);
          w3[(signed long int)4] = (unsigned char)((((signed int)address & 0xff00) >> 8) << 6 | 0x33);
          IFD_Towitoko_PrepareCommand(ifd, w3, (unsigned char)8);
          signed int return_value_IO_Serial_Write$15;
          return_value_IO_Serial_Write$15=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)8, w3);
          if(return_value_IO_Serial_Write$15 == 0)
            return 1;

          signed int return_value_IO_Serial_Read$16;
          return_value_IO_Serial_Read$16=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
          if(return_value_IO_Serial_Read$16 == 0)
            return 1;

          if(!((signed int)status[0l] == 0x01))
            return 2;

        }

        else
          return 3;
  return 0;
}

// IFD_Towitoko_Switch
// file ifd_towitoko.h line 137
extern signed int IFD_Towitoko_Switch(struct anonymous$6 *ifd)
{
  struct anonymous$10 props;
  unsigned char buffer[1l] = { (unsigned char)0xF8 };
  signed int return_value_IO_Serial_GetProperties$1;
  return_value_IO_Serial_GetProperties$1=IO_Serial_GetProperties(ifd->io, &props);
  if(return_value_IO_Serial_GetProperties$1 == 0)
    return 1;

  else
  {
    if(props.output_bitrate >= 9601ul)
    {
      signed int return_value_IO_Serial_Write$2;
      return_value_IO_Serial_Write$2=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)1, buffer);
      if(return_value_IO_Serial_Write$2 == 0)
        return 1;

    }

    return 0;
  }
}

// IFD_Towitoko_Transmit
// file ifd_towitoko.h line 135
extern signed int IFD_Towitoko_Transmit(struct anonymous$6 *ifd, struct anonymous$4 *timings, unsigned int size, unsigned char *buffer)
{
  unsigned char header[6l] = { (unsigned char)0x6F, (unsigned char)0x00, (unsigned char)0x05, (unsigned char)0x00, (unsigned char)0xFE, (unsigned char)0xF8 };
  unsigned int block_delay;
  unsigned int char_delay;
  unsigned int sent = (unsigned int)0;
  unsigned int to_send = (unsigned int)0;
  struct anonymous$10 props;
  signed int s = 0;
  if((signed int)ifd->type == 0x80)
    return 4;

  else
  {
    signed int return_value_IO_Serial_GetProperties$1;
    return_value_IO_Serial_GetProperties$1=IO_Serial_GetProperties(ifd->io, &props);
    if(return_value_IO_Serial_GetProperties$1 == 0)
      return 1;

    else
    {
      s = (signed int)(props.output_bitrate > (unsigned long int)9600);
      char_delay = (unsigned int)0 + timings->char_delay;
      block_delay = (unsigned int)0 + timings->block_delay;
      sent = (unsigned int)0;
      for( ; !(sent >= size); sent = sent + to_send)
      {
        to_send = size < (unsigned int)255 ? size : (unsigned int)255;
        header[(signed long int)1] = (unsigned char)to_send;
        IFD_Towitoko_PrepareCommand(ifd, header, (unsigned char)4);
        signed int return_value_IO_Serial_Write$2;
        return_value_IO_Serial_Write$2=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)(s != 0 ? 6 : 4), header);
        if(return_value_IO_Serial_Write$2 == 0)
          return 1;

        if(sent == 0u && !(block_delay == char_delay))
        {
          signed int return_value_IO_Serial_Write$3;
          return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, block_delay, (unsigned int)1, buffer);
          if(return_value_IO_Serial_Write$3 == 0)
            return 1;

          signed int return_value_IO_Serial_Write$4;
          return_value_IO_Serial_Write$4=IO_Serial_Write(ifd->io, char_delay, to_send - (unsigned int)1, buffer + (signed long int)1);
          if(return_value_IO_Serial_Write$4 == 0)
            return 1;

        }

        else
        {
          signed int return_value_IO_Serial_Write$5;
          return_value_IO_Serial_Write$5=IO_Serial_Write(ifd->io, char_delay, to_send, buffer + (signed long int)sent);
          if(return_value_IO_Serial_Write$5 == 0)
            return 1;

        }
      }
      return 0;
    }
  }
}

// IFD_Towitoko_WriteBuffer
// file ifd_towitoko.c line 1073
extern signed int IFD_Towitoko_WriteBuffer(struct anonymous$6 *ifd, unsigned int length, unsigned char *data)
{
  unsigned char buffer[17l];
  unsigned char status[1l];
  unsigned int blocks_length;
  unsigned int remaining_length;
  unsigned int pointer;
  buffer[(signed long int)0] = (unsigned char)0x4E;
  blocks_length = (length / (unsigned int)15) * (unsigned int)15;
  pointer = (unsigned int)0;
  for( ; !(pointer >= blocks_length); pointer = pointer + (unsigned int)15)
  {
    memcpy((void *)(buffer + (signed long int)1), (const void *)(data + (signed long int)pointer), (unsigned long int)15);
    IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)(15 + 2));
    signed int return_value_IO_Serial_Write$1;
    return_value_IO_Serial_Write$1=IO_Serial_Write(ifd->io, (unsigned int)0, (unsigned int)(15 + 2), buffer);
    if(return_value_IO_Serial_Write$1 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$2;
    return_value_IO_Serial_Read$2=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$2 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

  }
  remaining_length = length % (unsigned int)15;
  if(!(remaining_length == 0u))
  {
    buffer[(signed long int)0] = (unsigned char)((signed int)(unsigned char)(remaining_length - (unsigned int)1) | 0x40);
    memcpy((void *)(buffer + (signed long int)1), (const void *)(data + (signed long int)pointer), (unsigned long int)remaining_length);
    buffer[(signed long int)(remaining_length + (unsigned int)1)] = (unsigned char)0x0F;
    IFD_Towitoko_PrepareCommand(ifd, buffer, (unsigned char)(remaining_length + (unsigned int)3));
    signed int return_value_IO_Serial_Write$3;
    return_value_IO_Serial_Write$3=IO_Serial_Write(ifd->io, (unsigned int)0, remaining_length + (unsigned int)3, buffer);
    if(return_value_IO_Serial_Write$3 == 0)
      return 1;

    signed int return_value_IO_Serial_Read$4;
    return_value_IO_Serial_Read$4=IO_Serial_Read(ifd->io, (unsigned int)1000, (unsigned int)1, status);
    if(return_value_IO_Serial_Read$4 == 0)
      return 1;

    if(!((signed int)status[0l] == 0x01))
      return 2;

  }

  return 0;
}

// IO_Serial_Bitrate
// file io_serial.c line 671
static signed int IO_Serial_Bitrate(signed int bitrate)
{
  if(bitrate >= 230400)
    return 0010003;

  else
    if(bitrate >= 115200)
      return 0010002;

    else
      if(bitrate >= 57600)
        return 0010001;

      else
        if(bitrate >= 38400)
          return 0000017;

        else
          if(bitrate >= 19200)
            return 0000016;

          else
            if(bitrate >= 9600)
              return 0000015;

            else
              if(bitrate >= 4800)
                return 0000014;

              else
                if(bitrate >= 2400)
                  return 0000013;

                else
                  if(bitrate >= 1800)
                    return 0000012;

                  else
                    if(bitrate >= 1200)
                      return 0000011;

                    else
                      if(bitrate >= 600)
                        return 0000010;

                      else
                        if(bitrate >= 300)
                          return 0000007;

                        else
                          if(bitrate >= 200)
                            return 0000006;

                          else
                            if(bitrate >= 150)
                              return 0000005;

                            else
                              if(bitrate >= 134)
                                return 0000004;

                              else
                                if(bitrate >= 110)
                                  return 0000003;

                                else
                                  if(bitrate >= 75)
                                    return 0000002;

                                  else
                                    if(bitrate >= 50)
                                      return 0000001;

                                    else
                                      if(bitrate >= 0)
                                        return 0000000;

                                      else
                                        return 0;
}

// IO_Serial_Clear
// file io_serial.c line 829
static void IO_Serial_Clear(struct anonymous$9 *io)
{
  io->fd = -1;
  io->props = (struct anonymous$10 *)(void *)0;
  io->com = (unsigned int)0;
  memset((void *)io->PnP_id, 0, (unsigned long int)256);
  io->PnP_id_size = (unsigned int)0;
  io->usbserial = 0;
}

// IO_Serial_ClearPropertiesCache
// file io_serial.c line 874
static void IO_Serial_ClearPropertiesCache(struct anonymous$9 *io)
{
  if(!(io->props == ((struct anonymous$10 *)NULL)))
  {
    free((void *)io->props);
    io->props = (struct anonymous$10 *)(void *)0;
  }

}

// IO_Serial_Close
// file io_serial.c line 637
extern signed int IO_Serial_Close(struct anonymous$9 *io)
{
  char filename[32l];
  IO_Serial_DeviceName(io->com, io->usbserial, filename, (unsigned int)32);
  signed int return_value_close$1;
  return_value_close$1=close(io->fd);
  if(!(return_value_close$1 == 0))
    return 0;

  else
  {
    IO_Serial_ClearPropertiesCache(io);
    IO_Serial_Clear(io);
    return 1;
  }
}

// IO_Serial_Delete
// file io_serial.c line 658
extern void IO_Serial_Delete(struct anonymous$9 *io)
{
  if(!(io->props == ((struct anonymous$10 *)NULL)))
    free((void *)io->props);

  free((void *)io);
}

// IO_Serial_DeviceName
// file io_serial.c line 887
static void IO_Serial_DeviceName(unsigned int com, signed int usbserial, char *filename, unsigned int length)
{
  if(!(usbserial == 0))
    snprintf(filename, (unsigned long int)length, "/dev/ttyUSB%d", com - (unsigned int)1);

  else
    snprintf(filename, (unsigned long int)length, "/dev/ttyS%d", com - (unsigned int)1);
}

// IO_Serial_GetCom
// file io_serial.c line 529
extern unsigned int IO_Serial_GetCom(struct anonymous$9 *io)
{
  return io->com;
}

// IO_Serial_GetPnPId
// file io_serial.c line 522
extern void IO_Serial_GetPnPId(struct anonymous$9 *io, unsigned char *pnp_id, unsigned int *length)
{
  *length = io->PnP_id_size;
  memcpy((void *)pnp_id, (const void *)io->PnP_id, (unsigned long int)io->PnP_id_size);
}

// IO_Serial_GetProperties
// file io_serial.c line 120
extern signed int IO_Serial_GetProperties(struct anonymous$9 *io, struct anonymous$10 *props)
{
  struct termios currtio;
  unsigned int i_speed;
  unsigned int o_speed;
  unsigned int mctl;
  signed int return_value_IO_Serial_GetPropertiesCache$1;
  return_value_IO_Serial_GetPropertiesCache$1=IO_Serial_GetPropertiesCache(io, props);
  if(!(return_value_IO_Serial_GetPropertiesCache$1 == 0))
    return 1;

  else
  {
    signed int return_value_tcgetattr$2;
    return_value_tcgetattr$2=tcgetattr(io->fd, &currtio);
    if(!(return_value_tcgetattr$2 == 0))
      return 0;

    else
    {
      o_speed=cfgetospeed(&currtio);
      switch(o_speed)
      {
        case (unsigned int)0000000:
        {
          props->output_bitrate = (unsigned long int)0;
          break;
        }
        case (unsigned int)0000001:
        {
          props->output_bitrate = (unsigned long int)50;
          break;
        }
        case (unsigned int)0000002:
        {
          props->output_bitrate = (unsigned long int)75;
          break;
        }
        case (unsigned int)0000003:
        {
          props->output_bitrate = (unsigned long int)110;
          break;
        }
        case (unsigned int)0000004:
        {
          props->output_bitrate = (unsigned long int)134;
          break;
        }
        case (unsigned int)0000005:
        {
          props->output_bitrate = (unsigned long int)150;
          break;
        }
        case (unsigned int)0000006:
        {
          props->output_bitrate = (unsigned long int)200;
          break;
        }
        case (unsigned int)0000007:
        {
          props->output_bitrate = (unsigned long int)300;
          break;
        }
        case (unsigned int)0000010:
        {
          props->output_bitrate = (unsigned long int)600;
          break;
        }
        case (unsigned int)0000011:
        {
          props->output_bitrate = (unsigned long int)1200;
          break;
        }
        case (unsigned int)0000012:
        {
          props->output_bitrate = (unsigned long int)1800;
          break;
        }
        case (unsigned int)0000013:
        {
          props->output_bitrate = (unsigned long int)2400;
          break;
        }
        case (unsigned int)0000014:
        {
          props->output_bitrate = (unsigned long int)4800;
          break;
        }
        case (unsigned int)0000015:
        {
          props->output_bitrate = (unsigned long int)9600;
          break;
        }
        case (unsigned int)0000016:
        {
          props->output_bitrate = (unsigned long int)19200;
          break;
        }
        case (unsigned int)0000017:
        {
          props->output_bitrate = (unsigned long int)38400;
          break;
        }
        case (unsigned int)0010001:
        {
          props->output_bitrate = (unsigned long int)57600;
          break;
        }
        case (unsigned int)0010002:
        {
          props->output_bitrate = (unsigned long int)115200;
          break;
        }
        case (unsigned int)0010003:
        {
          props->output_bitrate = (unsigned long int)230400;
          break;
        }
        default:
          props->output_bitrate = (unsigned long int)1200;
      }
      i_speed=cfgetispeed(&currtio);
      switch(i_speed)
      {
        case (unsigned int)0000000:
        {
          props->input_bitrate = (unsigned long int)0;
          break;
        }
        case (unsigned int)0000001:
        {
          props->input_bitrate = (unsigned long int)50;
          break;
        }
        case (unsigned int)0000002:
        {
          props->input_bitrate = (unsigned long int)75;
          break;
        }
        case (unsigned int)0000003:
        {
          props->input_bitrate = (unsigned long int)110;
          break;
        }
        case (unsigned int)0000004:
        {
          props->input_bitrate = (unsigned long int)134;
          break;
        }
        case (unsigned int)0000005:
        {
          props->input_bitrate = (unsigned long int)150;
          break;
        }
        case (unsigned int)0000006:
        {
          props->input_bitrate = (unsigned long int)200;
          break;
        }
        case (unsigned int)0000007:
        {
          props->input_bitrate = (unsigned long int)300;
          break;
        }
        case (unsigned int)0000010:
        {
          props->input_bitrate = (unsigned long int)600;
          break;
        }
        case (unsigned int)0000011:
        {
          props->input_bitrate = (unsigned long int)1200;
          break;
        }
        case (unsigned int)0000012:
        {
          props->input_bitrate = (unsigned long int)1800;
          break;
        }
        case (unsigned int)0000013:
        {
          props->input_bitrate = (unsigned long int)2400;
          break;
        }
        case (unsigned int)0000014:
        {
          props->input_bitrate = (unsigned long int)4800;
          break;
        }
        case (unsigned int)0000015:
        {
          props->input_bitrate = (unsigned long int)9600;
          break;
        }
        case (unsigned int)0000016:
        {
          props->input_bitrate = (unsigned long int)19200;
          break;
        }
        case (unsigned int)0000017:
        {
          props->input_bitrate = (unsigned long int)38400;
          break;
        }
        case (unsigned int)0010001:
        {
          props->input_bitrate = (unsigned long int)57600;
          break;
        }
        case (unsigned int)0010002:
        {
          props->input_bitrate = (unsigned long int)115200;
          break;
        }
        case (unsigned int)0010003:
        {
          props->input_bitrate = (unsigned long int)230400;
          break;
        }
        default:
          props->input_bitrate = (unsigned long int)1200;
      }
      switch(currtio.c_cflag & (unsigned int)0000060)
      {
        case (unsigned int)0000000:
        {
          props->bits = (unsigned int)5;
          break;
        }
        case (unsigned int)0000020:
        {
          props->bits = (unsigned int)6;
          break;
        }
        case (unsigned int)0000040:
        {
          props->bits = (unsigned int)7;
          break;
        }
        case (unsigned int)0000060:
          props->bits = (unsigned int)8;
      }
      if((256u & currtio.c_cflag) == 256u)
      {
        if((512u & currtio.c_cflag) == 512u)
          props->parity = 1;

        else
          props->parity = 2;
      }

      else
        props->parity = 3;
      if((64u & currtio.c_cflag) == 64u)
        props->stopbits = (unsigned int)2;

      else
        props->stopbits = (unsigned int)1;
      signed int return_value_ioctl$3;
      return_value_ioctl$3=ioctl(io->fd, (unsigned long int)0x5415, &mctl);
      if(!(return_value_ioctl$3 >= 0))
        return 0;

      else
      {
        props->dtr = (mctl & (unsigned int)0x002) != 0u ? 1 : 0;
        props->rts = (mctl & (unsigned int)0x004) != 0u ? 1 : 0;
        IO_Serial_SetPropertiesCache(io, props);
        return 1;
      }
    }
  }
}

// IO_Serial_GetPropertiesCache
// file io_serial.c line 852
static signed int IO_Serial_GetPropertiesCache(struct anonymous$9 *io, struct anonymous$10 *props)
{
  if(!(io->props == ((struct anonymous$10 *)NULL)))
  {
    memcpy((void *)props, (const void *)io->props, sizeof(struct anonymous$10) /*40ul*/ );
    return 1;
  }

  else
    return 0;
}

// IO_Serial_Init
// file io_serial.c line 92
extern signed int IO_Serial_Init(struct anonymous$9 *io, unsigned int com, signed int usbserial, signed int pnp)
{
  char filename[32l];
  IO_Serial_DeviceName(com, usbserial, filename, (unsigned int)32);
  if(!(com >= 1u))
    return 0;

  else
  {
    io->com = com;
    io->fd=open(filename, 02 | 0400);
    if(!(io->fd >= 0))
      return 0;

    else
    {
      if(!(pnp == 0))
        IO_Serial_InitPnP(io);

      io->usbserial = usbserial;
      return 1;
    }
  }
}

// IO_Serial_InitPnP
// file io_serial.c line 961
static signed int IO_Serial_InitPnP(struct anonymous$9 *io)
{
  struct anonymous$10 props;
  signed int i = 0;
  props.input_bitrate = (unsigned long int)1200;
  props.output_bitrate = (unsigned long int)1200;
  props.parity = 3;
  props.bits = (unsigned int)7;
  props.stopbits = (unsigned int)1;
  props.dtr = 1;
  props.rts = 1;
  signed int return_value_IO_Serial_SetProperties$1;
  return_value_IO_Serial_SetProperties$1=IO_Serial_SetProperties(io, &props);
  signed int return_value_IO_Serial_Read$2;
  if(return_value_IO_Serial_SetProperties$1 == 0)
    return 0;

  else
  {
    for( ; !(i >= 256); i = i + 1)
    {
      return_value_IO_Serial_Read$2=IO_Serial_Read(io, (unsigned int)200, (unsigned int)1, &io->PnP_id[(signed long int)i]);
      if(return_value_IO_Serial_Read$2 == 0)
        break;

    }
    io->PnP_id_size = (unsigned int)i;
    return 1;
  }
}

// IO_Serial_New
// file io_serial.c line 80
extern struct anonymous$9 * IO_Serial_New(void)
{
  struct anonymous$9 *io;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$9) /*288ul*/ );
  io = (struct anonymous$9 *)return_value_malloc$1;
  if(!(io == ((struct anonymous$9 *)NULL)))
    IO_Serial_Clear(io);

  return io;
}

// IO_Serial_Read
// file io_serial.h line 90
extern signed int IO_Serial_Read(struct anonymous$9 *io, unsigned int timeout, unsigned int size, unsigned char *data)
{
  unsigned char c;
  signed int count = 0;
  count = 0;
  for( ; !((unsigned int)count >= size); count = count + 1)
  {
    signed int return_value_IO_Serial_WaitToRead$2;
    return_value_IO_Serial_WaitToRead$2=IO_Serial_WaitToRead(io->fd, (unsigned int)0, timeout);
    if(!(return_value_IO_Serial_WaitToRead$2 == 0))
    {
      signed long int return_value_read$1;
      return_value_read$1=read(io->fd, (void *)&c, (unsigned long int)1);
      if(!(return_value_read$1 == 1l))
        return 0;

      data[(signed long int)count] = c;
    }

    else
      return 0;
  }
  return 1;
}

// IO_Serial_SetProperties
// file io_serial.c line 395
extern signed int IO_Serial_SetProperties(struct anonymous$9 *io, struct anonymous$10 *props)
{
  struct termios newtio;
  unsigned int modembits = (unsigned int)0x002;
  if(props->dtr == 1)
  {
    signed int return_value_ioctl$1;
    return_value_ioctl$1=ioctl(io->fd, (unsigned long int)0x5416, &modembits);
    if(!(return_value_ioctl$1 >= 0))
      return 0;

  }

  else
    if(props->dtr == 0)
    {
      signed int return_value_ioctl$2;
      return_value_ioctl$2=ioctl(io->fd, (unsigned long int)0x5417, &modembits);
      if(!(return_value_ioctl$2 >= 0))
        return 0;

    }

  modembits = (unsigned int)0x004;
  if(props->rts == 1)
  {
    signed int return_value_ioctl$3;
    return_value_ioctl$3=ioctl(io->fd, (unsigned long int)0x5416, &modembits);
    if(!(return_value_ioctl$3 >= 0))
      return 0;

  }

  else
    if(props->rts == 0)
    {
      signed int return_value_ioctl$4;
      return_value_ioctl$4=ioctl(io->fd, (unsigned long int)0x5417, &modembits);
      if(!(return_value_ioctl$4 >= 0))
        return 0;

    }

  memset((void *)&newtio, 0, sizeof(struct termios) /*60ul*/ );
  signed int return_value_IO_Serial_Bitrate$5;
  return_value_IO_Serial_Bitrate$5=IO_Serial_Bitrate((signed int)props->input_bitrate);
  cfsetispeed(&newtio, (unsigned int)return_value_IO_Serial_Bitrate$5);
  signed int return_value_IO_Serial_Bitrate$6;
  return_value_IO_Serial_Bitrate$6=IO_Serial_Bitrate((signed int)props->output_bitrate);
  cfsetospeed(&newtio, (unsigned int)return_value_IO_Serial_Bitrate$6);
  switch(props->bits)
  {
    case (unsigned int)5:
    {
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0000000;
      break;
    }
    case (unsigned int)6:
    {
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0000020;
      break;
    }
    case (unsigned int)7:
    {
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0000040;
      break;
    }
    case (unsigned int)8:
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0000060;
  }
  switch(props->parity)
  {
    case 1:
    {
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0000400;
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0001000;
      break;
    }
    case 2:
    {
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0000400;
      newtio.c_cflag = newtio.c_cflag & (unsigned int)~0001000;
      break;
    }
    case 3:
      newtio.c_cflag = newtio.c_cflag & (unsigned int)~0000400;
  }
  switch(props->stopbits)
  {
    case (unsigned int)1:
    {
      newtio.c_cflag = newtio.c_cflag & (unsigned int)~0000100;
      break;
    }
    case (unsigned int)2:
      newtio.c_cflag = newtio.c_cflag | (unsigned int)0000100;
  }
  newtio.c_lflag = newtio.c_lflag & (unsigned int)~(0000002 | 0000010 | 0000020 | 0000001);
  newtio.c_oflag = newtio.c_oflag & (unsigned int)~0000001;
  newtio.c_iflag = newtio.c_iflag | (unsigned int)0000004;
  newtio.c_cflag = newtio.c_cflag | (unsigned int)(0000200 | 0002000 | 0004000);
  newtio.c_cc[(signed long int)6] = (unsigned char)1;
  newtio.c_cc[(signed long int)5] = (unsigned char)0;
  signed int return_value_tcsetattr$7;
  return_value_tcsetattr$7=tcsetattr(io->fd, 0, &newtio);
  if(!(return_value_tcsetattr$7 >= 0))
    return 0;

  else
  {
    signed int return_value_tcflush$8;
    return_value_tcflush$8=tcflush(io->fd, 0);
    if(!(return_value_tcflush$8 >= 0))
      return 0;

    else
    {
      IO_Serial_SetPropertiesCache(io, props);
      return 1;
    }
  }
}

// IO_Serial_SetPropertiesCache
// file io_serial.c line 840
static void IO_Serial_SetPropertiesCache(struct anonymous$9 *io, struct anonymous$10 *props)
{
  void *return_value_malloc$1;
  if(io->props == ((struct anonymous$10 *)NULL))
  {
    return_value_malloc$1=malloc(sizeof(struct anonymous$10) /*40ul*/ );
    io->props = (struct anonymous$10 *)return_value_malloc$1;
  }

  memcpy((void *)io->props, (const void *)props, sizeof(struct anonymous$10) /*40ul*/ );
}

// IO_Serial_WaitToRead
// file io_serial.c line 734
static signed int IO_Serial_WaitToRead(signed int hnd, unsigned int delay_ms, unsigned int timeout_ms)
{
  signed int rval;
  struct pollfd ufds;
  if(delay_ms >= 1u)
  {
    struct timespec req_ts;
    req_ts.tv_sec = (signed long int)(delay_ms / (unsigned int)1000);
    req_ts.tv_nsec = (signed long int)(delay_ms % (unsigned int)1000) * 1000000L;
    nanosleep(&req_ts, (struct timespec *)(void *)0);
  }

  ufds.fd = hnd;
  ufds.events = (signed short int)0x001;
  ufds.revents = (signed short int)0x0000;
  rval=poll(&ufds, (unsigned long int)1, (signed int)timeout_ms);
  if(!(rval == 1))
    return 0;

  else
    return (signed int)(((signed int)ufds.revents & 0x001) == 0x001);
}

// IO_Serial_WaitToWrite
// file io_serial.c line 781
static signed int IO_Serial_WaitToWrite(signed int hnd, unsigned int delay_ms, unsigned int timeout_ms)
{
  signed int rval;
  struct pollfd ufds;
  if(delay_ms >= 1u)
  {
    struct timespec req_ts;
    req_ts.tv_sec = (signed long int)(delay_ms / (unsigned int)1000);
    req_ts.tv_nsec = (signed long int)(delay_ms % (unsigned int)1000) * 1000000L;
    nanosleep(&req_ts, (struct timespec *)(void *)0);
  }

  ufds.fd = hnd;
  ufds.events = (signed short int)0x004;
  ufds.revents = (signed short int)0x0000;
  rval=poll(&ufds, (unsigned long int)1, (signed int)timeout_ms);
  if(!(rval == 1))
    return 0;

  else
    return (signed int)(((signed int)ufds.revents & 0x004) == 0x004);
}

// IO_Serial_Write
// file io_serial.c line 585
extern signed int IO_Serial_Write(struct anonymous$9 *io, unsigned int delay, unsigned int size, unsigned char *data)
{
  unsigned int count;
  unsigned int to_send;
  tcflush(io->fd, 0);
  count = (unsigned int)0;
  for( ; !(count >= size); count = count + to_send)
  {
    to_send = delay != 0u ? (unsigned int)1 : size;
    signed int return_value_IO_Serial_WaitToWrite$2;
    return_value_IO_Serial_WaitToWrite$2=IO_Serial_WaitToWrite(io->fd, delay, (unsigned int)1000);
    if(!(return_value_IO_Serial_WaitToWrite$2 == 0))
    {
      signed long int return_value_write$1;
      return_value_write$1=write(io->fd, (const void *)(data + (signed long int)count), (unsigned long int)to_send);
      if(!(return_value_write$1 == (signed long int)to_send))
        return 0;

    }

    else
      return 0;
  }
  return 1;
}

// Initialize
// file tester.c line 558
void Initialize(void)
{
  unsigned short int pn;
  unsigned short int ctn;
  char port[16l];
  char ret;
  printf("Port (COM[1..n] or USB[1..n]): ");
  pn=ReadPort(port);
  ctn = (unsigned short int)0;
  for( ; !((signed int)ctn >= 4); ctn = ctn + 1)
    if(ct_list[(signed long int)ctn].pn == pn)
    {
      printf("Port already open\n");
      goto __CPROVER_DUMP_L7;
    }

    else
      if((signed int)ct_list[(signed long int)ctn].pn == 0)
        break;

  if((signed int)ctn >= 5)
    printf("Maximum number of ports open\n");

  else
  {
    printf("Initializing terminal at %s...\n", (const void *)port);
    ret=CT_init(ctn, (unsigned short int)((signed int)pn - 1));
    if(!((signed int)ret == 0))
      fprintf(stderr, "Error on port allocation: %d\n", ret);

    else
    {
      __builtin_strncpy(ct_list[(signed long int)ctn].port, port, (unsigned long int)16);
      ct_list[(signed long int)ctn].pn = pn;
      unsigned short int *arg;
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(unsigned short int) /*2ul*/ );
      arg = (unsigned short int *)return_value_malloc$1;
      *arg = ctn;
      printf("Starting terminal monitoring job...\n");
      pthread_create(&ct_list[(signed long int)ctn].thread, (const union pthread_attr_t *)(void *)0, Monitor, (void *)arg);
      struct timespec req_ts;
      req_ts.tv_sec = (signed long int)0;
      req_ts.tv_nsec = (signed long int)100000000;
      nanosleep(&req_ts, (struct timespec *)(void *)0);
    }
  }

__CPROVER_DUMP_L7:
  ;
}

// Monitor
// file tester.c line 409
void * Monitor(void *arg)
{
  unsigned char cmd[5l];
  unsigned char res[256l];
  unsigned char sad;
  unsigned char dad;
  unsigned short int lr;
  unsigned short int ctn;
  char ret;
  struct timespec req_ts;
  req_ts.tv_sec = (signed long int)1;
  req_ts.tv_nsec = (signed long int)0;
  ctn = *((unsigned short int *)arg);
  free(arg);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  while(!((signed int)ct_list[(signed long int)ctn].pn == 0))
  {
    cmd[(signed long int)0] = (unsigned char)0x20;
    cmd[(signed long int)1] = (unsigned char)0x13;
    cmd[(signed long int)2] = (unsigned char)0x00;
    cmd[(signed long int)3] = (unsigned char)0x80;
    cmd[(signed long int)4] = (unsigned char)0x00;
    dad = (unsigned char)1;
    sad = (unsigned char)2;
    lr = (unsigned short int)256;
    ret=CT_data(ctn, &dad, &sad, (unsigned short int)5, cmd, &lr, res);
    if(!((signed int)ret == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)res[(signed long int)((signed int)lr - 2)] != 0x90 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      pthread_mutex_lock(&ct_list[(signed long int)ctn].mutex);
      if((signed int)res[0l] == 0x05)
      {
        if(ct_list[(signed long int)ctn].status == -1)
        {
          cmd[(signed long int)0] = (unsigned char)0x20;
          cmd[(signed long int)1] = (unsigned char)0x12;
          cmd[(signed long int)2] = (unsigned char)0x01;
          cmd[(signed long int)3] = (unsigned char)0x01;
          cmd[(signed long int)4] = (unsigned char)0x00;
          dad = (unsigned char)0x01;
          sad = (unsigned char)0x02;
          lr = (unsigned short int)256;
          ret=CT_data(ctn, &dad, &sad, (unsigned short int)5, cmd, &lr, res);
          if(!((signed int)ret == 0))
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = (signed int)res[(signed long int)((signed int)lr - 2)] != 0x90 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
          {
            pthread_mutex_unlock(&ct_list[(signed long int)ctn].mutex);
            continue;
          }

          ct_list[(signed long int)ctn].status = (signed int)res[(signed long int)((signed int)lr - 1)];
          memcpy((void *)ct_list[(signed long int)ctn].atr, (const void *)res, (unsigned long int)((signed int)lr - 2));
          ct_list[(signed long int)ctn].atr_size = (unsigned short int)((signed int)lr - 2);
          pthread_mutex_unlock(&ct_list[(signed long int)ctn].mutex);
        }

      }

      else
        if(!(ct_list[(signed long int)ctn].status == -1))
        {
          ct_list[(signed long int)ctn].status = -1;
          memset((void *)ct_list[(signed long int)ctn].atr, 0, (unsigned long int)33);
          ct_list[(signed long int)ctn].atr_size = (unsigned short int)0;
        }

      pthread_mutex_unlock(&ct_list[(signed long int)ctn].mutex);
      nanosleep(&req_ts, (struct timespec *)(void *)0);
    }

  }
  return (void *)0;
}

// PPS_Delete
// file pps.c line 160
extern void PPS_Delete(struct anonymous$0 *pps)
{
  free((void *)pps);
}

// PPS_Exchange
// file pps.c line 170
static signed int PPS_Exchange(struct anonymous$0 *pps, unsigned char *params, unsigned int *length)
{
  unsigned char confirm[6l];
  unsigned int len_request;
  unsigned int len_confirm;
  signed int ret;
  len_request=PPS_GetLength(params);
  params[(signed long int)(len_request - (unsigned int)1)]=PPS_GetPCK(params, len_request - (unsigned int)1);
  signed int return_value_ICC_Async_Transmit$1;
  return_value_ICC_Async_Transmit$1=ICC_Async_Transmit(pps->icc, len_request, params);
  if(!(return_value_ICC_Async_Transmit$1 == 0))
    return 1;

  else
  {
    signed int return_value_ICC_Async_Receive$2;
    return_value_ICC_Async_Receive$2=ICC_Async_Receive(pps->icc, (unsigned int)2, confirm);
    if(!(return_value_ICC_Async_Receive$2 == 0))
      return 1;

    else
    {
      len_confirm=PPS_GetLength(confirm);
      signed int return_value_ICC_Async_Receive$3;
      return_value_ICC_Async_Receive$3=ICC_Async_Receive(pps->icc, len_confirm - (unsigned int)2, confirm + (signed long int)2);
      if(!(return_value_ICC_Async_Receive$3 == 0))
        return 1;

      else
      {
        signed int return_value_PPS_Match$4;
        return_value_PPS_Match$4=PPS_Match(params, len_request, confirm, len_confirm);
        if(return_value_PPS_Match$4 == 0)
          ret = 2;

        else
          ret = 0;
        memcpy((void *)params, (const void *)confirm, (unsigned long int)len_confirm);
        *length = len_confirm;
        return ret;
      }
    }
  }
}

// PPS_GetLength
// file pps.c line 238
static unsigned int PPS_GetLength(unsigned char *block)
{
  unsigned int length = (unsigned int)3;
  if((0x10 & (signed int)block[1l]) == 0x10)
    length = length + 1u;

  if((0x20 & (signed int)block[1l]) == 0x20)
    length = length + 1u;

  if((0x40 & (signed int)block[1l]) == 0x40)
    length = length + 1u;

  return length;
}

// PPS_GetPCK
// file pps.c line 349
static unsigned char PPS_GetPCK(unsigned char *block, unsigned int length)
{
  unsigned char pck;
  unsigned int i;
  pck = block[(signed long int)0];
  i = (unsigned int)1;
  for( ; !(i >= length); i = i + 1u)
    pck = pck ^ block[(signed long int)i];
  return pck;
}

// PPS_GetProtocol
// file pps.c line 148
extern void * PPS_GetProtocol(struct anonymous$0 *pps)
{
  return pps->protocol;
}

// PPS_GetProtocolParameters
// file pps.c line 153
extern struct anonymous$12 * PPS_GetProtocolParameters(struct anonymous$0 *pps)
{
  return &pps->parameters;
}

// PPS_InitICC
// file pps.c line 255
static signed int PPS_InitICC(struct anonymous$0 *pps)
{
  unsigned long int baudrate;
  long double work_etu;
  unsigned long int return_value_ICC_Async_GetClockRate$1;
  return_value_ICC_Async_GetClockRate$1=ICC_Async_GetClockRate(pps->icc);
  work_etu = (long double)(((double)1000 * pps->parameters.f) / (pps->parameters.d * (double)return_value_ICC_Async_GetClockRate$1));
  baudrate = (unsigned long int)((long double)1000 / work_etu);
  signed int return_value_ICC_Async_SetBaudrate$2;
  return_value_ICC_Async_SetBaudrate$2=ICC_Async_SetBaudrate(pps->icc, baudrate);
  if(!(return_value_ICC_Async_SetBaudrate$2 == 0))
    return 1;

  else
    return 0;
}

// PPS_InitProtocol
// file pps.c line 277
static signed int PPS_InitProtocol(struct anonymous$0 *pps)
{
  signed int ret;
  if((signed int)pps->parameters.t == 0)
  {
    struct anonymous$11 *return_value_Protocol_T0_New$1;
    return_value_Protocol_T0_New$1=Protocol_T0_New();
    pps->protocol = (void *)return_value_Protocol_T0_New$1;
    if(!(pps->protocol == NULL))
    {
      ret=Protocol_T0_Init((struct anonymous$11 *)pps->protocol, (struct anonymous$5 *)pps->icc, &pps->parameters);
      if(!(ret == 0))
      {
        Protocol_T0_Delete((struct anonymous$11 *)pps->protocol);
        pps->protocol = (void *)0;
        return 3;
      }

      return 0;
    }

  }

  else
    if((signed int)pps->parameters.t == 1)
    {
      struct anonymous$18 *return_value_Protocol_T1_New$2;
      return_value_Protocol_T1_New$2=Protocol_T1_New();
      pps->protocol = (void *)return_value_Protocol_T1_New$2;
      if(!(pps->protocol == NULL))
      {
        ret=Protocol_T1_Init((struct anonymous$18 *)pps->protocol, (struct anonymous$5 *)pps->icc, &pps->parameters);
        if(!(ret == 0))
        {
          Protocol_T1_Delete((struct anonymous$18 *)pps->protocol);
          pps->protocol = (void *)0;
          return 3;
        }

        return 0;
      }

    }

    else
      pps->protocol = (void *)0;
  return 3;
}

// PPS_Match
// file pps.c line 223
static signed int PPS_Match(unsigned char *request, unsigned int len_request, unsigned char *confirm, unsigned int len_confirm)
{
  _Bool tmp_if_expr$2;
  signed int return_value_memcmp$1;
  if(!(len_request == len_confirm))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_memcmp$1=memcmp((const void *)request, (const void *)confirm, (unsigned long int)len_request);
    tmp_if_expr$2 = !(return_value_memcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(!((0x10 & (signed int)confirm[1l]) == 0x10))
      goto __CPROVER_DUMP_L3;

    if(confirm[2l] == request[2l])
      goto __CPROVER_DUMP_L3;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    return 1;
  }
}

// PPS_New
// file pps.c line 68
extern struct anonymous$0 * PPS_New(struct anonymous$5 *icc)
{
  struct anonymous$0 *pps;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$0) /*48ul*/ );
  pps = (struct anonymous$0 *)return_value_malloc$1;
  if(!(pps == ((struct anonymous$0 *)NULL)))
  {
    pps->icc = icc;
    pps->protocol = (void *)0;
    pps->parameters.t = (unsigned char)0x00;
    pps->parameters.f = (double)372;
    pps->parameters.d = (double)1;
    pps->parameters.n = (double)0;
  }

  return pps;
}

// PPS_Perform
// file pps.c line 88
extern signed int PPS_Perform(struct anonymous$0 *pps, unsigned char *params, unsigned int *length)
{
  struct anonymous$7 *atr;
  signed int ret;
  if(*length >= 1u)
  {
    ret=PPS_Exchange(pps, params, length);
    if(ret == 0)
    {
      pps->parameters.t = (unsigned char)((signed int)params[(signed long int)1] & 0x0F);
      if((0x10 & (signed int)params[1l]) == 0x10)
      {
        pps->parameters.f = (double)atr_f_table[(signed long int)((signed int)params[(signed long int)2] >> 4)];
        pps->parameters.d = atr_d_table[(signed long int)((signed int)params[(signed long int)2] & 0x0F)];
      }

      ret=PPS_InitICC(pps);
      if(!(ret == 0))
        return ret;

    }

    else
      return ret;
  }

  else
  {
    PPS_SelectFirstProtocol(pps);
    atr=ICC_Async_GetAtr(pps->icc);
    ATR_GetParameter(atr, 4, &pps->parameters.n);
    ATR_GetParameter(atr, 1, &pps->parameters.d);
    ATR_GetParameter(atr, 0, &pps->parameters.f);
  }
  ret=PPS_InitProtocol(pps);
  return ret;
}

// PPS_SelectFirstProtocol
// file pps.c line 327
static void PPS_SelectFirstProtocol(struct anonymous$0 *pps)
{
  struct anonymous$7 *atr;
  atr=ICC_Async_GetAtr(pps->icc);
  unsigned int np;
  pps->parameters.t = (unsigned char)0;
  ATR_GetNumberOfProtocols(atr, &np);
  if(np >= 2u)
    ATR_GetProtocolType(atr, (unsigned int)2, &pps->parameters.t);

}

// PrintArray
// file tester.c line 539
void PrintArray(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  if(length >= 17u)
    printf("\n");

  i = (unsigned int)0;
  for( ; !(i >= length); i = i + 1u)
  {
    printf("%02X ", buffer[(signed long int)i]);
    if(i % 16u == 15u)
      printf("\n");

  }
  if(!(i % 16u == 0u))
    printf("\n");

}

// PrintReport
// file tester.c line 257
void PrintReport(void)
{
  unsigned short int ctn;
  unsigned short int num;
  unsigned short int i;
  num = (unsigned short int)0;
  ctn = (unsigned short int)0;
  for( ; !((signed int)ctn >= 4); ctn = ctn + 1)
    if(!((signed int)ct_list[(signed long int)ctn].pn == 0))
      num = num + 1;

  printf("**********************************************************************\n");
  printf("Towitoko CT-API tester utility\n");
  printf("Copyright (C) 2000 2001 Carlos Prados <cprados@yahoo.com>\n");
  printf("Initilized CardTerminals: %d\n", num);
  ctn = (unsigned short int)0;
  char *tmp_if_expr$1;
  unsigned int return_value_GetMemoryLength$2;
  for( ; !((signed int)ctn >= 4); ctn = ctn + 1)
    if(!((signed int)ct_list[(signed long int)ctn].pn == 0))
    {
      pthread_mutex_lock(&ct_list[(signed long int)ctn].mutex);
      printf("**********************************************************************\n");
      printf("%s\n", (const void *)ct_list[(signed long int)ctn].port);
      if(ct_list[(signed long int)ctn].status == 0)
        tmp_if_expr$1 = "Memory smartcard present";

      else
        tmp_if_expr$1 = ct_list[(signed long int)ctn].status == 1 ? "Processor smartcard present" : "No smartcard present (type * to refresh)";
      printf("Status: %s", tmp_if_expr$1);
      if(ct_list[(signed long int)ctn].status == 0)
      {
        return_value_GetMemoryLength$2=GetMemoryLength(ct_list[(signed long int)ctn].atr, (unsigned int)ct_list[(signed long int)ctn].atr_size);
        printf(". Memory size: %d bytes\n", return_value_GetMemoryLength$2);
      }

      else
        printf("\n");
      if(!(ct_list[(signed long int)ctn].status == -1))
      {
        printf("ATR: ");
        i = (unsigned short int)0;
        for( ; !((signed int)i >= (signed int)ct_list[(signed long int)ctn].atr_size); i = i + 1)
          printf("%02X ", ct_list[(signed long int)ctn].atr[(signed long int)i]);
        printf("\n");
      }

      pthread_mutex_unlock(&ct_list[(signed long int)ctn].mutex);
    }

  printf("**********************************************************************\n");
}

// Protocol_Sync_BadCommand
// file protocol_sync.c line 655
static signed int Protocol_Sync_BadCommand(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[2l];
  buffer[(signed long int)0] = (unsigned char)0x6E;
  buffer[(signed long int)1] = (unsigned char)0x00;
  *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
  return 0;
}

// Protocol_Sync_ChangeVerifyData
// file protocol_sync.c line 592
static signed int Protocol_Sync_ChangeVerifyData(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char pin[3l];
  unsigned char newpin[3l];
  unsigned char buffer[2l];
  unsigned int trials;
  signed int ret;
  unsigned char *return_value_APDU_Cmd_Data$1;
  return_value_APDU_Cmd_Data$1=APDU_Cmd_Data(cmd);
  memcpy((void *)pin, (const void *)return_value_APDU_Cmd_Data$1, (unsigned long int)3);
  unsigned char *return_value_APDU_Cmd_Data$2;
  return_value_APDU_Cmd_Data$2=APDU_Cmd_Data(cmd);
  memcpy((void *)newpin, (const void *)(return_value_APDU_Cmd_Data$2 + (signed long int)3), (unsigned long int)3);
  ret=ICC_Sync_EnterPin(ps->icc, pin, &trials);
  if(ret == 4)
  {
    buffer[(signed long int)0] = (unsigned char)0x63;
    buffer[(signed long int)1] = (unsigned char)(0xC0 | (signed int)(unsigned char)trials & 0x0F);
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
    return 0;
  }

  else
    if(ret == 5)
    {
      buffer[(signed long int)0] = (unsigned char)0x69;
      buffer[(signed long int)1] = (unsigned char)0x83;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return 0;
    }

    else
      if(!(ret == 0))
      {
        buffer[(signed long int)0] = (unsigned char)0x63;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return 1;
      }

  ret=ICC_Sync_ChangePin(ps->icc, newpin);
  if(!(ret == 0))
  {
    buffer[(signed long int)0] = (unsigned char)0x63;
    buffer[(signed long int)1] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
    return 1;
  }

  else
  {
    buffer[(signed long int)0] = (unsigned char)0x90;
    buffer[(signed long int)1] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
    return 0;
  }
}

// Protocol_Sync_Clear
// file protocol_sync.c line 674
static void Protocol_Sync_Clear(struct anonymous *ps)
{
  ps->icc = (struct anonymous$22 *)(void *)0;
  ps->path = (unsigned int)0;
  ps->length = (unsigned int)0;
}

// Protocol_Sync_Close
// file protocol_sync.c line 127
extern signed int Protocol_Sync_Close(struct anonymous *ps)
{
  Protocol_Sync_Clear(ps);
  return 0;
}

// Protocol_Sync_Command
// file protocol_sync.c line 95
extern signed int Protocol_Sync_Command(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret;
  ICC_Sync_BeginTransmission(ps->icc);
  unsigned char return_value_APDU_Cmd_Ins$1;
  return_value_APDU_Cmd_Ins$1=APDU_Cmd_Ins(cmd);
  switch((signed int)return_value_APDU_Cmd_Ins$1)
  {
    case 0xA4:
    {
      ret=Protocol_Sync_SelectFile(ps, cmd, rsp);
      break;
    }
    case 0xB0:
    {
      ret=Protocol_Sync_ReadBinary(ps, cmd, rsp);
      break;
    }
    case 0xD6:
    {
      ret=Protocol_Sync_UpdateBinary(ps, cmd, rsp);
      break;
    }
    case 0x20:
    {
      ret=Protocol_Sync_Verify(ps, cmd, rsp);
      break;
    }
    case 0x24:
    {
      ret=Protocol_Sync_ChangeVerifyData(ps, cmd, rsp);
      break;
    }
    default:
      ret=Protocol_Sync_BadCommand(ps, cmd, rsp);
  }
  return ret;
}

// Protocol_Sync_Delete
// file protocol_sync.c line 135
extern void Protocol_Sync_Delete(struct anonymous *ps)
{
  free((void *)ps);
}

// Protocol_Sync_GetData
// file protocol_sync.c line 668
static signed int Protocol_Sync_GetData(void *data, unsigned short int address, unsigned short int length, unsigned char *buffer)
{
  signed int return_value_ICC_Sync_Read$1;
  return_value_ICC_Sync_Read$1=ICC_Sync_Read((struct anonymous$22 *)data, address, (unsigned int)length, buffer);
  return (signed int)(return_value_ICC_Sync_Read$1 == 0);
}

// Protocol_Sync_Init
// file protocol_sync.c line 83
extern signed int Protocol_Sync_Init(struct anonymous *ps, struct anonymous$22 *icc)
{
  ps->icc = icc;
  ps->path = (unsigned int)0;
  ps->length=ICC_Sync_GetLength(ps->icc);
  return 0;
}

// Protocol_Sync_New
// file protocol_sync.c line 70
extern struct anonymous * Protocol_Sync_New(void)
{
  struct anonymous *ps;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous) /*16ul*/ );
  ps = (struct anonymous *)return_value_malloc$1;
  if(!(ps == ((struct anonymous *)NULL)))
    Protocol_Sync_Clear(ps);

  return ps;
}

// Protocol_Sync_ReadBinary
// file protocol_sync.c line 424
static signed int Protocol_Sync_ReadBinary(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned int offset;
  unsigned int available;
  unsigned long int expected;
  unsigned char *buffer;
  unsigned char return_value_APDU_Cmd_P1$1;
  return_value_APDU_Cmd_P1$1=APDU_Cmd_P1(cmd);
  unsigned char return_value_APDU_Cmd_P2$2;
  return_value_APDU_Cmd_P2$2=APDU_Cmd_P2(cmd);
  offset = (unsigned int)((signed int)return_value_APDU_Cmd_P1$1 << 8 | (signed int)return_value_APDU_Cmd_P2$2);
  signed int tmp_if_expr$3;
  if((signed int)ps->length + -((signed int)offset) >= 1)
    tmp_if_expr$3 = (signed int)ps->length - (signed int)offset;

  else
    tmp_if_expr$3 = 0;
  available = (unsigned int)tmp_if_expr$3;
  signed int return_value_APDU_Cmd_Le_Available$4;
  return_value_APDU_Cmd_Le_Available$4=APDU_Cmd_Le_Available(cmd);
  if(!(return_value_APDU_Cmd_Le_Available$4 == 0))
    expected = (unsigned long int)available;

  else
    expected=APDU_Cmd_Le(cmd);
  expected = expected < (unsigned long int)(65538 - 2) ? expected : (unsigned long int)(65538 - 2);
  if(!((unsigned long int)available >= expected))
  {
    void *return_value_calloc$5;
    return_value_calloc$5=calloc((unsigned long int)(available + (unsigned int)2), sizeof(unsigned char) /*1ul*/ );
    buffer = (unsigned char *)return_value_calloc$5;
    signed int return_value_ICC_Sync_Read$6;
    return_value_ICC_Sync_Read$6=ICC_Sync_Read(ps->icc, (unsigned short int)(ps->path + offset), available, buffer);
    if(!(return_value_ICC_Sync_Read$6 == 0))
    {
      buffer[(signed long int)0] = (unsigned char)0x65;
      buffer[(signed long int)1] = (unsigned char)0x01;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      free((void *)buffer);
      return 1;
    }

    buffer[(signed long int)available] = (unsigned char)0x62;
    buffer[(signed long int)(available + (unsigned int)1)] = (unsigned char)0x82;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)(available + (unsigned int)2));
    free((void *)buffer);
  }

  else
  {
    void *return_value_calloc$7;
    return_value_calloc$7=calloc(expected + (unsigned long int)2, sizeof(unsigned char) /*1ul*/ );
    buffer = (unsigned char *)return_value_calloc$7;
    signed int return_value_ICC_Sync_Read$8;
    return_value_ICC_Sync_Read$8=ICC_Sync_Read(ps->icc, (unsigned short int)(ps->path + offset), (unsigned int)expected, buffer);
    if(!(return_value_ICC_Sync_Read$8 == 0))
    {
      buffer[(signed long int)0] = (unsigned char)0x65;
      buffer[(signed long int)1] = (unsigned char)0x01;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      free((void *)buffer);
      return 1;
    }

    buffer[(signed long int)expected] = (unsigned char)0x90;
    buffer[(signed long int)(expected + (unsigned long int)1)] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, expected + (unsigned long int)2);
    free((void *)buffer);
  }
  return 0;
}

// Protocol_Sync_SelectFile
// file protocol_sync.c line 145
static signed int Protocol_Sync_SelectFile(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[2l];
  unsigned char aid[16l];
  unsigned char path[2l];
  unsigned short int fid;
  unsigned short int aid_length;
  unsigned short int path_length;
  struct anonymous$23 *tlv_dir;
  struct anonymous$23 *tlv_template;
  struct anonymous$23 *tlv_aid;
  struct anonymous$23 *tlv_path;
  struct anonymous$23 *tlv_app;
  struct anonymous$19 *atr;
  unsigned char return_value_APDU_Cmd_P1$50;
  return_value_APDU_Cmd_P1$50=APDU_Cmd_P1(cmd);
  _Bool tmp_if_expr$10;
  unsigned char return_value_ATR_Sync_GetDirDataReference$9;
  _Bool tmp_if_expr$12;
  unsigned char return_value_ATR_Sync_GetDirDataReference$11;
  _Bool tmp_if_expr$14;
  unsigned int return_value_ICC_Sync_GetLength$13;
  unsigned int tmp_if_expr$7;
  unsigned char return_value_ATR_Sync_GetDirDataReference$5;
  unsigned int return_value_ICC_Sync_GetLength$6;
  _Bool tmp_if_expr$21;
  unsigned char return_value_ATR_Sync_GetDirDataReference$20;
  unsigned char return_value_APDU_Cmd_P1$49;
  unsigned long int tmp_if_expr$24;
  unsigned long int return_value_APDU_Cmd_Lc$23;
  _Bool tmp_if_expr$48;
  unsigned char return_value_ATR_Sync_GetDirDataReference$47;
  unsigned short int return_value_TLV_Object_GetTag$42;
  unsigned short int return_value_TLV_Object_GetTag$41;
  signed int return_value_TLV_Object_Iterate$34;
  unsigned int return_value_ICC_Sync_GetLength$35;
  unsigned int return_value_ICC_Sync_GetLength$36;
  if((signed int)return_value_APDU_Cmd_P1$50 == 0x00)
  {
    unsigned char *return_value_APDU_Cmd_Data$1;
    return_value_APDU_Cmd_Data$1=APDU_Cmd_Data(cmd);
    unsigned char *return_value_APDU_Cmd_Data$2;
    return_value_APDU_Cmd_Data$2=APDU_Cmd_Data(cmd);
    fid = (unsigned short int)((signed int)return_value_APDU_Cmd_Data$1[(signed long int)0] << 8 | (signed int)return_value_APDU_Cmd_Data$2[(signed long int)1]);
    if((signed int)fid == 0x3F00)
    {
      ps->path = (unsigned int)0;
      ps->length=ICC_Sync_GetLength(ps->icc);
      buffer[(signed long int)0] = (unsigned char)0x90;
      buffer[(signed long int)1] = (unsigned char)0x00;
    }

    else
      if((signed int)fid == 0x2F01)
      {
        atr=ICC_Sync_GetAtr(ps->icc);
        unsigned char return_value_ATR_Sync_GetCategoryIndicator$8;
        return_value_ATR_Sync_GetCategoryIndicator$8=ATR_Sync_GetCategoryIndicator(atr);
        if((signed int)return_value_ATR_Sync_GetCategoryIndicator$8 == 0x10)
        {
          return_value_ATR_Sync_GetDirDataReference$9=ATR_Sync_GetDirDataReference(atr);
          tmp_if_expr$10 = ((signed int)return_value_ATR_Sync_GetDirDataReference$9 & 0x80) == 0x80 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$10 = (_Bool)0;
        if(tmp_if_expr$10)
        {
          return_value_ATR_Sync_GetDirDataReference$11=ATR_Sync_GetDirDataReference(atr);
          tmp_if_expr$12 = ((signed int)return_value_ATR_Sync_GetDirDataReference$11 & 0x7F) > 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$12 = (_Bool)0;
        if(tmp_if_expr$12)
        {
          return_value_ICC_Sync_GetLength$13=ICC_Sync_GetLength(ps->icc);
          tmp_if_expr$14 = return_value_ICC_Sync_GetLength$13 > (unsigned int)4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$14 = (_Bool)0;
        if(tmp_if_expr$14)
        {
          ps->path = (unsigned int)4;
          unsigned char return_value_ATR_Sync_GetDirDataReference$3;
          return_value_ATR_Sync_GetDirDataReference$3=ATR_Sync_GetDirDataReference(atr);
          unsigned int return_value_ICC_Sync_GetLength$4;
          return_value_ICC_Sync_GetLength$4=ICC_Sync_GetLength(ps->icc);
          if(!((127u & (unsigned int)(signed int)return_value_ATR_Sync_GetDirDataReference$3) >= return_value_ICC_Sync_GetLength$4))
          {
            return_value_ATR_Sync_GetDirDataReference$5=ATR_Sync_GetDirDataReference(atr);
            tmp_if_expr$7 = (unsigned int)((signed int)return_value_ATR_Sync_GetDirDataReference$5 & 0x7F);
          }

          else
          {
            return_value_ICC_Sync_GetLength$6=ICC_Sync_GetLength(ps->icc);
            tmp_if_expr$7 = return_value_ICC_Sync_GetLength$6;
          }
          ps->length = tmp_if_expr$7 - (unsigned int)4;
          buffer[(signed long int)0] = (unsigned char)0x90;
          buffer[(signed long int)1] = (unsigned char)0x00;
        }

        else
        {
          buffer[(signed long int)0] = (unsigned char)0x6A;
          buffer[(signed long int)1] = (unsigned char)0x82;
        }
      }

      else
        if((signed int)fid == 0x2F00)
        {
          atr=ICC_Sync_GetAtr(ps->icc);
          unsigned char return_value_ATR_Sync_GetCategoryIndicator$19;
          return_value_ATR_Sync_GetCategoryIndicator$19=ATR_Sync_GetCategoryIndicator(atr);
          if((signed int)return_value_ATR_Sync_GetCategoryIndicator$19 == 0x10)
          {
            return_value_ATR_Sync_GetDirDataReference$20=ATR_Sync_GetDirDataReference(atr);
            tmp_if_expr$21 = ((signed int)return_value_ATR_Sync_GetDirDataReference$20 & 0x80) == 0x80 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$21 = (_Bool)0;
          if(tmp_if_expr$21)
          {
            unsigned int return_value_ICC_Sync_GetLength$17;
            return_value_ICC_Sync_GetLength$17=ICC_Sync_GetLength(ps->icc);
            unsigned char return_value_ATR_Sync_GetDirDataReference$18;
            return_value_ATR_Sync_GetDirDataReference$18=ATR_Sync_GetDirDataReference(atr);
            tlv_dir=TLV_Object_New((void *)ps->icc, Protocol_Sync_GetData, (unsigned short int)return_value_ICC_Sync_GetLength$17, (unsigned short int)((signed int)return_value_ATR_Sync_GetDirDataReference$18 & 0x7F));
            if(!(tlv_dir == ((struct anonymous$23 *)NULL)))
            {
              unsigned short int return_value_TLV_Object_GetAddress$15;
              return_value_TLV_Object_GetAddress$15=TLV_Object_GetAddress(tlv_dir);
              ps->path = (unsigned int)return_value_TLV_Object_GetAddress$15;
              unsigned short int return_value_TLV_Object_GetRawLength$16;
              return_value_TLV_Object_GetRawLength$16=TLV_Object_GetRawLength(tlv_dir);
              ps->length = (unsigned int)return_value_TLV_Object_GetRawLength$16;
              buffer[(signed long int)0] = (unsigned char)0x90;
              buffer[(signed long int)1] = (unsigned char)0x00;
              TLV_Object_Delete(tlv_dir);
            }

            else
            {
              buffer[(signed long int)0] = (unsigned char)0x6A;
              buffer[(signed long int)1] = (unsigned char)0x82;
            }
          }

          else
          {
            buffer[(signed long int)0] = (unsigned char)0x6A;
            buffer[(signed long int)1] = (unsigned char)0x82;
          }
        }

        else
        {
          buffer[(signed long int)0] = (unsigned char)0x6A;
          buffer[(signed long int)1] = (unsigned char)0x82;
        }
  }

  else
  {
    return_value_APDU_Cmd_P1$49=APDU_Cmd_P1(cmd);
    if((signed int)return_value_APDU_Cmd_P1$49 == 0x04)
    {
      unsigned long int return_value_APDU_Cmd_Lc$22;
      return_value_APDU_Cmd_Lc$22=APDU_Cmd_Lc(cmd);
      if(!(return_value_APDU_Cmd_Lc$22 >= 16ul))
      {
        return_value_APDU_Cmd_Lc$23=APDU_Cmd_Lc(cmd);
        tmp_if_expr$24 = return_value_APDU_Cmd_Lc$23;
      }

      else
        tmp_if_expr$24 = (unsigned long int)16;
      aid_length = (unsigned short int)tmp_if_expr$24;
      unsigned char *return_value_APDU_Cmd_Data$25;
      return_value_APDU_Cmd_Data$25=APDU_Cmd_Data(cmd);
      memcpy((void *)aid, (const void *)return_value_APDU_Cmd_Data$25, (unsigned long int)aid_length);
      atr=ICC_Sync_GetAtr(ps->icc);
      unsigned char return_value_ATR_Sync_GetCategoryIndicator$46;
      return_value_ATR_Sync_GetCategoryIndicator$46=ATR_Sync_GetCategoryIndicator(atr);
      if((signed int)return_value_ATR_Sync_GetCategoryIndicator$46 == 0x10)
      {
        return_value_ATR_Sync_GetDirDataReference$47=ATR_Sync_GetDirDataReference(atr);
        tmp_if_expr$48 = ((signed int)return_value_ATR_Sync_GetDirDataReference$47 & 0x80) == 0x80 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$48 = (_Bool)0;
      if(tmp_if_expr$48)
      {
        unsigned int return_value_ICC_Sync_GetLength$44;
        return_value_ICC_Sync_GetLength$44=ICC_Sync_GetLength(ps->icc);
        unsigned char return_value_ATR_Sync_GetDirDataReference$45;
        return_value_ATR_Sync_GetDirDataReference$45=ATR_Sync_GetDirDataReference(atr);
        tlv_dir=TLV_Object_New((void *)ps->icc, Protocol_Sync_GetData, (unsigned short int)return_value_ICC_Sync_GetLength$44, (unsigned short int)((signed int)return_value_ATR_Sync_GetDirDataReference$45 & 0x7F));
        if(!(tlv_dir == ((struct anonymous$23 *)NULL)))
        {
          unsigned short int return_value_TLV_Object_GetTag$43;
          return_value_TLV_Object_GetTag$43=TLV_Object_GetTag(tlv_dir);
          if((signed int)return_value_TLV_Object_GetTag$43 == 0x4F)
          {
            signed int return_value_TLV_Object_CompareValue$29;
            return_value_TLV_Object_CompareValue$29=TLV_Object_CompareValue(tlv_dir, aid, &aid_length);
            if(!(return_value_TLV_Object_CompareValue$29 == 0))
            {
              signed int return_value_TLV_Object_Shift$28;
              return_value_TLV_Object_Shift$28=TLV_Object_Shift(&tlv_dir);
              if(!(return_value_TLV_Object_Shift$28 == 0))
              {
                unsigned short int return_value_TLV_Object_GetAddress$26;
                return_value_TLV_Object_GetAddress$26=TLV_Object_GetAddress(tlv_dir);
                ps->path = (unsigned int)return_value_TLV_Object_GetAddress$26;
                unsigned short int return_value_TLV_Object_GetRawLength$27;
                return_value_TLV_Object_GetRawLength$27=TLV_Object_GetRawLength(tlv_dir);
                ps->length = (unsigned int)return_value_TLV_Object_GetRawLength$27;
                buffer[(signed long int)0] = (unsigned char)0x90;
                buffer[(signed long int)1] = (unsigned char)0x00;
                TLV_Object_Delete(tlv_dir);
              }

              else
              {
                buffer[(signed long int)0] = (unsigned char)0x6A;
                buffer[(signed long int)1] = (unsigned char)0x82;
              }
            }

            else
            {
              buffer[(signed long int)0] = (unsigned char)0x6A;
              buffer[(signed long int)1] = (unsigned char)0x82;
              TLV_Object_Delete(tlv_dir);
            }
          }

          else
          {
            return_value_TLV_Object_GetTag$42=TLV_Object_GetTag(tlv_dir);
            if((signed int)return_value_TLV_Object_GetTag$42 == 0x61)
            {
              tlv_aid=TLV_Object_GetObjectByTag(tlv_dir, (unsigned short int)0x4F);
              if(!(tlv_aid == ((struct anonymous$23 *)NULL)))
              {
                signed int return_value_TLV_Object_CompareValue$33;
                return_value_TLV_Object_CompareValue$33=TLV_Object_CompareValue(tlv_aid, aid, &aid_length);
                if(!(return_value_TLV_Object_CompareValue$33 == 0))
                {
                  signed int return_value_TLV_Object_Shift$32;
                  return_value_TLV_Object_Shift$32=TLV_Object_Shift(&tlv_dir);
                  if(!(return_value_TLV_Object_Shift$32 == 0))
                  {
                    unsigned short int return_value_TLV_Object_GetAddress$30;
                    return_value_TLV_Object_GetAddress$30=TLV_Object_GetAddress(tlv_dir);
                    ps->path = (unsigned int)return_value_TLV_Object_GetAddress$30;
                    unsigned short int return_value_TLV_Object_GetRawLength$31;
                    return_value_TLV_Object_GetRawLength$31=TLV_Object_GetRawLength(tlv_dir);
                    ps->length = (unsigned int)return_value_TLV_Object_GetRawLength$31;
                    buffer[(signed long int)0] = (unsigned char)0x90;
                    buffer[(signed long int)1] = (unsigned char)0x00;
                    TLV_Object_Delete(tlv_dir);
                  }

                  else
                  {
                    buffer[(signed long int)0] = (unsigned char)0x6A;
                    buffer[(signed long int)1] = (unsigned char)0x82;
                  }
                }

                else
                {
                  buffer[(signed long int)0] = (unsigned char)0x6A;
                  buffer[(signed long int)1] = (unsigned char)0x82;
                  TLV_Object_Delete(tlv_dir);
                }
                TLV_Object_Delete(tlv_aid);
              }

              else
              {
                buffer[(signed long int)0] = (unsigned char)0x6A;
                buffer[(signed long int)1] = (unsigned char)0x82;
                TLV_Object_Delete(tlv_dir);
              }
            }

            else
            {
              return_value_TLV_Object_GetTag$41=TLV_Object_GetTag(tlv_dir);
              if((signed int)return_value_TLV_Object_GetTag$41 == 0x30)
              {
                tlv_app = (struct anonymous$23 *)(void *)0;
                tlv_template = (struct anonymous$23 *)(void *)0;
                while(tlv_app == ((struct anonymous$23 *)NULL))
                {
                  return_value_TLV_Object_Iterate$34=TLV_Object_Iterate(tlv_dir, &tlv_template);
                  if(return_value_TLV_Object_Iterate$34 == 0)
                    break;

                  tlv_aid=TLV_Object_GetObjectByTag(tlv_template, (unsigned short int)0x4F);
                  if(!(tlv_aid == ((struct anonymous$23 *)NULL)))
                  {
                    signed int return_value_TLV_Object_CompareValue$38;
                    return_value_TLV_Object_CompareValue$38=TLV_Object_CompareValue(tlv_aid, aid, &aid_length);
                    if(!(return_value_TLV_Object_CompareValue$38 == 0))
                    {
                      tlv_path=TLV_Object_GetObjectByTag(tlv_template, (unsigned short int)0x51);
                      if(!(tlv_path == ((struct anonymous$23 *)NULL)))
                      {
                        signed int return_value_TLV_Object_GetValue$37;
                        return_value_TLV_Object_GetValue$37=TLV_Object_GetValue(tlv_path, path, &path_length);
                        if(!(return_value_TLV_Object_GetValue$37 == 0))
                        {
                          if(!((signed int)path_length >= 2))
                          {
                            return_value_ICC_Sync_GetLength$35=ICC_Sync_GetLength(ps->icc);
                            tlv_app=TLV_Object_New((void *)ps->icc, Protocol_Sync_GetData, (unsigned short int)return_value_ICC_Sync_GetLength$35, (unsigned short int)path[(signed long int)0]);
                          }

                          else
                          {
                            return_value_ICC_Sync_GetLength$36=ICC_Sync_GetLength(ps->icc);
                            tlv_app=TLV_Object_New((void *)ps->icc, Protocol_Sync_GetData, (unsigned short int)return_value_ICC_Sync_GetLength$36, (unsigned short int)((signed int)path[(signed long int)((signed int)path_length - 2)] << 8 | (signed int)path[(signed long int)((signed int)path_length - 1)]));
                          }
                        }

                        TLV_Object_Delete(tlv_path);
                      }

                    }

                    TLV_Object_Delete(tlv_aid);
                  }

                }
                if(!(tlv_template == ((struct anonymous$23 *)NULL)))
                  TLV_Object_Delete(tlv_template);

                if(!(tlv_app == ((struct anonymous$23 *)NULL)))
                {
                  unsigned short int return_value_TLV_Object_GetAddress$39;
                  return_value_TLV_Object_GetAddress$39=TLV_Object_GetAddress(tlv_app);
                  ps->path = (unsigned int)return_value_TLV_Object_GetAddress$39;
                  unsigned short int return_value_TLV_Object_GetRawLength$40;
                  return_value_TLV_Object_GetRawLength$40=TLV_Object_GetRawLength(tlv_app);
                  ps->length = (unsigned int)return_value_TLV_Object_GetRawLength$40;
                  buffer[(signed long int)0] = (unsigned char)0x90;
                  buffer[(signed long int)1] = (unsigned char)0x00;
                  TLV_Object_Delete(tlv_app);
                }

                else
                {
                  buffer[(signed long int)0] = (unsigned char)0x6A;
                  buffer[(signed long int)1] = (unsigned char)0x82;
                }
                TLV_Object_Delete(tlv_dir);
              }

              else
              {
                buffer[(signed long int)0] = (unsigned char)0x6A;
                buffer[(signed long int)1] = (unsigned char)0x82;
                TLV_Object_Delete(tlv_dir);
              }
            }
          }
        }

        else
        {
          buffer[(signed long int)0] = (unsigned char)0x6A;
          buffer[(signed long int)1] = (unsigned char)0x82;
        }
      }

      else
      {
        buffer[(signed long int)0] = (unsigned char)0x6A;
        buffer[(signed long int)1] = (unsigned char)0x82;
      }
    }

    else
    {
      buffer[(signed long int)0] = (unsigned char)0x6A;
      buffer[(signed long int)1] = (unsigned char)0x82;
    }
  }
  *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
  return 0;
}

// Protocol_Sync_UpdateBinary
// file protocol_sync.c line 493
static signed int Protocol_Sync_UpdateBinary(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned int available;
  unsigned int offset;
  unsigned long int provided;
  unsigned char buffer[2l];
  signed int ret;
  unsigned char return_value_APDU_Cmd_P1$1;
  return_value_APDU_Cmd_P1$1=APDU_Cmd_P1(cmd);
  unsigned char return_value_APDU_Cmd_P2$2;
  return_value_APDU_Cmd_P2$2=APDU_Cmd_P2(cmd);
  offset = (unsigned int)((signed int)return_value_APDU_Cmd_P1$1 << 8 | (signed int)return_value_APDU_Cmd_P2$2);
  signed int tmp_if_expr$3;
  if((signed int)ps->length + -((signed int)offset) >= 1)
    tmp_if_expr$3 = (signed int)ps->length - (signed int)offset;

  else
    tmp_if_expr$3 = 0;
  available = (unsigned int)tmp_if_expr$3;
  provided=APDU_Cmd_Lc(cmd);
  unsigned char *return_value_APDU_Cmd_Data$4;
  return_value_APDU_Cmd_Data$4=APDU_Cmd_Data(cmd);
  ret=ICC_Sync_Write(ps->icc, (unsigned short int)(ps->path + offset), (unsigned int)((unsigned long int)available < provided ? (unsigned long int)available : provided), return_value_APDU_Cmd_Data$4);
  if(ret == 3)
  {
    buffer[(signed long int)0] = (unsigned char)0x62;
    buffer[(signed long int)1] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
    return 0;
  }

  else
    if(!(ret == 0))
    {
      buffer[(signed long int)0] = (unsigned char)0x62;
      buffer[(signed long int)1] = (unsigned char)0x00;
      *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
      return 1;
    }

  if(!((unsigned long int)available >= provided))
  {
    buffer[(signed long int)0] = (unsigned char)0x62;
    buffer[(signed long int)1] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
    return 0;
  }

  else
  {
    buffer[(signed long int)0] = (unsigned char)0x90;
    buffer[(signed long int)1] = (unsigned char)0x00;
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
    return 0;
  }
}

// Protocol_Sync_Verify
// file protocol_sync.c line 545
static signed int Protocol_Sync_Verify(struct anonymous *ps, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[2l];
  unsigned char pin[3l];
  unsigned int trials;
  signed int ret;
  memset((void *)pin, 0x00, (unsigned long int)3);
  unsigned char *return_value_APDU_Cmd_Data$1;
  return_value_APDU_Cmd_Data$1=APDU_Cmd_Data(cmd);
  unsigned long int return_value_APDU_Cmd_Lc$2;
  return_value_APDU_Cmd_Lc$2=APDU_Cmd_Lc(cmd);
  unsigned long int tmp_if_expr$4;
  unsigned long int return_value_APDU_Cmd_Lc$3;
  if(!(return_value_APDU_Cmd_Lc$2 >= 3ul))
  {
    return_value_APDU_Cmd_Lc$3=APDU_Cmd_Lc(cmd);
    tmp_if_expr$4 = return_value_APDU_Cmd_Lc$3;
  }

  else
    tmp_if_expr$4 = (unsigned long int)3;
  memcpy((void *)pin, (const void *)return_value_APDU_Cmd_Data$1, tmp_if_expr$4);
  ret=ICC_Sync_EnterPin(ps->icc, pin, &trials);
  if(ret == 4)
  {
    buffer[(signed long int)0] = (unsigned char)0x63;
    buffer[(signed long int)1] = (unsigned char)(0xC0 | (signed int)(unsigned char)trials & 0x0F);
  }

  else
    if(ret == 5)
    {
      buffer[(signed long int)0] = (unsigned char)0x69;
      buffer[(signed long int)1] = (unsigned char)0x83;
    }

    else
      if(!(ret == 0))
      {
        buffer[(signed long int)0] = (unsigned char)0x63;
        buffer[(signed long int)1] = (unsigned char)0x00;
        *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
        return 1;
      }

      else
      {
        buffer[(signed long int)0] = (unsigned char)0x90;
        buffer[(signed long int)1] = (unsigned char)0x00;
      }
  *rsp=APDU_Rsp_New(buffer, (unsigned long int)2);
  return 0;
}

// Protocol_T0_Case1
// file protocol_t0.c line 185
static signed int Protocol_T0_Case1(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret;
  unsigned char buffer[5l];
  struct anonymous$13 *tpdu_cmd;
  unsigned char *return_value_APDU_Cmd_Raw$1;
  return_value_APDU_Cmd_Raw$1=APDU_Cmd_Raw(cmd);
  memcpy((void *)buffer, (const void *)return_value_APDU_Cmd_Raw$1, (unsigned long int)4);
  buffer[(signed long int)4] = (unsigned char)0x00;
  tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)5);
  ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, rsp);
  APDU_Cmd_Delete(tpdu_cmd);
  return ret;
}

// Protocol_T0_Case2E
// file protocol_t0.c line 412
static signed int Protocol_T0_Case2E(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret = 0;
  signed int i;
  unsigned char buffer[260l];
  struct anonymous$13 *tpdu_cmd;
  struct anonymous$14 *tpdu_rsp;
  unsigned long int return_value_APDU_Cmd_Lc$10;
  return_value_APDU_Cmd_Lc$10=APDU_Cmd_Lc(cmd);
  unsigned long int return_value_APDU_Cmd_RawLen$3;
  unsigned long int tmp_if_expr$6;
  unsigned long int return_value_APDU_Cmd_RawLen$5;
  if(!(return_value_APDU_Cmd_Lc$10 >= 256ul))
  {
    buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
    buffer[(signed long int)1]=APDU_Cmd_Ins(cmd);
    buffer[(signed long int)2]=APDU_Cmd_P1(cmd);
    buffer[(signed long int)3]=APDU_Cmd_P2(cmd);
    unsigned long int return_value_APDU_Cmd_Lc$1;
    return_value_APDU_Cmd_Lc$1=APDU_Cmd_Lc(cmd);
    buffer[(signed long int)4] = (unsigned char)return_value_APDU_Cmd_Lc$1;
    unsigned char *return_value_APDU_Cmd_Data$2;
    return_value_APDU_Cmd_Data$2=APDU_Cmd_Data(cmd);
    memcpy((void *)(buffer + (signed long int)5), (const void *)return_value_APDU_Cmd_Data$2, (unsigned long int)buffer[(signed long int)4]);
    tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)((signed int)buffer[(signed long int)4] + 5));
    ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, rsp);
    APDU_Cmd_Delete(tpdu_cmd);
  }

  else
  {
    buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
    buffer[(signed long int)1] = (unsigned char)0xC2;
    buffer[(signed long int)2] = (unsigned char)0x00;
    buffer[(signed long int)3] = (unsigned char)0x00;
    i = 0;
    do
    {
      return_value_APDU_Cmd_RawLen$3=APDU_Cmd_RawLen(cmd);
      if((unsigned long int)i >= return_value_APDU_Cmd_RawLen$3)
        break;

      unsigned long int return_value_APDU_Cmd_RawLen$4;
      return_value_APDU_Cmd_RawLen$4=APDU_Cmd_RawLen(cmd);
      if(return_value_APDU_Cmd_RawLen$4 + -((unsigned long int)i) >= 256ul)
        tmp_if_expr$6 = (unsigned long int)255;

      else
      {
        return_value_APDU_Cmd_RawLen$5=APDU_Cmd_RawLen(cmd);
        tmp_if_expr$6 = return_value_APDU_Cmd_RawLen$5 - (unsigned long int)i;
      }
      buffer[(signed long int)4] = (unsigned char)tmp_if_expr$6;
      unsigned char *return_value_APDU_Cmd_Raw$7;
      return_value_APDU_Cmd_Raw$7=APDU_Cmd_Raw(cmd);
      memcpy((void *)(buffer + (signed long int)5), (const void *)(return_value_APDU_Cmd_Raw$7 + (signed long int)i), (unsigned long int)buffer[(signed long int)4]);
      tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)((signed int)buffer[(signed long int)4] + 5));
      ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, &tpdu_rsp);
      APDU_Cmd_Delete(tpdu_cmd);
      if(ret == 0)
      {
        unsigned char return_value_APDU_Rsp_SW1$9;
        return_value_APDU_Rsp_SW1$9=APDU_Rsp_SW1(tpdu_rsp);
        if((signed int)return_value_APDU_Rsp_SW1$9 == 0x90)
        {
          unsigned long int return_value_APDU_Cmd_RawLen$8;
          return_value_APDU_Cmd_RawLen$8=APDU_Cmd_RawLen(cmd);
          if(!((unsigned long int)(i + (signed int)buffer[4l]) >= return_value_APDU_Cmd_RawLen$8))
            APDU_Rsp_Delete(tpdu_rsp);

          else
            *rsp = tpdu_rsp;
        }

        else
        {
          *rsp = tpdu_rsp;
          break;
        }
      }

      else
        break;
      i = i + (signed int)buffer[(signed long int)4];
    }
    while((_Bool)1);
  }
  return ret;
}

// Protocol_T0_Case2S
// file protocol_t0.c line 207
static signed int Protocol_T0_Case2S(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret;
  ret=Protocol_T0_ExchangeTPDU(t0, cmd, rsp);
  return ret;
}

// Protocol_T0_Case3E
// file protocol_t0.c line 497
static signed int Protocol_T0_Case3E(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret;
  unsigned char buffer[5l];
  struct anonymous$13 *tpdu_cmd;
  struct anonymous$14 *tpdu_rsp;
  signed long int Lm;
  signed long int Lx;
  unsigned long int return_value_APDU_Cmd_Le$14;
  return_value_APDU_Cmd_Le$14=APDU_Cmd_Le(cmd);
  unsigned char return_value_APDU_Rsp_SW1$12;
  unsigned char return_value_APDU_Rsp_SW1$11;
  signed int tmp_if_expr$5;
  unsigned char return_value_APDU_Rsp_SW2$4;
  if(!(return_value_APDU_Cmd_Le$14 >= 257ul))
  {
    buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
    buffer[(signed long int)1]=APDU_Cmd_Ins(cmd);
    buffer[(signed long int)2]=APDU_Cmd_P1(cmd);
    buffer[(signed long int)3]=APDU_Cmd_P2(cmd);
    unsigned long int return_value_APDU_Cmd_Le$1;
    return_value_APDU_Cmd_Le$1=APDU_Cmd_Le(cmd);
    buffer[(signed long int)4] = (unsigned char)return_value_APDU_Cmd_Le$1;
    tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)5);
    ret=Protocol_T0_Case3S(t0, tpdu_cmd, rsp);
    APDU_Cmd_Delete(tpdu_cmd);
  }

  else
  {
    buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
    buffer[(signed long int)1]=APDU_Cmd_Ins(cmd);
    buffer[(signed long int)2]=APDU_Cmd_P1(cmd);
    buffer[(signed long int)3]=APDU_Cmd_P2(cmd);
    buffer[(signed long int)4] = (unsigned char)0x00;
    tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)5);
    ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, &tpdu_rsp);
    APDU_Cmd_Delete(tpdu_cmd);
    if(ret == 0)
    {
      unsigned char return_value_APDU_Rsp_SW1$13;
      return_value_APDU_Rsp_SW1$13=APDU_Rsp_SW1(tpdu_rsp);
      if((signed int)return_value_APDU_Rsp_SW1$13 == 0x67)
        *rsp = tpdu_rsp;

      else
      {
        return_value_APDU_Rsp_SW1$12=APDU_Rsp_SW1(tpdu_rsp);
        if((signed int)return_value_APDU_Rsp_SW1$12 == 0x6C)
        {
          unsigned char *return_value_APDU_Cmd_Raw$2;
          return_value_APDU_Cmd_Raw$2=APDU_Cmd_Raw(cmd);
          memcpy((void *)buffer, (const void *)return_value_APDU_Cmd_Raw$2, (unsigned long int)4);
          buffer[(signed long int)4]=APDU_Rsp_SW2(tpdu_rsp);
          tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)5);
          APDU_Rsp_Delete(tpdu_rsp);
          ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, rsp);
          APDU_Cmd_Delete(tpdu_cmd);
        }

        else
        {
          return_value_APDU_Rsp_SW1$11=APDU_Rsp_SW1(tpdu_rsp);
          if((signed int)return_value_APDU_Rsp_SW1$11 == 0x61)
          {
            *rsp = tpdu_rsp;
            unsigned char return_value_APDU_Rsp_SW2$3;
            return_value_APDU_Rsp_SW2$3=APDU_Rsp_SW2(tpdu_rsp);
            if((signed int)return_value_APDU_Rsp_SW2$3 == 0x00)
              tmp_if_expr$5 = 256;

            else
            {
              return_value_APDU_Rsp_SW2$4=APDU_Rsp_SW2(tpdu_rsp);
              tmp_if_expr$5 = (signed int)return_value_APDU_Rsp_SW2$4;
            }
            Lx = (signed long int)tmp_if_expr$5;
            unsigned long int return_value_APDU_Cmd_Le$6;
            return_value_APDU_Cmd_Le$6=APDU_Cmd_Le(cmd);
            unsigned long int return_value_APDU_Rsp_DataLen$7;
            return_value_APDU_Rsp_DataLen$7=APDU_Rsp_DataLen(*rsp);
            Lm = (signed long int)(return_value_APDU_Cmd_Le$6 - return_value_APDU_Rsp_DataLen$7);
            buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
            buffer[(signed long int)1] = (unsigned char)0xC0;
            buffer[(signed long int)2] = (unsigned char)0x00;
            buffer[(signed long int)3] = (unsigned char)0x00;
            while(Lm >= 1l)
            {
              buffer[(signed long int)4] = (unsigned char)(Lm < Lx ? Lm : Lx);
              tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)5);
              ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, &tpdu_rsp);
              APDU_Cmd_Delete(tpdu_cmd);
              if(ret == 0)
              {
                signed int return_value_APDU_Rsp_AppendData$8;
                return_value_APDU_Rsp_AppendData$8=APDU_Rsp_AppendData(*rsp, tpdu_rsp);
                if(!(return_value_APDU_Rsp_AppendData$8 == 0))
                {
                  ret = 4;
                  APDU_Rsp_Delete(tpdu_rsp);
                  break;
                }

                APDU_Rsp_Delete(tpdu_rsp);
              }

              else
                break;
              unsigned long int return_value_APDU_Cmd_Le$9;
              return_value_APDU_Cmd_Le$9=APDU_Cmd_Le(cmd);
              unsigned long int return_value_APDU_Rsp_DataLen$10;
              return_value_APDU_Rsp_DataLen$10=APDU_Rsp_DataLen(*rsp);
              Lm = (signed long int)(return_value_APDU_Cmd_Le$9 - return_value_APDU_Rsp_DataLen$10);
            }
          }

          else
            *rsp = tpdu_rsp;
        }
      }
    }

  }
  return ret;
}

// Protocol_T0_Case3S
// file protocol_t0.c line 218
static signed int Protocol_T0_Case3S(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret;
  struct anonymous$14 *tpdu_rsp;
  ret=Protocol_T0_ExchangeTPDU(t0, cmd, &tpdu_rsp);
  if(ret == 0)
    *rsp = tpdu_rsp;

  return ret;
}

// Protocol_T0_Case4E
// file protocol_t0.c line 633
static signed int Protocol_T0_Case4E(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret;
  unsigned char buffer[260l];
  struct anonymous$13 *tpdu_cmd;
  struct anonymous$13 *gr_cmd;
  struct anonymous$14 *tpdu_rsp;
  signed long int Le;
  unsigned long int return_value_APDU_Cmd_Lc$3;
  return_value_APDU_Cmd_Lc$3=APDU_Cmd_Lc(cmd);
  if(!(return_value_APDU_Cmd_Lc$3 >= 256ul))
  {
    buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
    buffer[(signed long int)1]=APDU_Cmd_Ins(cmd);
    buffer[(signed long int)2]=APDU_Cmd_P1(cmd);
    buffer[(signed long int)3]=APDU_Cmd_P2(cmd);
    unsigned long int return_value_APDU_Cmd_Lc$1;
    return_value_APDU_Cmd_Lc$1=APDU_Cmd_Lc(cmd);
    buffer[(signed long int)4] = (unsigned char)return_value_APDU_Cmd_Lc$1;
    unsigned char *return_value_APDU_Cmd_Data$2;
    return_value_APDU_Cmd_Data$2=APDU_Cmd_Data(cmd);
    memcpy((void *)(buffer + (signed long int)5), (const void *)return_value_APDU_Cmd_Data$2, (unsigned long int)buffer[(signed long int)4]);
    tpdu_cmd=APDU_Cmd_New(buffer, (unsigned long int)((signed int)buffer[(signed long int)4] + 5));
    ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, &tpdu_rsp);
    APDU_Cmd_Delete(tpdu_cmd);
  }

  else
    ret=Protocol_T0_Case2E(t0, cmd, &tpdu_rsp);
  unsigned char return_value_APDU_Rsp_SW2$4;
  unsigned long int return_value_APDU_Cmd_Le$5;
  unsigned long int tmp_if_expr$8;
  unsigned char return_value_APDU_Rsp_SW2$6;
  unsigned long int return_value_APDU_Cmd_Le$7;
  unsigned long int return_value_APDU_Cmd_Le$9;
  unsigned char return_value_APDU_Rsp_SW1$13;
  if(ret == 0)
  {
    unsigned char return_value_APDU_Rsp_SW1$14;
    return_value_APDU_Rsp_SW1$14=APDU_Rsp_SW1(tpdu_rsp);
    if((signed int)return_value_APDU_Rsp_SW1$14 == 0x61)
    {
      unsigned char return_value_APDU_Rsp_SW2$10;
      return_value_APDU_Rsp_SW2$10=APDU_Rsp_SW2(tpdu_rsp);
      if(!((signed int)return_value_APDU_Rsp_SW2$10 == 0x00))
      {
        return_value_APDU_Rsp_SW2$4=APDU_Rsp_SW2(tpdu_rsp);
        return_value_APDU_Cmd_Le$5=APDU_Cmd_Le(cmd);
        if(!((unsigned long int)return_value_APDU_Rsp_SW2$4 >= return_value_APDU_Cmd_Le$5))
        {
          return_value_APDU_Rsp_SW2$6=APDU_Rsp_SW2(tpdu_rsp);
          tmp_if_expr$8 = (unsigned long int)return_value_APDU_Rsp_SW2$6;
        }

        else
        {
          return_value_APDU_Cmd_Le$7=APDU_Cmd_Le(cmd);
          tmp_if_expr$8 = return_value_APDU_Cmd_Le$7;
        }
        Le = (signed long int)tmp_if_expr$8;
      }

      else
      {
        return_value_APDU_Cmd_Le$9=APDU_Cmd_Le(cmd);
        Le = (signed long int)return_value_APDU_Cmd_Le$9;
      }
      APDU_Rsp_Delete(tpdu_rsp);
      buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
      buffer[(signed long int)1] = (unsigned char)0xC0;
      buffer[(signed long int)2] = (unsigned char)0x00;
      buffer[(signed long int)3] = (unsigned char)0x00;
      buffer[(signed long int)4] = (unsigned char)0x00;
      buffer[(signed long int)5] = (unsigned char)(Le >> 8);
      buffer[(signed long int)6] = (unsigned char)(Le & (signed long int)0x00FF);
      gr_cmd=APDU_Cmd_New(buffer, (unsigned long int)7);
      ret=Protocol_T0_Case3E(t0, gr_cmd, rsp);
      APDU_Cmd_Delete(gr_cmd);
    }

    else
    {
      return_value_APDU_Rsp_SW1$13=APDU_Rsp_SW1(tpdu_rsp);
      if((0xF0 & (signed int)return_value_APDU_Rsp_SW1$13) == 0x60)
        *rsp = tpdu_rsp;

      else
      {
        APDU_Rsp_Delete(tpdu_rsp);
        buffer[(signed long int)0]=APDU_Cmd_Cla(cmd);
        buffer[(signed long int)1] = (unsigned char)0xC0;
        buffer[(signed long int)2] = (unsigned char)0x00;
        buffer[(signed long int)3] = (unsigned char)0x00;
        buffer[(signed long int)4] = (unsigned char)0x00;
        unsigned long int return_value_APDU_Cmd_Le$11;
        return_value_APDU_Cmd_Le$11=APDU_Cmd_Le(cmd);
        buffer[(signed long int)5] = (unsigned char)(return_value_APDU_Cmd_Le$11 >> 8);
        unsigned long int return_value_APDU_Cmd_Le$12;
        return_value_APDU_Cmd_Le$12=APDU_Cmd_Le(cmd);
        buffer[(signed long int)6] = (unsigned char)(return_value_APDU_Cmd_Le$12 & (unsigned long int)0x00FF);
        gr_cmd=APDU_Cmd_New(buffer, (unsigned long int)7);
        ret=Protocol_T0_Case3E(t0, gr_cmd, rsp);
        APDU_Cmd_Delete(gr_cmd);
      }
    }
  }

  return ret;
}

// Protocol_T0_Case4S
// file protocol_t0.c line 328
static signed int Protocol_T0_Case4S(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int ret;
  unsigned char buffer[260l];
  struct anonymous$13 *tpdu_cmd;
  struct anonymous$14 *tpdu_rsp;
  unsigned char *return_value_APDU_Cmd_Raw$1;
  return_value_APDU_Cmd_Raw$1=APDU_Cmd_Raw(cmd);
  unsigned long int return_value_APDU_Cmd_RawLen$2;
  return_value_APDU_Cmd_RawLen$2=APDU_Cmd_RawLen(cmd);
  memcpy((void *)buffer, (const void *)return_value_APDU_Cmd_Raw$1, return_value_APDU_Cmd_RawLen$2 - (unsigned long int)1);
  unsigned long int return_value_APDU_Cmd_RawLen$3;
  return_value_APDU_Cmd_RawLen$3=APDU_Cmd_RawLen(cmd);
  tpdu_cmd=APDU_Cmd_New(buffer, return_value_APDU_Cmd_RawLen$3 - (unsigned long int)1);
  ret=Protocol_T0_ExchangeTPDU(t0, tpdu_cmd, &tpdu_rsp);
  APDU_Cmd_Delete(tpdu_cmd);
  if(ret == 0)
    *rsp = tpdu_rsp;

  return ret;
}

// Protocol_T0_Clear
// file protocol_t0.c line 949
static void Protocol_T0_Clear(struct anonymous$11 *t0)
{
  t0->icc = (struct anonymous$5 *)(void *)0;
  t0->wwt = (unsigned long int)0;
}

// Protocol_T0_Close
// file protocol_t0.c line 167
extern signed int Protocol_T0_Close(struct anonymous$11 *t0)
{
  Protocol_T0_Clear(t0);
  return 0;
}

// Protocol_T0_Command
// file protocol_t0.c line 123
extern signed int Protocol_T0_Command(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  signed int cmd_case;
  signed int ret;
  cmd_case=APDU_Cmd_Case(cmd);
  if(cmd_case == 0x0001)
    ret=Protocol_T0_Case1(t0, cmd, rsp);

  else
    if(cmd_case == 0x0002)
      ret=Protocol_T0_Case2S(t0, cmd, rsp);

    else
      if(cmd_case == 0x0003)
        ret=Protocol_T0_Case3S(t0, cmd, rsp);

      else
        if(cmd_case == 0x0004)
          ret=Protocol_T0_Case4S(t0, cmd, rsp);

        else
          if(cmd_case == 0x0102)
            ret=Protocol_T0_Case2E(t0, cmd, rsp);

          else
            if(cmd_case == 0x0103)
              ret=Protocol_T0_Case3E(t0, cmd, rsp);

            else
              if(cmd_case == 0x0104)
                ret=Protocol_T0_Case4E(t0, cmd, rsp);

              else
                ret = 4;
  return ret;
}

// Protocol_T0_Delete
// file protocol_t0.c line 175
extern void Protocol_T0_Delete(struct anonymous$11 *t0)
{
  free((void *)t0);
}

// Protocol_T0_ExchangeTPDU
// file protocol_t0.c line 733
static signed int Protocol_T0_ExchangeTPDU(struct anonymous$11 *t0, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  unsigned char buffer[258l];
  unsigned char *data;
  signed long int Lc;
  signed long int Le;
  signed long int sent;
  signed long int recv;
  signed int ret = 0;
  signed int nulls;
  signed int cmd_case;
  unsigned long int return_value_APDU_Cmd_Lc$1;
  return_value_APDU_Cmd_Lc$1=APDU_Cmd_Lc(cmd);
  Lc = (signed long int)return_value_APDU_Cmd_Lc$1;
  unsigned long int return_value_APDU_Cmd_Le$2;
  return_value_APDU_Cmd_Le$2=APDU_Cmd_Le(cmd);
  Le = (signed long int)return_value_APDU_Cmd_Le$2;
  data=APDU_Cmd_Data(cmd);
  cmd_case=APDU_Cmd_Case(cmd);
  _Bool tmp_if_expr$16;
  unsigned char return_value_APDU_Cmd_Ins$15;
  unsigned char return_value_APDU_Cmd_Ins$14;
  if(!(cmd_case == 0x0002) && !(cmd_case == 0x0003))
    return 4;

  else
  {
    signed int return_value_ICC_Async_BeginTransmission$3;
    return_value_ICC_Async_BeginTransmission$3=ICC_Async_BeginTransmission(t0->icc);
    if(!(return_value_ICC_Async_BeginTransmission$3 == 0))
    {
      *rsp = (struct anonymous$14 *)(void *)0;
      return 2;
    }

    else
    {
      unsigned char *return_value_APDU_Cmd_Header$4;
      return_value_APDU_Cmd_Header$4=APDU_Cmd_Header(cmd);
      signed int return_value_ICC_Async_Transmit$5;
      return_value_ICC_Async_Transmit$5=ICC_Async_Transmit(t0->icc, (unsigned int)5, return_value_APDU_Cmd_Header$4);
      if(!(return_value_ICC_Async_Transmit$5 == 0))
      {
        ICC_Async_EndTransmission(t0->icc);
        *rsp = (struct anonymous$14 *)(void *)0;
        return 2;
      }

      else
      {
        nulls = 0;
        sent = (signed long int)0;
        recv = (signed long int)0;
        while(!(recv >= 258l))
        {
          signed int return_value_ICC_Async_Receive$6;
          return_value_ICC_Async_Receive$6=ICC_Async_Receive(t0->icc, (unsigned int)1, buffer + recv);
          if(!(return_value_ICC_Async_Receive$6 == 0))
          {
            ret = 2;
            break;
          }

          if((signed int)buffer[recv] == 0x60)
          {
            nulls = nulls + 1;
            if(nulls >= 200)
            {
              ret = 1;
              break;
            }

            continue;
          }

          else
          {
            if((0xF0 & (signed int)buffer[recv]) == 0x60)
              tmp_if_expr$16 = (_Bool)1;

            else
              tmp_if_expr$16 = ((signed int)buffer[recv] & 0xF0) == 0x90 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$16)
            {
              recv = recv + 1l;
              if(recv >= 258l)
                return 4;

              signed int return_value_ICC_Async_Receive$7;
              return_value_ICC_Async_Receive$7=ICC_Async_Receive(t0->icc, (unsigned int)1, buffer + recv);
              if(!(return_value_ICC_Async_Receive$7 == 0))
              {
                ret = 2;
                break;
              }

              recv = recv + 1l;
              ret = 0;
              break;
            }

            else
            {
              return_value_APDU_Cmd_Ins$15=APDU_Cmd_Ins(cmd);
              if((0x0E & (signed int)buffer[recv]) == (0x0E & (signed int)return_value_APDU_Cmd_Ins$15))
              {
                nulls = 0;
                if(cmd_case == 0x0002)
                {
                  if(sent >= Lc)
                    return 4;

                  signed int return_value_ICC_Async_Switch$8;
                  return_value_ICC_Async_Switch$8=ICC_Async_Switch(t0->icc);
                  if(!(return_value_ICC_Async_Switch$8 == 0))
                  {
                    ret = 2;
                    break;
                  }

                  signed int return_value_ICC_Async_Transmit$9;
                  return_value_ICC_Async_Transmit$9=ICC_Async_Transmit(t0->icc, (unsigned int)(Lc - sent > (signed long int)0 ? Lc - sent : (signed long int)0), data + sent);
                  if(!(return_value_ICC_Async_Transmit$9 == 0))
                  {
                    ret = 2;
                    break;
                  }

                  sent = Lc;
                  continue;
                }

                else
                {
                  if(recv >= 258l)
                    return 4;

                  signed int return_value_ICC_Async_Receive$10;
                  return_value_ICC_Async_Receive$10=ICC_Async_Receive(t0->icc, (unsigned int)(Le - recv > (signed long int)0 ? Le - recv : (signed long int)0), buffer + recv);
                  if(!(return_value_ICC_Async_Receive$10 == 0))
                  {
                    ret = 2;
                    break;
                  }

                  recv = Le;
                  continue;
                }
              }

              else
              {
                return_value_APDU_Cmd_Ins$14=APDU_Cmd_Ins(cmd);
                if((0x0E & (signed int)buffer[recv]) == (~((signed int)return_value_APDU_Cmd_Ins$14) & 0x0E))
                {
                  nulls = 0;
                  if(cmd_case == 0x0002)
                  {
                    if(sent >= Lc)
                      return 4;

                    signed int return_value_ICC_Async_Switch$11;
                    return_value_ICC_Async_Switch$11=ICC_Async_Switch(t0->icc);
                    if(!(return_value_ICC_Async_Switch$11 == 0))
                    {
                      ret = 2;
                      break;
                    }

                    signed int return_value_ICC_Async_Transmit$12;
                    return_value_ICC_Async_Transmit$12=ICC_Async_Transmit(t0->icc, (unsigned int)1, data + sent);
                    if(!(return_value_ICC_Async_Transmit$12 == 0))
                    {
                      ret = 2;
                      break;
                    }

                    sent = sent + 1l;
                    continue;
                  }

                  else
                  {
                    if(recv >= 258l)
                      return 4;

                    signed int return_value_ICC_Async_Receive$13;
                    return_value_ICC_Async_Receive$13=ICC_Async_Receive(t0->icc, (unsigned int)1, buffer + recv);
                    if(!(return_value_ICC_Async_Receive$13 == 0))
                    {
                      ret = 2;
                      break;
                    }

                    recv = recv + 1l;
                    continue;
                  }
                }

                else
                {
                  ret = 4;
                  break;
                }
              }
            }
          }
        }
        signed int return_value_ICC_Async_Switch$17;
        return_value_ICC_Async_Switch$17=ICC_Async_Switch(t0->icc);
        if(!(return_value_ICC_Async_Switch$17 == 0))
          ret = 2;

        if(ret == 0)
          *rsp=APDU_Rsp_New(buffer, (unsigned long int)recv);

        else
          *rsp = (struct anonymous$14 *)(void *)0;
        signed int return_value_ICC_Async_EndTransmission$18;
        return_value_ICC_Async_EndTransmission$18=ICC_Async_EndTransmission(t0->icc);
        if(!(return_value_ICC_Async_EndTransmission$18 == 0))
          return 2;

        else
          return ret;
      }
    }
  }
}

// Protocol_T0_Init
// file protocol_t0.c line 87
extern signed int Protocol_T0_Init(struct anonymous$11 *t0, struct anonymous$5 *icc, struct anonymous$12 *params)
{
  struct anonymous$4 timings;
  unsigned char wi;
  struct anonymous$7 *atr;
  atr=ICC_Async_GetAtr(icc);
  t0->icc = icc;
  signed int return_value_ATR_GetInterfaceByte$1;
  return_value_ATR_GetInterfaceByte$1=ATR_GetInterfaceByte(atr, (unsigned int)2, 2, &wi);
  if(!(return_value_ATR_GetInterfaceByte$1 == 0))
    wi = (unsigned char)10;

  unsigned long int return_value_ICC_Async_GetClockRate$2;
  return_value_ICC_Async_GetClockRate$2=ICC_Async_GetClockRate(t0->icc);
  t0->wwt = (unsigned long int)((double)(960 * (signed int)wi) * (params->f / (double)return_value_ICC_Async_GetClockRate$2) * (double)1000);
  ICC_Async_GetTimings(t0->icc, &timings);
  timings.block_timeout = (unsigned int)t0->wwt;
  timings.char_timeout = (unsigned int)t0->wwt;
  ICC_Async_SetTimings(t0->icc, &timings);
  return 0;
}

// Protocol_T0_New
// file protocol_t0.c line 74
extern struct anonymous$11 * Protocol_T0_New(void)
{
  struct anonymous$11 *t0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$11) /*16ul*/ );
  t0 = (struct anonymous$11 *)return_value_malloc$1;
  if(!(t0 == ((struct anonymous$11 *)NULL)))
    Protocol_T0_Clear(t0);

  return t0;
}

// Protocol_T1_Clear
// file protocol_t1.c line 459
static void Protocol_T1_Clear(struct anonymous$18 *t1)
{
  t1->icc = (struct anonymous$5 *)(void *)0;
  t1->ifsc = (unsigned short int)0;
  t1->ifsd = (unsigned short int)0;
  t1->bgt = (unsigned short int)0;
  t1->bwt = (unsigned short int)0;
  t1->cwt = (unsigned short int)0;
  t1->edc = 0;
  t1->ns = (unsigned char)0;
}

// Protocol_T1_Close
// file protocol_t1.c line 358
extern signed int Protocol_T1_Close(struct anonymous$18 *t1)
{
  Protocol_T1_Clear(t1);
  return 0;
}

// Protocol_T1_Command
// file protocol_t1.c line 170
extern signed int Protocol_T1_Command(struct anonymous$18 *t1, struct anonymous$13 *cmd, struct anonymous$14 **rsp)
{
  struct anonymous$15 *block;
  unsigned char *buffer;
  unsigned char rsp_type;
  unsigned char bytes;
  unsigned char nr;
  unsigned char wtx;
  unsigned short int counter;
  signed int ret;
  signed int more;
  counter = (unsigned short int)0;
  unsigned long int return_value_APDU_Cmd_RawLen$1;
  return_value_APDU_Cmd_RawLen$1=APDU_Cmd_RawLen(cmd);
  unsigned long int tmp_if_expr$3;
  unsigned long int return_value_APDU_Cmd_RawLen$2;
  if(!(return_value_APDU_Cmd_RawLen$1 >= (unsigned long int)t1->ifsc))
  {
    return_value_APDU_Cmd_RawLen$2=APDU_Cmd_RawLen(cmd);
    tmp_if_expr$3 = return_value_APDU_Cmd_RawLen$2;
  }

  else
    tmp_if_expr$3 = (unsigned long int)t1->ifsc;
  bytes = (unsigned char)tmp_if_expr$3;
  unsigned long int return_value_APDU_Cmd_RawLen$4;
  return_value_APDU_Cmd_RawLen$4=APDU_Cmd_RawLen(cmd);
  more = (signed int)(return_value_APDU_Cmd_RawLen$4 > (unsigned long int)t1->ifsc);
  t1->ns = (unsigned char)(((signed int)t1->ns + 1) % 2);
  unsigned char *return_value_APDU_Cmd_Raw$5;
  return_value_APDU_Cmd_Raw$5=APDU_Cmd_Raw(cmd);
  block=T1_Block_NewIBlock(bytes, return_value_APDU_Cmd_Raw$5, t1->ns, more);
  ret=Protocol_T1_SendBlock(t1, block);
  T1_Block_Delete(block);
  unsigned long int tmp_if_expr$8;
  unsigned long int return_value_APDU_Cmd_RawLen$7;
  while(ret == 0 && !(more == 0))
  {
    ret=Protocol_T1_ReceiveBlock(t1, &block);
    if(ret == 0)
    {
      rsp_type=T1_Block_GetType(block);
      if((signed int)rsp_type == 0x80)
      {
        T1_Block_Delete(block);
        t1->ns = (unsigned char)(((signed int)t1->ns + 1) % 2);
        counter = counter + (unsigned short int)bytes;
        unsigned long int return_value_APDU_Cmd_RawLen$6;
        return_value_APDU_Cmd_RawLen$6=APDU_Cmd_RawLen(cmd);
        if(!(return_value_APDU_Cmd_RawLen$6 + -((unsigned long int)counter) >= (unsigned long int)t1->ifsc))
        {
          return_value_APDU_Cmd_RawLen$7=APDU_Cmd_RawLen(cmd);
          tmp_if_expr$8 = return_value_APDU_Cmd_RawLen$7 - (unsigned long int)counter;
        }

        else
          tmp_if_expr$8 = (unsigned long int)t1->ifsc;
        bytes = (unsigned char)tmp_if_expr$8;
        unsigned long int return_value_APDU_Cmd_RawLen$9;
        return_value_APDU_Cmd_RawLen$9=APDU_Cmd_RawLen(cmd);
        more = (signed int)(return_value_APDU_Cmd_RawLen$9 - (unsigned long int)counter > (unsigned long int)t1->ifsc);
        unsigned char *return_value_APDU_Cmd_Raw$10;
        return_value_APDU_Cmd_Raw$10=APDU_Cmd_Raw(cmd);
        block=T1_Block_NewIBlock(bytes, return_value_APDU_Cmd_Raw$10 + (signed long int)counter, t1->ns, more);
        ret=Protocol_T1_SendBlock(t1, block);
        T1_Block_Delete(block);
      }

      else
      {
        T1_Block_Delete(block);
        ret = 7;
      }
    }

    else
      ret = 7;
  }
  buffer = (unsigned char *)(void *)0;
  counter = (unsigned short int)0;
  more = 1;
  wtx = (unsigned char)0;
  while(ret == 0 && !(more == 0))
  {
    if((signed int)wtx >= 2)
      Protocol_T1_UpdateBWT(t1, (unsigned short int)((signed int)wtx * (signed int)t1->bwt));

    ret=Protocol_T1_ReceiveBlock(t1, &block);
    if((signed int)wtx >= 2)
    {
      Protocol_T1_UpdateBWT(t1, t1->bwt);
      wtx = (unsigned char)0;
    }

    if(ret == 0)
    {
      rsp_type=T1_Block_GetType(block);
      if((signed int)rsp_type == 0x00)
      {
        unsigned char return_value_T1_Block_GetNS$11;
        return_value_T1_Block_GetNS$11=T1_Block_GetNS(block);
        nr = (unsigned char)(((signed int)return_value_T1_Block_GetNS$11 + 1) % 2);
        bytes=T1_Block_GetLen(block);
        void *return_value_realloc$12;
        return_value_realloc$12=realloc((void *)buffer, (unsigned long int)((signed int)counter + (signed int)bytes));
        buffer = (unsigned char *)return_value_realloc$12;
        unsigned char *return_value_T1_Block_GetInf$13;
        return_value_T1_Block_GetInf$13=T1_Block_GetInf(block);
        memcpy((void *)(buffer + (signed long int)counter), (const void *)return_value_T1_Block_GetInf$13, (unsigned long int)bytes);
        counter = counter + (unsigned short int)bytes;
        more=T1_Block_GetMore(block);
        T1_Block_Delete(block);
        if(!(more == 0))
        {
          block=T1_Block_NewRBlock((unsigned char)0x80, nr);
          ret=Protocol_T1_SendBlock(t1, block);
          T1_Block_Delete(block);
        }

      }

      else
        if((signed int)rsp_type == 0xC3)
        {
          unsigned char *return_value_T1_Block_GetInf$14;
          return_value_T1_Block_GetInf$14=T1_Block_GetInf(block);
          wtx = *return_value_T1_Block_GetInf$14;
          T1_Block_Delete(block);
          block=T1_Block_NewSBlock((unsigned char)0xE3, (unsigned char)1, &wtx);
          ret=Protocol_T1_SendBlock(t1, block);
          T1_Block_Delete(block);
        }

        else
          ret = 7;
    }

  }
  if(ret == 0)
    *rsp=APDU_Rsp_New(buffer, (unsigned long int)counter);

  if(!(buffer == ((unsigned char *)NULL)))
    free((void *)buffer);

  return ret;
}

// Protocol_T1_Delete
// file protocol_t1.c line 366
extern void Protocol_T1_Delete(struct anonymous$18 *t1)
{
  free((void *)t1);
}

// Protocol_T1_Init
// file protocol_t1.c line 75
extern signed int Protocol_T1_Init(struct anonymous$18 *t1, struct anonymous$5 *icc, struct anonymous$12 *params)
{
  struct anonymous$4 timings;
  unsigned char ta;
  unsigned char tb;
  unsigned char tc;
  unsigned char cwi;
  unsigned char bwi;
  unsigned long int baudrate;
  double work_etu;
  struct anonymous$7 *atr;
  signed int i;
  t1->icc = icc;
  atr=ICC_Async_GetAtr(t1->icc);
  signed int return_value_ATR_GetInterfaceByte$1;
  return_value_ATR_GetInterfaceByte$1=ATR_GetInterfaceByte(atr, (unsigned int)3, 0, &ta);
  if(return_value_ATR_GetInterfaceByte$1 == 1)
    t1->ifsc = (unsigned short int)32;

  else
    if(!((signed int)ta == 0x00) && !((signed int)ta == 0xFF))
      t1->ifsc = (unsigned short int)ta;

    else
      t1->ifsc = (unsigned short int)32;
  signed int tmp_if_expr$2;
  if(!((signed int)t1->ifsc >= 251))
    tmp_if_expr$2 = (signed int)t1->ifsc;

  else
    tmp_if_expr$2 = 251;
  t1->ifsc = (unsigned short int)tmp_if_expr$2;
  t1->ifsd = (unsigned short int)32;
  signed int return_value_ATR_GetInterfaceByte$3;
  return_value_ATR_GetInterfaceByte$3=ATR_GetInterfaceByte(atr, (unsigned int)3, 1, &tb);
  if(return_value_ATR_GetInterfaceByte$3 == 1)
  {
    cwi = (unsigned char)13;
    bwi = (unsigned char)4;
  }

  else
  {
    cwi = (unsigned char)((signed int)tb & 0x0F);
    bwi = (unsigned char)(((signed int)tb & 0xF0) >> 4);
  }
  ICC_Async_GetBaudrate(t1->icc, &baudrate);
  work_etu = (double)1000 / (double)baudrate;
  t1->cwt = (unsigned short int)1;
  i = 0;
  for( ; !(i >= (signed int)cwi); i = i + 1)
    t1->cwt = t1->cwt * (unsigned short int)2;
  t1->cwt = (unsigned short int)((double)((signed int)t1->cwt + 11) * work_etu);
  t1->bwt = (unsigned short int)1;
  i = 0;
  for( ; !(i >= (signed int)bwi); i = i + 1)
    t1->bwt = t1->bwt * (unsigned short int)2;
  t1->bwt = (unsigned short int)((double)((signed int)t1->bwt * 960 + 11) * work_etu);
  t1->bgt = (unsigned short int)((double)22 * work_etu);
  signed int return_value_ATR_GetInterfaceByte$4;
  return_value_ATR_GetInterfaceByte$4=ATR_GetInterfaceByte(atr, (unsigned int)3, 2, &tc);
  if(return_value_ATR_GetInterfaceByte$4 == 1)
    t1->edc = 0;

  else
    t1->edc = (signed int)tc & 0x01;
  t1->ns = (unsigned char)1;
  ICC_Async_GetTimings(t1->icc, &timings);
  timings.block_timeout = (unsigned int)t1->bwt;
  timings.char_timeout = (unsigned int)t1->cwt;
  timings.block_delay = (unsigned int)t1->bgt;
  ICC_Async_SetTimings(t1->icc, &timings);
  return 0;
}

// Protocol_T1_New
// file protocol_t1.c line 62
extern struct anonymous$18 * Protocol_T1_New(void)
{
  struct anonymous$18 *t1;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$18) /*32ul*/ );
  t1 = (struct anonymous$18 *)return_value_malloc$1;
  if(!(t1 == ((struct anonymous$18 *)NULL)))
    Protocol_T1_Clear(t1);

  return t1;
}

// Protocol_T1_ReceiveBlock
// file protocol_t1.c line 405
static signed int Protocol_T1_ReceiveBlock(struct anonymous$18 *t1, struct anonymous$15 **block)
{
  unsigned char buffer[259l];
  signed int ret;
  signed int return_value_ICC_Async_Receive$2;
  return_value_ICC_Async_Receive$2=ICC_Async_Receive(t1->icc, (unsigned int)4, buffer);
  if(!(return_value_ICC_Async_Receive$2 == 0))
  {
    ret = 2;
    *block = (struct anonymous$15 *)(void *)0;
  }

  else
    if(!((signed int)buffer[2l] == 0x00))
    {
      Protocol_T1_UpdateBWT(t1, t1->cwt);
      signed int return_value_ICC_Async_Receive$1;
      return_value_ICC_Async_Receive$1=ICC_Async_Receive(t1->icc, (unsigned int)buffer[(signed long int)2], buffer + (signed long int)4);
      if(!(return_value_ICC_Async_Receive$1 == 0))
      {
        *block = (struct anonymous$15 *)(void *)0;
        ret = 2;
      }

      else
      {
        *block=T1_Block_New(buffer, (unsigned int)((signed int)buffer[(signed long int)2] + 4));
        ret = 0;
      }
      Protocol_T1_UpdateBWT(t1, t1->bwt);
    }

    else
    {
      ret = 0;
      *block=T1_Block_New(buffer, (unsigned int)4);
    }
  signed int return_value_ICC_Async_Switch$3;
  return_value_ICC_Async_Switch$3=ICC_Async_Switch(t1->icc);
  if(!(return_value_ICC_Async_Switch$3 == 0))
    ret = 2;

  signed int return_value_ICC_Async_EndTransmission$4;
  return_value_ICC_Async_EndTransmission$4=ICC_Async_EndTransmission(t1->icc);
  if(!(return_value_ICC_Async_EndTransmission$4 == 0))
    ret = 2;

  return ret;
}

// Protocol_T1_SendBlock
// file protocol_t1.c line 376
static signed int Protocol_T1_SendBlock(struct anonymous$18 *t1, struct anonymous$15 *block)
{
  unsigned char *buffer;
  signed int length;
  signed int ret;
  signed int return_value_ICC_Async_BeginTransmission$3;
  return_value_ICC_Async_BeginTransmission$3=ICC_Async_BeginTransmission(t1->icc);
  if(!(return_value_ICC_Async_BeginTransmission$3 == 0))
    ret = 2;

  else
  {
    buffer=T1_Block_Raw(block);
    unsigned int return_value_T1_Block_RawLen$1;
    return_value_T1_Block_RawLen$1=T1_Block_RawLen(block);
    length = (signed int)return_value_T1_Block_RawLen$1;
    signed int return_value_ICC_Async_Transmit$2;
    return_value_ICC_Async_Transmit$2=ICC_Async_Transmit(t1->icc, (unsigned int)length, buffer);
    if(!(return_value_ICC_Async_Transmit$2 == 0))
    {
      ICC_Async_EndTransmission(t1->icc);
      ret = 2;
    }

    else
      ret = 0;
  }
  return ret;
}

// Protocol_T1_UpdateBWT
// file protocol_t1.c line 472
static signed int Protocol_T1_UpdateBWT(struct anonymous$18 *t1, unsigned short int bwt)
{
  struct anonymous$4 timings;
  ICC_Async_GetTimings(t1->icc, &timings);
  timings.block_timeout = (unsigned int)bwt;
  ICC_Async_SetTimings(t1->icc, &timings);
  return 0;
}

// ReadBinary
// file tester.c line 849
void ReadBinary(unsigned short int ctn)
{
  unsigned char read_binary[5l] = { (unsigned char)0x00, (unsigned char)0xB0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
  char buffer[32l];
  unsigned char res[258l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  signed int dummy;
  char ret;
  read_binary[(signed long int)0] = ct_list[(signed long int)ctn].cla;
  printf("File size: ");
  scanf("%X", (unsigned int *)buffer);
  dummy=getchar();
  read_binary[(signed long int)4] = (unsigned char)buffer[(signed long int)0];
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)258;
  printf("Command: ");
  PrintArray(read_binary, (unsigned int)5);
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)5, read_binary, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on READ BYNARY: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// ReadData
// file tester.c line 1043
void ReadData(unsigned short int ctn)
{
  unsigned char select_file[7l] = { (unsigned char)0x00, (unsigned char)0xA4, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x3F, (unsigned char)0x00 };
  unsigned char read_binary[6l] = { (unsigned char)0x00, (unsigned char)0xB0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
  signed int address;
  signed int size;
  signed int total_size;
  unsigned char *res;
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  unsigned short int lc;
  signed int dummy;
  char ret;
  printf("Address: ");
  scanf("%d", &address);
  dummy=getchar();
  read_binary[(signed long int)2] = (unsigned char)(address >> 8);
  read_binary[(signed long int)3] = (unsigned char)(address & 0x00FF);
  unsigned int return_value_GetMemoryLength$1;
  return_value_GetMemoryLength$1=GetMemoryLength(ct_list[(signed long int)ctn].atr, (unsigned int)ct_list[(signed long int)ctn].atr_size);
  total_size = (signed int)return_value_GetMemoryLength$1;
  printf("Size (0..%d): ", total_size);
  scanf("%d", &size);
  dummy=getchar();
  if(!(size >= 256))
  {
    read_binary[(signed long int)4] = (unsigned char)size;
    lc = (unsigned short int)5;
  }

  else
  {
    read_binary[(signed long int)4] = (unsigned char)0;
    read_binary[(signed long int)5] = (unsigned char)(size >> 8);
    read_binary[(signed long int)6] = (unsigned char)(size & 0x00FF);
    lc = (unsigned short int)7;
  }
  printf("Command: ");
  PrintArray(select_file, (unsigned int)7);
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)2;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)lr, sizeof(unsigned char) /*1ul*/ );
  res = (unsigned char *)return_value_calloc$2;
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)7, select_file, &lr, res);
  void *return_value_calloc$3;
  void *return_value_calloc$4;
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on SELECT FILE: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
    free((void *)res);
    printf("Command: ");
    PrintArray(read_binary, (unsigned int)lc);
    dad = (unsigned char)0;
    sad = (unsigned char)2;
    if(!(size == 0))
    {
      lr = (unsigned short int)(size + 2);
      return_value_calloc$3=calloc((unsigned long int)lr, sizeof(unsigned char) /*1ul*/ );
      res = (unsigned char *)return_value_calloc$3;
    }

    else
    {
      lr = (unsigned short int)(total_size + 2);
      return_value_calloc$4=calloc((unsigned long int)lr, sizeof(unsigned char) /*1ul*/ );
      res = (unsigned char *)return_value_calloc$4;
    }
    if(!(res == ((unsigned char *)NULL)))
    {
      ret=CT_data(ctn, &dad, &sad, lc, read_binary, &lr, res);
      if(!((signed int)ret == 0))
        fprintf(stderr, "Error on READ BINARY: %d\n", ret);

      else
      {
        printf("Response: ");
        PrintArray(res, (unsigned int)lr);
        free((void *)res);
      }
    }

  }
}

// ReadPort
// file tester.c line 501
unsigned short int ReadPort(char *port)
{
  unsigned short int pn;
  scanf("%6s", port);
  signed int return_value_strncasecmp$2;
  return_value_strncasecmp$2=strncasecmp(port, "COM", (unsigned long int)3);
  signed int return_value_strncasecmp$1;
  if(return_value_strncasecmp$2 == 0)
  {
    sscanf(port + (signed long int)3, "%hu", &pn);
    snprintf(port, (unsigned long int)16, "COM%hu", pn);
  }

  else
  {
    return_value_strncasecmp$1=strncasecmp(port, "USB", (unsigned long int)3);
    if(return_value_strncasecmp$1 == 0)
    {
      sscanf(port + (signed long int)3, "%hu", &pn);
      snprintf(port, (unsigned long int)16, "USB%hu", pn);
      pn = pn + (unsigned short int)32768;
    }

    else
    {
      sscanf(port, "%hu", &pn);
      snprintf(port, (unsigned long int)16, "COM%hu", pn);
    }
  }
  return pn;
}

// SelectClass
// file tester.c line 708
void SelectClass(unsigned short int ctn)
{
  unsigned char buffer[32l];
  signed int dummy;
  printf("Class byte (current is %02X): ", ct_list[(signed long int)ctn].cla);
  scanf("%X", (unsigned int *)buffer);
  dummy=getchar();
  pthread_mutex_lock(&ct_list[(signed long int)ctn].mutex);
  ct_list[(signed long int)ctn].cla = buffer[(signed long int)0];
  pthread_mutex_unlock(&ct_list[(signed long int)ctn].mutex);
}

// SelectFile
// file tester.c line 727
void SelectFile(unsigned short int ctn)
{
  unsigned char select_file[8l] = { (unsigned char)0x00, (unsigned char)0xA4, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x3f, (unsigned char)0x00, (unsigned char)0x00 };
  unsigned char buffer[32l];
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  signed int dummy;
  char ret;
  select_file[(signed long int)0] = ct_list[(signed long int)ctn].cla;
  printf("File ID: ");
  scanf("%X %X", (unsigned int *)buffer, (unsigned int *)(buffer + (signed long int)1));
  dummy=getchar();
  select_file[(signed long int)5] = buffer[(signed long int)0];
  select_file[(signed long int)6] = buffer[(signed long int)1];
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)256;
  printf("Command: ");
  PrintArray(select_file, (unsigned int)8);
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)8, select_file, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error in SELECT FILE: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// SendPPS
// file tester.c line 919
void SendPPS(unsigned short int ctn)
{
  unsigned char reset[9l] = { (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x01, (unsigned char)0x01, (unsigned char)0x03, (unsigned char)0xFF, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
  unsigned char buffer[32l];
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  signed int dummy;
  char ret;
  printf("PPS request (PPSS PPS0 PPS1): ");
  scanf("%X %X %X", (unsigned int *)buffer, (unsigned int *)(buffer + (signed long int)1), (unsigned int *)(buffer + (signed long int)2));
  dummy=getchar();
  reset[(signed long int)5] = buffer[(signed long int)0];
  reset[(signed long int)6] = buffer[(signed long int)1];
  reset[(signed long int)7] = buffer[(signed long int)2];
  dad = (unsigned char)0x01;
  sad = (unsigned char)0x02;
  lr = (unsigned short int)256;
  printf("Command: ");
  PrintArray(reset, (unsigned int)8);
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)9, reset, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on Reset CT (Send  PPS): %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// T1_Block_Delete
// file t1_block.h line 103
extern void T1_Block_Delete(struct anonymous$15 *block)
{
  free((void *)block->data);
  free((void *)block);
}

// T1_Block_GetInf
// file t1_block.h line 94
extern unsigned char * T1_Block_GetInf(struct anonymous$15 *block)
{
  if(!(block->length >= 5u))
    return (unsigned char *)(void *)0;

  else
    return block->data + (signed long int)3;
}

// T1_Block_GetLen
// file t1_block.h line 91
extern unsigned char T1_Block_GetLen(struct anonymous$15 *block)
{
  return block->data[(signed long int)2];
}

// T1_Block_GetMore
// file t1_block.h line 85
extern signed int T1_Block_GetMore(struct anonymous$15 *block)
{
  return (signed int)block->data[(signed long int)1] >> 5 & 0x01;
}

// T1_Block_GetNR
// file t1_block.c line 193
extern unsigned char T1_Block_GetNR(struct anonymous$15 *block)
{
  return (unsigned char)((signed int)block->data[(signed long int)1] >> 4 & 0x01);
}

// T1_Block_GetNS
// file t1_block.h line 82
extern unsigned char T1_Block_GetNS(struct anonymous$15 *block)
{
  return (unsigned char)((signed int)block->data[(signed long int)1] >> 6 & 0x01);
}

// T1_Block_GetType
// file t1_block.h line 79
extern unsigned char T1_Block_GetType(struct anonymous$15 *block)
{
  if((0x80 & (signed int)block->data[1l]) == 0x00)
    return (unsigned char)0x00;

  else
    return (unsigned char)((signed int)block->data[(signed long int)1] & 0xEF);
}

// T1_Block_LRC
// file t1_block.c line 237
static unsigned char T1_Block_LRC(unsigned char *data, unsigned int length)
{
  unsigned char lrc;
  unsigned int i;
  lrc = (unsigned char)0x00;
  i = (unsigned int)0;
  for( ; !(i >= length); i = i + 1u)
    lrc = lrc ^ data[(signed long int)i];
  return lrc;
}

// T1_Block_New
// file t1_block.h line 67
extern struct anonymous$15 * T1_Block_New(unsigned char *buffer, unsigned int length)
{
  struct anonymous$15 *block;
  if(!(length >= 4u))
    return (struct anonymous$15 *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$15) /*16ul*/ );
    block = (struct anonymous$15 *)return_value_malloc$1;
    if(!(block == ((struct anonymous$15 *)NULL)))
    {
      block->length = length < (unsigned int)259 ? length : (unsigned int)259;
      void *return_value_calloc$2;
      return_value_calloc$2=calloc((unsigned long int)block->length, sizeof(unsigned char) /*1ul*/ );
      block->data = (unsigned char *)return_value_calloc$2;
      if(!(block->data == ((unsigned char *)NULL)))
        memcpy((void *)block->data, (const void *)buffer, (unsigned long int)block->length);

      else
      {
        free((void *)block);
        block = (struct anonymous$15 *)(void *)0;
      }
    }

    return block;
  }
}

// T1_Block_NewIBlock
// file t1_block.h line 70
extern struct anonymous$15 * T1_Block_NewIBlock(unsigned char len, unsigned char *inf, unsigned char ns, signed int more)
{
  struct anonymous$15 *block;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$15) /*16ul*/ );
  block = (struct anonymous$15 *)return_value_malloc$1;
  if(!(block == ((struct anonymous$15 *)NULL)))
  {
    block->length = (unsigned int)((signed int)len + 4);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)block->length, sizeof(unsigned char) /*1ul*/ );
    block->data = (unsigned char *)return_value_calloc$2;
    if(!(block->data == ((unsigned char *)NULL)))
    {
      block->data[(signed long int)0] = (unsigned char)0x00;
      block->data[(signed long int)1] = (unsigned char)(0x00 | (signed int)ns << 6 & 0x40);
      if(!(more == 0))
        block->data[(signed long int)1] = block->data[(signed long int)1] | (unsigned char)0x20;

      block->data[(signed long int)2] = len;
      if(!((signed int)len == 0x00))
        memcpy((void *)(block->data + (signed long int)3), (const void *)inf, (unsigned long int)len);

      block->data[(signed long int)((signed int)len + 3)]=T1_Block_LRC(block->data, (unsigned int)((signed int)len + 3));
    }

    else
    {
      free((void *)block);
      block = (struct anonymous$15 *)(void *)0;
    }
  }

  return block;
}

// T1_Block_NewRBlock
// file t1_block.h line 73
extern struct anonymous$15 * T1_Block_NewRBlock(unsigned char type, unsigned char nr)
{
  struct anonymous$15 *block;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$15) /*16ul*/ );
  block = (struct anonymous$15 *)return_value_malloc$1;
  if(!(block == ((struct anonymous$15 *)NULL)))
  {
    block->length = (unsigned int)4;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)block->length, sizeof(unsigned char) /*1ul*/ );
    block->data = (unsigned char *)return_value_calloc$2;
    if(!(block->data == ((unsigned char *)NULL)))
    {
      block->data[(signed long int)0] = (unsigned char)0x00;
      block->data[(signed long int)1] = (unsigned char)((signed int)type | (signed int)nr << 4 & 0x10);
      block->data[(signed long int)2] = (unsigned char)0x00;
      block->data[(signed long int)3]=T1_Block_LRC(block->data, (unsigned int)3);
    }

    else
    {
      free((void *)block);
      block = (struct anonymous$15 *)(void *)0;
    }
  }

  return block;
}

// T1_Block_NewSBlock
// file t1_block.h line 76
extern struct anonymous$15 * T1_Block_NewSBlock(unsigned char type, unsigned char len, unsigned char *inf)
{
  struct anonymous$15 *block;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$15) /*16ul*/ );
  block = (struct anonymous$15 *)return_value_malloc$1;
  if(!(block == ((struct anonymous$15 *)NULL)))
  {
    block->length = (unsigned int)(4 + (signed int)len);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)block->length, sizeof(unsigned char) /*1ul*/ );
    block->data = (unsigned char *)return_value_calloc$2;
    if(!(block->data == ((unsigned char *)NULL)))
    {
      block->data[(signed long int)0] = (unsigned char)0x00;
      block->data[(signed long int)1] = type;
      block->data[(signed long int)2] = len;
      if(!((signed int)len == 0x00))
        memcpy((void *)(block->data + (signed long int)3), (const void *)inf, (unsigned long int)len);

      block->data[(signed long int)((signed int)len + 3)]=T1_Block_LRC(block->data, (unsigned int)((signed int)len + 3));
    }

    else
    {
      free((void *)block);
      block = (struct anonymous$15 *)(void *)0;
    }
  }

  return block;
}

// T1_Block_Raw
// file t1_block.h line 97
extern unsigned char * T1_Block_Raw(struct anonymous$15 *block)
{
  return block->data;
}

// T1_Block_RawLen
// file t1_block.h line 100
extern unsigned int T1_Block_RawLen(struct anonymous$15 *block)
{
  return block->length;
}

// TLV_Object_CompareValue
// file tlv_object.h line 93
extern signed int TLV_Object_CompareValue(struct anonymous$23 *tlv, unsigned char *value, unsigned short int *length)
{
  unsigned char *buffer;
  signed int ret;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)*length, sizeof(unsigned char) /*1ul*/ );
  buffer = (unsigned char *)return_value_calloc$1;
  signed int return_value_TLV_Object_GetValue$3;
  return_value_TLV_Object_GetValue$3=TLV_Object_GetValue(tlv, buffer, length);
  signed int return_value_memcmp$2;
  if(!(return_value_TLV_Object_GetValue$3 == 0))
  {
    return_value_memcmp$2=memcmp(value, buffer, *length);
    ret = (signed int)!(return_value_memcmp$2 != 0);
  }

  else
    ret = 0;
  return ret;
}

// TLV_Object_Delete
// file tlv_object.h line 87
extern void TLV_Object_Delete(struct anonymous$23 *tlv)
{
  free((void *)tlv);
}

// TLV_Object_GetAddress
// file tlv_object.h line 103
extern unsigned short int TLV_Object_GetAddress(struct anonymous$23 *tlv)
{
  return tlv->address;
}

// TLV_Object_GetLength
// file tlv_object.c line 159
extern unsigned short int TLV_Object_GetLength(struct anonymous$23 *tlv)
{
  return tlv->length;
}

// TLV_Object_GetObjectBySec
// file tlv_object.c line 251
extern struct anonymous$23 * TLV_Object_GetObjectBySec(struct anonymous$23 *tlv, unsigned short int sec)
{
  struct anonymous$23 *aux;
  unsigned short int i;
  aux=TLV_Object_New(tlv->data, tlv->get_data, tlv->data_length, tlv->value);
  i = (unsigned short int)0;
  for( ; !(aux == ((struct anonymous$23 *)NULL)) && !((signed int)i >= (signed int)sec); i = i + 1)
    if(!((signed int)aux->length + (signed int)aux->value >= (signed int)tlv->length + (signed int)tlv->value))
      TLV_Object_Shift(&aux);

    else
    {
      TLV_Object_Delete(aux);
      aux = (struct anonymous$23 *)(void *)0;
    }
  return aux;
}

// TLV_Object_GetObjectByTag
// file tlv_object.h line 98
extern struct anonymous$23 * TLV_Object_GetObjectByTag(struct anonymous$23 *tlv, unsigned short int tag)
{
  struct anonymous$23 *aux;
  aux=TLV_Object_New(tlv->data, tlv->get_data, tlv->data_length, tlv->value);
  unsigned short int return_value_TLV_Object_GetTag$1;
  while(!(aux == ((struct anonymous$23 *)NULL)))
  {
    return_value_TLV_Object_GetTag$1=TLV_Object_GetTag(aux);
    if(return_value_TLV_Object_GetTag$1 == tag)
      break;

    if(!((signed int)aux->length + (signed int)aux->value >= (signed int)tlv->length + (signed int)tlv->value))
      TLV_Object_Shift(&aux);

    else
    {
      TLV_Object_Delete(aux);
      aux = (struct anonymous$23 *)(void *)0;
    }
  }
  return aux;
}

// TLV_Object_GetRawLength
// file tlv_object.h line 102
extern unsigned short int TLV_Object_GetRawLength(struct anonymous$23 *tlv)
{
  return (unsigned short int)((signed int)tlv->length + ((signed int)tlv->value - (signed int)tlv->address));
}

// TLV_Object_GetTag
// file tlv_object.h line 90
extern unsigned short int TLV_Object_GetTag(struct anonymous$23 *tlv)
{
  return tlv->tag;
}

// TLV_Object_GetValue
// file tlv_object.h line 92
extern signed int TLV_Object_GetValue(struct anonymous$23 *tlv, unsigned char *value, unsigned short int *length)
{
  signed int tmp_if_expr$1;
  if(!((signed int)*length >= (signed int)tlv->length))
    tmp_if_expr$1 = (signed int)*length;

  else
    tmp_if_expr$1 = (signed int)tlv->length;
  *length = (unsigned short int)tmp_if_expr$1;
  if((signed int)*length == 0)
    return 1;

  else
  {
    signed int return_value;
    return_value=tlv->get_data(tlv->data, tlv->value, *length, value);
    return return_value;
  }
}

// TLV_Object_Iterate
// file tlv_object.h line 97
extern signed int TLV_Object_Iterate(struct anonymous$23 *tlv, struct anonymous$23 **iterator)
{
  struct anonymous$23 *next;
  if(*iterator == ((struct anonymous$23 *)NULL))
    next=TLV_Object_New(tlv->data, tlv->get_data, tlv->data_length, tlv->value);

  else
  {
    next = *iterator;
    if(!((signed int)next->length + (signed int)next->value >= (signed int)tlv->length + (signed int)tlv->value))
      TLV_Object_Shift(&next);

    else
    {
      TLV_Object_Delete(next);
      next = (struct anonymous$23 *)(void *)0;
    }
  }
  *iterator = next;
  return (signed int)(*iterator != (struct anonymous$23 *)(void *)0);
}

// TLV_Object_New
// file tlv_object.h line 86
extern struct anonymous$23 * TLV_Object_New(void *data, signed int (*get_data)(void *, unsigned short int, unsigned short int, unsigned char *), unsigned short int data_length, unsigned short int address)
{
  struct anonymous$23 *tlv;
  unsigned char buffer[2l];
  unsigned int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$23) /*32ul*/ );
  tlv = (struct anonymous$23 *)return_value_malloc$1;
  _Bool tmp_if_expr$2;
  signed int return_value;
  _Bool tmp_if_expr$3;
  signed int return_value_1;
  _Bool tmp_if_expr$4;
  signed int return_value_2;
  _Bool tmp_if_expr$5;
  signed int return_value_3;
  _Bool tmp_if_expr$6;
  signed int return_value_4;
  signed int tmp_if_expr$7;
  if(!(tlv == ((struct anonymous$23 *)NULL)))
  {
    tlv->data = data;
    tlv->get_data = get_data;
    tlv->data_length = data_length;
    tlv->address = address;
    i = (unsigned int)0;
    if((signed int)address >= (signed int)data_length)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value=get_data(data, address, (unsigned short int)1, buffer);
      tmp_if_expr$2 = !(return_value != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
    {
      free((void *)tlv);
      return (struct anonymous$23 *)(void *)0;
    }

    if((0x1F & (signed int)buffer[0l]) == 0x1F)
    {
      i = i + 1u;
      if(i + (unsigned int)address >= (unsigned int)data_length)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_1=get_data(data, (unsigned short int)((unsigned int)address + i), (unsigned short int)1, buffer + (signed long int)i);
        tmp_if_expr$3 = !(return_value_1 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
      {
        free((void *)tlv);
        return (struct anonymous$23 *)(void *)0;
      }

      tlv->tag = (unsigned short int)((signed int)buffer[(signed long int)0] << 8 | (signed int)buffer[(signed long int)1]);
    }

    else
      tlv->tag = (unsigned short int)(0x00FF & (signed int)buffer[(signed long int)0]);
    i = i + 1u;
    if(i + (unsigned int)address >= (unsigned int)data_length)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_2=get_data(data, (unsigned short int)((unsigned int)address + i), (unsigned short int)1, buffer);
      tmp_if_expr$4 = !(return_value_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      free((void *)tlv);
      return (struct anonymous$23 *)(void *)0;
    }

    if((0x80 & (signed int)buffer[0l]) == 0x80)
    {
      i = i + 1u;
      if((0x7F & (signed int)buffer[0l]) == 0x01)
      {
        if(i + (unsigned int)address >= (unsigned int)data_length)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_3=get_data(data, (unsigned short int)((unsigned int)address + i), (unsigned short int)1, buffer);
          tmp_if_expr$5 = !(return_value_3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
        {
          free((void *)tlv);
          return (struct anonymous$23 *)(void *)0;
        }

        tlv->length = (unsigned short int)(0x00FF & (signed int)buffer[(signed long int)0]);
        i = i + 1u;
      }

      else
        if((0x7F & (signed int)buffer[0l]) == 0x02)
        {
          if(1u + i + (unsigned int)address >= (unsigned int)data_length)
            tmp_if_expr$6 = (_Bool)1;

          else
          {
            return_value_4=get_data(data, (unsigned short int)((unsigned int)address + i), (unsigned short int)2, buffer);
            tmp_if_expr$6 = !(return_value_4 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$6)
          {
            free((void *)tlv);
            return (struct anonymous$23 *)(void *)0;
          }

          tlv->length = (unsigned short int)((signed int)buffer[(signed long int)0] << 8 | (signed int)buffer[(signed long int)1]);
          i = i + (unsigned int)2;
        }

        else
        {
          free((void *)tlv);
          return (struct anonymous$23 *)(void *)0;
        }
    }

    else
    {
      i = i + 1u;
      tlv->length = (unsigned short int)(0x7F & (signed int)buffer[(signed long int)0]);
    }
    if(i + (unsigned int)address >= (unsigned int)data_length)
    {
      free((void *)tlv);
      return (struct anonymous$23 *)(void *)0;
    }

    tlv->value = (unsigned short int)((unsigned int)address + i);
    if(!((signed int)tlv->length >= (signed int)data_length + -((signed int)tlv->value)))
      tmp_if_expr$7 = (signed int)tlv->length;

    else
      tmp_if_expr$7 = (signed int)data_length - (signed int)tlv->value;
    tlv->length = (unsigned short int)tmp_if_expr$7;
  }

  return tlv;
}

// TLV_Object_Shift
// file tlv_object.h line 96
extern signed int TLV_Object_Shift(struct anonymous$23 **tlv)
{
  struct anonymous$23 *aux;
  aux=TLV_Object_New((*tlv)->data, (*tlv)->get_data, (*tlv)->data_length, (unsigned short int)((signed int)(*tlv)->value + (signed int)(*tlv)->length));
  TLV_Object_Delete(*tlv);
  *tlv = aux;
  return (signed int)(aux != (struct anonymous$23 *)(void *)0);
}

// UpdateBinary
// file tester.c line 805
void UpdateBinary(unsigned short int ctn)
{
  unsigned char update_binary[260l] = { (unsigned char)0x00, (unsigned char)0xD6, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char buffer[32l];
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  signed int size;
  signed int dummy;
  char ret;
  update_binary[(signed long int)0] = ct_list[(signed long int)ctn].cla;
  printf("File size (0..255): ");
  scanf("%d", &size);
  dummy=getchar();
  update_binary[(signed long int)4] = (unsigned char)(size % 256);
  printf("Data: ");
  scanf("%02X", (unsigned int *)buffer);
  dummy=getchar();
  memset((void *)(update_binary + (signed long int)5), (signed int)buffer[(signed long int)0], (unsigned long int)update_binary[(signed long int)4]);
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)256;
  printf("Command: ");
  PrintArray(update_binary, (unsigned int)((signed int)update_binary[(signed long int)4] + 5));
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)((signed int)update_binary[(signed long int)4] + 5), update_binary, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on UPDATE BYNARY: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// VerifyKey
// file tester.c line 888
void VerifyKey(unsigned short int ctn)
{
  unsigned char verify_key[13l] = { (unsigned char)0x00, (unsigned char)0x2A, (unsigned char)0x00, (unsigned char)0x01, (unsigned char)0x08, (unsigned char)0x47, (unsigned char)0x46, (unsigned char)0x58, (unsigned char)0x49, (unsigned char)0x32, (unsigned char)0x56, (unsigned char)0x78, (unsigned char)0x40 };
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  char ret;
  verify_key[(signed long int)0] = ct_list[(signed long int)ctn].cla;
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)256;
  printf("Command: ");
  PrintArray(verify_key, (unsigned int)13);
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)13, verify_key, &lr, res);
  if(!((signed int)ret == 0))
    fprintf(stderr, "Error on VERIFY KEY: %d\n", ret);

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
  }
}

// WriteData
// file tester.c line 1132
void WriteData(unsigned short int ctn)
{
  unsigned char select_file[7l] = { (unsigned char)0x00, (unsigned char)0xA4, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x3F, (unsigned char)0x00 };
  unsigned char *update_binary;
  signed int address;
  signed int size;
  signed int total_size;
  unsigned char buffer[32l];
  unsigned char res[256l];
  unsigned char dad;
  unsigned char sad;
  unsigned short int lr;
  unsigned short int lc;
  signed int dummy;
  char ret;
  printf("Address: ");
  scanf("%d", &address);
  dummy=getchar();
  unsigned int return_value_GetMemoryLength$1;
  return_value_GetMemoryLength$1=GetMemoryLength(ct_list[(signed long int)ctn].atr, (unsigned int)ct_list[(signed long int)ctn].atr_size);
  total_size = (signed int)return_value_GetMemoryLength$1;
  printf("Size (0..%d): ", total_size);
  scanf("%d", &size);
  dummy=getchar();
  printf("Data: ");
  scanf("%X", (unsigned int *)buffer);
  dummy=getchar();
  if(!(size >= 256))
  {
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)(size + 5), sizeof(unsigned char) /*1ul*/ );
    update_binary = (unsigned char *)return_value_calloc$2;
    if(update_binary == ((unsigned char *)NULL))
      goto __CPROVER_DUMP_L7;

    update_binary[(signed long int)0] = (unsigned char)0x00;
    update_binary[(signed long int)1] = (unsigned char)0xD6;
    update_binary[(signed long int)2] = (unsigned char)(address >> 8);
    update_binary[(signed long int)3] = (unsigned char)(address & 0x00FF);
    update_binary[(signed long int)4] = (unsigned char)size;
    memset((void *)(update_binary + (signed long int)5), (signed int)buffer[(signed long int)0], (unsigned long int)size);
    lc = (unsigned short int)(size + 5);
  }

  else
  {
    void *return_value_calloc$3;
    return_value_calloc$3=calloc((unsigned long int)(size + 7), sizeof(unsigned char) /*1ul*/ );
    update_binary = (unsigned char *)return_value_calloc$3;
    if(update_binary == ((unsigned char *)NULL))
      goto __CPROVER_DUMP_L7;

    update_binary[(signed long int)0] = (unsigned char)0x00;
    update_binary[(signed long int)1] = (unsigned char)0xD6;
    update_binary[(signed long int)2] = (unsigned char)(address >> 8);
    update_binary[(signed long int)3] = (unsigned char)(address & 0x00FF);
    update_binary[(signed long int)4] = (unsigned char)0;
    update_binary[(signed long int)5] = (unsigned char)(size >> 8);
    update_binary[(signed long int)6] = (unsigned char)(size & 0x00FF);
    memset((void *)(update_binary + (signed long int)7), (signed int)buffer[(signed long int)0], (unsigned long int)size);
    lc = (unsigned short int)(size + 7);
  }
  printf("Command: ");
  PrintArray(select_file, (unsigned int)7);
  dad = (unsigned char)0;
  sad = (unsigned char)2;
  lr = (unsigned short int)256;
  ret=CT_data(ctn, &dad, &sad, (unsigned short int)7, select_file, &lr, res);
  if(!((signed int)ret == 0))
  {
    fprintf(stderr, "Error on SELECT FILE: %d\n", ret);
    free((void *)update_binary);
  }

  else
  {
    printf("Response: ");
    PrintArray(res, (unsigned int)lr);
    printf("Command: ");
    PrintArray(update_binary, (unsigned int)lc);
    dad = (unsigned char)0;
    sad = (unsigned char)2;
    lr = (unsigned short int)256;
    ret=CT_data(ctn, &dad, &sad, lc, update_binary, &lr, res);
    free((void *)update_binary);
    if(!((signed int)ret == 0))
      fprintf(stderr, "Error on UPDATE BINARY: %d\n", ret);

    else
    {
      printf("Response: ");
      PrintArray(res, (unsigned int)lr);
    }
  }

__CPROVER_DUMP_L7:
  ;
}

// getchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 44
static inline signed int getchar(void)
{
  signed int return_value__IO_getc$1;
  return_value__IO_getc$1=_IO_getc(stdin);
  return return_value__IO_getc$1;
}

// main
// file tester.c line 106
signed int main(signed int argc, char **argv)
{
  unsigned short int ctn = (unsigned short int)0;
  for( ; !((signed int)ctn >= 4); ctn = ctn + 1)
  {
    ct_list[(signed long int)ctn].pn = (unsigned short int)0;
    ct_list[(signed long int)ctn].status = -1;
    ct_list[(signed long int)ctn].cla = (unsigned char)0x00;
    memset((void *)ct_list[(signed long int)ctn].port, 0, (unsigned long int)16);
    memset((void *)ct_list[(signed long int)ctn].atr, 0, (unsigned long int)33);
    ct_list[(signed long int)ctn].atr_size = (unsigned short int)0;
    pthread_mutex_init(&ct_list[(signed long int)ctn].mutex, (const union anonymous$17 *)(void *)0);
  }
  menu_loop();
  ctn = (unsigned short int)0;
  for( ; !((signed int)ctn >= 4); ctn = ctn + 1)
    if(!((signed int)ct_list[(signed long int)ctn].pn == 0))
    {
      Close(ctn);
      pthread_mutex_destroy(&ct_list[(signed long int)ctn].mutex);
    }

  return 0;
}

// menu_loop
// file tester.c line 143
void menu_loop(void)
{
  char option[32l];
  unsigned short int ctn = (unsigned short int)0;
  unsigned short int i;
  signed int dummy;
  signed int tmp_statement_expression$1;
  signed int tmp_if_expr$3;
  const signed int **return_value___ctype_tolower_loc$2;
  const signed int **return_value___ctype_tolower_loc$4;
  signed int tmp_statement_expression$11;
  signed int tmp_statement_expression$9;
  signed int tmp_statement_expression$7;
  signed int tmp_statement_expression$5;
  signed int tmp_statement_expression$25;
  signed int tmp_statement_expression$23;
  signed int tmp_statement_expression$21;
  signed int tmp_statement_expression$19;
  signed int tmp_statement_expression$17;
  signed int tmp_statement_expression$15;
  signed int tmp_statement_expression$13;
  signed int tmp_statement_expression$33;
  signed int tmp_statement_expression$31;
  signed int tmp_statement_expression$29;
  signed int tmp_statement_expression$27;
  while((_Bool)1)
  {
    PrintReport();
    printf("Select option:\n");
    printf("in: Initialize new terminal\n");
    printf("ch: Change current terminal\n");
    printf("cl: Close current terminal\n");
    if(!((signed int)ct_list[(signed long int)ctn].pn == 0))
    {
      if(ct_list[(signed long int)ctn].status == 1)
      {
        printf("sc: Select Class Byte (current: %02X)\n", ct_list[(signed long int)ctn].cla);
        printf("sf: Select File\n");
        printf("gr: Get Response\n");
        printf("vk: Verify Key (Cryptoflex)\n");
        printf("rb: Read Binary\n");
        printf("ub: Update Binary\n");
        printf("pps: Send PPS\n");
      }

      else
        if(ct_list[(signed long int)ctn].status == 0)
        {
          printf("ep: Enter PIN\n");
          printf("cp: Change PIN\n");
          printf("rd: Read Data\n");
          printf("wd: Write Data\n");
        }

    }

    printf("*: Refresh Menu\n");
    printf("q: Quit\n");
    if(!((signed int)ct_list[(signed long int)ctn].pn == 0))
      printf("%s$ ", (const void *)ct_list[(signed long int)ctn].port);

    else
      printf("$ ");
    scanf("%s", (const void *)option);
    dummy=getchar();
    i = (unsigned short int)0;
    for( ; !(option[(signed long int)i] == 0); i = i + 1)
    {
      signed int __res;
      __res=tolower((signed int)option[(signed long int)i]);
      tmp_statement_expression$1 = __res;
      option[(signed long int)i] = (char)tmp_statement_expression$1;
    }
    unsigned long int menu_loop$$1$$1$$3$$__s1_len;
    unsigned long int menu_loop$$1$$1$$3$$__s2_len;
    signed int return_value___builtin_strcmp$12;
    return_value___builtin_strcmp$12=__builtin_strcmp(option, "q");
    tmp_statement_expression$11 = return_value___builtin_strcmp$12;
    if(tmp_statement_expression$11 == 0)
      break;

    else
    {
      unsigned long int menu_loop$$1$$1$$4$$__s1_len;
      unsigned long int menu_loop$$1$$1$$4$$__s2_len;
      signed int return_value___builtin_strcmp$10;
      return_value___builtin_strcmp$10=__builtin_strcmp(option, "in");
      tmp_statement_expression$9 = return_value___builtin_strcmp$10;
      if(tmp_statement_expression$9 == 0)
        Initialize();

      else
      {
        unsigned long int menu_loop$$1$$1$$5$$__s1_len;
        unsigned long int menu_loop$$1$$1$$5$$__s2_len;
        signed int return_value___builtin_strcmp$8;
        return_value___builtin_strcmp$8=__builtin_strcmp(option, "ch");
        tmp_statement_expression$7 = return_value___builtin_strcmp$8;
        if(tmp_statement_expression$7 == 0)
          ctn=Change(ctn);

        else
        {
          unsigned long int menu_loop$$1$$1$$6$$__s1_len;
          unsigned long int menu_loop$$1$$1$$6$$__s2_len;
          signed int return_value___builtin_strcmp$6;
          return_value___builtin_strcmp$6=__builtin_strcmp(option, "cl");
          tmp_statement_expression$5 = return_value___builtin_strcmp$6;
          if(tmp_statement_expression$5 == 0)
            Close(ctn);

        }
      }
    }
    if(ct_list[(signed long int)ctn].status == 1)
    {
      unsigned long int menu_loop$$1$$1$$7$$1$$__s1_len;
      unsigned long int menu_loop$$1$$1$$7$$1$$__s2_len;
      signed int return_value___builtin_strcmp$26;
      return_value___builtin_strcmp$26=__builtin_strcmp(option, "sc");
      tmp_statement_expression$25 = return_value___builtin_strcmp$26;
      if(tmp_statement_expression$25 == 0)
        SelectClass(ctn);

      else
      {
        unsigned long int menu_loop$$1$$1$$7$$2$$__s1_len;
        unsigned long int menu_loop$$1$$1$$7$$2$$__s2_len;
        signed int return_value___builtin_strcmp$24;
        return_value___builtin_strcmp$24=__builtin_strcmp(option, "sf");
        tmp_statement_expression$23 = return_value___builtin_strcmp$24;
        if(tmp_statement_expression$23 == 0)
          SelectFile(ctn);

        else
        {
          unsigned long int menu_loop$$1$$1$$7$$3$$__s1_len;
          unsigned long int menu_loop$$1$$1$$7$$3$$__s2_len;
          signed int return_value___builtin_strcmp$22;
          return_value___builtin_strcmp$22=__builtin_strcmp(option, "gr");
          tmp_statement_expression$21 = return_value___builtin_strcmp$22;
          if(tmp_statement_expression$21 == 0)
            GetResponse(ctn);

          else
          {
            unsigned long int menu_loop$$1$$1$$7$$4$$__s1_len;
            unsigned long int menu_loop$$1$$1$$7$$4$$__s2_len;
            signed int return_value___builtin_strcmp$20;
            return_value___builtin_strcmp$20=__builtin_strcmp(option, "vk");
            tmp_statement_expression$19 = return_value___builtin_strcmp$20;
            if(tmp_statement_expression$19 == 0)
              VerifyKey(ctn);

            else
            {
              unsigned long int menu_loop$$1$$1$$7$$5$$__s1_len;
              unsigned long int menu_loop$$1$$1$$7$$5$$__s2_len;
              signed int return_value___builtin_strcmp$18;
              return_value___builtin_strcmp$18=__builtin_strcmp(option, "rb");
              tmp_statement_expression$17 = return_value___builtin_strcmp$18;
              if(tmp_statement_expression$17 == 0)
                ReadBinary(ctn);

              else
              {
                unsigned long int menu_loop$$1$$1$$7$$6$$__s1_len;
                unsigned long int menu_loop$$1$$1$$7$$6$$__s2_len;
                signed int return_value___builtin_strcmp$16;
                return_value___builtin_strcmp$16=__builtin_strcmp(option, "ub");
                tmp_statement_expression$15 = return_value___builtin_strcmp$16;
                if(tmp_statement_expression$15 == 0)
                  UpdateBinary(ctn);

                else
                {
                  unsigned long int menu_loop$$1$$1$$7$$7$$__s1_len;
                  unsigned long int menu_loop$$1$$1$$7$$7$$__s2_len;
                  signed int return_value___builtin_strcmp$14;
                  return_value___builtin_strcmp$14=__builtin_strcmp(option, "pps");
                  tmp_statement_expression$13 = return_value___builtin_strcmp$14;
                  if(tmp_statement_expression$13 == 0)
                    SendPPS(ctn);

                }
              }
            }
          }
        }
      }
    }

    else
      if(ct_list[(signed long int)ctn].status == 0)
      {
        unsigned long int menu_loop$$1$$1$$8$$1$$__s1_len;
        unsigned long int menu_loop$$1$$1$$8$$1$$__s2_len;
        signed int return_value___builtin_strcmp$34;
        return_value___builtin_strcmp$34=__builtin_strcmp(option, "ep");
        tmp_statement_expression$33 = return_value___builtin_strcmp$34;
        if(tmp_statement_expression$33 == 0)
          EnterPin(ctn);

        else
        {
          unsigned long int menu_loop$$1$$1$$8$$2$$__s1_len;
          unsigned long int menu_loop$$1$$1$$8$$2$$__s2_len;
          signed int return_value___builtin_strcmp$32;
          return_value___builtin_strcmp$32=__builtin_strcmp(option, "cp");
          tmp_statement_expression$31 = return_value___builtin_strcmp$32;
          if(tmp_statement_expression$31 == 0)
            ChangePin(ctn);

          else
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$30;
            return_value___builtin_strcmp$30=__builtin_strcmp(option, "rd");
            tmp_statement_expression$29 = return_value___builtin_strcmp$30;
            if(tmp_statement_expression$29 == 0)
              ReadData(ctn);

            else
            {
              unsigned long int menu_loop$$1$$1$$8$$4$$__s1_len;
              unsigned long int menu_loop$$1$$1$$8$$4$$__s2_len;
              signed int return_value___builtin_strcmp$28;
              return_value___builtin_strcmp$28=__builtin_strcmp(option, "wd");
              tmp_statement_expression$27 = return_value___builtin_strcmp$28;
              if(tmp_statement_expression$27 == 0)
                WriteData(ctn);

            }
          }
        }
      }

  }
}

// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_tolower_loc$1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_tolower_loc$1=__ctype_tolower_loc();
    tmp_if_expr$2 = (*return_value___ctype_tolower_loc$1)[(signed long int)__c];
  }

  else
    tmp_if_expr$2 = __c;
  return tmp_if_expr$2;
}

