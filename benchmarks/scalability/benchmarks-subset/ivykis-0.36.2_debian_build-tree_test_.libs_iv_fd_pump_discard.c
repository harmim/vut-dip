// tag-#anon#ST[*{SYM#tag-pollfd#}$SYM#tag-pollfd#$'pfds'||*{*{SYM#tag-iv_fd_#}$SYM#tag-iv_fd_#$}$*{SYM#tag-iv_fd_#}$SYM#tag-iv_fd_#$$'fds'||S32'num_regd_fds'||U32'$pad0'|]
// file ../../../src/iv_private.h line 86
struct anonymous$29;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$27;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$24;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$17;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous$34;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous$33;

// tag-#anon#ST[BF{U32}$U32$'__w_stopval'||BF{U32}$U32$'__w_stopsig'||BF{U32}$U32$'$anon0'|]
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 84
struct anonymous$40;

// tag-#anon#ST[BF{U32}$U32$'__w_termsig'||BF{U32}$U32$'__w_coredump'||BF{U32}$U32$'__w_retcode'||BF{U32}$U32$'$anon0'|]
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 69
struct anonymous$39;

// tag-#anon#ST[S32'epoll_fd'||U32'$pad0'||SYM#tag-iv_list_head#'notify'|]
// file ../../../src/iv_private.h line 73
struct anonymous$28;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$20;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$23;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$22;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$18;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$21;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$25;

// tag-#anon#UN[*{SYM#tag-wait#}$SYM#tag-wait#$'__uptr'||*{S32}$S32$'__iptr'|]
// file /usr/include/stdlib.h line 67
union anonymous$41;

// tag-#anon#UN[*{SYM#tag-wait#}$SYM#tag-wait#$'__uptr'||*{S32}$S32$'__iptr'|]$transparent
// file /usr/include/stdlib.h line 67
union anonymous$0;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$19;

// tag-#anon#UN[ARR0{U8}$U8$'buf'||ARR2{S32}$S32$'pfd'|]
// file ../../../src/iv_fd_pump.c line 84
union anonymous$1;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$32;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$26;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$37;

// tag-#anon#UN[S32'index'|]
// file ../../../src/iv_fd_private.h line 80
union anonymous$31;

// tag-#anon#UN[S64'ru_idrss'||S64'__ru_idrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 208
union anonymous$4;

// tag-#anon#UN[S64'ru_inblock'||S64'__ru_inblock_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 240
union anonymous$9;

// tag-#anon#UN[S64'ru_isrss'||S64'__ru_isrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 214
union anonymous$5;

// tag-#anon#UN[S64'ru_ixrss'||S64'__ru_ixrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 202
union anonymous$3;

// tag-#anon#UN[S64'ru_majflt'||S64'__ru_majflt_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 227
union anonymous$7;

// tag-#anon#UN[S64'ru_maxrss'||S64'__ru_maxrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 194
union anonymous$2;

// tag-#anon#UN[S64'ru_minflt'||S64'__ru_minflt_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 221
union anonymous$6;

// tag-#anon#UN[S64'ru_msgrcv'||S64'__ru_msgrcv_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 258
union anonymous$12;

// tag-#anon#UN[S64'ru_msgsnd'||S64'__ru_msgsnd_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 252
union anonymous$11;

// tag-#anon#UN[S64'ru_nivcsw'||S64'__ru_nivcsw_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 279
union anonymous$15;

// tag-#anon#UN[S64'ru_nsignals'||S64'__ru_nsignals_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 264
union anonymous$13;

// tag-#anon#UN[S64'ru_nswap'||S64'__ru_nswap_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 233
union anonymous$8;

// tag-#anon#UN[S64'ru_nvcsw'||S64'__ru_nvcsw_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 272
union anonymous$14;

// tag-#anon#UN[S64'ru_oublock'||S64'__ru_oublock_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 246
union anonymous$10;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'epoll_fd'||U32'$pad0'||SYM#tag-iv_list_head#'notify'|]#'epoll'||SYM#tag-#anon#ST[*{SYM#tag-pollfd#}$SYM#tag-pollfd#$'pfds'||*{*{SYM#tag-iv_fd_#}$SYM#tag-iv_fd_#$}$*{SYM#tag-iv_fd_#}$SYM#tag-iv_fd_#$$'fds'||S32'num_regd_fds'||U32'$pad0'|]#'poll'|]
// file ../../../src/iv_private.h line 63
union anonymous$30;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$38;

// tag-#anon#UN[SYM#tag-iv_event_raw#'ier'||*{SYM#tag-iv_state#}$SYM#tag-iv_state#$'st'|]
// file ../../../src/iv_event.c line 33
union anonymous$36;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$35;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-connection
// file ../../../test/iv_fd_pump_discard.c line 30
struct connection;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-inotify_event
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 28
struct inotify_event;

// tag-iv_avl_node
// file ../../../src/include/iv_avl.h line 30
struct iv_avl_node;

// tag-iv_avl_tree
// file ../../../src/include/iv_avl.h line 37
struct iv_avl_tree;

// tag-iv_event
// file ../../../src/include/iv_event.h line 31
struct iv_event;

// tag-iv_event_raw
// file ../../../src/include/iv_event_raw.h line 30
struct iv_event_raw;

// tag-iv_event_thr_info
// file ../../../src/iv_event.c line 31
struct iv_event_thr_info;

// tag-iv_fd
// file ../src/include/iv.h line 66
struct iv_fd;

// tag-iv_fd_
// file ../../../src/iv_private.h line 37
struct iv_fd_;

// tag-iv_fd_poll_method
// file ../../../src/iv_fd_private.h line 88
struct iv_fd_poll_method;

// tag-iv_fd_pump
// file ../../../src/include/iv_fd_pump.h line 28
struct iv_fd_pump;

// tag-iv_fd_pump_buf
// file ../../../src/iv_fd_pump.c line 82
struct iv_fd_pump_buf;

// tag-iv_fd_pump_thr_info
// file ../../../src/iv_fd_pump.c line 33
struct iv_fd_pump_thr_info;

// tag-iv_inotify
// file ../../../src/include/iv_inotify.h line 33
struct iv_inotify;

// tag-iv_inotify_watch
// file ../../../src/include/iv_inotify.h line 49
struct iv_inotify_watch;

// tag-iv_list_head
// file ../../../src/include/iv_list.h line 35
struct iv_list_head;

// tag-iv_popen_request
// file ../../../src/include/iv_popen.h line 28
struct iv_popen_request;

// tag-iv_popen_running_child
// file ../../../src/iv_popen.c line 38
struct iv_popen_running_child;

// tag-iv_popen_spawn_info
// file ../../../src/iv_popen.c line 62
struct iv_popen_spawn_info;

// tag-iv_signal
// file ../../../src/include/iv_signal.h line 33
struct iv_signal;

// tag-iv_state
// file ../../../src/iv_private.h line 29
struct iv_state;

// tag-iv_task
// file ../src/include/iv.h line 109
struct iv_task;

// tag-iv_task_
// file ../../../src/iv_private.h line 133
struct iv_task_;

// tag-iv_thread
// file ../../../src/iv_thread_posix.c line 73
struct iv_thread;

// tag-iv_thread_thr_info
// file ../../../src/iv_thread_posix.c line 87
struct iv_thread_thr_info;

// tag-iv_timer
// file ../src/include/iv.h line 124
struct iv_timer;

// tag-iv_timer_
// file ../../../src/iv_private.h line 146
struct iv_timer_;

// tag-iv_tls_user
// file ../../../src/include/iv_tls.h line 30
struct iv_tls_user;

// tag-iv_wait_interest
// file ../../../src/include/iv_wait.h line 34
struct iv_wait_interest;

// tag-iv_wait_thr_info
// file ../../../src/iv_wait.c line 169
struct iv_wait_thr_info;

// tag-iv_work_item
// file ../../../src/include/iv_work.h line 40
struct iv_work_item;

// tag-iv_work_pool
// file ../../../src/include/iv_work.h line 31
struct iv_work_pool;

// tag-iv_work_thr_info
// file ../../../src/iv_work.c line 349
struct iv_work_thr_info;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-ratnode
// file ../../../src/iv_private.h line 59
struct ratnode;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rusage
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 187
struct rusage;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-wait
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 66
union wait;

// tag-wait_event
// file ../../../src/iv_wait.c line 38
struct wait_event;

// tag-work_pool_priv
// file ../../../src/iv_work.c line 34
struct work_pool_priv;

// tag-work_pool_thread
// file ../../../src/iv_work.c line 49
struct work_pool_thread;

#ifndef NULL
#define NULL ((void*)0)
#endif

// IV_EVENT_INIT
// file ../../../src/include/iv_event.h line 39
static inline void IV_EVENT_INIT(struct iv_event *this);
// IV_EVENT_INIT$link1
// file ../../../src/include/iv_event.h line 39
static inline void IV_EVENT_INIT$link1(struct iv_event *this$link1);
// IV_EVENT_INIT$link2
// file ../../../src/include/iv_event.h line 39
static inline void IV_EVENT_INIT$link2(struct iv_event *this$link2);
// IV_EVENT_RAW_INIT
// file ../../../src/include/iv_event_raw.h line 42
static inline void IV_EVENT_RAW_INIT(struct iv_event_raw *this);
// IV_EVENT_RAW_INIT$link1
// file ../../../src/include/iv_event_raw.h line 42
static inline void IV_EVENT_RAW_INIT$link1(struct iv_event_raw *this$link1);
// IV_FD_INIT
// file ../src/include/iv.h line 76
void IV_FD_INIT(struct iv_fd *_fd);
// IV_FD_PUMP_INIT
// file ../../../src/include/iv_fd_pump.h line 41
static inline void IV_FD_PUMP_INIT(struct iv_fd_pump *this);
// IV_SIGNAL_INIT
// file ../../../src/include/iv_signal.h line 44
static inline void IV_SIGNAL_INIT(struct iv_signal *this);
// IV_TASK_INIT
// file ../../../src/iv_task.c line 52
void IV_TASK_INIT(struct iv_task *_t);
// IV_TIMER_INIT
// file ../../../src/iv_timer.c line 194
void IV_TIMER_INIT(struct iv_timer *_t);
// IV_WAIT_INTEREST_INIT
// file ../../../src/include/iv_wait.h line 47
static inline void IV_WAIT_INTEREST_INIT(struct iv_wait_interest *this);
// __buf_dequeue
// file ../../../src/iv_fd_pump.c line 172
static struct iv_fd_pump_buf * __buf_dequeue(struct iv_fd_pump_thr_info *tinfo);
// __buf_free
// file ../../../src/iv_fd_pump.c line 110
static void __buf_free(struct iv_fd_pump_buf *buf);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __find_watch
// file ../../../src/iv_inotify.c line 32
static struct iv_inotify_watch * __find_watch(struct iv_inotify *this, signed int wd);
// __iv_deinit
// file ../../../src/iv_main_posix.c line 32
static void __iv_deinit(struct iv_state *st);
// __iv_event_run_pending_events
// file ../../../src/iv_event.c line 43
static void __iv_event_run_pending_events(void *_tinfo);
// __iv_fd_epoll_flush_one
// file ../../../src/iv_fd_epoll.c line 69
static signed int __iv_fd_epoll_flush_one(struct iv_state *st, struct iv_fd_ *fd);
// __iv_fd_pump_pump
// file ../../../src/iv_fd_pump.c line 329
static signed int __iv_fd_pump_pump(struct iv_fd_pump *ip);
// __iv_inotify_watch_compare
// file ../../../src/iv_inotify.c line 103
static signed int __iv_inotify_watch_compare(struct iv_avl_node *_a, struct iv_avl_node *_b);
// __iv_invalidate_now
// file ../../../src/iv_timer.c line 29
void __iv_invalidate_now(struct iv_state *st);
// __iv_list_steal_elements
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements(struct iv_list_head *oldh, struct iv_list_head *newh);
// __iv_list_steal_elements$link1
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements$link1(struct iv_list_head *oldh$link1, struct iv_list_head *newh$link1);
// __iv_list_steal_elements$link2
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements$link2(struct iv_list_head *oldh$link2, struct iv_list_head *newh$link2);
// __iv_list_steal_elements$link3
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements$link3(struct iv_list_head *oldh$link3, struct iv_list_head *newh$link3);
// __iv_now_location
// file ../../../src/iv_timer.c line 51
struct timespec * __iv_now_location(void);
// __iv_signal_do_wake
// file ../../../src/iv_signal.c line 132
static void __iv_signal_do_wake(signed int signum);
// __iv_signal_find_first
// file ../../../src/iv_signal.c line 111
static struct iv_avl_node * __iv_signal_find_first(signed int signum);
// __iv_wait_interest_find
// file ../../../src/iv_wait.c line 66
static struct iv_wait_interest * __iv_wait_interest_find(signed int pid);
// __iv_wait_interest_register
// file ../../../src/iv_wait.c line 234
static void __iv_wait_interest_register(struct iv_wait_thr_info *tinfo, struct iv_wait_interest *this);
// __iv_wait_interest_unregister
// file ../../../src/iv_wait.c line 263
static void __iv_wait_interest_unregister(struct iv_wait_thr_info *tinfo, struct iv_wait_interest *this);
// __iv_work_thread_die
// file ../../../src/iv_work.c line 78
static void __iv_work_thread_die(struct work_pool_thread *thr);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$34 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$34 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$34 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous, unsigned int *);
// balance
// file ../../../src/iv_avl.c line 192
static signed int balance(struct iv_avl_node *an);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous, unsigned int);
// bits_to_poll_mask
// file ../../../src/iv_fd_poll.c line 92
static signed int bits_to_poll_mask(signed int bits);
// bits_to_poll_mask$link1
// file ../../../src/iv_fd_epoll.c line 56
static signed int bits_to_poll_mask$link1(signed int bits$link1);
// buf_alloc
// file ../../../src/iv_fd_pump.c line 90
static struct iv_fd_pump_buf * buf_alloc(void);
// buf_get
// file ../../../src/iv_fd_pump.c line 188
static struct iv_fd_pump_buf * buf_get(void);
// buf_purge
// file ../../../src/iv_fd_pump.c line 201
static void buf_purge(struct iv_fd_pump_thr_info *tinfo);
// buf_put
// file ../../../src/iv_fd_pump.c line 119
static void buf_put(struct iv_fd_pump_buf *buf, signed int bytes);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_splice_available
// file ../../../src/iv_fd_pump.c line 137
static void check_splice_available(void);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// conn_pump
// file ../../../test/iv_fd_pump_discard.c line 38
static void conn_pump(void *_conn);
// conn_set_bands
// file ../../../test/iv_fd_pump_discard.c line 52
static void conn_set_bands(void *_conn, signed int pollin, signed int pollout);
// consider_poll_method
// file ../../../src/iv_fd.c line 81
static void consider_poll_method(struct iv_state *st, char *exclude, struct iv_fd_poll_method *m);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_create1
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 104
extern signed int epoll_create1(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// event_rx_off
// file ../../../src/iv_event_private.h line 32
static inline void event_rx_off(struct iv_state *st);
// event_rx_on
// file ../../../src/iv_event_private.h line 24
static inline signed int event_rx_on(struct iv_state *st);
// event_send
// file ../../../src/iv_event_private.h line 37
static inline void event_send(struct iv_state *dest);
// eventfd
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 34
extern signed int eventfd(unsigned int, signed int);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fatal_msg_handler$object
// 
void fatal_msg_handler$object(const char *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// find_reference
// file ../../../src/iv_avl.c line 220
static struct iv_avl_node ** find_reference(struct iv_avl_tree *tree, struct iv_avl_node *an);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_ratnode
// file ../../../src/iv_timer.c line 153
static void free_ratnode(struct ratnode *node, signed int depth);
// get_thread_id
// file ../../../src/iv_thread_posix.c line 47
static unsigned long int get_thread_id(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// got_connection
// file ../../../test/iv_fd_pump_discard.c line 64
static void got_connection(void *_dummy);
// grab_eventfd
// file ../../../src/iv_event_raw_posix.c line 40
static signed int grab_eventfd(void);
// height
// file ../../../src/iv_avl.c line 25
static signed int height(struct iv_avl_node *an);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inotify_add_watch
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 91
extern signed int inotify_add_watch(signed int, const char *, unsigned int);
// inotify_init
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 84
extern signed int inotify_init(void);
// inotify_rm_watch
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 95
extern signed int inotify_rm_watch(signed int, signed int);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// iv_avl_tree_delete
// file ../../../src/iv_avl.c line 384
void iv_avl_tree_delete(struct iv_avl_tree *tree, struct iv_avl_node *an);
// iv_avl_tree_delete_leaf
// file ../../../src/iv_avl.c line 307
static struct iv_avl_node * iv_avl_tree_delete_leaf(struct iv_avl_tree *tree, struct iv_avl_node *an);
// iv_avl_tree_delete_nonleaf
// file ../../../src/iv_avl.c line 319
static struct iv_avl_node * iv_avl_tree_delete_nonleaf(struct iv_avl_tree *tree, struct iv_avl_node *an);
// iv_avl_tree_insert
// file ../../../src/iv_avl.c line 265
signed int iv_avl_tree_insert(struct iv_avl_tree *tree, struct iv_avl_node *an);
// iv_avl_tree_next
// file ../../../src/iv_avl.c line 396
struct iv_avl_node * iv_avl_tree_next(struct iv_avl_node *an);
// iv_avl_tree_prev
// file ../../../src/iv_avl.c line 417
struct iv_avl_node * iv_avl_tree_prev(struct iv_avl_node *an);
// iv_deinit
// file ../src/include/iv.h line 46
void iv_deinit(void);
// iv_event_post
// file ../../../src/iv_event.c line 156
void iv_event_post(struct iv_event *this);
// iv_event_raw_got_event
// file ../../../src/iv_event_raw_posix.c line 64
static void iv_event_raw_got_event(void *_this);
// iv_event_raw_post
// file ../../../src/include/iv_event_raw.h line 48
void iv_event_raw_post(struct iv_event_raw *this);
// iv_event_raw_register
// file ../../../src/include/iv_event_raw.h line 46
signed int iv_event_raw_register(struct iv_event_raw *this);
// iv_event_raw_unregister
// file ../../../src/include/iv_event_raw.h line 47
void iv_event_raw_unregister(struct iv_event_raw *this);
// iv_event_register
// file ../../../src/iv_event.c line 104
signed int iv_event_register(struct iv_event *this);
// iv_event_run_pending_events
// file ../../../src/iv_event.c line 99
void iv_event_run_pending_events(void);
// iv_event_tls_deinit_thread
// file ../../../src/iv_event.c line 80
static void iv_event_tls_deinit_thread(void *_tinfo);
// iv_event_tls_init_thread
// file ../../../src/iv_event.c line 65
static void iv_event_tls_init_thread(void *_tinfo);
// iv_event_unregister
// file ../../../src/iv_event.c line 136
void iv_event_unregister(struct iv_event *this);
// iv_fatal
// file ../../../src/iv_fatal.c line 41
void iv_fatal(const char *fmt, ...);
// iv_fatal_default_handler
// file ../../../src/iv_fatal.c line 28
static void iv_fatal_default_handler(const char *msg);
// iv_fd_deinit
// file ../../../src/iv_fd.c line 135
void iv_fd_deinit(struct iv_state *st);
// iv_fd_epoll_deinit
// file ../../../src/iv_fd_epoll.c line 176
static void iv_fd_epoll_deinit(struct iv_state *st);
// iv_fd_epoll_flush_one
// file ../../../src/iv_fd_epoll.c line 99
static void iv_fd_epoll_flush_one(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_epoll_flush_pending
// file ../../../src/iv_fd_epoll.c line 107
static void iv_fd_epoll_flush_pending(struct iv_state *st);
// iv_fd_epoll_init
// file ../../../src/iv_fd_epoll.c line 29
static signed int iv_fd_epoll_init(struct iv_state *st);
// iv_fd_epoll_notify_fd
// file ../../../src/iv_fd_epoll.c line 164
static void iv_fd_epoll_notify_fd(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_epoll_notify_fd_sync
// file ../../../src/iv_fd_epoll.c line 171
static signed int iv_fd_epoll_notify_fd_sync(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_epoll_poll
// file ../../../src/iv_fd_epoll.c line 119
static void iv_fd_epoll_poll(struct iv_state *st, struct iv_list_head *active, struct timespec *to);
// iv_fd_epoll_unregister_fd
// file ../../../src/iv_fd_epoll.c line 158
static void iv_fd_epoll_unregister_fd(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_init
// file ../../../src/iv_fd.c line 124
void iv_fd_init(struct iv_state *st);
// iv_fd_init_first_thread
// file ../../../src/iv_fd.c line 90
static void iv_fd_init_first_thread(struct iv_state *st);
// iv_fd_make_ready
// file ../../../src/iv_fd.c line 171
void iv_fd_make_ready(struct iv_list_head *active, struct iv_fd_ *fd, signed int bands);
// iv_fd_poll_and_run
// file ../../../src/iv_fd.c line 140
void iv_fd_poll_and_run(struct iv_state *st, struct timespec *to);
// iv_fd_poll_deinit
// file ../../../src/iv_fd_poll.c line 160
static void iv_fd_poll_deinit(struct iv_state *st);
// iv_fd_poll_init
// file ../../../src/iv_fd_poll.c line 28
static signed int iv_fd_poll_init(struct iv_state *st);
// iv_fd_poll_notify_fd
// file ../../../src/iv_fd_poll.c line 107
static void iv_fd_poll_notify_fd(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_poll_notify_fd_sync
// file ../../../src/iv_fd_poll.c line 140
static signed int iv_fd_poll_notify_fd_sync(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_poll_poll
// file ../../../src/iv_fd_poll.c line 45
static void iv_fd_poll_poll(struct iv_state *st, struct iv_list_head *active, struct timespec *to);
// iv_fd_poll_register_fd
// file ../../../src/iv_fd_poll.c line 87
static void iv_fd_poll_register_fd(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_pump_buf
// file ../../../src/iv_fd_pump.c line 211
static struct iv_fd_pump_buf * iv_fd_pump_buf(struct iv_fd_pump *ip);
// iv_fd_pump_destroy
// file ../../../src/include/iv_fd_pump.h line 48
void iv_fd_pump_destroy(struct iv_fd_pump *ip);
// iv_fd_pump_init
// file ../../../src/include/iv_fd_pump.h line 47
void iv_fd_pump_init(struct iv_fd_pump *ip);
// iv_fd_pump_is_done
// file ../../../src/iv_fd_pump.c line 376
signed int iv_fd_pump_is_done(struct iv_fd_pump *ip);
// iv_fd_pump_pump
// file ../../../src/include/iv_fd_pump.h line 49
signed int iv_fd_pump_pump(struct iv_fd_pump *ip);
// iv_fd_pump_tls_deinit_thread
// file ../../../src/iv_fd_pump.c line 48
static void iv_fd_pump_tls_deinit_thread(void *_tinfo);
// iv_fd_pump_tls_init_thread
// file ../../../src/iv_fd_pump.c line 40
static void iv_fd_pump_tls_init_thread(void *_tinfo);
// iv_fd_pump_try_input
// file ../../../src/iv_fd_pump.c line 242
static signed int iv_fd_pump_try_input(struct iv_fd_pump *ip);
// iv_fd_pump_try_output
// file ../../../src/iv_fd_pump.c line 297
static signed int iv_fd_pump_try_output(struct iv_fd_pump *ip);
// iv_fd_register
// file ../src/include/iv.h line 77
void iv_fd_register(struct iv_fd *_fd);
// iv_fd_register_epilogue
// file ../../../src/iv_fd.c line 269
static void iv_fd_register_epilogue(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_register_prologue
// file ../../../src/iv_fd.c line 244
static void iv_fd_register_prologue(struct iv_state *st, struct iv_fd_ *fd);
// iv_fd_register_try
// file ../../../src/iv_fd.c line 295
signed int iv_fd_register_try(struct iv_fd *_fd);
// iv_fd_registered
// file ../../../src/iv_fd.c line 352
signed int iv_fd_registered(struct iv_fd *_fd);
// iv_fd_set_cloexec
// file ../../../src/iv_fd_private.h line 118
void iv_fd_set_cloexec(signed int fd);
// iv_fd_set_handler_err
// file ../../../src/iv_fd.c line 387
void iv_fd_set_handler_err(struct iv_fd *_fd, void (*handler_err)(void *));
// iv_fd_set_handler_err::handler_err$object
// 
void handler_err$object(void *);
// iv_fd_set_handler_in
// file ../src/include/iv.h line 81
void iv_fd_set_handler_in(struct iv_fd *_fd, void (*handler_in)(void *));
// iv_fd_set_handler_in::handler_in$object
// 
void handler_in$object(void *);
// iv_fd_set_handler_out
// file ../../../src/iv_fd.c line 373
void iv_fd_set_handler_out(struct iv_fd *_fd, void (*handler_out)(void *));
// iv_fd_set_handler_out::handler_out$object
// 
void handler_out$object(void *);
// iv_fd_set_nonblock
// file ../../../src/iv_fd_private.h line 119
void iv_fd_set_nonblock(signed int fd);
// iv_fd_unregister
// file ../src/include/iv.h line 79
void iv_fd_unregister(struct iv_fd *_fd);
// iv_get_soonest_timeout
// file ../../../src/iv_timer.c line 107
signed int iv_get_soonest_timeout(struct iv_state *st, struct timespec *to);
// iv_get_state
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state(void);
// iv_get_state$link1
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link1(void);
// iv_get_state$link2
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link2(void);
// iv_get_state$link3
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link3(void);
// iv_get_state$link4
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link4(void);
// iv_get_state$link5
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link5(void);
// iv_init
// file ../src/include/iv.h line 42
void iv_init(void);
// iv_inited
// file ../../../src/iv_main_posix.c line 81
signed int iv_inited(void);
// iv_inotify_got_event
// file ../../../src/iv_inotify.c line 53
static void iv_inotify_got_event(void *_this);
// iv_inotify_register
// file ../../../src/iv_inotify.c line 119
signed int iv_inotify_register(struct iv_inotify *this);
// iv_inotify_unregister
// file ../../../src/iv_inotify.c line 138
void iv_inotify_unregister(struct iv_inotify *this);
// iv_inotify_watch_register
// file ../../../src/iv_inotify.c line 147
signed int iv_inotify_watch_register(struct iv_inotify_watch *w);
// iv_inotify_watch_unregister
// file ../../../src/iv_inotify.c line 158
void iv_inotify_watch_unregister(struct iv_inotify_watch *w);
// iv_invalidate_now
// file ../../../src/iv_timer.c line 34
void iv_invalidate_now(void);
// iv_list_add
// file ../../../src/include/iv_list.h line 48
static inline void iv_list_add(struct iv_list_head *ilh, struct iv_list_head *head);
// iv_list_add$link1
// file ../../../src/include/iv_list.h line 48
static inline void iv_list_add$link1(struct iv_list_head *ilh$link1, struct iv_list_head *head$link1);
// iv_list_add_tail
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail(struct iv_list_head *ilh, struct iv_list_head *head);
// iv_list_add_tail$link1
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link1(struct iv_list_head *ilh$link1, struct iv_list_head *head$link1);
// iv_list_add_tail$link2
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link2(struct iv_list_head *ilh$link2, struct iv_list_head *head$link2);
// iv_list_add_tail$link3
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link3(struct iv_list_head *ilh$link3, struct iv_list_head *head$link3);
// iv_list_add_tail$link4
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link4(struct iv_list_head *ilh$link4, struct iv_list_head *head$link4);
// iv_list_add_tail$link5
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link5(struct iv_list_head *ilh$link5, struct iv_list_head *head$link5);
// iv_list_add_tail$link6
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link6(struct iv_list_head *ilh$link6, struct iv_list_head *head$link6);
// iv_list_add_tail$link7
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link7(struct iv_list_head *ilh$link7, struct iv_list_head *head$link7);
// iv_list_del
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del(struct iv_list_head *ilh);
// iv_list_del$link1
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link1(struct iv_list_head *ilh$link1);
// iv_list_del$link2
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link2(struct iv_list_head *ilh$link2);
// iv_list_del$link3
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link3(struct iv_list_head *ilh$link3);
// iv_list_del$link4
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link4(struct iv_list_head *ilh$link4);
// iv_list_del$link5
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link5(struct iv_list_head *ilh$link5);
// iv_list_del_init
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init(struct iv_list_head *ilh);
// iv_list_del_init$link1
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link1(struct iv_list_head *ilh$link1);
// iv_list_del_init$link2
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link2(struct iv_list_head *ilh$link2);
// iv_list_del_init$link3
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link3(struct iv_list_head *ilh$link3);
// iv_list_del_init$link4
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link4(struct iv_list_head *ilh$link4);
// iv_list_empty
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty(struct iv_list_head *head);
// iv_list_empty$link1
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link1(struct iv_list_head *head$link1);
// iv_list_empty$link2
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link2(struct iv_list_head *head$link2);
// iv_list_empty$link3
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link3(struct iv_list_head *head$link3);
// iv_list_empty$link4
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link4(struct iv_list_head *head$link4);
// iv_list_empty$link5
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link5(struct iv_list_head *head$link5);
// iv_list_empty$link6
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link6(struct iv_list_head *head$link6);
// iv_main
// file ../src/include/iv.h line 44
void iv_main(void);
// iv_pending_tasks
// file ../../../src/iv_task.c line 30
signed int iv_pending_tasks(struct iv_state *st);
// iv_poll_method_name
// file ../../../src/iv_fd.c line 204
const char * iv_poll_method_name(void);
// iv_popen_child
// file ../../../src/iv_popen.c line 68
static void iv_popen_child(void *cookie);
// iv_popen_request_close
// file ../../../src/iv_popen.c line 181
void iv_popen_request_close(struct iv_popen_request *this);
// iv_popen_request_submit
// file ../../../src/iv_popen.c line 97
signed int iv_popen_request_submit(struct iv_popen_request *this);
// iv_popen_running_child_timer
// file ../../../src/iv_popen.c line 160
static void iv_popen_running_child_timer(void *_ch);
// iv_popen_running_child_wait
// file ../../../src/iv_popen.c line 46
static void iv_popen_running_child_wait(void *_ch, signed int status, struct rusage *rusage);
// iv_quit
// file ../../../src/iv_main_posix.c line 91
void iv_quit(void);
// iv_run_tasks
// file ../../../src/iv_task.c line 35
void iv_run_tasks(struct iv_state *st);
// iv_run_timers
// file ../../../src/iv_timer.c line 136
void iv_run_timers(struct iv_state *st);
// iv_set_fatal_msg_handler
// file ../../../src/iv_fatal.c line 60
void iv_set_fatal_msg_handler(void (*handler)(const char *));
// iv_set_fatal_msg_handler::handler$object
// 
void handler$object(const char *);
// iv_signal_event
// file ../../../src/iv_signal.c line 161
static void iv_signal_event(void *_this);
// iv_signal_handler
// file ../../../src/iv_signal.c line 154
static void iv_signal_handler(signed int signum);
// iv_signal_register
// file ../../../src/iv_signal.c line 173
signed int iv_signal_register(struct iv_signal *this);
// iv_signal_unregister
// file ../../../src/iv_signal.c line 208
void iv_signal_unregister(struct iv_signal *this);
// iv_state_destructor
// file ../../../src/iv_main_posix.c line 47
static void iv_state_destructor(void *data);
// iv_task_init
// file ../../../src/iv_task.c line 25
void iv_task_init(struct iv_state *st);
// iv_task_register
// file ../../../src/iv_task.c line 59
void iv_task_register(struct iv_task *_t);
// iv_task_registered
// file ../../../src/iv_task.c line 83
signed int iv_task_registered(struct iv_task *_t);
// iv_task_unregister
// file ../../../src/iv_task.c line 71
void iv_task_unregister(struct iv_task *_t);
// iv_thread_cleanup_handler
// file ../../../src/iv_thread_posix.c line 125
static void iv_thread_cleanup_handler(void *_thr);
// iv_thread_create
// file ../../../src/include/iv_thread.h line 28
signed int iv_thread_create(char *name, void (*start_routine)(void *), void *arg);
// iv_thread_create::start_routine$object
// 
void start_routine$object(void *);
// iv_thread_died
// file ../../../src/iv_thread_posix.c line 156
static void iv_thread_died(void *_thr);
// iv_thread_get_id
// file ../../../src/iv_thread_posix.c line 221
unsigned long int iv_thread_get_id(void);
// iv_thread_handler
// file ../../../src/iv_thread_posix.c line 135
static void * iv_thread_handler(void *_thr);
// iv_thread_handler::1::1::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// iv_thread_list_children
// file ../../../src/iv_thread_posix.c line 226
void iv_thread_list_children(void);
// iv_thread_set_debug_state
// file ../../../src/iv_thread_posix.c line 216
void iv_thread_set_debug_state(signed int state);
// iv_thread_tls_deinit_thread
// file ../../../src/iv_thread_posix.c line 98
static void iv_thread_tls_deinit_thread(void *_tinfo);
// iv_thread_tls_init_thread
// file ../../../src/iv_thread_posix.c line 91
static void iv_thread_tls_init_thread(void *_tinfo);
// iv_time_get
// file ../../../src/iv_private.h line 199
void iv_time_get(struct timespec *time);
// iv_timer_allocate_ratnode
// file ../../../src/iv_timer.c line 64
static struct ratnode * iv_timer_allocate_ratnode(void);
// iv_timer_deinit
// file ../../../src/iv_timer.c line 168
void iv_timer_deinit(struct iv_state *st);
// iv_timer_get_node
// file ../../../src/iv_timer.c line 81
static struct iv_timer_ ** iv_timer_get_node(struct iv_state *st, signed int index);
// iv_timer_init
// file ../../../src/iv_timer.c line 75
void iv_timer_init(struct iv_state *st);
// iv_timer_radix_tree_remove_level
// file ../../../src/iv_timer.c line 174
static void iv_timer_radix_tree_remove_level(struct iv_state *st);
// iv_timer_register
// file ../../../src/iv_timer.c line 231
void iv_timer_register(struct iv_timer *_t);
// iv_timer_registered
// file ../../../src/iv_timer.c line 335
signed int iv_timer_registered(struct iv_timer *_t);
// iv_timer_unregister
// file ../../../src/iv_timer.c line 292
void iv_timer_unregister(struct iv_timer *_t);
// iv_tls_thread_deinit
// file ../../../src/iv_tls.c line 62
void iv_tls_thread_deinit(struct iv_state *st);
// iv_tls_thread_init
// file ../../../src/iv_tls.c line 47
void iv_tls_thread_init(struct iv_state *st);
// iv_tls_total_state_size
// file ../../../src/iv_tls.c line 42
signed int iv_tls_total_state_size(void);
// iv_tls_user_ptr
// file ../../../src/include/iv_tls.h line 40
void * iv_tls_user_ptr(struct iv_tls_user *itu);
// iv_tls_user_register
// file ../../../src/iv_tls.c line 31
void iv_tls_user_register(struct iv_tls_user *itu);
// iv_validate_now
// file ../../../src/iv_timer.c line 41
void iv_validate_now(void);
// iv_wait_completion
// file ../../../src/iv_wait.c line 202
static void iv_wait_completion(void *_this);
// iv_wait_got_sigchld
// file ../../../src/iv_wait.c line 101
static void iv_wait_got_sigchld(void *_dummy);
// iv_wait_interest_compare
// file ../../../src/iv_wait.c line 47
static signed int iv_wait_interest_compare(struct iv_avl_node *_a, struct iv_avl_node *_b);
// iv_wait_interest_kill
// file ../../../src/include/iv_wait.h line 55
signed int iv_wait_interest_kill(struct iv_wait_interest *this, signed int sig);
// iv_wait_interest_register
// file ../../../src/iv_wait.c line 252
void iv_wait_interest_register(struct iv_wait_interest *this);
// iv_wait_interest_register_spawn
// file ../../../src/include/iv_wait.h line 52
signed int iv_wait_interest_register_spawn(struct iv_wait_interest *this, void (*fn)(void *), void *cookie);
// iv_wait_interest_register_spawn::fn$object
// 
void fn$object(void *);
// iv_wait_interest_unregister
// file ../../../src/include/iv_wait.h line 54
void iv_wait_interest_unregister(struct iv_wait_interest *this);
// iv_wait_status_dead
// file ../../../src/iv_wait.c line 87
static signed int iv_wait_status_dead(signed int status);
// iv_wait_tls_init_thread
// file ../../../src/iv_wait.c line 175
static void iv_wait_tls_init_thread(void *_tinfo);
// iv_work_event
// file ../../../src/iv_work.c line 207
static void iv_work_event(void *_pool);
// iv_work_handle_local
// file ../../../src/iv_work.c line 378
static void iv_work_handle_local(void *_tinfo);
// iv_work_pool_create
// file ../../../src/iv_work.c line 238
signed int iv_work_pool_create(struct iv_work_pool *this);
// iv_work_pool_put
// file ../../../src/iv_work.c line 274
void iv_work_pool_put(struct iv_work_pool *this);
// iv_work_pool_submit_work
// file ../../../src/iv_work.c line 406
void iv_work_pool_submit_work(struct iv_work_pool *this, struct iv_work_item *work);
// iv_work_start_thread
// file ../../../src/iv_work.c line 300
static signed int iv_work_start_thread(struct work_pool_priv *pool);
// iv_work_submit_local
// file ../../../src/iv_work.c line 395
static void iv_work_submit_local(struct iv_work_item *work);
// iv_work_submit_pool
// file ../../../src/iv_work.c line 326
static void iv_work_submit_pool(struct iv_work_pool *this, struct iv_work_item *work);
// iv_work_thread
// file ../../../src/iv_work.c line 172
static void iv_work_thread(void *_thr);
// iv_work_thread_do_work
// file ../../../src/iv_work.c line 100
static void iv_work_thread_do_work(void *_thr);
// iv_work_thread_got_event
// file ../../../src/iv_work.c line 60
static void iv_work_thread_got_event(void *_thr);
// iv_work_thread_idle_timeout
// file ../../../src/iv_work.c line 153
static void iv_work_thread_idle_timeout(void *_thr);
// iv_work_tls_init_thread
// file ../../../src/iv_work.c line 356
static void iv_work_tls_init_thread(void *_tinfo);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// method_is_excluded
// file ../../../src/iv_fd.c line 65
static signed int method_is_excluded(char *exclude, char *name);
// mutex_destroy
// file ../../../src/mutex.h line 31
static inline void mutex_destroy(union anonymous$38 *mutex);
// mutex_destroy$link1
// file ../../../src/mutex.h line 31
static inline void mutex_destroy$link1(union anonymous$38 *mutex$link1);
// mutex_init
// file ../../../src/mutex.h line 26
static inline signed int mutex_init(union anonymous$38 *mutex);
// mutex_init$link1
// file ../../../src/mutex.h line 26
static inline signed int mutex_init$link1(union anonymous$38 *mutex$link1);
// mutex_lock
// file ../../../src/mutex.h line 36
static inline void mutex_lock(union anonymous$38 *mutex);
// mutex_lock$link1
// file ../../../src/mutex.h line 36
static inline void mutex_lock$link1(union anonymous$38 *mutex$link1);
// mutex_unlock
// file ../../../src/mutex.h line 41
static inline void mutex_unlock(union anonymous$38 *mutex);
// mutex_unlock$link1
// file ../../../src/mutex.h line 41
static inline void mutex_unlock$link1(union anonymous$38 *mutex$link1);
// notify_fd
// file ../../../src/iv_fd.c line 237
static void notify_fd(struct iv_state *st, struct iv_fd_ *fd);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_listening_socket
// file ../../../test/iv_fd_pump_discard.c line 96
static signed int open_listening_socket(void);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$38 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$38 *, const union anonymous$37 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$38 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$38 *);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$17 *, struct anonymous$17 *);
// pthread_spin_lock
// file /usr/include/pthread.h line 1054
extern signed int pthread_spin_lock(volatile signed int *);
// pthread_spin_unlock
// file /usr/include/pthread.h line 1062
extern signed int pthread_spin_unlock(volatile signed int *);
// pull_up
// file ../../../src/iv_timer.c line 206
static void pull_up(struct iv_state *st, signed int index, struct iv_timer_ **i);
// push_down
// file ../../../src/iv_timer.c line 253
static void push_down(struct iv_state *st, signed int index, struct iv_timer_ **i);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// rebalance_node
// file ../../../src/iv_avl.c line 197
static void rebalance_node(struct iv_avl_node **_root);
// rebalance_path
// file ../../../src/iv_avl.c line 245
static void rebalance_path(struct iv_avl_tree *tree, struct iv_avl_node *an);
// recalc_height
// file ../../../src/iv_avl.c line 30
static void recalc_height(struct iv_avl_node *an);
// recompute_wanted_flags
// file ../../../src/iv_fd.c line 220
static void recompute_wanted_flags(struct iv_fd_ *fd);
// replace_reference
// file ../../../src/iv_avl.c line 233
static void replace_reference(struct iv_avl_tree *tree, struct iv_avl_node *an, struct iv_avl_node *new_child);
// rotate_left
// file ../../../src/iv_avl.c line 92
static void rotate_left(struct iv_avl_node **root);
// rotate_left_right
// file ../../../src/iv_avl.c line 132
static void rotate_left_right(struct iv_avl_node **root);
// rotate_right
// file ../../../src/iv_avl.c line 112
static void rotate_right(struct iv_avl_node **root);
// rotate_right_left
// file ../../../src/iv_avl.c line 162
static void rotate_right_left(struct iv_avl_node **root);
// sanitise_nofile_rlimit
// file ../../../src/iv_fd.c line 34
static void sanitise_nofile_rlimit(signed int euid);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(enum __rlimit_resource, struct rlimit *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$17 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$17 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// spin_lock
// file ../../../src/spinlock.h line 31
static inline void spin_lock(volatile signed int *lock);
// spin_lock_sigmask
// file ../../../src/spinlock.h line 76
static inline void spin_lock_sigmask(volatile signed int *lock, struct anonymous$17 *mask);
// spin_unlock
// file ../../../src/spinlock.h line 36
static inline void spin_unlock(volatile signed int *lock);
// spin_unlock_sigmask
// file ../../../src/spinlock.h line 84
static inline void spin_unlock_sigmask(volatile signed int *lock, struct anonymous$17 *mask);
// splice
// file /usr/include/x86_64-linux-gnu/bits/fcntl-linux.h line 391
extern signed long int splice(signed int, signed long int *, signed int, signed long int *, unsigned long int, unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// timer_ptr_gt
// file ../../../src/iv_timer.c line 201
static inline signed int timer_ptr_gt(struct iv_timer_ *a, struct iv_timer_ *b);
// timespec_gt
// file ../../../src/iv_timer.c line 130
static inline signed int timespec_gt(struct timespec *a, struct timespec *b);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait4
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 168
extern signed int wait4(signed int, union anonymous$0, signed int, struct rusage *);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$29
{
  // pfds
  struct pollfd *pfds;
  // fds
  struct iv_fd_ **fds;
  // num_regd_fds
  signed int num_regd_fds;
};

struct anonymous$27
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$24
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$17
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$33
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$34
{
  // __cancel_jmp_buf
  struct anonymous$33 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$40
{
  // __w_stopval
  unsigned int __w_stopval : 8;
  // __w_stopsig
  unsigned int __w_stopsig : 8;
  // $anon0
  unsigned int $anon0 : 16;
};

struct anonymous$39
{
  // __w_termsig
  unsigned int __w_termsig : 7;
  // __w_coredump
  unsigned int __w_coredump : 1;
  // __w_retcode
  unsigned int __w_retcode : 8;
  // $anon0
  unsigned int $anon0 : 16;
};

struct iv_list_head
{
  // next
  struct iv_list_head *next;
  // prev
  struct iv_list_head *prev;
};

struct anonymous$28
{
  // epoll_fd
  signed int epoll_fd;
  // notify
  struct iv_list_head notify;
};

struct anonymous$20
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$23
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$22
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$21
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$25
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$26
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$20 _kill;
  // _timer
  struct anonymous$21 _timer;
  // _rt
  struct anonymous$22 _rt;
  // _sigchld
  struct anonymous$23 _sigchld;
  // _sigfault
  struct anonymous$24 _sigfault;
  // _sigpoll
  struct anonymous$25 _sigpoll;
  // _sigsys
  struct anonymous$27 _sigsys;
};

struct anonymous$18
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$26 _sifields;
};

union anonymous$41
{
  // __uptr
  union wait *__uptr;
  // __iptr
  signed int *__iptr;
};

union anonymous$0
{
  // __uptr
  union wait *__uptr;
  // __iptr
  signed int *__iptr;
} __attribute__ ((__transparent_union__));

union anonymous$19
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$18 *, void *);
};

union anonymous$1
{
  // buf
  unsigned char buf[0l];
  // pfd
  signed int pfd[2l];
};

union anonymous$32
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$37
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$31
{
  // index
  signed int index;
};

union anonymous$4
{
  // ru_idrss
  signed long int ru_idrss;
  // __ru_idrss_word
  signed long int __ru_idrss_word;
};

union anonymous$9
{
  // ru_inblock
  signed long int ru_inblock;
  // __ru_inblock_word
  signed long int __ru_inblock_word;
};

union anonymous$5
{
  // ru_isrss
  signed long int ru_isrss;
  // __ru_isrss_word
  signed long int __ru_isrss_word;
};

union anonymous$3
{
  // ru_ixrss
  signed long int ru_ixrss;
  // __ru_ixrss_word
  signed long int __ru_ixrss_word;
};

union anonymous$7
{
  // ru_majflt
  signed long int ru_majflt;
  // __ru_majflt_word
  signed long int __ru_majflt_word;
};

union anonymous$2
{
  // ru_maxrss
  signed long int ru_maxrss;
  // __ru_maxrss_word
  signed long int __ru_maxrss_word;
};

union anonymous$6
{
  // ru_minflt
  signed long int ru_minflt;
  // __ru_minflt_word
  signed long int __ru_minflt_word;
};

union anonymous$12
{
  // ru_msgrcv
  signed long int ru_msgrcv;
  // __ru_msgrcv_word
  signed long int __ru_msgrcv_word;
};

union anonymous$11
{
  // ru_msgsnd
  signed long int ru_msgsnd;
  // __ru_msgsnd_word
  signed long int __ru_msgsnd_word;
};

union anonymous$15
{
  // ru_nivcsw
  signed long int ru_nivcsw;
  // __ru_nivcsw_word
  signed long int __ru_nivcsw_word;
};

union anonymous$13
{
  // ru_nsignals
  signed long int ru_nsignals;
  // __ru_nsignals_word
  signed long int __ru_nsignals_word;
};

union anonymous$8
{
  // ru_nswap
  signed long int ru_nswap;
  // __ru_nswap_word
  signed long int __ru_nswap_word;
};

union anonymous$14
{
  // ru_nvcsw
  signed long int ru_nvcsw;
  // __ru_nvcsw_word
  signed long int __ru_nvcsw_word;
};

union anonymous$10
{
  // ru_oublock
  signed long int ru_oublock;
  // __ru_oublock_word
  signed long int __ru_oublock_word;
};

union anonymous$30
{
  // epoll
  struct anonymous$28 epoll;
  // poll
  struct anonymous$29 poll;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$38
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct iv_fd
{
  // fd
  signed int fd;
  // cookie
  void *cookie;
  // handler_in
  void (*handler_in)(void *);
  // handler_out
  void (*handler_out)(void *);
  // handler_err
  void (*handler_err)(void *);
  // pad
  void *pad[11l];
};

struct iv_event_raw
{
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *);
  // event_rfd
  struct iv_fd event_rfd;
  // event_wfd
  signed int event_wfd;
};

union anonymous$36
{
  // ier
  struct iv_event_raw ier;
  // st
  struct iv_state *st;
};

union anonymous$35
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct iv_fd_pump
{
  // from_fd
  signed int from_fd;
  // to_fd
  signed int to_fd;
  // cookie
  void *cookie;
  // set_bands
  void (*set_bands)(void *, signed int, signed int);
  // flags
  unsigned int flags;
  // buf
  void *buf;
  // bytes
  signed int bytes;
  // full
  signed int full;
  // saw_fin
  signed int saw_fin;
};

struct connection
{
  // sock
  struct iv_fd sock;
  // pump
  struct iv_fd_pump pump;
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct in6_addr
{
  // __in6_u
  union anonymous$32 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct inotify_event
{
  // wd
  signed int wd;
  // mask
  unsigned int mask;
  // cookie
  unsigned int cookie;
  // len
  unsigned int len;
  // name
  char name[0l];
};

struct iv_avl_node
{
  // left
  struct iv_avl_node *left;
  // right
  struct iv_avl_node *right;
  // parent
  struct iv_avl_node *parent;
  // height
  unsigned char height;
};

struct iv_avl_tree
{
  // compare
  signed int (*compare)(struct iv_avl_node *, struct iv_avl_node *);
  // root
  struct iv_avl_node *root;
};

struct iv_event
{
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *);
  // tinfo
  void *tinfo;
  // list
  struct iv_list_head list;
};

struct iv_event_thr_info
{
  // event_count
  signed int event_count;
  // u
  union anonymous$36 u;
  // list_mutex
  union anonymous$38 list_mutex;
  // pending_events
  struct iv_list_head pending_events;
};

struct iv_fd_
{
  // fd
  signed int fd;
  // cookie
  void *cookie;
  // handler_in
  void (*handler_in)(void *);
  // handler_out
  void (*handler_out)(void *);
  // handler_err
  void (*handler_err)(void *);
  // list_active
  struct iv_list_head list_active;
  // ready_bands
  unsigned int ready_bands : 3;
  // registered
  unsigned int registered : 1;
  // wanted_bands
  unsigned int wanted_bands : 3;
  // registered_bands
  unsigned int registered_bands : 3;
  // list_notify
  struct iv_list_head list_notify;
  // u
  union anonymous$31 u;
};

struct iv_fd_poll_method
{
  // name
  char *name;
  // init
  signed int (*init)(struct iv_state *);
  // poll
  void (*poll)(struct iv_state *, struct iv_list_head *, struct timespec *);
  // register_fd
  void (*register_fd)(struct iv_state *, struct iv_fd_ *);
  // unregister_fd
  void (*unregister_fd)(struct iv_state *, struct iv_fd_ *);
  // notify_fd
  void (*notify_fd)(struct iv_state *, struct iv_fd_ *);
  // notify_fd_sync
  signed int (*notify_fd_sync)(struct iv_state *, struct iv_fd_ *);
  // deinit
  void (*deinit)(struct iv_state *);
  // event_rx_on
  signed int (*event_rx_on)(struct iv_state *);
  // event_rx_off
  void (*event_rx_off)(struct iv_state *);
  // event_send
  void (*event_send)(struct iv_state *);
};

struct iv_fd_pump_buf
{
  // list
  struct iv_list_head list;
  // u
  union anonymous$1 u;
};

struct iv_fd_pump_thr_info
{
  // num_bufs
  signed int num_bufs;
  // bufs
  struct iv_list_head bufs;
};

struct iv_inotify
{
  // fd
  struct iv_fd fd;
  // watches
  struct iv_avl_tree watches;
  // term
  void **term;
};

struct iv_inotify_watch
{
  // inotify
  struct iv_inotify *inotify;
  // pathname
  const char *pathname;
  // mask
  unsigned int mask;
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *, struct inotify_event *);
  // wd
  signed int wd;
  // an
  struct iv_avl_node an;
};

struct iv_popen_request
{
  // file
  char *file;
  // argv
  char **argv;
  // type
  char *type;
  // child
  void *child;
};

struct iv_wait_interest
{
  // pid
  signed int pid;
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *, signed int, struct rusage *);
  // avl_node
  struct iv_avl_node avl_node;
  // ev
  struct iv_event ev;
  // events
  struct iv_list_head events;
  // dummy
  void *dummy;
  // flags
  unsigned int flags;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct iv_timer
{
  // expires
  struct timespec expires;
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *);
  // pad
  void *pad[4l];
};

struct iv_popen_running_child
{
  // wait
  struct iv_wait_interest wait;
  // parent
  struct iv_popen_request *parent;
  // signal_timer
  struct iv_timer signal_timer;
  // num_kills
  signed int num_kills;
};

struct iv_popen_spawn_info
{
  // this
  struct iv_popen_request *this;
  // for_read
  signed int for_read;
  // data_pipe
  signed int data_pipe[2l];
};

struct iv_signal
{
  // signum
  signed int signum;
  // flags
  unsigned int flags;
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *);
  // an
  struct iv_avl_node an;
  // active
  unsigned char active;
  // ev
  struct iv_event_raw ev;
};

struct iv_state
{
  // quit
  signed int quit;
  // numobjs
  signed int numobjs;
  // numfds
  signed int numfds;
  // handled_fd
  struct iv_fd_ *handled_fd;
  // tasks
  struct iv_list_head tasks;
  // time
  struct timespec time;
  // time_valid
  signed int time_valid;
  // num_timers
  signed int num_timers;
  // rat_depth
  signed int rat_depth;
  // timer_root
  struct ratnode *timer_root;
  // u
  union anonymous$30 u;
};

struct iv_task
{
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *);
  // pad
  void *pad[6l];
};

struct iv_task_
{
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *);
  // list
  struct iv_list_head list;
};

struct iv_thread
{
  // list
  struct iv_list_head list;
  // thread_id
  unsigned long int thread_id;
  // dead
  struct iv_event dead;
  // name
  char *name;
  // tid
  unsigned long int tid;
  // start_routine
  void (*start_routine)(void *);
  // arg
  void *arg;
};

struct iv_thread_thr_info
{
  // child_threads
  struct iv_list_head child_threads;
};

struct iv_timer_
{
  // expires
  struct timespec expires;
  // cookie
  void *cookie;
  // handler
  void (*handler)(void *);
  // index
  signed int index;
};

struct iv_tls_user
{
  // sizeof_state
  unsigned long int sizeof_state;
  // init_thread
  void (*init_thread)(void *);
  // deinit_thread
  void (*deinit_thread)(void *);
  // list
  struct iv_list_head list;
  // state_offset
  signed int state_offset;
};

struct iv_wait_thr_info
{
  // wait_count
  signed int wait_count;
  // sigchld_interest
  struct iv_signal sigchld_interest;
  // handled_wait_interest
  struct iv_wait_interest *handled_wait_interest;
};

struct iv_work_item
{
  // cookie
  void *cookie;
  // work
  void (*work)(void *);
  // completion
  void (*completion)(void *);
  // list
  struct iv_list_head list;
};

struct iv_work_pool
{
  // max_threads
  signed int max_threads;
  // cookie
  void *cookie;
  // thread_start
  void (*thread_start)(void *);
  // thread_stop
  void (*thread_stop)(void *);
  // priv
  void *priv;
};

struct iv_work_thr_info
{
  // task
  struct iv_task task;
  // work_items
  struct iv_list_head work_items;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct ratnode
{
  // child
  void *child[256l];
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct rusage
{
  // ru_utime
  struct timeval ru_utime;
  // ru_stime
  struct timeval ru_stime;
  // $anon0
  union anonymous$2 $anon0;
  // $anon1
  union anonymous$3 $anon1;
  // $anon2
  union anonymous$4 $anon2;
  // $anon3
  union anonymous$5 $anon3;
  // $anon4
  union anonymous$6 $anon4;
  // $anon5
  union anonymous$7 $anon5;
  // $anon6
  union anonymous$8 $anon6;
  // $anon7
  union anonymous$9 $anon7;
  // $anon8
  union anonymous$10 $anon8;
  // $anon9
  union anonymous$11 $anon9;
  // $anon10
  union anonymous$12 $anon10;
  // $anon11
  union anonymous$13 $anon11;
  // $anon12
  union anonymous$14 $anon12;
  // $anon13
  union anonymous$15 $anon13;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$19 __sigaction_handler;
  // sa_mask
  struct anonymous$17 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

union wait
{
  // w_status
  signed int w_status;
  // __wait_terminated
  struct anonymous$39 __wait_terminated;
  // __wait_stopped
  struct anonymous$40 __wait_stopped;
};

struct wait_event
{
  // list
  struct iv_list_head list;
  // status
  signed int status;
  // rusage
  struct rusage rusage;
};

struct work_pool_priv
{
  // lock
  union anonymous$38 lock;
  // ev
  struct iv_event ev;
  // shutting_down
  signed int shutting_down;
  // started_threads
  signed int started_threads;
  // idle_threads
  struct iv_list_head idle_threads;
  // cookie
  void *cookie;
  // thread_start
  void (*thread_start)(void *);
  // thread_stop
  void (*thread_stop)(void *);
  // seq_head
  unsigned int seq_head;
  // seq_tail
  unsigned int seq_tail;
  // work_items
  struct iv_list_head work_items;
  // work_done
  struct iv_list_head work_done;
};

struct work_pool_thread
{
  // pool
  struct work_pool_priv *pool;
  // list
  struct iv_list_head list;
  // kicked
  signed int kicked;
  // kick
  struct iv_event kick;
  // work_task
  struct iv_task work_task;
  // idle_timer
  struct iv_timer idle_timer;
};


// __st
// file ../../../src/iv_main_posix.c line 29
struct iv_state *__st;
// clock_source
// file ../../../src/iv_time_posix.c line 28
static signed int clock_source;
// devnull
// file ../../../test/iv_fd_pump_discard.c line 35
static signed int devnull;
// eventfd_unavailable
// file ../../../src/iv_event_raw_posix.c line 62
static signed int eventfd_unavailable;
// fatal_msg_handler
// file ../../../src/iv_fatal.c line 39
static void (*fatal_msg_handler)(const char *);
// inited
// file ../../../src/iv_tls.c line 27
static signed int inited;
// iv_event_tls_user
// file ../../../src/iv_event.c line 87
static struct iv_tls_user iv_event_tls_user;
// iv_event_tls_user
// file ../../../src/iv_event.c line 87
static struct iv_tls_user iv_event_tls_user = { .sizeof_state=sizeof(struct iv_event_thr_info) /*216ul*/ , .init_thread=iv_event_tls_init_thread,
    .deinit_thread=iv_event_tls_deinit_thread,
    .list={ .next=((struct iv_list_head *)NULL), .prev=((struct iv_list_head *)NULL) },
    .state_offset=0 };
// iv_event_use_event_raw
// file ../../../src/iv_event.c line 41
static signed int iv_event_use_event_raw;
// iv_fd_poll_method_epoll
// file ../../../src/iv_fd_epoll.c line 182
struct iv_fd_poll_method iv_fd_poll_method_epoll;
// iv_fd_poll_method_epoll
// file ../../../src/iv_fd_epoll.c line 182
struct iv_fd_poll_method iv_fd_poll_method_epoll = { .name="epoll", .init=iv_fd_epoll_init, .poll=iv_fd_epoll_poll,
    .register_fd=((void (*)(struct iv_state *, struct iv_fd_ *))NULL), .unregister_fd=iv_fd_epoll_unregister_fd,
    .notify_fd=iv_fd_epoll_notify_fd,
    .notify_fd_sync=iv_fd_epoll_notify_fd_sync, .deinit=iv_fd_epoll_deinit,
    .event_rx_on=((signed int (*)(struct iv_state *))NULL), .event_rx_off=((void (*)(struct iv_state *))NULL),
    .event_send=((void (*)(struct iv_state *))NULL) };
// iv_fd_poll_method_poll
// file ../../../src/iv_fd_poll.c line 167
struct iv_fd_poll_method iv_fd_poll_method_poll;
// iv_fd_poll_method_poll
// file ../../../src/iv_fd_poll.c line 167
struct iv_fd_poll_method iv_fd_poll_method_poll = { .name="poll", .init=iv_fd_poll_init, .poll=iv_fd_poll_poll, .register_fd=iv_fd_poll_register_fd,
    .unregister_fd=((void (*)(struct iv_state *, struct iv_fd_ *))NULL),
    .notify_fd=iv_fd_poll_notify_fd,
    .notify_fd_sync=iv_fd_poll_notify_fd_sync, .deinit=iv_fd_poll_deinit,
    .event_rx_on=((signed int (*)(struct iv_state *))NULL), .event_rx_off=((void (*)(struct iv_state *))NULL),
    .event_send=((void (*)(struct iv_state *))NULL) };
// iv_fd_pump_tls_user
// file ../../../src/iv_fd_pump.c line 55
static struct iv_tls_user iv_fd_pump_tls_user;
// iv_fd_pump_tls_user
// file ../../../src/iv_fd_pump.c line 55
static struct iv_tls_user iv_fd_pump_tls_user = { .sizeof_state=sizeof(struct iv_fd_pump_thr_info) /*24ul*/ , .init_thread=iv_fd_pump_tls_init_thread,
    .deinit_thread=iv_fd_pump_tls_deinit_thread,
    .list={ .next=((struct iv_list_head *)NULL), .prev=((struct iv_list_head *)NULL) },
    .state_offset=0 };
// iv_state_key
// file ../../../src/iv_main_posix.c line 27
unsigned int iv_state_key;
// iv_state_key_allocated
// file ../../../src/iv_main_posix.c line 26
signed int iv_state_key_allocated;
// iv_thread_debug
// file ../../../src/iv_thread_posix.c line 83
static signed int iv_thread_debug;
// iv_thread_tls_user
// file ../../../src/iv_thread_posix.c line 111
static struct iv_tls_user iv_thread_tls_user;
// iv_thread_tls_user
// file ../../../src/iv_thread_posix.c line 111
static struct iv_tls_user iv_thread_tls_user = { .sizeof_state=sizeof(struct iv_thread_thr_info) /*16ul*/ , .init_thread=iv_thread_tls_init_thread,
    .deinit_thread=iv_thread_tls_deinit_thread,
    .list={ .next=((struct iv_list_head *)NULL), .prev=((struct iv_list_head *)NULL) },
    .state_offset=0 };
// iv_tls_users
// file ../../../src/iv_tls.c line 29
static struct iv_list_head iv_tls_users;
// iv_tls_users
// file ../../../src/iv_tls.c line 29
static struct iv_list_head iv_tls_users = { .next=&iv_tls_users, .prev=&iv_tls_users };
// iv_wait_interests
// file ../../../src/iv_wait.c line 63
static struct iv_avl_tree iv_wait_interests;
// iv_wait_interests
// file ../../../src/iv_wait.c line 63
static struct iv_avl_tree iv_wait_interests = { .compare=iv_wait_interest_compare, .root=(struct iv_avl_node *)(void *)0 };
// iv_wait_lock
// file ../../../src/iv_wait.c line 62
static union anonymous$38 iv_wait_lock;
// iv_wait_tls_user
// file ../../../src/iv_wait.c line 189
static struct iv_tls_user iv_wait_tls_user;
// iv_wait_tls_user
// file ../../../src/iv_wait.c line 189
static struct iv_tls_user iv_wait_tls_user = { .sizeof_state=sizeof(struct iv_wait_thr_info) /*232ul*/ , .init_thread=iv_wait_tls_init_thread,
    .deinit_thread=((void (*)(void *))NULL),
    .list={ .next=((struct iv_list_head *)NULL), .prev=((struct iv_list_head *)NULL) },
    .state_offset=0 };
// iv_work_tls_user
// file ../../../src/iv_work.c line 367
static struct iv_tls_user iv_work_tls_user;
// iv_work_tls_user
// file ../../../src/iv_work.c line 367
static struct iv_tls_user iv_work_tls_user = { .sizeof_state=sizeof(struct iv_work_thr_info) /*80ul*/ , .init_thread=iv_work_tls_init_thread,
    .deinit_thread=((void (*)(void *))NULL),
    .list={ .next=((struct iv_list_head *)NULL), .prev=((struct iv_list_head *)NULL) },
    .state_offset=0 };
// last_offset
// file ../../../src/iv_tls.c line 28
static signed int last_offset = (signed int)(sizeof(struct iv_state) /*104ul*/  + (unsigned long int)15 & (unsigned long int)~15);
// listening_socket
// file ../../../test/iv_fd_pump_discard.c line 62
static struct iv_fd listening_socket;
// maxfd
// file ../../../src/iv_fd.c line 31
signed int maxfd;
// method
// file ../../../src/iv_fd.c line 32
struct iv_fd_poll_method *method;
// sig_interests
// file ../../../src/iv_signal.c line 31
static struct iv_avl_tree sig_interests;
// sig_interests_lock
// file ../../../src/iv_signal.c line 30
static volatile signed int sig_interests_lock;
// splice_available
// file ../../../src/iv_fd_pump.c line 79
static signed int splice_available = -1;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// IV_EVENT_INIT
// file ../../../src/include/iv_event.h line 39
static inline void IV_EVENT_INIT(struct iv_event *this)
{
  ;
}

// IV_EVENT_INIT$link1
// file ../../../src/include/iv_event.h line 39
static inline void IV_EVENT_INIT$link1(struct iv_event *this$link1)
{
  ;
}

// IV_EVENT_INIT$link2
// file ../../../src/include/iv_event.h line 39
static inline void IV_EVENT_INIT$link2(struct iv_event *this$link2)
{
  ;
}

// IV_EVENT_RAW_INIT
// file ../../../src/include/iv_event_raw.h line 42
static inline void IV_EVENT_RAW_INIT(struct iv_event_raw *this)
{
  ;
}

// IV_EVENT_RAW_INIT$link1
// file ../../../src/include/iv_event_raw.h line 42
static inline void IV_EVENT_RAW_INIT$link1(struct iv_event_raw *this$link1)
{
  ;
}

// IV_FD_INIT
// file ../src/include/iv.h line 76
void IV_FD_INIT(struct iv_fd *_fd)
{
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  fd->fd = -1;
  fd->handler_in = (void (*)(void *))(void *)0;
  fd->handler_out = (void (*)(void *))(void *)0;
  fd->handler_err = (void (*)(void *))(void *)0;
  fd->registered = (unsigned int)0;
}

// IV_FD_PUMP_INIT
// file ../../../src/include/iv_fd_pump.h line 41
static inline void IV_FD_PUMP_INIT(struct iv_fd_pump *this)
{
  ;
}

// IV_SIGNAL_INIT
// file ../../../src/include/iv_signal.h line 44
static inline void IV_SIGNAL_INIT(struct iv_signal *this)
{
  ;
}

// IV_TASK_INIT
// file ../../../src/iv_task.c line 52
void IV_TASK_INIT(struct iv_task *_t)
{
  struct iv_task_ *t = (struct iv_task_ *)_t;
  do
  {
    (&t->list)->next = &t->list;
    (&t->list)->prev = &t->list;
  }
  while((_Bool)0);
}

// IV_TIMER_INIT
// file ../../../src/iv_timer.c line 194
void IV_TIMER_INIT(struct iv_timer *_t)
{
  struct iv_timer_ *t = (struct iv_timer_ *)_t;
  t->index = -1;
}

// IV_WAIT_INTEREST_INIT
// file ../../../src/include/iv_wait.h line 47
static inline void IV_WAIT_INTEREST_INIT(struct iv_wait_interest *this)
{
  ;
}

// __buf_dequeue
// file ../../../src/iv_fd_pump.c line 172
static struct iv_fd_pump_buf * __buf_dequeue(struct iv_fd_pump_thr_info *tinfo)
{
  signed int return_value_iv_list_empty$2;
  return_value_iv_list_empty$2=iv_list_empty$link4(&tinfo->bufs);
  struct iv_fd_pump_buf *tmp_statement_expression$1;
  if(return_value_iv_list_empty$2 == 0)
  {
    struct iv_list_head *ilh;
    tinfo->num_bufs = tinfo->num_bufs - 1;
    ilh = tinfo->bufs.next;
    iv_list_del$link3(ilh);
    const struct iv_list_head *__ptr = ilh;
    tmp_statement_expression$1 = (struct iv_fd_pump_buf *)((char *)__ptr - (signed long int)&((struct iv_fd_pump_buf *)0)->list);
    return tmp_statement_expression$1;
  }

  return (struct iv_fd_pump_buf *)(void *)0;
}

// __buf_free
// file ../../../src/iv_fd_pump.c line 110
static void __buf_free(struct iv_fd_pump_buf *buf)
{
  if(!(splice_available == 0))
  {
    close(buf->u.pfd[(signed long int)0]);
    close(buf->u.pfd[(signed long int)1]);
  }

  free((void *)buf);
}

// __find_watch
// file ../../../src/iv_inotify.c line 32
static struct iv_inotify_watch * __find_watch(struct iv_inotify *this, signed int wd)
{
  struct iv_avl_node *an = this->watches.root;
  struct iv_inotify_watch *tmp_statement_expression$1;
  while(!(an == ((struct iv_avl_node *)NULL)))
  {
    struct iv_inotify_watch *w;
    const struct iv_avl_node *__ptr = an;
    tmp_statement_expression$1 = (struct iv_inotify_watch *)((char *)__ptr - (signed long int)&((struct iv_inotify_watch *)0)->an);
    w = tmp_statement_expression$1;
    if(wd == w->wd)
      return w;

    if(!(wd >= w->wd))
      an = an->left;

    else
      an = an->right;
  }
  return (struct iv_inotify_watch *)(void *)0;
}

// __iv_deinit
// file ../../../src/iv_main_posix.c line 32
static void __iv_deinit(struct iv_state *st)
{
  iv_tls_thread_deinit(st);
  iv_fd_deinit(st);
  iv_timer_deinit(st);
  pthread_setspecific(iv_state_key, (void *)0);
  __st = (struct iv_state *)(void *)0;
  free((void *)st);
}

// __iv_event_run_pending_events
// file ../../../src/iv_event.c line 43
static void __iv_event_run_pending_events(void *_tinfo)
{
  struct iv_event_thr_info *tinfo = (struct iv_event_thr_info *)_tinfo;
  struct iv_list_head events;
  mutex_lock(&tinfo->list_mutex);
  __iv_list_steal_elements(&tinfo->pending_events, &events);
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty(&events);
  struct iv_event *tmp_statement_expression$2;
  if(return_value_iv_list_empty$1 == 0)
  {
    struct iv_event *ie;
    const struct iv_list_head *__ptr = events.next;
    tmp_statement_expression$2 = (struct iv_event *)((char *)__ptr - (signed long int)&((struct iv_event *)0)->list);
    ie = tmp_statement_expression$2;
    iv_list_del_init(&ie->list);
    mutex_unlock(&tinfo->list_mutex);
    ie->handler(ie->cookie);
    mutex_lock(&tinfo->list_mutex);
  }

  mutex_unlock(&tinfo->list_mutex);
}

// __iv_fd_epoll_flush_one
// file ../../../src/iv_fd_epoll.c line 69
static signed int __iv_fd_epoll_flush_one(struct iv_state *st, struct iv_fd_ *fd)
{
  signed int op;
  struct epoll_event event;
  signed int ret;
  iv_list_del_init$link4(&fd->list_notify);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  if(fd->registered_bands == fd->wanted_bands)
    return 0;

  else
  {
    if(fd->registered_bands == 0u)
      tmp_if_expr$2 = fd->wanted_bands != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      op = 1;

    else
    {
      if(!(fd->registered_bands == 0u))
        tmp_if_expr$1 = !(fd->wanted_bands != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        op = 2;

      else
        op = 3;
    }
    event.data.ptr = (void *)fd;
    signed int return_value_bits_to_poll_mask$3;
    return_value_bits_to_poll_mask$3=bits_to_poll_mask$link1((signed int)fd->wanted_bands);
    event.events = (unsigned int)return_value_bits_to_poll_mask$3;
    do
    {
      ret=epoll_ctl(st->u.epoll.epoll_fd, op, fd->fd, &event);
      if(!(ret >= 0))
      {
        return_value___errno_location$4=__errno_location();
        tmp_if_expr$5 = *return_value___errno_location$4 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
    }
    while(tmp_if_expr$5);
    if(ret == 0)
      fd->registered_bands = (unsigned int)fd->wanted_bands;

    return ret;
  }
}

// __iv_fd_pump_pump
// file ../../../src/iv_fd_pump.c line 329
static signed int __iv_fd_pump_pump(struct iv_fd_pump *ip)
{
  if(ip->full == 0)
  {
    if(ip->saw_fin == 0)
    {
      signed int return_value_iv_fd_pump_try_input$1;
      return_value_iv_fd_pump_try_input$1=iv_fd_pump_try_input(ip);
      if(!(return_value_iv_fd_pump_try_input$1 == 0))
        return -1;

    }

  }

  _Bool tmp_if_expr$3;
  if(!(ip->bytes == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = ip->saw_fin == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    signed int return_value_iv_fd_pump_try_output$2;
    return_value_iv_fd_pump_try_output$2=iv_fd_pump_try_output(ip);
    if(!(return_value_iv_fd_pump_try_output$2 == 0))
      return -1;

  }

  switch(ip->saw_fin)
  {
    case 0:
      ip->set_bands(ip->cookie, (signed int)!(ip->full != 0), (signed int)!(!(ip->bytes != 0)));
    case 1:
      ip->set_bands(ip->cookie, 0, 1);
    case 2:
      ip->set_bands(ip->cookie, 0, 0);
  }
  return 0;
  iv_fatal("iv_fd_pump_pump: saw_fin == %d", ip->saw_fin);
}

// __iv_inotify_watch_compare
// file ../../../src/iv_inotify.c line 103
static signed int __iv_inotify_watch_compare(struct iv_avl_node *_a, struct iv_avl_node *_b)
{
  struct iv_inotify_watch *a;
  struct iv_inotify_watch *tmp_statement_expression$1;
  const struct iv_avl_node *__iv_inotify_watch_compare$$1$$1$$__ptr = _a;
  tmp_statement_expression$1 = (struct iv_inotify_watch *)((char *)__iv_inotify_watch_compare$$1$$1$$__ptr - (signed long int)&((struct iv_inotify_watch *)0)->an);
  a = tmp_statement_expression$1;
  struct iv_inotify_watch *b;
  struct iv_inotify_watch *tmp_statement_expression$2;
  const struct iv_avl_node *__ptr = _b;
  tmp_statement_expression$2 = (struct iv_inotify_watch *)((char *)__ptr - (signed long int)&((struct iv_inotify_watch *)0)->an);
  b = tmp_statement_expression$2;
  if(!(a->wd >= b->wd))
    return -1;

  else
    if(!(b->wd >= a->wd))
      return 1;

    else
      return 0;
}

// __iv_invalidate_now
// file ../../../src/iv_timer.c line 29
void __iv_invalidate_now(struct iv_state *st)
{
  st->time_valid = 0;
}

// __iv_list_steal_elements
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements(struct iv_list_head *oldh, struct iv_list_head *newh)
{
  struct iv_list_head *first = oldh->next;
  struct iv_list_head *last = oldh->prev;
  last->next = newh;
  first->prev = newh;
  newh->next = oldh->next;
  newh->prev = oldh->prev;
  oldh->next = oldh;
  oldh->prev = oldh;
}

// __iv_list_steal_elements$link1
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements$link1(struct iv_list_head *oldh$link1, struct iv_list_head *newh$link1)
{
  struct iv_list_head *first$link1 = oldh$link1->next;
  struct iv_list_head *last$link1 = oldh$link1->prev;
  last$link1->next = newh$link1;
  first$link1->prev = newh$link1;
  newh$link1->next = oldh$link1->next;
  newh$link1->prev = oldh$link1->prev;
  oldh$link1->next = oldh$link1;
  oldh$link1->prev = oldh$link1;
}

// __iv_list_steal_elements$link2
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements$link2(struct iv_list_head *oldh$link2, struct iv_list_head *newh$link2)
{
  struct iv_list_head *first$link2 = oldh$link2->next;
  struct iv_list_head *last$link2 = oldh$link2->prev;
  last$link2->next = newh$link2;
  first$link2->prev = newh$link2;
  newh$link2->next = oldh$link2->next;
  newh$link2->prev = oldh$link2->prev;
  oldh$link2->next = oldh$link2;
  oldh$link2->prev = oldh$link2;
}

// __iv_list_steal_elements$link3
// file ../../../src/iv_private.h line 167
static inline void __iv_list_steal_elements$link3(struct iv_list_head *oldh$link3, struct iv_list_head *newh$link3)
{
  struct iv_list_head *first$link3 = oldh$link3->next;
  struct iv_list_head *last$link3 = oldh$link3->prev;
  last$link3->next = newh$link3;
  first$link3->prev = newh$link3;
  newh$link3->next = oldh$link3->next;
  newh$link3->prev = oldh$link3->prev;
  oldh$link3->next = oldh$link3;
  oldh$link3->prev = oldh$link3;
}

// __iv_now_location
// file ../../../src/iv_timer.c line 51
struct timespec * __iv_now_location(void)
{
  struct iv_state *st;
  st=iv_get_state$link2();
  return &st->time;
}

// __iv_signal_do_wake
// file ../../../src/iv_signal.c line 132
static void __iv_signal_do_wake(signed int signum)
{
  struct iv_avl_node *an;
  an=__iv_signal_find_first(signum);
  struct iv_signal *tmp_statement_expression$1;
  while(!(an == ((struct iv_avl_node *)NULL)))
  {
    struct iv_signal *is;
    const struct iv_avl_node *__ptr = an;
    tmp_statement_expression$1 = (struct iv_signal *)((char *)__ptr - (signed long int)&((struct iv_signal *)0)->an);
    is = tmp_statement_expression$1;
    if(!(is->signum == signum))
      break;

    is->active = (unsigned char)1;
    iv_event_raw_post(&is->ev);
    if(!((1u & is->flags) == 0u))
      break;

    an=iv_avl_tree_next(an);
  }
}

// __iv_signal_find_first
// file ../../../src/iv_signal.c line 111
static struct iv_avl_node * __iv_signal_find_first(signed int signum)
{
  struct iv_avl_node *iter;
  struct iv_avl_node *best;
  iter = sig_interests.root;
  best = (struct iv_avl_node *)(void *)0;
  struct iv_signal *tmp_statement_expression$1;
  while(!(iter == ((struct iv_avl_node *)NULL)))
  {
    struct iv_signal *is;
    const struct iv_avl_node *__ptr = iter;
    tmp_statement_expression$1 = (struct iv_signal *)((char *)__ptr - (signed long int)&((struct iv_signal *)0)->an);
    is = tmp_statement_expression$1;
    if(signum == is->signum)
      best = iter;

    if(is->signum >= signum)
      iter = iter->left;

    else
      iter = iter->right;
  }
  return best;
}

// __iv_wait_interest_find
// file ../../../src/iv_wait.c line 66
static struct iv_wait_interest * __iv_wait_interest_find(signed int pid)
{
  struct iv_avl_node *an = iv_wait_interests.root;
  struct iv_wait_interest *tmp_statement_expression$1;
  while(!(an == ((struct iv_avl_node *)NULL)))
  {
    struct iv_wait_interest *p;
    const struct iv_avl_node *__ptr = an;
    tmp_statement_expression$1 = (struct iv_wait_interest *)((char *)__ptr - (signed long int)&((struct iv_wait_interest *)0)->avl_node);
    p = tmp_statement_expression$1;
    if(pid == p->pid)
      return p;

    if(!(pid >= p->pid))
      an = an->left;

    else
      an = an->right;
  }
  return (struct iv_wait_interest *)(void *)0;
}

// __iv_wait_interest_register
// file ../../../src/iv_wait.c line 234
static void __iv_wait_interest_register(struct iv_wait_thr_info *tinfo, struct iv_wait_interest *this)
{
  signed int tmp_post$1 = tinfo->wait_count;
  tinfo->wait_count = tinfo->wait_count + 1;
  if(tmp_post$1 == 0)
    iv_signal_register(&tinfo->sigchld_interest);

  IV_EVENT_INIT$link2(&this->ev);
  this->ev.handler = iv_wait_completion;
  this->ev.cookie = (void *)this;
  iv_event_register(&this->ev);
  do
  {
    (&this->events)->next = &this->events;
    (&this->events)->prev = &this->events;
  }
  while((_Bool)0);
  this->dummy = (void *)0;
  this->flags = (unsigned int)0;
}

// __iv_wait_interest_unregister
// file ../../../src/iv_wait.c line 263
static void __iv_wait_interest_unregister(struct iv_wait_thr_info *tinfo, struct iv_wait_interest *this)
{
  iv_event_unregister(&this->ev);
  signed int return_value_iv_list_empty$1;
  struct wait_event *tmp_statement_expression$2;
  do
  {
    return_value_iv_list_empty$1=iv_list_empty$link5(&this->events);
    if(!(return_value_iv_list_empty$1 == 0))
      break;

    struct wait_event *we;
    const struct iv_list_head *__ptr = this->events.next;
    tmp_statement_expression$2 = (struct wait_event *)((char *)__ptr - (signed long int)&((struct wait_event *)0)->list);
    we = tmp_statement_expression$2;
    iv_list_del$link5(&we->list);
    free((void *)we);
  }
  while((_Bool)1);
  if(tinfo->handled_wait_interest == this)
    tinfo->handled_wait_interest = (struct iv_wait_interest *)(void *)0;

  tinfo->wait_count = tinfo->wait_count - 1;
  if(tinfo->wait_count == 0)
    iv_signal_unregister(&tinfo->sigchld_interest);

}

// __iv_work_thread_die
// file ../../../src/iv_work.c line 78
static void __iv_work_thread_die(struct work_pool_thread *thr)
{
  struct work_pool_priv *pool = thr->pool;
  if(!(thr->kicked == 0))
    iv_fatal("__iv_work_thread_die: called on kicked thread");

  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link2(&thr->list);
  if(return_value_iv_list_empty$1 == 0)
    iv_fatal("__iv_work_thread_die: thread still on list");

  iv_event_unregister(&thr->kick);
  free((void *)thr);
  pool->started_threads = pool->started_threads - 1;
  if(!(pool->thread_stop == ((void (*)(void *))NULL)))
    pool->thread_stop(pool->cookie);

  if(!(pool->shutting_down == 0))
  {
    if(pool->started_threads == 0)
      iv_event_post(&pool->ev);

  }

}

// balance
// file ../../../src/iv_avl.c line 192
static signed int balance(struct iv_avl_node *an)
{
  signed int return_value_height$1;
  return_value_height$1=height(an->right);
  signed int return_value_height$2;
  return_value_height$2=height(an->left);
  return return_value_height$1 - return_value_height$2;
}

// bits_to_poll_mask
// file ../../../src/iv_fd_poll.c line 92
static signed int bits_to_poll_mask(signed int bits)
{
  signed int mask = 0;
  if(!((1 & bits) == 0))
    mask = mask | 0x001 | 0x010;

  if(!((2 & bits) == 0))
    mask = mask | 0x004 | 0x010;

  if(!((4 & bits) == 0))
    mask = mask | 0x010;

  return mask;
}

// bits_to_poll_mask$link1
// file ../../../src/iv_fd_epoll.c line 56
static signed int bits_to_poll_mask$link1(signed int bits$link1)
{
  signed int mask$link1 = 0;
  if(!((1 & bits$link1) == 0))
    mask$link1 = mask$link1 | 1;

  if(!((2 & bits$link1) == 0))
    mask$link1 = mask$link1 | 4;

  return mask$link1;
}

// buf_alloc
// file ../../../src/iv_fd_pump.c line 90
static struct iv_fd_pump_buf * buf_alloc(void)
{
  signed int size;
  struct iv_fd_pump_buf *buf;
  if(splice_available == 0)
    size = (signed int)(sizeof(struct iv_list_head) /*16ul*/  + (unsigned long int)4096);

  else
    size = (signed int)sizeof(struct iv_fd_pump_buf) /*24ul*/ ;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)size);
  buf = (struct iv_fd_pump_buf *)return_value_malloc$1;
  signed int return_value_pipe$2;
  if(!(buf == ((struct iv_fd_pump_buf *)NULL)) && !(splice_available == 0))
  {
    return_value_pipe$2=pipe(buf->u.pfd);
    if(!(return_value_pipe$2 >= 0))
    {
      free((void *)buf);
      buf = (struct iv_fd_pump_buf *)(void *)0;
    }

  }

  return buf;
}

// buf_get
// file ../../../src/iv_fd_pump.c line 188
static struct iv_fd_pump_buf * buf_get(void)
{
  struct iv_fd_pump_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_fd_pump_tls_user);
  tinfo = (struct iv_fd_pump_thr_info *)return_value_iv_tls_user_ptr$1;
  struct iv_fd_pump_buf *buf;
  buf=__buf_dequeue(tinfo);
  if(buf == ((struct iv_fd_pump_buf *)NULL))
    buf=buf_alloc();

  return buf;
}

// buf_purge
// file ../../../src/iv_fd_pump.c line 201
static void buf_purge(struct iv_fd_pump_thr_info *tinfo)
{
  struct iv_fd_pump_buf *buf;
  do
  {
    buf=__buf_dequeue(tinfo);
    if(buf == ((struct iv_fd_pump_buf *)NULL))
      break;

    __buf_free(buf);
  }
  while((_Bool)1);
}

// buf_put
// file ../../../src/iv_fd_pump.c line 119
static void buf_put(struct iv_fd_pump_buf *buf, signed int bytes)
{
  struct iv_fd_pump_thr_info *tinfo;
  if(!(bytes == 0) && !(splice_available == 0))
    __buf_free(buf);

  else
  {
    void *return_value_iv_tls_user_ptr$1;
    return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_fd_pump_tls_user);
    tinfo = (struct iv_fd_pump_thr_info *)return_value_iv_tls_user_ptr$1;
    if(!(tinfo->num_bufs >= 20))
    {
      tinfo->num_bufs = tinfo->num_bufs + 1;
      iv_list_add$link1(&buf->list, &tinfo->bufs);
    }

    else
      __buf_free(buf);
  }
}

// check_splice_available
// file ../../../src/iv_fd_pump.c line 137
static void check_splice_available(void)
{
  struct iv_fd_pump_buf *b0;
  struct iv_fd_pump_buf *b1;
  signed int ret;
  splice_available = 1;
  b0=buf_alloc();
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(b0 == ((struct iv_fd_pump_buf *)NULL))
    splice_available = 0;

  else
  {
    b1=buf_alloc();
    if(b1 == ((struct iv_fd_pump_buf *)NULL))
    {
      __buf_free(b0);
      splice_available = 0;
    }

    else
    {
      signed long int return_value_splice$1;
      return_value_splice$1=splice(b0->u.pfd[(signed long int)0], (signed long int *)(void *)0, b1->u.pfd[(signed long int)1], (signed long int *)(void *)0, (unsigned long int)1, (unsigned int)2);
      ret = (signed int)return_value_splice$1;
      if(!(ret >= 0))
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        buf_put(b1, 0);
        buf_put(b0, 0);
      }

      else
      {
        __buf_free(b0);
        __buf_free(b1);
        splice_available = 0;
      }
    }
  }
}

// conn_pump
// file ../../../test/iv_fd_pump_discard.c line 38
static void conn_pump(void *_conn)
{
  struct connection *conn = (struct connection *)_conn;
  signed int return_value_iv_fd_pump_pump$1;
  return_value_iv_fd_pump_pump$1=iv_fd_pump_pump(&conn->pump);
  if(!(return_value_iv_fd_pump_pump$1 >= 1))
  {
    iv_fd_pump_destroy(&conn->pump);
    iv_fd_unregister(&conn->sock);
    close(conn->sock.fd);
    free((void *)conn);
  }

}

// conn_set_bands
// file ../../../test/iv_fd_pump_discard.c line 52
static void conn_set_bands(void *_conn, signed int pollin, signed int pollout)
{
  struct connection *conn = (struct connection *)_conn;
  iv_fd_set_handler_in(&conn->sock, pollin != 0 ? conn_pump : (void (*)(void *_conn))(void *)0);
  if(!(pollout == 0))
    printf("conn_set_bands: pollout is set?!\n");

}

// consider_poll_method
// file ../../../src/iv_fd.c line 81
static void consider_poll_method(struct iv_state *st, char *exclude, struct iv_fd_poll_method *m)
{
  signed int return_value_method_is_excluded$1;
  if(method == ((struct iv_fd_poll_method *)NULL))
  {
    return_value_method_is_excluded$1=method_is_excluded(exclude, m->name);
    if(return_value_method_is_excluded$1 == 0)
    {
      signed int return_value;
      return_value=m->init(st);
      if(return_value >= 0)
        method = m;

    }

  }

}

// event_rx_off
// file ../../../src/iv_event_private.h line 32
static inline void event_rx_off(struct iv_state *st)
{
  method->event_rx_off(st);
}

// event_rx_on
// file ../../../src/iv_event_private.h line 24
static inline signed int event_rx_on(struct iv_state *st)
{
  signed int return_value;
  if(!(method->event_rx_on == ((signed int (*)(struct iv_state *))NULL)))
  {
    return_value=method->event_rx_on(st);
    return return_value;
  }

  else
    return -1;
}

// event_send
// file ../../../src/iv_event_private.h line 37
static inline void event_send(struct iv_state *dest)
{
  method->event_send(dest);
}

// find_reference
// file ../../../src/iv_avl.c line 220
static struct iv_avl_node ** find_reference(struct iv_avl_tree *tree, struct iv_avl_node *an)
{
  if(!(an->parent == ((struct iv_avl_node *)NULL)))
  {
    if(an->parent->left == an)
      return &an->parent->left;

    else
      return &an->parent->right;
  }

  else
    return &tree->root;
}

// free_ratnode
// file ../../../src/iv_timer.c line 153
static void free_ratnode(struct ratnode *node, signed int depth)
{
  if(!(depth == 0))
  {
    signed int i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      if(node->child[(signed long int)i] == NULL)
        break;

      free_ratnode((struct ratnode *)node->child[(signed long int)i], depth - 1);
    }
  }

  free((void *)node);
}

// get_thread_id
// file ../../../src/iv_thread_posix.c line 47
static unsigned long int get_thread_id(void)
{
  unsigned long int thread_id;
  signed long int return_value_syscall$1;
  return_value_syscall$1=syscall((signed long int)186);
  thread_id = (unsigned long int)return_value_syscall$1;
  return thread_id;
}

// got_connection
// file ../../../test/iv_fd_pump_discard.c line 64
static void got_connection(void *_dummy)
{
  struct sockaddr_in addr;
  struct connection *conn;
  unsigned int addrlen;
  signed int ret;
  addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  ret=accept(listening_socket.fd, (struct sockaddr *)&addr, &addrlen);
  if(ret >= 0)
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct connection) /*184ul*/ );
    conn = (struct connection *)return_value_malloc$1;
    if(conn == ((struct connection *)NULL))
    {
      fprintf(stderr, "memory squeeze\n");
      abort();
    }

    IV_FD_INIT(&conn->sock);
    conn->sock.fd = ret;
    conn->sock.cookie = (void *)conn;
    iv_fd_register(&conn->sock);
    IV_FD_PUMP_INIT(&conn->pump);
    conn->pump.from_fd = ret;
    conn->pump.to_fd = devnull;
    conn->pump.cookie = (void *)conn;
    conn->pump.set_bands = conn_set_bands;
    conn->pump.flags = (unsigned int)0;
    iv_fd_pump_init(&conn->pump);
  }

}

// grab_eventfd
// file ../../../src/iv_event_raw_posix.c line 40
static signed int grab_eventfd(void)
{
  signed int fd;
  fd=eventfd((unsigned int)0, 2048 | 524288);
  signed int *return_value___errno_location$1;
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 22))
    {
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 38))
        perror("eventfd");

    }

    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    return -(*return_value___errno_location$3);
  }

  return fd;
}

// height
// file ../../../src/iv_avl.c line 25
static signed int height(struct iv_avl_node *an)
{
  signed int tmp_if_expr$1;
  if(!(an == ((struct iv_avl_node *)NULL)))
    tmp_if_expr$1 = (signed int)an->height;

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// iv_avl_tree_delete
// file ../../../src/iv_avl.c line 384
void iv_avl_tree_delete(struct iv_avl_tree *tree, struct iv_avl_node *an)
{
  struct iv_avl_node *p;
  _Bool tmp_if_expr$1;
  if(an->left == ((struct iv_avl_node *)NULL))
    tmp_if_expr$1 = an->right == (struct iv_avl_node *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    p=iv_avl_tree_delete_leaf(tree, an);

  else
    p=iv_avl_tree_delete_nonleaf(tree, an);
  rebalance_path(tree, p);
}

// iv_avl_tree_delete_leaf
// file ../../../src/iv_avl.c line 307
static struct iv_avl_node * iv_avl_tree_delete_leaf(struct iv_avl_tree *tree, struct iv_avl_node *an)
{
  replace_reference(tree, an, (struct iv_avl_node *)(void *)0);
  return an->parent;
}

// iv_avl_tree_delete_nonleaf
// file ../../../src/iv_avl.c line 319
static struct iv_avl_node * iv_avl_tree_delete_nonleaf(struct iv_avl_tree *tree, struct iv_avl_node *an)
{
  struct iv_avl_node *victim;
  struct iv_avl_node *p;
  signed int return_value_height$1;
  return_value_height$1=height(an->left);
  signed int return_value_height$2;
  return_value_height$2=height(an->right);
  if(!(return_value_height$2 >= return_value_height$1))
  {
    victim = an->left;
    for( ; !(victim->right == ((struct iv_avl_node *)NULL)); victim = victim->right)
      ;
    replace_reference(tree, victim, victim->left);
    if(!(victim->left == ((struct iv_avl_node *)NULL)))
      victim->left->parent = victim->parent;

  }

  else
  {
    victim = an->right;
    for( ; !(victim->left == ((struct iv_avl_node *)NULL)); victim = victim->left)
      ;
    replace_reference(tree, victim, victim->right);
    if(!(victim->right == ((struct iv_avl_node *)NULL)))
      victim->right->parent = victim->parent;

  }
  p = victim->parent;
  if(p == an)
    p = victim;

  replace_reference(tree, an, victim);
  victim->left = an->left;
  victim->right = an->right;
  victim->parent = an->parent;
  victim->height = an->height;
  if(!(victim->left == ((struct iv_avl_node *)NULL)))
    victim->left->parent = victim;

  if(!(victim->right == ((struct iv_avl_node *)NULL)))
    victim->right->parent = victim;

  return p;
}

// iv_avl_tree_insert
// file ../../../src/iv_avl.c line 265
signed int iv_avl_tree_insert(struct iv_avl_tree *tree, struct iv_avl_node *an)
{
  struct iv_avl_node *p;
  struct iv_avl_node **pp;
  p = (struct iv_avl_node *)(void *)0;
  pp = &tree->root;
  if(!(*pp == ((struct iv_avl_node *)NULL)))
  {
    signed int ret;
    p = *pp;
    ret=tree->compare(an, p);
    if(!(ret >= 0))
      pp = &p->left;

    else
      if(ret >= 1)
        pp = &p->right;

      else
        return -1;
  }

  an->left = (struct iv_avl_node *)(void *)0;
  an->right = (struct iv_avl_node *)(void *)0;
  an->parent = p;
  an->height = (unsigned char)1;
  *pp = an;
  rebalance_path(tree, p);
  return 0;
}

// iv_avl_tree_next
// file ../../../src/iv_avl.c line 396
struct iv_avl_node * iv_avl_tree_next(struct iv_avl_node *an)
{
  struct iv_avl_node *p;
  if(!(an->right == ((struct iv_avl_node *)NULL)))
  {
    an = an->right;
    for( ; !(an->left == ((struct iv_avl_node *)NULL)); an = an->left)
      ;
    return an;
  }

  else
  {
    p = an->parent;
    for( ; !(p == ((struct iv_avl_node *)NULL)); p = an->parent)
    {
      if(!(an == p->right))
        break;

      an = p;
    }
    return p;
  }
}

// iv_avl_tree_prev
// file ../../../src/iv_avl.c line 417
struct iv_avl_node * iv_avl_tree_prev(struct iv_avl_node *an)
{
  struct iv_avl_node *p;
  if(!(an->left == ((struct iv_avl_node *)NULL)))
  {
    an = an->left;
    for( ; !(an->right == ((struct iv_avl_node *)NULL)); an = an->right)
      ;
    return an;
  }

  else
  {
    p = an->parent;
    for( ; !(p == ((struct iv_avl_node *)NULL)); p = an->parent)
    {
      if(!(an == p->left))
        break;

      an = p;
    }
    return p;
  }
}

// iv_deinit
// file ../src/include/iv.h line 46
void iv_deinit(void)
{
  struct iv_state *st;
  st=iv_get_state$link5();
  __iv_deinit(st);
}

// iv_event_post
// file ../../../src/iv_event.c line 156
void iv_event_post(struct iv_event *this)
{
  struct iv_event_thr_info *tinfo = (struct iv_event_thr_info *)this->tinfo;
  signed int post = 0;
  mutex_lock(&tinfo->list_mutex);
  signed int return_value_iv_list_empty$2;
  return_value_iv_list_empty$2=iv_list_empty(&this->list);
  if(!(return_value_iv_list_empty$2 == 0))
  {
    signed int return_value_iv_list_empty$1;
    return_value_iv_list_empty$1=iv_list_empty(&tinfo->pending_events);
    if(!(return_value_iv_list_empty$1 == 0))
      post = 1;

    iv_list_add_tail(&this->list, &tinfo->pending_events);
  }

  mutex_unlock(&tinfo->list_mutex);
  if(!(post == 0))
  {
    if(iv_event_use_event_raw == 0)
      event_send(tinfo->u.st);

    else
      iv_event_raw_post(&tinfo->u.ier);
  }

}

// iv_event_raw_got_event
// file ../../../src/iv_event_raw_posix.c line 64
static void iv_event_raw_got_event(void *_this)
{
  struct iv_event_raw *this = (struct iv_event_raw *)_this;
  signed int toread;
  char buf[1024l];
  signed int ret;
  toread = (signed int)(eventfd_unavailable != 0 ? sizeof(char [1024l]) /*1024ul*/  : (unsigned long int)8);
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_read$3;
    return_value_read$3=read(this->event_rfd.fd, (void *)buf, (unsigned long int)toread);
    ret = (signed int)return_value_read$3;
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$7;
  if(!(ret >= 1))
  {
    if(ret == 0)
      iv_fatal("iv_event_raw: reading from event fd returned zero");

    else
    {
      return_value___errno_location$7=__errno_location();
      if(!(*return_value___errno_location$7 == 11))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        iv_fatal("iv_event_raw: reading from event fd returned error %d[%s]", *return_value___errno_location$4, return_value_strerror$6);
      }

    }
    goto __CPROVER_DUMP_L7;
  }

  this->handler(this->cookie);

__CPROVER_DUMP_L7:
  ;
}

// iv_event_raw_post
// file ../../../src/include/iv_event_raw.h line 48
void iv_event_raw_post(struct iv_event_raw *this)
{
  if(!(eventfd_unavailable == 0))
    write(this->event_wfd, (const void *)"", (unsigned long int)1);

  else
  {
    unsigned long int x = (unsigned long int)1;
    write(this->event_wfd, (const void *)&x, sizeof(unsigned long int) /*8ul*/ );
  }
}

// iv_event_raw_register
// file ../../../src/include/iv_event_raw.h line 46
signed int iv_event_raw_register(struct iv_event_raw *this)
{
  signed int fd[2l];
  if(eventfd_unavailable == 0)
  {
    signed int ret;
    ret=grab_eventfd();
    if(!(ret >= 0))
    {
      if(!(ret == -38) && !(ret == -22))
        return -1;

      eventfd_unavailable = 1;
    }

    else
    {
      fd[(signed long int)0] = ret;
      fd[(signed long int)1] = ret;
    }
  }

  if(!(eventfd_unavailable == 0))
  {
    signed int return_value_pipe$1;
    return_value_pipe$1=pipe(fd);
    if(!(return_value_pipe$1 >= 0))
    {
      perror("pipe");
      return -1;
    }

  }

  IV_FD_INIT(&this->event_rfd);
  this->event_rfd.fd = fd[(signed long int)0];
  this->event_rfd.cookie = (void *)this;
  this->event_rfd.handler_in = iv_event_raw_got_event;
  iv_fd_register(&this->event_rfd);
  this->event_wfd = fd[(signed long int)1];
  if(!(eventfd_unavailable == 0))
  {
    iv_fd_set_cloexec(fd[(signed long int)1]);
    iv_fd_set_nonblock(fd[(signed long int)1]);
  }

  return 0;
}

// iv_event_raw_unregister
// file ../../../src/include/iv_event_raw.h line 47
void iv_event_raw_unregister(struct iv_event_raw *this)
{
  iv_fd_unregister(&this->event_rfd);
  close(this->event_rfd.fd);
  if(!(eventfd_unavailable == 0))
    close(this->event_wfd);

}

// iv_event_register
// file ../../../src/iv_event.c line 104
signed int iv_event_register(struct iv_event *this)
{
  struct iv_event_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_event_tls_user);
  tinfo = (struct iv_event_thr_info *)return_value_iv_tls_user_ptr$1;
  signed int tmp_post$3 = tinfo->event_count;
  tinfo->event_count = tinfo->event_count + 1;
  if(tmp_post$3 == 0)
  {
    if(iv_event_use_event_raw == 0)
    {
      struct iv_state *st;
      st=iv_get_state();
      signed int return_value_event_rx_on$2;
      return_value_event_rx_on$2=event_rx_on(st);
      if(return_value_event_rx_on$2 == 0)
        tinfo->u.st = st;

      else
        iv_event_use_event_raw = 1;
    }

    if(!(iv_event_use_event_raw == 0))
    {
      signed int ret;
      ret=iv_event_raw_register(&tinfo->u.ier);
      if(!(ret == 0))
      {
        tinfo->event_count = tinfo->event_count - 1;
        return ret;
      }

    }

  }

  this->tinfo = (void *)tinfo;
  do
  {
    (&this->list)->next = &this->list;
    (&this->list)->prev = &this->list;
  }
  while((_Bool)0);
  return 0;
}

// iv_event_run_pending_events
// file ../../../src/iv_event.c line 99
void iv_event_run_pending_events(void)
{
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_event_tls_user);
  __iv_event_run_pending_events(return_value_iv_tls_user_ptr$1);
}

// iv_event_tls_deinit_thread
// file ../../../src/iv_event.c line 80
static void iv_event_tls_deinit_thread(void *_tinfo)
{
  struct iv_event_thr_info *tinfo = (struct iv_event_thr_info *)_tinfo;
  mutex_destroy(&tinfo->list_mutex);
}

// iv_event_tls_init_thread
// file ../../../src/iv_event.c line 65
static void iv_event_tls_init_thread(void *_tinfo)
{
  struct iv_event_thr_info *tinfo = (struct iv_event_thr_info *)_tinfo;
  tinfo->event_count = 0;
  IV_EVENT_RAW_INIT(&tinfo->u.ier);
  tinfo->u.ier.cookie = (void *)tinfo;
  tinfo->u.ier.handler = __iv_event_run_pending_events;
  mutex_init(&tinfo->list_mutex);
  do
  {
    (&tinfo->pending_events)->next = &tinfo->pending_events;
    (&tinfo->pending_events)->prev = &tinfo->pending_events;
  }
  while((_Bool)0);
}

// iv_event_unregister
// file ../../../src/iv_event.c line 136
void iv_event_unregister(struct iv_event *this)
{
  struct iv_event_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_event_tls_user);
  tinfo = (struct iv_event_thr_info *)return_value_iv_tls_user_ptr$1;
  signed int return_value_iv_list_empty$2;
  return_value_iv_list_empty$2=iv_list_empty(&this->list);
  if(return_value_iv_list_empty$2 == 0)
  {
    mutex_lock(&tinfo->list_mutex);
    iv_list_del(&this->list);
    mutex_unlock(&tinfo->list_mutex);
  }

  tinfo->event_count = tinfo->event_count - 1;
  if(tinfo->event_count == 0)
  {
    if(iv_event_use_event_raw == 0)
    {
      event_rx_off(tinfo->u.st);
      tinfo->u.st = (struct iv_state *)(void *)0;
    }

    else
      iv_event_raw_unregister(&tinfo->u.ier);
  }

}

// iv_fatal
// file ../../../src/iv_fatal.c line 41
void iv_fatal(const char *fmt, ...)
{
  void **ap;
  char msg[1024l];
  ap = (void **)&fmt;
  vsnprintf(msg, sizeof(char [1024l]) /*1024ul*/ , fmt, ap);
  ap = ((void **)NULL);
  msg[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  if(!(fatal_msg_handler == ((void (*)(const char *))NULL)))
    fatal_msg_handler(msg);

  else
    iv_fatal_default_handler(msg);
  abort();
}

// iv_fatal_default_handler
// file ../../../src/iv_fatal.c line 28
static void iv_fatal_default_handler(const char *msg)
{
  syslog(2, "%s", msg);
}

// iv_fd_deinit
// file ../../../src/iv_fd.c line 135
void iv_fd_deinit(struct iv_state *st)
{
  method->deinit(st);
}

// iv_fd_epoll_deinit
// file ../../../src/iv_fd_epoll.c line 176
static void iv_fd_epoll_deinit(struct iv_state *st)
{
  close(st->u.epoll.epoll_fd);
}

// iv_fd_epoll_flush_one
// file ../../../src/iv_fd_epoll.c line 99
static void iv_fd_epoll_flush_one(struct iv_state *st, struct iv_fd_ *fd)
{
  signed int return_value___iv_fd_epoll_flush_one$4;
  return_value___iv_fd_epoll_flush_one$4=__iv_fd_epoll_flush_one(st, fd);
  if(!(return_value___iv_fd_epoll_flush_one$4 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    iv_fatal("iv_fd_epoll_flush_one: got error %d[%s]", *return_value___errno_location$1, return_value_strerror$3);
  }

}

// iv_fd_epoll_flush_pending
// file ../../../src/iv_fd_epoll.c line 107
static void iv_fd_epoll_flush_pending(struct iv_state *st)
{
  signed int return_value_iv_list_empty$1;
  struct iv_fd_ *tmp_statement_expression$2;
  do
  {
    return_value_iv_list_empty$1=iv_list_empty$link6(&st->u.epoll.notify);
    if(!(return_value_iv_list_empty$1 == 0))
      break;

    struct iv_fd_ *fd;
    const struct iv_list_head *__ptr = st->u.epoll.notify.next;
    tmp_statement_expression$2 = (struct iv_fd_ *)((char *)__ptr - (signed long int)&((struct iv_fd_ *)0)->list_notify);
    fd = tmp_statement_expression$2;
    iv_fd_epoll_flush_one(st, fd);
  }
  while((_Bool)1);
}

// iv_fd_epoll_init
// file ../../../src/iv_fd_epoll.c line 29
static signed int iv_fd_epoll_init(struct iv_state *st)
{
  signed int fd;
  do
  {
    (&st->u.epoll.notify)->next = &st->u.epoll.notify;
    (&st->u.epoll.notify)->prev = &st->u.epoll.notify;
  }
  while((_Bool)0);
  fd=epoll_create1(524288);
  signed int *return_value___errno_location$1;
  if(fd >= 0)
  {
    st->u.epoll.epoll_fd = fd;
    return 0;
  }

  else
  {
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 38))
      return -1;

  }
  fd=epoll_create(maxfd);
  if(!(fd >= 0))
    return -1;

  else
  {
    iv_fd_set_cloexec(fd);
    st->u.epoll.epoll_fd = fd;
    return 0;
  }
}

// iv_fd_epoll_notify_fd
// file ../../../src/iv_fd_epoll.c line 164
static void iv_fd_epoll_notify_fd(struct iv_state *st, struct iv_fd_ *fd)
{
  iv_list_del_init$link4(&fd->list_notify);
  if(!(fd->registered_bands == fd->wanted_bands))
    iv_list_add_tail$link7(&fd->list_notify, &st->u.epoll.notify);

}

// iv_fd_epoll_notify_fd_sync
// file ../../../src/iv_fd_epoll.c line 171
static signed int iv_fd_epoll_notify_fd_sync(struct iv_state *st, struct iv_fd_ *fd)
{
  signed int return_value___iv_fd_epoll_flush_one$1;
  return_value___iv_fd_epoll_flush_one$1=__iv_fd_epoll_flush_one(st, fd);
  return return_value___iv_fd_epoll_flush_one$1;
}

// iv_fd_epoll_poll
// file ../../../src/iv_fd_epoll.c line 119
static void iv_fd_epoll_poll(struct iv_state *st, struct iv_list_head *active, struct timespec *to)
{
  signed long int iv_fd_epoll_poll$array_size0;
  signed int tmp_if_expr$1;
  if(!(st->numfds == 0))
    tmp_if_expr$1 = st->numfds;

  else
    tmp_if_expr$1 = 1;
  iv_fd_epoll_poll$array_size0 = (signed long int)tmp_if_expr$1;
  struct epoll_event batch[iv_fd_epoll_poll$array_size0];
  signed int msec;
  signed int ret;
  signed int i;
  iv_fd_epoll_flush_pending(st);
  msec = (signed int)((signed long int)1000 * to->tv_sec + (to->tv_nsec + (signed long int)999999) / (signed long int)1000000);
  ret=epoll_wait(st->u.epoll.epoll_fd, batch, (signed int)((12ul * (unsigned long int)iv_fd_epoll_poll$array_size0) / sizeof(struct epoll_event) /*12ul*/ ), msec);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 4)
      goto __CPROVER_DUMP_L10;

    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    iv_fatal("iv_fd_epoll_poll: got error %d[%s]", *return_value___errno_location$3, return_value_strerror$5);
  }

  i = 0;
  for( ; !(i >= ret); i = i + 1)
  {
    struct iv_fd_ *fd;
    unsigned int events;
    fd = (struct iv_fd_ *)batch[(signed long int)i].data.ptr;
    events = batch[(signed long int)i].events;
    if(!((25u & events) == 0u))
      iv_fd_make_ready(active, fd, 1);

    if(!((28u & events) == 0u))
      iv_fd_make_ready(active, fd, 2);

    if(!((24u & events) == 0u))
      iv_fd_make_ready(active, fd, 4);

  }

__CPROVER_DUMP_L10:
  ;
}

// iv_fd_epoll_unregister_fd
// file ../../../src/iv_fd_epoll.c line 158
static void iv_fd_epoll_unregister_fd(struct iv_state *st, struct iv_fd_ *fd)
{
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link6(&fd->list_notify);
  if(return_value_iv_list_empty$1 == 0)
    iv_fd_epoll_flush_one(st, fd);

}

// iv_fd_init
// file ../../../src/iv_fd.c line 124
void iv_fd_init(struct iv_state *st)
{
  signed int return_value;
  if(method == ((struct iv_fd_poll_method *)NULL))
    iv_fd_init_first_thread(st);

  else
  {
    return_value=method->init(st);
    if(!(return_value >= 0))
      iv_fatal("iv_init: can't initialize event dispatcher");

  }
  st->numfds = 0;
  st->handled_fd = (struct iv_fd_ *)(void *)0;
}

// iv_fd_init_first_thread
// file ../../../src/iv_fd.c line 90
static void iv_fd_init_first_thread(struct iv_state *st)
{
  signed int euid;
  char *exclude;
  unsigned int return_value_geteuid$1;
  return_value_geteuid$1=geteuid();
  euid = (signed int)return_value_geteuid$1;
  signal(13, (void (*)(signed int))1);
  signal(23, (void (*)(signed int))1);
  sanitise_nofile_rlimit(euid);
  exclude=getenv("IV_EXCLUDE_POLL_METHOD");
  unsigned int return_value_getuid$2;
  if(!(exclude == ((char *)NULL)))
  {
    return_value_getuid$2=getuid();
    if(!(return_value_getuid$2 == (unsigned int)euid))
      exclude = (char *)(void *)0;

  }

  consider_poll_method(st, exclude, &iv_fd_poll_method_epoll);
  consider_poll_method(st, exclude, &iv_fd_poll_method_poll);
  if(method == ((struct iv_fd_poll_method *)NULL))
    iv_fatal("iv_init: can't find suitable event dispatcher");

}

// iv_fd_make_ready
// file ../../../src/iv_fd.c line 171
void iv_fd_make_ready(struct iv_list_head *active, struct iv_fd_ *fd, signed int bands)
{
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link3(&fd->list_active);
  if(!(return_value_iv_list_empty$1 == 0))
  {
    fd->ready_bands = (unsigned int)0;
    iv_list_add_tail$link4(&fd->list_active, active);
  }

  fd->ready_bands = (unsigned int)fd->ready_bands | (unsigned int)bands;
}

// iv_fd_poll_and_run
// file ../../../src/iv_fd.c line 140
void iv_fd_poll_and_run(struct iv_state *st, struct timespec *to)
{
  struct iv_list_head active;
  __iv_invalidate_now(st);
  do
  {
    (&active)->next = &active;
    (&active)->prev = &active;
  }
  while((_Bool)0);
  method->poll(st, &active, to);
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link3(&active);
  struct iv_fd_ *tmp_statement_expression$2;
  if(return_value_iv_list_empty$1 == 0)
  {
    struct iv_fd_ *fd;
    const struct iv_list_head *__ptr = active.next;
    tmp_statement_expression$2 = (struct iv_fd_ *)((char *)__ptr - (signed long int)&((struct iv_fd_ *)0)->list_active);
    fd = tmp_statement_expression$2;
    iv_list_del_init$link3(&fd->list_active);
    st->handled_fd = fd;
    if(!((4 & (signed int)fd->ready_bands) == 0))
    {
      if(!(fd->handler_err == ((void (*)(void *))NULL)))
        fd->handler_err(fd->cookie);

    }

    if(!(st->handled_fd == ((struct iv_fd_ *)NULL)))
    {
      if(!((1 & (signed int)fd->ready_bands) == 0))
      {
        if(!(fd->handler_in == ((void (*)(void *))NULL)))
          fd->handler_in(fd->cookie);

      }

    }

    if(!(st->handled_fd == ((struct iv_fd_ *)NULL)))
    {
      if(!((2 & (signed int)fd->ready_bands) == 0))
      {
        if(!(fd->handler_out == ((void (*)(void *))NULL)))
          fd->handler_out(fd->cookie);

      }

    }

  }

}

// iv_fd_poll_deinit
// file ../../../src/iv_fd_poll.c line 160
static void iv_fd_poll_deinit(struct iv_state *st)
{
  free((void *)st->u.poll.fds);
  free((void *)st->u.poll.pfds);
}

// iv_fd_poll_init
// file ../../../src/iv_fd_poll.c line 28
static signed int iv_fd_poll_init(struct iv_state *st)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)maxfd * sizeof(struct pollfd) /*8ul*/ );
  st->u.poll.pfds = (struct pollfd *)return_value_malloc$1;
  if(st->u.poll.pfds == ((struct pollfd *)NULL))
    return -1;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)maxfd * sizeof(struct iv_fd_ *) /*8ul*/ );
    st->u.poll.fds = (struct iv_fd_ **)return_value_malloc$2;
    if(st->u.poll.fds == ((struct iv_fd_ **)NULL))
    {
      free((void *)st->u.poll.pfds);
      return -1;
    }

    else
    {
      st->u.poll.num_regd_fds = 0;
      return 0;
    }
  }
}

// iv_fd_poll_notify_fd
// file ../../../src/iv_fd_poll.c line 107
static void iv_fd_poll_notify_fd(struct iv_state *st, struct iv_fd_ *fd)
{
  _Bool tmp_if_expr$5;
  signed int tmp_post$1;
  _Bool tmp_if_expr$4;
  if(!(fd->registered_bands == fd->wanted_bands))
  {
    if(fd->u.index == -1)
      tmp_if_expr$5 = fd->wanted_bands != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
    {
      tmp_post$1 = st->u.poll.num_regd_fds;
      st->u.poll.num_regd_fds = st->u.poll.num_regd_fds + 1;
      fd->u.index = tmp_post$1;
      (st->u.poll.pfds + (signed long int)fd->u.index)->fd = fd->fd;
      signed int return_value_bits_to_poll_mask$2;
      return_value_bits_to_poll_mask$2=bits_to_poll_mask((signed int)fd->wanted_bands);
      (st->u.poll.pfds + (signed long int)fd->u.index)->events = (signed short int)return_value_bits_to_poll_mask$2;
      st->u.poll.fds[(signed long int)fd->u.index] = fd;
    }

    else
    {
      if(!(fd->u.index == -1))
        tmp_if_expr$4 = !(fd->wanted_bands != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        st->u.poll.num_regd_fds = st->u.poll.num_regd_fds - 1;
        if(!(fd->u.index == st->u.poll.num_regd_fds))
        {
          struct iv_fd_ *last;
          st->u.poll.pfds[(signed long int)fd->u.index] = st->u.poll.pfds[(signed long int)st->u.poll.num_regd_fds];
          last = st->u.poll.fds[(signed long int)st->u.poll.num_regd_fds];
          last->u.index = fd->u.index;
          st->u.poll.fds[(signed long int)fd->u.index] = last;
        }

        fd->u.index = -1;
      }

      else
      {
        signed int return_value_bits_to_poll_mask$3;
        return_value_bits_to_poll_mask$3=bits_to_poll_mask((signed int)fd->wanted_bands);
        (st->u.poll.pfds + (signed long int)fd->u.index)->events = (signed short int)return_value_bits_to_poll_mask$3;
      }
    }
    fd->registered_bands = (unsigned int)fd->wanted_bands;
  }

}

// iv_fd_poll_notify_fd_sync
// file ../../../src/iv_fd_poll.c line 140
static signed int iv_fd_poll_notify_fd_sync(struct iv_state *st, struct iv_fd_ *fd)
{
  struct pollfd pfd;
  signed int ret;
  pfd.fd = fd->fd;
  pfd.events = (signed short int)(0x001 | 0x004 | 0x010);
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    ret=poll(&pfd, (unsigned long int)1, 0);
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  if(!((0x020 & (signed int)pfd.revents) == 0) || !(ret >= 0))
    return -1;

  else
  {
    iv_fd_poll_notify_fd(st, fd);
    return 0;
  }
}

// iv_fd_poll_poll
// file ../../../src/iv_fd_poll.c line 45
static void iv_fd_poll_poll(struct iv_state *st, struct iv_list_head *active, struct timespec *to)
{
  signed int ret;
  signed int i;
  ret=poll(st->u.poll.pfds, (unsigned long int)st->u.poll.num_regd_fds, (signed int)((signed long int)1000 * to->tv_sec + (to->tv_nsec + (signed long int)999999) / (signed long int)1000000));
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 4)
      goto __CPROVER_DUMP_L8;

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    iv_fatal("iv_fd_poll_poll: got error %d[%s]", *return_value___errno_location$2, return_value_strerror$4);
  }

  i = 0;
  for( ; !(i >= st->u.poll.num_regd_fds); i = i + 1)
  {
    struct iv_fd_ *fd;
    signed int revents;
    fd = st->u.poll.fds[(signed long int)i];
    revents = (signed int)(st->u.poll.pfds + (signed long int)i)->revents;
    if(!((25 & revents) == 0))
      iv_fd_make_ready(active, fd, 1);

    if(!((28 & revents) == 0))
      iv_fd_make_ready(active, fd, 2);

    if(!((24 & revents) == 0))
      iv_fd_make_ready(active, fd, 4);

  }

__CPROVER_DUMP_L8:
  ;
}

// iv_fd_poll_register_fd
// file ../../../src/iv_fd_poll.c line 87
static void iv_fd_poll_register_fd(struct iv_state *st, struct iv_fd_ *fd)
{
  fd->u.index = -1;
}

// iv_fd_pump_buf
// file ../../../src/iv_fd_pump.c line 211
static struct iv_fd_pump_buf * iv_fd_pump_buf(struct iv_fd_pump *ip)
{
  return (struct iv_fd_pump_buf *)ip->buf;
}

// iv_fd_pump_destroy
// file ../../../src/include/iv_fd_pump.h line 48
void iv_fd_pump_destroy(struct iv_fd_pump *ip)
{
  struct iv_fd_pump_buf *buf;
  buf=iv_fd_pump_buf(ip);
  if(!(ip->saw_fin == 2))
    ip->set_bands(ip->cookie, 0, 0);

  if(!(buf == ((struct iv_fd_pump_buf *)NULL)))
  {
    buf_put(buf, ip->bytes);
    ip->buf = (void *)0;
  }

}

// iv_fd_pump_init
// file ../../../src/include/iv_fd_pump.h line 47
void iv_fd_pump_init(struct iv_fd_pump *ip)
{
  if(splice_available == -1)
    check_splice_available();

  ip->buf = (void *)0;
  ip->bytes = 0;
  ip->full = 0;
  ip->saw_fin = 0;
  ip->set_bands(ip->cookie, 1, 0);
}

// iv_fd_pump_is_done
// file ../../../src/iv_fd_pump.c line 376
signed int iv_fd_pump_is_done(struct iv_fd_pump *ip)
{
  return (signed int)!(!(ip->saw_fin == 2));
}

// iv_fd_pump_pump
// file ../../../src/include/iv_fd_pump.h line 49
signed int iv_fd_pump_pump(struct iv_fd_pump *ip)
{
  signed int ret;
  ret=__iv_fd_pump_pump(ip);
  _Bool tmp_if_expr$1;
  if(!(ret >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(ip->bytes != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    struct iv_fd_pump_buf *buf;
    buf=iv_fd_pump_buf(ip);
    if(!(buf == ((struct iv_fd_pump_buf *)NULL)))
    {
      buf_put(buf, ip->bytes);
      ip->buf = (void *)0;
    }

  }

  return ret;
}

// iv_fd_pump_tls_deinit_thread
// file ../../../src/iv_fd_pump.c line 48
static void iv_fd_pump_tls_deinit_thread(void *_tinfo)
{
  struct iv_fd_pump_thr_info *tinfo = (struct iv_fd_pump_thr_info *)_tinfo;
  buf_purge(tinfo);
}

// iv_fd_pump_tls_init_thread
// file ../../../src/iv_fd_pump.c line 40
static void iv_fd_pump_tls_init_thread(void *_tinfo)
{
  struct iv_fd_pump_thr_info *tinfo = (struct iv_fd_pump_thr_info *)_tinfo;
  tinfo->num_bufs = 0;
  do
  {
    (&tinfo->bufs)->next = &tinfo->bufs;
    (&tinfo->bufs)->prev = &tinfo->bufs;
  }
  while((_Bool)0);
}

// iv_fd_pump_try_input
// file ../../../src/iv_fd_pump.c line 242
static signed int iv_fd_pump_try_input(struct iv_fd_pump *ip)
{
  struct iv_fd_pump_buf *buf;
  buf=iv_fd_pump_buf(ip);
  signed int ret;
  if(buf == ((struct iv_fd_pump_buf *)NULL))
  {
    buf=buf_get();
    if(buf == ((struct iv_fd_pump_buf *)NULL))
      return -1;

    ip->buf = (void *)buf;
  }

  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  while((_Bool)1)
  {
    if(splice_available == 0)
    {
      signed long int return_value_read$3;
      return_value_read$3=read(ip->from_fd, (void *)(buf->u.buf + (signed long int)ip->bytes), (unsigned long int)(4096 - ip->bytes));
      ret = (signed int)return_value_read$3;
    }

    else
    {
      signed long int return_value_splice$4;
      return_value_splice$4=splice(ip->from_fd, (signed long int *)(void *)0, buf->u.pfd[(signed long int)1], (signed long int *)(void *)0, (unsigned long int)1048576, (unsigned int)2);
      ret = (signed int)return_value_splice$4;
    }
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

  }
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    if(!(*return_value___errno_location$5 == 11))
      return -1;

    if(!(splice_available == 0))
    {
      if(!(ip->bytes == 0))
      {
        signed int bytes = 1;
        ioctl(ip->from_fd, (unsigned long int)0x541B, &bytes);
        if(bytes >= 1)
          ip->full = 1;

      }

    }

    return 0;
  }

  if(ret == 0)
  {
    ip->saw_fin = 1;
    if(ip->bytes == 0)
    {
      if(!((1u & ip->flags) == 0u))
        shutdown(ip->to_fd, 1);

      ip->saw_fin = 2;
    }

    return 0;
  }

  else
  {
    ip->bytes = ip->bytes + ret;
    if(splice_available == 0)
    {
      if(ip->bytes == 4096)
        ip->full = 1;

    }

    return 0;
  }
}

// iv_fd_pump_try_output
// file ../../../src/iv_fd_pump.c line 297
static signed int iv_fd_pump_try_output(struct iv_fd_pump *ip)
{
  struct iv_fd_pump_buf *buf;
  buf=iv_fd_pump_buf(ip);
  signed int ret;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  while((_Bool)1)
  {
    if(splice_available == 0)
    {
      signed long int return_value_write$3;
      return_value_write$3=write(ip->to_fd, (const void *)buf->u.buf, (unsigned long int)ip->bytes);
      ret = (signed int)return_value_write$3;
    }

    else
    {
      signed long int return_value_splice$4;
      return_value_splice$4=splice(buf->u.pfd[(signed long int)0], (signed long int *)(void *)0, ip->to_fd, (signed long int *)(void *)0, (unsigned long int)ip->bytes, (unsigned int)0);
      ret = (signed int)return_value_splice$4;
    }
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

  }
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  if(!(ret >= 1))
  {
    if(!(ret >= 0))
    {
      return_value___errno_location$5=__errno_location();
      tmp_if_expr$6 = *return_value___errno_location$5 == 11 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    return tmp_if_expr$6 ? 0 : -1;
  }

  else
  {
    ip->full = 0;
    ip->bytes = ip->bytes - ret;
    if(splice_available == 0)
      memmove((void *)buf->u.buf, (const void *)(buf->u.buf + (signed long int)ret), (unsigned long int)ip->bytes);

    if(ip->bytes == 0)
    {
      if(ip->saw_fin == 1)
      {
        if(!((1u & ip->flags) == 0u))
          shutdown(ip->to_fd, 1);

        ip->saw_fin = 2;
      }

    }

    return 0;
  }
}

// iv_fd_register
// file ../src/include/iv.h line 77
void iv_fd_register(struct iv_fd *_fd)
{
  struct iv_state *st;
  st=iv_get_state$link4();
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  iv_fd_register_prologue(st, fd);
  notify_fd(st, fd);
  iv_fd_register_epilogue(st, fd);
}

// iv_fd_register_epilogue
// file ../../../src/iv_fd.c line 269
static void iv_fd_register_epilogue(struct iv_state *st, struct iv_fd_ *fd)
{
  signed int yes;
  st->numobjs = st->numobjs + 1;
  st->numfds = st->numfds + 1;
  iv_fd_set_cloexec(fd->fd);
  iv_fd_set_nonblock(fd->fd);
  yes = 1;
  setsockopt(fd->fd, 1, 10, (const void *)&yes, (unsigned int)sizeof(signed int) /*4ul*/ );
}

// iv_fd_register_prologue
// file ../../../src/iv_fd.c line 244
static void iv_fd_register_prologue(struct iv_state *st, struct iv_fd_ *fd)
{
  if(!(fd->registered == 0u))
    iv_fatal("iv_fd_register: called with fd which is still registered");

  _Bool tmp_if_expr$1;
  if(!(fd->fd >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = fd->fd >= maxfd ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    iv_fatal("iv_fd_register: called with invalid fd %d (maxfd=%d)", fd->fd, maxfd);

  fd->registered = (unsigned int)1;
  do
  {
    (&fd->list_active)->next = &fd->list_active;
    (&fd->list_active)->prev = &fd->list_active;
  }
  while((_Bool)0);
  fd->ready_bands = (unsigned int)0;
  fd->registered_bands = (unsigned int)0;
  do
  {
    (&fd->list_notify)->next = &fd->list_notify;
    (&fd->list_notify)->prev = &fd->list_notify;
  }
  while((_Bool)0);
  if(!(method->register_fd == ((void (*)(struct iv_state *, struct iv_fd_ *))NULL)))
    method->register_fd(st, fd);

}

// iv_fd_register_try
// file ../../../src/iv_fd.c line 295
signed int iv_fd_register_try(struct iv_fd *_fd)
{
  struct iv_state *st;
  st=iv_get_state$link4();
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  signed int orig_wanted_bands;
  signed int ret;
  iv_fd_register_prologue(st, fd);
  recompute_wanted_flags(fd);
  orig_wanted_bands = (signed int)fd->wanted_bands;
  if(fd->wanted_bands == 0u)
    fd->wanted_bands = (unsigned int)(1 | 2);

  ret=method->notify_fd_sync(st, fd);
  if(!(ret == 0))
  {
    fd->registered = (unsigned int)0;
    if(!(method->unregister_fd == ((void (*)(struct iv_state *, struct iv_fd_ *))NULL)))
      method->unregister_fd(st, fd);

    return ret;
  }

  else
  {
    if(orig_wanted_bands == 0)
    {
      fd->wanted_bands = (unsigned int)0;
      method->notify_fd(st, fd);
    }

    iv_fd_register_epilogue(st, fd);
    return 0;
  }
}

// iv_fd_registered
// file ../../../src/iv_fd.c line 352
signed int iv_fd_registered(struct iv_fd *_fd)
{
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  return (signed int)fd->registered;
}

// iv_fd_set_cloexec
// file ../../../src/iv_fd_private.h line 118
void iv_fd_set_cloexec(signed int fd)
{
  signed int flags;
  flags=fcntl(fd, 1);
  if((1 & flags) == 0)
  {
    flags = flags | 1;
    fcntl(fd, 2, flags);
  }

}

// iv_fd_set_handler_err
// file ../../../src/iv_fd.c line 387
void iv_fd_set_handler_err(struct iv_fd *_fd, void (*handler_err)(void *))
{
  struct iv_state *st;
  st=iv_get_state$link4();
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  if(fd->registered == 0u)
    iv_fatal("iv_fd_set_handler_err: called with fd which is not registered");

  fd->handler_err = handler_err;
  notify_fd(st, fd);
}

// iv_fd_set_handler_in
// file ../src/include/iv.h line 81
void iv_fd_set_handler_in(struct iv_fd *_fd, void (*handler_in)(void *))
{
  struct iv_state *st;
  st=iv_get_state$link4();
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  if(fd->registered == 0u)
    iv_fatal("iv_fd_set_handler_in: called with fd which is not registered");

  fd->handler_in = handler_in;
  notify_fd(st, fd);
}

// iv_fd_set_handler_out
// file ../../../src/iv_fd.c line 373
void iv_fd_set_handler_out(struct iv_fd *_fd, void (*handler_out)(void *))
{
  struct iv_state *st;
  st=iv_get_state$link4();
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  if(fd->registered == 0u)
    iv_fatal("iv_fd_set_handler_out: called with fd which is not registered");

  fd->handler_out = handler_out;
  notify_fd(st, fd);
}

// iv_fd_set_nonblock
// file ../../../src/iv_fd_private.h line 119
void iv_fd_set_nonblock(signed int fd)
{
  signed int flags;
  flags=fcntl(fd, 3);
  if((04000 & flags) == 0)
  {
    flags = flags | 04000;
    fcntl(fd, 4, flags);
  }

}

// iv_fd_unregister
// file ../src/include/iv.h line 79
void iv_fd_unregister(struct iv_fd *_fd)
{
  struct iv_state *st;
  st=iv_get_state$link4();
  struct iv_fd_ *fd = (struct iv_fd_ *)_fd;
  if(fd->registered == 0u)
    iv_fatal("iv_fd_unregister: called with fd which is not registered");

  fd->registered = (unsigned int)0;
  iv_list_del$link2(&fd->list_active);
  notify_fd(st, fd);
  if(!(method->unregister_fd == ((void (*)(struct iv_state *, struct iv_fd_ *))NULL)))
    method->unregister_fd(st, fd);

  st->numobjs = st->numobjs - 1;
  st->numfds = st->numfds - 1;
  if(st->handled_fd == fd)
    st->handled_fd = (struct iv_fd_ *)(void *)0;

}

// iv_get_soonest_timeout
// file ../../../src/iv_timer.c line 107
signed int iv_get_soonest_timeout(struct iv_state *st, struct timespec *to)
{
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(!(st->num_timers == 0))
  {
    struct iv_timer_ *t;
    struct iv_timer_ **return_value_iv_timer_get_node$1;
    return_value_iv_timer_get_node$1=iv_timer_get_node(st, 1);
    t = *return_value_iv_timer_get_node$1;
    iv_validate_now();
    to->tv_sec = t->expires.tv_sec - st->time.tv_sec;
    to->tv_nsec = t->expires.tv_nsec - st->time.tv_nsec;
    if(!(to->tv_nsec >= 0l))
    {
      to->tv_sec = to->tv_sec - 1l;
      to->tv_nsec = to->tv_nsec + (signed long int)1000000000;
    }

    if(!(to->tv_sec >= 0l))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(to->tv_sec == 0l)
        tmp_if_expr$2 = to->tv_nsec == (signed long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    return (signed int)!(!tmp_if_expr$3);
  }

  to->tv_sec = (signed long int)3600;
  to->tv_nsec = (signed long int)0;
  return 0;
}

// iv_get_state
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state(void)
{
  return __st;
}

// iv_get_state$link1
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link1(void)
{
  return __st;
}

// iv_get_state$link2
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link2(void)
{
  return __st;
}

// iv_get_state$link3
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link3(void)
{
  return __st;
}

// iv_get_state$link4
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link4(void)
{
  return __st;
}

// iv_get_state$link5
// file ../../../src/iv_private.h line 105
static inline struct iv_state * iv_get_state$link5(void)
{
  return __st;
}

// iv_init
// file ../src/include/iv.h line 42
void iv_init(void)
{
  struct iv_state *st;
  if(iv_state_key_allocated == 0)
  {
    signed int return_value_pthread_key_create$1;
    return_value_pthread_key_create$1=pthread_key_create(&iv_state_key, iv_state_destructor);
    if(!(return_value_pthread_key_create$1 == 0))
      iv_fatal("iv_init: failed to allocate TLS key");

    iv_state_key_allocated = 1;
  }

  signed int return_value_iv_tls_total_state_size$2;
  return_value_iv_tls_total_state_size$2=iv_tls_total_state_size();
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)1, (unsigned long int)return_value_iv_tls_total_state_size$2);
  st = (struct iv_state *)return_value_calloc$3;
  pthread_setspecific(iv_state_key, (const void *)st);
  __st = st;
  st->numobjs = 0;
  iv_fd_init(st);
  iv_task_init(st);
  iv_timer_init(st);
  iv_tls_thread_init(st);
}

// iv_inited
// file ../../../src/iv_main_posix.c line 81
signed int iv_inited(void)
{
  struct iv_state *return_value_iv_get_state$1;
  return_value_iv_get_state$1=iv_get_state$link5();
  return (signed int)(return_value_iv_get_state$1 != (struct iv_state *)(void *)0);
}

// iv_inotify_got_event
// file ../../../src/iv_inotify.c line 53
static void iv_inotify_got_event(void *_this)
{
  struct iv_inotify *this = (struct iv_inotify *)_this;
  unsigned char event_queue[65536l];
  signed long int ret;
  void *curr;
  void *end;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    ret=read(this->fd.fd, (void *)event_queue, sizeof(unsigned char [65536l]) /*65536ul*/ );
    if(ret == -1l)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$6;
  if(!(ret >= 1l))
  {
    if(ret == 0l)
      iv_fatal("iv_inotify: reading from inotify fd returned zero");

    else
    {
      return_value___errno_location$6=__errno_location();
      if(!(*return_value___errno_location$6 == 11))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        iv_fatal("iv_inotify: reading from inotify fd returned error %d[%s]", *return_value___errno_location$3, return_value_strerror$5);
      }

    }
    goto __CPROVER_DUMP_L15;
  }

  this->term = (void **)&this;
  curr = (void *)event_queue;
  end = (void *)(event_queue + ret);
  _Bool tmp_if_expr$7;
  while(!(curr >= end))
  {
    struct inotify_event *event = (struct inotify_event *)curr;
    struct iv_inotify_watch *w;
    w=__find_watch(this, event->wd);
    if(!(w == ((struct iv_inotify_watch *)NULL)))
    {
      if(!((32768u & event->mask) == 0u))
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (w->mask & 0x80000000) != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        iv_avl_tree_delete(&this->watches, &w->an);

      w->handler(w->cookie, event);
    }

    curr = curr + (signed long int)((unsigned long int)event->len + sizeof(struct inotify_event) /*16ul*/ );
    if(this == ((struct iv_inotify *)NULL))
      break;

  }
  if(!(this == ((struct iv_inotify *)NULL)))
    this->term = (void **)(void *)0;


__CPROVER_DUMP_L15:
  ;
}

// iv_inotify_register
// file ../../../src/iv_inotify.c line 119
signed int iv_inotify_register(struct iv_inotify *this)
{
  signed int fd;
  fd=inotify_init();
  if(fd == -1)
    return -1;

  else
  {
    IV_FD_INIT(&this->fd);
    this->fd.fd = fd;
    this->fd.cookie = (void *)this;
    this->fd.handler_in = iv_inotify_got_event;
    iv_fd_register(&this->fd);
    do
    {
      (&this->watches)->compare = __iv_inotify_watch_compare;
      (&this->watches)->root = (struct iv_avl_node *)(void *)0;
    }
    while((_Bool)0);
    return 0;
  }
}

// iv_inotify_unregister
// file ../../../src/iv_inotify.c line 138
void iv_inotify_unregister(struct iv_inotify *this)
{
  iv_fd_unregister(&this->fd);
  close(this->fd.fd);
  if(!(this->term == ((void **)NULL)))
    *this->term = (void *)0;

}

// iv_inotify_watch_register
// file ../../../src/iv_inotify.c line 147
signed int iv_inotify_watch_register(struct iv_inotify_watch *w)
{
  struct iv_inotify *inotify = w->inotify;
  w->wd=inotify_add_watch(inotify->fd.fd, w->pathname, w->mask);
  if(w->wd == -1)
    return -1;

  else
  {
    signed int return_value_iv_avl_tree_insert$1;
    return_value_iv_avl_tree_insert$1=iv_avl_tree_insert(&inotify->watches, &w->an);
    return return_value_iv_avl_tree_insert$1;
  }
}

// iv_inotify_watch_unregister
// file ../../../src/iv_inotify.c line 158
void iv_inotify_watch_unregister(struct iv_inotify_watch *w)
{
  struct iv_inotify *inotify = w->inotify;
  inotify_rm_watch(inotify->fd.fd, w->wd);
  iv_avl_tree_delete(&inotify->watches, &w->an);
}

// iv_invalidate_now
// file ../../../src/iv_timer.c line 34
void iv_invalidate_now(void)
{
  struct iv_state *st;
  st=iv_get_state$link2();
  __iv_invalidate_now(st);
}

// iv_list_add
// file ../../../src/include/iv_list.h line 48
static inline void iv_list_add(struct iv_list_head *ilh, struct iv_list_head *head)
{
  ilh->next = head->next;
  ilh->prev = head;
  head->next->prev = ilh;
  head->next = ilh;
}

// iv_list_add$link1
// file ../../../src/include/iv_list.h line 48
static inline void iv_list_add$link1(struct iv_list_head *ilh$link1, struct iv_list_head *head$link1)
{
  ilh$link1->next = head$link1->next;
  ilh$link1->prev = head$link1;
  head$link1->next->prev = ilh$link1;
  head$link1->next = ilh$link1;
}

// iv_list_add_tail
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail(struct iv_list_head *ilh, struct iv_list_head *head)
{
  ilh->next = head;
  ilh->prev = head->prev;
  head->prev->next = ilh;
  head->prev = ilh;
}

// iv_list_add_tail$link1
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link1(struct iv_list_head *ilh$link1, struct iv_list_head *head$link1)
{
  ilh$link1->next = head$link1;
  ilh$link1->prev = head$link1->prev;
  head$link1->prev->next = ilh$link1;
  head$link1->prev = ilh$link1;
}

// iv_list_add_tail$link2
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link2(struct iv_list_head *ilh$link2, struct iv_list_head *head$link2)
{
  ilh$link2->next = head$link2;
  ilh$link2->prev = head$link2->prev;
  head$link2->prev->next = ilh$link2;
  head$link2->prev = ilh$link2;
}

// iv_list_add_tail$link3
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link3(struct iv_list_head *ilh$link3, struct iv_list_head *head$link3)
{
  ilh$link3->next = head$link3;
  ilh$link3->prev = head$link3->prev;
  head$link3->prev->next = ilh$link3;
  head$link3->prev = ilh$link3;
}

// iv_list_add_tail$link4
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link4(struct iv_list_head *ilh$link4, struct iv_list_head *head$link4)
{
  ilh$link4->next = head$link4;
  ilh$link4->prev = head$link4->prev;
  head$link4->prev->next = ilh$link4;
  head$link4->prev = ilh$link4;
}

// iv_list_add_tail$link5
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link5(struct iv_list_head *ilh$link5, struct iv_list_head *head$link5)
{
  ilh$link5->next = head$link5;
  ilh$link5->prev = head$link5->prev;
  head$link5->prev->next = ilh$link5;
  head$link5->prev = ilh$link5;
}

// iv_list_add_tail$link6
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link6(struct iv_list_head *ilh$link6, struct iv_list_head *head$link6)
{
  ilh$link6->next = head$link6;
  ilh$link6->prev = head$link6->prev;
  head$link6->prev->next = ilh$link6;
  head$link6->prev = ilh$link6;
}

// iv_list_add_tail$link7
// file ../../../src/include/iv_list.h line 57
static inline void iv_list_add_tail$link7(struct iv_list_head *ilh$link7, struct iv_list_head *head$link7)
{
  ilh$link7->next = head$link7;
  ilh$link7->prev = head$link7->prev;
  head$link7->prev->next = ilh$link7;
  head$link7->prev = ilh$link7;
}

// iv_list_del
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del(struct iv_list_head *ilh)
{
  ilh->prev->next = ilh->next;
  ilh->next->prev = ilh->prev;
  ilh->prev = (struct iv_list_head *)(void *)0;
  ilh->next = (struct iv_list_head *)(void *)0;
}

// iv_list_del$link1
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link1(struct iv_list_head *ilh$link1)
{
  ilh$link1->prev->next = ilh$link1->next;
  ilh$link1->next->prev = ilh$link1->prev;
  ilh$link1->prev = (struct iv_list_head *)(void *)0;
  ilh$link1->next = (struct iv_list_head *)(void *)0;
}

// iv_list_del$link2
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link2(struct iv_list_head *ilh$link2)
{
  ilh$link2->prev->next = ilh$link2->next;
  ilh$link2->next->prev = ilh$link2->prev;
  ilh$link2->prev = (struct iv_list_head *)(void *)0;
  ilh$link2->next = (struct iv_list_head *)(void *)0;
}

// iv_list_del$link3
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link3(struct iv_list_head *ilh$link3)
{
  ilh$link3->prev->next = ilh$link3->next;
  ilh$link3->next->prev = ilh$link3->prev;
  ilh$link3->prev = (struct iv_list_head *)(void *)0;
  ilh$link3->next = (struct iv_list_head *)(void *)0;
}

// iv_list_del$link4
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link4(struct iv_list_head *ilh$link4)
{
  ilh$link4->prev->next = ilh$link4->next;
  ilh$link4->next->prev = ilh$link4->prev;
  ilh$link4->prev = (struct iv_list_head *)(void *)0;
  ilh$link4->next = (struct iv_list_head *)(void *)0;
}

// iv_list_del$link5
// file ../../../src/include/iv_list.h line 65
static inline void iv_list_del$link5(struct iv_list_head *ilh$link5)
{
  ilh$link5->prev->next = ilh$link5->next;
  ilh$link5->next->prev = ilh$link5->prev;
  ilh$link5->prev = (struct iv_list_head *)(void *)0;
  ilh$link5->next = (struct iv_list_head *)(void *)0;
}

// iv_list_del_init
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init(struct iv_list_head *ilh)
{
  ilh->prev->next = ilh->next;
  ilh->next->prev = ilh->prev;
  do
  {
    ilh->next = ilh;
    ilh->prev = ilh;
  }
  while((_Bool)0);
}

// iv_list_del_init$link1
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link1(struct iv_list_head *ilh$link1)
{
  ilh$link1->prev->next = ilh$link1->next;
  ilh$link1->next->prev = ilh$link1->prev;
  do
  {
    ilh$link1->next = ilh$link1;
    ilh$link1->prev = ilh$link1;
  }
  while((_Bool)0);
}

// iv_list_del_init$link2
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link2(struct iv_list_head *ilh$link2)
{
  ilh$link2->prev->next = ilh$link2->next;
  ilh$link2->next->prev = ilh$link2->prev;
  do
  {
    ilh$link2->next = ilh$link2;
    ilh$link2->prev = ilh$link2;
  }
  while((_Bool)0);
}

// iv_list_del_init$link3
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link3(struct iv_list_head *ilh$link3)
{
  ilh$link3->prev->next = ilh$link3->next;
  ilh$link3->next->prev = ilh$link3->prev;
  do
  {
    ilh$link3->next = ilh$link3;
    ilh$link3->prev = ilh$link3;
  }
  while((_Bool)0);
}

// iv_list_del_init$link4
// file ../../../src/include/iv_list.h line 73
static inline void iv_list_del_init$link4(struct iv_list_head *ilh$link4)
{
  ilh$link4->prev->next = ilh$link4->next;
  ilh$link4->next->prev = ilh$link4->prev;
  do
  {
    ilh$link4->next = ilh$link4;
    ilh$link4->prev = ilh$link4;
  }
  while((_Bool)0);
}

// iv_list_empty
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty(struct iv_list_head *head)
{
  return (signed int)(head->next == head);
}

// iv_list_empty$link1
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link1(struct iv_list_head *head$link1)
{
  return (signed int)(head$link1->next == head$link1);
}

// iv_list_empty$link2
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link2(struct iv_list_head *head$link2)
{
  return (signed int)(head$link2->next == head$link2);
}

// iv_list_empty$link3
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link3(struct iv_list_head *head$link3)
{
  return (signed int)(head$link3->next == head$link3);
}

// iv_list_empty$link4
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link4(struct iv_list_head *head$link4)
{
  return (signed int)(head$link4->next == head$link4);
}

// iv_list_empty$link5
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link5(struct iv_list_head *head$link5)
{
  return (signed int)(head$link5->next == head$link5);
}

// iv_list_empty$link6
// file ../../../src/include/iv_list.h line 80
static inline signed int iv_list_empty$link6(struct iv_list_head *head$link6)
{
  return (signed int)(head$link6->next == head$link6);
}

// iv_main
// file ../src/include/iv.h line 44
void iv_main(void)
{
  struct iv_state *st;
  st=iv_get_state$link5();
  st->quit = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  signed int return_value_iv_get_soonest_timeout$3;
  while((_Bool)1)
  {
    struct timespec to;
    iv_run_tasks(st);
    iv_run_timers(st);
    if(!(st->quit == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(st->numobjs != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      break;

    signed int return_value_iv_pending_tasks$2;
    return_value_iv_pending_tasks$2=iv_pending_tasks(st);
    if(!(return_value_iv_pending_tasks$2 == 0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_iv_get_soonest_timeout$3=iv_get_soonest_timeout(st, &to);
      tmp_if_expr$4 = return_value_iv_get_soonest_timeout$3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      to.tv_sec = (signed long int)0;
      to.tv_nsec = (signed long int)0;
    }

    iv_fd_poll_and_run(st, &to);
  }
}

// iv_pending_tasks
// file ../../../src/iv_task.c line 30
signed int iv_pending_tasks(struct iv_state *st)
{
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link1(&st->tasks);
  return (signed int)!(return_value_iv_list_empty$1 != 0);
}

// iv_poll_method_name
// file ../../../src/iv_fd.c line 204
const char * iv_poll_method_name(void)
{
  char *tmp_if_expr$1;
  if(!(method == ((struct iv_fd_poll_method *)NULL)))
    tmp_if_expr$1 = method->name;

  else
    tmp_if_expr$1 = (char *)(void *)0;
  return tmp_if_expr$1;
}

// iv_popen_child
// file ../../../src/iv_popen.c line 68
static void iv_popen_child(void *cookie)
{
  struct iv_popen_spawn_info *info = (struct iv_popen_spawn_info *)cookie;
  signed int iv_popen_child$$1$$devnull;
  iv_popen_child$$1$$devnull=open("/dev/null", 02);
  if(!(iv_popen_child$$1$$devnull >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    iv_fatal("iv_popen_child: got error %d[%s] opening /dev/null", *return_value___errno_location$1, return_value_strerror$3);
  }

  if(!(info->for_read == 0))
  {
    dup2(iv_popen_child$$1$$devnull, 0);
    dup2(info->data_pipe[(signed long int)1], 1);
    dup2(iv_popen_child$$1$$devnull, 2);
  }

  else
  {
    dup2(info->data_pipe[(signed long int)0], 0);
    dup2(iv_popen_child$$1$$devnull, 1);
    dup2(iv_popen_child$$1$$devnull, 2);
  }
  close(info->data_pipe[(signed long int)0]);
  close(info->data_pipe[(signed long int)1]);
  close(iv_popen_child$$1$$devnull);
  execvp(info->this->file, info->this->argv);
  perror("execvp");
}

// iv_popen_request_close
// file ../../../src/iv_popen.c line 181
void iv_popen_request_close(struct iv_popen_request *this)
{
  struct iv_popen_running_child *ch = (struct iv_popen_running_child *)this->child;
  if(!(ch == ((struct iv_popen_running_child *)NULL)))
  {
    ch->parent = (struct iv_popen_request *)(void *)0;
    IV_TIMER_INIT(&ch->signal_timer);
    iv_validate_now();
    struct timespec *return_value___iv_now_location$1;
    return_value___iv_now_location$1=__iv_now_location();
    ch->signal_timer.expires = *return_value___iv_now_location$1;
    ch->signal_timer.handler = iv_popen_running_child_timer;
    ch->signal_timer.cookie = (void *)ch;
    iv_timer_register(&ch->signal_timer);
    ch->num_kills = 0;
  }

}

// iv_popen_request_submit
// file ../../../src/iv_popen.c line 97
signed int iv_popen_request_submit(struct iv_popen_request *this)
{
  struct iv_popen_running_child *ch;
  struct iv_popen_spawn_info info;
  signed int ret;
  signed int fd;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct iv_popen_running_child) /*208ul*/ );
  ch = (struct iv_popen_running_child *)return_value_malloc$1;
  signed int return_value_strcmp$2;
  if(ch == ((struct iv_popen_running_child *)NULL))
  {
    fprintf(stderr, "iv_popen_request_submit: out of memory\n");
    return -1;
  }

  else
  {
    info.this = this;
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(this->type, "r");
    if(return_value_strcmp$3 == 0)
      info.for_read = 1;

    else
    {
      return_value_strcmp$2=strcmp(this->type, "w");
      if(return_value_strcmp$2 == 0)
        info.for_read = 0;

      else
      {
        fprintf(stderr, "iv_popen_request_submit: invalid type\n");
        free((void *)ch);
        return -1;
      }
    }
    signed int return_value_pipe$4;
    return_value_pipe$4=pipe(info.data_pipe);
    if(!(return_value_pipe$4 >= 0))
    {
      perror("pipe");
      free((void *)ch);
      return -1;
    }

    else
    {
      IV_WAIT_INTEREST_INIT(&ch->wait);
      ch->wait.cookie = (void *)ch;
      ch->wait.handler = iv_popen_running_child_wait;
      ch->parent = this;
      ret=iv_wait_interest_register_spawn(&ch->wait, iv_popen_child, (void *)&info);
      if(!(ret >= 0))
      {
        perror("fork");
        close(info.data_pipe[(signed long int)1]);
        close(info.data_pipe[(signed long int)0]);
        free((void *)ch);
        return -1;
      }

      else
      {
        this->child = (void *)ch;
        if(!(info.for_read == 0))
        {
          fd = info.data_pipe[(signed long int)0];
          close(info.data_pipe[(signed long int)1]);
        }

        else
        {
          fd = info.data_pipe[(signed long int)1];
          close(info.data_pipe[(signed long int)0]);
        }
        return fd;
      }
    }
  }
}

// iv_popen_running_child_timer
// file ../../../src/iv_popen.c line 160
static void iv_popen_running_child_timer(void *_ch)
{
  struct iv_popen_running_child *ch = (struct iv_popen_running_child *)_ch;
  signed int signum;
  signed int ret;
  signed int tmp_post$1 = ch->num_kills;
  ch->num_kills = ch->num_kills + 1;
  signum = tmp_post$1 < 5 ? 15 : 9;
  ret=iv_wait_interest_kill(&ch->wait, signum);
  if(!(ret >= 0))
  {
    iv_wait_interest_unregister(&ch->wait);
    free((void *)ch);
  }

  else
  {
    iv_validate_now();
    struct timespec *return_value___iv_now_location$2;
    return_value___iv_now_location$2=__iv_now_location();
    ch->signal_timer.expires = *return_value___iv_now_location$2;
    ch->signal_timer.expires.tv_sec = ch->signal_timer.expires.tv_sec + (signed long int)5;
    iv_timer_register(&ch->signal_timer);
  }
}

// iv_popen_running_child_wait
// file ../../../src/iv_popen.c line 46
static void iv_popen_running_child_wait(void *_ch, signed int status, struct rusage *rusage)
{
  struct iv_popen_running_child *ch = (struct iv_popen_running_child *)_ch;
  if(!((0x7f & status) == 0))
  {
    if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    iv_wait_interest_unregister(&ch->wait);
    if(!(ch->parent == ((struct iv_popen_request *)NULL)))
      ch->parent->child = (void *)0;

    else
      iv_timer_unregister(&ch->signal_timer);
    free((void *)ch);
  }
}

// iv_quit
// file ../../../src/iv_main_posix.c line 91
void iv_quit(void)
{
  struct iv_state *st;
  st=iv_get_state$link5();
  st->quit = 1;
}

// iv_run_tasks
// file ../../../src/iv_task.c line 35
void iv_run_tasks(struct iv_state *st)
{
  struct iv_list_head tasks;
  __iv_list_steal_elements$link1(&st->tasks, &tasks);
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link1(&tasks);
  struct iv_task_ *tmp_statement_expression$2;
  if(return_value_iv_list_empty$1 == 0)
  {
    struct iv_task_ *t;
    const struct iv_list_head *__ptr = tasks.next;
    tmp_statement_expression$2 = (struct iv_task_ *)((char *)__ptr - (signed long int)&((struct iv_task_ *)0)->list);
    t = tmp_statement_expression$2;
    iv_list_del_init$link1(&t->list);
    st->numobjs = st->numobjs - 1;
    t->handler(t->cookie);
  }

}

// iv_run_timers
// file ../../../src/iv_timer.c line 136
void iv_run_timers(struct iv_state *st)
{
  if(!(st->num_timers == 0))
  {
    struct iv_timer_ *t;
    struct iv_timer_ **return_value_iv_timer_get_node$1;
    return_value_iv_timer_get_node$1=iv_timer_get_node(st, 1);
    t = *return_value_iv_timer_get_node$1;
    if(st->time_valid == 0)
    {
      st->time_valid = 1;
      iv_time_get(&st->time);
    }

    signed int return_value_timespec_gt$2;
    return_value_timespec_gt$2=timespec_gt(&t->expires, &st->time);
    if(return_value_timespec_gt$2 == 0)
    {
      iv_timer_unregister((struct iv_timer *)t);
      t->handler(t->cookie);
    }

  }

}

// iv_set_fatal_msg_handler
// file ../../../src/iv_fatal.c line 60
void iv_set_fatal_msg_handler(void (*handler)(const char *))
{
  fatal_msg_handler = handler;
}

// iv_signal_event
// file ../../../src/iv_signal.c line 161
static void iv_signal_event(void *_this)
{
  struct iv_signal *this = (struct iv_signal *)_this;
  struct anonymous$17 mask;
  spin_lock_sigmask(&sig_interests_lock, &mask);
  this->active = (unsigned char)0;
  spin_unlock_sigmask(&sig_interests_lock, &mask);
  this->handler(this->cookie);
}

// iv_signal_handler
// file ../../../src/iv_signal.c line 154
static void iv_signal_handler(signed int signum)
{
  spin_lock(&sig_interests_lock);
  __iv_signal_do_wake(signum);
  spin_unlock(&sig_interests_lock);
}

// iv_signal_register
// file ../../../src/iv_signal.c line 173
signed int iv_signal_register(struct iv_signal *this)
{
  struct anonymous$17 mask;
  IV_EVENT_RAW_INIT$link1(&this->ev);
  this->ev.cookie = (void *)this;
  this->ev.handler = iv_signal_event;
  iv_event_raw_register(&this->ev);
  this->active = (unsigned char)0;
  spin_lock_sigmask(&sig_interests_lock, &mask);
  struct iv_avl_node *return_value___iv_signal_find_first$5;
  return_value___iv_signal_find_first$5=__iv_signal_find_first(this->signum);
  if(return_value___iv_signal_find_first$5 == ((struct iv_avl_node *)NULL))
  {
    struct sigaction sa;
    sa.__sigaction_handler.sa_handler = iv_signal_handler;
    sigfillset(&sa.sa_mask);
    sa.sa_flags = 0x10000000;
    signed int return_value_sigaction$4;
    return_value_sigaction$4=sigaction(this->signum, &sa, (struct sigaction *)(void *)0);
    if(!(return_value_sigaction$4 >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      iv_fatal("iv_signal_register: sigaction got error %d[%s]", *return_value___errno_location$1, return_value_strerror$3);
    }

  }

  iv_avl_tree_insert(&sig_interests, &this->an);
  spin_unlock_sigmask(&sig_interests_lock, &mask);
  return 0;
}

// iv_signal_unregister
// file ../../../src/iv_signal.c line 208
void iv_signal_unregister(struct iv_signal *this)
{
  struct anonymous$17 mask;
  spin_lock_sigmask(&sig_interests_lock, &mask);
  iv_avl_tree_delete(&sig_interests, &this->an);
  struct iv_avl_node *return_value___iv_signal_find_first$1;
  return_value___iv_signal_find_first$1=__iv_signal_find_first(this->signum);
  if(return_value___iv_signal_find_first$1 == ((struct iv_avl_node *)NULL))
  {
    struct sigaction sa;
    sa.__sigaction_handler.sa_handler = (void (*)(signed int))0;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(this->signum, &sa, (struct sigaction *)(void *)0);
  }

  else
    if(!((1u & this->flags) == 0u))
    {
      if(!(this->active == 0))
        __iv_signal_do_wake(this->signum);

    }

  spin_unlock_sigmask(&sig_interests_lock, &mask);
  iv_event_raw_unregister(&this->ev);
}

// iv_state_destructor
// file ../../../src/iv_main_posix.c line 47
static void iv_state_destructor(void *data)
{
  struct iv_state *st = (struct iv_state *)data;
  pthread_setspecific(iv_state_key, (const void *)st);
  __iv_deinit(st);
}

// iv_task_init
// file ../../../src/iv_task.c line 25
void iv_task_init(struct iv_state *st)
{
  do
  {
    (&st->tasks)->next = &st->tasks;
    (&st->tasks)->prev = &st->tasks;
  }
  while((_Bool)0);
}

// iv_task_register
// file ../../../src/iv_task.c line 59
void iv_task_register(struct iv_task *_t)
{
  struct iv_state *st;
  st=iv_get_state$link1();
  struct iv_task_ *t = (struct iv_task_ *)_t;
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link1(&t->list);
  if(return_value_iv_list_empty$1 == 0)
    iv_fatal("iv_task_register: called with task still on a list");

  st->numobjs = st->numobjs + 1;
  iv_list_add_tail$link1(&t->list, &st->tasks);
}

// iv_task_registered
// file ../../../src/iv_task.c line 83
signed int iv_task_registered(struct iv_task *_t)
{
  struct iv_task_ *t = (struct iv_task_ *)_t;
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link1(&t->list);
  return (signed int)!(return_value_iv_list_empty$1 != 0);
}

// iv_task_unregister
// file ../../../src/iv_task.c line 71
void iv_task_unregister(struct iv_task *_t)
{
  struct iv_state *st;
  st=iv_get_state$link1();
  struct iv_task_ *t = (struct iv_task_ *)_t;
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link1(&t->list);
  if(!(return_value_iv_list_empty$1 == 0))
    iv_fatal("iv_task_unregister: called with task not on a list");

  st->numobjs = st->numobjs - 1;
  iv_list_del_init$link1(&t->list);
}

// iv_thread_cleanup_handler
// file ../../../src/iv_thread_posix.c line 125
static void iv_thread_cleanup_handler(void *_thr)
{
  struct iv_thread *thr = (struct iv_thread *)_thr;
  if(!(iv_thread_debug == 0))
    fprintf(stderr, "iv_thread: [%s] was canceled\n", thr->name);

  iv_event_post(&thr->dead);
}

// iv_thread_create
// file ../../../src/include/iv_thread.h line 28
signed int iv_thread_create(char *name, void (*start_routine)(void *), void *arg)
{
  struct iv_thread_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_thread_tls_user);
  tinfo = (struct iv_thread_thr_info *)return_value_iv_tls_user_ptr$1;
  struct iv_thread *thr;
  signed int ret;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct iv_thread) /*96ul*/ );
  thr = (struct iv_thread *)return_value_malloc$2;
  if(thr == ((struct iv_thread *)NULL))
    return -1;

  else
  {
    IV_EVENT_INIT$link1(&thr->dead);
    thr->dead.cookie = (void *)thr;
    thr->dead.handler = iv_thread_died;
    iv_event_register(&thr->dead);
    thr->name=strdup(name);
    thr->tid = (unsigned long int)0;
    thr->start_routine = start_routine;
    thr->arg = arg;
    ret=pthread_create(&thr->thread_id, (const union pthread_attr_t *)(void *)0, iv_thread_handler, (void *)thr);
    if(ret == 0)
    {
      iv_list_add_tail$link5(&thr->list, &tinfo->child_threads);
      if(!(iv_thread_debug == 0))
        fprintf(stderr, "iv_thread: [%s] started\n", name);

      return 0;
    }

    else
    {

    out:
      ;
      iv_event_unregister(&thr->dead);
      free((void *)thr->name);
      free((void *)thr);
      if(!(iv_thread_debug == 0))
      {
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(ret);
        fprintf(stderr, "iv_thread: pthread_create for [%s] failed with error %d[%s]\n", name, ret, return_value_strerror$3);
      }

      return -1;
    }
  }
}

// iv_thread_died
// file ../../../src/iv_thread_posix.c line 156
static void iv_thread_died(void *_thr)
{
  struct iv_thread *thr = (struct iv_thread *)_thr;
  pthread_join(thr->thread_id, (void **)(void *)0);
  if(!(iv_thread_debug == 0))
    fprintf(stderr, "iv_thread: [%s] joined\n", thr->name);

  iv_list_del$link4(&thr->list);
  iv_event_unregister(&thr->dead);
  free((void *)thr->name);
  free((void *)thr);
}

// iv_thread_get_id
// file ../../../src/iv_thread_posix.c line 221
unsigned long int iv_thread_get_id(void)
{
  unsigned long int return_value_get_thread_id$1;
  return_value_get_thread_id$1=get_thread_id();
  return return_value_get_thread_id$1;
}

// iv_thread_handler
// file ../../../src/iv_thread_posix.c line 135
static void * iv_thread_handler(void *_thr)
{
  struct iv_thread *thr = (struct iv_thread *)_thr;
  thr->tid=get_thread_id();
  struct anonymous$34 __cancel_buf;
  void (*__cancel_routine)(void *) = iv_thread_cleanup_handler;
  void *__cancel_arg = (void *)thr;
  signed int __not_first_call;
  __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
  if(!((signed long int)__not_first_call == 0l))
  {
    __cancel_routine(__cancel_arg);
    __pthread_unwind_next(&__cancel_buf);
  }

  __pthread_register_cancel(&__cancel_buf);
  thr->start_routine(thr->arg);
  __pthread_unregister_cancel(&__cancel_buf);
  if(!(iv_thread_debug == 0))
    fprintf(stderr, "iv_thread: [%s] terminating normally\n", thr->name);

  iv_event_post(&thr->dead);
  return (void *)0;
}

// iv_thread_list_children
// file ../../../src/iv_thread_posix.c line 226
void iv_thread_list_children(void)
{
  struct iv_thread_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_thread_tls_user);
  tinfo = (struct iv_thread_thr_info *)return_value_iv_tls_user_ptr$1;
  struct iv_list_head *ilh;
  fprintf(stderr, "tid\tname\n");
  unsigned long int return_value_get_thread_id$2;
  return_value_get_thread_id$2=get_thread_id();
  fprintf(stderr, "%lu\tself\n", return_value_get_thread_id$2);
  ilh = (&tinfo->child_threads)->next;
  struct iv_thread *tmp_statement_expression$3;
  for( ; !(ilh == &tinfo->child_threads); ilh = ilh->next)
  {
    struct iv_thread *thr;
    const struct iv_list_head *__ptr = ilh;
    tmp_statement_expression$3 = (struct iv_thread *)((char *)__ptr - (signed long int)&((struct iv_thread *)0)->list);
    thr = tmp_statement_expression$3;
    fprintf(stderr, "%lu\t%s\n", thr->tid, thr->name);
  }
}

// iv_thread_set_debug_state
// file ../../../src/iv_thread_posix.c line 216
void iv_thread_set_debug_state(signed int state)
{
  iv_thread_debug = (signed int)!(!(state != 0));
}

// iv_thread_tls_deinit_thread
// file ../../../src/iv_thread_posix.c line 98
static void iv_thread_tls_deinit_thread(void *_tinfo)
{
  struct iv_thread_thr_info *tinfo = (struct iv_thread_thr_info *)_tinfo;
  struct iv_list_head *ilh = (&tinfo->child_threads)->next;
  struct iv_thread *tmp_statement_expression$1;
  for( ; !(ilh == &tinfo->child_threads); ilh = ilh->next)
  {
    struct iv_thread *thr;
    const struct iv_list_head *__ptr = ilh;
    tmp_statement_expression$1 = (struct iv_thread *)((char *)__ptr - (signed long int)&((struct iv_thread *)0)->list);
    thr = tmp_statement_expression$1;
    pthread_detach(thr->thread_id);
  }
}

// iv_thread_tls_init_thread
// file ../../../src/iv_thread_posix.c line 91
static void iv_thread_tls_init_thread(void *_tinfo)
{
  struct iv_thread_thr_info *tinfo = (struct iv_thread_thr_info *)_tinfo;
  do
  {
    (&tinfo->child_threads)->next = &tinfo->child_threads;
    (&tinfo->child_threads)->prev = &tinfo->child_threads;
  }
  while((_Bool)0);
}

// iv_time_get
// file ../../../src/iv_private.h line 199
void iv_time_get(struct timespec *time)
{
  struct timeval tv;
  if(!(clock_source >= 1))
  {
    signed int return_value_clock_gettime$1;
    return_value_clock_gettime$1=clock_gettime(1, time);
    if(return_value_clock_gettime$1 >= 0)
      goto __CPROVER_DUMP_L5;

    clock_source = 1;
  }

  if(!(clock_source >= 2))
  {
    signed int return_value_clock_gettime$2;
    return_value_clock_gettime$2=clock_gettime(0, time);
    if(return_value_clock_gettime$2 >= 0)
      goto __CPROVER_DUMP_L5;

    clock_source = 2;
  }

  gettimeofday(&tv, (struct timezone *)(void *)0);
  time->tv_sec = tv.tv_sec;
  time->tv_nsec = 1000L * tv.tv_usec;

__CPROVER_DUMP_L5:
  ;
}

// iv_timer_allocate_ratnode
// file ../../../src/iv_timer.c line 64
static struct ratnode * iv_timer_allocate_ratnode(void)
{
  struct ratnode *node;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ratnode) /*2048ul*/ );
  node = (struct ratnode *)return_value_calloc$1;
  if(node == ((struct ratnode *)NULL))
    iv_fatal("iv_timer_allocate_ratnode: out of memory");

  return node;
}

// iv_timer_deinit
// file ../../../src/iv_timer.c line 168
void iv_timer_deinit(struct iv_state *st)
{
  free_ratnode(st->timer_root, st->rat_depth);
  st->timer_root = (struct ratnode *)(void *)0;
}

// iv_timer_get_node
// file ../../../src/iv_timer.c line 81
static struct iv_timer_ ** iv_timer_get_node(struct iv_state *st, signed int index)
{
  struct ratnode *r;
  signed int i;
  if(!(index >> (1 + st->rat_depth) * 8 == 0))
  {
    st->rat_depth = st->rat_depth + 1;
    r=iv_timer_allocate_ratnode();
    r->child[(signed long int)0] = (void *)st->timer_root;
    st->timer_root = r;
  }

  r = st->timer_root;
  i = st->rat_depth;
  struct ratnode *return_value_iv_timer_allocate_ratnode$1;
  for( ; i >= 1; i = i - 1)
  {
    signed int bits = index >> i * 8 & (1 << 8) - 1;
    if(r->child[(signed long int)bits] == NULL)
    {
      return_value_iv_timer_allocate_ratnode$1=iv_timer_allocate_ratnode();
      r->child[(signed long int)bits] = (void *)return_value_iv_timer_allocate_ratnode$1;
    }

    r = (struct ratnode *)r->child[(signed long int)bits];
  }
  return (struct iv_timer_ **)(r->child + (signed long int)(index & (1 << 8) - 1));
}

// iv_timer_init
// file ../../../src/iv_timer.c line 75
void iv_timer_init(struct iv_state *st)
{
  st->rat_depth = 0;
  st->timer_root=iv_timer_allocate_ratnode();
}

// iv_timer_radix_tree_remove_level
// file ../../../src/iv_timer.c line 174
static void iv_timer_radix_tree_remove_level(struct iv_state *st)
{
  struct ratnode *root;
  signed int i;
  st->rat_depth = st->rat_depth - 1;
  root = st->timer_root;
  i = 1;
  for( ; !(i >= 256); i = i + 1)
  {
    if(root->child[(signed long int)i] == NULL)
      break;

    free_ratnode((struct ratnode *)root->child[(signed long int)i], st->rat_depth);
  }
  st->timer_root = (struct ratnode *)root->child[(signed long int)0];
  free((void *)root);
}

// iv_timer_register
// file ../../../src/iv_timer.c line 231
void iv_timer_register(struct iv_timer *_t)
{
  struct iv_state *st;
  st=iv_get_state$link2();
  struct iv_timer_ *t = (struct iv_timer_ *)_t;
  struct iv_timer_ **p;
  signed int index;
  if(!(t->index == -1))
    iv_fatal("iv_timer_register: called with timer still on the heap");

  st->numobjs = st->numobjs + 1;
  st->num_timers = st->num_timers + 1;
  index = st->num_timers;
  p=iv_timer_get_node(st, index);
  *p = t;
  t->index = index;
  pull_up(st, index, p);
}

// iv_timer_registered
// file ../../../src/iv_timer.c line 335
signed int iv_timer_registered(struct iv_timer *_t)
{
  struct iv_timer_ *t = (struct iv_timer_ *)_t;
  return (signed int)!(t->index == -1);
}

// iv_timer_unregister
// file ../../../src/iv_timer.c line 292
void iv_timer_unregister(struct iv_timer *_t)
{
  struct iv_state *st;
  st=iv_get_state$link2();
  struct iv_timer_ *t = (struct iv_timer_ *)_t;
  struct iv_timer_ **m;
  struct iv_timer_ **p;
  if(t->index == -1)
    iv_fatal("iv_timer_unregister: called with timer not on the heap");

  if(!(st->num_timers >= t->index))
    iv_fatal("iv_timer_unregister: timer index %d > %d", t->index, st->num_timers);

  p=iv_timer_get_node(st, t->index);
  if(!(*p == t))
    iv_fatal("iv_timer_unregister: unregistered timer index belonging to other timer");

  st->numobjs = st->numobjs - 1;
  m=iv_timer_get_node(st, st->num_timers);
  *p = *m;
  (*p)->index = t->index;
  *m = (struct iv_timer_ *)(void *)0;
  if(st->rat_depth >= 1)
  {
    if(st->num_timers == 1 << 8 * st->rat_depth)
      iv_timer_radix_tree_remove_level(st);

  }

  st->num_timers = st->num_timers - 1;
  if(!(p == m))
  {
    pull_up(st, (*p)->index, p);
    push_down(st, (*p)->index, p);
  }

  t->index = -1;
}

// iv_tls_thread_deinit
// file ../../../src/iv_tls.c line 62
void iv_tls_thread_deinit(struct iv_state *st)
{
  struct iv_list_head *ilh = (&iv_tls_users)->next;
  struct iv_tls_user *tmp_statement_expression$1;
  for( ; !(ilh == &iv_tls_users); ilh = ilh->next)
  {
    struct iv_tls_user *itu;
    const struct iv_list_head *__ptr = ilh;
    tmp_statement_expression$1 = (struct iv_tls_user *)((char *)__ptr - (signed long int)&((struct iv_tls_user *)0)->list);
    itu = tmp_statement_expression$1;
    if(!(itu->deinit_thread == ((void (*)(void *))NULL)))
      itu->deinit_thread((void *)st + (signed long int)itu->state_offset);

  }
}

// iv_tls_thread_init
// file ../../../src/iv_tls.c line 47
void iv_tls_thread_init(struct iv_state *st)
{
  struct iv_list_head *ilh;
  inited = 1;
  ilh = (&iv_tls_users)->next;
  struct iv_tls_user *tmp_statement_expression$1;
  for( ; !(ilh == &iv_tls_users); ilh = ilh->next)
  {
    struct iv_tls_user *itu;
    const struct iv_list_head *__ptr = ilh;
    tmp_statement_expression$1 = (struct iv_tls_user *)((char *)__ptr - (signed long int)&((struct iv_tls_user *)0)->list);
    itu = tmp_statement_expression$1;
    if(!(itu->init_thread == ((void (*)(void *))NULL)))
      itu->init_thread((void *)st + (signed long int)itu->state_offset);

  }
}

// iv_tls_total_state_size
// file ../../../src/iv_tls.c line 42
signed int iv_tls_total_state_size(void)
{
  return last_offset;
}

// iv_tls_user_ptr
// file ../../../src/include/iv_tls.h line 40
void * iv_tls_user_ptr(struct iv_tls_user *itu)
{
  struct iv_state *st;
  st=iv_get_state$link3();
  if(itu->state_offset == 0)
    iv_fatal("iv_tls_user_ptr: called on unregistered iv_tls_user");

  if(!(st == ((struct iv_state *)NULL)))
    return (void *)st + (signed long int)itu->state_offset;

  else
    return (void *)0;
}

// iv_tls_user_register
// file ../../../src/iv_tls.c line 31
void iv_tls_user_register(struct iv_tls_user *itu)
{
  if(!(inited == 0))
    iv_fatal("iv_tls_user_register: called after iv_init");

  itu->state_offset = last_offset;
  last_offset = (signed int)((unsigned long int)last_offset + itu->sizeof_state + (unsigned long int)15 & (unsigned long int)~15);
  iv_list_add_tail$link2(&itu->list, &iv_tls_users);
}

// iv_validate_now
// file ../../../src/iv_timer.c line 41
void iv_validate_now(void)
{
  struct iv_state *st;
  st=iv_get_state$link2();
  if(st->time_valid == 0)
  {
    st->time_valid = 1;
    iv_time_get(&st->time);
  }

}

// iv_wait_completion
// file ../../../src/iv_wait.c line 202
static void iv_wait_completion(void *_this)
{
  struct iv_wait_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_wait_tls_user);
  tinfo = (struct iv_wait_thr_info *)return_value_iv_tls_user_ptr$1;
  struct iv_wait_interest *this = (struct iv_wait_interest *)_this;
  struct iv_list_head events;
  pthread_mutex_lock(&iv_wait_lock);
  __iv_list_steal_elements$link3(&this->events, &events);
  pthread_mutex_unlock(&iv_wait_lock);
  tinfo->handled_wait_interest = this;
  signed int return_value_iv_list_empty$2;
  struct wait_event *tmp_statement_expression$3;
  do
  {
    return_value_iv_list_empty$2=iv_list_empty$link5(&events);
    if(!(return_value_iv_list_empty$2 == 0))
      break;

    struct wait_event *we;
    const struct iv_list_head *__ptr = events.next;
    tmp_statement_expression$3 = (struct wait_event *)((char *)__ptr - (signed long int)&((struct wait_event *)0)->list);
    we = tmp_statement_expression$3;
    iv_list_del$link5(&we->list);
    if(!(tinfo->handled_wait_interest == ((struct iv_wait_interest *)NULL)))
      this->handler(this->cookie, we->status, &we->rusage);

    free((void *)we);
  }
  while((_Bool)1);
  tinfo->handled_wait_interest = (struct iv_wait_interest *)(void *)0;
}

// iv_wait_got_sigchld
// file ../../../src/iv_wait.c line 101
static void iv_wait_got_sigchld(void *_dummy)
{
  pthread_mutex_lock(&iv_wait_lock);
  signed int *return_value___errno_location$1;
  while((_Bool)1)
  {
    signed int pid;
    signed int status;
    struct wait_event *we;
    struct iv_wait_interest *p;
    struct rusage rusage;
    pid=wait4(-1, &status, 1 | 2 | 8, &rusage);
    if(!(pid >= 1))
    {
      if(!(pid >= 0))
      {
        return_value___errno_location$1=__errno_location();
        if(!(*return_value___errno_location$1 == 10))
          perror("wait4");

      }

      break;
    }

    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct wait_event) /*168ul*/ );
    we = (struct wait_event *)return_value_malloc$2;
    if(we == ((struct wait_event *)NULL))
      iv_fatal("iv_wait_got_sigchld: out of memory");

    we->status = status;
    we->rusage = rusage;
    p=__iv_wait_interest_find(pid);
    if(!(p == ((struct iv_wait_interest *)NULL)))
    {
      iv_list_add_tail$link6(&we->list, &p->events);
      iv_event_post(&p->ev);
    }

    else
      free((void *)we);
    signed int return_value_iv_wait_status_dead$3;
    return_value_iv_wait_status_dead$3=iv_wait_status_dead(status);
    if(!(return_value_iv_wait_status_dead$3 == 0))
    {
      iv_avl_tree_delete(&iv_wait_interests, &p->avl_node);
      p->flags = (unsigned int)1;
    }

  }
  pthread_mutex_unlock(&iv_wait_lock);
}

// iv_wait_interest_compare
// file ../../../src/iv_wait.c line 47
static signed int iv_wait_interest_compare(struct iv_avl_node *_a, struct iv_avl_node *_b)
{
  struct iv_wait_interest *a;
  struct iv_wait_interest *b;
  struct iv_wait_interest *tmp_statement_expression$1;
  const struct iv_avl_node *iv_wait_interest_compare$$1$$1$$__ptr = _a;
  tmp_statement_expression$1 = (struct iv_wait_interest *)((char *)iv_wait_interest_compare$$1$$1$$__ptr - (signed long int)&((struct iv_wait_interest *)0)->avl_node);
  a = tmp_statement_expression$1;
  struct iv_wait_interest *tmp_statement_expression$2;
  const struct iv_avl_node *__ptr = _b;
  tmp_statement_expression$2 = (struct iv_wait_interest *)((char *)__ptr - (signed long int)&((struct iv_wait_interest *)0)->avl_node);
  b = tmp_statement_expression$2;
  if(!(a->pid >= b->pid))
    return -1;

  else
    if(!(b->pid >= a->pid))
      return 1;

    else
      return 0;
}

// iv_wait_interest_kill
// file ../../../src/include/iv_wait.h line 55
signed int iv_wait_interest_kill(struct iv_wait_interest *this, signed int sig)
{
  signed int ret;
  pthread_mutex_lock(&iv_wait_lock);
  if((1u & this->flags) == 0u)
    ret=kill(this->pid, sig);

  else
    ret = -3;
  pthread_mutex_unlock(&iv_wait_lock);
  return ret;
}

// iv_wait_interest_register
// file ../../../src/iv_wait.c line 252
void iv_wait_interest_register(struct iv_wait_interest *this)
{
  struct iv_wait_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_wait_tls_user);
  tinfo = (struct iv_wait_thr_info *)return_value_iv_tls_user_ptr$1;
  __iv_wait_interest_register(tinfo, this);
  pthread_mutex_lock(&iv_wait_lock);
  iv_avl_tree_insert(&iv_wait_interests, &this->avl_node);
  pthread_mutex_unlock(&iv_wait_lock);
}

// iv_wait_interest_register_spawn
// file ../../../src/include/iv_wait.h line 52
signed int iv_wait_interest_register_spawn(struct iv_wait_interest *this, void (*fn)(void *), void *cookie)
{
  struct iv_wait_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_wait_tls_user);
  tinfo = (struct iv_wait_thr_info *)return_value_iv_tls_user_ptr$1;
  signed int pid;
  __iv_wait_interest_register(tinfo, this);
  pthread_mutex_lock(&iv_wait_lock);
  pid=fork();
  if(!(pid >= 0))
  {
    pthread_mutex_unlock(&iv_wait_lock);
    __iv_wait_interest_unregister(tinfo, this);
    return pid;
  }

  else
  {
    if(pid == 0)
    {
      fn(cookie);
      exit(1);
    }

    else
    {
      this->pid = pid;
      iv_avl_tree_insert(&iv_wait_interests, &this->avl_node);
    }
    pthread_mutex_unlock(&iv_wait_lock);
    return 0;
  }
}

// iv_wait_interest_unregister
// file ../../../src/include/iv_wait.h line 54
void iv_wait_interest_unregister(struct iv_wait_interest *this)
{
  struct iv_wait_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_wait_tls_user);
  tinfo = (struct iv_wait_thr_info *)return_value_iv_tls_user_ptr$1;
  pthread_mutex_lock(&iv_wait_lock);
  if((1u & this->flags) == 0u)
    iv_avl_tree_delete(&iv_wait_interests, &this->avl_node);

  pthread_mutex_unlock(&iv_wait_lock);
  __iv_wait_interest_unregister(tinfo, this);
}

// iv_wait_status_dead
// file ../../../src/iv_wait.c line 87
static signed int iv_wait_status_dead(signed int status)
{
  if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
  {
    if(status == 0xffff)
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if((0x7f & status) == 0)
      return 1;

    else
      return 0;
  }
}

// iv_wait_tls_init_thread
// file ../../../src/iv_wait.c line 175
static void iv_wait_tls_init_thread(void *_tinfo)
{
  struct iv_wait_thr_info *tinfo = (struct iv_wait_thr_info *)_tinfo;
  tinfo->wait_count = 0;
  IV_SIGNAL_INIT(&tinfo->sigchld_interest);
  tinfo->sigchld_interest.signum = 17;
  tinfo->sigchld_interest.flags = (unsigned int)1;
  tinfo->sigchld_interest.handler = iv_wait_got_sigchld;
  tinfo->handled_wait_interest = (struct iv_wait_interest *)(void *)0;
}

// iv_work_event
// file ../../../src/iv_work.c line 207
static void iv_work_event(void *_pool)
{
  struct work_pool_priv *pool = (struct work_pool_priv *)_pool;
  struct iv_list_head items;
  mutex_lock$link1(&pool->lock);
  __iv_list_steal_elements$link2(&pool->work_done, &items);
  mutex_unlock$link1(&pool->lock);
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link2(&items);
  struct iv_work_item *tmp_statement_expression$2;
  if(return_value_iv_list_empty$1 == 0)
  {
    struct iv_work_item *work;
    const struct iv_list_head *__ptr = items.next;
    tmp_statement_expression$2 = (struct iv_work_item *)((char *)__ptr - (signed long int)&((struct iv_work_item *)0)->list);
    work = tmp_statement_expression$2;
    iv_list_del$link1(&work->list);
    work->completion(work->cookie);
  }

  signed int return_value_iv_list_empty$3;
  if(!(pool->shutting_down == 0))
  {
    mutex_lock$link1(&pool->lock);
    if(pool->started_threads == 0)
    {
      return_value_iv_list_empty$3=iv_list_empty$link2(&pool->work_done);
      if(!(return_value_iv_list_empty$3 == 0))
      {
        mutex_unlock$link1(&pool->lock);
        mutex_destroy$link1(&pool->lock);
        iv_event_unregister(&pool->ev);
        free((void *)pool);
        goto __CPROVER_DUMP_L5;
      }

    }

    mutex_unlock$link1(&pool->lock);
  }


__CPROVER_DUMP_L5:
  ;
}

// iv_work_handle_local
// file ../../../src/iv_work.c line 378
static void iv_work_handle_local(void *_tinfo)
{
  struct iv_work_thr_info *tinfo = (struct iv_work_thr_info *)_tinfo;
  struct iv_list_head items;
  __iv_list_steal_elements$link2(&tinfo->work_items, &items);
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link2(&items);
  struct iv_work_item *tmp_statement_expression$2;
  if(return_value_iv_list_empty$1 == 0)
  {
    struct iv_work_item *work;
    const struct iv_list_head *__ptr = items.next;
    tmp_statement_expression$2 = (struct iv_work_item *)((char *)__ptr - (signed long int)&((struct iv_work_item *)0)->list);
    work = tmp_statement_expression$2;
    iv_list_del$link1(&work->list);
    work->work(work->cookie);
    work->completion(work->cookie);
  }

}

// iv_work_pool_create
// file ../../../src/iv_work.c line 238
signed int iv_work_pool_create(struct iv_work_pool *this)
{
  struct work_pool_priv *pool;
  signed int ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct work_pool_priv) /*168ul*/ );
  pool = (struct work_pool_priv *)return_value_malloc$1;
  if(pool == ((struct work_pool_priv *)NULL))
    return -1;

  else
  {
    ret=mutex_init$link1(&pool->lock);
    if(!(ret == 0))
    {
      free((void *)pool);
      return -1;
    }

    else
    {
      IV_EVENT_INIT(&pool->ev);
      pool->ev.cookie = (void *)pool;
      pool->ev.handler = iv_work_event;
      iv_event_register(&pool->ev);
      pool->shutting_down = 0;
      pool->started_threads = 0;
      do
      {
        (&pool->idle_threads)->next = &pool->idle_threads;
        (&pool->idle_threads)->prev = &pool->idle_threads;
      }
      while((_Bool)0);
      pool->cookie = this->cookie;
      pool->thread_start = this->thread_start;
      pool->thread_stop = this->thread_stop;
      pool->seq_head = (unsigned int)0;
      pool->seq_tail = (unsigned int)0;
      do
      {
        (&pool->work_items)->next = &pool->work_items;
        (&pool->work_items)->prev = &pool->work_items;
      }
      while((_Bool)0);
      do
      {
        (&pool->work_done)->next = &pool->work_done;
        (&pool->work_done)->prev = &pool->work_done;
      }
      while((_Bool)0);
      this->priv = (void *)pool;
      return 0;
    }
  }
}

// iv_work_pool_put
// file ../../../src/iv_work.c line 274
void iv_work_pool_put(struct iv_work_pool *this)
{
  struct work_pool_priv *pool = (struct work_pool_priv *)this->priv;
  struct iv_list_head *ilh;
  mutex_lock$link1(&pool->lock);
  this->priv = (void *)0;
  pool->shutting_down = 1;
  struct work_pool_thread *tmp_statement_expression$1;
  if(pool->started_threads == 0)
  {
    mutex_unlock$link1(&pool->lock);
    iv_event_post(&pool->ev);
  }

  else
  {
    ilh = (&pool->idle_threads)->next;
    for( ; !(ilh == &pool->idle_threads); ilh = ilh->next)
    {
      struct work_pool_thread *thr;
      const struct iv_list_head *__ptr = ilh;
      tmp_statement_expression$1 = (struct work_pool_thread *)((char *)__ptr - (signed long int)&((struct work_pool_thread *)0)->list);
      thr = tmp_statement_expression$1;
      iv_event_post(&thr->kick);
    }
    mutex_unlock$link1(&pool->lock);
  }
}

// iv_work_pool_submit_work
// file ../../../src/iv_work.c line 406
void iv_work_pool_submit_work(struct iv_work_pool *this, struct iv_work_item *work)
{
  if(!(this == ((struct iv_work_pool *)NULL)))
    iv_work_submit_pool(this, work);

  else
    iv_work_submit_local(work);
}

// iv_work_start_thread
// file ../../../src/iv_work.c line 300
static signed int iv_work_start_thread(struct work_pool_priv *pool)
{
  struct work_pool_thread *thr;
  char name[512l];
  signed int ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct work_pool_thread) /*200ul*/ );
  thr = (struct work_pool_thread *)return_value_malloc$1;
  if(thr == ((struct work_pool_thread *)NULL))
    return -1;

  else
  {
    thr->pool = pool;
    snprintf(name, sizeof(char [512l]) /*512ul*/ , "iv_work pool %p thread %p", pool, thr);
    ret=iv_thread_create(name, iv_work_thread, (void *)thr);
    if(!(ret >= 0))
    {
      free((void *)thr);
      return -1;
    }

    else
    {
      pool->started_threads = pool->started_threads + 1;
      return 0;
    }
  }
}

// iv_work_submit_local
// file ../../../src/iv_work.c line 395
static void iv_work_submit_local(struct iv_work_item *work)
{
  struct iv_work_thr_info *tinfo;
  void *return_value_iv_tls_user_ptr$1;
  return_value_iv_tls_user_ptr$1=iv_tls_user_ptr(&iv_work_tls_user);
  tinfo = (struct iv_work_thr_info *)return_value_iv_tls_user_ptr$1;
  signed int return_value_iv_list_empty$2;
  return_value_iv_list_empty$2=iv_list_empty$link2(&tinfo->work_items);
  if(!(return_value_iv_list_empty$2 == 0))
    iv_task_register(&tinfo->task);

  iv_list_add_tail$link3(&work->list, &tinfo->work_items);
}

// iv_work_submit_pool
// file ../../../src/iv_work.c line 326
static void iv_work_submit_pool(struct iv_work_pool *this, struct iv_work_item *work)
{
  struct work_pool_priv *pool = (struct work_pool_priv *)this->priv;
  mutex_lock$link1(&pool->lock);
  pool->seq_tail = pool->seq_tail + 1u;
  iv_list_add_tail$link3(&work->list, &pool->work_items);
  signed int return_value_iv_list_empty$2;
  return_value_iv_list_empty$2=iv_list_empty$link2(&pool->idle_threads);
  struct work_pool_thread *tmp_statement_expression$1;
  if(return_value_iv_list_empty$2 == 0)
  {
    struct work_pool_thread *thr;
    const struct iv_list_head *__ptr = pool->idle_threads.next;
    tmp_statement_expression$1 = (struct work_pool_thread *)((char *)__ptr - (signed long int)&((struct work_pool_thread *)0)->list);
    thr = tmp_statement_expression$1;
    thr->kicked = 1;
    iv_event_post(&thr->kick);
  }

  else
    if(!(pool->started_threads >= this->max_threads))
      iv_work_start_thread(pool);

  mutex_unlock$link1(&pool->lock);
}

// iv_work_thread
// file ../../../src/iv_work.c line 172
static void iv_work_thread(void *_thr)
{
  struct work_pool_thread *thr = (struct work_pool_thread *)_thr;
  struct work_pool_priv *pool = thr->pool;
  iv_init();
  do
  {
    (&thr->list)->next = &thr->list;
    (&thr->list)->prev = &thr->list;
  }
  while((_Bool)0);
  thr->kicked = 0;
  IV_EVENT_INIT(&thr->kick);
  thr->kick.cookie = (void *)thr;
  thr->kick.handler = iv_work_thread_got_event;
  iv_event_register(&thr->kick);
  IV_TASK_INIT(&thr->work_task);
  thr->work_task.cookie = (void *)thr;
  thr->work_task.handler = iv_work_thread_do_work;
  iv_task_register(&thr->work_task);
  IV_TIMER_INIT(&thr->idle_timer);
  thr->idle_timer.cookie = (void *)thr;
  thr->idle_timer.handler = iv_work_thread_idle_timeout;
  if(!(pool->thread_start == ((void (*)(void *))NULL)))
    pool->thread_start(pool->cookie);

  iv_main();
  iv_deinit();
}

// iv_work_thread_do_work
// file ../../../src/iv_work.c line 100
static void iv_work_thread_do_work(void *_thr)
{
  struct work_pool_thread *thr = (struct work_pool_thread *)_thr;
  struct work_pool_priv *pool = thr->pool;
  unsigned int last_seq;
  mutex_lock$link1(&pool->lock);
  last_seq = pool->seq_tail;
  struct iv_work_item *tmp_statement_expression$1;
  if((signed int)last_seq + -((signed int)pool->seq_head) >= 1)
  {
    struct iv_work_item *work;
    pool->seq_head = pool->seq_head + 1u;
    const struct iv_list_head *__ptr = pool->work_items.next;
    tmp_statement_expression$1 = (struct iv_work_item *)((char *)__ptr - (signed long int)&((struct iv_work_item *)0)->list);
    work = tmp_statement_expression$1;
    iv_list_del$link1(&work->list);
    mutex_unlock$link1(&pool->lock);
    work->work(work->cookie);
    iv_invalidate_now();
    mutex_lock$link1(&pool->lock);
    signed int return_value_iv_list_empty$2;
    return_value_iv_list_empty$2=iv_list_empty$link2(&pool->work_done);
    if(!(return_value_iv_list_empty$2 == 0))
      iv_event_post(&pool->ev);

    iv_list_add_tail$link3(&work->list, &pool->work_done);
  }

  if(pool->seq_head == pool->seq_tail)
  {
    if(pool->shutting_down == 0)
    {
      iv_list_add(&thr->list, &pool->idle_threads);
      iv_validate_now();
      struct timespec *return_value___iv_now_location$3;
      return_value___iv_now_location$3=__iv_now_location();
      thr->idle_timer.expires = *return_value___iv_now_location$3;
      thr->idle_timer.expires.tv_sec = thr->idle_timer.expires.tv_sec + (signed long int)10;
      iv_timer_register(&thr->idle_timer);
    }

    else
      __iv_work_thread_die(thr);
  }

  else
    iv_task_register(&thr->work_task);
  mutex_unlock$link1(&pool->lock);
}

// iv_work_thread_got_event
// file ../../../src/iv_work.c line 60
static void iv_work_thread_got_event(void *_thr)
{
  struct work_pool_thread *thr = (struct work_pool_thread *)_thr;
  struct work_pool_priv *pool = thr->pool;
  mutex_lock$link1(&pool->lock);
  thr->kicked = 0;
  signed int return_value_iv_list_empty$1;
  return_value_iv_list_empty$1=iv_list_empty$link2(&thr->list);
  if(return_value_iv_list_empty$1 == 0)
  {
    iv_list_del_init$link2(&thr->list);
    iv_task_register(&thr->work_task);
    iv_timer_unregister(&thr->idle_timer);
  }

  mutex_unlock$link1(&pool->lock);
}

// iv_work_thread_idle_timeout
// file ../../../src/iv_work.c line 153
static void iv_work_thread_idle_timeout(void *_thr)
{
  struct work_pool_thread *thr = (struct work_pool_thread *)_thr;
  struct work_pool_priv *pool = thr->pool;
  mutex_lock$link1(&pool->lock);
  if(!(thr->kicked == 0))
  {
    struct timespec *return_value___iv_now_location$1;
    return_value___iv_now_location$1=__iv_now_location();
    thr->idle_timer.expires = *return_value___iv_now_location$1;
    thr->idle_timer.expires.tv_sec = thr->idle_timer.expires.tv_sec + (signed long int)10;
    iv_timer_register(&thr->idle_timer);
  }

  else
  {
    iv_list_del_init$link2(&thr->list);
    __iv_work_thread_die(thr);
  }
  mutex_unlock$link1(&pool->lock);
}

// iv_work_tls_init_thread
// file ../../../src/iv_work.c line 356
static void iv_work_tls_init_thread(void *_tinfo)
{
  struct iv_work_thr_info *tinfo = (struct iv_work_thr_info *)_tinfo;
  IV_TASK_INIT(&tinfo->task);
  tinfo->task.cookie = (void *)tinfo;
  tinfo->task.handler = iv_work_handle_local;
  do
  {
    (&tinfo->work_items)->next = &tinfo->work_items;
    (&tinfo->work_items)->prev = &tinfo->work_items;
  }
  while((_Bool)0);
}

// main
// file ../../../test/iv_fd_pump_discard.c line 126
signed int main()
{
  devnull=open("/dev/null", 01);
  if(!(devnull >= 0))
  {
    perror("open /dev/null");
    return 1;
  }

  else
  {
    iv_init();
    open_listening_socket();
    iv_main();
    return 0;
  }
}

// method_is_excluded
// file ../../../src/iv_fd.c line 65
static signed int method_is_excluded(char *exclude, char *name)
{
  signed int return_value_sscanf$1;
  if(!(exclude == ((char *)NULL)))
  {
    char method_name[64l];
    signed int len;
    do
    {
      return_value_sscanf$1=sscanf(exclude, "%63s%n", (const void *)method_name, &len);
      if(!(return_value_sscanf$1 >= 1))
        break;

      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(name, method_name);
      if(return_value_strcmp$2 == 0)
        return 1;

      exclude = exclude + (signed long int)len;
    }
    while((_Bool)1);
  }

  return 0;
}

// mutex_destroy
// file ../../../src/mutex.h line 31
static inline void mutex_destroy(union anonymous$38 *mutex)
{
  pthread_mutex_destroy(mutex);
}

// mutex_destroy$link1
// file ../../../src/mutex.h line 31
static inline void mutex_destroy$link1(union anonymous$38 *mutex$link1)
{
  pthread_mutex_destroy(mutex$link1);
}

// mutex_init
// file ../../../src/mutex.h line 26
static inline signed int mutex_init(union anonymous$38 *mutex)
{
  signed int return_value_pthread_mutex_init$1;
  return_value_pthread_mutex_init$1=pthread_mutex_init(mutex, (const union anonymous$37 *)(void *)0);
  return return_value_pthread_mutex_init$1;
}

// mutex_init$link1
// file ../../../src/mutex.h line 26
static inline signed int mutex_init$link1(union anonymous$38 *mutex$link1)
{
  signed int return_value_pthread_mutex_init$1$link1;
  return_value_pthread_mutex_init$1$link1=pthread_mutex_init(mutex$link1, (const union anonymous$37 *)(void *)0);
  return return_value_pthread_mutex_init$1$link1;
}

// mutex_lock
// file ../../../src/mutex.h line 36
static inline void mutex_lock(union anonymous$38 *mutex)
{
  pthread_mutex_lock(mutex);
}

// mutex_lock$link1
// file ../../../src/mutex.h line 36
static inline void mutex_lock$link1(union anonymous$38 *mutex$link1)
{
  pthread_mutex_lock(mutex$link1);
}

// mutex_unlock
// file ../../../src/mutex.h line 41
static inline void mutex_unlock(union anonymous$38 *mutex)
{
  pthread_mutex_unlock(mutex);
}

// mutex_unlock$link1
// file ../../../src/mutex.h line 41
static inline void mutex_unlock$link1(union anonymous$38 *mutex$link1)
{
  pthread_mutex_unlock(mutex$link1);
}

// notify_fd
// file ../../../src/iv_fd.c line 237
static void notify_fd(struct iv_state *st, struct iv_fd_ *fd)
{
  recompute_wanted_flags(fd);
  method->notify_fd(st, fd);
}

// open_listening_socket
// file ../../../test/iv_fd_pump_discard.c line 96
static signed int open_listening_socket(void)
{
  struct sockaddr_in addr;
  signed int sock;
  sock=socket(2, 1, 0);
  if(!(sock >= 0))
  {
    perror("socket");
    return 1;
  }

  else
  {
    addr.sin_family = (unsigned short int)2;
    addr.sin_addr.s_addr=htonl((unsigned int)0x00000000);
    addr.sin_port=htons((unsigned short int)10009);
    signed int return_value_bind$1;
    return_value_bind$1=bind(sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind$1 >= 0))
    {
      perror("bind");
      return 1;
    }

    else
    {
      listen(sock, 5);
      IV_FD_INIT(&listening_socket);
      listening_socket.fd = sock;
      listening_socket.cookie = (void *)0;
      listening_socket.handler_in = got_connection;
      iv_fd_register(&listening_socket);
      return 0;
    }
  }
}

// pull_up
// file ../../../src/iv_timer.c line 206
static void pull_up(struct iv_state *st, signed int index, struct iv_timer_ **i)
{
  while(!(index == 1))
  {
    struct iv_timer_ *et;
    signed int parent;
    struct iv_timer_ **p;
    parent = index / 2;
    p=iv_timer_get_node(st, parent);
    signed int return_value_timer_ptr_gt$1;
    return_value_timer_ptr_gt$1=timer_ptr_gt(*p, *i);
    if(return_value_timer_ptr_gt$1 == 0)
      break;

    et = *i;
    *i = *p;
    *p = et;
    (*i)->index = index;
    (*p)->index = parent;
    index = parent;
    i = p;
  }
}

// push_down
// file ../../../src/iv_timer.c line 253
static void push_down(struct iv_state *st, signed int index, struct iv_timer_ **i)
{
  signed int return_value_timer_ptr_gt$2;
  while((_Bool)1)
  {
    struct iv_timer_ *et;
    struct iv_timer_ **imin;
    signed int index_min = index;
    imin = i;
    if(st->num_timers >= 2 * index)
    {
      struct iv_timer_ **p;
      p=iv_timer_get_node(st, 2 * index);
      signed int return_value_timer_ptr_gt$1;
      return_value_timer_ptr_gt$1=timer_ptr_gt(*imin, p[(signed long int)0]);
      if(!(return_value_timer_ptr_gt$1 == 0))
      {
        index_min = 2 * index;
        imin = p;
      }

      if(!(p[1l] == ((struct iv_timer_ *)NULL)))
      {
        return_value_timer_ptr_gt$2=timer_ptr_gt(*imin, p[(signed long int)1]);
        if(!(return_value_timer_ptr_gt$2 == 0))
        {
          index_min = 2 * index + 1;
          imin = p + (signed long int)1;
        }

      }

    }

    if(index == index_min)
      break;

    et = *i;
    *i = *imin;
    *imin = et;
    (*i)->index = index;
    (*imin)->index = index_min;
    index = index_min;
    i = imin;
  }
}

// rebalance_node
// file ../../../src/iv_avl.c line 197
static void rebalance_node(struct iv_avl_node **_root)
{
  struct iv_avl_node *root = *_root;
  signed int bal;
  bal=balance(root);
  if(bal == -2)
  {
    signed int return_value_balance$1;
    return_value_balance$1=balance(root->left);
    if(!(return_value_balance$1 >= 1))
      rotate_right(_root);

    else
      rotate_left_right(_root);
  }

  else
    if(bal == 2)
    {
      signed int return_value_balance$2;
      return_value_balance$2=balance(root->right);
      if(!(return_value_balance$2 >= 0))
        rotate_right_left(_root);

      else
        rotate_left(_root);
    }

}

// rebalance_path
// file ../../../src/iv_avl.c line 245
static void rebalance_path(struct iv_avl_tree *tree, struct iv_avl_node *an)
{
  while(!(an == ((struct iv_avl_node *)NULL)))
  {
    signed int old_height;
    struct iv_avl_node **ref;
    old_height = (signed int)an->height;
    recalc_height(an);
    ref=find_reference(tree, an);
    rebalance_node(ref);
    an = *ref;
    if(old_height == (signed int)an->height)
      break;

    an = an->parent;
  }
}

// recalc_height
// file ../../../src/iv_avl.c line 30
static void recalc_height(struct iv_avl_node *an)
{
  signed int hl;
  signed int hr;
  hl=height(an->left);
  hr=height(an->right);
  an->height = (unsigned char)(1 + (hl > hr ? hl : hr));
}

// recompute_wanted_flags
// file ../../../src/iv_fd.c line 220
static void recompute_wanted_flags(struct iv_fd_ *fd)
{
  signed int wanted = 0;
  if(!(fd->registered == 0u))
  {
    if(!(fd->handler_in == ((void (*)(void *))NULL)))
      wanted = wanted | 1;

    if(!(fd->handler_out == ((void (*)(void *))NULL)))
      wanted = wanted | 2;

    if(!(fd->handler_err == ((void (*)(void *))NULL)))
      wanted = wanted | 4;

  }

  fd->wanted_bands = (unsigned int)wanted;
}

// replace_reference
// file ../../../src/iv_avl.c line 233
static void replace_reference(struct iv_avl_tree *tree, struct iv_avl_node *an, struct iv_avl_node *new_child)
{
  struct iv_avl_node **return_value_find_reference$1;
  return_value_find_reference$1=find_reference(tree, an);
  *return_value_find_reference$1 = new_child;
}

// rotate_left
// file ../../../src/iv_avl.c line 92
static void rotate_left(struct iv_avl_node **root)
{
  struct iv_avl_node *b = *root;
  struct iv_avl_node *d = b->right;
  struct iv_avl_node *c = d->left;
  b->right = c;
  if(!(c == ((struct iv_avl_node *)NULL)))
    c->parent = b;

  recalc_height(b);
  d->left = b;
  d->parent = b->parent;
  b->parent = d;
  recalc_height(d);
  *root = d;
}

// rotate_left_right
// file ../../../src/iv_avl.c line 132
static void rotate_left_right(struct iv_avl_node **root)
{
  struct iv_avl_node *f = *root;
  struct iv_avl_node *b = f->left;
  struct iv_avl_node *d = b->right;
  struct iv_avl_node *c;
  struct iv_avl_node *e;
  c = d->left;
  b->right = c;
  if(!(c == ((struct iv_avl_node *)NULL)))
    c->parent = b;

  recalc_height(b);
  e = d->right;
  f->left = e;
  if(!(e == ((struct iv_avl_node *)NULL)))
    e->parent = f;

  recalc_height(f);
  d->left = b;
  d->right = f;
  d->parent = f->parent;
  b->parent = d;
  f->parent = d;
  recalc_height(d);
  *root = d;
}

// rotate_right
// file ../../../src/iv_avl.c line 112
static void rotate_right(struct iv_avl_node **root)
{
  struct iv_avl_node *d = *root;
  struct iv_avl_node *b = d->left;
  struct iv_avl_node *c = b->right;
  d->left = c;
  if(!(c == ((struct iv_avl_node *)NULL)))
    c->parent = d;

  recalc_height(d);
  b->right = d;
  b->parent = d->parent;
  d->parent = b;
  recalc_height(b);
  *root = b;
}

// rotate_right_left
// file ../../../src/iv_avl.c line 162
static void rotate_right_left(struct iv_avl_node **root)
{
  struct iv_avl_node *b = *root;
  struct iv_avl_node *f = b->right;
  struct iv_avl_node *d = f->left;
  struct iv_avl_node *c;
  struct iv_avl_node *e;
  c = d->left;
  b->right = c;
  if(!(c == ((struct iv_avl_node *)NULL)))
    c->parent = b;

  recalc_height(b);
  e = d->right;
  f->left = e;
  if(!(e == ((struct iv_avl_node *)NULL)))
    e->parent = f;

  recalc_height(f);
  d->left = b;
  d->right = f;
  d->parent = b->parent;
  b->parent = d;
  f->parent = d;
  recalc_height(d);
  *root = d;
}

// sanitise_nofile_rlimit
// file ../../../src/iv_fd.c line 34
static void sanitise_nofile_rlimit(signed int euid)
{
  struct rlimit lim;
  getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
  maxfd = (signed int)lim.rlim_cur;
  if(!(euid == 0))
  {
    if(!(lim.rlim_cur >= lim.rlim_max))
    {
      lim.rlim_cur = (unsigned long int)((unsigned int)lim.rlim_max & (unsigned int)0x7FFFFFFF);
      if(lim.rlim_cur >= 131073ul)
        lim.rlim_cur = (unsigned long int)131072;

      signed int return_value_setrlimit$1;
      return_value_setrlimit$1=setrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
      if(return_value_setrlimit$1 >= 0)
        maxfd = (signed int)lim.rlim_cur;

    }

  }

  else
  {
    lim.rlim_cur = (unsigned long int)131072;
    lim.rlim_max = (unsigned long int)131072;
    while(!((unsigned long int)maxfd >= lim.rlim_cur))
    {
      signed int return_value_setrlimit$2;
      return_value_setrlimit$2=setrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
      if(return_value_setrlimit$2 >= 0)
      {
        maxfd = (signed int)lim.rlim_cur;
        break;
      }

      lim.rlim_cur = lim.rlim_cur / (unsigned long int)2;
      lim.rlim_max = lim.rlim_max / (unsigned long int)2;
    }
  }
}

// spin_lock
// file ../../../src/spinlock.h line 31
static inline void spin_lock(volatile signed int *lock)
{
  pthread_spin_lock(lock);
}

// spin_lock_sigmask
// file ../../../src/spinlock.h line 76
static inline void spin_lock_sigmask(volatile signed int *lock, struct anonymous$17 *mask)
{
  sigfillset(mask);
  pthread_sigmask(0, mask, mask);
  spin_lock(lock);
}

// spin_unlock
// file ../../../src/spinlock.h line 36
static inline void spin_unlock(volatile signed int *lock)
{
  pthread_spin_unlock(lock);
}

// spin_unlock_sigmask
// file ../../../src/spinlock.h line 84
static inline void spin_unlock_sigmask(volatile signed int *lock, struct anonymous$17 *mask)
{
  spin_unlock(lock);
  pthread_sigmask(2, mask, (struct anonymous$17 *)(void *)0);
}

// timer_ptr_gt
// file ../../../src/iv_timer.c line 201
static inline signed int timer_ptr_gt(struct iv_timer_ *a, struct iv_timer_ *b)
{
  signed int return_value_timespec_gt$1;
  return_value_timespec_gt$1=timespec_gt(&a->expires, &b->expires);
  return return_value_timespec_gt$1;
}

// timespec_gt
// file ../../../src/iv_timer.c line 130
static inline signed int timespec_gt(struct timespec *a, struct timespec *b)
{
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(b->tv_sec >= a->tv_sec))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(a->tv_sec == b->tv_sec)
      tmp_if_expr$1 = a->tv_nsec > b->tv_nsec ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)!(!tmp_if_expr$2);
}

