// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'visualid'||S32'screen'||S32'depth'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'colormap_size'||S32'bits_per_rgb'|]
// file /usr/include/X11/Xutil.h line 287
struct anonymous$2;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$9;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$10;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$7;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$3;

// tag-#anon#ST[*{V}$V$'pointer'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 99
struct anonymous$5;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$6;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$0;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$8;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$4;

// tag-#anon#ST[U32'sequence'|]
// file /usr/include/xcb/xcb.h line 187
struct anonymous$11;

// tag-#anon#ST[U8'response_type'||U8'error_code'||U16'sequence'||U32'resource_id'||U16'minor_code'||U8'major_code'||U8'pad0'||ARR5{U32}$U32$'pad'||U32'full_sequence'|]
// file /usr/include/xcb/xcb.h line 170
struct anonymous$12;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$13;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-CheckIntegerRange
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 154
struct CheckIntegerRange;

// tag-CheckIntegerSet
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 161
struct CheckIntegerSet;

// tag-CheckMemoryData
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 169
struct CheckMemoryData;

// tag-CheckParameterEvent
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1603
struct CheckParameterEvent;

// tag-ListNode
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 108
struct ListNode;

// tag-MallocBlockInfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 116
struct MallocBlockInfo;

// tag-SourceLocation
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1597
struct SourceLocation;

// tag-SymbolMapValue
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 145
struct SymbolMapValue;

// tag-SymbolValue
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 135
struct SymbolValue;

// tag-TestState
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 125
struct TestState;

// tag-UnitTest
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1589
struct UnitTest;

// tag-UnitTestFunctionType
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1578
enum UnitTestFunctionType { UNIT_TEST_FUNCTION_TYPE_TEST=0, UNIT_TEST_FUNCTION_TYPE_SETUP=1, UNIT_TEST_FUNCTION_TYPE_TEARDOWN=2 };

// tag-ValuePointer
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 97
union ValuePointer;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__GLXFBConfigRec
// file /usr/include/GL/glx.h line 169
struct __GLXFBConfigRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-api_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_object.h line 33
struct api_object;

// tag-gbm_bo
// file /usr/include/EGL/eglplatform.h line 95
struct gbm_bo;

// tag-gbm_device
// file /usr/include/gbm.h line 46
struct gbm_device;

// tag-gbm_surface
// file /usr/include/gbm.h line 48
struct gbm_surface;

// tag-glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 40
struct glx_config;

// tag-glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 38
struct glx_context;

// tag-glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 43
struct glx_display;

// tag-glx_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 36
struct glx_platform;

// tag-glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 37
struct glx_window;

// tag-impl_thrd_param
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 60
struct impl_thrd_param;

// tag-linux_dl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.h line 34
struct linux_dl;

// tag-linux_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 31
struct linux_platform;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-thread_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 136
struct thread_arg;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-udev
// file /usr/include/libudev.h line 36
struct udev;

// tag-udev_device
// file /usr/include/libudev.h line 76
struct udev_device;

// tag-udev_enumerate
// file /usr/include/libudev.h line 140
struct udev_enumerate;

// tag-udev_list_entry
// file /usr/include/libudev.h line 54
struct udev_list_entry;

// tag-waffle_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 40
struct waffle_config;

// tag-waffle_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 41
struct waffle_context;

// tag-waffle_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 39
struct waffle_display;

// tag-waffle_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 53
enum waffle_error { WAFFLE_NO_ERROR=0, WAFFLE_ERROR_FATAL=1, WAFFLE_ERROR_UNKNOWN=2, WAFFLE_ERROR_INTERNAL=3, WAFFLE_ERROR_BAD_ALLOC=4, WAFFLE_ERROR_NOT_INITIALIZED=5, WAFFLE_ERROR_ALREADY_INITIALIZED=6, WAFFLE_ERROR_BAD_ATTRIBUTE=8, WAFFLE_ERROR_BAD_PARAMETER=16, WAFFLE_ERROR_BAD_DISPLAY_MATCH=17, WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM=18, WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT=19 };

// tag-waffle_error_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 68
struct waffle_error_info;

// tag-waffle_gbm_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 264
struct waffle_gbm_config;

// tag-waffle_gbm_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 265
struct waffle_gbm_context;

// tag-waffle_gbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 266
struct waffle_gbm_display;

// tag-waffle_gbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 267
struct waffle_gbm_window;

// tag-waffle_glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 268
struct waffle_glx_config;

// tag-waffle_glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 269
struct waffle_glx_context;

// tag-waffle_glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 270
struct waffle_glx_display;

// tag-waffle_glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 271
struct waffle_glx_window;

// tag-waffle_native_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 45
union waffle_native_config;

// tag-waffle_native_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 46
union waffle_native_context;

// tag-waffle_native_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 44
union waffle_native_display;

// tag-waffle_native_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 47
union waffle_native_window;

// tag-waffle_wayland_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 272
struct waffle_wayland_config;

// tag-waffle_wayland_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 273
struct waffle_wayland_context;

// tag-waffle_wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 274
struct waffle_wayland_display;

// tag-waffle_wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 275
struct waffle_wayland_window;

// tag-waffle_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 42
struct waffle_window;

// tag-waffle_x11_egl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 276
struct waffle_x11_egl_config;

// tag-waffle_x11_egl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 277
struct waffle_x11_egl_context;

// tag-waffle_x11_egl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 278
struct waffle_x11_egl_display;

// tag-waffle_x11_egl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 279
struct waffle_x11_egl_window;

// tag-wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 43
struct wayland_display;

// tag-wayland_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.h line 40
struct wayland_platform;

// tag-wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 39
struct wayland_window;

// tag-wcore_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 39
struct wcore_config;

// tag-wcore_config_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.h line 32
struct wcore_config_attrs;

// tag-wcore_config_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 85
struct wcore_config_vtbl;

// tag-wcore_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 37
struct wcore_context;

// tag-wcore_context_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 99
struct wcore_context_vtbl;

// tag-wcore_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 34
struct wcore_display;

// tag-wcore_display_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 67
struct wcore_display_vtbl;

// tag-wcore_error_tinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 33
struct wcore_error_tinfo;

// tag-wcore_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.h line 51
struct wcore_platform;

// tag-wcore_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 40
struct wcore_platform_vtbl;

// tag-wcore_tinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.h line 31
struct wcore_tinfo;

// tag-wcore_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 38
struct wcore_window;

// tag-wcore_window_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 113
struct wcore_window_vtbl;

// tag-wegl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 40
struct wegl_config;

// tag-wegl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 38
struct wegl_context;

// tag-wegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 37
struct wegl_display;

// tag-wegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform;

// tag-wegl_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform$0;

// tag-wegl_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform$1;

// tag-wegl_platform$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform$2;

// tag-wegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 38
struct wegl_window;

// tag-wgbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 38
struct wgbm_display;

// tag-wgbm_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 39
struct wgbm_platform$0;

// tag-wgbm_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 39
struct wgbm_platform;

// tag-wgbm_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 39
struct wgbm_platform$1;

// tag-wgbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 35
struct wgbm_window;

// tag-wl_compositor
// file /usr/include/wayland-client-protocol.h line 44
struct wl_compositor;

// tag-wl_display
// file /usr/include/wayland-client-core.h line 109
struct wl_display;

// tag-wl_egl_window
// file /usr/include/EGL/eglplatform.h line 90
struct wl_egl_window;

// tag-wl_interface
// file /usr/include/wayland-util.h line 67
struct wl_interface;

// tag-wl_message
// file /usr/include/wayland-util.h line 64
struct wl_message;

// tag-wl_proxy
// file /usr/include/wayland-client-core.h line 52
struct wl_proxy;

// tag-wl_registry
// file /usr/include/wayland-client-protocol.h line 54
struct wl_registry;

// tag-wl_registry_listener
// file /usr/include/wayland-client-protocol.h line 217
struct wl_registry_listener;

// tag-wl_shell
// file /usr/include/wayland-client-protocol.h line 56
struct wl_shell;

// tag-wl_shell_surface
// file /usr/include/wayland-client-protocol.h line 57
struct wl_shell_surface;

// tag-wl_shell_surface_listener
// file /usr/include/wayland-client-protocol.h line 1190
struct wl_shell_surface_listener;

// tag-wl_surface
// file /usr/include/wayland-client-protocol.h line 62
struct wl_surface;

// tag-x11_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 32
struct x11_display;

// tag-x11_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 34
struct x11_window;

// tag-xcb_connection_t
// file /usr/include/xcb/xcb.h line 104
struct xcb_connection_t;

// tag-xcb_depth_iterator_t
// file /usr/include/xcb/xproto.h line 313
struct xcb_depth_iterator_t;

// tag-xcb_depth_t
// file /usr/include/xcb/xproto.h line 303
struct xcb_depth_t;

// tag-xcb_screen_iterator_t
// file /usr/include/xcb/xproto.h line 379
struct xcb_screen_iterator_t;

// tag-xcb_screen_t
// file /usr/include/xcb/xproto.h line 357
struct xcb_screen_t;

// tag-xcb_setup_t
// file /usr/include/xcb/xproto.h line 453
struct xcb_setup_t;

// tag-xcb_visualtype_iterator_t
// file /usr/include/xcb/xproto.h line 294
struct xcb_visualtype_iterator_t;

// tag-xcb_visualtype_t
// file /usr/include/xcb/xproto.h line 280
struct xcb_visualtype_t;

// tag-xegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 39
struct xegl_display;

// tag-xegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.h line 39
struct xegl_platform;

// tag-xegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 39
struct xegl_window;

// tag-xtime
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 122
struct xtime;

#ifndef NULL
#define NULL ((void*)0)
#endif

// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XGetXCBConnection
// file /usr/include/X11/Xlib-xcb.h line 13
struct xcb_connection_t * XGetXCBConnection(struct _XDisplay *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous$4 *)))(struct _XDisplay *, struct anonymous$4 *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _assert_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1353
void _assert_in_range(const unsigned long long int value, const unsigned long long int minimum, const unsigned long long int maximum, const char * const file, const signed int line);
// _assert_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1371
void _assert_in_set(const unsigned long long int value, const unsigned long long int *values, const unsigned long int number_of_values, const char * const file, const signed int line);
// _assert_int_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1687
void _assert_int_equal(const unsigned long long int a, const unsigned long long int b, const char * const file, const signed int line);
// _assert_int_not_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1309
void _assert_int_not_equal(const unsigned long long int a, const unsigned long long int b, const char * const file, const signed int line);
// _assert_memory_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1334
void _assert_memory_equal(const void * const a, const void * const b, const unsigned long int size, const char * const file, const signed int line);
// _assert_memory_not_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1343
void _assert_memory_not_equal(const void * const a, const void * const b, const unsigned long int size, const char * const file, const signed int line);
// _assert_not_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1362
void _assert_not_in_range(const unsigned long long int value, const unsigned long long int minimum, const unsigned long long int maximum, const char * const file, const signed int line);
// _assert_not_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1383
void _assert_not_in_set(const unsigned long long int value, const unsigned long long int *values, const unsigned long int number_of_values, const char * const file, const signed int line);
// _assert_string_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1693
void _assert_string_equal(const char * const a, const char * const b, const char * const file, const signed int line);
// _assert_string_not_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1326
void _assert_string_not_equal(const char * const a, const char * const b, const char *file, const signed int line);
// _assert_true
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1684
void _assert_true(const unsigned long long int result, const char * const expression, const char * const file, const signed int line);
// _check_expected
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1232
void _check_expected(const char * const function_name, const char * const parameter_name, const char *file, const signed int line, const unsigned long long int value);
// _expect_any
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1224
void _expect_any(const char * const function, const char * const parameter, const char * const file, const signed int line, const signed int count);
// _expect_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 746
void _expect_check(const char * const function, const char * const parameter, const char * const file, const signed int line, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const unsigned long long int check_data, struct CheckParameterEvent * const event, const signed int count);
// _expect_check::check_function$object
// 
signed int check_function$object(const unsigned long long int, const unsigned long long int);
// _expect_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1047
void _expect_in_range(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int minimum, const unsigned long long int maximum, const signed int count);
// _expect_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 984
void _expect_in_set(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int *values, const unsigned long int number_of_values, const signed int count);
// _expect_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1181
void _expect_memory(const char * const function, const char * const parameter, const char * const file, const signed int line, const void * const memory, const unsigned long int size, const signed int count);
// _expect_not_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1058
void _expect_not_in_range(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int minimum, const unsigned long long int maximum, const signed int count);
// _expect_not_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 995
void _expect_not_in_set(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int *values, const unsigned long int number_of_values, const signed int count);
// _expect_not_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1205
void _expect_not_memory(const char * const function, const char * const parameter, const char * const file, const signed int line, const void * const memory, const unsigned long int size, const signed int count);
// _expect_not_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1136
void _expect_not_string(const char * const function, const char * const parameter, const char * const file, const signed int line, const char *string, const signed int count);
// _expect_not_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1095
void _expect_not_value(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int value, const signed int count);
// _expect_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1114
void _expect_string(const char * const function, const char * const parameter, const char * const file, const signed int line, const char *string, const signed int count);
// _expect_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1077
void _expect_value(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int value, const signed int count);
// _fail
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1553
void _fail(const char * const file, const signed int line);
// _mock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 695
unsigned long long int _mock(const char * const function, const char * const file, const signed int line);
// _run_test
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1646
signed int _run_test(const char * const function_name, void (* const Function)(void **), void ** const volatile state, const enum UnitTestFunctionType function_type, const void * const heap_check_point);
// _run_test::Function$object
// 
void Function$object(void **);
// _run_tests
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1726
signed int _run_tests(const struct UnitTest * const tests, const unsigned long int number_of_tests);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// _test_calloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1439
void * _test_calloc(const unsigned long int number_of_elements, const unsigned long int size, const char *file, const signed int line);
// _test_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1451
void _test_free(void * const ptr, const char *file, const signed int line);
// _test_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1408
void * _test_malloc(const unsigned long int size, const char *file, const signed int line);
// _wcore_error_disable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 90
void _wcore_error_disable(void);
// _wcore_error_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 89
void _wcore_error_enable(void);
// _wcore_error_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 87
void _wcore_error_internal(const char *file, signed int line, const char *format, ...);
// _will_return
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 727
void _will_return(const char * const function_name, const char * const file, const signed int line, const unsigned long long int value, const signed int count);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_symbol_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 525
static void add_symbol_value(struct ListNode * const symbol_map_head, const char * const *symbol_names, const unsigned long int number_of_symbol_names, const void *value, const signed int refcount);
// api_check_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.c line 38
_Bool api_check_entry(struct api_object **obj_list, signed int length);
// bind_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 38
static _Bool bind_api(struct wegl_platform *plat, signed int waffle_context_api);
// call_once
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 147
void call_once(signed int *flag, void (*func)(void));
// call_once::func$object
// 
//void func$object(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_any
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1215
static signed int check_any(const unsigned long long int value, const unsigned long long int check_value_data);
// check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 41
static _Bool check_context_attrs(struct wegl_display *dpy, struct wcore_config_attrs *attrs);
// check_final
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 456
static _Bool check_final(struct wcore_config_attrs *attrs);
// check_for_leftover_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 653
static signed int check_for_leftover_values(const struct ListNode * const map_head, const char * const error_message, const unsigned long int number_of_symbol_names);
// check_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1006
static signed int check_in_range(const unsigned long long int value, const unsigned long long int check_value_data);
// check_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 943
static signed int check_in_set(const unsigned long long int value, const unsigned long long int check_value_data);
// check_keys
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 42
static _Bool check_keys(const signed int *attrib_list);
// check_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1148
static signed int check_memory(const unsigned long long int value, const unsigned long long int check_value_data);
// check_not_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1018
static signed int check_not_in_range(const unsigned long long int value, const unsigned long long int check_value_data);
// check_not_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 952
static signed int check_not_in_set(const unsigned long long int value, const unsigned long long int check_value_data);
// check_not_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1192
static signed int check_not_memory(const unsigned long long int value, const unsigned long long int check_value_data);
// check_not_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1127
static signed int check_not_string(const unsigned long long int value, const unsigned long long int check_value_data);
// check_not_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1088
static signed int check_not_value(const unsigned long long int value, const unsigned long long int check_value_data);
// check_point_allocated_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1491
static const struct ListNode * check_point_allocated_blocks();
// check_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1105
static signed int check_string(const unsigned long long int value, const unsigned long long int check_value_data);
// check_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1070
static signed int check_value(const unsigned long long int value, const unsigned long long int check_value_data);
// choose_real_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 130
static void * choose_real_config(struct wegl_display *dpy, struct wcore_config_attrs *attrs);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// cnd_broadcast
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 149
signed int cnd_broadcast(union anonymous$1 *cond);
// cnd_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 150
void cnd_destroy(union anonymous$1 *cond);
// cnd_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 151
signed int cnd_init(union anonymous$1 *cond);
// cnd_signal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 106
signed int cnd_signal(union anonymous$1 *cond);
// cnd_timedwait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 114
signed int cnd_timedwait(union anonymous$1 *cond, union anonymous *mtx, const struct xtime *xt);
// cnd_wait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 154
signed int cnd_wait(union anonymous$1 *cond, union anonymous *mtx);
// create_real_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 64
static void * create_real_context(struct wegl_config *config, void *share_ctx);
// display_allocated_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1498
static signed int display_allocated_blocks(const struct ListNode * const check_point);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// exception_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1560
static void exception_handler(signed int sig);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_test
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 300
static void exit_test(const signed int quit_application);
// expect_memory_setup
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1161
static void expect_memory_setup(const char * const function, const char * const parameter, const char * const file, const signed int line, const void * const memory, const unsigned long int size, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const signed int count);
// expect_memory_setup::check_function$object
// 
signed int check_function$object(const unsigned long long int, const unsigned long long int);
// expect_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1031
static void expect_range(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int minimum, const unsigned long long int maximum, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const signed int count);
// expect_range::check_function$object
// 
signed int check_function$object(const unsigned long long int, const unsigned long long int);
// expect_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 962
static void expect_set(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int *values, const unsigned long int number_of_values, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const signed int count);
// expect_set::check_function$object
// 
signed int check_function$object(const unsigned long long int, const unsigned long long int);
// fail_if_blocks_allocated
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1541
static void fail_if_blocks_allocated(const struct ListNode * const check_point, const char * const test_name);
// fail_if_leftover_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 344
static void fail_if_leftover_values(const char *test_name);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_allocated_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1524
static void free_allocated_blocks(const struct ListNode * const check_point);
// free_symbol_map_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 499
static void free_symbol_map_value(const void *value, void *cleanup_value_data);
// free_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 491
static void free_value(const void *value, void *cleanup_value_data);
// get_allocated_blocks_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1397
static struct ListNode * get_allocated_blocks_list();
// get_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 37
static _Bool get_extensions(struct wegl_display *dpy);
// get_symbol_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 565
static signed int get_symbol_value(struct ListNode * const head, const char * const *symbol_names, const unsigned long int number_of_symbol_names, void **output);
// get_xcb_screen
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 57
static struct xcb_screen_t * get_xcb_screen(const struct xcb_setup_t *setup, signed int screen);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config(struct wcore_config *wcore_self);
// glx_config$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config$link1(struct wcore_config *wcore_self$link1);
// glx_config$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config$link2(struct wcore_config *wcore_self$link2);
// glx_config_check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 54
static _Bool glx_config_check_context_attrs(struct glx_display *dpy, struct wcore_config_attrs *attrs);
// glx_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 167
struct wcore_config * glx_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs);
// glx_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 40
_Bool glx_config_destroy(struct wcore_config *wc_self);
// glx_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 275
union waffle_native_config * glx_config_get_native(struct wcore_config *wc_self);
// glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context(struct wcore_context *wcore_self);
// glx_context$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context$link1(struct wcore_context *wcore_self$link1);
// glx_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 203
struct wcore_context * glx_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx);
// glx_context_create_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 156
static struct __GLXcontextRec * glx_context_create_native(struct glx_config *config, struct glx_context *share_ctx);
// glx_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 44
_Bool glx_context_destroy(struct wcore_context *wc_self);
// glx_context_fill_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 71
static _Bool glx_context_fill_attrib_list(struct glx_config *config, signed int *attrib_list);
// glx_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 232
union waffle_native_context * glx_context_get_native(struct wcore_context *wc_self);
// glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display(struct wcore_display *wcore_self);
// glx_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link1(struct wcore_display *wcore_self$link1);
// glx_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link2(struct wcore_display *wcore_self$link2);
// glx_display$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link3(struct wcore_display *wcore_self$link3);
// glx_display$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link4(struct wcore_display *wcore_self$link4);
// glx_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 86
struct wcore_display * glx_display_connect(struct wcore_platform *wc_plat, const char *name);
// glx_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 37
_Bool glx_display_destroy(struct wcore_display *wc_self);
// glx_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 145
union waffle_native_display * glx_display_get_native(struct wcore_display *wc_self);
// glx_display_set_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 52
static _Bool glx_display_set_extensions(struct glx_display *self);
// glx_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 116
_Bool glx_display_supports_context_api(struct wcore_display *wc_self, signed int context_api);
// glx_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform(struct wcore_platform *wcore_self);
// glx_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link1(struct wcore_platform *wcore_self$link1);
// glx_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link2(struct wcore_platform *wcore_self$link2);
// glx_platform$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link3(struct wcore_platform *wcore_self$link3);
// glx_platform$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link4(struct wcore_platform *wcore_self$link4);
// glx_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 33
struct wcore_platform * glx_platform_create(void);
// glx_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 45
static _Bool glx_platform_destroy(struct wcore_platform *wc_self);
// glx_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 160
static _Bool glx_platform_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// glx_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 168
static void * glx_platform_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// glx_platform_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 152
static void * glx_platform_get_proc_address(struct wcore_platform *wc_self, const char *name);
// glx_platform_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 132
static _Bool glx_platform_make_current(struct wcore_platform *wc_self, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx);
// glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window(struct wcore_window *wcore_self);
// glx_window$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window$link1(struct wcore_window *wcore_self$link1);
// glx_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 47
struct wcore_window * glx_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// glx_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 53
_Bool glx_window_destroy(struct wcore_window *wc_self);
// glx_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 66
union waffle_native_window * glx_window_get_native(struct wcore_window *wc_self);
// glx_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 59
_Bool glx_window_resize(struct wcore_window *wc_self, signed int width, signed int height);
// glx_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 56
_Bool glx_window_show(struct wcore_window *wc_self);
// glx_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 63
_Bool glx_window_swap_buffers(struct wcore_window *wc_self);
// impl_thrd_routine
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 65
static void * impl_thrd_routine(void *p);
// initialize_source_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 310
static void initialize_source_location(struct SourceLocation * const location);
// initialize_testing
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 335
static void initialize_testing(const char *test_name);
// integer_in_range_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 832
static signed int integer_in_range_display_error(const unsigned long long int value, const unsigned long long int range_min, const unsigned long long int range_max);
// integer_not_in_range_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 849
static signed int integer_not_in_range_display_error(const unsigned long long int value, const unsigned long long int range_min, const unsigned long long int range_max);
// linux_dl_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 103
_Bool linux_dl_close(struct linux_dl *self);
// linux_dl_get_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 47
static const char * linux_dl_get_name(signed int waffle_dl);
// linux_dl_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 78
struct linux_dl * linux_dl_open(signed int waffle_dl);
// linux_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 124
void * linux_dl_sym(struct linux_dl *self, const char *symbol);
// linux_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 34
struct linux_platform * linux_platform_create(void);
// linux_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 37
_Bool linux_platform_destroy(struct linux_platform *self);
// linux_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 41
_Bool linux_platform_dl_can_open(struct linux_platform *self, signed int waffle_dl);
// linux_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 46
void * linux_platform_dl_sym(struct linux_platform *self, signed int waffle_dl, const char *name);
// linux_platform_get_dl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.c line 64
static struct linux_dl * linux_platform_get_dl(struct linux_platform *self, signed int waffle_dl);
// list_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 402
static struct ListNode * list_add(struct ListNode * const head, struct ListNode *new_node);
// list_add_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 390
static struct ListNode * list_add_value(struct ListNode * const head, const void *value, const signed int refcount);
// list_empty
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 454
static signed int list_empty(const struct ListNode * const head);
// list_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 464
static signed int list_find(struct ListNode * const head, const void *value, signed int (* const equal_func)(const void *, const void *), struct ListNode **output);
// list_find::equal_func$object
// 
signed int equal_func$object(const void *, const void *);
// list_first
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 478
static signed int list_first(struct ListNode * const head, struct ListNode **output);
// list_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 442
static struct ListNode * list_free(struct ListNode * const head, void (* const cleanup_value)(const void *, void *), void * const cleanup_value_data);
// list_free::cleanup_value$object
// 
void cleanup_value$object(const void *, void *);
// list_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 377
static struct ListNode * list_initialize(struct ListNode * const node);
// list_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 414
static struct ListNode * list_remove(struct ListNode * const node, void (* const cleanup_value)(const void *, void *), void * const cleanup_value_data);
// list_remove::cleanup_value$object
// 
void cleanup_value$object(const void *, void *);
// list_remove_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 428
static void list_remove_free(struct ListNode * const node, void (* const cleanup_value)(const void *, void *), void * const cleanup_value_data);
// list_remove_free::cleanup_value$object
// 
void cleanup_value$object(const void *, void *);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memory_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 895
static signed int memory_equal_display_error(const char * const a, const char * const b, const unsigned long int size);
// memory_not_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 922
static signed int memory_not_equal_display_error(const char * const a, const char * const b, const unsigned long int size);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mock_assert
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1277
void mock_assert(const signed int result, const char * const expression, const char * const file, const signed int line);
// mtx_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 156
void mtx_destroy(union anonymous *mtx);
// mtx_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 157
signed int mtx_init(union anonymous *mtx, signed int type);
// mtx_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 158
signed int mtx_lock(union anonymous *mtx);
// mtx_timedlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 174
signed int mtx_timedlock(union anonymous *mtx, const struct xtime *xt);
// mtx_trylock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 203
signed int mtx_trylock(union anonymous *mtx);
// mtx_unlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 161
signed int mtx_unlock(union anonymous *mtx);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse_bool
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 80
static _Bool parse_bool(const signed int *attrib_list, signed int attrib_name, _Bool *value, _Bool default_value);
// parse_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 106
static _Bool parse_context_api(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_context_forward_compatible
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 307
static _Bool parse_context_forward_compatible(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_context_profile
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 260
static _Bool parse_context_profile(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_context_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 163
static _Bool parse_context_version(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_misc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 365
static _Bool parse_misc(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// print_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1638
void print_error(const char * const format, ...);
// print_message
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1630
void print_message(const char * const format, ...);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$1 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$1 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$1 *, const union anonymous$13 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$1 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$1 *, union anonymous *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$1 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_equal
// file /usr/include/pthread.h line 1155
static inline signed int pthread_equal(unsigned long int __thread1, unsigned long int __thread2);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_key_delete
// file /usr/include/pthread.h line 1118
extern signed int pthread_key_delete(unsigned int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$13 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_timedlock
// file /usr/include/pthread.h line 769
extern signed int pthread_mutex_timedlock(union anonymous *, struct timespec *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous$13 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous$13 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous$13 *, signed int);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// registry_listener_global
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 61
static void registry_listener_global(void *data, struct wl_registry *registry, unsigned int name, const char *interface, unsigned int version);
// registry_listener_global_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 80
static void registry_listener_global_remove(void *data, struct wl_registry *registry, unsigned int name);
// remove_always_return_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 616
static void remove_always_return_values(struct ListNode * const map_head, const unsigned long int number_of_symbol_names);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// set_context_profile_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 235
static _Bool set_context_profile_default(struct wcore_config_attrs *attrs);
// set_context_version_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 136
static _Bool set_context_version_default(struct wcore_config_attrs *attrs);
// set_misc_defaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 339
static _Bool set_misc_defaults(struct wcore_config_attrs *attrs);
// set_source_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 325
static void set_source_location(struct SourceLocation * const location, const char * const file, const signed int line);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// shell_surface_listener_configure
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 76
static void shell_surface_listener_configure(void *data, struct wl_shell_surface *shell_surface, unsigned int edges, signed int width, signed int height);
// shell_surface_listener_ping
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 68
static void shell_surface_listener_ping(void *data, struct wl_shell_surface *shell_surface, unsigned int serial);
// shell_surface_listener_popup_done
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 85
static void shell_surface_listener_popup_done(void *data, struct wl_shell_surface *shell_surface);
// signal
// file /usr/include/signal.h line 107
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// source_location_is_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 318
static signed int source_location_is_set(const struct SourceLocation * const location);
// strerror_r
// file /usr/include/string.h line 426
extern signed int strerror_r(signed int, char *, unsigned long int);
// string_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 866
static signed int string_equal_display_error(const char * const left, const char * const right);
// string_not_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 881
static signed int string_not_equal_display_error(const char * const left, const char * const right);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// symbol_names_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 515
static signed int symbol_names_match(const void *map_value, const void *symbol);
// teardown_testing
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 366
static void teardown_testing(const char *test_name);
// test_wcore_error_code_bad_attribute
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 48
static void test_wcore_error_code_bad_attribute(void **state);
// test_wcore_error_code_unknown_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 39
static void test_wcore_error_code_unknown_error(void **state);
// test_wcore_error_disable_then_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 94
static void test_wcore_error_disable_then_error(void **state);
// test_wcore_error_disable_then_error_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 114
static void test_wcore_error_disable_then_error_internal(void **state);
// test_wcore_error_disable_then_errorf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 104
static void test_wcore_error_disable_then_errorf(void **state);
// test_wcore_error_first_call_with_message_wins
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 85
static void test_wcore_error_first_call_with_message_wins(void **state);
// test_wcore_error_first_call_without_message_wins
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 76
static void test_wcore_error_first_call_without_message_wins(void **state);
// test_wcore_error_internal_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 64
static void test_wcore_error_internal_error(void **state);
// test_wcore_error_thread_local
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 186
static void test_wcore_error_thread_local(void **state);
// test_wcore_error_with_message
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 56
static void test_wcore_error_with_message(void **state);
// thrd_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 163
signed int thrd_create(unsigned long int *thr, signed int (*func)(void *), void *arg);
// thrd_create::func$object
// 
signed int func$object(void *);
// thrd_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 236
unsigned long int thrd_current(void);
// thrd_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 242
signed int thrd_detach(unsigned long int thr);
// thrd_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 248
signed int thrd_equal(unsigned long int thr0, unsigned long int thr1);
// thrd_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 254
void thrd_exit(signed int res);
// thrd_join
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 168
signed int thrd_join(unsigned long int thr, signed int *res);
// thrd_sleep
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 271
void thrd_sleep(const struct xtime *xt);
// thrd_yield
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 281
void thrd_yield(void);
// thread_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 152
static _Bool thread_start(struct thread_arg *a);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tss_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 172
signed int tss_create(unsigned int *key, void (*dtor)(void *));
// tss_create::dtor$object
// 
void dtor$object(void *);
// tss_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 296
void tss_delete(unsigned int key);
// tss_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 302
void * tss_get(unsigned int key);
// tss_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 175
signed int tss_set(unsigned int key, void *val);
// udev_device_get_devnode
// file /usr/include/libudev.h line 96
const char * udev_device_get_devnode(struct udev_device *);
// udev_device_new_from_syspath
// file /usr/include/libudev.h line 80
struct udev_device * udev_device_new_from_syspath(struct udev *, const char *);
// udev_device_unref
// file /usr/include/libudev.h line 78
struct udev_device * udev_device_unref(struct udev_device *);
// udev_enumerate_add_match_subsystem
// file /usr/include/libudev.h line 146
signed int udev_enumerate_add_match_subsystem(struct udev_enumerate *, const char *);
// udev_enumerate_add_match_sysname
// file /usr/include/libudev.h line 151
signed int udev_enumerate_add_match_sysname(struct udev_enumerate *, const char *);
// udev_enumerate_get_list_entry
// file /usr/include/libudev.h line 160
struct udev_list_entry * udev_enumerate_get_list_entry(struct udev_enumerate *);
// udev_enumerate_new
// file /usr/include/libudev.h line 144
struct udev_enumerate * udev_enumerate_new(struct udev *);
// udev_enumerate_scan_devices
// file /usr/include/libudev.h line 157
signed int udev_enumerate_scan_devices(struct udev_enumerate *);
// udev_enumerate_unref
// file /usr/include/libudev.h line 142
struct udev_enumerate * udev_enumerate_unref(struct udev_enumerate *);
// udev_list_entry_get_name
// file /usr/include/libudev.h line 57
const char * udev_list_entry_get_name(struct udev_list_entry *);
// udev_list_entry_get_next
// file /usr/include/libudev.h line 55
struct udev_list_entry * udev_list_entry_get_next(struct udev_list_entry *);
// udev_new
// file /usr/include/libudev.h line 39
struct udev * udev_new(void);
// udev_unref
// file /usr/include/libudev.h line 38
struct udev * udev_unref(struct udev *);
// unsetenv
// file /usr/include/stdlib.h line 588
extern signed int unsetenv(const char *);
// value_in_set_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 797
static signed int value_in_set_display_error(const unsigned long long int value, const struct CheckIntegerSet * const check_integer_set, const signed int invert);
// values_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 766
static signed int values_equal_display_error(const unsigned long long int left, const unsigned long long int right);
// values_not_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 779
static signed int values_not_equal_display_error(const unsigned long long int left, const unsigned long long int right);
// vprint_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1619
void vprint_error(const char * const format, void **args);
// vprint_message
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1608
void vprint_message(const char * const format, void **args);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waffle_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 40
_Bool waffle_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value);
// waffle_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 50
_Bool waffle_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value);
// waffle_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 32
signed int waffle_attrib_list_length(const signed int *attrib_list);
// waffle_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 62
_Bool waffle_attrib_list_update(signed int *attrib_list, signed int key, signed int value);
// waffle_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 49
static inline struct waffle_config * waffle_config(struct wcore_config *cfg);
// waffle_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 35
struct waffle_config * waffle_config_choose(struct waffle_display *dpy, const signed int *attrib_list);
// waffle_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 63
_Bool waffle_config_destroy(struct waffle_config *self);
// waffle_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 78
union waffle_native_config * waffle_config_get_native(struct waffle_config *self);
// waffle_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 47
static inline struct waffle_context * waffle_context(struct wcore_context *ctx);
// waffle_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 33
struct waffle_context * waffle_context_create(struct waffle_config *config, struct waffle_context *shared_ctx);
// waffle_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 61
_Bool waffle_context_destroy(struct waffle_context *self);
// waffle_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 76
union waffle_native_context * waffle_context_get_native(struct waffle_context *self);
// waffle_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 44
static inline struct waffle_display * waffle_display(struct wcore_display *dpy);
// waffle_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 34
struct waffle_display * waffle_display_connect(const char *name);
// waffle_display_disconnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 49
_Bool waffle_display_disconnect(struct waffle_display *self);
// waffle_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 94
union waffle_native_display * waffle_display_get_native(struct waffle_display *self);
// waffle_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 64
_Bool waffle_display_supports_context_api(struct waffle_display *self, signed int context_api);
// waffle_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 47
_Bool waffle_dl_can_open(signed int dl);
// waffle_dl_check_enum
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 32
static _Bool waffle_dl_check_enum(signed int dl);
// waffle_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 59
void * waffle_dl_sym(signed int dl, const char *name);
// waffle_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_enum.c line 32
const char * waffle_enum_to_string(signed int e);
// waffle_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 33
enum waffle_error waffle_error_get_code(void);
// waffle_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 39
struct waffle_error_info * waffle_error_get_info(void);
// waffle_error_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 45
const char * waffle_error_to_string(enum waffle_error e);
// waffle_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 104
void * waffle_get_proc_address(const char *name);
// waffle_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 174
_Bool waffle_init(const signed int *attrib_list);
// waffle_init_create_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 136
static struct wcore_platform * waffle_init_create_platform(signed int waffle_platform);
// waffle_init_parse_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 40
static _Bool waffle_init_parse_attrib_list(const signed int *attrib_list, signed int *platform);
// waffle_is_extension_in_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 39
_Bool waffle_is_extension_in_string(const char * restrict extension_string, const char * restrict extension_name);
// waffle_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 76
_Bool waffle_make_current(struct waffle_display *dpy, struct waffle_window *window, struct waffle_context *ctx);
// waffle_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 40
static inline struct waffle_window * waffle_window(struct wcore_window *win);
// waffle_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 36
struct waffle_window * waffle_window_create(struct waffle_config *config, signed int width, signed int height);
// waffle_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 61
_Bool waffle_window_destroy(struct waffle_window *self);
// waffle_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 130
union waffle_native_window * waffle_window_get_native(struct waffle_window *self);
// waffle_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 91
_Bool waffle_window_resize(struct waffle_window *self, signed int width, signed int height);
// waffle_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 76
_Bool waffle_window_show(struct waffle_window *self);
// waffle_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 115
_Bool waffle_window_swap_buffers(struct waffle_window *self);
// wayland_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 113
static union waffle_native_config * wayland_config_get_native(struct wcore_config *wc_config);
// wayland_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 130
static union waffle_native_context * wayland_context_get_native(struct wcore_context *wc_ctx);
// wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display(struct wcore_display *wc_self);
// wayland_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display$link1(struct wcore_display *wc_self$link1);
// wayland_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display$link2(struct wcore_display *wc_self$link2);
// wayland_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 92
struct wcore_display * wayland_display_connect(struct wcore_platform *wc_plat, const char *name);
// wayland_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 43
_Bool wayland_display_destroy(struct wcore_display *wc_self);
// wayland_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 155
void wayland_display_fill_native(struct wayland_display *self, struct waffle_wayland_display *n_dpy);
// wayland_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 165
union waffle_native_display * wayland_display_get_native(struct wcore_display *wc_self);
// wayland_display_sync
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 180
_Bool wayland_display_sync(struct wayland_display *dpy);
// wayland_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 96
static _Bool wayland_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// wayland_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 104
static void * wayland_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// wayland_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.h line 45
static inline struct wayland_platform * wayland_platform(struct wegl_platform$0 *wegl_self);
// wayland_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 34
struct wcore_platform * wayland_platform_create(void);
// wayland_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 49
static _Bool wayland_platform_destroy(struct wcore_platform *wc_self);
// wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 48
static inline struct wayland_window * wayland_window(struct wcore_window *wc_self);
// wayland_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 60
struct wcore_window * wayland_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// wayland_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 66
_Bool wayland_window_destroy(struct wcore_window *wc_self);
// wayland_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 79
union waffle_native_window * wayland_window_get_native(struct wcore_window *wc_self);
// wayland_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 75
_Bool wayland_window_resize(struct wcore_window *wc_self, signed int width, signed int height);
// wayland_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 69
_Bool wayland_window_show(struct wcore_window *wc_self);
// wayland_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 72
_Bool wayland_window_swap_buffers(struct wcore_window *wc_self);
// wcore_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 35
_Bool wcore_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value);
// wcore_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 41
_Bool wcore_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value);
// wcore_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 32
signed int wcore_attrib_list_length(const signed int *attrib_list);
// wcore_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 48
_Bool wcore_attrib_list_update(signed int *attrib_list, signed int key, signed int value);
// wcore_calloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 41
void * wcore_calloc(unsigned long int size);
// wcore_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config(struct waffle_config *cfg);
// wcore_config$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config$link1(struct waffle_config *cfg$link1);
// wcore_config$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config$link2(struct waffle_config *cfg$link2);
// wcore_config_attrs_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.h line 59
_Bool wcore_config_attrs_parse(const signed int *waffle_attrib_list, struct wcore_config_attrs *attrs);
// wcore_config_attrs_version_eq
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 512
_Bool wcore_config_attrs_version_eq(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_ge
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 533
_Bool wcore_config_attrs_version_ge(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_gt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 522
_Bool wcore_config_attrs_version_gt(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_le
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 552
_Bool wcore_config_attrs_version_le(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_lt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 544
_Bool wcore_config_attrs_version_lt(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init(struct wcore_config *self, struct wcore_display *display, struct wcore_config_attrs *attrs);
// wcore_config_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init$link1(struct wcore_config *self$link1, struct wcore_display *display$link1, struct wcore_config_attrs *attrs$link1);
// wcore_config_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown(struct wcore_config *self);
// wcore_config_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown$link1(struct wcore_config *self$link1);
// wcore_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context(struct waffle_context *ctx);
// wcore_context$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context$link1(struct waffle_context *ctx$link1);
// wcore_context_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init(struct wcore_context *self, struct wcore_config *config);
// wcore_context_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init$link1(struct wcore_context *self$link1, struct wcore_config *config$link1);
// wcore_context_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown(struct wcore_context *self);
// wcore_context_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown$link1(struct wcore_context *self$link1);
// wcore_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display(struct waffle_display *dpy);
// wcore_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display$link1(struct waffle_display *dpy$link1);
// wcore_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display$link2(struct waffle_display *dpy$link2);
// wcore_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 33
_Bool wcore_display_init(struct wcore_display *self, struct wcore_platform *platform);
// wcore_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 57
_Bool wcore_display_teardown(struct wcore_display *self);
// wcore_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.h line 82
const char * wcore_enum_to_string(signed int e);
// wcore_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 49
void wcore_error(enum waffle_error error);
// wcore_error_errno
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 137
void wcore_error_errno(const char *format, ...);
// wcore_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 80
enum waffle_error wcore_error_get_code(void);
// wcore_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 84
struct waffle_error_info * wcore_error_get_info(void);
// wcore_error_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 43
void wcore_error_reset(void);
// wcore_error_tinfo_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 51
struct wcore_error_tinfo * wcore_error_tinfo_create(void);
// wcore_error_tinfo_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 65
_Bool wcore_error_tinfo_destroy(struct wcore_error_tinfo *self);
// wcore_errorf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 56
void wcore_errorf(enum waffle_error error, const char *format, ...);
// wcore_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 32
void * wcore_malloc(unsigned long int size);
// wcore_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init(struct wcore_platform *self);
// wcore_platform_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init$link1(struct wcore_platform *self$link1);
// wcore_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown(struct wcore_platform *self);
// wcore_platform_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown$link1(struct wcore_platform *self$link1);
// wcore_tinfo_abort_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 66
static void wcore_tinfo_abort_init(void);
// wcore_tinfo_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.h line 39
struct wcore_tinfo * wcore_tinfo_get(void);
// wcore_tinfo_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 97
static void wcore_tinfo_init(struct wcore_tinfo *tinfo);
// wcore_tinfo_key_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 87
static void wcore_tinfo_key_create(void);
// wcore_tinfo_key_dtor
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 73
static void wcore_tinfo_key_dtor(void *args);
// wcore_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window(struct waffle_window *win);
// wcore_window$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window$link1(struct waffle_window *win$link1);
// wcore_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init(struct wcore_window *self, struct wcore_config *config);
// wcore_window_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init$link1(struct wcore_window *self$link1, struct wcore_config *config$link1);
// wcore_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown(struct wcore_window *self);
// wcore_window_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown$link1(struct wcore_window *self$link1);
// wegl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config(struct wcore_config *wcore_self);
// wegl_config$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link1(struct wcore_config *wcore_self$link1);
// wegl_config$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link2(struct wcore_config *wcore_self$link2);
// wegl_config$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link3(struct wcore_config *wcore_self$link3);
// wegl_config$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link4(struct wcore_config *wcore_self$link4);
// wegl_config$link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link5(struct wcore_config *wcore_self$link5);
// wegl_config$link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link6(struct wcore_config *wcore_self$link6);
// wegl_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 210
struct wcore_config * wegl_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs);
// wegl_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 241
_Bool wegl_config_destroy(struct wcore_config *wc_config);
// wegl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context(struct wcore_context *wcore_self);
// wegl_context$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link1(struct wcore_context *wcore_self$link1);
// wegl_context$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link2(struct wcore_context *wcore_self$link2);
// wegl_context$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link3(struct wcore_context *wcore_self$link3);
// wegl_context$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link4(struct wcore_context *wcore_self$link4);
// wegl_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 160
struct wcore_context * wegl_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx);
// wegl_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 192
_Bool wegl_context_destroy(struct wcore_context *wc_ctx);
// wegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display(struct wcore_display *wcore_self);
// wegl_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link1(struct wcore_display *wcore_self$link1);
// wegl_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link2(struct wcore_display *wcore_self$link2);
// wegl_display$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link3(struct wcore_display *wcore_self$link3);
// wegl_display$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link4(struct wcore_display *wcore_self$link4);
// wegl_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 60
_Bool wegl_display_init(struct wegl_display *dpy, struct wcore_platform *wc_plat, signed long int native_display);
// wegl_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 111
_Bool wegl_display_supports_context_api(struct wcore_display *wc_dpy, signed int waffle_context_api);
// wegl_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 96
_Bool wegl_display_teardown(struct wegl_display *dpy);
// wegl_emit_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.h line 42
void wegl_emit_error(struct wegl_platform *plat, const char *egl_func_call);
// wegl_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 95
void * wegl_get_proc_address(struct wcore_platform *wc_self, const char *name);
// wegl_get_proc_address::$tmp::return_value$object
// 
void return_value$object(void);
// wegl_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 73
_Bool wegl_make_current(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx);
// wegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform(struct wcore_platform *wcore_self);
// wegl_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link1(struct wcore_platform *wcore_self$link1);
// wegl_platform$link10
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link10(struct wcore_platform *wcore_self$link10);
// wegl_platform$link11
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform$2 * wegl_platform$link11(struct wcore_platform *wcore_self$link11);
// wegl_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link2(struct wcore_platform *wcore_self$link2);
// wegl_platform$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link3(struct wcore_platform *wcore_self$link3);
// wegl_platform$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link4(struct wcore_platform *wcore_self$link4);
// wegl_platform$link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform$0 * wegl_platform$link5(struct wcore_platform *wcore_self$link5);
// wegl_platform$link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link6(struct wcore_platform *wcore_self$link6);
// wegl_platform$link7
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link7(struct wcore_platform *wcore_self$link7);
// wegl_platform$link8
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link8(struct wcore_platform *wcore_self$link8);
// wegl_platform$link9
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform$1 * wegl_platform$link9(struct wcore_platform *wcore_self$link9);
// wegl_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 58
_Bool wegl_platform_init(struct wegl_platform *self);
// wegl_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 39
_Bool wegl_platform_teardown(struct wegl_platform *self);
// wegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window(struct wcore_window *wcore_self);
// wegl_window$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window$link1(struct wcore_window *wcore_self$link1);
// wegl_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 36
_Bool wegl_window_init(struct wegl_window *window, struct wcore_config *wc_config, signed long int native_window);
// wegl_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 97
_Bool wegl_window_swap_buffers(struct wcore_window *wc_window);
// wegl_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 78
_Bool wegl_window_teardown(struct wegl_window *window);
// wgbm_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 34
struct wcore_config * wgbm_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs);
// wgbm_config_get_gbm_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 53
unsigned int wgbm_config_get_gbm_format(struct wcore_platform *wc_plat, struct wcore_display *wc_display, struct wcore_config *wc_config);
// wgbm_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 73
union waffle_native_config * wgbm_config_get_native(struct wcore_config *wc_config);
// wgbm_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 153
static union waffle_native_context * wgbm_context_get_native(struct wcore_context *wc_ctx);
// wgbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display(struct wcore_display *wc_self);
// wgbm_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display$link1(struct wcore_display *wc_self$link1);
// wgbm_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display$link2(struct wcore_display *wc_self$link2);
// wgbm_display$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display$link3(struct wcore_display *wc_self$link3);
// wgbm_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 119
struct wcore_display * wgbm_display_connect(struct wcore_platform *wc_plat, const char *name);
// wgbm_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 44
_Bool wgbm_display_destroy(struct wcore_display *wc_self);
// wgbm_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 66
void wgbm_display_fill_native(struct wgbm_display *self, struct waffle_gbm_display *n_dpy);
// wgbm_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 177
union waffle_native_display * wgbm_display_get_native(struct wcore_display *wc_self);
// wgbm_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 136
static _Bool wgbm_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// wgbm_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 144
static void * wgbm_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// wgbm_get_default_fd
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 104
static signed int wgbm_get_default_fd(void);
// wgbm_get_default_fd_for_pattern
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 69
static signed int wgbm_get_default_fd_for_pattern(const char *pattern);
// wgbm_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform * wgbm_platform(struct wegl_platform$1 *wegl_self);
// wgbm_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform$0 * wgbm_platform$link1(struct wegl_platform *wegl_self$link1);
// wgbm_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform$1 * wgbm_platform$link2(struct wegl_platform$2 *wegl_self$link2);
// wgbm_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 36
struct wcore_platform * wgbm_platform_create(void);
// wgbm_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 50
static _Bool wgbm_platform_destroy(struct wcore_platform *wc_self);
// wgbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 41
static inline struct wgbm_window * wgbm_window(struct wcore_window *wc_self);
// wgbm_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 53
struct wcore_window * wgbm_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// wgbm_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 59
_Bool wgbm_window_destroy(struct wcore_window *wc_self);
// wgbm_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 68
union waffle_native_window * wgbm_window_get_native(struct wcore_window *wc_self);
// wgbm_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 62
_Bool wgbm_window_show(struct wcore_window *wc_self);
// wgbm_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 65
_Bool wgbm_window_swap_buffers(struct wcore_window *wc_self);
// wl_compositor_create_surface
// file /usr/include/wayland-client-protocol.h line 361
static inline struct wl_surface * wl_compositor_create_surface(struct wl_compositor *wl_compositor);
// wl_display_connect
// file /usr/include/wayland-client-core.h line 150
struct wl_display * wl_display_connect(const char *);
// wl_display_disconnect
// file /usr/include/wayland-client-core.h line 152
void wl_display_disconnect(struct wl_display *);
// wl_display_get_registry
// file /usr/include/wayland-client-protocol.h line 185
static inline struct wl_registry * wl_display_get_registry(struct wl_display *wl_display);
// wl_display_roundtrip
// file /usr/include/wayland-client-core.h line 168
signed int wl_display_roundtrip(struct wl_display *);
// wl_egl_window_create
// file /usr/include/wayland-egl-core.h line 40
struct wl_egl_window * wl_egl_window_create(struct wl_surface *, signed int, signed int);
// wl_egl_window_destroy
// file /usr/include/wayland-egl-core.h line 44
void wl_egl_window_destroy(struct wl_egl_window *);
// wl_egl_window_resize
// file /usr/include/wayland-egl-core.h line 47
void wl_egl_window_resize(struct wl_egl_window *, signed int, signed int, signed int, signed int);
// wl_proxy_add_listener
// file /usr/include/wayland-client-core.h line 138
signed int wl_proxy_add_listener(struct wl_proxy *, void (**)(void), void *);
// wl_proxy_destroy
// file /usr/include/wayland-client-core.h line 137
void wl_proxy_destroy(struct wl_proxy *);
// wl_proxy_marshal
// file /usr/include/wayland-client-core.h line 123
void wl_proxy_marshal(struct wl_proxy *, unsigned int, ...);
// wl_proxy_marshal_constructor
// file /usr/include/wayland-client-core.h line 128
struct wl_proxy * wl_proxy_marshal_constructor(struct wl_proxy *, unsigned int, struct wl_interface *, ...);
// wl_registry_add_listener
// file /usr/include/wayland-client-protocol.h line 256
static inline signed int wl_registry_add_listener(struct wl_registry *wl_registry, struct wl_registry_listener *listener, void *data);
// wl_registry_bind
// file /usr/include/wayland-client-protocol.h line 284
static inline void * wl_registry_bind(struct wl_registry *wl_registry, unsigned int name, struct wl_interface *interface, unsigned int version);
// wl_shell_get_shell_surface
// file /usr/include/wayland-client-protocol.h line 1090
static inline struct wl_shell_surface * wl_shell_get_shell_surface(struct wl_shell *wl_shell, struct wl_surface *surface);
// wl_shell_surface_add_listener
// file /usr/include/wayland-client-protocol.h line 1242
static inline signed int wl_shell_surface_add_listener(struct wl_shell_surface *wl_shell_surface, struct wl_shell_surface_listener *listener, void *data);
// wl_shell_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1273
static inline void wl_shell_surface_destroy(struct wl_shell_surface *wl_shell_surface);
// wl_shell_surface_pong
// file /usr/include/wayland-client-protocol.h line 1279
static inline void wl_shell_surface_pong(struct wl_shell_surface *wl_shell_surface, unsigned int serial);
// wl_shell_surface_set_toplevel
// file /usr/include/wayland-client-protocol.h line 1300
static inline void wl_shell_surface_set_toplevel(struct wl_shell_surface *wl_shell_surface);
// wl_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1463
static inline void wl_surface_destroy(struct wl_surface *wl_surface);
// wrapped_XCloseDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 64
static inline signed int wrapped_XCloseDisplay(struct _XDisplay *dpy);
// wrapped_XCloseDisplay::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_XGetXCBConnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 73
static inline struct xcb_connection_t * wrapped_XGetXCBConnection(struct _XDisplay *dpy);
// wrapped_XGetXCBConnection::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_XOpenDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 55
static inline struct _XDisplay * wrapped_XOpenDisplay(const char *name);
// wrapped_XOpenDisplay::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXChooseFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 48
static inline struct __GLXFBConfigRec ** wrapped_glXChooseFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen, const signed int *attribList, signed int *nitems);
// wrapped_glXChooseFBConfig::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXCreateContextAttribsARB
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 60
static inline struct __GLXcontextRec * wrapped_glXCreateContextAttribsARB(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, struct __GLXcontextRec *share_context, signed int direct, const signed int *attrib_list);
// wrapped_glXCreateContextAttribsARB::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXCreateNewContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 73
static inline struct __GLXcontextRec * wrapped_glXCreateNewContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int renderType, struct __GLXcontextRec *shareList, signed int direct);
// wrapped_glXCreateNewContext::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXDestroyContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 106
static inline void wrapped_glXDestroyContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXcontextRec *ctx);
// wrapped_glXDestroyContext::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXGetFBConfigAttrib
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 85
static inline signed int wrapped_glXGetFBConfigAttrib(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int attribute, signed int *value);
// wrapped_glXGetFBConfigAttrib::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXGetVisualFromFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 96
static inline struct anonymous$2 * wrapped_glXGetVisualFromFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config);
// wrapped_glXGetVisualFromFBConfig::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXMakeCurrent
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 115
static inline signed int wrapped_glXMakeCurrent(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable, struct __GLXcontextRec *ctx);
// wrapped_glXMakeCurrent::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXQueryExtensionsString
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 125
static inline const char * wrapped_glXQueryExtensionsString(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen);
// wrapped_glXQueryExtensionsString::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// wrapped_glXSwapBuffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 135
static inline void wrapped_glXSwapBuffers(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable);
// wrapped_glXSwapBuffers::1::old_handler$object
// 
signed int old_handler$object(struct _XDisplay *, struct anonymous$4 *);
// x11_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 39
_Bool x11_display_init(struct x11_display *self, const char *name);
// x11_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 42
_Bool x11_display_teardown(struct x11_display *self);
// x11_dummy_error_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler(struct _XDisplay *dpy, struct anonymous$4 *err);
// x11_dummy_error_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link1(struct _XDisplay *dpy$link1, struct anonymous$4 *err$link1);
// x11_dummy_error_handler$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link2(struct _XDisplay *dpy$link2, struct anonymous$4 *err$link2);
// x11_dummy_error_handler$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link3(struct _XDisplay *dpy$link3, struct anonymous$4 *err$link3);
// x11_dummy_error_handler$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link4(struct _XDisplay *dpy$link4, struct anonymous$4 *err$link4);
// x11_dummy_error_handler$link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link5(struct _XDisplay *dpy$link5, struct anonymous$4 *err$link5);
// x11_winddow_get_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 34
static unsigned char x11_winddow_get_depth(struct xcb_connection_t *conn, const struct xcb_screen_t *screen, unsigned int id);
// x11_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 40
_Bool x11_window_init(struct x11_window *self, struct x11_display *dpy, unsigned int visual_id, signed int width, signed int height);
// x11_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 53
_Bool x11_window_resize(struct x11_window *self, signed int width, signed int height);
// x11_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 50
_Bool x11_window_show(struct x11_window *self);
// x11_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 47
_Bool x11_window_teardown(struct x11_window *self);
// xcb_configure_window
// file /usr/include/xcb/xproto.h line 6040
struct anonymous$11 xcb_configure_window(struct xcb_connection_t *, unsigned int, unsigned short int, const unsigned int *);
// xcb_create_colormap_checked
// file /usr/include/xcb/xproto.h line 9866
struct anonymous$11 xcb_create_colormap_checked(struct xcb_connection_t *, unsigned char, unsigned int, unsigned int, unsigned int);
// xcb_create_window_checked
// file /usr/include/xcb/xproto.h line 5507
struct anonymous$11 xcb_create_window_checked(struct xcb_connection_t *, unsigned char, unsigned int, unsigned int, signed short int, signed short int, unsigned short int, unsigned short int, unsigned short int, unsigned short int, unsigned int, unsigned int, const unsigned int *);
// xcb_depth_next
// file /usr/include/xcb/xproto.h line 5224
void xcb_depth_next(struct xcb_depth_iterator_t *);
// xcb_depth_visuals_iterator
// file /usr/include/xcb/xproto.h line 5213
struct xcb_visualtype_iterator_t xcb_depth_visuals_iterator(const struct xcb_depth_t *);
// xcb_destroy_window
// file /usr/include/xcb/xproto.h line 5715
struct anonymous$11 xcb_destroy_window(struct xcb_connection_t *, unsigned int);
// xcb_destroy_window_checked
// file /usr/include/xcb/xproto.h line 5696
struct anonymous$11 xcb_destroy_window_checked(struct xcb_connection_t *, unsigned int);
// xcb_free_colormap
// file /usr/include/xcb/xproto.h line 9911
struct anonymous$11 xcb_free_colormap(struct xcb_connection_t *, unsigned int);
// xcb_generate_id
// file /usr/include/xcb/xcb.h line 587
unsigned int xcb_generate_id(struct xcb_connection_t *);
// xcb_get_setup
// file /usr/include/xcb/xcb.h line 456
struct xcb_setup_t * xcb_get_setup(struct xcb_connection_t *);
// xcb_map_window_checked
// file /usr/include/xcb/xproto.h line 5873
struct anonymous$11 xcb_map_window_checked(struct xcb_connection_t *, unsigned int);
// xcb_request_check
// file /usr/include/xcb/xcb.h line 363
struct anonymous$12 * xcb_request_check(struct xcb_connection_t *, struct anonymous$11);
// xcb_screen_allowed_depths_iterator
// file /usr/include/xcb/xproto.h line 5245
struct xcb_depth_iterator_t xcb_screen_allowed_depths_iterator(const struct xcb_screen_t *);
// xcb_screen_next
// file /usr/include/xcb/xproto.h line 5256
void xcb_screen_next(struct xcb_screen_iterator_t *);
// xcb_setup_roots_iterator
// file /usr/include/xcb/xproto.h line 5409
struct xcb_screen_iterator_t xcb_setup_roots_iterator(const struct xcb_setup_t *);
// xcb_visualtype_next
// file /usr/include/xcb/xproto.h line 5189
void xcb_visualtype_next(struct xcb_visualtype_iterator_t *);
// xegl_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 110
static union waffle_native_config * xegl_config_get_native(struct wcore_config *wc_config);
// xegl_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 127
static union waffle_native_context * xegl_context_get_native(struct wcore_context *wc_ctx);
// xegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display(struct wcore_display *wc_self);
// xegl_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display$link1(struct wcore_display *wc_self$link1);
// xegl_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display$link2(struct wcore_display *wc_self$link2);
// xegl_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 50
struct wcore_display * xegl_display_connect(struct wcore_platform *wc_plat, const char *name);
// xegl_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 35
_Bool xegl_display_destroy(struct wcore_display *wc_self);
// xegl_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 77
void xegl_display_fill_native(struct xegl_display *self, struct waffle_x11_egl_display *n_dpy);
// xegl_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 85
union waffle_native_display * xegl_display_get_native(struct wcore_display *wc_self);
// xegl_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 93
static _Bool xegl_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// xegl_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 101
static void * xegl_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// xegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.h line 44
static inline struct xegl_platform * xegl_platform(struct wegl_platform *wegl_self);
// xegl_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 35
struct wcore_platform * xegl_platform_create(void);
// xegl_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 46
static _Bool xegl_platform_destroy(struct wcore_platform *wc_self);
// xegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 45
static inline struct xegl_window * xegl_window(struct wcore_window *wc_self);
// xegl_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 57
struct wcore_window * xegl_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// xegl_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 63
_Bool xegl_window_destroy(struct wcore_window *wc_self);
// xegl_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 73
union waffle_native_window * xegl_window_get_native(struct wcore_window *wc_self);
// xegl_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 69
_Bool xegl_window_resize(struct wcore_window *wc_self, signed int width, signed int height);
// xegl_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 66
_Bool xegl_window_show(struct wcore_window *wc_self);
// xtime_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 316
signed int xtime_get(struct xtime *xt, signed int base);

struct anonymous$2
{
  // visual
  struct anonymous$3 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous$9
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$8 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$3 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$10
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$7 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$9 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$7
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$3
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$5
{
  // pointer
  void *pointer;
};

struct anonymous$6
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$0
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$8
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$3 *visuals;
};

struct anonymous$4
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$11
{
  // sequence
  unsigned int sequence;
};

struct anonymous$12
{
  // response_type
  unsigned char response_type;
  // error_code
  unsigned char error_code;
  // sequence
  unsigned short int sequence;
  // resource_id
  unsigned int resource_id;
  // minor_code
  unsigned short int minor_code;
  // major_code
  unsigned char major_code;
  // pad0
  unsigned char pad0;
  // pad
  unsigned int pad[5l];
  // full_sequence
  unsigned int full_sequence;
};

union anonymous$13
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$1
{
  // __data
  struct anonymous$0 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct SourceLocation
{
  // file
  const char *file;
  // line
  signed int line;
};

struct CheckParameterEvent
{
  // location
  struct SourceLocation location;
  // parameter_name
  const char *parameter_name;
  // check_value
  signed int (*check_value)(const unsigned long long int, const unsigned long long int);
  // check_value_data
  unsigned long long int check_value_data;
};

struct CheckIntegerRange
{
  // event
  struct CheckParameterEvent event;
  // minimum
  unsigned long long int minimum;
  // maximum
  unsigned long long int maximum;
};

struct CheckIntegerSet
{
  // event
  struct CheckParameterEvent event;
  // set
  const unsigned long long int *set;
  // size_of_set
  unsigned long int size_of_set;
};

struct CheckMemoryData
{
  // event
  struct CheckParameterEvent event;
  // memory
  const void *memory;
  // size
  unsigned long int size;
};

struct ListNode
{
  // value
  const void *value;
  // refcount
  signed int refcount;
  // next
  struct ListNode *next;
  // prev
  struct ListNode *prev;
};

struct MallocBlockInfo
{
  // block
  void *block;
  // allocated_size
  unsigned long int allocated_size;
  // size
  unsigned long int size;
  // location
  struct SourceLocation location;
  // node
  struct ListNode node;
};

struct SymbolMapValue
{
  // symbol_name
  const char *symbol_name;
  // symbol_values_list_head
  struct ListNode symbol_values_list_head;
};

struct SymbolValue
{
  // location
  struct SourceLocation location;
  // value
  unsigned long long int value;
};

struct TestState
{
  // check_point
  const struct ListNode *check_point;
  // state
  void *state;
};

struct UnitTest
{
  // name
  const char *name;
  // function
  void (*function)(void **);
  // function_type
  enum UnitTestFunctionType function_type;
};

union ValuePointer
{
  // value
  unsigned long long int value;
  // x
  struct anonymous$5 x;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$6 __saved_mask;
};

struct api_object
{
  // display_id
  unsigned long int display_id;
};

struct wcore_config_attrs
{
  // context_api
  signed int context_api;
  // context_major_version
  signed int context_major_version;
  // context_minor_version
  signed int context_minor_version;
  // context_profile
  signed int context_profile;
  // rgb_size
  signed int rgb_size;
  // rgba_size
  signed int rgba_size;
  // red_size
  signed int red_size;
  // green_size
  signed int green_size;
  // blue_size
  signed int blue_size;
  // alpha_size
  signed int alpha_size;
  // depth_size
  signed int depth_size;
  // stencil_size
  signed int stencil_size;
  // samples
  signed int samples;
  // context_forward_compatible
  _Bool context_forward_compatible;
  // context_debug
  _Bool context_debug;
  // double_buffered
  _Bool double_buffered;
  // sample_buffers
  _Bool sample_buffers;
  // accum_buffer
  _Bool accum_buffer;
};

struct wcore_config
{
  // api
  struct api_object api;
  // attrs
  struct wcore_config_attrs attrs;
  // display
  struct wcore_display *display;
};

struct glx_config
{
  // wcore
  struct wcore_config wcore;
  // glx_fbconfig
  struct __GLXFBConfigRec *glx_fbconfig;
  // glx_fbconfig_id
  signed int glx_fbconfig_id;
  // xcb_visual_id
  unsigned int xcb_visual_id;
};

struct wcore_context
{
  // api
  struct api_object api;
  // display
  struct wcore_display *display;
};

struct glx_context
{
  // wcore
  struct wcore_context wcore;
  // glx
  struct __GLXcontextRec *glx;
};

struct wcore_display
{
  // api
  struct api_object api;
  // platform
  struct wcore_platform *platform;
};

struct x11_display
{
  // xlib
  struct _XDisplay *xlib;
  // xcb
  struct xcb_connection_t *xcb;
  // screen
  signed int screen;
};

struct glx_display
{
  // wcore
  struct wcore_display wcore;
  // x11
  struct x11_display x11;
  // ARB_create_context
  _Bool ARB_create_context;
  // ARB_create_context_profile
  _Bool ARB_create_context_profile;
  // EXT_create_context_es_profile
  _Bool EXT_create_context_es_profile;
  // EXT_create_context_es2_profile
  _Bool EXT_create_context_es2_profile;
};

struct wcore_platform
{
  // vtbl
  struct wcore_platform_vtbl *vtbl;
};

struct glx_platform
{
  // wcore
  struct wcore_platform wcore;
  // linux
  //struct linux_platform *linux;
  // glxHandle
  void *glxHandle;
  // glXCreateNewContext
  struct __GLXcontextRec * (*glXCreateNewContext)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int);
  // glXDestroyContext
  void (*glXDestroyContext)(struct _XDisplay *, struct __GLXcontextRec *);
  // glXMakeCurrent
  signed int (*glXMakeCurrent)(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
  // glXQueryExtensionsString
  const char * (*glXQueryExtensionsString)(struct _XDisplay *, signed int);
  // glXGetProcAddress
  void * (*glXGetProcAddress)(const unsigned char *);
  // glXGetVisualFromFBConfig
  struct anonymous$2 * (*glXGetVisualFromFBConfig)(struct _XDisplay *, struct __GLXFBConfigRec *);
  // glXGetFBConfigAttrib
  signed int (*glXGetFBConfigAttrib)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *);
  // glXChooseFBConfig
  struct __GLXFBConfigRec ** (*glXChooseFBConfig)(struct _XDisplay *, signed int, const signed int *, signed int *);
  // glXSwapBuffers
  void (*glXSwapBuffers)(struct _XDisplay *, unsigned long int);
  // glXCreateContextAttribsARB
  struct __GLXcontextRec * (*glXCreateContextAttribsARB)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *);
};

struct wcore_window
{
  // api
  struct api_object api;
  // display
  struct wcore_display *display;
};

struct x11_window
{
  // display
  struct x11_display *display;
  // xcb
  unsigned int xcb;
};

struct glx_window
{
  // wcore
  struct wcore_window wcore;
  // x11
  struct x11_window x11;
};

struct impl_thrd_param
{
  // func
  signed int (*func)(void *);
  // arg
  void *arg;
};

struct linux_dl
{
  // name
  const char *name;
  // dl
  void *dl;
};

struct linux_platform
{
  // libgl
  struct linux_dl *libgl;
  // libgles1
  struct linux_dl *libgles1;
  // libgles2
  struct linux_dl *libgles2;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct thread_arg
{
  // thread_id
  signed int thread_id;
  // mutex
  union anonymous *mutex;
  // cond
  union anonymous$1 *cond;
  // num_threads_waiting
  volatile signed int *num_threads_waiting;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct waffle_error_info
{
  // code
  enum waffle_error code;
  // message
  const char *message;
  // message_length
  unsigned long int message_length;
};

struct waffle_gbm_display
{
  // gbm_device
  struct gbm_device *gbm_device;
  // egl_display
  void *egl_display;
};

struct waffle_gbm_config
{
  // display
  struct waffle_gbm_display display;
  // egl_config
  void *egl_config;
};

struct waffle_gbm_context
{
  // display
  struct waffle_gbm_display display;
  // egl_context
  void *egl_context;
};

struct waffle_gbm_window
{
  // display
  struct waffle_gbm_display display;
  // gbm_surface
  struct gbm_surface *gbm_surface;
  // egl_surface
  void *egl_surface;
};

struct waffle_glx_config
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // glx_fbconfig
  struct __GLXFBConfigRec *glx_fbconfig;
};

struct waffle_glx_context
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // glx_context
  struct __GLXcontextRec *glx_context;
};

struct waffle_glx_display
{
  // xlib_display
  struct _XDisplay *xlib_display;
};

struct waffle_glx_window
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // xlib_window
  unsigned long int xlib_window;
};

union waffle_native_config
{
  // gbm
  struct waffle_gbm_config *gbm;
  // glx
  struct waffle_glx_config *glx;
  // x11_egl
  struct waffle_x11_egl_config *x11_egl;
  // wayland
  struct waffle_wayland_config *wayland;
};

union waffle_native_context
{
  // gbm
  struct waffle_gbm_context *gbm;
  // glx
  struct waffle_glx_context *glx;
  // x11_egl
  struct waffle_x11_egl_context *x11_egl;
  // wayland
  struct waffle_wayland_context *wayland;
};

union waffle_native_display
{
  // gbm
  struct waffle_gbm_display *gbm;
  // glx
  struct waffle_glx_display *glx;
  // x11_egl
  struct waffle_x11_egl_display *x11_egl;
  // wayland
  struct waffle_wayland_display *wayland;
};

union waffle_native_window
{
  // gbm
  struct waffle_gbm_window *gbm;
  // glx
  struct waffle_glx_window *glx;
  // x11_egl
  struct waffle_x11_egl_window *x11_egl;
  // wayland
  struct waffle_wayland_window *wayland;
};

struct waffle_wayland_display
{
  // wl_display
  struct wl_display *wl_display;
  // wl_compositor
  struct wl_compositor *wl_compositor;
  // wl_shell
  struct wl_shell *wl_shell;
  // egl_display
  void *egl_display;
};

struct waffle_wayland_config
{
  // display
  struct waffle_wayland_display display;
  // egl_config
  void *egl_config;
};

struct waffle_wayland_context
{
  // display
  struct waffle_wayland_display display;
  // egl_context
  void *egl_context;
};

struct waffle_wayland_window
{
  // display
  struct waffle_wayland_display display;
  // wl_surface
  struct wl_surface *wl_surface;
  // wl_shell_surface
  struct wl_shell_surface *wl_shell_surface;
  // wl_window
  struct wl_egl_window *wl_window;
  // egl_surface
  void *egl_surface;
};

struct waffle_x11_egl_display
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // egl_display
  void *egl_display;
};

struct waffle_x11_egl_config
{
  // display
  struct waffle_x11_egl_display display;
  // egl_config
  void *egl_config;
};

struct waffle_x11_egl_context
{
  // display
  struct waffle_x11_egl_display display;
  // egl_context
  void *egl_context;
};

struct waffle_x11_egl_window
{
  // display
  struct waffle_x11_egl_display display;
  // xlib_window
  unsigned long int xlib_window;
  // egl_surface
  void *egl_surface;
};

struct wegl_display
{
  // wcore
  struct wcore_display wcore;
  // egl
  void *egl;
  // KHR_create_context
  _Bool KHR_create_context;
};

struct wayland_display
{
  // wl_display
  struct wl_display *wl_display;
  // wl_registry
  struct wl_registry *wl_registry;
  // wl_compositor
  struct wl_compositor *wl_compositor;
  // wl_shell
  struct wl_shell *wl_shell;
  // wegl
  struct wegl_display wegl;
};

struct wegl_platform$0
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct wl_display *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, struct wl_egl_window *, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wayland_platform
{
  // wegl
  struct wegl_platform$0 wegl;
  // linux
  //struct linux_platform *linux;
};

struct wegl_window
{
  // wcore
  struct wcore_window wcore;
  // egl
  void *egl;
};

struct wayland_window
{
  // wl_surface
  struct wl_surface *wl_surface;
  // wl_shell_surface
  struct wl_shell_surface *wl_shell_surface;
  // wl_window
  struct wl_egl_window *wl_window;
  // wegl
  struct wegl_window wegl;
};

struct wcore_config_vtbl
{
  // choose
  struct wcore_config * (*choose)(struct wcore_platform *, struct wcore_display *, struct wcore_config_attrs *);
  // destroy
  _Bool (*destroy)(struct wcore_config *);
  // get_native
  union waffle_native_config * (*get_native)(struct wcore_config *);
};

struct wcore_context_vtbl
{
  // create
  struct wcore_context * (*create)(struct wcore_platform *, struct wcore_config *, struct wcore_context *);
  // destroy
  _Bool (*destroy)(struct wcore_context *);
  // get_native
  union waffle_native_context * (*get_native)(struct wcore_context *);
};

struct wcore_display_vtbl
{
  // connect
  struct wcore_display * (*connect)(struct wcore_platform *, const char *);
  // destroy
  _Bool (*destroy)(struct wcore_display *);
  // supports_context_api
  _Bool (*supports_context_api)(struct wcore_display *, signed int);
  // get_native
  union waffle_native_display * (*get_native)(struct wcore_display *);
};

struct wcore_error_tinfo
{
  // is_enabled
  _Bool is_enabled;
  // code
  enum waffle_error code;
  // message
  char message[1024l];
  // user_info
  struct waffle_error_info user_info;
};

struct wcore_window_vtbl
{
  // create
  struct wcore_window * (*create)(struct wcore_platform *, struct wcore_config *, signed int, signed int);
  // destroy
  _Bool (*destroy)(struct wcore_window *);
  // show
  _Bool (*show)(struct wcore_window *);
  // swap_buffers
  _Bool (*swap_buffers)(struct wcore_window *);
  // resize
  _Bool (*resize)(struct wcore_window *, signed int, signed int);
  // get_native
  union waffle_native_window * (*get_native)(struct wcore_window *);
};

struct wcore_platform_vtbl
{
  // destroy
  _Bool (*destroy)(struct wcore_platform *);
  // make_current
  _Bool (*make_current)(struct wcore_platform *, struct wcore_display *, struct wcore_window *, struct wcore_context *);
  // get_proc_address
  void * (*get_proc_address)(struct wcore_platform *, const char *);
  // dl_can_open
  _Bool (*dl_can_open)(struct wcore_platform *, signed int);
  // dl_sym
  void * (*dl_sym)(struct wcore_platform *, signed int, const char *);
  // display
  struct wcore_display_vtbl display;
  // config
  struct wcore_config_vtbl config;
  // context
  struct wcore_context_vtbl context;
  // window
  struct wcore_window_vtbl window;
};

struct wcore_tinfo
{
  // error
  struct wcore_error_tinfo *error;
  // is_init
  _Bool is_init;
};

struct wegl_config
{
  // wcore
  struct wcore_config wcore;
  // egl
  void *egl;
};

struct wegl_context
{
  // wcore
  struct wcore_context wcore;
  // egl
  void *egl;
};

struct wegl_platform
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct _XDisplay *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, unsigned long int, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wegl_platform$1
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct gbm_device *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, void *, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wegl_platform$2
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct gbm_device *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, void *, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wgbm_display
{
  // gbm_device
  struct gbm_device *gbm_device;
  // wegl
  struct wegl_display wegl;
};

struct wgbm_platform$0
{
  // wegl
  struct wegl_platform wegl;
  // linux
  //struct linux_platform *linux;
  // gbmHandle
  void *gbmHandle;
  // gbm_create_device
  struct gbm_device * (*gbm_create_device)(signed int);
  // gbm_device_get_fd
  signed int (*gbm_device_get_fd)(struct gbm_device *);
  // gbm_device_destroy
  void (*gbm_device_destroy)(struct gbm_device *);
  // gbm_surface_create
  struct gbm_surface * (*gbm_surface_create)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int);
  // gbm_surface_destroy
  void (*gbm_surface_destroy)(struct gbm_surface *);
  // gbm_surface_lock_front_buffer
  struct gbm_bo * (*gbm_surface_lock_front_buffer)(struct gbm_surface *);
  // gbm_surface_release_buffer
  void (*gbm_surface_release_buffer)(struct gbm_surface *, struct gbm_bo *);
};

struct wgbm_platform
{
  // wegl
  struct wegl_platform$1 wegl;
  // linux
  //struct linux_platform *linux;
  // gbmHandle
  void *gbmHandle;
  // gbm_create_device
  struct gbm_device * (*gbm_create_device)(signed int);
  // gbm_device_get_fd
  signed int (*gbm_device_get_fd)(struct gbm_device *);
  // gbm_device_destroy
  void (*gbm_device_destroy)(struct gbm_device *);
  // gbm_surface_create
  struct gbm_surface * (*gbm_surface_create)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int);
  // gbm_surface_destroy
  void (*gbm_surface_destroy)(struct gbm_surface *);
  // gbm_surface_lock_front_buffer
  struct gbm_bo * (*gbm_surface_lock_front_buffer)(struct gbm_surface *);
  // gbm_surface_release_buffer
  void (*gbm_surface_release_buffer)(struct gbm_surface *, struct gbm_bo *);
};

struct wgbm_platform$1
{
  // wegl
  struct wegl_platform$2 wegl;
  // linux
  //struct linux_platform *linux;
  // gbmHandle
  void *gbmHandle;
  // gbm_create_device
  struct gbm_device * (*gbm_create_device)(signed int);
  // gbm_device_get_fd
  signed int (*gbm_device_get_fd)(struct gbm_device *);
  // gbm_device_destroy
  void (*gbm_device_destroy)(struct gbm_device *);
  // gbm_surface_create
  struct gbm_surface * (*gbm_surface_create)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int);
  // gbm_surface_destroy
  void (*gbm_surface_destroy)(struct gbm_surface *);
  // gbm_surface_lock_front_buffer
  struct gbm_bo * (*gbm_surface_lock_front_buffer)(struct gbm_surface *);
  // gbm_surface_release_buffer
  void (*gbm_surface_release_buffer)(struct gbm_surface *, struct gbm_bo *);
};

struct wgbm_window
{
  // gbm_surface
  struct gbm_surface *gbm_surface;
  // wegl
  struct wegl_window wegl;
};

struct wl_interface
{
  // name
  const char *name;
  // version
  signed int version;
  // method_count
  signed int method_count;
  // methods
  struct wl_message *methods;
  // event_count
  signed int event_count;
  // events
  struct wl_message *events;
};

struct wl_message
{
  // name
  const char *name;
  // signature
  const char *signature;
  // types
  struct wl_interface **types;
};

struct wl_registry_listener
{
  // global
  void (*global)(void *, struct wl_registry *, unsigned int, const char *, unsigned int);
  // global_remove
  void (*global_remove)(void *, struct wl_registry *, unsigned int);
};

struct wl_shell_surface_listener
{
  // ping
  void (*ping)(void *, struct wl_shell_surface *, unsigned int);
  // configure
  void (*configure)(void *, struct wl_shell_surface *, unsigned int, signed int, signed int);
  // popup_done
  void (*popup_done)(void *, struct wl_shell_surface *);
};

struct xcb_depth_iterator_t
{
  // data
  struct xcb_depth_t *data;
  // rem
  signed int rem;
  // index
  signed int index;
};

struct xcb_depth_t
{
  // depth
  unsigned char depth;
  // pad0
  unsigned char pad0;
  // visuals_len
  unsigned short int visuals_len;
  // pad1
  unsigned char pad1[4l];
};

struct xcb_screen_iterator_t
{
  // data
  struct xcb_screen_t *data;
  // rem
  signed int rem;
  // index
  signed int index;
};

struct xcb_screen_t
{
  // root
  unsigned int root;
  // default_colormap
  unsigned int default_colormap;
  // white_pixel
  unsigned int white_pixel;
  // black_pixel
  unsigned int black_pixel;
  // current_input_masks
  unsigned int current_input_masks;
  // width_in_pixels
  unsigned short int width_in_pixels;
  // height_in_pixels
  unsigned short int height_in_pixels;
  // width_in_millimeters
  unsigned short int width_in_millimeters;
  // height_in_millimeters
  unsigned short int height_in_millimeters;
  // min_installed_maps
  unsigned short int min_installed_maps;
  // max_installed_maps
  unsigned short int max_installed_maps;
  // root_visual
  unsigned int root_visual;
  // backing_stores
  unsigned char backing_stores;
  // save_unders
  unsigned char save_unders;
  // root_depth
  unsigned char root_depth;
  // allowed_depths_len
  unsigned char allowed_depths_len;
};

struct xcb_setup_t
{
  // status
  unsigned char status;
  // pad0
  unsigned char pad0;
  // protocol_major_version
  unsigned short int protocol_major_version;
  // protocol_minor_version
  unsigned short int protocol_minor_version;
  // length
  unsigned short int length;
  // release_number
  unsigned int release_number;
  // resource_id_base
  unsigned int resource_id_base;
  // resource_id_mask
  unsigned int resource_id_mask;
  // motion_buffer_size
  unsigned int motion_buffer_size;
  // vendor_len
  unsigned short int vendor_len;
  // maximum_request_length
  unsigned short int maximum_request_length;
  // roots_len
  unsigned char roots_len;
  // pixmap_formats_len
  unsigned char pixmap_formats_len;
  // image_byte_order
  unsigned char image_byte_order;
  // bitmap_format_bit_order
  unsigned char bitmap_format_bit_order;
  // bitmap_format_scanline_unit
  unsigned char bitmap_format_scanline_unit;
  // bitmap_format_scanline_pad
  unsigned char bitmap_format_scanline_pad;
  // min_keycode
  unsigned char min_keycode;
  // max_keycode
  unsigned char max_keycode;
  // pad1
  unsigned char pad1[4l];
};

struct xcb_visualtype_iterator_t
{
  // data
  struct xcb_visualtype_t *data;
  // rem
  signed int rem;
  // index
  signed int index;
};

struct xcb_visualtype_t
{
  // visual_id
  unsigned int visual_id;
  // _class
  unsigned char _class;
  // bits_per_rgb_value
  unsigned char bits_per_rgb_value;
  // colormap_entries
  unsigned short int colormap_entries;
  // red_mask
  unsigned int red_mask;
  // green_mask
  unsigned int green_mask;
  // blue_mask
  unsigned int blue_mask;
  // pad0
  unsigned char pad0[4l];
};

struct xegl_display
{
  // x11
  struct x11_display x11;
  // wegl
  struct wegl_display wegl;
};

struct xegl_platform
{
  // wegl
  struct wegl_platform wegl;
  // linux
  //struct linux_platform *linux;
};

struct xegl_window
{
  // x11
  struct x11_window x11;
  // wegl
  struct wegl_window wegl;
};

struct xtime
{
  // sec
  signed long int sec;
  // nsec
  signed long int nsec;
};


// api_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.c line 35
struct wcore_platform *api_platform = ((struct wcore_platform *)NULL);
// default_signal_functions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 258
static void (*default_signal_functions[5l])(signed int);
// exception_signals
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 248
static const signed int exception_signals[5l] = { 8, 4, 11, 7, 31 };
// global_allocated_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 244
static struct ListNode global_allocated_blocks;
// global_expect_assert_env
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 227
struct __jmp_buf_tag global_expect_assert_env[1l];
// global_expecting_assert
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 228
signed int global_expecting_assert = 0;
// global_function_parameter_map_head
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 239
static struct ListNode global_function_parameter_map_head;
// global_function_result_map_head
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 233
static struct ListNode global_function_result_map_head;
// global_last_failed_assert
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 229
const char *global_last_failed_assert = (const char *)(void *)0;
// global_last_mock_value_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 235
static struct SourceLocation global_last_mock_value_location;
// global_last_parameter_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 241
static struct SourceLocation global_last_parameter_location;
// global_run_test_env
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 222
static struct __jmp_buf_tag global_run_test_env[1l];
// global_running_test
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 223
static signed int global_running_test = 0;
// glx_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 42
static struct wcore_platform_vtbl glx_platform_vtbl;
// glx_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 42
static struct wcore_platform_vtbl glx_platform_vtbl = { .destroy=glx_platform_destroy, .make_current=glx_platform_make_current, .get_proc_address=glx_platform_get_proc_address,
    .dl_can_open=glx_platform_dl_can_open,
    .dl_sym=glx_platform_dl_sym,
    .display={ .connect=glx_display_connect, .destroy=glx_display_destroy, .supports_context_api=glx_display_supports_context_api,
    .get_native=glx_display_get_native }, .config={ .choose=glx_config_choose, .destroy=glx_config_destroy, .get_native=glx_config_get_native },
    .context={ .create=glx_context_create, .destroy=glx_context_destroy, .get_native=glx_context_get_native },
    .window={ .create=glx_window_create, .destroy=glx_window_destroy, .show=glx_window_show,
    .swap_buffers=glx_window_swap_buffers, .resize=glx_window_resize,
    .get_native=glx_window_get_native } };
// libEGL_filename
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 35
static const char *libEGL_filename = "libEGL.so.1";
// libGL_filename
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 40
static const char *libGL_filename = "libGL.so.1";
// libgbm_filename
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 45
static const char *libgbm_filename = "libgbm.so.1";
// registry_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 86
static struct wl_registry_listener registry_listener;
// registry_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 86
static struct wl_registry_listener registry_listener = { .global=registry_listener_global, .global_remove=registry_listener_global_remove };
// shell_surface_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 90
static struct wl_shell_surface_listener shell_surface_listener;
// shell_surface_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 90
static struct wl_shell_surface_listener shell_surface_listener = { .ping=shell_surface_listener_ping, .configure=shell_surface_listener_configure, .popup_done=shell_surface_listener_popup_done };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// wayland_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 46
static struct wcore_platform_vtbl wayland_platform_vtbl;
// wayland_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 46
static struct wcore_platform_vtbl wayland_platform_vtbl = { .destroy=wayland_platform_destroy, .make_current=wegl_make_current, .get_proc_address=wegl_get_proc_address,
    .dl_can_open=wayland_dl_can_open,
    .dl_sym=wayland_dl_sym, .display={ .connect=wayland_display_connect, .destroy=wayland_display_destroy, .supports_context_api=wegl_display_supports_context_api,
    .get_native=wayland_display_get_native },
    .config={ .choose=wegl_config_choose, .destroy=wegl_config_destroy, .get_native=wayland_config_get_native },
    .context={ .create=wegl_context_create, .destroy=wegl_context_destroy, .get_native=wayland_context_get_native },
    .window={ .create=wayland_window_create, .destroy=wayland_window_destroy, .show=wayland_window_show,
    .swap_buffers=wayland_window_swap_buffers, .resize=wayland_window_resize,
    .get_native=wayland_window_get_native } };
// wcore_tinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 50
static struct wcore_tinfo wcore_tinfo;
// wcore_tinfo_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 37
static unsigned int wcore_tinfo_key;
// wcore_tinfo_once
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 36
static signed int wcore_tinfo_once = 0;
// wgbm_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 47
static struct wcore_platform_vtbl wgbm_platform_vtbl;
// wgbm_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 47
static struct wcore_platform_vtbl wgbm_platform_vtbl = { .destroy=wgbm_platform_destroy, .make_current=wegl_make_current, .get_proc_address=wegl_get_proc_address,
    .dl_can_open=wgbm_dl_can_open,
    .dl_sym=wgbm_dl_sym, .display={ .connect=wgbm_display_connect, .destroy=wgbm_display_destroy, .supports_context_api=wegl_display_supports_context_api,
    .get_native=wgbm_display_get_native },
    .config={ .choose=wgbm_config_choose, .destroy=wegl_config_destroy, .get_native=wgbm_config_get_native },
    .context={ .create=wegl_context_create, .destroy=wegl_context_destroy, .get_native=wgbm_context_get_native },
    .window={ .create=wgbm_window_create, .destroy=wgbm_window_destroy, .show=wgbm_window_show,
    .swap_buffers=wgbm_window_swap_buffers, .resize=((_Bool (*)(struct wcore_window *, signed int, signed int))NULL),
    .get_native=wgbm_window_get_native } };
// wl_compositor_interface
// file /usr/include/wayland-client-protocol.h line 68
extern struct wl_interface wl_compositor_interface;
// wl_registry_interface
// file /usr/include/wayland-client-protocol.h line 66
extern struct wl_interface wl_registry_interface;
// wl_shell_interface
// file /usr/include/wayland-client-protocol.h line 76
extern struct wl_interface wl_shell_interface;
// wl_shell_surface_interface
// file /usr/include/wayland-client-protocol.h line 77
extern struct wl_interface wl_shell_surface_interface;
// wl_surface_interface
// file /usr/include/wayland-client-protocol.h line 78
extern struct wl_interface wl_surface_interface;
// xegl_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 43
static struct wcore_platform_vtbl xegl_platform_vtbl;
// xegl_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 43
static struct wcore_platform_vtbl xegl_platform_vtbl = { .destroy=xegl_platform_destroy, .make_current=wegl_make_current, .get_proc_address=wegl_get_proc_address,
    .dl_can_open=xegl_dl_can_open,
    .dl_sym=xegl_dl_sym, .display={ .connect=xegl_display_connect, .destroy=xegl_display_destroy, .supports_context_api=wegl_display_supports_context_api,
    .get_native=xegl_display_get_native },
    .config={ .choose=wegl_config_choose, .destroy=wegl_config_destroy, .get_native=xegl_config_get_native },
    .context={ .create=wegl_context_create, .destroy=wegl_context_destroy, .get_native=xegl_context_get_native },
    .window={ .create=xegl_window_create, .destroy=xegl_window_destroy, .show=xegl_window_show,
    .swap_buffers=wegl_window_swap_buffers, .resize=xegl_window_resize,
    .get_native=xegl_window_get_native } };

// _assert_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1353
void _assert_in_range(const unsigned long long int value, const unsigned long long int minimum, const unsigned long long int maximum, const char * const file, const signed int line)
{
  signed int return_value_integer_in_range_display_error$1;
  return_value_integer_in_range_display_error$1=integer_in_range_display_error(value, minimum, maximum);
  if(return_value_integer_in_range_display_error$1 == 0)
    _fail(file, line);

}

// _assert_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1371
void _assert_in_set(const unsigned long long int value, const unsigned long long int *values, const unsigned long int number_of_values, const char * const file, const signed int line)
{
  struct CheckIntegerSet check_integer_set;
  check_integer_set.set = values;
  check_integer_set.size_of_set = number_of_values;
  signed int return_value_value_in_set_display_error$1;
  return_value_value_in_set_display_error$1=value_in_set_display_error(value, &check_integer_set, 0);
  if(return_value_value_in_set_display_error$1 == 0)
    _fail(file, line);

}

// _assert_int_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1687
void _assert_int_equal(const unsigned long long int a, const unsigned long long int b, const char * const file, const signed int line)
{
  signed int return_value_values_equal_display_error$1;
  return_value_values_equal_display_error$1=values_equal_display_error(a, b);
  if(return_value_values_equal_display_error$1 == 0)
    _fail(file, line);

}

// _assert_int_not_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1309
void _assert_int_not_equal(const unsigned long long int a, const unsigned long long int b, const char * const file, const signed int line)
{
  signed int return_value_values_not_equal_display_error$1;
  return_value_values_not_equal_display_error$1=values_not_equal_display_error(a, b);
  if(return_value_values_not_equal_display_error$1 == 0)
    _fail(file, line);

}

// _assert_memory_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1334
void _assert_memory_equal(const void * const a, const void * const b, const unsigned long int size, const char * const file, const signed int line)
{
  signed int return_value_memory_equal_display_error$1;
  return_value_memory_equal_display_error$1=memory_equal_display_error((const char *)a, (const char *)b, size);
  if(return_value_memory_equal_display_error$1 == 0)
    _fail(file, line);

}

// _assert_memory_not_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1343
void _assert_memory_not_equal(const void * const a, const void * const b, const unsigned long int size, const char * const file, const signed int line)
{
  signed int return_value_memory_not_equal_display_error$1;
  return_value_memory_not_equal_display_error$1=memory_not_equal_display_error((const char *)a, (const char *)b, size);
  if(return_value_memory_not_equal_display_error$1 == 0)
    _fail(file, line);

}

// _assert_not_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1362
void _assert_not_in_range(const unsigned long long int value, const unsigned long long int minimum, const unsigned long long int maximum, const char * const file, const signed int line)
{
  signed int return_value_integer_not_in_range_display_error$1;
  return_value_integer_not_in_range_display_error$1=integer_not_in_range_display_error(value, minimum, maximum);
  if(return_value_integer_not_in_range_display_error$1 == 0)
    _fail(file, line);

}

// _assert_not_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1383
void _assert_not_in_set(const unsigned long long int value, const unsigned long long int *values, const unsigned long int number_of_values, const char * const file, const signed int line)
{
  struct CheckIntegerSet check_integer_set;
  check_integer_set.set = values;
  check_integer_set.size_of_set = number_of_values;
  signed int return_value_value_in_set_display_error$1;
  return_value_value_in_set_display_error$1=value_in_set_display_error(value, &check_integer_set, 1);
  if(return_value_value_in_set_display_error$1 == 0)
    _fail(file, line);

}

// _assert_string_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1693
void _assert_string_equal(const char * const a, const char * const b, const char * const file, const signed int line)
{
  signed int return_value_string_equal_display_error$1;
  return_value_string_equal_display_error$1=string_equal_display_error(a, b);
  if(return_value_string_equal_display_error$1 == 0)
    _fail(file, line);

}

// _assert_string_not_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1326
void _assert_string_not_equal(const char * const a, const char * const b, const char *file, const signed int line)
{
  signed int return_value_string_not_equal_display_error$1;
  return_value_string_not_equal_display_error$1=string_not_equal_display_error(a, b);
  if(return_value_string_not_equal_display_error$1 == 0)
    _fail(file, line);

}

// _assert_true
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1684
void _assert_true(const unsigned long long int result, const char * const expression, const char * const file, const signed int line)
{
  if(result == 0ull)
  {
    print_error("%s\n", expression);
    _fail(file, line);
  }

}

// _check_expected
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1232
void _check_expected(const char * const function_name, const char * const parameter_name, const char *file, const signed int line, const unsigned long long int value)
{
  void *result;
  const char *symbols[2l] = { function_name, parameter_name };
  signed int rc;
  rc=get_symbol_value(&global_function_parameter_map_head, symbols, (const unsigned long int)2, &result);
  if(!(rc == 0))
  {
    struct CheckParameterEvent * const check = (struct CheckParameterEvent *)result;
    signed int check_succeeded;
    global_last_parameter_location = check->location;
    check_succeeded=check->check_value(value, check->check_value_data);
    if(rc == 1)
      free((void *)check);

    if(check_succeeded == 0)
    {
      print_error("%s:%u: error: Check of parameter %s, function %s failed\n%s:%u: note: Expected parameter declared here\n", file, line, parameter_name, function_name, global_last_parameter_location.file, global_last_parameter_location.line);
      _fail(file, line);
    }

  }

  else
  {
    print_error("%s:%u: error: Could not get value to check parameter %s of function %s\n", file, line, parameter_name, function_name);
    signed int return_value_source_location_is_set$1;
    return_value_source_location_is_set$1=source_location_is_set(&global_last_parameter_location);
    if(!(return_value_source_location_is_set$1 == 0))
      print_error("%s:%u: note: Previously declared parameter value was declared here\n", global_last_parameter_location.file, global_last_parameter_location.line);

    else
      print_error("There were no previously declared parameter values for this test.\n");
    exit_test(1);
  }
}

// _expect_any
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1224
void _expect_any(const char * const function, const char * const parameter, const char * const file, const signed int line, const signed int count)
{
  _expect_check(function, parameter, file, line, check_any, (const unsigned long long int)0, (struct CheckParameterEvent *)(void *)0, count);
}

// _expect_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 746
void _expect_check(const char * const function, const char * const parameter, const char * const file, const signed int line, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const unsigned long long int check_data, struct CheckParameterEvent * const event, const signed int count)
{
  struct CheckParameterEvent *check;
  struct CheckParameterEvent *tmp_if_expr$2;
  void *return_value_malloc$1;
  if(!(event == ((struct CheckParameterEvent *)NULL)))
    tmp_if_expr$2 = event;

  else
  {
    return_value_malloc$1=malloc(sizeof(struct CheckParameterEvent) /*40ul*/ );
    tmp_if_expr$2 = (struct CheckParameterEvent *)return_value_malloc$1;
  }
  check = tmp_if_expr$2;
  const char *symbols[2l] = { function, parameter };
  check->parameter_name = parameter;
  check->check_value = check_function;
  check->check_value_data = check_data;
  set_source_location(&check->location, file, line);
  add_symbol_value(&global_function_parameter_map_head, symbols, (const unsigned long int)2, (const void *)check, count);
}

// _expect_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1047
void _expect_in_range(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int minimum, const unsigned long long int maximum, const signed int count)
{
  expect_range(function, parameter, file, line, minimum, maximum, check_in_range, count);
}

// _expect_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 984
void _expect_in_set(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int *values, const unsigned long int number_of_values, const signed int count)
{
  expect_set(function, parameter, file, line, values, number_of_values, check_in_set, count);
}

// _expect_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1181
void _expect_memory(const char * const function, const char * const parameter, const char * const file, const signed int line, const void * const memory, const unsigned long int size, const signed int count)
{
  expect_memory_setup(function, parameter, file, line, memory, size, check_memory, count);
}

// _expect_not_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1058
void _expect_not_in_range(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int minimum, const unsigned long long int maximum, const signed int count)
{
  expect_range(function, parameter, file, line, minimum, maximum, check_not_in_range, count);
}

// _expect_not_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 995
void _expect_not_in_set(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int *values, const unsigned long int number_of_values, const signed int count)
{
  expect_set(function, parameter, file, line, values, number_of_values, check_not_in_set, count);
}

// _expect_not_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1205
void _expect_not_memory(const char * const function, const char * const parameter, const char * const file, const signed int line, const void * const memory, const unsigned long int size, const signed int count)
{
  expect_memory_setup(function, parameter, file, line, memory, size, check_not_memory, count);
}

// _expect_not_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1136
void _expect_not_string(const char * const function, const char * const parameter, const char * const file, const signed int line, const char *string, const signed int count)
{
  union ValuePointer string_pointer;
  string_pointer.value = (unsigned long long int)0;
  string_pointer.x.pointer = (void *)(unsigned long int)string;
  _expect_check(function, parameter, file, line, check_not_string, string_pointer.value, (struct CheckParameterEvent *)(void *)0, count);
}

// _expect_not_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1095
void _expect_not_value(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int value, const signed int count)
{
  _expect_check(function, parameter, file, line, check_not_value, value, (struct CheckParameterEvent *)(void *)0, count);
}

// _expect_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1114
void _expect_string(const char * const function, const char * const parameter, const char * const file, const signed int line, const char *string, const signed int count)
{
  union ValuePointer string_pointer;
  string_pointer.value = (unsigned long long int)0;
  string_pointer.x.pointer = (void *)(unsigned long int)string;
  _expect_check(function, parameter, file, line, check_string, string_pointer.value, (struct CheckParameterEvent *)(void *)0, count);
}

// _expect_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1077
void _expect_value(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int value, const signed int count)
{
  _expect_check(function, parameter, file, line, check_value, value, (struct CheckParameterEvent *)(void *)0, count);
}

// _fail
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1553
void _fail(const char * const file, const signed int line)
{
  print_error("%s:%u: error: Failure!\n", file, line);
  exit_test(1);
}

// _mock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 695
unsigned long long int _mock(const char * const function, const char * const file, const signed int line)
{
  void *result;
  signed int rc;
  rc=get_symbol_value(&global_function_result_map_head, &function, (const unsigned long int)1, &result);
  if(!(rc == 0))
  {
    struct SymbolValue * const symbol = (struct SymbolValue *)result;
    const unsigned long long int value = symbol->value;
    global_last_mock_value_location = symbol->location;
    if(rc == 1)
      free((void *)symbol);

    return value;
  }

  else
  {
    print_error("%s:%u: error: Could not get value to mock function %s\n", file, line, function);
    signed int return_value_source_location_is_set$1;
    return_value_source_location_is_set$1=source_location_is_set(&global_last_mock_value_location);
    if(!(return_value_source_location_is_set$1 == 0))
      print_error("%s:%u: note: Previously returned mock value was declared here\n", global_last_mock_value_location.file, global_last_mock_value_location.line);

    else
      print_error("There were no previously returned mock values for this test.\n");
    exit_test(1);
  }
  return (unsigned long long int)0;
}

// _run_test
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1646
signed int _run_test(const char * const function_name, void (* const Function)(void **), void ** const volatile state, const enum UnitTestFunctionType function_type, const void * const heap_check_point)
{
  const struct ListNode * volatile check_point;
  const struct ListNode *tmp_if_expr$2;
  const struct ListNode *return_value_check_point_allocated_blocks$1;
  if(!(heap_check_point == NULL))
    tmp_if_expr$2 = (const struct ListNode *)heap_check_point;

  else
  {
    return_value_check_point_allocated_blocks$1=check_point_allocated_blocks();
    tmp_if_expr$2 = return_value_check_point_allocated_blocks$1;
  }
  check_point = (const struct ListNode *)tmp_if_expr$2;
  void *current_state = (void *)0;
  volatile signed int rc = 1;
  signed int handle_exceptions = 1;
  if(!(handle_exceptions == 0))
  {
    unsigned int i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 5ul); i = i + 1u)
      default_signal_functions[(signed long int)i]=signal(exception_signals[(signed long int)i], exception_handler);
  }

  if((signed int)function_type == UNIT_TEST_FUNCTION_TYPE_TEST)
    print_message("[ RUN      ] %s\n", function_name);

  initialize_testing(function_name);
  global_running_test = 1;
  signed int return_value__setjmp$3;
  return_value__setjmp$3=_setjmp(global_run_test_env);
  if(return_value__setjmp$3 == 0)
  {
    Function(state != ((void ** const volatile )NULL) ? state : &current_state);
    fail_if_leftover_values(function_name);
    if(!((signed int)function_type == UNIT_TEST_FUNCTION_TYPE_SETUP))
      fail_if_blocks_allocated(check_point, function_name);

    global_running_test = 0;
    if((signed int)function_type == UNIT_TEST_FUNCTION_TYPE_TEST)
      print_message("[       OK ] %s\n", function_name);

    rc = 0;
  }

  else
  {
    global_running_test = 0;
    print_message("[  FAILED  ] %s\n", function_name);
  }
  teardown_testing(function_name);
  if(!(handle_exceptions == 0))
  {
    unsigned int _run_test$$1$$5$$i = (unsigned int)0;
    for( ; !((unsigned long int)_run_test$$1$$5$$i >= 5ul); _run_test$$1$$5$$i = _run_test$$1$$5$$i + 1u)
      signal(exception_signals[(signed long int)_run_test$$1$$5$$i], default_signal_functions[(signed long int)_run_test$$1$$5$$i]);
  }

  return rc;
}

// _run_tests
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/include/cmocka.h line 1726
signed int _run_tests(const struct UnitTest * const tests, const unsigned long int number_of_tests)
{
  signed int run_next_test = 1;
  signed int previous_test_failed = 0;
  const struct ListNode *check_point;
  check_point=check_point_allocated_blocks();
  unsigned long int current_test = (unsigned long int)0;
  unsigned long int tests_executed = (unsigned long int)0;
  unsigned long int total_failed = (unsigned long int)0;
  unsigned long int setups = (unsigned long int)0;
  unsigned long int teardowns = (unsigned long int)0;
  struct TestState *test_states;
  void *return_value__test_malloc$1;
  return_value__test_malloc$1=_test_malloc(number_of_tests * sizeof(struct TestState) /*16ul*/ , "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1743);
  test_states = (struct TestState *)return_value__test_malloc$1;
  unsigned long int number_of_test_states = (unsigned long int)0;
  const char **failed_names;
  void *return_value__test_malloc$2;
  return_value__test_malloc$2=_test_malloc(number_of_tests * sizeof(const char *) /*8ul*/ , "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1746);
  failed_names = (const char **)return_value__test_malloc$2;
  void **current_state = (void **)(void *)0;
  print_message("[==========] Running %zd test(s).\n", number_of_tests);
  _assert_true((unsigned long int)(sizeof(unsigned long long int) /*8ul*/  >= sizeof(void *) /*8ul*/ ), "sizeof(LargestIntegralType) >= sizeof(void*)", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1753);
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$4;
  while(!(current_test >= number_of_tests))
  {
    const struct ListNode *test_check_point = (const struct ListNode *)(void *)0;
    struct TestState *current_TestState;
    const struct UnitTest *test;
    tmp_post$3 = current_test;
    current_test = current_test + 1ul;
    test = &tests[(signed long int)tmp_post$3];
    if(!(test->function == ((void (*)(void **))NULL)))
    {
      switch((signed int)test->function_type)
      {
        case UNIT_TEST_FUNCTION_TYPE_TEST:
        {
          run_next_test = 1;
          break;
        }
        case UNIT_TEST_FUNCTION_TYPE_SETUP:
        {
          tmp_post$4 = number_of_test_states;
          number_of_test_states = number_of_test_states + 1ul;
          current_TestState = &test_states[(signed long int)tmp_post$4];
          current_TestState->check_point=check_point_allocated_blocks();
          test_check_point = current_TestState->check_point;
          current_state = &current_TestState->state;
          *current_state = (void *)0;
          run_next_test = 1;
          setups = setups + 1ul;
          break;
        }
        case UNIT_TEST_FUNCTION_TYPE_TEARDOWN:
        {
          _assert_true((unsigned long int)number_of_test_states, "number_of_test_states", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1780);
          number_of_test_states = number_of_test_states - 1ul;
          current_TestState = &test_states[(signed long int)number_of_test_states];
          test_check_point = current_TestState->check_point;
          current_state = &current_TestState->state;
          teardowns = teardowns + 1ul;
          break;
        }
        default:
        {
          print_error("Invalid unit test function type %d\n", test->function_type);
          exit_test(1);
        }
      }
      if(!(run_next_test == 0))
      {
        signed int failed;
        failed=_run_test(test->name, test->function, current_state, test->function_type, (const void *)test_check_point);
        if(!(failed == 0))
          failed_names[(signed long int)total_failed] = test->name;

        switch((signed int)test->function_type)
        {
          case UNIT_TEST_FUNCTION_TYPE_TEST:
          {
            previous_test_failed = failed;
            total_failed = total_failed + (unsigned long int)failed;
            tests_executed = tests_executed + 1ul;
            break;
          }
          case UNIT_TEST_FUNCTION_TYPE_SETUP:
          {
            if(!(failed == 0))
            {
              total_failed = total_failed + 1ul;
              tests_executed = tests_executed + 1ul;
              run_next_test = 0;
            }

            previous_test_failed = 0;
            break;
          }
          case UNIT_TEST_FUNCTION_TYPE_TEARDOWN:
          {
            if(previous_test_failed == 0 && !(failed == 0))
              total_failed = total_failed + 1ul;

            break;
          }
          default:
            _assert_true((const unsigned long long int)!((unsigned long int)"BUG: shouldn't be here!" != 0ull), "\"BUG: shouldn't be here!\"", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1825);
        }
      }

    }

  }
  print_message("[==========] %zd test(s) run.\n", tests_executed);
  print_error("[  PASSED  ] %zd test(s).\n", tests_executed - total_failed);
  if(!(total_failed == 0ul))
  {
    unsigned long int i;
    print_error("[  FAILED  ] %zd test(s), listed below:\n", total_failed);
    i = (unsigned long int)0;
    for( ; !(i >= total_failed); i = i + 1ul)
      print_error("[  FAILED  ] %s\n", failed_names[(signed long int)i]);
  }

  else
    print_error("\n %zd FAILED TEST(S)\n", total_failed);
  if(!(number_of_test_states == 0ul))
  {
    print_error("[  ERROR   ] Mismatched number of setup %zd and teardown %zd functions\n", setups, teardowns);
    total_failed = (unsigned long int)-1;
  }

  _test_free((void *)test_states, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1851);
  _test_free((void *)failed_names, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1852);
  fail_if_blocks_allocated(check_point, "run_tests");
  return (signed int)total_failed;
}

// _test_calloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1439
void * _test_calloc(const unsigned long int number_of_elements, const unsigned long int size, const char *file, const signed int line)
{
  void *ptr;
  ptr=_test_malloc(number_of_elements * size, file, line);
  if(!(ptr == NULL))
    memset(ptr, 0, number_of_elements * size);

  return ptr;
}

// _test_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1451
void _test_free(void * const ptr, const char *file, const signed int line)
{
  unsigned int i;
  char *block = (char *)(void *)(unsigned long int)ptr;
  struct MallocBlockInfo *block_info;
  _assert_true((unsigned long int)ptr, "ptr", file, line);
  block_info = (struct MallocBlockInfo *)(block - (signed long int)((unsigned long int)16 + sizeof(struct MallocBlockInfo) /*72ul*/ ));
  char *guards[2l] = { block - (signed long int)16, block + (signed long int)block_info->size };
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 2ul); i = i + 1u)
  {
    unsigned int j;
    char * const guard = guards[(signed long int)i];
    j = (unsigned int)0;
    for( ; !(j >= 16u); j = j + 1u)
    {
      const char diff = (const char)((signed int)guard[(signed long int)j] - 0xEF);
      if(!(diff == 0))
      {
        print_error("%s:%u: error: Guard block of %p size=%lu is corrupt\n%s:%u: note: allocated here at %p\n", file, line, ptr, (unsigned long int)block_info->size, block_info->location.file, block_info->location.line, &guard[(signed long int)j]);
        _fail(file, line);
      }

    }
  }
  list_remove(&block_info->node, (void (*)(const void *, void *))(void *)0, (void *)0);
  block = (char *)(void *)(unsigned long int)block_info->block;
  memset((void *)block, 0xCD, block_info->allocated_size);
  free((void *)block);
}

// _test_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1408
void * _test_malloc(const unsigned long int size, const char *file, const signed int line)
{
  char *ptr;
  struct MallocBlockInfo *block_info;
  struct ListNode *block_list;
  block_list=get_allocated_blocks_list();
  const unsigned long int allocate_size = size + (unsigned long int)(16 * 2) + sizeof(struct MallocBlockInfo) /*72ul*/  + sizeof(unsigned long int) /*8ul*/ ;
  char *block;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(allocate_size);
  block = (char *)return_value_malloc$1;
  _assert_true((unsigned long int)block, "block", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1415);
  ptr = (char *)((unsigned long int)block + (unsigned long int)16 + sizeof(struct MallocBlockInfo) /*72ul*/  + sizeof(unsigned long int) /*8ul*/  & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
  memset((void *)(ptr - (signed long int)16), 0xEF, (unsigned long int)16);
  memset((void *)(ptr + (signed long int)size), 0xEF, (unsigned long int)16);
  memset((void *)ptr, 0xBA, size);
  block_info = (struct MallocBlockInfo *)(ptr - (signed long int)((unsigned long int)16 + sizeof(struct MallocBlockInfo) /*72ul*/ ));
  set_source_location(&block_info->location, file, line);
  block_info->allocated_size = allocate_size;
  block_info->size = size;
  block_info->block = (void *)block;
  block_info->node.value = (const void *)block_info;
  list_add(block_list, &block_info->node);
  return (void *)ptr;
}

// _wcore_error_disable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 90
void _wcore_error_disable(void)
{
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  return_value_wcore_tinfo_get$1->error->is_enabled = (_Bool)0;
}

// _wcore_error_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 89
void _wcore_error_enable(void)
{
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  return_value_wcore_tinfo_get$1->error->is_enabled = (_Bool)1;
}

// _wcore_error_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 87
void _wcore_error_internal(const char *file, signed int line, const char *format, ...)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get$1->error;
  char *cur = t->message;
  char *end = t->message + (signed long int)1024;
  signed int printed;
  if(!(t->is_enabled == (_Bool)0))
  {
    t->code = (enum waffle_error)WAFFLE_ERROR_INTERNAL;
    printed=snprintf(cur, (unsigned long int)(end - cur), "waffle: internal error: %s:%d: ", file, line);
    cur = cur + (signed long int)printed;
    if(!(cur >= end) && printed >= 0)
    {
      if(!(format == ((const char *)NULL)))
      {
        void **ap = (void **)&format;
        printed=vsnprintf(cur, (unsigned long int)(end - cur), format, ap);
        cur = cur + (signed long int)printed;
        ap = ((void **)NULL);
        if(cur >= end || !(printed >= 0))
          goto __CPROVER_DUMP_L5;

      }

      snprintf(cur, (unsigned long int)(end - cur), " ; Please report bug at https://github.com/waffle-gl/waffle/issues");
    }

  }


__CPROVER_DUMP_L5:
  ;
}

// _will_return
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 727
void _will_return(const char * const function_name, const char * const file, const signed int line, const unsigned long long int value, const signed int count)
{
  struct SymbolValue *return_value;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct SymbolValue) /*24ul*/ );
  return_value = (struct SymbolValue *)return_value_malloc$1;
  _assert_true((unsigned long int)(count > 0 || count == -1), "count > 0 || count == -1", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 732);
  return_value->value = value;
  set_source_location(&return_value->location, file, line);
  add_symbol_value(&global_function_result_map_head, &function_name, (const unsigned long int)1, (const void *)return_value, count);
}

// add_symbol_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 525
static void add_symbol_value(struct ListNode * const symbol_map_head, const char * const *symbol_names, const unsigned long int number_of_symbol_names, const void *value, const signed int refcount)
{
  const char *symbol_name;
  struct ListNode *target_node;
  struct SymbolMapValue *target_map_value;
  _assert_true((unsigned long int)symbol_map_head, "symbol_map_head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 532);
  _assert_true((unsigned long int)symbol_names, "symbol_names", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 533);
  _assert_true((unsigned long int)number_of_symbol_names, "number_of_symbol_names", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 534);
  symbol_name = symbol_names[(signed long int)0];
  signed int return_value_list_find$2;
  return_value_list_find$2=list_find(symbol_map_head, (const void *)symbol_name, symbol_names_match, &target_node);
  if(return_value_list_find$2 == 0)
  {
    struct SymbolMapValue *new_symbol_map_value;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct SymbolMapValue) /*40ul*/ );
    new_symbol_map_value = (struct SymbolMapValue *)return_value_malloc$1;
    new_symbol_map_value->symbol_name = symbol_name;
    list_initialize(&new_symbol_map_value->symbol_values_list_head);
    target_node=list_add_value(symbol_map_head, (const void *)new_symbol_map_value, 1);
  }

  target_map_value = (struct SymbolMapValue *)target_node->value;
  if(number_of_symbol_names == 1ul)
    list_add_value(&target_map_value->symbol_values_list_head, value, refcount);

  else
    add_symbol_value(&target_map_value->symbol_values_list_head, &symbol_names[(signed long int)1], number_of_symbol_names - (unsigned long int)1, value, refcount);
}

// api_check_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.c line 38
_Bool api_check_entry(struct api_object **obj_list, signed int length)
{
  wcore_error_reset();
  if(api_platform == ((struct wcore_platform *)NULL))
  {
    wcore_error((enum waffle_error)WAFFLE_ERROR_NOT_INITIALIZED);
    return (_Bool)0;
  }

  else
  {
    signed int i = 0;
    for( ; !(i >= length); i = i + 1)
    {
      if(obj_list[(signed long int)i] == ((struct api_object *)NULL))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_PARAMETER, "null pointer");
        return (_Bool)0;
      }

      if(!(obj_list[(signed long int)i]->display_id == (*obj_list)->display_id))
      {
        wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_DISPLAY_MATCH);
        return (_Bool)0;
      }

    }
    return (_Bool)1;
  }
}

// bind_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 38
static _Bool bind_api(struct wegl_platform *plat, signed int waffle_context_api)
{
  _Bool ok = (_Bool)1;
  unsigned int return_value;
  unsigned int return_value_1;
  switch(waffle_context_api)
  {
    case 523:
      return_value=plat->eglBindAPI((unsigned int)0x30A2);
    case 524:

    case 525:

    case 532:
      return_value_1=plat->eglBindAPI((unsigned int)0x30A0);
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c", 53, "waffle_context_api has bad value #x%x", waffle_context_api);
      return (_Bool)0;
    }
  }
  if(ok == (_Bool)0)
    wegl_emit_error(plat, "eglBindAPI");

  return ok;
}

// call_once
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 147
void call_once(signed int *flag, void (*func)(void))
{
  pthread_once(flag, func);
}

// check_any
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1215
static signed int check_any(const unsigned long long int value, const unsigned long long int check_value_data)
{
  (void)value;
  (void)check_value_data;
  return 1;
}

// check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 41
static _Bool check_context_attrs(struct wegl_display *dpy, struct wcore_config_attrs *attrs)
{
  struct wcore_platform *plat = dpy->wcore.platform;
  _Bool return_value_wcore_config_attrs_version_eq$1;
  _Bool return_value_wcore_config_attrs_version_ge$2;
  _Bool return_value;
  _Bool return_value_1;
  _Bool return_value_2;
  _Bool return_value_3;
  if(!(attrs->context_debug == (_Bool)0))
  {
    if(dpy->KHR_create_context != (_Bool)0)
      goto __CPROVER_DUMP_L1;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "EGL_KHR_create_context is required in order to request a debug context");
    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    switch(attrs->context_api)
    {
      case 523:
      {
        return_value_wcore_config_attrs_version_eq$1=wcore_config_attrs_version_eq(attrs, 10);
        if(return_value_wcore_config_attrs_version_eq$1 == (_Bool)0)
        {
          if(dpy->KHR_create_context == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "KHR_EXT_create_context is required in order to request an OpenGL version not equal to the default value 1.0");
            return (_Bool)0;
          }

        }

        return_value_wcore_config_attrs_version_ge$2=wcore_config_attrs_version_ge(attrs, 32);
        if(!(attrs->context_forward_compatible == (_Bool)0))
        {
          if(dpy->KHR_create_context == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "EGL_KHR_create_context is required in order to request a forward-compatible context");
            return (_Bool)0;
          }

        }

        return_value=plat->vtbl->dl_can_open(plat, 769);
      }
      case 524:
        return_value_1=plat->vtbl->dl_can_open(plat, 770);
      case 525:
        return_value_2=plat->vtbl->dl_can_open(plat, 771);
      case 532:
      {
        if(dpy->KHR_create_context == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "EGL_KHR_create_context is required to request an OpenGL ES3 context");
          return (_Bool)0;
        }

        return_value_3=plat->vtbl->dl_can_open(plat, 772);
      }
    }
    if(return_value_3 == (_Bool)0)
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES3 library");
      return (_Bool)0;
    }

    else
    {
      return (_Bool)1;
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c", 124, "context_api has bad value %#x", attrs->context_api);
      return (_Bool)0;
    }
  }
}

// check_final
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 456
static _Bool check_final(struct wcore_config_attrs *attrs)
{
  _Bool return_value_wcore_config_attrs_version_ge$1;
  if(attrs->context_api == 523)
  {
    if(!(attrs->context_profile == 529))
      goto __CPROVER_DUMP_L1;

    return_value_wcore_config_attrs_version_ge$1=wcore_config_attrs_version_ge(attrs, 32);
    if(return_value_wcore_config_attrs_version_ge$1 == (_Bool)0)
      goto __CPROVER_DUMP_L1;

    if(attrs->accum_buffer == (_Bool)0)
      goto __CPROVER_DUMP_L1;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "%s", (const void *)"WAFFLE_ACCUM_BUFFER must be false forOpenGL Core profile");
    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (_Bool)1;
  }
}

// check_for_leftover_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 653
static signed int check_for_leftover_values(const struct ListNode * const map_head, const char * const error_message, const unsigned long int number_of_symbol_names)
{
  const struct ListNode *current;
  signed int symbols_with_leftover_values = 0;
  _assert_true((unsigned long int)map_head, "map_head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 658);
  _assert_true((unsigned long int)number_of_symbol_names, "number_of_symbol_names", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 659);
  current = map_head->next;
  for( ; !(current == map_head); current = current->next)
  {
    const struct SymbolMapValue * const value = (struct SymbolMapValue *)current->value;
    const struct ListNode *child_list;
    _assert_true((unsigned long int)value, "value", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 666);
    child_list = &value->symbol_values_list_head;
    signed int return_value_list_empty$1;
    return_value_list_empty$1=list_empty(child_list);
    if(return_value_list_empty$1 == 0)
    {
      if(number_of_symbol_names == 1ul)
      {
        const struct ListNode *child_node;
        print_error(error_message, value->symbol_name);
        child_node = child_list->next;
        for( ; !(child_node == child_list); child_node = child_node->next)
        {
          const struct SourceLocation * const location = (const struct SourceLocation *)child_node->value;
          print_error("%s:%u: note: remaining item was declared here\n", location->file, location->line);
        }
      }

      else
      {
        print_error("%s.", value->symbol_name);
        check_for_leftover_values(child_list, error_message, number_of_symbol_names - (unsigned long int)1);
      }
      symbols_with_leftover_values = symbols_with_leftover_values + 1;
    }

  }
  return symbols_with_leftover_values;
}

// check_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1006
static signed int check_in_range(const unsigned long long int value, const unsigned long long int check_value_data)
{
  struct CheckIntegerRange * const check_integer_range = (struct CheckIntegerRange *)((union ValuePointer *)&check_value_data)->x.pointer;
  _assert_true((unsigned long int)check_integer_range, "check_integer_range", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1011);
  signed int return_value_integer_in_range_display_error$1;
  return_value_integer_in_range_display_error$1=integer_in_range_display_error(value, check_integer_range->minimum, check_integer_range->maximum);
  return return_value_integer_in_range_display_error$1;
}

// check_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 943
static signed int check_in_set(const unsigned long long int value, const unsigned long long int check_value_data)
{
  signed int return_value_value_in_set_display_error$1;
  return_value_value_in_set_display_error$1=value_in_set_display_error(value, (struct CheckIntegerSet *)((union ValuePointer *)&check_value_data)->x.pointer, 0);
  return return_value_value_in_set_display_error$1;
}

// check_keys
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 42
static _Bool check_keys(const signed int *attrib_list)
{
  if(attrib_list == ((const signed int *)NULL))
    return (_Bool)1;

  else
  {
    signed int i = 0;
    for( ; !(attrib_list[(signed long int)i] == 0); i = i + 2)
    {
      signed int key = attrib_list[(signed long int)i];
      if(key == 513 || key == 514 || key == 515 || key == 516 || key == 517 || key == 518 || key == 519 || key == 520 || key == 521 || key == 522 || key == 526 || key == 527 || key == 528 || key == 531 || key == 533 || key == 534)
        goto __CPROVER_DUMP_L5;

      wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "unrecognized attribute 0x%x at attrib_list[%d]", key, i);
      return (_Bool)0;

    __CPROVER_DUMP_L5:
      ;
    }
    return (_Bool)1;
  }
}

// check_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1148
static signed int check_memory(const unsigned long long int value, const unsigned long long int check_value_data)
{
  struct CheckMemoryData * const check = (struct CheckMemoryData *)((union ValuePointer *)&check_value_data)->x.pointer;
  _assert_true((unsigned long int)check, "check", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1152);
  signed int return_value_memory_equal_display_error$1;
  return_value_memory_equal_display_error$1=memory_equal_display_error((const char *)((union ValuePointer *)&value)->x.pointer, (const char *)check->memory, check->size);
  return return_value_memory_equal_display_error$1;
}

// check_not_in_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1018
static signed int check_not_in_range(const unsigned long long int value, const unsigned long long int check_value_data)
{
  struct CheckIntegerRange * const check_integer_range = (struct CheckIntegerRange *)((union ValuePointer *)&check_value_data)->x.pointer;
  _assert_true((unsigned long int)check_integer_range, "check_integer_range", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1023);
  signed int return_value_integer_not_in_range_display_error$1;
  return_value_integer_not_in_range_display_error$1=integer_not_in_range_display_error(value, check_integer_range->minimum, check_integer_range->maximum);
  return return_value_integer_not_in_range_display_error$1;
}

// check_not_in_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 952
static signed int check_not_in_set(const unsigned long long int value, const unsigned long long int check_value_data)
{
  signed int return_value_value_in_set_display_error$1;
  return_value_value_in_set_display_error$1=value_in_set_display_error(value, (struct CheckIntegerSet *)((union ValuePointer *)&check_value_data)->x.pointer, 1);
  return return_value_value_in_set_display_error$1;
}

// check_not_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1192
static signed int check_not_memory(const unsigned long long int value, const unsigned long long int check_value_data)
{
  struct CheckMemoryData * const check = (struct CheckMemoryData *)((union ValuePointer *)&check_value_data)->x.pointer;
  _assert_true((unsigned long int)check, "check", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1196);
  signed int return_value_memory_not_equal_display_error$1;
  return_value_memory_not_equal_display_error$1=memory_not_equal_display_error((const char *)((union ValuePointer *)&value)->x.pointer, (const char *)check->memory, check->size);
  return return_value_memory_not_equal_display_error$1;
}

// check_not_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1127
static signed int check_not_string(const unsigned long long int value, const unsigned long long int check_value_data)
{
  signed int return_value_string_not_equal_display_error$1;
  return_value_string_not_equal_display_error$1=string_not_equal_display_error((char *)((union ValuePointer *)&value)->x.pointer, (char *)((union ValuePointer *)&check_value_data)->x.pointer);
  return return_value_string_not_equal_display_error$1;
}

// check_not_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1088
static signed int check_not_value(const unsigned long long int value, const unsigned long long int check_value_data)
{
  signed int return_value_values_not_equal_display_error$1;
  return_value_values_not_equal_display_error$1=values_not_equal_display_error(value, check_value_data);
  return return_value_values_not_equal_display_error$1;
}

// check_point_allocated_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1491
static const struct ListNode * check_point_allocated_blocks()
{
  struct ListNode *return_value_get_allocated_blocks_list$1;
  return_value_get_allocated_blocks_list$1=get_allocated_blocks_list();
  return return_value_get_allocated_blocks_list$1->prev;
}

// check_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1105
static signed int check_string(const unsigned long long int value, const unsigned long long int check_value_data)
{
  signed int return_value_string_equal_display_error$1;
  return_value_string_equal_display_error$1=string_equal_display_error((char *)((union ValuePointer *)&value)->x.pointer, (char *)((union ValuePointer *)&check_value_data)->x.pointer);
  return return_value_string_equal_display_error$1;
}

// check_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1070
static signed int check_value(const unsigned long long int value, const unsigned long long int check_value_data)
{
  signed int return_value_values_equal_display_error$1;
  return_value_values_equal_display_error$1=values_equal_display_error(value, check_value_data);
  return return_value_values_equal_display_error$1;
}

// choose_real_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 130
static void * choose_real_config(struct wegl_display *dpy, struct wcore_config_attrs *attrs)
{
  struct wegl_platform *plat;
  plat=wegl_platform(dpy->wcore.platform);
  void *config = (void *)0;
  _Bool ok = (_Bool)1;
  if(!(attrs->accum_buffer == (_Bool)0))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "accum buffers do not exist on EGL");
    return (void *)0;
  }

  else
  {
    const signed int renderable_index = 19;
    signed int attrib_list[23l] = { 0x3020, attrs->rgba_size, 0x3024, attrs->red_size, 0x3023, attrs->green_size, 0x3022, attrs->blue_size, 0x3021, attrs->alpha_size, 0x3025, attrs->depth_size, 0x3026, attrs->stencil_size, 0x3032, (signed int)attrs->sample_buffers, 0x3031, attrs->samples, 0x3040, 31415926, 0x3033, 0x0004, 0x3038 };
    switch(attrs->context_api)
    {
      case 523:
      {
        attrib_list[(signed long int)renderable_index] = 0x0008;
        break;
      }
      case 524:
      {
        attrib_list[(signed long int)renderable_index] = 0x0001;
        break;
      }
      case 525:
      {
        attrib_list[(signed long int)renderable_index] = 0x0004;
        break;
      }
      case 532:
      {
        attrib_list[(signed long int)renderable_index] = 0x00000040;
        break;
      }
      default:
      {
        _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c", 189, "waffle_context_api has bad value %#x", attrs->context_api);
        return (void *)0;
      }
    }
    signed int num_configs = 0;
    unsigned int return_value;
    return_value=plat->eglChooseConfig(dpy->egl, attrib_list, &config, 1, &num_configs);
    ok = ((unsigned int)ok & return_value) != 0u;
    if(ok == (_Bool)0)
    {
      wegl_emit_error(plat, "eglChooseConfig");
      return (void *)0;
    }

    else
      if(num_configs == 0)
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "eglChooseConfig found no matching configs");
        return (void *)0;
      }

    return config;
  }
}

// cnd_broadcast
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 149
signed int cnd_broadcast(union anonymous$1 *cond)
{
  if(cond == ((union anonymous$1 *)NULL))
    return 2;

  else
  {
    pthread_cond_broadcast(cond);
    return 0;
  }
}

// cnd_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 150
void cnd_destroy(union anonymous$1 *cond)
{
  pthread_cond_destroy(cond);
}

// cnd_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 151
signed int cnd_init(union anonymous$1 *cond)
{
  if(cond == ((union anonymous$1 *)NULL))
    return 2;

  else
  {
    pthread_cond_init(cond, (const union anonymous$13 *)(void *)0);
    return 0;
  }
}

// cnd_signal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 106
signed int cnd_signal(union anonymous$1 *cond)
{
  if(cond == ((union anonymous$1 *)NULL))
    return 2;

  else
  {
    pthread_cond_signal(cond);
    return 0;
  }
}

// cnd_timedwait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 114
signed int cnd_timedwait(union anonymous$1 *cond, union anonymous *mtx, const struct xtime *xt)
{
  struct timespec abs_time;
  signed int rt;
  if(cond == ((union anonymous$1 *)NULL) || mtx == ((union anonymous *)NULL) || xt == ((const struct xtime *)NULL))
    return 2;

  else
  {
    rt=pthread_cond_timedwait(cond, mtx, &abs_time);
    if(rt == 110)
      return 3;

    else
      return rt == 0 ? 0 : 2;
  }
}

// cnd_wait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 154
signed int cnd_wait(union anonymous$1 *cond, union anonymous *mtx)
{
  if(cond == ((union anonymous$1 *)NULL) || mtx == ((union anonymous *)NULL))
    return 2;

  else
  {
    pthread_cond_wait(cond, mtx);
    return 0;
  }
}

// create_real_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 64
static void * create_real_context(struct wegl_config *config, void *share_ctx)
{
  struct wegl_display *dpy;
  dpy=wegl_display$link1(config->wcore.display);
  struct wegl_platform *plat;
  plat=wegl_platform$link1(dpy->wcore.platform);
  struct wcore_config_attrs *attrs = &config->wcore.attrs;
  _Bool ok = (_Bool)1;
  signed int waffle_context_api = attrs->context_api;
  signed int attrib_list[64l];
  signed int context_flags = 0;
  signed int i = 0;
  if(!(attrs->context_debug == (_Bool)0))
    context_flags = context_flags | 0x00000001;

  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  _Bool return_value_wcore_config_attrs_version_ge$9;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$13;
  switch(waffle_context_api)
  {
    case 523:
    {
      if(!(dpy->KHR_create_context == (_Bool)0))
      {
        tmp_post$1 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$1] = 0x3098;
        tmp_post$2 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$2] = attrs->context_major_version;
        tmp_post$3 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$3] = 0x30FB;
        tmp_post$4 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$4] = attrs->context_minor_version;
      }

      if(!(attrs->context_forward_compatible == (_Bool)0))
        context_flags = context_flags | 0x00000002;

      return_value_wcore_config_attrs_version_ge$9=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge$9 == (_Bool)0))
        switch(attrs->context_profile)
        {
          case 529:
          {
            tmp_post$5 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$5] = 0x30FD;
            tmp_post$6 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$6] = 0x00000001;
            break;
          }
          case 530:
          {
            tmp_post$7 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$7] = 0x30FD;
            tmp_post$8 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$8] = 0x00000002;
            break;
          }
          default:
          {
            _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c", 112, "attrs->context_profile has bad value %#x", attrs->context_profile);
            return (void *)0;
          }
        }

      break;
    }
    case 524:

    case 525:

    case 532:
    {
      tmp_post$10 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post$10] = 0x3098;
      tmp_post$11 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post$11] = attrs->context_major_version;
      if(!(dpy->KHR_create_context == (_Bool)0))
      {
        tmp_post$12 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$12] = 0x30FB;
        tmp_post$13 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$13] = attrs->context_minor_version;
      }

      break;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c", 136, "waffle_context_api has bad value %#x", waffle_context_api);
      return (void *)0;
    }
  }
  signed int tmp_post$14;
  signed int tmp_post$15;
  if(!(context_flags == 0))
  {
    tmp_post$14 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post$14] = 0x30FC;
    tmp_post$15 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post$15] = context_flags;
  }

  signed int tmp_post$16 = i;
  i = i + 1;
  attrib_list[(signed long int)tmp_post$16] = 0x3038;
  ok=bind_api(plat, waffle_context_api);
  if(ok == (_Bool)0)
    return NULL;

  else
  {
    void *ctx;
    ctx=plat->eglCreateContext(dpy->egl, config->egl, share_ctx, attrib_list);
    if(ctx == NULL)
      wegl_emit_error(plat, "eglCreateContext");

    return ctx;
  }
}

// display_allocated_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1498
static signed int display_allocated_blocks(const struct ListNode * const check_point)
{
  const struct ListNode *head;
  head=get_allocated_blocks_list();
  const struct ListNode *node;
  signed int allocated_blocks = 0;
  _assert_true((unsigned long int)check_point, "check_point", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1502);
  _assert_true((unsigned long int)check_point->next, "check_point->next", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1503);
  node = check_point->next;
  for( ; !(node == head); node = node->next)
  {
    const struct MallocBlockInfo * const block_info = (const struct MallocBlockInfo *)node->value;
    _assert_true((unsigned long int)block_info, "block_info", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1508);
    if(allocated_blocks == 0)
      print_error("Blocks allocated...\n");

    print_error("%s:%u: note: block %p allocated here\n", block_info->location.file, block_info->location.line, block_info->block);
    allocated_blocks = allocated_blocks + 1;
  }
  return allocated_blocks;
}

// exception_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1560
static void exception_handler(signed int sig)
{
  print_error("%d\n", sig);
  exit_test(1);
}

// exit_test
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 300
static void exit_test(const signed int quit_application)
{
  if(!(global_running_test == 0))
    longjmp(global_run_test_env, 1);

  else
    if(!(quit_application == 0))
      exit(-1);

}

// expect_memory_setup
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1161
static void expect_memory_setup(const char * const function, const char * const parameter, const char * const file, const signed int line, const void * const memory, const unsigned long int size, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const signed int count)
{
  struct CheckMemoryData *check_data;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct CheckMemoryData) /*56ul*/  + size);
  check_data = (struct CheckMemoryData *)return_value_malloc$1;
  void * const mem = (void *)(check_data + (signed long int)1);
  union ValuePointer check_data_pointer;
  check_data_pointer.value = (unsigned long long int)0;
  check_data_pointer.x.pointer = (void *)check_data;
  _assert_true((unsigned long int)memory, "memory", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1170);
  _assert_true((unsigned long int)size, "size", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1171);
  memcpy(mem, memory, size);
  check_data->memory = mem;
  check_data->size = size;
  _expect_check(function, parameter, file, line, check_function, check_data_pointer.value, &check_data->event, count);
}

// expect_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1031
static void expect_range(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int minimum, const unsigned long long int maximum, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const signed int count)
{
  struct CheckIntegerRange *check_integer_range;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct CheckIntegerRange) /*56ul*/ );
  check_integer_range = (struct CheckIntegerRange *)return_value_malloc$1;
  union ValuePointer check_data;
  check_data.value = (unsigned long long int)0;
  check_data.x.pointer = (void *)check_integer_range;
  check_integer_range->minimum = minimum;
  check_integer_range->maximum = maximum;
  _expect_check(function, parameter, file, line, check_function, check_data.value, &check_integer_range->event, count);
}

// expect_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 962
static void expect_set(const char * const function, const char * const parameter, const char * const file, const signed int line, const unsigned long long int *values, const unsigned long int number_of_values, signed int (* const check_function)(const unsigned long long int, const unsigned long long int), const signed int count)
{
  struct CheckIntegerSet *check_integer_set;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct CheckIntegerSet) /*56ul*/  + sizeof(const unsigned long long int) /*8ul*/  * number_of_values);
  check_integer_set = (struct CheckIntegerSet *)return_value_malloc$1;
  unsigned long long int * const set = (unsigned long long int *)(check_integer_set + (signed long int)1);
  union ValuePointer check_data;
  check_data.value = (unsigned long long int)0;
  check_data.x.pointer = (void *)check_integer_set;
  _assert_true((unsigned long int)values, "values", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 973);
  _assert_true((unsigned long int)number_of_values, "number_of_values", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 974);
  memcpy((void *)set, (const void *)values, number_of_values * sizeof(const unsigned long long int) /*8ul*/ );
  check_integer_set->set = set;
  _expect_check(function, parameter, file, line, check_function, check_data.value, &check_integer_set->event, count);
}

// fail_if_blocks_allocated
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1541
static void fail_if_blocks_allocated(const struct ListNode * const check_point, const char * const test_name)
{
  signed int allocated_blocks;
  allocated_blocks=display_allocated_blocks(check_point);
  if(!(allocated_blocks == 0))
  {
    free_allocated_blocks(check_point);
    print_error("ERROR: %s leaked %d block(s)\n", test_name, allocated_blocks);
    exit_test(1);
  }

}

// fail_if_leftover_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 344
static void fail_if_leftover_values(const char *test_name)
{
  signed int error_occurred = 0;
  (void)test_name;
  remove_always_return_values(&global_function_result_map_head, (const unsigned long int)1);
  signed int return_value_check_for_leftover_values$1;
  return_value_check_for_leftover_values$1=check_for_leftover_values(&global_function_result_map_head, "%s() has remaining non-returned values.\n", (const unsigned long int)1);
  if(!(return_value_check_for_leftover_values$1 == 0))
    error_occurred = 1;

  remove_always_return_values(&global_function_parameter_map_head, (const unsigned long int)2);
  signed int return_value_check_for_leftover_values$2;
  return_value_check_for_leftover_values$2=check_for_leftover_values(&global_function_parameter_map_head, "%s parameter still has values that haven't been checked.\n", (const unsigned long int)2);
  if(!(return_value_check_for_leftover_values$2 == 0))
    error_occurred = 1;

  if(!(error_occurred == 0))
    exit_test(1);

}

// free_allocated_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1524
static void free_allocated_blocks(const struct ListNode * const check_point)
{
  const struct ListNode *head;
  head=get_allocated_blocks_list();
  const struct ListNode *node;
  _assert_true((unsigned long int)check_point, "check_point", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1527);
  node = check_point->next;
  _assert_true((unsigned long int)node, "node", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1530);
  while(!(node == head))
  {
    struct MallocBlockInfo * const block_info = (struct MallocBlockInfo *)node->value;
    node = node->next;
    _test_free((void *)((char *)(void *)(unsigned long int)block_info + (signed long int)sizeof(struct MallocBlockInfo) /*72ul*/  + (signed long int)16), "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 1535);
  }
}

// free_symbol_map_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 499
static void free_symbol_map_value(const void *value, void *cleanup_value_data)
{
  struct SymbolMapValue * const map_value = (struct SymbolMapValue *)value;
  const unsigned long long int children = (unsigned long int)cleanup_value_data;
  _assert_true((unsigned long int)value, "value", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 503);
  list_free(&map_value->symbol_values_list_head, children != 0ull ? free_symbol_map_value : free_value, (void *)((unsigned long int)children - (unsigned long int)1));
  free((void *)map_value);
}

// free_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 491
static void free_value(const void *value, void *cleanup_value_data)
{
  (void)cleanup_value_data;
  _assert_true((unsigned long int)value, "value", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 493);
  free((void *)value);
}

// get_allocated_blocks_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1397
static struct ListNode * get_allocated_blocks_list()
{
  if(global_allocated_blocks.value == NULL)
  {
    list_initialize(&global_allocated_blocks);
    global_allocated_blocks.value = (void *)1;
  }

  return &global_allocated_blocks;
}

// get_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 37
static _Bool get_extensions(struct wegl_display *dpy)
{
  struct wegl_platform *plat;
  plat=wegl_platform$link2(dpy->wcore.platform);
  const char *extensions;
  extensions=plat->eglQueryString(dpy->egl, 0x3055);
  if(extensions == ((const char *)NULL))
  {
    wegl_emit_error(plat, "eglQueryString(EGL_EXTENSIONS");
    return (_Bool)0;
  }

  else
  {
    dpy->KHR_create_context=waffle_is_extension_in_string(extensions, "EGL_KHR_create_context");
    return (_Bool)1;
  }
}

// get_symbol_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 565
static signed int get_symbol_value(struct ListNode * const head, const char * const *symbol_names, const unsigned long int number_of_symbol_names, void **output)
{
  const char *symbol_name;
  struct ListNode *target_node;
  _assert_true((unsigned long int)head, "head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 570);
  _assert_true((unsigned long int)symbol_names, "symbol_names", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 571);
  _assert_true((unsigned long int)number_of_symbol_names, "number_of_symbol_names", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 572);
  _assert_true((unsigned long int)output, "output", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 573);
  symbol_name = symbol_names[(signed long int)0];
  signed int return_value_list_find$2;
  return_value_list_find$2=list_find(head, (const void *)symbol_name, symbol_names_match, &target_node);
  if(!(return_value_list_find$2 == 0))
  {
    struct SymbolMapValue *map_value;
    struct ListNode *child_list;
    signed int return_value = 0;
    _assert_true((unsigned long int)target_node, "target_node", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 580);
    _assert_true((unsigned long int)target_node->value, "target_node->value", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 581);
    map_value = (struct SymbolMapValue *)target_node->value;
    child_list = &map_value->symbol_values_list_head;
    if(number_of_symbol_names == 1ul)
    {
      struct ListNode *value_node = (struct ListNode *)(void *)0;
      return_value=list_first(child_list, &value_node);
      _assert_true((unsigned long int)return_value, "return_value", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 589);
      *output = (void *)value_node->value;
      return_value = value_node->refcount;
      value_node->refcount = value_node->refcount - 1;
      if(value_node->refcount == 0)
        list_remove_free(value_node, (void (*)(const void *, void *))(void *)0, (void *)0);

    }

    else
      return_value=get_symbol_value(child_list, &symbol_names[(signed long int)1], number_of_symbol_names - (unsigned long int)1, output);
    signed int return_value_list_empty$1;
    return_value_list_empty$1=list_empty(child_list);
    if(!(return_value_list_empty$1 == 0))
      list_remove_free(target_node, free_symbol_map_value, (void *)0);

    return return_value;
  }

  else
    print_error("No entries for symbol %s.\n", symbol_name);
  return 0;
}

// get_xcb_screen
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 57
static struct xcb_screen_t * get_xcb_screen(const struct xcb_setup_t *setup, signed int screen)
{
  struct xcb_screen_iterator_t iter;
  iter=xcb_setup_roots_iterator(setup);
  while(!(iter.rem == 0))
  {
    if(screen == 0)
      return iter.data;

    screen = screen - 1;
    xcb_screen_next(&iter);
  }
  return (struct xcb_screen_t *)(void *)0;
}

// glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config(struct wcore_config *wcore_self)
{
  struct glx_config *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct glx_config *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct glx_config *)NULL);
}

// glx_config$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config$link1(struct wcore_config *wcore_self$link1)
{
  struct glx_config *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct glx_config *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct glx_config *)NULL);
}

// glx_config$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config$link2(struct wcore_config *wcore_self$link2)
{
  struct glx_config *tmp_statement_expression$1$link2;
  if(!(wcore_self$link2 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link2 = wcore_self$link2;
    tmp_statement_expression$1$link2 = (struct glx_config *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct glx_config *)NULL);
}

// glx_config_check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 54
static _Bool glx_config_check_context_attrs(struct glx_display *dpy, struct wcore_config_attrs *attrs)
{
  struct glx_platform *plat;
  plat=glx_platform(dpy->wcore.platform);
  _Bool return_value_wcore_config_attrs_version_eq$4;
  _Bool tmp_if_expr$5;
  _Bool return_value_wcore_config_attrs_version_ge$2;
  _Bool tmp_if_expr$3;
  _Bool return_value_wcore_config_attrs_version_ge$1;
  _Bool return_value_linux_platform_dl_can_open$6;
  _Bool return_value_linux_platform_dl_can_open$7;
  _Bool return_value_linux_platform_dl_can_open$8;
  if(!(attrs->context_debug == (_Bool)0))
  {
    if(dpy->ARB_create_context != (_Bool)0)
      goto __CPROVER_DUMP_L1;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context is required in order to request a debug context");
    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    switch(attrs->context_api)
    {
      case 523:
      {
        return_value_wcore_config_attrs_version_eq$4=wcore_config_attrs_version_eq(attrs, 10);
        if(return_value_wcore_config_attrs_version_eq$4 == (_Bool)0)
          tmp_if_expr$5 = !(dpy->ARB_create_context != (_Bool)0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context is required in order to request an OpenGL version not equal to the default value 1.0");
          return (_Bool)0;
        }

        else
        {
          return_value_wcore_config_attrs_version_ge$2=wcore_config_attrs_version_ge(attrs, 32);
          if(!(return_value_wcore_config_attrs_version_ge$2 == (_Bool)0))
            tmp_if_expr$3 = !(dpy->ARB_create_context_profile != (_Bool)0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context_profile is required to create a context with version >= 3.2");
            return (_Bool)0;
          }

          else
            return_value_wcore_config_attrs_version_ge$1=wcore_config_attrs_version_ge(attrs, 32);
        }
        if(!(attrs->context_forward_compatible == (_Bool)0))
        {
          if(dpy->ARB_create_context == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context is required in order to request a forward-compatible context");
            return (_Bool)0;
          }

        }

        return (_Bool)1;
      }
      case 524:
      {
        if(dpy->EXT_create_context_es_profile == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_EXT_create_context_es_profile is required to create an OpenGL ES1 context");
          return (_Bool)0;
        }

        else
        {
          return_value_linux_platform_dl_can_open$6=0;//(plat->linux, 770);
          if(return_value_linux_platform_dl_can_open$6 == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES1 library");
            return (_Bool)0;
          }

        }
        return (_Bool)1;
      }
      case 525:
      {
        if(dpy->EXT_create_context_es_profile == (_Bool)0)
        {
          if(dpy->EXT_create_context_es2_profile == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_EXT_create_context_es_profile or GLX_EXT_create_context_es2_profile is required to create an OpenGL ES2 context");
            return (_Bool)0;
          }

        }

        return_value_linux_platform_dl_can_open$7=0;//(plat->linux, 771);
        if(return_value_linux_platform_dl_can_open$7 == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES2 library");
          return (_Bool)0;
        }

        return (_Bool)1;
      }
      case 532:
      {
        if(dpy->EXT_create_context_es_profile == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_EXT_create_context_es_profile is required to create an OpenGL ES3 context");
          return (_Bool)0;
        }

        return_value_linux_platform_dl_can_open$8=0;//(plat->linux, 772);
        if(return_value_linux_platform_dl_can_open$8 == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES3 library");
          return (_Bool)0;
        }

        return (_Bool)1;
      }
      default:
      {
        _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c", 161, "context_api has bad value %#x", attrs->context_api);
        return (_Bool)0;
      }
    }
  }
}

// glx_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 167
struct wcore_config * glx_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs)
{
  struct glx_config *self;
  struct glx_display *dpy;
  dpy=glx_display(wc_dpy);
  struct glx_platform *plat;
  plat=glx_platform(wc_plat);
  struct __GLXFBConfigRec **configs = (struct __GLXFBConfigRec **)(void *)0;
  signed int num_configs = 0;
  struct anonymous$2 *vi = (struct anonymous$2 *)(void *)0;
  _Bool ok = (_Bool)1;
  _Bool return_value_glx_config_check_context_attrs$1;
  return_value_glx_config_check_context_attrs$1=glx_config_check_context_attrs(dpy, attrs);
  signed int attrib_list[31l];
  signed int return_value_wrapped_glXGetFBConfigAttrib$3;
  if(return_value_glx_config_check_context_attrs$1 == (_Bool)0)
    return (struct wcore_config *)(void *)0;

  else
  {
    void *return_value_wcore_calloc$2;
    return_value_wcore_calloc$2=wcore_calloc(sizeof(struct glx_config) /*96ul*/ );
    self = (struct glx_config *)return_value_wcore_calloc$2;
    if(self == ((struct glx_config *)NULL))
      return (struct wcore_config *)(void *)0;

    else
    {
      ok=wcore_config_init$link1(&self->wcore, wc_dpy, attrs);
      if(!(ok == (_Bool)0))
      {
        attrib_list[0] = 2;
        attrib_list[1] = attrs->rgba_size;
        attrib_list[2] = 8;
        attrib_list[3] = attrs->red_size;
        attrib_list[4] = 9;
        attrib_list[5] = attrs->green_size;
        attrib_list[6] = 10;
        attrib_list[7] = attrs->blue_size;
        attrib_list[8] = 11;
        attrib_list[9] = attrs->alpha_size;
        attrib_list[10] = 12;
        attrib_list[11] = attrs->depth_size;
        attrib_list[12] = 13;
        attrib_list[13] = attrs->stencil_size;
        attrib_list[14] = 0x186a0;
        attrib_list[15] = (signed int)attrs->sample_buffers;
        attrib_list[16] = 0x186a1;
        attrib_list[17] = attrs->samples;
        attrib_list[18] = 5;
        attrib_list[19] = (signed int)attrs->double_buffered;
        attrib_list[20] = 14;
        attrib_list[21] = (signed int)attrs->accum_buffer;
        attrib_list[22] = 15;
        attrib_list[23] = (signed int)attrs->accum_buffer;
        attrib_list[24] = 16;
        attrib_list[25] = (signed int)attrs->accum_buffer;
        attrib_list[26] = 17;
        attrib_list[27] = (signed int)attrs->accum_buffer;
        attrib_list[28] = 0x8010;
        attrib_list[29] = 0x00000001;
        attrib_list[30] = 0;
        configs=wrapped_glXChooseFBConfig(plat, dpy->x11.xlib, dpy->x11.screen, attrib_list, &num_configs);
        if(configs == ((struct __GLXFBConfigRec **)NULL) || num_configs == 0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXChooseFBConfig returned no matching configs");
          goto error;
        }

        self->glx_fbconfig = configs[(signed long int)0];
        return_value_wrapped_glXGetFBConfigAttrib$3=wrapped_glXGetFBConfigAttrib(plat, dpy->x11.xlib, self->glx_fbconfig, 0x8013, &self->glx_fbconfig_id);
        ok = !(return_value_wrapped_glXGetFBConfigAttrib$3 != 0);
        if(ok == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glxGetFBConfigAttrib failed");
          goto error;
        }

        vi=wrapped_glXGetVisualFromFBConfig(plat, dpy->x11.xlib, self->glx_fbconfig);
        if(vi == ((struct anonymous$2 *)NULL))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXGetVisualInfoFromFBConfig failed with GLXFBConfigID=0x%x\n", self->glx_fbconfig_id);
          goto error;
        }

        self->xcb_visual_id = (unsigned int)vi->visualid;
      }

      else
      {

      error:
        ;
        glx_config_destroy(&self->wcore);
        self = (struct glx_config *)(void *)0;
      }

    cleanup:
      ;
      if(!(configs == ((struct __GLXFBConfigRec **)NULL)))
        XFree((void *)configs);

      if(!(vi == ((struct anonymous$2 *)NULL)))
        XFree((void *)vi);

      return &self->wcore;
    }
  }
}

// glx_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 40
_Bool glx_config_destroy(struct wcore_config *wc_self)
{
  _Bool ok = (_Bool)1;
  if(wc_self == ((struct wcore_config *)NULL))
    return ok;

  else
  {
    _Bool return_value_wcore_config_teardown$1;
    return_value_wcore_config_teardown$1=wcore_config_teardown$link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_config_teardown$1) != 0;
    struct glx_config *return_value_glx_config$2;
    return_value_glx_config$2=glx_config(wc_self);
    free((void *)return_value_glx_config$2);
    return ok;
  }
}

// glx_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 275
union waffle_native_config * glx_config_get_native(struct wcore_config *wc_self)
{
  struct glx_config *self;
  self=glx_config(wc_self);
  struct glx_display *dpy;
  dpy=glx_display(wc_self->display);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_glx_config) /*16ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc$1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->glx = (struct waffle_glx_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    n_config->glx->xlib_display = dpy->x11.xlib;
    n_config->glx->glx_fbconfig = self->glx_fbconfig;
    return n_config;
  }
}

// glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context(struct wcore_context *wcore_self)
{
  struct glx_context *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct glx_context *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct glx_context *)NULL);
}

// glx_context$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context$link1(struct wcore_context *wcore_self$link1)
{
  struct glx_context *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct glx_context *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct glx_context *)NULL);
}

// glx_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 203
struct wcore_context * glx_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx)
{
  struct glx_context *self;
  struct glx_config *config;
  config=glx_config$link1(wc_config);
  struct glx_context *share_ctx;
  share_ctx=glx_context(wc_share_ctx);
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct glx_context) /*24ul*/ );
  self = (struct glx_context *)return_value_wcore_calloc$1;
  if(self == ((struct glx_context *)NULL))
    return (struct wcore_context *)(void *)0;

  else
  {
    ok=wcore_context_init$link1(&self->wcore, wc_config);
    if(!(ok == (_Bool)0))
    {
      self->glx=glx_context_create_native(config, share_ctx);
      if(self->glx == ((struct __GLXcontextRec *)NULL))
        goto error;

      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_context_destroy(&self->wcore);
      return (struct wcore_context *)(void *)0;
    }
  }
}

// glx_context_create_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 156
static struct __GLXcontextRec * glx_context_create_native(struct glx_config *config, struct glx_context *share_ctx)
{
  struct __GLXcontextRec *ctx;
  struct __GLXcontextRec *real_share_ctx;
  struct __GLXcontextRec *tmp_if_expr$1;
  if(!(share_ctx == ((struct glx_context *)NULL)))
    tmp_if_expr$1 = share_ctx->glx;

  else
    tmp_if_expr$1 = (struct __GLXcontextRec *)(void *)0;
  real_share_ctx = tmp_if_expr$1;
  struct glx_display *dpy;
  dpy=glx_display$link1(config->wcore.display);
  struct glx_platform *platform;
  platform=glx_platform$link1(dpy->wcore.platform);
  if(!(dpy->ARB_create_context == (_Bool)0))
  {
    _Bool ok;
    signed int attrib_list[64l];
    ok=glx_context_fill_attrib_list(config, attrib_list);
    if(ok == (_Bool)0)
      return (struct __GLXcontextRec *)(void *)0;

    ctx=wrapped_glXCreateContextAttribsARB(platform, dpy->x11.xlib, config->glx_fbconfig, real_share_ctx, 1, attrib_list);
    if(ctx == ((struct __GLXcontextRec *)NULL))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXCreateContextAttribsARB failed");
      return (struct __GLXcontextRec *)(void *)0;
    }

  }

  else
  {
    ctx=wrapped_glXCreateNewContext(platform, dpy->x11.xlib, config->glx_fbconfig, 0x8014, real_share_ctx, 1);
    if(ctx == ((struct __GLXcontextRec *)NULL))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXCreateContext failed");
      return (struct __GLXcontextRec *)(void *)0;
    }

  }
  return ctx;
}

// glx_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 44
_Bool glx_context_destroy(struct wcore_context *wc_self)
{
  struct glx_context *self;
  struct glx_display *dpy;
  struct glx_platform *platform;
  _Bool ok = (_Bool)1;
  if(wc_self == ((struct wcore_context *)NULL))
    return ok;

  else
  {
    self=glx_context(wc_self);
    dpy=glx_display$link1(wc_self->display);
    platform=glx_platform$link1(wc_self->display->platform);
    if(!(self->glx == ((struct __GLXcontextRec *)NULL)))
      wrapped_glXDestroyContext(platform, dpy->x11.xlib, self->glx);

    _Bool return_value_wcore_context_teardown$1;
    return_value_wcore_context_teardown$1=wcore_context_teardown$link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_context_teardown$1) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_context_fill_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 71
static _Bool glx_context_fill_attrib_list(struct glx_config *config, signed int *attrib_list)
{
  struct wcore_config_attrs *attrs = &config->wcore.attrs;
  signed int i = 0;
  signed int context_flags = 0;
  _Bool return_value_wcore_config_attrs_version_eq$5;
  return_value_wcore_config_attrs_version_eq$5=wcore_config_attrs_version_eq(attrs, 10);
  _Bool tmp_if_expr$6;
  if(!(return_value_wcore_config_attrs_version_eq$5 == (_Bool)0))
    tmp_if_expr$6 = attrs->context_api == 523 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$6 = (_Bool)0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  if(!tmp_if_expr$6)
  {
    tmp_post$1 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post$1] = 0x2091;
    tmp_post$2 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post$2] = attrs->context_major_version;
    tmp_post$3 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post$3] = 0x2092;
    tmp_post$4 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post$4] = attrs->context_minor_version;
  }

  _Bool return_value_wcore_config_attrs_version_ge$11;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$12;
  signed int tmp_post$13;
  signed int tmp_post$14;
  signed int tmp_post$15;
  signed int tmp_post$16;
  switch(attrs->context_api)
  {
    case 523:
    {
      return_value_wcore_config_attrs_version_ge$11=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge$11 == (_Bool)0))
        switch(attrs->context_profile)
        {
          case 529:
          {
            tmp_post$7 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$7] = 0x9126;
            tmp_post$8 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$8] = 0x00000001;
            break;
          }
          case 530:
          {
            tmp_post$9 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$9] = 0x9126;
            tmp_post$10 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post$10] = 0x00000002;
          }
        }

      if(!(attrs->context_forward_compatible == (_Bool)0))
        context_flags = context_flags | 0x00000002;

      goto __CPROVER_DUMP_L10;
    }
    case 524:

    case 525:

    case 532:
    {
      tmp_post$12 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post$12] = 0x9126;
      tmp_post$13 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post$13] = 0x00000004;
    }
    default:
    {

    __CPROVER_DUMP_L10:
      ;
      if(!(attrs->context_debug == (_Bool)0))
        context_flags = context_flags | 0x00000001;

      if(!(context_flags == 0))
      {
        tmp_post$14 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$14] = 0x2094;
        tmp_post$15 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post$15] = context_flags;
      }

      tmp_post$16 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post$16] = 0;
      return (_Bool)1;
    }
  }
}

// glx_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 232
union waffle_native_context * glx_context_get_native(struct wcore_context *wc_self)
{
  struct glx_context *self;
  self=glx_context(wc_self);
  struct glx_display *dpy;
  dpy=glx_display$link1(wc_self->display);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_glx_context) /*16ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc$1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->glx = (struct waffle_glx_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    n_ctx->glx->xlib_display = dpy->x11.xlib;
    n_ctx->glx->glx_context = self->glx;
    return n_ctx;
  }
}

// glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display(struct wcore_display *wcore_self)
{
  struct glx_display *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct glx_display *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link1(struct wcore_display *wcore_self$link1)
{
  struct glx_display *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct glx_display *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link2(struct wcore_display *wcore_self$link2)
{
  struct glx_display *tmp_statement_expression$1$link2;
  if(!(wcore_self$link2 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link2 = wcore_self$link2;
    tmp_statement_expression$1$link2 = (struct glx_display *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link3(struct wcore_display *wcore_self$link3)
{
  struct glx_display *tmp_statement_expression$1$link3;
  if(!(wcore_self$link3 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link3 = wcore_self$link3;
    tmp_statement_expression$1$link3 = (struct glx_display *)((void *)__mptr$link3 - (signed long int)0ul);
    return tmp_statement_expression$1$link3;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display$link4(struct wcore_display *wcore_self$link4)
{
  struct glx_display *tmp_statement_expression$1$link4;
  if(!(wcore_self$link4 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link4 = wcore_self$link4;
    tmp_statement_expression$1$link4 = (struct glx_display *)((void *)__mptr$link4 - (signed long int)0ul);
    return tmp_statement_expression$1$link4;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 86
struct wcore_display * glx_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct glx_display *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct glx_display) /*48ul*/ );
  self = (struct glx_display *)return_value_wcore_calloc$1;
  if(self == ((struct glx_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    ok=wcore_display_init(&self->wcore, wc_plat);
    if(!(ok == (_Bool)0))
    {
      ok=x11_display_init(&self->x11, name);
      if(ok == (_Bool)0)
        goto error;

      ok=glx_display_set_extensions(self);
      if(ok == (_Bool)0)
        goto error;

      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_display_destroy(&self->wcore);
      return (struct wcore_display *)(void *)0;
    }
  }
}

// glx_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 37
_Bool glx_display_destroy(struct wcore_display *wc_self)
{
  struct glx_display *self;
  self=glx_display$link2(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct glx_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_x11_display_teardown$1;
    return_value_x11_display_teardown$1=x11_display_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_display_teardown$1) != 0;
    _Bool return_value_wcore_display_teardown$2;
    return_value_wcore_display_teardown$2=wcore_display_teardown(&self->wcore);
    ok = ((signed int)ok & (signed int)return_value_wcore_display_teardown$2) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 145
union waffle_native_display * glx_display_get_native(struct wcore_display *wc_self)
{
  struct glx_display *self;
  self=glx_display$link2(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_glx_display) /*8ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc$1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->glx = (struct waffle_glx_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    n_dpy->glx->xlib_display = self->x11.xlib;
    return n_dpy;
  }
}

// glx_display_set_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 52
static _Bool glx_display_set_extensions(struct glx_display *self)
{
  struct glx_platform *platform;
  platform=glx_platform$link2(self->wcore.platform);
  const char *s;
  s=wrapped_glXQueryExtensionsString(platform, self->x11.xlib, self->x11.screen);
  if(s == ((const char *)NULL))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXQueryExtensionsString failed");
    return (_Bool)0;
  }

  else
  {
    self->ARB_create_context=waffle_is_extension_in_string(s, "GLX_ARB_create_context");
    self->ARB_create_context_profile=waffle_is_extension_in_string(s, "GLX_ARB_create_context_profile");
    self->EXT_create_context_es_profile=waffle_is_extension_in_string(s, "GLX_EXT_create_context_es_profile");
    if(!(self->EXT_create_context_es_profile == (_Bool)0))
      self->EXT_create_context_es2_profile = (_Bool)1;

    else
      self->EXT_create_context_es2_profile=waffle_is_extension_in_string(s, "GLX_EXT_create_context_es2_profile");
    return (_Bool)1;
  }
}

// glx_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 116
_Bool glx_display_supports_context_api(struct wcore_display *wc_self, signed int context_api)
{
  struct glx_display *self;
  self=glx_display$link2(wc_self);
  struct glx_platform *plat;
  plat=glx_platform$link2(wc_self->platform);
  _Bool tmp_if_expr$2;
  _Bool return_value_linux_platform_dl_can_open$1;
  _Bool tmp_if_expr$4;
  _Bool return_value_linux_platform_dl_can_open$3;
  _Bool tmp_if_expr$6;
  _Bool return_value_linux_platform_dl_can_open$5;
  switch(context_api)
  {
    case 523:
      return (_Bool)1;
    case 524:
    {
      if(!(self->EXT_create_context_es_profile == (_Bool)0))
      {
        return_value_linux_platform_dl_can_open$1=0;//(plat->linux, 770);
        tmp_if_expr$2 = return_value_linux_platform_dl_can_open$1 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      return tmp_if_expr$2;
    }
    case 525:
    {
      if(!(self->EXT_create_context_es2_profile == (_Bool)0))
      {
        return_value_linux_platform_dl_can_open$3=0;//(plat->linux, 771);
        tmp_if_expr$4 = return_value_linux_platform_dl_can_open$3 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      return tmp_if_expr$4;
    }
    case 532:
    {
      if(!(self->EXT_create_context_es_profile == (_Bool)0))
      {
        return_value_linux_platform_dl_can_open$5=0;//(plat->linux, 772);
        tmp_if_expr$6 = return_value_linux_platform_dl_can_open$5 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      return tmp_if_expr$6;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c", 139, "waffle_context_api has bad value %#x", context_api);
      return (_Bool)0;
    }
  }
}

// glx_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform(struct wcore_platform *wcore_self)
{
  struct glx_platform *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct glx_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link1(struct wcore_platform *wcore_self$link1)
{
  struct glx_platform *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct glx_platform *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link2(struct wcore_platform *wcore_self$link2)
{
  struct glx_platform *tmp_statement_expression$1$link2;
  if(!(wcore_self$link2 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link2 = wcore_self$link2;
    tmp_statement_expression$1$link2 = (struct glx_platform *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link3(struct wcore_platform *wcore_self$link3)
{
  struct glx_platform *tmp_statement_expression$1$link3;
  if(!(wcore_self$link3 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link3 = wcore_self$link3;
    tmp_statement_expression$1$link3 = (struct glx_platform *)((void *)__mptr$link3 - (signed long int)0ul);
    return tmp_statement_expression$1$link3;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform$link4(struct wcore_platform *wcore_self$link4)
{
  struct glx_platform *tmp_statement_expression$1$link4;
  if(!(wcore_self$link4 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link4 = wcore_self$link4;
    tmp_statement_expression$1$link4 = (struct glx_platform *)((void *)__mptr$link4 - (signed long int)0ul);
    return tmp_statement_expression$1$link4;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 33
struct wcore_platform * glx_platform_create(void)
{
  struct glx_platform *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct glx_platform) /*104ul*/ );
  self = (struct glx_platform *)return_value_wcore_calloc$1;
  void *return_value_dlsym$3;
  void *return_value_dlsym$5;
  void *return_value_dlsym$7;
  void *return_value_dlsym$9;
  void *return_value_dlsym$11;
  void *return_value_dlsym$13;
  void *return_value_dlsym$15;
  void *return_value_dlsym$17;
  void *return_value_dlsym$19;
  void *return_value;
  if(self == ((struct glx_platform *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wcore_platform_init$link1(&self->wcore);
    if(!(ok == (_Bool)0))
    {
      self->glxHandle=dlopen(libGL_filename, 0x00001 | 0);
      if(self->glxHandle == NULL)
      {
        char *return_value_dlerror$2;
        return_value_dlerror$2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlopen(\"%s\") failed: %s", libGL_filename, return_value_dlerror$2);
        goto error;
      }

      return_value_dlsym$3=dlsym(self->glxHandle, "glXCreateNewContext");
      self->glXCreateNewContext = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int))return_value_dlsym$3;
      if(self->glXCreateNewContext == ((struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int))NULL))
      {
        char *return_value_dlerror$4;
        return_value_dlerror$4=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXCreateNewContext\") failed: %s", libGL_filename, return_value_dlerror$4);
        goto error;
      }

      return_value_dlsym$5=dlsym(self->glxHandle, "glXDestroyContext");
      self->glXDestroyContext = (void (*)(struct _XDisplay *, struct __GLXcontextRec *))return_value_dlsym$5;
      if(self->glXDestroyContext == ((void (*)(struct _XDisplay *, struct __GLXcontextRec *))NULL))
      {
        char *return_value_dlerror$6;
        return_value_dlerror$6=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXDestroyContext\") failed: %s", libGL_filename, return_value_dlerror$6);
        goto error;
      }

      return_value_dlsym$7=dlsym(self->glxHandle, "glXMakeCurrent");
      self->glXMakeCurrent = (signed int (*)(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *))return_value_dlsym$7;
      if(self->glXMakeCurrent == ((signed int (*)(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *))NULL))
      {
        char *return_value_dlerror$8;
        return_value_dlerror$8=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXMakeCurrent\") failed: %s", libGL_filename, return_value_dlerror$8);
        goto error;
      }

      return_value_dlsym$9=dlsym(self->glxHandle, "glXQueryExtensionsString");
      self->glXQueryExtensionsString = (const char * (*)(struct _XDisplay *, signed int))return_value_dlsym$9;
      if(self->glXQueryExtensionsString == ((const char * (*)(struct _XDisplay *, signed int))NULL))
      {
        char *return_value_dlerror$10;
        return_value_dlerror$10=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXQueryExtensionsString\") failed: %s", libGL_filename, return_value_dlerror$10);
        goto error;
      }

      return_value_dlsym$11=dlsym(self->glxHandle, "glXGetProcAddress");
      self->glXGetProcAddress = (void * (*)(const unsigned char *))return_value_dlsym$11;
      if(self->glXGetProcAddress == ((void * (*)(const unsigned char *))NULL))
      {
        char *return_value_dlerror$12;
        return_value_dlerror$12=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXGetProcAddress\") failed: %s", libGL_filename, return_value_dlerror$12);
        goto error;
      }

      return_value_dlsym$13=dlsym(self->glxHandle, "glXGetVisualFromFBConfig");
      self->glXGetVisualFromFBConfig = (struct anonymous$2 * (*)(struct _XDisplay *, struct __GLXFBConfigRec *))return_value_dlsym$13;
      if(self->glXGetVisualFromFBConfig == ((struct anonymous$2 * (*)(struct _XDisplay *, struct __GLXFBConfigRec *))NULL))
      {
        char *return_value_dlerror$14;
        return_value_dlerror$14=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXGetVisualFromFBConfig\") failed: %s", libGL_filename, return_value_dlerror$14);
        goto error;
      }

      return_value_dlsym$15=dlsym(self->glxHandle, "glXGetFBConfigAttrib");
      self->glXGetFBConfigAttrib = (signed int (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *))return_value_dlsym$15;
      if(self->glXGetFBConfigAttrib == ((signed int (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *))NULL))
      {
        char *return_value_dlerror$16;
        return_value_dlerror$16=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXGetFBConfigAttrib\") failed: %s", libGL_filename, return_value_dlerror$16);
        goto error;
      }

      return_value_dlsym$17=dlsym(self->glxHandle, "glXChooseFBConfig");
      self->glXChooseFBConfig = (struct __GLXFBConfigRec ** (*)(struct _XDisplay *, signed int, const signed int *, signed int *))return_value_dlsym$17;
      if(self->glXChooseFBConfig == ((struct __GLXFBConfigRec ** (*)(struct _XDisplay *, signed int, const signed int *, signed int *))NULL))
      {
        char *return_value_dlerror$18;
        return_value_dlerror$18=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXChooseFBConfig\") failed: %s", libGL_filename, return_value_dlerror$18);
        goto error;
      }

      return_value_dlsym$19=dlsym(self->glxHandle, "glXSwapBuffers");
      self->glXSwapBuffers = (void (*)(struct _XDisplay *, unsigned long int))return_value_dlsym$19;
      if(self->glXSwapBuffers == ((void (*)(struct _XDisplay *, unsigned long int))NULL))
      {
        char *return_value_dlerror$20;
        return_value_dlerror$20=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXSwapBuffers\") failed: %s", libGL_filename, return_value_dlerror$20);
        goto error;
      }

      /*self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;*/

      return_value=self->glXGetProcAddress((const unsigned char *)"glXCreateContextAttribsARB");
      self->glXCreateContextAttribsARB = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *))return_value;
      self->wcore.vtbl = &glx_platform_vtbl;
      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_platform_destroy(&self->wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// glx_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 45
static _Bool glx_platform_destroy(struct wcore_platform *wc_self)
{
  struct glx_platform *self;
  self=glx_platform$link3(wc_self);
  _Bool ok = (_Bool)1;
  signed int error = 0;
  _Bool return_value_linux_platform_destroy$1;
  if(self == ((struct glx_platform *)NULL))
    return (_Bool)1;

  else
  {
    /*if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy$1=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy$1) != 0;
    }*/

    if(!(self->glxHandle == NULL))
    {
      error=dlclose(self->glxHandle);
      if(!(error == 0))
      {
        ok = ((signed int)ok & 0) != 0;
        char *return_value_dlerror$2;
        return_value_dlerror$2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(\"%s\") failed: %s", libGL_filename, return_value_dlerror$2);
      }

    }

    _Bool return_value_wcore_platform_teardown$3;
    return_value_wcore_platform_teardown$3=wcore_platform_teardown$link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_platform_teardown$3) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 160
static _Bool glx_platform_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct glx_platform *return_value_glx_platform$1;
  return_value_glx_platform$1=glx_platform$link3(wc_self);
  _Bool return_value_linux_platform_dl_can_open$2;
  return_value_linux_platform_dl_can_open$2=0;//(return_value_glx_platform$1->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open$2;
}

// glx_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 168
static void * glx_platform_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct glx_platform *return_value_glx_platform$1;
  return_value_glx_platform$1=glx_platform$link3(wc_self);
  void *return_value_linux_platform_dl_sym$2;
  return_value_linux_platform_dl_sym$2=NULL;//(return_value_glx_platform$1->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym$2;
}

// glx_platform_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 152
static void * glx_platform_get_proc_address(struct wcore_platform *wc_self, const char *name)
{
  struct glx_platform *self;
  self=glx_platform$link3(wc_self);
  void *return_value;
  return_value=self->glXGetProcAddress((const unsigned char *)name);
  return return_value;
}

// glx_platform_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 132
static _Bool glx_platform_make_current(struct wcore_platform *wc_self, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx)
{
  struct glx_platform *self;
  self=glx_platform$link3(wc_self);
  struct _XDisplay *dpy;
  struct glx_display *return_value_glx_display$1;
  return_value_glx_display$1=glx_display$link3(wc_dpy);
  dpy = return_value_glx_display$1->x11.xlib;
  unsigned long int win;
  unsigned int tmp_if_expr$3;
  struct glx_window *return_value_glx_window$2;
  if(!(wc_window == ((struct wcore_window *)NULL)))
  {
    return_value_glx_window$2=glx_window(wc_window);
    tmp_if_expr$3 = return_value_glx_window$2->x11.xcb;
  }

  else
    tmp_if_expr$3 = (unsigned int)0;
  win = (unsigned long int)tmp_if_expr$3;
  struct __GLXcontextRec *ctx;
  struct __GLXcontextRec *tmp_if_expr$5;
  struct glx_context *return_value_glx_context$4;
  if(!(wc_ctx == ((struct wcore_context *)NULL)))
  {
    return_value_glx_context$4=glx_context$link1(wc_ctx);
    tmp_if_expr$5 = return_value_glx_context$4->glx;
  }

  else
    tmp_if_expr$5 = (struct __GLXcontextRec *)(void *)0;
  ctx = tmp_if_expr$5;
  _Bool ok;
  signed int return_value_wrapped_glXMakeCurrent$6;
  return_value_wrapped_glXMakeCurrent$6=wrapped_glXMakeCurrent(self, dpy, win, ctx);
  ok = (_Bool)return_value_wrapped_glXMakeCurrent$6;
  if(ok == (_Bool)0)
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXMakeCurrent failed");

  return ok;
}

// glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window(struct wcore_window *wcore_self)
{
  struct glx_window *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct glx_window *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct glx_window *)NULL);
}

// glx_window$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window$link1(struct wcore_window *wcore_self$link1)
{
  struct glx_window *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct glx_window *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct glx_window *)NULL);
}

// glx_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 47
struct wcore_window * glx_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct glx_window *self;
  struct glx_display *dpy;
  dpy=glx_display$link4(wc_config->display);
  struct glx_config *config;
  config=glx_config$link2(wc_config);
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct glx_window) /*32ul*/ );
  self = (struct glx_window *)return_value_wcore_calloc$1;
  if(self == ((struct glx_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    ok=wcore_window_init$link1(&self->wcore, wc_config);
    if(!(ok == (_Bool)0))
    {
      ok=x11_window_init(&self->x11, &dpy->x11, config->xcb_visual_id, width, height);
      if(ok == (_Bool)0)
        goto error;

      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_window_destroy(&self->wcore);
      return (struct wcore_window *)(void *)0;
    }
  }
}

// glx_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 53
_Bool glx_window_destroy(struct wcore_window *wc_self)
{
  struct glx_window *self;
  self=glx_window$link1(wc_self);
  _Bool ok = (_Bool)1;
  if(wc_self == ((struct wcore_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_x11_window_teardown$1;
    return_value_x11_window_teardown$1=x11_window_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_window_teardown$1) != 0;
    _Bool return_value_wcore_window_teardown$2;
    return_value_wcore_window_teardown$2=wcore_window_teardown$link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_window_teardown$2) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 66
union waffle_native_window * glx_window_get_native(struct wcore_window *wc_self)
{
  struct glx_window *self;
  self=glx_window$link1(wc_self);
  struct glx_display *dpy;
  dpy=glx_display$link4(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_glx_window) /*16ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc$1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->glx = (struct waffle_glx_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    n_window->glx->xlib_display = dpy->x11.xlib;
    n_window->glx->xlib_window = (unsigned long int)self->x11.xcb;
    return n_window;
  }
}

// glx_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 59
_Bool glx_window_resize(struct wcore_window *wc_self, signed int width, signed int height)
{
  struct glx_window *return_value_glx_window$1;
  return_value_glx_window$1=glx_window$link1(wc_self);
  _Bool return_value_x11_window_resize$2;
  return_value_x11_window_resize$2=x11_window_resize(&return_value_glx_window$1->x11, width, height);
  return return_value_x11_window_resize$2;
}

// glx_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 56
_Bool glx_window_show(struct wcore_window *wc_self)
{
  struct glx_window *return_value_glx_window$1;
  return_value_glx_window$1=glx_window$link1(wc_self);
  _Bool return_value_x11_window_show$2;
  return_value_x11_window_show$2=x11_window_show(&return_value_glx_window$1->x11);
  return return_value_x11_window_show$2;
}

// glx_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 63
_Bool glx_window_swap_buffers(struct wcore_window *wc_self)
{
  struct glx_window *self;
  self=glx_window$link1(wc_self);
  struct glx_display *dpy;
  dpy=glx_display$link4(wc_self->display);
  struct glx_platform *plat;
  plat=glx_platform$link4(wc_self->display->platform);
  wrapped_glXSwapBuffers(plat, dpy->x11.xlib, (unsigned long int)self->x11.xcb);
  return (_Bool)1;
}

// impl_thrd_routine
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 65
static void * impl_thrd_routine(void *p)
{
  struct impl_thrd_param pack = *((struct impl_thrd_param *)p);
  free(p);
  signed int return_value;
  return_value=pack.func(pack.arg);
  return (void *)(signed long int)return_value;
}

// initialize_source_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 310
static void initialize_source_location(struct SourceLocation * const location)
{
  _assert_true((unsigned long int)location, "location", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 311);
  location->file = (const char *)(void *)0;
  location->line = 0;
}

// initialize_testing
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 335
static void initialize_testing(const char *test_name)
{
  (void)test_name;
  list_initialize(&global_function_result_map_head);
  initialize_source_location(&global_last_mock_value_location);
  list_initialize(&global_function_parameter_map_head);
  initialize_source_location(&global_last_parameter_location);
}

// integer_in_range_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 832
static signed int integer_in_range_display_error(const unsigned long long int value, const unsigned long long int range_min, const unsigned long long int range_max)
{
  if(range_max >= value && value >= range_min)
    return 1;

  else
  {
    print_error("%llu is not within the range %llu-%llu\n", value, range_min, range_max);
    return 0;
  }
}

// integer_not_in_range_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 849
static signed int integer_not_in_range_display_error(const unsigned long long int value, const unsigned long long int range_min, const unsigned long long int range_max)
{
  if(!(range_max >= value) || !(value >= range_min))
    return 1;

  else
  {
    print_error("%llu is within the range %llu-%llu\n", value, range_min, range_max);
    return 0;
  }
}

// linux_dl_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 103
_Bool linux_dl_close(struct linux_dl *self)
{
  signed int error = 0;
  if(self == ((struct linux_dl *)NULL))
    return (_Bool)1;

  else
  {
    if(!(self->dl == NULL))
    {
      error=dlclose(self->dl);
      if(!(error == 0))
      {
        char *return_value_dlerror$1;
        return_value_dlerror$1=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(libname=\"%s\") failed: %s", self->name, return_value_dlerror$1);
      }

    }

    free((void *)self);
    return error == 0;
  }
}

// linux_dl_get_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 47
static const char * linux_dl_get_name(signed int waffle_dl)
{
  switch(waffle_dl)
  {
    case 769:
      return "libGL.so.1";
    case 770:
      return "libGLESv1_CM.so.1";
    case 771:

    case 772:
      return "libGLESv2.so.2";
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c", 72, "waffle_dl has bad value %#x", waffle_dl);
      return (const char *)(void *)0;
    }
  }
}

// linux_dl_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 78
struct linux_dl * linux_dl_open(signed int waffle_dl)
{
  struct linux_dl *self;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct linux_dl) /*16ul*/ );
  self = (struct linux_dl *)return_value_wcore_calloc$1;
  if(self == ((struct linux_dl *)NULL))
    return (struct linux_dl *)(void *)0;

  else
  {
    self->name=linux_dl_get_name(waffle_dl);
    if(!(self->name == ((const char *)NULL)))
    {
      self->dl=dlopen(self->name, 0x00001);
      if(self->dl == NULL)
      {
        char *return_value_dlerror$2;
        return_value_dlerror$2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlopen(\"%s\") failed: %s", self->name, return_value_dlerror$2);
        goto error;
      }

      return self;
    }

    else
    {

    error:
      ;
      free((void *)self);
      return (struct linux_dl *)(void *)0;
    }
  }
}

// linux_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 124
void * linux_dl_sym(struct linux_dl *self, const char *symbol)
{
  dlerror();
  void *sym;
  sym=dlsym(self->dl, symbol);
  const char *error;
  error=dlerror();
  if(!(error == ((const char *)NULL)))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlsym(libname=\"%s\", \"%s\") failed: %s", self->name, symbol, error);
    return (void *)0;
  }

  else
    return sym;
}

// linux_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 34
struct linux_platform * linux_platform_create(void)
{
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct linux_platform) /*24ul*/ );
  return (struct linux_platform *)return_value_wcore_calloc$1;
}

// linux_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 37
_Bool linux_platform_destroy(struct linux_platform *self)
{
  _Bool ok = (_Bool)1;
  if(self == ((struct linux_platform *)NULL))
    return (_Bool)1;

  else
  {
    _Bool return_value_linux_dl_close$1;
    return_value_linux_dl_close$1=linux_dl_close(self->libgl);
    ok = ((signed int)ok & (signed int)return_value_linux_dl_close$1) != 0;
    _Bool return_value_linux_dl_close$2;
    return_value_linux_dl_close$2=linux_dl_close(self->libgles1);
    ok = ((signed int)ok & (signed int)return_value_linux_dl_close$2) != 0;
    _Bool return_value_linux_dl_close$3;
    return_value_linux_dl_close$3=linux_dl_close(self->libgles2);
    ok = ((signed int)ok & (signed int)return_value_linux_dl_close$3) != 0;
    free((void *)self);
    return ok;
  }
}

// linux_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 41
_Bool linux_platform_dl_can_open(struct linux_platform *self, signed int waffle_dl)
{
  struct linux_dl *dl = (struct linux_dl *)(void *)0;
  do
  {
    _wcore_error_disable();
    dl=linux_platform_get_dl(self, waffle_dl);
    _wcore_error_enable();
  }
  while((_Bool)0);
  return dl != (struct linux_dl *)(void *)0;
}

// linux_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 46
void * linux_platform_dl_sym(struct linux_platform *self, signed int waffle_dl, const char *name)
{
  struct linux_dl *dl;
  dl=linux_platform_get_dl(self, waffle_dl);
  if(dl == ((struct linux_dl *)NULL))
    return (void *)0;

  else
  {
    void *return_value_linux_dl_sym$1;
    return_value_linux_dl_sym$1=linux_dl_sym(dl, name);
    return return_value_linux_dl_sym$1;
  }
}

// linux_platform_get_dl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.c line 64
static struct linux_dl * linux_platform_get_dl(struct linux_platform *self, signed int waffle_dl)
{
  struct linux_dl **dl;
  switch(waffle_dl)
  {
    case 769:
    {
      dl = &self->libgl;
      break;
    }
    case 770:
    {
      dl = &self->libgles1;
      break;
    }
    case 771:
    {
      dl = &self->libgles2;
      break;
    }
    case 772:
    {
      dl = &self->libgles2;
      break;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.c", 76, "waffle_dl has bad value %#x", waffle_dl);
      return (struct linux_dl *)(void *)0;
    }
  }
  if(*dl == ((struct linux_dl *)NULL))
    *dl=linux_dl_open(waffle_dl);

  return *dl;
}

// list_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 402
static struct ListNode * list_add(struct ListNode * const head, struct ListNode *new_node)
{
  _assert_true((unsigned long int)head, "head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 403);
  _assert_true((unsigned long int)new_node, "new_node", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 404);
  new_node->next = head;
  new_node->prev = head->prev;
  head->prev->next = new_node;
  head->prev = new_node;
  return new_node;
}

// list_add_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 390
static struct ListNode * list_add_value(struct ListNode * const head, const void *value, const signed int refcount)
{
  struct ListNode *new_node;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ListNode) /*32ul*/ );
  new_node = (struct ListNode *)return_value_malloc$1;
  _assert_true((unsigned long int)head, "head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 393);
  _assert_true((unsigned long int)value, "value", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 394);
  new_node->value = value;
  new_node->refcount = refcount;
  struct ListNode *return_value_list_add$2;
  return_value_list_add$2=list_add(head, new_node);
  return return_value_list_add$2;
}

// list_empty
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 454
static signed int list_empty(const struct ListNode * const head)
{
  _assert_true((unsigned long int)head, "head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 455);
  return (signed int)(head->next == head);
}

// list_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 464
static signed int list_find(struct ListNode * const head, const void *value, signed int (* const equal_func)(const void *, const void *), struct ListNode **output)
{
  struct ListNode *current;
  _assert_true((unsigned long int)head, "head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 467);
  current = head->next;
  if(!(current == head))
  {
    signed int return_value;
    return_value=equal_func(current->value, value);
    if(!(return_value == 0))
    {
      *output = current;
      return 1;
    }

    current = current->next;
  }

  return 0;
}

// list_first
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 478
static signed int list_first(struct ListNode * const head, struct ListNode **output)
{
  struct ListNode *target_node;
  _assert_true((unsigned long int)head, "head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 480);
  signed int return_value_list_empty$1;
  return_value_list_empty$1=list_empty(head);
  if(!(return_value_list_empty$1 == 0))
    return 0;

  else
  {
    target_node = head->next;
    *output = target_node;
    return 1;
  }
}

// list_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 442
static struct ListNode * list_free(struct ListNode * const head, void (* const cleanup_value)(const void *, void *), void * const cleanup_value_data)
{
  _assert_true((unsigned long int)head, "head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 445);
  signed int return_value_list_empty$1;
  do
  {
    return_value_list_empty$1=list_empty(head);
    if(!(return_value_list_empty$1 == 0))
      break;

    list_remove_free(head->next, cleanup_value, cleanup_value_data);
  }
  while((_Bool)1);
  return head;
}

// list_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 377
static struct ListNode * list_initialize(struct ListNode * const node)
{
  node->value = (void *)0;
  node->next = node;
  node->prev = node;
  node->refcount = 1;
  return node;
}

// list_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 414
static struct ListNode * list_remove(struct ListNode * const node, void (* const cleanup_value)(const void *, void *), void * const cleanup_value_data)
{
  _assert_true((unsigned long int)node, "node", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 417);
  node->prev->next = node->next;
  node->next->prev = node->prev;
  if(!(cleanup_value == ((void (*)(const void *, void *))NULL)))
    cleanup_value(node->value, cleanup_value_data);

  return node;
}

// list_remove_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 428
static void list_remove_free(struct ListNode * const node, void (* const cleanup_value)(const void *, void *), void * const cleanup_value_data)
{
  _assert_true((unsigned long int)node, "node", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 431);
  struct ListNode *return_value_list_remove$1;
  return_value_list_remove$1=list_remove(node, cleanup_value, cleanup_value_data);
  free((void *)return_value_list_remove$1);
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 229
signed int main(void)
{
  const struct UnitTest tests[11l] = { { .name="test_wcore_error_code_unknown_error", .function=test_wcore_error_code_unknown_error,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_code_bad_attribute", .function=test_wcore_error_code_bad_attribute,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_code_unknown_error", .function=test_wcore_error_code_unknown_error,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_with_message", .function=test_wcore_error_with_message,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_internal_error", .function=test_wcore_error_internal_error,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_first_call_without_message_wins", .function=test_wcore_error_first_call_without_message_wins,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_first_call_with_message_wins", .function=test_wcore_error_first_call_with_message_wins,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_disable_then_error", .function=test_wcore_error_disable_then_error,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_disable_then_errorf", .function=test_wcore_error_disable_then_errorf,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_disable_then_error_internal", .function=test_wcore_error_disable_then_error_internal,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST }, 
    { .name="test_wcore_error_thread_local", .function=test_wcore_error_thread_local,
    .function_type=(enum UnitTestFunctionType)UNIT_TEST_FUNCTION_TYPE_TEST } };
  signed int return_value__run_tests$1;
  return_value__run_tests$1=_run_tests(tests, sizeof(const struct UnitTest [11l]) /*264ul*/  / sizeof(const struct UnitTest) /*24ul*/ );
  return return_value__run_tests$1;
}

// memory_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 895
static signed int memory_equal_display_error(const char * const a, const char * const b, const unsigned long int size)
{
  signed int differences = 0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= size); i = i + 1ul)
  {
    const char l = a[(signed long int)i];
    const char r = b[(signed long int)i];
    if(!(l == r))
    {
      print_error("difference at offset %zd 0x%02x 0x%02x\n", i, l, r);
      differences = differences + 1;
    }

  }
  if(!(differences == 0))
  {
    print_error("%d bytes of %p and %p differ\n", differences, a, b);
    return 0;
  }

  else
    return 1;
}

// memory_not_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 922
static signed int memory_not_equal_display_error(const char * const a, const char * const b, const unsigned long int size)
{
  unsigned long int same = (unsigned long int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= size); i = i + 1ul)
  {
    const char l = a[(signed long int)i];
    const char r = b[(signed long int)i];
    if(l == r)
      same = same + 1ul;

  }
  if(same == size)
  {
    print_error("%zdbytes of %p and %p the same\n", same, a, b);
    return 0;
  }

  else
    return 1;
}

// mock_assert
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1277
void mock_assert(const signed int result, const char * const expression, const char * const file, const signed int line)
{
  if(result == 0)
  {
    if(!(global_expecting_assert == 0))
    {
      global_last_failed_assert = expression;
      longjmp(global_expect_assert_env, result);
    }

    else
    {
      print_error("ASSERT: %s\n", expression);
      _fail(file, line);
    }
  }

}

// mtx_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 156
void mtx_destroy(union anonymous *mtx)
{
  pthread_mutex_destroy(mtx);
}

// mtx_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 157
signed int mtx_init(union anonymous *mtx, signed int type)
{
  union anonymous$13 attr;
  if(mtx == ((union anonymous *)NULL))
    return 2;

  else
    if(!(type == 0) && !(type == 1) && !(type == 2) && !(type == 4) && !(type == 5) && !(type == 6))
      return 2;

    else
    {
      pthread_mutexattr_init(&attr);
      if(!((4 & type) == 0))
        pthread_mutexattr_settype(&attr, 1);

      pthread_mutex_init(mtx, &attr);
      pthread_mutexattr_destroy(&attr);
      return 0;
    }
}

// mtx_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 158
signed int mtx_lock(union anonymous *mtx)
{
  if(mtx == ((union anonymous *)NULL))
    return 2;

  else
  {
    pthread_mutex_lock(mtx);
    return 0;
  }
}

// mtx_timedlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 174
signed int mtx_timedlock(union anonymous *mtx, const struct xtime *xt)
{
  if(mtx == ((union anonymous *)NULL) || xt == ((const struct xtime *)NULL))
    return 2;

  else
  {
    struct timespec ts;
    signed int rt;
    ts.tv_sec = xt->sec;
    ts.tv_nsec = xt->nsec;
    rt=pthread_mutex_timedlock(mtx, &ts);
    if(rt == 0)
      return 0;

    else
      return rt == 110 ? 3 : 2;
  }
}

// mtx_trylock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 203
signed int mtx_trylock(union anonymous *mtx)
{
  if(mtx == ((union anonymous *)NULL))
    return 2;

  else
  {
    signed int return_value_pthread_mutex_trylock$1;
    return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(mtx);
    return return_value_pthread_mutex_trylock$1 == 0 ? 0 : 3;
  }
}

// mtx_unlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 161
signed int mtx_unlock(union anonymous *mtx)
{
  if(mtx == ((union anonymous *)NULL))
    return 2;

  else
  {
    pthread_mutex_unlock(mtx);
    return 0;
  }
}

// parse_bool
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 80
static _Bool parse_bool(const signed int *attrib_list, signed int attrib_name, _Bool *value, _Bool default_value)
{
  signed int raw_value;
  wcore_attrib_list_get_with_default(attrib_list, attrib_name, &raw_value, (signed int)default_value);
  if(raw_value == -1)
    *value = default_value;

  else
    if(raw_value == 0 || raw_value == 1)
      *value = (_Bool)raw_value;

    else
    {
      const char *return_value_wcore_enum_to_string$1;
      return_value_wcore_enum_to_string$1=wcore_enum_to_string(attrib_name);
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "%s has bad value 0x%x. Must be true(1), false(0), or WAFFLE_DONT_CARE(-1)", return_value_wcore_enum_to_string$1, raw_value);
      return (_Bool)0;
    }
  return (_Bool)1;
}

// parse_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 106
static _Bool parse_context_api(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  _Bool found;
  found=wcore_attrib_list_get(attrib_list, 522, &attrs->context_api);
  if(found == (_Bool)0)
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "required attribute WAFFLE_CONTEXT_API is missing");
    return (_Bool)0;
  }

  else
  {
    if(attrs->context_api == 523 || attrs->context_api == 524 || attrs->context_api == 525 || attrs->context_api == 532)
      goto __CPROVER_DUMP_L4;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_CONTEXT_API has bad value %#x", attrs->context_api);
    return (_Bool)0;

  __CPROVER_DUMP_L4:
    ;
    return (_Bool)1;
  }
}

// parse_context_forward_compatible
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 307
static _Bool parse_context_forward_compatible(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  _Bool return_value_parse_bool$1;
  return_value_parse_bool$1=parse_bool(attrib_list, 533, &attrs->context_forward_compatible, (_Bool)0);
  if(return_value_parse_bool$1 == (_Bool)0)
    return (_Bool)0;

  else
    if(attrs->context_forward_compatible == (_Bool)0)
      return (_Bool)1;

    else
      if(!(attrs->context_api == 523))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "To request a forward-compatible context, the context API must be WAFFLE_CONTEXT_OPENGL");
        return (_Bool)0;
      }

      else
      {
        _Bool return_value_wcore_config_attrs_version_lt$2;
        return_value_wcore_config_attrs_version_lt$2=wcore_config_attrs_version_lt(attrs, 30);
        if(!(return_value_wcore_config_attrs_version_lt$2 == (_Bool)0))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "To request a forward-compatible context, the context version must be at least 3.0");
          return (_Bool)0;
        }

        else
          return (_Bool)1;
      }
}

// parse_context_profile
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 260
static _Bool parse_context_profile(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  wcore_attrib_list_get_with_default(attrib_list, 528, &attrs->context_profile, attrs->context_profile);
  _Bool return_value_wcore_config_attrs_version_ge$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool return_value_wcore_config_attrs_version_lt$1;
  switch(attrs->context_api)
  {
    case 523:
    {
      return_value_wcore_config_attrs_version_ge$2=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge$2 == (_Bool)0))
        tmp_if_expr$3 = attrs->context_profile != 529 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = attrs->context_profile != 530 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL >= 3.2, WAFFLE_CONTEXT_PROFILE must be either WAFFLE_CONTEXT_CORE_PROFILE or WAFFLE_CONTEXT_COMPATIBILITY_PROFILE");
        return (_Bool)0;
      }

      else
      {
        return_value_wcore_config_attrs_version_lt$1=wcore_config_attrs_version_lt(attrs, 32);
        if(!(return_value_wcore_config_attrs_version_lt$1 == (_Bool)0))
        {
          if(!(attrs->context_profile == 0))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL < 3.2, WAFFLE_CONTEXT_PROFILE must be WAFFLE_NONE");
            return (_Bool)0;
          }

        }

      }
      break;
    }
    case 524:

    case 525:

    case 532:
    {
      if(!(attrs->context_profile == 0))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES, WAFFLE_CONTEXT_PROFILE must be WAFFLE_NONE");
        return (_Bool)0;
      }

      break;
    }
    default:
      return (_Bool)0;
  }
  return (_Bool)1;
}

// parse_context_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 163
static _Bool parse_context_version(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  wcore_attrib_list_get_with_default(attrib_list, 526, &attrs->context_major_version, attrs->context_major_version);
  wcore_attrib_list_get_with_default(attrib_list, 527, &attrs->context_minor_version, attrs->context_minor_version);
  _Bool return_value_wcore_config_attrs_version_lt$1;
  _Bool return_value_wcore_config_attrs_version_eq$3;
  _Bool return_value_wcore_config_attrs_version_eq$2;
  if(!(attrs->context_major_version >= 1))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_CONTEXT_MAJOR_VERSION must be >= 1");
    return (_Bool)0;
  }

  else
    if(!(attrs->context_minor_version >= 0))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_CONTEXT_MINOR_VERSION must be >= 0");
      return (_Bool)0;
    }

    else
    {
      switch(attrs->context_api)
      {
        case 523:
        {
          return_value_wcore_config_attrs_version_lt$1=wcore_config_attrs_version_lt(attrs, 10);
          if(!(return_value_wcore_config_attrs_version_lt$1 == (_Bool)0))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL, the requested context version must be >= 1.0");
            return (_Bool)0;
          }

          break;
        }
        case 524:
        {
          return_value_wcore_config_attrs_version_eq$3=wcore_config_attrs_version_eq(attrs, 10);
          if(return_value_wcore_config_attrs_version_eq$3 == (_Bool)0)
          {
            return_value_wcore_config_attrs_version_eq$2=wcore_config_attrs_version_eq(attrs, 11);
            if(return_value_wcore_config_attrs_version_eq$2 == (_Bool)0)
            {
              wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES1, the requested context version must be 1.0 or 1.1");
              return (_Bool)0;
            }

          }

          break;
        }
        case 525:
        {
          if(!(attrs->context_major_version == 2))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES2, the requested major context version must be 2");
            return (_Bool)0;
          }

          break;
        }
        case 532:
        {
          if(!(attrs->context_major_version == 3))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES3, the requested major context version must be 3");
            return (_Bool)0;
          }

          break;
        }
        default:
        {
          _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c", 227, "attrs->context_api has bad value 0x%x", attrs->context_api);
          return (_Bool)0;
        }
      }
      return (_Bool)1;
    }
}

// parse_misc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 365
static _Bool parse_misc(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  signed int i = 0;
  _Bool return_value_parse_bool$1;
  _Bool return_value_parse_bool$2;
  _Bool return_value_parse_bool$3;
  _Bool return_value_parse_bool$4;
  for( ; !(attrib_list[(signed long int)i] == 0); i = i + 2)
  {
    signed int key = attrib_list[(signed long int)(i + 0)];
    signed int value = attrib_list[(signed long int)(i + 1)];
    switch(key)
    {
      case 522:

      case 526:

      case 527:

      case 528:

      case 533:
        break;
      case 513:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_RED_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->red_size = value;
        break;
      }
      case 514:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_GREEN_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->green_size = value;
        break;
      }
      case 515:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_BLUE_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->blue_size = value;
        break;
      }
      case 516:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_ALPHA_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->alpha_size = value;
        break;
      }
      case 517:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_DEPTH_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->depth_size = value;
        break;
      }
      case 518:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_STENCIL_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->stencil_size = value;
        break;
      }
      case 520:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_SAMPLES has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->samples = value;
        break;
      }
      case 534:
      {
        return_value_parse_bool$1=parse_bool(attrib_list, 534, &attrs->context_debug, (_Bool)0);
        if(return_value_parse_bool$1 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      case 519:
      {
        return_value_parse_bool$2=parse_bool(attrib_list, 519, &attrs->sample_buffers, (_Bool)0);
        if(return_value_parse_bool$2 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      case 521:
      {
        return_value_parse_bool$3=parse_bool(attrib_list, 521, &attrs->double_buffered, (_Bool)1);
        if(return_value_parse_bool$3 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      case 531:
      {
        return_value_parse_bool$4=parse_bool(attrib_list, 531, &attrs->accum_buffer, (_Bool)0);
        if(return_value_parse_bool$4 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      default:
      {
        _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c", 429, "%s", (const void *)"bad attribute key should have been found by check_keys()");
        return (_Bool)0;
      }
    }
  }
  attrs->rgb_size = 0;
  if(!(attrs->red_size == -1))
    attrs->rgb_size = attrs->rgb_size + attrs->red_size;

  if(!(attrs->green_size == -1))
    attrs->rgb_size = attrs->rgb_size + attrs->green_size;

  if(!(attrs->blue_size == -1))
    attrs->rgb_size = attrs->rgb_size + attrs->blue_size;

  attrs->rgba_size = attrs->rgb_size;
  if(!(attrs->alpha_size == -1))
    attrs->rgba_size = attrs->rgba_size + attrs->alpha_size;

  return (_Bool)1;
}

// print_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1638
void print_error(const char * const format, ...)
{
  void **args = (void **)&format;
  vprint_error(format, args);
  args = ((void **)NULL);
}

// print_message
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1630
void print_message(const char * const format, ...)
{
  void **args = (void **)&format;
  vprint_message(format, args);
  args = ((void **)NULL);
}

// pthread_equal
// file /usr/include/pthread.h line 1155
static inline signed int pthread_equal(unsigned long int __thread1, unsigned long int __thread2)
{
  return (signed int)(__thread1 == __thread2);
}

// registry_listener_global
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 61
static void registry_listener_global(void *data, struct wl_registry *registry, unsigned int name, const char *interface, unsigned int version)
{
  struct wayland_display *self = (struct wayland_display *)data;
  signed int return_value_strncmp$4;
  return_value_strncmp$4=strncmp(interface, "wl_compositor", (unsigned long int)14);
  signed int return_value_strncmp$3;
  if(return_value_strncmp$4 == 0)
  {
    void *return_value_wl_registry_bind$1;
    return_value_wl_registry_bind$1=wl_registry_bind(self->wl_registry, name, &wl_compositor_interface, (unsigned int)1);
    self->wl_compositor = (struct wl_compositor *)return_value_wl_registry_bind$1;
  }

  else
  {
    return_value_strncmp$3=strncmp(interface, "wl_shell", (unsigned long int)9);
    if(return_value_strncmp$3 == 0)
    {
      void *return_value_wl_registry_bind$2;
      return_value_wl_registry_bind$2=wl_registry_bind(self->wl_registry, name, &wl_shell_interface, (unsigned int)1);
      self->wl_shell = (struct wl_shell *)return_value_wl_registry_bind$2;
    }

  }
}

// registry_listener_global_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 80
static void registry_listener_global_remove(void *data, struct wl_registry *registry, unsigned int name)
{
  ;
}

// remove_always_return_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 616
static void remove_always_return_values(struct ListNode * const map_head, const unsigned long int number_of_symbol_names)
{
  struct ListNode *current;
  _assert_true((unsigned long int)map_head, "map_head", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 619);
  _assert_true((unsigned long int)number_of_symbol_names, "number_of_symbol_names", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 620);
  current = map_head->next;
  while(!(current == map_head))
  {
    struct SymbolMapValue * const value = (struct SymbolMapValue *)current->value;
    struct ListNode * const next = current->next;
    struct ListNode *child_list;
    _assert_true((unsigned long int)value, "value", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 626);
    child_list = &value->symbol_values_list_head;
    signed int return_value_list_empty$1;
    return_value_list_empty$1=list_empty(child_list);
    if(return_value_list_empty$1 == 0)
    {
      if(number_of_symbol_names == 1ul)
      {
        struct ListNode * const child_node = child_list->next;
        if(!(child_node->refcount >= -1))
          list_remove_free(child_node, free_value, (void *)0);

      }

      else
        remove_always_return_values(child_list, number_of_symbol_names - (unsigned long int)1);
    }

    signed int return_value_list_empty$2;
    return_value_list_empty$2=list_empty(child_list);
    if(!(return_value_list_empty$2 == 0))
      list_remove_free(current, free_value, (void *)0);

    current = next;
  }
}

// set_context_profile_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 235
static _Bool set_context_profile_default(struct wcore_config_attrs *attrs)
{
  _Bool return_value_wcore_config_attrs_version_ge$1;
  switch(attrs->context_api)
  {
    case 523:
    {
      return_value_wcore_config_attrs_version_ge$1=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge$1 == (_Bool)0))
        attrs->context_profile = 529;

      else
        attrs->context_profile = 0;
      break;
    }
    case 524:

    case 525:

    case 532:
    {
      attrs->context_profile = 0;
      break;
    }
    default:
      return (_Bool)0;
  }
  return (_Bool)1;
}

// set_context_version_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 136
static _Bool set_context_version_default(struct wcore_config_attrs *attrs)
{
  switch(attrs->context_api)
  {
    case 523:
    {
      attrs->context_major_version = 1;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    case 524:
    {
      attrs->context_major_version = 1;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    case 525:
    {
      attrs->context_major_version = 2;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    case 532:
    {
      attrs->context_major_version = 3;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c", 157, "attrs->context_api has bad value 0x%x", attrs->context_api);
      return (_Bool)0;
    }
  }
}

// set_misc_defaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 339
static _Bool set_misc_defaults(struct wcore_config_attrs *attrs)
{
  attrs->context_debug = (_Bool)0;
  attrs->rgba_size = 0;
  attrs->red_size = 0;
  attrs->green_size = 0;
  attrs->blue_size = 0;
  attrs->alpha_size = 0;
  attrs->depth_size = 0;
  attrs->stencil_size = 0;
  attrs->sample_buffers = (_Bool)0;
  attrs->samples = 0;
  attrs->double_buffered = (_Bool)1;
  attrs->accum_buffer = (_Bool)0;
  return (_Bool)1;
}

// set_source_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 325
static void set_source_location(struct SourceLocation * const location, const char * const file, const signed int line)
{
  _assert_true((unsigned long int)location, "location", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 328);
  location->file = file;
  location->line = line;
}

// shell_surface_listener_configure
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 76
static void shell_surface_listener_configure(void *data, struct wl_shell_surface *shell_surface, unsigned int edges, signed int width, signed int height)
{
  ;
}

// shell_surface_listener_ping
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 68
static void shell_surface_listener_ping(void *data, struct wl_shell_surface *shell_surface, unsigned int serial)
{
  wl_shell_surface_pong(shell_surface, serial);
}

// shell_surface_listener_popup_done
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 85
static void shell_surface_listener_popup_done(void *data, struct wl_shell_surface *shell_surface)
{
  ;
}

// source_location_is_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 318
static signed int source_location_is_set(const struct SourceLocation * const location)
{
  _assert_true((unsigned long int)location, "location", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 319);
  _Bool tmp_if_expr$1;
  if(!(location->file == ((const char *)NULL)))
    tmp_if_expr$1 = location->line != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// string_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 866
static signed int string_equal_display_error(const char * const left, const char * const right)
{
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(left, right);
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  if(tmp_statement_expression$1 == 0)
    return 1;

  else
  {
    print_error("\"%s\" != \"%s\"\n", left, right);
    return 0;
  }
}

// string_not_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 881
static signed int string_not_equal_display_error(const char * const left, const char * const right)
{
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(left, right);
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  if(!(tmp_statement_expression$1 == 0))
    return 1;

  else
  {
    print_error("\"%s\" == \"%s\"\n", left, right);
    return 0;
  }
}

// symbol_names_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 515
static signed int symbol_names_match(const void *map_value, const void *symbol)
{
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(((struct SymbolMapValue *)map_value)->symbol_name, (const char *)symbol);
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  return (signed int)!(tmp_statement_expression$1 != 0);
}

// teardown_testing
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 366
static void teardown_testing(const char *test_name)
{
  (void)test_name;
  list_free(&global_function_result_map_head, free_symbol_map_value, (void *)0);
  initialize_source_location(&global_last_mock_value_location);
  list_free(&global_function_parameter_map_head, free_symbol_map_value, (void *)1);
  initialize_source_location(&global_last_parameter_location);
}

// test_wcore_error_code_bad_attribute
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 48
static void test_wcore_error_code_bad_attribute(void **state)
{
  wcore_error_reset();
  wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_BAD_ATTRIBUTE, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 51);
  struct waffle_error_info *return_value_wcore_error_get_info$2;
  return_value_wcore_error_get_info$2=wcore_error_get_info();
  _assert_string_equal((const char *)return_value_wcore_error_get_info$2->message, (const char *)"", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 52);
}

// test_wcore_error_code_unknown_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 39
static void test_wcore_error_code_unknown_error(void **state)
{
  wcore_error_reset();
  wcore_error((enum waffle_error)WAFFLE_ERROR_UNKNOWN);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_UNKNOWN, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 42);
  struct waffle_error_info *return_value_wcore_error_get_info$2;
  return_value_wcore_error_get_info$2=wcore_error_get_info();
  _assert_string_equal((const char *)return_value_wcore_error_get_info$2->message, (const char *)"", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 43);
}

// test_wcore_error_disable_then_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 94
static void test_wcore_error_disable_then_error(void **state)
{
  wcore_error_reset();
  wcore_error((enum waffle_error)WAFFLE_ERROR_NOT_INITIALIZED);
  do
  {
    _wcore_error_disable();
    wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE);
    _wcore_error_enable();
  }
  while((_Bool)0);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_NOT_INITIALIZED, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 100);
}

// test_wcore_error_disable_then_error_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 114
static void test_wcore_error_disable_then_error_internal(void **state)
{
  wcore_error_reset();
  wcore_error((enum waffle_error)WAFFLE_ERROR_NOT_INITIALIZED);
  do
  {
    _wcore_error_disable();
    _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 121, "this isn't happening");
    _wcore_error_enable();
  }
  while((_Bool)0);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_NOT_INITIALIZED, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 122);
}

// test_wcore_error_disable_then_errorf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 104
static void test_wcore_error_disable_then_errorf(void **state)
{
  wcore_error_reset();
  wcore_error((enum waffle_error)WAFFLE_ERROR_NOT_INITIALIZED);
  do
  {
    _wcore_error_disable();
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "i'm not here");
    _wcore_error_enable();
  }
  while((_Bool)0);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_NOT_INITIALIZED, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 110);
}

// test_wcore_error_first_call_with_message_wins
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 85
static void test_wcore_error_first_call_with_message_wins(void **state)
{
  wcore_error_reset();
  wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "cookies");
  wcore_errorf((enum waffle_error)WAFFLE_NO_ERROR, "all is well");
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_UNKNOWN, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 89);
  struct waffle_error_info *return_value_wcore_error_get_info$2;
  return_value_wcore_error_get_info$2=wcore_error_get_info();
  _assert_string_equal((const char *)return_value_wcore_error_get_info$2->message, (const char *)"cookies", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 90);
}

// test_wcore_error_first_call_without_message_wins
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 76
static void test_wcore_error_first_call_without_message_wins(void **state)
{
  wcore_error_reset();
  wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "cookies");
  wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_UNKNOWN, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 80);
  struct waffle_error_info *return_value_wcore_error_get_info$2;
  return_value_wcore_error_get_info$2=wcore_error_get_info();
  _assert_string_equal((const char *)return_value_wcore_error_get_info$2->message, (const char *)"cookies", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 81);
}

// test_wcore_error_internal_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 64
static void test_wcore_error_internal_error(void **state)
{
  char error_location[1024l];
  snprintf(error_location, (unsigned long int)1024, "%s:%d:", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 66 + 3);
  wcore_error_reset();
  _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 69, "%s zoroaster %d", (const void *)"hello", 5);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_INTERNAL, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 70);
  struct waffle_error_info *return_value_wcore_error_get_info$2;
  return_value_wcore_error_get_info$2=wcore_error_get_info();
  char *return_value_strstr$3;
  return_value_strstr$3=strstr(return_value_wcore_error_get_info$2->message, "hello zoroaster 5");
  _assert_true((unsigned long int)return_value_strstr$3, "strstr(wcore_error_get_info()->message, \"hello zoroaster 5\")", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 71);
  struct waffle_error_info *return_value_wcore_error_get_info$4;
  return_value_wcore_error_get_info$4=wcore_error_get_info();
  char *return_value_strstr$5;
  return_value_strstr$5=strstr(return_value_wcore_error_get_info$4->message, error_location);
  _assert_true((unsigned long int)return_value_strstr$5, "strstr(wcore_error_get_info()->message, error_location)", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 72);
}

// test_wcore_error_thread_local
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 186
static void test_wcore_error_thread_local(void **state)
{
  union anonymous mutex;
  union anonymous$1 cond;
  volatile signed int num_threads_waiting = 0;
  unsigned long int threads[3l];
  struct thread_arg thread_args[3l];
  signed int exit_codes[3l];
  mtx_init(&mutex, 0);
  cnd_init(&cond);
  signed int i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    struct thread_arg *a = &thread_args[(signed long int)i];
    a->thread_id = i;
    a->mutex = &mutex;
    a->cond = &cond;
    a->num_threads_waiting = &num_threads_waiting;
    thrd_create(&threads[(signed long int)i], (signed int (*)(void *))thread_start, (void *)a);
  }
  while(!(num_threads_waiting >= 3))
    ;
  mtx_lock(&mutex);
  cnd_broadcast(&cond);
  mtx_unlock(&mutex);
  signed int test_wcore_error_thread_local$$1$$3$$i = 0;
  for( ; !(test_wcore_error_thread_local$$1$$3$$i >= 3); test_wcore_error_thread_local$$1$$3$$i = test_wcore_error_thread_local$$1$$3$$i + 1)
  {
    thrd_join(threads[(signed long int)test_wcore_error_thread_local$$1$$3$$i], &exit_codes[(signed long int)test_wcore_error_thread_local$$1$$3$$i]);
    _assert_true((unsigned long int)exit_codes[(signed long int)test_wcore_error_thread_local$$1$$3$$i], "exit_codes[i]", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 221);
  }
  cnd_destroy(&cond);
  mtx_destroy(&mutex);
}

// test_wcore_error_with_message
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 56
static void test_wcore_error_with_message(void **state)
{
  wcore_error_reset();
  wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_PARAMETER, "bad %s (0x%x)", (const void *)"gl_api", 0x17);
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  _assert_int_equal((unsigned long int)return_value_wcore_error_get_code$1, (unsigned long int)WAFFLE_ERROR_BAD_PARAMETER, "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 59);
  struct waffle_error_info *return_value_wcore_error_get_info$2;
  return_value_wcore_error_get_info$2=wcore_error_get_info();
  _assert_string_equal((const char *)return_value_wcore_error_get_info$2->message, (const char *)"bad gl_api (0x17)", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c", 60);
}

// thrd_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 163
signed int thrd_create(unsigned long int *thr, signed int (*func)(void *), void *arg)
{
  struct impl_thrd_param *pack;
  if(thr == ((unsigned long int *)NULL))
    return 2;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct impl_thrd_param) /*16ul*/ );
    pack = (struct impl_thrd_param *)return_value_malloc$1;
    if(pack == ((struct impl_thrd_param *)NULL))
      return 4;

    else
    {
      pack->func = func;
      pack->arg = arg;
      signed int return_value_pthread_create$2;
      return_value_pthread_create$2=pthread_create(thr, (const union pthread_attr_t *)(void *)0, impl_thrd_routine, (void *)pack);
      if(!(return_value_pthread_create$2 == 0))
      {
        free((void *)pack);
        return 2;
      }

      else
        return 0;
    }
  }
}

// thrd_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 236
unsigned long int thrd_current(void)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  return return_value_pthread_self$1;
}

// thrd_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 242
signed int thrd_detach(unsigned long int thr)
{
  signed int return_value_pthread_detach$1;
  return_value_pthread_detach$1=pthread_detach(thr);
  return return_value_pthread_detach$1 == 0 ? 0 : 2;
}

// thrd_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 248
signed int thrd_equal(unsigned long int thr0, unsigned long int thr1)
{
  signed int return_value_pthread_equal$1;
  return_value_pthread_equal$1=pthread_equal(thr0, thr1);
  return return_value_pthread_equal$1;
}

// thrd_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 254
void thrd_exit(signed int res)
{
  pthread_exit((void *)(signed long int)res);
}

// thrd_join
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 168
signed int thrd_join(unsigned long int thr, signed int *res)
{
  void *code;
  signed int return_value_pthread_join$1;
  return_value_pthread_join$1=pthread_join(thr, &code);
  if(!(return_value_pthread_join$1 == 0))
    return 2;

  else
  {
    if(!(res == ((signed int *)NULL)))
      *res = (signed int)(signed long int)code;

    return 0;
  }
}

// thrd_sleep
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 271
void thrd_sleep(const struct xtime *xt)
{
  struct timespec req;
  req.tv_sec = xt->sec;
  req.tv_nsec = xt->nsec;
  nanosleep(&req, (struct timespec *)(void *)0);
}

// thrd_yield
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 281
void thrd_yield(void)
{
  sched_yield();
}

// thread_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error_unittest.c line 152
static _Bool thread_start(struct thread_arg *a)
{
  _Bool ok = (_Bool)1;
  static const enum waffle_error error_codes[3l] = { (const enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, 
    (const enum waffle_error)WAFFLE_ERROR_UNKNOWN, 
    (const enum waffle_error)WAFFLE_ERROR_ALREADY_INITIALIZED };
  enum waffle_error error_code = error_codes[(signed long int)a->thread_id];
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  ok = ((signed int)ok & (signed int)((signed int)return_value_wcore_error_get_code$1 == WAFFLE_NO_ERROR)) != 0;
  wcore_error(error_code);
  mtx_lock(a->mutex);
  *a->num_threads_waiting = *a->num_threads_waiting + 1;
  cnd_wait(a->cond, a->mutex);
  mtx_unlock(a->mutex);
  enum waffle_error return_value_wcore_error_get_code$2;
  return_value_wcore_error_get_code$2=wcore_error_get_code();
  ok = ((signed int)ok & (signed int)(return_value_wcore_error_get_code$2 == error_code)) != 0;
  return ok;
}

// tss_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 172
signed int tss_create(unsigned int *key, void (*dtor)(void *))
{
  if(key == ((unsigned int *)NULL))
    return 2;

  else
  {
    signed int return_value_pthread_key_create$1;
    return_value_pthread_key_create$1=pthread_key_create(key, dtor);
    return return_value_pthread_key_create$1 == 0 ? 0 : 2;
  }
}

// tss_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 296
void tss_delete(unsigned int key)
{
  pthread_key_delete(key);
}

// tss_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 302
void * tss_get(unsigned int key)
{
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(key);
  return return_value_pthread_getspecific$1;
}

// tss_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 175
signed int tss_set(unsigned int key, void *val)
{
  signed int return_value_pthread_setspecific$1;
  return_value_pthread_setspecific$1=pthread_setspecific(key, val);
  return return_value_pthread_setspecific$1 == 0 ? 0 : 2;
}

// value_in_set_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 797
static signed int value_in_set_display_error(const unsigned long long int value, const struct CheckIntegerSet * const check_integer_set, const signed int invert)
{
  signed int succeeded = invert;
  _assert_true((unsigned long int)check_integer_set, "check_integer_set", "/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c", 801);
  const unsigned long long int * const set = check_integer_set->set;
  const unsigned long int size_of_set = check_integer_set->size_of_set;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= size_of_set); i = i + 1ul)
    if(set[(signed long int)i] == value)
    {
      succeeded = (signed int)!(succeeded != 0);
      break;
    }

  if(!(succeeded == 0))
    return 1;

  else
  {
    print_error("%llu is %sin the set (", value, invert != 0 ? "" : "not ");
    i = (unsigned long int)0;
    for( ; !(i >= size_of_set); i = i + 1ul)
      print_error("%llu, ", set[(signed long int)i]);
    print_error(")\n");
    return 0;
  }
}

// values_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 766
static signed int values_equal_display_error(const unsigned long long int left, const unsigned long long int right)
{
  const signed int equal = (const signed int)(left == right);
  if(equal == 0)
    print_error("%llx != %llx\n", left, right);

  return equal;
}

// values_not_equal_display_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 779
static signed int values_not_equal_display_error(const unsigned long long int left, const unsigned long long int right)
{
  const signed int not_equal = (const signed int)(left != right);
  if(not_equal == 0)
    print_error("%llx == %llx\n", left, right);

  return not_equal;
}

// vprint_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1619
void vprint_error(const char * const format, void **args)
{
  char buffer[1024l];
  vsnprintf(buffer, sizeof(char [1024l]) /*1024ul*/ , format, args);
  fprintf(stderr, "%s", (const void *)buffer);
  fflush(stderr);
}

// vprint_message
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/cmocka/src/cmocka.c line 1608
void vprint_message(const char * const format, void **args)
{
  char buffer[1024l];
  vsnprintf(buffer, sizeof(char [1024l]) /*1024ul*/ , format, args);
  printf("%s", (const void *)buffer);
  fflush(stdout);
}

// waffle_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 40
_Bool waffle_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value)
{
  wcore_error_reset();
  _Bool return_value_wcore_attrib_list_get$1;
  return_value_wcore_attrib_list_get$1=wcore_attrib_list_get(attrib_list, key, value);
  return return_value_wcore_attrib_list_get$1;
}

// waffle_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 50
_Bool waffle_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value)
{
  wcore_error_reset();
  _Bool return_value_wcore_attrib_list_get_with_default$1;
  return_value_wcore_attrib_list_get_with_default$1=wcore_attrib_list_get_with_default(attrib_list, key, value, default_value);
  return return_value_wcore_attrib_list_get_with_default$1;
}

// waffle_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 32
signed int waffle_attrib_list_length(const signed int *attrib_list)
{
  wcore_error_reset();
  signed int return_value_wcore_attrib_list_length$1;
  return_value_wcore_attrib_list_length$1=wcore_attrib_list_length(attrib_list);
  return return_value_wcore_attrib_list_length$1;
}

// waffle_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 62
_Bool waffle_attrib_list_update(signed int *attrib_list, signed int key, signed int value)
{
  wcore_error_reset();
  _Bool return_value_wcore_attrib_list_update$1;
  return_value_wcore_attrib_list_update$1=wcore_attrib_list_update(attrib_list, key, value);
  return return_value_wcore_attrib_list_update$1;
}

// waffle_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 49
static inline struct waffle_config * waffle_config(struct wcore_config *cfg)
{
  return (struct waffle_config *)cfg;
}

// waffle_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 35
struct waffle_config * waffle_config_choose(struct waffle_display *dpy, const signed int *attrib_list)
{
  struct wcore_config *wc_self;
  struct wcore_display *wc_dpy;
  wc_dpy=wcore_display(dpy);
  struct wcore_config_attrs attrs;
  _Bool ok = (_Bool)1;
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_dpy == ((struct wcore_display *)NULL)))
    tmp_if_expr$1 = &wc_dpy->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (struct waffle_config *)(void *)0;

  else
  {
    ok=wcore_config_attrs_parse(attrib_list, &attrs);
    if(ok == (_Bool)0)
      return (struct waffle_config *)(void *)0;

    else
    {
      wc_self=api_platform->vtbl->config.choose(api_platform, wc_dpy, &attrs);
      if(wc_self == ((struct wcore_config *)NULL))
        return (struct waffle_config *)(void *)0;

      else
      {
        struct waffle_config *return_value_waffle_config$3;
        return_value_waffle_config$3=waffle_config(wc_self);
        return return_value_waffle_config$3;
      }
    }
  }
}

// waffle_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 63
_Bool waffle_config_destroy(struct waffle_config *self)
{
  struct wcore_config *wc_self;
  wc_self=wcore_config(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_config *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->config.destroy(wc_self);
    return return_value;
  }
}

// waffle_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 78
union waffle_native_config * waffle_config_get_native(struct waffle_config *self)
{
  struct wcore_config *wc_self;
  wc_self=wcore_config(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_config *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (union waffle_native_config *)(void *)0;

  else
    if(!(api_platform->vtbl->config.get_native == ((union waffle_native_config * (*)(struct wcore_config *))NULL)))
    {
      union waffle_native_config *return_value;
      return_value=api_platform->vtbl->config.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_config *)(void *)0;
    }
}

// waffle_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 47
static inline struct waffle_context * waffle_context(struct wcore_context *ctx)
{
  return (struct waffle_context *)ctx;
}

// waffle_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 33
struct waffle_context * waffle_context_create(struct waffle_config *config, struct waffle_context *shared_ctx)
{
  struct wcore_context *wc_self;
  struct wcore_config *wc_config;
  wc_config=wcore_config$link1(config);
  struct wcore_context *wc_shared_ctx;
  wc_shared_ctx=wcore_context(shared_ctx);
  struct api_object *obj_list[2l];
  signed int len = 0;
  signed int tmp_post$1 = len;
  len = len + 1;
  struct api_object *tmp_if_expr$2;
  if(!(wc_config == ((struct wcore_config *)NULL)))
    tmp_if_expr$2 = &wc_config->api;

  else
    tmp_if_expr$2 = (struct api_object *)(void *)0;
  obj_list[(signed long int)tmp_post$1] = tmp_if_expr$2;
  signed int tmp_post$3;
  if(!(wc_shared_ctx == ((struct wcore_context *)NULL)))
  {
    tmp_post$3 = len;
    len = len + 1;
    obj_list[(signed long int)tmp_post$3] = &wc_shared_ctx->api;
  }

  _Bool return_value_api_check_entry$4;
  return_value_api_check_entry$4=api_check_entry(obj_list, len);
  if(return_value_api_check_entry$4 == (_Bool)0)
    return (struct waffle_context *)(void *)0;

  else
  {
    wc_self=api_platform->vtbl->context.create(api_platform, wc_config, wc_shared_ctx);
    if(wc_self == ((struct wcore_context *)NULL))
      return (struct waffle_context *)(void *)0;

    else
    {
      struct waffle_context *return_value_waffle_context$5;
      return_value_waffle_context$5=waffle_context(wc_self);
      return return_value_waffle_context$5;
    }
  }
}

// waffle_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 61
_Bool waffle_context_destroy(struct waffle_context *self)
{
  struct wcore_context *wc_self;
  wc_self=wcore_context(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_context *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->context.destroy(wc_self);
    return return_value;
  }
}

// waffle_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 76
union waffle_native_context * waffle_context_get_native(struct waffle_context *self)
{
  struct wcore_context *wc_self;
  wc_self=wcore_context(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_context *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (union waffle_native_context *)(void *)0;

  else
    if(!(api_platform->vtbl->context.get_native == ((union waffle_native_context * (*)(struct wcore_context *))NULL)))
    {
      union waffle_native_context *return_value;
      return_value=api_platform->vtbl->context.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_context *)(void *)0;
    }
}

// waffle_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 44
static inline struct waffle_display * waffle_display(struct wcore_display *dpy)
{
  return (struct waffle_display *)dpy;
}

// waffle_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 34
struct waffle_display * waffle_display_connect(const char *name)
{
  struct wcore_display *wc_self;
  _Bool return_value_api_check_entry$1;
  return_value_api_check_entry$1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry$1 == (_Bool)0)
    return (struct waffle_display *)(void *)0;

  else
  {
    wc_self=api_platform->vtbl->display.connect(api_platform, name);
    if(wc_self == ((struct wcore_display *)NULL))
      return (struct waffle_display *)(void *)0;

    else
    {
      struct waffle_display *return_value_waffle_display$2;
      return_value_waffle_display$2=waffle_display(wc_self);
      return return_value_waffle_display$2;
    }
  }
}

// waffle_display_disconnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 49
_Bool waffle_display_disconnect(struct waffle_display *self)
{
  struct wcore_display *wc_self;
  wc_self=wcore_display$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_display *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->display.destroy(wc_self);
    return return_value;
  }
}

// waffle_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 94
union waffle_native_display * waffle_display_get_native(struct waffle_display *self)
{
  struct wcore_display *wc_self;
  wc_self=wcore_display$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_display *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (union waffle_native_display *)(void *)0;

  else
    if(!(api_platform->vtbl->display.get_native == ((union waffle_native_display * (*)(struct wcore_display *))NULL)))
    {
      union waffle_native_display *return_value;
      return_value=api_platform->vtbl->display.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_display *)(void *)0;
    }
}

// waffle_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 64
_Bool waffle_display_supports_context_api(struct waffle_display *self, signed int context_api)
{
  struct wcore_display *wc_self;
  wc_self=wcore_display$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_display *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    if(context_api == 523 || context_api == 524 || context_api == 525 || context_api == 532)
      goto __CPROVER_DUMP_L6;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_PARAMETER, "context_api has bad value %#x", context_api);
    return (_Bool)0;

  __CPROVER_DUMP_L6:
    ;
    _Bool return_value;
    return_value=api_platform->vtbl->display.supports_context_api(wc_self, context_api);
    return return_value;
  }
}

// waffle_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 47
_Bool waffle_dl_can_open(signed int dl)
{
  _Bool return_value_api_check_entry$1;
  return_value_api_check_entry$1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry$1 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value_waffle_dl_check_enum$2;
    return_value_waffle_dl_check_enum$2=waffle_dl_check_enum(dl);
    if(return_value_waffle_dl_check_enum$2 == (_Bool)0)
      return (_Bool)0;

    else
    {
      _Bool return_value;
      return_value=api_platform->vtbl->dl_can_open(api_platform, dl);
      return return_value;
    }
  }
}

// waffle_dl_check_enum
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 32
static _Bool waffle_dl_check_enum(signed int dl)
{
  if(dl == 769 || dl == 770 || dl == 771 || dl == 772)
    return (_Bool)1;

  wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_PARAMETER, "dl has bad value %#x");
  return (_Bool)0;
}

// waffle_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 59
void * waffle_dl_sym(signed int dl, const char *name)
{
  _Bool return_value_api_check_entry$1;
  return_value_api_check_entry$1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry$1 == (_Bool)0)
    return (void *)0;

  else
  {
    _Bool return_value_waffle_dl_check_enum$2;
    return_value_waffle_dl_check_enum$2=waffle_dl_check_enum(dl);
    if(return_value_waffle_dl_check_enum$2 == (_Bool)0)
      return (void *)0;

    else
    {
      void *return_value;
      return_value=api_platform->vtbl->dl_sym(api_platform, dl, name);
      return return_value;
    }
  }
}

// waffle_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_enum.c line 32
const char * waffle_enum_to_string(signed int e)
{
  wcore_error_reset();
  const char *return_value_wcore_enum_to_string$1;
  return_value_wcore_enum_to_string$1=wcore_enum_to_string(e);
  return return_value_wcore_enum_to_string$1;
}

// waffle_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 33
enum waffle_error waffle_error_get_code(void)
{
  enum waffle_error return_value_wcore_error_get_code$1;
  return_value_wcore_error_get_code$1=wcore_error_get_code();
  return return_value_wcore_error_get_code$1;
}

// waffle_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 39
struct waffle_error_info * waffle_error_get_info(void)
{
  struct waffle_error_info *return_value_wcore_error_get_info$1;
  return_value_wcore_error_get_info$1=wcore_error_get_info();
  return return_value_wcore_error_get_info$1;
}

// waffle_error_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 45
const char * waffle_error_to_string(enum waffle_error e)
{
  switch((signed int)e)
  {
    case WAFFLE_NO_ERROR:
      return "WAFFLE_NO_ERROR";
    case WAFFLE_ERROR_FATAL:
      return "WAFFLE_ERROR_FATAL";
    case WAFFLE_ERROR_UNKNOWN:
      return "WAFFLE_ERROR_UNKNOWN";
    case WAFFLE_ERROR_INTERNAL:
      return "WAFFLE_ERROR_INTERNAL";
    case WAFFLE_ERROR_BAD_ALLOC:
      return "WAFFLE_ERROR_BAD_ALLOC";
    case WAFFLE_ERROR_NOT_INITIALIZED:
      return "WAFFLE_ERROR_NOT_INITIALIZED";
    case WAFFLE_ERROR_ALREADY_INITIALIZED:
      return "WAFFLE_ERROR_ALREADY_INITIALIZED";
    case WAFFLE_ERROR_BAD_ATTRIBUTE:
      return "WAFFLE_ERROR_BAD_ATTRIBUTE";
    case WAFFLE_ERROR_BAD_PARAMETER:
      return "WAFFLE_ERROR_BAD_PARAMETER";
    case WAFFLE_ERROR_BAD_DISPLAY_MATCH:
      return "WAFFLE_ERROR_BAD_DISPLAY_MATCH";
    case WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM:
      return "WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM";
    case WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT:
      return "WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT";
    default:
      return ((const char *)NULL);
  }
}

// waffle_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 104
void * waffle_get_proc_address(const char *name)
{
  _Bool return_value_api_check_entry$1;
  return_value_api_check_entry$1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry$1 == (_Bool)0)
    return (void *)0;

  else
  {
    void *return_value;
    return_value=api_platform->vtbl->get_proc_address(api_platform, name);
    return return_value;
  }
}

// waffle_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 174
_Bool waffle_init(const signed int *attrib_list)
{
  _Bool ok = (_Bool)1;
  signed int platform;
  wcore_error_reset();
  if(!(api_platform == ((struct wcore_platform *)NULL)))
  {
    wcore_error((enum waffle_error)WAFFLE_ERROR_ALREADY_INITIALIZED);
    return (_Bool)0;
  }

  else
  {
    _Bool return_value_waffle_init_parse_attrib_list$1;
    return_value_waffle_init_parse_attrib_list$1=waffle_init_parse_attrib_list(attrib_list, &platform);
    ok = ((signed int)ok & (signed int)return_value_waffle_init_parse_attrib_list$1) != 0;
    if(ok == (_Bool)0)
      return (_Bool)0;

    else
    {
      api_platform=waffle_init_create_platform(platform);
      if(api_platform == ((struct wcore_platform *)NULL))
        return (_Bool)0;

      else
        return (_Bool)1;
    }
  }
}

// waffle_init_create_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 136
static struct wcore_platform * waffle_init_create_platform(signed int waffle_platform)
{
  struct wcore_platform *return_value_glx_platform_create$1;
  struct wcore_platform *return_value_wayland_platform_create$2;
  struct wcore_platform *return_value_xegl_platform_create$3;
  struct wcore_platform *return_value_wgbm_platform_create$4;
  switch(waffle_platform)
  {
    case 19:
    {
      return_value_glx_platform_create$1=glx_platform_create();
      return return_value_glx_platform_create$1;
    }
    case 20:
    {
      return_value_wayland_platform_create$2=wayland_platform_create();
      return return_value_wayland_platform_create$2;
    }
    case 21:
    {
      return_value_xegl_platform_create$3=xegl_platform_create();
      return return_value_xegl_platform_create$3;
    }
    case 22:
    {
      return_value_wgbm_platform_create$4=wgbm_platform_create();
      return return_value_wgbm_platform_create$4;
    }
    default:
      return (struct wcore_platform *)(void *)0;
  }
}

// waffle_init_parse_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 40
static _Bool waffle_init_parse_attrib_list(const signed int *attrib_list, signed int *platform)
{
  _Bool found_platform = (_Bool)0;
  const signed int *i = attrib_list;
  for( ; !(*i == 0); i = i + (signed long int)2)
  {
    const signed int attr = i[(signed long int)0];
    const signed int value = i[(signed long int)1];
    if(attr == 16)
    {
      switch(value)
      {
        case 17:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT, "waffle was built without support for WAFFLE_PLATFORM_ANDROID");
          return (_Bool)0;
        }
        case 18:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT, "waffle was built without support for WAFFLE_PLATFORM_CGL");
          return (_Bool)0;
        }
        case 19:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case 20:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case 21:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case 22:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case 23:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT, "waffle was built without support for WAFFLE_PLATFORM_WGL");
          return (_Bool)0;
        }
        default:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_PLATFORM has bad value 0x%x", value);
          return (_Bool)0;
        }
      }
      goto __CPROVER_DUMP_L13;
    }

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "bad attribute name %#x", attr);
    return (_Bool)0;

  __CPROVER_DUMP_L13:
    ;
  }
  if(found_platform == (_Bool)0)
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "attribute list is missing WAFFLE_PLATFORM");
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// waffle_is_extension_in_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 39
_Bool waffle_is_extension_in_string(const char * restrict extension_string, const char * restrict extension_name)
{
  unsigned long int name_length;
  const char * restrict search_start;
  wcore_error_reset();
  _Bool tmp_if_expr$1;
  if(extension_name == ((const char *)NULL) || extension_string == ((const char *)NULL))
    return (_Bool)0;

  else
  {
    name_length=strlen(extension_name);
    search_start = extension_string;
    if(name_length == 0ul)
      return (_Bool)0;

    else
      while((_Bool)1)
      {
        const char * restrict s;
        const char * restrict next_char;
        s=strstr(search_start, extension_name);
        if(s == ((const char *)NULL))
          return (_Bool)0;

        next_char = s + (signed long int)name_length;
        if((signed int)*next_char == 32)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)*next_char == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          return (_Bool)1;

        search_start = next_char;
      }
  }
}

// waffle_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 76
_Bool waffle_make_current(struct waffle_display *dpy, struct waffle_window *window, struct waffle_context *ctx)
{
  struct wcore_display *wc_dpy;
  wc_dpy=wcore_display$link2(dpy);
  struct wcore_window *wc_window;
  wc_window=wcore_window(window);
  struct wcore_context *wc_ctx;
  wc_ctx=wcore_context$link1(ctx);
  struct api_object *obj_list[3l];
  signed int len = 0;
  signed int tmp_post$1 = len;
  len = len + 1;
  struct api_object *tmp_if_expr$2;
  if(!(wc_dpy == ((struct wcore_display *)NULL)))
    tmp_if_expr$2 = &wc_dpy->api;

  else
    tmp_if_expr$2 = (struct api_object *)(void *)0;
  obj_list[(signed long int)tmp_post$1] = tmp_if_expr$2;
  signed int tmp_post$3;
  if(!(wc_window == ((struct wcore_window *)NULL)))
  {
    tmp_post$3 = len;
    len = len + 1;
    obj_list[(signed long int)tmp_post$3] = &wc_window->api;
  }

  signed int tmp_post$4;
  if(!(wc_ctx == ((struct wcore_context *)NULL)))
  {
    tmp_post$4 = len;
    len = len + 1;
    obj_list[(signed long int)tmp_post$4] = &wc_ctx->api;
  }

  _Bool return_value_api_check_entry$5;
  return_value_api_check_entry$5=api_check_entry(obj_list, len);
  if(return_value_api_check_entry$5 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->make_current(api_platform, wc_dpy, wc_window, wc_ctx);
    return return_value;
  }
}

// waffle_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 40
static inline struct waffle_window * waffle_window(struct wcore_window *win)
{
  return (struct waffle_window *)win;
}

// waffle_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 36
struct waffle_window * waffle_window_create(struct waffle_config *config, signed int width, signed int height)
{
  struct wcore_window *wc_self;
  struct wcore_config *wc_config;
  wc_config=wcore_config$link2(config);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_config == ((struct wcore_config *)NULL)))
    tmp_if_expr$1 = &wc_config->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (struct waffle_window *)(void *)0;

  else
  {
    wc_self=api_platform->vtbl->window.create(api_platform, wc_config, width, height);
    if(wc_self == ((struct wcore_window *)NULL))
      return (struct waffle_window *)(void *)0;

    else
    {
      struct waffle_window *return_value_waffle_window$3;
      return_value_waffle_window$3=waffle_window(wc_self);
      return return_value_waffle_window$3;
    }
  }
}

// waffle_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 61
_Bool waffle_window_destroy(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->window.destroy(wc_self);
    return return_value;
  }
}

// waffle_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 130
union waffle_native_window * waffle_window_get_native(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (union waffle_native_window *)(void *)0;

  else
    if(!(api_platform->vtbl->window.get_native == ((union waffle_native_window * (*)(struct wcore_window *))NULL)))
    {
      union waffle_native_window *return_value;
      return_value=api_platform->vtbl->window.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_window *)(void *)0;
    }
}

// waffle_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 91
_Bool waffle_window_resize(struct waffle_window *self, signed int width, signed int height)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
    if(!(api_platform->vtbl->window.resize == ((_Bool (*)(struct wcore_window *, signed int, signed int))NULL)))
    {
      _Bool return_value;
      return_value=api_platform->vtbl->window.resize(wc_self, width, height);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (_Bool)0;
    }
}

// waffle_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 76
_Bool waffle_window_show(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->window.show(wc_self);
    return return_value;
  }
}

// waffle_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 115
_Bool waffle_window_swap_buffers(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window$link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr$1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr$1 = &wc_self->api;

  else
    tmp_if_expr$1 = (struct api_object *)(void *)0;
  obj_list[0] = tmp_if_expr$1;
  _Bool return_value_api_check_entry$2;
  return_value_api_check_entry$2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->window.swap_buffers(wc_self);
    return return_value;
  }
}

// wayland_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 113
static union waffle_native_config * wayland_config_get_native(struct wcore_config *wc_config)
{
  struct wegl_config *config;
  config=wegl_config$link3(wc_config);
  struct wayland_display *dpy;
  dpy=wayland_display$link1(wc_config->display);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_wayland_config) /*40ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc$1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->wayland = (struct waffle_wayland_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    wayland_display_fill_native(dpy, &n_config->wayland->display);
    n_config->wayland->egl_config = config->egl;
    return n_config;
  }
}

// wayland_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 130
static union waffle_native_context * wayland_context_get_native(struct wcore_context *wc_ctx)
{
  struct wayland_display *dpy;
  dpy=wayland_display$link1(wc_ctx->display);
  struct wegl_context *ctx;
  ctx=wegl_context$link2(wc_ctx);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_wayland_context) /*40ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc$1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->wayland = (struct waffle_wayland_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    wayland_display_fill_native(dpy, &n_ctx->wayland->display);
    n_ctx->wayland->egl_context = ctx->egl;
    return n_ctx;
  }
}

// wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display(struct wcore_display *wc_self)
{
  struct wegl_display *tmp_statement_expression$1;
  struct wayland_display *tmp_statement_expression$2;
  if(!(wc_self == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self;
    const struct wcore_display *wayland_display$$1$$1$$1$$__mptr = wc_self;
    tmp_statement_expression$1 = (struct wegl_display *)((void *)wayland_display$$1$$1$$1$$__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression$1;
    const struct wegl_display *__mptr = wegl_self;
    tmp_statement_expression$2 = (struct wayland_display *)((void *)__mptr - (signed long int)32ul);
    return tmp_statement_expression$2;
  }

  else
    return (struct wayland_display *)(void *)0;
}

// wayland_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display$link1(struct wcore_display *wc_self$link1)
{
  struct wegl_display *tmp_statement_expression$1$link1;
  struct wayland_display *tmp_statement_expression$2$link1;
  if(!(wc_self$link1 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self$link1;
    const struct wcore_display *__mptr$link1 = wc_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_display *)((void *)__mptr$link1 - (signed long int)0ul);
    wegl_self$link1 = tmp_statement_expression$1$link1;
    const struct wegl_display *wayland_display$$1$$1$$2$$__mptr$link1 = wegl_self$link1;
    tmp_statement_expression$2$link1 = (struct wayland_display *)((void *)wayland_display$$1$$1$$2$$__mptr$link1 - (signed long int)32ul);
    return tmp_statement_expression$2$link1;
  }

  else
    return (struct wayland_display *)(void *)0;
}

// wayland_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display$link2(struct wcore_display *wc_self$link2)
{
  struct wegl_display *tmp_statement_expression$1$link2;
  struct wayland_display *tmp_statement_expression$2$link2;
  if(!(wc_self$link2 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self$link2;
    const struct wcore_display *wayland_display$$1$$1$$1$$__mptr$link2 = wc_self$link2;
    tmp_statement_expression$1$link2 = (struct wegl_display *)((void *)wayland_display$$1$$1$$1$$__mptr$link2 - (signed long int)0ul);
    wegl_self$link2 = tmp_statement_expression$1$link2;
    const struct wegl_display *__mptr$link2 = wegl_self$link2;
    tmp_statement_expression$2$link2 = (struct wayland_display *)((void *)__mptr$link2 - (signed long int)32ul);
    return tmp_statement_expression$2$link2;
  }

  else
    return (struct wayland_display *)(void *)0;
}

// wayland_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 92
struct wcore_display * wayland_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct wayland_display *self;
  _Bool ok = (_Bool)1;
  signed int error = 0;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct wayland_display) /*64ul*/ );
  self = (struct wayland_display *)return_value_wcore_calloc$1;
  if(self == ((struct wayland_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    self->wl_display=wl_display_connect(name);
    if(self->wl_display == ((struct wl_display *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_display_connect failed");

    else
    {
      self->wl_registry=wl_display_get_registry(self->wl_display);
      if(self->wl_registry == ((struct wl_registry *)NULL))
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_display_get_registry failed");

      else
      {
        error=wl_registry_add_listener(self->wl_registry, &registry_listener, (void *)self);
        if(!(error >= 0))
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_registry_add_listener failed");

        else
        {
          ok=wayland_display_sync(self);
          if(!(ok == (_Bool)0))
          {
            if(self->wl_compositor == ((struct wl_compositor *)NULL))
              wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to bind to the wayland compositor");

            else
              if(self->wl_shell == ((struct wl_shell *)NULL))
                wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to bind to the wayland shell");

              else
              {
                ok=wegl_display_init(&self->wegl, wc_plat, (signed long int)self->wl_display);
                if(!(ok == (_Bool)0))
                  return &self->wegl.wcore;

              }
          }

        }
      }
    }

  error:
    ;
    wayland_display_destroy(&self->wegl.wcore);
    return (struct wcore_display *)(void *)0;
  }
}

// wayland_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 43
_Bool wayland_display_destroy(struct wcore_display *wc_self)
{
  struct wayland_display *self;
  self=wayland_display(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct wayland_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_display_teardown$1;
    return_value_wegl_display_teardown$1=wegl_display_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_display_teardown$1) != 0;
    if(!(self->wl_display == ((struct wl_display *)NULL)))
      wl_display_disconnect(self->wl_display);

    free((void *)self);
    return ok;
  }
}

// wayland_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 155
void wayland_display_fill_native(struct wayland_display *self, struct waffle_wayland_display *n_dpy)
{
  n_dpy->wl_display = self->wl_display;
  n_dpy->wl_compositor = self->wl_compositor;
  n_dpy->wl_shell = self->wl_shell;
  n_dpy->egl_display = self->wegl.egl;
}

// wayland_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 165
union waffle_native_display * wayland_display_get_native(struct wcore_display *wc_self)
{
  struct wayland_display *self;
  self=wayland_display(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_wayland_display) /*32ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc$1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->wayland = (struct waffle_wayland_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    wayland_display_fill_native(self, n_dpy->wayland);
    return n_dpy;
  }
}

// wayland_display_sync
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 180
_Bool wayland_display_sync(struct wayland_display *dpy)
{
  signed int return_value_wl_display_roundtrip$1;
  return_value_wl_display_roundtrip$1=wl_display_roundtrip(dpy->wl_display);
  if(return_value_wl_display_roundtrip$1 == -1)
  {
    wcore_error_errno("error on wl_display");
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// wayland_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 96
static _Bool wayland_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct wayland_platform *self;
  struct wegl_platform$0 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link5(wc_self);
  self=wayland_platform(return_value_wegl_platform$1);
  _Bool return_value_linux_platform_dl_can_open$2;
  return_value_linux_platform_dl_can_open$2=0;//(self->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open$2;
}

// wayland_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 104
static void * wayland_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct wayland_platform *self;
  struct wegl_platform$0 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link5(wc_self);
  self=wayland_platform(return_value_wegl_platform$1);
  void *return_value_linux_platform_dl_sym$2;
  return_value_linux_platform_dl_sym$2=NULL;//(self->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym$2;
}

// wayland_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.h line 45
static inline struct wayland_platform * wayland_platform(struct wegl_platform$0 *wegl_self)
{
  struct wayland_platform *tmp_statement_expression$1;
  if(!(wegl_self == ((struct wegl_platform$0 *)NULL)))
  {
    const struct wegl_platform$0 *__mptr = wegl_self;
    tmp_statement_expression$1 = (struct wayland_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct wayland_platform *)NULL);
}

// wayland_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 34
struct wcore_platform * wayland_platform_create(void)
{
  struct wayland_platform *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct wayland_platform) /*144ul*/ );
  self = (struct wayland_platform *)return_value_wcore_calloc$1;
  if(self == ((struct wayland_platform *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wegl_platform_init(&self->wegl);
    if(!(ok == (_Bool)0))
    {
      /*self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;*/

      setenv("EGL_PLATFORM", "wayland", 1);
      self->wegl.wcore.vtbl = &wayland_platform_vtbl;
      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      wayland_platform_destroy(&self->wegl.wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// wayland_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 49
static _Bool wayland_platform_destroy(struct wcore_platform *wc_self)
{
  struct wayland_platform *self;
  struct wegl_platform$0 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link5(wc_self);
  self=wayland_platform(return_value_wegl_platform$1);
  _Bool ok = (_Bool)1;
  _Bool return_value_linux_platform_destroy$2;
  if(self == ((struct wayland_platform *)NULL))
    return (_Bool)1;

  else
  {
    unsetenv("EGL_PLATFORM");
    /*if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy$2=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy$2) != 0;
    }*/

    _Bool return_value_wegl_platform_teardown$3;
    return_value_wegl_platform_teardown$3=wegl_platform_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_platform_teardown$3) != 0;
    free((void *)self);
    return ok;
  }
}

// wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 48
static inline struct wayland_window * wayland_window(struct wcore_window *wc_self)
{
  struct wegl_window *tmp_statement_expression$1;
  struct wayland_window *tmp_statement_expression$2;
  if(!(wc_self == ((struct wcore_window *)NULL)))
  {
    struct wegl_window *wegl_self;
    const struct wcore_window *__mptr = wc_self;
    tmp_statement_expression$1 = (struct wegl_window *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression$1;
    const struct wegl_window *wayland_window$$1$$1$$2$$__mptr = wegl_self;
    tmp_statement_expression$2 = (struct wayland_window *)((void *)wayland_window$$1$$1$$2$$__mptr - (signed long int)24ul);
    return tmp_statement_expression$2;
  }

  else
    return (struct wayland_window *)(void *)0;
}

// wayland_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 60
struct wcore_window * wayland_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct wayland_window *self;
  struct wayland_display *dpy;
  dpy=wayland_display$link2(wc_config->display);
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct wayland_window) /*48ul*/ );
  self = (struct wayland_window *)return_value_wcore_calloc$1;
  if(self == ((struct wayland_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    if(dpy->wl_compositor == ((struct wl_compositor *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wayland compositor not found");

    else
      if(dpy->wl_shell == ((struct wl_shell *)NULL))
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wayland shell not found");

      else
      {
        self->wl_surface=wl_compositor_create_surface(dpy->wl_compositor);
        if(self->wl_surface == ((struct wl_surface *)NULL))
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_compositor_create_surface failed");

        else
        {
          self->wl_shell_surface=wl_shell_get_shell_surface(dpy->wl_shell, self->wl_surface);
          if(self->wl_shell_surface == ((struct wl_shell_surface *)NULL))
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_shell_get_shell_surface failed");

          else
          {
            wl_shell_surface_add_listener(self->wl_shell_surface, &shell_surface_listener, (void *)0);
            self->wl_window=wl_egl_window_create(self->wl_surface, width, height);
            if(self->wl_window == ((struct wl_egl_window *)NULL))
              wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_egl_window_create failed");

            else
            {
              ok=wegl_window_init(&self->wegl, wc_config, (signed long int)self->wl_window);
              if(!(ok == (_Bool)0))
              {
                ok=wayland_display_sync(dpy);
                if(!(ok == (_Bool)0))
                  return &self->wegl.wcore;

              }

            }
          }
        }
      }

  error:
    ;
    wayland_window_destroy(&self->wegl.wcore);
    return (struct wcore_window *)(void *)0;
  }
}

// wayland_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 66
_Bool wayland_window_destroy(struct wcore_window *wc_self)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct wayland_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_window_teardown$1;
    return_value_wegl_window_teardown$1=wegl_window_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_window_teardown$1) != 0;
    if(!(self->wl_window == ((struct wl_egl_window *)NULL)))
      wl_egl_window_destroy(self->wl_window);

    if(!(self->wl_shell_surface == ((struct wl_shell_surface *)NULL)))
      wl_shell_surface_destroy(self->wl_shell_surface);

    if(!(self->wl_surface == ((struct wl_surface *)NULL)))
      wl_surface_destroy(self->wl_surface);

    free((void *)self);
    return ok;
  }
}

// wayland_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 79
union waffle_native_window * wayland_window_get_native(struct wcore_window *wc_self)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  struct wayland_display *dpy;
  dpy=wayland_display$link2(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_wayland_window) /*64ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc$1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->wayland = (struct waffle_wayland_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    wayland_display_fill_native(dpy, &n_window->wayland->display);
    n_window->wayland->wl_surface = self->wl_surface;
    n_window->wayland->wl_shell_surface = self->wl_shell_surface;
    n_window->wayland->wl_window = self->wl_window;
    n_window->wayland->egl_surface = self->wegl.egl;
    return n_window;
  }
}

// wayland_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 75
_Bool wayland_window_resize(struct wcore_window *wc_self, signed int width, signed int height)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  struct wayland_display *dpy;
  dpy=wayland_display$link2(self->wegl.wcore.display);
  struct wayland_window *return_value_wayland_window$1;
  return_value_wayland_window$1=wayland_window(wc_self);
  wl_egl_window_resize(return_value_wayland_window$1->wl_window, width, height, 0, 0);
  _Bool return_value_wayland_display_sync$2;
  return_value_wayland_display_sync$2=wayland_display_sync(dpy);
  if(return_value_wayland_display_sync$2 == (_Bool)0)
    return (_Bool)0;

  else
    return (_Bool)1;
}

// wayland_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 69
_Bool wayland_window_show(struct wcore_window *wc_self)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  struct wayland_display *dpy;
  dpy=wayland_display$link2(wc_self->display);
  _Bool ok = (_Bool)1;
  wl_shell_surface_set_toplevel(self->wl_shell_surface);
  ok=wayland_display_sync(dpy);
  if(ok == (_Bool)0)
    return (_Bool)0;

  else
    return (_Bool)1;
}

// wayland_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 72
_Bool wayland_window_swap_buffers(struct wcore_window *wc_self)
{
  struct wayland_display *dpy;
  dpy=wayland_display$link2(wc_self->display);
  _Bool ok;
  ok=wegl_window_swap_buffers(wc_self);
  if(ok == (_Bool)0)
    return (_Bool)0;

  else
  {
    ok=wayland_display_sync(dpy);
    if(ok == (_Bool)0)
      return (_Bool)0;

    else
      return (_Bool)1;
  }
}

// wcore_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 35
_Bool wcore_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value)
{
  if(attrib_list == ((const signed int *)NULL))
    return (_Bool)0;

  else
  {
    signed int i = 0;
    for( ; !(attrib_list[(signed long int)i] == 0); i = i + 2)
      if(attrib_list[(signed long int)i] == key)
      {
        *value = attrib_list[(signed long int)(i + 1)];
        return (_Bool)1;
      }

    return (_Bool)0;
  }
}

// wcore_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 41
_Bool wcore_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value)
{
  _Bool return_value_wcore_attrib_list_get$1;
  return_value_wcore_attrib_list_get$1=wcore_attrib_list_get(attrib_list, key, value);
  if(!(return_value_wcore_attrib_list_get$1 == (_Bool)0))
    return (_Bool)1;

  else
  {
    *value = default_value;
    return (_Bool)0;
  }
}

// wcore_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 32
signed int wcore_attrib_list_length(const signed int *attrib_list)
{
  const signed int *i = attrib_list;
  if(attrib_list == ((const signed int *)NULL))
    return 0;

  else
  {
    for( ; !(*i == 0); i = i + (signed long int)2)
      ;
    return (signed int)(i - attrib_list) / 2;
  }
}

// wcore_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 48
_Bool wcore_attrib_list_update(signed int *attrib_list, signed int key, signed int value)
{
  signed int *i = attrib_list;
  if(attrib_list == ((signed int *)NULL))
    return (_Bool)0;

  else
  {
    for( ; !(*i == 0); i = i + (signed long int)2)
      if(*i == key)
        break;

    if(*i == key)
    {
      i[(signed long int)1] = value;
      return (_Bool)1;
    }

    else
      return (_Bool)0;
  }
}

// wcore_calloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 41
void * wcore_calloc(unsigned long int size)
{
  void *p;
  p=calloc((unsigned long int)1, size);
  if(p == NULL)
    wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_ALLOC);

  return p;
}

// wcore_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config(struct waffle_config *cfg)
{
  return (struct wcore_config *)cfg;
}

// wcore_config$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config$link1(struct waffle_config *cfg$link1)
{
  return (struct wcore_config *)cfg$link1;
}

// wcore_config$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config$link2(struct waffle_config *cfg$link2)
{
  return (struct wcore_config *)cfg$link2;
}

// wcore_config_attrs_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.h line 59
_Bool wcore_config_attrs_parse(const signed int *waffle_attrib_list, struct wcore_config_attrs *attrs)
{
  memset((void *)attrs, 0, sizeof(struct wcore_config_attrs) /*60ul*/ );
  _Bool return_value_check_keys$1;
  return_value_check_keys$1=check_keys(waffle_attrib_list);
  if(return_value_check_keys$1 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value_parse_context_api$2;
    return_value_parse_context_api$2=parse_context_api(attrs, waffle_attrib_list);
    if(return_value_parse_context_api$2 == (_Bool)0)
      return (_Bool)0;

    else
    {
      _Bool return_value_set_context_version_default$3;
      return_value_set_context_version_default$3=set_context_version_default(attrs);
      if(return_value_set_context_version_default$3 == (_Bool)0)
        return (_Bool)0;

      else
      {
        _Bool return_value_parse_context_version$4;
        return_value_parse_context_version$4=parse_context_version(attrs, waffle_attrib_list);
        if(return_value_parse_context_version$4 == (_Bool)0)
          return (_Bool)0;

        else
        {
          _Bool return_value_set_context_profile_default$5;
          return_value_set_context_profile_default$5=set_context_profile_default(attrs);
          if(return_value_set_context_profile_default$5 == (_Bool)0)
            return (_Bool)0;

          else
          {
            _Bool return_value_parse_context_profile$6;
            return_value_parse_context_profile$6=parse_context_profile(attrs, waffle_attrib_list);
            if(return_value_parse_context_profile$6 == (_Bool)0)
              return (_Bool)0;

            else
            {
              _Bool return_value_parse_context_forward_compatible$7;
              return_value_parse_context_forward_compatible$7=parse_context_forward_compatible(attrs, waffle_attrib_list);
              if(return_value_parse_context_forward_compatible$7 == (_Bool)0)
                return (_Bool)0;

              else
              {
                _Bool return_value_set_misc_defaults$8;
                return_value_set_misc_defaults$8=set_misc_defaults(attrs);
                if(return_value_set_misc_defaults$8 == (_Bool)0)
                  return (_Bool)0;

                else
                {
                  _Bool return_value_parse_misc$9;
                  return_value_parse_misc$9=parse_misc(attrs, waffle_attrib_list);
                  if(return_value_parse_misc$9 == (_Bool)0)
                    return (_Bool)0;

                  else
                  {
                    _Bool return_value_check_final$10;
                    return_value_check_final$10=check_final(attrs);
                    if(return_value_check_final$10 == (_Bool)0)
                      return (_Bool)0;

                    else
                      return (_Bool)1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// wcore_config_attrs_version_eq
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 512
_Bool wcore_config_attrs_version_eq(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool tmp_if_expr$1;
  if(attrs->context_major_version == merged_version / 10)
    tmp_if_expr$1 = attrs->context_minor_version == merged_version % 10 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// wcore_config_attrs_version_ge
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 533
_Bool wcore_config_attrs_version_ge(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(merged_version / 10 >= attrs->context_major_version))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(attrs->context_major_version == merged_version / 10)
      tmp_if_expr$1 = attrs->context_minor_version >= merged_version % 10 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr$2;
}

// wcore_config_attrs_version_gt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 522
_Bool wcore_config_attrs_version_gt(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(merged_version / 10 >= attrs->context_major_version))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(attrs->context_major_version == merged_version / 10)
      tmp_if_expr$1 = attrs->context_minor_version > merged_version % 10 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr$2;
}

// wcore_config_attrs_version_le
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 552
_Bool wcore_config_attrs_version_le(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool return_value_wcore_config_attrs_version_gt$1;
  return_value_wcore_config_attrs_version_gt$1=wcore_config_attrs_version_gt(attrs, merged_version);
  return !(return_value_wcore_config_attrs_version_gt$1 != (_Bool)0);
}

// wcore_config_attrs_version_lt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 544
_Bool wcore_config_attrs_version_lt(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool return_value_wcore_config_attrs_version_ge$1;
  return_value_wcore_config_attrs_version_ge$1=wcore_config_attrs_version_ge(attrs, merged_version);
  return !(return_value_wcore_config_attrs_version_ge$1 != (_Bool)0);
}

// wcore_config_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init(struct wcore_config *self, struct wcore_display *display, struct wcore_config_attrs *attrs)
{
  self->api.display_id = display->api.display_id;
  self->display = display;
  memcpy((void *)&self->attrs, (const void *)attrs, sizeof(struct wcore_config_attrs) /*60ul*/ );
  return (_Bool)1;
}

// wcore_config_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init$link1(struct wcore_config *self$link1, struct wcore_display *display$link1, struct wcore_config_attrs *attrs$link1)
{
  self$link1->api.display_id = display$link1->api.display_id;
  self$link1->display = display$link1;
  memcpy((void *)&self$link1->attrs, (const void *)attrs$link1, sizeof(struct wcore_config_attrs) /*60ul*/ );
  return (_Bool)1;
}

// wcore_config_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown(struct wcore_config *self)
{
  return (_Bool)1;
}

// wcore_config_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown$link1(struct wcore_config *self$link1)
{
  return (_Bool)1;
}

// wcore_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context(struct waffle_context *ctx)
{
  return (struct wcore_context *)ctx;
}

// wcore_context$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context$link1(struct waffle_context *ctx$link1)
{
  return (struct wcore_context *)ctx$link1;
}

// wcore_context_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init(struct wcore_context *self, struct wcore_config *config)
{
  self->api.display_id = config->display->api.display_id;
  self->display = config->display;
  return (_Bool)1;
}

// wcore_context_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init$link1(struct wcore_context *self$link1, struct wcore_config *config$link1)
{
  self$link1->api.display_id = config$link1->display->api.display_id;
  self$link1->display = config$link1->display;
  return (_Bool)1;
}

// wcore_context_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown(struct wcore_context *self)
{
  return (_Bool)1;
}

// wcore_context_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown$link1(struct wcore_context *self$link1)
{
  return (_Bool)1;
}

// wcore_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display(struct waffle_display *dpy)
{
  return (struct wcore_display *)dpy;
}

// wcore_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display$link1(struct waffle_display *dpy$link1)
{
  return (struct wcore_display *)dpy$link1;
}

// wcore_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display$link2(struct waffle_display *dpy$link2)
{
  return (struct wcore_display *)dpy$link2;
}

// wcore_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 33
_Bool wcore_display_init(struct wcore_display *self, struct wcore_platform *platform)
{
  static union anonymous mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  mtx_lock(&mutex);
  static unsigned long int id_counter = (unsigned long int)0;
  id_counter = id_counter + 1ul;
  self->api.display_id = id_counter;
  mtx_unlock(&mutex);
  self->platform = platform;
  if(self->api.display_id == 0ul)
  {
    fprintf(stderr, "waffle: error: internal counter wrapped to 0\n");
    abort();
  }

  return (_Bool)1;
}

// wcore_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 57
_Bool wcore_display_teardown(struct wcore_display *self)
{
  return (_Bool)1;
}

// wcore_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.h line 82
const char * wcore_enum_to_string(signed int e)
{
  switch(e)
  {
    case -1:
      return "WAFFLE_DONT_CARE";
    case 0:
      return "WAFFLE_NONE";
    case 16:
      return "WAFFLE_PLATFORM";
    case 17:
      return "WAFFLE_PLATFORM_ANDROID";
    case 18:
      return "WAFFLE_PLATFORM_CGL";
    case 19:
      return "WAFFLE_PLATFORM_GLX";
    case 20:
      return "WAFFLE_PLATFORM_WAYLAND";
    case 21:
      return "WAFFLE_PLATFORM_X11_EGL";
    case 22:
      return "WAFFLE_PLATFORM_GBM";
    case 23:
      return "WAFFLE_PLATFORM_WGL";
    case 522:
      return "WAFFLE_CONTEXT_API";
    case 523:
      return "WAFFLE_CONTEXT_OPENGL";
    case 524:
      return "WAFFLE_CONTEXT_OPENGL_ES1";
    case 525:
      return "WAFFLE_CONTEXT_OPENGL_ES2";
    case 532:
      return "WAFFLE_CONTEXT_OPENGL_ES3";
    case 526:
      return "WAFFLE_CONTEXT_MAJOR_VERSION";
    case 527:
      return "WAFFLE_CONTEXT_MINOR_VERSION";
    case 528:
      return "WAFFLE_CONTEXT_PROFILE";
    case 529:
      return "WAFFLE_CONTEXT_CORE_PROFILE";
    case 530:
      return "WAFFLE_CONTEXT_COMPATIBILITY_PROFILE";
    case 533:
      return "WAFFLE_CONTEXT_FORWARD_COMPATIBLE";
    case 534:
      return "WAFFLE_CONTEXT_DEBUG";
    case 513:
      return "WAFFLE_RED_SIZE";
    case 514:
      return "WAFFLE_GREEN_SIZE";
    case 515:
      return "WAFFLE_BLUE_SIZE";
    case 516:
      return "WAFFLE_ALPHA_SIZE";
    case 517:
      return "WAFFLE_DEPTH_SIZE";
    case 518:
      return "WAFFLE_STENCIL_SIZE";
    case 519:
      return "WAFFLE_SAMPLE_BUFFERS";
    case 520:
      return "WAFFLE_SAMPLES";
    case 521:
      return "WAFFLE_DOUBLE_BUFFERED";
    case 531:
      return "WAFFLE_ACCUM_BUFFER";
    case 769:
      return "WAFFLE_DL_OPENGL";
    case 770:
      return "WAFFLE_DL_OPENGL_ES1";
    case 771:
      return "WAFFLE_DL_OPENGL_ES2";
    case 772:
      return "WAFFLE_DL_OPENGL_ES3";
    default:
      return (const char *)(void *)0;
  }
}

// wcore_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 49
void wcore_error(enum waffle_error error)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get$1->error;
  if(!(t->is_enabled == (_Bool)0))
  {
    if((signed int)t->code == WAFFLE_NO_ERROR)
    {
      t->code = error;
      t->message[(signed long int)0] = (char)0;
    }

  }

}

// wcore_error_errno
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 137
void wcore_error_errno(const char *format, ...)
{
  signed int saved_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  saved_errno = *return_value___errno_location$1;
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get$2;
  return_value_wcore_tinfo_get$2=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get$2->error;
  char *cur = t->message;
  char *end = t->message + (signed long int)1024;
  signed int printed;
  if(!(t->is_enabled == (_Bool)0))
  {
    t->code = (enum waffle_error)WAFFLE_ERROR_UNKNOWN;
    if(!(format == ((const char *)NULL)))
    {
      void **ap = (void **)&format;
      printed=vsnprintf(cur, (unsigned long int)(end - cur), format, ap);
      cur = cur + (signed long int)printed;
      ap = ((void **)NULL);
      if(cur >= end || !(printed >= 0))
        goto __CPROVER_DUMP_L5;

      printed=snprintf(cur, (unsigned long int)(end - cur), ": ");
      cur = cur + (signed long int)printed;
      if(cur >= end || !(printed >= 0))
        goto __CPROVER_DUMP_L5;

    }

    strerror_r(saved_errno, cur, (unsigned long int)(end - cur));
  }


__CPROVER_DUMP_L5:
  ;
}

// wcore_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 80
enum waffle_error wcore_error_get_code(void)
{
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  return return_value_wcore_tinfo_get$1->error->code;
}

// wcore_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 84
struct waffle_error_info * wcore_error_get_info(void)
{
  struct wcore_error_tinfo *info;
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  info = return_value_wcore_tinfo_get$1->error;
  info->user_info.code = info->code;
  info->user_info.message = info->message;
  info->user_info.message_length=strlen(info->message);
  return &info->user_info;
}

// wcore_error_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 43
void wcore_error_reset(void)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get$1->error;
  if(!(t->is_enabled == (_Bool)0))
  {
    t->code = (enum waffle_error)WAFFLE_NO_ERROR;
    t->message[(signed long int)0] = (char)0;
  }

}

// wcore_error_tinfo_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 51
struct wcore_error_tinfo * wcore_error_tinfo_create(void)
{
  struct wcore_error_tinfo *self;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct wcore_error_tinfo) /*1056ul*/ );
  self = (struct wcore_error_tinfo *)return_value_malloc$1;
  if(self == ((struct wcore_error_tinfo *)NULL))
    return (struct wcore_error_tinfo *)(void *)0;

  else
  {
    self->is_enabled = (_Bool)1;
    self->code = (enum waffle_error)WAFFLE_NO_ERROR;
    self->message[(signed long int)0] = (char)0;
    return self;
  }
}

// wcore_error_tinfo_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 65
_Bool wcore_error_tinfo_destroy(struct wcore_error_tinfo *self)
{
  free((void *)self);
  return (_Bool)1;
}

// wcore_errorf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 56
void wcore_errorf(enum waffle_error error, const char *format, ...)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get$1;
  return_value_wcore_tinfo_get$1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get$1->error;
  void **ap;
  if(!(t->is_enabled == (_Bool)0))
  {
    if((signed int)t->code == WAFFLE_NO_ERROR)
    {
      t->code = error;
      ap = (void **)&format;
      vsnprintf(t->message, (unsigned long int)(1024 - 1), format, ap);
      ap = ((void **)NULL);
    }

  }

}

// wcore_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 32
void * wcore_malloc(unsigned long int size)
{
  void *p;
  p=malloc(size);
  if(p == NULL)
    wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_ALLOC);

  return p;
}

// wcore_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init(struct wcore_platform *self)
{
  return (_Bool)1;
}

// wcore_platform_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init$link1(struct wcore_platform *self$link1)
{
  return (_Bool)1;
}

// wcore_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown(struct wcore_platform *self)
{
  return (_Bool)1;
}

// wcore_platform_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown$link1(struct wcore_platform *self$link1)
{
  return (_Bool)1;
}

// wcore_tinfo_abort_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 66
static void wcore_tinfo_abort_init(void)
{
  printf("waffle: fatal-error: failed to initialize thread local info\n");
  abort();
}

// wcore_tinfo_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.h line 39
struct wcore_tinfo * wcore_tinfo_get(void)
{
  wcore_tinfo_init(&wcore_tinfo);
  return &wcore_tinfo;
}

// wcore_tinfo_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 97
static void wcore_tinfo_init(struct wcore_tinfo *tinfo)
{
  signed int err;
  if(tinfo->is_init == (_Bool)0)
  {
    tinfo->error=wcore_error_tinfo_create();
    if(tinfo->error == ((struct wcore_error_tinfo *)NULL))
      wcore_tinfo_abort_init();

    tinfo->is_init = (_Bool)1;
    call_once(&wcore_tinfo_once, wcore_tinfo_key_create);
    err=tss_set(wcore_tinfo_key, (void *)tinfo);
    if(!(err == 0))
      wcore_tinfo_abort_init();

  }

}

// wcore_tinfo_key_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 87
static void wcore_tinfo_key_create(void)
{
  signed int err;
  err=tss_create(&wcore_tinfo_key, wcore_tinfo_key_dtor);
  if(!(err == 0))
    wcore_tinfo_abort_init();

}

// wcore_tinfo_key_dtor
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 73
static void wcore_tinfo_key_dtor(void *args)
{
  struct wcore_tinfo *tinfo = (struct wcore_tinfo *)args;
  if(!(tinfo == ((struct wcore_tinfo *)NULL)))
    wcore_error_tinfo_destroy(tinfo->error);

}

// wcore_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window(struct waffle_window *win)
{
  return (struct wcore_window *)win;
}

// wcore_window$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window$link1(struct waffle_window *win$link1)
{
  return (struct wcore_window *)win$link1;
}

// wcore_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init(struct wcore_window *self, struct wcore_config *config)
{
  self->api.display_id = config->display->api.display_id;
  self->display = config->display;
  return (_Bool)1;
}

// wcore_window_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init$link1(struct wcore_window *self$link1, struct wcore_config *config$link1)
{
  self$link1->api.display_id = config$link1->display->api.display_id;
  self$link1->display = config$link1->display;
  return (_Bool)1;
}

// wcore_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown(struct wcore_window *self)
{
  return (_Bool)1;
}

// wcore_window_teardown$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown$link1(struct wcore_window *self$link1)
{
  return (_Bool)1;
}

// wegl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config(struct wcore_config *wcore_self)
{
  struct wegl_config *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct wegl_config *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link1(struct wcore_config *wcore_self$link1)
{
  struct wegl_config *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_config *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link2(struct wcore_config *wcore_self$link2)
{
  struct wegl_config *tmp_statement_expression$1$link2;
  if(!(wcore_self$link2 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link2 = wcore_self$link2;
    tmp_statement_expression$1$link2 = (struct wegl_config *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link3(struct wcore_config *wcore_self$link3)
{
  struct wegl_config *tmp_statement_expression$1$link3;
  if(!(wcore_self$link3 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link3 = wcore_self$link3;
    tmp_statement_expression$1$link3 = (struct wegl_config *)((void *)__mptr$link3 - (signed long int)0ul);
    return tmp_statement_expression$1$link3;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link4(struct wcore_config *wcore_self$link4)
{
  struct wegl_config *tmp_statement_expression$1$link4;
  if(!(wcore_self$link4 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link4 = wcore_self$link4;
    tmp_statement_expression$1$link4 = (struct wegl_config *)((void *)__mptr$link4 - (signed long int)0ul);
    return tmp_statement_expression$1$link4;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config$link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link5(struct wcore_config *wcore_self$link5)
{
  struct wegl_config *tmp_statement_expression$1$link5;
  if(!(wcore_self$link5 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link5 = wcore_self$link5;
    tmp_statement_expression$1$link5 = (struct wegl_config *)((void *)__mptr$link5 - (signed long int)0ul);
    return tmp_statement_expression$1$link5;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config$link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config$link6(struct wcore_config *wcore_self$link6)
{
  struct wegl_config *tmp_statement_expression$1$link6;
  if(!(wcore_self$link6 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr$link6 = wcore_self$link6;
    tmp_statement_expression$1$link6 = (struct wegl_config *)((void *)__mptr$link6 - (signed long int)0ul);
    return tmp_statement_expression$1$link6;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 210
struct wcore_config * wegl_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs)
{
  struct wegl_display *dpy;
  dpy=wegl_display(wc_dpy);
  struct wegl_config *config;
  _Bool ok;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct wegl_config) /*88ul*/ );
  config = (struct wegl_config *)return_value_wcore_calloc$1;
  _Bool return_value_check_context_attrs$2;
  if(config == ((struct wegl_config *)NULL))
    return (struct wcore_config *)(void *)0;

  else
  {
    ok=wcore_config_init(&config->wcore, wc_dpy, attrs);
    if(!(ok == (_Bool)0))
    {
      return_value_check_context_attrs$2=check_context_attrs(dpy, attrs);
      if(return_value_check_context_attrs$2 == (_Bool)0)
        goto fail;

      config->egl=choose_real_config(dpy, attrs);
      if(config->egl == NULL)
        goto fail;

      return &config->wcore;
    }

    else
    {

    fail:
      ;
      wegl_config_destroy(&config->wcore);
      return (struct wcore_config *)(void *)0;
    }
  }
}

// wegl_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 241
_Bool wegl_config_destroy(struct wcore_config *wc_config)
{
  struct wegl_config *config;
  config=wegl_config(wc_config);
  _Bool result = (_Bool)1;
  if(config == ((struct wegl_config *)NULL))
    return (_Bool)1;

  else
  {
    _Bool return_value_wcore_config_teardown$1;
    return_value_wcore_config_teardown$1=wcore_config_teardown(wc_config);
    result = ((signed int)result & (signed int)return_value_wcore_config_teardown$1) != 0;
    free((void *)config);
    return result;
  }
}

// wegl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context(struct wcore_context *wcore_self)
{
  struct wegl_context *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct wegl_context *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link1(struct wcore_context *wcore_self$link1)
{
  struct wegl_context *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_context *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link2(struct wcore_context *wcore_self$link2)
{
  struct wegl_context *tmp_statement_expression$1$link2;
  if(!(wcore_self$link2 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr$link2 = wcore_self$link2;
    tmp_statement_expression$1$link2 = (struct wegl_context *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link3(struct wcore_context *wcore_self$link3)
{
  struct wegl_context *tmp_statement_expression$1$link3;
  if(!(wcore_self$link3 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr$link3 = wcore_self$link3;
    tmp_statement_expression$1$link3 = (struct wegl_context *)((void *)__mptr$link3 - (signed long int)0ul);
    return tmp_statement_expression$1$link3;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context$link4(struct wcore_context *wcore_self$link4)
{
  struct wegl_context *tmp_statement_expression$1$link4;
  if(!(wcore_self$link4 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr$link4 = wcore_self$link4;
    tmp_statement_expression$1$link4 = (struct wegl_context *)((void *)__mptr$link4 - (signed long int)0ul);
    return tmp_statement_expression$1$link4;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 160
struct wcore_context * wegl_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx)
{
  struct wegl_context *ctx;
  struct wegl_config *config;
  config=wegl_config$link1(wc_config);
  struct wegl_context *share_ctx;
  share_ctx=wegl_context(wc_share_ctx);
  _Bool ok;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct wegl_context) /*24ul*/ );
  ctx = (struct wegl_context *)return_value_wcore_calloc$1;
  void *tmp_if_expr$2;
  if(ctx == ((struct wegl_context *)NULL))
    return (struct wcore_context *)(void *)0;

  else
  {
    ok=wcore_context_init(&ctx->wcore, &config->wcore);
    if(!(ok == (_Bool)0))
    {
      if(!(share_ctx == ((struct wegl_context *)NULL)))
        tmp_if_expr$2 = share_ctx->egl;

      else
        tmp_if_expr$2 = (void *)0;
      ctx->egl=create_real_context(config, tmp_if_expr$2);
      if(ctx->egl == NULL)
        goto fail;

      return &ctx->wcore;
    }

    else
    {

    fail:
      ;
      wegl_context_destroy(&ctx->wcore);
      return (struct wcore_context *)(void *)0;
    }
  }
}

// wegl_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 192
_Bool wegl_context_destroy(struct wcore_context *wc_ctx)
{
  struct wegl_display *dpy;
  dpy=wegl_display$link1(wc_ctx->display);
  struct wegl_platform *plat;
  plat=wegl_platform$link1(dpy->wcore.platform);
  struct wegl_context *ctx;
  _Bool result = (_Bool)1;
  if(wc_ctx == ((struct wcore_context *)NULL))
    return result;

  else
  {
    ctx=wegl_context(wc_ctx);
    if(!(ctx->egl == NULL))
    {
      _Bool ok;
      struct wegl_display *return_value_wegl_display$1;
      return_value_wegl_display$1=wegl_display$link1(wc_ctx->display);
      unsigned int return_value;
      return_value=plat->eglDestroyContext(return_value_wegl_display$1->egl, ctx->egl);
      ok = (_Bool)return_value;
      if(ok == (_Bool)0)
      {
        wegl_emit_error(plat, "eglDestroyContext");
        result = (_Bool)0;
      }

    }

    _Bool return_value_wcore_context_teardown$2;
    return_value_wcore_context_teardown$2=wcore_context_teardown(wc_ctx);
    result = ((signed int)result & (signed int)return_value_wcore_context_teardown$2) != 0;
    free((void *)ctx);
    return result;
  }
}

// wegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display(struct wcore_display *wcore_self)
{
  struct wegl_display *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct wegl_display *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link1(struct wcore_display *wcore_self$link1)
{
  struct wegl_display *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_display *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link2(struct wcore_display *wcore_self$link2)
{
  struct wegl_display *tmp_statement_expression$1$link2;
  if(!(wcore_self$link2 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link2 = wcore_self$link2;
    tmp_statement_expression$1$link2 = (struct wegl_display *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link3(struct wcore_display *wcore_self$link3)
{
  struct wegl_display *tmp_statement_expression$1$link3;
  if(!(wcore_self$link3 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link3 = wcore_self$link3;
    tmp_statement_expression$1$link3 = (struct wegl_display *)((void *)__mptr$link3 - (signed long int)0ul);
    return tmp_statement_expression$1$link3;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display$link4(struct wcore_display *wcore_self$link4)
{
  struct wegl_display *tmp_statement_expression$1$link4;
  if(!(wcore_self$link4 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr$link4 = wcore_self$link4;
    tmp_statement_expression$1$link4 = (struct wegl_display *)((void *)__mptr$link4 - (signed long int)0ul);
    return tmp_statement_expression$1$link4;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 60
_Bool wegl_display_init(struct wegl_display *dpy, struct wcore_platform *wc_plat, signed long int native_display)
{
  struct wegl_platform *plat;
  plat=wegl_platform$link2(wc_plat);
  _Bool ok;
  signed int major;
  signed int minor;
  ok=wcore_display_init(&dpy->wcore, wc_plat);
  unsigned int return_value;
  if(!(ok == (_Bool)0))
  {
    dpy->egl=plat->eglGetDisplay((struct _XDisplay *)native_display);
    if(dpy->egl == NULL)
      wegl_emit_error(plat, "eglGetDisplay");

    return_value=plat->eglInitialize(dpy->egl, &major, &minor);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
      wegl_emit_error(plat, "eglInitialize");

    ok=get_extensions(dpy);
    return (_Bool)1;
  }

  else
  {

  fail:
    ;
    wegl_display_teardown(dpy);
    return (_Bool)0;
  }
}

// wegl_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 111
_Bool wegl_display_supports_context_api(struct wcore_display *wc_dpy, signed int waffle_context_api)
{
  struct wegl_display *dpy;
  dpy=wegl_display$link2(wc_dpy);
  struct wcore_platform *wc_plat = dpy->wcore.platform;
  signed int waffle_dl;
  switch(waffle_context_api)
  {
    case 523:
    {
      waffle_dl = 769;
      break;
    }
    case 524:
    {
      waffle_dl = 770;
      break;
    }
    case 525:
    {
      waffle_dl = 771;
      break;
    }
    case 532:
    {
      if(dpy->KHR_create_context == (_Bool)0)
        return (_Bool)0;

      waffle_dl = 772;
      break;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c", 136, "waffle_context_api has bad value %#x", waffle_context_api);
      return (_Bool)0;
    }
  }
  _Bool return_value;
  return_value=wc_plat->vtbl->dl_can_open(wc_plat, waffle_dl);
  return return_value;
}

// wegl_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 96
_Bool wegl_display_teardown(struct wegl_display *dpy)
{
  struct wegl_platform *plat;
  plat=wegl_platform$link2(dpy->wcore.platform);
  _Bool ok = (_Bool)1;
  if(!(dpy->egl == NULL))
  {
    unsigned int return_value;
    return_value=plat->eglTerminate(dpy->egl);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
      wegl_emit_error(plat, "eglTerminate");

  }

  return ok;
}

// wegl_emit_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.h line 42
void wegl_emit_error(struct wegl_platform *plat, const char *egl_func_call)
{
  signed int egl_error_code;
  egl_error_code=plat->eglGetError();
  const char *egl_error_name;
  if(egl_error_code == 0)
  {
    egl_error_name = "EGL_FALSE";
    egl_error_name = "EGL_TRUE";
    egl_error_name = "EGL_DONT_CARE";
    egl_error_name = "EGL_SUCCESS";
    egl_error_name = "EGL_NOT_INITIALIZED";
    egl_error_name = "EGL_BAD_ACCESS";
    egl_error_name = "EGL_BAD_ALLOC";
    egl_error_name = "EGL_BAD_ATTRIBUTE";
    egl_error_name = "EGL_BAD_CONFIG";
    egl_error_name = "EGL_BAD_CONTEXT";
    egl_error_name = "EGL_BAD_CURRENT_SURFACE";
    egl_error_name = "EGL_BAD_DISPLAY";
    egl_error_name = "EGL_BAD_MATCH";
    egl_error_name = "EGL_BAD_NATIVE_PIXMAP";
    egl_error_name = "EGL_BAD_NATIVE_WINDOW";
    egl_error_name = "EGL_BAD_PARAMETER";
    egl_error_name = "EGL_BAD_SURFACE";
    egl_error_name = "EGL_CONTEXT_LOST";
  }

  egl_error_name = "";
  wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "%s failed with error %s(0x%x)", egl_func_call, egl_error_name, egl_error_code);
}

// wegl_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 95
void * wegl_get_proc_address(struct wcore_platform *wc_self, const char *name)
{
  struct wegl_platform *self;
  self=wegl_platform$link3(wc_self);
  void (*return_value)(void);
  return_value=self->eglGetProcAddress(name);
  return (void *)return_value;
}

// wegl_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 73
_Bool wegl_make_current(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx)
{
  struct wegl_platform *plat;
  plat=wegl_platform$link3(wc_plat);
  void *surface;
  void *tmp_if_expr$2;
  struct wegl_window *return_value_wegl_window$1;
  if(!(wc_window == ((struct wcore_window *)NULL)))
  {
    return_value_wegl_window$1=wegl_window(wc_window);
    tmp_if_expr$2 = return_value_wegl_window$1->egl;
  }

  else
    tmp_if_expr$2 = (void *)0;
  surface = tmp_if_expr$2;
  _Bool ok;
  struct wegl_display *return_value_wegl_display$3;
  return_value_wegl_display$3=wegl_display$link3(wc_dpy);
  void *tmp_if_expr$5;
  struct wegl_context *return_value_wegl_context$4;
  if(!(wc_ctx == ((struct wcore_context *)NULL)))
  {
    return_value_wegl_context$4=wegl_context$link1(wc_ctx);
    tmp_if_expr$5 = return_value_wegl_context$4->egl;
  }

  else
    tmp_if_expr$5 = (void *)0;
  unsigned int return_value;
  return_value=plat->eglMakeCurrent(return_value_wegl_display$3->egl, surface, surface, tmp_if_expr$5);
  ok = (_Bool)return_value;
  if(ok == (_Bool)0)
    wegl_emit_error(plat, "eglMakeCurrent");

  return ok;
}

// wegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform(struct wcore_platform *wcore_self)
{
  struct wegl_platform *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct wegl_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link1(struct wcore_platform *wcore_self$link1)
{
  struct wegl_platform *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_platform *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link10
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link10(struct wcore_platform *wcore_self$link10)
{
  struct wegl_platform *tmp_statement_expression$1$link10;
  if(!(wcore_self$link10 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link10 = wcore_self$link10;
    tmp_statement_expression$1$link10 = (struct wegl_platform *)((void *)__mptr$link10 - (signed long int)0ul);
    return tmp_statement_expression$1$link10;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link11
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform$2 * wegl_platform$link11(struct wcore_platform *wcore_self$link11)
{
  struct wegl_platform$2 *tmp_statement_expression$1$link11;
  if(!(wcore_self$link11 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link11 = wcore_self$link11;
    tmp_statement_expression$1$link11 = (struct wegl_platform$2 *)((void *)__mptr$link11 - (signed long int)0ul);
    return tmp_statement_expression$1$link11;
  }

  else
    return ((struct wegl_platform$2 *)NULL);
}

// wegl_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link2(struct wcore_platform *wcore_self$link2)
{
  struct wegl_platform *tmp_statement_expression$1$link2;
  if(!(wcore_self$link2 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link2 = wcore_self$link2;
    tmp_statement_expression$1$link2 = (struct wegl_platform *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link3(struct wcore_platform *wcore_self$link3)
{
  struct wegl_platform *tmp_statement_expression$1$link3;
  if(!(wcore_self$link3 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link3 = wcore_self$link3;
    tmp_statement_expression$1$link3 = (struct wegl_platform *)((void *)__mptr$link3 - (signed long int)0ul);
    return tmp_statement_expression$1$link3;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link4(struct wcore_platform *wcore_self$link4)
{
  struct wegl_platform *tmp_statement_expression$1$link4;
  if(!(wcore_self$link4 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link4 = wcore_self$link4;
    tmp_statement_expression$1$link4 = (struct wegl_platform *)((void *)__mptr$link4 - (signed long int)0ul);
    return tmp_statement_expression$1$link4;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform$0 * wegl_platform$link5(struct wcore_platform *wcore_self$link5)
{
  struct wegl_platform$0 *tmp_statement_expression$1$link5;
  if(!(wcore_self$link5 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link5 = wcore_self$link5;
    tmp_statement_expression$1$link5 = (struct wegl_platform$0 *)((void *)__mptr$link5 - (signed long int)0ul);
    return tmp_statement_expression$1$link5;
  }

  else
    return ((struct wegl_platform$0 *)NULL);
}

// wegl_platform$link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link6(struct wcore_platform *wcore_self$link6)
{
  struct wegl_platform *tmp_statement_expression$1$link6;
  if(!(wcore_self$link6 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link6 = wcore_self$link6;
    tmp_statement_expression$1$link6 = (struct wegl_platform *)((void *)__mptr$link6 - (signed long int)0ul);
    return tmp_statement_expression$1$link6;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link7
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link7(struct wcore_platform *wcore_self$link7)
{
  struct wegl_platform *tmp_statement_expression$1$link7;
  if(!(wcore_self$link7 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link7 = wcore_self$link7;
    tmp_statement_expression$1$link7 = (struct wegl_platform *)((void *)__mptr$link7 - (signed long int)0ul);
    return tmp_statement_expression$1$link7;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link8
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform$link8(struct wcore_platform *wcore_self$link8)
{
  struct wegl_platform *tmp_statement_expression$1$link8;
  if(!(wcore_self$link8 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link8 = wcore_self$link8;
    tmp_statement_expression$1$link8 = (struct wegl_platform *)((void *)__mptr$link8 - (signed long int)0ul);
    return tmp_statement_expression$1$link8;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform$link9
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform$1 * wegl_platform$link9(struct wcore_platform *wcore_self$link9)
{
  struct wegl_platform$1 *tmp_statement_expression$1$link9;
  if(!(wcore_self$link9 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr$link9 = wcore_self$link9;
    tmp_statement_expression$1$link9 = (struct wegl_platform$1 *)((void *)__mptr$link9 - (signed long int)0ul);
    return tmp_statement_expression$1$link9;
  }

  else
    return ((struct wegl_platform$1 *)NULL);
}

// wegl_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 58
_Bool wegl_platform_init(struct wegl_platform *self)
{
  _Bool ok;
  ok=wcore_platform_init(&self->wcore);
  void *return_value_dlsym$2;
  void *return_value_dlsym$4;
  void *return_value_dlsym$6;
  void *return_value_dlsym$8;
  void *return_value_dlsym$10;
  void *return_value_dlsym$12;
  void *return_value_dlsym$14;
  void *return_value_dlsym$16;
  void *return_value_dlsym$18;
  void *return_value_dlsym$20;
  void *return_value_dlsym$22;
  void *return_value_dlsym$24;
  void *return_value_dlsym$26;
  void *return_value_dlsym$28;
  void *return_value_dlsym$30;
  if(!(ok == (_Bool)0))
  {
    self->eglHandle=dlopen(libEGL_filename, 0x00001 | 0);
    if(self->eglHandle == NULL)
    {
      char *return_value_dlerror$1;
      return_value_dlerror$1=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlopen(\"%s\") failed: %s", libEGL_filename, return_value_dlerror$1);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$2=dlsym(self->eglHandle, "eglMakeCurrent");
    self->eglMakeCurrent = (unsigned int (*)(void *, void *, void *, void *))return_value_dlsym$2;
    if(self->eglMakeCurrent == ((unsigned int (*)(void *, void *, void *, void *))NULL))
    {
      char *return_value_dlerror$3;
      return_value_dlerror$3=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglMakeCurrent\") failed: %s", libEGL_filename, return_value_dlerror$3);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$4=dlsym(self->eglHandle, "eglGetProcAddress");
    self->eglGetProcAddress = (void (*(*)(const char *))(void))return_value_dlsym$4;
    if(self->eglGetProcAddress == ((void (*(*)(const char *))(void))NULL))
    {
      char *return_value_dlerror$5;
      return_value_dlerror$5=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetProcAddress\") failed: %s", libEGL_filename, return_value_dlerror$5);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$6=dlsym(self->eglHandle, "eglGetDisplay");
    self->eglGetDisplay = (void * (*)(struct _XDisplay *))return_value_dlsym$6;
    if(self->eglGetDisplay == ((void * (*)(struct _XDisplay *))NULL))
    {
      char *return_value_dlerror$7;
      return_value_dlerror$7=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetDisplay\") failed: %s", libEGL_filename, return_value_dlerror$7);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$8=dlsym(self->eglHandle, "eglInitialize");
    self->eglInitialize = (unsigned int (*)(void *, signed int *, signed int *))return_value_dlsym$8;
    if(self->eglInitialize == ((unsigned int (*)(void *, signed int *, signed int *))NULL))
    {
      char *return_value_dlerror$9;
      return_value_dlerror$9=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglInitialize\") failed: %s", libEGL_filename, return_value_dlerror$9);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$10=dlsym(self->eglHandle, "eglQueryString");
    self->eglQueryString = (const char * (*)(void *, signed int))return_value_dlsym$10;
    if(self->eglQueryString == ((const char * (*)(void *, signed int))NULL))
    {
      char *return_value_dlerror$11;
      return_value_dlerror$11=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglQueryString\") failed: %s", libEGL_filename, return_value_dlerror$11);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$12=dlsym(self->eglHandle, "eglGetError");
    self->eglGetError = (signed int (*)(void))return_value_dlsym$12;
    if(self->eglGetError == ((signed int (*)(void))NULL))
    {
      char *return_value_dlerror$13;
      return_value_dlerror$13=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetError\") failed: %s", libEGL_filename, return_value_dlerror$13);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$14=dlsym(self->eglHandle, "eglTerminate");
    self->eglTerminate = (unsigned int (*)(void *))return_value_dlsym$14;
    if(self->eglTerminate == ((unsigned int (*)(void *))NULL))
    {
      char *return_value_dlerror$15;
      return_value_dlerror$15=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglTerminate\") failed: %s", libEGL_filename, return_value_dlerror$15);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$16=dlsym(self->eglHandle, "eglChooseConfig");
    self->eglChooseConfig = (unsigned int (*)(void *, const signed int *, void **, signed int, signed int *))return_value_dlsym$16;
    if(self->eglChooseConfig == ((unsigned int (*)(void *, const signed int *, void **, signed int, signed int *))NULL))
    {
      char *return_value_dlerror$17;
      return_value_dlerror$17=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglChooseConfig\") failed: %s", libEGL_filename, return_value_dlerror$17);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$18=dlsym(self->eglHandle, "eglBindAPI");
    self->eglBindAPI = (unsigned int (*)(unsigned int))return_value_dlsym$18;
    if(self->eglBindAPI == ((unsigned int (*)(unsigned int))NULL))
    {
      char *return_value_dlerror$19;
      return_value_dlerror$19=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglBindAPI\") failed: %s", libEGL_filename, return_value_dlerror$19);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$20=dlsym(self->eglHandle, "eglCreateContext");
    self->eglCreateContext = (void * (*)(void *, void *, void *, const signed int *))return_value_dlsym$20;
    if(self->eglCreateContext == ((void * (*)(void *, void *, void *, const signed int *))NULL))
    {
      char *return_value_dlerror$21;
      return_value_dlerror$21=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglCreateContext\") failed: %s", libEGL_filename, return_value_dlerror$21);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$22=dlsym(self->eglHandle, "eglDestroyContext");
    self->eglDestroyContext = (unsigned int (*)(void *, void *))return_value_dlsym$22;
    if(self->eglDestroyContext == ((unsigned int (*)(void *, void *))NULL))
    {
      char *return_value_dlerror$23;
      return_value_dlerror$23=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglDestroyContext\") failed: %s", libEGL_filename, return_value_dlerror$23);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$24=dlsym(self->eglHandle, "eglGetConfigAttrib");
    self->eglGetConfigAttrib = (unsigned int (*)(void *, void *, signed int, signed int *))return_value_dlsym$24;
    if(self->eglGetConfigAttrib == ((unsigned int (*)(void *, void *, signed int, signed int *))NULL))
    {
      char *return_value_dlerror$25;
      return_value_dlerror$25=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetConfigAttrib\") failed: %s", libEGL_filename, return_value_dlerror$25);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$26=dlsym(self->eglHandle, "eglCreateWindowSurface");
    self->eglCreateWindowSurface = (void * (*)(void *, void *, unsigned long int, const signed int *))return_value_dlsym$26;
    if(self->eglCreateWindowSurface == ((void * (*)(void *, void *, unsigned long int, const signed int *))NULL))
    {
      char *return_value_dlerror$27;
      return_value_dlerror$27=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglCreateWindowSurface\") failed: %s", libEGL_filename, return_value_dlerror$27);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$28=dlsym(self->eglHandle, "eglDestroySurface");
    self->eglDestroySurface = (unsigned int (*)(void *, void *))return_value_dlsym$28;
    if(self->eglDestroySurface == ((unsigned int (*)(void *, void *))NULL))
    {
      char *return_value_dlerror$29;
      return_value_dlerror$29=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglDestroySurface\") failed: %s", libEGL_filename, return_value_dlerror$29);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym$30=dlsym(self->eglHandle, "eglSwapBuffers");
    self->eglSwapBuffers = (unsigned int (*)(void *, void *))return_value_dlsym$30;
    if(self->eglSwapBuffers == ((unsigned int (*)(void *, void *))NULL))
    {
      char *return_value_dlerror$31;
      return_value_dlerror$31=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglSwapBuffers\") failed: %s", libEGL_filename, return_value_dlerror$31);
      ok = (_Bool)0;
      goto error;
    }

  }


error:
  ;
  return ok;
}

// wegl_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 39
_Bool wegl_platform_teardown(struct wegl_platform *self)
{
  _Bool ok = (_Bool)1;
  signed int error = 0;
  if(!(self->eglHandle == NULL))
  {
    error=dlclose(self->eglHandle);
    if(!(error == 0))
    {
      ok = (_Bool)0;
      char *return_value_dlerror$1;
      return_value_dlerror$1=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(\"%s\") failed: %s", libEGL_filename, return_value_dlerror$1);
    }

  }

  _Bool return_value_wcore_platform_teardown$2;
  return_value_wcore_platform_teardown$2=wcore_platform_teardown(&self->wcore);
  ok = ((signed int)ok & (signed int)return_value_wcore_platform_teardown$2) != 0;
  return ok;
}

// wegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window(struct wcore_window *wcore_self)
{
  struct wegl_window *tmp_statement_expression$1;
  if(!(wcore_self == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr = wcore_self;
    tmp_statement_expression$1 = (struct wegl_window *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct wegl_window *)NULL);
}

// wegl_window$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window$link1(struct wcore_window *wcore_self$link1)
{
  struct wegl_window *tmp_statement_expression$1$link1;
  if(!(wcore_self$link1 == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr$link1 = wcore_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_window *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct wegl_window *)NULL);
}

// wegl_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 36
_Bool wegl_window_init(struct wegl_window *window, struct wcore_config *wc_config, signed long int native_window)
{
  struct wegl_config *config;
  config=wegl_config$link2(wc_config);
  struct wegl_display *dpy;
  dpy=wegl_display$link4(wc_config->display);
  struct wegl_platform *plat;
  plat=wegl_platform$link4(dpy->wcore.platform);
  signed int egl_render_buffer;
  _Bool ok;
  ok=wcore_window_init(&window->wcore, wc_config);
  signed int attrib_list[3l];
  if(!(ok == (_Bool)0))
  {
    if(!(config->wcore.attrs.double_buffered == (_Bool)0))
      egl_render_buffer = 0x3084;

    else
      egl_render_buffer = 0x3085;
    attrib_list[0] = 0x3086;
    attrib_list[1] = egl_render_buffer;
    attrib_list[2] = 0x3038;
    window->egl=plat->eglCreateWindowSurface(dpy->egl, config->egl, (unsigned long int)native_window, attrib_list);
    if(window->egl == NULL)
      wegl_emit_error(plat, "eglCreateWindowSurface");

    return (_Bool)1;
  }

  else
  {

  fail:
    ;
    wegl_window_teardown(window);
    return (_Bool)0;
  }
}

// wegl_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 97
_Bool wegl_window_swap_buffers(struct wcore_window *wc_window)
{
  struct wegl_window *window;
  window=wegl_window$link1(wc_window);
  struct wegl_display *dpy;
  dpy=wegl_display$link4(window->wcore.display);
  struct wegl_platform *plat;
  plat=wegl_platform$link4(dpy->wcore.platform);
  _Bool ok;
  unsigned int return_value;
  return_value=plat->eglSwapBuffers(dpy->egl, window->egl);
  ok = (_Bool)return_value;
  if(ok == (_Bool)0)
    wegl_emit_error(plat, "eglSwapBuffers");

  return ok;
}

// wegl_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 78
_Bool wegl_window_teardown(struct wegl_window *window)
{
  struct wegl_display *dpy;
  dpy=wegl_display$link4(window->wcore.display);
  struct wegl_platform *plat;
  plat=wegl_platform$link4(dpy->wcore.platform);
  _Bool result = (_Bool)1;
  if(!(window->egl == NULL))
  {
    _Bool ok;
    unsigned int return_value;
    return_value=plat->eglDestroySurface(dpy->egl, window->egl);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
    {
      wegl_emit_error(plat, "eglDestroySurface");
      result = (_Bool)0;
    }

  }

  _Bool return_value_wcore_window_teardown$1;
  return_value_wcore_window_teardown$1=wcore_window_teardown(&window->wcore);
  result = ((signed int)result & (signed int)return_value_wcore_window_teardown$1) != 0;
  return result;
}

// wgbm_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 34
struct wcore_config * wgbm_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs)
{
  struct wcore_config *wc_config;
  wc_config=wegl_config_choose(wc_plat, wc_dpy, attrs);
  if(wc_config == ((struct wcore_config *)NULL))
    return (struct wcore_config *)(void *)0;

  else
  {
    unsigned int return_value_wgbm_config_get_gbm_format$1;
    return_value_wgbm_config_get_gbm_format$1=wgbm_config_get_gbm_format(wc_plat, wc_dpy, wc_config);
    if(return_value_wgbm_config_get_gbm_format$1 == 0u)
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "requested config is unsupported on GBM");
      wegl_config_destroy(wc_config);
      return (struct wcore_config *)(void *)0;
    }

    else
      return wc_config;
  }
}

// wgbm_config_get_gbm_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 53
unsigned int wgbm_config_get_gbm_format(struct wcore_platform *wc_plat, struct wcore_display *wc_display, struct wcore_config *wc_config)
{
  signed int gbm_format;
  struct wgbm_display *dpy;
  dpy=wgbm_display(wc_display);
  struct wegl_platform *plat;
  plat=wegl_platform$link8(wc_plat);
  struct wegl_config *egl_config;
  egl_config=wegl_config$link6(wc_config);
  _Bool ok;
  unsigned int return_value;
  return_value=plat->eglGetConfigAttrib(dpy->wegl.egl, egl_config->egl, 0x302E, &gbm_format);
  ok = (_Bool)return_value;
  if(ok == (_Bool)0)
    return (unsigned int)0;

  else
    return (unsigned int)gbm_format;
}

// wgbm_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 73
union waffle_native_config * wgbm_config_get_native(struct wcore_config *wc_config)
{
  struct wgbm_display *dpy;
  dpy=wgbm_display(wc_config->display);
  struct wegl_config *config;
  config=wegl_config$link6(wc_config);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_gbm_config) /*24ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc$1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->gbm = (struct waffle_gbm_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    wgbm_display_fill_native(dpy, &n_config->gbm->display);
    n_config->gbm->egl_config = config->egl;
    return n_config;
  }
}

// wgbm_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 153
static union waffle_native_context * wgbm_context_get_native(struct wcore_context *wc_ctx)
{
  struct wgbm_display *dpy;
  dpy=wgbm_display$link2(wc_ctx->display);
  struct wegl_context *ctx;
  ctx=wegl_context$link4(wc_ctx);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_gbm_context) /*24ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc$1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->gbm = (struct waffle_gbm_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    wgbm_display_fill_native(dpy, &n_ctx->gbm->display);
    n_ctx->gbm->egl_context = ctx->egl;
    return n_ctx;
  }
}

// wgbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display(struct wcore_display *wc_self)
{
  struct wegl_display *tmp_statement_expression$1;
  struct wgbm_display *tmp_statement_expression$2;
  if(!(wc_self == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self;
    const struct wcore_display *wgbm_display$$1$$1$$1$$__mptr = wc_self;
    tmp_statement_expression$1 = (struct wegl_display *)((void *)wgbm_display$$1$$1$$1$$__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression$1;
    const struct wegl_display *__mptr = wegl_self;
    tmp_statement_expression$2 = (struct wgbm_display *)((void *)__mptr - (signed long int)8ul);
    return tmp_statement_expression$2;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display$link1(struct wcore_display *wc_self$link1)
{
  struct wegl_display *tmp_statement_expression$1$link1;
  struct wgbm_display *tmp_statement_expression$2$link1;
  if(!(wc_self$link1 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self$link1;
    const struct wcore_display *__mptr$link1 = wc_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_display *)((void *)__mptr$link1 - (signed long int)0ul);
    wegl_self$link1 = tmp_statement_expression$1$link1;
    const struct wegl_display *wgbm_display$$1$$1$$2$$__mptr$link1 = wegl_self$link1;
    tmp_statement_expression$2$link1 = (struct wgbm_display *)((void *)wgbm_display$$1$$1$$2$$__mptr$link1 - (signed long int)8ul);
    return tmp_statement_expression$2$link1;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display$link2(struct wcore_display *wc_self$link2)
{
  struct wegl_display *tmp_statement_expression$1$link2;
  struct wgbm_display *tmp_statement_expression$2$link2;
  if(!(wc_self$link2 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self$link2;
    const struct wcore_display *wgbm_display$$1$$1$$1$$__mptr$link2 = wc_self$link2;
    tmp_statement_expression$1$link2 = (struct wegl_display *)((void *)wgbm_display$$1$$1$$1$$__mptr$link2 - (signed long int)0ul);
    wegl_self$link2 = tmp_statement_expression$1$link2;
    const struct wegl_display *__mptr$link2 = wegl_self$link2;
    tmp_statement_expression$2$link2 = (struct wgbm_display *)((void *)__mptr$link2 - (signed long int)8ul);
    return tmp_statement_expression$2$link2;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display$link3(struct wcore_display *wc_self$link3)
{
  struct wegl_display *tmp_statement_expression$1$link3;
  struct wgbm_display *tmp_statement_expression$2$link3;
  if(!(wc_self$link3 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self$link3;
    const struct wcore_display *__mptr$link3 = wc_self$link3;
    tmp_statement_expression$1$link3 = (struct wegl_display *)((void *)__mptr$link3 - (signed long int)0ul);
    wegl_self$link3 = tmp_statement_expression$1$link3;
    const struct wegl_display *wgbm_display$$1$$1$$2$$__mptr$link3 = wegl_self$link3;
    tmp_statement_expression$2$link3 = (struct wgbm_display *)((void *)wgbm_display$$1$$1$$2$$__mptr$link3 - (signed long int)8ul);
    return tmp_statement_expression$2$link3;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 119
struct wcore_display * wgbm_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct wgbm_display *self;
  struct wgbm_platform *plat;
  struct wegl_platform$1 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link9(wc_plat);
  plat=wgbm_platform(return_value_wegl_platform$1);
  _Bool ok = (_Bool)1;
  signed int fd;
  void *return_value_wcore_calloc$2;
  return_value_wcore_calloc$2=wcore_calloc(sizeof(struct wgbm_display) /*40ul*/ );
  self = (struct wgbm_display *)return_value_wcore_calloc$2;
  if(self == ((struct wgbm_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    if(name == ((const char *)NULL))
      name=getenv("WAFFLE_GBM_DEVICE");

    if(!(name == ((const char *)NULL)))
    {
      fd=open(name, 02 | 02000000);
      if(!(fd >= 0))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to open gbm device \"%s\"", name);
        goto error;
      }

    }

    else
    {
      fd=wgbm_get_default_fd();
      if(!(fd >= 0))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "open drm file for gbm failed");
        goto error;
      }

    }
    dlopen("libglapi.so.0", 0x00001 | 0x00100);
    self->gbm_device=plat->gbm_create_device(fd);
    if(self->gbm_device == ((struct gbm_device *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "gbm_create_device failed");

    else
    {
      ok=wegl_display_init(&self->wegl, wc_plat, (signed long int)self->gbm_device);
      if(!(ok == (_Bool)0))
        return &self->wegl.wcore;

    }

  error:
    ;
    wgbm_display_destroy(&self->wegl.wcore);
    return (struct wcore_display *)(void *)0;
  }
}

// wgbm_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 44
_Bool wgbm_display_destroy(struct wcore_display *wc_self)
{
  struct wgbm_display *self;
  self=wgbm_display$link1(wc_self);
  struct wcore_platform *wc_plat = wc_self->platform;
  struct wgbm_platform *plat;
  struct wegl_platform$1 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link9(wc_plat);
  plat=wgbm_platform(return_value_wegl_platform$1);
  _Bool ok = (_Bool)1;
  signed int fd;
  if(self == ((struct wgbm_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_display_teardown$2;
    return_value_wegl_display_teardown$2=wegl_display_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_display_teardown$2) != 0;
    if(!(self->gbm_device == ((struct gbm_device *)NULL)))
    {
      fd=plat->gbm_device_get_fd(self->gbm_device);
      plat->gbm_device_destroy(self->gbm_device);
      close(fd);
    }

    free((void *)self);
    return ok;
  }
}

// wgbm_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 66
void wgbm_display_fill_native(struct wgbm_display *self, struct waffle_gbm_display *n_dpy)
{
  n_dpy->gbm_device = self->gbm_device;
  n_dpy->egl_display = self->wegl.egl;
}

// wgbm_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 177
union waffle_native_display * wgbm_display_get_native(struct wcore_display *wc_self)
{
  struct wgbm_display *self;
  self=wgbm_display$link1(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_gbm_display) /*16ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc$1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->gbm = (struct waffle_gbm_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    wgbm_display_fill_native(self, n_dpy->gbm);
    return n_dpy;
  }
}

// wgbm_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 136
static _Bool wgbm_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct wgbm_platform$0 *self;
  struct wegl_platform *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link10(wc_self);
  self=wgbm_platform$link1(return_value_wegl_platform$1);
  _Bool return_value_linux_platform_dl_can_open$2;
  return_value_linux_platform_dl_can_open$2=0;//(self->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open$2;
}

// wgbm_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 144
static void * wgbm_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct wgbm_platform$0 *self;
  struct wegl_platform *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link10(wc_self);
  self=wgbm_platform$link1(return_value_wegl_platform$1);
  void *return_value_linux_platform_dl_sym$2;
  return_value_linux_platform_dl_sym$2=NULL;//(self->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym$2;
}

// wgbm_get_default_fd
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 104
static signed int wgbm_get_default_fd(void)
{
  signed int fd;
  fd=wgbm_get_default_fd_for_pattern("renderD[0-9]*");
  if(fd >= 0)
    return fd;

  else
  {
    fd=wgbm_get_default_fd_for_pattern("card[0-9]*");
    return fd;
  }
}

// wgbm_get_default_fd_for_pattern
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 69
static signed int wgbm_get_default_fd_for_pattern(const char *pattern)
{
  struct udev *ud;
  struct udev_enumerate *en;
  struct udev_list_entry *devices;
  struct udev_list_entry *entry;
  const char *path;
  const char *filename;
  struct udev_device *device;
  signed int fd;
  ud=udev_new();
  en=udev_enumerate_new(ud);
  udev_enumerate_add_match_subsystem(en, "drm");
  udev_enumerate_add_match_sysname(en, pattern);
  udev_enumerate_scan_devices(en);
  devices=udev_enumerate_get_list_entry(en);
  entry = devices;
  while(!(entry == ((struct udev_list_entry *)NULL)))
  {
    path=udev_list_entry_get_name(entry);
    device=udev_device_new_from_syspath(ud, path);
    filename=udev_device_get_devnode(device);
    fd=open(filename, 02 | 02000000);
    udev_device_unref(device);
    if(fd >= 0)
    {
      udev_enumerate_unref(en);
      udev_unref(ud);
      return fd;
    }

    entry=udev_list_entry_get_next(entry);
  }
  udev_enumerate_unref(en);
  udev_unref(ud);
  return -1;
}

// wgbm_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform * wgbm_platform(struct wegl_platform$1 *wegl_self)
{
  struct wgbm_platform *tmp_statement_expression$1;
  if(!(wegl_self == ((struct wegl_platform$1 *)NULL)))
  {
    const struct wegl_platform$1 *__mptr = wegl_self;
    tmp_statement_expression$1 = (struct wgbm_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct wgbm_platform *)NULL);
}

// wgbm_platform$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform$0 * wgbm_platform$link1(struct wegl_platform *wegl_self$link1)
{
  struct wgbm_platform$0 *tmp_statement_expression$1$link1;
  if(!(wegl_self$link1 == ((struct wegl_platform *)NULL)))
  {
    const struct wegl_platform *__mptr$link1 = wegl_self$link1;
    tmp_statement_expression$1$link1 = (struct wgbm_platform$0 *)((void *)__mptr$link1 - (signed long int)0ul);
    return tmp_statement_expression$1$link1;
  }

  else
    return ((struct wgbm_platform$0 *)NULL);
}

// wgbm_platform$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform$1 * wgbm_platform$link2(struct wegl_platform$2 *wegl_self$link2)
{
  struct wgbm_platform$1 *tmp_statement_expression$1$link2;
  if(!(wegl_self$link2 == ((struct wegl_platform$2 *)NULL)))
  {
    const struct wegl_platform$2 *__mptr$link2 = wegl_self$link2;
    tmp_statement_expression$1$link2 = (struct wgbm_platform$1 *)((void *)__mptr$link2 - (signed long int)0ul);
    return tmp_statement_expression$1$link2;
  }

  else
    return ((struct wgbm_platform$1 *)NULL);
}

// wgbm_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 36
struct wcore_platform * wgbm_platform_create(void)
{
  struct wgbm_platform$0 *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct wgbm_platform$0) /*208ul*/ );
  self = (struct wgbm_platform$0 *)return_value_wcore_calloc$1;
  void *return_value_dlsym$3;
  void *return_value_dlsym$5;
  void *return_value_dlsym$7;
  void *return_value_dlsym$9;
  void *return_value_dlsym$11;
  void *return_value_dlsym$13;
  void *return_value_dlsym$15;
  if(self == ((struct wgbm_platform$0 *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wegl_platform_init(&self->wegl);
    if(!(ok == (_Bool)0))
    {
      self->gbmHandle=dlopen(libgbm_filename, 0x00001 | 0);
      if(self->gbmHandle == NULL)
      {
        char *return_value_dlerror$2;
        return_value_dlerror$2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlopen(\"%s\") failed: %s", libgbm_filename, return_value_dlerror$2);
        goto error;
      }

      return_value_dlsym$3=dlsym(self->gbmHandle, "gbm_create_device");
      self->gbm_create_device = (struct gbm_device * (*)(signed int))return_value_dlsym$3;
      if(self->gbm_create_device == ((struct gbm_device * (*)(signed int))NULL))
      {
        char *return_value_dlerror$4;
        return_value_dlerror$4=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_create_device\") failed: %s", libgbm_filename, return_value_dlerror$4);
        goto error;
      }

      return_value_dlsym$5=dlsym(self->gbmHandle, "gbm_device_get_fd");
      self->gbm_device_get_fd = (signed int (*)(struct gbm_device *))return_value_dlsym$5;
      if(self->gbm_device_get_fd == ((signed int (*)(struct gbm_device *))NULL))
      {
        char *return_value_dlerror$6;
        return_value_dlerror$6=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_device_get_fd\") failed: %s", libgbm_filename, return_value_dlerror$6);
        goto error;
      }

      return_value_dlsym$7=dlsym(self->gbmHandle, "gbm_device_destroy");
      self->gbm_device_destroy = (void (*)(struct gbm_device *))return_value_dlsym$7;
      if(self->gbm_device_destroy == ((void (*)(struct gbm_device *))NULL))
      {
        char *return_value_dlerror$8;
        return_value_dlerror$8=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_device_destroy\") failed: %s", libgbm_filename, return_value_dlerror$8);
        goto error;
      }

      return_value_dlsym$9=dlsym(self->gbmHandle, "gbm_surface_create");
      self->gbm_surface_create = (struct gbm_surface * (*)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int))return_value_dlsym$9;
      if(self->gbm_surface_create == ((struct gbm_surface * (*)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int))NULL))
      {
        char *return_value_dlerror$10;
        return_value_dlerror$10=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_create\") failed: %s", libgbm_filename, return_value_dlerror$10);
        goto error;
      }

      return_value_dlsym$11=dlsym(self->gbmHandle, "gbm_surface_destroy");
      self->gbm_surface_destroy = (void (*)(struct gbm_surface *))return_value_dlsym$11;
      if(self->gbm_surface_destroy == ((void (*)(struct gbm_surface *))NULL))
      {
        char *return_value_dlerror$12;
        return_value_dlerror$12=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_destroy\") failed: %s", libgbm_filename, return_value_dlerror$12);
        goto error;
      }

      return_value_dlsym$13=dlsym(self->gbmHandle, "gbm_surface_lock_front_buffer");
      self->gbm_surface_lock_front_buffer = (struct gbm_bo * (*)(struct gbm_surface *))return_value_dlsym$13;
      if(self->gbm_surface_lock_front_buffer == ((struct gbm_bo * (*)(struct gbm_surface *))NULL))
      {
        char *return_value_dlerror$14;
        return_value_dlerror$14=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_lock_front_buffer\") failed: %s", libgbm_filename, return_value_dlerror$14);
        goto error;
      }

      return_value_dlsym$15=dlsym(self->gbmHandle, "gbm_surface_release_buffer");
      self->gbm_surface_release_buffer = (void (*)(struct gbm_surface *, struct gbm_bo *))return_value_dlsym$15;
      if(self->gbm_surface_release_buffer == ((void (*)(struct gbm_surface *, struct gbm_bo *))NULL))
      {
        char *return_value_dlerror$16;
        return_value_dlerror$16=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_release_buffer\") failed: %s", libgbm_filename, return_value_dlerror$16);
        goto error;
      }

      /*self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;*/

      setenv("EGL_PLATFORM", "drm", 1);
      self->wegl.wcore.vtbl = &wgbm_platform_vtbl;
      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      wgbm_platform_destroy(&self->wegl.wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// wgbm_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 50
static _Bool wgbm_platform_destroy(struct wcore_platform *wc_self)
{
  struct wgbm_platform$0 *self;
  struct wegl_platform *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link10(wc_self);
  self=wgbm_platform$link1(return_value_wegl_platform$1);
  _Bool ok = (_Bool)1;
  signed int error = 0;
  _Bool return_value_linux_platform_destroy$2;
  if(self == ((struct wgbm_platform$0 *)NULL))
    return (_Bool)1;

  else
  {
    unsetenv("EGL_PLATFORM");
    /*if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy$2=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy$2) != 0;
    }*/

    if(!(self->gbmHandle == NULL))
    {
      error=dlclose(self->gbmHandle);
      if(!(error == 0))
      {
        ok = ((signed int)ok & 0) != 0;
        char *return_value_dlerror$3;
        return_value_dlerror$3=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(\"%s\") failed: %s", libgbm_filename, return_value_dlerror$3);
      }

    }

    _Bool return_value_wegl_platform_teardown$4;
    return_value_wegl_platform_teardown$4=wegl_platform_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_platform_teardown$4) != 0;
    free((void *)self);
    return ok;
  }
}

// wgbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 41
static inline struct wgbm_window * wgbm_window(struct wcore_window *wc_self)
{
  struct wegl_window *tmp_statement_expression$1;
  struct wgbm_window *tmp_statement_expression$2;
  if(!(wc_self == ((struct wcore_window *)NULL)))
  {
    struct wegl_window *wegl_self;
    const struct wcore_window *wgbm_window$$1$$1$$1$$__mptr = wc_self;
    tmp_statement_expression$1 = (struct wegl_window *)((void *)wgbm_window$$1$$1$$1$$__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression$1;
    const struct wegl_window *__mptr = wegl_self;
    tmp_statement_expression$2 = (struct wgbm_window *)((void *)__mptr - (signed long int)8ul);
    return tmp_statement_expression$2;
  }

  else
    return (struct wgbm_window *)(void *)0;
}

// wgbm_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 53
struct wcore_window * wgbm_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct wgbm_display *dpy;
  dpy=wgbm_display$link3(wc_config->display);
  struct wgbm_platform$1 *plat;
  struct wegl_platform$2 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link11(wc_plat);
  plat=wgbm_platform$link2(return_value_wegl_platform$1);
  struct wgbm_window *self;
  unsigned int gbm_format;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$2;
  return_value_wcore_calloc$2=wcore_calloc(sizeof(struct wgbm_window) /*32ul*/ );
  self = (struct wgbm_window *)return_value_wcore_calloc$2;
  if(self == ((struct wgbm_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    gbm_format=wgbm_config_get_gbm_format(wc_plat, wc_config->display, wc_config);
    self->gbm_surface=plat->gbm_surface_create(dpy->gbm_device, (unsigned int)width, (unsigned int)height, gbm_format, (unsigned int)4);
    if(self->gbm_surface == ((struct gbm_surface *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "gbm_surface_create failed");

    else
    {
      ok=wegl_window_init(&self->wegl, wc_config, (signed long int)self->gbm_surface);
      if(!(ok == (_Bool)0))
        return &self->wegl.wcore;

    }

  error:
    ;
    wgbm_window_destroy(&self->wegl.wcore);
    return (struct wcore_window *)(void *)0;
  }
}

// wgbm_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 59
_Bool wgbm_window_destroy(struct wcore_window *wc_self)
{
  struct wcore_platform *wc_plat = wc_self->display->platform;
  struct wgbm_platform$1 *plat;
  struct wegl_platform$2 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link11(wc_plat);
  plat=wgbm_platform$link2(return_value_wegl_platform$1);
  struct wgbm_window *self;
  self=wgbm_window(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct wgbm_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_window_teardown$2;
    return_value_wegl_window_teardown$2=wegl_window_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_window_teardown$2) != 0;
    plat->gbm_surface_destroy(self->gbm_surface);
    free((void *)self);
    return ok;
  }
}

// wgbm_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 68
union waffle_native_window * wgbm_window_get_native(struct wcore_window *wc_self)
{
  struct wgbm_window *self;
  self=wgbm_window(wc_self);
  struct wgbm_display *dpy;
  dpy=wgbm_display$link3(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_gbm_window) /*32ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc$1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->gbm = (struct waffle_gbm_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    wgbm_display_fill_native(dpy, &n_window->gbm->display);
    n_window->gbm->egl_surface = self->wegl.egl;
    n_window->gbm->gbm_surface = self->gbm_surface;
    return n_window;
  }
}

// wgbm_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 62
_Bool wgbm_window_show(struct wcore_window *wc_self)
{
  return (_Bool)1;
}

// wgbm_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 65
_Bool wgbm_window_swap_buffers(struct wcore_window *wc_self)
{
  struct wcore_platform *wc_plat = wc_self->display->platform;
  struct wgbm_platform$1 *plat;
  struct wegl_platform$2 *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link11(wc_plat);
  plat=wgbm_platform$link2(return_value_wegl_platform$1);
  _Bool return_value_wegl_window_swap_buffers$2;
  return_value_wegl_window_swap_buffers$2=wegl_window_swap_buffers(wc_self);
  if(return_value_wegl_window_swap_buffers$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    struct wgbm_window *self;
    self=wgbm_window(wc_self);
    struct gbm_bo *bo;
    bo=plat->gbm_surface_lock_front_buffer(self->gbm_surface);
    if(bo == ((struct gbm_bo *)NULL))
      return (_Bool)0;

    else
    {
      plat->gbm_surface_release_buffer(self->gbm_surface, bo);
      return (_Bool)1;
    }
  }
}

// wl_compositor_create_surface
// file /usr/include/wayland-client-protocol.h line 361
static inline struct wl_surface * wl_compositor_create_surface(struct wl_compositor *wl_compositor)
{
  struct wl_proxy *id;
  id=wl_proxy_marshal_constructor((struct wl_proxy *)wl_compositor, (unsigned int)0, &wl_surface_interface, (void *)0);
  return (struct wl_surface *)id;
}

// wl_display_get_registry
// file /usr/include/wayland-client-protocol.h line 185
static inline struct wl_registry * wl_display_get_registry(struct wl_display *wl_display)
{
  struct wl_proxy *registry;
  registry=wl_proxy_marshal_constructor((struct wl_proxy *)wl_display, (unsigned int)1, &wl_registry_interface, (void *)0);
  return (struct wl_registry *)registry;
}

// wl_registry_add_listener
// file /usr/include/wayland-client-protocol.h line 256
static inline signed int wl_registry_add_listener(struct wl_registry *wl_registry, struct wl_registry_listener *listener, void *data)
{
  signed int return_value_wl_proxy_add_listener$1;
  return_value_wl_proxy_add_listener$1=wl_proxy_add_listener((struct wl_proxy *)wl_registry, (void (**)(void))listener, data);
  return return_value_wl_proxy_add_listener$1;
}

// wl_registry_bind
// file /usr/include/wayland-client-protocol.h line 284
static inline void * wl_registry_bind(struct wl_registry *wl_registry, unsigned int name, struct wl_interface *interface, unsigned int version)
{
  struct wl_proxy *id;
  id=wl_proxy_marshal_constructor((struct wl_proxy *)wl_registry, (unsigned int)0, interface, name, interface->name, version, (void *)0);
  return (void *)id;
}

// wl_shell_get_shell_surface
// file /usr/include/wayland-client-protocol.h line 1090
static inline struct wl_shell_surface * wl_shell_get_shell_surface(struct wl_shell *wl_shell, struct wl_surface *surface)
{
  struct wl_proxy *id;
  id=wl_proxy_marshal_constructor((struct wl_proxy *)wl_shell, (unsigned int)0, &wl_shell_surface_interface, (void *)0, surface);
  return (struct wl_shell_surface *)id;
}

// wl_shell_surface_add_listener
// file /usr/include/wayland-client-protocol.h line 1242
static inline signed int wl_shell_surface_add_listener(struct wl_shell_surface *wl_shell_surface, struct wl_shell_surface_listener *listener, void *data)
{
  signed int return_value_wl_proxy_add_listener$1;
  return_value_wl_proxy_add_listener$1=wl_proxy_add_listener((struct wl_proxy *)wl_shell_surface, (void (**)(void))listener, data);
  return return_value_wl_proxy_add_listener$1;
}

// wl_shell_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1273
static inline void wl_shell_surface_destroy(struct wl_shell_surface *wl_shell_surface)
{
  wl_proxy_destroy((struct wl_proxy *)wl_shell_surface);
}

// wl_shell_surface_pong
// file /usr/include/wayland-client-protocol.h line 1279
static inline void wl_shell_surface_pong(struct wl_shell_surface *wl_shell_surface, unsigned int serial)
{
  wl_proxy_marshal((struct wl_proxy *)wl_shell_surface, (unsigned int)0, serial);
}

// wl_shell_surface_set_toplevel
// file /usr/include/wayland-client-protocol.h line 1300
static inline void wl_shell_surface_set_toplevel(struct wl_shell_surface *wl_shell_surface)
{
  wl_proxy_marshal((struct wl_proxy *)wl_shell_surface, (unsigned int)3);
}

// wl_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1463
static inline void wl_surface_destroy(struct wl_surface *wl_surface)
{
  wl_proxy_marshal((struct wl_proxy *)wl_surface, (unsigned int)0);
  wl_proxy_destroy((struct wl_proxy *)wl_surface);
}

// wrapped_XCloseDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 64
static inline signed int wrapped_XCloseDisplay(struct _XDisplay *dpy)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link5);
  signed int error;
  error=XCloseDisplay(dpy);
  XSetErrorHandler(old_handler);
  return error;
}

// wrapped_XGetXCBConnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 73
static inline struct xcb_connection_t * wrapped_XGetXCBConnection(struct _XDisplay *dpy)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link5);
  struct xcb_connection_t *conn;
  conn=XGetXCBConnection(dpy);
  XSetErrorHandler(old_handler);
  return conn;
}

// wrapped_XOpenDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 55
static inline struct _XDisplay * wrapped_XOpenDisplay(const char *name)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link5);
  struct _XDisplay *dpy;
  dpy=XOpenDisplay(name);
  XSetErrorHandler(old_handler);
  return dpy;
}

// wrapped_glXChooseFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 48
static inline struct __GLXFBConfigRec ** wrapped_glXChooseFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen, const signed int *attribList, signed int *nitems)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler);
  struct __GLXFBConfigRec **configs;
  configs=platform->glXChooseFBConfig(dpy, screen, attribList, nitems);
  XSetErrorHandler(old_handler);
  return configs;
}

// wrapped_glXCreateContextAttribsARB
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 60
static inline struct __GLXcontextRec * wrapped_glXCreateContextAttribsARB(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, struct __GLXcontextRec *share_context, signed int direct, const signed int *attrib_list)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link1);
  struct __GLXcontextRec *ctx;
  ctx=platform->glXCreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
  XSetErrorHandler(old_handler);
  return ctx;
}

// wrapped_glXCreateNewContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 73
static inline struct __GLXcontextRec * wrapped_glXCreateNewContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int renderType, struct __GLXcontextRec *shareList, signed int direct)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link1);
  struct __GLXcontextRec *ctx;
  ctx=platform->glXCreateNewContext(dpy, config, renderType, shareList, direct);
  XSetErrorHandler(old_handler);
  return ctx;
}

// wrapped_glXDestroyContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 106
static inline void wrapped_glXDestroyContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXcontextRec *ctx)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link1);
  platform->glXDestroyContext(dpy, ctx);
  XSetErrorHandler(old_handler);
}

// wrapped_glXGetFBConfigAttrib
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 85
static inline signed int wrapped_glXGetFBConfigAttrib(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int attribute, signed int *value)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler);
  signed int error;
  error=platform->glXGetFBConfigAttrib(dpy, config, attribute, value);
  XSetErrorHandler(old_handler);
  return error;
}

// wrapped_glXGetVisualFromFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 96
static inline struct anonymous$2 * wrapped_glXGetVisualFromFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler);
  struct anonymous$2 *vi;
  vi=platform->glXGetVisualFromFBConfig(dpy, config);
  XSetErrorHandler(old_handler);
  return vi;
}

// wrapped_glXMakeCurrent
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 115
static inline signed int wrapped_glXMakeCurrent(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable, struct __GLXcontextRec *ctx)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link3);
  signed int ok;
  ok=platform->glXMakeCurrent(dpy, drawable, ctx);
  XSetErrorHandler(old_handler);
  return ok;
}

// wrapped_glXQueryExtensionsString
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 125
static inline const char * wrapped_glXQueryExtensionsString(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link2);
  const char *s;
  s=platform->glXQueryExtensionsString(dpy, screen);
  XSetErrorHandler(old_handler);
  return s;
}

// wrapped_glXSwapBuffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 135
static inline void wrapped_glXSwapBuffers(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous$4 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler$link4);
  platform->glXSwapBuffers(dpy, drawable);
  XSetErrorHandler(old_handler);
}

// x11_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 39
_Bool x11_display_init(struct x11_display *self, const char *name)
{
  self->xlib=wrapped_XOpenDisplay(name);
  if(self->xlib == ((struct _XDisplay *)NULL))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "XOpenDisplay failed");
    return (_Bool)0;
  }

  else
  {
    self->xcb=wrapped_XGetXCBConnection(self->xlib);
    if(self->xcb == ((struct xcb_connection_t *)NULL))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "XGetXCBConnection failed");
      wrapped_XCloseDisplay(self->xlib);
      return (_Bool)0;
    }

    else
    {
      self->screen = ((struct anonymous$10 *)self->xlib)->default_screen;
      return (_Bool)1;
    }
  }
}

// x11_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 42
_Bool x11_display_teardown(struct x11_display *self)
{
  signed int error = 0;
  if(self->xlib == ((struct _XDisplay *)NULL))
    return !(error != 0);

  else
  {
    error=wrapped_XCloseDisplay(self->xlib);
    if(!(error == 0))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "XCloseDisplay failed");

    return !(error != 0);
  }
}

// x11_dummy_error_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler(struct _XDisplay *dpy, struct anonymous$4 *err)
{
  return 0;
}

// x11_dummy_error_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link1(struct _XDisplay *dpy$link1, struct anonymous$4 *err$link1)
{
  return 0;
}

// x11_dummy_error_handler$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link2(struct _XDisplay *dpy$link2, struct anonymous$4 *err$link2)
{
  return 0;
}

// x11_dummy_error_handler$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link3(struct _XDisplay *dpy$link3, struct anonymous$4 *err$link3)
{
  return 0;
}

// x11_dummy_error_handler$link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link4(struct _XDisplay *dpy$link4, struct anonymous$4 *err$link4)
{
  return 0;
}

// x11_dummy_error_handler$link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler$link5(struct _XDisplay *dpy$link5, struct anonymous$4 *err$link5)
{
  return 0;
}

// x11_winddow_get_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 34
static unsigned char x11_winddow_get_depth(struct xcb_connection_t *conn, const struct xcb_screen_t *screen, unsigned int id)
{
  struct xcb_depth_iterator_t depth;
  depth=xcb_screen_allowed_depths_iterator(screen);
  while(!(depth.rem == 0))
  {
    struct xcb_visualtype_iterator_t visual;
    visual=xcb_depth_visuals_iterator(depth.data);
    while(!(visual.rem == 0))
    {
      if(visual.data->visual_id == id)
        return depth.data->depth;

      xcb_visualtype_next(&visual);
    }
    xcb_depth_next(&depth);
  }
  return (unsigned char)0;
}

// x11_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 40
_Bool x11_window_init(struct x11_window *self, struct x11_display *dpy, unsigned int visual_id, signed int width, signed int height)
{
  unsigned int colormap = (unsigned int)0;
  unsigned int window = (unsigned int)0;
  _Bool ok = (_Bool)1;
  struct xcb_connection_t *conn = dpy->xcb;
  const struct xcb_setup_t *setup;
  setup=xcb_get_setup(conn);
  const struct xcb_screen_t *screen;
  struct anonymous$11 colormap_cookie;
  unsigned int event_mask;
  unsigned int attrib_mask;
  unsigned int attrib_list[3l];
  struct anonymous$11 create_cookie;
  unsigned char return_value_x11_winddow_get_depth$1;
  struct anonymous$12 *error;
  if(setup == ((const struct xcb_setup_t *)NULL))
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_get_setup() failed");

  else
  {
    screen=get_xcb_screen(setup, dpy->screen);
    if(screen == ((const struct xcb_screen_t *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to get xcb screen");

    else
    {
      colormap=xcb_generate_id(conn);
      window=xcb_generate_id(conn);
      if(!(colormap >= 1u) || !(window >= 1u))
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_generate_id() failed");

      else
      {
        colormap_cookie=xcb_create_colormap_checked(conn, (unsigned char)0, colormap, screen->root, visual_id);
        event_mask = (const unsigned int)(4 | 32768 | 1);
        attrib_mask = (const unsigned int)(8 | 2048 | 8192);
        attrib_list[0] = (const unsigned int)0;
        attrib_list[1] = event_mask;
        attrib_list[2] = colormap;
        return_value_x11_winddow_get_depth$1=x11_winddow_get_depth(conn, screen, visual_id);
        create_cookie=xcb_create_window_checked(conn, return_value_x11_winddow_get_depth$1, window, screen->root, (signed short int)0, (signed short int)0, (unsigned short int)width, (unsigned short int)height, (unsigned short int)0, (unsigned short int)1, visual_id, attrib_mask, attrib_list);
        error=xcb_request_check(conn, colormap_cookie);
        if(!(error == ((struct anonymous$12 *)NULL)))
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_create_colormap() failed on visual_id=0x%x with error=0x%x\n", visual_id, error->error_code);

        else
        {
          error=xcb_request_check(conn, create_cookie);
          if(!(error == ((struct anonymous$12 *)NULL)))
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_create_window_checked() failed: error=0x%x", error->error_code);

          else
          {
            self->display = dpy;
            self->xcb = window;
            goto end;
          }
        }
      }
    }
  }

error:
  ;
  ok = (_Bool)0;
  if(!(colormap == 0u))
    xcb_free_colormap(conn, colormap);

  if(!(window == 0u))
    xcb_destroy_window(conn, window);


end:
  ;
  return ok;
}

// x11_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 53
_Bool x11_window_resize(struct x11_window *self, signed int width, signed int height)
{
  struct anonymous$11 cookie;
  struct anonymous$12 *error;
  unsigned int literal$1[2l] = { (unsigned int)width, (unsigned int)height };
  cookie=xcb_configure_window(self->display->xcb, self->xcb, (unsigned short int)(4 | 8), literal$1);
  error=xcb_request_check(self->display->xcb, cookie);
  if(!(error == ((struct anonymous$12 *)NULL)))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_configure_window() failed to resize width, height: error=0x%x\n", error->error_code);
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// x11_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 50
_Bool x11_window_show(struct x11_window *self)
{
  struct anonymous$11 cookie;
  struct anonymous$12 *error;
  cookie=xcb_map_window_checked(self->display->xcb, self->xcb);
  error=xcb_request_check(self->display->xcb, cookie);
  if(!(error == ((struct anonymous$12 *)NULL)))
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_map_window_checked() failed: error=0x%x", error->error_code);

  return !(error != ((struct anonymous$12 *)NULL));
}

// x11_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 47
_Bool x11_window_teardown(struct x11_window *self)
{
  struct anonymous$11 cookie;
  struct anonymous$12 *error;
  if(self->xcb == 0u)
    return (_Bool)1;

  else
  {
    cookie=xcb_destroy_window_checked(self->display->xcb, self->xcb);
    error=xcb_request_check(self->display->xcb, cookie);
    if(!(error == ((struct anonymous$12 *)NULL)))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_destroy_window_checked() failed: error=0x%x", error->error_code);

    return !(error != ((struct anonymous$12 *)NULL));
  }
}

// xegl_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 110
static union waffle_native_config * xegl_config_get_native(struct wcore_config *wc_config)
{
  struct xegl_display *dpy;
  dpy=xegl_display$link1(wc_config->display);
  struct wegl_config *config;
  config=wegl_config$link4(wc_config);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_x11_egl_config) /*24ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc$1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->x11_egl = (struct waffle_x11_egl_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    xegl_display_fill_native(dpy, &n_config->x11_egl->display);
    n_config->x11_egl->egl_config = config->egl;
    return n_config;
  }
}

// xegl_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 127
static union waffle_native_context * xegl_context_get_native(struct wcore_context *wc_ctx)
{
  struct xegl_display *dpy;
  dpy=xegl_display$link1(wc_ctx->display);
  struct wegl_context *ctx;
  ctx=wegl_context$link3(wc_ctx);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_x11_egl_context) /*24ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc$1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->x11_egl = (struct waffle_x11_egl_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    xegl_display_fill_native(dpy, &n_ctx->x11_egl->display);
    n_ctx->x11_egl->egl_context = ctx->egl;
    return n_ctx;
  }
}

// xegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display(struct wcore_display *wc_self)
{
  struct wegl_display *tmp_statement_expression$1;
  struct xegl_display *tmp_statement_expression$2;
  if(!(wc_self == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self;
    const struct wcore_display *__mptr = wc_self;
    tmp_statement_expression$1 = (struct wegl_display *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression$1;
    const struct wegl_display *xegl_display$$1$$1$$2$$__mptr = wegl_self;
    tmp_statement_expression$2 = (struct xegl_display *)((void *)xegl_display$$1$$1$$2$$__mptr - (signed long int)24ul);
    return tmp_statement_expression$2;
  }

  else
    return (struct xegl_display *)(void *)0;
}

// xegl_display$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display$link1(struct wcore_display *wc_self$link1)
{
  struct wegl_display *tmp_statement_expression$1$link1;
  struct xegl_display *tmp_statement_expression$2$link1;
  if(!(wc_self$link1 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self$link1;
    const struct wcore_display *xegl_display$$1$$1$$1$$__mptr$link1 = wc_self$link1;
    tmp_statement_expression$1$link1 = (struct wegl_display *)((void *)xegl_display$$1$$1$$1$$__mptr$link1 - (signed long int)0ul);
    wegl_self$link1 = tmp_statement_expression$1$link1;
    const struct wegl_display *__mptr$link1 = wegl_self$link1;
    tmp_statement_expression$2$link1 = (struct xegl_display *)((void *)__mptr$link1 - (signed long int)24ul);
    return tmp_statement_expression$2$link1;
  }

  else
    return (struct xegl_display *)(void *)0;
}

// xegl_display$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display$link2(struct wcore_display *wc_self$link2)
{
  struct wegl_display *tmp_statement_expression$1$link2;
  struct xegl_display *tmp_statement_expression$2$link2;
  if(!(wc_self$link2 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self$link2;
    const struct wcore_display *xegl_display$$1$$1$$1$$__mptr$link2 = wc_self$link2;
    tmp_statement_expression$1$link2 = (struct wegl_display *)((void *)xegl_display$$1$$1$$1$$__mptr$link2 - (signed long int)0ul);
    wegl_self$link2 = tmp_statement_expression$1$link2;
    const struct wegl_display *__mptr$link2 = wegl_self$link2;
    tmp_statement_expression$2$link2 = (struct xegl_display *)((void *)__mptr$link2 - (signed long int)24ul);
    return tmp_statement_expression$2$link2;
  }

  else
    return (struct xegl_display *)(void *)0;
}

// xegl_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 50
struct wcore_display * xegl_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct xegl_display *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct xegl_display) /*56ul*/ );
  self = (struct xegl_display *)return_value_wcore_calloc$1;
  if(self == ((struct xegl_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    ok=x11_display_init(&self->x11, name);
    if(!(ok == (_Bool)0))
    {
      ok=wegl_display_init(&self->wegl, wc_plat, (signed long int)self->x11.xlib);
      if(ok == (_Bool)0)
        goto error;

      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      xegl_display_destroy(&self->wegl.wcore);
      return (struct wcore_display *)(void *)0;
    }
  }
}

// xegl_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 35
_Bool xegl_display_destroy(struct wcore_display *wc_self)
{
  struct xegl_display *self;
  self=xegl_display(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct xegl_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_display_teardown$1;
    return_value_wegl_display_teardown$1=wegl_display_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_display_teardown$1) != 0;
    _Bool return_value_x11_display_teardown$2;
    return_value_x11_display_teardown$2=x11_display_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_display_teardown$2) != 0;
    free((void *)self);
    return ok;
  }
}

// xegl_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 77
void xegl_display_fill_native(struct xegl_display *self, struct waffle_x11_egl_display *n_dpy)
{
  n_dpy->xlib_display = self->x11.xlib;
  n_dpy->egl_display = self->wegl.egl;
}

// xegl_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 85
union waffle_native_display * xegl_display_get_native(struct wcore_display *wc_self)
{
  struct xegl_display *self;
  self=xegl_display(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_x11_egl_display) /*16ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc$1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->x11_egl = (struct waffle_x11_egl_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    xegl_display_fill_native(self, n_dpy->x11_egl);
    return n_dpy;
  }
}

// xegl_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 93
static _Bool xegl_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct xegl_platform *self;
  struct wegl_platform *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link6(wc_self);
  self=xegl_platform(return_value_wegl_platform$1);
  _Bool return_value_linux_platform_dl_can_open$2;
  return_value_linux_platform_dl_can_open$2=0;//(self->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open$2;
}

// xegl_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 101
static void * xegl_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct xegl_platform *self;
  struct wegl_platform *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link6(wc_self);
  self=xegl_platform(return_value_wegl_platform$1);
  void *return_value_linux_platform_dl_sym$2;
  return_value_linux_platform_dl_sym$2=NULL;//(self->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym$2;
}

// xegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.h line 44
static inline struct xegl_platform * xegl_platform(struct wegl_platform *wegl_self)
{
  struct xegl_platform *tmp_statement_expression$1;
  if(!(wegl_self == ((struct wegl_platform *)NULL)))
  {
    const struct wegl_platform *__mptr = wegl_self;
    tmp_statement_expression$1 = (struct xegl_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression$1;
  }

  else
    return ((struct xegl_platform *)NULL);
}

// xegl_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 35
struct wcore_platform * xegl_platform_create(void)
{
  struct xegl_platform *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct xegl_platform) /*144ul*/ );
  self = (struct xegl_platform *)return_value_wcore_calloc$1;
  if(self == ((struct xegl_platform *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wegl_platform_init(&self->wegl);
    if(!(ok == (_Bool)0))
    {
      /*self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;*/

      setenv("EGL_PLATFORM", "x11", 1);
      self->wegl.wcore.vtbl = &xegl_platform_vtbl;
      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      xegl_platform_destroy(&self->wegl.wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// xegl_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 46
static _Bool xegl_platform_destroy(struct wcore_platform *wc_self)
{
  struct xegl_platform *self;
  struct wegl_platform *return_value_wegl_platform$1;
  return_value_wegl_platform$1=wegl_platform$link6(wc_self);
  self=xegl_platform(return_value_wegl_platform$1);
  _Bool ok = (_Bool)1;
  _Bool return_value_linux_platform_destroy$2;
  if(self == ((struct xegl_platform *)NULL))
    return (_Bool)1;

  else
  {
    unsetenv("EGL_PLATFORM");
    /*if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy$2=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy$2) != 0;
    }*/

    _Bool return_value_wegl_platform_teardown$3;
    return_value_wegl_platform_teardown$3=wegl_platform_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_platform_teardown$3) != 0;
    free((void *)self);
    return ok;
  }
}

// xegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 45
static inline struct xegl_window * xegl_window(struct wcore_window *wc_self)
{
  struct wegl_window *tmp_statement_expression$1;
  struct xegl_window *tmp_statement_expression$2;
  if(!(wc_self == ((struct wcore_window *)NULL)))
  {
    struct wegl_window *wegl_self;
    const struct wcore_window *__mptr = wc_self;
    tmp_statement_expression$1 = (struct wegl_window *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression$1;
    const struct wegl_window *xegl_window$$1$$1$$2$$__mptr = wegl_self;
    tmp_statement_expression$2 = (struct xegl_window *)((void *)xegl_window$$1$$1$$2$$__mptr - (signed long int)16ul);
    return tmp_statement_expression$2;
  }

  else
    return (struct xegl_window *)(void *)0;
}

// xegl_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 57
struct wcore_window * xegl_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct xegl_window *self;
  struct xegl_display *dpy;
  dpy=xegl_display$link2(wc_config->display);
  struct wegl_config *config;
  config=wegl_config$link5(wc_config);
  struct wegl_platform *plat;
  plat=wegl_platform$link7(wc_plat);
  unsigned int visual;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc$1;
  return_value_wcore_calloc$1=wcore_calloc(sizeof(struct xegl_window) /*40ul*/ );
  self = (struct xegl_window *)return_value_wcore_calloc$1;
  if(self == ((struct xegl_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    unsigned int return_value;
    return_value=plat->eglGetConfigAttrib(dpy->wegl.egl, config->egl, 0x302E, (signed int *)&visual);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
      wegl_emit_error(plat, "eglGetConfigAttrib(EGL_NATIVE_VISUAL_ID)");

    else
    {
      ok=x11_window_init(&self->x11, &dpy->x11, visual, width, height);
      if(!(ok == (_Bool)0))
      {
        ok=wegl_window_init(&self->wegl, &config->wcore, (signed long int)self->x11.xcb);
        if(!(ok == (_Bool)0))
          return &self->wegl.wcore;

      }

    }

  error:
    ;
    xegl_window_destroy(&self->wegl.wcore);
    return (struct wcore_window *)(void *)0;
  }
}

// xegl_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 63
_Bool xegl_window_destroy(struct wcore_window *wc_self)
{
  struct xegl_window *self;
  self=xegl_window(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct xegl_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_window_teardown$1;
    return_value_wegl_window_teardown$1=wegl_window_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_window_teardown$1) != 0;
    _Bool return_value_x11_window_teardown$2;
    return_value_x11_window_teardown$2=x11_window_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_window_teardown$2) != 0;
    free((void *)self);
    return ok;
  }
}

// xegl_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 73
union waffle_native_window * xegl_window_get_native(struct wcore_window *wc_self)
{
  struct xegl_window *self;
  self=xegl_window(wc_self);
  struct xegl_display *dpy;
  dpy=xegl_display$link2(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc$1;
    return_value_wcore_malloc$1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_x11_egl_window) /*32ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc$1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->x11_egl = (struct waffle_x11_egl_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    xegl_display_fill_native(dpy, &n_window->x11_egl->display);
    n_window->x11_egl->xlib_window = (unsigned long int)self->x11.xcb;
    n_window->x11_egl->egl_surface = self->wegl.egl;
    return n_window;
  }
}

// xegl_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 69
_Bool xegl_window_resize(struct wcore_window *wc_self, signed int width, signed int height)
{
  struct xegl_window *return_value_xegl_window$1;
  return_value_xegl_window$1=xegl_window(wc_self);
  _Bool return_value_x11_window_resize$2;
  return_value_x11_window_resize$2=x11_window_resize(&return_value_xegl_window$1->x11, width, height);
  return return_value_x11_window_resize$2;
}

// xegl_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 66
_Bool xegl_window_show(struct wcore_window *wc_self)
{
  struct xegl_window *return_value_xegl_window$1;
  return_value_xegl_window$1=xegl_window(wc_self);
  _Bool return_value_x11_window_show$2;
  return_value_x11_window_show$2=x11_window_show(&return_value_xegl_window$1->x11);
  return return_value_x11_window_show$2;
}

// xtime_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 316
signed int xtime_get(struct xtime *xt, signed int base)
{
  if(xt == ((struct xtime *)NULL))
    return 0;

  else
    if(base == 1)
    {
      xt->sec=time((signed long int *)(void *)0);
      xt->nsec = (signed long int)0;
      return base;
    }

    else
      return 0;
}

