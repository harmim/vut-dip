// #anon_enum$GG_ACTION_WAIT=0$GG_ACTION_NEXT=1$GG_ACTION_FAIL=2
// file events.c line 412
enum anonymous$27 { GG_ACTION_WAIT=0, GG_ACTION_NEXT=1, GG_ACTION_FAIL=2 };

// #anon_enum$GG_COMPAT_FEATURE_ACK_EVENT=0$GG_COMPAT_FEATURE_LEGACY_CONFER=1
// file ../include/internal.h line 148
enum anonymous$18 { GG_COMPAT_FEATURE_ACK_EVENT=0, GG_COMPAT_FEATURE_LEGACY_CONFER=1 };

// #anon_enum$GG_COMPAT_LEGACY=0$GG_COMPAT_1_12_0=1
// file ../../include/libgadu.h line 232
enum anonymous$5 { GG_COMPAT_LEGACY=0, GG_COMPAT_1_12_0=1 };

// #anon_enum$GG_ENCODING_CP1250=0$GG_ENCODING_UTF8=1$GG_ENCODING_INVALID=-1
// file ../../include/libgadu.h line 223
enum anonymous$3 { GG_ENCODING_CP1250=0, GG_ENCODING_UTF8=1, GG_ENCODING_INVALID=-1 };

// #anon_enum$GG_LIBGADU_FEATURE_SSL=0$GG_LIBGADU_FEATURE_PTHREAD=1$GG_LIBGADU_FEATURE_USERLIST100=2
// file ../include/libgadu.h line 1605
enum anonymous$17 { GG_LIBGADU_FEATURE_SSL=0, GG_LIBGADU_FEATURE_PTHREAD=1, GG_LIBGADU_FEATURE_USERLIST100=2 };

// #anon_enum$GG_PUBDIR_ERROR_NONE=0$GG_PUBDIR_ERROR_OTHER=1$GG_PUBDIR_ERROR_TOKEN=2$GG_PUBDIR_ERROR_OLD_PASSWORD=3$GG_PUBDIR_ERROR_NEW_PASSWORD=4
// file ../include/libgadu.h line 1471
enum anonymous$21 { GG_PUBDIR_ERROR_NONE=0, GG_PUBDIR_ERROR_OTHER=1, GG_PUBDIR_ERROR_TOKEN=2, GG_PUBDIR_ERROR_OLD_PASSWORD=3, GG_PUBDIR_ERROR_NEW_PASSWORD=4 };

// #anon_enum$GG_RESOLVER_DEFAULT=0$GG_RESOLVER_FORK=1$GG_RESOLVER_PTHREAD=2$GG_RESOLVER_CUSTOM=3$GG_RESOLVER_WIN32=4$GG_RESOLVER_INVALID=-1
// file ../../include/libgadu.h line 211
enum anonymous$4 { GG_RESOLVER_DEFAULT=0, GG_RESOLVER_FORK=1, GG_RESOLVER_PTHREAD=2, GG_RESOLVER_CUSTOM=3, GG_RESOLVER_WIN32=4, GG_RESOLVER_INVALID=-1 };

// #anon_enum$GG_SOCKET_MANAGER_TYPE_INTERNAL=0$GG_SOCKET_MANAGER_TYPE_TCP=1$GG_SOCKET_MANAGER_TYPE_TLS=2
// file ../../include/libgadu.h line 657
enum anonymous$6 { GG_SOCKET_MANAGER_TYPE_INTERNAL=0, GG_SOCKET_MANAGER_TYPE_TCP=1, GG_SOCKET_MANAGER_TYPE_TLS=2 };

// #anon_enum$GG_SSL_DISABLED=0$GG_SSL_ENABLED=1$GG_SSL_REQUIRED=2
// file ../../include/libgadu.h line 242
enum anonymous$8 { GG_SSL_DISABLED=0, GG_SSL_ENABLED=1, GG_SSL_REQUIRED=2 };

// #anon_enum$GNUTLS_COMP_UNKNOWN=0$GNUTLS_COMP_NULL=1$GNUTLS_COMP_DEFLATE=2$GNUTLS_COMP_ZLIB=2
// file /usr/include/gnutls/gnutls.h line 316
enum anonymous$32 { GNUTLS_COMP_UNKNOWN=0, GNUTLS_COMP_NULL=1, GNUTLS_COMP_DEFLATE=2, GNUTLS_COMP_ZLIB=2 };

// #anon_enum$GNUTLS_CRD_CERTIFICATE=1$GNUTLS_CRD_ANON=2$GNUTLS_CRD_SRP=3$GNUTLS_CRD_PSK=4$GNUTLS_CRD_IA=5
// file /usr/include/gnutls/gnutls.h line 222
enum anonymous$11 { GNUTLS_CRD_CERTIFICATE=1, GNUTLS_CRD_ANON=2, GNUTLS_CRD_SRP=3, GNUTLS_CRD_PSK=4, GNUTLS_CRD_IA=5 };

// #anon_enum$GNUTLS_CRT_UNKNOWN=0$GNUTLS_CRT_X509=1$GNUTLS_CRT_OPENPGP=2$GNUTLS_CRT_RAW=3
// file /usr/include/gnutls/gnutls.h line 599
enum anonymous$33 { GNUTLS_CRT_UNKNOWN=0, GNUTLS_CRT_X509=1, GNUTLS_CRT_OPENPGP=2, GNUTLS_CRT_RAW=3 };

// #anon_enum$GNUTLS_DIG_UNKNOWN=0$GNUTLS_DIG_NULL=1$GNUTLS_DIG_MD5=2$GNUTLS_DIG_SHA1=3$GNUTLS_DIG_RMD160=4$GNUTLS_DIG_MD2=5$GNUTLS_DIG_SHA256=6$GNUTLS_DIG_SHA384=7$GNUTLS_DIG_SHA512=8$GNUTLS_DIG_SHA224=9
// file /usr/include/gnutls/gnutls.h line 285
enum anonymous$25 { GNUTLS_DIG_UNKNOWN=0, GNUTLS_DIG_NULL=1, GNUTLS_DIG_MD5=2, GNUTLS_DIG_SHA1=3, GNUTLS_DIG_RMD160=4, GNUTLS_DIG_MD2=5, GNUTLS_DIG_SHA256=6, GNUTLS_DIG_SHA384=7, GNUTLS_DIG_SHA512=8, GNUTLS_DIG_SHA224=9 };

// #anon_enum$GNUTLS_KX_UNKNOWN=0$GNUTLS_KX_RSA=1$GNUTLS_KX_DHE_DSS=2$GNUTLS_KX_DHE_RSA=3$GNUTLS_KX_ANON_DH=4$GNUTLS_KX_SRP=5$GNUTLS_KX_RSA_EXPORT=6$GNUTLS_KX_SRP_RSA=7$GNUTLS_KX_SRP_DSS=8$GNUTLS_KX_PSK=9$GNUTLS_KX_DHE_PSK=10$GNUTLS_KX_ANON_ECDH=11$GNUTLS_KX_ECDHE_RSA=12$GNUTLS_KX_ECDHE_ECDSA=13$GNUTLS_KX_ECDHE_PSK=14$GNUTLS_KX_RSA_PSK=15
// file /usr/include/gnutls/gnutls.h line 179
enum anonymous$30 { GNUTLS_KX_UNKNOWN=0, GNUTLS_KX_RSA=1, GNUTLS_KX_DHE_DSS=2, GNUTLS_KX_DHE_RSA=3, GNUTLS_KX_ANON_DH=4, GNUTLS_KX_SRP=5, GNUTLS_KX_RSA_EXPORT=6, GNUTLS_KX_SRP_RSA=7, GNUTLS_KX_SRP_DSS=8, GNUTLS_KX_PSK=9, GNUTLS_KX_DHE_PSK=10, GNUTLS_KX_ANON_ECDH=11, GNUTLS_KX_ECDHE_RSA=12, GNUTLS_KX_ECDHE_ECDSA=13, GNUTLS_KX_ECDHE_PSK=14, GNUTLS_KX_RSA_PSK=15 };

// #anon_enum$GNUTLS_MAC_UNKNOWN=0$GNUTLS_MAC_NULL=1$GNUTLS_MAC_MD5=2$GNUTLS_MAC_SHA1=3$GNUTLS_MAC_RMD160=4$GNUTLS_MAC_MD2=5$GNUTLS_MAC_SHA256=6$GNUTLS_MAC_SHA384=7$GNUTLS_MAC_SHA512=8$GNUTLS_MAC_SHA224=9$GNUTLS_MAC_AEAD=200$GNUTLS_MAC_UMAC_96=201$GNUTLS_MAC_UMAC_128=202
// file /usr/include/gnutls/gnutls.h line 252
enum anonymous$31 { GNUTLS_MAC_UNKNOWN=0, GNUTLS_MAC_NULL=1, GNUTLS_MAC_MD5=2, GNUTLS_MAC_SHA1=3, GNUTLS_MAC_RMD160=4, GNUTLS_MAC_MD2=5, GNUTLS_MAC_SHA256=6, GNUTLS_MAC_SHA384=7, GNUTLS_MAC_SHA512=8, GNUTLS_MAC_SHA224=9, GNUTLS_MAC_AEAD=200, GNUTLS_MAC_UMAC_96=201, GNUTLS_MAC_UMAC_128=202 };

// #anon_enum$GNUTLS_SHUT_RDWR=0$GNUTLS_SHUT_WR=1
// file /usr/include/gnutls/gnutls.h line 554
enum anonymous$14 { GNUTLS_SHUT_RDWR=0, GNUTLS_SHUT_WR=1 };

// #anon_enum$GNUTLS_SSL3=1$GNUTLS_TLS1_0=2$GNUTLS_TLS1=2$GNUTLS_TLS1_1=3$GNUTLS_TLS1_2=4$GNUTLS_DTLS0_9=200$GNUTLS_DTLS1_0=201$GNUTLS_DTLS1_2=202$GNUTLS_DTLS_VERSION_MIN=200$GNUTLS_DTLS_VERSION_MAX=202$GNUTLS_TLS_VERSION_MAX=4$GNUTLS_VERSION_UNKNOWN=255
// file /usr/include/gnutls/gnutls.h line 574
enum anonymous$29 { GNUTLS_SSL3=1, GNUTLS_TLS1_0=2, GNUTLS_TLS1=2, GNUTLS_TLS1_1=3, GNUTLS_TLS1_2=4, GNUTLS_DTLS0_9=200, GNUTLS_DTLS1_0=201, GNUTLS_DTLS1_2=202, GNUTLS_DTLS_VERSION_MIN=200, GNUTLS_DTLS_VERSION_MAX=202, GNUTLS_TLS_VERSION_MAX=4, GNUTLS_VERSION_UNKNOWN=255 };

// #anon_enum$GNUTLS_X509_FMT_DER=0$GNUTLS_X509_FMT_PEM=1
// file /usr/include/gnutls/gnutls.h line 613
enum anonymous$2 { GNUTLS_X509_FMT_DER=0, GNUTLS_X509_FMT_PEM=1 };

// #anon_enum$PLUG_NONE=0$PLUG_RESET=1$PLUG_TIMEOUT=2
// file connect.c line 63
enum anonymous$15 { PLUG_NONE=0, PLUG_RESET=1, PLUG_TIMEOUT=2 };

// #anon_enum$PROTOBUF_C_LABEL_REQUIRED=0$PROTOBUF_C_LABEL_OPTIONAL=1$PROTOBUF_C_LABEL_REPEATED=2
// file /usr/include/protobuf-c/protobuf-c.h line 271
enum anonymous { PROTOBUF_C_LABEL_REQUIRED=0, PROTOBUF_C_LABEL_OPTIONAL=1, PROTOBUF_C_LABEL_REPEATED=2 };

// #anon_enum$PROTOBUF_C_TYPE_INT32=0$PROTOBUF_C_TYPE_SINT32=1$PROTOBUF_C_TYPE_SFIXED32=2$PROTOBUF_C_TYPE_INT64=3$PROTOBUF_C_TYPE_SINT64=4$PROTOBUF_C_TYPE_SFIXED64=5$PROTOBUF_C_TYPE_UINT32=6$PROTOBUF_C_TYPE_FIXED32=7$PROTOBUF_C_TYPE_UINT64=8$PROTOBUF_C_TYPE_FIXED64=9$PROTOBUF_C_TYPE_FLOAT=10$PROTOBUF_C_TYPE_DOUBLE=11$PROTOBUF_C_TYPE_BOOL=12$PROTOBUF_C_TYPE_ENUM=13$PROTOBUF_C_TYPE_STRING=14$PROTOBUF_C_TYPE_BYTES=15$PROTOBUF_C_TYPE_MESSAGE=16
// file /usr/include/protobuf-c/protobuf-c.h line 297
enum anonymous$0 { PROTOBUF_C_TYPE_INT32=0, PROTOBUF_C_TYPE_SINT32=1, PROTOBUF_C_TYPE_SFIXED32=2, PROTOBUF_C_TYPE_INT64=3, PROTOBUF_C_TYPE_SINT64=4, PROTOBUF_C_TYPE_SFIXED64=5, PROTOBUF_C_TYPE_UINT32=6, PROTOBUF_C_TYPE_FIXED32=7, PROTOBUF_C_TYPE_UINT64=8, PROTOBUF_C_TYPE_FIXED64=9, PROTOBUF_C_TYPE_FLOAT=10, PROTOBUF_C_TYPE_DOUBLE=11, PROTOBUF_C_TYPE_BOOL=12, PROTOBUF_C_TYPE_ENUM=13, PROTOBUF_C_TYPE_STRING=14, PROTOBUF_C_TYPE_BYTES=15, PROTOBUF_C_TYPE_MESSAGE=16 };

// #anon_enum$PROTOBUF_C_WIRE_TYPE_VARINT=0$PROTOBUF_C_WIRE_TYPE_64BIT=1$PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED=2$PROTOBUF_C_WIRE_TYPE_32BIT=5
// file /usr/include/protobuf-c/protobuf-c.h line 325
enum anonymous$35 { PROTOBUF_C_WIRE_TYPE_VARINT=0, PROTOBUF_C_WIRE_TYPE_64BIT=1, PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED=2, PROTOBUF_C_WIRE_TYPE_32BIT=5 };

// tag-#anon#ST[*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'session'||*{SYM#tag-gnutls_certificate_credentials_st#}$SYM#tag-gnutls_certificate_credentials_st#$'xcred'|]
// file ../include/session.h line 50
struct anonymous$34;

// tag-#anon#ST[*{U8}$U8$'data'||U32'size'||U32'$pad0'|]
// file /usr/include/gnutls/gnutls.h line 795
struct anonymous$28;

// tag-#anon#ST[*{V}$V$'cb_data'||*{*{V}$V$(*{V}$V$|*{cS8}$cS8$|S32|S32|S32|*{V}$V$)->*{V}$V$}$*{V}$V$(*{V}$V$|*{cS8}$cS8$|S32|S32|S32|*{V}$V$)->*{V}$V$$'connect_cb'||*{V(*{V}$V$|*{V}$V$)->V}$V(*{V}$V$|*{V}$V$)->V$'close_cb'||*{S64(*{V}$V$|*{V}$V$|*{U8}$U8$|U64)->S64}$S64(*{V}$V$|*{V}$V$|*{U8}$U8$|U64)->S64$'read_cb'||*{S64(*{V}$V$|*{V}$V$|*{cU8}$cU8$|U64)->S64}$S64(*{V}$V$|*{V}$V$|*{cU8}$cU8$|U64)->S64$'write_cb'||*{V}$V$'reserved1'||*{V}$V$'reserved2'||*{V}$V$'reserved3'||*{V}$V$'reserved4'|]
// file ../../include/libgadu.h line 732
struct anonymous$7;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$19;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous$24;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous$23;

// tag-#anon#ST[ARR8{U8}$U8$'id'|]
// file ../../include/libgadu.h line 167
struct anonymous$9;

// tag-#anon#ST[EN#anon_enum$PLUG_NONE=0$PLUG_RESET=1$PLUG_TIMEOUT=2#{U32}$U32$'plug_80'||EN#anon_enum$PLUG_NONE=0$PLUG_RESET=1$PLUG_TIMEOUT=2#{U32}$U32$'plug_443'||EN#anon_enum$PLUG_NONE=0$PLUG_RESET=1$PLUG_TIMEOUT=2#{U32}$U32$'plug_8074'||EN#anon_enum$PLUG_NONE=0$PLUG_RESET=1$PLUG_TIMEOUT=2#{U32}$U32$'plug_8080'||EN#anon_enum$PLUG_NONE=0$PLUG_RESET=1$PLUG_TIMEOUT=2#{U32}$U32$'plug_resolver'||B'server'||B'async_mode'||B'proxy_mode'||B'ssl_mode'||B'tried_80'||B'tried_443'||B'tried_8074'||B'tried_8080'||B'tried_non_8080'||B'tried_resolver'||U16'$pad0'|]
// file connect.c line 78
struct anonymous$16;

// tag-#anon#ST[ENtag-gg_state_t#{U32}$U32$'state'||U32'$pad0'||*{EN#anon_enum$GG_ACTION_WAIT=0$GG_ACTION_NEXT=1$GG_ACTION_FAIL=2#{U32}$U32$(*{SYM#tag-gg_session#}$SYM#tag-gg_session#$|*{SYM#tag-gg_event#}$SYM#tag-gg_event#$|ENtag-gg_state_t#{U32}$U32$|ENtag-gg_state_t#{U32}$U32$|ENtag-gg_state_t#{U32}$U32$)->EN#anon_enum$GG_ACTION_WAIT=0$GG_ACTION_NEXT=1$GG_ACTION_FAIL=2#{U32}$U32$}$EN#anon_enum$GG_ACTION_WAIT=0$GG_ACTION_NEXT=1$GG_ACTION_FAIL=2#{U32}$U32$(*{SYM#tag-gg_session#}$SYM#tag-gg_session#$|*{SYM#tag-gg_event#}$SYM#tag-gg_event#$|ENtag-gg_state_t#{U32}$U32$|ENtag-gg_state_t#{U32}$U32$|ENtag-gg_state_t#{U32}$U32$)->EN#anon_enum$GG_ACTION_WAIT=0$GG_ACTION_NEXT=1$GG_ACTION_FAIL=2#{U32}$U32$$'handler'||ENtag-gg_state_t#{U32}$U32$'next_state'||ENtag-gg_state_t#{U32}$U32$'alt_state'||ENtag-gg_state_t#{U32}$U32$'alt2_state'||U32'$pad1'|]
// file events.c line 423
struct anonymous$26;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$12;

// tag-#anon#ST[SYM#tag-in_addr#'addr'||U32'$pad0'||ARR2{*{S8}$S8$}$*{S8}$S8$$'addr_list'||ARR1{S8}$S8$'name'||U56'$pad1'|]
// file connect.c line 287
struct anonymous$20;

// tag-#anon#ST[U32'type'||ENtag-gg_state_t#{U32}$U32$'state'||U64'min_length'||*{S32(*{SYM#tag-gg_session#}$SYM#tag-gg_session#$|U32|*{cS8}$cS8$|U64|*{SYM#tag-gg_event#}$SYM#tag-gg_event#$)->S32}$S32(*{SYM#tag-gg_session#}$SYM#tag-gg_session#$|U32|*{cS8}$cS8$|U64|*{SYM#tag-gg_event#}$SYM#tag-gg_event#$)->S32$'handler'|]
// file handlers.c line 58
struct anonymous$1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$13;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$10;

// tag-ProtobufCAllocator
// file /usr/include/protobuf-c/protobuf-c.h line 333
struct ProtobufCAllocator;

// tag-ProtobufCBinaryData
// file /usr/include/protobuf-c/protobuf-c.h line 334
struct ProtobufCBinaryData;

// tag-ProtobufCBuffer
// file /usr/include/protobuf-c/protobuf-c.h line 335
struct ProtobufCBuffer;

// tag-ProtobufCEnumDescriptor
// file /usr/include/protobuf-c/protobuf-c.h line 337
struct ProtobufCEnumDescriptor;

// tag-ProtobufCEnumValue
// file /usr/include/protobuf-c/protobuf-c.h line 338
struct ProtobufCEnumValue;

// tag-ProtobufCEnumValueIndex
// file /usr/include/protobuf-c/protobuf-c.h line 339
struct ProtobufCEnumValueIndex;

// tag-ProtobufCFieldDescriptor
// file /usr/include/protobuf-c/protobuf-c.h line 340
struct ProtobufCFieldDescriptor;

// tag-ProtobufCIntRange
// file /usr/include/protobuf-c/protobuf-c.h line 341
struct ProtobufCIntRange;

// tag-ProtobufCMessage
// file /usr/include/protobuf-c/protobuf-c.h line 342
struct ProtobufCMessage;

// tag-ProtobufCMessageDescriptor
// file /usr/include/protobuf-c/protobuf-c.h line 343
struct ProtobufCMessageDescriptor;

// tag-ProtobufCMessageUnknownField
// file /usr/include/protobuf-c/protobuf-c.h line 344
struct ProtobufCMessageUnknownField;

// tag-_GG105Login
// file ../include/packets.pb-c.h line 21
struct _GG105Login;

// tag-_GG110AccessInfo
// file ../include/packets.pb-c.h line 31
struct _GG110AccessInfo;

// tag-_GG110Ack
// file ../include/packets.pb-c.h line 20
struct _GG110Ack;

// tag-_GG110Ack__Type
// file ../include/packets.pb-c.h line 40
enum _GG110Ack__Type { GG110_ACK__TYPE__MSG=1, GG110_ACK__TYPE__CHAT=2, GG110_ACK__TYPE__CHAT_INFO=3, GG110_ACK__TYPE__MAGIC_NOTIFICATION=5, GG110_ACK__TYPE__MPA=6, GG110_ACK__TYPE__TRANSFER_INFO=7, _GG110_ACK__TYPE_IS_INT_SIZE=2147483647 };

// tag-_GG110ChatInfoUpdate
// file ../include/packets.pb-c.h line 28
struct _GG110ChatInfoUpdate;

// tag-_GG110Event
// file ../include/packets.pb-c.h line 24
struct _GG110Event;

// tag-_GG110Event__Type
// file ../include/packets.pb-c.h line 49
enum _GG110Event__Type { GG110_EVENT__TYPE__XML=0, GG110_EVENT__TYPE__JSON=2, _GG110_EVENT__TYPE_IS_INT_SIZE=2147483647 };

// tag-_GG110Imtoken
// file ../include/packets.pb-c.h line 27
struct _GG110Imtoken;

// tag-_GG110LoginOK
// file ../include/packets.pb-c.h line 18
struct _GG110LoginOK;

// tag-_GG110MagicNotification
// file ../include/packets.pb-c.h line 35
struct _GG110MagicNotification;

// tag-_GG110MessageAck
// file ../include/packets.pb-c.h line 23
struct _GG110MessageAck;

// tag-_GG110MessageAckLink
// file ../include/packets.pb-c.h line 22
struct _GG110MessageAckLink;

// tag-_GG110Options
// file ../include/packets.pb-c.h line 30
struct _GG110Options;

// tag-_GG110Pong
// file ../include/packets.pb-c.h line 19
struct _GG110Pong;

// tag-_GG110RecvMessage
// file ../include/packets.pb-c.h line 25
struct _GG110RecvMessage;

// tag-_GG110SendMessage
// file ../include/packets.pb-c.h line 26
struct _GG110SendMessage;

// tag-_GG112TransferInfo
// file ../include/packets.pb-c.h line 34
struct _GG112TransferInfo;

// tag-_GG112TransferInfoFile
// file ../include/packets.pb-c.h line 33
struct _GG112TransferInfoFile;

// tag-_GG112TransferInfoUin
// file ../include/packets.pb-c.h line 32
struct _GG112TransferInfoUin;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_ProtobufKVP
// file ../include/packets.pb-c.h line 29
struct _ProtobufKVP;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_gg_chat_list
// file ../../include/internal.h line 85
struct _gg_chat_list;

// tag-_gg_eventqueue
// file ../../include/internal.h line 104
struct _gg_eventqueue;

// tag-_gg_imgout_queue_t
// file ../../include/internal.h line 111
struct _gg_imgout_queue_t;

// tag-_gg_msg_list
// file ../../include/internal.h line 95
struct _gg_msg_list;

// tag-_gg_protobuf_uin_buff
// file ../include/protobuf.h line 41
struct _gg_protobuf_uin_buff;

// tag-gg_add_remove
// file ../include/libgadu.h line 2205
struct gg_add_remove;

// tag-gg_change_info_request
// file ../include/libgadu.h line 1718
struct gg_change_info_request;

// tag-gg_chat_create
// file ../include/protocol.h line 337
struct gg_chat_create;

// tag-gg_chat_created
// file ../include/protocol.h line 357
struct gg_chat_created;

// tag-gg_chat_invite
// file ../include/protocol.h line 342
struct gg_chat_invite;

// tag-gg_chat_invite_ack
// file ../include/protocol.h line 362
struct gg_chat_invite_ack;

// tag-gg_chat_leave
// file ../include/protocol.h line 352
struct gg_chat_leave;

// tag-gg_chat_left
// file ../include/protocol.h line 369
struct gg_chat_left;

// tag-gg_dcc
// file ../../include/libgadu.h line 431
struct gg_dcc;

// tag-gg_dcc7
// file ../../include/libgadu.h line 202
struct gg_dcc7;

// tag-gg_dcc7_accept
// file ../include/libgadu.h line 2568
struct gg_dcc7_accept;

// tag-gg_dcc7_id_reply
// file ../include/libgadu.h line 2604
struct gg_dcc7_id_reply;

// tag-gg_dcc7_id_request
// file ../include/libgadu.h line 2594
struct gg_dcc7_id_request;

// tag-gg_dcc7_info
// file ../include/libgadu.h line 2545
struct gg_dcc7_info;

// tag-gg_dcc7_new
// file ../include/libgadu.h line 2555
struct gg_dcc7_new;

// tag-gg_dcc7_reject
// file ../include/libgadu.h line 2581
struct gg_dcc7_reject;

// tag-gg_dcc7_relay
// file ../../include/libgadu.h line 204
struct gg_dcc7_relay;

// tag-gg_dcc7_relay_reply
// file ../include/protocol.h line 286
struct gg_dcc7_relay_reply;

// tag-gg_dcc7_relay_reply_server
// file ../include/protocol.h line 292
struct gg_dcc7_relay_reply_server;

// tag-gg_dcc7_relay_req
// file ../include/protocol.h line 274
struct gg_dcc7_relay_req;

// tag-gg_dcc7_welcome_p2p
// file ../include/protocol.h line 305
struct gg_dcc7_welcome_p2p;

// tag-gg_dcc7_welcome_server
// file ../include/protocol.h line 300
struct gg_dcc7_welcome_server;

// tag-gg_dcc_big_packet
// file ../include/libgadu.h line 2520
struct gg_dcc_big_packet;

// tag-gg_dcc_small_packet
// file ../include/libgadu.h line 2516
struct gg_dcc_small_packet;

// tag-gg_dcc_tiny_packet
// file ../include/libgadu.h line 2512
struct gg_dcc_tiny_packet;

// tag-gg_error_t
// file ../../include/libgadu.h line 937
enum gg_error_t { GG_ERROR_RESOLVING=1, GG_ERROR_CONNECTING=2, GG_ERROR_READING=3, GG_ERROR_WRITING=4, GG_ERROR_DCC_HANDSHAKE=5, GG_ERROR_DCC_FILE=6, GG_ERROR_DCC_EOF=7, GG_ERROR_DCC_NET=8, GG_ERROR_DCC_REFUSED=9, GG_ERROR_DCC7_HANDSHAKE=10, GG_ERROR_DCC7_FILE=11, GG_ERROR_DCC7_EOF=12, GG_ERROR_DCC7_NET=13, GG_ERROR_DCC7_REFUSED=14, GG_ERROR_DCC7_RELAY=15 };

// tag-gg_event
// file ../../include/libgadu.h line 265
struct gg_event;

// tag-gg_event_ack
// file ../../include/libgadu.h line 1070
struct gg_event_ack;

// tag-gg_event_ack110
// file ../../include/libgadu.h line 1079
struct gg_event_ack110;

// tag-gg_event_chat_created
// file ../../include/libgadu.h line 1294
struct gg_event_chat_created;

// tag-gg_event_chat_info
// file ../../include/libgadu.h line 1272
struct gg_event_chat_info;

// tag-gg_event_chat_info_update
// file ../../include/libgadu.h line 1282
struct gg_event_chat_info_update;

// tag-gg_event_chat_invite_ack
// file ../../include/libgadu.h line 1302
struct gg_event_chat_invite_ack;

// tag-gg_event_dcc7_accept
// file ../../include/libgadu.h line 1161
struct gg_event_dcc7_accept;

// tag-gg_event_dcc7_connected
// file ../../include/libgadu.h line 1139
struct gg_event_dcc7_connected;

// tag-gg_event_dcc7_done
// file ../../include/libgadu.h line 1171
struct gg_event_dcc7_done;

// tag-gg_event_dcc7_pending
// file ../../include/libgadu.h line 1146
struct gg_event_dcc7_pending;

// tag-gg_event_dcc7_reject
// file ../../include/libgadu.h line 1153
struct gg_event_dcc7_reject;

// tag-gg_event_dcc_voice_data
// file ../../include/libgadu.h line 1096
struct gg_event_dcc_voice_data;

// tag-gg_event_image_reply
// file ../../include/libgadu.h line 1113
struct gg_event_image_reply;

// tag-gg_event_image_request
// file ../../include/libgadu.h line 1104
struct gg_event_image_request;

// tag-gg_event_imtoken
// file ../../include/libgadu.h line 1254
struct gg_event_imtoken;

// tag-gg_event_json_event
// file ../../include/libgadu.h line 1131
struct gg_event_json_event;

// tag-gg_event_msg
// file ../../include/libgadu.h line 991
struct gg_event_msg;

// tag-gg_event_multilogon_info
// file ../../include/libgadu.h line 1229
struct gg_event_multilogon_info;

// tag-gg_event_notify60
// file ../../include/libgadu.h line 1052
struct gg_event_notify60;

// tag-gg_event_notify_descr
// file ../../include/libgadu.h line 1017
struct gg_event_notify_descr;

// tag-gg_event_pong110
// file ../../include/libgadu.h line 1261
struct gg_event_pong110;

// tag-gg_event_status
// file ../../include/libgadu.h line 1025
struct gg_event_status;

// tag-gg_event_status60
// file ../../include/libgadu.h line 1034
struct gg_event_status60;

// tag-gg_event_t
// file ../include/libgadu.h line 845
enum gg_event_t { GG_EVENT_NONE=0, GG_EVENT_MSG=1, GG_EVENT_NOTIFY=2, GG_EVENT_NOTIFY_DESCR=3, GG_EVENT_STATUS=4, GG_EVENT_ACK=5, GG_EVENT_PONG=6, GG_EVENT_CONN_FAILED=7, GG_EVENT_CONN_SUCCESS=8, GG_EVENT_DISCONNECT=9, GG_EVENT_DCC_NEW=10, GG_EVENT_DCC_ERROR=11, GG_EVENT_DCC_DONE=12, GG_EVENT_DCC_CLIENT_ACCEPT=13, GG_EVENT_DCC_CALLBACK=14, GG_EVENT_DCC_NEED_FILE_INFO=15, GG_EVENT_DCC_NEED_FILE_ACK=16, GG_EVENT_DCC_NEED_VOICE_ACK=17, GG_EVENT_DCC_VOICE_DATA=18, GG_EVENT_PUBDIR50_SEARCH_REPLY=19, GG_EVENT_PUBDIR50_READ=20, GG_EVENT_PUBDIR50_WRITE=21, GG_EVENT_STATUS60=22, GG_EVENT_NOTIFY60=23, GG_EVENT_USERLIST=24, GG_EVENT_IMAGE_REQUEST=25, GG_EVENT_IMAGE_REPLY=26, GG_EVENT_DCC_ACK=27, GG_EVENT_DCC7_NEW=28, GG_EVENT_DCC7_ACCEPT=29, GG_EVENT_DCC7_REJECT=30, GG_EVENT_DCC7_CONNECTED=31, GG_EVENT_DCC7_ERROR=32, GG_EVENT_DCC7_DONE=33, GG_EVENT_DCC7_PENDING=34, GG_EVENT_XML_EVENT=35, GG_EVENT_DISCONNECT_ACK=36, GG_EVENT_TYPING_NOTIFICATION=37, GG_EVENT_USER_DATA=38, GG_EVENT_MULTILOGON_MSG=39, GG_EVENT_MULTILOGON_INFO=40, GG_EVENT_USERLIST100_VERSION=41, GG_EVENT_USERLIST100_REPLY=42, GG_EVENT_IMTOKEN=43, GG_EVENT_PONG110=44, GG_EVENT_JSON_EVENT=45, GG_EVENT_ACK110=46, GG_EVENT_CHAT_INFO=47, GG_EVENT_CHAT_INFO_GOT_ALL=48, GG_EVENT_CHAT_INFO_UPDATE=49, GG_EVENT_CHAT_CREATED=50, GG_EVENT_CHAT_INVITE_ACK=51 };

// tag-gg_event_typing_notification
// file ../../include/libgadu.h line 1178
struct gg_event_typing_notification;

// tag-gg_event_union
// file ../../include/libgadu.h line 1313
union gg_event_union;

// tag-gg_event_user_data
// file ../../include/libgadu.h line 1204
struct gg_event_user_data;

// tag-gg_event_user_data_attr
// file ../../include/libgadu.h line 1186
struct gg_event_user_data_attr;

// tag-gg_event_user_data_user
// file ../../include/libgadu.h line 1195
struct gg_event_user_data_user;

// tag-gg_event_userlist
// file ../../include/libgadu.h line 1088
struct gg_event_userlist;

// tag-gg_event_userlist100_reply
// file ../../include/libgadu.h line 1244
struct gg_event_userlist100_reply;

// tag-gg_event_userlist100_version
// file ../../include/libgadu.h line 1237
struct gg_event_userlist100_version;

// tag-gg_event_xml_event
// file ../../include/libgadu.h line 1124
struct gg_event_xml_event;

// tag-gg_failure_t
// file ../../include/libgadu.h line 913
enum gg_failure_t { GG_FAILURE_RESOLVING=1, GG_FAILURE_CONNECTING=2, GG_FAILURE_INVALID=3, GG_FAILURE_READING=4, GG_FAILURE_WRITING=5, GG_FAILURE_PASSWORD=6, GG_FAILURE_404=7, GG_FAILURE_TLS=8, GG_FAILURE_NEED_EMAIL=9, GG_FAILURE_INTRUDER=10, GG_FAILURE_UNAVAILABLE=11, GG_FAILURE_PROXY=12, GG_FAILURE_HUB=13, GG_FAILURE_INTERNAL=14 };

// tag-gg_file_info
// file ../../include/libgadu.h line 409
struct gg_file_info;

// tag-gg_header
// file ../include/libgadu.h line 1877
struct gg_header;

// tag-gg_http
// file ../include/libgadu.h line 360
struct gg_http;

// tag-gg_image_queue
// file ../../include/libgadu.h line 200
struct gg_image_queue;

// tag-gg_login80
// file ../include/protocol.h line 53
struct gg_login80;

// tag-gg_login_params
// file ../../include/libgadu.h line 756
struct gg_login_params;

// tag-gg_msg_image_reply
// file ../include/libgadu.h line 2337
struct gg_msg_image_reply;

// tag-gg_msg_image_request
// file ../include/libgadu.h line 2331
struct gg_msg_image_request;

// tag-gg_msg_recipients
// file ../include/libgadu.h line 2326
struct gg_msg_recipients;

// tag-gg_multilogon_disconnect
// file ../include/protocol.h line 194
struct gg_multilogon_disconnect;

// tag-gg_multilogon_info
// file ../include/protocol.h line 178
struct gg_multilogon_info;

// tag-gg_multilogon_info_item
// file ../include/protocol.h line 182
struct gg_multilogon_info_item;

// tag-gg_multilogon_session
// file ../../include/libgadu.h line 1213
struct gg_multilogon_session;

// tag-gg_new_status80
// file ../include/protocol.h line 98
struct gg_new_status80;

// tag-gg_notify
// file ../include/libgadu.h line 2113
struct gg_notify;

// tag-gg_notify_reply
// file ../../include/libgadu.h line 1018
struct gg_notify_reply;

// tag-gg_notify_reply60
// file ../include/libgadu.h line 2154
struct gg_notify_reply60;

// tag-gg_notify_reply77
// file ../include/libgadu.h line 2178
struct gg_notify_reply77;

// tag-gg_notify_reply80
// file ../include/protocol.h line 112
struct gg_notify_reply80;

// tag-gg_pubdir
// file ../include/libgadu.h line 1484
struct gg_pubdir;

// tag-gg_pubdir50_entry
// file ../../include/libgadu.h line 960
struct gg_pubdir50_entry;

// tag-gg_pubdir50_reply
// file ../include/libgadu.h line 1959
struct gg_pubdir50_reply;

// tag-gg_pubdir50_request
// file ../include/libgadu.h line 1952
struct gg_pubdir50_request;

// tag-gg_pubdir50_s
// file ../../include/libgadu.h line 971
struct gg_pubdir50_s;

// tag-gg_recv_msg
// file ../include/libgadu.h line 2381
struct gg_recv_msg;

// tag-gg_recv_msg80
// file ../include/protocol.h line 136
struct gg_recv_msg80;

// tag-gg_recv_msg_ack
// file ../include/protocol.h line 149
struct gg_recv_msg_ack;

// tag-gg_resolver_fork_data
// file resolver.c line 370
struct gg_resolver_fork_data;

// tag-gg_resolver_pthread_data
// file resolver.c line 494
struct gg_resolver_pthread_data;

// tag-gg_search_request
// file ../include/libgadu.h line 1659
struct gg_search_request;

// tag-gg_send_msg
// file ../../include/libgadu.h line 2255
struct gg_send_msg;

// tag-gg_send_msg80
// file ../include/protocol.h line 126
struct gg_send_msg80;

// tag-gg_send_msg_ack
// file ../include/libgadu.h line 2373
struct gg_send_msg_ack;

// tag-gg_session
// file ../../include/libgadu.h line 255
struct gg_session;

// tag-gg_session_private
// file ../../include/libgadu.h line 206
struct gg_session_private;

// tag-gg_state_t
// file ../include/libgadu.h line 549
enum gg_state_t { GG_STATE_IDLE=0, GG_STATE_RESOLVING=1, GG_STATE_CONNECTING=2, GG_STATE_READING_DATA=3, GG_STATE_ERROR=4, GG_STATE_CONNECTING_HUB=5, GG_STATE_CONNECTING_GG=6, GG_STATE_READING_KEY=7, GG_STATE_READING_REPLY=8, GG_STATE_CONNECTED=9, GG_STATE_SENDING_QUERY=10, GG_STATE_READING_HEADER=11, GG_STATE_PARSING=12, GG_STATE_DONE=13, GG_STATE_LISTENING=14, GG_STATE_READING_UIN_1=15, GG_STATE_READING_UIN_2=16, GG_STATE_SENDING_ACK=17, GG_STATE_READING_ACK=18, GG_STATE_READING_REQUEST=19, GG_STATE_SENDING_REQUEST=20, GG_STATE_SENDING_FILE_INFO=21, GG_STATE_READING_PRE_FILE_INFO=22, GG_STATE_READING_FILE_INFO=23, GG_STATE_SENDING_FILE_ACK=24, GG_STATE_READING_FILE_ACK=25, GG_STATE_SENDING_FILE_HEADER=26, GG_STATE_READING_FILE_HEADER=27, GG_STATE_GETTING_FILE=28, GG_STATE_SENDING_FILE=29, GG_STATE_READING_VOICE_ACK=30, GG_STATE_READING_VOICE_HEADER=31, GG_STATE_READING_VOICE_SIZE=32, GG_STATE_READING_VOICE_DATA=33, GG_STATE_SENDING_VOICE_ACK=34, GG_STATE_SENDING_VOICE_REQUEST=35, GG_STATE_READING_TYPE=36, GG_STATE_TLS_NEGOTIATION=37, GG_STATE_REQUESTING_ID=38, GG_STATE_WAITING_FOR_ACCEPT=39, GG_STATE_WAITING_FOR_INFO=40, GG_STATE_READING_ID=41, GG_STATE_SENDING_ID=42, GG_STATE_RESOLVING_GG=43, GG_STATE_RESOLVING_RELAY=44, GG_STATE_CONNECTING_RELAY=45, GG_STATE_READING_RELAY=46, GG_STATE_DISCONNECTING=47, GG_STATE_CONNECT_HUB=48, GG_STATE_CONNECT_PROXY_HUB=49, GG_STATE_CONNECT_GG=50, GG_STATE_CONNECT_PROXY_GG=51, GG_STATE_CONNECTING_PROXY_HUB=52, GG_STATE_CONNECTING_PROXY_GG=53, GG_STATE_RESOLVE_HUB_SYNC=54, GG_STATE_RESOLVE_HUB_ASYNC=55, GG_STATE_RESOLVE_PROXY_HUB_SYNC=56, GG_STATE_RESOLVE_PROXY_HUB_ASYNC=57, GG_STATE_RESOLVE_PROXY_GG_SYNC=58, GG_STATE_RESOLVE_PROXY_GG_ASYNC=59, GG_STATE_RESOLVE_GG_SYNC=60, GG_STATE_RESOLVE_GG_ASYNC=61, GG_STATE_RESOLVING_HUB=62, GG_STATE_RESOLVING_PROXY_HUB=63, GG_STATE_RESOLVING_PROXY_GG=64, GG_STATE_SEND_HUB=65, GG_STATE_SEND_PROXY_HUB=66, GG_STATE_SEND_PROXY_GG=67, GG_STATE_SENDING_HUB=68, GG_STATE_SENDING_PROXY_HUB=69, GG_STATE_SENDING_PROXY_GG=70, GG_STATE_READING_HUB=71, GG_STATE_READING_PROXY_HUB=72, GG_STATE_READING_PROXY_GG=73 };

// tag-gg_status
// file ../include/libgadu.h line 2212
struct gg_status;

// tag-gg_status60
// file ../include/libgadu.h line 2166
struct gg_status60;

// tag-gg_status77
// file ../include/libgadu.h line 2191
struct gg_status77;

// tag-gg_token
// file ../include/libgadu.h line 1498
struct gg_token;

// tag-gg_tvbuff
// file ../include/tvbuff.h line 26
struct gg_tvbuff;

// tag-gg_tvbuilder
// file ../include/tvbuilder.h line 26
struct gg_tvbuilder;

// tag-gg_typing_notification
// file ../include/protocol.h line 167
struct gg_typing_notification;

// tag-gg_user_data
// file ../include/protocol.h line 155
struct gg_user_data;

// tag-gg_user_data_user
// file ../include/protocol.h line 160
struct gg_user_data_user;

// tag-gg_userlist100_reply
// file ../include/protocol.h line 329
struct gg_userlist100_reply;

// tag-gg_userlist100_request
// file ../include/protocol.h line 319
struct gg_userlist100_request;

// tag-gg_userlist100_version
// file ../include/protocol.h line 313
struct gg_userlist100_version;

// tag-gg_welcome
// file ../include/libgadu.h line 1885
struct gg_welcome;

// tag-gnutls_certificate_credentials_st
// file /usr/include/gnutls/gnutls.h line 1399
struct gnutls_certificate_credentials_st;

// tag-gnutls_cipher_algorithm
// file /usr/include/gnutls/gnutls.h line 119
enum gnutls_cipher_algorithm { GNUTLS_CIPHER_UNKNOWN=0, GNUTLS_CIPHER_NULL=1, GNUTLS_CIPHER_ARCFOUR_128=2, GNUTLS_CIPHER_3DES_CBC=3, GNUTLS_CIPHER_AES_128_CBC=4, GNUTLS_CIPHER_AES_256_CBC=5, GNUTLS_CIPHER_ARCFOUR_40=6, GNUTLS_CIPHER_CAMELLIA_128_CBC=7, GNUTLS_CIPHER_CAMELLIA_256_CBC=8, GNUTLS_CIPHER_AES_192_CBC=9, GNUTLS_CIPHER_AES_128_GCM=10, GNUTLS_CIPHER_AES_256_GCM=11, GNUTLS_CIPHER_CAMELLIA_192_CBC=12, GNUTLS_CIPHER_SALSA20_256=13, GNUTLS_CIPHER_ESTREAM_SALSA20_256=14, GNUTLS_CIPHER_CAMELLIA_128_GCM=15, GNUTLS_CIPHER_CAMELLIA_256_GCM=16, GNUTLS_CIPHER_RC2_40_CBC=17, GNUTLS_CIPHER_DES_CBC=18, GNUTLS_CIPHER_AES_128_CCM=19, GNUTLS_CIPHER_AES_256_CCM=20, GNUTLS_CIPHER_AES_128_CCM_8=21, GNUTLS_CIPHER_AES_256_CCM_8=22, GNUTLS_CIPHER_CHACHA20_POLY1305=23, GNUTLS_CIPHER_IDEA_PGP_CFB=200, GNUTLS_CIPHER_3DES_PGP_CFB=201, GNUTLS_CIPHER_CAST5_PGP_CFB=202, GNUTLS_CIPHER_BLOWFISH_PGP_CFB=203, GNUTLS_CIPHER_SAFER_SK128_PGP_CFB=204, GNUTLS_CIPHER_AES128_PGP_CFB=205, GNUTLS_CIPHER_AES192_PGP_CFB=206, GNUTLS_CIPHER_AES256_PGP_CFB=207, GNUTLS_CIPHER_TWOFISH_PGP_CFB=208 };

// tag-gnutls_dh_params_int
// file /usr/include/gnutls/gnutls.h line 785
struct gnutls_dh_params_int;

// tag-gnutls_session_int
// file /usr/include/gnutls/gnutls.h line 782
struct gnutls_session_int;

// tag-gnutls_x509_crt_int
// file /usr/include/gnutls/gnutls.h line 1387
struct gnutls_x509_crt_int;

// tag-hash_hd_st
// file /usr/include/gnutls/crypto.h line 89
struct hash_hd_st;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file ../../include/libgadu.h line 340
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __connect
// file connect.c line 284
extern signed int __connect(signed int, struct sockaddr *, unsigned int);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$24 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$24 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$24 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// client_func
// file connect.c line 558
static signed int client_func(const struct anonymous$16 *test);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file connect.c line 380
extern signed int connect(signed int socket, struct sockaddr *address, unsigned int address_len);
// debug
// file connect.c line 274
static void debug(const char *fmt, ...);
// debug_handler
// file connect.c line 211
static void debug_handler(signed int level, const char *format, void **ap);
// deflate
// file /usr/include/zlib.h line 246
extern signed int deflate(struct z_stream_s *, signed int);
// deflateBound
// file /usr/include/zlib.h line 698
extern unsigned long int deflateBound(struct z_stream_s *, unsigned long int);
// deflateEnd
// file /usr/include/zlib.h line 353
extern signed int deflateEnd(struct z_stream_s *);
// deflateInit_
// file /usr/include/zlib.h line 1633
extern signed int deflateInit_(struct z_stream_s *, signed int, const char *, signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// failure
// file connect.c line 146
static void failure(void);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// get32
// file connect.c line 266
static inline unsigned int get32(char *ptr);
// get_test_param
// file connect.c line 204
static struct anonymous$16 * get_test_param(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file connect.c line 303
extern struct hostent * gethostbyname(const char *name);
// gethostbyname_r
// file connect.c line 316
extern signed int gethostbyname_r(const char *name, struct hostent *ret, char *buf, unsigned long int buflen, struct hostent **result, signed int *h_errnop);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gg105_login__free_unpacked
// file packets.pb-c.c line 175
void gg105_login__free_unpacked(struct _GG105Login *message, struct ProtobufCAllocator *allocator);
// gg105_login__get_packed_size
// file ../include/packets.pb-c.h line 534
unsigned long int gg105_login__get_packed_size(const struct _GG105Login *message);
// gg105_login__init
// file packets.pb-c.c line 139
void gg105_login__init(struct _GG105Login *message);
// gg105_login__pack
// file ../include/packets.pb-c.h line 536
unsigned long int gg105_login__pack(const struct _GG105Login *message, unsigned char *out);
// gg105_login__pack_to_buffer
// file packets.pb-c.c line 158
unsigned long int gg105_login__pack_to_buffer(const struct _GG105Login *message, struct ProtobufCBuffer *buffer);
// gg105_login__unpack
// file packets.pb-c.c line 166
struct _GG105Login * gg105_login__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_access_info__free_unpacked
// file ../include/packets.pb-c.h line 737
void gg110_access_info__free_unpacked(struct _GG110AccessInfo *message, struct ProtobufCAllocator *allocator);
// gg110_access_info__get_packed_size
// file packets.pb-c.c line 575
unsigned long int gg110_access_info__get_packed_size(const struct _GG110AccessInfo *message);
// gg110_access_info__init
// file packets.pb-c.c line 569
void gg110_access_info__init(struct _GG110AccessInfo *message);
// gg110_access_info__pack
// file packets.pb-c.c line 581
unsigned long int gg110_access_info__pack(const struct _GG110AccessInfo *message, unsigned char *out);
// gg110_access_info__pack_to_buffer
// file packets.pb-c.c line 588
unsigned long int gg110_access_info__pack_to_buffer(const struct _GG110AccessInfo *message, struct ProtobufCBuffer *buffer);
// gg110_access_info__unpack
// file ../include/packets.pb-c.h line 733
struct _GG110AccessInfo * gg110_access_info__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_ack__free_unpacked
// file packets.pb-c.c line 132
void gg110_ack__free_unpacked(struct _GG110Ack *message, struct ProtobufCAllocator *allocator);
// gg110_ack__get_packed_size
// file ../include/packets.pb-c.h line 515
unsigned long int gg110_ack__get_packed_size(const struct _GG110Ack *message);
// gg110_ack__init
// file packets.pb-c.c line 96
void gg110_ack__init(struct _GG110Ack *message);
// gg110_ack__pack
// file ../include/packets.pb-c.h line 517
unsigned long int gg110_ack__pack(const struct _GG110Ack *message, unsigned char *out);
// gg110_ack__pack_to_buffer
// file packets.pb-c.c line 115
unsigned long int gg110_ack__pack_to_buffer(const struct _GG110Ack *message, struct ProtobufCBuffer *buffer);
// gg110_ack__unpack
// file packets.pb-c.c line 123
struct _GG110Ack * gg110_ack__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_chat_info_update__free_unpacked
// file ../include/packets.pb-c.h line 680
void gg110_chat_info_update__free_unpacked(struct _GG110ChatInfoUpdate *message, struct ProtobufCAllocator *allocator);
// gg110_chat_info_update__get_packed_size
// file packets.pb-c.c line 446
unsigned long int gg110_chat_info_update__get_packed_size(const struct _GG110ChatInfoUpdate *message);
// gg110_chat_info_update__init
// file packets.pb-c.c line 440
void gg110_chat_info_update__init(struct _GG110ChatInfoUpdate *message);
// gg110_chat_info_update__pack
// file packets.pb-c.c line 452
unsigned long int gg110_chat_info_update__pack(const struct _GG110ChatInfoUpdate *message, unsigned char *out);
// gg110_chat_info_update__pack_to_buffer
// file packets.pb-c.c line 459
unsigned long int gg110_chat_info_update__pack_to_buffer(const struct _GG110ChatInfoUpdate *message, struct ProtobufCBuffer *buffer);
// gg110_chat_info_update__unpack
// file ../include/packets.pb-c.h line 676
struct _GG110ChatInfoUpdate * gg110_chat_info_update__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_event__free_unpacked
// file ../include/packets.pb-c.h line 604
void gg110_event__free_unpacked(struct _GG110Event *message, struct ProtobufCAllocator *allocator);
// gg110_event__get_packed_size
// file packets.pb-c.c line 274
unsigned long int gg110_event__get_packed_size(const struct _GG110Event *message);
// gg110_event__init
// file packets.pb-c.c line 268
void gg110_event__init(struct _GG110Event *message);
// gg110_event__pack
// file packets.pb-c.c line 280
unsigned long int gg110_event__pack(const struct _GG110Event *message, unsigned char *out);
// gg110_event__pack_to_buffer
// file packets.pb-c.c line 287
unsigned long int gg110_event__pack_to_buffer(const struct _GG110Event *message, struct ProtobufCBuffer *buffer);
// gg110_event__unpack
// file ../include/packets.pb-c.h line 600
struct _GG110Event * gg110_event__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_imtoken__free_unpacked
// file ../include/packets.pb-c.h line 661
void gg110_imtoken__free_unpacked(struct _GG110Imtoken *message, struct ProtobufCAllocator *allocator);
// gg110_imtoken__get_packed_size
// file packets.pb-c.c line 403
unsigned long int gg110_imtoken__get_packed_size(const struct _GG110Imtoken *message);
// gg110_imtoken__init
// file packets.pb-c.c line 397
void gg110_imtoken__init(struct _GG110Imtoken *message);
// gg110_imtoken__pack
// file packets.pb-c.c line 409
unsigned long int gg110_imtoken__pack(const struct _GG110Imtoken *message, unsigned char *out);
// gg110_imtoken__pack_to_buffer
// file packets.pb-c.c line 416
unsigned long int gg110_imtoken__pack_to_buffer(const struct _GG110Imtoken *message, struct ProtobufCBuffer *buffer);
// gg110_imtoken__unpack
// file ../include/packets.pb-c.h line 657
struct _GG110Imtoken * gg110_imtoken__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_login_ok__free_unpacked
// file ../include/packets.pb-c.h line 490
void gg110_login_ok__free_unpacked(struct _GG110LoginOK *message, struct ProtobufCAllocator *allocator);
// gg110_login_ok__get_packed_size
// file packets.pb-c.c line 16
unsigned long int gg110_login_ok__get_packed_size(const struct _GG110LoginOK *message);
// gg110_login_ok__init
// file packets.pb-c.c line 10
void gg110_login_ok__init(struct _GG110LoginOK *message);
// gg110_login_ok__pack
// file packets.pb-c.c line 22
unsigned long int gg110_login_ok__pack(const struct _GG110LoginOK *message, unsigned char *out);
// gg110_login_ok__pack_to_buffer
// file packets.pb-c.c line 29
unsigned long int gg110_login_ok__pack_to_buffer(const struct _GG110LoginOK *message, struct ProtobufCBuffer *buffer);
// gg110_login_ok__unpack
// file ../include/packets.pb-c.h line 486
struct _GG110LoginOK * gg110_login_ok__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_magic_notification__free_unpacked
// file ../include/packets.pb-c.h line 813
void gg110_magic_notification__free_unpacked(struct _GG110MagicNotification *message, struct ProtobufCAllocator *allocator);
// gg110_magic_notification__get_packed_size
// file packets.pb-c.c line 747
unsigned long int gg110_magic_notification__get_packed_size(const struct _GG110MagicNotification *message);
// gg110_magic_notification__init
// file packets.pb-c.c line 741
void gg110_magic_notification__init(struct _GG110MagicNotification *message);
// gg110_magic_notification__pack
// file packets.pb-c.c line 753
unsigned long int gg110_magic_notification__pack(const struct _GG110MagicNotification *message, unsigned char *out);
// gg110_magic_notification__pack_to_buffer
// file packets.pb-c.c line 760
unsigned long int gg110_magic_notification__pack_to_buffer(const struct _GG110MagicNotification *message, struct ProtobufCBuffer *buffer);
// gg110_magic_notification__unpack
// file ../include/packets.pb-c.h line 809
struct _GG110MagicNotification * gg110_magic_notification__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_message_ack__free_unpacked
// file ../include/packets.pb-c.h line 585
void gg110_message_ack__free_unpacked(struct _GG110MessageAck *message, struct ProtobufCAllocator *allocator);
// gg110_message_ack__get_packed_size
// file packets.pb-c.c line 231
unsigned long int gg110_message_ack__get_packed_size(const struct _GG110MessageAck *message);
// gg110_message_ack__init
// file packets.pb-c.c line 225
void gg110_message_ack__init(struct _GG110MessageAck *message);
// gg110_message_ack__pack
// file packets.pb-c.c line 237
unsigned long int gg110_message_ack__pack(const struct _GG110MessageAck *message, unsigned char *out);
// gg110_message_ack__pack_to_buffer
// file packets.pb-c.c line 244
unsigned long int gg110_message_ack__pack_to_buffer(const struct _GG110MessageAck *message, struct ProtobufCBuffer *buffer);
// gg110_message_ack__unpack
// file ../include/packets.pb-c.h line 581
struct _GG110MessageAck * gg110_message_ack__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_message_ack_link__free_unpacked
// file packets.pb-c.c line 218
void gg110_message_ack_link__free_unpacked(struct _GG110MessageAckLink *message, struct ProtobufCAllocator *allocator);
// gg110_message_ack_link__get_packed_size
// file packets.pb-c.c line 188
unsigned long int gg110_message_ack_link__get_packed_size(const struct _GG110MessageAckLink *message);
// gg110_message_ack_link__init
// file packets.pb-c.c line 182
void gg110_message_ack_link__init(struct _GG110MessageAckLink *message);
// gg110_message_ack_link__pack
// file packets.pb-c.c line 194
unsigned long int gg110_message_ack_link__pack(const struct _GG110MessageAckLink *message, unsigned char *out);
// gg110_message_ack_link__pack_to_buffer
// file packets.pb-c.c line 201
unsigned long int gg110_message_ack_link__pack_to_buffer(const struct _GG110MessageAckLink *message, struct ProtobufCBuffer *buffer);
// gg110_message_ack_link__unpack
// file packets.pb-c.c line 209
struct _GG110MessageAckLink * gg110_message_ack_link__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_options__free_unpacked
// file ../include/packets.pb-c.h line 718
void gg110_options__free_unpacked(struct _GG110Options *message, struct ProtobufCAllocator *allocator);
// gg110_options__get_packed_size
// file packets.pb-c.c line 532
unsigned long int gg110_options__get_packed_size(const struct _GG110Options *message);
// gg110_options__init
// file packets.pb-c.c line 526
void gg110_options__init(struct _GG110Options *message);
// gg110_options__pack
// file packets.pb-c.c line 538
unsigned long int gg110_options__pack(const struct _GG110Options *message, unsigned char *out);
// gg110_options__pack_to_buffer
// file packets.pb-c.c line 545
unsigned long int gg110_options__pack_to_buffer(const struct _GG110Options *message, struct ProtobufCBuffer *buffer);
// gg110_options__unpack
// file ../include/packets.pb-c.h line 714
struct _GG110Options * gg110_options__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_pong__free_unpacked
// file ../include/packets.pb-c.h line 509
void gg110_pong__free_unpacked(struct _GG110Pong *message, struct ProtobufCAllocator *allocator);
// gg110_pong__get_packed_size
// file packets.pb-c.c line 59
unsigned long int gg110_pong__get_packed_size(const struct _GG110Pong *message);
// gg110_pong__init
// file packets.pb-c.c line 53
void gg110_pong__init(struct _GG110Pong *message);
// gg110_pong__pack
// file packets.pb-c.c line 65
unsigned long int gg110_pong__pack(const struct _GG110Pong *message, unsigned char *out);
// gg110_pong__pack_to_buffer
// file packets.pb-c.c line 72
unsigned long int gg110_pong__pack_to_buffer(const struct _GG110Pong *message, struct ProtobufCBuffer *buffer);
// gg110_pong__unpack
// file ../include/packets.pb-c.h line 505
struct _GG110Pong * gg110_pong__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_recv_message__free_unpacked
// file ../include/packets.pb-c.h line 623
void gg110_recv_message__free_unpacked(struct _GG110RecvMessage *message, struct ProtobufCAllocator *allocator);
// gg110_recv_message__get_packed_size
// file packets.pb-c.c line 317
unsigned long int gg110_recv_message__get_packed_size(const struct _GG110RecvMessage *message);
// gg110_recv_message__init
// file packets.pb-c.c line 311
void gg110_recv_message__init(struct _GG110RecvMessage *message);
// gg110_recv_message__pack
// file packets.pb-c.c line 323
unsigned long int gg110_recv_message__pack(const struct _GG110RecvMessage *message, unsigned char *out);
// gg110_recv_message__pack_to_buffer
// file packets.pb-c.c line 330
unsigned long int gg110_recv_message__pack_to_buffer(const struct _GG110RecvMessage *message, struct ProtobufCBuffer *buffer);
// gg110_recv_message__unpack
// file ../include/packets.pb-c.h line 619
struct _GG110RecvMessage * gg110_recv_message__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg110_send_message__free_unpacked
// file packets.pb-c.c line 390
void gg110_send_message__free_unpacked(struct _GG110SendMessage *message, struct ProtobufCAllocator *allocator);
// gg110_send_message__get_packed_size
// file ../include/packets.pb-c.h line 629
unsigned long int gg110_send_message__get_packed_size(const struct _GG110SendMessage *message);
// gg110_send_message__init
// file packets.pb-c.c line 354
void gg110_send_message__init(struct _GG110SendMessage *message);
// gg110_send_message__pack
// file ../include/packets.pb-c.h line 631
unsigned long int gg110_send_message__pack(const struct _GG110SendMessage *message, unsigned char *out);
// gg110_send_message__pack_to_buffer
// file packets.pb-c.c line 373
unsigned long int gg110_send_message__pack_to_buffer(const struct _GG110SendMessage *message, struct ProtobufCBuffer *buffer);
// gg110_send_message__unpack
// file packets.pb-c.c line 381
struct _GG110SendMessage * gg110_send_message__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg112_transfer_info__free_unpacked
// file ../include/packets.pb-c.h line 794
void gg112_transfer_info__free_unpacked(struct _GG112TransferInfo *message, struct ProtobufCAllocator *allocator);
// gg112_transfer_info__get_packed_size
// file packets.pb-c.c line 704
unsigned long int gg112_transfer_info__get_packed_size(const struct _GG112TransferInfo *message);
// gg112_transfer_info__init
// file packets.pb-c.c line 698
void gg112_transfer_info__init(struct _GG112TransferInfo *message);
// gg112_transfer_info__pack
// file packets.pb-c.c line 710
unsigned long int gg112_transfer_info__pack(const struct _GG112TransferInfo *message, unsigned char *out);
// gg112_transfer_info__pack_to_buffer
// file packets.pb-c.c line 717
unsigned long int gg112_transfer_info__pack_to_buffer(const struct _GG112TransferInfo *message, struct ProtobufCBuffer *buffer);
// gg112_transfer_info__unpack
// file ../include/packets.pb-c.h line 790
struct _GG112TransferInfo * gg112_transfer_info__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg112_transfer_info_file__free_unpacked
// file packets.pb-c.c line 691
void gg112_transfer_info_file__free_unpacked(struct _GG112TransferInfoFile *message, struct ProtobufCAllocator *allocator);
// gg112_transfer_info_file__get_packed_size
// file packets.pb-c.c line 661
unsigned long int gg112_transfer_info_file__get_packed_size(const struct _GG112TransferInfoFile *message);
// gg112_transfer_info_file__init
// file packets.pb-c.c line 655
void gg112_transfer_info_file__init(struct _GG112TransferInfoFile *message);
// gg112_transfer_info_file__pack
// file packets.pb-c.c line 667
unsigned long int gg112_transfer_info_file__pack(const struct _GG112TransferInfoFile *message, unsigned char *out);
// gg112_transfer_info_file__pack_to_buffer
// file packets.pb-c.c line 674
unsigned long int gg112_transfer_info_file__pack_to_buffer(const struct _GG112TransferInfoFile *message, struct ProtobufCBuffer *buffer);
// gg112_transfer_info_file__unpack
// file packets.pb-c.c line 682
struct _GG112TransferInfoFile * gg112_transfer_info_file__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg112_transfer_info_uin__free_unpacked
// file packets.pb-c.c line 648
void gg112_transfer_info_uin__free_unpacked(struct _GG112TransferInfoUin *message, struct ProtobufCAllocator *allocator);
// gg112_transfer_info_uin__get_packed_size
// file packets.pb-c.c line 618
unsigned long int gg112_transfer_info_uin__get_packed_size(const struct _GG112TransferInfoUin *message);
// gg112_transfer_info_uin__init
// file packets.pb-c.c line 612
void gg112_transfer_info_uin__init(struct _GG112TransferInfoUin *message);
// gg112_transfer_info_uin__pack
// file packets.pb-c.c line 624
unsigned long int gg112_transfer_info_uin__pack(const struct _GG112TransferInfoUin *message, unsigned char *out);
// gg112_transfer_info_uin__pack_to_buffer
// file packets.pb-c.c line 631
unsigned long int gg112_transfer_info_uin__pack_to_buffer(const struct _GG112TransferInfoUin *message, struct ProtobufCBuffer *buffer);
// gg112_transfer_info_uin__unpack
// file packets.pb-c.c line 639
struct _GG112TransferInfoUin * gg112_transfer_info_uin__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// gg_ack_110
// file handlers.c line 69
static signed int gg_ack_110(struct gg_session *gs, enum _GG110Ack__Type type, unsigned int seq, struct gg_event *ge);
// gg_add_notify
// file libgadu.c line 2440
signed int gg_add_notify(struct gg_session *sess, unsigned int uin);
// gg_add_notify_ex
// file libgadu.c line 2393
signed int gg_add_notify_ex(struct gg_session *sess, unsigned int uin, char type);
// gg_after_append_formatted_char
// file message.c line 621
static void gg_after_append_formatted_char(unsigned short int *pos, unsigned char attr_flag, unsigned char *old_attr_flag, const unsigned char *color, unsigned char *old_color, unsigned long int imgs_size, unsigned char **format, unsigned long int *format_len);
// gg_append
// file message.c line 368
static void gg_append(char *dst, unsigned long int *pos, const void *src, unsigned long int len);
// gg_async_connect_failed
// file events.c line 384
static signed int gg_async_connect_failed(struct gg_session *gs, signed int *res_ptr);
// gg_base64_decode
// file common.c line 514
char * gg_base64_decode(const char *buf);
// gg_base64_encode
// file common.c line 455
char * gg_base64_encode(const char *buf);
// gg_change_info
// file obsolete.c line 205
struct gg_http * gg_change_info(unsigned int uin, const char *passwd, struct gg_change_info_request *request, signed int async);
// gg_change_info_request_free
// file obsolete.c line 219
void gg_change_info_request_free(struct gg_change_info_request *r);
// gg_change_info_request_new
// file obsolete.c line 212
struct gg_change_info_request * gg_change_info_request_new(const char *first_name, const char *last_name, const char *nickname, const char *email, signed int born, signed int gender, const char *city);
// gg_change_passwd
// file obsolete.c line 168
struct gg_http * gg_change_passwd(unsigned int uin, const char *passwd, const char *newpasswd, const char *newemail, signed int async);
// gg_change_passwd2
// file obsolete.c line 175
struct gg_http * gg_change_passwd2(unsigned int uin, const char *passwd, const char *newpasswd, const char *email, const char *newemail, signed int async);
// gg_change_passwd3
// file obsolete.c line 184
struct gg_http * gg_change_passwd3(unsigned int uin, const char *passwd, const char *newpasswd, const char *qa, signed int async);
// gg_change_passwd4
// file pubdir.c line 322
struct gg_http * gg_change_passwd4(unsigned int uin, const char *email, const char *passwd, const char *newpasswd, const char *tokenid, const char *tokenval, signed int async);
// gg_change_status
// file libgadu.c line 1304
signed int gg_change_status(struct gg_session *sess, signed int status);
// gg_change_status_descr
// file libgadu.c line 1322
signed int gg_change_status_descr(struct gg_session *sess, signed int status, const char *descr);
// gg_change_status_descr_time
// file libgadu.c line 1397
signed int gg_change_status_descr_time(struct gg_session *sess, signed int status, const char *descr, signed int ts);
// gg_change_status_flags
// file libgadu.c line 1419
signed int gg_change_status_flags(struct gg_session *sess, signed int flags);
// gg_chat_create
// file libgadu.c line 2688
signed int gg_chat_create(struct gg_session *gs);
// gg_chat_find
// file common.c line 739
struct _gg_chat_list * gg_chat_find(struct gg_session *sess, unsigned long int id);
// gg_chat_invite
// file libgadu.c line 2720
signed int gg_chat_invite(struct gg_session *gs, unsigned long int id, unsigned int *participants, unsigned int participants_count);
// gg_chat_leave
// file libgadu.c line 2780
signed int gg_chat_leave(struct gg_session *gs, unsigned long int id);
// gg_chat_send_message
// file libgadu.c line 2811
signed int gg_chat_send_message(struct gg_session *gs, unsigned long int id, const char *message, signed int is_html);
// gg_chat_update
// file common.c line 763
signed int gg_chat_update(struct gg_session *sess, unsigned long int id, unsigned int version, const unsigned int *participants, unsigned int participants_count);
// gg_chomp
// file common.c line 320
void gg_chomp(char *line);
// gg_close
// file ../include/internal.h line 183
void gg_close(struct gg_session *sess);
// gg_compat_feature_is_enabled
// file libgadu.c line 2890
signed int gg_compat_feature_is_enabled(struct gg_session *sess, enum anonymous$18 feature);
// gg_compat_find_sent_message
// file libgadu.c line 2908
static struct _gg_msg_list * gg_compat_find_sent_message(struct gg_session *sess, signed int seq, signed int remove);
// gg_compat_message_ack
// file ../include/internal.h line 187
void gg_compat_message_ack(struct gg_session *sess, signed int seq);
// gg_compat_message_cleanup
// file libgadu.c line 2930
static void gg_compat_message_cleanup(struct gg_session *sess);
// gg_compat_message_sent
// file libgadu.c line 2942
static void gg_compat_message_sent(struct gg_session *sess, signed int seq, unsigned long int recipients_count, unsigned int *recipients);
// gg_connect
// file common.c line 247
signed int gg_connect(void *addr, signed int port, signed int async);
// gg_connection_failure
// file common.c line 801
void gg_connection_failure(struct gg_session *gs, struct gg_event *ge, enum gg_failure_t failure);
// gg_crc32
// file common.c line 689
unsigned int gg_crc32(unsigned int crc, const unsigned char *buf, signed int len);
// gg_dcc7_accept
// file dcc7.c line 572
signed int gg_dcc7_accept(struct gg_dcc7 *dcc, unsigned int offset);
// gg_dcc7_connect
// file dcc7.c line 190
static signed int gg_dcc7_connect(struct gg_dcc7 *dcc);
// gg_dcc7_free
// file dcc7.c line 1638
void gg_dcc7_free(struct gg_dcc7 *dcc);
// gg_dcc7_get_relay_addr
// file dcc7.c line 159
static signed int gg_dcc7_get_relay_addr(struct gg_dcc7 *dcc);
// gg_dcc7_handle_accept
// file dcc7.c line 693
signed int gg_dcc7_handle_accept(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len);
// gg_dcc7_handle_id
// file dcc7.c line 637
signed int gg_dcc7_handle_id(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len);
// gg_dcc7_handle_info
// file dcc7.c line 733
signed int gg_dcc7_handle_info(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len);
// gg_dcc7_handle_new
// file dcc7.c line 927
signed int gg_dcc7_handle_new(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len);
// gg_dcc7_handle_reject
// file dcc7.c line 889
signed int gg_dcc7_handle_reject(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len);
// gg_dcc7_listen
// file dcc7.c line 222
static signed int gg_dcc7_listen(struct gg_dcc7 *dcc, unsigned int addr, unsigned short int port);
// gg_dcc7_listen_and_send_info
// file dcc7.c line 287
static signed int gg_dcc7_listen_and_send_info(struct gg_dcc7 *dcc);
// gg_dcc7_postauth_fixup
// file dcc7.c line 1019
static signed int gg_dcc7_postauth_fixup(struct gg_dcc7 *dcc);
// gg_dcc7_reject
// file dcc7.c line 607
signed int gg_dcc7_reject(struct gg_dcc7 *dcc, signed int reason);
// gg_dcc7_request_id
// file dcc7.c line 357
static signed int gg_dcc7_request_id(struct gg_session *sess, unsigned int type);
// gg_dcc7_reverse_connect
// file dcc7.c line 332
static signed int gg_dcc7_reverse_connect(struct gg_dcc7 *dcc);
// gg_dcc7_send_file
// file dcc7.c line 466
struct gg_dcc7 * gg_dcc7_send_file(struct gg_session *sess, unsigned int rcpt, const char *filename, const char *filename1250, const char *hash);
// gg_dcc7_send_file_common
// file dcc7.c line 405
static struct gg_dcc7 * gg_dcc7_send_file_common(struct gg_session *sess, unsigned int rcpt, signed int fd, unsigned long int size, const char *filename1250, const char *hash, signed int seek);
// gg_dcc7_send_file_fd
// file dcc7.c line 547
struct gg_dcc7 * gg_dcc7_send_file_fd(struct gg_session *sess, unsigned int rcpt, signed int fd, unsigned long int size, const char *filename1250, const char *hash);
// gg_dcc7_session_add
// file dcc7.c line 67
static signed int gg_dcc7_session_add(struct gg_session *sess, struct gg_dcc7 *dcc);
// gg_dcc7_session_find
// file dcc7.c line 130
static struct gg_dcc7 * gg_dcc7_session_find(struct gg_session *sess, struct anonymous$9 id, unsigned int uin);
// gg_dcc7_session_remove
// file dcc7.c line 91
static signed int gg_dcc7_session_remove(struct gg_session *sess, struct gg_dcc7 *dcc);
// gg_dcc7_watch_fd
// file dcc7.c line 1064
struct gg_event * gg_dcc7_watch_fd(struct gg_dcc7 *dcc);
// gg_dcc_callback
// file dcc.c line 362
static signed int gg_dcc_callback(struct gg_dcc *d);
// gg_dcc_debug_data
// file dcc.c line 49
static void gg_dcc_debug_data(const char *prefix, signed int fd, const void *buf, unsigned int size);
// gg_dcc_fill_file_info
// file dcc.c line 110
signed int gg_dcc_fill_file_info(struct gg_dcc *d, const char *filename);
// gg_dcc_fill_file_info2
// file dcc.c line 126
signed int gg_dcc_fill_file_info2(struct gg_dcc *d, const char *filename, const char *local_filename);
// gg_dcc_fill_filetime
// file dcc.c line 85
static void gg_dcc_fill_filetime(unsigned int ut, unsigned int *ft);
// gg_dcc_free
// file dcc.c line 1385
void gg_dcc_free(struct gg_dcc *d);
// gg_dcc_get_file
// file dcc.c line 288
struct gg_dcc * gg_dcc_get_file(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin);
// gg_dcc_request
// file dcc.c line 71
signed int gg_dcc_request(struct gg_session *sess, unsigned int uin);
// gg_dcc_send_file
// file dcc.c line 307
struct gg_dcc * gg_dcc_send_file(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin);
// gg_dcc_set_type
// file dcc.c line 344
void gg_dcc_set_type(struct gg_dcc *d, signed int type);
// gg_dcc_socket_create
// file dcc.c line 386
struct gg_dcc * gg_dcc_socket_create(unsigned int uin, unsigned short int port);
// gg_dcc_transfer
// file dcc.c line 235
static struct gg_dcc * gg_dcc_transfer(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin, signed int type);
// gg_dcc_voice_chat
// file dcc.c line 326
struct gg_dcc * gg_dcc_voice_chat(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin);
// gg_dcc_voice_send
// file dcc.c line 469
signed int gg_dcc_voice_send(struct gg_dcc *d, char *buf, signed int length);
// gg_dcc_watch_fd
// file dcc.c line 572
struct gg_event * gg_dcc_watch_fd(struct gg_dcc *h);
// gg_debug
// file ../include/libgadu.h line 1594
void gg_debug(signed int level, const char *format, ...);
// gg_debug_common
// file debug.c line 102
void gg_debug_common(struct gg_session *sess, signed int level, const char *format, void **ap);
// gg_debug_dump
// file ../include/debug.h line 24
void gg_debug_dump(struct gg_session *gs, signed int level, const char *buf, unsigned long int len);
// gg_debug_event
// file debug.c line 311
const char * gg_debug_event(enum gg_event_t event);
// gg_debug_handler$object
// 
void gg_debug_handler$object(signed int, const char *, void **);
// gg_debug_handler_session$object
// 
void gg_debug_handler_session$object(struct gg_session *, signed int, const char *, void **);
// gg_debug_session
// file ../include/libgadu.h line 1595
void gg_debug_session(struct gg_session *gs, signed int level, const char *format, ...);
// gg_debug_state
// file debug.c line 216
const char * gg_debug_state(enum gg_state_t state);
// gg_deflate
// file deflate.c line 50
unsigned char * gg_deflate(const char *in, unsigned long int *out_lenp);
// gg_encoding_convert
// file encoding.c line 228
char * gg_encoding_convert(const char *src, enum anonymous$3 src_encoding, enum anonymous$3 dst_encoding, signed int src_length, signed int dst_length);
// gg_encoding_convert_cp1250_utf8
// file encoding.c line 65
static char * gg_encoding_convert_cp1250_utf8(const char *src, signed int src_length, signed int dst_length);
// gg_encoding_convert_utf8_cp1250
// file encoding.c line 132
static char * gg_encoding_convert_utf8_cp1250(const char *src, signed int src_length, signed int dst_length);
// gg_event_free
// file ../../include/libgadu.h line 1368
void gg_event_free(struct gg_event *e);
// gg_eventqueue_add
// file events.c line 1746
struct gg_event * gg_eventqueue_add(struct gg_session *sess);
// gg_fd_set_nonblocking
// file ../../include/network.h line 112
static inline signed int gg_fd_set_nonblocking(signed int fd);
// gg_fd_set_nonblocking$link1
// file ../include/network.h line 112
static inline signed int gg_fd_set_nonblocking$link1(signed int fd$link1);
// gg_fd_set_nonblocking$link2
// file ../include/network.h line 112
static inline signed int gg_fd_set_nonblocking$link2(signed int fd$link2);
// gg_fd_set_nonblocking$link3
// file ../include/network.h line 112
static inline signed int gg_fd_set_nonblocking$link3(signed int fd$link3);
// gg_file_hash_sha1
// file ../include/libgadu.h line 1752
signed int gg_file_hash_sha1(signed int fd, unsigned char *result);
// gg_file_hash_sha1_part
// file sha1.c line 286
static signed int gg_file_hash_sha1_part(signed int fd, struct hash_hd_st **ctx, signed long int pos, unsigned long int len);
// gg_fix16
// file ../include/libgadu.h line 1775
unsigned short int gg_fix16(unsigned short int x);
// gg_fix32
// file ../include/libgadu.h line 1774
unsigned int gg_fix32(unsigned int x);
// gg_fix64
// file ../include/internal.h line 176
unsigned long int gg_fix64(unsigned long int x);
// gg_free_search
// file obsolete.c line 107
void gg_free_search(struct gg_http *h);
// gg_free_session
// file ../../include/libgadu.h line 799
void gg_free_session(struct gg_session *sess);
// gg_get_dummy_fd
// file ../include/internal.h line 158
signed int gg_get_dummy_fd(struct gg_session *sess);
// gg_get_line
// file common.c line 160
char * gg_get_line(char **ptr);
// gg_gethostbyname
// file resolver.c line 354
struct in_addr * gg_gethostbyname(const char *hostname);
// gg_gethostbyname_real
// file ../include/resolver.h line 24
signed int gg_gethostbyname_real(const char *hostname, struct in_addr **result, unsigned int *count, signed int pthread);
// gg_gethostbyname_real::1::2::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// gg_global_get_resolver
// file resolver.c line 1085
enum anonymous$4 gg_global_get_resolver(void);
// gg_global_resolver_cleanup$object
// 
void gg_global_resolver_cleanup$object(void **, signed int);
// gg_global_resolver_start$object
// 
signed int gg_global_resolver_start$object(signed int *, void **, const char *);
// gg_global_set_custom_resolver
// file resolver.c line 1100
signed int gg_global_set_custom_resolver(signed int (*resolver_start)(signed int *, void **, const char *), void (*resolver_cleanup)(void **, signed int));
// gg_global_set_custom_resolver::resolver_cleanup$object
// 
void resolver_cleanup$object(void **, signed int);
// gg_global_set_custom_resolver::resolver_start$object
// 
signed int resolver_start$object(signed int *, void **, const char *);
// gg_global_set_resolver
// file resolver.c line 1041
signed int gg_global_set_resolver(enum anonymous$4 type);
// gg_handle_connect
// file events.c line 702
static enum anonymous$27 gg_handle_connect(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_connect_gg
// file events.c line 774
static enum anonymous$27 gg_handle_connect_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_connected
// file events.c line 1588
static enum anonymous$27 gg_handle_connected(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_connecting
// file events.c line 745
static enum anonymous$27 gg_handle_connecting(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_connecting_gg
// file events.c line 823
static enum anonymous$27 gg_handle_connecting_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_error
// file events.c line 1679
static enum anonymous$27 gg_handle_error(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_reading_hub_proxy
// file events.c line 970
static enum anonymous$27 gg_handle_reading_hub_proxy(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_reading_proxy_gg
// file events.c line 1462
static enum anonymous$27 gg_handle_reading_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_recv_msg_options
// file handlers.c line 862
static signed int gg_handle_recv_msg_options(struct gg_session *sess, struct gg_event *e, unsigned int sender, const char *p, const char *packet_end, unsigned int packet_type);
// gg_handle_resolve_async
// file events.c line 556
static enum anonymous$27 gg_handle_resolve_async(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_resolve_custom
// file events.c line 437
static signed int gg_handle_resolve_custom(struct gg_session *sess, enum gg_state_t next_state);
// gg_handle_resolve_sync
// file events.c line 508
static enum anonymous$27 gg_handle_resolve_sync(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_resolving
// file events.c line 583
static enum anonymous$27 gg_handle_resolving(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_send_hub
// file events.c line 867
static enum anonymous$27 gg_handle_send_hub(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_send_proxy_gg
// file events.c line 1182
static enum anonymous$27 gg_handle_send_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_sending_hub_proxy
// file events.c line 951
static enum anonymous$27 gg_handle_sending_hub_proxy(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_handle_tls_negotiation
// file events.c line 1241
static enum anonymous$27 gg_handle_tls_negotiation(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state);
// gg_http_connect
// file http.c line 66
struct gg_http * gg_http_connect(const char *hostname, signed int port, signed int async, const char *method, const char *path, const char *header);
// gg_http_free
// file http.c line 582
void gg_http_free(struct gg_http *h);
// gg_http_free_fields
// file http.c line 558
void gg_http_free_fields(struct gg_http *h);
// gg_http_get_resolver
// file resolver.c line 999
enum anonymous$4 gg_http_get_resolver(struct gg_http *gh);
// gg_http_hash
// file common.c line 406
signed int gg_http_hash(const char *format, ...);
// gg_http_set_custom_resolver
// file resolver.c line 1018
signed int gg_http_set_custom_resolver(struct gg_http *gh, signed int (*resolver_start)(signed int *, void **, const char *), void (*resolver_cleanup)(void **, signed int));
// gg_http_set_custom_resolver::resolver_cleanup$object
// 
void resolver_cleanup$object(void **, signed int);
// gg_http_set_custom_resolver::resolver_start$object
// 
signed int resolver_start$object(signed int *, void **, const char *);
// gg_http_set_resolver
// file ../include/libgadu.h line 825
signed int gg_http_set_resolver(struct gg_http *gh, enum anonymous$4 type);
// gg_http_stop
// file http.c line 535
void gg_http_stop(struct gg_http *h);
// gg_http_watch_fd
// file http.c line 197
signed int gg_http_watch_fd(struct gg_http *h);
// gg_image_queue_parse
// file handlers.c line 744
static void gg_image_queue_parse(struct gg_event *e, const char *p, unsigned int len, struct gg_session *sess, unsigned int sender, unsigned int type);
// gg_image_queue_remove
// file events.c line 199
signed int gg_image_queue_remove(struct gg_session *s, struct gg_image_queue *q, signed int freeq);
// gg_image_reply
// file libgadu.c line 2119
signed int gg_image_reply(struct gg_session *sess, unsigned int recipient, const char *filename, const char *image, signed int size);
// gg_image_request
// file libgadu.c line 2032
signed int gg_image_request(struct gg_session *sess, unsigned int recipient, signed int size, unsigned int crc32);
// gg_image_sendout
// file ../include/internal.h line 189
void gg_image_sendout(struct gg_session *sess);
// gg_inflate
// file deflate.c line 152
char * gg_inflate(const unsigned char *in, unsigned long int length);
// gg_is_gpl_compliant
// file libgadu.c line 147
signed int gg_is_gpl_compliant(void);
// gg_libgadu_check_feature
// file libgadu.c line 2830
signed int gg_libgadu_check_feature(enum anonymous$17 feature);
// gg_libgadu_version
// file libgadu.c line 160
const char * gg_libgadu_version(void);
// gg_login
// file ../../include/libgadu.h line 798
struct gg_session * gg_login(struct gg_login_params *p);
// gg_login_hash
// file ../include/libgadu.h line 1772
unsigned int gg_login_hash(const unsigned char *password, unsigned int seed);
// gg_login_hash_sha1
// file obsolete.c line 244
void gg_login_hash_sha1(const char *password, unsigned int seed, unsigned char *result);
// gg_login_hash_sha1_2
// file ../include/internal.h line 168
signed int gg_login_hash_sha1_2(const char *password, unsigned int seed, unsigned char *result);
// gg_logoff
// file libgadu.c line 1183
void gg_logoff(struct gg_session *sess);
// gg_message_html_to_text
// file ../include/message.h line 54
unsigned long int gg_message_html_to_text(char *dst, unsigned char *format, unsigned long int *format_len, const char *html, enum anonymous$3 encoding);
// gg_message_html_to_text_110
// file ../include/message.h line 59
char * gg_message_html_to_text_110(const char *html);
// gg_message_html_to_text_110_buff
// file message.c line 940
static unsigned long int gg_message_html_to_text_110_buff(char *dst, const char *html);
// gg_message_legacy_text_to_html
// file libgadu.c line 1521
static char * gg_message_legacy_text_to_html(const char *src, enum anonymous$3 encoding, const unsigned char *format, unsigned long int format_len);
// gg_message_text_to_html
// file ../include/message.h line 56
unsigned long int gg_message_text_to_html(char *dst, const char *src, enum anonymous$3 encoding, const unsigned char *format, unsigned long int format_len);
// gg_message_text_to_html_110
// file ../include/message.h line 60
char * gg_message_text_to_html_110(const char *text, signed long int text_len);
// gg_message_text_to_html_110_buff
// file message.c line 945
static unsigned long int gg_message_text_to_html_110_buff(char *dst, const char *text, signed long int text_len);
// gg_multilogon_disconnect
// file libgadu.c line 2669
signed int gg_multilogon_disconnect(struct gg_session *gs, struct anonymous$9 conn_id);
// gg_new0
// file ../include/internal.h line 156
void * gg_new0(unsigned long int size);
// gg_notify
// file libgadu.c line 2373
signed int gg_notify(struct gg_session *sess, unsigned int *userlist, signed int count);
// gg_notify105_ex
// file libgadu.c line 2240
static signed int gg_notify105_ex(struct gg_session *sess, unsigned int *userlist, char *types, signed int count);
// gg_notify_ex
// file libgadu.c line 2297
signed int gg_notify_ex(struct gg_session *sess, unsigned int *userlist, char *types, signed int count);
// gg_ping
// file libgadu.c line 1147
signed int gg_ping(struct gg_session *sess);
// gg_protobuf_expected
// file ../include/protobuf.h line 55
void gg_protobuf_expected(struct gg_session *gs, const char *field_name, unsigned int value, unsigned int expected);
// gg_protobuf_get_uin
// file ../include/protobuf.h line 68
unsigned int gg_protobuf_get_uin(struct ProtobufCBinaryData uin_data);
// gg_protobuf_send_ex
// file ../include/protobuf.h line 63
signed int gg_protobuf_send_ex(struct gg_session *gs, struct gg_event *ge, signed int type, void *msg, unsigned long int (*size_cb)(const void *), unsigned long int (*pack_cb)(const void *, unsigned char *));
// gg_protobuf_send_ex::pack_cb$object
// 
unsigned long int pack_cb$object(const void *, unsigned char *);
// gg_protobuf_send_ex::size_cb$object
// 
unsigned long int size_cb$object(const void *);
// gg_protobuf_set_uin
// file ../include/protobuf.h line 67
void gg_protobuf_set_uin(struct ProtobufCBinaryData *dst, unsigned int uin, struct _gg_protobuf_uin_buff *buff);
// gg_protobuf_valid_chknull
// file ../include/protobuf.h line 58
signed int gg_protobuf_valid_chknull(struct gg_session *gs, const char *msg_name, signed int isNull);
// gg_protobuf_valid_chkunknown
// file ../include/protobuf.h line 60
signed int gg_protobuf_valid_chkunknown(struct gg_session *gs, const char *msg_name, struct ProtobufCMessage *base);
// gg_proxy_auth
// file common.c line 572
char * gg_proxy_auth(void);
// gg_pubdir50
// file pubdir50.c line 199
unsigned int gg_pubdir50(struct gg_session *sess, struct gg_pubdir50_s *req);
// gg_pubdir50_add
// file pubdir50.c line 136
signed int gg_pubdir50_add(struct gg_pubdir50_s *req, const char *field, const char *value);
// gg_pubdir50_add_n
// file pubdir50.c line 77
static signed int gg_pubdir50_add_n(struct gg_pubdir50_s *req, signed int num, const char *field, const char *value);
// gg_pubdir50_count
// file pubdir50.c line 495
signed int gg_pubdir50_count(struct gg_pubdir50_s *res);
// gg_pubdir50_free
// file ../include/libgadu.h line 1391
void gg_pubdir50_free(struct gg_pubdir50_s *s);
// gg_pubdir50_get
// file pubdir50.c line 463
const char * gg_pubdir50_get(struct gg_pubdir50_s *res, signed int num, const char *field);
// gg_pubdir50_handle_reply
// file obsolete.c line 239
signed int gg_pubdir50_handle_reply(struct gg_event *e, const char *packet, signed int length);
// gg_pubdir50_handle_reply_sess
// file ../include/internal.h line 162
signed int gg_pubdir50_handle_reply_sess(struct gg_session *sess, struct gg_event *e, const char *packet, signed int length);
// gg_pubdir50_new
// file pubdir50.c line 48
struct gg_pubdir50_s * gg_pubdir50_new(signed int type);
// gg_pubdir50_next
// file pubdir50.c line 528
unsigned int gg_pubdir50_next(struct gg_pubdir50_s *res);
// gg_pubdir50_seq
// file pubdir50.c line 542
unsigned int gg_pubdir50_seq(struct gg_pubdir50_s *res);
// gg_pubdir50_seq_set
// file pubdir50.c line 151
signed int gg_pubdir50_seq_set(struct gg_pubdir50_s *req, unsigned int seq);
// gg_pubdir50_type
// file pubdir50.c line 509
signed int gg_pubdir50_type(struct gg_pubdir50_s *res);
// gg_pubdir_free
// file pubdir.c line 663
void gg_pubdir_free(struct gg_http *h);
// gg_pubdir_watch_fd
// file pubdir.c line 591
signed int gg_pubdir_watch_fd(struct gg_http *h);
// gg_read
// file libgadu.c line 256
signed int gg_read(struct gg_session *sess, char *buf, signed int length);
// gg_read_line
// file common.c line 201
char * gg_read_line(signed int sock, char *buf, signed int length);
// gg_recv_packet
// file ../include/libgadu.h line 1770
void * gg_recv_packet(struct gg_session *sess);
// gg_register
// file obsolete.c line 139
struct gg_http * gg_register(const char *email, const char *password, signed int async);
// gg_register2
// file obsolete.c line 146
struct gg_http * gg_register2(const char *email, const char *password, const char *qa, signed int async);
// gg_register3
// file pubdir.c line 52
struct gg_http * gg_register3(const char *email, const char *password, const char *tokenid, const char *tokenval, signed int async);
// gg_remind_passwd
// file obsolete.c line 191
struct gg_http * gg_remind_passwd(unsigned int uin, signed int async);
// gg_remind_passwd2
// file obsolete.c line 198
struct gg_http * gg_remind_passwd2(unsigned int uin, const char *tokenid, const char *tokenval, signed int async);
// gg_remind_passwd3
// file pubdir.c line 465
struct gg_http * gg_remind_passwd3(unsigned int uin, const char *email, const char *tokenid, const char *tokenval, signed int async);
// gg_remove_notify
// file libgadu.c line 2505
signed int gg_remove_notify(struct gg_session *sess, unsigned int uin);
// gg_remove_notify_ex
// file libgadu.c line 2458
signed int gg_remove_notify_ex(struct gg_session *sess, unsigned int uin, char type);
// gg_required_proto
// file libgadu.c line 182
signed int gg_required_proto(struct gg_session *gs, signed int protocol_version);
// gg_resolve
// file obsolete.c line 224
signed int gg_resolve(signed int *fd, signed int *pid, const char *hostname);
// gg_resolve_pthread
// file obsolete.c line 234
signed int gg_resolve_pthread(signed int *fd, void **resolver, const char *hostname);
// gg_resolve_pthread_cleanup
// file obsolete.c line 229
void gg_resolve_pthread_cleanup(void *arg, signed int kill);
// gg_resolver_cleaner
// file resolver.c line 68
void gg_resolver_cleaner(void *data);
// gg_resolver_fork_cleanup
// file resolver.c line 468
static void gg_resolver_fork_cleanup(void **priv_data, signed int force);
// gg_resolver_fork_start
// file resolver.c line 390
static signed int gg_resolver_fork_start(signed int *fd, void **priv_data, const char *hostname);
// gg_resolver_pthread_cleanup
// file resolver.c line 510
static void gg_resolver_pthread_cleanup(void **priv_data, signed int force);
// gg_resolver_pthread_start
// file resolver.c line 561
static signed int gg_resolver_pthread_start(signed int *fd, void **priv_data, const char *hostname);
// gg_resolver_pthread_thread
// file resolver.c line 535
static void * gg_resolver_pthread_thread(void *arg);
// gg_resolver_recv
// file ../include/resolver.h line 25
signed int gg_resolver_recv(signed int fd, void *buf, unsigned long int len);
// gg_resolver_run
// file resolver.c line 281
static signed int gg_resolver_run(signed int fd, const char *hostname, signed int pthread);
// gg_resolver_run::1::1::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// gg_saprintf
// file common.c line 134
char * gg_saprintf(const char *format, ...);
// gg_search
// file obsolete.c line 94
struct gg_http * gg_search(struct gg_search_request *r, signed int async);
// gg_search_request_free
// file obsolete.c line 134
void gg_search_request_free(struct gg_search_request *r);
// gg_search_request_mode_0
// file obsolete.c line 112
struct gg_search_request * gg_search_request_mode_0(char *nickname, char *first_name, char *last_name, char *city, signed int gender, signed int min_birth, signed int max_birth, signed int active, signed int start);
// gg_search_request_mode_1
// file obsolete.c line 119
struct gg_search_request * gg_search_request_mode_1(char *email, signed int active, signed int start);
// gg_search_request_mode_2
// file obsolete.c line 124
struct gg_search_request * gg_search_request_mode_2(char *phone, signed int active, signed int start);
// gg_search_request_mode_3
// file obsolete.c line 129
struct gg_search_request * gg_search_request_mode_3(unsigned int uin, signed int active, signed int start);
// gg_search_watch_fd
// file obsolete.c line 101
signed int gg_search_watch_fd(struct gg_http *h);
// gg_send_message
// file libgadu.c line 1815
signed int gg_send_message(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *message);
// gg_send_message_110
// file libgadu.c line 1435
static signed int gg_send_message_110(struct gg_session *sess, unsigned int recipient, unsigned long int chat_id, const char *message, signed int is_html);
// gg_send_message_common
// file libgadu.c line 1565
static signed int gg_send_message_common(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *message, const unsigned char *format, signed int formatlen, const unsigned char *html_message);
// gg_send_message_confer
// file libgadu.c line 1903
signed int gg_send_message_confer(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *message);
// gg_send_message_confer_html
// file libgadu.c line 1962
signed int gg_send_message_confer_html(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *html_message);
// gg_send_message_confer_richtext
// file libgadu.c line 1934
signed int gg_send_message_confer_richtext(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *message, const unsigned char *format, signed int formatlen);
// gg_send_message_ctcp
// file ../include/libgadu.h line 811
signed int gg_send_message_ctcp(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *message, signed int message_len);
// gg_send_message_html
// file libgadu.c line 1879
signed int gg_send_message_html(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *html_message);
// gg_send_message_richtext
// file libgadu.c line 1853
signed int gg_send_message_richtext(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *message, const unsigned char *format, signed int formatlen);
// gg_send_packet
// file ../include/libgadu.h line 1771
signed int gg_send_packet(struct gg_session *sess, signed int type, ...);
// gg_send_queued_data
// file events.c line 335
static signed int gg_send_queued_data(struct gg_session *sess);
// gg_server_time
// file common.c line 813
signed long int gg_server_time(struct gg_session *gs);
// gg_session_callback
// file libgadu.c line 805
static signed int gg_session_callback(struct gg_session *sess);
// gg_session_get_resolver
// file resolver.c line 872
enum anonymous$4 gg_session_get_resolver(struct gg_session *gs);
// gg_session_handle_access_info
// file handlers.c line 2604
static signed int gg_session_handle_access_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_chat_created
// file handlers.c line 2534
static signed int gg_session_handle_chat_created(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_chat_info
// file handlers.c line 2392
static signed int gg_session_handle_chat_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_chat_info_update
// file handlers.c line 2466
static signed int gg_session_handle_chat_info_update(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_chat_invite_ack
// file handlers.c line 2548
static signed int gg_session_handle_chat_invite_ack(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_chat_left
// file handlers.c line 2561
static signed int gg_session_handle_chat_left(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_dcc7_accept
// file handlers.c line 687
static signed int gg_session_handle_dcc7_accept(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_dcc7_id_reply
// file handlers.c line 674
static signed int gg_session_handle_dcc7_id_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_dcc7_info
// file handlers.c line 726
static signed int gg_session_handle_dcc7_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_dcc7_new
// file handlers.c line 700
static signed int gg_session_handle_dcc7_new(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_dcc7_reject
// file handlers.c line 713
static signed int gg_session_handle_dcc7_reject(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_disconnect_ack
// file handlers.c line 523
static signed int gg_session_handle_disconnect_ack(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_disconnecting
// file handlers.c line 508
static signed int gg_session_handle_disconnecting(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_event_110
// file handlers.c line 557
static signed int gg_session_handle_event_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_imtoken
// file handlers.c line 2345
static signed int gg_session_handle_imtoken(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_login110_ok
// file handlers.c line 169
static signed int gg_session_handle_login110_ok(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_login_failed
// file handlers.c line 388
static signed int gg_session_handle_login_failed(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_login_ok
// file handlers.c line 363
static signed int gg_session_handle_login_ok(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_magic_notification
// file handlers.c line 2721
static signed int gg_session_handle_magic_notification(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_multilogon_info
// file handlers.c line 2205
static signed int gg_session_handle_multilogon_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_notify_reply
// file handlers.c line 1617
static signed int gg_session_handle_notify_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_notify_reply_60
// file handlers.c line 1893
static signed int gg_session_handle_notify_reply_60(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_notify_reply_77_80beta
// file handlers.c line 1808
static signed int gg_session_handle_notify_reply_77_80beta(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_notify_reply_80
// file handlers.c line 1726
static signed int gg_session_handle_notify_reply_80(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_options
// file handlers.c line 2579
static signed int gg_session_handle_options(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_packet
// file ../include/session.h line 65
signed int gg_session_handle_packet(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_pong
// file handlers.c line 491
static signed int gg_session_handle_pong(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_pong_110
// file handlers.c line 2371
static signed int gg_session_handle_pong_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_pubdir50_reply
// file handlers.c line 600
static signed int gg_session_handle_pubdir50_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_recv_msg
// file handlers.c line 1091
static signed int gg_session_handle_recv_msg(struct gg_session *sess, unsigned int type, const char *packet, unsigned long int length, struct gg_event *e);
// gg_session_handle_recv_msg_110
// file handlers.c line 1371
static signed int gg_session_handle_recv_msg_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_recv_msg_80
// file handlers.c line 1193
static signed int gg_session_handle_recv_msg_80(struct gg_session *sess, unsigned int type, const char *packet, unsigned long int length, struct gg_event *e);
// gg_session_handle_send_msg_ack
// file handlers.c line 409
static signed int gg_session_handle_send_msg_ack(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_send_msg_ack_110
// file handlers.c line 432
static signed int gg_session_handle_send_msg_ack_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_status
// file handlers.c line 1517
static signed int gg_session_handle_status(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_status_60_77_80beta
// file handlers.c line 1547
static signed int gg_session_handle_status_60_77_80beta(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_status_80
// file handlers.c line 1685
static signed int gg_session_handle_status_80(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_transfer_info
// file handlers.c line 2658
static signed int gg_session_handle_transfer_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_typing_notification
// file handlers.c line 2183
static signed int gg_session_handle_typing_notification(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_uin_info
// file handlers.c line 2624
static signed int gg_session_handle_uin_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_user_data
// file handlers.c line 1980
static signed int gg_session_handle_user_data(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_userlist_100_reply
// file handlers.c line 2319
static signed int gg_session_handle_userlist_100_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_userlist_100_version
// file handlers.c line 2301
static signed int gg_session_handle_userlist_100_version(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_userlist_reply
// file handlers.c line 613
static signed int gg_session_handle_userlist_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_welcome
// file handlers.c line 206
static signed int gg_session_handle_welcome(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_handle_welcome_110
// file handlers.c line 94
static signed int gg_session_handle_welcome_110(struct gg_session *gs, unsigned int seed, struct gg_event *ge);
// gg_session_handle_xml_event
// file handlers.c line 538
static signed int gg_session_handle_xml_event(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge);
// gg_session_init_ssl
// file events.c line 237
signed int gg_session_init_ssl(struct gg_session *gs);
// gg_session_send_msg_ack
// file handlers.c line 1068
static signed int gg_session_send_msg_ack(struct gg_session *gs, unsigned int seq);
// gg_session_set_custom_resolver
// file resolver.c line 911
signed int gg_session_set_custom_resolver(struct gg_session *gs, signed int (*resolver_start)(signed int *, void **, const char *), void (*resolver_cleanup)(void **, signed int));
// gg_session_set_custom_resolver::resolver_cleanup$object
// 
void resolver_cleanup$object(void **, signed int);
// gg_session_set_custom_resolver::resolver_start$object
// 
signed int resolver_start$object(signed int *, void **, const char *);
// gg_session_set_resolver
// file ../include/libgadu.h line 821
signed int gg_session_set_resolver(struct gg_session *gs, enum anonymous$4 type);
// gg_socket_manager_connected
// file libgadu.c line 3026
signed int gg_socket_manager_connected(void *handle, void *priv, signed int fd);
// gg_socket_manager_error
// file libgadu.c line 2862
static void gg_socket_manager_error(struct gg_session *sess, enum gg_failure_t failure);
// gg_str_to_uin
// file common.c line 710
unsigned int gg_str_to_uin(const char *str, signed int len);
// gg_strarr_dup
// file common.c line 838
char ** gg_strarr_dup(char **strarr);
// gg_strarr_free
// file common.c line 826
void gg_strarr_free(char **strarr);
// gg_sync_time
// file handlers.c line 81
static void gg_sync_time(struct gg_session *gs, signed long int server_time);
// gg_token
// file pubdir.c line 684
struct gg_http * gg_token(signed int async);
// gg_token_free
// file pubdir.c line 866
void gg_token_free(struct gg_http *h);
// gg_token_watch_fd
// file pubdir.c line 725
signed int gg_token_watch_fd(struct gg_http *h);
// gg_tvbuff_close
// file ../include/tvbuff.h line 29
signed int gg_tvbuff_close(struct gg_tvbuff *tvb);
// gg_tvbuff_expected_eob
// file tvbuff.c line 597
void gg_tvbuff_expected_eob(const struct gg_tvbuff *tvb);
// gg_tvbuff_expected_uint32
// file ../include/tvbuff.h line 56
void gg_tvbuff_expected_uint32(struct gg_tvbuff *tvb, unsigned int value);
// gg_tvbuff_expected_uint8
// file ../include/tvbuff.h line 55
void gg_tvbuff_expected_uint8(struct gg_tvbuff *tvb, unsigned char value);
// gg_tvbuff_get_remaining
// file tvbuff.c line 117
unsigned long int gg_tvbuff_get_remaining(const struct gg_tvbuff *tvb);
// gg_tvbuff_have_remaining
// file tvbuff.c line 134
signed int gg_tvbuff_have_remaining(struct gg_tvbuff *tvb, unsigned long int length);
// gg_tvbuff_is_valid
// file ../include/tvbuff.h line 31
signed int gg_tvbuff_is_valid(const struct gg_tvbuff *tvb);
// gg_tvbuff_match
// file tvbuff.c line 200
signed int gg_tvbuff_match(struct gg_tvbuff *tvb, unsigned char value);
// gg_tvbuff_new
// file ../include/tvbuff.h line 28
struct gg_tvbuff * gg_tvbuff_new(const char *buffer, unsigned long int length);
// gg_tvbuff_read_buff
// file tvbuff.c line 359
const char * gg_tvbuff_read_buff(struct gg_tvbuff *tvb, unsigned long int length);
// gg_tvbuff_read_buff_cpy
// file tvbuff.c line 385
void gg_tvbuff_read_buff_cpy(struct gg_tvbuff *tvb, char *buffer, unsigned long int length);
// gg_tvbuff_read_packed_uint
// file tvbuff.c line 308
unsigned long int gg_tvbuff_read_packed_uint(struct gg_tvbuff *tvb);
// gg_tvbuff_read_str
// file tvbuff.c line 418
const char * gg_tvbuff_read_str(struct gg_tvbuff *tvb, unsigned long int *length);
// gg_tvbuff_read_str_dup
// file ../include/tvbuff.h line 51
void gg_tvbuff_read_str_dup(struct gg_tvbuff *tvb, char **dst);
// gg_tvbuff_read_uin
// file tvbuff.c line 506
unsigned int gg_tvbuff_read_uin(struct gg_tvbuff *tvb);
// gg_tvbuff_read_uint32
// file ../include/tvbuff.h line 43
unsigned int gg_tvbuff_read_uint32(struct gg_tvbuff *tvb);
// gg_tvbuff_read_uint64
// file ../include/tvbuff.h line 44
unsigned long int gg_tvbuff_read_uint64(struct gg_tvbuff *tvb);
// gg_tvbuff_read_uint8
// file tvbuff.c line 224
unsigned char gg_tvbuff_read_uint8(struct gg_tvbuff *tvb);
// gg_tvbuff_rewind
// file tvbuff.c line 177
void gg_tvbuff_rewind(struct gg_tvbuff *tvb, unsigned long int amount);
// gg_tvbuff_skip
// file ../include/tvbuff.h line 37
void gg_tvbuff_skip(struct gg_tvbuff *tvb, unsigned long int amount);
// gg_tvbuilder_expected_size
// file ../include/tvbuilder.h line 36
void gg_tvbuilder_expected_size(struct gg_tvbuilder *tvb, unsigned long int length);
// gg_tvbuilder_extend
// file tvbuilder.c line 259
static char * gg_tvbuilder_extend(struct gg_tvbuilder *tvb, unsigned long int length);
// gg_tvbuilder_fail
// file tvbuilder.c line 106
void gg_tvbuilder_fail(struct gg_tvbuilder *tvb, enum gg_failure_t failure);
// gg_tvbuilder_free
// file tvbuilder.c line 91
void gg_tvbuilder_free(struct gg_tvbuilder *tvb);
// gg_tvbuilder_get_size
// file ../include/tvbuilder.h line 35
unsigned long int gg_tvbuilder_get_size(const struct gg_tvbuilder *tvb);
// gg_tvbuilder_is_valid
// file tvbuilder.c line 182
signed int gg_tvbuilder_is_valid(const struct gg_tvbuilder *tvb);
// gg_tvbuilder_new
// file ../include/tvbuilder.h line 28
struct gg_tvbuilder * gg_tvbuilder_new(struct gg_session *gs, struct gg_event *ge);
// gg_tvbuilder_send
// file ../include/tvbuilder.h line 31
signed int gg_tvbuilder_send(struct gg_tvbuilder *tvb, signed int type);
// gg_tvbuilder_strip
// file ../include/tvbuilder.h line 37
void gg_tvbuilder_strip(struct gg_tvbuilder *tvb, unsigned long int length);
// gg_tvbuilder_write_buff
// file tvbuilder.c line 380
void gg_tvbuilder_write_buff(struct gg_tvbuilder *tvb, const char *buffer, unsigned long int length);
// gg_tvbuilder_write_packed_uint
// file tvbuilder.c line 337
void gg_tvbuilder_write_packed_uint(struct gg_tvbuilder *tvb, unsigned long int value);
// gg_tvbuilder_write_str
// file tvbuilder.c line 398
void gg_tvbuilder_write_str(struct gg_tvbuilder *tvb, const char *buffer, signed long int length);
// gg_tvbuilder_write_uin
// file ../include/tvbuilder.h line 48
void gg_tvbuilder_write_uin(struct gg_tvbuilder *tvb, unsigned int uin);
// gg_tvbuilder_write_uint32
// file tvbuilder.c line 311
void gg_tvbuilder_write_uint32(struct gg_tvbuilder *tvb, unsigned int value);
// gg_tvbuilder_write_uint64
// file tvbuilder.c line 323
void gg_tvbuilder_write_uint64(struct gg_tvbuilder *tvb, unsigned long int value);
// gg_tvbuilder_write_uint8
// file ../include/tvbuilder.h line 39
void gg_tvbuilder_write_uint8(struct gg_tvbuilder *tvb, unsigned char value);
// gg_typing_notification
// file libgadu.c line 2648
signed int gg_typing_notification(struct gg_session *sess, unsigned int recipient, signed int length);
// gg_unregister
// file obsolete.c line 153
struct gg_http * gg_unregister(unsigned int uin, const char *password, const char *email, signed int async);
// gg_unregister2
// file obsolete.c line 160
struct gg_http * gg_unregister2(unsigned int uin, const char *password, const char *qa, signed int async);
// gg_unregister3
// file pubdir.c line 186
struct gg_http * gg_unregister3(unsigned int uin, const char *password, const char *tokenid, const char *tokenval, signed int async);
// gg_urlencode
// file common.c line 348
char * gg_urlencode(const char *str);
// gg_userlist100_request
// file libgadu.c line 2597
signed int gg_userlist100_request(struct gg_session *sess, char type, unsigned int version, char format_type, const char *request);
// gg_userlist_get
// file obsolete.c line 40
struct gg_http * gg_userlist_get(unsigned int uin, const char *passwd, signed int async);
// gg_userlist_get_free
// file obsolete.c line 53
void gg_userlist_get_free(struct gg_http *h);
// gg_userlist_get_watch_fd
// file obsolete.c line 47
signed int gg_userlist_get_watch_fd(struct gg_http *h);
// gg_userlist_put
// file obsolete.c line 58
struct gg_http * gg_userlist_put(unsigned int uin, const char *password, const char *contacts, signed int async);
// gg_userlist_put_free
// file obsolete.c line 71
void gg_userlist_put_free(struct gg_http *h);
// gg_userlist_put_watch_fd
// file obsolete.c line 65
signed int gg_userlist_put_watch_fd(struct gg_http *h);
// gg_userlist_remove
// file obsolete.c line 76
struct gg_http * gg_userlist_remove(unsigned int uin, const char *passwd, signed int async);
// gg_userlist_remove_free
// file obsolete.c line 89
void gg_userlist_remove_free(struct gg_http *h);
// gg_userlist_remove_watch_fd
// file obsolete.c line 83
signed int gg_userlist_remove_watch_fd(struct gg_http *h);
// gg_userlist_request
// file libgadu.c line 2531
signed int gg_userlist_request(struct gg_session *sess, char type, const char *request);
// gg_vsaprintf
// file common.c line 67
char * gg_vsaprintf(const char *format, void **ap);
// gg_watch_fd
// file ../../include/libgadu.h line 1367
struct gg_event * gg_watch_fd(struct gg_session *sess);
// gg_write
// file libgadu.c line 459
signed int gg_write(struct gg_session *sess, const char *buf, signed int length);
// gg_write_common
// file libgadu.c line 359
static signed int gg_write_common(struct gg_session *sess, const char *buf, signed int length);
// gnutls_bye
// file /usr/include/gnutls/gnutls.h line 819
signed int gnutls_bye(struct gnutls_session_int *, enum anonymous$14);
// gnutls_certificate_allocate_credentials
// file /usr/include/gnutls/gnutls.h line 1437
signed int gnutls_certificate_allocate_credentials(struct gnutls_certificate_credentials_st **);
// gnutls_certificate_free_credentials
// file /usr/include/gnutls/gnutls.h line 1435
void gnutls_certificate_free_credentials(struct gnutls_certificate_credentials_st *);
// gnutls_certificate_get_peers
// file /usr/include/gnutls/gnutls.h line 2084
const struct anonymous$28 * gnutls_certificate_get_peers(struct gnutls_session_int *, unsigned int *);
// gnutls_certificate_set_dh_params
// file /usr/include/gnutls/gnutls.h line 1466
void gnutls_certificate_set_dh_params(struct gnutls_certificate_credentials_st *, struct gnutls_dh_params_int *);
// gnutls_certificate_set_x509_key_file
// file /usr/include/gnutls/gnutls.h line 1519
signed int gnutls_certificate_set_x509_key_file(struct gnutls_certificate_credentials_st *, const char *, const char *, enum anonymous$2);
// gnutls_certificate_set_x509_system_trust
// file /usr/include/gnutls/gnutls.h line 1494
signed int gnutls_certificate_set_x509_system_trust(struct gnutls_certificate_credentials_st *);
// gnutls_certificate_type_get
// file /usr/include/gnutls/gnutls.h line 858
enum anonymous$33 gnutls_certificate_type_get(struct gnutls_session_int *);
// gnutls_certificate_verify_peers2
// file /usr/include/gnutls/gnutls.h line 2097
signed int gnutls_certificate_verify_peers2(struct gnutls_session_int *, unsigned int *);
// gnutls_cipher_get
// file /usr/include/gnutls/gnutls.h line 852
enum gnutls_cipher_algorithm gnutls_cipher_get(struct gnutls_session_int *);
// gnutls_cipher_get_name
// file /usr/include/gnutls/gnutls.h line 868
const char * gnutls_cipher_get_name(enum gnutls_cipher_algorithm);
// gnutls_compression_get
// file /usr/include/gnutls/gnutls.h line 856
enum anonymous$32 gnutls_compression_get(struct gnutls_session_int *);
// gnutls_compression_get_name
// file /usr/include/gnutls/gnutls.h line 874
const char * gnutls_compression_get_name(enum anonymous$32);
// gnutls_credentials_set
// file /usr/include/gnutls/gnutls.h line 1367
signed int gnutls_credentials_set(struct gnutls_session_int *, enum anonymous$11, void *);
// gnutls_deinit
// file /usr/include/gnutls/gnutls.h line 816
void gnutls_deinit(struct gnutls_session_int *);
// gnutls_dh_params_deinit
// file /usr/include/gnutls/gnutls.h line 1662
void gnutls_dh_params_deinit(struct gnutls_dh_params_int *);
// gnutls_dh_params_generate2
// file /usr/include/gnutls/gnutls.h line 1673
signed int gnutls_dh_params_generate2(struct gnutls_dh_params_int *, unsigned int);
// gnutls_dh_params_init
// file /usr/include/gnutls/gnutls.h line 1661
signed int gnutls_dh_params_init(struct gnutls_dh_params_int **);
// gnutls_error_is_fatal
// file /usr/include/gnutls/gnutls.h line 935
signed int gnutls_error_is_fatal(signed int);
// gnutls_global_deinit
// file /usr/include/gnutls/gnutls.h line 1608
void gnutls_global_deinit(void);
// gnutls_global_init
// file /usr/include/gnutls/gnutls.h line 1607
signed int gnutls_global_init(void);
// gnutls_handshake
// file /usr/include/gnutls/gnutls.h line 821
signed int gnutls_handshake(struct gnutls_session_int *);
// gnutls_hash
// file /usr/include/gnutls/crypto.h line 108
signed int gnutls_hash(struct hash_hd_st *, const void *, unsigned long int);
// gnutls_hash_deinit
// file /usr/include/gnutls/crypto.h line 110
void gnutls_hash_deinit(struct hash_hd_st *, void *);
// gnutls_hash_init
// file /usr/include/gnutls/crypto.h line 106
signed int gnutls_hash_init(struct hash_hd_st **, enum anonymous$25);
// gnutls_init
// file /usr/include/gnutls/gnutls.h line 815
signed int gnutls_init(struct gnutls_session_int **, unsigned int);
// gnutls_kx_get
// file /usr/include/gnutls/gnutls.h line 853
enum anonymous$30 gnutls_kx_get(struct gnutls_session_int *);
// gnutls_kx_get_name
// file /usr/include/gnutls/gnutls.h line 876
const char * gnutls_kx_get_name(enum anonymous$30);
// gnutls_mac_get
// file /usr/include/gnutls/gnutls.h line 854
enum anonymous$31 gnutls_mac_get(struct gnutls_session_int *);
// gnutls_mac_get_name
// file /usr/include/gnutls/gnutls.h line 869
const char * gnutls_mac_get_name(enum anonymous$31);
// gnutls_protocol_get_name
// file /usr/include/gnutls/gnutls.h line 1213
const char * gnutls_protocol_get_name(enum anonymous$29);
// gnutls_protocol_get_version
// file /usr/include/gnutls/gnutls.h line 1211
enum anonymous$29 gnutls_protocol_get_version(struct gnutls_session_int *);
// gnutls_record_get_direction
// file /usr/include/gnutls/gnutls.h line 1027
signed int gnutls_record_get_direction(struct gnutls_session_int *);
// gnutls_record_recv
// file /usr/include/gnutls/gnutls.h line 997
signed long int gnutls_record_recv(struct gnutls_session_int *, void *, unsigned long int);
// gnutls_record_send
// file /usr/include/gnutls/gnutls.h line 992
signed long int gnutls_record_send(struct gnutls_session_int *, const void *, unsigned long int);
// gnutls_set_default_priority
// file /usr/include/gnutls/gnutls.h line 1200
signed int gnutls_set_default_priority(struct gnutls_session_int *);
// gnutls_strerror
// file /usr/include/gnutls/gnutls.h line 939
const char * gnutls_strerror(signed int);
// gnutls_transport_set_ptr
// file /usr/include/gnutls/gnutls.h line 1722
void gnutls_transport_set_ptr(struct gnutls_session_int *, void *);
// gnutls_x509_crt_check_hostname
// file /usr/include/gnutls/x509.h line 180
signed int gnutls_x509_crt_check_hostname(struct gnutls_x509_crt_int *, const char *);
// gnutls_x509_crt_deinit
// file /usr/include/gnutls/x509.h line 126
void gnutls_x509_crt_deinit(struct gnutls_x509_crt_int *);
// gnutls_x509_crt_get_dn
// file /usr/include/gnutls/x509.h line 171
signed int gnutls_x509_crt_get_dn(struct gnutls_x509_crt_int *, char *, unsigned long int *);
// gnutls_x509_crt_get_issuer_dn
// file /usr/include/gnutls/x509.h line 160
signed int gnutls_x509_crt_get_issuer_dn(struct gnutls_x509_crt_int *, char *, unsigned long int *);
// gnutls_x509_crt_import
// file /usr/include/gnutls/x509.h line 127
signed int gnutls_x509_crt_import(struct gnutls_x509_crt_int *, const struct anonymous$28 *, enum anonymous$2);
// gnutls_x509_crt_init
// file /usr/include/gnutls/x509.h line 125
signed int gnutls_x509_crt_init(struct gnutls_x509_crt_int **);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit_
// file /usr/include/zlib.h line 1635
extern signed int inflateInit_(struct z_stream_s *, const char *, signed int);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// plug_to_string
// file connect.c line 1182
static const char * plug_to_string(enum anonymous$15 plug);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// protobuf_c_message_free_unpacked
// file /usr/include/protobuf-c/protobuf-c.h line 966
void protobuf_c_message_free_unpacked(struct ProtobufCMessage *, struct ProtobufCAllocator *);
// protobuf_c_message_get_packed_size
// file /usr/include/protobuf-c/protobuf-c.h line 886
unsigned long int protobuf_c_message_get_packed_size(const struct ProtobufCMessage *);
// protobuf_c_message_pack
// file /usr/include/protobuf-c/protobuf-c.h line 906
unsigned long int protobuf_c_message_pack(const struct ProtobufCMessage *, unsigned char *);
// protobuf_c_message_pack_to_buffer
// file /usr/include/protobuf-c/protobuf-c.h line 923
unsigned long int protobuf_c_message_pack_to_buffer(const struct ProtobufCMessage *, struct ProtobufCBuffer *);
// protobuf_c_message_unpack
// file /usr/include/protobuf-c/protobuf-c.h line 946
struct ProtobufCMessage * protobuf_c_message_unpack(const struct ProtobufCMessageDescriptor *, struct ProtobufCAllocator *, unsigned long int, const unsigned char *);
// protobuf_kvp__free_unpacked
// file packets.pb-c.c line 519
void protobuf_kvp__free_unpacked(struct _ProtobufKVP *message, struct ProtobufCAllocator *allocator);
// protobuf_kvp__get_packed_size
// file packets.pb-c.c line 489
unsigned long int protobuf_kvp__get_packed_size(const struct _ProtobufKVP *message);
// protobuf_kvp__init
// file packets.pb-c.c line 483
void protobuf_kvp__init(struct _ProtobufKVP *message);
// protobuf_kvp__pack
// file packets.pb-c.c line 495
unsigned long int protobuf_kvp__pack(const struct _ProtobufKVP *message, unsigned char *out);
// protobuf_kvp__pack_to_buffer
// file packets.pb-c.c line 502
unsigned long int protobuf_kvp__pack_to_buffer(const struct _ProtobufKVP *message, struct ProtobufCBuffer *buffer);
// protobuf_kvp__unpack
// file packets.pb-c.c line 510
struct _ProtobufKVP * protobuf_kvp__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$13 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$13 *, union anonymous$10 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$10 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$10 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$19 *, struct anonymous$19 *, struct anonymous$19 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// server_func
// file connect.c line 734
static void * server_func(void *arg);
// server_ssl_deinit
// file connect.c line 727
static void server_ssl_deinit(struct gnutls_session_int **session);
// server_ssl_init
// file connect.c line 696
static signed int server_ssl_init(struct gnutls_session_int **session, signed int client_fd);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$34
{
  // session
  struct gnutls_session_int *session;
  // xcred
  struct gnutls_certificate_credentials_st *xcred;
};

struct anonymous$28
{
  // data
  unsigned char *data;
  // size
  unsigned int size;
};

struct anonymous$7
{
  // cb_data
  void *cb_data;
  // connect_cb
  void * (*connect_cb)(void *, const char *, signed int, signed int, signed int, void *);
  // close_cb
  void (*close_cb)(void *, void *);
  // read_cb
  signed long int (*read_cb)(void *, void *, unsigned char *, unsigned long int);
  // write_cb
  signed long int (*write_cb)(void *, void *, const unsigned char *, unsigned long int);
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
  // reserved3
  void *reserved3;
  // reserved4
  void *reserved4;
};

struct anonymous$19
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$23
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$24
{
  // __cancel_jmp_buf
  struct anonymous$23 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$9
{
  // id
  unsigned char id[8l];
};

struct anonymous$16
{
  // plug_80
  enum anonymous$15 plug_80;
  // plug_443
  enum anonymous$15 plug_443;
  // plug_8074
  enum anonymous$15 plug_8074;
  // plug_8080
  enum anonymous$15 plug_8080;
  // plug_resolver
  enum anonymous$15 plug_resolver;
  // server
  _Bool server;
  // async_mode
  _Bool async_mode;
  // proxy_mode
  _Bool proxy_mode;
  // ssl_mode
  _Bool ssl_mode;
  // tried_80
  _Bool tried_80;
  // tried_443
  _Bool tried_443;
  // tried_8074
  _Bool tried_8074;
  // tried_8080
  _Bool tried_8080;
  // tried_non_8080
  _Bool tried_non_8080;
  // tried_resolver
  _Bool tried_resolver;
};

struct anonymous$26
{
  // state
  enum gg_state_t state;
  // handler
  enum anonymous$27 (*handler)(struct gg_session *, struct gg_event *, enum gg_state_t, enum gg_state_t, enum gg_state_t);
  // next_state
  enum gg_state_t next_state;
  // alt_state
  enum gg_state_t alt_state;
  // alt2_state
  enum gg_state_t alt2_state;
};

struct anonymous$12
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct anonymous$20
{
  // addr
  struct in_addr addr;
  // addr_list
  char *addr_list[2l];
  // name
  char name[1l];
};

struct anonymous$1
{
  // type
  unsigned int type;
  // state
  enum gg_state_t state;
  // min_length
  unsigned long int min_length;
  // handler
  signed int (*handler)(struct gg_session *, unsigned int, const char *, unsigned long int, struct gg_event *);
};

union anonymous$13
{
  // __data
  struct anonymous$12 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$10
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ProtobufCAllocator
{
  // alloc
  void * (*alloc)(void *, unsigned long int);
  // free
  void (*free)(void *, void *);
  // allocator_data
  void *allocator_data;
};

struct ProtobufCBinaryData
{
  // len
  unsigned long int len;
  // data
  unsigned char *data;
};

struct ProtobufCBuffer
{
  // append
  void (*append)(struct ProtobufCBuffer *, unsigned long int, const unsigned char *);
};

struct ProtobufCEnumDescriptor
{
  // magic
  unsigned int magic;
  // name
  const char *name;
  // short_name
  const char *short_name;
  // c_name
  const char *c_name;
  // package_name
  const char *package_name;
  // n_values
  unsigned int n_values;
  // values
  const struct ProtobufCEnumValue *values;
  // n_value_names
  unsigned int n_value_names;
  // values_by_name
  const struct ProtobufCEnumValueIndex *values_by_name;
  // n_value_ranges
  unsigned int n_value_ranges;
  // value_ranges
  const struct ProtobufCIntRange *value_ranges;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
  // reserved3
  void *reserved3;
  // reserved4
  void *reserved4;
};

struct ProtobufCEnumValue
{
  // name
  const char *name;
  // c_name
  const char *c_name;
  // value
  signed int value;
};

struct ProtobufCEnumValueIndex
{
  // name
  const char *name;
  // index
  unsigned int index;
};

struct ProtobufCFieldDescriptor
{
  // name
  const char *name;
  // id
  unsigned int id;
  // label
  enum anonymous label;
  // type
  enum anonymous$0 type;
  // quantifier_offset
  unsigned int quantifier_offset;
  // offset
  unsigned int offset;
  // descriptor
  const void *descriptor;
  // default_value
  const void *default_value;
  // flags
  unsigned int flags;
  // reserved_flags
  unsigned int reserved_flags;
  // reserved2
  void *reserved2;
  // reserved3
  void *reserved3;
};

struct ProtobufCIntRange
{
  // start_value
  signed int start_value;
  // orig_index
  unsigned int orig_index;
};

struct ProtobufCMessage
{
  // descriptor
  const struct ProtobufCMessageDescriptor *descriptor;
  // n_unknown_fields
  unsigned int n_unknown_fields;
  // unknown_fields
  struct ProtobufCMessageUnknownField *unknown_fields;
};

struct ProtobufCMessageDescriptor
{
  // magic
  unsigned int magic;
  // name
  const char *name;
  // short_name
  const char *short_name;
  // c_name
  const char *c_name;
  // package_name
  const char *package_name;
  // sizeof_message
  unsigned long int sizeof_message;
  // n_fields
  unsigned int n_fields;
  // fields
  const struct ProtobufCFieldDescriptor *fields;
  // fields_sorted_by_name
  const unsigned int *fields_sorted_by_name;
  // n_field_ranges
  unsigned int n_field_ranges;
  // field_ranges
  const struct ProtobufCIntRange *field_ranges;
  // message_init
  void (*message_init)(struct ProtobufCMessage *);
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
  // reserved3
  void *reserved3;
};

struct ProtobufCMessageUnknownField
{
  // tag
  unsigned int tag;
  // wire_type
  enum anonymous$35 wire_type;
  // len
  unsigned long int len;
  // data
  unsigned char *data;
};

struct _GG105Login
{
  // base
  struct ProtobufCMessage base;
  // lang
  char *lang;
  // uin
  struct ProtobufCBinaryData uin;
  // hash
  struct ProtobufCBinaryData hash;
  // client
  char *client;
  // initial_status
  unsigned int initial_status;
  // initial_descr
  char *initial_descr;
  // supported_features
  char *supported_features;
  // dummy1
  signed int dummy1;
  // dummy2
  unsigned int dummy2;
  // dummy3
  unsigned int dummy3;
  // dummy4
  struct ProtobufCBinaryData dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // has_dummy7
  signed int has_dummy7;
  // dummy7
  unsigned int dummy7;
  // has_dummy8
  signed int has_dummy8;
  // dummy8
  signed int dummy8;
  // has_dummy10
  signed int has_dummy10;
  // dummy10
  unsigned int dummy10;
};

struct _GG110AccessInfo
{
  // base
  struct ProtobufCMessage base;
  // dummy1
  unsigned int dummy1;
  // dummy2
  unsigned int dummy2;
  // last_message
  unsigned int last_message;
  // last_file_transfer
  unsigned int last_file_transfer;
  // last_conference_ch
  unsigned int last_conference_ch;
};

struct _GG110Ack
{
  // base
  struct ProtobufCMessage base;
  // type
  enum _GG110Ack__Type type;
  // seq
  unsigned int seq;
  // dummy1
  unsigned int dummy1;
};

struct _GG110ChatInfoUpdate
{
  // base
  struct ProtobufCMessage base;
  // participant
  struct ProtobufCBinaryData participant;
  // inviter
  struct ProtobufCBinaryData inviter;
  // update_type
  unsigned int update_type;
  // time
  unsigned int time;
  // dummy1
  unsigned int dummy1;
  // version
  unsigned int version;
  // dummy2
  unsigned int dummy2;
  // msg_id
  unsigned long int msg_id;
  // chat_id
  unsigned long int chat_id;
  // conv_id
  unsigned long int conv_id;
};

struct _GG110Event
{
  // base
  struct ProtobufCMessage base;
  // type
  enum _GG110Event__Type type;
  // seq
  unsigned int seq;
  // data
  char *data;
  // subtype
  char *subtype;
  // has_id
  signed int has_id;
  // id
  unsigned long int id;
};

struct _GG110Imtoken
{
  // base
  struct ProtobufCMessage base;
  // imtoken
  char *imtoken;
};

struct _GG110LoginOK
{
  // base
  struct ProtobufCMessage base;
  // dummy1
  signed int dummy1;
  // dummyhash
  char *dummyhash;
  // uin
  unsigned int uin;
  // server_time
  unsigned int server_time;
};

struct _GG110MagicNotification
{
  // base
  struct ProtobufCMessage base;
  // dummy1
  signed int dummy1;
  // seq
  signed int seq;
  // dummy2
  signed int dummy2;
  // dummy3
  signed int dummy3;
  // uin
  struct ProtobufCBinaryData uin;
  // dummy4
  char *dummy4;
};

struct _GG110MessageAck
{
  // base
  struct ProtobufCMessage base;
  // msg_type
  unsigned int msg_type;
  // seq
  unsigned int seq;
  // time
  unsigned int time;
  // has_msg_id
  signed int has_msg_id;
  // msg_id
  unsigned long int msg_id;
  // has_conv_id
  signed int has_conv_id;
  // conv_id
  unsigned long int conv_id;
  // n_links
  unsigned long int n_links;
  // links
  struct _GG110MessageAckLink **links;
  // dummy1
  unsigned int dummy1;
};

struct _GG110MessageAckLink
{
  // base
  struct ProtobufCMessage base;
  // id
  unsigned long int id;
  // url
  char *url;
};

struct _GG110Options
{
  // base
  struct ProtobufCMessage base;
  // n_options
  unsigned long int n_options;
  // options
  struct _ProtobufKVP **options;
  // dummy1
  unsigned int dummy1;
};

struct _GG110Pong
{
  // base
  struct ProtobufCMessage base;
  // server_time
  unsigned int server_time;
};

struct _GG110RecvMessage
{
  // base
  struct ProtobufCMessage base;
  // has_sender
  signed int has_sender;
  // sender
  struct ProtobufCBinaryData sender;
  // flags
  unsigned int flags;
  // seq
  unsigned int seq;
  // time
  unsigned int time;
  // msg_plain
  char *msg_plain;
  // msg_xhtml
  char *msg_xhtml;
  // has_data
  signed int has_data;
  // data
  struct ProtobufCBinaryData data;
  // has_msg_id
  signed int has_msg_id;
  // msg_id
  unsigned long int msg_id;
  // has_chat_id
  signed int has_chat_id;
  // chat_id
  unsigned long int chat_id;
  // has_conv_id
  signed int has_conv_id;
  // conv_id
  unsigned long int conv_id;
};

struct _GG110SendMessage
{
  // base
  struct ProtobufCMessage base;
  // has_recipient
  signed int has_recipient;
  // recipient
  struct ProtobufCBinaryData recipient;
  // dummy1
  unsigned int dummy1;
  // seq
  unsigned int seq;
  // msg_plain
  char *msg_plain;
  // msg_xhtml
  char *msg_xhtml;
  // dummy3
  char *dummy3;
  // has_chat_id
  signed int has_chat_id;
  // chat_id
  unsigned long int chat_id;
};

struct _GG112TransferInfo
{
  // base
  struct ProtobufCMessage base;
  // dummy1
  unsigned int dummy1;
  // peer
  struct _GG112TransferInfoUin *peer;
  // sender
  struct _GG112TransferInfoUin *sender;
  // time
  unsigned int time;
  // n_data
  unsigned long int n_data;
  // data
  struct _ProtobufKVP **data;
  // file
  struct _GG112TransferInfoFile *file;
  // seq
  unsigned int seq;
  // msg_id
  unsigned long int msg_id;
  // conv_id
  unsigned long int conv_id;
};

struct _GG112TransferInfoFile
{
  // base
  struct ProtobufCMessage base;
  // type
  char *type;
  // url
  char *url;
  // content_type
  char *content_type;
  // filename
  char *filename;
  // filesize
  unsigned int filesize;
  // msg_id
  unsigned long int msg_id;
};

struct _GG112TransferInfoUin
{
  // base
  struct ProtobufCMessage base;
  // dummy1
  unsigned int dummy1;
  // uin
  struct ProtobufCBinaryData uin;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ProtobufKVP
{
  // base
  struct ProtobufCMessage base;
  // key
  char *key;
  // value
  char *value;
};

struct _gg_chat_list
{
  // id
  unsigned long int id;
  // version
  unsigned int version;
  // participants_count
  unsigned int participants_count;
  // participants
  unsigned int *participants;
  // next
  struct _gg_chat_list *next;
};

struct _gg_eventqueue
{
  // event
  struct gg_event *event;
  // next
  struct _gg_eventqueue *next;
};

struct gg_send_msg
{
  // recipient
  unsigned int recipient;
  // seq
  unsigned int seq;
  // msgclass
  unsigned int msgclass;
} __attribute__ ((__packed__));

struct _gg_imgout_queue_t
{
  // msg_hdr
  struct gg_send_msg msg_hdr;
  // buf
  char buf[1910l];
  // buf_len
  unsigned long int buf_len;
  // next
  struct _gg_imgout_queue_t *next;
};

struct _gg_msg_list
{
  // seq
  signed int seq;
  // recipients
  unsigned int *recipients;
  // recipients_count
  unsigned long int recipients_count;
  // next
  struct _gg_msg_list *next;
};

struct _gg_protobuf_uin_buff
{
  // data
  char data[18l];
};

struct gg_add_remove
{
  // uin
  unsigned int uin;
  // dunno1
  unsigned char dunno1;
} __attribute__ ((__packed__));

struct gg_change_info_request
{
  // first_name
  char *first_name;
  // last_name
  char *last_name;
  // nickname
  char *nickname;
  // email
  char *email;
  // born
  signed int born;
  // gender
  signed int gender;
  // city
  char *city;
};

struct gg_chat_create
{
  // seq
  unsigned int seq;
  // dummy
  unsigned int dummy;
} __attribute__ ((__packed__));

struct gg_chat_created
{
  // id
  unsigned long int id;
  // seq
  unsigned int seq;
} __attribute__ ((__packed__));

struct gg_chat_invite
{
  // id
  unsigned long int id;
  // seq
  unsigned int seq;
  // participants_count
  unsigned int participants_count;
} __attribute__ ((__packed__));

struct gg_chat_invite_ack
{
  // id
  unsigned long int id;
  // seq
  unsigned int seq;
  // unknown1
  unsigned int unknown1;
  // unknown2
  unsigned int unknown2;
} __attribute__ ((__packed__));

struct gg_chat_leave
{
  // id
  unsigned long int id;
  // seq
  unsigned int seq;
} __attribute__ ((__packed__));

struct gg_chat_left
{
  // id
  unsigned long int id;
  // uin
  unsigned int uin;
} __attribute__ ((__packed__));

struct gg_file_info
{
  // mode
  unsigned int mode;
  // ctime
  unsigned int ctime[2l];
  // atime
  unsigned int atime[2l];
  // mtime
  unsigned int mtime[2l];
  // size_hi
  unsigned int size_hi;
  // size
  unsigned int size;
  // reserved0
  unsigned int reserved0;
  // reserved1
  unsigned int reserved1;
  // filename
  unsigned char filename[262l];
  // short_filename
  unsigned char short_filename[14l];
} __attribute__ ((__packed__));

struct gg_dcc
{
  // fd
  signed int fd;
  // check
  signed int check;
  // state
  signed int state;
  // error
  signed int error;
  // type
  signed int type;
  // id
  signed int id;
  // timeout
  signed int timeout;
  // callback
  signed int (*callback)(struct gg_dcc *);
  // destroy
  void (*destroy)(struct gg_dcc *);
  // event
  struct gg_event *event;
  // active
  signed int active;
  // port
  signed int port;
  // uin
  unsigned int uin;
  // peer_uin
  unsigned int peer_uin;
  // file_fd
  signed int file_fd;
  // offset
  unsigned int offset;
  // chunk_size
  unsigned int chunk_size;
  // chunk_offset
  unsigned int chunk_offset;
  // file_info
  struct gg_file_info file_info;
  // established
  signed int established;
  // voice_buf
  char *voice_buf;
  // incoming
  signed int incoming;
  // chunk_buf
  char *chunk_buf;
  // remote_addr
  unsigned int remote_addr;
  // remote_port
  unsigned short int remote_port;
};

struct gg_dcc7
{
  // fd
  signed int fd;
  // check
  signed int check;
  // state
  signed int state;
  // error
  signed int error;
  // type
  signed int type;
  // id
  signed int id;
  // timeout
  signed int timeout;
  // callback
  signed int (*callback)(struct gg_dcc7 *);
  // destroy
  void (*destroy)(struct gg_dcc7 *);
  // cid
  struct anonymous$9 cid;
  // event
  struct gg_event *event;
  // uin
  unsigned int uin;
  // peer_uin
  unsigned int peer_uin;
  // file_fd
  signed int file_fd;
  // offset
  unsigned int offset;
  // size
  unsigned int size;
  // filename
  unsigned char filename[256l];
  // hash
  unsigned char hash[20l];
  // dcc_type
  signed int dcc_type;
  // established
  signed int established;
  // incoming
  signed int incoming;
  // reverse
  signed int reverse;
  // local_addr
  unsigned int local_addr;
  // local_port
  unsigned short int local_port;
  // remote_addr
  unsigned int remote_addr;
  // remote_port
  unsigned short int remote_port;
  // sess
  struct gg_session *sess;
  // next
  struct gg_dcc7 *next;
  // soft_timeout
  signed int soft_timeout;
  // seek
  signed int seek;
  // resolver
  void *resolver;
  // relay
  signed int relay;
  // relay_index
  signed int relay_index;
  // relay_count
  signed int relay_count;
  // relay_list
  struct gg_dcc7_relay *relay_list;
};

struct gg_dcc7_accept
{
  // uin
  unsigned int uin;
  // id
  struct anonymous$9 id;
  // offset
  unsigned int offset;
  // dunno1
  unsigned int dunno1;
} __attribute__ ((__packed__));

struct gg_dcc7_id_reply
{
  // type
  unsigned int type;
  // id
  struct anonymous$9 id;
} __attribute__ ((__packed__));

struct gg_dcc7_id_request
{
  // type
  unsigned int type;
} __attribute__ ((__packed__));

struct gg_dcc7_info
{
  // uin
  unsigned int uin;
  // type
  unsigned int type;
  // id
  struct anonymous$9 id;
  // info
  char info[32l];
  // hash
  char hash[32l];
} __attribute__ ((__packed__));

struct gg_dcc7_new
{
  // id
  struct anonymous$9 id;
  // uin_from
  unsigned int uin_from;
  // uin_to
  unsigned int uin_to;
  // type
  unsigned int type;
  // filename
  unsigned char filename[255l];
  // size
  unsigned int size;
  // size_hi
  unsigned int size_hi;
  // hash
  unsigned char hash[20l];
} __attribute__ ((__packed__));

struct gg_dcc7_reject
{
  // uin
  unsigned int uin;
  // id
  struct anonymous$9 id;
  // reason
  unsigned int reason;
} __attribute__ ((__packed__));

struct gg_dcc7_relay
{
  // addr
  unsigned int addr;
  // port
  unsigned short int port;
  // family
  unsigned char family;
};

struct gg_dcc7_relay_reply
{
  // magic
  unsigned int magic;
  // len
  unsigned int len;
  // rcount
  unsigned int rcount;
} __attribute__ ((__packed__));

struct gg_dcc7_relay_reply_server
{
  // addr
  unsigned int addr;
  // port
  unsigned short int port;
  // family
  unsigned char family;
} __attribute__ ((__packed__));

struct gg_dcc7_relay_req
{
  // magic
  unsigned int magic;
  // len
  unsigned int len;
  // id
  struct anonymous$9 id;
  // type
  unsigned short int type;
  // dunno1
  unsigned short int dunno1;
} __attribute__ ((__packed__));

struct gg_dcc7_welcome_p2p
{
  // id
  struct anonymous$9 id;
} __attribute__ ((__packed__));

struct gg_dcc7_welcome_server
{
  // magic
  unsigned int magic;
  // id
  struct anonymous$9 id;
} __attribute__ ((__packed__));

struct gg_dcc_big_packet
{
  // type
  unsigned int type;
  // dunno1
  unsigned int dunno1;
  // dunno2
  unsigned int dunno2;
} __attribute__ ((__packed__));

struct gg_dcc_small_packet
{
  // type
  unsigned int type;
} __attribute__ ((__packed__));

struct gg_dcc_tiny_packet
{
  // type
  unsigned char type;
} __attribute__ ((__packed__));

struct gg_event_notify_descr
{
  // notify
  struct gg_notify_reply *notify;
  // descr
  char *descr;
};

struct gg_event_status
{
  // uin
  unsigned int uin;
  // status
  unsigned int status;
  // descr
  char *descr;
};

struct gg_event_status60
{
  // uin
  unsigned int uin;
  // status
  signed int status;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // version
  signed int version;
  // image_size
  signed int image_size;
  // descr
  char *descr;
  // time
  signed long int time;
};

struct gg_event_msg
{
  // sender
  unsigned int sender;
  // msgclass
  signed int msgclass;
  // time
  signed long int time;
  // message
  unsigned char *message;
  // recipients_count
  signed int recipients_count;
  // recipients
  unsigned int *recipients;
  // formats_length
  signed int formats_length;
  // formats
  void *formats;
  // seq
  unsigned int seq;
  // xhtml_message
  char *xhtml_message;
  // chat_id
  unsigned long int chat_id;
  // flags
  unsigned long int flags;
};

struct gg_event_ack
{
  // recipient
  unsigned int recipient;
  // status
  signed int status;
  // seq
  signed int seq;
};

struct gg_event_ack110
{
  // msg_type
  unsigned char msg_type;
  // seq
  unsigned int seq;
  // time
  unsigned int time;
};

struct gg_event_image_request
{
  // sender
  unsigned int sender;
  // size
  unsigned int size;
  // crc32
  unsigned int crc32;
};

struct gg_event_image_reply
{
  // sender
  unsigned int sender;
  // size
  unsigned int size;
  // crc32
  unsigned int crc32;
  // filename
  char *filename;
  // image
  char *image;
};

struct gg_event_userlist
{
  // type
  char type;
  // reply
  char *reply;
};

struct gg_event_xml_event
{
  // data
  char *data;
};

struct gg_event_json_event
{
  // data
  char *data;
  // type
  char *type;
};

struct gg_event_dcc_voice_data
{
  // data
  unsigned char *data;
  // length
  signed int length;
};

struct gg_event_dcc7_connected
{
  // dcc7
  struct gg_dcc7 *dcc7;
};

struct gg_event_dcc7_pending
{
  // dcc7
  struct gg_dcc7 *dcc7;
};

struct gg_event_dcc7_reject
{
  // dcc7
  struct gg_dcc7 *dcc7;
  // reason
  signed int reason;
};

struct gg_event_dcc7_accept
{
  // dcc7
  struct gg_dcc7 *dcc7;
  // type
  signed int type;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
};

struct gg_event_dcc7_done
{
  // dcc7
  struct gg_dcc7 *dcc7;
};

struct gg_event_typing_notification
{
  // uin
  unsigned int uin;
  // length
  signed int length;
};

struct gg_event_user_data
{
  // type
  signed int type;
  // user_count
  unsigned long int user_count;
  // users
  struct gg_event_user_data_user *users;
};

struct gg_event_multilogon_info
{
  // count
  signed int count;
  // sessions
  struct gg_multilogon_session *sessions;
};

struct gg_event_userlist100_version
{
  // version
  unsigned int version;
};

struct gg_event_userlist100_reply
{
  // type
  char type;
  // version
  unsigned int version;
  // format_type
  char format_type;
  // reply
  char *reply;
};

struct gg_event_imtoken
{
  // imtoken
  char *imtoken;
};

struct gg_event_pong110
{
  // time
  signed long int time;
};

struct gg_event_chat_info
{
  // id
  unsigned long int id;
  // version
  unsigned int version;
  // participants_count
  unsigned int participants_count;
  // participants
  unsigned int *participants;
};

struct gg_event_chat_info_update
{
  // id
  unsigned long int id;
  // type
  unsigned int type;
  // participant
  unsigned int participant;
  // inviter
  unsigned int inviter;
  // version
  unsigned int version;
  // time
  unsigned int time;
};

struct gg_event_chat_created
{
  // id
  unsigned long int id;
  // seq
  unsigned int seq;
};

struct gg_event_chat_invite_ack
{
  // id
  unsigned long int id;
  // seq
  unsigned int seq;
};

union gg_event_union
{
  // failure
  enum gg_failure_t failure;
  // notify
  struct gg_notify_reply *notify;
  // notify_descr
  struct gg_event_notify_descr notify_descr;
  // status
  struct gg_event_status status;
  // status60
  struct gg_event_status60 status60;
  // notify60
  struct gg_event_notify60 *notify60;
  // msg
  struct gg_event_msg msg;
  // ack
  struct gg_event_ack ack;
  // ack110
  struct gg_event_ack110 ack110;
  // image_request
  struct gg_event_image_request image_request;
  // image_reply
  struct gg_event_image_reply image_reply;
  // userlist
  struct gg_event_userlist userlist;
  // pubdir50
  struct gg_pubdir50_s *pubdir50;
  // xml_event
  struct gg_event_xml_event xml_event;
  // json_event
  struct gg_event_json_event json_event;
  // dcc_new
  struct gg_dcc *dcc_new;
  // dcc_error
  enum gg_error_t dcc_error;
  // dcc_voice_data
  struct gg_event_dcc_voice_data dcc_voice_data;
  // dcc7_new
  struct gg_dcc7 *dcc7_new;
  // dcc7_error
  enum gg_error_t dcc7_error;
  // dcc7_connected
  struct gg_event_dcc7_connected dcc7_connected;
  // dcc7_pending
  struct gg_event_dcc7_pending dcc7_pending;
  // dcc7_reject
  struct gg_event_dcc7_reject dcc7_reject;
  // dcc7_accept
  struct gg_event_dcc7_accept dcc7_accept;
  // dcc7_done
  struct gg_event_dcc7_done dcc7_done;
  // typing_notification
  struct gg_event_typing_notification typing_notification;
  // user_data
  struct gg_event_user_data user_data;
  // multilogon_msg
  struct gg_event_msg multilogon_msg;
  // multilogon_info
  struct gg_event_multilogon_info multilogon_info;
  // userlist100_version
  struct gg_event_userlist100_version userlist100_version;
  // userlist100_reply
  struct gg_event_userlist100_reply userlist100_reply;
  // imtoken
  struct gg_event_imtoken imtoken;
  // pong110
  struct gg_event_pong110 pong110;
  // chat_info
  struct gg_event_chat_info chat_info;
  // chat_info_update
  struct gg_event_chat_info_update chat_info_update;
  // chat_created
  struct gg_event_chat_created chat_created;
  // chat_invite_ack
  struct gg_event_chat_invite_ack chat_invite_ack;
};

struct gg_event
{
  // type
  signed int type;
  // event
  union gg_event_union event;
};

struct gg_event_notify60
{
  // uin
  unsigned int uin;
  // status
  signed int status;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // version
  signed int version;
  // image_size
  signed int image_size;
  // descr
  char *descr;
  // time
  signed long int time;
};

struct gg_event_user_data_attr
{
  // type
  signed int type;
  // key
  char *key;
  // value
  char *value;
};

struct gg_event_user_data_user
{
  // uin
  unsigned int uin;
  // attr_count
  unsigned long int attr_count;
  // attrs
  struct gg_event_user_data_attr *attrs;
};

struct gg_header
{
  // type
  unsigned int type;
  // length
  unsigned int length;
} __attribute__ ((__packed__));

struct gg_http
{
  // fd
  signed int fd;
  // check
  signed int check;
  // state
  signed int state;
  // error
  signed int error;
  // type
  signed int type;
  // id
  signed int id;
  // timeout
  signed int timeout;
  // callback
  signed int (*callback)(struct gg_http *);
  // destroy
  void (*destroy)(struct gg_http *);
  // async
  signed int async;
  // pid
  signed int pid;
  // port
  signed int port;
  // query
  char *query;
  // header
  char *header;
  // header_size
  signed int header_size;
  // body
  char *body;
  // body_size
  unsigned int body_size;
  // data
  void *data;
  // user_data
  char *user_data;
  // resolver
  void *resolver;
  // body_done
  unsigned int body_done;
  // resolver_type
  enum anonymous$4 resolver_type;
  // resolver_start
  signed int (*resolver_start)(signed int *, void **, const char *);
  // resolver_cleanup
  void (*resolver_cleanup)(void **, signed int);
};

struct gg_image_queue
{
  // sender
  unsigned int sender;
  // size
  unsigned int size;
  // crc32
  unsigned int crc32;
  // filename
  char *filename;
  // image
  char *image;
  // done
  unsigned int done;
  // next
  struct gg_image_queue *next;
  // packet_type
  unsigned int packet_type;
};

struct gg_login80
{
  // uin
  unsigned int uin;
  // language
  unsigned char language[2l];
  // hash_type
  unsigned char hash_type;
  // hash
  unsigned char hash[64l];
  // status
  unsigned int status;
  // flags
  unsigned int flags;
  // features
  unsigned int features;
  // local_ip
  unsigned int local_ip;
  // local_port
  unsigned short int local_port;
  // external_ip
  unsigned int external_ip;
  // external_port
  unsigned short int external_port;
  // image_size
  unsigned char image_size;
  // dunno2
  unsigned char dunno2;
} __attribute__ ((__packed__));

struct gg_login_params
{
  // uin
  unsigned int uin;
  // password
  char *password;
  // async
  signed int async;
  // status
  signed int status;
  // status_descr
  char *status_descr;
  // server_addr
  unsigned int server_addr;
  // server_port
  unsigned short int server_port;
  // client_addr
  unsigned int client_addr;
  // client_port
  unsigned short int client_port;
  // protocol_version
  signed int protocol_version;
  // client_version
  char *client_version;
  // has_audio
  signed int has_audio;
  // last_sysmsg
  signed int last_sysmsg;
  // external_addr
  unsigned int external_addr;
  // external_port
  unsigned short int external_port;
  // tls
  signed int tls;
  // image_size
  signed int image_size;
  // era_omnix
  signed int era_omnix;
  // hash_type
  signed int hash_type;
  // encoding
  enum anonymous$3 encoding;
  // resolver
  enum anonymous$4 resolver;
  // protocol_features
  signed int protocol_features;
  // status_flags
  signed int status_flags;
  // struct_size
  unsigned int struct_size;
  // compatibility
  enum anonymous$5 compatibility;
  // connect_host
  char *connect_host;
  // socket_manager_type
  enum anonymous$6 socket_manager_type;
  // socket_manager
  struct anonymous$7 socket_manager;
  // host_white_list
  char **host_white_list;
};

struct gg_msg_image_reply
{
  // flag
  unsigned char flag;
  // size
  unsigned int size;
  // crc32
  unsigned int crc32;
} __attribute__ ((__packed__));

struct gg_msg_image_request
{
  // flag
  unsigned char flag;
  // size
  unsigned int size;
  // crc32
  unsigned int crc32;
} __attribute__ ((__packed__));

struct gg_msg_recipients
{
  // flag
  unsigned char flag;
  // count
  unsigned int count;
} __attribute__ ((__packed__));

struct gg_multilogon_disconnect
{
  // conn_id
  struct anonymous$9 conn_id;
} __attribute__ ((__packed__));

struct gg_multilogon_info
{
  // count
  unsigned int count;
} __attribute__ ((__packed__));

struct gg_multilogon_info_item
{
  // addr
  unsigned int addr;
  // flags
  unsigned int flags;
  // features
  unsigned int features;
  // logon_time
  unsigned int logon_time;
  // conn_id
  struct anonymous$9 conn_id;
  // unknown1
  unsigned int unknown1;
  // name_size
  unsigned int name_size;
} __attribute__ ((__packed__));

struct gg_multilogon_session
{
  // id
  struct anonymous$9 id;
  // name
  char *name;
  // remote_addr
  unsigned int remote_addr;
  // status_flags
  signed int status_flags;
  // protocol_features
  signed int protocol_features;
  // logon_time
  signed long int logon_time;
};

struct gg_new_status80
{
  // status
  unsigned int status;
  // flags
  unsigned int flags;
  // description_size
  unsigned int description_size;
} __attribute__ ((__packed__));

struct gg_notify
{
  // uin
  unsigned int uin;
  // dunno1
  unsigned char dunno1;
} __attribute__ ((__packed__));

struct gg_notify_reply
{
  // uin
  unsigned int uin;
  // status
  unsigned int status;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // version
  unsigned int version;
  // dunno2
  unsigned short int dunno2;
} __attribute__ ((__packed__));

struct gg_notify_reply60
{
  // uin
  unsigned int uin;
  // status
  unsigned char status;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // version
  unsigned char version;
  // image_size
  unsigned char image_size;
  // dunno1
  unsigned char dunno1;
} __attribute__ ((__packed__));

struct gg_notify_reply77
{
  // uin
  unsigned int uin;
  // status
  unsigned char status;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // version
  unsigned char version;
  // image_size
  unsigned char image_size;
  // dunno1
  unsigned char dunno1;
  // dunno2
  unsigned int dunno2;
} __attribute__ ((__packed__));

struct gg_notify_reply80
{
  // uin
  unsigned int uin;
  // status
  unsigned int status;
  // features
  unsigned int features;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // image_size
  unsigned char image_size;
  // unknown1
  unsigned char unknown1;
  // flags
  unsigned int flags;
  // descr_len
  unsigned int descr_len;
} __attribute__ ((__packed__));

struct gg_pubdir
{
  // success
  signed int success;
  // uin
  unsigned int uin;
  // error
  enum anonymous$21 error;
};

struct gg_pubdir50_entry
{
  // num
  signed int num;
  // field
  char *field;
  // value
  char *value;
};

struct gg_pubdir50_reply
{
  // type
  unsigned char type;
  // seq
  unsigned int seq;
} __attribute__ ((__packed__));

struct gg_pubdir50_request
{
  // type
  unsigned char type;
  // seq
  unsigned int seq;
} __attribute__ ((__packed__));

struct gg_pubdir50_s
{
  // count
  signed int count;
  // next
  unsigned int next;
  // type
  signed int type;
  // seq
  unsigned int seq;
  // entries
  struct gg_pubdir50_entry *entries;
  // entries_count
  signed int entries_count;
};

struct gg_recv_msg
{
  // sender
  unsigned int sender;
  // seq
  unsigned int seq;
  // time
  unsigned int time;
  // msgclass
  unsigned int msgclass;
} __attribute__ ((__packed__));

struct gg_recv_msg80
{
  // sender
  unsigned int sender;
  // seq
  unsigned int seq;
  // time
  unsigned int time;
  // msgclass
  unsigned int msgclass;
  // offset_plain
  unsigned int offset_plain;
  // offset_attr
  unsigned int offset_attr;
} __attribute__ ((__packed__));

struct gg_recv_msg_ack
{
  // seq
  unsigned int seq;
} __attribute__ ((__packed__));

struct gg_resolver_fork_data
{
  // pid
  signed int pid;
};

struct gg_resolver_pthread_data
{
  // thread
  unsigned long int thread;
  // hostname
  char *hostname;
  // wfd
  signed int wfd;
};

struct gg_search_request
{
  // active
  signed int active;
  // start
  unsigned int start;
  // nickname
  char *nickname;
  // first_name
  char *first_name;
  // last_name
  char *last_name;
  // city
  char *city;
  // gender
  signed int gender;
  // min_birth
  signed int min_birth;
  // max_birth
  signed int max_birth;
  // email
  char *email;
  // phone
  char *phone;
  // uin
  unsigned int uin;
};

struct gg_send_msg80
{
  // recipient
  unsigned int recipient;
  // seq
  unsigned int seq;
  // msgclass
  unsigned int msgclass;
  // offset_plain
  unsigned int offset_plain;
  // offset_attr
  unsigned int offset_attr;
} __attribute__ ((__packed__));

struct gg_send_msg_ack
{
  // status
  unsigned int status;
  // recipient
  unsigned int recipient;
  // seq
  unsigned int seq;
} __attribute__ ((__packed__));

struct gg_session
{
  // fd
  signed int fd;
  // check
  signed int check;
  // state
  signed int state;
  // error
  signed int error;
  // type
  signed int type;
  // id
  signed int id;
  // timeout
  signed int timeout;
  // callback
  signed int (*callback)(struct gg_session *);
  // destroy
  void (*destroy)(struct gg_session *);
  // async
  signed int async;
  // pid
  signed int pid;
  // port
  signed int port;
  // seq
  signed int seq;
  // last_pong
  signed int last_pong;
  // last_event
  signed int last_event;
  // event
  struct gg_event *event;
  // proxy_addr
  unsigned int proxy_addr;
  // proxy_port
  unsigned short int proxy_port;
  // hub_addr
  unsigned int hub_addr;
  // server_addr
  unsigned int server_addr;
  // client_addr
  unsigned int client_addr;
  // client_port
  unsigned short int client_port;
  // external_addr
  unsigned int external_addr;
  // external_port
  unsigned short int external_port;
  // uin
  unsigned int uin;
  // password
  char *password;
  // initial_status
  signed int initial_status;
  // status
  signed int status;
  // recv_buf
  char *recv_buf;
  // recv_done
  signed int recv_done;
  // recv_left
  signed int recv_left;
  // protocol_version
  signed int protocol_version;
  // client_version
  char *client_version;
  // last_sysmsg
  signed int last_sysmsg;
  // initial_descr
  char *initial_descr;
  // resolver
  void *resolver;
  // header_buf
  char *header_buf;
  // header_done
  unsigned int header_done;
  // ssl
  void *ssl;
  // ssl_ctx
  void *ssl_ctx;
  // image_size
  signed int image_size;
  // userlist_reply
  char *userlist_reply;
  // userlist_blocks
  signed int userlist_blocks;
  // images
  struct gg_image_queue *images;
  // hash_type
  signed int hash_type;
  // send_buf
  char *send_buf;
  // send_left
  signed int send_left;
  // dcc7_list
  struct gg_dcc7 *dcc7_list;
  // soft_timeout
  signed int soft_timeout;
  // protocol_flags
  signed int protocol_flags;
  // encoding
  enum anonymous$3 encoding;
  // resolver_type
  enum anonymous$4 resolver_type;
  // resolver_start
  signed int (*resolver_start)(signed int *, void **, const char *);
  // resolver_cleanup
  void (*resolver_cleanup)(void **, signed int);
  // protocol_features
  signed int protocol_features;
  // status_flags
  signed int status_flags;
  // recv_msg_count
  signed int recv_msg_count;
  // resolver_host
  const char *resolver_host;
  // resolver_result
  struct in_addr *resolver_result;
  // resolver_index
  unsigned int resolver_index;
  // resolver_count
  unsigned int resolver_count;
  // connect_port
  unsigned short int connect_port[2l];
  // connect_index
  unsigned int connect_index;
  // connect_host
  char *connect_host;
  // ssl_flag
  enum anonymous$8 ssl_flag;
  // private_data
  struct gg_session_private *private_data;
};

struct gg_session_private
{
  // compatibility
  enum anonymous$5 compatibility;
  // chat_list
  struct _gg_chat_list *chat_list;
  // sent_messages
  struct _gg_msg_list *sent_messages;
  // event_queue
  struct _gg_eventqueue *event_queue;
  // check_after_queue
  signed int check_after_queue;
  // fd_after_queue
  signed int fd_after_queue;
  // imgout_queue
  struct _gg_imgout_queue_t *imgout_queue;
  // imgout_waiting_ack
  signed int imgout_waiting_ack;
  // socket_manager_type
  enum anonymous$6 socket_manager_type;
  // socket_manager
  struct anonymous$7 socket_manager;
  // socket_handle
  void *socket_handle;
  // socket_next_state
  signed int socket_next_state;
  // socket_is_external
  signed int socket_is_external;
  // socket_failure
  enum gg_failure_t socket_failure;
  // time_diff
  signed int time_diff;
  // dummyfds_created
  signed int dummyfds_created;
  // dummyfds
  signed int dummyfds[2l];
  // host_white_list
  char **host_white_list;
};

struct gg_status
{
  // uin
  unsigned int uin;
  // status
  unsigned int status;
} __attribute__ ((__packed__));

struct gg_status60
{
  // uin
  unsigned int uin;
  // status
  unsigned char status;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // version
  unsigned char version;
  // image_size
  unsigned char image_size;
  // dunno1
  unsigned char dunno1;
} __attribute__ ((__packed__));

struct gg_status77
{
  // uin
  unsigned int uin;
  // status
  unsigned char status;
  // remote_ip
  unsigned int remote_ip;
  // remote_port
  unsigned short int remote_port;
  // version
  unsigned char version;
  // image_size
  unsigned char image_size;
  // dunno1
  unsigned char dunno1;
  // dunno2
  unsigned int dunno2;
} __attribute__ ((__packed__));

struct gg_token
{
  // width
  signed int width;
  // height
  signed int height;
  // length
  signed int length;
  // tokenid
  char *tokenid;
};

struct gg_tvbuff
{
  // buffer
  const char *buffer;
  // length
  unsigned long int length;
  // offset
  unsigned long int offset;
  // valid
  signed int valid;
};

struct gg_tvbuilder
{
  // buffer
  char *buffer;
  // length
  unsigned long int length;
  // alloc_length
  unsigned long int alloc_length;
  // valid
  signed int valid;
  // gs
  struct gg_session *gs;
  // ge
  struct gg_event *ge;
};

struct gg_typing_notification
{
  // length
  unsigned short int length;
  // uin
  unsigned int uin;
} __attribute__ ((__packed__));

struct gg_user_data
{
  // type
  unsigned int type;
  // user_count
  unsigned int user_count;
} __attribute__ ((__packed__));

struct gg_user_data_user
{
  // uin
  unsigned int uin;
  // attr_count
  unsigned int attr_count;
} __attribute__ ((__packed__));

struct gg_userlist100_reply
{
  // type
  unsigned char type;
  // version
  unsigned int version;
  // format_type
  unsigned char format_type;
  // unknown1
  unsigned char unknown1;
} __attribute__ ((__packed__));

struct gg_userlist100_request
{
  // type
  unsigned char type;
  // version
  unsigned int version;
  // format_type
  unsigned char format_type;
  // unknown1
  unsigned char unknown1;
} __attribute__ ((__packed__));

struct gg_userlist100_version
{
  // version
  unsigned int version;
} __attribute__ ((__packed__));

struct gg_welcome
{
  // key
  unsigned int key;
} __attribute__ ((__packed__));

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// dh_params
// file connect.c line 134
static struct gnutls_dh_params_int *dh_params;
// gg105_login__descriptor
// file packets.pb-c.c line 1230
const struct ProtobufCMessageDescriptor gg105_login__descriptor;
// gg105_login__field_descriptors
// file packets.pb-c.c line 1011
static const struct ProtobufCFieldDescriptor gg105_login__field_descriptors[16l];
// gg105_login__dummy10__default_value
// file packets.pb-c.c line 1010
static const unsigned int gg105_login__dummy10__default_value = 0u;
// gg105_login__dummy1__default_value
// file packets.pb-c.c line 1003
static const signed int gg105_login__dummy1__default_value = 4;
// gg105_login__dummy2__default_value
// file packets.pb-c.c line 1004
static const unsigned int gg105_login__dummy2__default_value = 65994615u;
// gg105_login__dummy3__default_value
// file packets.pb-c.c line 1005
static const unsigned int gg105_login__dummy3__default_value = 198164u;
// gg105_login__dummy5__default_value
// file packets.pb-c.c line 1006
static const signed int gg105_login__dummy5__default_value = 255;
// gg105_login__dummy6__default_value
// file packets.pb-c.c line 1007
static const signed int gg105_login__dummy6__default_value = 100;
// gg105_login__dummy7__default_value
// file packets.pb-c.c line 1008
static const unsigned int gg105_login__dummy7__default_value = 127u;
// gg105_login__dummy8__default_value
// file packets.pb-c.c line 1009
static const signed int gg105_login__dummy8__default_value = 0;
// gg105_login__initial_descr__default_value
// file packets.pb-c.c line 1001
char gg105_login__initial_descr__default_value[1l] = { 0 };
// gg105_login__initial_status__default_value
// file packets.pb-c.c line 1002
static const unsigned int gg105_login__initial_status__default_value = 8227u;
// gg105_login__field_descriptors
// file packets.pb-c.c line 1011
static const struct ProtobufCFieldDescriptor gg105_login__field_descriptors[16l] = { { .name="lang", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="uin", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="hash", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)48ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy1", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)96ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg105_login__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy2", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)100ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg105_login__dummy2__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy3", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)104ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg105_login__dummy3__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="client", .id=(unsigned int)7, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)64ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="initial_status", .id=(unsigned int)8, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)72ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg105_login__initial_status__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="initial_descr", .id=(unsigned int)9, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)80ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg105_login__initial_descr__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy4", .id=(unsigned int)10, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)112ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="supported_features", .id=(unsigned int)11, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)88ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy5", .id=(unsigned int)12, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)128ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg105_login__dummy5__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy6", .id=(unsigned int)13, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)132ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg105_login__dummy6__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy7", .id=(unsigned int)14, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)136ul,
    .offset=(unsigned int)140ul,
    .descriptor=(void *)0, .default_value=(const void *)&gg105_login__dummy7__default_value,
    .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy8", .id=(unsigned int)15, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)144ul,
    .offset=(unsigned int)148ul,
    .descriptor=(void *)0, .default_value=(const void *)&gg105_login__dummy8__default_value,
    .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy10", .id=(unsigned int)17, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)152ul,
    .offset=(unsigned int)156ul,
    .descriptor=(void *)0, .default_value=(const void *)&gg105_login__dummy10__default_value,
    .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg105_login__field_indices_by_name
// file packets.pb-c.c line 1206
static const unsigned int gg105_login__field_indices_by_name[16l] = { (const unsigned int)6, (const unsigned int)3, (const unsigned int)15, (const unsigned int)4, (const unsigned int)5, (const unsigned int)9, (const unsigned int)11, (const unsigned int)12, (const unsigned int)13, (const unsigned int)14, (const unsigned int)2, (const unsigned int)8, (const unsigned int)7, (const unsigned int)0, (const unsigned int)10, (const unsigned int)1 };
// gg105_login__number_ranges
// file packets.pb-c.c line 1224
static const struct ProtobufCIntRange gg105_login__number_ranges[3l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=17, .orig_index=(unsigned int)15 }, 
    { .start_value=0, .orig_index=(unsigned int)16 } };
// gg105_login__descriptor
// file packets.pb-c.c line 1230
const struct ProtobufCMessageDescriptor gg105_login__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG105Login", .short_name="GG105Login",
    .c_name="GG105Login", .package_name="",
    .sizeof_message=sizeof(struct _GG105Login) /*160ul*/ , .n_fields=(unsigned int)16,
    .fields=gg105_login__field_descriptors, .fields_sorted_by_name=gg105_login__field_indices_by_name,
    .n_field_ranges=(unsigned int)2,
    .field_ranges=gg105_login__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg105_login__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_access_info__descriptor
// file packets.pb-c.c line 2181
const struct ProtobufCMessageDescriptor gg110_access_info__descriptor;
// gg110_access_info__field_descriptors
// file packets.pb-c.c line 2106
static const struct ProtobufCFieldDescriptor gg110_access_info__field_descriptors[5l];
// gg110_access_info__dummy1__default_value
// file packets.pb-c.c line 2105
static const unsigned int gg110_access_info__dummy1__default_value = 1u;
// gg110_access_info__field_descriptors
// file packets.pb-c.c line 2106
static const struct ProtobufCFieldDescriptor gg110_access_info__field_descriptors[5l] = { { .name="dummy1", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_access_info__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy2", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)28ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="last_message", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="last_file_transfer", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)36ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="last_conference_ch", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_access_info__field_indices_by_name
// file packets.pb-c.c line 2169
static const unsigned int gg110_access_info__field_indices_by_name[5l] = { (const unsigned int)0, (const unsigned int)1, (const unsigned int)4, (const unsigned int)3, (const unsigned int)2 };
// gg110_access_info__number_ranges
// file packets.pb-c.c line 2176
static const struct ProtobufCIntRange gg110_access_info__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)5 } };
// gg110_access_info__descriptor
// file packets.pb-c.c line 2181
const struct ProtobufCMessageDescriptor gg110_access_info__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110AccessInfo", .short_name="GG110AccessInfo",
    .c_name="GG110AccessInfo", .package_name="",
    .sizeof_message=sizeof(struct _GG110AccessInfo) /*48ul*/ , .n_fields=(unsigned int)5,
    .fields=gg110_access_info__field_descriptors, .fields_sorted_by_name=gg110_access_info__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_access_info__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_access_info__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_ack__descriptor
// file packets.pb-c.c line 986
const struct ProtobufCMessageDescriptor gg110_ack__descriptor;
// gg110_ack__field_descriptors
// file packets.pb-c.c line 937
static const struct ProtobufCFieldDescriptor gg110_ack__field_descriptors[3l];
// gg110_ack__dummy1__default_value
// file packets.pb-c.c line 936
static const unsigned int gg110_ack__dummy1__default_value = 1u;
// gg110_ack__type__descriptor
// file packets.pb-c.c line 921
const struct ProtobufCEnumDescriptor gg110_ack__type__descriptor;
// gg110_ack__type__enum_values_by_name
// file packets.pb-c.c line 912
static const struct ProtobufCEnumValueIndex gg110_ack__type__enum_values_by_name[6l] = { { .name="CHAT", .index=(unsigned int)1 }, 
    { .name="CHAT_INFO", .index=(unsigned int)2 }, 
    { .name="MAGIC_NOTIFICATION", .index=(unsigned int)3 }, 
    { .name="MPA", .index=(unsigned int)4 }, 
    { .name="MSG", .index=(unsigned int)0 }, 
    { .name="TRANSFER_INFO", .index=(unsigned int)5 } };
// gg110_ack__type__enum_values_by_number
// file packets.pb-c.c line 900
static const struct ProtobufCEnumValue gg110_ack__type__enum_values_by_number[6l] = { { .name="MSG", .c_name="GG110_ACK__TYPE__MSG", .value=1 }, 
    { .name="CHAT", .c_name="GG110_ACK__TYPE__CHAT", .value=2 }, 
    { .name="CHAT_INFO", .c_name="GG110_ACK__TYPE__CHAT_INFO", .value=3 }, 
    { .name="MAGIC_NOTIFICATION", .c_name="GG110_ACK__TYPE__MAGIC_NOTIFICATION", .value=5 }, 
    { .name="MPA", .c_name="GG110_ACK__TYPE__MPA", .value=6 }, 
    { .name="TRANSFER_INFO", .c_name="GG110_ACK__TYPE__TRANSFER_INFO", .value=7 } };
// gg110_ack__type__value_ranges
// file packets.pb-c.c line 909
static const struct ProtobufCIntRange gg110_ack__type__value_ranges[3l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=5, .orig_index=(unsigned int)3 }, 
    { .start_value=0, .orig_index=(unsigned int)6 } };
// gg110_ack__type__descriptor
// file packets.pb-c.c line 921
const struct ProtobufCEnumDescriptor gg110_ack__type__descriptor = { .magic=(unsigned int)0x114315af, .name="GG110Ack.Type", .short_name="Type",
    .c_name="GG110Ack__Type", .package_name="",
    .n_values=(unsigned int)6, .values=gg110_ack__type__enum_values_by_number,
    .n_value_names=(unsigned int)6,
    .values_by_name=gg110_ack__type__enum_values_by_name, .n_value_ranges=(unsigned int)2,
    .value_ranges=gg110_ack__type__value_ranges, .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0,
    .reserved4=(void *)0 };
// gg110_ack__field_descriptors
// file packets.pb-c.c line 937
static const struct ProtobufCFieldDescriptor gg110_ack__field_descriptors[3l] = { { .name="type", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_ENUM,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(const void *)&gg110_ack__type__descriptor,
    .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="seq", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)28ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy1", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_ack__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_ack__field_indices_by_name
// file packets.pb-c.c line 976
static const unsigned int gg110_ack__field_indices_by_name[3l] = { (const unsigned int)2, (const unsigned int)1, (const unsigned int)0 };
// gg110_ack__number_ranges
// file packets.pb-c.c line 981
static const struct ProtobufCIntRange gg110_ack__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)3 } };
// gg110_ack__descriptor
// file packets.pb-c.c line 986
const struct ProtobufCMessageDescriptor gg110_ack__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110Ack", .short_name="GG110Ack",
    .c_name="GG110Ack", .package_name="",
    .sizeof_message=sizeof(struct _GG110Ack) /*40ul*/ , .n_fields=(unsigned int)3,
    .fields=gg110_ack__field_descriptors, .fields_sorted_by_name=gg110_ack__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_ack__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_ack__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_chat_info_update__descriptor
// file packets.pb-c.c line 1987
const struct ProtobufCMessageDescriptor gg110_chat_info_update__descriptor;
// gg110_chat_info_update__field_descriptors
// file packets.pb-c.c line 1846
static const struct ProtobufCFieldDescriptor gg110_chat_info_update__field_descriptors[10l] = { { .name="participant", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="inviter", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="update_type", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)56ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="time", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)60ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy1", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)64ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="version", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)68ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy2", .id=(unsigned int)7, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)72ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_id", .id=(unsigned int)9, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)80ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="chat_id", .id=(unsigned int)10, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)88ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="conv_id", .id=(unsigned int)11, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)96ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_chat_info_update__field_indices_by_name
// file packets.pb-c.c line 1969
static const unsigned int gg110_chat_info_update__field_indices_by_name[10l] = { (const unsigned int)8, (const unsigned int)9, (const unsigned int)4, (const unsigned int)6, (const unsigned int)1, (const unsigned int)7, (const unsigned int)0, (const unsigned int)3, (const unsigned int)2, (const unsigned int)5 };
// gg110_chat_info_update__number_ranges
// file packets.pb-c.c line 1981
static const struct ProtobufCIntRange gg110_chat_info_update__number_ranges[3l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=9, .orig_index=(unsigned int)7 }, 
    { .start_value=0, .orig_index=(unsigned int)10 } };
// gg110_chat_info_update__descriptor
// file packets.pb-c.c line 1987
const struct ProtobufCMessageDescriptor gg110_chat_info_update__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110ChatInfoUpdate", .short_name="GG110ChatInfoUpdate",
    .c_name="GG110ChatInfoUpdate", .package_name="",
    .sizeof_message=sizeof(struct _GG110ChatInfoUpdate) /*104ul*/ , .n_fields=(unsigned int)10,
    .fields=gg110_chat_info_update__field_descriptors, .fields_sorted_by_name=gg110_chat_info_update__field_indices_by_name,
    .n_field_ranges=(unsigned int)2,
    .field_ranges=gg110_chat_info_update__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_chat_info_update__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_event__descriptor
// file packets.pb-c.c line 1516
const struct ProtobufCMessageDescriptor gg110_event__descriptor;
// gg110_event__field_descriptors
// file packets.pb-c.c line 1441
static const struct ProtobufCFieldDescriptor gg110_event__field_descriptors[5l];
// gg110_event__type__descriptor
// file packets.pb-c.c line 1426
const struct ProtobufCEnumDescriptor gg110_event__type__descriptor;
// gg110_event__type__enum_values_by_name
// file packets.pb-c.c line 1421
static const struct ProtobufCEnumValueIndex gg110_event__type__enum_values_by_name[2l] = { { .name="JSON", .index=(unsigned int)1 }, 
    { .name="XML", .index=(unsigned int)0 } };
// gg110_event__type__enum_values_by_number
// file packets.pb-c.c line 1413
static const struct ProtobufCEnumValue gg110_event__type__enum_values_by_number[2l] = { { .name="XML", .c_name="GG110_EVENT__TYPE__XML", .value=0 }, 
    { .name="JSON", .c_name="GG110_EVENT__TYPE__JSON", .value=2 } };
// gg110_event__type__value_ranges
// file packets.pb-c.c line 1418
static const struct ProtobufCIntRange gg110_event__type__value_ranges[3l] = { { .start_value=0, .orig_index=(unsigned int)0 }, 
    { .start_value=2, .orig_index=(unsigned int)1 }, 
    { .start_value=0, .orig_index=(unsigned int)2 } };
// gg110_event__type__descriptor
// file packets.pb-c.c line 1426
const struct ProtobufCEnumDescriptor gg110_event__type__descriptor = { .magic=(unsigned int)0x114315af, .name="GG110Event.Type", .short_name="Type",
    .c_name="GG110Event__Type", .package_name="",
    .n_values=(unsigned int)2, .values=gg110_event__type__enum_values_by_number,
    .n_value_names=(unsigned int)2,
    .values_by_name=gg110_event__type__enum_values_by_name, .n_value_ranges=(unsigned int)2,
    .value_ranges=gg110_event__type__value_ranges, .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0,
    .reserved4=(void *)0 };
// gg110_event__field_descriptors
// file packets.pb-c.c line 1441
static const struct ProtobufCFieldDescriptor gg110_event__field_descriptors[5l] = { { .name="type", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_ENUM,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(const void *)&gg110_event__type__descriptor,
    .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="seq", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)28ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="data", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="subtype", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="id", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT64,
    .quantifier_offset=(unsigned int)48ul,
    .offset=(unsigned int)56ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 } };
// gg110_event__field_indices_by_name
// file packets.pb-c.c line 1504
static const unsigned int gg110_event__field_indices_by_name[5l] = { (const unsigned int)2, (const unsigned int)4, (const unsigned int)1, (const unsigned int)3, (const unsigned int)0 };
// gg110_event__number_ranges
// file packets.pb-c.c line 1511
static const struct ProtobufCIntRange gg110_event__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)5 } };
// gg110_event__descriptor
// file packets.pb-c.c line 1516
const struct ProtobufCMessageDescriptor gg110_event__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110Event", .short_name="GG110Event",
    .c_name="GG110Event", .package_name="",
    .sizeof_message=sizeof(struct _GG110Event) /*64ul*/ , .n_fields=(unsigned int)5,
    .fields=gg110_event__field_descriptors, .fields_sorted_by_name=gg110_event__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_event__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_event__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_imtoken__descriptor
// file packets.pb-c.c line 1831
const struct ProtobufCMessageDescriptor gg110_imtoken__descriptor;
// gg110_imtoken__field_descriptors
// file packets.pb-c.c line 1808
static const struct ProtobufCFieldDescriptor gg110_imtoken__field_descriptors[1l] = { { .name="imtoken", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_imtoken__field_indices_by_name
// file packets.pb-c.c line 1823
static const unsigned int gg110_imtoken__field_indices_by_name[1l] = { (const unsigned int)0 };
// gg110_imtoken__number_ranges
// file packets.pb-c.c line 1826
static const struct ProtobufCIntRange gg110_imtoken__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)1 } };
// gg110_imtoken__descriptor
// file packets.pb-c.c line 1831
const struct ProtobufCMessageDescriptor gg110_imtoken__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110Imtoken", .short_name="GG110Imtoken",
    .c_name="GG110Imtoken", .package_name="",
    .sizeof_message=sizeof(struct _GG110Imtoken) /*32ul*/ , .n_fields=(unsigned int)1,
    .fields=gg110_imtoken__field_descriptors, .fields_sorted_by_name=gg110_imtoken__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_imtoken__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_imtoken__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_login_ok__descriptor
// file packets.pb-c.c line 847
const struct ProtobufCMessageDescriptor gg110_login_ok__descriptor;
// gg110_login_ok__field_descriptors
// file packets.pb-c.c line 785
static const struct ProtobufCFieldDescriptor gg110_login_ok__field_descriptors[4l];
// gg110_login_ok__dummy1__default_value
// file packets.pb-c.c line 784
static const signed int gg110_login_ok__dummy1__default_value = 1;
// gg110_login_ok__field_descriptors
// file packets.pb-c.c line 785
static const struct ProtobufCFieldDescriptor gg110_login_ok__field_descriptors[4l] = { { .name="dummy1", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_login_ok__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummyhash", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="uin", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="server_time", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)44ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_login_ok__field_indices_by_name
// file packets.pb-c.c line 836
static const unsigned int gg110_login_ok__field_indices_by_name[4l] = { (const unsigned int)0, (const unsigned int)1, (const unsigned int)3, (const unsigned int)2 };
// gg110_login_ok__number_ranges
// file packets.pb-c.c line 842
static const struct ProtobufCIntRange gg110_login_ok__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)4 } };
// gg110_login_ok__descriptor
// file packets.pb-c.c line 847
const struct ProtobufCMessageDescriptor gg110_login_ok__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110LoginOK", .short_name="GG110LoginOK",
    .c_name="GG110LoginOK", .package_name="",
    .sizeof_message=sizeof(struct _GG110LoginOK) /*48ul*/ , .n_fields=(unsigned int)4,
    .fields=gg110_login_ok__field_descriptors, .fields_sorted_by_name=gg110_login_ok__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_login_ok__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_login_ok__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_magic_notification__descriptor
// file packets.pb-c.c line 2589
const struct ProtobufCMessageDescriptor gg110_magic_notification__descriptor;
// gg110_magic_notification__field_descriptors
// file packets.pb-c.c line 2501
static const struct ProtobufCFieldDescriptor gg110_magic_notification__field_descriptors[6l];
// gg110_magic_notification__dummy1__default_value
// file packets.pb-c.c line 2498
static const signed int gg110_magic_notification__dummy1__default_value = 2;
// gg110_magic_notification__dummy2__default_value
// file packets.pb-c.c line 2499
static const signed int gg110_magic_notification__dummy2__default_value = 1;
// gg110_magic_notification__dummy3__default_value
// file packets.pb-c.c line 2500
static const signed int gg110_magic_notification__dummy3__default_value = 1;
// gg110_magic_notification__dummy4__default_value
// file packets.pb-c.c line 2497
char gg110_magic_notification__dummy4__default_value[1l] = { 0 };
// gg110_magic_notification__field_descriptors
// file packets.pb-c.c line 2501
static const struct ProtobufCFieldDescriptor gg110_magic_notification__field_descriptors[6l] = { { .name="dummy1", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_magic_notification__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="seq", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)28ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy2", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_magic_notification__dummy2__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy3", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_INT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)36ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_magic_notification__dummy3__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="uin", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy4", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)56ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_magic_notification__dummy4__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_magic_notification__field_indices_by_name
// file packets.pb-c.c line 2576
static const unsigned int gg110_magic_notification__field_indices_by_name[6l] = { (const unsigned int)0, (const unsigned int)2, (const unsigned int)3, (const unsigned int)5, (const unsigned int)1, (const unsigned int)4 };
// gg110_magic_notification__number_ranges
// file packets.pb-c.c line 2584
static const struct ProtobufCIntRange gg110_magic_notification__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)6 } };
// gg110_magic_notification__descriptor
// file packets.pb-c.c line 2589
const struct ProtobufCMessageDescriptor gg110_magic_notification__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110MagicNotification", .short_name="GG110MagicNotification",
    .c_name="GG110MagicNotification",
    .package_name="", .sizeof_message=sizeof(struct _GG110MagicNotification) /*64ul*/ ,
    .n_fields=(unsigned int)6,
    .fields=gg110_magic_notification__field_descriptors, .fields_sorted_by_name=gg110_magic_notification__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_magic_notification__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_magic_notification__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_message_ack__descriptor
// file packets.pb-c.c line 1398
const struct ProtobufCMessageDescriptor gg110_message_ack__descriptor;
// gg110_message_ack__field_descriptors
// file packets.pb-c.c line 1297
static const struct ProtobufCFieldDescriptor gg110_message_ack__field_descriptors[7l];
// gg110_message_ack__dummy1__default_value
// file packets.pb-c.c line 1296
static const unsigned int gg110_message_ack__dummy1__default_value = 0u;
// gg110_message_ack_link__descriptor
// file packets.pb-c.c line 1281
const struct ProtobufCMessageDescriptor gg110_message_ack_link__descriptor;
// gg110_message_ack_link__field_descriptors
// file packets.pb-c.c line 1245
static const struct ProtobufCFieldDescriptor gg110_message_ack_link__field_descriptors[2l] = { { .name="id", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="url", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_message_ack_link__field_indices_by_name
// file packets.pb-c.c line 1272
static const unsigned int gg110_message_ack_link__field_indices_by_name[2l] = { (const unsigned int)0, (const unsigned int)1 };
// gg110_message_ack_link__number_ranges
// file packets.pb-c.c line 1276
static const struct ProtobufCIntRange gg110_message_ack_link__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)2 } };
// gg110_message_ack_link__descriptor
// file packets.pb-c.c line 1281
const struct ProtobufCMessageDescriptor gg110_message_ack_link__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110MessageAckLink", .short_name="GG110MessageAckLink",
    .c_name="GG110MessageAckLink", .package_name="",
    .sizeof_message=sizeof(struct _GG110MessageAckLink) /*40ul*/ , .n_fields=(unsigned int)2,
    .fields=gg110_message_ack_link__field_descriptors, .fields_sorted_by_name=gg110_message_ack_link__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_message_ack_link__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_message_ack_link__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_message_ack__field_descriptors
// file packets.pb-c.c line 1297
static const struct ProtobufCFieldDescriptor gg110_message_ack__field_descriptors[7l] = { { .name="msg_type", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="seq", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)28ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="time", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_id", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)36ul,
    .offset=(unsigned int)40ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="conv_id", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)48ul,
    .offset=(unsigned int)56ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="links", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_REPEATED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_MESSAGE,
    .quantifier_offset=(unsigned int)64ul,
    .offset=(unsigned int)72ul,
    .descriptor=(const void *)&gg110_message_ack_link__descriptor, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="dummy1", .id=(unsigned int)7, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)80ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_message_ack__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_message_ack__field_indices_by_name
// file packets.pb-c.c line 1384
static const unsigned int gg110_message_ack__field_indices_by_name[7l] = { (const unsigned int)4, (const unsigned int)6, (const unsigned int)5, (const unsigned int)3, (const unsigned int)0, (const unsigned int)1, (const unsigned int)2 };
// gg110_message_ack__number_ranges
// file packets.pb-c.c line 1393
static const struct ProtobufCIntRange gg110_message_ack__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)7 } };
// gg110_message_ack__descriptor
// file packets.pb-c.c line 1398
const struct ProtobufCMessageDescriptor gg110_message_ack__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110MessageAck", .short_name="GG110MessageAck",
    .c_name="GG110MessageAck", .package_name="",
    .sizeof_message=sizeof(struct _GG110MessageAck) /*88ul*/ , .n_fields=(unsigned int)7,
    .fields=gg110_message_ack__field_descriptors, .fields_sorted_by_name=gg110_message_ack__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_message_ack__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_message_ack__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_options__descriptor
// file packets.pb-c.c line 2090
const struct ProtobufCMessageDescriptor gg110_options__descriptor;
// gg110_options__field_descriptors
// file packets.pb-c.c line 2054
static const struct ProtobufCFieldDescriptor gg110_options__field_descriptors[2l];
// gg110_options__dummy1__default_value
// file packets.pb-c.c line 2053
static const unsigned int gg110_options__dummy1__default_value = 0u;
// protobuf_kvp__descriptor
// file packets.pb-c.c line 2038
const struct ProtobufCMessageDescriptor protobuf_kvp__descriptor;
// protobuf_kvp__field_descriptors
// file packets.pb-c.c line 2002
static const struct ProtobufCFieldDescriptor protobuf_kvp__field_descriptors[2l] = { { .name="key", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="value", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// protobuf_kvp__field_indices_by_name
// file packets.pb-c.c line 2029
static const unsigned int protobuf_kvp__field_indices_by_name[2l] = { (const unsigned int)0, (const unsigned int)1 };
// protobuf_kvp__number_ranges
// file packets.pb-c.c line 2033
static const struct ProtobufCIntRange protobuf_kvp__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)2 } };
// protobuf_kvp__descriptor
// file packets.pb-c.c line 2038
const struct ProtobufCMessageDescriptor protobuf_kvp__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="ProtobufKVP", .short_name="ProtobufKVP",
    .c_name="ProtobufKVP", .package_name="",
    .sizeof_message=sizeof(struct _ProtobufKVP) /*40ul*/ , .n_fields=(unsigned int)2,
    .fields=protobuf_kvp__field_descriptors, .fields_sorted_by_name=protobuf_kvp__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=protobuf_kvp__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))protobuf_kvp__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_options__field_descriptors
// file packets.pb-c.c line 2054
static const struct ProtobufCFieldDescriptor gg110_options__field_descriptors[2l] = { { .name="options", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REPEATED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_MESSAGE,
    .quantifier_offset=(unsigned int)24ul,
    .offset=(unsigned int)32ul,
    .descriptor=(const void *)&protobuf_kvp__descriptor, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="dummy1", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_options__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_options__field_indices_by_name
// file packets.pb-c.c line 2081
static const unsigned int gg110_options__field_indices_by_name[2l] = { (const unsigned int)1, (const unsigned int)0 };
// gg110_options__number_ranges
// file packets.pb-c.c line 2085
static const struct ProtobufCIntRange gg110_options__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)2 } };
// gg110_options__descriptor
// file packets.pb-c.c line 2090
const struct ProtobufCMessageDescriptor gg110_options__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110Options", .short_name="GG110Options",
    .c_name="GG110Options", .package_name="",
    .sizeof_message=sizeof(struct _GG110Options) /*48ul*/ , .n_fields=(unsigned int)2,
    .fields=gg110_options__field_descriptors, .fields_sorted_by_name=gg110_options__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_options__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_options__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_pong__descriptor
// file packets.pb-c.c line 885
const struct ProtobufCMessageDescriptor gg110_pong__descriptor;
// gg110_pong__field_descriptors
// file packets.pb-c.c line 862
static const struct ProtobufCFieldDescriptor gg110_pong__field_descriptors[1l] = { { .name="server_time", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg110_pong__field_indices_by_name
// file packets.pb-c.c line 877
static const unsigned int gg110_pong__field_indices_by_name[1l] = { (const unsigned int)0 };
// gg110_pong__number_ranges
// file packets.pb-c.c line 880
static const struct ProtobufCIntRange gg110_pong__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)1 } };
// gg110_pong__descriptor
// file packets.pb-c.c line 885
const struct ProtobufCMessageDescriptor gg110_pong__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110Pong", .short_name="GG110Pong",
    .c_name="GG110Pong", .package_name="",
    .sizeof_message=sizeof(struct _GG110Pong) /*32ul*/ , .n_fields=(unsigned int)1,
    .fields=gg110_pong__field_descriptors, .fields_sorted_by_name=gg110_pong__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg110_pong__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_pong__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_recv_message__descriptor
// file packets.pb-c.c line 1673
const struct ProtobufCMessageDescriptor gg110_recv_message__descriptor;
// gg110_recv_message__field_descriptors
// file packets.pb-c.c line 1532
static const struct ProtobufCFieldDescriptor gg110_recv_message__field_descriptors[10l];
// gg110_recv_message__msg_plain__default_value
// file packets.pb-c.c line 1531
char gg110_recv_message__msg_plain__default_value[1l] = { 0 };
// gg110_recv_message__field_descriptors
// file packets.pb-c.c line 1532
static const struct ProtobufCFieldDescriptor gg110_recv_message__field_descriptors[10l] = { { .name="sender", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)24ul,
    .offset=(unsigned int)32ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="flags", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)48ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="seq", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)52ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="time", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)56ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_plain", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)64ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_recv_message__msg_plain__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_xhtml", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)72ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="data", .id=(unsigned int)7, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)80ul,
    .offset=(unsigned int)88ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="msg_id", .id=(unsigned int)9, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)104ul,
    .offset=(unsigned int)112ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="chat_id", .id=(unsigned int)10, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)120ul,
    .offset=(unsigned int)128ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="conv_id", .id=(unsigned int)11, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)136ul,
    .offset=(unsigned int)144ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 } };
// gg110_recv_message__field_indices_by_name
// file packets.pb-c.c line 1655
static const unsigned int gg110_recv_message__field_indices_by_name[10l] = { (const unsigned int)8, (const unsigned int)9, (const unsigned int)6, (const unsigned int)1, (const unsigned int)7, (const unsigned int)4, (const unsigned int)5, (const unsigned int)0, (const unsigned int)2, (const unsigned int)3 };
// gg110_recv_message__number_ranges
// file packets.pb-c.c line 1667
static const struct ProtobufCIntRange gg110_recv_message__number_ranges[3l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=9, .orig_index=(unsigned int)7 }, 
    { .start_value=0, .orig_index=(unsigned int)10 } };
// gg110_recv_message__descriptor
// file packets.pb-c.c line 1673
const struct ProtobufCMessageDescriptor gg110_recv_message__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110RecvMessage", .short_name="GG110RecvMessage",
    .c_name="GG110RecvMessage", .package_name="",
    .sizeof_message=sizeof(struct _GG110RecvMessage) /*152ul*/ , .n_fields=(unsigned int)10,
    .fields=gg110_recv_message__field_descriptors, .fields_sorted_by_name=gg110_recv_message__field_indices_by_name,
    .n_field_ranges=(unsigned int)2,
    .field_ranges=gg110_recv_message__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_recv_message__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg110_send_message__descriptor
// file packets.pb-c.c line 1793
const struct ProtobufCMessageDescriptor gg110_send_message__descriptor;
// gg110_send_message__field_descriptors
// file packets.pb-c.c line 1690
static const struct ProtobufCFieldDescriptor gg110_send_message__field_descriptors[7l];
// gg110_send_message__dummy1__default_value
// file packets.pb-c.c line 1689
static const unsigned int gg110_send_message__dummy1__default_value = 8u;
// gg110_send_message__dummy3__default_value
// file packets.pb-c.c line 1688
char gg110_send_message__dummy3__default_value[1l] = { 0 };
// gg110_send_message__field_descriptors
// file packets.pb-c.c line 1690
static const struct ProtobufCFieldDescriptor gg110_send_message__field_descriptors[7l] = { { .name="recipient", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)24ul,
    .offset=(unsigned int)32ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="dummy1", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)48ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_send_message__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="seq", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)52ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_plain", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)56ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_xhtml", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)64ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="dummy3", .id=(unsigned int)7, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)72ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg110_send_message__dummy3__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="chat_id", .id=(unsigned int)10, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)80ul,
    .offset=(unsigned int)88ul,
    .descriptor=(void *)0, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 } };
// gg110_send_message__field_indices_by_name
// file packets.pb-c.c line 1777
static const unsigned int gg110_send_message__field_indices_by_name[7l] = { (const unsigned int)6, (const unsigned int)1, (const unsigned int)5, (const unsigned int)3, (const unsigned int)4, (const unsigned int)0, (const unsigned int)2 };
// gg110_send_message__number_ranges
// file packets.pb-c.c line 1786
static const struct ProtobufCIntRange gg110_send_message__number_ranges[4l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=5, .orig_index=(unsigned int)3 }, 
    { .start_value=10, .orig_index=(unsigned int)6 }, 
    { .start_value=0, .orig_index=(unsigned int)7 } };
// gg110_send_message__descriptor
// file packets.pb-c.c line 1793
const struct ProtobufCMessageDescriptor gg110_send_message__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG110SendMessage", .short_name="GG110SendMessage",
    .c_name="GG110SendMessage", .package_name="",
    .sizeof_message=sizeof(struct _GG110SendMessage) /*96ul*/ , .n_fields=(unsigned int)7,
    .fields=gg110_send_message__field_descriptors, .fields_sorted_by_name=gg110_send_message__field_indices_by_name,
    .n_field_ranges=(unsigned int)3,
    .field_ranges=gg110_send_message__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg110_send_message__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg112_transfer_info__descriptor
// file packets.pb-c.c line 2482
const struct ProtobufCMessageDescriptor gg112_transfer_info__descriptor;
// gg112_transfer_info__field_descriptors
// file packets.pb-c.c line 2354
static const struct ProtobufCFieldDescriptor gg112_transfer_info__field_descriptors[9l];
// gg112_transfer_info_file__descriptor
// file packets.pb-c.c line 2339
const struct ProtobufCMessageDescriptor gg112_transfer_info_file__descriptor;
// gg112_transfer_info_file__field_descriptors
// file packets.pb-c.c line 2249
static const struct ProtobufCFieldDescriptor gg112_transfer_info_file__field_descriptors[6l];
// gg112_transfer_info_file__type__default_value
// file packets.pb-c.c line 2248
char gg112_transfer_info_file__type__default_value[6l] = { 'o', 't', 'h', 'e', 'r', 0 };
// gg112_transfer_info_file__field_descriptors
// file packets.pb-c.c line 2249
static const struct ProtobufCFieldDescriptor gg112_transfer_info_file__field_descriptors[6l] = { { .name="type", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg112_transfer_info_file__type__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="url", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="content_type", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="filename", .id=(unsigned int)7, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_STRING,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)48ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="filesize", .id=(unsigned int)8, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)56ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_id", .id=(unsigned int)1001, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)64ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg112_transfer_info_file__field_indices_by_name
// file packets.pb-c.c line 2324
static const unsigned int gg112_transfer_info_file__field_indices_by_name[6l] = { (const unsigned int)2, (const unsigned int)3, (const unsigned int)4, (const unsigned int)5, (const unsigned int)0, (const unsigned int)1 };
// gg112_transfer_info_file__number_ranges
// file packets.pb-c.c line 2332
static const struct ProtobufCIntRange gg112_transfer_info_file__number_ranges[4l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=6, .orig_index=(unsigned int)2 }, 
    { .start_value=1001, .orig_index=(unsigned int)5 }, 
    { .start_value=0, .orig_index=(unsigned int)6 } };
// gg112_transfer_info_file__descriptor
// file packets.pb-c.c line 2339
const struct ProtobufCMessageDescriptor gg112_transfer_info_file__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG112TransferInfoFile", .short_name="GG112TransferInfoFile",
    .c_name="GG112TransferInfoFile",
    .package_name="", .sizeof_message=sizeof(struct _GG112TransferInfoFile) /*72ul*/ ,
    .n_fields=(unsigned int)6,
    .fields=gg112_transfer_info_file__field_descriptors, .fields_sorted_by_name=gg112_transfer_info_file__field_indices_by_name,
    .n_field_ranges=(unsigned int)3,
    .field_ranges=gg112_transfer_info_file__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg112_transfer_info_file__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg112_transfer_info_uin__descriptor
// file packets.pb-c.c line 2233
const struct ProtobufCMessageDescriptor gg112_transfer_info_uin__descriptor;
// gg112_transfer_info_uin__field_descriptors
// file packets.pb-c.c line 2197
static const struct ProtobufCFieldDescriptor gg112_transfer_info_uin__field_descriptors[2l];
// gg112_transfer_info_uin__dummy1__default_value
// file packets.pb-c.c line 2196
static const unsigned int gg112_transfer_info_uin__dummy1__default_value = 1u;
// gg112_transfer_info_uin__field_descriptors
// file packets.pb-c.c line 2197
static const struct ProtobufCFieldDescriptor gg112_transfer_info_uin__field_descriptors[2l] = { { .name="dummy1", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(const void *)&gg112_transfer_info_uin__dummy1__default_value, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="uin", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_BYTES,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg112_transfer_info_uin__field_indices_by_name
// file packets.pb-c.c line 2224
static const unsigned int gg112_transfer_info_uin__field_indices_by_name[2l] = { (const unsigned int)0, (const unsigned int)1 };
// gg112_transfer_info_uin__number_ranges
// file packets.pb-c.c line 2228
static const struct ProtobufCIntRange gg112_transfer_info_uin__number_ranges[2l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=0, .orig_index=(unsigned int)2 } };
// gg112_transfer_info_uin__descriptor
// file packets.pb-c.c line 2233
const struct ProtobufCMessageDescriptor gg112_transfer_info_uin__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG112TransferInfoUin", .short_name="GG112TransferInfoUin",
    .c_name="GG112TransferInfoUin", .package_name="",
    .sizeof_message=sizeof(struct _GG112TransferInfoUin) /*48ul*/ , .n_fields=(unsigned int)2,
    .fields=gg112_transfer_info_uin__field_descriptors, .fields_sorted_by_name=gg112_transfer_info_uin__field_indices_by_name,
    .n_field_ranges=(unsigned int)1,
    .field_ranges=gg112_transfer_info_uin__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg112_transfer_info_uin__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg112_transfer_info__field_descriptors
// file packets.pb-c.c line 2354
static const struct ProtobufCFieldDescriptor gg112_transfer_info__field_descriptors[9l] = { { .name="dummy1", .id=(unsigned int)1, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)24ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="peer", .id=(unsigned int)2, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_MESSAGE,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)32ul, .descriptor=(const void *)&gg112_transfer_info_uin__descriptor,
    .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="time", .id=(unsigned int)3, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)48ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="sender", .id=(unsigned int)4, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_MESSAGE,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)40ul, .descriptor=(const void *)&gg112_transfer_info_uin__descriptor,
    .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="data", .id=(unsigned int)5, .label=(enum anonymous)PROTOBUF_C_LABEL_REPEATED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_MESSAGE,
    .quantifier_offset=(unsigned int)56ul,
    .offset=(unsigned int)64ul,
    .descriptor=(const void *)&protobuf_kvp__descriptor, .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="file", .id=(unsigned int)6, .label=(enum anonymous)PROTOBUF_C_LABEL_OPTIONAL, .type=(enum anonymous$0)PROTOBUF_C_TYPE_MESSAGE,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)72ul, .descriptor=(const void *)&gg112_transfer_info_file__descriptor,
    .default_value=(void *)0,
    .flags=(unsigned int)0, .reserved_flags=(unsigned int)0,
    .reserved2=(void *)0, .reserved3=(void *)0 }, 
    { .name="seq", .id=(unsigned int)7, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED, .type=(enum anonymous$0)PROTOBUF_C_TYPE_UINT32,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)80ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="msg_id", .id=(unsigned int)1001, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)88ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 }, 
    { .name="conv_id", .id=(unsigned int)1002, .label=(enum anonymous)PROTOBUF_C_LABEL_REQUIRED,
    .type=(enum anonymous$0)PROTOBUF_C_TYPE_FIXED64,
    .quantifier_offset=(unsigned int)0,
    .offset=(unsigned int)96ul, .descriptor=(void *)0,
    .default_value=(void *)0, .flags=(unsigned int)0,
    .reserved_flags=(unsigned int)0, .reserved2=(void *)0,
    .reserved3=(void *)0 } };
// gg112_transfer_info__field_indices_by_name
// file packets.pb-c.c line 2465
static const unsigned int gg112_transfer_info__field_indices_by_name[9l] = { (const unsigned int)8, (const unsigned int)4, (const unsigned int)0, (const unsigned int)5, (const unsigned int)7, (const unsigned int)1, (const unsigned int)3, (const unsigned int)6, (const unsigned int)2 };
// gg112_transfer_info__number_ranges
// file packets.pb-c.c line 2476
static const struct ProtobufCIntRange gg112_transfer_info__number_ranges[3l] = { { .start_value=1, .orig_index=(unsigned int)0 }, 
    { .start_value=1001, .orig_index=(unsigned int)7 }, 
    { .start_value=0, .orig_index=(unsigned int)9 } };
// gg112_transfer_info__descriptor
// file packets.pb-c.c line 2482
const struct ProtobufCMessageDescriptor gg112_transfer_info__descriptor = { .magic=(unsigned int)0x28aaeef9, .name="GG112TransferInfo", .short_name="GG112TransferInfo",
    .c_name="GG112TransferInfo", .package_name="",
    .sizeof_message=sizeof(struct _GG112TransferInfo) /*104ul*/ , .n_fields=(unsigned int)9,
    .fields=gg112_transfer_info__field_descriptors, .fields_sorted_by_name=gg112_transfer_info__field_indices_by_name,
    .n_field_ranges=(unsigned int)2,
    .field_ranges=gg112_transfer_info__number_ranges, .message_init=(void (*)(struct ProtobufCMessage *))gg112_transfer_info__init,
    .reserved1=(void *)0,
    .reserved2=(void *)0, .reserved3=(void *)0 };
// gg_base64_charset
// file common.c line 441
static char gg_base64_charset[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// gg_crc32_table
// file common.c line 611
static const unsigned int gg_crc32_table[256l] = { (const unsigned int)0x00000000, (const unsigned int)0x77073096, 0xee0e612c, 0x990951ba, (const unsigned int)0x076dc419, (const unsigned int)0x706af48f, 0xe963a535, 0x9e6495a3, (const unsigned int)0x0edb8832, (const unsigned int)0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, (const unsigned int)0x09b64c2b, (const unsigned int)0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, (const unsigned int)0x1db71064, (const unsigned int)0x6ab020f2, 0xf3b97148, 0x84be41de, (const unsigned int)0x1adad47d, (const unsigned int)0x6ddde4eb, 0xf4d4b551, 0x83d385c7, (const unsigned int)0x136c9856, (const unsigned int)0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, (const unsigned int)0x14015c4f, (const unsigned int)0x63066cd9, 0xfa0f3d63, 0x8d080df5, (const unsigned int)0x3b6e20c8, (const unsigned int)0x4c69105e, 0xd56041e4, 0xa2677172, (const unsigned int)0x3c03e4d1, (const unsigned int)0x4b04d447, 0xd20d85fd, 0xa50ab56b, (const unsigned int)0x35b5a8fa, (const unsigned int)0x42b2986c, 0xdbbbc9d6, 0xacbcf940, (const unsigned int)0x32d86ce3, (const unsigned int)0x45df5c75, 0xdcd60dcf, 0xabd13d59, (const unsigned int)0x26d930ac, (const unsigned int)0x51de003a, 0xc8d75180, 0xbfd06116, (const unsigned int)0x21b4f4b5, (const unsigned int)0x56b3c423, 0xcfba9599, 0xb8bda50f, (const unsigned int)0x2802b89e, (const unsigned int)0x5f058808, 0xc60cd9b2, 0xb10be924, (const unsigned int)0x2f6f7c87, (const unsigned int)0x58684c11, 0xc1611dab, 0xb6662d3d, (const unsigned int)0x76dc4190, (const unsigned int)0x01db7106, 0x98d220bc, 0xefd5102a, (const unsigned int)0x71b18589, (const unsigned int)0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, (const unsigned int)0x7807c9a2, (const unsigned int)0x0f00f934, 0x9609a88e, 0xe10e9818, (const unsigned int)0x7f6a0dbb, (const unsigned int)0x086d3d2d, 0x91646c97, 0xe6635c01, (const unsigned int)0x6b6b51f4, (const unsigned int)0x1c6c6162, 0x856530d8, 0xf262004e, (const unsigned int)0x6c0695ed, (const unsigned int)0x1b01a57b, 0x8208f4c1, 0xf50fc457, (const unsigned int)0x65b0d9c6, (const unsigned int)0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, (const unsigned int)0x62dd1ddf, (const unsigned int)0x15da2d49, 0x8cd37cf3, 0xfbd44c65, (const unsigned int)0x4db26158, (const unsigned int)0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, (const unsigned int)0x4adfa541, (const unsigned int)0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, (const unsigned int)0x4369e96a, (const unsigned int)0x346ed9fc, 0xad678846, 0xda60b8d0, (const unsigned int)0x44042d73, (const unsigned int)0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, (const unsigned int)0x5005713c, (const unsigned int)0x270241aa, 0xbe0b1010, 0xc90c2086, (const unsigned int)0x5768b525, (const unsigned int)0x206f85b3, 0xb966d409, 0xce61e49f, (const unsigned int)0x5edef90e, (const unsigned int)0x29d9c998, 0xb0d09822, 0xc7d7a8b4, (const unsigned int)0x59b33d17, (const unsigned int)0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, (const unsigned int)0x03b6e20c, (const unsigned int)0x74b1d29a, 0xead54739, 0x9dd277af, (const unsigned int)0x04db2615, (const unsigned int)0x73dc1683, 0xe3630b12, 0x94643b84, (const unsigned int)0x0d6d6a3e, (const unsigned int)0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, (const unsigned int)0x0a00ae27, (const unsigned int)0x7d079eb1, 0xf00f9344, 0x8708a3d2, (const unsigned int)0x1e01f268, (const unsigned int)0x6906c2fe, 0xf762575d, 0x806567cb, (const unsigned int)0x196c3671, (const unsigned int)0x6e6b06e7, 0xfed41b76, 0x89d32be0, (const unsigned int)0x10da7a5a, (const unsigned int)0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, (const unsigned int)0x17b7be43, (const unsigned int)0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, (const unsigned int)0x38d8c2c4, (const unsigned int)0x4fdff252, 0xd1bb67f1, 0xa6bc5767, (const unsigned int)0x3fb506dd, (const unsigned int)0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, (const unsigned int)0x36034af6, (const unsigned int)0x41047a60, 0xdf60efc3, 0xa867df55, (const unsigned int)0x316e8eef, (const unsigned int)0x4669be79, 0xcb61b38c, 0xbc66831a, (const unsigned int)0x256fd2a0, (const unsigned int)0x5268e236, 0xcc0c7795, 0xbb0b4703, (const unsigned int)0x220216b9, (const unsigned int)0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, (const unsigned int)0x2bb45a92, (const unsigned int)0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, (const unsigned int)0x2cd99e8b, (const unsigned int)0x5bdeae1d, 0x9b64c2b0, 0xec63f226, (const unsigned int)0x756aa39c, (const unsigned int)0x026d930a, 0x9c0906a9, 0xeb0e363f, (const unsigned int)0x72076785, (const unsigned int)0x05005713, 0x95bf4a82, 0xe2b87a14, (const unsigned int)0x7bb12bae, (const unsigned int)0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, (const unsigned int)0x7cdcefb7, (const unsigned int)0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, (const unsigned int)0x68ddb3f8, (const unsigned int)0x1fda836e, 0x81be16cd, 0xf6b9265b, (const unsigned int)0x6fb077e1, (const unsigned int)0x18b74777, 0x88085ae6, 0xff0f6a70, (const unsigned int)0x66063bca, (const unsigned int)0x11010b5c, 0x8f659eff, 0xf862ae69, (const unsigned int)0x616bffd3, (const unsigned int)0x166ccf45, 0xa00ae278, 0xd70dd2ee, (const unsigned int)0x4e048354, (const unsigned int)0x3903b3c2, 0xa7672661, 0xd06016f7, (const unsigned int)0x4969474d, (const unsigned int)0x3e6e77db, 0xaed16a4a, 0xd9d65adc, (const unsigned int)0x40df0b66, (const unsigned int)0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, (const unsigned int)0x47b2cf7f, (const unsigned int)0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, (const unsigned int)0x53b39330, (const unsigned int)0x24b4a3a6, 0xbad03605, 0xcdd70693, (const unsigned int)0x54de5729, (const unsigned int)0x23d967bf, 0xb3667a2e, 0xc4614ab8, (const unsigned int)0x5d681b02, (const unsigned int)0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, (const unsigned int)0x5a05df1b, (const unsigned int)0x2d02ef8d };
// gg_dcc_ip
// file libgadu.c line 73
unsigned long int gg_dcc_ip = (unsigned long int)0;
// gg_dcc_port
// file libgadu.c line 66
signed int gg_dcc_port = 0;
// gg_debug_file
// file debug.c line 86
struct _IO_FILE *gg_debug_file = (struct _IO_FILE *)(void *)0;
// gg_debug_handler
// file debug.c line 58
void (*gg_debug_handler)(signed int, const char *, void **) = (void (*)(signed int, const char *, void **))(void *)0;
// gg_debug_handler_session
// file debug.c line 74
void (*gg_debug_handler_session)(struct gg_session *, signed int, const char *, void **) = (void (*)(struct gg_session *, signed int, const char *, void **))(void *)0;
// gg_debug_level
// file debug.c line 43
signed int gg_debug_level = 0;
// gg_global_resolver_cleanup
// file resolver.c line 52
static void (*gg_global_resolver_cleanup)(void **, signed int);
// gg_global_resolver_start
// file resolver.c line 49
static signed int (*gg_global_resolver_start)(signed int *, void **, const char *);
// gg_global_resolver_type
// file resolver.c line 46
static enum anonymous$4 gg_global_resolver_type = (enum anonymous$4)GG_RESOLVER_DEFAULT;
// gg_local_ip
// file libgadu.c line 80
unsigned long int gg_local_ip = (unsigned long int)0;
// gg_proxy_enabled
// file libgadu.c line 87
signed int gg_proxy_enabled = 0;
// gg_proxy_host
// file libgadu.c line 94
char *gg_proxy_host = (char *)(void *)0;
// gg_proxy_http_only
// file libgadu.c line 108
signed int gg_proxy_http_only = 0;
// gg_proxy_password
// file libgadu.c line 122
char *gg_proxy_password = (char *)(void *)0;
// gg_proxy_port
// file libgadu.c line 101
signed int gg_proxy_port = 0;
// gg_proxy_username
// file libgadu.c line 115
char *gg_proxy_username = (char *)(void *)0;
// gnutls_initialized
// file connect.c line 132
static _Bool gnutls_initialized;
// h_errno
// file connect.c line 297
static signed int h_errno;
// handlers
// file events.c line 1692
static const struct anonymous$26 handlers[35l];
// handlers
// file events.c line 1692
static const struct anonymous$26 handlers[35l] = { { .state=(enum gg_state_t)54, .handler=gg_handle_resolve_sync, .next_state=(enum gg_state_t)48,
    .alt_state=(enum gg_state_t)65, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)60, .handler=gg_handle_resolve_sync, .next_state=(enum gg_state_t)50,
    .alt_state=(enum gg_state_t)7, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)56, .handler=gg_handle_resolve_sync, .next_state=(enum gg_state_t)49,
    .alt_state=(enum gg_state_t)66, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)58, .handler=gg_handle_resolve_sync, .next_state=(enum gg_state_t)51,
    .alt_state=(enum gg_state_t)67, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)55, .handler=gg_handle_resolve_async, .next_state=(enum gg_state_t)62,
    .alt_state=(enum gg_state_t)65, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)61, .handler=gg_handle_resolve_async, .next_state=(enum gg_state_t)43,
    .alt_state=(enum gg_state_t)7, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)57, .handler=gg_handle_resolve_async, .next_state=(enum gg_state_t)63,
    .alt_state=(enum gg_state_t)66, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)59, .handler=gg_handle_resolve_async, .next_state=(enum gg_state_t)64,
    .alt_state=(enum gg_state_t)67, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)62, .handler=gg_handle_resolving, .next_state=(enum gg_state_t)48,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)43, .handler=gg_handle_resolving, .next_state=(enum gg_state_t)50,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)63, .handler=gg_handle_resolving, .next_state=(enum gg_state_t)49,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)64, .handler=gg_handle_resolving, .next_state=(enum gg_state_t)51,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)48, .handler=gg_handle_connect, .next_state=(enum gg_state_t)5,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)49, .handler=gg_handle_connect, .next_state=(enum gg_state_t)52,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)51, .handler=gg_handle_connect, .next_state=(enum gg_state_t)53,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)50, .handler=gg_handle_connect_gg, .next_state=(enum gg_state_t)6,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)5, .handler=gg_handle_connecting, .next_state=(enum gg_state_t)65,
    .alt_state=(enum gg_state_t)48, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)52, .handler=gg_handle_connecting, .next_state=(enum gg_state_t)66,
    .alt_state=(enum gg_state_t)49, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)53, .handler=gg_handle_connecting, .next_state=(enum gg_state_t)67,
    .alt_state=(enum gg_state_t)51, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)6, .handler=gg_handle_connecting_gg, .next_state=(enum gg_state_t)7,
    .alt_state=(enum gg_state_t)50, .alt2_state=(enum gg_state_t)37 }, 
    { .state=(enum gg_state_t)65, .handler=gg_handle_send_hub, .next_state=(enum gg_state_t)71,
    .alt_state=(enum gg_state_t)68, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)66, .handler=gg_handle_send_hub, .next_state=(enum gg_state_t)72,
    .alt_state=(enum gg_state_t)69, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)67, .handler=gg_handle_send_proxy_gg, .next_state=(enum gg_state_t)73,
    .alt_state=(enum gg_state_t)70, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)68, .handler=gg_handle_sending_hub_proxy, .next_state=(enum gg_state_t)71,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)69, .handler=gg_handle_sending_hub_proxy, .next_state=(enum gg_state_t)72,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)70, .handler=gg_handle_sending_hub_proxy, .next_state=(enum gg_state_t)73,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)71, .handler=gg_handle_reading_hub_proxy, .next_state=(enum gg_state_t)61,
    .alt_state=(enum gg_state_t)60, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)72, .handler=gg_handle_reading_hub_proxy, .next_state=(enum gg_state_t)51,
    .alt_state=(enum gg_state_t)51, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)73, .handler=gg_handle_reading_proxy_gg, .next_state=(enum gg_state_t)7,
    .alt_state=(enum gg_state_t)37, .alt2_state=(enum gg_state_t)7 }, 
    { .state=(enum gg_state_t)37, .handler=gg_handle_tls_negotiation, .next_state=(enum gg_state_t)7,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)7, .handler=gg_handle_connected, .next_state=(enum gg_state_t)0,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)8, .handler=gg_handle_connected, .next_state=(enum gg_state_t)0,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)9, .handler=gg_handle_connected, .next_state=(enum gg_state_t)0,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)47, .handler=gg_handle_connected, .next_state=(enum gg_state_t)0,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 }, 
    { .state=(enum gg_state_t)4, .handler=gg_handle_error, .next_state=(enum gg_state_t)0,
    .alt_state=(enum gg_state_t)0, .alt2_state=(enum gg_state_t)0 } };
// handlers$link1
// file handlers.c line 2747
static const struct anonymous$1 handlers$link1[56l];
// handlers$link1
// file handlers.c line 2747
static const struct anonymous$1 handlers$link1[56l] = { { .type=(unsigned int)0x0001, .state=(enum gg_state_t)7, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_welcome }, 
    { .type=(unsigned int)0x0003, .state=(enum gg_state_t)8, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_login_ok }, 
    { .type=(unsigned int)0x0035, .state=(enum gg_state_t)8, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_login_ok }, 
    { .type=(unsigned int)0x009d, .state=(enum gg_state_t)8, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_login110_ok }, 
    { .type=(unsigned int)0x0014, .state=(enum gg_state_t)8, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_login_ok }, 
    { .type=(unsigned int)0x0009, .state=(enum gg_state_t)8, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_login_failed }, 
    { .type=(unsigned int)0x0043, .state=(enum gg_state_t)8, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_login_failed }, 
    { .type=(unsigned int)0x0005, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_send_msg_ack) /*12ul*/ ,
    .handler=gg_session_handle_send_msg_ack }, 
    { .type=(unsigned int)0x0087, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_send_msg_ack_110 }, 
    { .type=(unsigned int)0x0007, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_pong }, 
    { .type=(unsigned int)0x000b, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_disconnecting }, 
    { .type=(unsigned int)0x000d, .state=(enum gg_state_t)47, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_disconnect_ack }, 
    { .type=(unsigned int)0x0027, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_xml_event }, 
    { .type=(unsigned int)0x0084, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_event_110 }, 
    { .type=(unsigned int)0x000e, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_pubdir50_reply }, 
    { .type=(unsigned int)0x0010, .state=(enum gg_state_t)9, .min_length=sizeof(char) /*1ul*/ ,
    .handler=gg_session_handle_userlist_reply }, 
    { .type=(unsigned int)0x23, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_dcc7_id_reply) /*12ul*/ ,
    .handler=gg_session_handle_dcc7_id_reply }, 
    { .type=(unsigned int)0x21, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_dcc7_accept) /*20ul*/ ,
    .handler=gg_session_handle_dcc7_accept }, 
    { .type=(unsigned int)0x20, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_dcc7_new) /*303ul*/ ,
    .handler=gg_session_handle_dcc7_new }, 
    { .type=(unsigned int)0x22, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_dcc7_reject) /*16ul*/ ,
    .handler=gg_session_handle_dcc7_reject }, 
    { .type=(unsigned int)0x1f, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_dcc7_info) /*80ul*/ ,
    .handler=gg_session_handle_dcc7_info }, 
    { .type=(unsigned int)0x000a, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_recv_msg) /*16ul*/ ,
    .handler=gg_session_handle_recv_msg }, 
    { .type=(unsigned int)0x002e, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_recv_msg80) /*24ul*/ ,
    .handler=gg_session_handle_recv_msg_80 }, 
    { .type=(unsigned int)0x007e, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_recv_msg_110 }, 
    { .type=(unsigned int)0x0082, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_recv_msg_110 }, 
    { .type=(unsigned int)0x0002, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_status) /*8ul*/ ,
    .handler=gg_session_handle_status }, 
    { .type=(unsigned int)0x000f, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_status60) /*14ul*/ ,
    .handler=gg_session_handle_status_60_77_80beta }, 
    { .type=(unsigned int)0x0017, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_status77) /*18ul*/ ,
    .handler=gg_session_handle_status_60_77_80beta }, 
    { .type=(unsigned int)0x002a, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_status77) /*18ul*/ ,
    .handler=gg_session_handle_status_60_77_80beta }, 
    { .type=(unsigned int)0x0036, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_notify_reply80) /*28ul*/ ,
    .handler=gg_session_handle_status_80 }, 
    { .type=(unsigned int)0x000c, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_notify_reply) /*20ul*/ ,
    .handler=gg_session_handle_notify_reply }, 
    { .type=(unsigned int)0x0011, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_notify_reply60) /*14ul*/ ,
    .handler=gg_session_handle_notify_reply_60 }, 
    { .type=(unsigned int)0x0018, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_notify_reply77) /*18ul*/ ,
    .handler=gg_session_handle_notify_reply_77_80beta }, 
    { .type=(unsigned int)0x002b, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_notify_reply77) /*18ul*/ ,
    .handler=gg_session_handle_notify_reply_77_80beta }, 
    { .type=(unsigned int)0x0037, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_notify_reply80) /*28ul*/ ,
    .handler=gg_session_handle_notify_reply_80 }, 
    { .type=(unsigned int)0x0044, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_user_data) /*8ul*/ ,
    .handler=gg_session_handle_user_data }, 
    { .type=(unsigned int)0x0059, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_typing_notification) /*6ul*/ ,
    .handler=gg_session_handle_typing_notification }, 
    { .type=(unsigned int)0x005b, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_multilogon_info) /*4ul*/ ,
    .handler=gg_session_handle_multilogon_info }, 
    { .type=(unsigned int)0x002c, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_xml_event }, 
    { .type=(unsigned int)0x005a, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_recv_msg80) /*24ul*/ ,
    .handler=gg_session_handle_recv_msg_80 }, 
    { .type=(unsigned int)0x5c, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_userlist100_version) /*4ul*/ ,
    .handler=gg_session_handle_userlist_100_version }, 
    { .type=(unsigned int)0x41, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_userlist100_reply) /*7ul*/ ,
    .handler=gg_session_handle_userlist_100_reply }, 
    { .type=(unsigned int)0x008c, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_imtoken }, 
    { .type=(unsigned int)0x00a1, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_pong_110 }, 
    { .type=(unsigned int)0x0093, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_chat_info }, 
    { .type=(unsigned int)0x009e, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_chat_info_update }, 
    { .type=(unsigned int)0x0045, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_chat_created) /*12ul*/ ,
    .handler=gg_session_handle_chat_created }, 
    { .type=(unsigned int)0x0047, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_chat_invite_ack) /*20ul*/ ,
    .handler=gg_session_handle_chat_invite_ack }, 
    { .type=(unsigned int)0x0088, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_recv_msg_110 }, 
    { .type=(unsigned int)0x008e, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_recv_msg_110 }, 
    { .type=(unsigned int)0x0066, .state=(enum gg_state_t)9, .min_length=sizeof(struct gg_chat_left) /*12ul*/ ,
    .handler=gg_session_handle_chat_left }, 
    { .type=(unsigned int)0x009b, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_options }, 
    { .type=(unsigned int)0x008f, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_access_info }, 
    { .type=(unsigned int)0x007a, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_uin_info }, 
    { .type=(unsigned int)0x00a0, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_transfer_info }, 
    { .type=(unsigned int)0x009f, .state=(enum gg_state_t)9, .min_length=(unsigned long int)0,
    .handler=gg_session_handle_magic_notification } };
// log_buffer
// file connect.c line 113
static char *log_buffer;
// log_mutex
// file connect.c line 114
static union anonymous$10 log_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// server_cond
// file connect.c line 120
static union anonymous$13 server_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// server_init
// file connect.c line 122
static _Bool server_init = (_Bool)0;
// server_mutex
// file connect.c line 118
static union anonymous$10 server_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// server_pipe
// file connect.c line 123
static signed int server_pipe[2l];
// server_ports
// file connect.c line 117
static signed int server_ports[5l];
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// table_cp1250
// file encoding.c line 36
static const unsigned short int table_cp1250[128l] = { (const unsigned short int)0x20ac, (const unsigned short int)63, (const unsigned short int)0x201a, (const unsigned short int)63, (const unsigned short int)0x201e, (const unsigned short int)0x2026, (const unsigned short int)0x2020, (const unsigned short int)0x2021, (const unsigned short int)63, (const unsigned short int)0x2030, (const unsigned short int)0x0160, (const unsigned short int)0x2039, (const unsigned short int)0x015a, (const unsigned short int)0x0164, (const unsigned short int)0x017d, (const unsigned short int)0x0179, (const unsigned short int)63, (const unsigned short int)0x2018, (const unsigned short int)0x2019, (const unsigned short int)0x201c, (const unsigned short int)0x201d, (const unsigned short int)0x2022, (const unsigned short int)0x2013, (const unsigned short int)0x2014, (const unsigned short int)63, (const unsigned short int)0x2122, (const unsigned short int)0x0161, (const unsigned short int)0x203a, (const unsigned short int)0x015b, (const unsigned short int)0x0165, (const unsigned short int)0x017e, (const unsigned short int)0x017a, (const unsigned short int)0x00a0, (const unsigned short int)0x02c7, (const unsigned short int)0x02d8, (const unsigned short int)0x0141, (const unsigned short int)0x00a4, (const unsigned short int)0x0104, (const unsigned short int)0x00a6, (const unsigned short int)0x00a7, (const unsigned short int)0x00a8, (const unsigned short int)0x00a9, (const unsigned short int)0x015e, (const unsigned short int)0x00ab, (const unsigned short int)0x00ac, (const unsigned short int)0x00ad, (const unsigned short int)0x00ae, (const unsigned short int)0x017b, (const unsigned short int)0x00b0, (const unsigned short int)0x00b1, (const unsigned short int)0x02db, (const unsigned short int)0x0142, (const unsigned short int)0x00b4, (const unsigned short int)0x00b5, (const unsigned short int)0x00b6, (const unsigned short int)0x00b7, (const unsigned short int)0x00b8, (const unsigned short int)0x0105, (const unsigned short int)0x015f, (const unsigned short int)0x00bb, (const unsigned short int)0x013d, (const unsigned short int)0x02dd, (const unsigned short int)0x013e, (const unsigned short int)0x017c, (const unsigned short int)0x0154, (const unsigned short int)0x00c1, (const unsigned short int)0x00c2, (const unsigned short int)0x0102, (const unsigned short int)0x00c4, (const unsigned short int)0x0139, (const unsigned short int)0x0106, (const unsigned short int)0x00c7, (const unsigned short int)0x010c, (const unsigned short int)0x00c9, (const unsigned short int)0x0118, (const unsigned short int)0x00cb, (const unsigned short int)0x011a, (const unsigned short int)0x00cd, (const unsigned short int)0x00ce, (const unsigned short int)0x010e, (const unsigned short int)0x0110, (const unsigned short int)0x0143, (const unsigned short int)0x0147, (const unsigned short int)0x00d3, (const unsigned short int)0x00d4, (const unsigned short int)0x0150, (const unsigned short int)0x00d6, (const unsigned short int)0x00d7, (const unsigned short int)0x0158, (const unsigned short int)0x016e, (const unsigned short int)0x00da, (const unsigned short int)0x0170, (const unsigned short int)0x00dc, (const unsigned short int)0x00dd, (const unsigned short int)0x0162, (const unsigned short int)0x00df, (const unsigned short int)0x0155, (const unsigned short int)0x00e1, (const unsigned short int)0x00e2, (const unsigned short int)0x0103, (const unsigned short int)0x00e4, (const unsigned short int)0x013a, (const unsigned short int)0x0107, (const unsigned short int)0x00e7, (const unsigned short int)0x010d, (const unsigned short int)0x00e9, (const unsigned short int)0x0119, (const unsigned short int)0x00eb, (const unsigned short int)0x011b, (const unsigned short int)0x00ed, (const unsigned short int)0x00ee, (const unsigned short int)0x010f, (const unsigned short int)0x0111, (const unsigned short int)0x0144, (const unsigned short int)0x0148, (const unsigned short int)0x00f3, (const unsigned short int)0x00f4, (const unsigned short int)0x0151, (const unsigned short int)0x00f6, (const unsigned short int)0x00f7, (const unsigned short int)0x0159, (const unsigned short int)0x016f, (const unsigned short int)0x00fa, (const unsigned short int)0x0171, (const unsigned short int)0x00fc, (const unsigned short int)0x00fd, (const unsigned short int)0x0163, (const unsigned short int)0x02d9 };
// timeout_pipe
// file connect.c line 126
static signed int timeout_pipe[2l];
// verbose
// file connect.c line 129
static _Bool verbose;
// x509_cred
// file connect.c line 133
static struct gnutls_certificate_credentials_st *x509_cred;

// client_func
// file connect.c line 558
static signed int client_func(const struct anonymous$16 *test)
{
  struct gg_session *gs;
  struct gg_login_params glp;
  char tmp;
  gg_proxy_host = "proxy.example.org";
  gg_proxy_port = 8080;
  gg_proxy_enabled = (signed int)test->proxy_mode;
  memset((void *)&glp, 0, sizeof(struct gg_login_params) /*216ul*/ );
  glp.uin = (unsigned int)1;
  glp.password = "dupa.8";
  glp.async = (signed int)test->async_mode;
  if(!(test->server == (_Bool)0))
    glp.server_addr=inet_addr("127.0.0.1");

  if(!(test->ssl_mode == (_Bool)0))
    glp.tls = GG_SSL_ENABLED;

  signed long int return_value_recv$1;
  do
  {
    return_value_recv$1=recv(timeout_pipe[(signed long int)0], (void *)&tmp, (unsigned long int)1, 0);
    if(return_value_recv$1 == -1l)
      break;

  }
  while((_Bool)1);
  gs=gg_login(&glp);
  signed int *return_value___errno_location$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  if(gs == ((struct gg_session *)NULL))
    return 0;

  else
    if(test->async_mode == (_Bool)0)
    {
      gg_free_session(gs);
      return 1;
    }

    else
      do
      {
        struct anonymous$19 rd;
        struct anonymous$19 wr;
        signed int res;
        signed int max_fd;
        struct timeval *tv_ptr = (struct timeval *)(void *)0;
        do
        {
          signed int client_func$$1$$2$$1$$1$$1$$__d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(client_func$$1$$2$$1$$1$$1$$__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rd)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        do
        {
          signed int __d0;
          signed int client_func$$1$$2$$1$$1$$2$$__d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(client_func$$1$$2$$1$$1$$2$$__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wr)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        max_fd = timeout_pipe[(signed long int)0];
        if(!(max_fd >= gs->fd))
          max_fd = gs->fd;

        (&rd)->__fds_bits[(signed long int)(timeout_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rd)->__fds_bits[(signed long int)(timeout_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << timeout_pipe[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!((2 & gs->check) == 0))
          (&rd)->__fds_bits[(signed long int)(gs->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rd)->__fds_bits[(signed long int)(gs->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << gs->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        if(!((1 & gs->check) == 0))
          (&wr)->__fds_bits[(signed long int)(gs->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wr)->__fds_bits[(signed long int)(gs->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << gs->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        res=select(max_fd + 1, &rd, &wr, (struct anonymous$19 *)(void *)0, tv_ptr);
        if(res == 0)
        {
          debug("Test timeout\n");
          gg_free_session(gs);
          return 0;
        }

        if(res == -1)
        {
          return_value___errno_location$5=__errno_location();
          if(!(*return_value___errno_location$5 == 4))
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            char *return_value_strerror$3;
            return_value_strerror$3=strerror(*return_value___errno_location$2);
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            debug("select() failed: %s (errno=%d)\n", return_value_strerror$3, *return_value___errno_location$4);
            gg_free_session(gs);
            return -1;
          }

        }

        if(!(res == -1))
        {
          if(!((rd.__fds_bits[(signed long int)(timeout_pipe[0l] / 8)] & (signed long int)(1UL << timeout_pipe[0l] % 8)) == 0l))
          {
            signed long int return_value_recv$6;
            return_value_recv$6=recv(timeout_pipe[(signed long int)0], (void *)&tmp, (unsigned long int)1, 0);
            if(!(return_value_recv$6 == 1l))
            {
              debug("Test error\n");
              gg_free_session(gs);
              return -1;
            }

            if(gs->soft_timeout == 0)
            {
              debug("Hard timeout\n");
              gg_free_session(gs);
              return 0;
            }

          }

          if(!((rd.__fds_bits[(signed long int)(gs->fd / 8)] & (signed long int)(1UL << gs->fd % 8)) == 0l))
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = ((&wr)->__fds_bits[(signed long int)(gs->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << gs->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
            tmp_if_expr$9 = (_Bool)1;

          else
          {
            if(!((rd.__fds_bits[(signed long int)(timeout_pipe[0l] / 8)] & (signed long int)(1UL << timeout_pipe[0l] % 8)) == 0l))
              tmp_if_expr$8 = gs->soft_timeout != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$8 = (_Bool)0;
            tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$9)
          {
            struct gg_event *ge;
            if(!((rd.__fds_bits[(signed long int)(timeout_pipe[0l] / 8)] & (signed long int)(1UL << timeout_pipe[0l] % 8)) == 0l))
            {
              debug("Soft timeout\n");
              gs->timeout = 0;
            }

            ge=gg_watch_fd(gs);
            if(ge == ((struct gg_event *)NULL))
            {
              debug("gg_watch_fd() failed\n");
              gg_free_session(gs);
              return -1;
            }

            switch(ge->type)
            {
              case GG_EVENT_CONN_SUCCESS:
              {
                gg_event_free(ge);
                gg_free_session(gs);
                return 1;
              }
              case GG_EVENT_CONN_FAILED:
              {
                gg_event_free(ge);
                gg_free_session(gs);
                return 0;
              }
              case GG_EVENT_NONE:
                break;
              default:
              {
                debug("Unknown event %d\n", ge->type);
                gg_event_free(ge);
                gg_free_session(gs);
                return -1;
              }
            }
            gg_event_free(ge);
          }

        }

      }
      while((_Bool)1);
}

// connect
// file connect.c line 380
extern signed int connect(signed int socket, struct sockaddr *address, unsigned int address_len)
{
  struct sockaddr_in sin;
  signed int result;
  signed int plug;
  signed int port;
  struct anonymous$16 *test;
  test=get_test_param();
  if(gnutls_initialized == (_Bool)0)
  {
    signed int return_value___connect$1;
    return_value___connect$1=__connect(socket, address, address_len);
    return return_value___connect$1;
  }

  if(!((unsigned long int)address_len >= sizeof(struct sockaddr_in) /*16ul*/ ))
  {
    debug("Invalid argument for connect(): sa_len < %zu\n", sizeof(struct sockaddr_in) /*16ul*/ );
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return -1;
  }

  memcpy((void *)&sin, (const void *)address, (unsigned long int)address_len);
  if(!((signed int)sin.sin_family == 2))
  {
    debug("Invalid argument for connect(): sa_family = %d\n", sin.sin_family);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  unsigned int return_value_inet_addr$6;
  return_value_inet_addr$6=inet_addr("127.0.0.1");
  if(!(sin.sin_addr.s_addr == return_value_inet_addr$6))
  {
    char *return_value_inet_ntoa$4;
    return_value_inet_ntoa$4=inet_ntoa(sin.sin_addr);
    debug("Invalid argument for connect(): sin_addr = %s\n", return_value_inet_ntoa$4);
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    *return_value___errno_location$5 = 22;
    return -1;
  }

  unsigned short int return_value_ntohs$7;
  return_value_ntohs$7=ntohs(sin.sin_port);
  if(!((signed int)return_value_ntohs$7 == 8080))
    test->tried_non_8080 = (_Bool)1;

  unsigned short int return_value_ntohs$8;
  return_value_ntohs$8=ntohs(sin.sin_port);
  unsigned short int return_value_ntohs$9;
  signed int *return_value___errno_location$10;
  switch((signed int)return_value_ntohs$8)
  {
    case 80:
    {
      plug = (signed int)test->plug_80;
      port = server_ports[(signed long int)0];
      test->tried_80 = (_Bool)1;
      break;
    }
    case 443:
    {
      plug = (signed int)test->plug_443;
      port = server_ports[(signed long int)1];
      test->tried_443 = (_Bool)1;
      break;
    }
    case 8074:
    {
      plug = (signed int)test->plug_8074;
      port = server_ports[(signed long int)2];
      test->tried_8074 = (_Bool)1;
      break;
    }
    case 8080:
    {
      plug = (signed int)test->plug_8080;
      port = server_ports[(signed long int)3];
      test->tried_8080 = (_Bool)1;
      break;
    }
    default:
    {
      return_value_ntohs$9=ntohs(sin.sin_port);
      debug("Invalid argument for connect(): sin_port = %d\n", return_value_ntohs$9);
      return_value___errno_location$10=__errno_location();
      *return_value___errno_location$10 = 22;
      return -1;
    }
  }
  unsigned short int return_value_ntohs$11;
  if(!(test->proxy_mode == (_Bool)0))
  {
    return_value_ntohs$11=ntohs(sin.sin_port);
    if(!((signed int)return_value_ntohs$11 == 8080))
      plug = PLUG_RESET;

  }

  switch(plug)
  {
    case PLUG_NONE:
    {
      sin.sin_port=htons((unsigned short int)port);
      goto __CPROVER_DUMP_L19;
    }
    case PLUG_RESET:
    {
      sin.sin_port=htons((unsigned short int)server_ports[(signed long int)4]);
      goto __CPROVER_DUMP_L19;
    }
    case PLUG_TIMEOUT:
    {
      if(test->async_mode == (_Bool)0)
      {
        signed int *return_value___errno_location$12;
        return_value___errno_location$12=__errno_location();
        *return_value___errno_location$12 = 110;
      }

      else
      {
        signed int res;
        signed long int return_value_send$14;
        return_value_send$14=send(timeout_pipe[(signed long int)1], (const void *)"", (unsigned long int)1, 0);
        res = (signed int)return_value_send$14;
        if(!(res == 1))
        {
          debug("send() returned %d\n", res);
          signed int *return_value___errno_location$13;
          return_value___errno_location$13=__errno_location();
          *return_value___errno_location$13 = 9;
          return -1;
        }

        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        *return_value___errno_location$15 = 115;
      }
      return -1;
    }
    default:
    {

    __CPROVER_DUMP_L19:
      ;
      result=__connect(socket, (struct sockaddr *)&sin, address_len);
      return result;
    }
  }
}

// debug
// file connect.c line 274
static void debug(const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  debug_handler(0, fmt, ap);
  ap = ((void **)NULL);
}

// debug_handler
// file connect.c line 211
static void debug_handler(signed int level, const char *format, void **ap)
{
  unsigned long int tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  if(!(verbose == (_Bool)0))
    vprintf(format, ap);

  else
  {
    char buf[4096l];
    char *tmp;
    signed int len;
    signed int ret;
    ret=vsnprintf(buf, sizeof(char [4096l]) /*4096ul*/ , format, ap);
    if(!(ret >= 0))
      fprintf(stderr, "vsnprintf error!\n");

    else
      if((unsigned long int)ret >= sizeof(char [4096l]) /*4096ul*/ )
        fprintf(stderr, "Increase temporary log buffer size!\n");

      else
      {
        signed int return_value_pthread_mutex_lock$1;
        return_value_pthread_mutex_lock$1=pthread_mutex_lock(&log_mutex);
        if(!(return_value_pthread_mutex_lock$1 == 0))
          fprintf(stderr, "pthread_mutex_lock failed!\n");

        else
        {
          if(!(log_buffer == ((char *)NULL)))
          {
            return_value_strlen$2=strlen(log_buffer);
            tmp_if_expr$3 = return_value_strlen$2;
          }

          else
            tmp_if_expr$3 = (unsigned long int)0;
          len = (signed int)tmp_if_expr$3;
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(buf);
          void *return_value_realloc$5;
          return_value_realloc$5=realloc((void *)log_buffer, (unsigned long int)len + return_value_strlen$4 + (unsigned long int)1);
          tmp = (char *)return_value_realloc$5;
          if(!(tmp == ((char *)NULL)))
          {
            log_buffer = tmp;
            strcpy(log_buffer + (signed long int)len, buf);
          }

          else
            fprintf(stderr, "Out of memory for log buffer!\n");
          signed int return_value_pthread_mutex_unlock$6;
          return_value_pthread_mutex_unlock$6=pthread_mutex_unlock(&log_mutex);
          if(!(return_value_pthread_mutex_unlock$6 == 0))
          {
            fprintf(stderr, "pthread_mutex_unlock failed!\n");
            failure();
          }

        }
      }
  }
}

// failure
// file connect.c line 146
static void failure(void)
{
  exit(1);
}

// get32
// file connect.c line 266
static inline unsigned int get32(char *ptr)
{
  unsigned char *tmp = (unsigned char *)ptr;
  return (unsigned int)((signed int)tmp[(signed long int)0] | (signed int)tmp[(signed long int)1] << 8 | (signed int)tmp[(signed long int)2] << 16 | (signed int)tmp[(signed long int)3] << 24);
}

// get_test_param
// file connect.c line 204
static struct anonymous$16 * get_test_param(void)
{
  static struct anonymous$16 test;
  return &test;
}

// gethostbyname
// file connect.c line 303
extern struct hostent * gethostbyname(const char *name)
{
  struct hostent *he_ptr;
  signed int return_value_gethostbyname_r$1;
  static char buf[256l];
  static struct hostent he;
  return_value_gethostbyname_r$1=gethostbyname_r(name, &he, buf, sizeof(char [256l]) /*256ul*/ , &he_ptr, &h_errno);
  if(!(return_value_gethostbyname_r$1 == 0))
    return (struct hostent *)(void *)0;

  else
    return he_ptr;
}

// gethostbyname_r
// file connect.c line 316
extern signed int gethostbyname_r(const char *name, struct hostent *ret, char *buf, unsigned long int buflen, struct hostent **result, signed int *h_errnop)
{
  struct anonymous$20 *storage = (struct anonymous$20 *)(void *)buf;
  struct anonymous$16 *test;
  test=get_test_param();
  *result = (struct hostent *)(void *)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  signed int return_value_strcmp$5;
  if(!(buflen >= sizeof(struct anonymous$20) /*32ul*/  + return_value_strlen$1))
    return 34;

  else
  {
    test->tried_resolver = (_Bool)1;
    if(!((signed int)test->plug_resolver == PLUG_NONE))
    {
      if((signed int)test->plug_resolver == PLUG_TIMEOUT)
      {
        if(!(test->async_mode == (_Bool)0))
        {
          signed int res;
          signed long int return_value_send$2;
          return_value_send$2=send(timeout_pipe[(signed long int)1], (const void *)"", (unsigned long int)1, 0);
          res = (signed int)return_value_send$2;
          if(!(res == 1))
          {
            if(res == -1)
              perror("send");

            else
              fprintf(stderr, "send returned %d\n", res);
            failure();
          }

        }

        *h_errnop = 2;
      }

      else
        *h_errnop = 1;
      return -1;
    }

    else
    {
      if(test->proxy_mode == (_Bool)0)
      {
        return_value_strcmp$3=strcmp(name, "appmsg.gadu-gadu.pl");
        tmp_if_expr$4 = return_value_strcmp$3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        if(!(test->proxy_mode == (_Bool)0))
        {
          return_value_strcmp$5=strcmp(name, "proxy.example.org");
          tmp_if_expr$6 = return_value_strcmp$5 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
      {
        debug("Invalid argument for gethostbyname(): \"%s\"\n", name);
        *h_errnop = 1;
        return -1;
      }

      else
      {
        storage->addr_list[(signed long int)0] = (char *)&storage->addr;
        storage->addr_list[(signed long int)1] = (char *)(void *)0;
        storage->addr.s_addr=inet_addr("127.0.0.1");
        strcpy(storage->name, name);
        memset((void *)ret, 0, sizeof(struct hostent) /*32ul*/ );
        ret->h_name = storage->name;
        ret->h_addrtype = 2;
        ret->h_length = (signed int)sizeof(struct in_addr) /*4ul*/ ;
        ret->h_addr_list = storage->addr_list;
        *result = ret;
        return 0;
      }
    }
  }
}

// gg105_login__free_unpacked
// file packets.pb-c.c line 175
void gg105_login__free_unpacked(struct _GG105Login *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg105_login__descriptor */
  assert(message->base.descriptor == &gg105_login__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg105_login__get_packed_size
// file ../include/packets.pb-c.h line 534
unsigned long int gg105_login__get_packed_size(const struct _GG105Login *message)
{
  /* assertion message->base.descriptor == &gg105_login__descriptor */
  assert(message->base.descriptor == &gg105_login__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg105_login__init
// file packets.pb-c.c line 139
void gg105_login__init(struct _GG105Login *message)
{
  static struct _GG105Login init_value = { .base={ .descriptor=&gg105_login__descriptor, .n_unknown_fields=(unsigned int)0, .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .lang=(char *)(void *)0,
    .uin={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 }, .hash={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .client=(char *)(void *)0,
    .initial_status=8227u, .initial_descr=gg105_login__initial_descr__default_value,
    .supported_features=(char *)(void *)0,
    .dummy1=4,
    .dummy2=65994615u, .dummy3=198164u, .dummy4={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .dummy5=255,
    .dummy6=100, .has_dummy7=0, .dummy7=127u,
    .has_dummy8=0, .dummy8=0, .has_dummy10=0,
    .dummy10=0u };
  *message = init_value;
}

// gg105_login__pack
// file ../include/packets.pb-c.h line 536
unsigned long int gg105_login__pack(const struct _GG105Login *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg105_login__descriptor */
  assert(message->base.descriptor == &gg105_login__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg105_login__pack_to_buffer
// file packets.pb-c.c line 158
unsigned long int gg105_login__pack_to_buffer(const struct _GG105Login *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg105_login__descriptor */
  assert(message->base.descriptor == &gg105_login__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg105_login__unpack
// file packets.pb-c.c line 166
struct _GG105Login * gg105_login__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg105_login__descriptor, allocator, len, data);
  return (struct _GG105Login *)return_value_protobuf_c_message_unpack$1;
}

// gg110_access_info__free_unpacked
// file ../include/packets.pb-c.h line 737
void gg110_access_info__free_unpacked(struct _GG110AccessInfo *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_access_info__descriptor */
  assert(message->base.descriptor == &gg110_access_info__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_access_info__get_packed_size
// file packets.pb-c.c line 575
unsigned long int gg110_access_info__get_packed_size(const struct _GG110AccessInfo *message)
{
  /* assertion message->base.descriptor == &gg110_access_info__descriptor */
  assert(message->base.descriptor == &gg110_access_info__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_access_info__init
// file packets.pb-c.c line 569
void gg110_access_info__init(struct _GG110AccessInfo *message)
{
  static struct _GG110AccessInfo init_value = { .base={ .descriptor=&gg110_access_info__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .dummy1=1u,
    .dummy2=(unsigned int)0, .last_message=(unsigned int)0,
    .last_file_transfer=(unsigned int)0, .last_conference_ch=(unsigned int)0 };
  *message = init_value;
}

// gg110_access_info__pack
// file packets.pb-c.c line 581
unsigned long int gg110_access_info__pack(const struct _GG110AccessInfo *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_access_info__descriptor */
  assert(message->base.descriptor == &gg110_access_info__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_access_info__pack_to_buffer
// file packets.pb-c.c line 588
unsigned long int gg110_access_info__pack_to_buffer(const struct _GG110AccessInfo *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_access_info__descriptor */
  assert(message->base.descriptor == &gg110_access_info__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_access_info__unpack
// file ../include/packets.pb-c.h line 733
struct _GG110AccessInfo * gg110_access_info__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_access_info__descriptor, allocator, len, data);
  return (struct _GG110AccessInfo *)return_value_protobuf_c_message_unpack$1;
}

// gg110_ack__free_unpacked
// file packets.pb-c.c line 132
void gg110_ack__free_unpacked(struct _GG110Ack *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_ack__descriptor */
  assert(message->base.descriptor == &gg110_ack__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_ack__get_packed_size
// file ../include/packets.pb-c.h line 515
unsigned long int gg110_ack__get_packed_size(const struct _GG110Ack *message)
{
  /* assertion message->base.descriptor == &gg110_ack__descriptor */
  assert(message->base.descriptor == &gg110_ack__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_ack__init
// file packets.pb-c.c line 96
void gg110_ack__init(struct _GG110Ack *message)
{
  static struct _GG110Ack init_value = { .base={ .descriptor=&gg110_ack__descriptor, .n_unknown_fields=(unsigned int)0, .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .type=(enum _GG110Ack__Type)0,
    .seq=(unsigned int)0, .dummy1=1u };
  *message = init_value;
}

// gg110_ack__pack
// file ../include/packets.pb-c.h line 517
unsigned long int gg110_ack__pack(const struct _GG110Ack *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_ack__descriptor */
  assert(message->base.descriptor == &gg110_ack__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_ack__pack_to_buffer
// file packets.pb-c.c line 115
unsigned long int gg110_ack__pack_to_buffer(const struct _GG110Ack *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_ack__descriptor */
  assert(message->base.descriptor == &gg110_ack__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_ack__unpack
// file packets.pb-c.c line 123
struct _GG110Ack * gg110_ack__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_ack__descriptor, allocator, len, data);
  return (struct _GG110Ack *)return_value_protobuf_c_message_unpack$1;
}

// gg110_chat_info_update__free_unpacked
// file ../include/packets.pb-c.h line 680
void gg110_chat_info_update__free_unpacked(struct _GG110ChatInfoUpdate *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_chat_info_update__descriptor */
  assert(message->base.descriptor == &gg110_chat_info_update__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_chat_info_update__get_packed_size
// file packets.pb-c.c line 446
unsigned long int gg110_chat_info_update__get_packed_size(const struct _GG110ChatInfoUpdate *message)
{
  /* assertion message->base.descriptor == &gg110_chat_info_update__descriptor */
  assert(message->base.descriptor == &gg110_chat_info_update__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_chat_info_update__init
// file packets.pb-c.c line 440
void gg110_chat_info_update__init(struct _GG110ChatInfoUpdate *message)
{
  static struct _GG110ChatInfoUpdate init_value = { .base={ .descriptor=&gg110_chat_info_update__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .participant={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .inviter={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .update_type=(unsigned int)0,
    .time=(unsigned int)0, .dummy1=(unsigned int)0,
    .version=(unsigned int)0, .dummy2=(unsigned int)0,
    .msg_id=(unsigned long int)0, .chat_id=(unsigned long int)0,
    .conv_id=(unsigned long int)0 };
  *message = init_value;
}

// gg110_chat_info_update__pack
// file packets.pb-c.c line 452
unsigned long int gg110_chat_info_update__pack(const struct _GG110ChatInfoUpdate *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_chat_info_update__descriptor */
  assert(message->base.descriptor == &gg110_chat_info_update__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_chat_info_update__pack_to_buffer
// file packets.pb-c.c line 459
unsigned long int gg110_chat_info_update__pack_to_buffer(const struct _GG110ChatInfoUpdate *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_chat_info_update__descriptor */
  assert(message->base.descriptor == &gg110_chat_info_update__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_chat_info_update__unpack
// file ../include/packets.pb-c.h line 676
struct _GG110ChatInfoUpdate * gg110_chat_info_update__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_chat_info_update__descriptor, allocator, len, data);
  return (struct _GG110ChatInfoUpdate *)return_value_protobuf_c_message_unpack$1;
}

// gg110_event__free_unpacked
// file ../include/packets.pb-c.h line 604
void gg110_event__free_unpacked(struct _GG110Event *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_event__descriptor */
  assert(message->base.descriptor == &gg110_event__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_event__get_packed_size
// file packets.pb-c.c line 274
unsigned long int gg110_event__get_packed_size(const struct _GG110Event *message)
{
  /* assertion message->base.descriptor == &gg110_event__descriptor */
  assert(message->base.descriptor == &gg110_event__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_event__init
// file packets.pb-c.c line 268
void gg110_event__init(struct _GG110Event *message)
{
  static struct _GG110Event init_value = { .base={ .descriptor=&gg110_event__descriptor, .n_unknown_fields=(unsigned int)0, .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .type=(enum _GG110Event__Type)0,
    .seq=(unsigned int)0, .data=(char *)(void *)0,
    .subtype=(char *)(void *)0, .has_id=0,
    .id=(unsigned long int)0 };
  *message = init_value;
}

// gg110_event__pack
// file packets.pb-c.c line 280
unsigned long int gg110_event__pack(const struct _GG110Event *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_event__descriptor */
  assert(message->base.descriptor == &gg110_event__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_event__pack_to_buffer
// file packets.pb-c.c line 287
unsigned long int gg110_event__pack_to_buffer(const struct _GG110Event *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_event__descriptor */
  assert(message->base.descriptor == &gg110_event__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_event__unpack
// file ../include/packets.pb-c.h line 600
struct _GG110Event * gg110_event__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_event__descriptor, allocator, len, data);
  return (struct _GG110Event *)return_value_protobuf_c_message_unpack$1;
}

// gg110_imtoken__free_unpacked
// file ../include/packets.pb-c.h line 661
void gg110_imtoken__free_unpacked(struct _GG110Imtoken *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_imtoken__descriptor */
  assert(message->base.descriptor == &gg110_imtoken__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_imtoken__get_packed_size
// file packets.pb-c.c line 403
unsigned long int gg110_imtoken__get_packed_size(const struct _GG110Imtoken *message)
{
  /* assertion message->base.descriptor == &gg110_imtoken__descriptor */
  assert(message->base.descriptor == &gg110_imtoken__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_imtoken__init
// file packets.pb-c.c line 397
void gg110_imtoken__init(struct _GG110Imtoken *message)
{
  static struct _GG110Imtoken init_value = { .base={ .descriptor=&gg110_imtoken__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .imtoken=(char *)(void *)0 };
  *message = init_value;
}

// gg110_imtoken__pack
// file packets.pb-c.c line 409
unsigned long int gg110_imtoken__pack(const struct _GG110Imtoken *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_imtoken__descriptor */
  assert(message->base.descriptor == &gg110_imtoken__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_imtoken__pack_to_buffer
// file packets.pb-c.c line 416
unsigned long int gg110_imtoken__pack_to_buffer(const struct _GG110Imtoken *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_imtoken__descriptor */
  assert(message->base.descriptor == &gg110_imtoken__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_imtoken__unpack
// file ../include/packets.pb-c.h line 657
struct _GG110Imtoken * gg110_imtoken__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_imtoken__descriptor, allocator, len, data);
  return (struct _GG110Imtoken *)return_value_protobuf_c_message_unpack$1;
}

// gg110_login_ok__free_unpacked
// file ../include/packets.pb-c.h line 490
void gg110_login_ok__free_unpacked(struct _GG110LoginOK *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_login_ok__descriptor */
  assert(message->base.descriptor == &gg110_login_ok__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_login_ok__get_packed_size
// file packets.pb-c.c line 16
unsigned long int gg110_login_ok__get_packed_size(const struct _GG110LoginOK *message)
{
  /* assertion message->base.descriptor == &gg110_login_ok__descriptor */
  assert(message->base.descriptor == &gg110_login_ok__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_login_ok__init
// file packets.pb-c.c line 10
void gg110_login_ok__init(struct _GG110LoginOK *message)
{
  static struct _GG110LoginOK init_value = { .base={ .descriptor=&gg110_login_ok__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .dummy1=1,
    .dummyhash=(char *)(void *)0, .uin=(unsigned int)0,
    .server_time=(unsigned int)0 };
  *message = init_value;
}

// gg110_login_ok__pack
// file packets.pb-c.c line 22
unsigned long int gg110_login_ok__pack(const struct _GG110LoginOK *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_login_ok__descriptor */
  assert(message->base.descriptor == &gg110_login_ok__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_login_ok__pack_to_buffer
// file packets.pb-c.c line 29
unsigned long int gg110_login_ok__pack_to_buffer(const struct _GG110LoginOK *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_login_ok__descriptor */
  assert(message->base.descriptor == &gg110_login_ok__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_login_ok__unpack
// file ../include/packets.pb-c.h line 486
struct _GG110LoginOK * gg110_login_ok__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_login_ok__descriptor, allocator, len, data);
  return (struct _GG110LoginOK *)return_value_protobuf_c_message_unpack$1;
}

// gg110_magic_notification__free_unpacked
// file ../include/packets.pb-c.h line 813
void gg110_magic_notification__free_unpacked(struct _GG110MagicNotification *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_magic_notification__descriptor */
  assert(message->base.descriptor == &gg110_magic_notification__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_magic_notification__get_packed_size
// file packets.pb-c.c line 747
unsigned long int gg110_magic_notification__get_packed_size(const struct _GG110MagicNotification *message)
{
  /* assertion message->base.descriptor == &gg110_magic_notification__descriptor */
  assert(message->base.descriptor == &gg110_magic_notification__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_magic_notification__init
// file packets.pb-c.c line 741
void gg110_magic_notification__init(struct _GG110MagicNotification *message)
{
  static struct _GG110MagicNotification init_value = { .base={ .descriptor=&gg110_magic_notification__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .dummy1=2,
    .seq=0, .dummy2=1, .dummy3=1, .uin={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .dummy4=gg110_magic_notification__dummy4__default_value };
  *message = init_value;
}

// gg110_magic_notification__pack
// file packets.pb-c.c line 753
unsigned long int gg110_magic_notification__pack(const struct _GG110MagicNotification *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_magic_notification__descriptor */
  assert(message->base.descriptor == &gg110_magic_notification__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_magic_notification__pack_to_buffer
// file packets.pb-c.c line 760
unsigned long int gg110_magic_notification__pack_to_buffer(const struct _GG110MagicNotification *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_magic_notification__descriptor */
  assert(message->base.descriptor == &gg110_magic_notification__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_magic_notification__unpack
// file ../include/packets.pb-c.h line 809
struct _GG110MagicNotification * gg110_magic_notification__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_magic_notification__descriptor, allocator, len, data);
  return (struct _GG110MagicNotification *)return_value_protobuf_c_message_unpack$1;
}

// gg110_message_ack__free_unpacked
// file ../include/packets.pb-c.h line 585
void gg110_message_ack__free_unpacked(struct _GG110MessageAck *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_message_ack__descriptor */
  assert(message->base.descriptor == &gg110_message_ack__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_message_ack__get_packed_size
// file packets.pb-c.c line 231
unsigned long int gg110_message_ack__get_packed_size(const struct _GG110MessageAck *message)
{
  /* assertion message->base.descriptor == &gg110_message_ack__descriptor */
  assert(message->base.descriptor == &gg110_message_ack__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_message_ack__init
// file packets.pb-c.c line 225
void gg110_message_ack__init(struct _GG110MessageAck *message)
{
  static struct _GG110MessageAck init_value = { .base={ .descriptor=&gg110_message_ack__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .msg_type=(unsigned int)0,
    .seq=(unsigned int)0, .time=(unsigned int)0,
    .has_msg_id=0, .msg_id=(unsigned long int)0,
    .has_conv_id=0, .conv_id=(unsigned long int)0,
    .n_links=(unsigned long int)0, .links=(struct _GG110MessageAckLink **)(void *)0,
    .dummy1=0u };
  *message = init_value;
}

// gg110_message_ack__pack
// file packets.pb-c.c line 237
unsigned long int gg110_message_ack__pack(const struct _GG110MessageAck *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_message_ack__descriptor */
  assert(message->base.descriptor == &gg110_message_ack__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_message_ack__pack_to_buffer
// file packets.pb-c.c line 244
unsigned long int gg110_message_ack__pack_to_buffer(const struct _GG110MessageAck *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_message_ack__descriptor */
  assert(message->base.descriptor == &gg110_message_ack__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_message_ack__unpack
// file ../include/packets.pb-c.h line 581
struct _GG110MessageAck * gg110_message_ack__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_message_ack__descriptor, allocator, len, data);
  return (struct _GG110MessageAck *)return_value_protobuf_c_message_unpack$1;
}

// gg110_message_ack_link__free_unpacked
// file packets.pb-c.c line 218
void gg110_message_ack_link__free_unpacked(struct _GG110MessageAckLink *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_message_ack_link__descriptor */
  assert(message->base.descriptor == &gg110_message_ack_link__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_message_ack_link__get_packed_size
// file packets.pb-c.c line 188
unsigned long int gg110_message_ack_link__get_packed_size(const struct _GG110MessageAckLink *message)
{
  /* assertion message->base.descriptor == &gg110_message_ack_link__descriptor */
  assert(message->base.descriptor == &gg110_message_ack_link__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_message_ack_link__init
// file packets.pb-c.c line 182
void gg110_message_ack_link__init(struct _GG110MessageAckLink *message)
{
  static struct _GG110MessageAckLink init_value = { .base={ .descriptor=&gg110_message_ack_link__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .id=(unsigned long int)0,
    .url=(char *)(void *)0 };
  *message = init_value;
}

// gg110_message_ack_link__pack
// file packets.pb-c.c line 194
unsigned long int gg110_message_ack_link__pack(const struct _GG110MessageAckLink *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_message_ack_link__descriptor */
  assert(message->base.descriptor == &gg110_message_ack_link__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_message_ack_link__pack_to_buffer
// file packets.pb-c.c line 201
unsigned long int gg110_message_ack_link__pack_to_buffer(const struct _GG110MessageAckLink *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_message_ack_link__descriptor */
  assert(message->base.descriptor == &gg110_message_ack_link__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_message_ack_link__unpack
// file packets.pb-c.c line 209
struct _GG110MessageAckLink * gg110_message_ack_link__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_message_ack_link__descriptor, allocator, len, data);
  return (struct _GG110MessageAckLink *)return_value_protobuf_c_message_unpack$1;
}

// gg110_options__free_unpacked
// file ../include/packets.pb-c.h line 718
void gg110_options__free_unpacked(struct _GG110Options *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_options__descriptor */
  assert(message->base.descriptor == &gg110_options__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_options__get_packed_size
// file packets.pb-c.c line 532
unsigned long int gg110_options__get_packed_size(const struct _GG110Options *message)
{
  /* assertion message->base.descriptor == &gg110_options__descriptor */
  assert(message->base.descriptor == &gg110_options__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_options__init
// file packets.pb-c.c line 526
void gg110_options__init(struct _GG110Options *message)
{
  static struct _GG110Options init_value = { .base={ .descriptor=&gg110_options__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .n_options=(unsigned long int)0,
    .options=(struct _ProtobufKVP **)(void *)0, .dummy1=0u };
  *message = init_value;
}

// gg110_options__pack
// file packets.pb-c.c line 538
unsigned long int gg110_options__pack(const struct _GG110Options *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_options__descriptor */
  assert(message->base.descriptor == &gg110_options__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_options__pack_to_buffer
// file packets.pb-c.c line 545
unsigned long int gg110_options__pack_to_buffer(const struct _GG110Options *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_options__descriptor */
  assert(message->base.descriptor == &gg110_options__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_options__unpack
// file ../include/packets.pb-c.h line 714
struct _GG110Options * gg110_options__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_options__descriptor, allocator, len, data);
  return (struct _GG110Options *)return_value_protobuf_c_message_unpack$1;
}

// gg110_pong__free_unpacked
// file ../include/packets.pb-c.h line 509
void gg110_pong__free_unpacked(struct _GG110Pong *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_pong__descriptor */
  assert(message->base.descriptor == &gg110_pong__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_pong__get_packed_size
// file packets.pb-c.c line 59
unsigned long int gg110_pong__get_packed_size(const struct _GG110Pong *message)
{
  /* assertion message->base.descriptor == &gg110_pong__descriptor */
  assert(message->base.descriptor == &gg110_pong__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_pong__init
// file packets.pb-c.c line 53
void gg110_pong__init(struct _GG110Pong *message)
{
  static struct _GG110Pong init_value = { .base={ .descriptor=&gg110_pong__descriptor, .n_unknown_fields=(unsigned int)0, .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .server_time=(unsigned int)0 };
  *message = init_value;
}

// gg110_pong__pack
// file packets.pb-c.c line 65
unsigned long int gg110_pong__pack(const struct _GG110Pong *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_pong__descriptor */
  assert(message->base.descriptor == &gg110_pong__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_pong__pack_to_buffer
// file packets.pb-c.c line 72
unsigned long int gg110_pong__pack_to_buffer(const struct _GG110Pong *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_pong__descriptor */
  assert(message->base.descriptor == &gg110_pong__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_pong__unpack
// file ../include/packets.pb-c.h line 505
struct _GG110Pong * gg110_pong__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_pong__descriptor, allocator, len, data);
  return (struct _GG110Pong *)return_value_protobuf_c_message_unpack$1;
}

// gg110_recv_message__free_unpacked
// file ../include/packets.pb-c.h line 623
void gg110_recv_message__free_unpacked(struct _GG110RecvMessage *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_recv_message__descriptor */
  assert(message->base.descriptor == &gg110_recv_message__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_recv_message__get_packed_size
// file packets.pb-c.c line 317
unsigned long int gg110_recv_message__get_packed_size(const struct _GG110RecvMessage *message)
{
  /* assertion message->base.descriptor == &gg110_recv_message__descriptor */
  assert(message->base.descriptor == &gg110_recv_message__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_recv_message__init
// file packets.pb-c.c line 311
void gg110_recv_message__init(struct _GG110RecvMessage *message)
{
  static struct _GG110RecvMessage init_value = { .base={ .descriptor=&gg110_recv_message__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .has_sender=0,
    .sender={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 }, .flags=(unsigned int)0,
    .seq=(unsigned int)0, .time=(unsigned int)0,
    .msg_plain=gg110_recv_message__msg_plain__default_value, .msg_xhtml=(char *)(void *)0,
    .has_data=0, .data={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .has_msg_id=0,
    .msg_id=(unsigned long int)0, .has_chat_id=0,
    .chat_id=(unsigned long int)0, .has_conv_id=0,
    .conv_id=(unsigned long int)0 };
  *message = init_value;
}

// gg110_recv_message__pack
// file packets.pb-c.c line 323
unsigned long int gg110_recv_message__pack(const struct _GG110RecvMessage *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_recv_message__descriptor */
  assert(message->base.descriptor == &gg110_recv_message__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_recv_message__pack_to_buffer
// file packets.pb-c.c line 330
unsigned long int gg110_recv_message__pack_to_buffer(const struct _GG110RecvMessage *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_recv_message__descriptor */
  assert(message->base.descriptor == &gg110_recv_message__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_recv_message__unpack
// file ../include/packets.pb-c.h line 619
struct _GG110RecvMessage * gg110_recv_message__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_recv_message__descriptor, allocator, len, data);
  return (struct _GG110RecvMessage *)return_value_protobuf_c_message_unpack$1;
}

// gg110_send_message__free_unpacked
// file packets.pb-c.c line 390
void gg110_send_message__free_unpacked(struct _GG110SendMessage *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg110_send_message__descriptor */
  assert(message->base.descriptor == &gg110_send_message__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg110_send_message__get_packed_size
// file ../include/packets.pb-c.h line 629
unsigned long int gg110_send_message__get_packed_size(const struct _GG110SendMessage *message)
{
  /* assertion message->base.descriptor == &gg110_send_message__descriptor */
  assert(message->base.descriptor == &gg110_send_message__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg110_send_message__init
// file packets.pb-c.c line 354
void gg110_send_message__init(struct _GG110SendMessage *message)
{
  static struct _GG110SendMessage init_value = { .base={ .descriptor=&gg110_send_message__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .has_recipient=0,
    .recipient={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 }, .dummy1=8u,
    .seq=(unsigned int)0, .msg_plain=(char *)(void *)0, .msg_xhtml=(char *)(void *)0,
    .dummy3=gg110_send_message__dummy3__default_value, .has_chat_id=0,
    .chat_id=(unsigned long int)0 };
  *message = init_value;
}

// gg110_send_message__pack
// file ../include/packets.pb-c.h line 631
unsigned long int gg110_send_message__pack(const struct _GG110SendMessage *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg110_send_message__descriptor */
  assert(message->base.descriptor == &gg110_send_message__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg110_send_message__pack_to_buffer
// file packets.pb-c.c line 373
unsigned long int gg110_send_message__pack_to_buffer(const struct _GG110SendMessage *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg110_send_message__descriptor */
  assert(message->base.descriptor == &gg110_send_message__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg110_send_message__unpack
// file packets.pb-c.c line 381
struct _GG110SendMessage * gg110_send_message__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg110_send_message__descriptor, allocator, len, data);
  return (struct _GG110SendMessage *)return_value_protobuf_c_message_unpack$1;
}

// gg112_transfer_info__free_unpacked
// file ../include/packets.pb-c.h line 794
void gg112_transfer_info__free_unpacked(struct _GG112TransferInfo *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg112_transfer_info__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg112_transfer_info__get_packed_size
// file packets.pb-c.c line 704
unsigned long int gg112_transfer_info__get_packed_size(const struct _GG112TransferInfo *message)
{
  /* assertion message->base.descriptor == &gg112_transfer_info__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg112_transfer_info__init
// file packets.pb-c.c line 698
void gg112_transfer_info__init(struct _GG112TransferInfo *message)
{
  static struct _GG112TransferInfo init_value = { .base={ .descriptor=&gg112_transfer_info__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .dummy1=(unsigned int)0,
    .peer=(struct _GG112TransferInfoUin *)(void *)0, .sender=(struct _GG112TransferInfoUin *)(void *)0,
    .time=(unsigned int)0,
    .n_data=(unsigned long int)0, .data=(struct _ProtobufKVP **)(void *)0,
    .file=(struct _GG112TransferInfoFile *)(void *)0,
    .seq=(unsigned int)0,
    .msg_id=(unsigned long int)0, .conv_id=(unsigned long int)0 };
  *message = init_value;
}

// gg112_transfer_info__pack
// file packets.pb-c.c line 710
unsigned long int gg112_transfer_info__pack(const struct _GG112TransferInfo *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg112_transfer_info__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg112_transfer_info__pack_to_buffer
// file packets.pb-c.c line 717
unsigned long int gg112_transfer_info__pack_to_buffer(const struct _GG112TransferInfo *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg112_transfer_info__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg112_transfer_info__unpack
// file ../include/packets.pb-c.h line 790
struct _GG112TransferInfo * gg112_transfer_info__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg112_transfer_info__descriptor, allocator, len, data);
  return (struct _GG112TransferInfo *)return_value_protobuf_c_message_unpack$1;
}

// gg112_transfer_info_file__free_unpacked
// file packets.pb-c.c line 691
void gg112_transfer_info_file__free_unpacked(struct _GG112TransferInfoFile *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_file__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_file__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg112_transfer_info_file__get_packed_size
// file packets.pb-c.c line 661
unsigned long int gg112_transfer_info_file__get_packed_size(const struct _GG112TransferInfoFile *message)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_file__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_file__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg112_transfer_info_file__init
// file packets.pb-c.c line 655
void gg112_transfer_info_file__init(struct _GG112TransferInfoFile *message)
{
  static struct _GG112TransferInfoFile init_value = { .base={ .descriptor=&gg112_transfer_info_file__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .type=gg112_transfer_info_file__type__default_value,
    .url=(char *)(void *)0,
    .content_type=(char *)(void *)0, .filename=(char *)(void *)0,
    .filesize=(unsigned int)0, .msg_id=(unsigned long int)0 };
  *message = init_value;
}

// gg112_transfer_info_file__pack
// file packets.pb-c.c line 667
unsigned long int gg112_transfer_info_file__pack(const struct _GG112TransferInfoFile *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_file__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_file__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg112_transfer_info_file__pack_to_buffer
// file packets.pb-c.c line 674
unsigned long int gg112_transfer_info_file__pack_to_buffer(const struct _GG112TransferInfoFile *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_file__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_file__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg112_transfer_info_file__unpack
// file packets.pb-c.c line 682
struct _GG112TransferInfoFile * gg112_transfer_info_file__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg112_transfer_info_file__descriptor, allocator, len, data);
  return (struct _GG112TransferInfoFile *)return_value_protobuf_c_message_unpack$1;
}

// gg112_transfer_info_uin__free_unpacked
// file packets.pb-c.c line 648
void gg112_transfer_info_uin__free_unpacked(struct _GG112TransferInfoUin *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_uin__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_uin__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// gg112_transfer_info_uin__get_packed_size
// file packets.pb-c.c line 618
unsigned long int gg112_transfer_info_uin__get_packed_size(const struct _GG112TransferInfoUin *message)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_uin__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_uin__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// gg112_transfer_info_uin__init
// file packets.pb-c.c line 612
void gg112_transfer_info_uin__init(struct _GG112TransferInfoUin *message)
{
  static struct _GG112TransferInfoUin init_value = { .base={ .descriptor=&gg112_transfer_info_uin__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .dummy1=1u,
    .uin={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 } };
  *message = init_value;
}

// gg112_transfer_info_uin__pack
// file packets.pb-c.c line 624
unsigned long int gg112_transfer_info_uin__pack(const struct _GG112TransferInfoUin *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_uin__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_uin__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// gg112_transfer_info_uin__pack_to_buffer
// file packets.pb-c.c line 631
unsigned long int gg112_transfer_info_uin__pack_to_buffer(const struct _GG112TransferInfoUin *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &gg112_transfer_info_uin__descriptor */
  assert(message->base.descriptor == &gg112_transfer_info_uin__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// gg112_transfer_info_uin__unpack
// file packets.pb-c.c line 639
struct _GG112TransferInfoUin * gg112_transfer_info_uin__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&gg112_transfer_info_uin__descriptor, allocator, len, data);
  return (struct _GG112TransferInfoUin *)return_value_protobuf_c_message_unpack$1;
}

// gg_ack_110
// file handlers.c line 69
static signed int gg_ack_110(struct gg_session *gs, enum _GG110Ack__Type type, unsigned int seq, struct gg_event *ge)
{
  struct _GG110Ack msg = { .base={ .descriptor=&gg110_ack__descriptor, .n_unknown_fields=(unsigned int)0, .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .type=(enum _GG110Ack__Type)0,
    .seq=(unsigned int)0, .dummy1=1u };
  msg.type = type;
  msg.seq = seq;
  signed int return_value_gg_protobuf_send_ex$1;
  return_value_gg_protobuf_send_ex$1=gg_protobuf_send_ex(gs, ge, 0x0086, (void *)&msg, (unsigned long int (*)(const void *))gg110_ack__get_packed_size, (unsigned long int (*)(const void *, unsigned char *))gg110_ack__pack);
  if(return_value_gg_protobuf_send_ex$1 == 0)
    return -1;

  else
    return 0;
}

// gg_add_notify
// file libgadu.c line 2440
signed int gg_add_notify(struct gg_session *sess, unsigned int uin)
{
  signed int return_value_gg_add_notify_ex$1;
  return_value_gg_add_notify_ex$1=gg_add_notify_ex(sess, uin, (char)0x03);
  return return_value_gg_add_notify_ex$1;
}

// gg_add_notify_ex
// file libgadu.c line 2393
signed int gg_add_notify_ex(struct gg_session *sess, unsigned int uin, char type)
{
  gg_debug_session(sess, 8, "** gg_add_notify_ex(%p, %u, %d);\n", sess, uin, type);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  if(sess->protocol_version >= 0x40)
  {
    struct gg_tvbuilder *tvb;
    tvb=gg_tvbuilder_new(sess, (struct gg_event *)(void *)0);
    gg_tvbuilder_expected_size(tvb, (unsigned long int)16);
    gg_tvbuilder_write_uin(tvb, uin);
    gg_tvbuilder_write_uint8(tvb, (unsigned char)type);
    signed int return_value_gg_tvbuilder_send$3;
    return_value_gg_tvbuilder_send$3=gg_tvbuilder_send(tvb, 0x007b);
    if(return_value_gg_tvbuilder_send$3 == 0)
      return -1;

    return 0;
  }

  else
  {
    struct gg_add_remove a;
    a.uin=gg_fix32(uin);
    a.dunno1 = (unsigned char)type;
    signed int return_value_gg_send_packet$4;
    return_value_gg_send_packet$4=gg_send_packet(sess, 0x000d, &a, sizeof(struct gg_add_remove) /*5ul*/ , (void *)0);
    return return_value_gg_send_packet$4;
  }
}

// gg_after_append_formatted_char
// file message.c line 621
static void gg_after_append_formatted_char(unsigned short int *pos, unsigned char attr_flag, unsigned char *old_attr_flag, const unsigned char *color, unsigned char *old_color, unsigned long int imgs_size, unsigned char **format, unsigned long int *format_len)
{
  const unsigned long int color_size = (const unsigned long int)3;
  signed int has_color = 0;
  if(!((0x08 & (signed int)attr_flag) == 0))
    has_color = 1;

  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  signed int return_value_memcmp$1;
  if(!(*old_attr_flag == attr_flag))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(!(has_color == 0))
    {
      return_value_memcmp$1=memcmp((const void *)old_color, (const void *)color, color_size);
      tmp_if_expr$2 = return_value_memcmp$1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    unsigned long int attr_size = sizeof(unsigned short int) /*2ul*/  + sizeof(unsigned char) /*1ul*/  + (has_color != 0 ? color_size : (unsigned long int)0);
    if(!(*format == ((unsigned char *)NULL)))
    {
      *format = *format - (signed long int)imgs_size;
      memmove((void *)(*format + (signed long int)attr_size), (const void *)*format, imgs_size);
      *(*format) = (unsigned char)((signed int)*pos & (signed int)(unsigned short int)0x00ffU);
      *format = *format + (signed long int)1;
      *(*format) = (unsigned char)(((signed int)*pos & (signed int)(unsigned short int)0xff00U) >> 8);
      *format = *format + (signed long int)1;
      *(*format) = attr_flag;
      *format = *format + (signed long int)1;
      if(!(has_color == 0))
      {
        memcpy((void *)*format, (const void *)color, color_size);
        *format = *format + (signed long int)color_size;
      }

      *format = *format + (signed long int)imgs_size;
    }

    if(!(format_len == ((unsigned long int *)NULL)))
      *format_len = *format_len + attr_size;

    *old_attr_flag = attr_flag;
    if(!(has_color == 0))
      memcpy((void *)old_color, (const void *)color, color_size);

  }

  *pos = *pos + (unsigned short int)1;
}

// gg_append
// file message.c line 368
static void gg_append(char *dst, unsigned long int *pos, const void *src, unsigned long int len)
{
  if(!(dst == ((char *)NULL)))
    memcpy((void *)&dst[(signed long int)*pos], src, len);

  *pos = *pos + len;
}

// gg_async_connect_failed
// file events.c line 384
static signed int gg_async_connect_failed(struct gg_session *gs, signed int *res_ptr)
{
  signed int res = 0;
  unsigned int res_size = (unsigned int)sizeof(signed int) /*4ul*/ ;
  if(gs->async == 0)
    return 0;

  else
    if(gs->timeout == 0)
    {
      *res_ptr = 110;
      return 1;
    }

    else
    {
      signed int return_value_getsockopt$2;
      return_value_getsockopt$2=getsockopt(gs->fd, 1, 4, (void *)&res, &res_size);
      if(return_value_getsockopt$2 == -1)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        *res_ptr = *return_value___errno_location$1;
        return 1;
      }

      if(!(res == 0))
      {
        *res_ptr = res;
        return 1;
      }

      else
      {
        *res_ptr = 0;
        return 0;
      }
    }
}

// gg_base64_decode
// file common.c line 514
char * gg_base64_decode(const char *buf)
{
  char *res;
  char *save;
  char *foo;
  char val;
  const char *end;
  unsigned int idx = (unsigned int)0;
  _Bool tmp_if_expr$4;
  char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  if(buf == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(buf);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, (return_value_strlen$1 / (unsigned long int)4 + (unsigned long int)1) * (unsigned long int)3 + (unsigned long int)2);
    res = (char *)return_value_calloc$2;
    save = res;
    if(save == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(buf);
      end = buf + (signed long int)return_value_strlen$3;
      while(!(*buf == 0))
      {
        if(buf >= end)
          break;

        if((signed int)*buf == 13)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)*buf == 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          buf = buf + 1l;

        else
        {
          void *return_value_memchr$5;
          return_value_memchr$5=memchr((const void *)gg_base64_charset, (signed int)*buf, sizeof(char [65l]) /*65ul*/ );
          foo = (char *)return_value_memchr$5;
          if(foo == ((char *)NULL))
            foo = gg_base64_charset;

          val = (char)(signed int)(foo - gg_base64_charset);
          buf = buf + 1l;
          switch(idx)
          {
            case (unsigned int)0:
            {
              *res = *res | (char)((signed int)val << 2);
              break;
            }
            case (unsigned int)1:
            {
              tmp_post$6 = res;
              res = res + 1l;
              *tmp_post$6 = *tmp_post$6 | (char)((signed int)val >> 4);
              *res = *res | (char)((signed int)val << 4);
              break;
            }
            case (unsigned int)2:
            {
              tmp_post$7 = res;
              res = res + 1l;
              *tmp_post$7 = *tmp_post$7 | (char)((signed int)val >> 2);
              *res = *res | (char)((signed int)val << 6);
              break;
            }
            case (unsigned int)3:
            {
              tmp_post$8 = res;
              res = res + 1l;
              *tmp_post$8 = *tmp_post$8 | val;
            }
          }
          idx = idx + 1u;
          idx = idx % (unsigned int)4;
        }
      }
      *res = (char)0;
      return save;
    }
  }
}

// gg_base64_encode
// file common.c line 455
char * gg_base64_encode(const char *buf)
{
  char *out;
  char *res;
  unsigned int i = (unsigned int)0;
  unsigned int j = (unsigned int)0;
  unsigned int k = (unsigned int)0;
  unsigned int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  len = (unsigned int)return_value_strlen$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)((len / (unsigned int)3 + (unsigned int)1) * (unsigned int)4 + (unsigned int)2));
  out = (char *)return_value_malloc$2;
  res = out;
  unsigned int tmp_post$3;
  char *tmp_post$4;
  if(res == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; len >= j; i = i + 1u)
    {
      switch(i % (unsigned int)4)
      {
        case (unsigned int)0:
        {
          k = (unsigned int)(((signed int)buf[(signed long int)j] & 252) >> 2);
          break;
        }
        case (unsigned int)1:
        {
          if(!(j >= len))
            k = (unsigned int)(((signed int)buf[(signed long int)j] & 3) << 4 | ((signed int)buf[(signed long int)(j + (unsigned int)1)] & 240) >> 4);

          else
            k = (unsigned int)(((signed int)buf[(signed long int)j] & 3) << 4);
          j = j + 1u;
          break;
        }
        case (unsigned int)2:
        {
          if(!(j >= len))
            k = (unsigned int)(((signed int)buf[(signed long int)j] & 15) << 2 | ((signed int)buf[(signed long int)(j + (unsigned int)1)] & 192) >> 6);

          else
            k = (unsigned int)(((signed int)buf[(signed long int)j] & 15) << 2);
          j = j + 1u;
          break;
        }
        case (unsigned int)3:
        {
          tmp_post$3 = j;
          j = j + 1u;
          k = (unsigned int)((signed int)buf[(signed long int)tmp_post$3] & 63);
        }
      }
      tmp_post$4 = out;
      out = out + 1l;
      *tmp_post$4 = gg_base64_charset[(signed long int)k];
    }
    if(!(i % 4u == 0u))
    {
      j = (unsigned int)0;
      for( ; !(j >= 4u + -(i % 4u)); out = out + 1l)
      {
        *out = (char)61;
        j = j + 1u;
      }
    }

    *out = (char)0;
    return res;
  }
}

// gg_change_info
// file obsolete.c line 205
struct gg_http * gg_change_info(unsigned int uin, const char *passwd, struct gg_change_info_request *request, signed int async)
{
  gg_debug(16, "// gg_change_info() is obsolete. use gg_pubdir50() instead\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_change_info_request_free
// file obsolete.c line 219
void gg_change_info_request_free(struct gg_change_info_request *r)
{
  ;
}

// gg_change_info_request_new
// file obsolete.c line 212
struct gg_change_info_request * gg_change_info_request_new(const char *first_name, const char *last_name, const char *nickname, const char *email, signed int born, signed int gender, const char *city)
{
  return (struct gg_change_info_request *)(void *)0;
}

// gg_change_passwd
// file obsolete.c line 168
struct gg_http * gg_change_passwd(unsigned int uin, const char *passwd, const char *newpasswd, const char *newemail, signed int async)
{
  gg_debug(16, "// gg_change_passwd() is obsolete. use gg_change_passwd4() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_change_passwd2
// file obsolete.c line 175
struct gg_http * gg_change_passwd2(unsigned int uin, const char *passwd, const char *newpasswd, const char *email, const char *newemail, signed int async)
{
  gg_debug(16, "// gg_change_passwd2() is obsolete. use gg_change_passwd4() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_change_passwd3
// file obsolete.c line 184
struct gg_http * gg_change_passwd3(unsigned int uin, const char *passwd, const char *newpasswd, const char *qa, signed int async)
{
  gg_debug(16, "// gg_change_passwd3() is obsolete. use gg_change_passwd4() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_change_passwd4
// file pubdir.c line 322
struct gg_http * gg_change_passwd4(unsigned int uin, const char *email, const char *passwd, const char *newpasswd, const char *tokenid, const char *tokenval, signed int async)
{
  struct gg_http *h;
  char *form;
  char *query;
  char *__email;
  char *__fmpwd;
  char *__pwd;
  char *__tokenid;
  char *__tokenval;
  if(email == ((const char *)NULL) || newpasswd == ((const char *)NULL) || passwd == ((const char *)NULL) || tokenid == ((const char *)NULL) || tokenval == ((const char *)NULL) || uin == 0u)
  {
    gg_debug(16, "=> change, NULL parameter\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (struct gg_http *)(void *)0;
  }

  __fmpwd=gg_urlencode(passwd);
  __pwd=gg_urlencode(newpasswd);
  __email=gg_urlencode(email);
  __tokenid=gg_urlencode(tokenid);
  __tokenval=gg_urlencode(tokenval);
  if(__email == ((char *)NULL) || __fmpwd == ((char *)NULL) || __pwd == ((char *)NULL) || __tokenid == ((char *)NULL) || __tokenval == ((char *)NULL))
  {
    gg_debug(16, "=> change, not enough memory for form fields\n");
    free((void *)__fmpwd);
    free((void *)__pwd);
    free((void *)__email);
    free((void *)__tokenid);
    free((void *)__tokenval);
    return (struct gg_http *)(void *)0;
  }

  else
  {
    signed int return_value_gg_http_hash$2;
    return_value_gg_http_hash$2=gg_http_hash("ss", email, newpasswd);
    form=gg_saprintf("fmnumber=%d&fmpwd=%s&pwd=%s&email=%s&tokenid=%s&tokenval=%s&code=%u", uin, __fmpwd, __pwd, __email, __tokenid, __tokenval, return_value_gg_http_hash$2);
    if(form == ((char *)NULL))
    {
      gg_debug(16, "=> change, not enough memory for form fields\n");
      free((void *)__fmpwd);
      free((void *)__pwd);
      free((void *)__email);
      free((void *)__tokenid);
      free((void *)__tokenval);
      return (struct gg_http *)(void *)0;
    }

    else
    {
      free((void *)__fmpwd);
      free((void *)__pwd);
      free((void *)__email);
      free((void *)__tokenid);
      free((void *)__tokenval);
      gg_debug(16, "=> change, %s\n", form);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(form);
      query=gg_saprintf("Host: register.gadu-gadu.pl\r\nContent-Type: application/x-www-form-urlencoded\r\nUser-Agent: Mozilla/4.7 [en] (Win98; I)\r\nContent-Length: %d\r\nPragma: no-cache\r\n\r\n%s", (signed int)return_value_strlen$3, form);
      free((void *)form);
      if(query == ((char *)NULL))
      {
        gg_debug(16, "=> change, not enough memory for query\n");
        return (struct gg_http *)(void *)0;
      }

      else
      {
        h=gg_http_connect("register.gadu-gadu.pl", 80, async, "POST", "/appsvc/fmregister3.asp", query);
        if(h == ((struct gg_http *)NULL))
        {
          gg_debug(16, "=> change, gg_http_connect() failed mysteriously\n");
          free((void *)query);
          return (struct gg_http *)(void *)0;
        }

        else
        {
          h->type = 6;
          free((void *)query);
          h->callback = gg_pubdir_watch_fd;
          h->destroy = gg_pubdir_free;
          if(async == 0)
            gg_pubdir_watch_fd(h);

          return h;
        }
      }
    }
  }
}

// gg_change_status
// file libgadu.c line 1304
signed int gg_change_status(struct gg_session *sess, signed int status)
{
  gg_debug_session(sess, 8, "** gg_change_status(%p, %d);\n", sess, status);
  signed int return_value_gg_change_status_descr$1;
  return_value_gg_change_status_descr$1=gg_change_status_descr(sess, status, (const char *)(void *)0);
  return return_value_gg_change_status_descr$1;
}

// gg_change_status_descr
// file libgadu.c line 1322
signed int gg_change_status_descr(struct gg_session *sess, signed int status, const char *descr)
{
  struct gg_new_status80 p;
  char *gen_descr = (char *)(void *)0;
  signed int descr_len = 0;
  signed int descr_null_len = 0;
  signed int res;
  gg_debug_session(sess, 8, "** gg_change_status_descr(%p, %d, \"%s\");\n", sess, status, descr);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  sess->status = status;
  if(!(descr == ((const char *)NULL)))
  {
    if((signed int)sess->encoding == GG_ENCODING_UTF8)
      goto __CPROVER_DUMP_L3;

    gen_descr=gg_encoding_convert(descr, (enum anonymous$3)GG_ENCODING_CP1250, (enum anonymous$3)GG_ENCODING_UTF8, -1, -1);
    descr = gen_descr;
    if(!(gen_descr == ((char *)NULL)))
      goto __CPROVER_DUMP_L3;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!(descr == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(descr);
      descr_len = (signed int)return_value_strlen$3;
      if(descr_len >= 256)
        descr_len = 255;

    }

    else
      descr = "";
    p.status=gg_fix32((unsigned int)status);
    p.flags=gg_fix32((unsigned int)sess->status_flags);
    p.description_size=gg_fix32((unsigned int)descr_len);
    if(sess->protocol_version >= 0x40)
    {
      p.flags=gg_fix32((unsigned int)0x00000014);
      descr_null_len = 1;
    }

    res=gg_send_packet(sess, 0x0038, &p, sizeof(struct gg_new_status80) /*12ul*/ , descr, descr_len, (const void *)"\0", descr_null_len, (void *)0);
    free((void *)gen_descr);
    if((0xff & status) == 0x0001 || (0xff & status) == 0x0015)
    {
      sess->state = GG_STATE_DISCONNECTING;
      sess->timeout = 5;
    }

    return res;
  }
}

// gg_change_status_descr_time
// file libgadu.c line 1397
signed int gg_change_status_descr_time(struct gg_session *sess, signed int status, const char *descr, signed int ts)
{
  gg_debug_session(sess, 8, "** gg_change_status_descr_time(%p, %d, \"%s\", %d);\n", sess, status, descr, ts);
  signed int return_value_gg_change_status_descr$1;
  return_value_gg_change_status_descr$1=gg_change_status_descr(sess, status, descr);
  return return_value_gg_change_status_descr$1;
}

// gg_change_status_flags
// file libgadu.c line 1419
signed int gg_change_status_flags(struct gg_session *sess, signed int flags)
{
  gg_debug_session(sess, 8, "** gg_change_status_flags(%p, 0x%08x);\n", sess, flags);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  sess->status_flags = flags;
  return 0;
}

// gg_chat_create
// file libgadu.c line 2688
signed int gg_chat_create(struct gg_session *gs)
{
  struct gg_chat_create pkt;
  signed int seq;
  signed int return_value_gg_required_proto$1;
  return_value_gg_required_proto$1=gg_required_proto(gs, 0x40);
  if(return_value_gg_required_proto$1 == 0)
    return -1;

  else
  {
    gs->seq = gs->seq + 1;
    seq = gs->seq;
    pkt.seq=gg_fix32((unsigned int)seq);
    pkt.dummy = (unsigned int)0;
    signed int return_value_gg_send_packet$2;
    return_value_gg_send_packet$2=gg_send_packet(gs, 0x0047, &pkt, sizeof(struct gg_chat_create) /*8ul*/ , (void *)0);
    if(return_value_gg_send_packet$2 == -1)
      return -1;

    else
      return seq;
  }
}

// gg_chat_find
// file common.c line 739
struct _gg_chat_list * gg_chat_find(struct gg_session *sess, unsigned long int id)
{
  struct _gg_chat_list *chat_list = sess->private_data->chat_list;
  for( ; !(chat_list == ((struct _gg_chat_list *)NULL)); chat_list = chat_list->next)
    if(chat_list->id == id)
      return chat_list;

  return (struct _gg_chat_list *)(void *)0;
}

// gg_chat_invite
// file libgadu.c line 2720
signed int gg_chat_invite(struct gg_session *gs, unsigned long int id, unsigned int *participants, unsigned int participants_count)
{
  struct gg_chat_invite pkt;
  signed int seq;
  signed int ret;
  unsigned int i;
  /* gg_chat_invite::1::tag-gg_chat_participant */
struct gg_chat_participant
{
  // uin
  unsigned int uin;
  // dummy
  unsigned int dummy;
} __attribute__ ((__packed__));

/* */
  ;
  struct gg_chat_participant *participants_list;
  unsigned long int participants_list_size;
  signed int return_value_gg_required_proto$1;
  return_value_gg_required_proto$1=gg_required_proto(gs, 0x40);
  if(return_value_gg_required_proto$1 == 0)
    return -1;

  else
    if(participants_count == 0u || (unsigned long int)participants_count >= 536870911ul)
      return -1;

    else
    {
      participants_list_size = sizeof(struct gg_chat_participant) /*8ul*/  * (unsigned long int)participants_count;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(participants_list_size);
      participants_list = (struct gg_chat_participant *)return_value_malloc$2;
      if(participants_list == ((struct gg_chat_participant *)NULL))
        return -1;

      else
      {
        gs->seq = gs->seq + 1;
        seq = gs->seq;
        pkt.id=gg_fix64(id);
        pkt.seq=gg_fix32((unsigned int)seq);
        pkt.participants_count=gg_fix32(participants_count);
        i = (unsigned int)0;
        for( ; !(i >= participants_count); i = i + 1u)
        {
          (participants_list + (signed long int)i)->uin=gg_fix32(participants[(signed long int)i]);
          (participants_list + (signed long int)i)->dummy=gg_fix32((unsigned int)0x1e);
        }
        ret=gg_send_packet(gs, 0x0090, &pkt, sizeof(struct gg_chat_invite) /*16ul*/ , participants_list, participants_list_size, (void *)0);
        free((void *)participants_list);
        if(ret == -1)
          return -1;

        else
          return seq;
      }
    }
}

// gg_chat_leave
// file libgadu.c line 2780
signed int gg_chat_leave(struct gg_session *gs, unsigned long int id)
{
  struct gg_chat_leave pkt;
  signed int seq;
  signed int return_value_gg_required_proto$1;
  return_value_gg_required_proto$1=gg_required_proto(gs, 0x40);
  if(return_value_gg_required_proto$1 == 0)
    return -1;

  else
  {
    gs->seq = gs->seq + 1;
    seq = gs->seq;
    pkt.id=gg_fix64(id);
    pkt.seq=gg_fix32((unsigned int)seq);
    signed int return_value_gg_send_packet$2;
    return_value_gg_send_packet$2=gg_send_packet(gs, 0x0052, &pkt, sizeof(struct gg_chat_leave) /*12ul*/ , (void *)0);
    if(return_value_gg_send_packet$2 == -1)
      return -1;

    else
      return seq;
  }
}

// gg_chat_send_message
// file libgadu.c line 2811
signed int gg_chat_send_message(struct gg_session *gs, unsigned long int id, const char *message, signed int is_html)
{
  signed int return_value_gg_required_proto$1;
  return_value_gg_required_proto$1=gg_required_proto(gs, 0x40);
  if(return_value_gg_required_proto$1 == 0)
    return -1;

  else
  {
    signed int return_value_gg_send_message_110$2;
    return_value_gg_send_message_110$2=gg_send_message_110(gs, (unsigned int)0, id, message, is_html);
    return return_value_gg_send_message_110$2;
  }
}

// gg_chat_update
// file common.c line 763
signed int gg_chat_update(struct gg_session *sess, unsigned long int id, unsigned int version, const unsigned int *participants, unsigned int participants_count)
{
  struct _gg_chat_list *chat;
  unsigned int *participants_new;
  if((unsigned long int)participants_count >= 1073741823ul)
    return -1;

  else
  {
    chat=gg_chat_find(sess, id);
    if(chat == ((struct _gg_chat_list *)NULL))
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct _gg_chat_list) /*32ul*/ );
      chat = (struct _gg_chat_list *)return_value_malloc$1;
      if(chat == ((struct _gg_chat_list *)NULL))
        return -1;

      memset((void *)chat, 0, sizeof(struct _gg_chat_list) /*32ul*/ );
      chat->id = id;
      chat->next = sess->private_data->chat_list;
      sess->private_data->chat_list = chat;
    }

    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)chat->participants, sizeof(unsigned int) /*4ul*/  * (unsigned long int)participants_count);
    participants_new = (unsigned int *)return_value_realloc$2;
    if(participants_new == ((unsigned int *)NULL))
      return -1;

    else
    {
      chat->version = version;
      chat->participants = participants_new;
      chat->participants_count = participants_count;
      memcpy((void *)chat->participants, (const void *)participants, sizeof(unsigned int) /*4ul*/  * (unsigned long int)participants_count);
      return 0;
    }
  }
}

// gg_chomp
// file common.c line 320
void gg_chomp(char *line)
{
  signed int len;
  if(!(line == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(line);
    len = (signed int)return_value_strlen$1;
    if(len >= 1)
    {
      if((signed int)line[(signed long int)(len + -1)] == 10)
      {
        len = len - 1;
        line[(signed long int)len] = (char)0;
      }

    }

    if(len >= 1)
    {
      if((signed int)line[(signed long int)(len + -1)] == 13)
      {
        len = len - 1;
        line[(signed long int)len] = (char)0;
      }

    }

  }

}

// gg_close
// file ../include/internal.h line 183
void gg_close(struct gg_session *sess)
{
  struct gg_session_private *p = sess->private_data;
  signed int errno_copy;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errno_copy = *return_value___errno_location$1;
  if(p->socket_is_external == 0)
  {
    if(!(sess->fd == -1))
      close(sess->fd);

  }

  else
  {
    /* assertion p->socket_manager_type != GG_SOCKET_MANAGER_TYPE_INTERNAL */
    assert((signed int)p->socket_manager_type != GG_SOCKET_MANAGER_TYPE_INTERNAL);
    if(!(p->socket_handle == NULL))
      p->socket_manager.close_cb(p->socket_manager.cb_data, p->socket_handle);

    p->socket_is_external = 0;
  }
  sess->fd = -1;
  p->socket_handle = (void *)0;
  while(!(p->event_queue == ((struct _gg_eventqueue *)NULL)))
  {
    struct _gg_eventqueue *gg_close$$1$$3$$next = p->event_queue->next;
    gg_event_free(p->event_queue->event);
    free((void *)p->event_queue);
    p->event_queue = gg_close$$1$$3$$next;
  }
  while(!(p->imgout_queue == ((struct _gg_imgout_queue_t *)NULL)))
  {
    struct _gg_imgout_queue_t *next = p->imgout_queue->next;
    free((void *)p->imgout_queue);
    p->imgout_queue = next;
  }
  if(!(p->dummyfds_created == 0))
  {
    close(p->dummyfds[(signed long int)0]);
    close(p->dummyfds[(signed long int)1]);
    p->dummyfds_created = 0;
  }

  gg_compat_message_cleanup(sess);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = errno_copy;
}

// gg_compat_feature_is_enabled
// file libgadu.c line 2890
signed int gg_compat_feature_is_enabled(struct gg_session *sess, enum anonymous$18 feature)
{
  enum anonymous$5 level;
  if(sess == ((struct gg_session *)NULL))
    return 0;

  else
  {
    level = sess->private_data->compatibility;
    if((signed int)feature == GG_COMPAT_FEATURE_ACK_EVENT || (signed int)feature == GG_COMPAT_FEATURE_LEGACY_CONFER)
      return (signed int)((signed int)level < GG_COMPAT_1_12_0);

    return 0;
  }
}

// gg_compat_find_sent_message
// file libgadu.c line 2908
static struct _gg_msg_list * gg_compat_find_sent_message(struct gg_session *sess, signed int seq, signed int remove)
{
  struct gg_session_private *p = sess->private_data;
  struct _gg_msg_list *it;
  struct _gg_msg_list *previous = (struct _gg_msg_list *)(void *)0;
  it = p->sent_messages;
  for( ; !(it == ((struct _gg_msg_list *)NULL)); it = it->next)
    if(it->seq == seq)
      break;

    else
      previous = it;
  if(!(it == ((struct _gg_msg_list *)NULL)) && !(remove == 0))
  {
    if(previous == ((struct _gg_msg_list *)NULL))
      p->sent_messages = it->next;

    else
      previous->next = it->next;
  }

  return it;
}

// gg_compat_message_ack
// file ../include/internal.h line 187
void gg_compat_message_ack(struct gg_session *sess, signed int seq)
{
  struct _gg_msg_list *sm;
  unsigned long int i;
  if(sess->protocol_version >= 0x40)
  {
    signed int return_value_gg_compat_feature_is_enabled$1;
    return_value_gg_compat_feature_is_enabled$1=gg_compat_feature_is_enabled(sess, (enum anonymous$18)GG_COMPAT_FEATURE_ACK_EVENT);
    if(!(return_value_gg_compat_feature_is_enabled$1 == 0))
    {
      sm=gg_compat_find_sent_message(sess, seq, 1);
      if(!(sm == ((struct _gg_msg_list *)NULL)))
      {
        i = (unsigned long int)0;
        for( ; !(i >= sm->recipients_count); i = i + 1ul)
        {
          struct gg_event *qev;
          qev=gg_eventqueue_add(sess);
          qev->type = GG_EVENT_ACK;
          qev->event.ack.status = 0x0002;
          qev->event.ack.recipient = sm->recipients[(signed long int)i];
          qev->event.ack.seq = seq;
        }
        free((void *)sm->recipients);
        free((void *)sm);
      }

    }

  }

}

// gg_compat_message_cleanup
// file libgadu.c line 2930
static void gg_compat_message_cleanup(struct gg_session *sess)
{
  struct gg_session_private *p = sess->private_data;
  while(!(p->sent_messages == ((struct _gg_msg_list *)NULL)))
  {
    struct _gg_msg_list *next = p->sent_messages->next;
    free((void *)p->sent_messages->recipients);
    free((void *)p->sent_messages);
    p->sent_messages = next;
  }
}

// gg_compat_message_sent
// file libgadu.c line 2942
static void gg_compat_message_sent(struct gg_session *sess, signed int seq, unsigned long int recipients_count, unsigned int *recipients)
{
  struct gg_session_private *p = sess->private_data;
  struct _gg_msg_list *sm;
  unsigned int *new_recipients;
  unsigned long int old_count;
  unsigned long int i;
  if(sess->protocol_version >= 0x40)
  {
    signed int return_value_gg_compat_feature_is_enabled$1;
    return_value_gg_compat_feature_is_enabled$1=gg_compat_feature_is_enabled(sess, (enum anonymous$18)GG_COMPAT_FEATURE_ACK_EVENT);
    if(!(return_value_gg_compat_feature_is_enabled$1 == 0))
    {
      sm=gg_compat_find_sent_message(sess, seq, 0);
      if(sm == ((struct _gg_msg_list *)NULL))
      {
        void *return_value_gg_new0$2;
        return_value_gg_new0$2=gg_new0(sizeof(struct _gg_msg_list) /*32ul*/ );
        sm = (struct _gg_msg_list *)return_value_gg_new0$2;
        if(sm == ((struct _gg_msg_list *)NULL))
          goto __CPROVER_DUMP_L8;

        sm->next = p->sent_messages;
        p->sent_messages = sm;
      }

      sm->seq = seq;
      old_count = sm->recipients_count;
      sm->recipients_count = sm->recipients_count + recipients_count;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)sm->recipients, sizeof(unsigned int) /*4ul*/  * sm->recipients_count);
      new_recipients = (unsigned int *)return_value_realloc$3;
      if(new_recipients == ((unsigned int *)NULL))
        gg_debug_session(sess, 16 | 128, "// gg_compat_message_sent() not enough memory\n");

      else
      {
        sm->recipients = new_recipients;
        i = (unsigned long int)0;
        for( ; !(i >= recipients_count); i = i + 1ul)
          sm->recipients[(signed long int)(old_count + i)] = recipients[(signed long int)i];
      }
    }

  }


__CPROVER_DUMP_L8:
  ;
}

// gg_connect
// file common.c line 247
signed int gg_connect(void *addr, signed int port, signed int async)
{
  signed int sock;
  signed int errno2;
  struct sockaddr_in sin;
  struct in_addr *a = (struct in_addr *)addr;
  struct sockaddr_in myaddr;
  char *return_value_inet_ntoa$1;
  return_value_inet_ntoa$1=inet_ntoa(*a);
  gg_debug(8, "** gg_connect(%s, %d, %d);\n", return_value_inet_ntoa$1, port, async);
  sock=socket(2, 1, 6);
  if(sock == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    gg_debug(16, "// gg_connect() socket() failed (errno=%d, %s)\n", *return_value___errno_location$2, return_value_strerror$4);
    return -1;
  }

  memset((void *)&myaddr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  myaddr.sin_family = (unsigned short int)2;
  myaddr.sin_addr.s_addr = (unsigned int)gg_local_ip;
  signed int return_value_bind$10;
  return_value_bind$10=bind(sock, (struct sockaddr *)&myaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(return_value_bind$10 == -1)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    gg_debug(16, "// gg_connect() bind() failed (errno=%d, %s)\n", *return_value___errno_location$5, return_value_strerror$7);
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    errno2 = *return_value___errno_location$8;
    close(sock);
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    *return_value___errno_location$9 = errno2;
    return -1;
  }

  if(!(async == 0))
  {
    signed int return_value_gg_fd_set_nonblocking$16;
    return_value_gg_fd_set_nonblocking$16=gg_fd_set_nonblocking$link3(sock);
    if(return_value_gg_fd_set_nonblocking$16 == 0)
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      char *return_value_strerror$13;
      return_value_strerror$13=strerror(*return_value___errno_location$12);
      gg_debug(16, "// gg_connect() can't set nonblocking (errno=%d, %s)\n", *return_value___errno_location$11, return_value_strerror$13);
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      errno2 = *return_value___errno_location$14;
      close(sock);
      signed int *return_value___errno_location$15;
      return_value___errno_location$15=__errno_location();
      *return_value___errno_location$15 = errno2;
      return -1;
    }

  }

  memset((void *)&sin, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  sin.sin_port=htons((unsigned short int)port);
  sin.sin_family = (unsigned short int)2;
  sin.sin_addr.s_addr = a->s_addr;
  signed int return_value_connect$25;
  return_value_connect$25=connect(sock, (struct sockaddr *)&sin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  _Bool tmp_if_expr$23;
  signed int *return_value___errno_location$22;
  if(return_value_connect$25 == -1)
  {
    signed int *return_value___errno_location$24;
    return_value___errno_location$24=__errno_location();
    if(!(*return_value___errno_location$24 == 0))
    {
      if(async == 0)
        tmp_if_expr$23 = (_Bool)1;

      else
      {
        return_value___errno_location$22=__errno_location();
        tmp_if_expr$23 = *return_value___errno_location$22 != 115 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$23)
      {
        signed int *return_value___errno_location$17;
        return_value___errno_location$17=__errno_location();
        signed int *return_value___errno_location$18;
        return_value___errno_location$18=__errno_location();
        char *return_value_strerror$19;
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        gg_debug(16, "// gg_connect() connect() failed (errno=%d, %s)\n", *return_value___errno_location$17, return_value_strerror$19);
        signed int *return_value___errno_location$20;
        return_value___errno_location$20=__errno_location();
        errno2 = *return_value___errno_location$20;
        close(sock);
        signed int *return_value___errno_location$21;
        return_value___errno_location$21=__errno_location();
        *return_value___errno_location$21 = errno2;
        return -1;
      }

    }

    gg_debug(16, "// gg_connect() connect() in progress\n");
  }

  return sock;
}

// gg_connection_failure
// file common.c line 801
void gg_connection_failure(struct gg_session *gs, struct gg_event *ge, enum gg_failure_t failure)
{
  gg_close(gs);
  if(!(ge == ((struct gg_event *)NULL)))
  {
    ge->type = GG_EVENT_CONN_FAILED;
    ge->event.failure = failure;
  }

  gs->state = GG_STATE_IDLE;
}

// gg_crc32
// file common.c line 689
unsigned int gg_crc32(unsigned int crc, const unsigned char *buf, signed int len)
{
  signed int tmp_post$1;
  const unsigned char *tmp_post$2;
  if(buf == ((const unsigned char *)NULL) || !(len >= 0))
    return crc;

  else
  {
    crc = crc ^ (unsigned int)0xffffffffL;
    do
    {
      tmp_post$1 = len;
      len = len - 1;
      if(tmp_post$1 == 0)
        break;

      tmp_post$2 = buf;
      buf = buf + 1l;
      crc = crc >> 8 ^ gg_crc32_table[(signed long int)((crc ^ (unsigned int)*tmp_post$2) & (unsigned int)0xff)];
    }
    while((_Bool)1);
    return (unsigned int)((signed long int)crc ^ 0xffffffffL);
  }
}

// gg_dcc7_accept
// file dcc7.c line 572
signed int gg_dcc7_accept(struct gg_dcc7 *dcc, unsigned int offset)
{
  struct gg_dcc7_accept pkt;
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_accept(%p, %d)\n", dcc, offset);
  _Bool tmp_if_expr$4;
  if(dcc == ((struct gg_dcc7 *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(dcc->sess != ((struct gg_session *)NULL)) ? (_Bool)1 : (_Bool)0;
  struct gg_session *tmp_if_expr$2;
  if(tmp_if_expr$4)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_accept() invalid parameters\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 14;
    return -1;
  }

  memset((void *)&pkt, 0, sizeof(struct gg_dcc7_accept) /*20ul*/ );
  pkt.uin=gg_fix32(dcc->peer_uin);
  pkt.id = dcc->cid;
  pkt.offset=gg_fix32(offset);
  signed int return_value_gg_send_packet$5;
  return_value_gg_send_packet$5=gg_send_packet(dcc->sess, 0x21, &pkt, sizeof(struct gg_dcc7_accept) /*20ul*/ , (void *)0);
  if(return_value_gg_send_packet$5 == -1)
    return -1;

  else
  {
    dcc->offset = offset;
    signed int return_value_gg_dcc7_listen_and_send_info$6;
    return_value_gg_dcc7_listen_and_send_info$6=gg_dcc7_listen_and_send_info(dcc);
    return return_value_gg_dcc7_listen_and_send_info$6;
  }
}

// gg_dcc7_connect
// file dcc7.c line 190
static signed int gg_dcc7_connect(struct gg_dcc7 *dcc)
{
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_connect(%p)\n", dcc);
  struct gg_session *tmp_if_expr$2;
  if(dcc == ((struct gg_dcc7 *)NULL))
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_connect() invalid parameters\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  dcc->fd=gg_connect((void *)&dcc->remote_addr, (signed int)dcc->remote_port, 1);
  struct gg_session *tmp_if_expr$4;
  if(dcc->fd == -1)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$4 = dcc->sess;

    else
      tmp_if_expr$4 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$4, 16, "// gg_dcc7_connect() connection failed\n");
    return -1;
  }

  else
  {
    dcc->state = GG_STATE_CONNECTING;
    dcc->check = 1;
    dcc->timeout = 10;
    dcc->soft_timeout = 1;
    return 0;
  }
}

// gg_dcc7_free
// file dcc7.c line 1638
void gg_dcc7_free(struct gg_dcc7 *dcc)
{
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_free(%p)\n", dcc);
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
  {
    if(!(dcc->fd == -1))
      close(dcc->fd);

    if(!(dcc->file_fd == -1))
      close(dcc->file_fd);

    if(!(dcc->sess == ((struct gg_session *)NULL)))
      gg_dcc7_session_remove(dcc->sess, dcc);

    free((void *)dcc->relay_list);
    free((void *)dcc);
  }

}

// gg_dcc7_get_relay_addr
// file dcc7.c line 159
static signed int gg_dcc7_get_relay_addr(struct gg_dcc7 *dcc)
{
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_get_relay_addr(%p)\n", dcc);
  _Bool tmp_if_expr$4;
  if(dcc == ((struct gg_dcc7 *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = dcc->sess == (struct gg_session *)(void *)0 ? (_Bool)1 : (_Bool)0;
  struct gg_session *tmp_if_expr$2;
  if(tmp_if_expr$4)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_get_relay_addr() invalid parameters\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  signed int return_value;
  return_value=dcc->sess->resolver_start(&dcc->fd, &dcc->resolver, "relay.gadu-gadu.pl");
  struct gg_session *tmp_if_expr$5;
  if(return_value == -1)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$5 = dcc->sess;

    else
      tmp_if_expr$5 = (struct gg_session *)(void *)0;
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    gg_debug_session(tmp_if_expr$5, 16, "// gg_dcc7_get_relay_addr() resolving failed (errno=%d, %s)\n", *return_value___errno_location$6, return_value_strerror$8);
    return -1;
  }

  dcc->state = GG_STATE_RESOLVING_RELAY;
  dcc->check = 2;
  dcc->timeout = 30;
  return 0;
}

// gg_dcc7_handle_accept
// file dcc7.c line 693
signed int gg_dcc7_handle_accept(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len)
{
  struct gg_dcc7_accept *p = (struct gg_dcc7_accept *)payload;
  struct gg_dcc7 *dcc;
  gg_debug_session(sess, 8, "** gg_dcc7_handle_accept(%p, %p, %p, %d)\n", sess, e, payload, len);
  unsigned int return_value_gg_fix32$1;
  return_value_gg_fix32$1=gg_fix32(p->uin);
  dcc=gg_dcc7_session_find(sess, p->id, return_value_gg_fix32$1);
  if(dcc == ((struct gg_dcc7 *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_handle_accept() unknown dcc session\n");
    e->type = GG_EVENT_DCC7_ERROR;
    e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
    return 0;
  }

  else
    if(!(dcc->state == GG_STATE_WAITING_FOR_ACCEPT))
    {
      gg_debug_session(sess, 16, "// gg_dcc7_handle_accept() invalid state\n");
      e->type = GG_EVENT_DCC7_ERROR;
      e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
      return 0;
    }

    else
    {
      dcc->offset=gg_fix32(p->offset);
      dcc->state = GG_STATE_WAITING_FOR_INFO;
      return 0;
    }
}

// gg_dcc7_handle_id
// file dcc7.c line 637
signed int gg_dcc7_handle_id(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len)
{
  struct gg_dcc7_id_reply *p = (struct gg_dcc7_id_reply *)payload;
  struct gg_dcc7 *tmp;
  gg_debug_session(sess, 8, "** gg_dcc7_handle_id(%p, %p, %p, %d)\n", sess, e, payload, len);
  tmp = sess->dcc7_list;
  _Bool tmp_if_expr$2;
  unsigned int return_value_gg_fix32$1;
  for( ; !(tmp == ((struct gg_dcc7 *)NULL)); tmp = tmp->next)
  {
    gg_debug_session(sess, 16, "// checking dcc %p, state %d, type %d\n", tmp, tmp->state, tmp->dcc_type);
    if(!(tmp->state == GG_STATE_REQUESTING_ID))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_gg_fix32$1=gg_fix32(p->type);
      tmp_if_expr$2 = tmp->dcc_type != (signed int)return_value_gg_fix32$1 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$2)
    {
      tmp->cid = p->id;
      if(tmp->dcc_type == 0x00000004)
      {
        struct gg_dcc7_new s;
        memset((void *)&s, 0, sizeof(struct gg_dcc7_new) /*303ul*/ );
        s.id = tmp->cid;
        s.type=gg_fix32((unsigned int)0x00000004);
        s.uin_from=gg_fix32(tmp->uin);
        s.uin_to=gg_fix32(tmp->peer_uin);
        s.size=gg_fix32(tmp->size);
        char dummy[1l];
        (void)dummy;
        memcpy((void *)(char *)s.filename, (const void *)(char *)tmp->filename, sizeof(unsigned char [255l]) /*255ul*/ );
        tmp->state = GG_STATE_WAITING_FOR_ACCEPT;
        tmp->timeout = 300;
        signed int return_value_gg_send_packet$3;
        return_value_gg_send_packet$3=gg_send_packet(sess, 0x20, &s, sizeof(struct gg_dcc7_new) /*303ul*/ , (void *)0);
        return return_value_gg_send_packet$3;
      }

    }

  }
  return 0;
}

// gg_dcc7_handle_info
// file dcc7.c line 733
signed int gg_dcc7_handle_info(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len)
{
  struct gg_dcc7_info *p = (struct gg_dcc7_info *)payload;
  struct gg_dcc7 *dcc;
  char *tmp;
  gg_debug_session(sess, 8, "** gg_dcc7_handle_info(%p, %p, %p, %d)\n", sess, e, payload, len);
  gg_debug_session(sess, 8, "// gg_dcc7_handle_info() received address: %s, hash: %s\n", (const void *)p->info, (const void *)p->hash);
  unsigned int return_value_gg_fix32$1;
  return_value_gg_fix32$1=gg_fix32(p->uin);
  dcc=gg_dcc7_session_find(sess, p->id, return_value_gg_fix32$1);
  _Bool tmp_if_expr$3;
  signed int return_value_atoi$2;
  signed int return_value_gg_dcc7_get_relay_addr$5;
  struct gg_session *tmp_if_expr$4;
  if(dcc == ((struct gg_dcc7 *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_handle_info() unknown dcc session\n");
    return 0;
  }

  else
    if(dcc->state == GG_STATE_CONNECTED)
    {
      gg_debug_session(sess, 16, "// gg_dcc7_handle_info() state is already connected\n");
      return 0;
    }

    else
    {
      switch(p->type)
      {
        case (unsigned int)0x00000001:
        {
          dcc->remote_addr=inet_addr(p->info);
          if(dcc->remote_addr == 0xffffffff)
          {
            gg_debug_session(sess, 16, "// gg_dcc7_handle_info() invalid IP address\n");
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return 0;
          }

          tmp=strchr(p->info, 32);
          if(tmp == ((char *)NULL))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value_atoi$2=atoi(tmp + (signed long int)1);
            dcc->remote_port = (unsigned short int)return_value_atoi$2;
            tmp_if_expr$3 = !(dcc->remote_port != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
          {
            gg_debug_session(sess, 16, "// gg_dcc7_handle_info() invalid IP port\n");
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return 0;
          }

          if(dcc->state == GG_STATE_WAITING_FOR_INFO)
          {
            gg_debug_session(sess, 16, "// gg_dcc7_handle_info() waiting for info so send one\n");
            gg_dcc7_listen_and_send_info(dcc);
            e->type = GG_EVENT_DCC7_PENDING;
            e->event.dcc7_pending.dcc7 = dcc;
            return 0;
          }

          break;
        }
        case (unsigned int)0x00000002:
        {
          tmp=strstr(p->info, "GG");
          if(tmp == ((char *)NULL))
          {
            gg_debug_session(sess, 16, "// gg_dcc7_handle_info() unknown info packet\n");
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return 0;
          }

          (void)tmp;
          return_value_gg_dcc7_get_relay_addr$5=gg_dcc7_get_relay_addr(dcc);
          if(return_value_gg_dcc7_get_relay_addr$5 == -1)
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$4 = dcc->sess;

            else
              tmp_if_expr$4 = (struct gg_session *)(void *)0;
            gg_debug_session(tmp_if_expr$4, 16, "// gg_dcc7_handle_info() unable to retrieve relay address\n");
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_RELAY;
            return 0;
          }

          gg_send_packet(dcc->sess, 0x1f, payload, len, (void *)0);
          return 0;
        }
        default:
        {
          gg_debug_session(sess, 16, "// gg_dcc7_handle_info() unhandled transfer type (%d)\n", p->type);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
          return 0;
        }
      }
      if(dcc->state == GG_STATE_LISTENING)
      {
        close(dcc->fd);
        dcc->fd = -1;
        dcc->reverse = 1;
      }

      if(dcc->type == 19)
      {
        e->type = GG_EVENT_DCC7_ACCEPT;
        e->event.dcc7_accept.dcc7 = dcc;
        unsigned int return_value_gg_fix32$6;
        return_value_gg_fix32$6=gg_fix32(p->type);
        e->event.dcc7_accept.type = (signed int)return_value_gg_fix32$6;
        e->event.dcc7_accept.remote_ip = dcc->remote_addr;
        e->event.dcc7_accept.remote_port = dcc->remote_port;
      }

      else
      {
        e->type = GG_EVENT_DCC7_PENDING;
        e->event.dcc7_pending.dcc7 = dcc;
      }
      signed int return_value_gg_dcc7_connect$8;
      return_value_gg_dcc7_connect$8=gg_dcc7_connect(dcc);
      if(return_value_gg_dcc7_connect$8 == -1)
      {
        signed int return_value_gg_dcc7_reverse_connect$7;
        return_value_gg_dcc7_reverse_connect$7=gg_dcc7_reverse_connect(dcc);
        if(return_value_gg_dcc7_reverse_connect$7 == -1)
        {
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_NET;
          return 0;
        }

      }

      return 0;
    }
}

// gg_dcc7_handle_new
// file dcc7.c line 927
signed int gg_dcc7_handle_new(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len)
{
  struct gg_dcc7_new *p = (struct gg_dcc7_new *)payload;
  struct gg_dcc7 *dcc;
  gg_debug_session(sess, 8, "** gg_dcc7_handle_new(%p, %p, %p, %d)\n", sess, e, payload, len);
  unsigned int return_value_gg_fix32$1;
  return_value_gg_fix32$1=gg_fix32(p->type);
  void *return_value_malloc$2;
  signed int return_value_gg_dcc7_session_add$3;
  void *return_value_malloc$4;
  signed int return_value_gg_dcc7_session_add$5;
  unsigned int return_value_gg_fix32$6;
  unsigned int return_value_gg_fix32$7;
  switch(return_value_gg_fix32$1)
  {
    case (unsigned int)0x00000004:
    {
      return_value_malloc$2=malloc(sizeof(struct gg_dcc7) /*448ul*/ );
      dcc = (struct gg_dcc7 *)return_value_malloc$2;
      if(dcc == ((struct gg_dcc7 *)NULL))
      {
        gg_debug_session(sess, 16, "// gg_dcc7_handle_new() not enough memory\n");
        return -1;
      }

      memset((void *)dcc, 0, sizeof(struct gg_dcc7) /*448ul*/ );
      dcc->type = 20;
      dcc->dcc_type = 0x00000004;
      dcc->fd = -1;
      dcc->file_fd = -1;
      dcc->uin = sess->uin;
      dcc->peer_uin=gg_fix32(p->uin_from);
      dcc->cid = p->id;
      dcc->sess = sess;
      return_value_gg_dcc7_session_add$3=gg_dcc7_session_add(sess, dcc);
      if(return_value_gg_dcc7_session_add$3 == -1)
      {
        gg_debug_session(sess, 16, "// gg_dcc7_handle_new() unable to add to session\n");
        gg_dcc7_free(dcc);
        return -1;
      }

      dcc->size=gg_fix32(p->size);
      strncpy((char *)dcc->filename, (char *)p->filename, (unsigned long int)255);
      dcc->filename[(signed long int)255] = (unsigned char)0;
      memcpy((void *)dcc->hash, (const void *)p->hash, (unsigned long int)20);
      e->type = GG_EVENT_DCC7_NEW;
      e->event.dcc7_new = dcc;
      break;
    }
    case (unsigned int)0x00000001:
    {
      return_value_malloc$4=malloc(sizeof(struct gg_dcc7) /*448ul*/ );
      dcc = (struct gg_dcc7 *)return_value_malloc$4;
      if(dcc == ((struct gg_dcc7 *)NULL))
      {
        gg_debug_session(sess, 16, "// gg_dcc7_handle_packet() not enough memory\n");
        return -1;
      }

      memset((void *)dcc, 0, sizeof(struct gg_dcc7) /*448ul*/ );
      dcc->type = 21;
      dcc->dcc_type = 0x00000001;
      dcc->fd = -1;
      dcc->file_fd = -1;
      dcc->uin = sess->uin;
      dcc->peer_uin=gg_fix32(p->uin_from);
      dcc->cid = p->id;
      dcc->sess = sess;
      return_value_gg_dcc7_session_add$5=gg_dcc7_session_add(sess, dcc);
      if(return_value_gg_dcc7_session_add$5 == -1)
      {
        gg_debug_session(sess, 16, "// gg_dcc7_handle_new() unable to add to session\n");
        gg_dcc7_free(dcc);
        return -1;
      }

      e->type = GG_EVENT_DCC7_NEW;
      e->event.dcc7_new = dcc;
      break;
    }
    default:
    {
      return_value_gg_fix32$6=gg_fix32(p->type);
      return_value_gg_fix32$7=gg_fix32(p->uin_from);
      gg_debug_session(sess, 16, "// gg_dcc7_handle_new() unknown dcc type (%d) from %u\n", return_value_gg_fix32$6, return_value_gg_fix32$7);
    }
  }
  return 0;
}

// gg_dcc7_handle_reject
// file dcc7.c line 889
signed int gg_dcc7_handle_reject(struct gg_session *sess, struct gg_event *e, const void *payload, signed int len)
{
  struct gg_dcc7_reject *p = (struct gg_dcc7_reject *)payload;
  struct gg_dcc7 *dcc;
  gg_debug_session(sess, 8, "** gg_dcc7_handle_reject(%p, %p, %p, %d)\n", sess, e, payload, len);
  unsigned int return_value_gg_fix32$1;
  return_value_gg_fix32$1=gg_fix32(p->uin);
  dcc=gg_dcc7_session_find(sess, p->id, return_value_gg_fix32$1);
  if(dcc == ((struct gg_dcc7 *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_handle_reject() unknown dcc session\n");
    return 0;
  }

  else
    if(!(dcc->state == GG_STATE_WAITING_FOR_ACCEPT))
    {
      gg_debug_session(sess, 16, "// gg_dcc7_handle_reject() invalid state\n");
      e->type = GG_EVENT_DCC7_ERROR;
      e->event.dcc7_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
      return 0;
    }

    else
    {
      e->type = GG_EVENT_DCC7_REJECT;
      e->event.dcc7_reject.dcc7 = dcc;
      unsigned int return_value_gg_fix32$2;
      return_value_gg_fix32$2=gg_fix32(p->reason);
      e->event.dcc7_reject.reason = (signed int)return_value_gg_fix32$2;
      return 0;
    }
}

// gg_dcc7_listen
// file dcc7.c line 222
static signed int gg_dcc7_listen(struct gg_dcc7 *dcc, unsigned int addr, unsigned short int port)
{
  struct sockaddr_in sin;
  unsigned int sin_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int errsv;
  signed int fd;
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_listen(%p, %d)\n", dcc, port);
  struct gg_session *tmp_if_expr$2;
  if(dcc == ((struct gg_dcc7 *)NULL))
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_listen() invalid parameters\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  fd=socket(2, 1, 6);
  struct gg_session *tmp_if_expr$4;
  if(fd == -1)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$4 = dcc->sess;

    else
      tmp_if_expr$4 = (struct gg_session *)(void *)0;
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    gg_debug_session(tmp_if_expr$4, 16, "// gg_dcc7_listen() can't create socket (%s)\n", return_value_strerror$6);
    return -1;
  }

  memset((void *)&sin, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  sin.sin_family = (unsigned short int)2;
  sin.sin_addr.s_addr = addr;
  sin.sin_port=htons(port);
  signed int return_value_bind$9;
  return_value_bind$9=bind(fd, (struct sockaddr *)&sin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  struct gg_session *tmp_if_expr$7;
  if(return_value_bind$9 == -1)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$7 = dcc->sess;

    else
      tmp_if_expr$7 = (struct gg_session *)(void *)0;
    char *return_value_inet_ntoa$8;
    return_value_inet_ntoa$8=inet_ntoa(sin.sin_addr);
    gg_debug_session(tmp_if_expr$7, 16, "// gg_dcc7_listen() unable to bind to %s:%d\n", return_value_inet_ntoa$8, port);
    goto fail;
  }

  signed int return_value_getsockname$11;
  struct gg_session *tmp_if_expr$10;
  signed int return_value_listen$15;
  struct gg_session *tmp_if_expr$12;
  if((signed int)port == 0)
  {
    return_value_getsockname$11=getsockname(fd, (struct sockaddr *)&sin, &sin_len);
    if(!(return_value_getsockname$11 == -1))
      goto __CPROVER_DUMP_L14;

    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$10 = dcc->sess;

    else
      tmp_if_expr$10 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$10, 16, "// gg_dcc7_listen() unable to bind to port %d\n", port);
  }

  else
  {

  __CPROVER_DUMP_L14:
    ;
    return_value_listen$15=listen(fd, 1);
    if(!(return_value_listen$15 == 0))
    {
      if(!(dcc == ((struct gg_dcc7 *)NULL)))
        tmp_if_expr$12 = dcc->sess;

      else
        tmp_if_expr$12 = (struct gg_session *)(void *)0;
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      char *return_value_strerror$14;
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      gg_debug_session(tmp_if_expr$12, 16, "// gg_dcc7_listen() unable to listen (%s)\n", return_value_strerror$14);
      goto fail;
    }

    dcc->fd = fd;
    dcc->local_addr = sin.sin_addr.s_addr;
    dcc->local_port=ntohs(sin.sin_port);
    dcc->state = GG_STATE_LISTENING;
    dcc->check = 2;
    dcc->timeout = 300;
    return 0;
  }

fail:
  ;
  signed int *return_value___errno_location$16;
  return_value___errno_location$16=__errno_location();
  errsv = *return_value___errno_location$16;
  close(fd);
  signed int *return_value___errno_location$17;
  return_value___errno_location$17=__errno_location();
  *return_value___errno_location$17 = errsv;
  return -1;
}

// gg_dcc7_listen_and_send_info
// file dcc7.c line 287
static signed int gg_dcc7_listen_and_send_info(struct gg_dcc7 *dcc)
{
  struct gg_dcc7_info pkt;
  unsigned short int external_port;
  unsigned int external_addr;
  struct in_addr addr;
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_listen_and_send_info(%p)\n", dcc);
  signed int return_value_gg_dcc7_listen$2;
  return_value_gg_dcc7_listen$2=gg_dcc7_listen(dcc, dcc->sess->client_addr, dcc->sess->client_port);
  struct gg_session *tmp_if_expr$3;
  if(return_value_gg_dcc7_listen$2 == -1)
    return -1;

  else
  {
    if(!((signed int)dcc->sess->external_port == 0))
      external_port = dcc->sess->external_port;

    else
      external_port = dcc->local_port;
    if(!(dcc->sess->external_addr == 0u))
      external_addr = dcc->sess->external_addr;

    else
      external_addr = dcc->local_addr;
    addr.s_addr = external_addr;
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$3 = dcc->sess;

    else
      tmp_if_expr$3 = (struct gg_session *)(void *)0;
    char *return_value_inet_ntoa$4;
    return_value_inet_ntoa$4=inet_ntoa(addr);
    gg_debug_session(tmp_if_expr$3, 16, "// dcc7_listen_and_send_info() sending IP address %s and port %d\n", return_value_inet_ntoa$4, external_port);
    memset((void *)&pkt, 0, sizeof(struct gg_dcc7_info) /*80ul*/ );
    pkt.uin=gg_fix32(dcc->peer_uin);
    pkt.type = (unsigned int)0x00000001;
    pkt.id = dcc->cid;
    char *return_value_inet_ntoa$5;
    return_value_inet_ntoa$5=inet_ntoa(addr);
    snprintf((char *)pkt.info, sizeof(char [32l]) /*32ul*/ , "%s %d", return_value_inet_ntoa$5, external_port);
    signed int return_value_rand$6;
    return_value_rand$6=rand();
    snprintf((char *)pkt.hash, sizeof(char [32l]) /*32ul*/ , "%u", external_addr + (unsigned int)((signed int)external_port * return_value_rand$6));
    signed int return_value_gg_send_packet$7;
    return_value_gg_send_packet$7=gg_send_packet(dcc->sess, 0x1f, &pkt, sizeof(struct gg_dcc7_info) /*80ul*/ , (void *)0);
    return return_value_gg_send_packet$7;
  }
}

// gg_dcc7_postauth_fixup
// file dcc7.c line 1019
static signed int gg_dcc7_postauth_fixup(struct gg_dcc7 *dcc)
{
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_postauth_fixup(%p)\n", dcc);
  struct gg_session *tmp_if_expr$2;
  if(dcc == ((struct gg_dcc7 *)NULL))
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_postauth_fixup() invalid parameters\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  signed int *return_value___errno_location$4;
  switch(dcc->type)
  {
    case 20:
    {
      dcc->state = GG_STATE_GETTING_FILE;
      dcc->check = 2;
      return 0;
    }
    case 19:
    {
      dcc->state = GG_STATE_SENDING_FILE;
      dcc->check = 1;
      return 0;
    }
    case 21:
    {
      dcc->state = GG_STATE_READING_VOICE_DATA;
      dcc->check = 2;
      return 0;
    }
    default:
    {
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 22;
      return -1;
    }
  }
}

// gg_dcc7_reject
// file dcc7.c line 607
signed int gg_dcc7_reject(struct gg_dcc7 *dcc, signed int reason)
{
  struct gg_dcc7_reject pkt;
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_reject(%p, %d)\n", dcc, reason);
  _Bool tmp_if_expr$4;
  if(dcc == ((struct gg_dcc7 *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(dcc->sess != ((struct gg_session *)NULL)) ? (_Bool)1 : (_Bool)0;
  struct gg_session *tmp_if_expr$2;
  if(tmp_if_expr$4)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_reject() invalid parameters\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 14;
    return -1;
  }

  memset((void *)&pkt, 0, sizeof(struct gg_dcc7_reject) /*16ul*/ );
  pkt.uin=gg_fix32(dcc->peer_uin);
  pkt.id = dcc->cid;
  pkt.reason=gg_fix32((unsigned int)reason);
  signed int return_value_gg_send_packet$5;
  return_value_gg_send_packet$5=gg_send_packet(dcc->sess, 0x22, &pkt, sizeof(struct gg_dcc7_reject) /*16ul*/ , (void *)0);
  return return_value_gg_send_packet$5;
}

// gg_dcc7_request_id
// file dcc7.c line 357
static signed int gg_dcc7_request_id(struct gg_session *sess, unsigned int type)
{
  struct gg_dcc7_id_request pkt;
  gg_debug_session(sess, 8, "** gg_dcc7_request_id(%p, %d)\n", sess, type);
  if(sess == ((struct gg_session *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_request_id() invalid parameters\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_request_id() not connected\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  if(!(type == 1u) && !(type == 4u))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_request_id() invalid transfer type (%d)\n", type);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  memset((void *)&pkt, 0, sizeof(struct gg_dcc7_id_request) /*4ul*/ );
  pkt.type=gg_fix32(type);
  signed int return_value_gg_send_packet$4;
  return_value_gg_send_packet$4=gg_send_packet(sess, 0x23, &pkt, sizeof(struct gg_dcc7_id_request) /*4ul*/ , (void *)0);
  return return_value_gg_send_packet$4;
}

// gg_dcc7_reverse_connect
// file dcc7.c line 332
static signed int gg_dcc7_reverse_connect(struct gg_dcc7 *dcc)
{
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_reverse_connect(%p)\n", dcc);
  struct gg_session *tmp_if_expr$2;
  struct gg_session *tmp_if_expr$3;
  if(!(dcc->reverse == 0))
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_reverse_connect() already reverse connection\n");
    return -1;
  }

  else
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$3 = dcc->sess;

    else
      tmp_if_expr$3 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$3, 16, "// gg_dcc7_reverse_connect() timeout, trying reverse connection\n");
    close(dcc->fd);
    dcc->fd = -1;
    dcc->reverse = 1;
    signed int return_value_gg_dcc7_listen_and_send_info$4;
    return_value_gg_dcc7_listen_and_send_info$4=gg_dcc7_listen_and_send_info(dcc);
    return return_value_gg_dcc7_listen_and_send_info$4;
  }
}

// gg_dcc7_send_file
// file dcc7.c line 466
struct gg_dcc7 * gg_dcc7_send_file(struct gg_session *sess, unsigned int rcpt, const char *filename, const char *filename1250, const char *hash)
{
  struct gg_dcc7 *dcc = (struct gg_dcc7 *)(void *)0;
  const char *tmp;
  char hash_buf[20l];
  struct stat st;
  signed int fd = -1;
  gg_debug_session(sess, 8, "** gg_dcc7_send_file(%p, %d, \"%s\", %p)\n", sess, rcpt, filename, hash);
  if(filename == ((const char *)NULL) || sess == ((struct gg_session *)NULL) || rcpt == 0u)
  {
    gg_debug_session(sess, 16, "// gg_dcc7_send_file() invalid parameters\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    goto fail;
  }

  if(filename1250 == ((const char *)NULL))
    filename1250 = filename;

  fd=open(filename, 00);
  if(fd == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    gg_debug_session(sess, 16, "// gg_dcc7_send_file() open() failed (%s)\n", return_value_strerror$3);
    goto fail;
  }

  signed int return_value_fstat$6;
  return_value_fstat$6=fstat(fd, &st);
  if(return_value_fstat$6 == -1)
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    gg_debug_session(sess, 16, "// gg_dcc7_send_file() fstat() failed (%s)\n", return_value_strerror$5);
    goto fail;
  }

  if(!((16384u & st.st_mode) == 0u))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_send_file() that's a directory\n");
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    *return_value___errno_location$7 = 22;
    goto fail;
  }

  if(hash == ((const char *)NULL))
  {
    signed int return_value_gg_file_hash_sha1$8;
    return_value_gg_file_hash_sha1$8=gg_file_hash_sha1(fd, (unsigned char *)hash_buf);
    if(return_value_gg_file_hash_sha1$8 == -1)
      goto fail;

    hash = hash_buf;
  }

  tmp=strrchr(filename1250, 47);
  if(!(tmp == ((const char *)NULL)))
    filename1250 = tmp + (signed long int)1;

  dcc=gg_dcc7_send_file_common(sess, rcpt, fd, (unsigned long int)st.st_size, filename1250, hash, 1);
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    return dcc;

  else
  {

  fail:
    ;
    if(!(fd == -1))
    {
      signed int errsv;
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      errsv = *return_value___errno_location$9;
      close(fd);
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      *return_value___errno_location$10 = errsv;
    }

    free((void *)dcc);
    return (struct gg_dcc7 *)(void *)0;
  }
}

// gg_dcc7_send_file_common
// file dcc7.c line 405
static struct gg_dcc7 * gg_dcc7_send_file_common(struct gg_session *sess, unsigned int rcpt, signed int fd, unsigned long int size, const char *filename1250, const char *hash, signed int seek)
{
  struct gg_dcc7 *dcc = (struct gg_dcc7 *)(void *)0;
  if(filename1250 == ((const char *)NULL) || hash == ((const char *)NULL) || sess == ((struct gg_session *)NULL) || fd == -1 || rcpt == 0u)
  {
    gg_debug_session(sess, 16, "// gg_dcc7_send_file_common() invalid parameters\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    goto fail;
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct gg_dcc7) /*448ul*/ );
  dcc = (struct gg_dcc7 *)return_value_malloc$2;
  signed int return_value_gg_dcc7_request_id$3;
  signed int return_value_gg_dcc7_session_add$4;
  if(dcc == ((struct gg_dcc7 *)NULL))
    gg_debug_session(sess, 16, "// gg_dcc7_send_file_common() not enough memory\n");

  else
  {
    return_value_gg_dcc7_request_id$3=gg_dcc7_request_id(sess, (unsigned int)0x00000004);
    if(!(return_value_gg_dcc7_request_id$3 == -1))
    {
      memset((void *)dcc, 0, sizeof(struct gg_dcc7) /*448ul*/ );
      dcc->type = 19;
      dcc->dcc_type = 0x00000004;
      dcc->state = GG_STATE_REQUESTING_ID;
      dcc->timeout = 30;
      dcc->sess = sess;
      dcc->fd = -1;
      dcc->uin = sess->uin;
      dcc->peer_uin = rcpt;
      dcc->file_fd = fd;
      dcc->size = (unsigned int)size;
      dcc->seek = seek;
      strncpy((char *)dcc->filename, filename1250, (unsigned long int)255);
      dcc->filename[(signed long int)255] = (unsigned char)0;
      memcpy((void *)dcc->hash, (const void *)hash, (unsigned long int)20);
      return_value_gg_dcc7_session_add$4=gg_dcc7_session_add(sess, dcc);
      if(!(return_value_gg_dcc7_session_add$4 == -1))
        return dcc;

    }

  }

fail:
  ;
  free((void *)dcc);
  return (struct gg_dcc7 *)(void *)0;
}

// gg_dcc7_send_file_fd
// file dcc7.c line 547
struct gg_dcc7 * gg_dcc7_send_file_fd(struct gg_session *sess, unsigned int rcpt, signed int fd, unsigned long int size, const char *filename1250, const char *hash)
{
  gg_debug_session(sess, 8, "** gg_dcc7_send_file_fd(%p, %d, %d, %zu, \"%s\", %p)\n", sess, rcpt, fd, size, filename1250, hash);
  struct gg_dcc7 *return_value_gg_dcc7_send_file_common$1;
  return_value_gg_dcc7_send_file_common$1=gg_dcc7_send_file_common(sess, rcpt, fd, size, filename1250, hash, 0);
  return return_value_gg_dcc7_send_file_common$1;
}

// gg_dcc7_session_add
// file dcc7.c line 67
static signed int gg_dcc7_session_add(struct gg_session *sess, struct gg_dcc7 *dcc)
{
  gg_debug_session(sess, 8, "** gg_dcc7_session_add(%p, %p)\n", sess, dcc);
  _Bool tmp_if_expr$2;
  if(dcc == ((struct gg_dcc7 *)NULL) || sess == ((struct gg_session *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = dcc->next != ((struct gg_dcc7 *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    gg_debug_session(sess, 16, "// gg_dcc7_session_add() invalid parameters\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  dcc->next = sess->dcc7_list;
  sess->dcc7_list = dcc;
  return 0;
}

// gg_dcc7_session_find
// file dcc7.c line 130
static struct gg_dcc7 * gg_dcc7_session_find(struct gg_session *sess, struct anonymous$9 id, unsigned int uin)
{
  struct gg_dcc7 *tmp;
  signed int empty;
  gg_debug_session(sess, 8, "** gg_dcc7_session_find(%p, ..., %d)\n", sess, (signed int)uin);
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)&id, (const void *)"\0\0\0\0\0\0\0\0", (unsigned long int)8);
  empty = (signed int)!(return_value_memcmp$1 != 0);
  tmp = sess->dcc7_list;
  for( ; !(tmp == ((struct gg_dcc7 *)NULL)); tmp = tmp->next)
    if(!(empty == 0))
    {
      if(tmp->peer_uin == uin)
      {
        if(tmp->state == GG_STATE_WAITING_FOR_ACCEPT)
          return tmp;

      }

    }

    else
    {
      signed int return_value_memcmp$2;
      return_value_memcmp$2=memcmp((const void *)&tmp->cid, (const void *)&id, sizeof(struct anonymous$9) /*8ul*/ );
      if(return_value_memcmp$2 == 0)
        return tmp;

    }
  return (struct gg_dcc7 *)(void *)0;
}

// gg_dcc7_session_remove
// file dcc7.c line 91
static signed int gg_dcc7_session_remove(struct gg_session *sess, struct gg_dcc7 *dcc)
{
  struct gg_dcc7 *tmp;
  gg_debug_session(sess, 8, "** gg_dcc7_session_remove(%p, %p)\n", sess, dcc);
  if(dcc == ((struct gg_dcc7 *)NULL) || sess == ((struct gg_session *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_dcc7_session_remove() invalid parameters\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  if(sess->dcc7_list == dcc)
  {
    sess->dcc7_list = dcc->next;
    dcc->next = (struct gg_dcc7 *)(void *)0;
    return 0;
  }

  else
  {
    tmp = sess->dcc7_list;
    for( ; !(tmp == ((struct gg_dcc7 *)NULL)); tmp = tmp->next)
      if(tmp->next == dcc)
      {
        tmp->next = dcc->next;
        dcc->next = (struct gg_dcc7 *)(void *)0;
        return 0;
      }

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 2;
    return -1;
  }
}

// gg_dcc7_watch_fd
// file dcc7.c line 1064
struct gg_event * gg_dcc7_watch_fd(struct gg_dcc7 *dcc)
{
  struct gg_event *e;
  struct gg_session *tmp_if_expr$1;
  if(!(dcc == ((struct gg_dcc7 *)NULL)))
    tmp_if_expr$1 = dcc->sess;

  else
    tmp_if_expr$1 = (struct gg_session *)(void *)0;
  gg_debug_session(tmp_if_expr$1, 8, "** gg_dcc7_watch_fd(%p)\n", dcc);
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(dcc == ((struct gg_dcc7 *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    if(!(dcc->type == 19))
      tmp_if_expr$4 = dcc->type != 20 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = dcc->type != 21 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
  }
  struct gg_session *tmp_if_expr$2;
  if(tmp_if_expr$6)
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$2 = dcc->sess;

    else
      tmp_if_expr$2 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$2, 16, "// gg_dcc7_watch_fd() invalid parameters\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return (struct gg_event *)(void *)0;
  }

  void *return_value_malloc$8;
  return_value_malloc$8=malloc(sizeof(struct gg_event) /*96ul*/ );
  e = (struct gg_event *)return_value_malloc$8;
  struct gg_session *tmp_if_expr$7;
  struct sockaddr_in sin;
  signed int fd;
  unsigned int sin_len;
  struct gg_session *tmp_if_expr$9;
  struct gg_session *tmp_if_expr$10;
  struct gg_session *tmp_if_expr$13;
  char *return_value_inet_ntoa$14;
  unsigned short int return_value_htons$15;
  signed int return_value_gg_fd_set_nonblocking$19;
  struct gg_session *tmp_if_expr$16;
  signed int gg_dcc7_watch_fd$$1$$3$$2$$res;
  signed int error;
  unsigned int error_size;
  struct gg_session *tmp_if_expr$20;
  _Bool tmp_if_expr$29;
  struct gg_session *tmp_if_expr$21;
  char *tmp_if_expr$25;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  char *return_value_strerror$24;
  struct gg_session *tmp_if_expr$27;
  struct gg_session *tmp_if_expr$30;
  signed int gg_dcc7_watch_fd$$1$$3$$3$$res;
  struct gg_session *tmp_if_expr$31;
  struct gg_session *tmp_if_expr$32;
  struct gg_session *tmp_if_expr$36;
  struct gg_session *tmp_if_expr$38;
  struct gg_session *tmp_if_expr$42;
  signed int res;
  struct gg_session *tmp_if_expr$44;
  struct gg_session *tmp_if_expr$45;
  struct gg_session *tmp_if_expr$49;
  char gg_dcc7_watch_fd$$1$$3$$5$$buf[1024l];
  unsigned long int chunk;
  signed int gg_dcc7_watch_fd$$1$$3$$5$$res;
  struct gg_session *tmp_if_expr$53;
  struct gg_session *tmp_if_expr$54;
  signed long int return_value_lseek$58;
  struct gg_session *tmp_if_expr$55;
  signed long int return_value_read$62;
  struct gg_session *tmp_if_expr$59;
  signed long int return_value_send$66;
  struct gg_session *tmp_if_expr$63;
  struct gg_session *tmp_if_expr$67;
  char gg_dcc7_watch_fd$$1$$3$$6$$buf[1024l];
  signed int gg_dcc7_watch_fd$$1$$3$$6$$res;
  signed int wres;
  struct gg_session *tmp_if_expr$68;
  struct gg_session *tmp_if_expr$69;
  signed long int return_value_recv$73;
  struct gg_session *tmp_if_expr$70;
  signed long int return_value_write$77;
  struct gg_session *tmp_if_expr$74;
  struct gg_session *tmp_if_expr$78;
  struct in_addr gg_dcc7_watch_fd$$1$$3$$7$$addr;
  signed int gg_dcc7_watch_fd$$1$$3$$7$$res;
  struct gg_session *tmp_if_expr$79;
  _Bool tmp_if_expr$81;
  signed int *return_value___errno_location$80;
  signed int gg_dcc7_watch_fd$$1$$3$$8$$res;
  unsigned int res_size;
  struct gg_dcc7_relay_req pkt;
  struct gg_session *tmp_if_expr$91;
  signed int return_value_getsockopt$94;
  struct gg_session *tmp_if_expr$92;
  struct gg_session *tmp_if_expr$95;
  unsigned int return_value_gg_fix32$96;
  struct gg_session *tmp_if_expr$97;
  signed long int return_value_send$99;
  struct gg_session *tmp_if_expr$98;
  char buf[256l];
  struct gg_dcc7_relay_reply *gg_dcc7_watch_fd$$1$$3$$9$$pkt;
  struct gg_dcc7_relay_reply_server srv;
  unsigned long int max_relay_count;
  signed int gg_dcc7_watch_fd$$1$$3$$9$$res;
  signed int i;
  struct gg_session *tmp_if_expr$100;
  signed long int return_value_recv$105;
  signed int *return_value___errno_location$101;
  struct gg_session *tmp_if_expr$102;
  unsigned int return_value_gg_fix32$108;
  _Bool tmp_if_expr$110;
  unsigned int return_value_gg_fix32$109;
  _Bool tmp_if_expr$112;
  unsigned int return_value_gg_fix32$111;
  _Bool tmp_if_expr$115;
  unsigned int return_value_gg_fix32$113;
  unsigned int return_value_gg_fix32$114;
  struct gg_session *tmp_if_expr$106;
  struct gg_session *tmp_if_expr$116;
  unsigned int return_value_gg_fix32$117;
  struct gg_session *tmp_if_expr$118;
  unsigned int return_value_gg_fix32$119;
  _Bool tmp_if_expr$121;
  struct gg_session *tmp_if_expr$120;
  void *return_value_malloc$122;
  struct gg_session *tmp_if_expr$123;
  struct gg_session *tmp_if_expr$124;
  struct gg_session *tmp_if_expr$128;
  struct gg_session *tmp_if_expr$129;
  if(e == ((struct gg_event *)NULL))
  {
    if(!(dcc == ((struct gg_dcc7 *)NULL)))
      tmp_if_expr$7 = dcc->sess;

    else
      tmp_if_expr$7 = (struct gg_session *)(void *)0;
    gg_debug_session(tmp_if_expr$7, 16, "// gg_dcc7_watch_fd() not enough memory\n");
    return (struct gg_event *)(void *)0;
  }

  else
  {
    memset((void *)e, 0, sizeof(struct gg_event) /*96ul*/ );
    e->type = GG_EVENT_NONE;
    switch(dcc->state)
    {
      case GG_STATE_LISTENING:
      {
        sin_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$9 = dcc->sess;

        else
          tmp_if_expr$9 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$9, 16, "// gg_dcc7_watch_fd() GG_STATE_LISTENING\n");
        fd=accept(dcc->fd, (struct sockaddr *)&sin, &sin_len);
        if(fd == -1)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$10 = dcc->sess;

          else
            tmp_if_expr$10 = (struct gg_session *)(void *)0;
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          char *return_value_strerror$12;
          return_value_strerror$12=strerror(*return_value___errno_location$11);
          gg_debug_session(tmp_if_expr$10, 16, "// gg_dcc7_watch_fd() accept() failed (%s)\n", return_value_strerror$12);
          return e;
        }

        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$13 = dcc->sess;

        else
          tmp_if_expr$13 = (struct gg_session *)(void *)0;
        return_value_inet_ntoa$14=inet_ntoa(sin.sin_addr);
        return_value_htons$15=htons(sin.sin_port);
        gg_debug_session(tmp_if_expr$13, 16, "// gg_dcc7_watch_fd() connection from %s:%d\n", return_value_inet_ntoa$14, return_value_htons$15);
        return_value_gg_fd_set_nonblocking$19=gg_fd_set_nonblocking$link2(fd);
        if(return_value_gg_fd_set_nonblocking$19 == 0)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$16 = dcc->sess;

          else
            tmp_if_expr$16 = (struct gg_session *)(void *)0;
          signed int *return_value___errno_location$17;
          return_value___errno_location$17=__errno_location();
          char *return_value_strerror$18;
          return_value_strerror$18=strerror(*return_value___errno_location$17);
          gg_debug_session(tmp_if_expr$16, 16, "// gg_dcc7_watch_fd() can't set nonblocking (%s)\n", return_value_strerror$18);
          close(fd);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
          return e;
        }

        close(dcc->fd);
        dcc->fd = fd;
        dcc->state = GG_STATE_READING_ID;
        dcc->check = 2;
        dcc->timeout = 30;
        dcc->incoming = 1;
        dcc->remote_port=ntohs(sin.sin_port);
        dcc->remote_addr = sin.sin_addr.s_addr;
        e->type = GG_EVENT_DCC7_CONNECTED;
        e->event.dcc7_connected.dcc7 = dcc;
        return e;
      }
      case GG_STATE_CONNECTING:
      {
        gg_dcc7_watch_fd$$1$$3$$2$$res = 0;
        error = 0;
        error_size = (unsigned int)sizeof(signed int) /*4ul*/ ;
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$20 = dcc->sess;

        else
          tmp_if_expr$20 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$20, 16, "// gg_dcc7_watch_fd() GG_STATE_CONNECTING\n");
        dcc->soft_timeout = 0;
        if(dcc->timeout == 0)
          error = 110;

        if(!(error == 0))
          tmp_if_expr$29 = (_Bool)1;

        else
        {
          gg_dcc7_watch_fd$$1$$3$$2$$res=getsockopt(dcc->fd, 1, 4, (void *)&error, &error_size);
          tmp_if_expr$29 = gg_dcc7_watch_fd$$1$$3$$2$$res == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(!(error == 0) || tmp_if_expr$29)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$21 = dcc->sess;

          else
            tmp_if_expr$21 = (struct gg_session *)(void *)0;
          if(gg_dcc7_watch_fd$$1$$3$$2$$res == -1)
          {
            return_value___errno_location$22=__errno_location();
            return_value_strerror$23=strerror(*return_value___errno_location$22);
            tmp_if_expr$25 = return_value_strerror$23;
          }

          else
          {
            return_value_strerror$24=strerror(error);
            tmp_if_expr$25 = return_value_strerror$24;
          }
          gg_debug_session(tmp_if_expr$21, 16, "// gg_dcc7_watch_fd() connection failed (%s)\n", tmp_if_expr$25);
          if(!(dcc->relay == 0))
          {
            dcc->relay_index = dcc->relay_index + 1;
            for( ; !(dcc->relay_index >= dcc->relay_count); dcc->relay_index = dcc->relay_index + 1)
            {
              dcc->remote_addr = (dcc->relay_list + (signed long int)dcc->relay_index)->addr;
              dcc->remote_port = (dcc->relay_list + (signed long int)dcc->relay_index)->port;
              signed int return_value_gg_dcc7_connect$26;
              return_value_gg_dcc7_connect$26=gg_dcc7_connect(dcc);
              if(return_value_gg_dcc7_connect$26 == 0)
                break;

            }
            if(dcc->relay_index >= dcc->relay_count)
            {
              if(!(dcc == ((struct gg_dcc7 *)NULL)))
                tmp_if_expr$27 = dcc->sess;

              else
                tmp_if_expr$27 = (struct gg_session *)(void *)0;
              gg_debug_session(tmp_if_expr$27, 16, "// gg_dcc7_watch_fd() no relay available\n");
              e->type = GG_EVENT_DCC7_ERROR;
              e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_RELAY;
              return e;
            }

          }

          else
          {
            signed int return_value_gg_dcc7_reverse_connect$28;
            return_value_gg_dcc7_reverse_connect$28=gg_dcc7_reverse_connect(dcc);
            if(!(return_value_gg_dcc7_reverse_connect$28 == -1))
            {
              e->type = GG_EVENT_DCC7_PENDING;
              e->event.dcc7_pending.dcc7 = dcc;
            }

            else
            {
              e->type = GG_EVENT_DCC7_ERROR;
              e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_NET;
            }
            return e;
          }
        }

        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$30 = dcc->sess;

        else
          tmp_if_expr$30 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$30, 16, "// gg_dcc7_watch_fd() connected, sending id\n");
        dcc->state = GG_STATE_SENDING_ID;
        dcc->check = 1;
        dcc->timeout = 30;
        dcc->incoming = 0;
        return e;
      }
      case GG_STATE_READING_ID:
      {
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$31 = dcc->sess;

        else
          tmp_if_expr$31 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$31, 16, "// gg_dcc7_watch_fd() GG_STATE_READING_ID\n");
        if(dcc->relay == 0)
        {
          struct gg_dcc7_welcome_p2p gg_dcc7_watch_fd$$1$$3$$3$$1$$welcome;
          struct gg_dcc7_welcome_p2p gg_dcc7_watch_fd$$1$$3$$3$$1$$welcome_ok;
          gg_dcc7_watch_fd$$1$$3$$3$$1$$welcome_ok.id = dcc->cid;
          signed long int return_value_recv$35;
          return_value_recv$35=recv(dcc->fd, (void *)&gg_dcc7_watch_fd$$1$$3$$3$$1$$welcome, sizeof(struct gg_dcc7_welcome_p2p) /*8ul*/ , 0);
          gg_dcc7_watch_fd$$1$$3$$3$$res = (signed int)return_value_recv$35;
          if(!((unsigned long int)gg_dcc7_watch_fd$$1$$3$$3$$res == sizeof(struct gg_dcc7_welcome_p2p) /*8ul*/ ))
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$32 = dcc->sess;

            else
              tmp_if_expr$32 = (struct gg_session *)(void *)0;
            signed int *return_value___errno_location$33;
            return_value___errno_location$33=__errno_location();
            char *return_value_strerror$34;
            return_value_strerror$34=strerror(*return_value___errno_location$33);
            gg_debug_session(tmp_if_expr$32, 16, "// gg_dcc7_watch_fd() recv() failed (%d, %s)\n", gg_dcc7_watch_fd$$1$$3$$3$$res, return_value_strerror$34);
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return e;
          }

          signed int return_value_memcmp$37;
          return_value_memcmp$37=memcmp((const void *)&gg_dcc7_watch_fd$$1$$3$$3$$1$$welcome, (const void *)&gg_dcc7_watch_fd$$1$$3$$3$$1$$welcome_ok, sizeof(struct gg_dcc7_welcome_p2p) /*8ul*/ );
          if(!(return_value_memcmp$37 == 0))
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$36 = dcc->sess;

            else
              tmp_if_expr$36 = (struct gg_session *)(void *)0;
            gg_debug_session(tmp_if_expr$36, 16, "// gg_dcc7_watch_fd() invalid id\n");
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return e;
          }

        }

        else
        {
          struct gg_dcc7_welcome_server welcome;
          struct gg_dcc7_welcome_server welcome_ok;
          welcome_ok.magic = 0xc0debabe;
          welcome_ok.id = dcc->cid;
          signed long int return_value_recv$41;
          return_value_recv$41=recv(dcc->fd, (void *)&welcome, sizeof(struct gg_dcc7_welcome_server) /*12ul*/ , 0);
          gg_dcc7_watch_fd$$1$$3$$3$$res = (signed int)return_value_recv$41;
          if(!((unsigned long int)gg_dcc7_watch_fd$$1$$3$$3$$res == sizeof(struct gg_dcc7_welcome_server) /*12ul*/ ))
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$38 = dcc->sess;

            else
              tmp_if_expr$38 = (struct gg_session *)(void *)0;
            signed int *return_value___errno_location$39;
            return_value___errno_location$39=__errno_location();
            char *return_value_strerror$40;
            return_value_strerror$40=strerror(*return_value___errno_location$39);
            gg_debug_session(tmp_if_expr$38, 16, "// gg_dcc7_watch_fd() recv() failed (%d, %s)\n", gg_dcc7_watch_fd$$1$$3$$3$$res, return_value_strerror$40);
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return e;
          }

          signed int return_value_memcmp$43;
          return_value_memcmp$43=memcmp((const void *)&welcome, (const void *)&welcome_ok, sizeof(struct gg_dcc7_welcome_server) /*12ul*/ );
          if(!(return_value_memcmp$43 == 0))
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$42 = dcc->sess;

            else
              tmp_if_expr$42 = (struct gg_session *)(void *)0;
            gg_debug_session(tmp_if_expr$42, 16, "// gg_dcc7_watch_fd() invalid id\n");
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return e;
          }

        }
        if(!(dcc->incoming == 0))
        {
          dcc->state = GG_STATE_SENDING_ID;
          dcc->check = 1;
          dcc->timeout = 30;
        }

        else
        {
          gg_dcc7_postauth_fixup(dcc);
          dcc->timeout = 30;
        }
        return e;
      }
      case GG_STATE_SENDING_ID:
      {
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$44 = dcc->sess;

        else
          tmp_if_expr$44 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$44, 16, "// gg_dcc7_watch_fd() GG_SENDING_ID\n");
        if(dcc->relay == 0)
        {
          struct gg_dcc7_welcome_p2p gg_dcc7_watch_fd$$1$$3$$4$$1$$welcome;
          gg_dcc7_watch_fd$$1$$3$$4$$1$$welcome.id = dcc->cid;
          signed long int return_value_send$48;
          return_value_send$48=send(dcc->fd, (const void *)&gg_dcc7_watch_fd$$1$$3$$4$$1$$welcome, sizeof(struct gg_dcc7_welcome_p2p) /*8ul*/ , 0);
          res = (signed int)return_value_send$48;
          if(!((unsigned long int)res == sizeof(struct gg_dcc7_welcome_p2p) /*8ul*/ ))
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$45 = dcc->sess;

            else
              tmp_if_expr$45 = (struct gg_session *)(void *)0;
            signed int *return_value___errno_location$46;
            return_value___errno_location$46=__errno_location();
            char *return_value_strerror$47;
            return_value_strerror$47=strerror(*return_value___errno_location$46);
            gg_debug_session(tmp_if_expr$45, 16, "// gg_dcc7_watch_fd() send() failed (%d, %s)\n", res, return_value_strerror$47);
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return e;
          }

        }

        else
        {
          struct gg_dcc7_welcome_server gg_dcc7_watch_fd$$1$$3$$4$$2$$welcome;
          gg_dcc7_watch_fd$$1$$3$$4$$2$$welcome.magic=gg_fix32(0xc0debabe);
          gg_dcc7_watch_fd$$1$$3$$4$$2$$welcome.id = dcc->cid;
          signed long int return_value_send$52;
          return_value_send$52=send(dcc->fd, (const void *)&gg_dcc7_watch_fd$$1$$3$$4$$2$$welcome, sizeof(struct gg_dcc7_welcome_server) /*12ul*/ , 0);
          res = (signed int)return_value_send$52;
          if(!((unsigned long int)res == sizeof(struct gg_dcc7_welcome_server) /*12ul*/ ))
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$49 = dcc->sess;

            else
              tmp_if_expr$49 = (struct gg_session *)(void *)0;
            signed int *return_value___errno_location$50;
            return_value___errno_location$50=__errno_location();
            char *return_value_strerror$51;
            return_value_strerror$51=strerror(*return_value___errno_location$50);
            gg_debug_session(tmp_if_expr$49, 16, "// gg_dcc7_watch_fd() send() failed (%d, %s)\n", res, return_value_strerror$51);
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
            return e;
          }

        }
        if(!(dcc->incoming == 0))
        {
          gg_dcc7_postauth_fixup(dcc);
          dcc->timeout = 30;
        }

        else
        {
          dcc->state = GG_STATE_READING_ID;
          dcc->check = 2;
          dcc->timeout = 30;
        }
        return e;
      }
      case GG_STATE_SENDING_FILE:
      {
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$53 = dcc->sess;

        else
          tmp_if_expr$53 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$53, 16, "// gg_dcc7_watch_fd() GG_STATE_SENDING_FILE (offset=%d, size=%d)\n", dcc->offset, dcc->size);
        if(dcc->offset >= dcc->size)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$54 = dcc->sess;

          else
            tmp_if_expr$54 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$54, 16, "// gg_dcc7_watch_fd() offset >= size, finished\n");
          e->type = GG_EVENT_DCC7_DONE;
          e->event.dcc7_done.dcc7 = dcc;
          return e;
        }

        if(!(dcc->seek == 0))
        {
          return_value_lseek$58=lseek(dcc->file_fd, (signed long int)dcc->offset, 0);
          if(return_value_lseek$58 == -1l)
          {
            if(!(dcc == ((struct gg_dcc7 *)NULL)))
              tmp_if_expr$55 = dcc->sess;

            else
              tmp_if_expr$55 = (struct gg_session *)(void *)0;
            signed int *return_value___errno_location$56;
            return_value___errno_location$56=__errno_location();
            char *return_value_strerror$57;
            return_value_strerror$57=strerror(*return_value___errno_location$56);
            gg_debug_session(tmp_if_expr$55, 16, "// gg_dcc7_watch_fd() lseek() failed (%s)\n", return_value_strerror$57);
            e->type = GG_EVENT_DCC7_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_FILE;
            return e;
          }

        }

        chunk = (unsigned long int)(dcc->size - dcc->offset);
        if(chunk >= 1025ul)
          chunk = sizeof(char [1024l]) /*1024ul*/ ;

        return_value_read$62=read(dcc->file_fd, (void *)gg_dcc7_watch_fd$$1$$3$$5$$buf, chunk);
        gg_dcc7_watch_fd$$1$$3$$5$$res = (signed int)return_value_read$62;
        if(!(gg_dcc7_watch_fd$$1$$3$$5$$res >= 1))
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$59 = dcc->sess;

          else
            tmp_if_expr$59 = (struct gg_session *)(void *)0;
          signed int *return_value___errno_location$60;
          return_value___errno_location$60=__errno_location();
          char *return_value_strerror$61;
          return_value_strerror$61=strerror(*return_value___errno_location$60);
          gg_debug_session(tmp_if_expr$59, 16, "// gg_dcc7_watch_fd() read() failed (res=%d, %s)\n", gg_dcc7_watch_fd$$1$$3$$5$$res, return_value_strerror$61);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)(gg_dcc7_watch_fd$$1$$3$$5$$res == -1 ? GG_ERROR_DCC7_FILE : GG_ERROR_DCC7_EOF);
          return e;
        }

        return_value_send$66=send(dcc->fd, (const void *)gg_dcc7_watch_fd$$1$$3$$5$$buf, (unsigned long int)gg_dcc7_watch_fd$$1$$3$$5$$res, 0);
        gg_dcc7_watch_fd$$1$$3$$5$$res = (signed int)return_value_send$66;
        if(gg_dcc7_watch_fd$$1$$3$$5$$res == -1)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$63 = dcc->sess;

          else
            tmp_if_expr$63 = (struct gg_session *)(void *)0;
          signed int *return_value___errno_location$64;
          return_value___errno_location$64=__errno_location();
          char *return_value_strerror$65;
          return_value_strerror$65=strerror(*return_value___errno_location$64);
          gg_debug_session(tmp_if_expr$63, 16, "// gg_dcc7_watch_fd() send() failed (%s)\n", return_value_strerror$65);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_NET;
          return e;
        }

        dcc->offset = dcc->offset + (unsigned int)gg_dcc7_watch_fd$$1$$3$$5$$res;
        if(dcc->offset >= dcc->size)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$67 = dcc->sess;

          else
            tmp_if_expr$67 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$67, 16, "// gg_dcc7_watch_fd() finished\n");
          e->type = GG_EVENT_DCC7_DONE;
          e->event.dcc7_done.dcc7 = dcc;
          return e;
        }

        dcc->state = GG_STATE_SENDING_FILE;
        dcc->check = 1;
        dcc->timeout = 1800;
        return e;
      }
      case GG_STATE_GETTING_FILE:
      {
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$68 = dcc->sess;

        else
          tmp_if_expr$68 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$68, 16, "// gg_dcc7_watch_fd() GG_STATE_GETTING_FILE (offset=%d, size=%d)\n", dcc->offset, dcc->size);
        if(dcc->offset >= dcc->size)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$69 = dcc->sess;

          else
            tmp_if_expr$69 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$69, 16, "// gg_dcc7_watch_fd() finished\n");
          e->type = GG_EVENT_DCC7_DONE;
          e->event.dcc7_done.dcc7 = dcc;
          return e;
        }

        return_value_recv$73=recv(dcc->fd, (void *)gg_dcc7_watch_fd$$1$$3$$6$$buf, sizeof(char [1024l]) /*1024ul*/ , 0);
        gg_dcc7_watch_fd$$1$$3$$6$$res = (signed int)return_value_recv$73;
        if(!(gg_dcc7_watch_fd$$1$$3$$6$$res >= 1))
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$70 = dcc->sess;

          else
            tmp_if_expr$70 = (struct gg_session *)(void *)0;
          signed int *return_value___errno_location$71;
          return_value___errno_location$71=__errno_location();
          char *return_value_strerror$72;
          return_value_strerror$72=strerror(*return_value___errno_location$71);
          gg_debug_session(tmp_if_expr$70, 16, "// gg_dcc7_watch_fd() recv() failed (fd=%d, res=%d, %s)\n", dcc->fd, gg_dcc7_watch_fd$$1$$3$$6$$res, return_value_strerror$72);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)(gg_dcc7_watch_fd$$1$$3$$6$$res == -1 ? GG_ERROR_DCC7_NET : GG_ERROR_DCC7_EOF);
          return e;
        }

        return_value_write$77=write(dcc->file_fd, (const void *)gg_dcc7_watch_fd$$1$$3$$6$$buf, (unsigned long int)gg_dcc7_watch_fd$$1$$3$$6$$res);
        wres = (signed int)return_value_write$77;
        if(!(wres >= gg_dcc7_watch_fd$$1$$3$$6$$res))
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$74 = dcc->sess;

          else
            tmp_if_expr$74 = (struct gg_session *)(void *)0;
          signed int *return_value___errno_location$75;
          return_value___errno_location$75=__errno_location();
          char *return_value_strerror$76;
          return_value_strerror$76=strerror(*return_value___errno_location$75);
          gg_debug_session(tmp_if_expr$74, 16, "// gg_dcc7_watch_fd() write() failed (fd=%d, res=%d, %s)\n", dcc->file_fd, wres, return_value_strerror$76);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_FILE;
          return e;
        }

        dcc->offset = dcc->offset + (unsigned int)gg_dcc7_watch_fd$$1$$3$$6$$res;
        if(dcc->offset >= dcc->size)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$78 = dcc->sess;

          else
            tmp_if_expr$78 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$78, 16, "// gg_dcc7_watch_fd() finished\n");
          e->type = GG_EVENT_DCC7_DONE;
          e->event.dcc7_done.dcc7 = dcc;
          return e;
        }

        dcc->state = GG_STATE_GETTING_FILE;
        dcc->check = 2;
        dcc->timeout = 1800;
        return e;
      }
      case GG_STATE_RESOLVING_RELAY:
      {
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$79 = dcc->sess;

        else
          tmp_if_expr$79 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$79, 16, "// gg_dcc7_watch_fd() GG_STATE_RESOLVING_RELAY\n");
        do
        {
          gg_dcc7_watch_fd$$1$$3$$7$$res=gg_resolver_recv(dcc->fd, (void *)&gg_dcc7_watch_fd$$1$$3$$7$$addr, sizeof(struct in_addr) /*4ul*/ );
          if(gg_dcc7_watch_fd$$1$$3$$7$$res == -1)
          {
            return_value___errno_location$80=__errno_location();
            tmp_if_expr$81 = *return_value___errno_location$80 == 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$81 = (_Bool)0;
        }
        while(tmp_if_expr$81);
        dcc->sess->resolver_cleanup(&dcc->resolver, 0);
      }
      case GG_STATE_CONNECTING_RELAY:
      {
        res_size = (unsigned int)sizeof(signed int) /*4ul*/ ;
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$91 = dcc->sess;

        else
          tmp_if_expr$91 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$91, 16, "// gg_dcc7_watch_fd() GG_STATE_CONNECTING_RELAY\n");
        return_value_getsockopt$94=getsockopt(dcc->fd, 1, 4, (void *)&gg_dcc7_watch_fd$$1$$3$$8$$res, &res_size);
        if(!(return_value_getsockopt$94 == 0) || !(gg_dcc7_watch_fd$$1$$3$$8$$res == 0))
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$92 = dcc->sess;

          else
            tmp_if_expr$92 = (struct gg_session *)(void *)0;
          char *return_value_strerror$93;
          return_value_strerror$93=strerror(gg_dcc7_watch_fd$$1$$3$$8$$res);
          gg_debug_session(tmp_if_expr$92, 16, "// gg_dcc7_watch_fd() connection failed (errno=%d, %s)\n", gg_dcc7_watch_fd$$1$$3$$8$$res, return_value_strerror$93);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_RELAY;
          return e;
        }

        memset((void *)&pkt, 0, sizeof(struct gg_dcc7_relay_req) /*20ul*/ );
        pkt.magic=gg_fix32((unsigned int)0x0a);
        pkt.len=gg_fix32((unsigned int)sizeof(struct gg_dcc7_relay_req) /*20ul*/ );
        pkt.id = dcc->cid;
        pkt.type=gg_fix16((unsigned short int)0x01);
        pkt.dunno1=gg_fix16((unsigned short int)0x02);
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$95 = dcc->sess;

        else
          tmp_if_expr$95 = (struct gg_session *)(void *)0;
        return_value_gg_fix32$96=gg_fix32(pkt.magic);
        gg_debug_session(tmp_if_expr$95, 4, "// gg_dcc7_watch_fd() send pkt(0x%.2x)\n", return_value_gg_fix32$96);
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$97 = dcc->sess;

        else
          tmp_if_expr$97 = (struct gg_session *)(void *)0;
        gg_debug_dump(tmp_if_expr$97, 4, (const char *)&pkt, sizeof(struct gg_dcc7_relay_req) /*20ul*/ );
        return_value_send$99=send(dcc->fd, (const void *)&pkt, sizeof(struct gg_dcc7_relay_req) /*20ul*/ , 0);
        gg_dcc7_watch_fd$$1$$3$$8$$res = (signed int)return_value_send$99;
        if(!((unsigned long int)gg_dcc7_watch_fd$$1$$3$$8$$res == sizeof(struct gg_dcc7_relay_req) /*20ul*/ ))
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$98 = dcc->sess;

          else
            tmp_if_expr$98 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$98, 16, "// gg_dcc7_watch_fd() sending failed\n");
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_RELAY;
          return e;
        }

        dcc->state = GG_STATE_READING_RELAY;
        dcc->check = 2;
        dcc->timeout = 30;
        return e;
      }
      case GG_STATE_READING_RELAY:
      {
        max_relay_count = (sizeof(char [256l]) /*256ul*/  - sizeof(struct gg_dcc7_relay_reply) /*12ul*/ ) / sizeof(struct gg_dcc7_relay_reply_server) /*7ul*/ ;
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$100 = dcc->sess;

        else
          tmp_if_expr$100 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$100, 16, "// gg_dcc7_watch_fd() GG_STATE_READING_RELAY\n");
        return_value_recv$105=recv(dcc->fd, (void *)buf, sizeof(char [256l]) /*256ul*/ , 0);
        gg_dcc7_watch_fd$$1$$3$$9$$res = (signed int)return_value_recv$105;
        if(!(gg_dcc7_watch_fd$$1$$3$$9$$res >= (signed int)sizeof(struct gg_dcc7_relay_reply) /*12*/ ))
        {
          if(gg_dcc7_watch_fd$$1$$3$$9$$res == 0)
          {
            return_value___errno_location$101=__errno_location();
            *return_value___errno_location$101 = 104;
          }

          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$102 = dcc->sess;

          else
            tmp_if_expr$102 = (struct gg_session *)(void *)0;
          signed int *return_value___errno_location$103;
          return_value___errno_location$103=__errno_location();
          char *return_value_strerror$104;
          return_value_strerror$104=strerror(*return_value___errno_location$103);
          gg_debug_session(tmp_if_expr$102, 16, "// gg_dcc7_watch_fd() recv() failed (%d, %s)\n", gg_dcc7_watch_fd$$1$$3$$9$$res, return_value_strerror$104);
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_RELAY;
          return e;
        }

        gg_dcc7_watch_fd$$1$$3$$9$$pkt = (struct gg_dcc7_relay_reply *)buf;
        return_value_gg_fix32$108=gg_fix32(gg_dcc7_watch_fd$$1$$3$$9$$pkt->magic);
        if(!(return_value_gg_fix32$108 == 11u))
          tmp_if_expr$110 = (_Bool)1;

        else
        {
          return_value_gg_fix32$109=gg_fix32(gg_dcc7_watch_fd$$1$$3$$9$$pkt->rcount);
          tmp_if_expr$110 = return_value_gg_fix32$109 < (unsigned int)1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$110)
          tmp_if_expr$112 = (_Bool)1;

        else
        {
          return_value_gg_fix32$111=gg_fix32(gg_dcc7_watch_fd$$1$$3$$9$$pkt->rcount);
          tmp_if_expr$112 = return_value_gg_fix32$111 > (unsigned int)256 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$112)
          tmp_if_expr$115 = (_Bool)1;

        else
        {
          return_value_gg_fix32$113=gg_fix32(gg_dcc7_watch_fd$$1$$3$$9$$pkt->len);
          return_value_gg_fix32$114=gg_fix32(gg_dcc7_watch_fd$$1$$3$$9$$pkt->rcount);
          tmp_if_expr$115 = (unsigned long int)return_value_gg_fix32$113 < sizeof(struct gg_dcc7_relay_reply) /*12ul*/  + (unsigned long int)return_value_gg_fix32$114 * sizeof(struct gg_dcc7_relay_reply_server) /*7ul*/  ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$115)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$106 = dcc->sess;

          else
            tmp_if_expr$106 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$106, 16, "// gg_dcc7_wathc_fd() invalid reply\n");
          signed int *return_value___errno_location$107;
          return_value___errno_location$107=__errno_location();
          *return_value___errno_location$107 = 22;
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_RELAY;
          return e;
        }

        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$116 = dcc->sess;

        else
          tmp_if_expr$116 = (struct gg_session *)(void *)0;
        return_value_gg_fix32$117=gg_fix32(gg_dcc7_watch_fd$$1$$3$$9$$pkt->magic);
        gg_debug_session(tmp_if_expr$116, 4, "// gg_dcc7_get_relay() read pkt(0x%.2x)\n", return_value_gg_fix32$117);
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$118 = dcc->sess;

        else
          tmp_if_expr$118 = (struct gg_session *)(void *)0;
        gg_debug_dump(tmp_if_expr$118, 4, buf, (unsigned long int)gg_dcc7_watch_fd$$1$$3$$9$$res);
        free((void *)dcc->relay_list);
        dcc->relay_index = 0;
        return_value_gg_fix32$119=gg_fix32(gg_dcc7_watch_fd$$1$$3$$9$$pkt->rcount);
        dcc->relay_count = (signed int)return_value_gg_fix32$119;
        if(dcc->relay_count >= 65536)
          tmp_if_expr$121 = (_Bool)1;

        else
          tmp_if_expr$121 = (unsigned long int)dcc->relay_count > max_relay_count ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$121)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$120 = dcc->sess;

          else
            tmp_if_expr$120 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$120, 16, "// gg_dcc7_watch_fd() relay_count out of bounds (%d)\n", dcc->relay_count);
          dcc->relay_count = 0;
          free((void *)e);
          return (struct gg_event *)(void *)0;
        }

        return_value_malloc$122=malloc((unsigned long int)dcc->relay_count * sizeof(struct gg_dcc7_relay) /*8ul*/ );
        dcc->relay_list = (struct gg_dcc7_relay *)return_value_malloc$122;
        if(dcc->relay_list == ((struct gg_dcc7_relay *)NULL))
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$123 = dcc->sess;

          else
            tmp_if_expr$123 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$123, 16, "// gg_dcc7_watch_fd() not enough memory\n");
          dcc->relay_count = 0;
          free((void *)e);
          return (struct gg_event *)(void *)0;
        }

        i = 0;
        for( ; !(i >= dcc->relay_count); i = i + 1)
        {
          struct in_addr addr;
          memcpy((void *)&srv, (const void *)(buf + (signed long int)sizeof(struct gg_dcc7_relay_reply) /*12ul*/  + (signed long int)((unsigned long int)i * sizeof(struct gg_dcc7_relay_reply_server) /*7ul*/ )), sizeof(struct gg_dcc7_relay_reply_server) /*7ul*/ );
          (dcc->relay_list + (signed long int)i)->addr = srv.addr;
          (dcc->relay_list + (signed long int)i)->port=gg_fix16(srv.port);
          (dcc->relay_list + (signed long int)i)->family = srv.family;
          addr.s_addr = srv.addr;
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$124 = dcc->sess;

          else
            tmp_if_expr$124 = (struct gg_session *)(void *)0;
          char *return_value_inet_ntoa$125;
          return_value_inet_ntoa$125=inet_ntoa(addr);
          unsigned short int return_value_gg_fix16$126;
          return_value_gg_fix16$126=gg_fix16(srv.port);
          gg_debug_session(tmp_if_expr$124, 16, "//    %s %d %d\n", return_value_inet_ntoa$125, return_value_gg_fix16$126, srv.family);
        }
        dcc->relay = 1;
        for( ; !(dcc->relay_index >= dcc->relay_count); dcc->relay_index = dcc->relay_index + 1)
        {
          dcc->remote_addr = (dcc->relay_list + (signed long int)dcc->relay_index)->addr;
          dcc->remote_port = (dcc->relay_list + (signed long int)dcc->relay_index)->port;
          signed int return_value_gg_dcc7_connect$127;
          return_value_gg_dcc7_connect$127=gg_dcc7_connect(dcc);
          if(return_value_gg_dcc7_connect$127 == 0)
            break;

        }
        if(dcc->relay_index >= dcc->relay_count)
        {
          if(!(dcc == ((struct gg_dcc7 *)NULL)))
            tmp_if_expr$128 = dcc->sess;

          else
            tmp_if_expr$128 = (struct gg_session *)(void *)0;
          gg_debug_session(tmp_if_expr$128, 16, "// gg_dcc7_watch_fd() no relay available\n");
          e->type = GG_EVENT_DCC7_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_RELAY;
          return e;
        }

        return e;
      }
      default:
      {
        if(!(dcc == ((struct gg_dcc7 *)NULL)))
          tmp_if_expr$129 = dcc->sess;

        else
          tmp_if_expr$129 = (struct gg_session *)(void *)0;
        gg_debug_session(tmp_if_expr$129, 16, "// gg_dcc7_watch_fd() GG_STATE_???\n");
        e->type = GG_EVENT_DCC7_ERROR;
        e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC7_HANDSHAKE;
        return e;
      }
    }
    return e;
  }
}

// gg_dcc_callback
// file dcc.c line 362
static signed int gg_dcc_callback(struct gg_dcc *d)
{
  struct gg_event *e;
  e=gg_dcc_watch_fd(d);
  d->event = e;
  return e != (struct gg_event *)(void *)0 ? 0 : -1;
}

// gg_dcc_debug_data
// file dcc.c line 49
static void gg_dcc_debug_data(const char *prefix, signed int fd, const void *buf, unsigned int size)
{
  gg_debug(16, "++ gg_dcc %s (fd=%d,len=%d)", prefix, fd, size);
  gg_debug_dump((struct gg_session *)(void *)0, 4, (const char *)buf, (unsigned long int)size);
  gg_debug(16, "\n");
}

// gg_dcc_fill_file_info
// file dcc.c line 110
signed int gg_dcc_fill_file_info(struct gg_dcc *d, const char *filename)
{
  signed int return_value_gg_dcc_fill_file_info2$1;
  return_value_gg_dcc_fill_file_info2$1=gg_dcc_fill_file_info2(d, filename, filename);
  return return_value_gg_dcc_fill_file_info2$1;
}

// gg_dcc_fill_file_info2
// file dcc.c line 126
signed int gg_dcc_fill_file_info2(struct gg_dcc *d, const char *filename, const char *local_filename)
{
  struct stat st;
  const char *name;
  const char *ext;
  const char *p;
  unsigned char *q;
  signed int i;
  signed int j;
  gg_debug(8, "** gg_dcc_fill_file_info2(%p, \"%s\", \"%s\");\n", d, filename, local_filename);
  _Bool tmp_if_expr$2;
  if(d == ((struct gg_dcc *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = d->type != 10 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    gg_debug(16, "// gg_dcc_fill_file_info2() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  d->file_fd=open(local_filename, 00);
  if(d->file_fd == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    gg_debug(16, "// gg_dcc_fill_file_info2() open() failed (%s)\n", return_value_strerror$4);
    return -1;
  }

  signed int return_value_fstat$7;
  return_value_fstat$7=fstat(d->file_fd, &st);
  if(return_value_fstat$7 == -1)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    gg_debug(16, "// gg_dcc_fill_file_info2() fstat() failed (%s)\n", return_value_strerror$6);
    close(d->file_fd);
    d->file_fd = -1;
    return -1;
  }

  if(!((16384u & st.st_mode) == 0u))
  {
    gg_debug(16, "// gg_dcc_fill_file_info2() that's a directory\n");
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    *return_value___errno_location$8 = 22;
    close(d->file_fd);
    d->file_fd = -1;
    return -1;
  }

  memset((void *)&d->file_info, 0, sizeof(struct gg_file_info) /*320ul*/ );
  unsigned int return_value_gg_fix32$9;
  if((128u & st.st_mode) == 0u)
  {
    return_value_gg_fix32$9=gg_fix32((unsigned int)0x0020);
    d->file_info.mode = d->file_info.mode | return_value_gg_fix32$9;
  }

  gg_dcc_fill_filetime((unsigned int)st.st_atim.tv_sec, d->file_info.atime);
  gg_dcc_fill_filetime((unsigned int)st.st_mtim.tv_sec, d->file_info.mtime);
  gg_dcc_fill_filetime((unsigned int)st.st_ctim.tv_sec, d->file_info.ctime);
  d->file_info.size=gg_fix32((unsigned int)st.st_size);
  d->file_info.mode=gg_fix32((unsigned int)0x20);
  name=strrchr(filename, 47);
  if(name == ((const char *)NULL))
    name = filename;

  else
    name = name + 1l;
  ext=strrchr(name, 46);
  unsigned long int return_value_strlen$10;
  if(ext == ((const char *)NULL))
  {
    return_value_strlen$10=strlen(name);
    ext = name + (signed long int)return_value_strlen$10;
  }

  i = 0;
  p = name;
  signed int return_value_toupper$11;
  for( ; !(p >= ext) && !(i >= 8); p = p + 1l)
  {
    return_value_toupper$11=toupper((signed int)name[(signed long int)i]);
    d->file_info.short_filename[(signed long int)i] = (unsigned char)return_value_toupper$11;
    i = i + 1;
  }
  if(i == 8 && !(p >= ext))
  {
    d->file_info.short_filename[(signed long int)6] = (unsigned char)126;
    d->file_info.short_filename[(signed long int)7] = (unsigned char)49;
  }

  unsigned long int return_value_strlen$13;
  return_value_strlen$13=strlen(ext);
  signed int return_value_toupper$12;
  if(return_value_strlen$13 >= 1ul)
  {
    j = 0;
    for( ; !(*ext == 0) && !(j >= 4); p = p + 1l)
    {
      return_value_toupper$12=toupper((signed int)ext[(signed long int)j]);
      d->file_info.short_filename[(signed long int)(i + j)] = (unsigned char)return_value_toupper$12;
      j = j + 1;
    }
  }

  q = d->file_info.short_filename;
  for( ; !(*q == 0); q = q + 1l)
    if((signed int)*q == 185)
      *q = (unsigned char)165;

    else
      if((signed int)*q == 230)
        *q = (unsigned char)198;

      else
        if((signed int)*q == 234)
          *q = (unsigned char)202;

        else
          if((signed int)*q == 179)
            *q = (unsigned char)163;

          else
            if((signed int)*q == 241)
              *q = (unsigned char)209;

            else
              if((signed int)*q == 243)
                *q = (unsigned char)211;

              else
                if((signed int)*q == 156)
                  *q = (unsigned char)140;

                else
                  if((signed int)*q == 159)
                    *q = (unsigned char)143;

                  else
                    if((signed int)*q == 191)
                      *q = (unsigned char)175;

  gg_debug(16, "// gg_dcc_fill_file_info2() short name \"%s\", dos name \"%s\"\n", name, (const void *)d->file_info.short_filename);
  strncpy((char *)d->file_info.filename, name, sizeof(unsigned char [262l]) /*262ul*/  - (unsigned long int)1);
  return 0;
}

// gg_dcc_fill_filetime
// file dcc.c line 85
static void gg_dcc_fill_filetime(unsigned int ut, unsigned int *ft)
{
  unsigned long int tmp = (unsigned long int)ut;
  tmp = tmp + (unsigned long int)11644473600LL;
  tmp = tmp * (unsigned long int)10000000LL;
  tmp=gg_fix64(tmp);
  memcpy((void *)ft, (const void *)&tmp, sizeof(unsigned long int) /*8ul*/ );
}

// gg_dcc_free
// file dcc.c line 1385
void gg_dcc_free(struct gg_dcc *d)
{
  gg_debug(8, "** gg_dcc_free(%p);\n", d);
  if(!(d == ((struct gg_dcc *)NULL)))
  {
    if(!(d->fd == -1))
      close(d->fd);

    if(!(d->file_fd == -1))
      close(d->file_fd);

    free((void *)d->chunk_buf);
    free((void *)d);
  }

}

// gg_dcc_get_file
// file dcc.c line 288
struct gg_dcc * gg_dcc_get_file(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin)
{
  gg_debug(16, "// gg_dcc_get_file() handing over to gg_dcc_transfer()\n");
  struct gg_dcc *return_value_gg_dcc_transfer$1;
  return_value_gg_dcc_transfer$1=gg_dcc_transfer(ip, port, my_uin, peer_uin, 11);
  return return_value_gg_dcc_transfer$1;
}

// gg_dcc_request
// file dcc.c line 71
signed int gg_dcc_request(struct gg_session *sess, unsigned int uin)
{
  signed int return_value_gg_send_message_ctcp$1;
  return_value_gg_send_message_ctcp$1=gg_send_message_ctcp(sess, 0x0010, uin, (const unsigned char *)"\002", 1);
  return return_value_gg_send_message_ctcp$1;
}

// gg_dcc_send_file
// file dcc.c line 307
struct gg_dcc * gg_dcc_send_file(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin)
{
  gg_debug(16, "// gg_dcc_send_file() handing over to gg_dcc_transfer()\n");
  struct gg_dcc *return_value_gg_dcc_transfer$1;
  return_value_gg_dcc_transfer$1=gg_dcc_transfer(ip, port, my_uin, peer_uin, 10);
  return return_value_gg_dcc_transfer$1;
}

// gg_dcc_set_type
// file dcc.c line 344
void gg_dcc_set_type(struct gg_dcc *d, signed int type)
{
  d->type = type;
  d->state = type == 10 ? GG_STATE_SENDING_FILE_INFO : GG_STATE_SENDING_VOICE_REQUEST;
}

// gg_dcc_socket_create
// file dcc.c line 386
struct gg_dcc * gg_dcc_socket_create(unsigned int uin, unsigned short int port)
{
  struct gg_dcc *c;
  signed int sock;
  signed int bound = 0;
  signed int errno2;
  gg_debug(8, "** gg_create_dcc_socket(%d, %d);\n", uin, port);
  if(uin == 0u)
  {
    gg_debug(16, "// gg_create_dcc_socket() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (struct gg_dcc *)(void *)0;
  }

  sock=socket(2, 1, 6);
  if(sock == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    gg_debug(16, "// gg_create_dcc_socket() can't create socket (%s)\n", return_value_strerror$3);
    return (struct gg_dcc *)(void *)0;
  }

  if(port == 65535 || (signed int)port == 0)
    port = (unsigned short int)1550;

  while(bound == 0)
  {
    struct sockaddr_in sin;
    memset((void *)&sin, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    sin.sin_family = (unsigned short int)2;
    sin.sin_addr.s_addr = (unsigned int)0x00000000;
    sin.sin_port=htons(port);
    gg_debug(16, "// gg_create_dcc_socket() trying port %d\n", port);
    signed int return_value_bind$4;
    return_value_bind$4=bind(sock, (struct sockaddr *)&sin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(return_value_bind$4 == 0)
      bound = 1;

    else
    {
      port = port + 1;
      if((signed int)port == 65535)
      {
        gg_debug(16, "// gg_create_dcc_socket() no free port found\n");
        close(sock);
        return (struct gg_dcc *)(void *)0;
      }

    }
  }
  signed int return_value_listen$9;
  return_value_listen$9=listen(sock, 10);
  if(!(return_value_listen$9 == 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    gg_debug(16, "// gg_create_dcc_socket() unable to listen (%s)\n", return_value_strerror$6);
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    errno2 = *return_value___errno_location$7;
    close(sock);
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    *return_value___errno_location$8 = errno2;
    return (struct gg_dcc *)(void *)0;
  }

  gg_debug(16, "// gg_create_dcc_socket() bound to port %d\n", port);
  void *return_value_malloc$10;
  return_value_malloc$10=malloc(sizeof(struct gg_dcc) /*448ul*/ );
  c = (struct gg_dcc *)return_value_malloc$10;
  if(c == ((struct gg_dcc *)NULL))
  {
    gg_debug(16, "// gg_create_dcc_socket() not enough memory for struct\n");
    close(sock);
    return (struct gg_dcc *)(void *)0;
  }

  else
  {
    memset((void *)c, 0, sizeof(struct gg_dcc) /*448ul*/ );
    c->id = (signed int)port;
    c->port = c->id;
    c->fd = sock;
    c->file_fd = -1;
    c->type = 9;
    c->uin = uin;
    c->timeout = -1;
    c->state = GG_STATE_LISTENING;
    c->check = 2;
    c->callback = gg_dcc_callback;
    c->destroy = gg_dcc_free;
    return c;
  }
}

// gg_dcc_transfer
// file dcc.c line 235
static struct gg_dcc * gg_dcc_transfer(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin, signed int type)
{
  struct gg_dcc *d = (struct gg_dcc *)(void *)0;
  struct in_addr addr;
  addr.s_addr = ip;
  char *return_value_inet_ntoa$1;
  return_value_inet_ntoa$1=inet_ntoa(addr);
  gg_debug(8, "** gg_dcc_transfer(%s, %d, %u, %u, %s);\n", return_value_inet_ntoa$1, port, my_uin, peer_uin, type == 10 ? "SEND" : "GET");
  if(port == 0 || ip == 0u || ip == 0xffffffff || my_uin == 0u || peer_uin == 0u)
  {
    gg_debug(16, "// gg_dcc_transfer() invalid arguments\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return (struct gg_dcc *)(void *)0;
  }

  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct gg_dcc) /*448ul*/ );
  d = (struct gg_dcc *)(void *)return_value_calloc$3;
  if(d == ((struct gg_dcc *)NULL))
  {
    gg_debug(16, "// gg_dcc_transfer() not enough memory\n");
    return (struct gg_dcc *)(void *)0;
  }

  else
  {
    d->check = 1;
    d->state = GG_STATE_CONNECTING;
    d->type = type;
    d->timeout = 30;
    d->file_fd = -1;
    d->active = 1;
    d->fd = -1;
    d->uin = my_uin;
    d->peer_uin = peer_uin;
    d->fd=gg_connect((void *)&addr, (signed int)port, 1);
    if(d->fd == -1)
    {
      gg_debug(16, "// gg_dcc_transfer() connection failed\n");
      free((void *)d);
      return (struct gg_dcc *)(void *)0;
    }

    else
      return d;
  }
}

// gg_dcc_voice_chat
// file dcc.c line 326
struct gg_dcc * gg_dcc_voice_chat(unsigned int ip, unsigned short int port, unsigned int my_uin, unsigned int peer_uin)
{
  gg_debug(16, "// gg_dcc_voice_chat() handing over to gg_dcc_transfer()\n");
  struct gg_dcc *return_value_gg_dcc_transfer$1;
  return_value_gg_dcc_transfer$1=gg_dcc_transfer(ip, port, my_uin, peer_uin, 12);
  return return_value_gg_dcc_transfer$1;
}

// gg_dcc_voice_send
// file dcc.c line 469
signed int gg_dcc_voice_send(struct gg_dcc *d, char *buf, signed int length)
{
  /* gg_dcc_voice_send::1::tag-packet_s */
struct packet_s
{
  // type
  unsigned char type;
  // length
  unsigned int length;
} __attribute__ ((__packed__));

/* */
  ;
  struct packet_s packet;
  gg_debug(8, "++ gg_dcc_voice_send(%p, %p, %d);\n", d, buf, length);
  _Bool tmp_if_expr$2;
  if(buf == ((char *)NULL) || d == ((struct gg_dcc *)NULL) || !(length >= 0))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = d->type != 12 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    gg_debug(16, "// gg_dcc_voice_send() invalid argument\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  packet.type = (unsigned char)0x03;
  packet.length=gg_fix32((unsigned int)length);
  signed long int return_value_send$3;
  return_value_send$3=send(d->fd, (const void *)&packet, sizeof(struct packet_s) /*5ul*/ , 0);
  if(!(return_value_send$3 >= (signed long int)sizeof(struct packet_s) /*5l*/ ))
  {
    gg_debug(16, "// gg_dcc_voice_send() send() failed\n");
    return -1;
  }

  else
  {
    gg_dcc_debug_data("write", d->fd, (const void *)&packet, (unsigned int)sizeof(struct packet_s) /*5ul*/ );
    signed long int return_value_send$4;
    return_value_send$4=send(d->fd, (const void *)buf, (unsigned long int)length, 0);
    if(!(return_value_send$4 >= (signed long int)length))
    {
      gg_debug(16, "// gg_dcc_voice_send() send() failed\n");
      return -1;
    }

    else
    {
      gg_dcc_debug_data("write", d->fd, (const void *)buf, (unsigned int)length);
      return 0;
    }
  }
}

// gg_dcc_watch_fd
// file dcc.c line 572
struct gg_event * gg_dcc_watch_fd(struct gg_dcc *h)
{
  struct gg_event *e;
  signed int foo;
  gg_debug(8, "** gg_dcc_watch_fd(%p);\n", h);
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(h == ((struct gg_dcc *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    if(!(h->type == 8))
      tmp_if_expr$2 = h->type != 9 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = h->type != 10 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = h->type != 11 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = h->type != 12 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$6)
  {
    gg_debug(16, "// gg_dcc_watch_fd() invalid argument\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (struct gg_event *)(void *)0;
  }

  void *return_value_calloc$7;
  return_value_calloc$7=calloc((unsigned long int)1, sizeof(struct gg_event) /*96ul*/ );
  e = (struct gg_event *)(void *)return_value_calloc$7;
  unsigned int uin;
  signed long int return_value_recv$46;
  void *return_value_malloc$58;
  signed long int return_value_recv$59;
  unsigned int uins[2l];
  signed int return_value_strncmp$75;
  unsigned int tmp_if_expr$82;
  unsigned int return_value_gg_fix32$80;
  unsigned int return_value_gg_fix32$81;
  signed long int return_value_lseek$110;
  signed long int return_value_read$111;
  signed long int return_value_send$115;
  signed long int return_value_recv$118;
  signed long int return_value_write$122;
  if(e == ((struct gg_event *)NULL))
  {
    gg_debug(16, "// gg_dcc_watch_fd() not enough memory\n");
    return (struct gg_event *)(void *)0;
  }

  else
  {
    e->type = GG_EVENT_NONE;
    if(h->type == 9)
    {
      struct sockaddr_in sin;
      struct gg_dcc *c;
      signed int fd;
      unsigned int sin_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      fd=accept(h->fd, (struct sockaddr *)&sin, &sin_len);
      if(fd == -1)
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        char *return_value_strerror$10;
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        gg_debug(16, "// gg_dcc_watch_fd() can't accept() new connection (errno=%d, %s)\n", *return_value___errno_location$8, return_value_strerror$10);
        return e;
      }

      char *return_value_inet_ntoa$11;
      return_value_inet_ntoa$11=inet_ntoa(sin.sin_addr);
      unsigned short int return_value_htons$12;
      return_value_htons$12=htons(sin.sin_port);
      gg_debug(16, "// gg_dcc_watch_fd() new direct connection from %s:%d\n", return_value_inet_ntoa$11, return_value_htons$12);
      signed int return_value_gg_fd_set_nonblocking$16;
      return_value_gg_fd_set_nonblocking$16=gg_fd_set_nonblocking$link1(fd);
      if(return_value_gg_fd_set_nonblocking$16 == 0)
      {
        signed int *return_value___errno_location$13;
        return_value___errno_location$13=__errno_location();
        signed int *return_value___errno_location$14;
        return_value___errno_location$14=__errno_location();
        char *return_value_strerror$15;
        return_value_strerror$15=strerror(*return_value___errno_location$14);
        gg_debug(16, "// gg_dcc_watch_fd() can't set nonblocking (errno=%d, %s)\n", *return_value___errno_location$13, return_value_strerror$15);
        close(fd);
        e->type = GG_EVENT_DCC_ERROR;
        e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
        return e;
      }

      void *return_value_calloc$17;
      return_value_calloc$17=calloc((unsigned long int)1, sizeof(struct gg_dcc) /*448ul*/ );
      c = (struct gg_dcc *)(void *)return_value_calloc$17;
      if(c == ((struct gg_dcc *)NULL))
      {
        gg_debug(16, "// gg_dcc_watch_fd() not enough memory for client data\n");
        free((void *)e);
        close(fd);
        return (struct gg_event *)(void *)0;
      }

      c->fd = fd;
      c->check = 2;
      c->state = GG_STATE_READING_UIN_1;
      c->type = 8;
      c->timeout = 30;
      c->file_fd = -1;
      c->remote_addr = sin.sin_addr.s_addr;
      c->remote_port=ntohs(sin.sin_port);
      e->type = GG_EVENT_DCC_NEW;
      e->event.dcc_new = c;
      return e;
    }

    else
    {
      struct gg_dcc_tiny_packet tiny_pkt;
      struct gg_dcc_small_packet small_pkt;
      struct gg_dcc_big_packet big_pkt;
      signed int size;
      signed int tmp;
      signed int res;
      unsigned int utmp;
      unsigned int res_size = (unsigned int)sizeof(signed int) /*4ul*/ ;
      char buf[1024l];
      char ack[5l] = { 'U', 'D', 'A', 'G', 0 };
      void *tmp_buf;
      /* gg_dcc_watch_fd::1::4::tag-gg_dcc_file_info_packet */
struct gg_dcc_file_info_packet
{
  // big
  struct gg_dcc_big_packet big;
  // file_info
  struct gg_file_info file_info;
} __attribute__ ((__packed__));

/* */
      ;
      struct gg_dcc_file_info_packet file_info_packet;
      switch(h->state)
      {
        case GG_STATE_READING_UIN_1:

        case GG_STATE_READING_UIN_2:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_READING_UIN_%d\n", h->state == GG_STATE_READING_UIN_1 ? 1 : 2);
          signed int gg_dcc_watch_fd$$1$$4$$1$$1$$1$$_tmp;
          signed long int return_value_recv$18;
          return_value_recv$18=recv(h->fd, (void *)&uin, sizeof(unsigned int) /*4ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$1$$1$$_tmp = (signed int)return_value_recv$18;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$1$$1$$_tmp >= (signed int)sizeof(unsigned int) /*4*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$1$$1$$_tmp == -1)
            {
              signed int *return_value___errno_location$19;
              return_value___errno_location$19=__errno_location();
              signed int *return_value___errno_location$20;
              return_value___errno_location$20=__errno_location();
              char *return_value_strerror$21;
              return_value_strerror$21=strerror(*return_value___errno_location$20);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$19, return_value_strerror$21);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$1$$1$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$1$$1$$_tmp, sizeof(unsigned int) /*4ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&uin, (unsigned int)sizeof(unsigned int) /*4ul*/ );
          if(h->state == GG_STATE_READING_UIN_1)
          {
            h->state = GG_STATE_READING_UIN_2;
            h->check = 2;
            h->timeout = 30;
            h->peer_uin=gg_fix32(uin);
          }

          else
          {
            h->state = GG_STATE_SENDING_ACK;
            h->check = 1;
            h->timeout = 30;
            h->uin=gg_fix32(uin);
            e->type = GG_EVENT_DCC_CLIENT_ACCEPT;
          }
          return e;
        }
        case GG_STATE_SENDING_ACK:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_SENDING_ACK\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$2$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)ack, (unsigned int)(unsigned long int)4);
          signed long int return_value_send$22;
          return_value_send$22=send(h->fd, (const void *)ack, (unsigned long int)4, 0);
          gg_dcc_watch_fd$$1$$4$$1$$2$$write_res = (signed int)return_value_send$22;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$2$$write_res >= 4))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$2$$write_res == -1)
            {
              signed int *return_value___errno_location$23;
              return_value___errno_location$23=__errno_location();
              signed int *return_value___errno_location$24;
              return_value___errno_location$24=__errno_location();
              char *return_value_strerror$25;
              return_value_strerror$25=strerror(*return_value___errno_location$24);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$23, return_value_strerror$25);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", (unsigned long int)4, gg_dcc_watch_fd$$1$$4$$1$$2$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->state = GG_STATE_READING_TYPE;
          h->check = 2;
          h->timeout = 30;
          return e;
        }
        case GG_STATE_READING_TYPE:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_TYPE\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$3$$_tmp;
          signed long int return_value_recv$26;
          return_value_recv$26=recv(h->fd, (void *)&small_pkt, sizeof(struct gg_dcc_small_packet) /*4ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$3$$_tmp = (signed int)return_value_recv$26;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$3$$_tmp >= (signed int)sizeof(struct gg_dcc_small_packet) /*4*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$3$$_tmp == -1)
            {
              signed int *return_value___errno_location$27;
              return_value___errno_location$27=__errno_location();
              signed int *return_value___errno_location$28;
              return_value___errno_location$28=__errno_location();
              char *return_value_strerror$29;
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$27, return_value_strerror$29);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$3$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$3$$_tmp, sizeof(struct gg_dcc_small_packet) /*4ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&small_pkt, (unsigned int)sizeof(struct gg_dcc_small_packet) /*4ul*/ );
          small_pkt.type=gg_fix32(small_pkt.type);
          switch(small_pkt.type)
          {
            case (unsigned int)0x0003:
            {
              gg_debug(16, "// gg_dcc_watch_fd() callback\n");
              h->type = 10;
              h->state = GG_STATE_SENDING_FILE_INFO;
              h->check = 1;
              h->timeout = 30;
              e->type = GG_EVENT_DCC_CALLBACK;
              break;
            }
            case (unsigned int)0x0002:
            {
              gg_debug(16, "// gg_dcc_watch_fd() dialin\n");
              h->type = 11;
              h->state = GG_STATE_READING_REQUEST;
              h->check = 2;
              h->timeout = 30;
              h->incoming = 1;
              break;
            }
            default:
            {
              gg_debug(16, "// gg_dcc_watch_fd() unknown dcc type (%.4x) from %u\n", small_pkt.type, h->peer_uin);
              e->type = GG_EVENT_DCC_ERROR;
              e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            }
          }
          return e;
        }
        case GG_STATE_READING_REQUEST:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_REQUEST\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$5$$_tmp;
          signed long int return_value_recv$30;
          return_value_recv$30=recv(h->fd, (void *)&small_pkt, sizeof(struct gg_dcc_small_packet) /*4ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$5$$_tmp = (signed int)return_value_recv$30;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$5$$_tmp >= (signed int)sizeof(struct gg_dcc_small_packet) /*4*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$5$$_tmp == -1)
            {
              signed int *return_value___errno_location$31;
              return_value___errno_location$31=__errno_location();
              signed int *return_value___errno_location$32;
              return_value___errno_location$32=__errno_location();
              char *return_value_strerror$33;
              return_value_strerror$33=strerror(*return_value___errno_location$32);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$31, return_value_strerror$33);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$5$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$5$$_tmp, sizeof(struct gg_dcc_small_packet) /*4ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&small_pkt, (unsigned int)sizeof(struct gg_dcc_small_packet) /*4ul*/ );
          small_pkt.type=gg_fix32(small_pkt.type);
          switch(small_pkt.type)
          {
            case (unsigned int)0x0001:
            {
              gg_debug(16, "// gg_dcc_watch_fd() file transfer request\n");
              h->state = GG_STATE_READING_FILE_INFO;
              h->check = 2;
              h->timeout = 30;
              break;
            }
            case (unsigned int)0x0003:
            {
              gg_debug(16, "// gg_dcc_watch_fd() voice chat request\n");
              h->state = GG_STATE_SENDING_VOICE_ACK;
              h->check = 1;
              h->timeout = 300;
              h->type = 12;
              e->type = GG_EVENT_DCC_NEED_VOICE_ACK;
              break;
            }
            default:
            {
              gg_debug(16, "// gg_dcc_watch_fd() unknown dcc request (%.4x) from %u\n", small_pkt.type, h->peer_uin);
              e->type = GG_EVENT_DCC_ERROR;
              e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            }
          }
          return e;
        }
        case GG_STATE_READING_FILE_INFO:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_FILE_INFO\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$7$$_tmp;
          signed long int return_value_recv$34;
          return_value_recv$34=recv(h->fd, (void *)&file_info_packet, sizeof(struct gg_dcc_file_info_packet) /*332ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$7$$_tmp = (signed int)return_value_recv$34;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$7$$_tmp >= (signed int)sizeof(struct gg_dcc_file_info_packet) /*332*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$7$$_tmp == -1)
            {
              signed int *return_value___errno_location$35;
              return_value___errno_location$35=__errno_location();
              signed int *return_value___errno_location$36;
              return_value___errno_location$36=__errno_location();
              char *return_value_strerror$37;
              return_value_strerror$37=strerror(*return_value___errno_location$36);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$35, return_value_strerror$37);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$7$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$7$$_tmp, sizeof(struct gg_dcc_file_info_packet) /*332ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&file_info_packet, (unsigned int)sizeof(struct gg_dcc_file_info_packet) /*332ul*/ );
          memcpy((void *)&h->file_info, (const void *)&file_info_packet.file_info, sizeof(struct gg_file_info) /*320ul*/ );
          h->file_info.mode=gg_fix32(h->file_info.mode);
          h->file_info.size=gg_fix32(h->file_info.size);
          h->state = GG_STATE_SENDING_FILE_ACK;
          h->check = 1;
          h->timeout = 300;
          e->type = GG_EVENT_DCC_NEED_FILE_ACK;
          return e;
        }
        case GG_STATE_SENDING_FILE_ACK:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_SENDING_FILE_ACK\n");
          big_pkt.type=gg_fix32((unsigned int)0x0006);
          big_pkt.dunno1=gg_fix32(h->offset);
          big_pkt.dunno2 = (unsigned int)0;
          signed int gg_dcc_watch_fd$$1$$4$$1$$8$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)&big_pkt, (unsigned int)sizeof(struct gg_dcc_big_packet) /*12ul*/ );
          signed long int return_value_send$38;
          return_value_send$38=send(h->fd, (const void *)&big_pkt, sizeof(struct gg_dcc_big_packet) /*12ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$8$$write_res = (signed int)return_value_send$38;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$8$$write_res >= (signed int)sizeof(struct gg_dcc_big_packet) /*12*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$8$$write_res == -1)
            {
              signed int *return_value___errno_location$39;
              return_value___errno_location$39=__errno_location();
              signed int *return_value___errno_location$40;
              return_value___errno_location$40=__errno_location();
              char *return_value_strerror$41;
              return_value_strerror$41=strerror(*return_value___errno_location$40);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$39, return_value_strerror$41);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(struct gg_dcc_big_packet) /*12ul*/ , gg_dcc_watch_fd$$1$$4$$1$$8$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->state = GG_STATE_READING_FILE_HEADER;
          h->chunk_size = (unsigned int)sizeof(struct gg_dcc_big_packet) /*12ul*/ ;
          h->chunk_offset = (unsigned int)0;
          h->chunk_buf = (char *)(void *)0;
          tmp_buf=malloc(sizeof(struct gg_dcc_big_packet) /*12ul*/ );
          if(tmp_buf == NULL)
          {
            gg_debug(16, "// gg_dcc_watch_fd() out of memory\n");
            free((void *)e);
            return (struct gg_event *)(void *)0;
          }

          h->chunk_buf = (char *)tmp_buf;
          h->check = 2;
          h->timeout = 30;
          return e;
        }
        case GG_STATE_SENDING_VOICE_ACK:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_SENDING_VOICE_ACK\n");
          tiny_pkt.type = (unsigned char)0x01;
          signed int gg_dcc_watch_fd$$1$$4$$1$$10$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)&tiny_pkt, (unsigned int)sizeof(struct gg_dcc_tiny_packet) /*1ul*/ );
          signed long int return_value_send$42;
          return_value_send$42=send(h->fd, (const void *)&tiny_pkt, sizeof(struct gg_dcc_tiny_packet) /*1ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$10$$write_res = (signed int)return_value_send$42;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$10$$write_res >= (signed int)sizeof(struct gg_dcc_tiny_packet) /*1*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$10$$write_res == -1)
            {
              signed int *return_value___errno_location$43;
              return_value___errno_location$43=__errno_location();
              signed int *return_value___errno_location$44;
              return_value___errno_location$44=__errno_location();
              char *return_value_strerror$45;
              return_value_strerror$45=strerror(*return_value___errno_location$44);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$43, return_value_strerror$45);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(struct gg_dcc_tiny_packet) /*1ul*/ , gg_dcc_watch_fd$$1$$4$$1$$10$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->state = GG_STATE_READING_VOICE_HEADER;
          h->check = 2;
          h->timeout = 30;
          h->offset = (unsigned int)0;
          return e;
        }
        case GG_STATE_READING_FILE_HEADER:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_FILE_HEADER\n");
          return_value_recv$46=recv(h->fd, (void *)(h->chunk_buf + (signed long int)h->chunk_offset), (unsigned long int)(h->chunk_size - h->chunk_offset), 0);
          tmp = (signed int)return_value_recv$46;
          if(tmp == -1)
          {
            signed int *return_value___errno_location$47;
            return_value___errno_location$47=__errno_location();
            signed int *return_value___errno_location$48;
            return_value___errno_location$48=__errno_location();
            char *return_value_strerror$49;
            return_value_strerror$49=strerror(*return_value___errno_location$48);
            gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$47, return_value_strerror$49);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_NET;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)(h->chunk_buf + (signed long int)h->chunk_offset), h->chunk_size - h->chunk_offset);
          h->chunk_offset = h->chunk_offset + (unsigned int)tmp;
          if(!(h->chunk_offset >= h->chunk_size))
            return e;

          memcpy((void *)&big_pkt, (const void *)h->chunk_buf, sizeof(struct gg_dcc_big_packet) /*12ul*/ );
          free((void *)h->chunk_buf);
          h->chunk_buf = (char *)(void *)0;
          big_pkt.type=gg_fix32(big_pkt.type);
          h->chunk_size=gg_fix32(big_pkt.dunno1);
          h->chunk_offset = (unsigned int)0;
          if(big_pkt.type == 5u)
          {
            gg_debug(16, "// gg_dcc_watch_fd() transfer refused\n");
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_REFUSED;
            return e;
          }

          if(h->chunk_size == 0u)
          {
            gg_debug(16, "// gg_dcc_watch_fd() empty chunk, EOF\n");
            e->type = GG_EVENT_DCC_DONE;
            return e;
          }

          h->state = GG_STATE_GETTING_FILE;
          h->check = 2;
          h->timeout = 30;
          h->established = 1;
          return e;
        }
        case GG_STATE_READING_VOICE_HEADER:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_VOICE_HEADER\n");
          signed int _tmp;
          signed long int return_value_recv$50;
          return_value_recv$50=recv(h->fd, (void *)&tiny_pkt, sizeof(struct gg_dcc_tiny_packet) /*1ul*/ , 0);
          _tmp = (signed int)return_value_recv$50;
          if(!(_tmp >= (signed int)sizeof(struct gg_dcc_tiny_packet) /*1*/ ))
          {
            if(_tmp == -1)
            {
              signed int *return_value___errno_location$51;
              return_value___errno_location$51=__errno_location();
              signed int *return_value___errno_location$52;
              return_value___errno_location$52=__errno_location();
              char *return_value_strerror$53;
              return_value_strerror$53=strerror(*return_value___errno_location$52);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$51, return_value_strerror$53);
            }

            else
              if(_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", _tmp, sizeof(struct gg_dcc_tiny_packet) /*1ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&tiny_pkt, (unsigned int)sizeof(struct gg_dcc_tiny_packet) /*1ul*/ );
          switch((signed int)tiny_pkt.type)
          {
            case 0x03:
            {
              h->state = GG_STATE_READING_VOICE_SIZE;
              h->check = 2;
              h->timeout = 30;
              h->established = 1;
              break;
            }
            case 0x04:
              gg_debug(16, "// gg_dcc_watch_fd() peer breaking connection\n");
            default:
            {
              gg_debug(16, "// gg_dcc_watch_fd() unknown request (%.2x)\n", tiny_pkt.type);
              e->type = GG_EVENT_DCC_ERROR;
              e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            }
          }
          return e;
        }
        case GG_STATE_READING_VOICE_SIZE:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_VOICE_SIZE\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$16$$_tmp;
          signed long int return_value_recv$54;
          return_value_recv$54=recv(h->fd, (void *)&small_pkt, sizeof(struct gg_dcc_small_packet) /*4ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$16$$_tmp = (signed int)return_value_recv$54;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$16$$_tmp >= (signed int)sizeof(struct gg_dcc_small_packet) /*4*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$16$$_tmp == -1)
            {
              signed int *return_value___errno_location$55;
              return_value___errno_location$55=__errno_location();
              signed int *return_value___errno_location$56;
              return_value___errno_location$56=__errno_location();
              char *return_value_strerror$57;
              return_value_strerror$57=strerror(*return_value___errno_location$56);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$55, return_value_strerror$57);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$16$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$16$$_tmp, sizeof(struct gg_dcc_small_packet) /*4ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&small_pkt, (unsigned int)sizeof(struct gg_dcc_small_packet) /*4ul*/ );
          small_pkt.type=gg_fix32(small_pkt.type);
          if((unsigned long int)small_pkt.type >= 1025ul || !(small_pkt.type >= 16u))
          {
            gg_debug(16, "// gg_dcc_watch_fd() invalid voice frame size (%d)\n", small_pkt.type);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_NET;
            return e;
          }

          h->chunk_size = small_pkt.type;
          h->chunk_offset = (unsigned int)0;
          return_value_malloc$58=malloc((unsigned long int)h->chunk_size);
          h->voice_buf = (char *)return_value_malloc$58;
          if(h->voice_buf == ((char *)NULL))
          {
            gg_debug(16, "// gg_dcc_watch_fd() out of memory for voice frame\n");
            free((void *)e);
            return (struct gg_event *)(void *)0;
          }

          h->state = GG_STATE_READING_VOICE_DATA;
          h->check = 2;
          h->timeout = 30;
          return e;
        }
        case GG_STATE_READING_VOICE_DATA:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_VOICE_DATA\n");
          return_value_recv$59=recv(h->fd, (void *)(h->voice_buf + (signed long int)h->chunk_offset), (unsigned long int)(h->chunk_size - h->chunk_offset), 0);
          tmp = (signed int)return_value_recv$59;
          if(!(tmp >= 1))
          {
            if(tmp == -1)
            {
              signed int *return_value___errno_location$60;
              return_value___errno_location$60=__errno_location();
              signed int *return_value___errno_location$61;
              return_value___errno_location$61=__errno_location();
              char *return_value_strerror$62;
              return_value_strerror$62=strerror(*return_value___errno_location$61);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$60, return_value_strerror$62);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_NET;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)(h->voice_buf + (signed long int)h->chunk_offset), (unsigned int)tmp);
          h->chunk_offset = h->chunk_offset + (unsigned int)tmp;
          if(h->chunk_offset >= h->chunk_size)
          {
            e->type = GG_EVENT_DCC_VOICE_DATA;
            e->event.dcc_voice_data.data = (unsigned char *)h->voice_buf;
            e->event.dcc_voice_data.length = (signed int)h->chunk_size;
            h->state = GG_STATE_READING_VOICE_HEADER;
            h->voice_buf = (char *)(void *)0;
          }

          h->check = 2;
          h->timeout = 30;
          return e;
        }
        case GG_STATE_CONNECTING:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_CONNECTING\n");
          res = 0;
          foo=getsockopt(h->fd, 1, 4, (void *)&res, &res_size);
          if(!(res == 0) || !(foo == 0))
          {
            signed int *return_value___errno_location$63;
            return_value___errno_location$63=__errno_location();
            signed int *return_value___errno_location$64;
            return_value___errno_location$64=__errno_location();
            char *return_value_strerror$65;
            return_value_strerror$65=strerror(*return_value___errno_location$64);
            char *return_value_strerror$66;
            return_value_strerror$66=strerror(res);
            gg_debug(16, "// gg_dcc_watch_fd() connection failed (fd=%d,errno=%d(%s),foo=%d,res=%d(%s))\n", h->fd, *return_value___errno_location$63, return_value_strerror$65, foo, res, return_value_strerror$66);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_debug(16, "// gg_dcc_watch_fd() connected, sending uins\n");
          uins[(signed long int)0]=gg_fix32(h->uin);
          uins[(signed long int)1]=gg_fix32(h->peer_uin);
          signed int write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)uins, (unsigned int)sizeof(unsigned int [2l]) /*8ul*/ );
          signed long int return_value_send$67;
          return_value_send$67=send(h->fd, (const void *)uins, sizeof(unsigned int [2l]) /*8ul*/ , 0);
          write_res = (signed int)return_value_send$67;
          if(!(write_res >= (signed int)sizeof(unsigned int [2l]) /*8*/ ))
          {
            if(write_res == -1)
            {
              signed int *return_value___errno_location$68;
              return_value___errno_location$68=__errno_location();
              signed int *return_value___errno_location$69;
              return_value___errno_location$69=__errno_location();
              char *return_value_strerror$70;
              return_value_strerror$70=strerror(*return_value___errno_location$69);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$68, return_value_strerror$70);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(unsigned int [2l]) /*8ul*/ , write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->state = GG_STATE_READING_ACK;
          h->check = 2;
          h->timeout = 30;
          return e;
        }
        case GG_STATE_READING_ACK:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_ACK\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$22$$_tmp;
          signed long int return_value_recv$71;
          return_value_recv$71=recv(h->fd, (void *)buf, (unsigned long int)4, 0);
          gg_dcc_watch_fd$$1$$4$$1$$22$$_tmp = (signed int)return_value_recv$71;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$22$$_tmp >= 4))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$22$$_tmp == -1)
            {
              signed int *return_value___errno_location$72;
              return_value___errno_location$72=__errno_location();
              signed int *return_value___errno_location$73;
              return_value___errno_location$73=__errno_location();
              char *return_value_strerror$74;
              return_value_strerror$74=strerror(*return_value___errno_location$73);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$72, return_value_strerror$74);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$22$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$22$$_tmp, (unsigned long int)4);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)buf, (unsigned int)(unsigned long int)4);
          return_value_strncmp$75=strncmp(buf, ack, (unsigned long int)4);
          if(!(return_value_strncmp$75 == 0))
          {
            gg_debug(16, "// gg_dcc_watch_fd() did't get ack\n");
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->check = 1;
          h->timeout = 30;
          h->state = GG_STATE_SENDING_REQUEST;
          return e;
        }
        case GG_STATE_SENDING_VOICE_REQUEST:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_SENDING_VOICE_REQUEST\n");
          small_pkt.type=gg_fix32((unsigned int)0x0003);
          signed int gg_dcc_watch_fd$$1$$4$$1$$24$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)&small_pkt, (unsigned int)sizeof(struct gg_dcc_small_packet) /*4ul*/ );
          signed long int return_value_send$76;
          return_value_send$76=send(h->fd, (const void *)&small_pkt, sizeof(struct gg_dcc_small_packet) /*4ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$24$$write_res = (signed int)return_value_send$76;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$24$$write_res >= (signed int)sizeof(struct gg_dcc_small_packet) /*4*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$24$$write_res == -1)
            {
              signed int *return_value___errno_location$77;
              return_value___errno_location$77=__errno_location();
              signed int *return_value___errno_location$78;
              return_value___errno_location$78=__errno_location();
              char *return_value_strerror$79;
              return_value_strerror$79=strerror(*return_value___errno_location$78);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$77, return_value_strerror$79);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(struct gg_dcc_small_packet) /*4ul*/ , gg_dcc_watch_fd$$1$$4$$1$$24$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->state = GG_STATE_READING_VOICE_ACK;
          h->check = 2;
          h->timeout = 30;
          return e;
        }
        case GG_STATE_SENDING_REQUEST:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_SENDING_REQUEST\n");
          if(h->type == 11)
          {
            return_value_gg_fix32$80=gg_fix32((unsigned int)0x0003);
            tmp_if_expr$82 = return_value_gg_fix32$80;
          }

          else
          {
            return_value_gg_fix32$81=gg_fix32((unsigned int)0x0002);
            tmp_if_expr$82 = return_value_gg_fix32$81;
          }
          small_pkt.type = tmp_if_expr$82;
          signed int gg_dcc_watch_fd$$1$$4$$1$$25$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)&small_pkt, (unsigned int)sizeof(struct gg_dcc_small_packet) /*4ul*/ );
          signed long int return_value_send$83;
          return_value_send$83=send(h->fd, (const void *)&small_pkt, sizeof(struct gg_dcc_small_packet) /*4ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$25$$write_res = (signed int)return_value_send$83;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$25$$write_res >= (signed int)sizeof(struct gg_dcc_small_packet) /*4*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$25$$write_res == -1)
            {
              signed int *return_value___errno_location$84;
              return_value___errno_location$84=__errno_location();
              signed int *return_value___errno_location$85;
              return_value___errno_location$85=__errno_location();
              char *return_value_strerror$86;
              return_value_strerror$86=strerror(*return_value___errno_location$85);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$84, return_value_strerror$86);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(struct gg_dcc_small_packet) /*4ul*/ , gg_dcc_watch_fd$$1$$4$$1$$25$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          switch(h->type)
          {
            case 11:
            {
              h->state = GG_STATE_READING_REQUEST;
              h->check = 2;
              h->timeout = 30;
              break;
            }
            case 10:
            {
              h->state = GG_STATE_SENDING_FILE_INFO;
              h->check = 1;
              h->timeout = 30;
              if(h->file_fd == -1)
                e->type = GG_EVENT_DCC_NEED_FILE_INFO;

              break;
            }
            case 12:
            {
              h->state = GG_STATE_SENDING_VOICE_REQUEST;
              h->check = 1;
              h->timeout = 30;
            }
          }
          return e;
        }
        case GG_STATE_SENDING_FILE_INFO:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_SENDING_FILE_INFO\n");
          if(h->file_fd == -1)
          {
            e->type = GG_EVENT_DCC_NEED_FILE_INFO;
            return e;
          }

          small_pkt.type=gg_fix32((unsigned int)0x0001);
          signed int gg_dcc_watch_fd$$1$$4$$1$$28$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)&small_pkt, (unsigned int)sizeof(struct gg_dcc_small_packet) /*4ul*/ );
          signed long int return_value_send$87;
          return_value_send$87=send(h->fd, (const void *)&small_pkt, sizeof(struct gg_dcc_small_packet) /*4ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$28$$write_res = (signed int)return_value_send$87;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$28$$write_res >= (signed int)sizeof(struct gg_dcc_small_packet) /*4*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$28$$write_res == -1)
            {
              signed int *return_value___errno_location$88;
              return_value___errno_location$88=__errno_location();
              signed int *return_value___errno_location$89;
              return_value___errno_location$89=__errno_location();
              char *return_value_strerror$90;
              return_value_strerror$90=strerror(*return_value___errno_location$89);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$88, return_value_strerror$90);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(struct gg_dcc_small_packet) /*4ul*/ , gg_dcc_watch_fd$$1$$4$$1$$28$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          file_info_packet.big.type=gg_fix32((unsigned int)0x0003);
          file_info_packet.big.dunno1 = (unsigned int)0;
          file_info_packet.big.dunno2 = (unsigned int)0;
          memcpy((void *)&file_info_packet.file_info, (const void *)&h->file_info, sizeof(struct gg_file_info) /*320ul*/ );
          h->file_info.size=gg_fix32(h->file_info.size);
          h->file_info.mode=gg_fix32(h->file_info.mode);
          signed int gg_dcc_watch_fd$$1$$4$$1$$29$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)&file_info_packet, (unsigned int)sizeof(struct gg_dcc_file_info_packet) /*332ul*/ );
          signed long int return_value_send$91;
          return_value_send$91=send(h->fd, (const void *)&file_info_packet, sizeof(struct gg_dcc_file_info_packet) /*332ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$29$$write_res = (signed int)return_value_send$91;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$29$$write_res >= (signed int)sizeof(struct gg_dcc_file_info_packet) /*332*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$29$$write_res == -1)
            {
              signed int *return_value___errno_location$92;
              return_value___errno_location$92=__errno_location();
              signed int *return_value___errno_location$93;
              return_value___errno_location$93=__errno_location();
              char *return_value_strerror$94;
              return_value_strerror$94=strerror(*return_value___errno_location$93);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$92, return_value_strerror$94);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(struct gg_dcc_file_info_packet) /*332ul*/ , gg_dcc_watch_fd$$1$$4$$1$$29$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->state = GG_STATE_READING_FILE_ACK;
          h->check = 2;
          h->timeout = 300;
          return e;
        }
        case GG_STATE_READING_FILE_ACK:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_FILE_ACK\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$30$$_tmp;
          signed long int return_value_recv$95;
          return_value_recv$95=recv(h->fd, (void *)&big_pkt, sizeof(struct gg_dcc_big_packet) /*12ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$30$$_tmp = (signed int)return_value_recv$95;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$30$$_tmp >= (signed int)sizeof(struct gg_dcc_big_packet) /*12*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$30$$_tmp == -1)
            {
              signed int *return_value___errno_location$96;
              return_value___errno_location$96=__errno_location();
              signed int *return_value___errno_location$97;
              return_value___errno_location$97=__errno_location();
              char *return_value_strerror$98;
              return_value_strerror$98=strerror(*return_value___errno_location$97);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$96, return_value_strerror$98);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$30$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$30$$_tmp, sizeof(struct gg_dcc_big_packet) /*12ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&big_pkt, (unsigned int)sizeof(struct gg_dcc_big_packet) /*12ul*/ );
          h->offset=gg_fix32(big_pkt.dunno1);
          h->state = GG_STATE_SENDING_FILE_HEADER;
          h->check = 1;
          h->timeout = 30;
          e->type = GG_EVENT_DCC_ACK;
          return e;
        }
        case GG_STATE_READING_VOICE_ACK:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_READING_VOICE_ACK\n");
          signed int gg_dcc_watch_fd$$1$$4$$1$$31$$_tmp;
          signed long int return_value_recv$99;
          return_value_recv$99=recv(h->fd, (void *)&tiny_pkt, sizeof(struct gg_dcc_tiny_packet) /*1ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$31$$_tmp = (signed int)return_value_recv$99;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$31$$_tmp >= (signed int)sizeof(struct gg_dcc_tiny_packet) /*1*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$31$$_tmp == -1)
            {
              signed int *return_value___errno_location$100;
              return_value___errno_location$100=__errno_location();
              signed int *return_value___errno_location$101;
              return_value___errno_location$101=__errno_location();
              char *return_value_strerror$102;
              return_value_strerror$102=strerror(*return_value___errno_location$101);
              gg_debug(16, "// gg_dcc_watch_fd() recv() failed (errno=%d, %s)\n", *return_value___errno_location$100, return_value_strerror$102);
            }

            else
              if(gg_dcc_watch_fd$$1$$4$$1$$31$$_tmp == 0)
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed, connection broken\n");

              else
                gg_debug(16, "// gg_dcc_watch_fd() recv() failed (%d bytes, %zu needed)\n", gg_dcc_watch_fd$$1$$4$$1$$31$$_tmp, sizeof(struct gg_dcc_tiny_packet) /*1ul*/ );
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          gg_dcc_debug_data("read", h->fd, (const void *)&tiny_pkt, (unsigned int)sizeof(struct gg_dcc_tiny_packet) /*1ul*/ );
          if(!((signed int)tiny_pkt.type == 0x01))
          {
            gg_debug(16, "// invalid reply (%.2x), connection refused\n", tiny_pkt.type);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_REFUSED;
            return e;
          }

          h->state = GG_STATE_READING_VOICE_HEADER;
          h->check = 2;
          h->timeout = 30;
          e->type = GG_EVENT_DCC_ACK;
          return e;
        }
        case GG_STATE_SENDING_FILE_HEADER:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_SENDING_FILE_HEADER\n");
          h->chunk_offset = (unsigned int)0;
          h->chunk_size = h->file_info.size - h->offset;
          if(h->chunk_size >= 4097u)
          {
            h->chunk_size = (unsigned int)4096;
            big_pkt.type=gg_fix32((unsigned int)0x0003);
          }

          else
            big_pkt.type=gg_fix32((unsigned int)0x0002);
          big_pkt.dunno1=gg_fix32(h->chunk_size);
          big_pkt.dunno2 = (unsigned int)0;
          signed int gg_dcc_watch_fd$$1$$4$$1$$34$$write_res;
          gg_dcc_debug_data("write", h->fd, (const void *)&big_pkt, (unsigned int)sizeof(struct gg_dcc_big_packet) /*12ul*/ );
          signed long int return_value_send$103;
          return_value_send$103=send(h->fd, (const void *)&big_pkt, sizeof(struct gg_dcc_big_packet) /*12ul*/ , 0);
          gg_dcc_watch_fd$$1$$4$$1$$34$$write_res = (signed int)return_value_send$103;
          if(!(gg_dcc_watch_fd$$1$$4$$1$$34$$write_res >= (signed int)sizeof(struct gg_dcc_big_packet) /*12*/ ))
          {
            if(gg_dcc_watch_fd$$1$$4$$1$$34$$write_res == -1)
            {
              signed int *return_value___errno_location$104;
              return_value___errno_location$104=__errno_location();
              signed int *return_value___errno_location$105;
              return_value___errno_location$105=__errno_location();
              char *return_value_strerror$106;
              return_value_strerror$106=strerror(*return_value___errno_location$105);
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$104, return_value_strerror$106);
            }

            else
              gg_debug(16, "// gg_dcc_watch_fd() send() failed (%zu needed, %d done)\n", sizeof(struct gg_dcc_big_packet) /*12ul*/ , gg_dcc_watch_fd$$1$$4$$1$$34$$write_res);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
            return e;
          }

          h->state = GG_STATE_SENDING_FILE;
          h->check = 1;
          h->timeout = 30;
          h->established = 1;
          return e;
        }
        case GG_STATE_SENDING_FILE:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_SENDING_FILE\n");
          utmp = h->chunk_size - h->chunk_offset;
          if((unsigned long int)utmp >= 1025ul)
            utmp = (unsigned int)sizeof(char [1024l]) /*1024ul*/ ;

          gg_debug(16, "// gg_dcc_watch_fd() offset=%d, size=%d\n", h->offset, h->file_info.size);
          if(h->file_info.size == 0u)
          {
            gg_debug(16, "// gg_dcc_watch_fd() read()reached eof on empty file\n");
            e->type = GG_EVENT_DCC_DONE;
            return e;
          }

          if(h->offset >= h->file_info.size)
          {
            gg_debug(16, "// gg_dcc_watch_fd() offset >= size, finished\n");
            e->type = GG_EVENT_DCC_DONE;
            return e;
          }

          return_value_lseek$110=lseek(h->file_fd, (signed long int)h->offset, 0);
          if(!(return_value_lseek$110 == (signed long int)h->offset))
          {
            signed int *return_value___errno_location$107;
            return_value___errno_location$107=__errno_location();
            signed int *return_value___errno_location$108;
            return_value___errno_location$108=__errno_location();
            char *return_value_strerror$109;
            return_value_strerror$109=strerror(*return_value___errno_location$108);
            gg_debug(16, "// gg_dcc_watch_fd() lseek() failed. (errno=%d, %s)\n", *return_value___errno_location$107, return_value_strerror$109);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_FILE;
            return e;
          }

          return_value_read$111=read(h->file_fd, (void *)buf, (unsigned long int)utmp);
          size = (signed int)return_value_read$111;
          if(size == -1)
          {
            signed int *return_value___errno_location$112;
            return_value___errno_location$112=__errno_location();
            signed int *return_value___errno_location$113;
            return_value___errno_location$113=__errno_location();
            char *return_value_strerror$114;
            return_value_strerror$114=strerror(*return_value___errno_location$113);
            gg_debug(16, "// gg_dcc_watch_fd() read() failed. (errno=%d, %s)\n", *return_value___errno_location$112, return_value_strerror$114);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_FILE;
            return e;
          }

          if(size == 0)
          {
            gg_debug(16, "// gg_dcc_watch_fd() read() reached eof\n");
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_EOF;
            return e;
          }

          if(!(h->file_info.size >= h->offset + (unsigned int)size))
          {
            gg_debug(16, "// gg_dcc_watch_fd() read() too much (read=%d, ofs=%d, size=%d)\n", size, h->offset, h->file_info.size);
            size = (signed int)(h->file_info.size - h->offset);
            if(!(size >= 1))
            {
              gg_debug(16, "// gg_dcc_watch_fd() reached EOF after cutting\n");
              e->type = GG_EVENT_DCC_DONE;
              return e;
            }

          }

          return_value_send$115=send(h->fd, (const void *)buf, (unsigned long int)size, 0);
          tmp = (signed int)return_value_send$115;
          if(tmp == -1)
          {
            signed int *return_value___errno_location$116;
            return_value___errno_location$116=__errno_location();
            char *return_value_strerror$117;
            return_value_strerror$117=strerror(*return_value___errno_location$116);
            gg_debug(16, "// gg_dcc_watch_fd() send() failed (%s)\n", return_value_strerror$117);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_NET;
            return e;
          }

          if(tmp == 0)
          {
            gg_debug(16, "// gg_dcc_watch_fd() send() failed (connection reset)\n");
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_NET;
            return e;
          }

          h->offset = h->offset + (unsigned int)tmp;
          if(h->offset >= h->file_info.size)
          {
            e->type = GG_EVENT_DCC_DONE;
            return e;
          }

          h->chunk_offset = h->chunk_offset + (unsigned int)tmp;
          if(h->chunk_offset >= h->chunk_size)
          {
            gg_debug(16, "// gg_dcc_watch_fd() chunk finished\n");
            h->state = GG_STATE_SENDING_FILE_HEADER;
            h->timeout = 30;
          }

          else
          {
            h->state = GG_STATE_SENDING_FILE;
            h->timeout = 1800;
          }
          h->check = 1;
          return e;
        }
        case GG_STATE_GETTING_FILE:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_GETTING_FILE\n");
          utmp = h->chunk_size - h->chunk_offset;
          if((unsigned long int)utmp >= 1025ul)
            utmp = (unsigned int)sizeof(char [1024l]) /*1024ul*/ ;

          if(h->offset >= h->file_info.size)
          {
            gg_debug(16, "// gg_dcc_watch_fd() offset >= size, finished\n");
            e->type = GG_EVENT_DCC_DONE;
            return e;
          }

          return_value_recv$118=recv(h->fd, (void *)buf, (unsigned long int)utmp, 0);
          size = (signed int)return_value_recv$118;
          gg_debug(16, "// gg_dcc_watch_fd() ofs=%d, size=%d, recv()=%d\n", h->offset, h->file_info.size, size);
          if(size == -1)
          {
            signed int *return_value___errno_location$119;
            return_value___errno_location$119=__errno_location();
            signed int *return_value___errno_location$120;
            return_value___errno_location$120=__errno_location();
            char *return_value_strerror$121;
            return_value_strerror$121=strerror(*return_value___errno_location$120);
            gg_debug(16, "// gg_dcc_watch_fd() recv() failed. (errno=%d, %s)\n", *return_value___errno_location$119, return_value_strerror$121);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_NET;
            return e;
          }

          if(size == 0)
          {
            gg_debug(16, "// gg_dcc_watch_fd() recv() reached eof\n");
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_EOF;
            return e;
          }

          return_value_write$122=write(h->file_fd, (const void *)buf, (unsigned long int)size);
          tmp = (signed int)return_value_write$122;
          if(tmp == -1 || !(tmp >= size))
          {
            signed int *return_value___errno_location$123;
            return_value___errno_location$123=__errno_location();
            char *return_value_strerror$124;
            return_value_strerror$124=strerror(*return_value___errno_location$123);
            gg_debug(16, "// gg_dcc_watch_fd() write() failed (%d:fd=%d:res=%d:%s)\n", tmp, h->file_fd, size, return_value_strerror$124);
            e->type = GG_EVENT_DCC_ERROR;
            e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_NET;
            return e;
          }

          h->offset = h->offset + (unsigned int)size;
          if(h->offset >= h->file_info.size)
          {
            e->type = GG_EVENT_DCC_DONE;
            return e;
          }

          h->chunk_offset = h->chunk_offset + (unsigned int)size;
          if(h->chunk_offset >= h->chunk_size)
          {
            gg_debug(16, "// gg_dcc_watch_fd() chunk finished\n");
            h->state = GG_STATE_READING_FILE_HEADER;
            h->timeout = 30;
            h->chunk_offset = (unsigned int)0;
            h->chunk_size = (unsigned int)sizeof(struct gg_dcc_big_packet) /*12ul*/ ;
            h->chunk_buf = (char *)(void *)0;
            tmp_buf=malloc(sizeof(struct gg_dcc_big_packet) /*12ul*/ );
            if(tmp_buf == NULL)
            {
              gg_debug(16, "// gg_dcc_watch_fd() out of memory\n");
              free((void *)e);
              return (struct gg_event *)(void *)0;
            }

            h->chunk_buf = (char *)tmp_buf;
          }

          else
          {
            h->state = GG_STATE_GETTING_FILE;
            h->timeout = 1800;
          }
          h->check = 2;
          return e;
        }
        default:
        {
          gg_debug(16, "// gg_dcc_watch_fd() GG_STATE_???\n");
          e->type = GG_EVENT_DCC_ERROR;
          e->event.dcc_error = (enum gg_error_t)GG_ERROR_DCC_HANDSHAKE;
          return e;
        }
      }
    }
    return e;
  }
}

// gg_debug
// file ../include/libgadu.h line 1594
void gg_debug(signed int level, const char *format, ...)
{
  void **ap;
  signed int old_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  old_errno = *return_value___errno_location$1;
  ap = (void **)&format;
  gg_debug_common((struct gg_session *)(void *)0, level, format, ap);
  ap = ((void **)NULL);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = old_errno;
}

// gg_debug_common
// file debug.c line 102
void gg_debug_common(struct gg_session *sess, signed int level, const char *format, void **ap)
{
  if(!(gg_debug_handler_session == ((void (*)(struct gg_session *, signed int, const char *, void **))NULL)))
    gg_debug_handler_session(sess, level, format, ap);

  else
    if(!(gg_debug_handler == ((void (*)(signed int, const char *, void **))NULL)))
      gg_debug_handler(level, format, ap);

    else
      if(!((level & gg_debug_level) == 0))
        vfprintf(gg_debug_file != ((struct _IO_FILE *)NULL) ? gg_debug_file : stderr, format, ap);

}

// gg_debug_dump
// file ../include/debug.h line 24
void gg_debug_dump(struct gg_session *gs, signed int level, const char *buf, unsigned long int len)
{
  char line[80l];
  unsigned int i;
  unsigned int j;
  i = (unsigned int)0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  for( ; !((unsigned long int)i >= len); i = i + (unsigned int)16)
  {
    signed int ofs;
    sprintf(line, "%.4x: ", i);
    ofs = 6;
    j = (unsigned int)0;
    for( ; !(j >= 16u); j = j + 1u)
    {
      if(!((unsigned long int)(i + j) >= len))
        sprintf(line + (signed long int)ofs, " %02x", (unsigned char)buf[(signed long int)(i + j)]);

      else
        sprintf(line + (signed long int)ofs, "   ");
      ofs = ofs + 3;
    }
    sprintf(line + (signed long int)ofs, "  ");
    ofs = ofs + 2;
    j = (unsigned int)0;
    for( ; !(j >= 16u); j = j + 1u)
    {
      unsigned char ch;
      if(!((unsigned long int)(i + j) >= len))
      {
        ch = (unsigned char)buf[(signed long int)(i + j)];
        if((signed int)ch >= 127 || !((signed int)ch >= 32))
          ch = (unsigned char)46;

      }

      else
        ch = (unsigned char)32;
      tmp_post$1 = ofs;
      ofs = ofs + 1;
      line[(signed long int)tmp_post$1] = (char)ch;
    }
    tmp_post$2 = ofs;
    ofs = ofs + 1;
    line[(signed long int)tmp_post$2] = (char)10;
    tmp_post$3 = ofs;
    ofs = ofs + 1;
    line[(signed long int)tmp_post$3] = (char)0;
    gg_debug_session(gs, level, "%s", (const void *)line);
  }
}

// gg_debug_event
// file debug.c line 311
const char * gg_debug_event(enum gg_event_t event)
{
  switch((signed int)event)
  {
    case GG_EVENT_NONE:
      return "GG_EVENT_NONE";
    case GG_EVENT_MSG:
      return "GG_EVENT_MSG";
    case GG_EVENT_NOTIFY:
      return "GG_EVENT_NOTIFY";
    case GG_EVENT_NOTIFY_DESCR:
      return "GG_EVENT_NOTIFY_DESCR";
    case GG_EVENT_STATUS:
      return "GG_EVENT_STATUS";
    case GG_EVENT_ACK:
      return "GG_EVENT_ACK";
    case GG_EVENT_PONG:
      return "GG_EVENT_PONG";
    case GG_EVENT_CONN_FAILED:
      return "GG_EVENT_CONN_FAILED";
    case GG_EVENT_CONN_SUCCESS:
      return "GG_EVENT_CONN_SUCCESS";
    case GG_EVENT_DISCONNECT:
      return "GG_EVENT_DISCONNECT";
    case GG_EVENT_DCC_NEW:
      return "GG_EVENT_DCC_NEW";
    case GG_EVENT_DCC_ERROR:
      return "GG_EVENT_DCC_ERROR";
    case GG_EVENT_DCC_DONE:
      return "GG_EVENT_DCC_DONE";
    case GG_EVENT_DCC_CLIENT_ACCEPT:
      return "GG_EVENT_DCC_CLIENT_ACCEPT";
    case GG_EVENT_DCC_CALLBACK:
      return "GG_EVENT_DCC_CALLBACK";
    case GG_EVENT_DCC_NEED_FILE_INFO:
      return "GG_EVENT_DCC_NEED_FILE_INFO";
    case GG_EVENT_DCC_NEED_FILE_ACK:
      return "GG_EVENT_DCC_NEED_FILE_ACK";
    case GG_EVENT_DCC_NEED_VOICE_ACK:
      return "GG_EVENT_DCC_NEED_VOICE_ACK";
    case GG_EVENT_DCC_VOICE_DATA:
      return "GG_EVENT_DCC_VOICE_DATA";
    case GG_EVENT_PUBDIR50_SEARCH_REPLY:
      return "GG_EVENT_PUBDIR50_SEARCH_REPLY";
    case GG_EVENT_PUBDIR50_READ:
      return "GG_EVENT_PUBDIR50_READ";
    case GG_EVENT_PUBDIR50_WRITE:
      return "GG_EVENT_PUBDIR50_WRITE";
    case GG_EVENT_STATUS60:
      return "GG_EVENT_STATUS60";
    case GG_EVENT_NOTIFY60:
      return "GG_EVENT_NOTIFY60";
    case GG_EVENT_USERLIST:
      return "GG_EVENT_USERLIST";
    case GG_EVENT_IMAGE_REQUEST:
      return "GG_EVENT_IMAGE_REQUEST";
    case GG_EVENT_IMAGE_REPLY:
      return "GG_EVENT_IMAGE_REPLY";
    case GG_EVENT_DCC_ACK:
      return "GG_EVENT_DCC_ACK";
    case GG_EVENT_DCC7_NEW:
      return "GG_EVENT_DCC7_NEW";
    case GG_EVENT_DCC7_ACCEPT:
      return "GG_EVENT_DCC7_ACCEPT";
    case GG_EVENT_DCC7_REJECT:
      return "GG_EVENT_DCC7_REJECT";
    case GG_EVENT_DCC7_CONNECTED:
      return "GG_EVENT_DCC7_CONNECTED";
    case GG_EVENT_DCC7_ERROR:
      return "GG_EVENT_DCC7_ERROR";
    case GG_EVENT_DCC7_DONE:
      return "GG_EVENT_DCC7_DONE";
    case GG_EVENT_DCC7_PENDING:
      return "GG_EVENT_DCC7_PENDING";
    case GG_EVENT_XML_EVENT:
      return "GG_EVENT_XML_EVENT";
    case GG_EVENT_JSON_EVENT:
      return "GG_EVENT_JSON_EVENT";
    case GG_EVENT_ACK110:
      return "GG_EVENT_ACK110";
    case GG_EVENT_DISCONNECT_ACK:
      return "GG_EVENT_DISCONNECT_ACK";
    case GG_EVENT_TYPING_NOTIFICATION:
      return "GG_EVENT_TYPING_NOTIFICATION";
    case GG_EVENT_USER_DATA:
      return "GG_EVENT_USER_DATA";
    case GG_EVENT_MULTILOGON_MSG:
      return "GG_EVENT_MULTILOGON_MSG";
    case GG_EVENT_MULTILOGON_INFO:
      return "GG_EVENT_MULTILOGON_INFO";
    case GG_EVENT_USERLIST100_VERSION:
      return "GG_EVENT_USERLIST100_VERSION";
    case GG_EVENT_USERLIST100_REPLY:
      return "GG_EVENT_USERLIST100_REPLY";
    case GG_EVENT_IMTOKEN:
      return "GG_EVENT_IMTOKEN";
    case GG_EVENT_PONG110:
      return "GG_EVENT_PONG110";
    case GG_EVENT_CHAT_INFO:
      return "GG_EVENT_CHAT_INFO";
    case GG_EVENT_CHAT_INFO_GOT_ALL:
      return "GG_EVENT_CHAT_INFO_GOT_ALL";
    case GG_EVENT_CHAT_INFO_UPDATE:
      return "GG_EVENT_CHAT_INFO_UPDATE";
    case GG_EVENT_CHAT_CREATED:
      return "GG_EVENT_CHAT_CREATED";
    case GG_EVENT_CHAT_INVITE_ACK:
      return "GG_EVENT_CHAT_INVITE_ACK";
    default:
      return (const char *)(void *)0;
  }
}

// gg_debug_session
// file ../include/libgadu.h line 1595
void gg_debug_session(struct gg_session *gs, signed int level, const char *format, ...)
{
  void **ap;
  signed int old_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  old_errno = *return_value___errno_location$1;
  ap = (void **)&format;
  gg_debug_common(gs, level, format, ap);
  ap = ((void **)NULL);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = old_errno;
}

// gg_debug_state
// file debug.c line 216
const char * gg_debug_state(enum gg_state_t state)
{
  switch((signed int)state)
  {
    case GG_STATE_IDLE:
      return "GG_STATE_IDLE";
    case GG_STATE_RESOLVING:
      return "GG_STATE_RESOLVING";
    case GG_STATE_CONNECTING:
      return "GG_STATE_CONNECTING";
    case GG_STATE_READING_DATA:
      return "GG_STATE_READING_DATA";
    case GG_STATE_ERROR:
      return "GG_STATE_ERROR";
    case GG_STATE_CONNECTING_HUB:
      return "GG_STATE_CONNECTING_HUB";
    case GG_STATE_CONNECTING_GG:
      return "GG_STATE_CONNECTING_GG";
    case GG_STATE_READING_KEY:
      return "GG_STATE_READING_KEY";
    case GG_STATE_READING_REPLY:
      return "GG_STATE_READING_REPLY";
    case GG_STATE_CONNECTED:
      return "GG_STATE_CONNECTED";
    case GG_STATE_SENDING_QUERY:
      return "GG_STATE_SENDING_QUERY";
    case GG_STATE_READING_HEADER:
      return "GG_STATE_READING_HEADER";
    case GG_STATE_PARSING:
      return "GG_STATE_PARSING";
    case GG_STATE_DONE:
      return "GG_STATE_DONE";
    case GG_STATE_LISTENING:
      return "GG_STATE_LISTENING";
    case GG_STATE_READING_UIN_1:
      return "GG_STATE_READING_UIN_1";
    case GG_STATE_READING_UIN_2:
      return "GG_STATE_READING_UIN_2";
    case GG_STATE_SENDING_ACK:
      return "GG_STATE_SENDING_ACK";
    case GG_STATE_READING_ACK:
      return "GG_STATE_READING_ACK";
    case GG_STATE_READING_REQUEST:
      return "GG_STATE_READING_REQUEST";
    case GG_STATE_SENDING_REQUEST:
      return "GG_STATE_SENDING_REQUEST";
    case GG_STATE_SENDING_FILE_INFO:
      return "GG_STATE_SENDING_FILE_INFO";
    case GG_STATE_READING_PRE_FILE_INFO:
      return "GG_STATE_READING_PRE_FILE_INFO";
    case GG_STATE_READING_FILE_INFO:
      return "GG_STATE_READING_FILE_INFO";
    case GG_STATE_SENDING_FILE_ACK:
      return "GG_STATE_SENDING_FILE_ACK";
    case GG_STATE_READING_FILE_ACK:
      return "GG_STATE_READING_FILE_ACK";
    case GG_STATE_SENDING_FILE_HEADER:
      return "GG_STATE_SENDING_FILE_HEADER";
    case GG_STATE_READING_FILE_HEADER:
      return "GG_STATE_READING_FILE_HEADER";
    case GG_STATE_GETTING_FILE:
      return "GG_STATE_GETTING_FILE";
    case GG_STATE_SENDING_FILE:
      return "GG_STATE_SENDING_FILE";
    case GG_STATE_READING_VOICE_ACK:
      return "GG_STATE_READING_VOICE_ACK";
    case GG_STATE_READING_VOICE_HEADER:
      return "GG_STATE_READING_VOICE_HEADER";
    case GG_STATE_READING_VOICE_SIZE:
      return "GG_STATE_READING_VOICE_SIZE";
    case GG_STATE_READING_VOICE_DATA:
      return "GG_STATE_READING_VOICE_DATA";
    case GG_STATE_SENDING_VOICE_ACK:
      return "GG_STATE_SENDING_VOICE_ACK";
    case GG_STATE_SENDING_VOICE_REQUEST:
      return "GG_STATE_SENDING_VOICE_REQUEST";
    case GG_STATE_READING_TYPE:
      return "GG_STATE_READING_TYPE";
    case GG_STATE_TLS_NEGOTIATION:
      return "GG_STATE_TLS_NEGOTIATION";
    case GG_STATE_REQUESTING_ID:
      return "GG_STATE_REQUESTING_ID";
    case GG_STATE_WAITING_FOR_ACCEPT:
      return "GG_STATE_WAITING_FOR_ACCEPT";
    case GG_STATE_WAITING_FOR_INFO:
      return "GG_STATE_WAITING_FOR_INFO";
    case GG_STATE_READING_ID:
      return "GG_STATE_READING_ID";
    case GG_STATE_SENDING_ID:
      return "GG_STATE_SENDING_ID";
    case GG_STATE_RESOLVING_GG:
      return "GG_STATE_RESOLVING_GG";
    case GG_STATE_RESOLVING_RELAY:
      return "GG_STATE_RESOLVING_RELAY";
    case GG_STATE_CONNECTING_RELAY:
      return "GG_STATE_CONNECTING_RELAY";
    case GG_STATE_READING_RELAY:
      return "GG_STATE_READING_RELAY";
    case GG_STATE_DISCONNECTING:
      return "GG_STATE_DISCONNECTING";
    case GG_STATE_CONNECT_HUB:
      return "GG_STATE_CONNECT_HUB";
    case GG_STATE_CONNECT_PROXY_HUB:
      return "GG_STATE_CONNECT_PROXY_HUB";
    case GG_STATE_CONNECT_GG:
      return "GG_STATE_CONNECT_GG";
    case GG_STATE_CONNECT_PROXY_GG:
      return "GG_STATE_CONNECT_PROXY_GG";
    case GG_STATE_CONNECTING_PROXY_HUB:
      return "GG_STATE_CONNECTING_PROXY_HUB";
    case GG_STATE_CONNECTING_PROXY_GG:
      return "GG_STATE_CONNECTING_PROXY_GG";
    case GG_STATE_RESOLVE_HUB_SYNC:
      return "GG_STATE_RESOLVE_HUB_SYNC";
    case GG_STATE_RESOLVE_HUB_ASYNC:
      return "GG_STATE_RESOLVE_HUB_ASYNC";
    case GG_STATE_RESOLVE_PROXY_HUB_SYNC:
      return "GG_STATE_RESOLVE_PROXY_HUB_SYNC";
    case GG_STATE_RESOLVE_PROXY_HUB_ASYNC:
      return "GG_STATE_RESOLVE_PROXY_HUB_ASYNC";
    case GG_STATE_RESOLVE_PROXY_GG_SYNC:
      return "GG_STATE_RESOLVE_PROXY_GG_SYNC";
    case GG_STATE_RESOLVE_PROXY_GG_ASYNC:
      return "GG_STATE_RESOLVE_PROXY_GG_ASYNC";
    case GG_STATE_RESOLVE_GG_SYNC:
      return "GG_STATE_RESOLVE_GG_SYNC";
    case GG_STATE_RESOLVE_GG_ASYNC:
      return "GG_STATE_RESOLVE_GG_ASYNC";
    case GG_STATE_RESOLVING_HUB:
      return "GG_STATE_RESOLVING_HUB";
    case GG_STATE_RESOLVING_PROXY_HUB:
      return "GG_STATE_RESOLVING_PROXY_HUB";
    case GG_STATE_RESOLVING_PROXY_GG:
      return "GG_STATE_RESOLVING_PROXY_GG";
    case GG_STATE_SEND_HUB:
      return "GG_STATE_SEND_HUB";
    case GG_STATE_SEND_PROXY_HUB:
      return "GG_STATE_SEND_PROXY_HUB";
    case GG_STATE_SEND_PROXY_GG:
      return "GG_STATE_SEND_PROXY_GG";
    case GG_STATE_SENDING_HUB:
      return "GG_STATE_SENDING_HUB";
    case GG_STATE_SENDING_PROXY_HUB:
      return "GG_STATE_SENDING_PROXY_HUB";
    case GG_STATE_SENDING_PROXY_GG:
      return "GG_STATE_SENDING_PROXY_GG";
    case GG_STATE_READING_HUB:
      return "GG_STATE_READING_HUB";
    case GG_STATE_READING_PROXY_HUB:
      return "GG_STATE_READING_PROXY_HUB";
    case GG_STATE_READING_PROXY_GG:
      return "GG_STATE_READING_PROXY_GG";
    default:
      return (const char *)(void *)0;
  }
}

// gg_deflate
// file deflate.c line 50
unsigned char * gg_deflate(const char *in, unsigned long int *out_lenp)
{
  signed int ret;
  struct z_stream_s strm;
  unsigned char *out;
  unsigned char *out2;
  unsigned long int out_len;
  void *return_value_realloc$4;
  if(in == ((const char *)NULL) || out_lenp == ((unsigned long int *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    strm.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    strm.zfree = ((void (*)(void *, void *))NULL);
    strm.opaque = NULL;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(in);
    strm.avail_in = (unsigned int)return_value_strlen$1;
    strm.next_in = (unsigned char *)in;
    ret=deflateInit_(&strm, 9, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(ret == 0))
    {
      gg_debug(16, "// gg_deflate() deflateInit() failed (%d)\n", ret);
      return (unsigned char *)(void *)0;
    }

    else
    {
      out_len=deflateBound(&strm, (unsigned long int)strm.avail_in);
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(out_len);
      out = (unsigned char *)return_value_malloc$2;
      if(out == ((unsigned char *)NULL))
        gg_debug(16, "// gg_deflate() not enough memory for output data (%zu)\n", out_len);

      else
      {
        strm.avail_out = (unsigned int)out_len;
        strm.next_out = out;
        do
        {
          ret=deflate(&strm, 4);
          if(ret == 1)
            break;

          if(ret == 0)
          {
            out_len = out_len * (unsigned long int)2;
            void *return_value_realloc$3;
            return_value_realloc$3=realloc((void *)out, out_len);
            out2 = (unsigned char *)return_value_realloc$3;
            if(out2 == ((unsigned char *)NULL))
            {
              gg_debug(16, "// gg_deflate() not enough memory for output data (%zu)\n", out_len);
              goto fail;
            }

            out = out2;
            strm.avail_out = (unsigned int)(out_len / (unsigned long int)2);
            strm.next_out = out + (signed long int)(out_len / (unsigned long int)2);
          }

          else
          {
            gg_debug(16, "// gg_deflate() deflate() failed (ret=%d, msg=%s)\n", ret, strm.msg != (char *)(void *)0 ? strm.msg : "no error message provided");
            goto fail;
          }
        }
        while((_Bool)1);
        out_len = strm.total_out;
        return_value_realloc$4=realloc((void *)out, out_len);
        out2 = (unsigned char *)return_value_realloc$4;
        if(out2 == ((unsigned char *)NULL))
          gg_debug(16, "// gg_deflate() not enough memory for output data (%zu)\n", out_len);

        else
        {
          *out_lenp = out_len;
          deflateEnd(&strm);
          return out2;
        }
      }

    fail:
      ;
      *out_lenp = (unsigned long int)0;
      deflateEnd(&strm);
      free((void *)out);
      return (unsigned char *)(void *)0;
    }
  }
}

// gg_encoding_convert
// file encoding.c line 228
char * gg_encoding_convert(const char *src, enum anonymous$3 src_encoding, enum anonymous$3 dst_encoding, signed int src_length, signed int dst_length)
{
  char *result;
  if(src == ((const char *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (char *)(void *)0;
  }

  char *return_value_strdup$2;
  unsigned long int return_value_strlen$3;
  char *return_value_gg_encoding_convert_utf8_cp1250$5;
  char *return_value_gg_encoding_convert_cp1250_utf8$6;
  if(dst_encoding == src_encoding && dst_length == -1 && src_length == -1)
  {
    return_value_strdup$2=strdup(src);
    return return_value_strdup$2;
  }

  else
  {
    if(src_length == -1)
    {
      return_value_strlen$3=strlen(src);
      src_length = (signed int)return_value_strlen$3;
    }

    if(dst_encoding == src_encoding)
    {
      signed int len;
      if(dst_length == -1)
        len = src_length;

      else
        len = src_length < dst_length ? src_length : dst_length;
      void *return_value_malloc$4;
      return_value_malloc$4=malloc((unsigned long int)(len + 1));
      result = (char *)return_value_malloc$4;
      if(result == ((char *)NULL))
        return (char *)(void *)0;

      strncpy(result, src, (unsigned long int)len);
      result[(signed long int)len] = (char)0;
      return result;
    }

    if((signed int)dst_encoding == GG_ENCODING_CP1250 && (signed int)src_encoding == GG_ENCODING_UTF8)
    {
      return_value_gg_encoding_convert_utf8_cp1250$5=gg_encoding_convert_utf8_cp1250(src, src_length, dst_length);
      return return_value_gg_encoding_convert_utf8_cp1250$5;
    }

    else
      if((signed int)dst_encoding == GG_ENCODING_UTF8 && (signed int)src_encoding == GG_ENCODING_CP1250)
      {
        return_value_gg_encoding_convert_cp1250_utf8$6=gg_encoding_convert_cp1250_utf8(src, src_length, dst_length);
        return return_value_gg_encoding_convert_cp1250_utf8$6;
      }

      else
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        *return_value___errno_location$7 = 22;
        return (char *)(void *)0;
      }
  }
}

// gg_encoding_convert_cp1250_utf8
// file encoding.c line 65
static char * gg_encoding_convert_cp1250_utf8(const char *src, signed int src_length, signed int dst_length)
{
  signed int i;
  signed int j;
  signed int len;
  char *result = (char *)(void *)0;
  i = 0;
  len = 0;
  for( ; !((signed int)src[(signed long int)i] == 0) && !(i >= src_length); i = i + 1)
  {
    unsigned short int uc;
    if(!((signed int)(unsigned char)src[(signed long int)i] >= 0x80))
      uc = (unsigned short int)(unsigned char)src[(signed long int)i];

    else
      uc = table_cp1250[(signed long int)((signed int)(unsigned char)src[(signed long int)i] - 128)];
    if(!((signed int)uc >= 0x80))
      len = len + 1;

    else
      if(!((signed int)uc >= 0x800))
        len = len + 2;

      else
        len = len + 3;
  }
  if(!(dst_length == -1) && !(dst_length >= len))
    len = dst_length;

  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(len + 1));
  result = (char *)return_value_malloc$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  if(result == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    j = 0;
    for( ; !((signed int)src[(signed long int)i] == 0) && !(i >= src_length) && !(j >= len); i = i + 1)
    {
      unsigned short int gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc;
      if(!((signed int)(unsigned char)src[(signed long int)i] >= 0x80))
        gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc = (unsigned short int)(unsigned char)src[(signed long int)i];

      else
        gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc = table_cp1250[(signed long int)((signed int)(unsigned char)src[(signed long int)i] - 128)];
      if(!((signed int)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc >= 0x80))
      {
        tmp_post$2 = j;
        j = j + 1;
        result[(signed long int)tmp_post$2] = (char)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc;
      }

      else
        if(!((signed int)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc >= 0x800))
        {
          if(!(len >= 1 + j))
            break;

          tmp_post$3 = j;
          j = j + 1;
          result[(signed long int)tmp_post$3] = (char)(0xc0 | (signed int)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc >> 6 & 0x1f);
          tmp_post$4 = j;
          j = j + 1;
          result[(signed long int)tmp_post$4] = (char)(0x80 | (signed int)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc & 0x3f);
        }

        else
        {
          if(!(len >= 2 + j))
            break;

          tmp_post$5 = j;
          j = j + 1;
          result[(signed long int)tmp_post$5] = (char)(0xe0 | (signed int)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc >> 12 & 0x1f);
          tmp_post$6 = j;
          j = j + 1;
          result[(signed long int)tmp_post$6] = (char)(0x80 | (signed int)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc >> 6 & 0x3f);
          tmp_post$7 = j;
          j = j + 1;
          result[(signed long int)tmp_post$7] = (char)(0x80 | (signed int)gg_encoding_convert_cp1250_utf8$$1$$2$$1$$uc & 0x3f);
        }
    }
    result[(signed long int)j] = (char)0;
    return result;
  }
}

// gg_encoding_convert_utf8_cp1250
// file encoding.c line 132
static char * gg_encoding_convert_utf8_cp1250(const char *src, signed int src_length, signed int dst_length)
{
  char *result;
  signed int i;
  signed int j;
  signed int len;
  signed int uc_left = 0;
  unsigned int uc = (unsigned int)0;
  unsigned int uc_min = (unsigned int)0;
  i = 0;
  len = 0;
  for( ; !((signed int)src[(signed long int)i] == 0) && !(i >= src_length); i = i + 1)
    if(!((0xc0 & (signed int)src[(signed long int)i]) == 0x80))
      len = len + 1;

  if(!(dst_length == -1) && !(dst_length >= len))
    len = dst_length;

  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(len + 1));
  result = (char *)return_value_malloc$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  if(result == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    j = 0;
    for( ; !((signed int)src[(signed long int)i] == 0) && !(i >= src_length) && !(j >= len); i = i + 1)
      if((signed int)(unsigned char)src[(signed long int)i] >= 0xf5)
      {
        if(!(uc_left == 0))
        {
          tmp_post$2 = j;
          j = j + 1;
          result[(signed long int)tmp_post$2] = (char)63;
        }

        tmp_post$3 = j;
        j = j + 1;
        result[(signed long int)tmp_post$3] = (char)63;
        uc_left = 0;
      }

      else
        if((0xf8 & (signed int)src[(signed long int)i]) == 0xf0)
        {
          if(!(uc_left == 0))
          {
            tmp_post$4 = j;
            j = j + 1;
            result[(signed long int)tmp_post$4] = (char)63;
          }

          uc = (unsigned int)((signed int)src[(signed long int)i] & 0x07);
          uc_left = 3;
          uc_min = (unsigned int)0x10000;
        }

        else
          if((0xf0 & (signed int)src[(signed long int)i]) == 0xe0)
          {
            if(!(uc_left == 0))
            {
              tmp_post$5 = j;
              j = j + 1;
              result[(signed long int)tmp_post$5] = (char)63;
            }

            uc = (unsigned int)((signed int)src[(signed long int)i] & 0x0f);
            uc_left = 2;
            uc_min = (unsigned int)0x800;
          }

          else
            if((0xe0 & (signed int)src[(signed long int)i]) == 0xc0)
            {
              if(!(uc_left == 0))
              {
                tmp_post$6 = j;
                j = j + 1;
                result[(signed long int)tmp_post$6] = (char)63;
              }

              uc = (unsigned int)((signed int)src[(signed long int)i] & 0x1f);
              uc_left = 1;
              uc_min = (unsigned int)0x80;
            }

            else
              if((0xc0 & (signed int)src[(signed long int)i]) == 0x80)
              {
                if(uc_left >= 1)
                {
                  uc = uc << 6;
                  uc = uc | (unsigned int)((signed int)src[(signed long int)i] & 0x3f);
                  uc_left = uc_left - 1;
                  if(uc_left == 0)
                  {
                    signed int valid = 0;
                    signed int k;
                    if(uc >= uc_min)
                    {
                      k = 0;
                      for( ; !(k >= 128); k = k + 1)
                        if(uc == (unsigned int)table_cp1250[(signed long int)k])
                        {
                          tmp_post$7 = j;
                          j = j + 1;
                          result[(signed long int)tmp_post$7] = (char)(k + 128);
                          valid = 1;
                          break;
                        }

                    }

                    if(valid == 0 && !(uc == 65279u))
                    {
                      tmp_post$8 = j;
                      j = j + 1;
                      result[(signed long int)tmp_post$8] = (char)63;
                    }

                  }

                }

              }

              else
              {
                if(!(uc_left == 0))
                {
                  tmp_post$9 = j;
                  j = j + 1;
                  result[(signed long int)tmp_post$9] = (char)63;
                  uc_left = 0;
                }

                tmp_post$10 = j;
                j = j + 1;
                result[(signed long int)tmp_post$10] = src[(signed long int)i];
              }
    if(!(uc_left == 0))
    {
      if((signed int)src[(signed long int)i] == 0)
      {
        tmp_post$11 = j;
        j = j + 1;
        result[(signed long int)tmp_post$11] = (char)63;
      }

    }

    result[(signed long int)j] = (char)0;
    return result;
  }
}

// gg_event_free
// file ../../include/libgadu.h line 1368
void gg_event_free(struct gg_event *e)
{
  gg_debug(8, "** gg_event_free(%p);\n", e);
  signed int gg_event_free$$1$$1$$1$$i;
  unsigned int gg_event_free$$1$$1$$2$$i;
  unsigned int j;
  signed int i;
  if(!(e == ((struct gg_event *)NULL)))
  {
    switch(e->type)
    {
      case GG_EVENT_MSG:

      case GG_EVENT_MULTILOGON_MSG:
      {
        free((void *)e->event.msg.message);
        free(e->event.msg.formats);
        free((void *)e->event.msg.recipients);
        free((void *)e->event.msg.xhtml_message);
        break;
      }
      case GG_EVENT_NOTIFY:
      {
        free((void *)e->event.notify);
        break;
      }
      case GG_EVENT_NOTIFY60:
      {
        gg_event_free$$1$$1$$1$$i = 0;
        for( ; !((e->event.notify60 + (signed long int)gg_event_free$$1$$1$$1$$i)->uin == 0u); gg_event_free$$1$$1$$1$$i = gg_event_free$$1$$1$$1$$i + 1)
          free((void *)(e->event.notify60 + (signed long int)gg_event_free$$1$$1$$1$$i)->descr);
        free((void *)e->event.notify60);
        break;
      }
      case GG_EVENT_STATUS60:
      {
        free((void *)e->event.status60.descr);
        break;
      }
      case GG_EVENT_STATUS:
      {
        free((void *)e->event.status.descr);
        break;
      }
      case GG_EVENT_NOTIFY_DESCR:
      {
        free((void *)e->event.notify_descr.notify);
        free((void *)e->event.notify_descr.descr);
        break;
      }
      case GG_EVENT_DCC_VOICE_DATA:
      {
        free((void *)e->event.dcc_voice_data.data);
        break;
      }
      case GG_EVENT_PUBDIR50_SEARCH_REPLY:

      case GG_EVENT_PUBDIR50_READ:

      case GG_EVENT_PUBDIR50_WRITE:
      {
        gg_pubdir50_free(e->event.pubdir50);
        break;
      }
      case GG_EVENT_USERLIST:
      {
        free((void *)e->event.userlist.reply);
        break;
      }
      case GG_EVENT_IMAGE_REPLY:
      {
        free((void *)e->event.image_reply.filename);
        free((void *)e->event.image_reply.image);
        break;
      }
      case GG_EVENT_XML_EVENT:
      {
        free((void *)e->event.xml_event.data);
        break;
      }
      case GG_EVENT_JSON_EVENT:
      {
        free((void *)e->event.json_event.data);
        free((void *)e->event.json_event.type);
        break;
      }
      case GG_EVENT_USER_DATA:
      {
        gg_event_free$$1$$1$$2$$i = (unsigned int)0;
        for( ; !((unsigned long int)gg_event_free$$1$$1$$2$$i >= e->event.user_data.user_count); gg_event_free$$1$$1$$2$$i = gg_event_free$$1$$1$$2$$i + 1u)
        {
          j = (unsigned int)0;
          for( ; !((unsigned long int)j >= (e->event.user_data.users + (signed long int)gg_event_free$$1$$1$$2$$i)->attr_count); j = j + 1u)
          {
            free((void *)((e->event.user_data.users + (signed long int)gg_event_free$$1$$1$$2$$i)->attrs + (signed long int)j)->key);
            free((void *)((e->event.user_data.users + (signed long int)gg_event_free$$1$$1$$2$$i)->attrs + (signed long int)j)->value);
          }
          free((void *)(e->event.user_data.users + (signed long int)gg_event_free$$1$$1$$2$$i)->attrs);
        }
        free((void *)e->event.user_data.users);
        break;
      }
      case GG_EVENT_MULTILOGON_INFO:
      {
        i = 0;
        for( ; !(i >= e->event.multilogon_info.count); i = i + 1)
          free((void *)(e->event.multilogon_info.sessions + (signed long int)i)->name);
        free((void *)e->event.multilogon_info.sessions);
        break;
      }
      case GG_EVENT_USERLIST100_REPLY:
      {
        free((void *)e->event.userlist100_reply.reply);
        break;
      }
      case GG_EVENT_IMTOKEN:
      {
        free((void *)e->event.imtoken.imtoken);
        break;
      }
      case GG_EVENT_CHAT_INFO:
        free((void *)e->event.chat_info.participants);
    }
    free((void *)e);
  }

}

// gg_eventqueue_add
// file events.c line 1746
struct gg_event * gg_eventqueue_add(struct gg_session *sess)
{
  struct gg_event *ge;
  struct _gg_eventqueue *queue_el;
  struct _gg_eventqueue *it;
  void *return_value_gg_new0$1;
  return_value_gg_new0$1=gg_new0(sizeof(struct _gg_eventqueue) /*16ul*/ );
  queue_el = (struct _gg_eventqueue *)return_value_gg_new0$1;
  void *return_value_gg_new0$2;
  return_value_gg_new0$2=gg_new0(sizeof(struct gg_event) /*96ul*/ );
  ge = (struct gg_event *)return_value_gg_new0$2;
  if(queue_el == ((struct _gg_eventqueue *)NULL) || ge == ((struct gg_event *)NULL))
  {
    free((void *)queue_el);
    free((void *)ge);
    return (struct gg_event *)(void *)0;
  }

  else
  {
    ge->type = GG_EVENT_NONE;
    queue_el->event = ge;
    if(sess->private_data->event_queue == ((struct _gg_eventqueue *)NULL))
      sess->private_data->event_queue = queue_el;

    else
    {
      it = sess->private_data->event_queue;
      for( ; !(it->next == ((struct _gg_eventqueue *)NULL)); it = it->next)
        ;
      it->next = queue_el;
    }
    return ge;
  }
}

// gg_fd_set_nonblocking
// file ../../include/network.h line 112
static inline signed int gg_fd_set_nonblocking(signed int fd)
{
  signed int success;
  signed int one = 1;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fd, (unsigned long int)0x5421, &one);
  success = (signed int)(return_value_ioctl$1 == 0);
  return success;
}

// gg_fd_set_nonblocking$link1
// file ../include/network.h line 112
static inline signed int gg_fd_set_nonblocking$link1(signed int fd$link1)
{
  signed int success$link1;
  signed int one$link1 = 1;
  signed int return_value_ioctl$1$link1;
  return_value_ioctl$1$link1=ioctl(fd$link1, (unsigned long int)0x5421, &one$link1);
  success$link1 = (signed int)(return_value_ioctl$1$link1 == 0);
  return success$link1;
}

// gg_fd_set_nonblocking$link2
// file ../include/network.h line 112
static inline signed int gg_fd_set_nonblocking$link2(signed int fd$link2)
{
  signed int success$link2;
  signed int one$link2 = 1;
  signed int return_value_ioctl$1$link2;
  return_value_ioctl$1$link2=ioctl(fd$link2, (unsigned long int)0x5421, &one$link2);
  success$link2 = (signed int)(return_value_ioctl$1$link2 == 0);
  return success$link2;
}

// gg_fd_set_nonblocking$link3
// file ../include/network.h line 112
static inline signed int gg_fd_set_nonblocking$link3(signed int fd$link3)
{
  signed int success$link3;
  signed int one$link3 = 1;
  signed int return_value_ioctl$1$link3;
  return_value_ioctl$1$link3=ioctl(fd$link3, (unsigned long int)0x5421, &one$link3);
  success$link3 = (signed int)(return_value_ioctl$1$link3 == 0);
  return success$link3;
}

// gg_file_hash_sha1
// file ../include/libgadu.h line 1752
signed int gg_file_hash_sha1(signed int fd, unsigned char *result)
{
  struct hash_hd_st *ctx;
  signed long int pos;
  signed long int len;
  signed int res;
  const unsigned long int part_len = (const unsigned long int)1048576;
  pos=lseek(fd, (signed long int)0, 1);
  if(pos == -1l)
    return -1;

  else
  {
    len=lseek(fd, (signed long int)0, 2);
    if(len == -1l)
      return -1;

    else
    {
      signed long int return_value_lseek$1;
      return_value_lseek$1=lseek(fd, (signed long int)0, 0);
      if(return_value_lseek$1 == -1l)
        return -1;

      else
      {
        signed int return_value_gnutls_hash_init$2;
        return_value_gnutls_hash_init$2=gnutls_hash_init(&ctx, (enum anonymous$25)GNUTLS_DIG_SHA1);
        if(!(return_value_gnutls_hash_init$2 == 0))
          return -1;

        else
        {
          if(10l * (signed long int)part_len >= len)
            res=gg_file_hash_sha1_part(fd, &ctx, (signed long int)0, (unsigned long int)len);

          else
          {
            unsigned int i = (unsigned int)0;
            for( ; !(i >= 9u); i = i + 1u)
            {
              signed long int part_pos = (signed long int)((((unsigned long int)len - part_len) / (unsigned long int)9) * (unsigned long int)i);
              res=gg_file_hash_sha1_part(fd, &ctx, part_pos, part_len);
              if(res == -1)
                break;

            }
          }
          gnutls_hash_deinit(*(&ctx), (void *)result);
          if(res == -1)
            return -1;

          else
          {
            signed long int return_value_lseek$3;
            return_value_lseek$3=lseek(fd, pos, 0);
            if(return_value_lseek$3 == -1l)
              return -1;

            else
              return 0;
          }
        }
      }
    }
  }
}

// gg_file_hash_sha1_part
// file sha1.c line 286
static signed int gg_file_hash_sha1_part(signed int fd, struct hash_hd_st **ctx, signed long int pos, unsigned long int len)
{
  unsigned char buf[4096l];
  unsigned long int chunk_len;
  signed int res = 0;
  signed int *return_value___errno_location$3;
  while(len >= 1ul)
  {
    signed long int return_value_lseek$1;
    return_value_lseek$1=lseek(fd, pos, 0);
    if(return_value_lseek$1 == -1l)
    {
      res = -1;
      break;
    }

    chunk_len = len;
    if(chunk_len >= 4097ul)
      chunk_len = sizeof(unsigned char [4096l]) /*4096ul*/ ;

    signed long int return_value_read$2;
    return_value_read$2=read(fd, (void *)buf, chunk_len);
    res = (signed int)return_value_read$2;
    if(res == -1)
    {
      return_value___errno_location$3=__errno_location();
      if(!(*return_value___errno_location$3 == 4))
        break;

    }

    if(!(res == -1))
    {
      signed int return_value_gnutls_hash$4;
      return_value_gnutls_hash$4=gnutls_hash(*ctx, (const void *)buf, (unsigned long int)res);
      if(!(return_value_gnutls_hash$4 == 0))
      {
        res = -1;
        break;
      }

      pos = pos + (signed long int)res;
      len = len - (unsigned long int)res;
    }

  }
  return res;
}

// gg_fix16
// file ../include/libgadu.h line 1775
unsigned short int gg_fix16(unsigned short int x)
{
  return x;
}

// gg_fix32
// file ../include/libgadu.h line 1774
unsigned int gg_fix32(unsigned int x)
{
  return x;
}

// gg_fix64
// file ../include/internal.h line 176
unsigned long int gg_fix64(unsigned long int x)
{
  return x;
}

// gg_free_search
// file obsolete.c line 107
void gg_free_search(struct gg_http *h)
{
  ;
}

// gg_free_session
// file ../../include/libgadu.h line 799
void gg_free_session(struct gg_session *sess)
{
  struct gg_dcc7 *dcc;
  struct _gg_chat_list *chat;
  gg_debug_session(sess, 8, "** gg_free_session(%p);\n", sess);
  if(!(sess == ((struct gg_session *)NULL)))
  {
    free((void *)sess->resolver_result);
    free((void *)sess->connect_host);
    free((void *)sess->password);
    free((void *)sess->initial_descr);
    free((void *)sess->client_version);
    free((void *)sess->header_buf);
    free((void *)sess->recv_buf);
    if(!(sess->ssl == NULL))
    {
      struct anonymous$34 *tmp = (struct anonymous$34 *)sess->ssl;
      gnutls_deinit(tmp->session);
      gnutls_certificate_free_credentials(tmp->xcred);
      gnutls_global_deinit();
      free(sess->ssl);
    }

    if(!(sess->resolver_cleanup == ((void (*)(void **, signed int))NULL)))
      sess->resolver_cleanup(&sess->resolver, 1);

    gg_close(sess);
    while(!(sess->images == ((struct gg_image_queue *)NULL)))
    {
      struct gg_image_queue *next = sess->images->next;
      gg_image_queue_remove(sess, sess->images, 1);
      sess->images = next;
    }
    free((void *)sess->send_buf);
    dcc = sess->dcc7_list;
    for( ; !(dcc == ((struct gg_dcc7 *)NULL)); dcc = dcc->next)
      dcc->sess = (struct gg_session *)(void *)0;
    chat = sess->private_data->chat_list;
    while(!(chat == ((struct _gg_chat_list *)NULL)))
    {
      struct _gg_chat_list *gg_free_session$$1$$4$$next = chat->next;
      free((void *)chat->participants);
      free((void *)chat);
      chat = gg_free_session$$1$$4$$next;
    }
    gg_strarr_free(sess->private_data->host_white_list);
    free((void *)sess->private_data);
    free((void *)sess);
  }

}

// gg_get_dummy_fd
// file ../include/internal.h line 158
signed int gg_get_dummy_fd(struct gg_session *sess)
{
  struct gg_session_private *p = sess->private_data;
  if(!(p->dummyfds_created == 0))
    return p->dummyfds[(signed long int)0];

  else
  {
    signed int return_value_socketpair$4;
    return_value_socketpair$4=socketpair(1, 1, 0, p->dummyfds);
    if(return_value_socketpair$4 == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      gg_debug(16 | 128, "// gg_get_dummy_fd() unable to create pipes (errno=%d, %s)\n", *return_value___errno_location$1, return_value_strerror$3);
      return -1;
    }

    p->dummyfds_created = 1;
    return p->dummyfds[(signed long int)0];
  }
}

// gg_get_line
// file common.c line 160
char * gg_get_line(char **ptr)
{
  char *foo;
  char *res;
  _Bool tmp_if_expr$1;
  if(ptr == ((char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*ptr != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strcmp$2=strcmp(*ptr, "");
    tmp_if_expr$3 = !(return_value_strcmp$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int return_value_strlen$4;
  if(tmp_if_expr$3)
    return (char *)(void *)0;

  else
  {
    res = *ptr;
    foo=strchr(*ptr, 10);
    if(foo == ((char *)NULL))
    {
      return_value_strlen$4=strlen(*ptr);
      *ptr = *ptr + (signed long int)return_value_strlen$4;
    }

    else
    {
      unsigned long int len;
      *ptr = foo + (signed long int)1;
      *foo = (char)0;
      len=strlen(res);
      if(len >= 2ul)
      {
        if((signed int)res[-1l + (signed long int)len] == 13)
          res[(signed long int)(len - (unsigned long int)1)] = (char)0;

      }

    }
    return res;
  }
}

// gg_gethostbyname
// file resolver.c line 354
struct in_addr * gg_gethostbyname(const char *hostname)
{
  struct in_addr *result;
  unsigned int count;
  signed int return_value_gg_gethostbyname_real$1;
  return_value_gg_gethostbyname_real$1=gg_gethostbyname_real(hostname, &result, &count, 0);
  if(return_value_gg_gethostbyname_real$1 == -1)
    return (struct in_addr *)(void *)0;

  else
    return result;
}

// gg_gethostbyname_real
// file ../include/resolver.h line 24
signed int gg_gethostbyname_real(const char *hostname, struct in_addr **result, unsigned int *count, signed int pthread)
{
  char *buf = (char *)(void *)0;
  char *new_buf = (char *)(void *)0;
  struct hostent he;
  struct hostent *he_ptr = (struct hostent *)(void *)0;
  unsigned long int buf_len = (unsigned long int)1024;
  signed int res = -1;
  signed int h_errnop;
  signed int ret = 0;
  signed int old_state;
  if(result == ((struct in_addr **)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  do
  {
    struct anonymous$24 __cancel_buf;
    void (*__cancel_routine)(void *) = gg_resolver_cleaner;
    void *__cancel_arg = (void *)&buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      if(!(pthread == 0))
        pthread_setcancelstate(1, &old_state);

      void *return_value_malloc$2;
      return_value_malloc$2=malloc(buf_len);
      buf = (char *)return_value_malloc$2;
      if(!(pthread == 0))
        pthread_setcancelstate(old_state, (signed int *)(void *)0);

      if(!(buf == ((char *)NULL)))
      {
        while((_Bool)1)
        {
          ret=gethostbyname_r(hostname, &he, buf, buf_len, &he_ptr, &h_errnop);
          if(!(ret == 34))
            break;

          buf_len = buf_len * (unsigned long int)2;
          if(!(pthread == 0))
            pthread_setcancelstate(1, &old_state);

          void *return_value_realloc$3;
          return_value_realloc$3=realloc((void *)buf, buf_len);
          new_buf = (char *)return_value_realloc$3;
          if(!(new_buf == ((char *)NULL)))
            buf = new_buf;

          if(!(pthread == 0))
            pthread_setcancelstate(old_state, (signed int *)(void *)0);

          if(new_buf == ((char *)NULL))
          {
            ret = 12;
            break;
          }

        }
        if(ret == 0 && !(he_ptr == ((struct hostent *)NULL)))
        {
          if(!(*he_ptr->h_addr_list == ((char *)NULL)))
          {
            signed int i = 0;
            for( ; !(he_ptr->h_addr_list[(signed long int)i] == ((char *)NULL)); i = i + 1)
              ;
            if(!(pthread == 0))
              pthread_setcancelstate(1, &old_state);

            void *return_value_malloc$4;
            return_value_malloc$4=malloc((unsigned long int)(i + 1) * sizeof(struct in_addr) /*4ul*/ );
            *result = (struct in_addr *)return_value_malloc$4;
            if(!(pthread == 0))
              pthread_setcancelstate(old_state, (signed int *)(void *)0);

            if(!(*result == ((struct in_addr *)NULL)))
            {
              i = 0;
              for( ; !(he_ptr->h_addr_list[(signed long int)i] == ((char *)NULL)); i = i + 1)
                memcpy((void *)&(*result)[(signed long int)i], (const void *)he_ptr->h_addr_list[(signed long int)i], sizeof(struct in_addr) /*4ul*/ );
              (*result + (signed long int)i)->s_addr = (unsigned int)0xffffffff;
              *count = (unsigned int)i;
              res = 0;
            }

            else
              res = -1;
          }

        }

        if(!(pthread == 0))
          pthread_setcancelstate(1, &old_state);

        free((void *)buf);
        buf = (char *)(void *)0;
        if(!(pthread == 0))
          pthread_setcancelstate(old_state, (signed int *)(void *)0);

      }


    __CPROVER_DUMP_L22:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  return res;
}

// gg_global_get_resolver
// file resolver.c line 1085
enum anonymous$4 gg_global_get_resolver(void)
{
  return gg_global_resolver_type;
}

// gg_global_set_custom_resolver
// file resolver.c line 1100
signed int gg_global_set_custom_resolver(signed int (*resolver_start)(signed int *, void **, const char *), void (*resolver_cleanup)(void **, signed int))
{
  if(resolver_cleanup == ((void (*)(void **, signed int))NULL) || resolver_start == ((signed int (*)(signed int *, void **, const char *))NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  gg_global_resolver_type = (enum anonymous$4)GG_RESOLVER_CUSTOM;
  gg_global_resolver_start = resolver_start;
  gg_global_resolver_cleanup = resolver_cleanup;
  return 0;
}

// gg_global_set_resolver
// file resolver.c line 1041
signed int gg_global_set_resolver(enum anonymous$4 type)
{
  signed int *return_value___errno_location$1;
  switch((signed int)type)
  {
    case GG_RESOLVER_DEFAULT:
    {
      gg_global_resolver_type = type;
      gg_global_resolver_start = (signed int (*)(signed int *, void **, const char *))(void *)0;
      gg_global_resolver_cleanup = (void (*)(void **, signed int))(void *)0;
      return 0;
    }
    case GG_RESOLVER_FORK:
    {
      gg_global_resolver_type = type;
      gg_global_resolver_start = gg_resolver_fork_start;
      gg_global_resolver_cleanup = gg_resolver_fork_cleanup;
      return 0;
    }
    case GG_RESOLVER_PTHREAD:
    {
      gg_global_resolver_type = type;
      gg_global_resolver_start = gg_resolver_pthread_start;
      gg_global_resolver_cleanup = gg_resolver_pthread_cleanup;
      return 0;
    }
    default:
    {
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
      return -1;
    }
  }
}

// gg_handle_connect
// file events.c line 702
static enum anonymous$27 gg_handle_connect(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  struct in_addr addr;
  signed int port;
  if(sess->resolver_index >= sess->resolver_count)
  {
    gg_debug_session(sess, 16, "// gg_watch_fd() out of addresses to connect to\n");
    e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
  {
    addr = sess->resolver_result[(signed long int)sess->resolver_index];
    if(sess->state == GG_STATE_CONNECT_HUB)
    {
      sess->hub_addr = addr.s_addr;
      port = 80;
    }

    else
    {
      sess->proxy_addr = addr.s_addr;
      port = (signed int)sess->proxy_port;
    }
    char *return_value_inet_ntoa$1;
    return_value_inet_ntoa$1=inet_ntoa(addr);
    gg_debug_session(sess, 16, "// gg_watch_fd() connecting to %s:%d\n", return_value_inet_ntoa$1, port);
    sess->fd=gg_connect((void *)&addr, port, sess->async);
    if(sess->fd == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      gg_debug_session(sess, 16, "// gg_watch_fd() connection failed (errno=%d, %s)\n", *return_value___errno_location$2, return_value_strerror$4);
      sess->resolver_index = sess->resolver_index + 1u;
      return (enum anonymous$27)GG_ACTION_NEXT;
    }

    sess->state = (signed int)next_state;
    sess->check = 1;
    sess->timeout = 30;
    sess->soft_timeout = 1;
    return (enum anonymous$27)GG_ACTION_WAIT;
  }
}

// gg_handle_connect_gg
// file events.c line 774
static enum anonymous$27 gg_handle_connect_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  struct in_addr addr;
  unsigned short int port;
  gg_debug_session(sess, 16, "resolver_index=%d, connect_index=%d, connect_port={%d,%d}\n", sess->resolver_index, sess->connect_index, sess->connect_port[(signed long int)0], sess->connect_port[(signed long int)1]);
  _Bool tmp_if_expr$1;
  if((unsigned long int)sess->connect_index >= 2ul)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)sess->connect_port[(signed long int)sess->connect_index] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    sess->connect_index = (unsigned int)0;
    sess->resolver_index = sess->resolver_index + 1u;
    if(!(sess->resolver_index >= sess->resolver_count))
      goto __CPROVER_DUMP_L3;

    gg_debug_session(sess, 16, "// gg_watch_fd() out of addresses to connect to\n");
    e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    addr = sess->resolver_result[(signed long int)sess->resolver_index];
    port = sess->connect_port[(signed long int)sess->connect_index];
    char *return_value_inet_ntoa$2;
    return_value_inet_ntoa$2=inet_ntoa(addr);
    gg_debug_session(sess, 16, "// gg_watch_fd() connecting to %s:%d\n", return_value_inet_ntoa$2, port);
    sess->server_addr = addr.s_addr;
    sess->fd=gg_connect((void *)&addr, (signed int)port, sess->async);
    if(sess->fd == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      gg_debug_session(sess, 16, "// gg_watch_fd() connection failed (errno=%d, %s)\n", *return_value___errno_location$3, return_value_strerror$5);
      sess->connect_index = sess->connect_index + 1u;
      return (enum anonymous$27)GG_ACTION_NEXT;
    }

    sess->state = (signed int)next_state;
    sess->check = 1;
    sess->timeout = 30;
    sess->soft_timeout = 1;
    return (enum anonymous$27)GG_ACTION_WAIT;
  }
}

// gg_handle_connected
// file events.c line 1588
static enum anonymous$27 gg_handle_connected(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  struct gg_header *gh;
  signed int return_value_gg_send_queued_data$1;
  return_value_gg_send_queued_data$1=gg_send_queued_data(sess);
  if(return_value_gg_send_queued_data$1 == -1)
    return (enum anonymous$27)GG_ACTION_FAIL;

  else
  {
    void *return_value_gg_recv_packet$2;
    return_value_gg_recv_packet$2=gg_recv_packet(sess);
    gh = (struct gg_header *)return_value_gg_recv_packet$2;
    if(gh == ((struct gg_header *)NULL))
    {
      if(sess->state == GG_STATE_DISCONNECTING)
      {
        gg_debug_session(sess, 16, "// gg_watch_fd() connection broken expectedly\n");
        e->type = GG_EVENT_DISCONNECT_ACK;
        return (enum anonymous$27)GG_ACTION_WAIT;
      }

      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      if(!(*return_value___errno_location$6 == 11))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        gg_debug_session(sess, 16, "// gg_watch_fd() gg_recv_packet failed (errno=%d, %s)\n", *return_value___errno_location$3, return_value_strerror$5);
        return (enum anonymous$27)GG_ACTION_FAIL;
      }

    }

    else
    {
      signed int return_value_gg_session_handle_packet$7;
      return_value_gg_session_handle_packet$7=gg_session_handle_packet(sess, gh->type, (const char *)gh + (signed long int)sizeof(struct gg_header) /*8ul*/ , (unsigned long int)gh->length, e);
      if(return_value_gg_session_handle_packet$7 == -1)
      {
        free((void *)gh);
        return (enum anonymous$27)GG_ACTION_FAIL;
      }

      free((void *)gh);
    }
    sess->check = 2;
    if(!(sess->send_buf == ((char *)NULL)))
      sess->check = sess->check | 1;

    return (enum anonymous$27)GG_ACTION_WAIT;
  }
}

// gg_handle_connecting
// file events.c line 745
static enum anonymous$27 gg_handle_connecting(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  signed int res;
  sess->soft_timeout = 0;
  signed int return_value_gg_async_connect_failed$2;
  return_value_gg_async_connect_failed$2=gg_async_connect_failed(sess, &res);
  if(!(return_value_gg_async_connect_failed$2 == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(res);
    gg_debug_session(sess, 16, "// gg_watch_fd() connection failed (errno=%d, %s)\n", res, return_value_strerror$1);
    gg_close(sess);
    sess->resolver_index = sess->resolver_index + 1u;
    sess->state = (signed int)alt_state;
  }

  else
  {
    if(!(sess->state == GG_STATE_CONNECTING_PROXY_HUB))
    {
      free((void *)sess->resolver_result);
      sess->resolver_result = (struct in_addr *)(void *)0;
    }

    sess->state = (signed int)next_state;
  }
  return (enum anonymous$27)GG_ACTION_NEXT;
}

// gg_handle_connecting_gg
// file events.c line 823
static enum anonymous$27 gg_handle_connecting_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  signed int res;
  sess->soft_timeout = 0;
  signed int return_value_gg_async_connect_failed$2;
  return_value_gg_async_connect_failed$2=gg_async_connect_failed(sess, &res);
  if(!(return_value_gg_async_connect_failed$2 == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(res);
    gg_debug_session(sess, 16, "// gg_watch_fd() connection failed (errno=%d, %s)\n", res, return_value_strerror$1);
    gg_close(sess);
    sess->connect_index = sess->connect_index + 1u;
    sess->state = (signed int)alt_state;
    return (enum anonymous$27)GG_ACTION_NEXT;
  }

  free((void *)sess->resolver_result);
  sess->resolver_result = (struct in_addr *)(void *)0;
  gg_debug_session(sess, 16, "// gg_watch_fd() connected\n");
  if(!((signed int)sess->ssl_flag == GG_SSL_DISABLED))
  {
    signed int return_value_gg_session_init_ssl$3;
    return_value_gg_session_init_ssl$3=gg_session_init_ssl(sess);
    if(return_value_gg_session_init_ssl$3 == -1)
    {
      e->event.failure = (enum gg_failure_t)GG_FAILURE_TLS;
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    sess->state = (signed int)alt2_state;
    sess->check = 1;
    sess->timeout = 30;
    return (enum anonymous$27)GG_ACTION_NEXT;
  }

  else
  {
    sess->state = (signed int)next_state;
    sess->check = 2;
    sess->timeout = 30;
    return (enum anonymous$27)GG_ACTION_WAIT;
  }
}

// gg_handle_error
// file events.c line 1679
static enum anonymous$27 gg_handle_error(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  struct gg_session_private *p = sess->private_data;
  gg_debug_session(sess, 16 | 128, "// gg_handle_error() failure=%d\n", p->socket_failure);
  e->event.failure = p->socket_failure;
  return (enum anonymous$27)GG_ACTION_FAIL;
}

// gg_handle_reading_hub_proxy
// file events.c line 970
static enum anonymous$27 gg_handle_reading_hub_proxy(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  char buf[1024l];
  char *tmp;
  char host[129l];
  signed int port = 8074;
  signed int reply;
  const char *body;
  struct in_addr addr;
  signed int res;
  char **host_white;
  char *host_white_default[3l] = { "gadu-gadu.pl", "gg.pl", (char *)(void *)0 };
  signed long int return_value_recv$1;
  return_value_recv$1=recv(sess->fd, (void *)buf, sizeof(char [1024l]) /*1024ul*/ , 0);
  res = (signed int)return_value_recv$1;
  signed int *return_value___errno_location$5;
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  if(res == -1)
  {
    return_value___errno_location$5=__errno_location();
    if(*return_value___errno_location$5 == 11)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value___errno_location$6=__errno_location();
      tmp_if_expr$7 = *return_value___errno_location$6 == 4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      gg_debug_session(sess, 16, "// gg_watch_fd() non-critical recv error (errno=%d, %s)\n", *return_value___errno_location$2, return_value_strerror$4);
      return (enum anonymous$27)GG_ACTION_WAIT;
    }

  }

  if(res == -1)
  {
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    char *return_value_strerror$10;
    return_value_strerror$10=strerror(*return_value___errno_location$9);
    gg_debug_session(sess, 16, "// gg_watch_fd() recv error (errno=%d, %s)\n", *return_value___errno_location$8, return_value_strerror$10);
    e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  if(!(res == 0))
  {
    void *return_value_realloc$11;
    return_value_realloc$11=realloc((void *)sess->recv_buf, (unsigned long int)(sess->recv_done + res + 1));
    tmp = (char *)return_value_realloc$11;
    if(tmp == ((char *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() not enough memory for http reply\n");
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    sess->recv_buf = tmp;
    memcpy((void *)(sess->recv_buf + (signed long int)sess->recv_done), (const void *)buf, (unsigned long int)res);
    sess->recv_done = sess->recv_done + res;
    sess->recv_buf[(signed long int)sess->recv_done] = (char)0;
  }

  signed int tmp_if_expr$14;
  if(res == 0)
  {
    if(!(sess->recv_buf == ((char *)NULL)))
      goto __CPROVER_DUMP_L7;

    gg_debug_session(sess, 16, "// gg_watch_fd() connection closed\n");
    e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if(!(res == 0))
      return (enum anonymous$27)GG_ACTION_WAIT;

    else
    {
      gg_debug_session(sess, 2, "// received http reply:\n%s", sess->recv_buf);
      res=sscanf(sess->recv_buf, "HTTP/1.%*d %3d ", &reply);
      if(!(reply == 200) || !(res == 1))
      {
        gg_debug_session(sess, 16, "// gg_watch_fd() invalid http reply, connection failed\n");
        e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
        return (enum anonymous$27)GG_ACTION_FAIL;
      }

      else
      {
        body=strstr(sess->recv_buf, "\r\n\r\n");
        if(body == ((const char *)NULL))
        {
          body=strstr(sess->recv_buf, "\n\n");
          if(body == ((const char *)NULL))
          {
            gg_debug_session(sess, 16, "// gg_watch_fd() can't find body\n");
            e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
            return (enum anonymous$27)GG_ACTION_FAIL;
          }

          else
            body = body + (signed long int)2;
        }

        else
          body = body + (signed long int)4;
        res=sscanf(body, "%d %*d %128s", &reply, (const void *)host);
        if(!(res == 2))
        {
          gg_debug_session(sess, 16, "// gg_watch_fd() invalid hub reply, connection failed\n");
          e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
          return (enum anonymous$27)GG_ACTION_FAIL;
        }

        else
        {
          gg_debug_session(sess, 16, "reply=%d, host=\"%s\"\n", reply, (const void *)host);
          if(!(reply == 0))
          {
            tmp=strchr(body, 10);
            if(!(tmp == ((char *)NULL)))
            {
              e->type = GG_EVENT_MSG;
              e->event.msg.msgclass = reply;
              e->event.msg.sender = (unsigned int)0;
              char *return_value_strdup$12;
              return_value_strdup$12=strdup(tmp + (signed long int)1);
              e->event.msg.message = (unsigned char *)return_value_strdup$12;
              if(e->event.msg.message == ((unsigned char *)NULL))
              {
                gg_debug_session(sess, 16, "// gg_watch_fd() not enough memory for system message\n");
                return (enum anonymous$27)GG_ACTION_FAIL;
              }

            }

          }

          gg_close(sess);
          tmp=strchr(host, 58);
          if(!(tmp == ((char *)NULL)))
          {
            *tmp = (char)0;
            port=atoi(tmp + (signed long int)1);
          }

          signed int return_value_strcmp$13;
          return_value_strcmp$13=strcmp(host, "notoperating");
          if(return_value_strcmp$13 == 0)
          {
            gg_debug_session(sess, 16, "// gg_watch_fd() service unavailable\n");
            e->event.failure = (enum gg_failure_t)GG_FAILURE_UNAVAILABLE;
            return (enum anonymous$27)GG_ACTION_FAIL;
          }

          else
          {
            addr.s_addr=inet_addr(host);
            if(addr.s_addr == 0xffffffff)
              addr.s_addr = (unsigned int)0;

            sess->server_addr = addr.s_addr;
            free((void *)sess->recv_buf);
            sess->recv_buf = (char *)(void *)0;
            sess->recv_done = 0;
            if(!(sess->state == GG_STATE_READING_PROXY_HUB))
            {
              if(sess->port == 0)
              {
                sess->connect_port[(signed long int)0] = (unsigned short int)port;
                sess->connect_port[(signed long int)1] = (unsigned short int)(port != 443 ? 443 : 0);
              }

              else
              {
                sess->connect_port[(signed long int)0] = (unsigned short int)sess->port;
                sess->connect_port[(signed long int)1] = (unsigned short int)0;
              }
            }

            else
            {
              if(sess->port == 0)
                tmp_if_expr$14 = 443;

              else
                tmp_if_expr$14 = sess->port;
              sess->connect_port[(signed long int)0] = (unsigned short int)tmp_if_expr$14;
              sess->connect_port[(signed long int)1] = (unsigned short int)0;
            }
            free((void *)sess->connect_host);
            sess->connect_host=strdup(host);
            if(sess->connect_host == ((char *)NULL))
            {
              gg_debug_session(sess, 16, "// gg_watch_fd() not enough memory\n");
              return (enum anonymous$27)GG_ACTION_FAIL;
            }

            else
            {
              host_white = sess->private_data->host_white_list;
              if(host_white == ((char **)NULL))
                host_white = host_white_default;

              if((signed int)sess->ssl_flag == GG_SSL_REQUIRED)
              {
                if(!(*host_white == ((char *)NULL)))
                {
                  signed int host_ok = 0;
                  char **it;
                  signed int host_len;
                  unsigned long int return_value_strlen$15;
                  return_value_strlen$15=strlen(sess->connect_host);
                  host_len = (signed int)return_value_strlen$15;
                  it = host_white;
                  for( ; !(*it == ((char *)NULL)); it = it + 1l)
                  {
                    const char *white = *it;
                    signed int white_len;
                    signed int dom_offset;
                    unsigned long int return_value_strlen$16;
                    return_value_strlen$16=strlen(white);
                    white_len = (signed int)return_value_strlen$16;
                    if(host_len >= white_len)
                    {
                      dom_offset = host_len - white_len;
                      signed int return_value_strncasecmp$17;
                      return_value_strncasecmp$17=strncasecmp(sess->connect_host + (signed long int)dom_offset, white, (unsigned long int)white_len);
                      if(return_value_strncasecmp$17 == 0)
                      {
                        if(!(white_len >= host_len))
                        {
                          if((signed int)sess->connect_host[(signed long int)(dom_offset + -1)] == 46)
                            goto __CPROVER_DUMP_L31;

                        }

                        else
                        {

                        __CPROVER_DUMP_L31:
                          ;
                          host_ok = 1;
                          break;
                        }
                      }

                    }

                  }
                  if(host_ok == 0)
                  {
                    gg_debug_session(sess, 16 | 128, "// gg_watch_fd() the HUB server returned a host that is not trusted (%s)\n", sess->connect_host);
                    e->event.failure = (enum gg_failure_t)GG_FAILURE_TLS;
                    return (enum anonymous$27)GG_ACTION_FAIL;
                  }

                }

              }

              if(sess->state == GG_STATE_READING_HUB)
                sess->resolver_host = sess->connect_host;

              sess->resolver_index = (unsigned int)0;
              sess->state = sess->async != 0 ? (signed int)next_state : (signed int)alt_state;
              return (enum anonymous$27)GG_ACTION_NEXT;
            }
          }
        }
      }
    }
  }
}

// gg_handle_reading_proxy_gg
// file events.c line 1462
static enum anonymous$27 gg_handle_reading_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  char buf[256l];
  signed int res;
  signed int reply;
  char *body;
  signed long int return_value_recv$1;
  return_value_recv$1=recv(sess->fd, (void *)buf, sizeof(char [256l]) /*256ul*/ , 0);
  res = (signed int)return_value_recv$1;
  gg_debug_session(sess, 16, "recv() = %d\n", res);
  signed int *return_value___errno_location$5;
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  if(res == -1)
  {
    return_value___errno_location$5=__errno_location();
    if(*return_value___errno_location$5 == 11)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value___errno_location$6=__errno_location();
      tmp_if_expr$7 = *return_value___errno_location$6 == 4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      gg_debug_session(sess, 16, "// gg_watch_fd() non-critical recv error (errno=%d, %s)\n", *return_value___errno_location$2, return_value_strerror$4);
      return (enum anonymous$27)GG_ACTION_WAIT;
    }

  }

  if(res == -1)
  {
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    char *return_value_strerror$10;
    return_value_strerror$10=strerror(*return_value___errno_location$9);
    gg_debug_session(sess, 16, "// gg_watch_fd() recv error (errno=%d, %s)\n", *return_value___errno_location$8, return_value_strerror$10);
    e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  if(!(res == 0))
  {
    char *tmp;
    void *return_value_realloc$11;
    return_value_realloc$11=realloc((void *)sess->recv_buf, (unsigned long int)(sess->recv_done + res + 1));
    tmp = (char *)return_value_realloc$11;
    if(tmp == ((char *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() not enough memory for http reply\n");
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    sess->recv_buf = tmp;
    memcpy((void *)(sess->recv_buf + (signed long int)sess->recv_done), (const void *)buf, (unsigned long int)res);
    sess->recv_done = sess->recv_done + res;
    sess->recv_buf[(signed long int)sess->recv_done] = (char)0;
  }

  if(res == 0)
  {
    if(!(sess->recv_buf == ((char *)NULL)))
      goto __CPROVER_DUMP_L7;

    gg_debug_session(sess, 16, "// gg_watch_fd() connection closed\n");
    e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    body=strstr(sess->recv_buf, "\r\n\r\n");
    if(body == ((char *)NULL))
    {
      body=strstr(sess->recv_buf, "\n\n");
      if(body == ((char *)NULL))
      {
        gg_debug_session(sess, 16, "// gg_watch_fd() can't find body\n");
        e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
        return (enum anonymous$27)GG_ACTION_FAIL;
      }

      else
        body = body + (signed long int)2;
    }

    else
      body = body + (signed long int)4;
    gg_debug_session(sess, 16, "// found body!\n");
    gg_debug_session(sess, 2, "// received proxy reply:\n%s\n", sess->recv_buf);
    res=sscanf(sess->recv_buf, "HTTP/1.%*d %3d ", &reply);
    gg_debug_session(sess, 16, "res = %d, reply = %d\n", res, reply);
    if(!(reply == 200) || !(res == 1))
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() invalid http reply, connection failed\n");
      e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    else
    {
      if(!((signed int)sess->ssl_flag == GG_SSL_DISABLED))
      {
        signed int return_value_gg_session_init_ssl$12;
        return_value_gg_session_init_ssl$12=gg_session_init_ssl(sess);
        if(return_value_gg_session_init_ssl$12 == -1)
        {
          e->event.failure = (enum gg_failure_t)GG_FAILURE_TLS;
          return (enum anonymous$27)GG_ACTION_FAIL;
        }

        if(!(body >= sess->recv_buf + (signed long int)sess->recv_done))
        {
          gg_debug_session(sess, 16, "// gg_watch_fd() unexpected SSL data\n");
          e->event.failure = (enum gg_failure_t)GG_FAILURE_TLS;
          return (enum anonymous$27)GG_ACTION_FAIL;
        }

        free((void *)sess->recv_buf);
        sess->recv_buf = (char *)(void *)0;
        sess->recv_done = 0;
        sess->state = (signed int)alt_state;
        sess->check = 1;
        sess->timeout = 30;
        return (enum anonymous$27)GG_ACTION_WAIT;
      }

      sess->state = (signed int)next_state;
      sess->check = 2;
      sess->timeout = 30;
      if(!(body >= sess->recv_buf + (signed long int)sess->recv_done))
      {
        sess->recv_done = (signed int)((signed long int)sess->recv_done - (body - sess->recv_buf));
        memmove((void *)sess->recv_buf, (const void *)body, (unsigned long int)sess->recv_done);
        sess->state = (signed int)alt2_state;
        return (enum anonymous$27)GG_ACTION_NEXT;
      }

      else
      {
        free((void *)sess->recv_buf);
        sess->recv_buf = (char *)(void *)0;
        sess->recv_done = 0;
      }
      return (enum anonymous$27)GG_ACTION_WAIT;
    }
  }
}

// gg_handle_recv_msg_options
// file handlers.c line 862
static signed int gg_handle_recv_msg_options(struct gg_session *sess, struct gg_event *e, unsigned int sender, const char *p, const char *packet_end, unsigned int packet_type)
{
  struct gg_msg_recipients *m;
  unsigned int gg_handle_recv_msg_options$$1$$1$$1$$1$$i;
  unsigned int count;
  void *return_value_malloc$1;
  unsigned short int len;
  char *buf;
  void *return_value_malloc$2;
  struct gg_msg_image_request *i;
  _Bool tmp_if_expr$3;
  struct gg_msg_image_reply *rep;
  _Bool tmp_if_expr$4;
  while(!(p >= packet_end))
    switch((signed int)*p)
    {
      case 0x01:
      {
        m = (struct gg_msg_recipients *)(const void *)p;
        p = p + (signed long int)sizeof(struct gg_msg_recipients) /*5ul*/ ;
        if(!(packet_end >= p))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() packet out of bounds (1)\n");
          goto malformed;
        }

        count=gg_fix32(m->count);
        if(count >= 65536u || !(p + (signed long int)sizeof(unsigned int) /*4l*/  * (signed long int)(unsigned long int)count >= p) || !(packet_end >= p + (signed long int)sizeof(unsigned int) /*4l*/  * (signed long int)(unsigned long int)count))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() packet out of bounds (1.5)\n");
          goto malformed;
        }

        if(!(e->event.msg.recipients == ((unsigned int *)NULL)))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() e->event.msg.recipients already exist\n");
          goto malformed;
        }

        return_value_malloc$1=malloc((unsigned long int)count * sizeof(unsigned int) /*4ul*/ );
        e->event.msg.recipients = (unsigned int *)return_value_malloc$1;
        if(e->event.msg.recipients == ((unsigned int *)NULL))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() not enough memory for recipients data\n");
          goto fail;
        }

        memcpy((void *)e->event.msg.recipients, (const void *)p, (unsigned long int)count * sizeof(unsigned int) /*4ul*/ );
        p = p + (signed long int)((unsigned long int)count * sizeof(unsigned int) /*4ul*/ );
        gg_handle_recv_msg_options$$1$$1$$1$$1$$i = (unsigned int)0;
        for( ; !(gg_handle_recv_msg_options$$1$$1$$1$$1$$i >= count); gg_handle_recv_msg_options$$1$$1$$1$$1$$i = gg_handle_recv_msg_options$$1$$1$$1$$1$$i + 1u)
          e->event.msg.recipients[(signed long int)gg_handle_recv_msg_options$$1$$1$$1$$1$$i]=gg_fix32(e->event.msg.recipients[(signed long int)gg_handle_recv_msg_options$$1$$1$$1$$1$$i]);
        e->event.msg.recipients_count = (signed int)count;
        break;
      }
      case 0x02:
      {
        if(!(packet_end >= p + 3l))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() packet out of bounds (2)\n");
          goto malformed;
        }

        memcpy((void *)&len, (const void *)(p + (signed long int)1), sizeof(unsigned short int) /*2ul*/ );
        len=gg_fix16(len);
        if(!(e->event.msg.formats == NULL))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() e->event.msg.formats already exist\n");
          goto malformed;
        }

        return_value_malloc$2=malloc((unsigned long int)len);
        buf = (char *)return_value_malloc$2;
        if(buf == ((char *)NULL))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() not enough memory for richtext data\n");
          goto fail;
        }

        p = p + (signed long int)3;
        if(!(packet_end >= p + (signed long int)len))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() packet out of bounds (3)\n");
          free((void *)buf);
          goto malformed;
        }

        memcpy((void *)buf, (const void *)p, (unsigned long int)len);
        e->event.msg.formats = (void *)buf;
        e->event.msg.formats_length = (signed int)len;
        p = p + (signed long int)len;
        break;
      }
      case 0x04:
      {
        i = (struct gg_msg_image_request *)(const void *)p;
        if(!(packet_end >= p + (signed long int)sizeof(struct gg_msg_image_request) /*9l*/ ))
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg() packet out of bounds (3)\n");
          goto malformed;
        }

        if(!(e->event.msg.formats == NULL))
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = e->event.msg.recipients != (unsigned int *)(void *)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() mixed options (1)\n");
          goto malformed;
        }

        e->event.image_request.sender = sender;
        e->event.image_request.size=gg_fix32(i->size);
        e->event.image_request.crc32=gg_fix32(i->crc32);
        e->type = GG_EVENT_IMAGE_REQUEST;
        goto handled;
      }
      case 0x05:

      case 0x06:
      {
        rep = (struct gg_msg_image_reply *)(void *)p;
        if(!(e->event.msg.formats == NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = e->event.msg.recipients != (unsigned int *)(void *)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
        {
          gg_debug_session(sess, 16, "// gg_handle_recv_msg_options() mixed options (2)\n");
          goto malformed;
        }

        if(p + (signed long int)sizeof(struct gg_msg_image_reply) /*9l*/  == packet_end)
        {
          e->type = GG_EVENT_IMAGE_REPLY;
          e->event.image_reply.sender = sender;
          e->event.image_reply.size = (unsigned int)0;
          e->event.image_reply.crc32=gg_fix32(rep->crc32);
          e->event.image_reply.filename = (char *)(void *)0;
          e->event.image_reply.image = (char *)(void *)0;
          goto handled;
        }

        else
          if(!(packet_end >= p + (signed long int)(sizeof(struct gg_msg_image_reply) + 1) /*10l*/ ))
          {
            gg_debug_session(sess, 16, "// gg_handle_recv_msg() packet out of bounds (4)\n");
            goto malformed;
          }

        rep->size=gg_fix32(rep->size);
        rep->crc32=gg_fix32(rep->crc32);
        gg_image_queue_parse(e, p, (unsigned int)(packet_end - p), sess, sender, packet_type);
        goto handled;
      }
      default:
      {
        gg_debug_session(sess, 16, "// gg_handle_recv_msg() unknown payload 0x%.2x\n", *p);
        p = packet_end;
      }
    }
  return 0;

handled:
  ;
  return -1;

fail:
  ;
  return -2;

malformed:
  ;
  return -3;
}

// gg_handle_resolve_async
// file events.c line 556
static enum anonymous$27 gg_handle_resolve_async(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  signed int res;
  res=gg_handle_resolve_custom(sess, alt_state);
  if(res == 1)
    return (enum anonymous$27)GG_ACTION_WAIT;

  else
    if(res == -1)
      return (enum anonymous$27)GG_ACTION_FAIL;

  signed int return_value;
  return_value=sess->resolver_start(&sess->fd, &sess->resolver, sess->resolver_host);
  if(return_value == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    gg_debug_session(sess, 16, "// gg_watch_fd() resolving failed (errno=%d, %s)\n", *return_value___errno_location$1, return_value_strerror$3);
    e->event.failure = (enum gg_failure_t)GG_FAILURE_RESOLVING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  sess->state = (signed int)next_state;
  sess->check = 2;
  sess->timeout = 30;
  return (enum anonymous$27)GG_ACTION_WAIT;
}

// gg_handle_resolve_custom
// file events.c line 437
static signed int gg_handle_resolve_custom(struct gg_session *sess, enum gg_state_t next_state)
{
  struct gg_session_private *p = sess->private_data;
  signed int is_tls = 0;
  signed int port;
  if((signed int)p->socket_manager_type == GG_SOCKET_MANAGER_TYPE_INTERNAL)
    return 0;

  else
    if(p->socket_manager.connect_cb == ((void * (*)(void *, const char *, signed int, signed int, signed int, void *))NULL))
    {
      gg_debug_session(sess, 16 | 128, "// gg_handle_resolve_custom() socket_manager.connect callback is empty\n");
      return -1;
    }

    else
      if(!(p->socket_handle == NULL))
      {
        gg_debug_session(sess, 16 | 128, "// gg_handle_resolve_custom() socket_handle is not NULL\n");
        return -1;
      }

      else
      {
        port = (signed int)sess->connect_port[(signed long int)sess->connect_index];
        if((signed int)next_state == GG_STATE_SEND_HUB)
          port = 80;

        if(!((signed int)sess->ssl_flag == GG_SSL_DISABLED))
        {
          if((signed int)next_state == GG_STATE_READING_KEY)
            is_tls = 1;

        }

        if(!(is_tls == 0))
        {
          if((signed int)p->socket_manager_type == GG_SOCKET_MANAGER_TYPE_TCP)
          {
            is_tls = 0;
            next_state = (enum gg_state_t)GG_STATE_TLS_NEGOTIATION;
          }

        }

        if(!(port >= 1))
        {
          gg_debug_session(sess, 16 | 128, "// gg_handle_resolve_custom() port <= 0\n");
          return -1;
        }

        else
        {
          p->socket_failure = (enum gg_failure_t)0;
          p->socket_next_state = (signed int)next_state;
          p->socket_handle=p->socket_manager.connect_cb(p->socket_manager.cb_data, sess->resolver_host, port, is_tls, sess->async, (void *)sess);
          if(!((signed int)p->socket_failure == 0))
          {
            if(!(p->socket_handle == NULL))
              gg_debug_session(sess, 16 | 64, "// gg_handle_resolve_custom() handle should be empty on error\n");

            return -1;
          }

          else
            if(p->socket_handle == NULL)
            {
              gg_debug_session(sess, 16 | 128, "// gg_handle_resolve_custom() returned empty handle\n");
              return -1;
            }

            else
              return 1;
        }
      }
}

// gg_handle_resolve_sync
// file events.c line 508
static enum anonymous$27 gg_handle_resolve_sync(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  struct in_addr addr;
  signed int res;
  res=gg_handle_resolve_custom(sess, alt_state);
  if(res == 1)
    return (enum anonymous$27)GG_ACTION_NEXT;

  else
    if(res == -1)
      return (enum anonymous$27)GG_ACTION_FAIL;

  addr.s_addr=inet_addr(sess->resolver_host);
  if(addr.s_addr == 0xffffffff)
  {
    struct in_addr *addr_list = (struct in_addr *)(void *)0;
    unsigned int addr_count;
    signed int return_value_gg_gethostbyname_real$1;
    return_value_gg_gethostbyname_real$1=gg_gethostbyname_real(sess->resolver_host, &addr_list, &addr_count, 0);
    if(return_value_gg_gethostbyname_real$1 == -1)
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() host %s not found\n", sess->resolver_host);
      e->event.failure = (enum gg_failure_t)GG_FAILURE_RESOLVING;
      free((void *)addr_list);
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    sess->resolver_result = addr_list;
    sess->resolver_count = addr_count;
    sess->resolver_index = (unsigned int)0;
  }

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct in_addr) /*4ul*/ );
    sess->resolver_result = (struct in_addr *)return_value_malloc$2;
    if(sess->resolver_result == ((struct in_addr *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() out of memory\n");
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    (sess->resolver_result + (signed long int)0)->s_addr = addr.s_addr;
    sess->resolver_count = (unsigned int)1;
    sess->resolver_index = (unsigned int)0;
  }
  sess->state = (signed int)next_state;
  return (enum anonymous$27)GG_ACTION_NEXT;
}

// gg_handle_resolving
// file events.c line 583
static enum anonymous$27 gg_handle_resolving(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  char buf[256l];
  signed int count = -1;
  signed int res;
  unsigned int i;
  struct in_addr *addrs;
  res=gg_resolver_recv(sess->fd, (void *)buf, sizeof(char [256l]) /*256ul*/ );
  signed int *return_value___errno_location$4;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  if(res == -1)
  {
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 11)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value___errno_location$5=__errno_location();
      tmp_if_expr$6 = *return_value___errno_location$5 == 4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      gg_debug_session(sess, 16, "// gg_watch_fd() non-critical error (errno=%d, %s)\n", *return_value___errno_location$1, return_value_strerror$3);
      return (enum anonymous$27)GG_ACTION_WAIT;
    }

  }

  sess->resolver_cleanup(&sess->resolver, 0);
  if(res == -1)
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    char *return_value_strerror$9;
    return_value_strerror$9=strerror(*return_value___errno_location$8);
    gg_debug_session(sess, 16, "// gg_watch_fd() read error (errno=%d, %s)\n", *return_value___errno_location$7, return_value_strerror$9);
    e->event.failure = (enum gg_failure_t)GG_FAILURE_RESOLVING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  if(res >= 1)
  {
    char *tmp;
    void *return_value_realloc$10;
    return_value_realloc$10=realloc((void *)sess->recv_buf, (unsigned long int)(sess->recv_done + res));
    tmp = (char *)return_value_realloc$10;
    if(tmp == ((char *)NULL))
      return (enum anonymous$27)GG_ACTION_FAIL;

    sess->recv_buf = tmp;
    memcpy((void *)(sess->recv_buf + (signed long int)sess->recv_done), (const void *)buf, (unsigned long int)res);
    sess->recv_done = sess->recv_done + res;
  }

  addrs = (struct in_addr *)(void *)sess->recv_buf;
  i = (unsigned int)0;
  if(!((unsigned long int)i >= (unsigned long int)sess->recv_done / sizeof(struct in_addr) /*4ul*/ ))
  {
    if((addrs + (signed long int)i)->s_addr == 0xffffffff)
      count = (signed int)i;

    else
      i = i + 1u;
  }

  if(count == 0)
  {
    gg_debug_session(sess, 16, "// gg_watch_fd() host not found\n");
    e->event.failure = (enum gg_failure_t)GG_FAILURE_RESOLVING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
    if(count == -1 && res == 0)
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() connection broken\n");
      e->event.failure = (enum gg_failure_t)GG_FAILURE_RESOLVING;
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    else
      if(count == -1)
        return (enum anonymous$27)GG_ACTION_WAIT;

      else
      {
        if(count >= 1 && !((4 & gg_debug_level) == 0))
        {
          char *list;
          unsigned long int len = (unsigned long int)0;
          i = (unsigned int)0;
          if(!(i >= (unsigned int)count))
          {
            if(i >= 1u)
              len = len + (unsigned long int)2;

            char *return_value_inet_ntoa$11;
            return_value_inet_ntoa$11=inet_ntoa(addrs[(signed long int)i]);
            unsigned long int return_value_strlen$12;
            return_value_strlen$12=strlen(return_value_inet_ntoa$11);
            len = len + return_value_strlen$12;
            i = i + 1u;
          }

          void *return_value_malloc$13;
          return_value_malloc$13=malloc(len + (unsigned long int)1);
          list = (char *)return_value_malloc$13;
          if(list == ((char *)NULL))
            return (enum anonymous$27)GG_ACTION_FAIL;

          list[(signed long int)0] = (char)0;
          i = (unsigned int)0;
          if(!(i >= (unsigned int)count))
          {
            if(i >= 1u)
              strcat(list, ", ");

            char *return_value_inet_ntoa$14;
            return_value_inet_ntoa$14=inet_ntoa(addrs[(signed long int)i]);
            strcat(list, return_value_inet_ntoa$14);
            i = i + 1u;
          }

          gg_debug_session(sess, 4, "// gg_watch_fd() resolved: %s\n", list);
          free((void *)list);
        }

        gg_close(sess);
        sess->state = (signed int)next_state;
        sess->resolver_result = addrs;
        sess->resolver_count = (unsigned int)count;
        sess->resolver_index = (unsigned int)0;
        sess->recv_buf = (char *)(void *)0;
        sess->recv_done = 0;
        return (enum anonymous$27)GG_ACTION_NEXT;
      }
}

// gg_handle_send_hub
// file events.c line 867
static enum anonymous$27 gg_handle_send_hub(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  char *req;
  char *client;
  char *auth;
  const char *host;
  signed int res;
  signed int proxy;
  unsigned long int req_len;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  if(!(sess->client_version == ((char *)NULL)))
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    tmp_if_expr$2 = ((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)sess->client_version[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    client=gg_urlencode(sess->client_version);

  else
    if(!(sess->protocol_version >= 47))
      client=gg_urlencode("10.1.0.11070");

    else
      client=gg_urlencode("11.3.45.10771");
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$5;
  if(client == ((char *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_watch_fd() out of memory for client version\n");
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
  {
    if(!(sess->proxy_addr == 0u))
      tmp_if_expr$3 = sess->proxy_port != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      host = "http://appmsg.gadu-gadu.pl";
      proxy = 1;
    }

    else
    {
      host = "";
      proxy = 0;
    }
    auth=gg_proxy_auth();
    if(!((signed int)sess->ssl_flag == GG_SSL_DISABLED))
      req=gg_saprintf("GET %s/appsvc/appmsg_ver10.asp?fmnumber=%u&fmt=2&lastmsg=%d&version=%s&age=2&gender=1 HTTP/1.0\r\nConnection: close\r\nHost: appmsg.gadu-gadu.pl\r\n%s\r\n", host, sess->uin, sess->last_sysmsg, client, auth != ((char *)NULL) ? auth : "");

    else
      req=gg_saprintf("GET %s/appsvc/appmsg_ver8.asp?fmnumber=%u&fmt=2&lastmsg=%d&version=%s HTTP/1.0\r\nHost: appmsg.gadu-gadu.pl\r\n%s\r\n", host, sess->uin, sess->last_sysmsg, client, auth != ((char *)NULL) ? auth : "");
    free((void *)auth);
    free((void *)client);
    if(req == ((char *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() out of memory\n");
      e->event.failure = (enum gg_failure_t)GG_FAILURE_PROXY;
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    else
    {
      req_len=strlen(req);
      gg_debug_session(sess, 2, "// sending http query:\n%s", req);
      signed long int return_value_send$4;
      return_value_send$4=send(sess->fd, (const void *)req, req_len, 0);
      res = (signed int)return_value_send$4;
      free((void *)req);
      if(res == -1)
      {
        return_value___errno_location$6=__errno_location();
        if(*return_value___errno_location$6 == 4)
          goto __CPROVER_DUMP_L14;

        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 11)
          goto __CPROVER_DUMP_L14;

        gg_debug_session(sess, 16, "// gg_watch_fd() sending query failed\n");
        e->event.failure = (enum gg_failure_t)(!(proxy != 0) ? GG_FAILURE_HUB : GG_FAILURE_PROXY);
        return (enum anonymous$27)GG_ACTION_FAIL;
      }

      else
      {

      __CPROVER_DUMP_L14:
        ;
        if(!((unsigned long int)res >= req_len))
        {
          sess->state = (signed int)alt_state;
          sess->check = 1;
          sess->timeout = 30;
        }

        else
        {
          sess->state = (signed int)next_state;
          sess->check = 2;
          sess->timeout = 30;
        }
        return (enum anonymous$27)GG_ACTION_WAIT;
      }
    }
  }
}

// gg_handle_send_proxy_gg
// file events.c line 1182
static enum anonymous$27 gg_handle_send_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  char *req;
  char *auth;
  unsigned long int req_len;
  signed int res;
  const char *return_value_gg_debug_state$1;
  return_value_gg_debug_state$1=gg_debug_state((enum gg_state_t)sess->state);
  gg_debug_session(sess, 16, "// gg_watch_fd() %s\n", return_value_gg_debug_state$1);
  _Bool tmp_if_expr$2;
  if(sess->connect_index >= 2u)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)sess->connect_port[(signed long int)sess->connect_index] == 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$5;
  signed int *return_value___errno_location$4;
  if(tmp_if_expr$2)
  {
    gg_debug_session(sess, 16, "// gg_watch_fd() out of connection candidates\n");
    e->event.failure = (enum gg_failure_t)GG_FAILURE_CONNECTING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
  {
    auth=gg_proxy_auth();
    req=gg_saprintf("CONNECT %s:%d HTTP/1.0\r\n%s\r\n", sess->connect_host, sess->connect_port[(signed long int)sess->connect_index], auth != ((char *)NULL) ? auth : "");
    free((void *)auth);
    sess->connect_index = sess->connect_index + 1u;
    if(req == ((char *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() out of memory\n");
      e->event.failure = (enum gg_failure_t)GG_FAILURE_PROXY;
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

    else
    {
      req_len=strlen(req);
      gg_debug_session(sess, 16, "// gg_watch_fd() proxy request:\n%s", req);
      signed long int return_value_send$3;
      return_value_send$3=send(sess->fd, (const void *)req, req_len, 0);
      res = (signed int)return_value_send$3;
      free((void *)req);
      if(res == -1)
      {
        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 4)
          goto __CPROVER_DUMP_L5;

        return_value___errno_location$4=__errno_location();
        if(*return_value___errno_location$4 == 11)
          goto __CPROVER_DUMP_L5;

        gg_debug_session(sess, 16, "// gg_watch_fd() sending query failed\n");
        e->event.failure = (enum gg_failure_t)GG_FAILURE_PROXY;
        return (enum anonymous$27)GG_ACTION_FAIL;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(!((unsigned long int)res >= req_len))
        {
          sess->state = (signed int)alt_state;
          sess->check = 1;
          sess->timeout = 30;
        }

        else
        {
          sess->state = (signed int)next_state;
          sess->check = 2;
          sess->timeout = 30;
        }
        return (enum anonymous$27)GG_ACTION_WAIT;
      }
    }
  }
}

// gg_handle_sending_hub_proxy
// file events.c line 951
static enum anonymous$27 gg_handle_sending_hub_proxy(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  signed int return_value_gg_send_queued_data$1;
  return_value_gg_send_queued_data$1=gg_send_queued_data(sess);
  if(return_value_gg_send_queued_data$1 == -1)
  {
    e->event.failure = (enum gg_failure_t)GG_FAILURE_WRITING;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
    if(sess->send_left >= 1)
      return (enum anonymous$27)GG_ACTION_WAIT;

    else
    {
      sess->state = (signed int)next_state;
      sess->check = 2;
      sess->timeout = 30;
      return (enum anonymous$27)GG_ACTION_WAIT;
    }
}

// gg_handle_tls_negotiation
// file events.c line 1241
static enum anonymous$27 gg_handle_tls_negotiation(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)
{
  signed int valid_hostname = 0;
  unsigned int status;
  signed int res;
  gg_debug_session(sess, 16, "// gg_watch_fd() GG_STATE_TLS_NEGOTIATION\n");
  do
  {
    res=gnutls_handshake(((struct anonymous$34 *)sess->ssl)->session);
    if(res == -28)
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() TLS handshake GNUTLS_E_AGAIN\n");
      signed int return_value_gnutls_record_get_direction$1;
      return_value_gnutls_record_get_direction$1=gnutls_record_get_direction(((struct anonymous$34 *)sess->ssl)->session);
      if(return_value_gnutls_record_get_direction$1 == 0)
        sess->check = 2;

      else
        sess->check = 1;
      sess->timeout = 30;
      return (enum anonymous$27)GG_ACTION_WAIT;
    }

    if(res == -52)
      gg_debug_session(sess, 16, "// gg_watch_fd() TLS handshake GNUTLS_E_INTERRUPTED\n");

    else
    {
      if(!(res == 0))
      {
        const char *return_value_gnutls_strerror$2;
        return_value_gnutls_strerror$2=gnutls_strerror(res);
        gg_debug_session(sess, 16, "// gg_watch_fd() TLS handshake error: %d, %s\n", res, return_value_gnutls_strerror$2);
        e->event.failure = (enum gg_failure_t)GG_FAILURE_TLS;
        return (enum anonymous$27)GG_ACTION_FAIL;
      }

      break;
    }
  }
  while((_Bool)1);
  gg_debug_session(sess, 16, "// gg_watch_fd() TLS negotiation succeded:\n");
  enum anonymous$29 return_value_gnutls_protocol_get_version$3;
  return_value_gnutls_protocol_get_version$3=gnutls_protocol_get_version(((struct anonymous$34 *)sess->ssl)->session);
  const char *return_value_gnutls_protocol_get_name$4;
  return_value_gnutls_protocol_get_name$4=gnutls_protocol_get_name(return_value_gnutls_protocol_get_version$3);
  enum gnutls_cipher_algorithm return_value_gnutls_cipher_get$5;
  return_value_gnutls_cipher_get$5=gnutls_cipher_get(((struct anonymous$34 *)sess->ssl)->session);
  const char *return_value_gnutls_cipher_get_name$6;
  return_value_gnutls_cipher_get_name$6=gnutls_cipher_get_name(return_value_gnutls_cipher_get$5);
  enum anonymous$30 return_value_gnutls_kx_get$7;
  return_value_gnutls_kx_get$7=gnutls_kx_get(((struct anonymous$34 *)sess->ssl)->session);
  const char *return_value_gnutls_kx_get_name$8;
  return_value_gnutls_kx_get_name$8=gnutls_kx_get_name(return_value_gnutls_kx_get$7);
  enum anonymous$31 return_value_gnutls_mac_get$9;
  return_value_gnutls_mac_get$9=gnutls_mac_get(((struct anonymous$34 *)sess->ssl)->session);
  const char *return_value_gnutls_mac_get_name$10;
  return_value_gnutls_mac_get_name$10=gnutls_mac_get_name(return_value_gnutls_mac_get$9);
  enum anonymous$32 return_value_gnutls_compression_get$11;
  return_value_gnutls_compression_get$11=gnutls_compression_get(((struct anonymous$34 *)sess->ssl)->session);
  const char *return_value_gnutls_compression_get_name$12;
  return_value_gnutls_compression_get_name$12=gnutls_compression_get_name(return_value_gnutls_compression_get$11);
  gg_debug_session(sess, 16, "//   cipher: VERS-%s:%s:%s:%s:COMP-%s\n", return_value_gnutls_protocol_get_name$4, return_value_gnutls_cipher_get_name$6, return_value_gnutls_kx_get_name$8, return_value_gnutls_mac_get_name$10, return_value_gnutls_compression_get_name$12);
  enum anonymous$33 return_value_gnutls_certificate_type_get$16;
  return_value_gnutls_certificate_type_get$16=gnutls_certificate_type_get(((struct anonymous$34 *)sess->ssl)->session);
  if((signed int)return_value_gnutls_certificate_type_get$16 == GNUTLS_CRT_X509)
  {
    unsigned int peer_count;
    const struct anonymous$28 *peers;
    struct gnutls_x509_crt_int *cert;
    signed int return_value_gnutls_x509_crt_init$15;
    return_value_gnutls_x509_crt_init$15=gnutls_x509_crt_init(&cert);
    if(return_value_gnutls_x509_crt_init$15 == 0)
    {
      peers=gnutls_certificate_get_peers(((struct anonymous$34 *)sess->ssl)->session, &peer_count);
      if(!(peers == ((const struct anonymous$28 *)NULL)))
      {
        char buf[256l];
        unsigned long int size;
        signed int return_value_gnutls_x509_crt_import$14;
        return_value_gnutls_x509_crt_import$14=gnutls_x509_crt_import(cert, &peers[(signed long int)0], (enum anonymous$2)GNUTLS_X509_FMT_DER);
        if(return_value_gnutls_x509_crt_import$14 == 0)
        {
          size = sizeof(char [256l]) /*256ul*/ ;
          gnutls_x509_crt_get_dn(cert, buf, &size);
          gg_debug_session(sess, 16, "//   cert subject: %s\n", (const void *)buf);
          size = sizeof(char [256l]) /*256ul*/ ;
          gnutls_x509_crt_get_issuer_dn(cert, buf, &size);
          gg_debug_session(sess, 16, "//   cert issuer: %s\n", (const void *)buf);
          signed int return_value_gnutls_x509_crt_check_hostname$13;
          return_value_gnutls_x509_crt_check_hostname$13=gnutls_x509_crt_check_hostname(cert, sess->connect_host);
          if(!(return_value_gnutls_x509_crt_check_hostname$13 == 0))
            valid_hostname = 1;

        }

      }

      gnutls_x509_crt_deinit(cert);
    }

  }

  res=gnutls_certificate_verify_peers2(((struct anonymous$34 *)sess->ssl)->session, &status);
  if(!(res == 0) || !(status == 0u))
  {
    const char *return_value_gnutls_strerror$17;
    return_value_gnutls_strerror$17=gnutls_strerror(res);
    gg_debug_session(sess, 16, "// WARNING!  unable to verify peer certificate: 0x%x, %d, %s\n", status, res, return_value_gnutls_strerror$17);
    if((signed int)sess->ssl_flag == GG_SSL_REQUIRED)
    {
      e->event.failure = (enum gg_failure_t)GG_FAILURE_TLS;
      return (enum anonymous$27)GG_ACTION_FAIL;
    }

  }

  else
    gg_debug_session(sess, 16, "//   verified peer certificate\n");
  if(valid_hostname == 0)
  {
    gg_debug_session(sess, 16, "// WARNING!  unable to verify hostname\n");
    if(!((signed int)sess->ssl_flag == GG_SSL_REQUIRED))
      goto __CPROVER_DUMP_L17;

    e->event.failure = (enum gg_failure_t)GG_FAILURE_TLS;
    return (enum anonymous$27)GG_ACTION_FAIL;
  }

  else
  {

  __CPROVER_DUMP_L17:
    ;
    sess->state = (signed int)next_state;
    sess->check = 2;
    sess->timeout = 30;
    return (enum anonymous$27)GG_ACTION_WAIT;
  }
}

// gg_http_connect
// file http.c line 66
struct gg_http * gg_http_connect(const char *hostname, signed int port, signed int async, const char *method, const char *path, const char *header)
{
  struct gg_http *h;
  if(header == ((const char *)NULL) || hostname == ((const char *)NULL) || method == ((const char *)NULL) || path == ((const char *)NULL) || port == 0)
  {
    gg_debug(16, "// gg_http_connect() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (struct gg_http *)(void *)0;
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct gg_http) /*152ul*/ );
  h = (struct gg_http *)return_value_malloc$2;
  if(h == ((struct gg_http *)NULL))
    return (struct gg_http *)(void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct gg_http) /*152ul*/ );
    h->async = async;
    h->port = port;
    h->fd = -1;
    h->type = 2;
    gg_http_set_resolver(h, (enum anonymous$4)GG_RESOLVER_DEFAULT);
    if(!(gg_proxy_enabled == 0))
    {
      char *auth;
      auth=gg_proxy_auth();
      h->query=gg_saprintf("%s http://%s:%d%s HTTP/1.0\r\n%s%s", method, hostname, port, path, auth != ((char *)NULL) ? auth : "", header);
      hostname = gg_proxy_host;
      port = gg_proxy_port;
      h->port = port;
      free((void *)auth);
    }

    else
      h->query=gg_saprintf("%s %s HTTP/1.0\r\n%s", method, path, header);
    if(h->query == ((char *)NULL))
    {
      gg_debug(16, "// gg_http_connect() not enough memory for query\n");
      free((void *)h);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 12;
      return (struct gg_http *)(void *)0;
    }

    gg_debug(16, "=> -----BEGIN-HTTP-QUERY-----\n%s\n=> -----END-HTTP-QUERY-----\n", h->query);
    if(!(async == 0))
    {
      signed int return_value;
      return_value=h->resolver_start(&h->fd, &h->resolver, hostname);
      if(return_value == -1)
      {
        gg_debug(16, "// gg_http_connect() resolver failed\n");
        gg_http_free(h);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 2;
        return (struct gg_http *)(void *)0;
      }

      gg_debug(16, "// gg_http_connect() resolver = %p\n", h->resolver);
      h->state = GG_STATE_RESOLVING;
      h->check = 2;
      h->timeout = 30;
    }

    else
    {
      struct in_addr *addr_list = (struct in_addr *)(void *)0;
      unsigned int addr_count;
      signed int return_value_gg_gethostbyname_real$6;
      return_value_gg_gethostbyname_real$6=gg_gethostbyname_real(hostname, &addr_list, &addr_count, 0);
      if(return_value_gg_gethostbyname_real$6 == -1 || addr_count == 0u)
      {
        gg_debug(16, "// gg_http_connect() host not found\n");
        gg_http_free(h);
        free((void *)addr_list);
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        *return_value___errno_location$5 = 2;
        return (struct gg_http *)(void *)0;
      }

      h->fd=gg_connect((void *)&addr_list[(signed long int)0], port, 0);
      if(h->fd == -1)
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        char *return_value_strerror$9;
        return_value_strerror$9=strerror(*return_value___errno_location$8);
        gg_debug(16, "// gg_http_connect() connection failed (errno=%d, %s)\n", *return_value___errno_location$7, return_value_strerror$9);
        gg_http_free(h);
        free((void *)addr_list);
        return (struct gg_http *)(void *)0;
      }

      free((void *)addr_list);
      h->state = GG_STATE_CONNECTING;
      while(!(h->state == GG_STATE_ERROR))
      {
        if(h->state == GG_STATE_PARSING)
          break;

        signed int return_value_gg_http_watch_fd$10;
        return_value_gg_http_watch_fd$10=gg_http_watch_fd(h);
        if(return_value_gg_http_watch_fd$10 == -1)
          break;

      }
      if(!(h->state == GG_STATE_PARSING))
      {
        gg_debug(16, "// gg_http_connect() some strange error\n");
        gg_http_free(h);
        return (struct gg_http *)(void *)0;
      }

    }
    h->callback = gg_http_watch_fd;
    h->destroy = gg_http_free;
    return h;
  }
}

// gg_http_free
// file http.c line 582
void gg_http_free(struct gg_http *h)
{
  if(!(h == ((struct gg_http *)NULL)))
  {
    gg_http_stop(h);
    gg_http_free_fields(h);
    free((void *)h);
  }

}

// gg_http_free_fields
// file http.c line 558
void gg_http_free_fields(struct gg_http *h)
{
  if(!(h == ((struct gg_http *)NULL)))
  {
    free((void *)h->body);
    h->body = (char *)(void *)0;
    free((void *)h->query);
    h->query = (char *)(void *)0;
    free((void *)h->header);
    h->header = (char *)(void *)0;
  }

}

// gg_http_get_resolver
// file resolver.c line 999
enum anonymous$4 gg_http_get_resolver(struct gg_http *gh)
{
  if(gh == ((struct gg_http *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (enum anonymous$4)GG_RESOLVER_INVALID;
  }

  return gh->resolver_type;
}

// gg_http_hash
// file common.c line 406
signed int gg_http_hash(const char *format, ...)
{
  unsigned int a;
  unsigned int c;
  unsigned int i;
  unsigned int j;
  __builtin_va_list ap;
  signed int b = -1;
  va_start(ap, format);
  j = (unsigned int)0;
  unsigned long int return_value_strlen$1;
  unsigned int tmp_post$3;
  do
  {
    return_value_strlen$1=strlen(format);
    if((unsigned long int)j >= return_value_strlen$1)
      break;

    const char *arg;
    char buf[16l];
    if((signed int)format[(signed long int)j] == 117)
    {
      unsigned int return_value_gcc_builtin_va_arg$2;
      return_value_gcc_builtin_va_arg$2=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg$2));
      snprintf(buf, sizeof(char [16l]) /*16ul*/ , "%d", return_value_gcc_builtin_va_arg$2);
      arg = buf;
    }

    else
    {
      arg=va_arg(ap, __typeof__(arg));
      if(arg == ((const char *)NULL))
        arg = "";

    }
    i = (unsigned int)0;
    do
    {
      tmp_post$3 = i;
      i = i + 1u;
      c = (unsigned int)(unsigned char)arg[(signed long int)tmp_post$3];
      if(c == 0u)
        break;

      a = (c ^ (unsigned int)b) + (c << 8);
      b = (signed int)(a >> 24 | a << 8);
    }
    while((_Bool)1);
    j = j + 1u;
  }
  while((_Bool)1);
  va_end(ap);
  return b < 0 ? -b : b;
}

// gg_http_set_custom_resolver
// file resolver.c line 1018
signed int gg_http_set_custom_resolver(struct gg_http *gh, signed int (*resolver_start)(signed int *, void **, const char *), void (*resolver_cleanup)(void **, signed int))
{
  if(resolver_cleanup == ((void (*)(void **, signed int))NULL) || resolver_start == ((signed int (*)(signed int *, void **, const char *))NULL) || gh == ((struct gg_http *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  gh->resolver_type = (enum anonymous$4)GG_RESOLVER_CUSTOM;
  gh->resolver_start = resolver_start;
  gh->resolver_cleanup = resolver_cleanup;
  return 0;
}

// gg_http_set_resolver
// file ../include/libgadu.h line 825
signed int gg_http_set_resolver(struct gg_http *gh, enum anonymous$4 type)
{
  if(gh == ((struct gg_http *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  if((signed int)type == GG_RESOLVER_DEFAULT)
  {
    if(!((signed int)gg_global_resolver_type == GG_RESOLVER_DEFAULT))
    {
      gh->resolver_type = gg_global_resolver_type;
      gh->resolver_start = gg_global_resolver_start;
      gh->resolver_cleanup = gg_global_resolver_cleanup;
      return 0;
    }

    type = (enum anonymous$4)GG_RESOLVER_PTHREAD;
  }

  signed int *return_value___errno_location$2;
  switch((signed int)type)
  {
    case GG_RESOLVER_FORK:
    {
      gh->resolver_type = type;
      gh->resolver_start = gg_resolver_fork_start;
      gh->resolver_cleanup = gg_resolver_fork_cleanup;
      return 0;
    }
    case GG_RESOLVER_PTHREAD:
    {
      gh->resolver_type = type;
      gh->resolver_start = gg_resolver_pthread_start;
      gh->resolver_cleanup = gg_resolver_pthread_cleanup;
      return 0;
    }
    default:
    {
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 22;
      return -1;
    }
  }
}

// gg_http_stop
// file http.c line 535
void gg_http_stop(struct gg_http *h)
{
  _Bool tmp_if_expr$1;
  if(!(h == ((struct gg_http *)NULL)))
  {
    if(h->state == GG_STATE_ERROR)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = h->state == GG_STATE_DONE ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      h->resolver_cleanup(&h->resolver, 1);
      if(!(h->fd == -1))
      {
        close(h->fd);
        h->fd = -1;
      }

    }

  }

}

// gg_http_watch_fd
// file http.c line 197
signed int gg_http_watch_fd(struct gg_http *h)
{
  gg_debug(8, "** gg_http_watch_fd(%p);\n", h);
  if(h == ((struct gg_http *)NULL))
  {
    gg_debug(16, "// gg_http_watch_fd() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(h->state == GG_STATE_RESOLVING)
  {
    struct in_addr addr;
    signed int gg_http_watch_fd$$1$$2$$res;
    gg_debug(16, "=> http, resolving done\n");
    do
    {
      gg_http_watch_fd$$1$$2$$res=gg_resolver_recv(h->fd, (void *)&addr, sizeof(struct in_addr) /*4ul*/ );
      if(gg_http_watch_fd$$1$$2$$res == -1)
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
    }
    while(tmp_if_expr$3);
    h->resolver_cleanup(&h->resolver, 0);
    if(addr.s_addr == 0xffffffff || !((unsigned long int)gg_http_watch_fd$$1$$2$$res == sizeof(struct in_addr) /*4ul*/ ))
    {
      gg_debug(16, "=> http, resolver thread failed\n");
      if(h->fd >= 0)
        close(h->fd);

      h->fd = -1;
      h->state = GG_STATE_ERROR;
      h->error = GG_ERROR_RESOLVING;
      return 0;
    }

    close(h->fd);
    h->fd = -1;
    char *return_value_inet_ntoa$4;
    return_value_inet_ntoa$4=inet_ntoa(addr);
    gg_debug(16, "=> http, connecting to %s:%d\n", return_value_inet_ntoa$4, h->port);
    h->fd=gg_connect((void *)&addr, h->port, h->async);
    if(h->fd == -1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      gg_debug(16, "=> http, connection failed (errno=%d, %s)\n", *return_value___errno_location$5, return_value_strerror$7);
      if(h->fd >= 0)
        close(h->fd);

      h->fd = -1;
      h->state = GG_STATE_ERROR;
      h->error = GG_ERROR_CONNECTING;
      return 0;
    }

    h->state = GG_STATE_CONNECTING;
    h->check = 1;
    h->timeout = 30;
    return 0;
  }

  signed int return_value_getsockopt$14;
  signed int tmp_if_expr$9;
  signed int *return_value___errno_location$8;
  signed int tmp_if_expr$11;
  signed int *return_value___errno_location$10;
  signed int *return_value___errno_location$13;
  if(h->state == GG_STATE_CONNECTING)
  {
    signed int gg_http_watch_fd$$1$$3$$res = 0;
    unsigned int res_size = (unsigned int)sizeof(signed int) /*4ul*/ ;
    if(!(h->async == 0))
    {
      return_value_getsockopt$14=getsockopt(h->fd, 1, 4, (void *)&gg_http_watch_fd$$1$$3$$res, &res_size);
      if(!(return_value_getsockopt$14 == 0) || !(gg_http_watch_fd$$1$$3$$res == 0))
      {
        if(!(gg_http_watch_fd$$1$$3$$res == 0))
          tmp_if_expr$9 = gg_http_watch_fd$$1$$3$$res;

        else
        {
          return_value___errno_location$8=__errno_location();
          tmp_if_expr$9 = *return_value___errno_location$8;
        }
        if(!(gg_http_watch_fd$$1$$3$$res == 0))
          tmp_if_expr$11 = gg_http_watch_fd$$1$$3$$res;

        else
        {
          return_value___errno_location$10=__errno_location();
          tmp_if_expr$11 = *return_value___errno_location$10;
        }
        char *return_value_strerror$12;
        return_value_strerror$12=strerror(tmp_if_expr$11);
        gg_debug(16, "=> http, async connection failed (errno=%d, %s)\n", tmp_if_expr$9, return_value_strerror$12);
        close(h->fd);
        h->fd = -1;
        h->state = GG_STATE_ERROR;
        h->error = GG_ERROR_CONNECTING;
        if(!(gg_http_watch_fd$$1$$3$$res == 0))
        {
          return_value___errno_location$13=__errno_location();
          *return_value___errno_location$13 = gg_http_watch_fd$$1$$3$$res;
        }

        return 0;
      }

    }

    gg_debug(16, "=> http, connected, sending request\n");
    h->state = GG_STATE_SENDING_QUERY;
  }

  signed int *return_value___errno_location$20;
  signed int *return_value___errno_location$19;
  if(h->state == GG_STATE_SENDING_QUERY)
  {
    signed int gg_http_watch_fd$$1$$4$$res;
    unsigned long int return_value_strlen$15;
    return_value_strlen$15=strlen(h->query);
    signed long int return_value_send$16;
    return_value_send$16=send(h->fd, (const void *)h->query, return_value_strlen$15, 0);
    gg_http_watch_fd$$1$$4$$res = (signed int)return_value_send$16;
    if(gg_http_watch_fd$$1$$4$$res == -1)
    {
      return_value___errno_location$20=__errno_location();
      if(!(*return_value___errno_location$20 == 4))
      {
        return_value___errno_location$19=__errno_location();
        if(!(*return_value___errno_location$19 == 11))
        {
          unsigned long int return_value_strlen$17;
          return_value_strlen$17=strlen(h->query);
          signed int *return_value___errno_location$18;
          return_value___errno_location$18=__errno_location();
          gg_debug(16, "=> http, send() failed (len=%zu, res=%d, errno=%d)\n", return_value_strlen$17, gg_http_watch_fd$$1$$4$$res, *return_value___errno_location$18);
          if(h->fd >= 0)
            close(h->fd);

          h->fd = -1;
          h->state = GG_STATE_ERROR;
          h->error = GG_ERROR_WRITING;
          return 0;
        }

      }

    }

    if(gg_http_watch_fd$$1$$4$$res == -1)
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      signed int *return_value___errno_location$22;
      return_value___errno_location$22=__errno_location();
      char *return_value_strerror$23;
      return_value_strerror$23=strerror(*return_value___errno_location$22);
      gg_debug(16, "=> http, non-critical send error (errno=%d, %s)\n", *return_value___errno_location$21, return_value_strerror$23);
      return 0;
    }

    unsigned long int return_value_strlen$27;
    return_value_strlen$27=strlen(h->query);
    if(!((unsigned long int)gg_http_watch_fd$$1$$4$$res >= return_value_strlen$27))
    {
      unsigned long int return_value_strlen$24;
      return_value_strlen$24=strlen(h->query);
      gg_debug(16, "=> http, partial header sent (led=%zu, sent=%d)\n", return_value_strlen$24, gg_http_watch_fd$$1$$4$$res);
      unsigned long int return_value_strlen$25;
      return_value_strlen$25=strlen(h->query);
      memmove((void *)h->query, (const void *)(h->query + (signed long int)gg_http_watch_fd$$1$$4$$res), (return_value_strlen$25 - (unsigned long int)gg_http_watch_fd$$1$$4$$res) + (unsigned long int)1);
      h->state = GG_STATE_SENDING_QUERY;
      h->check = 1;
      h->timeout = 30;
    }

    else
    {
      unsigned long int return_value_strlen$26;
      return_value_strlen$26=strlen(h->query);
      gg_debug(16, "=> http, request sent (len=%zu)\n", return_value_strlen$26);
      free((void *)h->query);
      h->query = (char *)(void *)0;
      h->state = GG_STATE_READING_HEADER;
      h->check = 2;
      h->timeout = 30;
    }
    return 0;
  }

  signed int *return_value___errno_location$31;
  signed int *return_value___errno_location$30;
  _Bool tmp_if_expr$42;
  _Bool tmp_if_expr$38;
  signed int return_value_strncmp$37;
  if(h->state == GG_STATE_READING_HEADER)
  {
    char gg_http_watch_fd$$1$$5$$buf[1024l];
    char *tmp;
    signed int res;
    signed long int return_value_recv$28;
    return_value_recv$28=recv(h->fd, (void *)gg_http_watch_fd$$1$$5$$buf, sizeof(char [1024l]) /*1024ul*/ , 0);
    res = (signed int)return_value_recv$28;
    if(res == -1)
    {
      return_value___errno_location$31=__errno_location();
      if(!(*return_value___errno_location$31 == 4))
      {
        return_value___errno_location$30=__errno_location();
        if(!(*return_value___errno_location$30 == 11))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          gg_debug(16, "=> http, reading header failed (errno=%d)\n", *return_value___errno_location$29);
          if(!(h->header == ((char *)NULL)))
          {
            free((void *)h->header);
            h->header = (char *)(void *)0;
          }

          if(h->fd >= 0)
            close(h->fd);

          h->fd = -1;
          h->state = GG_STATE_ERROR;
          h->error = GG_ERROR_READING;
          return 0;
        }

      }

    }

    if(res == -1)
    {
      signed int *return_value___errno_location$32;
      return_value___errno_location$32=__errno_location();
      signed int *return_value___errno_location$33;
      return_value___errno_location$33=__errno_location();
      char *return_value_strerror$34;
      return_value_strerror$34=strerror(*return_value___errno_location$33);
      gg_debug(16, "=> http, non-critical recv error (errno=%d, %s)\n", *return_value___errno_location$32, return_value_strerror$34);
      return 0;
    }

    if(res == 0)
    {
      gg_debug(16, "=> http, connection reset by peer\n");
      if(!(h->header == ((char *)NULL)))
      {
        free((void *)h->header);
        h->header = (char *)(void *)0;
      }

      if(h->fd >= 0)
        close(h->fd);

      h->fd = -1;
      h->state = GG_STATE_ERROR;
      h->error = GG_ERROR_READING;
      return 0;
    }

    gg_debug(16, "=> http, read %d bytes of header\n", res);
    void *return_value_realloc$35;
    return_value_realloc$35=realloc((void *)h->header, (unsigned long int)(h->header_size + res + 1));
    tmp = (char *)return_value_realloc$35;
    if(tmp == ((char *)NULL))
    {
      gg_debug(16, "=> http, not enough memory for header\n");
      free((void *)h->header);
      h->header = (char *)(void *)0;
      if(h->fd >= 0)
        close(h->fd);

      h->fd = -1;
      h->state = GG_STATE_ERROR;
      h->error = GG_ERROR_READING;
      return 0;
    }

    h->header = tmp;
    memcpy((void *)(h->header + (signed long int)h->header_size), (const void *)gg_http_watch_fd$$1$$5$$buf, (unsigned long int)res);
    h->header_size = h->header_size + res;
    gg_debug(16, "=> http, header_buf=%p, header_size=%d\n", h->header, h->header_size);
    h->header[(signed long int)h->header_size] = (char)0;
    tmp=strstr(h->header, "\r\n\r\n");
    if(!(tmp == ((char *)NULL)))
      tmp_if_expr$42 = (_Bool)1;

    else
    {
      tmp=strstr(h->header, "\n\n");
      tmp_if_expr$42 = tmp != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$42)
    {
      signed int sep_len = (signed int)*tmp == 13 ? 4 : 2;
      unsigned int left;
      char *line;
      left = (unsigned int)((unsigned long int)h->header_size - (((unsigned long int)tmp - (unsigned long int)h->header) + (unsigned long int)sep_len));
      gg_debug(16, "=> http, got all header (%d bytes, %d left)\n", (unsigned int)h->header_size - left, left);
      unsigned long int return_value_strlen$36;
      return_value_strlen$36=strlen(h->header);
      if(!(return_value_strlen$36 >= 16ul))
        tmp_if_expr$38 = (_Bool)1;

      else
      {
        return_value_strncmp$37=strncmp(h->header + (signed long int)9, "200", (unsigned long int)3);
        tmp_if_expr$38 = return_value_strncmp$37 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$38)
      {
        gg_debug(16, "=> -----BEGIN-HTTP-HEADER-----\n%s\n=> -----END-HTTP-HEADER-----\n", h->header);
        gg_debug(16, "=> http, didn't get 200 OK -- no results\n");
        free((void *)h->header);
        h->header = (char *)(void *)0;
        if(h->fd >= 0)
          close(h->fd);

        h->fd = -1;
        h->state = GG_STATE_ERROR;
        h->error = GG_ERROR_CONNECTING;
        return 0;
      }

      h->body_size = (unsigned int)0;
      line = h->header;
      *tmp = (char)0;
      gg_debug(16, "=> -----BEGIN-HTTP-HEADER-----\n%s\n=> -----END-HTTP-HEADER-----\n", h->header);
      while(!(line == ((char *)NULL)))
      {
        signed int return_value_strncasecmp$40;
        return_value_strncasecmp$40=strncasecmp(line, "Content-length: ", (unsigned long int)16);
        if(return_value_strncasecmp$40 == 0)
        {
          signed int return_value_atoi$39;
          return_value_atoi$39=atoi(line + (signed long int)16);
          h->body_size = (unsigned int)return_value_atoi$39;
        }

        line=strchr(line, 10);
        if(!(line == ((char *)NULL)))
          line = line + 1l;

      }
      if(!(h->body_size >= 1u))
      {
        gg_debug(16, "=> http, content-length not found\n");
        h->body_size = left;
      }

      if(h->body_size >= 1000000001u)
      {
        gg_debug(16, "=> http, content-length too big\n");
        h->body_size = (unsigned int)1000000000;
      }

      if(!(h->body_size >= left))
      {
        gg_debug(16, "=> http, oversized reply (%d bytes needed, %d bytes left)\n", h->body_size, left);
        h->body_size = left;
      }

      gg_debug(16, "=> http, body_size=%d\n", h->body_size);
      void *return_value_malloc$41;
      return_value_malloc$41=malloc((unsigned long int)(h->body_size + (unsigned int)1));
      h->body = (char *)return_value_malloc$41;
      if(h->body == ((char *)NULL))
      {
        gg_debug(16, "=> http, not enough memory (%d bytes for body_buf)\n", h->body_size + (unsigned int)1);
        free((void *)h->header);
        h->header = (char *)(void *)0;
        if(h->fd >= 0)
          close(h->fd);

        h->fd = -1;
        h->state = GG_STATE_ERROR;
        h->error = GG_ERROR_READING;
        return 0;
      }

      if(!(left == 0u))
      {
        memcpy((void *)h->body, (const void *)(tmp + (signed long int)sep_len), (unsigned long int)left);
        h->body_done = left;
      }

      h->body[(signed long int)left] = (char)0;
      h->state = GG_STATE_READING_DATA;
      h->check = 2;
      h->timeout = 30;
    }

    return 0;
  }

  signed int *return_value___errno_location$46;
  signed int *return_value___errno_location$45;
  if(h->state == GG_STATE_READING_DATA)
  {
    char buf[1024l];
    signed int gg_http_watch_fd$$1$$6$$res;
    signed long int return_value_recv$43;
    return_value_recv$43=recv(h->fd, (void *)buf, sizeof(char [1024l]) /*1024ul*/ , 0);
    gg_http_watch_fd$$1$$6$$res = (signed int)return_value_recv$43;
    if(gg_http_watch_fd$$1$$6$$res == -1)
    {
      return_value___errno_location$46=__errno_location();
      if(!(*return_value___errno_location$46 == 4))
      {
        return_value___errno_location$45=__errno_location();
        if(!(*return_value___errno_location$45 == 11))
        {
          signed int *return_value___errno_location$44;
          return_value___errno_location$44=__errno_location();
          gg_debug(16, "=> http, reading body failed (errno=%d)\n", *return_value___errno_location$44);
          if(!(h->body == ((char *)NULL)))
          {
            free((void *)h->body);
            h->body = (char *)(void *)0;
          }

          if(h->fd >= 0)
            close(h->fd);

          h->fd = -1;
          h->state = GG_STATE_ERROR;
          h->error = GG_ERROR_READING;
          return 0;
        }

      }

    }

    if(gg_http_watch_fd$$1$$6$$res == -1)
    {
      signed int *return_value___errno_location$47;
      return_value___errno_location$47=__errno_location();
      signed int *return_value___errno_location$48;
      return_value___errno_location$48=__errno_location();
      char *return_value_strerror$49;
      return_value_strerror$49=strerror(*return_value___errno_location$48);
      gg_debug(16, "=> http, non-critical recv error (errno=%d, %s)\n", *return_value___errno_location$47, return_value_strerror$49);
      return 0;
    }

    if(gg_http_watch_fd$$1$$6$$res == 0)
    {
      if(h->body_done >= h->body_size)
      {
        gg_debug(16, "=> http, we're done, closing socket\n");
        h->state = GG_STATE_PARSING;
        close(h->fd);
        h->fd = -1;
      }

      else
      {
        gg_debug(16, "=> http, connection closed while reading (have %d, need %d)\n", h->body_done, h->body_size);
        if(!(h->body == ((char *)NULL)))
        {
          free((void *)h->body);
          h->body = (char *)(void *)0;
        }

        if(h->fd >= 0)
          close(h->fd);

        h->fd = -1;
        h->state = GG_STATE_ERROR;
        h->error = GG_ERROR_READING;
        return 0;
      }
      return 0;
    }

    gg_debug(16, "=> http, read %d bytes of body\n", gg_http_watch_fd$$1$$6$$res);
    if(!(h->body_size >= h->body_done + (unsigned int)gg_http_watch_fd$$1$$6$$res))
    {
      char *gg_http_watch_fd$$1$$6$$4$$tmp;
      gg_debug(16, "=> http, too much data (%d bytes, %d needed), enlarging buffer\n", h->body_done + (unsigned int)gg_http_watch_fd$$1$$6$$res, h->body_size);
      void *return_value_realloc$50;
      return_value_realloc$50=realloc((void *)h->body, (unsigned long int)(h->body_done + (unsigned int)gg_http_watch_fd$$1$$6$$res + (unsigned int)1));
      gg_http_watch_fd$$1$$6$$4$$tmp = (char *)return_value_realloc$50;
      if(gg_http_watch_fd$$1$$6$$4$$tmp == ((char *)NULL))
      {
        gg_debug(16, "=> http, not enough memory for data (%d needed)\n", h->body_done + (unsigned int)gg_http_watch_fd$$1$$6$$res + (unsigned int)1);
        free((void *)h->body);
        h->body = (char *)(void *)0;
        if(h->fd >= 0)
          close(h->fd);

        h->fd = -1;
        h->state = GG_STATE_ERROR;
        h->error = GG_ERROR_READING;
        return 0;
      }

      h->body = gg_http_watch_fd$$1$$6$$4$$tmp;
      h->body_size = h->body_done + (unsigned int)gg_http_watch_fd$$1$$6$$res;
    }

    h->body[(signed long int)(h->body_done + (unsigned int)gg_http_watch_fd$$1$$6$$res)] = (char)0;
    memcpy((void *)(h->body + (signed long int)h->body_done), (const void *)buf, (unsigned long int)gg_http_watch_fd$$1$$6$$res);
    h->body_done = h->body_done + (unsigned int)gg_http_watch_fd$$1$$6$$res;
    gg_debug(16, "=> body_done=%d, body_size=%d\n", h->body_done, h->body_size);
    return 0;
  }

  if(!(h->fd == -1))
    close(h->fd);

  h->fd = -1;
  h->state = GG_STATE_ERROR;
  h->error = 0;
  return -1;
}

// gg_image_queue_parse
// file handlers.c line 744
static void gg_image_queue_parse(struct gg_event *e, const char *p, unsigned int len, struct gg_session *sess, unsigned int sender, unsigned int type)
{
  struct gg_msg_image_reply *i = (struct gg_msg_image_reply *)(const void *)p;
  struct gg_image_queue *q;
  struct gg_image_queue *qq;
  gg_debug_session(sess, 32, "// gg_image_queue_parse(%p, %p, %d, %p, %u, %d)\n", e, p, len, sess, sender, type);
  if(p == ((const char *)NULL) || e == ((struct gg_event *)NULL) || sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    goto __CPROVER_DUMP_L16;
  }

  if((signed int)i->flag == 0x04)
  {
    e->type = GG_EVENT_IMAGE_REQUEST;
    e->event.image_request.sender = sender;
    e->event.image_reply.size = i->size;
    e->event.image_request.crc32 = i->crc32;
  }

  else
  {
    qq = sess->images;
    q = (struct gg_image_queue *)(void *)0;
    for( ; !(qq == ((struct gg_image_queue *)NULL)); qq = qq->next)
      if(sender == qq->sender)
      {
        if(i->size == qq->size)
        {
          if(i->crc32 == qq->crc32)
          {
            q = qq;
            break;
          }

        }

      }

    if(q == ((struct gg_image_queue *)NULL))
      gg_debug_session(sess, 64, "// gg_image_queue_parse() unknown image from %d, size=%d, crc32=%.8x\n", sender, i->size, i->crc32);

    else
    {
      if(q->packet_type == 0u)
        q->packet_type = type;

      if(q->packet_type == type)
      {
        if((signed int)i->flag == 0x05)
        {
          q->done = (unsigned int)0;
          len = len - (unsigned int)sizeof(struct gg_msg_image_reply) /*9ul*/ ;
          p = p + (signed long int)sizeof(struct gg_msg_image_reply) /*9ul*/ ;
          void *return_value_memchr$2;
          return_value_memchr$2=memchr((const void *)p, 0, (unsigned long int)len);
          if(return_value_memchr$2 == NULL)
          {
            gg_debug_session(sess, 128, "// gg_image_queue_parse() malformed packet from %d, unlimited filename\n", sender);
            goto __CPROVER_DUMP_L16;
          }

          q->filename=strdup(p);
          if(q->filename == ((char *)NULL))
          {
            gg_debug_session(sess, 128, "// gg_image_queue_parse() out of memory\n");
            goto __CPROVER_DUMP_L16;
          }

          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(p);
          len = len - (unsigned int)(return_value_strlen$3 + (unsigned long int)1);
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(p);
          p = p + (signed long int)(return_value_strlen$4 + (unsigned long int)1);
        }

        else
          if((signed int)i->flag == 0x06)
          {
            len = len - (unsigned int)sizeof(struct gg_msg_image_reply) /*9ul*/ ;
            p = p + (signed long int)sizeof(struct gg_msg_image_reply) /*9ul*/ ;
          }

          else
          {
            gg_debug_session(sess, 64, "// gg_image_queue_parse() unexpected flag\n");
            goto __CPROVER_DUMP_L16;
          }
        if(!(q->size >= q->done + len))
        {
          gg_debug_session(sess, 128, "// gg_image_queue_parse() got too much\n");
          len = q->size - q->done;
        }

        memcpy((void *)(q->image + (signed long int)q->done), (const void *)p, (unsigned long int)len);
        q->done = q->done + len;
        gg_debug_session(sess, 32, "// gg_image_queue_parse() got image part (done: %d of %d)\n", q->done, q->size);
        if(q->done >= q->size)
        {
          gg_debug_session(sess, 32, "// gg_image_queue_parse() image ready\n");
          e->type = GG_EVENT_IMAGE_REPLY;
          e->event.image_reply.sender = sender;
          e->event.image_reply.size = q->size;
          e->event.image_reply.crc32 = q->crc32;
          e->event.image_reply.filename = q->filename;
          e->event.image_reply.image = q->image;
          gg_image_queue_remove(sess, q, 0);
          free((void *)q);
        }

      }

    }
  }

__CPROVER_DUMP_L16:
  ;
}

// gg_image_queue_remove
// file events.c line 199
signed int gg_image_queue_remove(struct gg_session *s, struct gg_image_queue *q, signed int freeq)
{
  if(q == ((struct gg_image_queue *)NULL) || s == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(s->images == q)
    s->images = q->next;

  else
  {
    struct gg_image_queue *qq = s->images;
    for( ; !(qq == ((struct gg_image_queue *)NULL)); qq = qq->next)
      if(qq->next == q)
      {
        qq->next = q->next;
        break;
      }

  }
  if(!(freeq == 0))
  {
    free((void *)q->image);
    free((void *)q->filename);
    free((void *)q);
  }

  return 0;
}

// gg_image_reply
// file libgadu.c line 2119
signed int gg_image_reply(struct gg_session *sess, unsigned int recipient, const char *filename, const char *image, signed int size)
{
  struct gg_session_private *p;
  struct gg_msg_image_reply *r;
  struct gg_send_msg s;
  const char *tmp;
  char buf[1910l];
  struct _gg_imgout_queue_t *queue = (struct _gg_imgout_queue_t *)(void *)0;
  struct _gg_imgout_queue_t *queue_end = (struct _gg_imgout_queue_t *)(void *)0;
  gg_debug_session(sess, 8, "** gg_image_reply(%p, %d, \"%s\", %p, %d);\n", sess, recipient, filename, image, size);
  if(filename == ((const char *)NULL) || image == ((const char *)NULL) || sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  p = sess->private_data;
  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  if(!(size >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  do
  {
    tmp=strrchr(filename, 47);
    if(tmp == ((const char *)NULL))
    {
      tmp=strrchr(filename, 92);
      if(tmp == ((const char *)NULL))
        break;

    }

    filename = tmp + (signed long int)1;
  }
  while((_Bool)1);
  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(filename);
  _Bool tmp_if_expr$7;
  unsigned long int return_value_strlen$6;
  if(!(return_value_strlen$5 >= 1ul))
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strlen$6=strlen(filename);
    tmp_if_expr$7 = return_value_strlen$6 > (unsigned long int)1024 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    *return_value___errno_location$4 = 22;
    return -1;
  }

  s.recipient=gg_fix32(recipient);
  s.seq=gg_fix32((unsigned int)0);
  s.msgclass=gg_fix32((unsigned int)0x0004);
  buf[(signed long int)0] = (char)0;
  r = (struct gg_msg_image_reply *)(void *)&buf[(signed long int)1];
  r->flag = (unsigned char)0x05;
  r->size=gg_fix32((unsigned int)size);
  unsigned int return_value_gg_crc32$8;
  return_value_gg_crc32$8=gg_crc32((unsigned int)0, (const unsigned char *)image, size);
  r->crc32=gg_fix32(return_value_gg_crc32$8);
  while(size >= 1)
  {
    struct _gg_imgout_queue_t *it;
    unsigned long int buflen;
    unsigned long int chunklen;
    buflen = sizeof(struct gg_msg_image_reply) /*9ul*/  + (unsigned long int)1;
    if((signed int)r->flag == 0x05)
    {
      strcpy(buf + (signed long int)buflen, filename);
      unsigned long int return_value_strlen$9;
      return_value_strlen$9=strlen(filename);
      buflen = buflen + return_value_strlen$9 + (unsigned long int)1;
    }

    chunklen = (unsigned long int)size >= sizeof(char [1910l]) /*1910ul*/  - buflen ? sizeof(char [1910l]) /*1910ul*/  - buflen : (unsigned long int)size;
    memcpy((void *)(buf + (signed long int)buflen), (const void *)image, chunklen);
    size = size - (signed int)chunklen;
    image = image + (signed long int)chunklen;
    void *return_value_gg_new0$10;
    return_value_gg_new0$10=gg_new0(sizeof(struct _gg_imgout_queue_t) /*1944ul*/ );
    it = (struct _gg_imgout_queue_t *)return_value_gg_new0$10;
    if(it == ((struct _gg_imgout_queue_t *)NULL))
      break;

    if(!(queue_end == ((struct _gg_imgout_queue_t *)NULL)))
    {
      queue_end->next = it;
      queue_end = it;
    }

    else
    {
      queue_end = it;
      queue = queue_end;
    }
    memcpy((void *)&it->msg_hdr, (const void *)&s, sizeof(struct gg_send_msg) /*12ul*/ );
    memcpy((void *)it->buf, (const void *)buf, buflen + chunklen);
    it->buf_len = buflen + chunklen;
    r->flag = (unsigned char)0x06;
  }
  if(!(p->imgout_queue == ((struct _gg_imgout_queue_t *)NULL)))
  {
    queue_end = p->imgout_queue;
    for( ; !(queue_end->next == ((struct _gg_imgout_queue_t *)NULL)); queue_end = queue_end->next)
      ;
    queue_end->next = queue;
  }

  else
    p->imgout_queue = queue;
  gg_image_sendout(sess);
  return 0;
}

// gg_image_request
// file libgadu.c line 2032
signed int gg_image_request(struct gg_session *sess, unsigned int recipient, signed int size, unsigned int crc32)
{
  struct gg_send_msg s;
  struct gg_msg_image_request r;
  char dummy = (char)0;
  signed int res;
  gg_debug_session(sess, 8, "** gg_image_request(%p, %d, %u, 0x%.4x);\n", sess, recipient, size, crc32);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  if(!(size >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  s.recipient=gg_fix32(recipient);
  s.seq=gg_fix32((unsigned int)0);
  s.msgclass=gg_fix32((unsigned int)0x0004);
  r.flag = (unsigned char)0x04;
  r.size=gg_fix32((unsigned int)size);
  r.crc32=gg_fix32(crc32);
  res=gg_send_packet(sess, 0x000b, &s, sizeof(struct gg_send_msg) /*12ul*/ , &dummy, 1, &r, sizeof(struct gg_msg_image_request) /*9ul*/ , (void *)0);
  if(res == 0)
  {
    struct gg_image_queue *q;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct gg_image_queue) /*56ul*/ );
    q = (struct gg_image_queue *)return_value_malloc$4;
    char *buf;
    if(q == ((struct gg_image_queue *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_image_request() not enough memory for image queue\n");
      return -1;
    }

    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)size);
    buf = (char *)return_value_malloc$5;
    if(buf == ((char *)NULL) && !(size == 0))
    {
      gg_debug_session(sess, 16, "// gg_image_request() not enough memory for image\n");
      free((void *)q);
      return -1;
    }

    memset((void *)q, 0, sizeof(struct gg_image_queue) /*56ul*/ );
    q->sender = recipient;
    q->size = (unsigned int)size;
    q->crc32 = crc32;
    q->image = buf;
    if(sess->images == ((struct gg_image_queue *)NULL))
      sess->images = q;

    else
    {
      struct gg_image_queue *qq = sess->images;
      for( ; !(qq->next == ((struct gg_image_queue *)NULL)); qq = qq->next)
        ;
      qq->next = q;
    }
  }

  return res;
}

// gg_image_sendout
// file ../include/internal.h line 189
void gg_image_sendout(struct gg_session *sess)
{
  struct gg_session_private *p = sess->private_data;
  while(!(p->imgout_waiting_ack >= 4))
  {
    if(p->imgout_queue == ((struct _gg_imgout_queue_t *)NULL))
      break;

    struct _gg_imgout_queue_t *it = p->imgout_queue;
    signed int res;
    p->imgout_queue = p->imgout_queue->next;
    p->imgout_waiting_ack = p->imgout_waiting_ack + 1;
    res=gg_send_packet(sess, 0x000b, &it->msg_hdr, sizeof(struct gg_send_msg) /*12ul*/ , (const void *)it->buf, it->buf_len, (void *)0);
    free((void *)it);
    if(res == -1)
      break;

  }
}

// gg_inflate
// file deflate.c line 152
char * gg_inflate(const unsigned char *in, unsigned long int length)
{
  signed int ret;
  struct z_stream_s strm;
  char *out = (char *)(void *)0;
  char *out2;
  unsigned long int out_len = (unsigned long int)1024;
  signed int first = 1;
  if(in == ((const unsigned char *)NULL))
    return (char *)(void *)0;

  else
  {
    strm.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    strm.zfree = ((void (*)(void *, void *))NULL);
    strm.opaque = NULL;
    strm.avail_in = (unsigned int)length;
    strm.next_in = (unsigned char *)in;
    ret=inflateInit_(&strm, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(ret == 0))
    {
      gg_debug(16, "// gg_inflate() inflateInit() failed (%d)\n", ret);
      return (char *)(void *)0;
    }

    else
    {
      do
      {
        out_len = out_len * (unsigned long int)2;
        void *return_value_realloc$1;
        return_value_realloc$1=realloc((void *)out, out_len);
        out2 = (char *)return_value_realloc$1;
        if(out2 == ((char *)NULL))
        {
          gg_debug(16, "// gg_inflate() not enough memory for output data (%zu)\n", out_len);
          goto fail;
        }

        out = out2;
        if(!(first == 0))
        {
          strm.avail_out = (unsigned int)out_len;
          strm.next_out = (unsigned char *)out;
        }

        else
        {
          strm.avail_out = (unsigned int)(out_len / (unsigned long int)2);
          strm.next_out = (unsigned char *)out + (signed long int)(out_len / (unsigned long int)2);
        }
        ret=inflate(&strm, 0);
        if(!(ret == 0) && !(ret == 1))
        {
          gg_debug(16, "// gg_inflate() inflate() failed (ret=%d, msg=%s)\n", ret, strm.msg != (char *)(void *)0 ? strm.msg : "no error message provided");
          goto fail;
        }

        first = 0;
      }
      while(!(ret == 1));
      out_len = strm.total_out + (unsigned long int)1;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)out, out_len);
      out2 = (char *)return_value_realloc$2;
      if(out2 == ((char *)NULL))
        gg_debug(16, "// gg_inflate() not enough memory for output data (%zu)\n", out_len);

      else
      {
        out = out2;
        out[(signed long int)(out_len - (unsigned long int)1)] = (char)0;
        inflateEnd(&strm);
        return out;
      }

    fail:
      ;
      inflateEnd(&strm);
      free((void *)out);
      return (char *)(void *)0;
    }
  }
}

// gg_is_gpl_compliant
// file libgadu.c line 147
signed int gg_is_gpl_compliant(void)
{
  return 1;
}

// gg_libgadu_check_feature
// file libgadu.c line 2830
signed int gg_libgadu_check_feature(enum anonymous$17 feature)
{
  switch((signed int)feature)
  {
    case GG_LIBGADU_FEATURE_SSL:
      return 1;
    case GG_LIBGADU_FEATURE_PTHREAD:
      return 1;
    case GG_LIBGADU_FEATURE_USERLIST100:
      return 1;
    default:
      return 0;
  }
}

// gg_libgadu_version
// file libgadu.c line 160
const char * gg_libgadu_version(void)
{
  return "1.12.1";
}

// gg_login
// file ../../include/libgadu.h line 798
struct gg_session * gg_login(struct gg_login_params *p)
{
  struct gg_session *sess = (struct gg_session *)(void *)0;
  struct gg_session_private *sess_private = (struct gg_session_private *)(void *)0;
  if(p == ((struct gg_login_params *)NULL))
  {
    gg_debug(8, "** gg_login(%p);\n", p);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (struct gg_session *)(void *)0;
  }

  gg_debug(8, "** gg_login(%p: [uin=%u, async=%d, ...]);\n", p, p->uin, p->async);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct gg_session) /*392ul*/ );
  sess = (struct gg_session *)return_value_malloc$2;
  void *return_value_malloc$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  signed int return_value_strcmp$11;
  signed int return_value_gg_session_set_resolver$13;
  _Bool tmp_if_expr$16;
  if(sess == ((struct gg_session *)NULL))
    gg_debug(16, "// gg_login() not enough memory for session data\n");

  else
  {
    memset((void *)sess, 0, sizeof(struct gg_session) /*392ul*/ );
    sess->fd = -1;
    return_value_malloc$3=malloc(sizeof(struct gg_session_private) /*176ul*/ );
    sess_private = (struct gg_session_private *)return_value_malloc$3;
    if(sess_private == ((struct gg_session_private *)NULL))
      gg_debug(16, "// gg_login() not enough memory for session private data\n");

    else
    {
      memset((void *)sess_private, 0, sizeof(struct gg_session_private) /*176ul*/ );
      sess->private_data = sess_private;
      if(p->password == ((char *)NULL))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = p->uin == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
      {
        gg_debug(16, "// gg_login() invalid arguments. uin and password needed\n");
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 14;
        goto fail;
      }

      sess->password=strdup(p->password);
      if(sess->password == ((char *)NULL))
        gg_debug(16, "// gg_login() not enough memory for password\n");

      else
      {
        if(!(p->hash_type >= 0))
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = p->hash_type > 0x02 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
        {
          gg_debug(16, "// gg_login() invalid arguments. unknown hash type (%d)\n", p->hash_type);
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          *return_value___errno_location$6 = 14;
          goto fail;
        }

        sess->uin = p->uin;
        sess->state = GG_STATE_RESOLVING;
        sess->check = 2;
        sess->timeout = 30;
        sess->async = p->async;
        sess->type = 1;
        sess->initial_status = p->status;
        sess->callback = gg_session_callback;
        sess->destroy = gg_free_session;
        sess->port = (signed int)p->server_port;
        sess->server_addr = p->server_addr;
        sess->external_port = p->external_port;
        sess->external_addr = p->external_addr;
        sess->client_addr = p->client_addr;
        sess->client_port = p->client_port;
        if((unsigned long int)p->struct_size >= 117ul)
          sess_private->compatibility = p->compatibility;

        if((unsigned long int)p->struct_size >= 121ul)
        {
          if(!(p->connect_host == ((char *)NULL)))
          {
            signed int port = 0;
            char *colon;
            sess->connect_host=strdup(p->connect_host);
            if(sess->connect_host == ((char *)NULL))
              goto fail;

            colon=strchr(sess->connect_host, 58);
            if(!(colon == ((char *)NULL)))
            {
              colon[(signed long int)0] = (char)0;
              port=atoi(colon + (signed long int)1);
            }

            if(port >= 1)
              sess->port = port;

          }

        }

        if((unsigned long int)p->struct_size >= 129ul)
          tmp_if_expr$9 = (136ul < (unsigned long int)p->struct_size ? (_Bool)1 : (136ul <= 112ul ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
          tmp_if_expr$10 = (signed int)p->socket_manager_type != GG_SOCKET_MANAGER_TYPE_INTERNAL ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$10 = (_Bool)0;
        if(tmp_if_expr$10)
        {
          if((unsigned int)p->socket_manager_type >= 3u)
          {
            gg_debug(16 | 128, "// gg_login() invalid arguments. unknown socket manager type (%d)\n", p->socket_manager_type);
            signed int *return_value___errno_location$8;
            return_value___errno_location$8=__errno_location();
            *return_value___errno_location$8 = 14;
            goto fail;
          }

          else
          {
            sess_private->socket_manager_type = p->socket_manager_type;
            memcpy((void *)&sess_private->socket_manager, (const void *)&p->socket_manager, sizeof(struct anonymous$7) /*72ul*/ );
          }
        }

        else
          sess_private->socket_manager_type = (enum anonymous$6)GG_SOCKET_MANAGER_TYPE_INTERNAL;
        if((unsigned long int)p->struct_size >= 209ul)
        {
          if(!(p->host_white_list == ((char **)NULL)))
          {
            sess_private->host_white_list=gg_strarr_dup(p->host_white_list);
            if(sess_private->host_white_list == ((char **)NULL))
              goto fail;

          }

        }

        if(p->protocol_features == 0)
          sess->protocol_features = 0x02 | 0x05 | 0x0010 | 0x0020 | 0x0100 | 0x0200 | 0x0400 | 0x2000;

        else
        {
          sess->protocol_features = p->protocol_features & ~(0x0002 | 0x0001);
          if((0x0002 & p->protocol_features) == 0)
            sess->protocol_features = sess->protocol_features | 0x05;

          if((0x0001 & p->protocol_features) == 0)
            sess->protocol_features = sess->protocol_features | 0x02;

        }
        sess->status_flags = p->status_flags;
        if(sess->status_flags == 0)
          sess->status_flags = 0x00000001 | 0x00800000;

        if(p->protocol_version == 0)
          sess->protocol_version = 0x40;

        else
          if(!(p->protocol_version >= 0x2e))
          {
            gg_debug(16, "// gg_login() libgadu no longer support protocol < 0x2e\n");
            sess->protocol_version = 0x2e;
          }

          else
            sess->protocol_version = p->protocol_version;
        if(!(p->client_version == ((char *)NULL)))
        {
          return_value_strcmp$11=strcmp(p->client_version, "-");
          if(!(return_value_strcmp$11 == 0))
            sess->client_version=strdup(p->client_version);

        }

        sess->last_sysmsg = p->last_sysmsg;
        sess->image_size = p->image_size;
        sess->pid = -1;
        sess->encoding = p->encoding;
        return_value_gg_session_set_resolver$13=gg_session_set_resolver(sess, p->resolver);
        if(return_value_gg_session_set_resolver$13 == -1)
        {
          gg_debug(16, "// gg_login() invalid arguments. unsupported resolver type (%d)\n", p->resolver);
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          *return_value___errno_location$12 = 14;
          goto fail;
        }

        if(!(p->status_descr == ((char *)NULL)))
        {
          sess->initial_descr=gg_encoding_convert(p->status_descr, p->encoding, (enum anonymous$3)GG_ENCODING_UTF8, -1, -1);
          if(sess->initial_descr == ((char *)NULL))
          {
            gg_debug(16, "// gg_login() not enough memory for status\n");
            goto fail;
          }

          unsigned long int return_value_strlen$14;
          return_value_strlen$14=strlen(sess->initial_descr);
          if(return_value_strlen$14 >= 256ul)
            sess->initial_descr[(signed long int)255] = (char)0;

        }

        if(!(p->tls == GG_SSL_DISABLED))
          sess->ssl_flag = (enum anonymous$8)p->tls;

        if(!(p->hash_type == 0))
          sess->hash_type = p->hash_type;

        else
          sess->hash_type = 0x02;
        if(sess->server_addr == 0u)
          tmp_if_expr$16 = sess->connect_host == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$16 = (_Bool)0;
        if(tmp_if_expr$16)
        {
          if(!(gg_proxy_enabled == 0))
          {
            sess->resolver_host = gg_proxy_host;
            sess->proxy_port = (unsigned short int)gg_proxy_port;
            sess->state = sess->async != 0 ? GG_STATE_RESOLVE_PROXY_HUB_ASYNC : GG_STATE_RESOLVE_PROXY_HUB_SYNC;
          }

          else
          {
            sess->resolver_host = "appmsg.gadu-gadu.pl";
            sess->proxy_port = (unsigned short int)0;
            sess->state = sess->async != 0 ? GG_STATE_RESOLVE_HUB_ASYNC : GG_STATE_RESOLVE_HUB_SYNC;
          }
        }

        else
        {
          if(!(sess->connect_host == ((char *)NULL)))
            sess->server_addr = (unsigned int)0;

          else
          {
            char *return_value_inet_ntoa$15;
            return_value_inet_ntoa$15=inet_ntoa(*((struct in_addr *)&sess->server_addr));
            sess->connect_host=strdup(return_value_inet_ntoa$15);
            if(sess->connect_host == ((char *)NULL))
              goto fail;

          }
          sess->connect_index = (unsigned int)0;
          if(!(gg_proxy_enabled == 0))
          {
            sess->resolver_host = gg_proxy_host;
            sess->proxy_port = (unsigned short int)gg_proxy_port;
            if(sess->port == 0)
              sess->connect_port[(signed long int)0] = (unsigned short int)443;

            else
              sess->connect_port[(signed long int)0] = (unsigned short int)sess->port;
            sess->connect_port[(signed long int)1] = (unsigned short int)0;
            sess->state = sess->async != 0 ? GG_STATE_RESOLVE_PROXY_GG_ASYNC : GG_STATE_RESOLVE_PROXY_GG_SYNC;
          }

          else
          {
            sess->resolver_host = sess->connect_host;
            if(sess->port == 0)
            {
              if((signed int)sess->ssl_flag == GG_SSL_DISABLED)
              {
                sess->connect_port[(signed long int)0] = (unsigned short int)8074;
                sess->connect_port[(signed long int)1] = (unsigned short int)443;
              }

              else
              {
                sess->connect_port[(signed long int)0] = (unsigned short int)443;
                sess->connect_port[(signed long int)1] = (unsigned short int)0;
              }
            }

            else
            {
              sess->connect_port[(signed long int)0] = (unsigned short int)sess->port;
              sess->connect_port[(signed long int)1] = (unsigned short int)0;
            }
            sess->state = sess->async != 0 ? GG_STATE_RESOLVE_GG_ASYNC : GG_STATE_RESOLVE_GG_SYNC;
          }
        }
        sess->timeout = 30;
        if(sess->async == 0)
          while(!(sess->state == GG_STATE_CONNECTED))
          {
            struct gg_event *gg_login$$1$$19$$1$$ge;
            gg_login$$1$$19$$1$$ge=gg_watch_fd(sess);
            if(gg_login$$1$$19$$1$$ge == ((struct gg_event *)NULL))
            {
              gg_debug(16, "// gg_session_connect() critical error in gg_watch_fd()\n");
              goto fail;
            }

            if(gg_login$$1$$19$$1$$ge->type == GG_EVENT_CONN_FAILED)
            {
              signed int *return_value___errno_location$17;
              return_value___errno_location$17=__errno_location();
              *return_value___errno_location$17 = 13;
              gg_debug(16, "// gg_session_connect() could not login\n");
              gg_event_free(gg_login$$1$$19$$1$$ge);
              goto fail;
            }

            gg_event_free(gg_login$$1$$19$$1$$ge);
          }

        else
        {
          struct gg_event *ge;
          ge=gg_watch_fd(sess);
          if(ge == ((struct gg_event *)NULL))
          {
            gg_debug(16, "// gg_session_connect() critical error in gg_watch_fd()\n");
            goto fail;
          }

          gg_event_free(ge);
        }
        return sess;
      }
    }
  }

fail:
  ;
  gg_free_session(sess);
  return (struct gg_session *)(void *)0;
}

// gg_login_hash
// file ../include/libgadu.h line 1772
unsigned int gg_login_hash(const unsigned char *password, unsigned int seed)
{
  unsigned int x;
  unsigned int y;
  unsigned int z;
  y = seed;
  x = (unsigned int)0;
  for( ; !(*password == 0); password = password + 1l)
  {
    x = x & 0xffffff00 | (unsigned int)*password;
    y = y ^ x;
    y = y + x;
    x = x << 8;
    y = y ^ x;
    x = x << 8;
    y = y - x;
    x = x << 8;
    y = y ^ x;
    z = y & (unsigned int)0x1F;
    y = y << z | y >> (unsigned int)32 - z;
  }
  return y;
}

// gg_login_hash_sha1
// file obsolete.c line 244
void gg_login_hash_sha1(const char *password, unsigned int seed, unsigned char *result)
{
  signed int return_value_gg_login_hash_sha1_2$1;
  return_value_gg_login_hash_sha1_2$1=gg_login_hash_sha1_2(password, seed, result);
  if(!(return_value_gg_login_hash_sha1_2$1 == 0))
    memset((void *)result, 0, (unsigned long int)20);

}

// gg_login_hash_sha1_2
// file ../include/internal.h line 168
signed int gg_login_hash_sha1_2(const char *password, unsigned int seed, unsigned char *result)
{
  struct hash_hd_st *ctx;
  signed int return_value_gnutls_hash_init$1;
  return_value_gnutls_hash_init$1=gnutls_hash_init(&ctx, (enum anonymous$25)GNUTLS_DIG_SHA1);
  signed int return_value_gnutls_hash$4;
  if(!(return_value_gnutls_hash_init$1 == 0))
    return -1;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(password);
    signed int return_value_gnutls_hash$3;
    return_value_gnutls_hash$3=gnutls_hash(*(&ctx), (const void *)(const unsigned char *)password, return_value_strlen$2);
    if(return_value_gnutls_hash$3 == 0)
    {
      seed=gg_fix32(seed);
      return_value_gnutls_hash$4=gnutls_hash(*(&ctx), (const void *)(unsigned char *)&seed, (unsigned long int)4);
      if(!(return_value_gnutls_hash$4 == 0))
        goto fail;

      gnutls_hash_deinit(*(&ctx), (void *)result);
      return 0;
    }

    else
    {

    fail:
      ;
      gnutls_hash_deinit(*(&ctx), (void *)result);
      1;
      return -1;
    }
  }
}

// gg_logoff
// file libgadu.c line 1183
void gg_logoff(struct gg_session *sess)
{
  if(!(sess == ((struct gg_session *)NULL)))
  {
    gg_debug_session(sess, 8, "** gg_logoff(%p);\n", sess);
    if(!(sess->ssl == NULL))
      gnutls_bye(((struct anonymous$34 *)sess->ssl)->session, (enum anonymous$14)GNUTLS_SHUT_RDWR);

    sess->resolver_cleanup(&sess->resolver, 1);
    gg_close(sess);
    if(!(sess->send_buf == ((char *)NULL)))
    {
      free((void *)sess->send_buf);
      sess->send_buf = (char *)(void *)0;
      sess->send_left = 0;
    }

  }

}

// gg_message_html_to_text
// file ../include/message.h line 54
unsigned long int gg_message_html_to_text(char *dst, unsigned char *format, unsigned long int *format_len, const char *html, enum anonymous$3 encoding)
{
  const char *src;
  const char *entity = (const char *)(void *)0;
  const char *tag = (const char *)(void *)0;
  signed int in_tag = 0;
  signed int in_entity = 0;
  signed int in_bold = 0;
  signed int in_italic = 0;
  signed int in_underline = 0;
  unsigned char color[3l] = { (unsigned char)0, 0, 0 };
  unsigned char old_color[3l] = { (unsigned char)0, 0, 0 };
  unsigned char attr_flag = (unsigned char)0;
  unsigned char old_attr_flag = (unsigned char)0;
  unsigned short int pos = (unsigned short int)0;
  unsigned long int len = (unsigned long int)0;
  unsigned long int imgs_size = (unsigned long int)0;
  if(!(format_len == ((unsigned long int *)NULL)))
    *format_len = (unsigned long int)0;

  src = html;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$1;
  signed int return_value_strncmp$22;
  _Bool tmp_if_expr$24;
  signed int return_value_strncmp$23;
  unsigned long int tmp_post$7;
  unsigned long int tmp_post$8;
  signed int return_value_strncmp$21;
  signed int return_value_strncmp$20;
  signed int return_value_strncmp$19;
  signed int return_value_strncmp$18;
  signed int return_value_strncmp$17;
  signed int return_value_strncmp$16;
  signed int return_value_strncmp$15;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  signed int return_value_strncmp$14;
  unsigned long int tmp_post$26;
  signed int return_value_strncmp$38;
  unsigned long int tmp_post$27;
  signed int return_value_strncmp$37;
  unsigned long int tmp_post$28;
  signed int return_value_strncmp$36;
  unsigned long int tmp_post$29;
  signed int return_value_strncmp$35;
  unsigned long int tmp_post$30;
  signed int return_value_strncmp$34;
  unsigned long int tmp_post$31;
  unsigned long int tmp_post$32;
  unsigned long int tmp_post$33;
  const unsigned short int **return_value___ctype_b_loc$41;
  _Bool tmp_if_expr$42;
  _Bool tmp_if_expr$43;
  for( ; !((signed int)*src == 0); src = src + 1l)
  {
    if(!(in_entity == 0))
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if(!((8 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*src]) == 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*src == 35 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)*src == 59 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$4)
      {
        signed int first = 1;
        unsigned long int i;
        unsigned long int append_len = (unsigned long int)(src - entity);
        gg_append(dst, &len, (const void *)entity, append_len);
        i = (unsigned long int)0;
        for( ; !(i >= append_len); i = i + 1ul)
        {
          if(!((signed int)encoding == GG_ENCODING_UTF8))
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = ((signed int)entity[(signed long int)i] & 0xc0) != 0x80 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
          {
            if(!(first == 0))
            {
              gg_after_append_formatted_char(&pos, attr_flag, &old_attr_flag, color, old_color, imgs_size, &format, format_len);
              first = 0;
            }

            else
              pos = pos + 1;
          }

        }
        in_entity = 0;
      }

    }

    if((signed int)*src == 60)
    {
      tag = src;
      in_tag = 1;
    }

    else
    {
      if(!(in_tag == 0))
      {
        if((signed int)*src == 62)
        {
          signed int return_value_strncmp$25;
          return_value_strncmp$25=strncmp(tag, "<br", (unsigned long int)3);
          if(return_value_strncmp$25 == 0)
          {
            if(!(dst == ((char *)NULL)))
              dst[(signed long int)len] = (char)10;

            len = len + 1ul;
            gg_after_append_formatted_char(&pos, attr_flag, &old_attr_flag, color, old_color, imgs_size, &format, format_len);
          }

          else
          {
            return_value_strncmp$22=strncmp(tag, "<img name=\"", (unsigned long int)11);
            if(return_value_strncmp$22 == 0)
              tmp_if_expr$24 = (_Bool)1;

            else
            {
              return_value_strncmp$23=strncmp(tag, "<img name='", (unsigned long int)11);
              tmp_if_expr$24 = return_value_strncmp$23 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$24)
            {
              tag = tag + (signed long int)11;
              if(src >= tag + 17l)
              {
                signed int gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i;
                signed int ok = 1;
                gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i = 0;
                for( ; !(gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i >= 16); gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i = gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i + 1)
                {
                  const unsigned short int **return_value___ctype_b_loc$5;
                  return_value___ctype_b_loc$5=__ctype_b_loc();
                  if((4096 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)tag[(signed long int)gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i]]) == 0)
                  {
                    ok = 0;
                    break;
                  }

                }
                if(!(ok == 0))
                {
                  unsigned char img_attr[13l];
                  if(!(format == ((unsigned char *)NULL)))
                  {
                    char buf[3l] = { (char)0, 0, 0 };
                    img_attr[(signed long int)0] = (unsigned char)((signed int)pos & (signed int)(unsigned short int)0x00ffU);
                    img_attr[(signed long int)1] = (unsigned char)(((signed int)pos & (signed int)(unsigned short int)0xff00U) >> 8);
                    img_attr[(signed long int)2] = (unsigned char)0x80;
                    img_attr[(signed long int)3] = (unsigned char)9;
                    img_attr[(signed long int)4] = (unsigned char)1;
                    gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i = 0;
                    for( ; !(gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i >= 16); gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i = gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i + 2)
                    {
                      buf[(signed long int)0] = tag[(signed long int)gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i];
                      buf[(signed long int)1] = tag[(signed long int)(gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i + 1)];
                      unsigned long int return_value_strtoul$6;
                      return_value_strtoul$6=strtoul(buf, (char ** restrict )(void *)0, 16);
                      img_attr[(signed long int)(12 - gg_message_html_to_text$$1$$1$$1$$3$$2$$1$$i / 2)] = (unsigned char)return_value_strtoul$6;
                    }
                    memcpy((void *)format, (const void *)img_attr, sizeof(unsigned char [13l]) /*13ul*/ );
                    format = format + (signed long int)sizeof(unsigned char [13l]) /*13ul*/ ;
                  }

                  if(!(format_len == ((unsigned long int *)NULL)))
                    *format_len = *format_len + sizeof(unsigned char [13l]) /*13ul*/ ;

                  imgs_size = imgs_size + sizeof(unsigned char [13l]) /*13ul*/ ;
                  if(!(dst == ((char *)NULL)))
                  {
                    if((signed int)encoding == GG_ENCODING_UTF8)
                    {
                      tmp_post$7 = len;
                      len = len + 1ul;
                      dst[(signed long int)tmp_post$7] = (char)-62;
                    }

                    tmp_post$8 = len;
                    len = len + 1ul;
                    dst[(signed long int)tmp_post$8] = (char)-96;
                  }

                  else
                    len = len + (unsigned long int)2;
                  pos = pos + 1;
                  old_attr_flag = (unsigned char)-1;
                }

              }

            }

            else
            {
              return_value_strncmp$21=strncmp(tag, "<b>", (unsigned long int)3);
              if(return_value_strncmp$21 == 0)
              {
                in_bold = in_bold + 1;
                attr_flag = attr_flag | (unsigned char)0x01;
              }

              else
              {
                return_value_strncmp$20=strncmp(tag, "</b>", (unsigned long int)4);
                if(return_value_strncmp$20 == 0)
                {
                  if(in_bold >= 1)
                  {
                    in_bold = in_bold - 1;
                    if(in_bold == 0)
                      attr_flag = attr_flag & (unsigned char)~0x01;

                  }

                }

                else
                {
                  return_value_strncmp$19=strncmp(tag, "<i>", (unsigned long int)3);
                  if(return_value_strncmp$19 == 0)
                  {
                    in_italic = in_italic + 1;
                    attr_flag = attr_flag | (unsigned char)0x02;
                  }

                  else
                  {
                    return_value_strncmp$18=strncmp(tag, "</i>", (unsigned long int)4);
                    if(return_value_strncmp$18 == 0)
                    {
                      if(in_italic >= 1)
                      {
                        in_italic = in_italic - 1;
                        if(in_italic == 0)
                          attr_flag = attr_flag & (unsigned char)~0x02;

                      }

                    }

                    else
                    {
                      return_value_strncmp$17=strncmp(tag, "<u>", (unsigned long int)3);
                      if(return_value_strncmp$17 == 0)
                      {
                        in_underline = in_underline + 1;
                        attr_flag = attr_flag | (unsigned char)0x04;
                      }

                      else
                      {
                        return_value_strncmp$16=strncmp(tag, "</u>", (unsigned long int)4);
                        if(return_value_strncmp$16 == 0)
                        {
                          if(in_underline >= 1)
                          {
                            in_underline = in_underline - 1;
                            if(in_underline == 0)
                              attr_flag = attr_flag & (unsigned char)~0x04;

                          }

                        }

                        else
                        {
                          return_value_strncmp$15=strncmp(tag, "<span ", (unsigned long int)6);
                          if(return_value_strncmp$15 == 0)
                          {
                            tag = tag + (signed long int)6;
                            for( ; !(tag >= src + -8l); tag = tag + 1l)
                            {
                              if((signed int)*tag == 34)
                                tmp_if_expr$12 = (_Bool)1;

                              else
                                tmp_if_expr$12 = (signed int)*tag == 39 ? (_Bool)1 : (_Bool)0;
                              if(tmp_if_expr$12)
                                tmp_if_expr$13 = (_Bool)1;

                              else
                                tmp_if_expr$13 = (signed int)*tag == 32 ? (_Bool)1 : (_Bool)0;
                              if(tmp_if_expr$13)
                              {
                                signed int return_value_strncmp$11;
                                return_value_strncmp$11=strncmp(tag + (signed long int)1, "color:#", (unsigned long int)7);
                                if(return_value_strncmp$11 == 0)
                                {
                                  signed int gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i;
                                  signed int gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$ok = 1;
                                  char gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$buf[3l] = { (char)0, 0, 0 };
                                  tag = tag + (signed long int)8;
                                  if(!(src >= tag + 6l))
                                    break;

                                  gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i = 0;
                                  for( ; !(gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i >= 6); gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i = gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i + 1)
                                  {
                                    const unsigned short int **return_value___ctype_b_loc$9;
                                    return_value___ctype_b_loc$9=__ctype_b_loc();
                                    if((4096 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)tag[(signed long int)gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i]]) == 0)
                                    {
                                      gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$ok = 0;
                                      break;
                                    }

                                  }
                                  if(gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$ok == 0)
                                    break;

                                  gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i = 0;
                                  for( ; !(gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i >= 6); gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i = gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i + 2)
                                  {
                                    gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$buf[(signed long int)0] = tag[(signed long int)gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i];
                                    gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$buf[(signed long int)1] = tag[(signed long int)(gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i + 1)];
                                    unsigned long int return_value_strtoul$10;
                                    return_value_strtoul$10=strtoul(gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$buf, (char ** restrict )(void *)0, 16);
                                    color[(signed long int)(gg_message_html_to_text$$1$$1$$1$$3$$9$$1$$1$$1$$1$$i / 2)] = (unsigned char)return_value_strtoul$10;
                                  }
                                  attr_flag = attr_flag | (unsigned char)0x08;
                                }

                              }

                            }
                          }

                          else
                          {
                            return_value_strncmp$14=strncmp(tag, "</span", (unsigned long int)6);
                            if(return_value_strncmp$14 == 0)
                              attr_flag = attr_flag & (unsigned char)~0x08;

                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          tag = (const char *)(void *)0;
          in_tag = 0;
          goto __CPROVER_DUMP_L79;
        }

      }

      if(in_tag == 0)
      {
        if((signed int)*src == 38)
        {
          in_entity = 1;
          entity = src;
        }

        else
          if(!(in_entity == 0))
          {
            if(!((signed int)*src == 59))
              goto __CPROVER_DUMP_L71;

            in_entity = 0;
            if(!(dst == ((char *)NULL)))
            {
              signed int return_value_strncmp$39;
              return_value_strncmp$39=strncmp(entity, "&lt;", (unsigned long int)4);
              if(return_value_strncmp$39 == 0)
              {
                tmp_post$26 = len;
                len = len + 1ul;
                dst[(signed long int)tmp_post$26] = (char)60;
              }

              else
              {
                return_value_strncmp$38=strncmp(entity, "&gt;", (unsigned long int)4);
                if(return_value_strncmp$38 == 0)
                {
                  tmp_post$27 = len;
                  len = len + 1ul;
                  dst[(signed long int)tmp_post$27] = (char)62;
                }

                else
                {
                  return_value_strncmp$37=strncmp(entity, "&quot;", (unsigned long int)6);
                  if(return_value_strncmp$37 == 0)
                  {
                    tmp_post$28 = len;
                    len = len + 1ul;
                    dst[(signed long int)tmp_post$28] = (char)34;
                  }

                  else
                  {
                    return_value_strncmp$36=strncmp(entity, "&apos;", (unsigned long int)6);
                    if(return_value_strncmp$36 == 0)
                    {
                      tmp_post$29 = len;
                      len = len + 1ul;
                      dst[(signed long int)tmp_post$29] = (char)39;
                    }

                    else
                    {
                      return_value_strncmp$35=strncmp(entity, "&amp;", (unsigned long int)5);
                      if(return_value_strncmp$35 == 0)
                      {
                        tmp_post$30 = len;
                        len = len + 1ul;
                        dst[(signed long int)tmp_post$30] = (char)38;
                      }

                      else
                      {
                        return_value_strncmp$34=strncmp(entity, "&nbsp;", (unsigned long int)6);
                        if(return_value_strncmp$34 == 0)
                        {
                          if((signed int)encoding == GG_ENCODING_UTF8)
                          {
                            tmp_post$31 = len;
                            len = len + 1ul;
                            dst[(signed long int)tmp_post$31] = (char)-62;
                          }

                          tmp_post$32 = len;
                          len = len + 1ul;
                          dst[(signed long int)tmp_post$32] = (char)-96;
                        }

                        else
                        {
                          tmp_post$33 = len;
                          len = len + 1ul;
                          dst[(signed long int)tmp_post$33] = (char)63;
                        }
                      }
                    }
                  }
                }
              }
            }

            else
            {
              signed int return_value_strncmp$40;
              return_value_strncmp$40=strncmp(entity, "&nbsp;", (unsigned long int)6);
              if(return_value_strncmp$40 == 0)
                len = len + (unsigned long int)2;

              else
                len = len + 1ul;
            }
            gg_after_append_formatted_char(&pos, attr_flag, &old_attr_flag, color, old_color, imgs_size, &format, format_len);
          }

          else
          {

          __CPROVER_DUMP_L71:
            ;
            if(!(in_entity == 0))
            {
              return_value___ctype_b_loc$41=__ctype_b_loc();
              if(!((8 & (signed int)(*return_value___ctype_b_loc$41)[(signed long int)(signed int)*src]) == 0))
                tmp_if_expr$42 = (_Bool)1;

              else
                tmp_if_expr$42 = (signed int)*src == 35 ? (_Bool)1 : (_Bool)0;
              if(!tmp_if_expr$42)
                in_entity = 0;

            }

            if(in_entity == 0)
            {
              if(!(dst == ((char *)NULL)))
                dst[(signed long int)len] = *src;

              len = len + 1ul;
              if(!((signed int)encoding == GG_ENCODING_UTF8))
                tmp_if_expr$43 = (_Bool)1;

              else
                tmp_if_expr$43 = ((signed int)*src & 0xc0) != 0x80 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$43)
                gg_after_append_formatted_char(&pos, attr_flag, &old_attr_flag, color, old_color, imgs_size, &format, format_len);

            }

          }
      }

    }

  __CPROVER_DUMP_L79:
    ;
  }
  if(!(dst == ((char *)NULL)))
    dst[(signed long int)len] = (char)0;

  return len;
}

// gg_message_html_to_text_110
// file ../include/message.h line 59
char * gg_message_html_to_text_110(const char *html)
{
  unsigned long int dst_len;
  char *dst;
  unsigned long int return_value_gg_message_html_to_text_110_buff$1;
  return_value_gg_message_html_to_text_110_buff$1=gg_message_html_to_text_110_buff((char *)(void *)0, html);
  dst_len = return_value_gg_message_html_to_text_110_buff$1 + (unsigned long int)1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(dst_len);
  dst = (char *)return_value_malloc$2;
  if(dst == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    gg_message_html_to_text_110_buff(dst, html);
    return dst;
  }
}

// gg_message_html_to_text_110_buff
// file message.c line 940
static unsigned long int gg_message_html_to_text_110_buff(char *dst, const char *html)
{
  unsigned long int return_value_gg_message_html_to_text$1;
  return_value_gg_message_html_to_text$1=gg_message_html_to_text(dst, (unsigned char *)(void *)0, (unsigned long int *)(void *)0, html, (enum anonymous$3)GG_ENCODING_UTF8);
  return return_value_gg_message_html_to_text$1;
}

// gg_message_legacy_text_to_html
// file libgadu.c line 1521
static char * gg_message_legacy_text_to_html(const char *src, enum anonymous$3 encoding, const unsigned char *format, unsigned long int format_len)
{
  unsigned long int len;
  char *dst;
  if(format == ((const unsigned char *)NULL) || !(format_len >= 4ul))
  {
    format = (const unsigned char *)(void *)0;
    format_len = (unsigned long int)0;
  }

  else
  {
    format = format + (signed long int)3;
    format_len = format_len - (unsigned long int)3;
  }
  len=gg_message_text_to_html((char *)(void *)0, src, encoding, format, format_len);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(len + (unsigned long int)1);
  dst = (char *)return_value_malloc$1;
  if(dst == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    gg_message_text_to_html(dst, src, encoding, format, format_len);
    return dst;
  }
}

// gg_message_text_to_html
// file ../include/message.h line 56
unsigned long int gg_message_text_to_html(char *dst, const char *src, enum anonymous$3 encoding, const unsigned char *format, unsigned long int format_len)
{
  const char span_fmt[82l] = { '<', 's', 'p', 'a', 'n', ' ', 's', 't', 'y', 'l', 'e', '=', '"', 'c', 'o', 'l', 'o', 'r', ':', '#', '%', '0', '2', 'x', '%', '0', '2', 'x', '%', '0', '2', 'x', ';', ' ', 'f', 'o', 'n', 't', '-', 'f', 'a', 'm', 'i', 'l', 'y', ':', '\'', 'M', 'S', ' ', 'S', 'h', 'e', 'l', 'l', ' ', 'D', 'l', 'g', ' ', '2', '\'', ';', ' ', 'f', 'o', 'n', 't', '-', 's', 'i', 'z', 'e', ':', '9', 'p', 't', ';', ' ', '"', '>', 0 };
  const unsigned long int span_len = (const unsigned long int)75;
  const char img_fmt[46l] = { '<', 'i', 'm', 'g', ' ', 'n', 'a', 'm', 'e', '=', '"', '%', '0', '2', 'x', '%', '0', '2', 'x', '%', '0', '2', 'x', '%', '0', '2', 'x', '%', '0', '2', 'x', '%', '0', '2', 'x', '%', '0', '2', 'x', '%', '0', '2', 'x', '"', '>', 0 };
  const unsigned long int img_len = (const unsigned long int)29;
  unsigned long int char_pos = (unsigned long int)0;
  unsigned char old_attr = (unsigned char)0;
  const unsigned char default_color[3l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  const unsigned char *old_color = (const unsigned char *)(void *)0;
  signed int in_span = 0;
  unsigned int i;
  unsigned long int len = (unsigned long int)0;
  if(format == ((const unsigned char *)NULL))
    format_len = (unsigned long int)0;

  i = (unsigned int)0;
  _Bool tmp_if_expr$2;
  signed int return_value_memcmp$1;
  do
  {
    signed int in_char = 0;
    unsigned long int format_idx = (unsigned long int)0;
    if((signed int)encoding == GG_ENCODING_UTF8)
    {
      if((0xc0 & (signed int)src[(signed long int)i]) == 0x80)
        in_char = 1;

    }

    if(in_char == 0 && !((0x80 & (signed int)old_attr) == 0))
      old_attr = old_attr & (unsigned char)~0x80;

    do
    {
      unsigned char attr;
      unsigned long int attr_pos;
      if(!(in_char == 0))
        break;

      if(!(format_len >= 3ul + format_idx))
        break;

      /* assertion format != ((void *)0) */
      assert(format != (const unsigned char *)(void *)0);
      attr_pos = (unsigned long int)((signed int)format[(signed long int)format_idx] | (signed int)format[(signed long int)(format_idx + (unsigned long int)1)] << 8);
      attr = format[(signed long int)(format_idx + (unsigned long int)2)];
      if((signed int)src[(signed long int)i] == 0)
        attr = attr & (unsigned char)~(0x01 | 0x02 | 0x04 | 0x08);

      format_idx = format_idx + (unsigned long int)3;
      if(!(attr_pos == char_pos))
      {
        if(!((0x08 & (signed int)attr) == 0))
          format_idx = format_idx + (unsigned long int)3;

        if(!((0x80 & (signed int)attr) == 0))
          format_idx = format_idx + (unsigned long int)10;

      }

      else
      {
        if(!((0x04 & (signed int)old_attr) == 0))
          gg_append(dst, &len, (const void *)"</u>", (unsigned long int)4);

        if(!((0x02 & (signed int)old_attr) == 0))
          gg_append(dst, &len, (const void *)"</i>", (unsigned long int)4);

        if(!((0x01 & (signed int)old_attr) == 0))
          gg_append(dst, &len, (const void *)"</b>", (unsigned long int)4);

        if(!((15 & (signed int)attr) == 0))
        {
          const unsigned char *color;
          if(format_len >= 3ul + format_idx && !((0x08 & (signed int)attr) == 0))
          {
            color = &format[(signed long int)format_idx];
            format_idx = format_idx + (unsigned long int)3;
          }

          else
            color = default_color;
          if(old_color == ((const unsigned char *)NULL))
            tmp_if_expr$2 = (_Bool)1;

          else
          {
            return_value_memcmp$1=memcmp((const void *)color, (const void *)old_color, (unsigned long int)3);
            tmp_if_expr$2 = return_value_memcmp$1 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$2)
          {
            if(!(in_span == 0))
            {
              gg_append(dst, &len, (const void *)"</span>", (unsigned long int)7);
              in_span = 0;
            }

            if(!((signed int)src[(signed long int)i] == 0))
            {
              if(!(dst == ((char *)NULL)))
                sprintf(&dst[(signed long int)len], span_fmt, color[(signed long int)0], color[(signed long int)1], color[(signed long int)2]);

              len = len + span_len;
              in_span = 1;
              old_color = color;
            }

          }

        }

        if(!((0x01 & (signed int)attr) == 0))
          gg_append(dst, &len, (const void *)"<b>", (unsigned long int)3);

        if(!((0x02 & (signed int)attr) == 0))
          gg_append(dst, &len, (const void *)"<i>", (unsigned long int)3);

        if(!((0x04 & (signed int)attr) == 0))
          gg_append(dst, &len, (const void *)"<u>", (unsigned long int)3);

        if(format_len >= 10ul + format_idx && !((0x80 & (signed int)attr) == 0))
        {
          if(!(dst == ((char *)NULL)))
            sprintf(&dst[(signed long int)len], img_fmt, format[(signed long int)(format_idx + (unsigned long int)9)], format[(signed long int)(format_idx + (unsigned long int)8)], format[(signed long int)(format_idx + (unsigned long int)7)], format[(signed long int)(format_idx + (unsigned long int)6)], format[(signed long int)(format_idx + (unsigned long int)5)], format[(signed long int)(format_idx + (unsigned long int)4)], format[(signed long int)(format_idx + (unsigned long int)3)], format[(signed long int)(format_idx + (unsigned long int)2)]);

          len = len + img_len;
          format_idx = format_idx + (unsigned long int)10;
        }

        old_attr = attr;
      }
    }
    while((_Bool)1);
    if((signed int)src[(signed long int)i] == 0)
      break;

    if(!((0x80 & (signed int)old_attr) == 0))
    {
      if(in_char == 0)
        char_pos = char_pos + 1ul;

    }

    else
    {
      if(in_span == 0)
      {
        if(!(dst == ((char *)NULL)))
          sprintf(&dst[(signed long int)len], span_fmt, default_color[(signed long int)0], default_color[(signed long int)1], default_color[(signed long int)2]);

        len = len + span_len;
        in_span = 1;
        old_color = default_color;
      }

      switch((signed int)src[(signed long int)i])
      {
        case 38:
        {
          gg_append(dst, &len, (const void *)"&amp;", (unsigned long int)5);
          break;
        }
        case 60:
        {
          gg_append(dst, &len, (const void *)"&lt;", (unsigned long int)4);
          break;
        }
        case 62:
        {
          gg_append(dst, &len, (const void *)"&gt;", (unsigned long int)4);
          break;
        }
        case 39:
        {
          gg_append(dst, &len, (const void *)"&apos;", (unsigned long int)6);
          break;
        }
        case 34:
        {
          gg_append(dst, &len, (const void *)"&quot;", (unsigned long int)6);
          break;
        }
        case 10:
        {
          gg_append(dst, &len, (const void *)"<br>", (unsigned long int)4);
          break;
        }
        case 13:
          break;
        default:
        {
          if(!(dst == ((char *)NULL)))
            dst[(signed long int)len] = src[(signed long int)i];

          len = len + 1ul;
        }
      }
      if(in_char == 0)
        char_pos = char_pos + 1ul;

    }
    i = i + 1u;
  }
  while((_Bool)1);
  if(!((0x04 & (signed int)old_attr) == 0))
    gg_append(dst, &len, (const void *)"</u>", (unsigned long int)4);

  if(!((0x02 & (signed int)old_attr) == 0))
    gg_append(dst, &len, (const void *)"</i>", (unsigned long int)4);

  if(!((0x01 & (signed int)old_attr) == 0))
    gg_append(dst, &len, (const void *)"</b>", (unsigned long int)4);

  if(!(in_span == 0))
    gg_append(dst, &len, (const void *)"</span>", (unsigned long int)7);

  if(!(dst == ((char *)NULL)))
    dst[(signed long int)len] = (char)0;

  return len;
}

// gg_message_text_to_html_110
// file ../include/message.h line 60
char * gg_message_text_to_html_110(const char *text, signed long int text_len)
{
  unsigned long int dst_len;
  char *dst;
  unsigned long int return_value_gg_message_text_to_html_110_buff$1;
  return_value_gg_message_text_to_html_110_buff$1=gg_message_text_to_html_110_buff((char *)(void *)0, text, text_len);
  dst_len = return_value_gg_message_text_to_html_110_buff$1 + (unsigned long int)1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(dst_len);
  dst = (char *)return_value_malloc$2;
  if(dst == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    gg_message_text_to_html_110_buff(dst, text, text_len);
    return dst;
  }
}

// gg_message_text_to_html_110_buff
// file message.c line 945
static unsigned long int gg_message_text_to_html_110_buff(char *dst, const char *text, signed long int text_len)
{
  unsigned long int i;
  unsigned long int dst_len;
  unsigned long int return_value_strlen$1;
  if(text_len == -1l)
  {
    return_value_strlen$1=strlen(text);
    text_len = (signed long int)return_value_strlen$1;
  }

  dst_len = (unsigned long int)0;
  gg_append(dst, &dst_len, (const void *)"<span>", (unsigned long int)6);
  i = (unsigned long int)0;
  _Bool tmp_if_expr$2;
  for( ; !(i >= (unsigned long int)text_len); i = i + 1ul)
  {
    char c = text[(signed long int)i];
    if((signed int)c == 60)
      gg_append(dst, &dst_len, (const void *)"&lt;", (unsigned long int)4);

    else
      if((signed int)c == 62)
        gg_append(dst, &dst_len, (const void *)"&gt;", (unsigned long int)4);

      else
        if((signed int)c == 38)
          gg_append(dst, &dst_len, (const void *)"&amp;", (unsigned long int)5);

        else
          if((signed int)c == 34)
            gg_append(dst, &dst_len, (const void *)"&quot;", (unsigned long int)6);

          else
            if((signed int)c == 39)
              gg_append(dst, &dst_len, (const void *)"&apos;", (unsigned long int)6);

            else
              if((signed int)c == 10)
                gg_append(dst, &dst_len, (const void *)"<br>", (unsigned long int)4);

              else
                if((signed int)c == 13)
                  goto __CPROVER_DUMP_L15;

                else
                {
                  if((signed int)c == -62)
                    tmp_if_expr$2 = (signed int)text[(signed long int)(i + (unsigned long int)1)] == -96 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$2 = (_Bool)0;
                  if(tmp_if_expr$2)
                  {
                    gg_append(dst, &dst_len, (const void *)"&nbsp;", (unsigned long int)6);
                    i = i + 1ul;
                  }

                  else
                  {
                    if(!(dst == ((char *)NULL)))
                      dst[(signed long int)dst_len] = c;

                    dst_len = dst_len + 1ul;
                  }
                }

  __CPROVER_DUMP_L15:
    ;
  }
  gg_append(dst, &dst_len, (const void *)"</span>", (unsigned long int)7);
  if(!(dst == ((char *)NULL)))
    dst[(signed long int)dst_len] = (char)0;

  return dst_len;
}

// gg_multilogon_disconnect
// file libgadu.c line 2669
signed int gg_multilogon_disconnect(struct gg_session *gs, struct anonymous$9 conn_id)
{
  struct gg_multilogon_disconnect pkt;
  pkt.conn_id = conn_id;
  signed int return_value_gg_send_packet$1;
  return_value_gg_send_packet$1=gg_send_packet(gs, 0x0062, &pkt, sizeof(struct gg_multilogon_disconnect) /*8ul*/ , (void *)0);
  return return_value_gg_send_packet$1;
}

// gg_new0
// file ../include/internal.h line 156
void * gg_new0(unsigned long int size)
{
  void *ptr;
  ptr=malloc(size);
  if(ptr == NULL)
  {
    gg_debug(16 | 128, "//gg_new0(%zu) not enough memory\n", size);
    return (void *)0;
  }

  else
  {
    memset(ptr, 0, size);
    return ptr;
  }
}

// gg_notify
// file libgadu.c line 2373
signed int gg_notify(struct gg_session *sess, unsigned int *userlist, signed int count)
{
  signed int return_value_gg_notify_ex$1;
  return_value_gg_notify_ex$1=gg_notify_ex(sess, userlist, (char *)(void *)0, count);
  return return_value_gg_notify_ex$1;
}

// gg_notify105_ex
// file libgadu.c line 2240
static signed int gg_notify105_ex(struct gg_session *sess, unsigned int *userlist, char *types, signed int count)
{
  signed int i = 0;
  signed int return_value_gg_send_packet$1;
  signed int tmp_if_expr$2;
  if(userlist == ((unsigned int *)NULL) || count == 0)
  {
    return_value_gg_send_packet$1=gg_send_packet(sess, 0x0079, (void *)0);
    return return_value_gg_send_packet$1;
  }

  else
  {
    while(!(i >= count))
    {
      struct gg_tvbuilder *tvb;
      tvb=gg_tvbuilder_new(sess, (struct gg_event *)(void *)0);
      gg_tvbuilder_expected_size(tvb, (unsigned long int)2100);
      while(!(i >= count))
      {
        unsigned long int prev_size;
        prev_size=gg_tvbuilder_get_size(tvb);
        gg_tvbuilder_write_uin(tvb, userlist[(signed long int)i]);
        if(types == ((char *)NULL))
          tmp_if_expr$2 = 0x03;

        else
          tmp_if_expr$2 = (signed int)types[(signed long int)i];
        gg_tvbuilder_write_uint8(tvb, (unsigned char)tmp_if_expr$2);
        unsigned long int return_value_gg_tvbuilder_get_size$3;
        return_value_gg_tvbuilder_get_size$3=gg_tvbuilder_get_size(tvb);
        if(return_value_gg_tvbuilder_get_size$3 >= 2049ul)
        {
          gg_tvbuilder_strip(tvb, prev_size);
          break;
        }

        i = i + 1;
      }
      signed int return_value_gg_tvbuilder_send$4;
      return_value_gg_tvbuilder_send$4=gg_tvbuilder_send(tvb, i < count ? 0x0077 : 0x0078);
      if(return_value_gg_tvbuilder_send$4 == 0)
        return -1;

    }
    return 0;
  }
}

// gg_notify_ex
// file libgadu.c line 2297
signed int gg_notify_ex(struct gg_session *sess, unsigned int *userlist, char *types, signed int count)
{
  struct gg_notify *n;
  signed int i;
  signed int res = 0;
  gg_debug_session(sess, 8, "** gg_notify_ex(%p, %p, %p, %d);\n", sess, userlist, types, count);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  signed int return_value_gg_notify105_ex$3;
  signed int return_value_gg_send_packet$4;
  if(sess->protocol_version >= 0x40)
  {
    return_value_gg_notify105_ex$3=gg_notify105_ex(sess, userlist, types, count);
    return return_value_gg_notify105_ex$3;
  }

  else
    if(userlist == ((unsigned int *)NULL) || count == 0)
    {
      return_value_gg_send_packet$4=gg_send_packet(sess, 0x0012, (void *)0);
      return return_value_gg_send_packet$4;
    }

    else
    {
      while(count >= 1)
      {
        signed int part_count;
        signed int packet_type;
        if(count >= 401)
        {
          part_count = 400;
          packet_type = 0x000f;
        }

        else
        {
          part_count = count;
          packet_type = 0x0010;
        }
        void *return_value_malloc$5;
        return_value_malloc$5=malloc(sizeof(struct gg_notify) /*5ul*/  * (unsigned long int)part_count);
        n = (struct gg_notify *)return_value_malloc$5;
        if(n == ((struct gg_notify *)NULL))
          return -1;

        i = 0;
        for( ; !(i >= part_count); i = i + 1)
        {
          (n + (signed long int)i)->uin=gg_fix32(userlist[(signed long int)i]);
          if(types == ((char *)NULL))
            (n + (signed long int)i)->dunno1 = (unsigned char)0x03;

          else
            (n + (signed long int)i)->dunno1 = (unsigned char)types[(signed long int)i];
        }
        signed int return_value_gg_send_packet$6;
        return_value_gg_send_packet$6=gg_send_packet(sess, packet_type, n, sizeof(struct gg_notify) /*5ul*/  * (unsigned long int)part_count, (void *)0);
        if(return_value_gg_send_packet$6 == -1)
        {
          free((void *)n);
          res = -1;
          break;
        }

        count = count - part_count;
        userlist = userlist + (signed long int)part_count;
        if(!(types == ((char *)NULL)))
          types = types + (signed long int)part_count;

        free((void *)n);
      }
      return res;
    }
}

// gg_ping
// file libgadu.c line 1147
signed int gg_ping(struct gg_session *sess)
{
  gg_debug_session(sess, 8, "** gg_ping(%p);\n", sess);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  signed int return_value_gg_send_packet$3;
  return_value_gg_send_packet$3=gg_send_packet(sess, 0x0008, (void *)0);
  return return_value_gg_send_packet$3;
}

// gg_protobuf_expected
// file ../include/protobuf.h line 55
void gg_protobuf_expected(struct gg_session *gs, const char *field_name, unsigned int value, unsigned int expected)
{
  if(!(value == expected))
    gg_debug_session(gs, 64, "// gg_packet: field %s was expected to be %#x, but its value was %#x\n", field_name, expected, value);

}

// gg_protobuf_get_uin
// file ../include/protobuf.h line 68
unsigned int gg_protobuf_get_uin(struct ProtobufCBinaryData uin_data)
{
  unsigned char magic;
  unsigned long int uin_len;
  const char *uin_str;
  unsigned int uin;
  signed int tmp_if_expr$1;
  if(uin_data.len >= 1ul)
    tmp_if_expr$1 = (signed int)uin_data.data[(signed long int)0];

  else
    tmp_if_expr$1 = 0;
  magic = (unsigned char)tmp_if_expr$1;
  signed int tmp_if_expr$2;
  if(uin_data.len >= 2ul)
    tmp_if_expr$2 = (signed int)uin_data.data[(signed long int)1];

  else
    tmp_if_expr$2 = 0;
  uin_len = (unsigned long int)tmp_if_expr$2;
  if(uin_len >= 11ul || !(uin_data.len == 2ul + uin_len))
  {
    gg_debug(128, "// gg_protobuf_get_uin: invalid length\n");
    return (unsigned int)0;
  }

  else
  {
    if(!((signed int)magic == 0))
      gg_debug(64, "// gg_protobuf_get_uin: unexpected magic value=%#x\n", magic);

    uin_str = (char *)(uin_data.data + (signed long int)2);
    uin=gg_str_to_uin(uin_str, (signed int)uin_len);
    if(uin == 0u)
      gg_debug(128, "// gg_protobuf_get_uin: invalid uin\n");

    return uin;
  }
}

// gg_protobuf_send_ex
// file ../include/protobuf.h line 63
signed int gg_protobuf_send_ex(struct gg_session *gs, struct gg_event *ge, signed int type, void *msg, unsigned long int (*size_cb)(const void *), unsigned long int (*pack_cb)(const void *, unsigned char *))
{
  void *buffer;
  unsigned long int len;
  signed int succ = 1;
  enum gg_failure_t gg_protobuf_send_ex$$1$$failure;
  len=size_cb(msg);
  buffer=malloc(len);
  if(buffer == NULL)
  {
    gg_debug_session(gs, 128, "// gg_protobuf_send: out of memory - tried to allocate %zu bytes for %#x packet\n", len, type);
    succ = 0;
    gg_protobuf_send_ex$$1$$failure = (enum gg_failure_t)GG_FAILURE_INTERNAL;
  }

  else
  {
    pack_cb(msg, (unsigned char *)buffer);
    signed int return_value_gg_send_packet$1;
    return_value_gg_send_packet$1=gg_send_packet(gs, type, buffer, len, (void *)0);
    succ = (signed int)(-1 != return_value_gg_send_packet$1);
    free(buffer);
    buffer = (void *)0;
    if(succ == 0)
    {
      gg_protobuf_send_ex$$1$$failure = (enum gg_failure_t)GG_FAILURE_WRITING;
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      gg_debug_session(gs, 128, "// gg_protobuf_send: sending packet %#x failed. (errno=%d, %s)\n", type, *return_value___errno_location$2, return_value_strerror$4);
    }

  }
  if(succ == 0)
    gg_connection_failure(gs, ge, gg_protobuf_send_ex$$1$$failure);

  return succ;
}

// gg_protobuf_set_uin
// file ../include/protobuf.h line 67
void gg_protobuf_set_uin(struct ProtobufCBinaryData *dst, unsigned int uin, struct _gg_protobuf_uin_buff *buff)
{
  char *uin_str;
  signed int uin_len;
  static struct _gg_protobuf_uin_buff static_buffer;
  if(buff == ((struct _gg_protobuf_uin_buff *)NULL))
    buff = &static_buffer;

  uin_str = buff->data + (signed long int)2;
  uin_len=snprintf(uin_str, (unsigned long int)(15 + 1), "%u", uin);
  buff->data[(signed long int)0] = (char)0x01;
  buff->data[(signed long int)1] = (char)uin_len;
  dst->len = (unsigned long int)(uin_len + 2);
  dst->data = (unsigned char *)&buff->data;
}

// gg_protobuf_valid_chknull
// file ../include/protobuf.h line 58
signed int gg_protobuf_valid_chknull(struct gg_session *gs, const char *msg_name, signed int isNull)
{
  if(!(isNull == 0))
    gg_debug_session(gs, 128, "// gg_protobuf: couldn't unpack %s message\n", msg_name);

  return (signed int)!(isNull != 0);
}

// gg_protobuf_valid_chkunknown
// file ../include/protobuf.h line 60
signed int gg_protobuf_valid_chkunknown(struct gg_session *gs, const char *msg_name, struct ProtobufCMessage *base)
{
  if(base->n_unknown_fields >= 1u)
    gg_debug_session(gs, 64, "// gg_protobuf: message %s had %d unknown field(s)\n", msg_name, base->n_unknown_fields);

  return 1;
}

// gg_proxy_auth
// file common.c line 572
char * gg_proxy_auth(void)
{
  char *tmp;
  char *enc;
  char *out;
  unsigned int tmp_size;
  if(gg_proxy_password == ((char *)NULL) || gg_proxy_username == ((char *)NULL) || gg_proxy_enabled == 0)
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(gg_proxy_username);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(gg_proxy_password);
    tmp_size = (unsigned int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)2);
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)tmp_size);
    tmp = (char *)return_value_malloc$3;
    if(tmp == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      snprintf(tmp, (unsigned long int)tmp_size, "%s:%s", gg_proxy_username, gg_proxy_password);
      enc=gg_base64_encode(tmp);
      if(enc == ((char *)NULL))
      {
        free((void *)tmp);
        return (char *)(void *)0;
      }

      else
      {
        free((void *)tmp);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(enc);
        void *return_value_malloc$5;
        return_value_malloc$5=malloc(return_value_strlen$4 + (unsigned long int)40);
        out = (char *)return_value_malloc$5;
        if(out == ((char *)NULL))
        {
          free((void *)enc);
          return (char *)(void *)0;
        }

        else
        {
          unsigned long int return_value_strlen$6;
          return_value_strlen$6=strlen(enc);
          snprintf(out, return_value_strlen$6 + (unsigned long int)40, "Proxy-Authorization: Basic %s\r\n", enc);
          free((void *)enc);
          return out;
        }
      }
    }
  }
}

// gg_pubdir50
// file pubdir50.c line 199
unsigned int gg_pubdir50(struct gg_session *sess, struct gg_pubdir50_s *req)
{
  signed int i;
  signed int size = 5;
  unsigned int res;
  char *buf;
  char *p;
  struct gg_pubdir50_request *r;
  gg_debug_session(sess, 8, "** gg_pubdir50(%p, %p);\n", sess, req);
  if(req == ((struct gg_pubdir50_s *)NULL) || sess == ((struct gg_session *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_pubdir50() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (unsigned int)0;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    gg_debug_session(sess, 16, "// gg_pubdir50() not connected\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return (unsigned int)0;
  }

  i = 0;
  for( ; !(i >= req->entries_count); i = i + 1)
    if((req->entries + (signed long int)i)->num == 0)
    {
      if((signed int)sess->encoding == GG_ENCODING_CP1250)
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen((req->entries + (signed long int)i)->field);
        size = size + (signed int)(return_value_strlen$3 + (unsigned long int)1);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen((req->entries + (signed long int)i)->value);
        size = size + (signed int)(return_value_strlen$4 + (unsigned long int)1);
      }

      else
      {
        char *tmp;
        tmp=gg_encoding_convert((req->entries + (signed long int)i)->field, sess->encoding, (enum anonymous$3)GG_ENCODING_CP1250, -1, -1);
        if(tmp == ((char *)NULL))
          return (unsigned int)-1;

        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(tmp);
        size = size + (signed int)(return_value_strlen$5 + (unsigned long int)1);
        free((void *)tmp);
        tmp=gg_encoding_convert((req->entries + (signed long int)i)->value, sess->encoding, (enum anonymous$3)GG_ENCODING_CP1250, -1, -1);
        if(tmp == ((char *)NULL))
          return (unsigned int)-1;

        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(tmp);
        size = size + (signed int)(return_value_strlen$6 + (unsigned long int)1);
        free((void *)tmp);
      }
    }

  void *return_value_malloc$7;
  return_value_malloc$7=malloc((unsigned long int)size);
  buf = (char *)return_value_malloc$7;
  signed long int return_value_time$8;
  if(buf == ((char *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_pubdir50() out of memory (%d bytes)\n", size);
    return (unsigned int)0;
  }

  else
  {
    if(req->seq == 0u)
    {
      return_value_time$8=time((signed long int *)(void *)0);
      req->seq = (unsigned int)return_value_time$8;
    }

    res = req->seq;
    r = (struct gg_pubdir50_request *)buf;
    r->type = (unsigned char)req->type;
    r->seq=gg_fix32(req->seq);
    i = 0;
    p = buf + (signed long int)5;
    for( ; !(i >= req->entries_count); i = i + 1)
      if((req->entries + (signed long int)i)->num == 0)
      {
        if((signed int)sess->encoding == GG_ENCODING_CP1250)
        {
          strcpy(p, (req->entries + (signed long int)i)->field);
          unsigned long int return_value_strlen$9;
          return_value_strlen$9=strlen(p);
          p = p + (signed long int)(return_value_strlen$9 + (unsigned long int)1);
          strcpy(p, (req->entries + (signed long int)i)->value);
          unsigned long int return_value_strlen$10;
          return_value_strlen$10=strlen(p);
          p = p + (signed long int)(return_value_strlen$10 + (unsigned long int)1);
        }

        else
        {
          char *gg_pubdir50$$1$$5$$1$$2$$tmp;
          gg_pubdir50$$1$$5$$1$$2$$tmp=gg_encoding_convert((req->entries + (signed long int)i)->field, sess->encoding, (enum anonymous$3)GG_ENCODING_CP1250, -1, -1);
          if(gg_pubdir50$$1$$5$$1$$2$$tmp == ((char *)NULL))
          {
            free((void *)buf);
            return (unsigned int)-1;
          }

          strcpy(p, gg_pubdir50$$1$$5$$1$$2$$tmp);
          unsigned long int return_value_strlen$11;
          return_value_strlen$11=strlen(gg_pubdir50$$1$$5$$1$$2$$tmp);
          p = p + (signed long int)(return_value_strlen$11 + (unsigned long int)1);
          free((void *)gg_pubdir50$$1$$5$$1$$2$$tmp);
          gg_pubdir50$$1$$5$$1$$2$$tmp=gg_encoding_convert((req->entries + (signed long int)i)->value, sess->encoding, (enum anonymous$3)GG_ENCODING_CP1250, -1, -1);
          if(gg_pubdir50$$1$$5$$1$$2$$tmp == ((char *)NULL))
          {
            free((void *)buf);
            return (unsigned int)-1;
          }

          strcpy(p, gg_pubdir50$$1$$5$$1$$2$$tmp);
          unsigned long int return_value_strlen$12;
          return_value_strlen$12=strlen(gg_pubdir50$$1$$5$$1$$2$$tmp);
          p = p + (signed long int)(return_value_strlen$12 + (unsigned long int)1);
          free((void *)gg_pubdir50$$1$$5$$1$$2$$tmp);
        }
      }

    signed int return_value_gg_send_packet$13;
    return_value_gg_send_packet$13=gg_send_packet(sess, 0x0014, buf, size, (void *)0, 0);
    if(return_value_gg_send_packet$13 == -1)
      res = (unsigned int)0;

    free((void *)buf);
    return res;
  }
}

// gg_pubdir50_add
// file pubdir50.c line 136
signed int gg_pubdir50_add(struct gg_pubdir50_s *req, const char *field, const char *value)
{
  signed int return_value_gg_pubdir50_add_n$1;
  return_value_gg_pubdir50_add_n$1=gg_pubdir50_add_n(req, 0, field, value);
  return return_value_gg_pubdir50_add_n$1;
}

// gg_pubdir50_add_n
// file pubdir50.c line 77
static signed int gg_pubdir50_add_n(struct gg_pubdir50_s *req, signed int num, const char *field, const char *value)
{
  struct gg_pubdir50_entry *tmp = (struct gg_pubdir50_entry *)(void *)0;
  struct gg_pubdir50_entry *entry;
  char *dupfield;
  char *dupvalue;
  signed int i;
  gg_debug(8, "** gg_pubdir50_add_n(%p, %d, \"%s\", \"%s\");\n", req, num, field, value);
  dupvalue=strdup(value);
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(dupvalue == ((char *)NULL))
  {
    gg_debug(16, "// gg_pubdir50_add_n() out of memory\n");
    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= req->entries_count); i = i + 1)
    {
      if(!((req->entries + (signed long int)i)->num == num))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_strcmp$1=strcmp((req->entries + (signed long int)i)->field, field);
        tmp_if_expr$2 = return_value_strcmp$1 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$2)
      {
        free((void *)(req->entries + (signed long int)i)->value);
        (req->entries + (signed long int)i)->value = dupvalue;
        return 0;
      }

    }
    dupfield=strdup(field);
    if(dupfield == ((char *)NULL))
    {
      gg_debug(16, "// gg_pubdir50_add_n() out of memory\n");
      free((void *)dupvalue);
      return -1;
    }

    else
    {
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)req->entries, sizeof(struct gg_pubdir50_entry) /*24ul*/  * (unsigned long int)(req->entries_count + 1));
      tmp = (struct gg_pubdir50_entry *)return_value_realloc$3;
      if(tmp == ((struct gg_pubdir50_entry *)NULL))
      {
        gg_debug(16, "// gg_pubdir50_add_n() out of memory\n");
        free((void *)dupfield);
        free((void *)dupvalue);
        return -1;
      }

      else
      {
        req->entries = tmp;
        entry = &req->entries[(signed long int)req->entries_count];
        entry->num = num;
        entry->field = dupfield;
        entry->value = dupvalue;
        req->entries_count = req->entries_count + 1;
        return 0;
      }
    }
  }
}

// gg_pubdir50_count
// file pubdir50.c line 495
signed int gg_pubdir50_count(struct gg_pubdir50_s *res)
{
  signed int tmp_if_expr$1;
  if(res == ((struct gg_pubdir50_s *)NULL))
    tmp_if_expr$1 = -1;

  else
    tmp_if_expr$1 = res->count;
  return tmp_if_expr$1;
}

// gg_pubdir50_free
// file ../include/libgadu.h line 1391
void gg_pubdir50_free(struct gg_pubdir50_s *s)
{
  signed int i;
  if(!(s == ((struct gg_pubdir50_s *)NULL)))
  {
    i = 0;
    for( ; !(i >= s->entries_count); i = i + 1)
    {
      free((void *)(s->entries + (signed long int)i)->field);
      free((void *)(s->entries + (signed long int)i)->value);
    }
    free((void *)s->entries);
    free((void *)s);
  }

}

// gg_pubdir50_get
// file pubdir50.c line 463
const char * gg_pubdir50_get(struct gg_pubdir50_s *res, signed int num, const char *field)
{
  char *value = (char *)(void *)0;
  signed int i;
  gg_debug(8, "** gg_pubdir50_get(%p, %d, \"%s\");\n", res, num, field);
  if(field == ((const char *)NULL) || res == ((struct gg_pubdir50_s *)NULL) || !(num >= 0))
  {
    gg_debug(16, "// gg_pubdir50_get() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (const char *)(void *)0;
  }

  i = 0;
  signed int return_value_strcasecmp$2;
  for( ; !(i >= res->entries_count); i = i + 1)
    if((res->entries + (signed long int)i)->num == num)
    {
      return_value_strcasecmp$2=strcasecmp((res->entries + (signed long int)i)->field, field);
      if(return_value_strcasecmp$2 == 0)
      {
        value = (res->entries + (signed long int)i)->value;
        break;
      }

    }

  return value;
}

// gg_pubdir50_handle_reply
// file obsolete.c line 239
signed int gg_pubdir50_handle_reply(struct gg_event *e, const char *packet, signed int length)
{
  return -1;
}

// gg_pubdir50_handle_reply_sess
// file ../include/internal.h line 162
signed int gg_pubdir50_handle_reply_sess(struct gg_session *sess, struct gg_event *e, const char *packet, signed int length)
{
  const char *end = packet + (signed long int)length;
  const char *p;
  struct gg_pubdir50_reply *r = (struct gg_pubdir50_reply *)packet;
  struct gg_pubdir50_s *res;
  signed int num = 0;
  gg_debug(8, "** gg_pubdir50_handle_reply_sess(%p, %p, %p, %d);\n", sess, e, packet, length);
  if(packet == ((const char *)NULL) || e == ((struct gg_event *)NULL) || sess == ((struct gg_session *)NULL))
  {
    gg_debug(16, "// gg_pubdir50_handle_reply() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(length >= 5))
  {
    gg_debug(16, "// gg_pubdir50_handle_reply() packet too short\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return -1;
  }

  res=gg_pubdir50_new((signed int)r->type);
  signed int tmp_if_expr$4;
  signed int return_value_atoi$3;
  if(res == ((struct gg_pubdir50_s *)NULL))
  {
    gg_debug(16, "// gg_pubdir50_handle_reply() unable to allocate reply\n");
    return -1;
  }

  else
  {
    e->event.pubdir50 = res;
    res->seq=gg_fix32(r->seq);
    switch(res->type)
    {
      case 0x02:
      {
        e->type = GG_EVENT_PUBDIR50_READ;
        break;
      }
      case 0x01:
      {
        e->type = GG_EVENT_PUBDIR50_WRITE;
        break;
      }
      default:
        e->type = GG_EVENT_PUBDIR50_SEARCH_REPLY;
    }
    if(length == 5)
      return 0;

    else
    {
      p = packet + (signed long int)5;
      while(!(p >= end))
      {
        const char *field;
        const char *value;
        field = p;
        if(*field == 0)
        {
          num = num + 1;
          field = field + 1l;
        }

        value = (const char *)(void *)0;
        p = field;
        for( ; !(p >= end); p = p + 1l)
          if(*p == 0)
          {
            if(value == ((const char *)NULL))
              value = p + (signed long int)1;

            else
              break;
          }

        if(p == end)
        {
          gg_debug(16, "// gg_pubdir50_handle_reply() premature end of packet\n");
          goto failure;
        }

        p = p + 1l;
        signed int return_value_strcasecmp$7;
        return_value_strcasecmp$7=strcasecmp(field, "nextstart");
        if(return_value_strcasecmp$7 == 0)
        {
          if(!(value == ((const char *)NULL)))
          {
            return_value_atoi$3=atoi(value);
            tmp_if_expr$4 = return_value_atoi$3;
          }

          else
            tmp_if_expr$4 = 0;
          res->next = (unsigned int)tmp_if_expr$4;
          num = num - 1;
        }

        else
          if((signed int)sess->encoding == GG_ENCODING_CP1250)
          {
            signed int return_value_gg_pubdir50_add_n$5;
            return_value_gg_pubdir50_add_n$5=gg_pubdir50_add_n(res, num, field, value);
            if(return_value_gg_pubdir50_add_n$5 == -1)
              goto failure;

          }

          else
          {
            char *tmp;
            tmp=gg_encoding_convert(value, (enum anonymous$3)GG_ENCODING_CP1250, sess->encoding, -1, -1);
            if(tmp == ((char *)NULL))
              goto failure;

            signed int return_value_gg_pubdir50_add_n$6;
            return_value_gg_pubdir50_add_n$6=gg_pubdir50_add_n(res, num, field, tmp);
            if(return_value_gg_pubdir50_add_n$6 == -1)
            {
              free((void *)tmp);
              goto failure;
            }

            free((void *)tmp);
          }
      }
      res->count = num + 1;
      return 0;

    failure:
      ;
      gg_pubdir50_free(res);
      return -1;
    }
  }
}

// gg_pubdir50_new
// file pubdir50.c line 48
struct gg_pubdir50_s * gg_pubdir50_new(signed int type)
{
  struct gg_pubdir50_s *res;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct gg_pubdir50_s) /*32ul*/ );
  res = (struct gg_pubdir50_s *)return_value_malloc$1;
  gg_debug(8, "** gg_pubdir50_new(%d);\n", type);
  if(res == ((struct gg_pubdir50_s *)NULL))
  {
    gg_debug(16, "// gg_pubdir50_new() out of memory\n");
    return (struct gg_pubdir50_s *)(void *)0;
  }

  else
  {
    memset((void *)res, 0, sizeof(struct gg_pubdir50_s) /*32ul*/ );
    res->type = type;
    return res;
  }
}

// gg_pubdir50_next
// file pubdir50.c line 528
unsigned int gg_pubdir50_next(struct gg_pubdir50_s *res)
{
  unsigned int tmp_if_expr$1;
  if(res == ((struct gg_pubdir50_s *)NULL))
    tmp_if_expr$1 = (unsigned int)-1;

  else
    tmp_if_expr$1 = res->next;
  return tmp_if_expr$1;
}

// gg_pubdir50_seq
// file pubdir50.c line 542
unsigned int gg_pubdir50_seq(struct gg_pubdir50_s *res)
{
  unsigned int tmp_if_expr$1;
  if(res == ((struct gg_pubdir50_s *)NULL))
    tmp_if_expr$1 = (unsigned int)-1;

  else
    tmp_if_expr$1 = res->seq;
  return tmp_if_expr$1;
}

// gg_pubdir50_seq_set
// file pubdir50.c line 151
signed int gg_pubdir50_seq_set(struct gg_pubdir50_s *req, unsigned int seq)
{
  gg_debug(8, "** gg_pubdir50_seq_set(%p, %d);\n", req, seq);
  if(req == ((struct gg_pubdir50_s *)NULL))
  {
    gg_debug(16, "// gg_pubdir50_seq_set() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  req->seq = seq;
  return 0;
}

// gg_pubdir50_type
// file pubdir50.c line 509
signed int gg_pubdir50_type(struct gg_pubdir50_s *res)
{
  signed int tmp_if_expr$1;
  if(res == ((struct gg_pubdir50_s *)NULL))
    tmp_if_expr$1 = -1;

  else
    tmp_if_expr$1 = res->type;
  return tmp_if_expr$1;
}

// gg_pubdir_free
// file pubdir.c line 663
void gg_pubdir_free(struct gg_http *h)
{
  if(!(h == ((struct gg_http *)NULL)))
  {
    free(h->data);
    gg_http_free(h);
  }

}

// gg_pubdir_watch_fd
// file pubdir.c line 591
signed int gg_pubdir_watch_fd(struct gg_http *h)
{
  struct gg_pubdir *p;
  char *tmp;
  if(h == ((struct gg_http *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(h->state == GG_STATE_ERROR)
  {
    gg_debug(16, "=> pubdir, watch_fd issued on failed session\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return -1;
  }

  if(!(h->state == GG_STATE_PARSING))
  {
    signed int return_value_gg_http_watch_fd$4;
    return_value_gg_http_watch_fd$4=gg_http_watch_fd(h);
    if(return_value_gg_http_watch_fd$4 == -1)
    {
      gg_debug(16, "=> pubdir, http failure\n");
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      return -1;
    }

  }

  _Bool tmp_if_expr$13;
  signed long int return_value_strtol$7;
  signed int return_value_strncmp$10;
  _Bool tmp_if_expr$12;
  signed int return_value_strncmp$11;
  signed int return_value_strncmp$9;
  signed int return_value_strncmp$8;
  if(!(h->state == GG_STATE_PARSING))
    return 0;

  else
  {
    h->state = GG_STATE_DONE;
    void *return_value_malloc$5;
    return_value_malloc$5=malloc(sizeof(struct gg_pubdir) /*12ul*/ );
    p = (struct gg_pubdir *)return_value_malloc$5;
    h->data = (void *)p;
    if(h->data == NULL)
    {
      gg_debug(16, "=> pubdir, not enough memory for results\n");
      return -1;
    }

    else
    {
      p->success = 0;
      p->uin = (unsigned int)0;
      gg_debug(16, "=> pubdir, let's parse \"%s\"\n", h->body);
      tmp=strstr(h->body, "Tokens okregisterreply_packet.reg.dwUserId=");
      if(!(tmp == ((char *)NULL)))
      {
        p->success = 1;
        signed long int return_value_strtol$6;
        return_value_strtol$6=strtol((tmp + (signed long int)sizeof(char [44l]) /*44ul*/ ) - (signed long int)1, (char ** restrict )(void *)0, 0);
        p->uin = (unsigned int)return_value_strtol$6;
        p->error = (enum anonymous$21)GG_PUBDIR_ERROR_NONE;
        gg_debug(16, "=> pubdir, success (okregisterreply, uin=%d)\n", p->uin);
      }

      else
      {
        tmp=strstr(h->body, "success");
        if(!(tmp == ((char *)NULL)))
          tmp_if_expr$13 = (_Bool)1;

        else
        {
          tmp=strstr(h->body, "results");
          tmp_if_expr$13 = tmp != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$13)
        {
          p->success = 1;
          if((signed int)tmp[7l] == 58)
          {
            return_value_strtol$7=strtol(tmp + (signed long int)8, (char ** restrict )(void *)0, 0);
            p->uin = (unsigned int)return_value_strtol$7;
          }

          p->error = (enum anonymous$21)GG_PUBDIR_ERROR_NONE;
          gg_debug(16, "=> pubdir, success (uin=%d)\n", p->uin);
        }

        else
        {
          return_value_strncmp$10=strncmp(h->body, "error1", (unsigned long int)6);
          if(return_value_strncmp$10 == 0)
            tmp_if_expr$12 = (_Bool)1;

          else
          {
            return_value_strncmp$11=strncmp(h->body, "error3", (unsigned long int)6);
            tmp_if_expr$12 = return_value_strncmp$11 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$12)
          {
            p->error = (enum anonymous$21)GG_PUBDIR_ERROR_NEW_PASSWORD;
            gg_debug(16, "=> pubdir, invalid new password\n");
          }

          else
          {
            return_value_strncmp$9=strncmp(h->body, "not authenticated", (unsigned long int)17);
            if(return_value_strncmp$9 == 0)
            {
              p->error = (enum anonymous$21)GG_PUBDIR_ERROR_OLD_PASSWORD;
              gg_debug(16, "=> pubdir, invalid old password\n");
            }

            else
            {
              return_value_strncmp$8=strncmp(h->body, "bad_tokenval", (unsigned long int)12);
              if(return_value_strncmp$8 == 0)
              {
                p->error = (enum anonymous$21)GG_PUBDIR_ERROR_TOKEN;
                gg_debug(16, "=> pubdir, invalid token\n");
              }

              else
              {
                p->error = (enum anonymous$21)GG_PUBDIR_ERROR_OTHER;
                gg_debug(16, "=> pubdir, unknown error\n");
              }
            }
          }
        }
      }
      return 0;
    }
  }
}

// gg_read
// file libgadu.c line 256
signed int gg_read(struct gg_session *sess, char *buf, signed int length)
{
  struct gg_session_private *p = sess->private_data;
  signed int res;
  signed int *return_value___errno_location$2;
  signed int return_value_gnutls_error_is_fatal$4;
  signed int *return_value___errno_location$3;
  if(!(sess->ssl == NULL))
    do
    {
      signed long int return_value_gnutls_record_recv$1;
      return_value_gnutls_record_recv$1=gnutls_record_recv(((struct anonymous$34 *)sess->ssl)->session, (void *)buf, (unsigned long int)length);
      res = (signed int)return_value_gnutls_record_recv$1;
      if(!(res >= 0))
      {
        if(res == -28)
        {
          return_value___errno_location$2=__errno_location();
          *return_value___errno_location$2 = 11;
        }

        else
        {
          return_value_gnutls_error_is_fatal$4=gnutls_error_is_fatal(res);
          if(return_value_gnutls_error_is_fatal$4 == 0 || res == -52)
            continue;

          else
          {
            return_value___errno_location$3=__errno_location();
            *return_value___errno_location$3 = 22;
          }
        }
        return -1;
      }

      return res;
    }
    while((_Bool)1);

  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  if(!(p->socket_handle == NULL))
  {
    if(p->socket_manager.read_cb == ((signed long int (*)(void *, void *, unsigned char *, unsigned long int))NULL))
    {
      gg_debug_session(sess, 16 | 128, "// gg_read() socket_manager.read callback is empty\n");
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      *return_value___errno_location$5 = 22;
      return -1;
    }

    signed long int return_value;
    return_value=p->socket_manager.read_cb(p->socket_manager.cb_data, p->socket_handle, (unsigned char *)buf, (unsigned long int)length);
    res = (signed int)return_value;
    if(!(res >= 0))
    {
      return_value___errno_location$6=__errno_location();
      tmp_if_expr$7 = *return_value___errno_location$6 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$7 = (_Bool)0;
    if(!(res >= 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      if(*return_value___errno_location$8 == 11)
        return -1;

      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      gg_debug_session(sess, 16 | 128, "// gg_read() unexpected errno=%d\n", *return_value___errno_location$9);
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      *return_value___errno_location$10 = 22;
    }

    return res;
  }

  signed int *return_value___errno_location$12;
  do
  {
    signed long int return_value_recv$11;
    return_value_recv$11=recv(sess->fd, (void *)buf, (unsigned long int)length, 0);
    res = (signed int)return_value_recv$11;
    if(res == -1)
    {
      return_value___errno_location$12=__errno_location();
      if(!(*return_value___errno_location$12 == 4))
        goto __CPROVER_DUMP_L14;

    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      return res;
    }
  }
  while((_Bool)1);
}

// gg_read_line
// file common.c line 201
char * gg_read_line(signed int sock, char *buf, signed int length)
{
  signed int ret;
  _Bool tmp_if_expr$10;
  signed int *return_value___errno_location$9;
  _Bool tmp_if_expr$12;
  signed int *return_value___errno_location$11;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(buf == ((char *)NULL) || !(length >= 0))
    return (char *)(void *)0;

  else
  {
    for( ; length >= 2; length = length - 1)
    {
      do
      {
        signed long int return_value_recv$8;
        return_value_recv$8=recv(sock, (void *)buf, (unsigned long int)1, 0);
        ret = (signed int)return_value_recv$8;
        if(ret == -1)
        {
          return_value___errno_location$9=__errno_location();
          tmp_if_expr$10 = *return_value___errno_location$9 != 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$10 = (_Bool)0;
        if(tmp_if_expr$10)
        {
          return_value___errno_location$11=__errno_location();
          tmp_if_expr$12 = *return_value___errno_location$11 != 11 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$12 = (_Bool)0;
        if(tmp_if_expr$12)
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          gg_debug(16, "// gg_read_line() error on read (errno=%d, %s)\n", *return_value___errno_location$5, return_value_strerror$7);
          *buf = (char)0;
          return (char *)(void *)0;
        }

        else
          if(ret == 0)
          {
            gg_debug(16, "// gg_read_line() eof reached\n");
            *buf = (char)0;
            return (char *)(void *)0;
          }

        if(ret == -1)
        {
          return_value___errno_location$1=__errno_location();
          if(*return_value___errno_location$1 == 4)
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value___errno_location$2=__errno_location();
            tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
      }
      while(tmp_if_expr$4);
      if((signed int)*buf == 10)
      {
        buf = buf + 1l;
        break;
      }

      buf = buf + 1l;
    }
    *buf = (char)0;
    return buf;
  }
}

// gg_recv_packet
// file ../include/libgadu.h line 1770
void * gg_recv_packet(struct gg_session *sess)
{
  struct gg_header *gh;
  char *packet;
  signed int res;
  unsigned long int len;
  unsigned int ghlen = (unsigned int)0;
  gg_debug_session(sess, 8, "** gg_recv_packet(%p);\n", sess);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (void *)0;
  }

  unsigned int tmp_if_expr$4;
  unsigned int return_value_gg_fix32$3;
  signed int *return_value___errno_location$7;
  unsigned int tmp_if_expr$12;
  unsigned int return_value_gg_fix32$11;
  while((_Bool)1)
  {
    if(sess->recv_buf == ((char *)NULL))
    {
      if(sess->recv_done == 0)
      {
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(sizeof(struct gg_header) /*8ul*/  + (unsigned long int)1);
        sess->recv_buf = (char *)return_value_malloc$2;
        if(sess->recv_buf == ((char *)NULL))
        {
          gg_debug_session(sess, 128, "// gg_recv_packet() out of memory\n");
          return (void *)0;
        }

      }

    }

    gh = (struct gg_header *)sess->recv_buf;
    if(!((unsigned long int)sess->recv_done >= sizeof(struct gg_header) /*8ul*/ ))
    {
      len = sizeof(struct gg_header) /*8ul*/  - (unsigned long int)sess->recv_done;
      gg_debug_session(sess, 1, "// gg_recv_packet() header: %d done, %zu to go\n", sess->recv_done, len);
    }

    else
    {
      if(!(gh == ((struct gg_header *)NULL)))
      {
        return_value_gg_fix32$3=gg_fix32(gh->length);
        tmp_if_expr$4 = return_value_gg_fix32$3;
      }

      else
        tmp_if_expr$4 = (unsigned int)0;
      ghlen = tmp_if_expr$4;
      if(ghlen >= 65536u)
      {
        gg_debug_session(sess, 128, "// gg_recv_packet() invalid packet length (%d)\n", ghlen);
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        *return_value___errno_location$5 = 34;
        goto fail;
      }

      if((unsigned long int)sess->recv_done >= sizeof(struct gg_header) /*8ul*/  + (unsigned long int)ghlen)
      {
        gg_debug_session(sess, 1, "// gg_recv_packet() and that's it\n");
        break;
      }

      len = (sizeof(struct gg_header) /*8ul*/  + (unsigned long int)ghlen) - (unsigned long int)sess->recv_done;
      gg_debug_session(sess, 1, "// gg_recv_packet() payload: %d done, %u length, %zu to go\n", sess->recv_done, ghlen, len);
    }
    res=gg_read(sess, sess->recv_buf + (signed long int)sess->recv_done, (signed int)len);
    if(res == 0)
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      *return_value___errno_location$6 = 104;
      gg_debug_session(sess, 128, "// gg_recv_packet() connection broken\n");
      goto fail;
    }

    if(res == -1)
    {
      return_value___errno_location$7=__errno_location();
      if(*return_value___errno_location$7 == 11)
      {
        gg_debug_session(sess, 1, "// gg_recv_packet() resource temporarily unavailable\n");
        goto eagain;
      }

    }

    if(res == -1)
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      char *return_value_strerror$10;
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      gg_debug_session(sess, 128, "// gg_recv_packet() read failed: errno=%d, %s\n", *return_value___errno_location$8, return_value_strerror$10);
      goto fail;
    }

    gg_debug_session(sess, 1, "// gg_recv_packet() read %d bytes\n", res);
    if((unsigned long int)(sess->recv_done + res) == sizeof(struct gg_header) /*8ul*/ )
    {
      char *tmp;
      if(!(gh == ((struct gg_header *)NULL)))
      {
        return_value_gg_fix32$11=gg_fix32(gh->length);
        tmp_if_expr$12 = return_value_gg_fix32$11;
      }

      else
        tmp_if_expr$12 = (unsigned int)0;
      ghlen = tmp_if_expr$12;
      gg_debug_session(sess, 1, "// gg_recv_packet() header complete, payload %d bytes\n", ghlen);
      if(ghlen == 0u)
        break;

      if(ghlen >= 65536u)
      {
        gg_debug_session(sess, 128, "// gg_recv_packet() invalid packet length (%d)\n", ghlen);
        signed int *return_value___errno_location$13;
        return_value___errno_location$13=__errno_location();
        *return_value___errno_location$13 = 34;
        goto fail;
      }

      void *return_value_realloc$14;
      return_value_realloc$14=realloc((void *)sess->recv_buf, sizeof(struct gg_header) /*8ul*/  + (unsigned long int)ghlen + (unsigned long int)1);
      tmp = (char *)return_value_realloc$14;
      if(tmp == ((char *)NULL))
      {
        gg_debug_session(sess, 128, "// gg_recv_packet() out of memory\n");
        goto fail;
      }

      sess->recv_buf = tmp;
    }

    sess->recv_done = sess->recv_done + res;
  }
  packet = sess->recv_buf;
  sess->recv_buf = (char *)(void *)0;
  sess->recv_done = 0;
  unsigned int return_value_gg_fix32$15;
  if(!(gh == ((struct gg_header *)NULL)))
  {
    packet[(signed long int)(sizeof(struct gg_header) /*8ul*/  + (unsigned long int)ghlen)] = (char)0;
    return_value_gg_fix32$15=gg_fix32(gh->type);
    gg_debug_session(sess, 16, "// gg_recv_packet(type=0x%.2x, length=%d)\n", return_value_gg_fix32$15, ghlen);
    gg_debug_dump(sess, 4, packet, sizeof(struct gg_header) /*8ul*/  + (unsigned long int)ghlen);
    gh->type=gg_fix32(gh->type);
    gh->length = ghlen;
    return (void *)packet;
  }

  else
  {

  fail:
    ;
    free((void *)sess->recv_buf);
    sess->recv_buf = (char *)(void *)0;
    sess->recv_done = 0;

  eagain:
    ;
    return (void *)0;
  }
}

// gg_register
// file obsolete.c line 139
struct gg_http * gg_register(const char *email, const char *password, signed int async)
{
  gg_debug(16, "// gg_register() is obsolete. use gg_register3() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_register2
// file obsolete.c line 146
struct gg_http * gg_register2(const char *email, const char *password, const char *qa, signed int async)
{
  gg_debug(16, "// gg_register2() is obsolete. use gg_register3() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_register3
// file pubdir.c line 52
struct gg_http * gg_register3(const char *email, const char *password, const char *tokenid, const char *tokenval, signed int async)
{
  struct gg_http *h;
  char *__pwd;
  char *__email;
  char *__tokenid;
  char *__tokenval;
  char *form;
  char *query;
  if(email == ((const char *)NULL) || password == ((const char *)NULL) || tokenid == ((const char *)NULL) || tokenval == ((const char *)NULL))
  {
    gg_debug(16, "=> register, NULL parameter\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (struct gg_http *)(void *)0;
  }

  __pwd=gg_urlencode(password);
  __email=gg_urlencode(email);
  __tokenid=gg_urlencode(tokenid);
  __tokenval=gg_urlencode(tokenval);
  if(__email == ((char *)NULL) || __pwd == ((char *)NULL) || __tokenid == ((char *)NULL) || __tokenval == ((char *)NULL))
  {
    gg_debug(16, "=> register, not enough memory for form fields\n");
    free((void *)__pwd);
    free((void *)__email);
    free((void *)__tokenid);
    free((void *)__tokenval);
    return (struct gg_http *)(void *)0;
  }

  else
  {
    signed int return_value_gg_http_hash$2;
    return_value_gg_http_hash$2=gg_http_hash("ss", email, password);
    form=gg_saprintf("pwd=%s&email=%s&tokenid=%s&tokenval=%s&code=%u", __pwd, __email, __tokenid, __tokenval, return_value_gg_http_hash$2);
    free((void *)__pwd);
    free((void *)__email);
    free((void *)__tokenid);
    free((void *)__tokenval);
    if(form == ((char *)NULL))
    {
      gg_debug(16, "=> register, not enough memory for form query\n");
      return (struct gg_http *)(void *)0;
    }

    else
    {
      gg_debug(16, "=> register, %s\n", form);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(form);
      query=gg_saprintf("Host: register.gadu-gadu.pl\r\nContent-Type: application/x-www-form-urlencoded\r\nUser-Agent: Mozilla/4.7 [en] (Win98; I)\r\nContent-Length: %d\r\nPragma: no-cache\r\n\r\n%s", (signed int)return_value_strlen$3, form);
      free((void *)form);
      if(query == ((char *)NULL))
      {
        gg_debug(16, "=> register, not enough memory for query\n");
        return (struct gg_http *)(void *)0;
      }

      else
      {
        h=gg_http_connect("register.gadu-gadu.pl", 80, async, "POST", "/appsvc/fmregister3.asp", query);
        if(h == ((struct gg_http *)NULL))
        {
          gg_debug(16, "=> register, gg_http_connect() failed mysteriously\n");
          free((void *)query);
          return (struct gg_http *)(void *)0;
        }

        else
        {
          h->type = 4;
          free((void *)query);
          h->callback = gg_pubdir_watch_fd;
          h->destroy = gg_pubdir_free;
          if(async == 0)
            gg_pubdir_watch_fd(h);

          return h;
        }
      }
    }
  }
}

// gg_remind_passwd
// file obsolete.c line 191
struct gg_http * gg_remind_passwd(unsigned int uin, signed int async)
{
  gg_debug(16, "// gg_remind_passwd() is obsolete. use gg_remind_passwd3() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_remind_passwd2
// file obsolete.c line 198
struct gg_http * gg_remind_passwd2(unsigned int uin, const char *tokenid, const char *tokenval, signed int async)
{
  gg_debug(16, "// gg_remind_passwd2() is obsolete. use gg_remind_passwd3() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_remind_passwd3
// file pubdir.c line 465
struct gg_http * gg_remind_passwd3(unsigned int uin, const char *email, const char *tokenid, const char *tokenval, signed int async)
{
  struct gg_http *h;
  char *form;
  char *query;
  char *__tokenid;
  char *__tokenval;
  char *__email;
  if(email == ((const char *)NULL) || tokenid == ((const char *)NULL) || tokenval == ((const char *)NULL))
  {
    gg_debug(16, "=> remind, NULL parameter\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (struct gg_http *)(void *)0;
  }

  __tokenid=gg_urlencode(tokenid);
  __tokenval=gg_urlencode(tokenval);
  __email=gg_urlencode(email);
  if(__email == ((char *)NULL) || __tokenid == ((char *)NULL) || __tokenval == ((char *)NULL))
  {
    gg_debug(16, "=> remind, not enough memory for form fields\n");
    free((void *)__tokenid);
    free((void *)__tokenval);
    free((void *)__email);
    return (struct gg_http *)(void *)0;
  }

  else
  {
    signed int return_value_gg_http_hash$2;
    return_value_gg_http_hash$2=gg_http_hash("u", uin);
    form=gg_saprintf("userid=%d&code=%u&tokenid=%s&tokenval=%s&email=%s", uin, return_value_gg_http_hash$2, __tokenid, __tokenval, __email);
    if(form == ((char *)NULL))
    {
      gg_debug(16, "=> remind, not enough memory for form fields\n");
      free((void *)__tokenid);
      free((void *)__tokenval);
      free((void *)__email);
      return (struct gg_http *)(void *)0;
    }

    else
    {
      free((void *)__tokenid);
      free((void *)__tokenval);
      free((void *)__email);
      gg_debug(16, "=> remind, %s\n", form);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(form);
      query=gg_saprintf("Host: retr.gadu-gadu.pl\r\nContent-Type: application/x-www-form-urlencoded\r\nUser-Agent: Mozilla/4.7 [en] (Win98; I)\r\nContent-Length: %d\r\nPragma: no-cache\r\n\r\n%s", (signed int)return_value_strlen$3, form);
      free((void *)form);
      if(query == ((char *)NULL))
      {
        gg_debug(16, "=> remind, not enough memory for query\n");
        return (struct gg_http *)(void *)0;
      }

      else
      {
        h=gg_http_connect("retr.gadu-gadu.pl", 80, async, "POST", "/appsvc/fmsendpwd3.asp", query);
        if(h == ((struct gg_http *)NULL))
        {
          gg_debug(16, "=> remind, gg_http_connect() failed mysteriously\n");
          free((void *)query);
          return (struct gg_http *)(void *)0;
        }

        else
        {
          h->type = 5;
          free((void *)query);
          h->callback = gg_pubdir_watch_fd;
          h->destroy = gg_pubdir_free;
          if(async == 0)
            gg_pubdir_watch_fd(h);

          return h;
        }
      }
    }
  }
}

// gg_remove_notify
// file libgadu.c line 2505
signed int gg_remove_notify(struct gg_session *sess, unsigned int uin)
{
  signed int return_value_gg_remove_notify_ex$1;
  return_value_gg_remove_notify_ex$1=gg_remove_notify_ex(sess, uin, (char)0x03);
  return return_value_gg_remove_notify_ex$1;
}

// gg_remove_notify_ex
// file libgadu.c line 2458
signed int gg_remove_notify_ex(struct gg_session *sess, unsigned int uin, char type)
{
  gg_debug_session(sess, 8, "** gg_remove_notify_ex(%p, %u, %d);\n", sess, uin, type);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  if(sess->protocol_version >= 0x40)
  {
    struct gg_tvbuilder *tvb;
    tvb=gg_tvbuilder_new(sess, (struct gg_event *)(void *)0);
    gg_tvbuilder_expected_size(tvb, (unsigned long int)16);
    gg_tvbuilder_write_uin(tvb, uin);
    gg_tvbuilder_write_uint8(tvb, (unsigned char)type);
    signed int return_value_gg_tvbuilder_send$3;
    return_value_gg_tvbuilder_send$3=gg_tvbuilder_send(tvb, 0x007c);
    if(return_value_gg_tvbuilder_send$3 == 0)
      return -1;

    return 0;
  }

  else
  {
    struct gg_add_remove a;
    a.uin=gg_fix32(uin);
    a.dunno1 = (unsigned char)type;
    signed int return_value_gg_send_packet$4;
    return_value_gg_send_packet$4=gg_send_packet(sess, 0x000e, &a, sizeof(struct gg_add_remove) /*5ul*/ , (void *)0);
    return return_value_gg_send_packet$4;
  }
}

// gg_required_proto
// file libgadu.c line 182
signed int gg_required_proto(struct gg_session *gs, signed int protocol_version)
{
  if(gs->protocol_version >= protocol_version)
    return 1;

  else
  {
    gg_debug_session(gs, 16 | 128, "// requested feature requires protocol %#02x, but %#02x is selected\n", protocol_version, gs->protocol_version);
    return 0;
  }
}

// gg_resolve
// file obsolete.c line 224
signed int gg_resolve(signed int *fd, signed int *pid, const char *hostname)
{
  return -1;
}

// gg_resolve_pthread
// file obsolete.c line 234
signed int gg_resolve_pthread(signed int *fd, void **resolver, const char *hostname)
{
  return -1;
}

// gg_resolve_pthread_cleanup
// file obsolete.c line 229
void gg_resolve_pthread_cleanup(void *arg, signed int kill)
{
  ;
}

// gg_resolver_cleaner
// file resolver.c line 68
void gg_resolver_cleaner(void *data)
{
  void **buf_ptr = (void **)data;
  if(!(buf_ptr == ((void **)NULL)))
  {
    free(*buf_ptr);
    *buf_ptr = (void *)0;
  }

}

// gg_resolver_fork_cleanup
// file resolver.c line 468
static void gg_resolver_fork_cleanup(void **priv_data, signed int force)
{
  struct gg_resolver_fork_data *data;
  _Bool tmp_if_expr$1;
  if(priv_data == ((void **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = *priv_data == (void *)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    data = (struct gg_resolver_fork_data *)*priv_data;
    *priv_data = (void *)0;
    if(!(force == 0))
      kill(data->pid, 9);

    waitpid(data->pid, (signed int *)(void *)0, 1);
    free((void *)data);
  }

}

// gg_resolver_fork_start
// file resolver.c line 390
static signed int gg_resolver_fork_start(signed int *fd, void **priv_data, const char *hostname)
{
  struct gg_resolver_fork_data *data = (struct gg_resolver_fork_data *)(void *)0;
  signed int pipes[2l];
  signed int new_errno;
  gg_debug(8, "** gg_resolver_fork_start(%p, %p, \"%s\");\n", fd, priv_data, hostname);
  if(priv_data == ((void **)NULL) || fd == ((signed int *)NULL) || hostname == ((const char *)NULL))
  {
    gg_debug(16, "// gg_resolver_fork_start() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct gg_resolver_fork_data) /*4ul*/ );
  data = (struct gg_resolver_fork_data *)return_value_malloc$2;
  if(data == ((struct gg_resolver_fork_data *)NULL))
  {
    gg_debug(16, "// gg_resolver_fork_start() out of memory for resolver data\n");
    return -1;
  }

  else
  {
    signed int return_value_socketpair$6;
    return_value_socketpair$6=socketpair(1, 1, 0, pipes);
    if(return_value_socketpair$6 == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      gg_debug(16, "// gg_resolver_fork_start() unable to create pipes (errno=%d, %s)\n", *return_value___errno_location$3, return_value_strerror$5);
      free((void *)data);
      return -1;
    }

    data->pid=fork();
    if(data->pid == -1)
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      new_errno = *return_value___errno_location$7;
      goto cleanup;
    }

    if(data->pid == 0)
    {
      signed int status;
      close(pipes[(signed long int)0]);
      signed int return_value_gg_resolver_run$8;
      return_value_gg_resolver_run$8=gg_resolver_run(pipes[(signed long int)1], hostname, 0);
      status = return_value_gg_resolver_run$8 == -1 ? 1 : 0;
      _exit(status);
    }

    close(pipes[(signed long int)1]);
    gg_debug(16, "// gg_resolver_fork_start() %p\n", data);
    *fd = pipes[(signed long int)0];
    *priv_data = (void *)data;
    return 0;

  cleanup:
    ;
    free((void *)data);
    close(pipes[(signed long int)0]);
    close(pipes[(signed long int)1]);
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    *return_value___errno_location$9 = new_errno;
    return -1;
  }
}

// gg_resolver_pthread_cleanup
// file resolver.c line 510
static void gg_resolver_pthread_cleanup(void **priv_data, signed int force)
{
  struct gg_resolver_pthread_data *data;
  _Bool tmp_if_expr$1;
  if(priv_data == ((void **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = *priv_data == (void *)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    data = (struct gg_resolver_pthread_data *)*priv_data;
    *priv_data = (void *)0;
    if(!(force == 0))
      pthread_cancel(data->thread);

    pthread_join(data->thread, (void **)(void *)0);
    close(data->wfd);
    free((void *)data->hostname);
    free((void *)data);
  }

}

// gg_resolver_pthread_start
// file resolver.c line 561
static signed int gg_resolver_pthread_start(signed int *fd, void **priv_data, const char *hostname)
{
  struct gg_resolver_pthread_data *data = (struct gg_resolver_pthread_data *)(void *)0;
  signed int pipes[2l];
  signed int new_errno;
  gg_debug(8, "** gg_resolver_pthread_start(%p, %p, \"%s\");\n", fd, priv_data, hostname);
  if(priv_data == ((void **)NULL) || fd == ((signed int *)NULL) || hostname == ((const char *)NULL))
  {
    gg_debug(16, "// gg_resolver_pthread_start() invalid arguments\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct gg_resolver_pthread_data) /*24ul*/ );
  data = (struct gg_resolver_pthread_data *)return_value_malloc$2;
  if(data == ((struct gg_resolver_pthread_data *)NULL))
  {
    gg_debug(16, "// gg_resolver_pthread_start() out of memory for resolver data\n");
    return -1;
  }

  else
  {
    signed int return_value_socketpair$6;
    return_value_socketpair$6=socketpair(1, 1, 0, pipes);
    if(return_value_socketpair$6 == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      gg_debug(16, "// gg_resolver_pthread_start() unable to create pipes (errno=%d, %s)\n", *return_value___errno_location$3, return_value_strerror$5);
      free((void *)data);
      return -1;
    }

    data->hostname=strdup(hostname);
    if(data->hostname == ((char *)NULL))
    {
      gg_debug(16, "// gg_resolver_pthread_start() out of memory\n");
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      new_errno = *return_value___errno_location$7;
      goto cleanup;
    }

    data->wfd = pipes[(signed long int)1];
    signed int return_value_pthread_create$9;
    return_value_pthread_create$9=pthread_create(&data->thread, (const union pthread_attr_t *)(void *)0, gg_resolver_pthread_thread, (void *)data);
    if(!(return_value_pthread_create$9 == 0))
    {
      gg_debug(16, "// gg_resolver_pthread_start() unable to create thread\n");
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      new_errno = *return_value___errno_location$8;
      goto cleanup;
    }

    gg_debug(16, "// gg_resolver_pthread_start() %p\n", data);
    *fd = pipes[(signed long int)0];
    *priv_data = (void *)data;
    return 0;

  cleanup:
    ;
    if(!(data == ((struct gg_resolver_pthread_data *)NULL)))
      free((void *)data->hostname);

    free((void *)data);
    close(pipes[(signed long int)0]);
    close(pipes[(signed long int)1]);
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    *return_value___errno_location$10 = new_errno;
    return -1;
  }
}

// gg_resolver_pthread_thread
// file resolver.c line 535
static void * gg_resolver_pthread_thread(void *arg)
{
  struct gg_resolver_pthread_data *data = (struct gg_resolver_pthread_data *)arg;
  signed int return_value_gg_resolver_run$1;
  return_value_gg_resolver_run$1=gg_resolver_run(data->wfd, data->hostname, 1);
  if(return_value_gg_resolver_run$1 == -1)
    pthread_exit((void *)-1);

  else
    pthread_exit((void *)0);
  return (void *)0;
}

// gg_resolver_recv
// file ../include/resolver.h line 25
signed int gg_resolver_recv(signed int fd, void *buf, unsigned long int len)
{
  signed long int return_value_read$1;
  return_value_read$1=read(fd, buf, len);
  return (signed int)return_value_read$1;
}

// gg_resolver_run
// file resolver.c line 281
static signed int gg_resolver_run(signed int fd, const char *hostname, signed int pthread)
{
  struct in_addr addr_ip[2l];
  struct in_addr *addr_list = (struct in_addr *)(void *)0;
  unsigned int addr_count;
  signed int res = 0;
  signed int old_state;
  struct in_addr *tmp_if_expr$2;
  do
  {
    struct anonymous$24 __cancel_buf;
    void (*__cancel_routine)(void *) = gg_resolver_cleaner;
    void *__cancel_arg = (void *)&addr_list;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      addr_ip[(signed long int)0].s_addr=inet_addr(hostname);
      if(addr_ip[0l].s_addr == 0xffffffff)
      {
        signed int return_value_gg_gethostbyname_real$1;
        return_value_gg_gethostbyname_real$1=gg_gethostbyname_real(hostname, &addr_list, &addr_count, pthread);
        if(return_value_gg_gethostbyname_real$1 == -1)
        {
          if(!(pthread == 0))
            pthread_setcancelstate(1, &old_state);

          free((void *)addr_list);
          addr_list = (struct in_addr *)(void *)0;
          if(!(pthread == 0))
            pthread_setcancelstate(old_state, (signed int *)(void *)0);

          addr_count = (unsigned int)0;
        }

      }

      else
      {
        addr_ip[(signed long int)1].s_addr = (unsigned int)0xffffffff;
        addr_count = (unsigned int)1;
      }
      if(!(addr_list == ((struct in_addr *)NULL)))
        tmp_if_expr$2 = addr_list;

      else
        tmp_if_expr$2 = addr_ip;
      signed long int return_value_send$3;
      return_value_send$3=send(fd, (const void *)tmp_if_expr$2, (unsigned long int)(addr_count + (unsigned int)1) * sizeof(struct in_addr) /*4ul*/ , 0);
      if(!(return_value_send$3 == (signed long int)((signed int)sizeof(struct in_addr) /*4*/  * (signed int)(unsigned long int)(1u + addr_count))))
        res = -1;

      if(!(pthread == 0))
        pthread_setcancelstate(1, &old_state);

      free((void *)addr_list);
      addr_list = (struct in_addr *)(void *)0;
      if(!(pthread == 0))
        pthread_setcancelstate(old_state, (signed int *)(void *)0);


    __CPROVER_DUMP_L13:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  return res;
}

// gg_saprintf
// file common.c line 134
char * gg_saprintf(const char *format, ...)
{
  void **ap;
  char *res;
  ap = (void **)&format;
  res=gg_vsaprintf(format, ap);
  ap = ((void **)NULL);
  return res;
}

// gg_search
// file obsolete.c line 94
struct gg_http * gg_search(struct gg_search_request *r, signed int async)
{
  gg_debug(16, "// gg_search() is obsolete. use gg_search50() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_search_request_free
// file obsolete.c line 134
void gg_search_request_free(struct gg_search_request *r)
{
  ;
}

// gg_search_request_mode_0
// file obsolete.c line 112
struct gg_search_request * gg_search_request_mode_0(char *nickname, char *first_name, char *last_name, char *city, signed int gender, signed int min_birth, signed int max_birth, signed int active, signed int start)
{
  return (struct gg_search_request *)(void *)0;
}

// gg_search_request_mode_1
// file obsolete.c line 119
struct gg_search_request * gg_search_request_mode_1(char *email, signed int active, signed int start)
{
  return (struct gg_search_request *)(void *)0;
}

// gg_search_request_mode_2
// file obsolete.c line 124
struct gg_search_request * gg_search_request_mode_2(char *phone, signed int active, signed int start)
{
  return (struct gg_search_request *)(void *)0;
}

// gg_search_request_mode_3
// file obsolete.c line 129
struct gg_search_request * gg_search_request_mode_3(unsigned int uin, signed int active, signed int start)
{
  return (struct gg_search_request *)(void *)0;
}

// gg_search_watch_fd
// file obsolete.c line 101
signed int gg_search_watch_fd(struct gg_http *h)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return -1;
}

// gg_send_message
// file libgadu.c line 1815
signed int gg_send_message(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *message)
{
  gg_debug_session(sess, 8, "** gg_send_message(%p, %d, %u, %p)\n", sess, msgclass, recipient, message);
  if(sess->protocol_version >= 0x40)
  {
    signed int seq_no;
    seq_no=gg_send_message_110(sess, recipient, (unsigned long int)0, (const char *)message, 0);
    if(seq_no >= 0)
      gg_compat_message_sent(sess, seq_no, (unsigned long int)1, &recipient);

    return seq_no;
  }

  signed int return_value_gg_send_message_common$1;
  return_value_gg_send_message_common$1=gg_send_message_common(sess, msgclass, 1, &recipient, message, (const unsigned char *)"\002\006\0\0\0\b\0\0\0", 9, (const unsigned char *)(void *)0);
  return return_value_gg_send_message_common$1;
}

// gg_send_message_110
// file libgadu.c line 1435
static signed int gg_send_message_110(struct gg_session *sess, unsigned int recipient, unsigned long int chat_id, const char *message, signed int is_html)
{
  struct _GG110SendMessage msg = { .base={ .descriptor=&gg110_send_message__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .has_recipient=0,
    .recipient={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 }, .dummy1=8u,
    .seq=(unsigned int)0, .msg_plain=(char *)(void *)0, .msg_xhtml=(char *)(void *)0,
    .dummy3=gg110_send_message__dummy3__default_value, .has_chat_id=0,
    .chat_id=(unsigned long int)0 };
  signed int packet_type = recipient != 0u ? 0x007d : 0x008d;
  signed int seq;
  char *html_message_gen = (char *)(void *)0;
  char *plain_message_gen = (char *)(void *)0;
  const char *html_message;
  const char *plain_message;
  signed int succ = 1;
  gg_debug_session(sess, 8, "** gg_send_message_110(%p, %u, %lu, %p, %d);\n", sess, recipient, chat_id, message, is_html);
  if(message == ((const char *)NULL))
    return -1;

  else
    if((recipient == 0u) == (chat_id == 0ul))
      return -1;

    else
    {
      if(!(is_html == 0))
      {
        html_message = message;
        if(!((signed int)sess->encoding == GG_ENCODING_UTF8))
        {
          html_message_gen=gg_encoding_convert(html_message, sess->encoding, (enum anonymous$3)GG_ENCODING_UTF8, -1, -1);
          html_message = html_message_gen;
          if(html_message_gen == ((char *)NULL))
            return -1;

        }

        plain_message_gen=gg_message_html_to_text_110(html_message);
        plain_message = plain_message_gen;
        if(plain_message_gen == ((char *)NULL))
        {
          free((void *)html_message_gen);
          return -1;
        }

      }

      else
      {
        plain_message = message;
        if(!((signed int)sess->encoding == GG_ENCODING_UTF8))
        {
          plain_message_gen=gg_encoding_convert(plain_message, sess->encoding, (enum anonymous$3)GG_ENCODING_UTF8, -1, -1);
          plain_message = plain_message_gen;
          if(plain_message_gen == ((char *)NULL))
            return -1;

        }

        html_message_gen=gg_message_text_to_html_110(plain_message, (signed long int)-1);
        html_message = html_message_gen;
        if(html_message_gen == ((char *)NULL))
        {
          free((void *)plain_message_gen);
          return -1;
        }

      }
      sess->seq = sess->seq + 1;
      seq = sess->seq;
      if(!(recipient == 0u))
      {
        msg.has_recipient = 1;
        gg_protobuf_set_uin(&msg.recipient, recipient, (struct _gg_protobuf_uin_buff *)(void *)0);
      }

      msg.seq = (unsigned int)seq;
      msg.msg_plain = (char *)plain_message;
      msg.msg_xhtml = (char *)html_message;
      if(!(chat_id == 0ul))
      {
        msg.dummy3 = "";
        msg.has_chat_id = 1;
        msg.chat_id = chat_id;
      }

      signed int return_value_gg_protobuf_send_ex$1;
      return_value_gg_protobuf_send_ex$1=gg_protobuf_send_ex(sess, (struct gg_event *)(void *)0, packet_type, (void *)&msg, (unsigned long int (*)(const void *))gg110_send_message__get_packed_size, (unsigned long int (*)(const void *, unsigned char *))gg110_send_message__pack);
      if(return_value_gg_protobuf_send_ex$1 == 0)
        succ = 0;

      free((void *)html_message_gen);
      free((void *)plain_message_gen);
      return succ != 0 ? seq : -1;
    }
}

// gg_send_message_common
// file libgadu.c line 1565
static signed int gg_send_message_common(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *message, const unsigned char *format, signed int formatlen, const unsigned char *html_message)
{
  struct gg_send_msg80 s80;
  const char *cp_msg = (const char *)(void *)0;
  const char *utf_html_msg = (const char *)(void *)0;
  char *recoded_msg = (char *)(void *)0;
  char *recoded_html_msg = (char *)(void *)0;
  unsigned char *generated_format = (unsigned char *)(void *)0;
  signed int seq_no = -1;
  gg_debug_session(sess, 8, "** gg_send_message_common(%p, %d, %d, %p, %p, %p, %d, %p);\n", sess, msgclass, recipients_count, recipients, message, format, formatlen, html_message);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  if(recipients == ((unsigned int *)NULL) || recipients_count >= 65536 || format == ((const unsigned char *)NULL) && !(formatlen == 0) || html_message == ((const unsigned char *)NULL) && message == ((const unsigned char *)NULL) || !(recipients_count >= 1))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return -1;
  }

  if(sess->protocol_version >= 0x40)
  {
    if(recipients_count == 1)
    {
      signed int is_html = (signed int)(html_message != (const unsigned char *)(void *)0);
      char *formatted_msg = (char *)(void *)0;
      if(is_html == 0 && formatlen >= 4)
      {
        gg_debug_session(sess, 16 | 64, "// gg_send_message_common() using legacy formatting with new protocol\n");
        formatted_msg=gg_message_legacy_text_to_html((const char *)message, sess->encoding, format, (unsigned long int)formatlen);
        if(formatted_msg == ((char *)NULL))
          goto cleanup;

        html_message = (unsigned char *)formatted_msg;
        is_html = 1;
      }

      seq_no=gg_send_message_110(sess, recipients[(signed long int)0], (unsigned long int)0, (const char *)(is_html != 0 ? html_message : message), is_html);
      goto cleanup;
    }

  }

  signed int return_value_gg_compat_feature_is_enabled$5;
  if(sess->protocol_version >= 0x40)
  {
    return_value_gg_compat_feature_is_enabled$5=gg_compat_feature_is_enabled(sess, (enum anonymous$18)GG_COMPAT_FEATURE_LEGACY_CONFER);
    if(return_value_gg_compat_feature_is_enabled$5 == 0)
    {
      gg_debug_session(sess, 16 | 128, "// gg_send_message_common() legacy conferences disabled\n");
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 22;
      return -1;
    }

  }

  if(message == ((const unsigned char *)NULL))
  {
    char *tmp_msg;
    unsigned long int len;
    unsigned long int fmt_len;
    unsigned short int fixed_fmt_len;
    len=gg_message_html_to_text((char *)(void *)0, (unsigned char *)(void *)0, &fmt_len, (const char *)html_message, sess->encoding);
    void *return_value_malloc$6;
    return_value_malloc$6=malloc(len + (unsigned long int)1);
    tmp_msg = (char *)return_value_malloc$6;
    if(tmp_msg == ((char *)NULL))
      goto cleanup;

    if(!(fmt_len == 0ul))
    {
      void *return_value_malloc$7;
      return_value_malloc$7=malloc(fmt_len + (unsigned long int)3);
      generated_format = (unsigned char *)return_value_malloc$7;
      if(generated_format == ((unsigned char *)NULL))
      {
        free((void *)tmp_msg);
        goto cleanup;
      }

      generated_format[(signed long int)0] = (unsigned char)2;
      fixed_fmt_len=gg_fix16((unsigned short int)fmt_len);
      memcpy((void *)(generated_format + (signed long int)1), (const void *)&fixed_fmt_len, sizeof(unsigned short int) /*2ul*/ );
      gg_message_html_to_text(tmp_msg, generated_format + (signed long int)3, (unsigned long int *)(void *)0, (const char *)html_message, sess->encoding);
      format = generated_format;
      formatlen = (signed int)(fmt_len + (unsigned long int)3);
    }

    else
    {
      gg_message_html_to_text(tmp_msg, (unsigned char *)(void *)0, (unsigned long int *)(void *)0, (const char *)html_message, sess->encoding);
      format = (const unsigned char *)(void *)0;
      formatlen = 0;
    }
    if(!((signed int)sess->encoding == GG_ENCODING_CP1250))
    {
      recoded_msg=gg_encoding_convert(tmp_msg, sess->encoding, (enum anonymous$3)GG_ENCODING_CP1250, -1, -1);
      cp_msg = recoded_msg;
      free((void *)tmp_msg);
      if(cp_msg == ((const char *)NULL))
        goto cleanup;

    }

    else
    {
      recoded_msg = tmp_msg;
      cp_msg = recoded_msg;
    }
  }

  else
    if(!((signed int)sess->encoding == GG_ENCODING_CP1250))
    {
      recoded_msg=gg_encoding_convert((const char *)message, sess->encoding, (enum anonymous$3)GG_ENCODING_CP1250, -1, -1);
      cp_msg = recoded_msg;
      if(cp_msg == ((const char *)NULL))
        goto cleanup;

    }

    else
      cp_msg = (const char *)message;
  if(html_message == ((const unsigned char *)NULL))
  {
    char *gg_send_message_common$$1$$8$$formatted_msg;
    gg_send_message_common$$1$$8$$formatted_msg=gg_message_legacy_text_to_html((const char *)message, sess->encoding, format, (unsigned long int)formatlen);
    if(gg_send_message_common$$1$$8$$formatted_msg == ((char *)NULL))
      goto cleanup;

    if((signed int)sess->encoding == GG_ENCODING_UTF8)
    {
      recoded_html_msg = gg_send_message_common$$1$$8$$formatted_msg;
      utf_html_msg = recoded_html_msg;
    }

    else
    {
      recoded_html_msg=gg_encoding_convert(gg_send_message_common$$1$$8$$formatted_msg, sess->encoding, (enum anonymous$3)GG_ENCODING_UTF8, -1, -1);
      utf_html_msg = recoded_html_msg;
      free((void *)gg_send_message_common$$1$$8$$formatted_msg);
      if(utf_html_msg == ((const char *)NULL))
        goto cleanup;

    }
  }

  else
    if((signed int)sess->encoding == GG_ENCODING_UTF8)
      utf_html_msg = (const char *)html_message;

    else
    {
      recoded_html_msg=gg_encoding_convert((const char *)html_message, sess->encoding, (enum anonymous$3)GG_ENCODING_UTF8, -1, -1);
      utf_html_msg = recoded_html_msg;
      if(utf_html_msg == ((const char *)NULL))
        goto cleanup;

    }
  signed long int return_value_time$8;
  return_value_time$8=time((signed long int *)(void *)0);
  seq_no = (signed int)return_value_time$8;
  if(sess->seq >= seq_no)
    seq_no = sess->seq + 1;

  sess->seq = seq_no;
  s80.seq=gg_fix32((unsigned int)seq_no);
  s80.msgclass=gg_fix32((unsigned int)msgclass);
  unsigned long int return_value_strlen$9;
  return_value_strlen$9=strlen(utf_html_msg);
  s80.offset_plain=gg_fix32((unsigned int)(sizeof(struct gg_send_msg80) /*20ul*/  + return_value_strlen$9 + (unsigned long int)1));
  unsigned long int return_value_strlen$10;
  return_value_strlen$10=strlen(utf_html_msg);
  unsigned long int return_value_strlen$11;
  return_value_strlen$11=strlen(cp_msg);
  s80.offset_attr=gg_fix32((unsigned int)(sizeof(struct gg_send_msg80) /*20ul*/  + return_value_strlen$10 + (unsigned long int)1 + return_value_strlen$11 + (unsigned long int)1));
  if(recipients_count >= 2)
  {
    struct gg_msg_recipients r;
    signed int i;
    signed int j;
    signed int k;
    unsigned int *recps;
    r.flag = (unsigned char)0x01;
    r.count=gg_fix32((unsigned int)(recipients_count - 1));
    void *return_value_malloc$12;
    return_value_malloc$12=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(recipients_count - 1));
    recps = (unsigned int *)return_value_malloc$12;
    if(recps == ((unsigned int *)NULL))
    {
      seq_no = -1;
      goto cleanup;
    }

    i = 0;
    for( ; !(i >= recipients_count); i = i + 1)
    {
      j = 0;
      k = 0;
      for( ; !(j >= recipients_count); j = j + 1)
        if(!(j == i))
        {
          recps[(signed long int)k]=gg_fix32(recipients[(signed long int)j]);
          k = k + 1;
        }

      s80.recipient=gg_fix32(recipients[(signed long int)i]);
      unsigned long int return_value_strlen$13;
      return_value_strlen$13=strlen(utf_html_msg);
      unsigned long int return_value_strlen$14;
      return_value_strlen$14=strlen(cp_msg);
      signed int return_value_gg_send_packet$15;
      return_value_gg_send_packet$15=gg_send_packet(sess, 0x002d, &s80, sizeof(struct gg_send_msg80) /*20ul*/ , utf_html_msg, return_value_strlen$13 + (unsigned long int)1, cp_msg, return_value_strlen$14 + (unsigned long int)1, &r, sizeof(struct gg_msg_recipients) /*5ul*/ , recps, (unsigned long int)(recipients_count - 1) * sizeof(unsigned int) /*4ul*/ , format, formatlen, (void *)0);
      if(return_value_gg_send_packet$15 == -1)
        seq_no = -1;

    }
    free((void *)recps);
  }

  else
  {
    s80.recipient=gg_fix32(recipients[(signed long int)0]);
    unsigned long int return_value_strlen$16;
    return_value_strlen$16=strlen(utf_html_msg);
    unsigned long int return_value_strlen$17;
    return_value_strlen$17=strlen(cp_msg);
    signed int return_value_gg_send_packet$18;
    return_value_gg_send_packet$18=gg_send_packet(sess, 0x002d, &s80, sizeof(struct gg_send_msg80) /*20ul*/ , utf_html_msg, return_value_strlen$16 + (unsigned long int)1, cp_msg, return_value_strlen$17 + (unsigned long int)1, format, formatlen, (void *)0);
    if(return_value_gg_send_packet$18 == -1)
      seq_no = -1;

  }

cleanup:
  ;
  free((void *)recoded_msg);
  free((void *)recoded_html_msg);
  free((void *)generated_format);
  if(seq_no >= 0)
    gg_compat_message_sent(sess, seq_no, (unsigned long int)recipients_count, recipients);

  return seq_no;
}

// gg_send_message_confer
// file libgadu.c line 1903
signed int gg_send_message_confer(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *message)
{
  gg_debug_session(sess, 8, "** gg_send_message_confer(%p, %d, %d, %p, %p);\n", sess, msgclass, recipients_count, recipients, message);
  signed int return_value_gg_send_message_common$1;
  return_value_gg_send_message_common$1=gg_send_message_common(sess, msgclass, recipients_count, recipients, message, (const unsigned char *)"\002\006\0\0\0\b\0\0\0", 9, (const unsigned char *)(void *)0);
  return return_value_gg_send_message_common$1;
}

// gg_send_message_confer_html
// file libgadu.c line 1962
signed int gg_send_message_confer_html(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *html_message)
{
  gg_debug_session(sess, 8, "** gg_send_message_confer_html(%p, %d, %d, %p, %p);\n", sess, msgclass, recipients_count, recipients, html_message);
  signed int return_value_gg_send_message_common$1;
  return_value_gg_send_message_common$1=gg_send_message_common(sess, msgclass, recipients_count, recipients, (const unsigned char *)(void *)0, (const unsigned char *)(void *)0, 0, html_message);
  return return_value_gg_send_message_common$1;
}

// gg_send_message_confer_richtext
// file libgadu.c line 1934
signed int gg_send_message_confer_richtext(struct gg_session *sess, signed int msgclass, signed int recipients_count, unsigned int *recipients, const unsigned char *message, const unsigned char *format, signed int formatlen)
{
  gg_debug_session(sess, 8, "** gg_send_message_confer_richtext(%p, %d, %d, %p, %p, %p, %d);\n", sess, msgclass, recipients_count, recipients, message, format, formatlen);
  signed int return_value_gg_send_message_common$1;
  return_value_gg_send_message_common$1=gg_send_message_common(sess, msgclass, recipients_count, recipients, message, format, formatlen, (const unsigned char *)(void *)0);
  return return_value_gg_send_message_common$1;
}

// gg_send_message_ctcp
// file ../include/libgadu.h line 811
signed int gg_send_message_ctcp(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *message, signed int message_len)
{
  struct gg_send_msg s;
  gg_debug_session(sess, 8, "** gg_send_message_ctcp(%p, %d, %u, ...);\n", sess, msgclass, recipient);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  s.recipient=gg_fix32(recipient);
  s.seq=gg_fix32((unsigned int)0);
  s.msgclass=gg_fix32((unsigned int)msgclass);
  signed int return_value_gg_send_packet$3;
  return_value_gg_send_packet$3=gg_send_packet(sess, 0x000b, &s, sizeof(struct gg_send_msg) /*12ul*/ , message, message_len, (void *)0);
  return return_value_gg_send_packet$3;
}

// gg_send_message_html
// file libgadu.c line 1879
signed int gg_send_message_html(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *html_message)
{
  gg_debug_session(sess, 8, "** gg_send_message_html(%p, %d, %u, %p);\n", sess, msgclass, recipient, html_message);
  signed int return_value_gg_send_message_common$1;
  return_value_gg_send_message_common$1=gg_send_message_common(sess, msgclass, 1, &recipient, (const unsigned char *)(void *)0, (const unsigned char *)(void *)0, 0, html_message);
  return return_value_gg_send_message_common$1;
}

// gg_send_message_richtext
// file libgadu.c line 1853
signed int gg_send_message_richtext(struct gg_session *sess, signed int msgclass, unsigned int recipient, const unsigned char *message, const unsigned char *format, signed int formatlen)
{
  gg_debug_session(sess, 8, "** gg_send_message_richtext(%p, %d, %u, %p, %p, %d);\n", sess, msgclass, recipient, message, format, formatlen);
  signed int return_value_gg_send_message_common$1;
  return_value_gg_send_message_common$1=gg_send_message_common(sess, msgclass, 1, &recipient, message, format, formatlen, (const unsigned char *)(void *)0);
  return return_value_gg_send_message_common$1;
}

// gg_send_packet
// file ../include/libgadu.h line 1771
signed int gg_send_packet(struct gg_session *sess, signed int type, ...)
{
  struct gg_header *h;
  char *tmp;
  unsigned int tmp_length;
  void *payload;
  unsigned int payload_length;
  __builtin_va_list ap;
  signed int res;
  gg_debug_session(sess, 8, "** gg_send_packet(%p, 0x%.2x, ...);\n", sess, type);
  tmp_length = (unsigned int)sizeof(struct gg_header) /*8ul*/ ;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)tmp_length);
  tmp = (char *)return_value_malloc$1;
  if(tmp == ((char *)NULL))
  {
    gg_debug_session(sess, 128, "// gg_send_packet() not enough memory for packet header\n");
    return -1;
  }

  else
  {
    va_start(ap, type);
    payload=va_arg(ap, __typeof__(payload));
    while(!(payload == NULL))
    {
      char *tmp2;
      payload_length=va_arg(ap, __typeof__(payload_length));
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)tmp, (unsigned long int)(tmp_length + payload_length));
      tmp2 = (char *)return_value_realloc$2;
      if(tmp2 == ((char *)NULL))
      {
        gg_debug_session(sess, 128, "// gg_send_packet() not enough memory for payload\n");
        free((void *)tmp);
        va_end(ap);
        return -1;
      }

      tmp = tmp2;
      memcpy((void *)(tmp + (signed long int)tmp_length), payload, (unsigned long int)payload_length);
      tmp_length = tmp_length + payload_length;
      payload=va_arg(ap, __typeof__(payload));
    }
    va_end(ap);
    h = (struct gg_header *)tmp;
    h->type=gg_fix32((unsigned int)type);
    h->length=gg_fix32((unsigned int)((unsigned long int)tmp_length - sizeof(struct gg_header) /*8ul*/ ));
    unsigned int return_value_gg_fix32$3;
    return_value_gg_fix32$3=gg_fix32(h->type);
    unsigned int return_value_gg_fix32$4;
    return_value_gg_fix32$4=gg_fix32(h->length);
    gg_debug_session(sess, 16, "// gg_send_packet(type=0x%.2x, length=%d)\n", return_value_gg_fix32$3, return_value_gg_fix32$4);
    gg_debug_dump(sess, 4, tmp, (unsigned long int)tmp_length);
    res=gg_write(sess, tmp, (signed int)tmp_length);
    free((void *)tmp);
    if(res == -1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      gg_debug_session(sess, 128, "// gg_send_packet() write() failed. res = %d, errno = %d (%s)\n", res, *return_value___errno_location$5, return_value_strerror$7);
      return -1;
    }

    if(!(sess->async == 0))
      gg_debug_session(sess, 1, "// gg_send_packet() partial write(), %d sent, %d left, %d total left\n", res, tmp_length - (unsigned int)res, sess->send_left);

    if(!(sess->send_buf == ((char *)NULL)))
      sess->check = sess->check | 1;

    return 0;
  }
}

// gg_send_queued_data
// file events.c line 335
static signed int gg_send_queued_data(struct gg_session *sess)
{
  signed int res;
  _Bool tmp_if_expr$1;
  if(sess->send_buf == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = sess->send_left == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$7;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    gg_debug_session(sess, 16, "// gg_watch_fd() sending %d bytes of queued data\n", sess->send_left);
    signed long int return_value_send$2;
    return_value_send$2=send(sess->fd, (const void *)sess->send_buf, (unsigned long int)sess->send_left, 0);
    res = (signed int)return_value_send$2;
    if(res == -1)
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      if(*return_value___errno_location$6 == 11)
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value___errno_location$7=__errno_location();
        tmp_if_expr$8 = *return_value___errno_location$7 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        gg_debug_session(sess, 16, "// gg_watch_fd() non-critical send error (errno=%d, %s)\n", *return_value___errno_location$3, return_value_strerror$5);
        return 0;
      }

      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      char *return_value_strerror$11;
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      gg_debug_session(sess, 16, "// gg_watch_fd() send() failed (errno=%d, %s)\n", *return_value___errno_location$9, return_value_strerror$11);
      return -1;
    }

    if(res == sess->send_left)
    {
      gg_debug_session(sess, 16, "// gg_watch_fd() sent all queued data\n");
      free((void *)sess->send_buf);
      sess->send_buf = (char *)(void *)0;
      sess->send_left = 0;
    }

    else
      if(res >= 1)
      {
        gg_debug_session(sess, 16, "// gg_watch_fd() sent %d bytes of queued data, %d bytes left\n", res, sess->send_left - res);
        memmove((void *)sess->send_buf, (const void *)(sess->send_buf + (signed long int)res), (unsigned long int)(sess->send_left - res));
        sess->send_left = sess->send_left - res;
      }

    return 0;
  }
}

// gg_server_time
// file common.c line 813
signed long int gg_server_time(struct gg_session *gs)
{
  signed long int now;
  now=time((signed long int *)(void *)0);
  _Bool tmp_if_expr$1;
  if(gs == ((struct gg_session *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = gs->private_data == (struct gg_session_private *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    gg_debug_session(gs, 128, "time diff data is not accessible\n");
    return now;
  }

  else
    return now + (signed long int)gs->private_data->time_diff;
}

// gg_session_callback
// file libgadu.c line 805
static signed int gg_session_callback(struct gg_session *sess)
{
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  sess->event=gg_watch_fd(sess);
  return sess->event != (struct gg_event *)(void *)0 ? 0 : -1;
}

// gg_session_get_resolver
// file resolver.c line 872
enum anonymous$4 gg_session_get_resolver(struct gg_session *gs)
{
  do
    if(gs == ((struct gg_session *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
      return (enum anonymous$4)-1;
    }

  while((_Bool)0);
  return gs->resolver_type;
}

// gg_session_handle_access_info
// file handlers.c line 2604
static signed int gg_session_handle_access_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110AccessInfo *msg;
  msg=gg110_access_info__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110AccessInfo", (signed int)(msg == (struct _GG110AccessInfo *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110AccessInfo", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(msg == ((struct _GG110AccessInfo *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_debug_session(gs, 16, "// gg_session_handle_access_info: dummy[%02x, %02x], last[message=%u, file_transfer=%u, conference_ch=%u]\n", msg->dummy1, msg->dummy2, msg->last_message, msg->last_file_transfer, msg->last_conference_ch);
    gg110_access_info__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    return 0;
  }
}

// gg_session_handle_chat_created
// file handlers.c line 2534
static signed int gg_session_handle_chat_created(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_chat_created *p = (struct gg_chat_created *)ptr;
  unsigned long int return_value_gg_fix64$1;
  return_value_gg_fix64$1=gg_fix64(p->id);
  signed int return_value_gg_chat_update$2;
  return_value_gg_chat_update$2=gg_chat_update(gs, return_value_gg_fix64$1, (unsigned int)0, &gs->uin, (unsigned int)1);
  if(!(return_value_gg_chat_update$2 == 0))
    return -1;

  else
  {
    ge->type = GG_EVENT_CHAT_CREATED;
    ge->event.chat_created.id=gg_fix64(p->id);
    ge->event.chat_created.seq=gg_fix32(p->seq);
    return 0;
  }
}

// gg_session_handle_chat_info
// file handlers.c line 2392
static signed int gg_session_handle_chat_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_tvbuff *tvb;
  unsigned int i;
  unsigned long int id;
  unsigned int version;
  unsigned int dummy1;
  unsigned int participants_count;
  unsigned int *participants = (unsigned int *)(void *)0;
  tvb=gg_tvbuff_new(ptr, len);
  id=gg_tvbuff_read_uint64(tvb);
  gg_tvbuff_expected_uint32(tvb, (unsigned int)0);
  version=gg_tvbuff_read_uint32(tvb);
  dummy1=gg_tvbuff_read_uint32(tvb);
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    if(dummy1 == 1u)
    {
      unsigned int name_length;
      name_length=gg_tvbuff_read_uint32(tvb);
      gg_tvbuff_skip(tvb, (unsigned long int)name_length);
      gg_tvbuff_expected_uint32(tvb, (unsigned int)0);
      gg_tvbuff_expected_uint32(tvb, (unsigned int)2);
    }

  }

  participants_count=gg_tvbuff_read_uint32(tvb);
  if(id == 0ul && participants_count >= 1u)
  {
    gg_debug_session(gs, 16 | 64, "// gg_session_handle_chat_info() terminating packet shouldn't contain participants\n");
    participants_count = (unsigned int)0;
  }

  if(participants_count >= 1u)
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)participants_count);
    participants = (unsigned int *)return_value_malloc$2;
    if(participants == ((unsigned int *)NULL))
    {
      gg_tvbuff_close(tvb);
      return -1;
    }

  }

  i = (unsigned int)0;
  _Bool tmp_if_expr$4;
  signed int return_value_gg_tvbuff_is_valid$3;
  do
  {
    if(!(i >= participants_count))
    {
      return_value_gg_tvbuff_is_valid$3=gg_tvbuff_is_valid(tvb);
      tmp_if_expr$4 = return_value_gg_tvbuff_is_valid$3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    participants[(signed long int)i]=gg_tvbuff_read_uint32(tvb);
    gg_tvbuff_read_uint32(tvb);
    i = i + 1u;
  }
  while((_Bool)1);
  signed int return_value_gg_tvbuff_close$5;
  return_value_gg_tvbuff_close$5=gg_tvbuff_close(tvb);
  if(return_value_gg_tvbuff_close$5 == 0)
  {
    free((void *)participants);
    return -1;
  }

  else
    if(id == 0ul)
    {
      ge->type = GG_EVENT_CHAT_INFO_GOT_ALL;
      return 0;
    }

    else
    {
      signed int return_value_gg_chat_update$6;
      return_value_gg_chat_update$6=gg_chat_update(gs, id, version, participants, participants_count);
      if(!(return_value_gg_chat_update$6 == 0))
      {
        free((void *)participants);
        return -1;
      }

      else
      {
        ge->type = GG_EVENT_CHAT_INFO;
        ge->event.chat_info.id = id;
        ge->event.chat_info.version = version;
        ge->event.chat_info.participants_count = participants_count;
        ge->event.chat_info.participants = participants;
        return 0;
      }
    }
}

// gg_session_handle_chat_info_update
// file handlers.c line 2466
static signed int gg_session_handle_chat_info_update(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110ChatInfoUpdate *msg;
  msg=gg110_chat_info_update__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  struct _gg_chat_list *chat;
  unsigned int participant;
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110ChatInfoUpdate", (signed int)(msg == (struct _GG110ChatInfoUpdate *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110ChatInfoUpdate", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(msg == ((struct _GG110ChatInfoUpdate *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_debug_session(gs, 32, "// gg_session_handle_chat_info_update() msg_id=%016lx conv_id=%016lx\n", msg->msg_id, msg->conv_id);
    ge->type = GG_EVENT_CHAT_INFO_UPDATE;
    ge->event.chat_info_update.id = msg->chat_id;
    ge->event.chat_info_update.type = msg->update_type;
    participant=gg_protobuf_get_uin(msg->participant);
    ge->event.chat_info_update.participant = participant;
    ge->event.chat_info_update.inviter=gg_protobuf_get_uin(msg->inviter);
    ge->event.chat_info_update.version = msg->version;
    ge->event.chat_info_update.time = msg->time;
    chat=gg_chat_find(gs, msg->chat_id);
    if(chat == ((struct _gg_chat_list *)NULL))
    {
      gg110_chat_info_update__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
      return 0;
    }

    else
    {
      chat->version = msg->version;
      if(msg->update_type == 1u)
      {
        unsigned int *old_part = chat->participants;
        void *return_value_realloc$4;
        return_value_realloc$4=realloc((void *)chat->participants, sizeof(unsigned int) /*4ul*/  * (unsigned long int)chat->participants_count);
        chat->participants = (unsigned int *)return_value_realloc$4;
        if(chat->participants == ((unsigned int *)NULL))
        {
          chat->participants = old_part;
          gg_debug_session(gs, 128, "// gg_session_handle_chat_info_update() out of memory (count=%u)\n", chat->participants_count);
          return -1;
        }

        chat->participants_count = chat->participants_count + 1u;
        chat->participants[(signed long int)(chat->participants_count - (unsigned int)1)] = participant;
      }

      else
        if(msg->update_type == 3u)
        {
          unsigned int idx = (unsigned int)0;
          for( ; !(idx >= chat->participants_count); idx = idx + 1u)
            if(chat->participants[(signed long int)idx] == participant)
              break;

          if(chat->participants_count >= 2u)
          {
            if(!(idx >= chat->participants_count))
              chat->participants[(signed long int)idx] = chat->participants[(signed long int)(chat->participants_count - (unsigned int)1)];

          }

          if(!(idx >= chat->participants_count))
          {
            chat->participants_count = chat->participants_count - 1u;
            if(chat->participants_count == 0u)
            {
              free((void *)chat->participants);
              chat->participants = (unsigned int *)(void *)0;
            }

            else
            {
              void *return_value_realloc$5;
              return_value_realloc$5=realloc((void *)chat->participants, sizeof(unsigned int) /*4ul*/  * (unsigned long int)chat->participants_count);
              chat->participants = (unsigned int *)return_value_realloc$5;
            }
          }

        }

      gg110_chat_info_update__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
      return 0;
    }
  }
}

// gg_session_handle_chat_invite_ack
// file handlers.c line 2548
static signed int gg_session_handle_chat_invite_ack(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_chat_invite_ack *p = (struct gg_chat_invite_ack *)ptr;
  ge->type = GG_EVENT_CHAT_INVITE_ACK;
  ge->event.chat_invite_ack.id=gg_fix64(p->id);
  ge->event.chat_invite_ack.seq=gg_fix32(p->seq);
  return 0;
}

// gg_session_handle_chat_left
// file handlers.c line 2561
static signed int gg_session_handle_chat_left(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_chat_left *p = (struct gg_chat_left *)ptr;
  ge->type = GG_EVENT_CHAT_INFO_UPDATE;
  ge->event.chat_info_update.id=gg_fix64(p->id);
  ge->event.chat_info_update.type = (unsigned int)0x03;
  ge->event.chat_info_update.participant=gg_fix32(p->uin);
  ge->event.chat_info_update.inviter=gg_fix32(p->uin);
  ge->event.chat_info_update.version = (unsigned int)0;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  ge->event.chat_info_update.time = (unsigned int)return_value_time$1;
  return 0;
}

// gg_session_handle_dcc7_accept
// file handlers.c line 687
static signed int gg_session_handle_dcc7_accept(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received dcc7 accept\n");
  signed int return_value_gg_dcc7_handle_accept$1;
  return_value_gg_dcc7_handle_accept$1=gg_dcc7_handle_accept(gs, ge, (const void *)ptr, (signed int)len);
  return return_value_gg_dcc7_handle_accept$1;
}

// gg_session_handle_dcc7_id_reply
// file handlers.c line 674
static signed int gg_session_handle_dcc7_id_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received dcc7 id packet\n");
  signed int return_value_gg_dcc7_handle_id$1;
  return_value_gg_dcc7_handle_id$1=gg_dcc7_handle_id(gs, ge, (const void *)ptr, (signed int)len);
  return return_value_gg_dcc7_handle_id$1;
}

// gg_session_handle_dcc7_info
// file handlers.c line 726
static signed int gg_session_handle_dcc7_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received dcc7 info\n");
  signed int return_value_gg_dcc7_handle_info$1;
  return_value_gg_dcc7_handle_info$1=gg_dcc7_handle_info(gs, ge, (const void *)ptr, (signed int)len);
  return return_value_gg_dcc7_handle_info$1;
}

// gg_session_handle_dcc7_new
// file handlers.c line 700
static signed int gg_session_handle_dcc7_new(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received dcc7 request\n");
  signed int return_value_gg_dcc7_handle_new$1;
  return_value_gg_dcc7_handle_new$1=gg_dcc7_handle_new(gs, ge, (const void *)ptr, (signed int)len);
  return return_value_gg_dcc7_handle_new$1;
}

// gg_session_handle_dcc7_reject
// file handlers.c line 713
static signed int gg_session_handle_dcc7_reject(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received dcc7 reject\n");
  signed int return_value_gg_dcc7_handle_reject$1;
  return_value_gg_dcc7_handle_reject$1=gg_dcc7_handle_reject(gs, ge, (const void *)ptr, (signed int)len);
  return return_value_gg_dcc7_handle_reject$1;
}

// gg_session_handle_disconnect_ack
// file handlers.c line 523
static signed int gg_session_handle_disconnect_ack(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received logoff acknowledge\n");
  ge->type = GG_EVENT_DISCONNECT_ACK;
  return 0;
}

// gg_session_handle_disconnecting
// file handlers.c line 508
static signed int gg_session_handle_disconnecting(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received disconnection warning\n");
  ge->type = GG_EVENT_DISCONNECT;
  return 0;
}

// gg_session_handle_event_110
// file handlers.c line 557
static signed int gg_session_handle_event_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110Event *msg;
  msg=gg110_event__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  signed int succ = 1;
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110Event", (signed int)(msg == (struct _GG110Event *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110Event", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(msg == ((struct _GG110Event *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_debug_session(gs, 16, "// gg_session_handle_event_110: received GG11 event (type=%d, id=%lx)\n", msg->type, msg->id);
    if((signed int)msg->type == GG110_EVENT__TYPE__XML)
    {
      ge->type = GG_EVENT_XML_EVENT;
      ge->event.xml_event.data=strdup(msg->data);
      if(!(succ == 0))
        tmp_if_expr$4 = ge->event.xml_event.data != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      succ = (signed int)tmp_if_expr$4;
    }

    else
      if((signed int)msg->type == GG110_EVENT__TYPE__JSON)
      {
        ge->type = GG_EVENT_JSON_EVENT;
        ge->event.json_event.data=strdup(msg->data);
        if(!(succ == 0))
          tmp_if_expr$5 = ge->event.json_event.data != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        succ = (signed int)tmp_if_expr$5;
        ge->event.json_event.type=strdup(msg->subtype);
        if(!(succ == 0))
          tmp_if_expr$6 = ge->event.json_event.type != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        succ = (signed int)tmp_if_expr$6;
      }

      else
      {
        gg_debug_session(gs, 64, "// gg_session_handle_event_110: unsupported GG11 event type: %d\n", msg->type);
        succ = 0;
      }
    signed int return_value_gg_ack_110$7;
    return_value_gg_ack_110$7=gg_ack_110(gs, (enum _GG110Ack__Type)GG110_ACK__TYPE__MPA, msg->seq, ge);
    if(!(return_value_gg_ack_110$7 == 0))
      succ = 0;

    gg110_event__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    return succ != 0 ? 0 : -1;
  }
}

// gg_session_handle_imtoken
// file handlers.c line 2345
static signed int gg_session_handle_imtoken(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110Imtoken *msg;
  msg=gg110_imtoken__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  char *imtoken = (char *)(void *)0;
  signed int succ = 1;
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110Imtoken", (signed int)(msg == (struct _GG110Imtoken *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110Imtoken", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(msg == ((struct _GG110Imtoken *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_debug_session(gs, 16, "// gg_watch_fd_connected() received imtoken\n");
    if(!((signed int)*msg->imtoken == 0))
    {
      imtoken=strdup(msg->imtoken);
      succ = (signed int)(succ != 0 && imtoken != (char *)(void *)0);
    }

    gg110_imtoken__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    ge->type = GG_EVENT_IMTOKEN;
    ge->event.imtoken.imtoken = imtoken;
    return succ != 0 ? 0 : -1;
  }
}

// gg_session_handle_login110_ok
// file handlers.c line 169
static signed int gg_session_handle_login110_ok(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110LoginOK *msg;
  msg=gg110_login_ok__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110LoginOK", (signed int)(msg == (struct _GG110LoginOK *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110LoginOK", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  signed int tmp_if_expr$4;
  if(msg == ((struct _GG110LoginOK *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_protobuf_expected(gs, "GG110LoginOK.dummy1", (unsigned int)msg->dummy1, (unsigned int)1);
    gg_sync_time(gs, (signed long int)msg->server_time);
    gg_debug_session(gs, 16, "// login110_ok: uin=%u, dummyhash=%s\n", msg->uin, msg->dummyhash);
    gg110_login_ok__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    ge->type = GG_EVENT_CONN_SUCCESS;
    gs->state = GG_STATE_CONNECTED;
    gs->check = 2;
    gs->timeout = -1;
    if(!(gs->initial_status == 0))
      tmp_if_expr$4 = gs->initial_status;

    else
      tmp_if_expr$4 = 0x0002;
    gs->status = tmp_if_expr$4;
    free((void *)gs->initial_descr);
    gs->initial_descr = (char *)(void *)0;
    return 0;
  }
}

// gg_session_handle_login_failed
// file handlers.c line 388
static signed int gg_session_handle_login_failed(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  if(!(type == 11u))
    gg_debug_session(gs, 16, "// gg_watch_fd() login failed\n");

  else
    gg_debug_session(gs, 16, "// gg_watch_fd() too many incorrect password attempts\n");
  ge->type = GG_EVENT_CONN_FAILED;
  ge->event.failure = (enum gg_failure_t)(type != (unsigned int)0x000b ? GG_FAILURE_PASSWORD : GG_FAILURE_INTRUDER);
  gs->state = GG_STATE_IDLE;
  gg_close(gs);
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 13;
  return 0;
}

// gg_session_handle_login_ok
// file handlers.c line 363
static signed int gg_session_handle_login_ok(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd() login succeded\n");
  ge->type = GG_EVENT_CONN_SUCCESS;
  gs->state = GG_STATE_CONNECTED;
  gs->check = 2;
  gs->timeout = -1;
  signed int tmp_if_expr$1;
  if(!(gs->initial_status == 0))
    tmp_if_expr$1 = gs->initial_status;

  else
    tmp_if_expr$1 = 0x0002;
  gs->status = tmp_if_expr$1;
  free((void *)gs->initial_descr);
  gs->initial_descr = (char *)(void *)0;
  return 0;
}

// gg_session_handle_magic_notification
// file handlers.c line 2721
static signed int gg_session_handle_magic_notification(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110MagicNotification *msg;
  msg=gg110_magic_notification__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  signed int succ = 1;
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110MagicNotification", (signed int)(msg == (struct _GG110MagicNotification *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110MagicNotification", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(msg == ((struct _GG110MagicNotification *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_debug_session(gs, 16, "// gg_session_handle_magic_notification \n");
    gg_protobuf_expected(gs, "GG110MagicNotification.dummy1", (unsigned int)msg->dummy1, (unsigned int)2);
    gg_protobuf_expected(gs, "GG110MagicNotification.dummy2", (unsigned int)msg->dummy2, (unsigned int)1);
    gg_protobuf_expected(gs, "GG110MagicNotification.dummy3", (unsigned int)msg->dummy3, (unsigned int)1);
    signed int return_value_gg_ack_110$4;
    return_value_gg_ack_110$4=gg_ack_110(gs, (enum _GG110Ack__Type)GG110_ACK__TYPE__MAGIC_NOTIFICATION, (unsigned int)msg->seq, ge);
    succ = (signed int)(return_value_gg_ack_110$4 == 0);
    gg110_magic_notification__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    return succ != 0 ? 0 : -1;
  }
}

// gg_session_handle_multilogon_info
// file handlers.c line 2205
static signed int gg_session_handle_multilogon_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  const char *packet_end = (const char *)ptr + (signed long int)len;
  struct gg_multilogon_info *info = (struct gg_multilogon_info *)ptr;
  const char *p = (const char *)ptr + (signed long int)sizeof(struct gg_multilogon_info) /*4ul*/ ;
  struct gg_multilogon_session *sessions = (struct gg_multilogon_session *)(void *)0;
  unsigned long int count;
  unsigned long int i;
  signed int res = 0;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received multilogon info\n");
  unsigned int return_value_gg_fix32$1;
  return_value_gg_fix32$1=gg_fix32(info->count);
  count = (unsigned long int)return_value_gg_fix32$1;
  void *return_value_calloc$2;
  if(count >= 65536ul)
    gg_debug_session(gs, 16, "// gg_handle_multilogon_info() malformed packet (1)\n");

  else
  {
    return_value_calloc$2=calloc(count, sizeof(struct gg_multilogon_session) /*40ul*/ );
    sessions = (struct gg_multilogon_session *)return_value_calloc$2;
    if(sessions == ((struct gg_multilogon_session *)NULL))
    {
      gg_debug_session(gs, 16, "// gg_handle_multilogon_info() out of memory (%zu*%zu)\n", count, sizeof(struct gg_multilogon_session) /*40ul*/ );
      return -1;
    }

    ge->type = GG_EVENT_MULTILOGON_INFO;
    ge->event.multilogon_info.count = (signed int)count;
    ge->event.multilogon_info.sessions = sessions;
    i = (unsigned long int)0;
    for( ; !(i >= count); i = i + 1ul)
    {
      struct gg_multilogon_info_item item;
      unsigned long int name_size;
      if(!(packet_end >= p + (signed long int)sizeof(struct gg_multilogon_info_item) /*32l*/ ))
      {
        gg_debug_session(gs, 16, "// gg_handle_multilogon_info() malformed packet (2)\n");
        goto malformed;
      }

      memcpy((void *)&item, (const void *)p, sizeof(struct gg_multilogon_info_item) /*32ul*/ );
      (sessions + (signed long int)i)->id = item.conn_id;
      (sessions + (signed long int)i)->remote_addr = item.addr;
      unsigned int return_value_gg_fix32$3;
      return_value_gg_fix32$3=gg_fix32(item.flags);
      (sessions + (signed long int)i)->status_flags = (signed int)return_value_gg_fix32$3;
      unsigned int return_value_gg_fix32$4;
      return_value_gg_fix32$4=gg_fix32(item.features);
      (sessions + (signed long int)i)->protocol_features = (signed int)return_value_gg_fix32$4;
      unsigned int return_value_gg_fix32$5;
      return_value_gg_fix32$5=gg_fix32(item.logon_time);
      (sessions + (signed long int)i)->logon_time = (signed long int)return_value_gg_fix32$5;
      p = p + (signed long int)sizeof(struct gg_multilogon_info_item) /*32ul*/ ;
      unsigned int return_value_gg_fix32$6;
      return_value_gg_fix32$6=gg_fix32(item.name_size);
      name_size = (unsigned long int)return_value_gg_fix32$6;
      if(name_size >= 65536ul || !(packet_end >= p + (signed long int)name_size))
      {
        gg_debug_session(gs, 16, "// gg_handle_multilogon_info() malformed packet (3)\n");
        goto malformed;
      }

      void *return_value_malloc$7;
      return_value_malloc$7=malloc(name_size + (unsigned long int)1);
      (sessions + (signed long int)i)->name = (char *)return_value_malloc$7;
      if((sessions + (signed long int)i)->name == ((char *)NULL))
      {
        gg_debug_session(gs, 16, "// gg_handle_multilogon_info() out of memory (%zu)\n", name_size);
        goto fail;
      }

      memcpy((void *)(sessions + (signed long int)i)->name, (const void *)p, name_size);
      (sessions + (signed long int)i)->name[(signed long int)name_size] = (char)0;
      p = p + (signed long int)name_size;
    }
    return 0;

  fail:
    ;
    res = -1;
  }

malformed:
  ;
  ge->type = GG_EVENT_NONE;
  i = (unsigned long int)0;
  for( ; !((signed int)i >= ge->event.multilogon_info.count); i = i + 1ul)
    free((void *)(ge->event.multilogon_info.sessions + (signed long int)i)->name);
  free((void *)ge->event.multilogon_info.sessions);
  return res;
}

// gg_session_handle_notify_reply
// file handlers.c line 1617
static signed int gg_session_handle_notify_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_notify_reply *n = (struct gg_notify_reply *)(const void *)ptr;
  char *descr;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a notify reply\n");
  unsigned int return_value_gg_fix32$3;
  return_value_gg_fix32$3=gg_fix32(n->status);
  _Bool tmp_if_expr$5;
  unsigned int return_value_gg_fix32$4;
  if(return_value_gg_fix32$3 == 5u)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_gg_fix32$4=gg_fix32(n->status);
    tmp_if_expr$5 = return_value_gg_fix32$4 == (unsigned int)0x0015 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  unsigned int return_value_gg_fix32$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_gg_fix32$6=gg_fix32(n->status);
    tmp_if_expr$7 = return_value_gg_fix32$6 == (unsigned int)0x0004 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    unsigned long int descr_len;
    ge->type = GG_EVENT_NOTIFY_DESCR;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct gg_notify_reply) /*20ul*/  * (unsigned long int)2);
    ge->event.notify_descr.notify = (struct gg_notify_reply *)(void *)return_value_malloc$1;
    if(ge->event.notify_descr.notify == ((struct gg_notify_reply *)NULL))
    {
      gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
      return -1;
    }

    (ge->event.notify_descr.notify + (signed long int)1)->uin = (unsigned int)0;
    memcpy((void *)ge->event.notify_descr.notify, (const void *)ptr, sizeof(struct gg_notify_reply) /*20ul*/ );
    (ge->event.notify_descr.notify + (signed long int)0)->uin=gg_fix32((ge->event.notify_descr.notify + (signed long int)0)->uin);
    (ge->event.notify_descr.notify + (signed long int)0)->status=gg_fix32((ge->event.notify_descr.notify + (signed long int)0)->status);
    (ge->event.notify_descr.notify + (signed long int)0)->remote_port=gg_fix16((ge->event.notify_descr.notify + (signed long int)0)->remote_port);
    (ge->event.notify_descr.notify + (signed long int)0)->version=gg_fix32((ge->event.notify_descr.notify + (signed long int)0)->version);
    descr_len = len - sizeof(struct gg_notify_reply) /*20ul*/ ;
    descr=gg_encoding_convert(ptr + (signed long int)sizeof(struct gg_notify_reply) /*20ul*/ , (enum anonymous$3)GG_ENCODING_CP1250, gs->encoding, (signed int)descr_len, -1);
    if(descr == ((char *)NULL))
    {
      gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
      return -1;
    }

    ge->event.notify_descr.descr = descr;
  }

  else
  {
    unsigned int i;
    unsigned int count;
    ge->type = GG_EVENT_NOTIFY;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(len + (unsigned long int)2 * sizeof(struct gg_notify_reply) /*20ul*/ );
    ge->event.notify = (struct gg_notify_reply *)(void *)return_value_malloc$2;
    if(ge->event.notify == ((struct gg_notify_reply *)NULL))
    {
      gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
      return -1;
    }

    memcpy((void *)ge->event.notify, (const void *)ptr, len);
    count = (unsigned int)(len / sizeof(struct gg_notify_reply) /*20ul*/ );
    (ge->event.notify + (signed long int)count)->uin = (unsigned int)0;
    i = (unsigned int)0;
    for( ; !(i >= count); i = i + 1u)
    {
      (ge->event.notify + (signed long int)i)->uin=gg_fix32((ge->event.notify + (signed long int)i)->uin);
      (ge->event.notify + (signed long int)i)->status=gg_fix32((ge->event.notify + (signed long int)i)->status);
      (ge->event.notify + (signed long int)i)->remote_port=gg_fix16((ge->event.notify + (signed long int)i)->remote_port);
      (ge->event.notify + (signed long int)i)->version=gg_fix32((ge->event.notify + (signed long int)i)->version);
    }
  }
  return 0;
}

// gg_session_handle_notify_reply_60
// file handlers.c line 1893
static signed int gg_session_handle_notify_reply_60(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_notify_reply60 *n = (struct gg_notify_reply60 *)(const void *)ptr;
  unsigned int length = (unsigned int)len;
  unsigned int i = (unsigned int)0;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a notify reply\n");
  ge->type = GG_EVENT_NOTIFY60;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct gg_event_notify60) /*40ul*/ );
  ge->event.notify60 = (struct gg_event_notify60 *)return_value_malloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(ge->event.notify60 == ((struct gg_event_notify60 *)NULL))
  {
    gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
    return -1;
  }

  else
  {
    (ge->event.notify60 + (signed long int)0)->uin = (unsigned int)0;
    while((unsigned long int)length >= sizeof(struct gg_notify_reply60) /*14ul*/ )
    {
      unsigned int uin;
      uin=gg_fix32(n->uin);
      void *tmp;
      (ge->event.notify60 + (signed long int)i)->uin = uin & (unsigned int)0x00ffffff;
      (ge->event.notify60 + (signed long int)i)->status = (signed int)n->status;
      (ge->event.notify60 + (signed long int)i)->remote_ip = n->remote_ip;
      (ge->event.notify60 + (signed long int)i)->remote_port=gg_fix16(n->remote_port);
      (ge->event.notify60 + (signed long int)i)->version = (signed int)n->version;
      (ge->event.notify60 + (signed long int)i)->image_size = (signed int)n->image_size;
      (ge->event.notify60 + (signed long int)i)->descr = (char *)(void *)0;
      (ge->event.notify60 + (signed long int)i)->time = (signed long int)0;
      if(!((1073741824u & uin) == 0u))
        (ge->event.notify60 + (signed long int)i)->version = (ge->event.notify60 + (signed long int)i)->version | 0x40000000;

      if(!((134217728u & uin) == 0u))
        (ge->event.notify60 + (signed long int)i)->version = (ge->event.notify60 + (signed long int)i)->version | 0x04000000;

      if((0xff & (signed int)n->status) == 0x0015)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = ((signed int)n->status & 0xff) == 0x0018 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = ((signed int)n->status & 0xff) == 0x0004 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = ((signed int)n->status & 0xff) == 0x0005 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = ((signed int)n->status & 0xff) == 0x0022 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = ((signed int)n->status & 0xff) == 0x0016 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
      {
        unsigned char descr_len = (unsigned char)((const char *)n)[(signed long int)sizeof(struct gg_notify_reply60) /*14ul*/ ];
        if((unsigned long int)length >= sizeof(struct gg_notify_reply60) /*14ul*/  + (unsigned long int)descr_len)
        {
          char *descr;
          descr=gg_encoding_convert((const char *)n + (signed long int)sizeof(struct gg_notify_reply60) /*14ul*/  + (signed long int)1, (enum anonymous$3)GG_ENCODING_CP1250, gs->encoding, (signed int)descr_len, -1);
          if(descr == ((char *)NULL))
          {
            gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
            return -1;
          }

          (ge->event.notify60 + (signed long int)i)->descr = descr;
          length = length - (unsigned int)(sizeof(struct gg_notify_reply60) /*14ul*/  + (unsigned long int)descr_len + (unsigned long int)1);
          n = (struct gg_notify_reply60 *)(const void *)((const char *)n + (signed long int)sizeof(struct gg_notify_reply60) /*14ul*/  + (signed long int)descr_len + (signed long int)1);
        }

        else
          length = (unsigned int)0;
      }

      else
      {
        length = length - (unsigned int)sizeof(struct gg_notify_reply60) /*14ul*/ ;
        n = (struct gg_notify_reply60 *)(const void *)((const char *)n + (signed long int)sizeof(struct gg_notify_reply60) /*14ul*/ );
      }
      tmp=realloc((void *)ge->event.notify60, (unsigned long int)(i + (unsigned int)2) * sizeof(struct gg_event_notify60) /*40ul*/ );
      if(tmp == NULL)
      {
        gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
        free((void *)ge->event.notify60);
        return -1;
      }

      ge->event.notify60 = (struct gg_event_notify60 *)tmp;
      i = i + 1u;
      (ge->event.notify60 + (signed long int)i)->uin = (unsigned int)0;
    }
    return 0;
  }
}

// gg_session_handle_notify_reply_77_80beta
// file handlers.c line 1808
static signed int gg_session_handle_notify_reply_77_80beta(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_notify_reply77 *n = (struct gg_notify_reply77 *)(const void *)ptr;
  unsigned int length = (unsigned int)len;
  unsigned int i = (unsigned int)0;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a notify reply\n");
  ge->type = GG_EVENT_NOTIFY60;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct gg_event_notify60) /*40ul*/ );
  ge->event.notify60 = (struct gg_event_notify60 *)return_value_malloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(ge->event.notify60 == ((struct gg_event_notify60 *)NULL))
  {
    gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
    return -1;
  }

  else
  {
    (ge->event.notify60 + (signed long int)0)->uin = (unsigned int)0;
    while((unsigned long int)length >= sizeof(struct gg_notify_reply77) /*18ul*/ )
    {
      unsigned int uin;
      uin=gg_fix32(n->uin);
      void *tmp;
      (ge->event.notify60 + (signed long int)i)->uin = uin & (unsigned int)0x00ffffff;
      (ge->event.notify60 + (signed long int)i)->status = (signed int)n->status;
      (ge->event.notify60 + (signed long int)i)->remote_ip = n->remote_ip;
      (ge->event.notify60 + (signed long int)i)->remote_port=gg_fix16(n->remote_port);
      (ge->event.notify60 + (signed long int)i)->version = (signed int)n->version;
      (ge->event.notify60 + (signed long int)i)->image_size = (signed int)n->image_size;
      (ge->event.notify60 + (signed long int)i)->descr = (char *)(void *)0;
      (ge->event.notify60 + (signed long int)i)->time = (signed long int)0;
      if(!((1073741824u & uin) == 0u))
        (ge->event.notify60 + (signed long int)i)->version = (ge->event.notify60 + (signed long int)i)->version | 0x40000000;

      if(!((536870912u & uin) == 0u))
        (ge->event.notify60 + (signed long int)i)->version = (ge->event.notify60 + (signed long int)i)->version | 0x20000000;

      if(!((134217728u & uin) == 0u))
        (ge->event.notify60 + (signed long int)i)->version = (ge->event.notify60 + (signed long int)i)->version | 0x04000000;

      if((0xff & (signed int)n->status) == 0x0015)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = ((signed int)n->status & 0xff) == 0x0018 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = ((signed int)n->status & 0xff) == 0x0004 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = ((signed int)n->status & 0xff) == 0x0005 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = ((signed int)n->status & 0xff) == 0x0022 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = ((signed int)n->status & 0xff) == 0x0016 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
      {
        unsigned char descr_len = (unsigned char)((const char *)n)[(signed long int)sizeof(struct gg_notify_reply77) /*18ul*/ ];
        if((unsigned long int)length >= sizeof(struct gg_notify_reply77) /*18ul*/  + (unsigned long int)descr_len)
        {
          (ge->event.notify60 + (signed long int)i)->descr=gg_encoding_convert((const char *)n + (signed long int)sizeof(struct gg_notify_reply77) /*18ul*/  + (signed long int)1, (enum anonymous$3)(type == (unsigned int)0x002b ? GG_ENCODING_UTF8 : GG_ENCODING_CP1250), gs->encoding, (signed int)descr_len, -1);
          if((ge->event.notify60 + (signed long int)i)->descr == ((char *)NULL))
          {
            gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
            return -1;
          }

          length = length - (unsigned int)(sizeof(struct gg_notify_reply77) /*18ul*/  + (unsigned long int)descr_len + (unsigned long int)1);
          n = (struct gg_notify_reply77 *)(const void *)((const char *)n + (signed long int)sizeof(struct gg_notify_reply77) /*18ul*/  + (signed long int)descr_len + (signed long int)1);
        }

        else
          length = (unsigned int)0;
      }

      else
      {
        length = length - (unsigned int)sizeof(struct gg_notify_reply77) /*18ul*/ ;
        n = (struct gg_notify_reply77 *)(const void *)((const char *)n + (signed long int)sizeof(struct gg_notify_reply77) /*18ul*/ );
      }
      tmp=realloc((void *)ge->event.notify60, (unsigned long int)(i + (unsigned int)2) * sizeof(struct gg_event_notify60) /*40ul*/ );
      if(tmp == NULL)
      {
        gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
        free((void *)ge->event.notify60);
        return -1;
      }

      ge->event.notify60 = (struct gg_event_notify60 *)tmp;
      i = i + 1u;
      (ge->event.notify60 + (signed long int)i)->uin = (unsigned int)0;
    }
    return 0;
  }
}

// gg_session_handle_notify_reply_80
// file handlers.c line 1726
static signed int gg_session_handle_notify_reply_80(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_notify_reply80 *n = (struct gg_notify_reply80 *)(const void *)ptr;
  unsigned int length = (unsigned int)len;
  unsigned int i = (unsigned int)0;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a notify reply\n");
  ge->type = GG_EVENT_NOTIFY60;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct gg_event_notify60) /*40ul*/ );
  ge->event.notify60 = (struct gg_event_notify60 *)return_value_malloc$1;
  if(ge->event.notify60 == ((struct gg_event_notify60 *)NULL))
  {
    gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
    return -1;
  }

  else
  {
    (ge->event.notify60 + (signed long int)0)->uin = (unsigned int)0;
    while((unsigned long int)length >= sizeof(struct gg_notify_reply80) /*28ul*/ )
    {
      unsigned int uin;
      uin=gg_fix32(n->uin);
      signed int descr_len;
      void *tmp;
      (ge->event.notify60 + (signed long int)i)->uin = uin;
      unsigned int return_value_gg_fix32$2;
      return_value_gg_fix32$2=gg_fix32(n->status);
      (ge->event.notify60 + (signed long int)i)->status = (signed int)return_value_gg_fix32$2;
      (ge->event.notify60 + (signed long int)i)->remote_ip = n->remote_ip;
      (ge->event.notify60 + (signed long int)i)->remote_port=gg_fix16(n->remote_port);
      (ge->event.notify60 + (signed long int)i)->version = 0;
      (ge->event.notify60 + (signed long int)i)->image_size = (signed int)n->image_size;
      (ge->event.notify60 + (signed long int)i)->descr = (char *)(void *)0;
      (ge->event.notify60 + (signed long int)i)->time = (signed long int)0;
      unsigned int return_value_gg_fix32$3;
      return_value_gg_fix32$3=gg_fix32(n->descr_len);
      descr_len = (signed int)return_value_gg_fix32$3;
      if(!(descr_len == 0))
      {
        if((unsigned long int)length >= sizeof(struct gg_notify_reply80) /*28ul*/  + (unsigned long int)descr_len)
        {
          (ge->event.notify60 + (signed long int)i)->descr=gg_encoding_convert((const char *)n + (signed long int)sizeof(struct gg_notify_reply80) /*28ul*/ , (enum anonymous$3)GG_ENCODING_UTF8, gs->encoding, descr_len, -1);
          if((ge->event.notify60 + (signed long int)i)->descr == ((char *)NULL))
          {
            gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
            return -1;
          }

          length = length - (unsigned int)(sizeof(struct gg_notify_reply80) /*28ul*/  + (unsigned long int)descr_len);
          n = (struct gg_notify_reply80 *)(const void *)((const char *)n + (signed long int)sizeof(struct gg_notify_reply80) /*28ul*/  + (signed long int)descr_len);
        }

        else
          length = (unsigned int)0;
      }

      else
      {
        length = length - (unsigned int)sizeof(struct gg_notify_reply80) /*28ul*/ ;
        n = (struct gg_notify_reply80 *)(const void *)((const char *)n + (signed long int)sizeof(struct gg_notify_reply80) /*28ul*/ );
      }
      tmp=realloc((void *)ge->event.notify60, (unsigned long int)(i + (unsigned int)2) * sizeof(struct gg_event_notify60) /*40ul*/ );
      if(tmp == NULL)
      {
        gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
        free((void *)ge->event.notify60);
        return -1;
      }

      ge->event.notify60 = (struct gg_event_notify60 *)tmp;
      i = i + 1u;
      (ge->event.notify60 + (signed long int)i)->uin = (unsigned int)0;
    }
    return 0;
  }
}

// gg_session_handle_options
// file handlers.c line 2579
static signed int gg_session_handle_options(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110Options *msg;
  msg=gg110_options__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  unsigned long int i;
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110Options", (signed int)(msg == (struct _GG110Options *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110Options", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$6;
  signed int return_value_gg_protobuf_valid_chkunknown$5;
  if(msg == ((struct _GG110Options *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_protobuf_expected(gs, "GG110Options.dummy1", msg->dummy1, (unsigned int)0);
    i = (unsigned long int)0;
    for( ; !(i >= msg->n_options); i = i + 1ul)
    {
      struct _ProtobufKVP *kvp = msg->options[(signed long int)i];
      signed int return_value_gg_protobuf_valid_chknull$4;
      return_value_gg_protobuf_valid_chknull$4=gg_protobuf_valid_chknull(gs, "ProtobufKVP", (signed int)(kvp == (struct _ProtobufKVP *)(void *)0));
      if(!(return_value_gg_protobuf_valid_chknull$4 == 0))
      {
        return_value_gg_protobuf_valid_chkunknown$5=gg_protobuf_valid_chkunknown(gs, "ProtobufKVP", &kvp->base);
        tmp_if_expr$6 = return_value_gg_protobuf_valid_chkunknown$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!(kvp == ((struct _ProtobufKVP *)NULL)) && tmp_if_expr$6)
        gg_debug_session(gs, 16, "// gg_session_handle_options[%s] = \"%s\"\n", kvp->key, kvp->value);

    }
    gg110_options__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    return 0;
  }
}

// gg_session_handle_packet
// file ../include/session.h line 65
signed int gg_session_handle_packet(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  unsigned int i;
  gg_debug_session(gs, 8, "// gg_session_handle_packet(%d, %p, %zu)\n", type, ptr, len);
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  gs->last_event = (signed int)return_value_time$1;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 56ul); i = i + 1u)
  {
    if(!(handlers$link1[(signed long int)i].type == 0u))
    {
      if(!(handlers$link1[(signed long int)i].type == type))
        goto __CPROVER_DUMP_L5;

    }

    if(!((signed int)handlers$link1[(signed long int)i].state == 0))
    {
      if(handlers$link1[(signed long int)i].state == (enum gg_state_t)gs->state)
        goto __CPROVER_DUMP_L3;

      gg_debug_session(gs, 64, "// gg_session_handle_packet() packet 0x%02x unexpected in state %d\n", type, gs->state);
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!(len >= handlers$link1[(signed long int)i].min_length))
        gg_debug_session(gs, 128, "// gg_session_handle_packet() packet 0x%02x too short (%zu bytes)\n", type, len);

      else
      {
        signed int return_value;
        return_value=handlers$link1[(signed long int)i].handler(gs, type, ptr, len, ge);
        return return_value;
      }
    }

  __CPROVER_DUMP_L5:
    ;
  }
  gg_debug_session(gs, 64, "// gg_session_handle_packet() unhandled packet 0x%02x, len %zu, state %d\n", type, len, gs->state);
  return 0;
}

// gg_session_handle_pong
// file handlers.c line 491
static signed int gg_session_handle_pong(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a pong\n");
  ge->type = GG_EVENT_PONG;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  gs->last_pong = (signed int)return_value_time$1;
  return 0;
}

// gg_session_handle_pong_110
// file handlers.c line 2371
static signed int gg_session_handle_pong_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110Pong *msg;
  msg=gg110_pong__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110Pong", (signed int)(msg == (struct _GG110Pong *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110Pong", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(msg == ((struct _GG110Pong *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    gg_debug_session(gs, 16, "// gg_watch_fd_connected() received pong110\n");
    ge->type = GG_EVENT_PONG110;
    ge->event.pong110.time = (signed long int)msg->server_time;
    gg_sync_time(gs, (signed long int)msg->server_time);
    gg110_pong__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    return 0;
  }
}

// gg_session_handle_pubdir50_reply
// file handlers.c line 600
static signed int gg_session_handle_pubdir50_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received pubdir/search reply\n");
  signed int return_value_gg_pubdir50_handle_reply_sess$1;
  return_value_gg_pubdir50_handle_reply_sess$1=gg_pubdir50_handle_reply_sess(gs, ge, ptr, (signed int)len);
  return return_value_gg_pubdir50_handle_reply_sess$1;
}

// gg_session_handle_recv_msg
// file handlers.c line 1091
static signed int gg_session_handle_recv_msg(struct gg_session *sess, unsigned int type, const char *packet, unsigned long int length, struct gg_event *e)
{
  struct gg_recv_msg *r = (struct gg_recv_msg *)packet;
  const char *payload = packet + (signed long int)sizeof(struct gg_recv_msg) /*16ul*/ ;
  const char *payload_end = packet + (signed long int)length;
  unsigned long int len;
  gg_debug_session(sess, 8, "** gg_handle_recv_msg(%p, %zu, %p);\n", packet, length, e);
  unsigned int return_value_gg_fix32$5;
  unsigned int return_value_gg_fix32$6;
  char *return_value_gg_encoding_convert$7;
  void *return_value_malloc$8;
  unsigned int return_value_gg_fix32$9;
  if(!(sess == ((struct gg_session *)NULL)))
  {
    if(r->seq == 0u)
    {
      if(r->msgclass == 0u)
      {
        gg_debug_session(sess, 16, "// gg_handle_recv_msg() oops, silently ignoring the bait\n");
        goto malformed;
      }

    }

    if(payload == payload_end + -1l && (signed int)*payload == 0x02)
    {
      gg_debug_session(sess, 16, "// gg_handle_recv_msg() received ctcp packet\n");
      length = (unsigned long int)1;
    }

    else
    {
      const char *options;
      void *return_value_memchr$1;
      return_value_memchr$1=memchr((const void *)payload, 0, (unsigned long int)(payload_end - payload));
      options = (const char *)return_value_memchr$1;
      if(options == ((const char *)NULL))
      {
        gg_debug_session(sess, 16, "// gg_handle_recv_msg() malformed packet, message out of bounds (0)\n");
        goto malformed;
      }

      length = (unsigned long int)(options - payload);
      unsigned int return_value_gg_fix32$2;
      return_value_gg_fix32$2=gg_fix32(r->sender);
      signed int return_value_gg_handle_recv_msg_options$3;
      return_value_gg_handle_recv_msg_options$3=gg_handle_recv_msg_options(sess, e, return_value_gg_fix32$2, options + (signed long int)1, payload_end, type);
      if(!(return_value_gg_handle_recv_msg_options$3 == -1))
      {
        if(return_value_gg_handle_recv_msg_options$3 == -2)
          goto __CPROVER_DUMP_L5;

        if(return_value_gg_handle_recv_msg_options$3 == -3)
          goto __CPROVER_DUMP_L6;

      }

      else
      {
        unsigned int return_value_gg_fix32$4;
        return_value_gg_fix32$4=gg_fix32(r->seq);
        gg_session_send_msg_ack(sess, return_value_gg_fix32$4);
        return 0;

      __CPROVER_DUMP_L5:
        ;
        goto fail;

      __CPROVER_DUMP_L6:
        ;
        goto malformed;
      }
    }
    e->type = GG_EVENT_MSG;
    return_value_gg_fix32$5=gg_fix32(r->msgclass);
    e->event.msg.msgclass = (signed int)return_value_gg_fix32$5;
    e->event.msg.sender=gg_fix32(r->sender);
    return_value_gg_fix32$6=gg_fix32(r->time);
    e->event.msg.time = (signed long int)return_value_gg_fix32$6;
    e->event.msg.seq=gg_fix32(r->seq);
    return_value_gg_encoding_convert$7=gg_encoding_convert(payload, (enum anonymous$3)GG_ENCODING_CP1250, sess->encoding, (signed int)length, -1);
    e->event.msg.message = (unsigned char *)return_value_gg_encoding_convert$7;
    if(e->event.msg.message == ((unsigned char *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_session_handle_recv_msg() out of memory\n");
      goto fail;
    }

    len=gg_message_text_to_html((char *)(void *)0, (char *)e->event.msg.message, sess->encoding, (const unsigned char *)e->event.msg.formats, (unsigned long int)e->event.msg.formats_length);
    return_value_malloc$8=malloc(len + (unsigned long int)1);
    e->event.msg.xhtml_message = (char *)return_value_malloc$8;
    if(e->event.msg.xhtml_message == ((char *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_session_handle_recv_msg() out of memory\n");
      goto fail;
    }

    gg_message_text_to_html(e->event.msg.xhtml_message, (char *)e->event.msg.message, sess->encoding, (const unsigned char *)e->event.msg.formats, (unsigned long int)e->event.msg.formats_length);
    return_value_gg_fix32$9=gg_fix32(r->seq);
    gg_session_send_msg_ack(sess, return_value_gg_fix32$9);
    return 0;
  }

  else
  {

  fail:
    ;
    free((void *)e->event.msg.message);
    free((void *)e->event.msg.xhtml_message);
    free((void *)e->event.msg.recipients);
    free(e->event.msg.formats);
    return -1;

  malformed:
    ;
    e->type = GG_EVENT_NONE;
    free((void *)e->event.msg.message);
    free((void *)e->event.msg.xhtml_message);
    free((void *)e->event.msg.recipients);
    free(e->event.msg.formats);
    unsigned int return_value_gg_fix32$10;
    return_value_gg_fix32$10=gg_fix32(r->seq);
    gg_session_send_msg_ack(sess, return_value_gg_fix32$10);
    return 0;
  }
}

// gg_session_handle_recv_msg_110
// file handlers.c line 1371
static signed int gg_session_handle_recv_msg_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG110RecvMessage *msg;
  msg=gg110_recv_message__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  unsigned char ack_type;
  unsigned int sender = (unsigned int)0;
  unsigned int seq;
  signed int succ = 1;
  struct gg_event_msg *ev = &ge->event.msg;
  gg_debug_session(gs, 8, "** gg_session_handle_recv_msg_110(%p, %zu, %p);\n", ptr, len, ge);
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110RecvMessage", (signed int)(msg == (struct _GG110RecvMessage *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110RecvMessage", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$6;
  unsigned long int tmp_if_expr$4;
  unsigned long int tmp_if_expr$5;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  if(msg == ((struct _GG110RecvMessage *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    seq = msg->seq;
    if(type == 136u || type == 142u)
      ack_type = (unsigned char)GG110_ACK__TYPE__CHAT;

    else
      ack_type = (unsigned char)GG110_ACK__TYPE__MSG;
    if(!(msg->has_msg_id == 0))
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = msg->has_conv_id != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      if(!(msg->has_msg_id == 0))
        tmp_if_expr$4 = msg->msg_id;

      else
        tmp_if_expr$4 = (unsigned long int)0;
      msg->msg_id = tmp_if_expr$4;
      if(!(msg->has_conv_id == 0))
        tmp_if_expr$5 = msg->conv_id;

      else
        tmp_if_expr$5 = (unsigned long int)0;
      msg->conv_id = tmp_if_expr$5;
      gg_debug_session(gs, 32, "// gg_session_handle_recv_msg_110() msg_id=%016lx conv_id=%016lx\n", msg->msg_id, msg->conv_id);
    }

    if(!(msg->has_sender == 0))
      sender=gg_protobuf_get_uin(msg->sender);

    else
      if(type == 142u)
        sender = gs->uin;

    if(!(msg->has_data == 0))
    {
      if((signed int)*msg->msg_plain == 0)
      {
        if(!(msg->data.len >= sizeof(struct gg_msg_image_reply) /*9ul*/ ))
          gg_debug_session(gs, 128, "// gg_session_handle_recv_msg_110() packet too small (%zu < %zu)\n", msg->data.len, sizeof(struct gg_msg_image_reply) /*9ul*/ );

        else
          gg_image_queue_parse(ge, (char *)msg->data.data, (unsigned int)msg->data.len, gs, sender, type);
        gg110_recv_message__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
        signed int return_value_gg_ack_110$7;
        return_value_gg_ack_110$7=gg_ack_110(gs, (enum _GG110Ack__Type)GG110_ACK__TYPE__MSG, seq, ge);
        return return_value_gg_ack_110$7;
      }

    }

    if(type == 130u || type == 142u)
      ge->type = GG_EVENT_MULTILOGON_MSG;

    else
      ge->type = GG_EVENT_MSG;
    ev->msgclass = 0x0008;
    ev->seq = seq;
    ev->sender = sender;
    ev->flags = (unsigned long int)msg->flags;
    ev->seq = seq;
    ev->time = (signed long int)msg->time;
    signed long int return_value_gg_server_time$8;
    return_value_gg_server_time$8=gg_server_time(gs);
    signed int return_value_abs$9;
    return_value_abs$9=abs((signed int)((signed long int)msg->time - return_value_gg_server_time$8));
    if(return_value_abs$9 >= 3)
      ev->msgclass = ev->msgclass | 0x0001;

    ev->message = (unsigned char *)(void *)0;
    if(!((signed int)*msg->msg_plain == 0))
    {
      char *return_value_gg_encoding_convert$10;
      return_value_gg_encoding_convert$10=gg_encoding_convert(msg->msg_plain, (enum anonymous$3)GG_ENCODING_UTF8, gs->encoding, -1, -1);
      ev->message = (unsigned char *)return_value_gg_encoding_convert$10;
      if(!(succ == 0))
        tmp_if_expr$11 = ev->message != (unsigned char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$11 = (_Bool)0;
      succ = (signed int)tmp_if_expr$11;
    }

    ev->xhtml_message = (char *)(void *)0;
    if(!(msg->msg_xhtml == ((char *)NULL)))
    {
      ev->xhtml_message=gg_encoding_convert(msg->msg_xhtml, (enum anonymous$3)GG_ENCODING_UTF8, gs->encoding, -1, -1);
      if(!(succ == 0))
        tmp_if_expr$12 = ev->xhtml_message != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$12 = (_Bool)0;
      succ = (signed int)tmp_if_expr$12;
    }

    if(ev->message == ((unsigned char *)NULL))
      tmp_if_expr$18 = ev->xhtml_message == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$18 = (_Bool)0;
    if(tmp_if_expr$18)
    {
      char *return_value_strdup$13;
      return_value_strdup$13=strdup("");
      ev->message = (unsigned char *)return_value_strdup$13;
      if(!(succ == 0))
        tmp_if_expr$14 = ev->message != (unsigned char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$14 = (_Bool)0;
      succ = (signed int)tmp_if_expr$14;
    }

    else
      if(ev->message == ((unsigned char *)NULL))
      {
        char *return_value_gg_message_html_to_text_110$15;
        return_value_gg_message_html_to_text_110$15=gg_message_html_to_text_110(ev->xhtml_message);
        ev->message = (unsigned char *)return_value_gg_message_html_to_text_110$15;
        if(!(succ == 0))
          tmp_if_expr$16 = ev->message != (unsigned char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$16 = (_Bool)0;
        succ = (signed int)tmp_if_expr$16;
      }

      else
        if(ev->xhtml_message == ((char *)NULL))
        {
          ev->xhtml_message=gg_message_text_to_html_110((char *)ev->message, (signed long int)-1);
          if(!(succ == 0))
            tmp_if_expr$17 = ev->xhtml_message != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$17 = (_Bool)0;
          succ = (signed int)tmp_if_expr$17;
        }

    ev->formats = (void *)0;
    ev->formats_length = 0;
    if(!(msg->has_data == 0))
    {
      if(!(succ == 0))
      {
        ev->formats_length = (signed int)msg->data.len;
        ev->formats=malloc(msg->data.len);
        if(ev->formats == NULL)
          succ = 0;

        else
          memcpy(ev->formats, (const void *)msg->data.data, msg->data.len);
      }

    }

    if(!(msg->has_chat_id == 0))
    {
      if(!(succ == 0))
      {
        struct _gg_chat_list *chat;
        ev->chat_id = msg->chat_id;
        chat=gg_chat_find(gs, msg->chat_id);
        if(!(chat == ((struct _gg_chat_list *)NULL)))
        {
          unsigned long int rcpt_size = (unsigned long int)chat->participants_count * sizeof(unsigned int) /*4ul*/ ;
          void *return_value_malloc$19;
          return_value_malloc$19=malloc(rcpt_size);
          ev->recipients = (unsigned int *)return_value_malloc$19;
          ev->recipients_count = (signed int)chat->participants_count;
          if(ev->recipients == ((unsigned int *)NULL))
            succ = 0;

          else
            memcpy((void *)ev->recipients, (const void *)chat->participants, rcpt_size);
        }

      }

    }

    gg110_recv_message__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    signed int return_value_gg_ack_110$20;
    return_value_gg_ack_110$20=gg_ack_110(gs, (enum _GG110Ack__Type)ack_type, seq, ge);
    if(!(return_value_gg_ack_110$20 == 0))
      succ = 0;

    if(!(succ == 0))
      return 0;

    else
    {
      free((void *)ev->message);
      free((void *)ev->xhtml_message);
      free(ev->formats);
      free((void *)ev->recipients);
      return -1;
    }
  }
}

// gg_session_handle_recv_msg_80
// file handlers.c line 1193
static signed int gg_session_handle_recv_msg_80(struct gg_session *sess, unsigned int type, const char *packet, unsigned long int length, struct gg_event *e)
{
  struct gg_recv_msg80 *r = (struct gg_recv_msg80 *)packet;
  unsigned int offset_plain;
  unsigned int offset_attr;
  gg_debug_session(sess, 8, "** gg_handle_recv_msg80(%p, %zu, %p);\n", packet, length, e);
  void *return_value_memchr$1;
  void *return_value_memchr$2;
  unsigned int return_value_gg_fix32$3;
  unsigned int return_value_gg_fix32$4;
  unsigned int return_value_gg_fix32$12;
  if(!(sess == ((struct gg_session *)NULL)))
  {
    if(r->seq == 0u)
    {
      if(r->msgclass == 0u)
      {
        gg_debug_session(sess, 16, "// gg_handle_recv_msg80() oops, silently ignoring the bait\n");
        goto malformed;
      }

    }

    offset_plain=gg_fix32(r->offset_plain);
    offset_attr=gg_fix32(r->offset_attr);
    if((unsigned long int)offset_plain >= length || !((unsigned long int)offset_plain >= sizeof(struct gg_recv_msg80) /*24ul*/ ))
    {
      gg_debug_session(sess, 16, "// gg_handle_recv_msg80() malformed packet, message out of bounds (0)\n");
      goto malformed;
    }

    if(!(length >= (unsigned long int)offset_attr) || !((unsigned long int)offset_attr >= sizeof(struct gg_recv_msg80) /*24ul*/ ))
    {
      gg_debug_session(sess, 16, "// gg_handle_recv_msg80() malformed packet, attr out of bounds (1)\n");
      offset_attr = (unsigned int)0;
    }

    if((unsigned long int)offset_attr == length)
      offset_attr = (unsigned int)0;

    return_value_memchr$1=memchr((const void *)(packet + (signed long int)offset_plain), 0, length - (unsigned long int)offset_plain);
    if(return_value_memchr$1 == NULL)
    {
      gg_debug_session(sess, 16, "// gg_handle_recv_msg80() malformed packet, message out of bounds (2)\n");
      goto malformed;
    }

    if((unsigned long int)offset_plain >= 25ul)
    {
      return_value_memchr$2=memchr((const void *)(packet + (signed long int)sizeof(struct gg_recv_msg80) /*24ul*/ ), 0, (unsigned long int)offset_plain - sizeof(struct gg_recv_msg80) /*24ul*/ );
      if(return_value_memchr$2 == NULL)
      {
        gg_debug_session(sess, 16, "// gg_handle_recv_msg80() malformed packet, message out of bounds (3)\n");
        goto malformed;
      }

    }

    e->type = type != (unsigned int)0x005a ? GG_EVENT_MSG : GG_EVENT_MULTILOGON_MSG;
    return_value_gg_fix32$3=gg_fix32(r->msgclass);
    e->event.msg.msgclass = (signed int)return_value_gg_fix32$3;
    e->event.msg.sender=gg_fix32(r->sender);
    return_value_gg_fix32$4=gg_fix32(r->time);
    e->event.msg.time = (signed long int)return_value_gg_fix32$4;
    e->event.msg.seq=gg_fix32(r->seq);
    if(!(offset_attr == 0u))
    {
      unsigned int return_value_gg_fix32$5;
      return_value_gg_fix32$5=gg_fix32(r->sender);
      signed int return_value_gg_handle_recv_msg_options$6;
      return_value_gg_handle_recv_msg_options$6=gg_handle_recv_msg_options(sess, e, return_value_gg_fix32$5, packet + (signed long int)offset_attr, packet + (signed long int)length, type);
      if(!(return_value_gg_handle_recv_msg_options$6 == -1))
      {
        if(return_value_gg_handle_recv_msg_options$6 == -2)
          goto __CPROVER_DUMP_L8;

        if(return_value_gg_handle_recv_msg_options$6 == -3)
          goto __CPROVER_DUMP_L9;

      }

      else
      {
        unsigned int return_value_gg_fix32$7;
        return_value_gg_fix32$7=gg_fix32(r->seq);
        gg_session_send_msg_ack(sess, return_value_gg_fix32$7);
        return 0;

      __CPROVER_DUMP_L8:
        ;
        goto fail;

      __CPROVER_DUMP_L9:
        ;
        goto malformed;
      }
    }

    if((signed int)sess->encoding == GG_ENCODING_CP1250)
    {
      char *return_value_strdup$8;
      return_value_strdup$8=strdup(packet + (signed long int)offset_plain);
      e->event.msg.message = (unsigned char *)return_value_strdup$8;
      if(e->event.msg.message == ((unsigned char *)NULL))
      {
        gg_debug_session(sess, 16, "// gg_session_handle_recv_msg_80() out of memory\n");
        goto fail;
      }

    }

    else
      if((unsigned long int)offset_plain >= 25ul)
      {
        unsigned long int len;
        unsigned long int fmt_len;
        len=gg_message_html_to_text((char *)(void *)0, (unsigned char *)(void *)0, &fmt_len, packet + (signed long int)sizeof(struct gg_recv_msg80) /*24ul*/ , (enum anonymous$3)GG_ENCODING_UTF8);
        void *return_value_malloc$9;
        return_value_malloc$9=malloc(len + (unsigned long int)1);
        e->event.msg.message = (unsigned char *)return_value_malloc$9;
        if(e->event.msg.message == ((unsigned char *)NULL))
        {
          gg_debug_session(sess, 16, "// gg_session_handle_recv_msg_80() out of memory\n");
          goto fail;
        }

        free(e->event.msg.formats);
        e->event.msg.formats_length = (signed int)fmt_len;
        e->event.msg.formats=malloc(fmt_len);
        if(e->event.msg.formats == NULL)
        {
          gg_debug_session(sess, 16, "// gg_session_handle_recv_msg_80() out of memory\n");
          goto fail;
        }

        gg_message_html_to_text((char *)e->event.msg.message, (unsigned char *)e->event.msg.formats, (unsigned long int *)(void *)0, packet + (signed long int)sizeof(struct gg_recv_msg80) /*24ul*/ , (enum anonymous$3)GG_ENCODING_UTF8);
      }

      else
      {
        char *return_value_gg_encoding_convert$10;
        return_value_gg_encoding_convert$10=gg_encoding_convert(packet + (signed long int)offset_plain, (enum anonymous$3)GG_ENCODING_CP1250, sess->encoding, -1, -1);
        e->event.msg.message = (unsigned char *)return_value_gg_encoding_convert$10;
        if(e->event.msg.message == ((unsigned char *)NULL))
        {
          gg_debug_session(sess, 16, "// gg_session_handle_recv_msg_80() out of memory\n");
          goto fail;
        }

      }
    if((unsigned long int)offset_plain >= 25ul)
    {
      e->event.msg.xhtml_message=gg_encoding_convert(packet + (signed long int)sizeof(struct gg_recv_msg80) /*24ul*/ , (enum anonymous$3)GG_ENCODING_UTF8, sess->encoding, -1, -1);
      if(e->event.msg.xhtml_message == ((char *)NULL))
      {
        gg_debug_session(sess, 16, "// gg_session_handle_recv_msg_80() out of memory\n");
        goto fail;
      }

    }

    else
    {
      unsigned long int gg_session_handle_recv_msg_80$$1$$10$$len;
      gg_session_handle_recv_msg_80$$1$$10$$len=gg_message_text_to_html((char *)(void *)0, (char *)e->event.msg.message, sess->encoding, (const unsigned char *)e->event.msg.formats, (unsigned long int)e->event.msg.formats_length);
      void *return_value_malloc$11;
      return_value_malloc$11=malloc(gg_session_handle_recv_msg_80$$1$$10$$len + (unsigned long int)1);
      e->event.msg.xhtml_message = (char *)return_value_malloc$11;
      if(e->event.msg.xhtml_message == ((char *)NULL))
      {
        gg_debug_session(sess, 16, "// gg_session_handle_recv_msg_80() out of memory\n");
        goto fail;
      }

      gg_message_text_to_html(e->event.msg.xhtml_message, (char *)e->event.msg.message, sess->encoding, (const unsigned char *)e->event.msg.formats, (unsigned long int)e->event.msg.formats_length);
    }
    return_value_gg_fix32$12=gg_fix32(r->seq);
    gg_session_send_msg_ack(sess, return_value_gg_fix32$12);
    return 0;
  }

  else
  {

  fail:
    ;
    free((void *)e->event.msg.message);
    free((void *)e->event.msg.xhtml_message);
    free((void *)e->event.msg.recipients);
    free(e->event.msg.formats);
    return -1;

  malformed:
    ;
    e->type = GG_EVENT_NONE;
    free((void *)e->event.msg.message);
    free((void *)e->event.msg.xhtml_message);
    free((void *)e->event.msg.recipients);
    free(e->event.msg.formats);
    unsigned int return_value_gg_fix32$13;
    return_value_gg_fix32$13=gg_fix32(r->seq);
    gg_session_send_msg_ack(sess, return_value_gg_fix32$13);
    return 0;
  }
}

// gg_session_handle_send_msg_ack
// file handlers.c line 409
static signed int gg_session_handle_send_msg_ack(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_session_private *p = gs->private_data;
  struct gg_send_msg_ack *s = (struct gg_send_msg_ack *)ptr;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a message ack\n");
  ge->type = GG_EVENT_ACK;
  unsigned int return_value_gg_fix32$1;
  return_value_gg_fix32$1=gg_fix32(s->status);
  ge->event.ack.status = (signed int)return_value_gg_fix32$1;
  ge->event.ack.recipient=gg_fix32(s->recipient);
  unsigned int return_value_gg_fix32$2;
  return_value_gg_fix32$2=gg_fix32(s->seq);
  ge->event.ack.seq = (signed int)return_value_gg_fix32$2;
  if(ge->event.ack.seq == 0)
  {
    if(p->imgout_waiting_ack >= 1)
      p->imgout_waiting_ack = p->imgout_waiting_ack - 1;

  }

  gg_image_sendout(gs);
  return 0;
}

// gg_session_handle_send_msg_ack_110
// file handlers.c line 432
static signed int gg_session_handle_send_msg_ack_110(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_session_private *p = gs->private_data;
  struct _GG110MessageAck *msg;
  msg=gg110_message_ack__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  unsigned long int i;
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG110MessageAck", (signed int)(msg == (struct _GG110MessageAck *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG110MessageAck", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$6;
  signed int return_value_gg_protobuf_valid_chkunknown$5;
  if(msg == ((struct _GG110MessageAck *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    if(msg->dummy1 == 16384u)
      gg_debug_session(gs, 16 | 64, "// gg_session_handle_send_msg_ack_110() magic dummy1 value 0x4000\n");

    else
      if(!(msg->dummy1 == 0u))
        gg_debug_session(gs, 16 | 64, "// gg_session_handle_send_msg_ack_110() unknown dummy1 value: %x\n", msg->dummy1);

    gg_debug_session(gs, 32, "// gg_session_handle_send_msg_ack_110() %s=%016lx %s=%016lx\n", msg->has_msg_id != 0 ? "msg_id" : "0", msg->msg_id, msg->has_conv_id != 0 ? "conv_id" : "0", msg->conv_id);
    i = (unsigned long int)0;
    for( ; !(i >= msg->n_links); i = i + 1ul)
    {
      struct _GG110MessageAckLink *link = msg->links[(signed long int)i];
      signed int return_value_gg_protobuf_valid_chknull$4;
      return_value_gg_protobuf_valid_chknull$4=gg_protobuf_valid_chknull(gs, "GG110MessageAckLink", (signed int)(link == (struct _GG110MessageAckLink *)(void *)0));
      if(!(return_value_gg_protobuf_valid_chknull$4 == 0))
      {
        return_value_gg_protobuf_valid_chkunknown$5=gg_protobuf_valid_chkunknown(gs, "GG110MessageAckLink", &link->base);
        tmp_if_expr$6 = return_value_gg_protobuf_valid_chkunknown$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!(link == ((struct _GG110MessageAckLink *)NULL)) && tmp_if_expr$6)
        gg_debug_session(gs, 16, "// gg_session_handle_send_msg_ack_110() got link (id=%lx) \"%s\"\n", link->id, link->url);

    }
    ge->type = GG_EVENT_ACK110;
    ge->event.ack110.msg_type = (unsigned char)msg->msg_type;
    ge->event.ack110.seq = msg->seq;
    ge->event.ack110.time = msg->time;
    gg_compat_message_ack(gs, (signed int)msg->seq);
    gg110_message_ack__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    if(msg->seq == 0u)
    {
      if(p->imgout_waiting_ack >= 1)
        p->imgout_waiting_ack = p->imgout_waiting_ack - 1;

    }

    gg_image_sendout(gs);
    return 0;
  }
}

// gg_session_handle_status
// file handlers.c line 1517
static signed int gg_session_handle_status(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_status *s = (struct gg_status *)(const void *)ptr;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a status change\n");
  ge->type = GG_EVENT_STATUS;
  ge->event.status.uin=gg_fix32(s->uin);
  ge->event.status.status=gg_fix32(s->status);
  ge->event.status.descr = (char *)(void *)0;
  if(len >= 9ul)
  {
    ge->event.status.descr=gg_encoding_convert(ptr + (signed long int)sizeof(struct gg_status) /*8ul*/ , (enum anonymous$3)GG_ENCODING_CP1250, gs->encoding, (signed int)(len - sizeof(struct gg_status) /*8ul*/ ), -1);
    if(!(ge->event.status.descr == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// gg_session_handle_status_60_77_80beta
// file handlers.c line 1547
static signed int gg_session_handle_status_60_77_80beta(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_status60 *s60 = (struct gg_status60 *)(const void *)ptr;
  struct gg_status77 *s77 = (struct gg_status77 *)(const void *)ptr;
  unsigned long int struct_len;
  unsigned int uin;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a status change\n");
  ge->type = GG_EVENT_STATUS60;
  ge->event.status60.descr = (char *)(void *)0;
  ge->event.status60.time = (signed long int)0;
  if(type == 15u)
  {
    uin=gg_fix32(s60->uin);
    ge->event.status60.status = (signed int)s60->status;
    ge->event.status60.remote_ip = s60->remote_ip;
    ge->event.status60.remote_port=gg_fix16(s60->remote_port);
    ge->event.status60.version = (signed int)s60->version;
    ge->event.status60.image_size = (signed int)s60->image_size;
    struct_len = sizeof(struct gg_status60) /*14ul*/ ;
  }

  else
  {
    uin=gg_fix32(s77->uin);
    ge->event.status60.status = (signed int)s77->status;
    ge->event.status60.remote_ip = s77->remote_ip;
    ge->event.status60.remote_port=gg_fix16(s77->remote_port);
    ge->event.status60.version = (signed int)s77->version;
    ge->event.status60.image_size = (signed int)s77->image_size;
    struct_len = sizeof(struct gg_status77) /*18ul*/ ;
  }
  ge->event.status60.uin = uin & (unsigned int)0x00ffffff;
  if(!((1073741824u & uin) == 0u))
    ge->event.status60.version = ge->event.status60.version | 0x40000000;

  if(!((536870912u & uin) == 0u))
    ge->event.status60.version = ge->event.status60.version | 0x20000000;

  if(!((134217728u & uin) == 0u))
    ge->event.status60.version = ge->event.status60.version | 0x04000000;

  if(!(struct_len >= len))
  {
    unsigned long int descr_len = len - struct_len;
    ge->event.status60.descr=gg_encoding_convert(ptr + (signed long int)struct_len, (enum anonymous$3)(type == (unsigned int)0x002a ? GG_ENCODING_UTF8 : GG_ENCODING_CP1250), gs->encoding, (signed int)descr_len, -1);
    if(ge->event.status60.descr == ((char *)NULL))
    {
      gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
      return -1;
    }

    if(descr_len >= 5ul)
    {
      if((signed int)ptr[-5l + (signed long int)len] == 0)
      {
        unsigned int t;
        memcpy((void *)&t, (const void *)((ptr + (signed long int)len) - (signed long int)4), sizeof(unsigned int) /*4ul*/ );
        unsigned int return_value_gg_fix32$1;
        return_value_gg_fix32$1=gg_fix32(t);
        ge->event.status60.time = (signed long int)return_value_gg_fix32$1;
      }

    }

  }

  return 0;
}

// gg_session_handle_status_80
// file handlers.c line 1685
static signed int gg_session_handle_status_80(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_notify_reply80 *n = (struct gg_notify_reply80 *)(const void *)ptr;
  unsigned long int descr_len;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received a status change\n");
  ge->type = GG_EVENT_STATUS60;
  ge->event.status60.uin=gg_fix32(n->uin);
  unsigned int return_value_gg_fix32$1;
  return_value_gg_fix32$1=gg_fix32(n->status);
  ge->event.status60.status = (signed int)return_value_gg_fix32$1;
  ge->event.status60.remote_ip = n->remote_ip;
  ge->event.status60.remote_port=gg_fix16(n->remote_port);
  ge->event.status60.version = 0;
  ge->event.status60.image_size = (signed int)n->image_size;
  ge->event.status60.descr = (char *)(void *)0;
  ge->event.status60.time = (signed long int)0;
  unsigned int return_value_gg_fix32$2;
  return_value_gg_fix32$2=gg_fix32(n->descr_len);
  descr_len = (unsigned long int)return_value_gg_fix32$2;
  if(len >= sizeof(struct gg_notify_reply80) /*28ul*/  + descr_len && !(descr_len == 0ul))
  {
    ge->event.status60.descr=gg_encoding_convert((const char *)n + (signed long int)sizeof(struct gg_notify_reply80) /*28ul*/ , (enum anonymous$3)GG_ENCODING_UTF8, gs->encoding, (signed int)descr_len, -1);
    if(!(ge->event.status60.descr == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// gg_session_handle_transfer_info
// file handlers.c line 2658
static signed int gg_session_handle_transfer_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct _GG112TransferInfo *msg;
  msg=gg112_transfer_info__unpack((struct ProtobufCAllocator *)(void *)0, len, (unsigned char *)ptr);
  signed int succ = 1;
  unsigned long int i;
  unsigned int peer = (unsigned int)0;
  unsigned int sender = (unsigned int)0;
  signed int return_value_gg_protobuf_valid_chknull$1;
  return_value_gg_protobuf_valid_chknull$1=gg_protobuf_valid_chknull(gs, "GG112TransferInfo", (signed int)(msg == (struct _GG112TransferInfo *)(void *)0));
  _Bool tmp_if_expr$3;
  signed int return_value_gg_protobuf_valid_chkunknown$2;
  if(!(return_value_gg_protobuf_valid_chknull$1 == 0))
  {
    return_value_gg_protobuf_valid_chkunknown$2=gg_protobuf_valid_chkunknown(gs, "GG112TransferInfo", &msg->base);
    tmp_if_expr$3 = return_value_gg_protobuf_valid_chkunknown$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  signed int return_value_gg_protobuf_valid_chkunknown$4;
  signed int return_value_gg_protobuf_valid_chkunknown$6;
  _Bool tmp_if_expr$10;
  signed int return_value_gg_protobuf_valid_chkunknown$9;
  signed int return_value_gg_protobuf_valid_chknull$12;
  signed int return_value_gg_protobuf_valid_chkunknown$11;
  if(msg == ((struct _GG112TransferInfo *)NULL) || !tmp_if_expr$3)
    return -1;

  else
  {
    if(!(msg->dummy1 == 5u))
    {
      if(!(msg->dummy1 == 6u))
        gg_debug_session(gs, 16 | 64, "// gg_session_handle_transfer_info: unknown dummy1 value: %d\n", msg->dummy1);

    }

    signed int return_value_gg_protobuf_valid_chknull$5;
    return_value_gg_protobuf_valid_chknull$5=gg_protobuf_valid_chknull(gs, "GG112TransferInfoUin", (signed int)(msg->peer == (struct _GG112TransferInfoUin *)(void *)0));
    if(!(return_value_gg_protobuf_valid_chknull$5 == 0))
    {
      return_value_gg_protobuf_valid_chkunknown$4=gg_protobuf_valid_chkunknown(gs, "GG112TransferInfoUin", &msg->peer->base);
      if(!(return_value_gg_protobuf_valid_chkunknown$4 == 0))
      {
        if(!(msg->peer == ((struct _GG112TransferInfoUin *)NULL)))
        {
          gg_protobuf_expected(gs, "GG112TransferInfoUin.dummy1", msg->peer->dummy1, (unsigned int)1);
          peer=gg_protobuf_get_uin(msg->peer->uin);
        }

      }

    }

    signed int return_value_gg_protobuf_valid_chknull$7;
    return_value_gg_protobuf_valid_chknull$7=gg_protobuf_valid_chknull(gs, "GG112TransferInfoUin", (signed int)(msg->sender == (struct _GG112TransferInfoUin *)(void *)0));
    if(!(return_value_gg_protobuf_valid_chknull$7 == 0))
    {
      return_value_gg_protobuf_valid_chkunknown$6=gg_protobuf_valid_chkunknown(gs, "GG112TransferInfoUin", &msg->sender->base);
      if(!(return_value_gg_protobuf_valid_chkunknown$6 == 0))
      {
        if(!(msg->sender == ((struct _GG112TransferInfoUin *)NULL)))
        {
          gg_protobuf_expected(gs, "GG112TransferInfoUin.dummy1", msg->sender->dummy1, (unsigned int)1);
          sender=gg_protobuf_get_uin(msg->sender->uin);
        }

      }

    }

    gg_debug_session(gs, 16, "// gg_session_handle_transfer_info: dummy1=%#x, time=%u, sender=%u, peer=%u, msg_id=%#016lx, conv_id=%#016lx\n", msg->dummy1, msg->time, sender, peer, msg->msg_id, msg->conv_id);
    i = (unsigned long int)0;
    for( ; !(i >= msg->n_data); i = i + 1ul)
    {
      struct _ProtobufKVP *kvp = msg->data[(signed long int)i];
      signed int return_value_gg_protobuf_valid_chknull$8;
      return_value_gg_protobuf_valid_chknull$8=gg_protobuf_valid_chknull(gs, "ProtobufKVP", (signed int)(kvp == (struct _ProtobufKVP *)(void *)0));
      if(!(return_value_gg_protobuf_valid_chknull$8 == 0))
      {
        return_value_gg_protobuf_valid_chkunknown$9=gg_protobuf_valid_chkunknown(gs, "ProtobufKVP", &kvp->base);
        tmp_if_expr$10 = return_value_gg_protobuf_valid_chkunknown$9 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$10 = (_Bool)0;
      if(!(kvp == ((struct _ProtobufKVP *)NULL)) && tmp_if_expr$10)
        gg_debug_session(gs, 16, "// gg_session_handle_transfer_info[%s] = \"%s\"\n", kvp->key, kvp->value);

    }
    if(!(msg->file == ((struct _GG112TransferInfoFile *)NULL)))
    {
      return_value_gg_protobuf_valid_chknull$12=gg_protobuf_valid_chknull(gs, "GG112TransferInfoFile", (signed int)(msg->file == (struct _GG112TransferInfoFile *)(void *)0));
      if(!(return_value_gg_protobuf_valid_chknull$12 == 0))
      {
        return_value_gg_protobuf_valid_chkunknown$11=gg_protobuf_valid_chkunknown(gs, "GG112TransferInfoFile", &msg->file->base);
        if(!(return_value_gg_protobuf_valid_chkunknown$11 == 0))
        {
          if(!(msg->file == ((struct _GG112TransferInfoFile *)NULL)))
          {
            struct _GG112TransferInfoFile *file = msg->file;
            gg_debug_session(gs, 16, "// gg_session_handle_transfer_info file: type=\"%s\", content_type=\"%s\", filename=\"%s\", filesize=%u, msg_id=%#016lx url=\"%s\"\n", file->type, file->content_type, file->filename, file->filesize, file->msg_id, file->url);
          }

        }

      }

    }

    signed int return_value_gg_ack_110$13;
    return_value_gg_ack_110$13=gg_ack_110(gs, (enum _GG110Ack__Type)GG110_ACK__TYPE__TRANSFER_INFO, msg->seq, ge);
    succ = (signed int)(return_value_gg_ack_110$13 == 0);
    gg112_transfer_info__free_unpacked(msg, (struct ProtobufCAllocator *)(void *)0);
    return succ != 0 ? 0 : -1;
  }
}

// gg_session_handle_typing_notification
// file handlers.c line 2183
static signed int gg_session_handle_typing_notification(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_typing_notification *n = (struct gg_typing_notification *)(const void *)ptr;
  unsigned int uin;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received typing notification\n");
  memcpy((void *)&uin, (const void *)&n->uin, sizeof(unsigned int) /*4ul*/ );
  ge->type = GG_EVENT_TYPING_NOTIFICATION;
  ge->event.typing_notification.uin=gg_fix32(uin);
  unsigned short int return_value_gg_fix16$1;
  return_value_gg_fix16$1=gg_fix16(n->length);
  ge->event.typing_notification.length = (signed int)return_value_gg_fix16$1;
  return 0;
}

// gg_session_handle_uin_info
// file handlers.c line 2624
static signed int gg_session_handle_uin_info(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_tvbuff *tvb;
  char *uin1 = (char *)(void *)0;
  char *uin2 = (char *)(void *)0;
  tvb=gg_tvbuff_new(ptr, len);
  gg_tvbuff_expected_uint32(tvb, (unsigned int)1);
  gg_tvbuff_expected_uint32(tvb, (unsigned int)2);
  gg_tvbuff_expected_uint8(tvb, (unsigned char)0);
  gg_tvbuff_read_str_dup(tvb, &uin1);
  gg_tvbuff_expected_uint8(tvb, (unsigned char)1);
  gg_tvbuff_read_str_dup(tvb, &uin2);
  signed int return_value_gg_tvbuff_close$1;
  return_value_gg_tvbuff_close$1=gg_tvbuff_close(tvb);
  if(return_value_gg_tvbuff_close$1 == 0)
  {
    free((void *)uin1);
    free((void *)uin2);
    return -1;
  }

  else
  {
    gg_debug_session(gs, 16, "// gg_session_handle_uin_info: uin1=\"%s\", uin2=\"%s\"\n", uin1, uin2);
    free((void *)uin1);
    free((void *)uin2);
    return 0;
  }
}

// gg_session_handle_user_data
// file handlers.c line 1980
static signed int gg_session_handle_user_data(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_user_data d;
  const char *p = (const char *)ptr;
  const char *packet_end = (const char *)ptr + (signed long int)len;
  struct gg_event_user_data_user *users;
  unsigned int i;
  unsigned int j;
  signed int res = 0;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received user data\n");
  ge->event.user_data.user_count = (unsigned long int)0;
  ge->event.user_data.users = (struct gg_event_user_data_user *)(void *)0;
  if(packet_end >= ptr + (signed long int)sizeof(struct gg_user_data) /*8l*/ )
  {
    memcpy((void *)&d, (const void *)p, sizeof(struct gg_user_data) /*8ul*/ );
    p = p + (signed long int)sizeof(struct gg_user_data) /*8ul*/ ;
    d.type=gg_fix32(d.type);
    d.user_count=gg_fix32(d.user_count);
    if(d.user_count >= 65536u)
      gg_debug_session(gs, 16, "// gg_session_handle_user_data() malformed packet (1)\n");

    else
    {
      if(d.user_count >= 1u)
      {
        void *return_value_calloc$1;
        return_value_calloc$1=calloc((unsigned long int)d.user_count, sizeof(struct gg_event_user_data_user) /*24ul*/ );
        users = (struct gg_event_user_data_user *)return_value_calloc$1;
        if(users == ((struct gg_event_user_data_user *)NULL))
        {
          gg_debug_session(gs, 16, "// gg_session_handle_user_data() out of memory (%d*%zu)\n", d.user_count, sizeof(struct gg_event_user_data_user) /*24ul*/ );
          goto fail;
        }

      }

      else
        users = (struct gg_event_user_data_user *)(void *)0;
      ge->type = GG_EVENT_USER_DATA;
      ge->event.user_data.type = (signed int)d.type;
      ge->event.user_data.user_count = (unsigned long int)d.user_count;
      ge->event.user_data.users = users;
      gg_debug_session(gs, 4, "type=%d, count=%d\n", d.type, d.user_count);
      i = (unsigned int)0;
      for( ; !(i >= d.user_count); i = i + 1u)
      {
        struct gg_user_data_user u;
        struct gg_event_user_data_attr *attrs;
        if(!(packet_end >= p + (signed long int)sizeof(struct gg_user_data_user) /*8l*/ ))
        {
          gg_debug_session(gs, 16, "// gg_session_handle_user_data() malformed packet (2)\n");
          goto malformed;
        }

        memcpy((void *)&u, (const void *)p, sizeof(struct gg_user_data_user) /*8ul*/ );
        p = p + (signed long int)sizeof(struct gg_user_data_user) /*8ul*/ ;
        u.uin=gg_fix32(u.uin);
        u.attr_count=gg_fix32(u.attr_count);
        if(u.attr_count >= 65536u)
        {
          gg_debug_session(gs, 16, "// gg_session_handle_user_data() malformed packet (2)\n");
          goto malformed;
        }

        if(u.attr_count >= 1u)
        {
          void *return_value_calloc$2;
          return_value_calloc$2=calloc((unsigned long int)u.attr_count, sizeof(struct gg_event_user_data_attr) /*24ul*/ );
          attrs = (struct gg_event_user_data_attr *)return_value_calloc$2;
          if(attrs == ((struct gg_event_user_data_attr *)NULL))
          {
            gg_debug_session(gs, 16, "// gg_session_handle_user_data() out of memory (%d*%zu)\n", u.attr_count, sizeof(struct gg_event_user_data_attr) /*24ul*/ );
            goto fail;
          }

        }

        else
          attrs = (struct gg_event_user_data_attr *)(void *)0;
        (users + (signed long int)i)->uin = u.uin;
        (users + (signed long int)i)->attr_count = (unsigned long int)u.attr_count;
        (users + (signed long int)i)->attrs = attrs;
        gg_debug_session(gs, 4, "    uin=%d, count=%d\n", u.uin, u.attr_count);
        j = (unsigned int)0;
        for( ; !(j >= u.attr_count); j = j + 1u)
        {
          unsigned int key_size;
          unsigned int attr_type;
          unsigned int value_size;
          char *key;
          char *value;
          if(!(packet_end >= p + (signed long int)sizeof(unsigned int) /*4l*/ ))
          {
            gg_debug_session(gs, 16, "// gg_session_handle_user_data()malformed packet (3)\n");
            goto malformed;
          }

          memcpy((void *)&key_size, (const void *)p, sizeof(unsigned int) /*4ul*/ );
          p = p + (signed long int)sizeof(unsigned int) /*4ul*/ ;
          key_size=gg_fix32(key_size);
          if(key_size >= 65536u || !(packet_end >= p + (signed long int)key_size))
          {
            gg_debug_session(gs, 16, "// gg_session_handle_user_data() malformed packet (3)\n");
            goto malformed;
          }

          void *return_value_malloc$3;
          return_value_malloc$3=malloc((unsigned long int)(key_size + (unsigned int)1));
          key = (char *)return_value_malloc$3;
          if(key == ((char *)NULL))
          {
            gg_debug_session(gs, 16, "// gg_session_handle_user_data() out of memory (%d)\n", key_size + (unsigned int)1);
            goto fail;
          }

          memcpy((void *)key, (const void *)p, (unsigned long int)key_size);
          p = p + (signed long int)key_size;
          key[(signed long int)key_size] = (char)0;
          (attrs + (signed long int)j)->key = key;
          if(!(packet_end >= p + (signed long int)(sizeof(unsigned int) * 2) /*8l*/ ))
          {
            gg_debug_session(gs, 16, "// gg_session_handle_user_data() malformed packet (4)\n");
            goto malformed;
          }

          memcpy((void *)&attr_type, (const void *)p, sizeof(unsigned int) /*4ul*/ );
          p = p + (signed long int)sizeof(unsigned int) /*4ul*/ ;
          memcpy((void *)&value_size, (const void *)p, sizeof(unsigned int) /*4ul*/ );
          p = p + (signed long int)sizeof(unsigned int) /*4ul*/ ;
          unsigned int return_value_gg_fix32$4;
          return_value_gg_fix32$4=gg_fix32(attr_type);
          (attrs + (signed long int)j)->type = (signed int)return_value_gg_fix32$4;
          value_size=gg_fix32(value_size);
          if(value_size >= 65536u || !(packet_end >= p + (signed long int)value_size))
          {
            gg_debug_session(gs, 16, "// gg_session_handle_user_data() malformed packet (5)\n");
            goto malformed;
          }

          void *return_value_malloc$5;
          return_value_malloc$5=malloc((unsigned long int)(value_size + (unsigned int)1));
          value = (char *)return_value_malloc$5;
          if(value == ((char *)NULL))
          {
            gg_debug_session(gs, 16, "// gg_session_handle_user_data() out of memory (%d)\n", value_size + (unsigned int)1);
            goto fail;
          }

          memcpy((void *)value, (const void *)p, (unsigned long int)value_size);
          p = p + (signed long int)value_size;
          value[(signed long int)value_size] = (char)0;
          (attrs + (signed long int)j)->value = value;
          gg_debug_session(gs, 4, "\tkey=\"%s\", type=%d, value=\"%s\"\n", key, attr_type, value);
        }
      }
      return 0;

    fail:
      ;
      res = -1;
    }
  }


malformed:
  ;
  ge->type = GG_EVENT_NONE;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= ge->event.user_data.user_count); i = i + 1u)
  {
    j = (unsigned int)0;
    for( ; !((unsigned long int)j >= (ge->event.user_data.users + (signed long int)i)->attr_count); j = j + 1u)
    {
      free((void *)((ge->event.user_data.users + (signed long int)i)->attrs + (signed long int)j)->key);
      free((void *)((ge->event.user_data.users + (signed long int)i)->attrs + (signed long int)j)->value);
    }
    free((void *)(ge->event.user_data.users + (signed long int)i)->attrs);
  }
  free((void *)ge->event.user_data.users);
  return res;
}

// gg_session_handle_userlist_100_reply
// file handlers.c line 2319
static signed int gg_session_handle_userlist_100_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_userlist100_reply *reply = (struct gg_userlist100_reply *)ptr;
  char *data = (char *)(void *)0;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received userlist 100 reply\n");
  if(len >= 8ul)
  {
    data=gg_inflate((const unsigned char *)ptr + (signed long int)sizeof(struct gg_userlist100_reply) /*7ul*/ , len - sizeof(struct gg_userlist100_reply) /*7ul*/ );
    if(!(data == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    gg_debug_session(gs, 16, "// gg_handle_userlist_100_reply() gg_inflate() failed\n");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    ge->type = GG_EVENT_USERLIST100_REPLY;
    ge->event.userlist100_reply.type = (char)reply->type;
    ge->event.userlist100_reply.version=gg_fix32(reply->version);
    ge->event.userlist100_reply.format_type = (char)reply->format_type;
    ge->event.userlist100_reply.reply = data;
    return 0;
  }
}

// gg_session_handle_userlist_100_version
// file handlers.c line 2301
static signed int gg_session_handle_userlist_100_version(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_userlist100_version *version = (struct gg_userlist100_version *)ptr;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received userlist 100 version\n");
  ge->type = GG_EVENT_USERLIST100_VERSION;
  ge->event.userlist100_version.version=gg_fix32(version->version);
  return 0;
}

// gg_session_handle_userlist_reply
// file handlers.c line 613
static signed int gg_session_handle_userlist_reply(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  char reply_type;
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received userlist reply\n");
  reply_type = ptr[(signed long int)0];
  if((signed int)reply_type == 0x00 || (signed int)reply_type == 0x02)
  {
    gs->userlist_blocks = gs->userlist_blocks - 1;
    if(!(gs->userlist_blocks == 0))
      return 0;

    reply_type = (char)0x00;
  }

  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(len >= 2ul)
  {
    unsigned int reply_len;
    if(!(gs->userlist_reply == ((char *)NULL)))
    {
      return_value_strlen$1=strlen(gs->userlist_reply);
      tmp_if_expr$2 = return_value_strlen$1;
    }

    else
      tmp_if_expr$2 = (unsigned long int)0;
    reply_len = (unsigned int)tmp_if_expr$2;
    char *tmp;
    gg_debug_session(gs, 16, "userlist_reply=%p, len=%zu\n", gs->userlist_reply, len);
    if(len + (unsigned long int)reply_len >= 10485761ul)
    {
      gg_debug_session(gs, 16, "// gg_session_handle_userlist_reply() too many userlist replies\n");
      return -1;
    }

    void *return_value_realloc$3;
    return_value_realloc$3=realloc((void *)gs->userlist_reply, (unsigned long int)reply_len + len);
    tmp = (char *)return_value_realloc$3;
    if(tmp == ((char *)NULL))
    {
      gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
      return -1;
    }

    gs->userlist_reply = tmp;
    memcpy((void *)(gs->userlist_reply + (signed long int)reply_len), (const void *)(ptr + (signed long int)1), len - (unsigned long int)1);
    gs->userlist_reply[(signed long int)(((unsigned long int)reply_len + len) - (unsigned long int)1)] = (char)0;
  }

  if((signed int)reply_type == 0x04)
    return 0;

  else
  {
    ge->type = GG_EVENT_USERLIST;
    ge->event.userlist.type = reply_type;
    ge->event.userlist.reply = gs->userlist_reply;
    gs->userlist_reply = (char *)(void *)0;
    return 0;
  }
}

// gg_session_handle_welcome
// file handlers.c line 206
static signed int gg_session_handle_welcome(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  struct gg_welcome *w;
  signed int ret;
  unsigned char hash_buf[64l];
  unsigned int local_ip;
  struct sockaddr_in sin;
  unsigned int sin_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  unsigned int seed;
  struct gg_login80 l80;
  const char *client_name;
  const char *version;
  const char *descr;
  unsigned int client_name_len;
  unsigned int version_len;
  unsigned int descr_len;
  signed int return_value_gg_session_handle_welcome_110$1;
  unsigned int hash;
  unsigned int return_value_gg_login_hash$2;
  char tmp[41l];
  signed int i;
  signed int return_value_gg_login_hash_sha1_2$3;
  signed int tmp_if_expr$6;
  _Bool tmp_if_expr$9;
  const unsigned short int **return_value___ctype_b_loc$8;
  char *tmp_if_expr$10;
  char *tmp_if_expr$12;
  unsigned int tmp_if_expr$15;
  unsigned long int return_value_strlen$13;
  unsigned int return_value_gg_fix32$14;
  if(!(len >= sizeof(struct gg_welcome) /*4ul*/ ))
  {
    ge->type = GG_EVENT_CONN_FAILED;
    ge->event.failure = (enum gg_failure_t)GG_FAILURE_INVALID;
    gs->state = GG_STATE_IDLE;
    gg_close(gs);
    return 0;
  }

  else
  {
    w = (struct gg_welcome *)ptr;
    seed=gg_fix32(w->key);
    if(gs->protocol_version >= 0x40)
    {
      return_value_gg_session_handle_welcome_110$1=gg_session_handle_welcome_110(gs, seed, ge);
      return return_value_gg_session_handle_welcome_110$1;
    }

    else
    {
      memset((void *)hash_buf, 0, sizeof(unsigned char [64l]) /*64ul*/ );
      switch(gs->hash_type)
      {
        case 0x01:
        {
          return_value_gg_login_hash$2=gg_login_hash((unsigned char *)gs->password, seed);
          hash=gg_fix32(return_value_gg_login_hash$2);
          gg_debug_session(gs, 4, "// gg_watch_fd() challenge %.4x --> GG32 hash %.8x\n", seed, hash);
          memcpy((void *)hash_buf, (const void *)&hash, sizeof(unsigned int) /*4ul*/ );
          break;
        }
        case 0x02:
        {
          return_value_gg_login_hash_sha1_2$3=gg_login_hash_sha1_2(gs->password, seed, hash_buf);
          if(return_value_gg_login_hash_sha1_2$3 == -1)
          {
            gg_debug_session(gs, 16, "// gg_watch_fd() gg_login_hash_sha1_2() failed, probably out of memory\n");
            gg_close(gs);
            ge->type = GG_EVENT_CONN_FAILED;
            ge->event.failure = (enum gg_failure_t)GG_FAILURE_INTERNAL;
            gs->state = GG_STATE_IDLE;
            return -1;
          }

          i = 0;
          for( ; !(i >= 40); i = i + 2)
            snprintf(tmp + (signed long int)i, sizeof(char [41l]) /*41ul*/  - (unsigned long int)i, "%02x", hash_buf[(signed long int)(i / 2)]);
          gg_debug_session(gs, 4, "// gg_watch_fd() challenge %.4x --> SHA1 hash: %s\n", seed, (const void *)tmp);
        }
      }
      signed int return_value_getsockname$5;
      return_value_getsockname$5=getsockname(gs->fd, (struct sockaddr *)&sin, &sin_len);
      if(return_value_getsockname$5 == 0)
      {
        char *return_value_inet_ntoa$4;
        return_value_inet_ntoa$4=inet_ntoa(sin.sin_addr);
        gg_debug_session(gs, 16, "// gg_watch_fd() detected address to %s\n", return_value_inet_ntoa$4);
        local_ip = sin.sin_addr.s_addr;
      }

      else
      {
        gg_debug_session(gs, 16, "// gg_watch_fd() unable to detect address\n");
        local_ip = (unsigned int)0;
      }
      if(gs->external_addr == 0u)
        gs->external_addr = local_ip;

      memset((void *)&l80, 0, sizeof(struct gg_login80) /*97ul*/ );
      gg_debug_session(gs, 16, "// gg_watch_fd() sending GG_LOGIN80 packet\n");
      l80.uin=gg_fix32(gs->uin);
      memcpy((void *)l80.language, (const void *)"pl", sizeof(unsigned char [2l]) /*2ul*/ );
      l80.hash_type = (unsigned char)gs->hash_type;
      memcpy((void *)l80.hash, (const void *)hash_buf, sizeof(unsigned char [64l]) /*64ul*/ );
      if(!(gs->initial_status == 0))
        tmp_if_expr$6 = gs->initial_status;

      else
        tmp_if_expr$6 = 0x0002;
      l80.status=gg_fix32((unsigned int)tmp_if_expr$6);
      l80.flags=gg_fix32((unsigned int)gs->status_flags);
      l80.features=gg_fix32((unsigned int)gs->protocol_features);
      l80.image_size = (unsigned char)gs->image_size;
      l80.dunno2 = (unsigned char)0x64;
      if(!(gs->client_version == ((char *)NULL)))
      {
        return_value___ctype_b_loc$8=__ctype_b_loc();
        tmp_if_expr$9 = !(((signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)gs->client_version[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        client_name = "";
        client_name_len = (unsigned int)0;
      }

      else
      {
        client_name = "Gadu-Gadu Client Build ";
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen("Gadu-Gadu Client Build ");
        client_name_len = (unsigned int)return_value_strlen$7;
      }
      if(!(gs->client_version == ((char *)NULL)))
        tmp_if_expr$10 = gs->client_version;

      else
        tmp_if_expr$10 = "10.1.0.11070";
      version = tmp_if_expr$10;
      unsigned long int return_value_strlen$11;
      return_value_strlen$11=strlen(version);
      version_len=gg_fix32((unsigned int)((unsigned long int)client_name_len + return_value_strlen$11));
      if(!(gs->initial_descr == ((char *)NULL)))
        tmp_if_expr$12 = gs->initial_descr;

      else
        tmp_if_expr$12 = "";
      descr = tmp_if_expr$12;
      if(!(gs->initial_descr == ((char *)NULL)))
      {
        return_value_strlen$13=strlen(gs->initial_descr);
        return_value_gg_fix32$14=gg_fix32((unsigned int)return_value_strlen$13);
        tmp_if_expr$15 = return_value_gg_fix32$14;
      }

      else
        tmp_if_expr$15 = (unsigned int)0;
      descr_len = tmp_if_expr$15;
      unsigned long int return_value_strlen$16;
      return_value_strlen$16=strlen(version);
      unsigned long int return_value_strlen$17;
      return_value_strlen$17=strlen(descr);
      ret=gg_send_packet(gs, 0x0031, &l80, sizeof(struct gg_login80) /*97ul*/ , &version_len, sizeof(unsigned int) /*4ul*/ , client_name, client_name_len, version, return_value_strlen$16, &descr_len, sizeof(unsigned int) /*4ul*/ , descr, return_value_strlen$17, (void *)0);
      if(ret == -1)
      {
        signed int *return_value___errno_location$18;
        return_value___errno_location$18=__errno_location();
        signed int *return_value___errno_location$19;
        return_value___errno_location$19=__errno_location();
        char *return_value_strerror$20;
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        gg_debug_session(gs, 16, "// gg_watch_fd() sending packet failed. (errno=%d, %s)\n", *return_value___errno_location$18, return_value_strerror$20);
        gg_close(gs);
        ge->type = GG_EVENT_CONN_FAILED;
        ge->event.failure = (enum gg_failure_t)GG_FAILURE_WRITING;
        gs->state = GG_STATE_IDLE;
        return -1;
      }

      gs->state = GG_STATE_READING_REPLY;
      gs->check = 2;
      return 0;
    }
  }
}

// gg_session_handle_welcome_110
// file handlers.c line 94
static signed int gg_session_handle_welcome_110(struct gg_session *gs, unsigned int seed, struct gg_event *ge)
{
  struct _GG105Login msg = { .base={ .descriptor=&gg105_login__descriptor, .n_unknown_fields=(unsigned int)0, .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .lang=(char *)(void *)0,
    .uin={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 }, .hash={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .client=(char *)(void *)0,
    .initial_status=8227u, .initial_descr=gg105_login__initial_descr__default_value,
    .supported_features=(char *)(void *)0,
    .dummy1=4,
    .dummy2=65994615u, .dummy3=198164u, .dummy4={ .len=(unsigned long int)0, .data=(unsigned char *)(void *)0 },
    .dummy5=255,
    .dummy6=100, .has_dummy7=0, .dummy7=127u,
    .has_dummy8=0, .dummy8=0, .has_dummy10=0,
    .dummy10=0u };
  char client_str[1000l];
  unsigned char hash[64l];
  const char *client_name = "GG-Phoenix/";
  const char *client_version = "11.3.45.10771";
  const char *client_target = " (BUILD;WINNT_x86-msvc;rv:11.0,pl;release;standard) (OS;Windows;Windows NT 6.1)";
  unsigned char dummy4[4l] = { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
  const unsigned short int **return_value___ctype_b_loc$2;
  signed int tmp_if_expr$3;
  if(!(gs->hash_type == 0x02))
  {
    gg_debug_session(gs, 128, "// Unsupported hash type for this protocol version\n");
    gg_connection_failure(gs, ge, (enum gg_failure_t)GG_FAILURE_INTERNAL);
    return -1;
  }

  else
  {
    signed int return_value_gg_login_hash_sha1_2$1;
    return_value_gg_login_hash_sha1_2$1=gg_login_hash_sha1_2(gs->password, seed, hash);
    if(return_value_gg_login_hash_sha1_2$1 == -1)
    {
      gg_debug_session(gs, 128, "// gg_watch_fd() gg_login_hash_sha1_2() failed, probably out of memory\n");
      gg_connection_failure(gs, ge, (enum gg_failure_t)GG_FAILURE_INTERNAL);
      return -1;
    }

    else
    {
      if(!(gs->client_version == ((char *)NULL)))
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*gs->client_version]) == 0)
        {
          client_name = "";
          client_target = "";
        }

      }

      if(!(gs->client_version == ((char *)NULL)))
        client_version = gs->client_version;

      snprintf(client_str, sizeof(char [1000l]) /*1000ul*/ , "%s%s%s", client_name, client_version, client_target);
      client_str[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
      gg_debug_session(gs, 16, "// gg_watch_fd() sending GG_LOGIN105 packet\n");
      msg.lang = "pl";
      gg_protobuf_set_uin(&msg.uin, gs->uin, (struct _gg_protobuf_uin_buff *)(void *)0);
      msg.hash.len = (unsigned long int)20;
      msg.hash.data = hash;
      msg.client = client_str;
      if(!(gs->initial_status == 0))
        tmp_if_expr$3 = gs->initial_status & 0xFF;

      else
        tmp_if_expr$3 = 0x0002;
      msg.initial_status = (unsigned int)tmp_if_expr$3;
      if(!(gs->initial_descr == ((char *)NULL)))
        msg.initial_descr = gs->initial_descr;

      msg.supported_features = "avatar,StatusComments,ggaccount,edisc,music_shared,bot,fanpage,pubdir,botCaps,gifts,Gift";
      msg.dummy4.len = sizeof(unsigned char [4l]) /*4ul*/ ;
      msg.dummy4.data = dummy4;
      msg.has_dummy7 = 1;
      msg.has_dummy8 = 1;
      msg.has_dummy10 = 1;
      signed int return_value_gg_protobuf_send_ex$4;
      return_value_gg_protobuf_send_ex$4=gg_protobuf_send_ex(gs, ge, 0x0083, (void *)&msg, (unsigned long int (*)(const void *))gg105_login__get_packed_size, (unsigned long int (*)(const void *, unsigned char *))gg105_login__pack);
      if(return_value_gg_protobuf_send_ex$4 == 0)
        return -1;

      else
      {
        gs->state = GG_STATE_READING_REPLY;
        gs->check = 2;
        return 0;
      }
    }
  }
}

// gg_session_handle_xml_event
// file handlers.c line 538
static signed int gg_session_handle_xml_event(struct gg_session *gs, unsigned int type, const char *ptr, unsigned long int len, struct gg_event *ge)
{
  gg_debug_session(gs, 16, "// gg_watch_fd_connected() received XML event\n");
  ge->type = GG_EVENT_XML_EVENT;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(len + (unsigned long int)1);
  ge->event.xml_event.data = (char *)return_value_malloc$1;
  if(ge->event.xml_event.data == ((char *)NULL))
  {
    gg_debug_session(gs, 16, "// gg_watch_fd_connected() out of memory\n");
    return -1;
  }

  else
  {
    memcpy((void *)ge->event.xml_event.data, (const void *)ptr, len);
    ge->event.xml_event.data[(signed long int)len] = (char)0;
    return 0;
  }
}

// gg_session_init_ssl
// file events.c line 237
signed int gg_session_init_ssl(struct gg_session *gs)
{
  struct anonymous$34 *tmp = (struct anonymous$34 *)gs->ssl;
  if(tmp == ((struct anonymous$34 *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$34) /*16ul*/ );
    tmp = (struct anonymous$34 *)return_value_malloc$1;
    if(tmp == ((struct anonymous$34 *)NULL))
    {
      gg_debug(16, "// gg_session_connect() out of memory for GnuTLS session\n");
      return -1;
    }

    memset((void *)tmp, 0, sizeof(struct anonymous$34) /*16ul*/ );
    gs->ssl = (void *)tmp;
    gnutls_global_init();
    gnutls_certificate_allocate_credentials(&tmp->xcred);
    gnutls_certificate_set_x509_system_trust(tmp->xcred);
  }

  else
    gnutls_deinit(tmp->session);
  gnutls_init(&tmp->session, (unsigned int)(1 << 1));
  gnutls_set_default_priority(tmp->session);
  gnutls_credentials_set(tmp->session, (enum anonymous$11)GNUTLS_CRD_CERTIFICATE, (void *)tmp->xcred);
  gnutls_transport_set_ptr(tmp->session, (void *)(signed long int)gs->fd);
  return 0;
}

// gg_session_send_msg_ack
// file handlers.c line 1068
static signed int gg_session_send_msg_ack(struct gg_session *gs, unsigned int seq)
{
  struct gg_recv_msg_ack pkt;
  gg_debug_session(gs, 8, "** gg_session_send_msg_ack(%p);\n", gs);
  if((0x0400 & gs->protocol_features) == 0)
    return 0;

  else
  {
    gs->recv_msg_count = gs->recv_msg_count + 1;
    pkt.seq=gg_fix32(seq);
    signed int return_value_gg_send_packet$1;
    return_value_gg_send_packet$1=gg_send_packet(gs, 0x0046, &pkt, sizeof(struct gg_recv_msg_ack) /*4ul*/ , (void *)0);
    return return_value_gg_send_packet$1;
  }
}

// gg_session_set_custom_resolver
// file resolver.c line 911
signed int gg_session_set_custom_resolver(struct gg_session *gs, signed int (*resolver_start)(signed int *, void **, const char *), void (*resolver_cleanup)(void **, signed int))
{
  do
    if(gs == ((struct gg_session *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
      return -1;
    }

  while((_Bool)0);
  if(resolver_cleanup == ((void (*)(void **, signed int))NULL) || resolver_start == ((signed int (*)(signed int *, void **, const char *))NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return -1;
  }

  gs->resolver_type = (enum anonymous$4)GG_RESOLVER_CUSTOM;
  gs->resolver_start = resolver_start;
  gs->resolver_cleanup = resolver_cleanup;
  return 0;
}

// gg_session_set_resolver
// file ../include/libgadu.h line 821
signed int gg_session_set_resolver(struct gg_session *gs, enum anonymous$4 type)
{
  do
    if(gs == ((struct gg_session *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
      return -1;
    }

  while((_Bool)0);
  if((signed int)type == GG_RESOLVER_DEFAULT)
  {
    if(!((signed int)gg_global_resolver_type == GG_RESOLVER_DEFAULT))
    {
      gs->resolver_type = gg_global_resolver_type;
      gs->resolver_start = gg_global_resolver_start;
      gs->resolver_cleanup = gg_global_resolver_cleanup;
      return 0;
    }

    type = (enum anonymous$4)GG_RESOLVER_PTHREAD;
  }

  signed int *return_value___errno_location$2;
  switch((signed int)type)
  {
    case GG_RESOLVER_FORK:
    {
      gs->resolver_type = type;
      gs->resolver_start = gg_resolver_fork_start;
      gs->resolver_cleanup = gg_resolver_fork_cleanup;
      return 0;
    }
    case GG_RESOLVER_PTHREAD:
    {
      gs->resolver_type = type;
      gs->resolver_start = gg_resolver_pthread_start;
      gs->resolver_cleanup = gg_resolver_pthread_cleanup;
      return 0;
    }
    default:
    {
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 22;
      return -1;
    }
  }
}

// gg_socket_manager_connected
// file libgadu.c line 3026
signed int gg_socket_manager_connected(void *handle, void *priv, signed int fd)
{
  struct gg_session *sess = (struct gg_session *)priv;
  struct gg_session_private *p = sess->private_data;
  if(!(p->socket_handle == handle))
  {
    gg_debug_session(sess, 16 | 128, "// gg_socket_manager_connected() invalid handle\n");
    return 0;
  }

  else
  {
    sess->fd = -1;
    if(!(fd >= 0))
    {
      gg_debug_session(sess, 16 | 128, "// gg_socket_manager_connected() connection error\n");
      p->socket_handle = (void *)0;
      gg_socket_manager_error(sess, (enum gg_failure_t)GG_FAILURE_CONNECTING);
      return 0;
    }

    else
    {
      if(p->socket_next_state == GG_STATE_TLS_NEGOTIATION)
      {
        signed int return_value_gg_session_init_ssl$1;
        return_value_gg_session_init_ssl$1=gg_session_init_ssl(sess);
        if(return_value_gg_session_init_ssl$1 == -1)
        {
          gg_debug_session(sess, 16 | 128, "// gg_socket_manager_connected() couldn't initialize ssl\n");
          p->socket_handle = (void *)0;
          gg_socket_manager_error(sess, (enum gg_failure_t)GG_FAILURE_TLS);
          return 0;
        }

      }

      p->socket_is_external = 1;
      sess->fd = fd;
      sess->timeout = 30;
      sess->state = p->socket_next_state;
      const char *return_value_gg_debug_state$2;
      return_value_gg_debug_state$2=gg_debug_state((enum gg_state_t)p->socket_next_state);
      gg_debug_session(sess, 16, "// next state=%s\n", return_value_gg_debug_state$2);
      if(p->socket_next_state == GG_STATE_READING_KEY)
        sess->check = 2;

      else
        sess->check = 1;
      return 1;
    }
  }
}

// gg_socket_manager_error
// file libgadu.c line 2862
static void gg_socket_manager_error(struct gg_session *sess, enum gg_failure_t failure)
{
  signed int pipes[2l];
  unsigned char dummy = (unsigned char)0;
  struct gg_session_private *p = sess->private_data;
  p->socket_failure = failure;
  signed int return_value_socketpair$4;
  return_value_socketpair$4=socketpair(1, 1, 0, pipes);
  if(return_value_socketpair$4 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    gg_debug(16, "// gg_socket_manager_error() unable to create pipes (errno=%d, %s)\n", *return_value___errno_location$1, return_value_strerror$3);
    goto __CPROVER_DUMP_L3;
  }

  p->socket_is_external = 0;
  sess->fd = pipes[(signed long int)1];
  sess->check = 2;
  sess->state = GG_STATE_ERROR;
  signed long int return_value_send$8;
  return_value_send$8=send(pipes[(signed long int)0], (const void *)&dummy, sizeof(unsigned char) /*1ul*/ , 0);
  if(!((unsigned long int)return_value_send$8 == sizeof(unsigned char) /*1ul*/ ))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    gg_debug(16, "// gg_socket_manager_error() unable to send via pipe (errno=%d, %s)\n", *return_value___errno_location$5, return_value_strerror$7);
    goto __CPROVER_DUMP_L3;
  }

  close(pipes[(signed long int)0]);

__CPROVER_DUMP_L3:
  ;
}

// gg_str_to_uin
// file common.c line 710
unsigned int gg_str_to_uin(const char *str, signed int len)
{
  char buff[11l];
  char *endptr;
  unsigned int uin;
  unsigned long int return_value_strlen$1;
  if(!(len >= 0))
  {
    return_value_strlen$1=strlen(str);
    len = (signed int)return_value_strlen$1;
  }

  _Bool tmp_if_expr$5;
  if(len >= 11)
    return (unsigned int)0;

  else
  {
    memcpy((void *)buff, (const void *)str, (unsigned long int)len);
    buff[(signed long int)len] = (char)0;
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 0;
    unsigned long int return_value_strtoul$3;
    return_value_strtoul$3=strtoul(buff, &endptr, 10);
    uin = (unsigned int)return_value_strtoul$3;
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 34)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)endptr[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      return (unsigned int)0;

    else
      return uin;
  }
}

// gg_strarr_dup
// file common.c line 838
char ** gg_strarr_dup(char **strarr)
{
  unsigned long int i;
  unsigned long int len;
  unsigned long int size;
  char **it;
  char **out;
  if(strarr == ((char **)NULL))
    return (char **)(void *)0;

  else
  {
    len = (unsigned long int)0;
    it = strarr;
    for( ; !(*it == ((char *)NULL)); it = it + 1l)
      len = len + 1ul;
    size = (len + (unsigned long int)1) * sizeof(char *) /*8ul*/ ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(size);
    out = (char **)return_value_malloc$1;
    if(out == ((char **)NULL))
    {
      gg_debug(16 | 128, "// gg_strarr_dup() not enough memory for the array\n");
      return (char **)(void *)0;
    }

    else
    {
      memset((void *)out, 0, size);
      i = (unsigned long int)0;
      for( ; !(i >= len); i = i + 1ul)
      {
        out[(signed long int)i]=strdup(strarr[(signed long int)i]);
        if(out[(signed long int)i] == ((char *)NULL))
        {
          gg_debug(16 | 128, "// gg_strarr_dup() not enough memory for the array element\n");
          gg_strarr_free(out);
          return (char **)(void *)0;
        }

      }
      return out;
    }
  }
}

// gg_strarr_free
// file common.c line 826
void gg_strarr_free(char **strarr)
{
  char **it;
  if(!(strarr == ((char **)NULL)))
  {
    it = strarr;
    for( ; !(*it == ((char *)NULL)); it = it + 1l)
      free((void *)*it);
    free((void *)strarr);
  }

}

// gg_sync_time
// file handlers.c line 81
static void gg_sync_time(struct gg_session *gs, signed long int server_time)
{
  signed long int local_time;
  local_time=time((signed long int *)(void *)0);
  signed int time_diff = (signed int)(server_time - local_time);
  if(!(gs->private_data->time_diff == time_diff))
  {
    gs->private_data->time_diff = time_diff;
    gg_debug_session(gs, 16 | 32, "// time synchronized (diff = %d)\n", time_diff);
  }

}

// gg_token
// file pubdir.c line 684
struct gg_http * gg_token(signed int async)
{
  struct gg_http *h;
  const char *query = "Host: register.gadu-gadu.pl\r\nContent-Type: application/x-www-form-urlencoded\r\nUser-Agent: Mozilla/4.7 [en] (Win98; I)\r\nContent-Length: 0\r\nPragma: no-cache\r\n\r\n";
  h=gg_http_connect("register.gadu-gadu.pl", 80, async, "POST", "/appsvc/regtoken.asp", query);
  if(h == ((struct gg_http *)NULL))
  {
    gg_debug(16, "=> token, gg_http_connect() failed mysteriously\n");
    return (struct gg_http *)(void *)0;
  }

  else
  {
    h->type = 17;
    h->callback = gg_token_watch_fd;
    h->destroy = gg_token_free;
    if(async == 0)
      gg_token_watch_fd(h);

    return h;
  }
}

// gg_token_free
// file pubdir.c line 866
void gg_token_free(struct gg_http *h)
{
  struct gg_token *t;
  if(!(h == ((struct gg_http *)NULL)))
  {
    t = (struct gg_token *)h->data;
    if(!(t == ((struct gg_token *)NULL)))
      free((void *)t->tokenid);

    free(h->data);
    gg_http_free(h);
  }

}

// gg_token_watch_fd
// file pubdir.c line 725
signed int gg_token_watch_fd(struct gg_http *h)
{
  if(h == ((struct gg_http *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(h->state == GG_STATE_ERROR)
  {
    gg_debug(16, "=> token, watch_fd issued on failed session\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return -1;
  }

  if(!(h->state == GG_STATE_PARSING))
  {
    signed int return_value_gg_http_watch_fd$4;
    return_value_gg_http_watch_fd$4=gg_http_watch_fd(h);
    if(return_value_gg_http_watch_fd$4 == -1)
    {
      gg_debug(16, "=> token, http failure\n");
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      return -1;
    }

  }

  unsigned long int tmp_if_expr$6;
  unsigned long int return_value_strlen$5;
  void *return_value_malloc$7;
  _Bool tmp_if_expr$9;
  void *return_value_malloc$8;
  _Bool tmp_if_expr$12;
  signed int return_value_sscanf$11;
  if(!(h->state == GG_STATE_PARSING))
    return 0;

  else
  {
    if(h->data == NULL)
    {
      signed int width;
      signed int height;
      signed int length;
      char *url = (char *)(void *)0;
      char *tokenid = (char *)(void *)0;
      char *path;
      char *headers;
      const char *host;
      struct gg_http *h2;
      struct gg_token *t;
      unsigned long int results_len;
      gg_debug(16, "=> token body \"%s\"\n", h->body);
      if(!(h->body == ((char *)NULL)))
      {
        return_value_strlen$5=strlen(h->body);
        tmp_if_expr$6 = return_value_strlen$5;
      }

      else
        tmp_if_expr$6 = (unsigned long int)0;
      results_len = tmp_if_expr$6;
      if(!(h->body == ((char *)NULL)))
      {
        return_value_malloc$7=malloc(results_len);
        url = (char *)return_value_malloc$7;
        if(url == ((char *)NULL))
          tmp_if_expr$9 = (_Bool)1;

        else
        {
          return_value_malloc$8=malloc(results_len);
          tokenid = (char *)return_value_malloc$8;
          tmp_if_expr$9 = !(tokenid != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$9)
        {
          gg_debug(16, "=> token, not enough memory for results\n");
          free((void *)url);
          return -1;
        }

      }

      if(h->body == ((char *)NULL))
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value_sscanf$11=sscanf(h->body, "%d %d %d\r\n%s\r\n%s", &width, &height, &length, tokenid, url);
        tmp_if_expr$12 = return_value_sscanf$11 != 5 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
      {
        gg_debug(16, "=> token, parsing failed\n");
        free((void *)url);
        free((void *)tokenid);
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        *return_value___errno_location$10 = 22;
        return -1;
      }

      signed int return_value_strncmp$14;
      return_value_strncmp$14=strncmp(url, "http://", (unsigned long int)7);
      if(!(return_value_strncmp$14 == 0))
      {
        path=gg_saprintf("%s?tokenid=%s", url, tokenid);
        host = "register.gadu-gadu.pl";
      }

      else
      {
        char *slash;
        slash=strchr(url + (signed long int)7, 47);
        if(!(slash == ((char *)NULL)))
        {
          path=gg_saprintf("%s?tokenid=%s", slash, tokenid);
          *slash = (char)0;
          host = url + (signed long int)7;
        }

        else
        {
          gg_debug(16, "=> token, url parsing failed\n");
          free((void *)url);
          free((void *)tokenid);
          signed int *return_value___errno_location$13;
          return_value___errno_location$13=__errno_location();
          *return_value___errno_location$13 = 22;
          return -1;
        }
      }
      if(path == ((char *)NULL))
      {
        gg_debug(16, "=> token, not enough memory for token url\n");
        free((void *)url);
        free((void *)tokenid);
        return -1;
      }

      headers=gg_saprintf("Host: %s\r\nUser-Agent: Mozilla/4.7 [en] (Win98; I)\r\n\r\n", host);
      if(headers == ((char *)NULL))
      {
        gg_debug(16, "=> token, not enough memory for token url\n");
        free((void *)path);
        free((void *)url);
        free((void *)tokenid);
        return -1;
      }

      h2=gg_http_connect(host, 80, h->async, "GET", path, headers);
      if(h2 == ((struct gg_http *)NULL))
      {
        gg_debug(16, "=> token, gg_http_connect() failed mysteriously\n");
        free((void *)headers);
        free((void *)url);
        free((void *)path);
        free((void *)tokenid);
        return -1;
      }

      free((void *)headers);
      free((void *)path);
      free((void *)url);
      gg_http_free_fields(h);
      memcpy((void *)h, (const void *)h2, sizeof(struct gg_http) /*152ul*/ );
      free((void *)h2);
      h->type = 17;
      h->callback = gg_token_watch_fd;
      h->destroy = gg_token_free;
      if(h->async == 0)
        gg_token_watch_fd(h);

      void *return_value_malloc$15;
      return_value_malloc$15=malloc(sizeof(struct gg_token) /*24ul*/ );
      t = (struct gg_token *)return_value_malloc$15;
      h->data = (void *)t;
      if(h->data == NULL)
      {
        gg_debug(16, "=> token, not enough memory for token data\n");
        free((void *)tokenid);
        return -1;
      }

      t->width = width;
      t->height = height;
      t->length = length;
      t->tokenid = tokenid;
    }

    else
      h->state = GG_STATE_DONE;
    return 0;
  }
}

// gg_tvbuff_close
// file ../include/tvbuff.h line 29
signed int gg_tvbuff_close(struct gg_tvbuff *tvb)
{
  signed int valid;
  gg_tvbuff_expected_eob(tvb);
  valid=gg_tvbuff_is_valid(tvb);
  free((void *)tvb);
  return valid;
}

// gg_tvbuff_expected_eob
// file tvbuff.c line 597
void gg_tvbuff_expected_eob(const struct gg_tvbuff *tvb)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  unsigned long int return_value_gg_tvbuff_get_remaining$2;
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    unsigned long int return_value_gg_tvbuff_get_remaining$3;
    return_value_gg_tvbuff_get_remaining$3=gg_tvbuff_get_remaining(tvb);
    if(!(return_value_gg_tvbuff_get_remaining$3 == 0ul))
    {
      return_value_gg_tvbuff_get_remaining$2=gg_tvbuff_get_remaining(tvb);
      gg_debug(64, "// gg_tvbuff_expected_eob() unexpected %zu bytes, first=%#02x\n", return_value_gg_tvbuff_get_remaining$2, tvb->buffer[(signed long int)tvb->offset]);
    }

  }

}

// gg_tvbuff_expected_uint32
// file ../include/tvbuff.h line 56
void gg_tvbuff_expected_uint32(struct gg_tvbuff *tvb, unsigned int value)
{
  unsigned int got;
  unsigned long int offset = tvb->offset;
  got=gg_tvbuff_read_uint32(tvb);
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    if(!(got == value))
      gg_debug(64, "// gg_tvbuff_expected_uint32() expected %#08x, but %#08x found at %zu\n", value, got, offset);

  }

}

// gg_tvbuff_expected_uint8
// file ../include/tvbuff.h line 55
void gg_tvbuff_expected_uint8(struct gg_tvbuff *tvb, unsigned char value)
{
  unsigned char got;
  unsigned long int offset = tvb->offset;
  got=gg_tvbuff_read_uint8(tvb);
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    if(!(got == value))
      gg_debug(64, "// gg_tvbuff_expected_uint8() expected %#02x, but %#02x found at %zu\n", value, got, offset);

  }

}

// gg_tvbuff_get_remaining
// file tvbuff.c line 117
unsigned long int gg_tvbuff_get_remaining(const struct gg_tvbuff *tvb)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (unsigned long int)0;

  else
    return tvb->length - tvb->offset;
}

// gg_tvbuff_have_remaining
// file tvbuff.c line 134
signed int gg_tvbuff_have_remaining(struct gg_tvbuff *tvb, unsigned long int length)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_gg_tvbuff_get_remaining$2;
    return_value_gg_tvbuff_get_remaining$2=gg_tvbuff_get_remaining(tvb);
    if(return_value_gg_tvbuff_get_remaining$2 >= length)
      return 1;

    else
    {
      unsigned long int return_value_gg_tvbuff_get_remaining$3;
      return_value_gg_tvbuff_get_remaining$3=gg_tvbuff_get_remaining(tvb);
      gg_debug(64, "// gg_tvbuff_have_remaining() failed (%zu < %zu)\n", return_value_gg_tvbuff_get_remaining$3, length);
      tvb->valid = 0;
      return 0;
    }
  }
}

// gg_tvbuff_is_valid
// file ../include/tvbuff.h line 31
signed int gg_tvbuff_is_valid(const struct gg_tvbuff *tvb)
{
  if(tvb == ((const struct gg_tvbuff *)NULL))
    return 0;

  else
    return tvb->valid;
}

// gg_tvbuff_match
// file tvbuff.c line 200
signed int gg_tvbuff_match(struct gg_tvbuff *tvb, unsigned char value)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return 0;

  else
  {
    signed int return_value_gg_tvbuff_have_remaining$2;
    return_value_gg_tvbuff_have_remaining$2=gg_tvbuff_have_remaining(tvb, (unsigned long int)1);
    if(return_value_gg_tvbuff_have_remaining$2 == 0)
    {
      gg_debug(64, "// gg_tvbuff_match() failed\n");
      return 0;
    }

    else
      if(!((signed int)tvb->buffer[(signed long int)tvb->offset] == (signed int)value))
        return 0;

      else
      {
        tvb->offset = tvb->offset + 1ul;
        return 1;
      }
  }
}

// gg_tvbuff_new
// file ../include/tvbuff.h line 28
struct gg_tvbuff * gg_tvbuff_new(const char *buffer, unsigned long int length)
{
  struct gg_tvbuff *tvb;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct gg_tvbuff) /*32ul*/ );
  tvb = (struct gg_tvbuff *)return_value_malloc$1;
  if(tvb == ((struct gg_tvbuff *)NULL))
    return (struct gg_tvbuff *)(void *)0;

  else
  {
    memset((void *)tvb, 0, sizeof(struct gg_tvbuff) /*32ul*/ );
    if(buffer == ((const char *)NULL) && length >= 1ul)
    {
      gg_debug(128, "// gg_tvbuff_new() invalid arguments\n");
      tvb->valid = 0;
      return tvb;
    }

    else
    {
      tvb->buffer = buffer;
      tvb->length = length;
      tvb->offset = (unsigned long int)0;
      tvb->valid = 1;
      return tvb;
    }
  }
}

// gg_tvbuff_read_buff
// file tvbuff.c line 359
const char * gg_tvbuff_read_buff(struct gg_tvbuff *tvb, unsigned long int length)
{
  const char *buff;
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (const char *)(void *)0;

  else
  {
    signed int return_value_gg_tvbuff_have_remaining$2;
    return_value_gg_tvbuff_have_remaining$2=gg_tvbuff_have_remaining(tvb, length);
    if(return_value_gg_tvbuff_have_remaining$2 == 0)
    {
      gg_debug(64, "// gg_tvbuff_get_buff() failed at %zu:%zu\n", tvb->offset, length);
      return (const char *)(void *)0;
    }

    else
    {
      buff = tvb->buffer + (signed long int)tvb->offset;
      tvb->offset = tvb->offset + length;
      return buff;
    }
  }
}

// gg_tvbuff_read_buff_cpy
// file tvbuff.c line 385
void gg_tvbuff_read_buff_cpy(struct gg_tvbuff *tvb, char *buffer, unsigned long int length)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    signed int return_value_gg_tvbuff_have_remaining$2;
    return_value_gg_tvbuff_have_remaining$2=gg_tvbuff_have_remaining(tvb, length);
    if(return_value_gg_tvbuff_have_remaining$2 == 0)
      gg_debug(64, "// gg_tvbuff_read_buff() failed at %zu:%zu\n", tvb->offset, length);

    else
      if(buffer == ((char *)NULL) && length >= 1ul)
      {
        gg_debug(128, "// gg_tvbuff_new() invalid arguments\n");
        tvb->valid = 0;
      }

      else
      {
        memcpy((void *)buffer, (const void *)(tvb->buffer + (signed long int)tvb->offset), length);
        tvb->offset = tvb->offset + length;
      }
  }

}

// gg_tvbuff_read_packed_uint
// file tvbuff.c line 308
unsigned long int gg_tvbuff_read_packed_uint(struct gg_tvbuff *tvb)
{
  unsigned long int val = (unsigned long int)0;
  signed int i;
  signed int val_len = 0;
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  signed int return_value_gg_tvbuff_have_remaining$2;
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (unsigned long int)0;

  else
  {
    do
    {
      return_value_gg_tvbuff_have_remaining$2=gg_tvbuff_have_remaining(tvb, (unsigned long int)1);
      if(return_value_gg_tvbuff_have_remaining$2 == 0)
        break;

      val_len = val_len + 1;
      unsigned char return_value_gg_tvbuff_read_uint8$3;
      return_value_gg_tvbuff_read_uint8$3=gg_tvbuff_read_uint8(tvb);
      if((0x80 & (signed int)return_value_gg_tvbuff_read_uint8$3) == 0)
        break;

    }
    while((_Bool)1);
    signed int return_value_gg_tvbuff_is_valid$4;
    return_value_gg_tvbuff_is_valid$4=gg_tvbuff_is_valid(tvb);
    if(return_value_gg_tvbuff_is_valid$4 == 0)
    {
      gg_debug(64, "// gg_tvbuff_read_packed_uint() failed\n");
      return (unsigned long int)0;
    }

    else
      if(val_len >= 10)
      {
        gg_debug(64, "// gg_tvbuff_read_packed_uint() packed uint size too big: %d\n", val_len);
        tvb->valid = 0;
        return (unsigned long int)0;
      }

      else
      {
        i = 1;
        for( ; val_len >= i; i = i + 1)
        {
          unsigned long int old_val = val;
          val = val << 7;
          if(!(old_val == val >> 7))
          {
            gg_debug(64, "// gg_tvbuff_read_packed_uint() overflow\n");
            tvb->valid = 0;
            return (unsigned long int)0;
          }

          val = val | (unsigned long int)(unsigned char)((signed int)tvb->buffer[(signed long int)(tvb->offset - (unsigned long int)i)] & ~0x80);
        }
        return val;
      }
  }
}

// gg_tvbuff_read_str
// file tvbuff.c line 418
const char * gg_tvbuff_read_str(struct gg_tvbuff *tvb, unsigned long int *length)
{
  unsigned long int offset;
  unsigned int str_len;
  const char *str;
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  _Bool tmp_if_expr$5;
  signed int return_value_gg_tvbuff_have_remaining$4;
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (const char *)(void *)0;

  else
  {
    offset = tvb->offset;
    unsigned long int return_value_gg_tvbuff_read_packed_uint$2;
    return_value_gg_tvbuff_read_packed_uint$2=gg_tvbuff_read_packed_uint(tvb);
    str_len = (unsigned int)return_value_gg_tvbuff_read_packed_uint$2;
    signed int return_value_gg_tvbuff_is_valid$3;
    return_value_gg_tvbuff_is_valid$3=gg_tvbuff_is_valid(tvb);
    if(return_value_gg_tvbuff_is_valid$3 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_gg_tvbuff_have_remaining$4=gg_tvbuff_have_remaining(tvb, (unsigned long int)str_len);
      tmp_if_expr$5 = !(return_value_gg_tvbuff_have_remaining$4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      gg_debug(64, "// gg_tvbuff_read_str() failed at %zu:%d\n", offset, str_len);
      return (const char *)(void *)0;
    }

    else
    {
      str=gg_tvbuff_read_buff(tvb, (unsigned long int)str_len);
      signed int return_value_gg_tvbuff_is_valid$6;
      return_value_gg_tvbuff_is_valid$6=gg_tvbuff_is_valid(tvb);
      if(return_value_gg_tvbuff_is_valid$6 == 0)
        return (const char *)(void *)0;

      else
      {
        if(!(length == ((unsigned long int *)NULL)))
          *length = (unsigned long int)str_len;

        if(str_len == 0u)
          return (const char *)(void *)0;

        else
          return str;
      }
    }
  }
}

// gg_tvbuff_read_str_dup
// file ../include/tvbuff.h line 51
void gg_tvbuff_read_str_dup(struct gg_tvbuff *tvb, char **dst)
{
  unsigned long int offset;
  unsigned int str_len;
  char *str;
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  _Bool tmp_if_expr$5;
  signed int return_value_gg_tvbuff_have_remaining$4;
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    offset = tvb->offset;
    unsigned long int return_value_gg_tvbuff_read_packed_uint$2;
    return_value_gg_tvbuff_read_packed_uint$2=gg_tvbuff_read_packed_uint(tvb);
    str_len = (unsigned int)return_value_gg_tvbuff_read_packed_uint$2;
    signed int return_value_gg_tvbuff_is_valid$3;
    return_value_gg_tvbuff_is_valid$3=gg_tvbuff_is_valid(tvb);
    if(return_value_gg_tvbuff_is_valid$3 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_gg_tvbuff_have_remaining$4=gg_tvbuff_have_remaining(tvb, (unsigned long int)str_len);
      tmp_if_expr$5 = !(return_value_gg_tvbuff_have_remaining$4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      gg_debug(64, "// gg_tvbuff_read_str_dup() failed at %zu:%d\n", offset, str_len);

    else
    {
      void *return_value_malloc$6;
      return_value_malloc$6=malloc((unsigned long int)(str_len + (unsigned int)1));
      str = (char *)return_value_malloc$6;
      if(str == ((char *)NULL))
      {
        gg_debug(128, "// gg_tvbuff_read_str_dup() not enough free memory: %d + 1\n", str_len);
        tvb->valid = 0;
      }

      else
      {
        gg_tvbuff_read_buff_cpy(tvb, str, (unsigned long int)str_len);
        str[(signed long int)str_len] = (char)0;
        if(!(*dst == ((char *)NULL)))
        {
          gg_debug(64, "// gg_tvbuff_read_str_dup() destination already filled, freeing it...\n");
          free((void *)*dst);
        }

        *dst = str;
      }
    }
  }

}

// gg_tvbuff_read_uin
// file tvbuff.c line 506
unsigned int gg_tvbuff_read_uin(struct gg_tvbuff *tvb)
{
  unsigned int uin = (unsigned int)0;
  unsigned int uin_len;
  unsigned int full_len;
  unsigned char uin_type;
  const char *raw;
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (unsigned int)0;

  else
  {
    unsigned long int return_value_gg_tvbuff_read_packed_uint$2;
    return_value_gg_tvbuff_read_packed_uint$2=gg_tvbuff_read_packed_uint(tvb);
    full_len = (unsigned int)return_value_gg_tvbuff_read_packed_uint$2;
    uin_type=gg_tvbuff_read_uint8(tvb);
    unsigned char return_value_gg_tvbuff_read_uint8$3;
    return_value_gg_tvbuff_read_uint8$3=gg_tvbuff_read_uint8(tvb);
    uin_len = (unsigned int)return_value_gg_tvbuff_read_uint8$3;
    signed int return_value_gg_tvbuff_is_valid$4;
    return_value_gg_tvbuff_is_valid$4=gg_tvbuff_is_valid(tvb);
    if(return_value_gg_tvbuff_is_valid$4 == 0)
      return (unsigned int)0;

    else
      if(uin_len >= 11u || !(full_len == 2u + uin_len) || !((signed int)uin_type == 0))
      {
        gg_debug(64, "// gg_tvbuff_read_uin() failed (1)\n");
        tvb->valid = 0;
        return (unsigned int)0;
      }

      else
      {
        raw=gg_tvbuff_read_buff(tvb, (unsigned long int)uin_len);
        if(!(raw == ((const char *)NULL)))
          uin=gg_str_to_uin(raw, (signed int)uin_len);

        if(uin == 0u)
        {
          gg_debug(64, "// gg_tvbuff_read_uin() failed (2)\n");
          tvb->valid = 0;
          return (unsigned int)0;
        }

        else
          return uin;
      }
  }
}

// gg_tvbuff_read_uint32
// file ../include/tvbuff.h line 43
unsigned int gg_tvbuff_read_uint32(struct gg_tvbuff *tvb)
{
  unsigned int val;
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (unsigned int)0;

  else
  {
    signed int return_value_gg_tvbuff_have_remaining$2;
    return_value_gg_tvbuff_have_remaining$2=gg_tvbuff_have_remaining(tvb, (unsigned long int)4);
    if(return_value_gg_tvbuff_have_remaining$2 == 0)
    {
      gg_debug(64, "// gg_tvbuff_read_uint32() failed at %zu\n", tvb->offset);
      return (unsigned int)0;
    }

    else
    {
      memcpy((void *)&val, (const void *)(tvb->buffer + (signed long int)tvb->offset), (unsigned long int)4);
      tvb->offset = tvb->offset + (unsigned long int)4;
      unsigned int return_value_gg_fix32$3;
      return_value_gg_fix32$3=gg_fix32(val);
      return return_value_gg_fix32$3;
    }
  }
}

// gg_tvbuff_read_uint64
// file ../include/tvbuff.h line 44
unsigned long int gg_tvbuff_read_uint64(struct gg_tvbuff *tvb)
{
  unsigned long int val;
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (unsigned long int)0;

  else
  {
    signed int return_value_gg_tvbuff_have_remaining$2;
    return_value_gg_tvbuff_have_remaining$2=gg_tvbuff_have_remaining(tvb, (unsigned long int)8);
    if(return_value_gg_tvbuff_have_remaining$2 == 0)
    {
      gg_debug(64, "// gg_tvbuff_read_uint64() failed at %zu\n", tvb->offset);
      return (unsigned long int)0;
    }

    else
    {
      memcpy((void *)&val, (const void *)(tvb->buffer + (signed long int)tvb->offset), (unsigned long int)8);
      tvb->offset = tvb->offset + (unsigned long int)8;
      unsigned long int return_value_gg_fix64$3;
      return_value_gg_fix64$3=gg_fix64(val);
      return return_value_gg_fix64$3;
    }
  }
}

// gg_tvbuff_read_uint8
// file tvbuff.c line 224
unsigned char gg_tvbuff_read_uint8(struct gg_tvbuff *tvb)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  unsigned long int tmp_post$3;
  if(return_value_gg_tvbuff_is_valid$1 == 0)
    return (unsigned char)0;

  else
  {
    signed int return_value_gg_tvbuff_have_remaining$2;
    return_value_gg_tvbuff_have_remaining$2=gg_tvbuff_have_remaining(tvb, (unsigned long int)1);
    if(return_value_gg_tvbuff_have_remaining$2 == 0)
    {
      gg_debug(64, "// gg_tvbuff_read_uint8() failed at %zu\n", tvb->offset);
      return (unsigned char)0;
    }

    else
    {
      tmp_post$3 = tvb->offset;
      tvb->offset = tvb->offset + 1ul;
      return (unsigned char)tvb->buffer[(signed long int)tmp_post$3];
    }
  }
}

// gg_tvbuff_rewind
// file tvbuff.c line 177
void gg_tvbuff_rewind(struct gg_tvbuff *tvb, unsigned long int amount)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    if(!(tvb->offset >= amount))
    {
      gg_debug(64, "// gg_tvbuff_rewind() failed\n");
      tvb->valid = 0;
    }

    else
      tvb->offset = tvb->offset - amount;
  }

}

// gg_tvbuff_skip
// file ../include/tvbuff.h line 37
void gg_tvbuff_skip(struct gg_tvbuff *tvb, unsigned long int amount)
{
  signed int return_value_gg_tvbuff_is_valid$1;
  return_value_gg_tvbuff_is_valid$1=gg_tvbuff_is_valid(tvb);
  if(!(return_value_gg_tvbuff_is_valid$1 == 0))
  {
    if(!(tvb->length >= tvb->offset + amount))
    {
      gg_debug(64, "// gg_tvbuff_skip() failed\n");
      tvb->valid = 0;
    }

    else
      tvb->offset = tvb->offset + amount;
  }

}

// gg_tvbuilder_expected_size
// file ../include/tvbuilder.h line 36
void gg_tvbuilder_expected_size(struct gg_tvbuilder *tvb, unsigned long int length)
{
  unsigned long int length_new;
  char *buff_new;
  signed int return_value_gg_tvbuilder_is_valid$1;
  return_value_gg_tvbuilder_is_valid$1=gg_tvbuilder_is_valid(tvb);
  if(!(return_value_gg_tvbuilder_is_valid$1 == 0) && !(length == 0ul))
  {
    length_new = tvb->length + length;
    if(!(tvb->alloc_length >= length_new))
    {
      if(tvb->alloc_length >= 1ul)
        gg_debug(16, "// gg_tvbuilder_expected_size(%p, %zu) realloc from %zu to %zu\n", tvb, length, tvb->alloc_length, length_new);

      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)tvb->buffer, length_new);
      buff_new = (char *)return_value_realloc$2;
      if(!(buff_new == ((char *)NULL)))
      {
        tvb->buffer = buff_new;
        tvb->alloc_length = length_new;
      }

      else
      {
        gg_debug(128, "// gg_tvbuilder_expected_size(%p, %zu) out of memory (new length: %zu)\n", tvb, length, length_new);
        free((void *)tvb->buffer);
        tvb->buffer = (char *)(void *)0;
        tvb->length = (unsigned long int)0;
        tvb->alloc_length = (unsigned long int)0;
        tvb->valid = 0;
      }
    }

  }

}

// gg_tvbuilder_extend
// file tvbuilder.c line 259
static char * gg_tvbuilder_extend(struct gg_tvbuilder *tvb, unsigned long int length)
{
  unsigned long int length_old;
  gg_tvbuilder_expected_size(tvb, length);
  signed int return_value_gg_tvbuilder_is_valid$1;
  return_value_gg_tvbuilder_is_valid$1=gg_tvbuilder_is_valid(tvb);
  if(return_value_gg_tvbuilder_is_valid$1 == 0)
    return (char *)(void *)0;

  else
  {
    length_old = tvb->length;
    tvb->length = tvb->length + length;
    return tvb->buffer + (signed long int)length_old;
  }
}

// gg_tvbuilder_fail
// file tvbuilder.c line 106
void gg_tvbuilder_fail(struct gg_tvbuilder *tvb, enum gg_failure_t failure)
{
  signed int errno_copy;
  if(tvb == ((struct gg_tvbuilder *)NULL))
    gg_debug(64, "// gg_tvbuilder_fail() NULL tvbuilder\n");

  else
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    errno_copy = *return_value___errno_location$1;
    close(tvb->gs->fd);
    tvb->gs->fd = -1;
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = errno_copy;
    if(!(tvb->ge == ((struct gg_event *)NULL)))
    {
      tvb->ge->type = GG_EVENT_CONN_FAILED;
      tvb->ge->event.failure = failure;
    }

    tvb->gs->state = GG_STATE_IDLE;
    gg_tvbuilder_free(tvb);
  }
}

// gg_tvbuilder_free
// file tvbuilder.c line 91
void gg_tvbuilder_free(struct gg_tvbuilder *tvb)
{
  if(!(tvb == ((struct gg_tvbuilder *)NULL)))
  {
    free((void *)tvb->buffer);
    free((void *)tvb);
  }

}

// gg_tvbuilder_get_size
// file ../include/tvbuilder.h line 35
unsigned long int gg_tvbuilder_get_size(const struct gg_tvbuilder *tvb)
{
  signed int return_value_gg_tvbuilder_is_valid$1;
  return_value_gg_tvbuilder_is_valid$1=gg_tvbuilder_is_valid(tvb);
  if(return_value_gg_tvbuilder_is_valid$1 == 0)
    return (unsigned long int)0;

  else
    return tvb->length;
}

// gg_tvbuilder_is_valid
// file tvbuilder.c line 182
signed int gg_tvbuilder_is_valid(const struct gg_tvbuilder *tvb)
{
  if(tvb == ((const struct gg_tvbuilder *)NULL))
    return 0;

  else
    return tvb->valid;
}

// gg_tvbuilder_new
// file ../include/tvbuilder.h line 28
struct gg_tvbuilder * gg_tvbuilder_new(struct gg_session *gs, struct gg_event *ge)
{
  struct gg_tvbuilder *tvb;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct gg_tvbuilder) /*48ul*/ );
  tvb = (struct gg_tvbuilder *)return_value_malloc$1;
  if(tvb == ((struct gg_tvbuilder *)NULL))
    return (struct gg_tvbuilder *)(void *)0;

  else
  {
    memset((void *)tvb, 0, sizeof(struct gg_tvbuilder) /*48ul*/ );
    if(gs == ((struct gg_session *)NULL))
    {
      gg_debug(128, "// gg_tvbuilder_new() invalid arguments\n");
      tvb->valid = 0;
      return tvb;
    }

    else
    {
      tvb->buffer = (char *)(void *)0;
      tvb->length = (unsigned long int)0;
      tvb->alloc_length = (unsigned long int)0;
      tvb->valid = 1;
      tvb->gs = gs;
      tvb->ge = ge;
      return tvb;
    }
  }
}

// gg_tvbuilder_send
// file ../include/tvbuilder.h line 31
signed int gg_tvbuilder_send(struct gg_tvbuilder *tvb, signed int type)
{
  signed int ret;
  enum gg_failure_t gg_tvbuilder_send$$1$$failure;
  char *tmp_if_expr$1;
  if(tvb == ((struct gg_tvbuilder *)NULL))
  {
    gg_debug(64, "// gg_tvbuilder_send() NULL tvbuilder\n");
    return 0;
  }

  else
  {
    signed int return_value_gg_tvbuilder_is_valid$5;
    return_value_gg_tvbuilder_is_valid$5=gg_tvbuilder_is_valid(tvb);
    if(return_value_gg_tvbuilder_is_valid$5 == 0)
    {
      gg_debug_session(tvb->gs, 128, "// gg_tvbuilder_send() invalid buffer\n");
      ret = -1;
      gg_tvbuilder_send$$1$$failure = (enum gg_failure_t)GG_FAILURE_INTERNAL;
    }

    else
    {
      const char *buffer;
      if(tvb->length >= 1ul)
        tmp_if_expr$1 = tvb->buffer;

      else
        tmp_if_expr$1 = "";
      buffer = tmp_if_expr$1;
      ret=gg_send_packet(tvb->gs, type, buffer, tvb->length, (void *)0);
      if(ret == -1)
      {
        gg_tvbuilder_send$$1$$failure = (enum gg_failure_t)GG_FAILURE_WRITING;
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        gg_debug_session(tvb->gs, 128, "// gg_tvbuilder_send() sending packet %#x failed. (errno=%d, %s)\n", type, *return_value___errno_location$2, return_value_strerror$4);
      }

    }
    if(ret == -1)
    {
      gg_tvbuilder_fail(tvb, gg_tvbuilder_send$$1$$failure);
      return 0;
    }

    else
    {
      gg_tvbuilder_free(tvb);
      return 1;
    }
  }
}

// gg_tvbuilder_strip
// file ../include/tvbuilder.h line 37
void gg_tvbuilder_strip(struct gg_tvbuilder *tvb, unsigned long int length)
{
  signed int return_value_gg_tvbuilder_is_valid$1;
  return_value_gg_tvbuilder_is_valid$1=gg_tvbuilder_is_valid(tvb);
  if(!(return_value_gg_tvbuilder_is_valid$1 == 0))
  {
    if(!(tvb->length >= length))
    {
      gg_debug(64, "// gg_tvbuilder_strip() out of range\n");
      tvb->valid = 0;
    }

    else
      tvb->length = length;
  }

}

// gg_tvbuilder_write_buff
// file tvbuilder.c line 380
void gg_tvbuilder_write_buff(struct gg_tvbuilder *tvb, const char *buffer, unsigned long int length)
{
  char *buff;
  buff=gg_tvbuilder_extend(tvb, length);
  if(!(buff == ((char *)NULL)))
    memcpy((void *)buff, (const void *)buffer, length);

}

// gg_tvbuilder_write_packed_uint
// file tvbuilder.c line 337
void gg_tvbuilder_write_packed_uint(struct gg_tvbuilder *tvb, unsigned long int value)
{
  unsigned char buff[9l];
  unsigned long int val_curr;
  signed int i;
  signed int val_len = 0;
  signed int return_value_gg_tvbuilder_is_valid$1;
  return_value_gg_tvbuilder_is_valid$1=gg_tvbuilder_is_valid(tvb);
  if(!(return_value_gg_tvbuilder_is_valid$1 == 0))
  {
    val_curr = value;
    for( ; val_curr >= 1ul; val_len = val_len + 1)
      val_curr = val_curr >> 7;
    if(val_len == 0)
      val_len = 1;

    if(val_len >= 10)
    {
      gg_debug(64, "// gg_tvbuilder_write_packed_uint() int size too big (%d): %lu\n", val_len, value);
      tvb->valid = 0;
    }

    else
    {
      val_curr = value;
      i = 0;
      for( ; !(i >= val_len); i = i + 1)
      {
        unsigned char raw = (unsigned char)(val_curr & (unsigned long int)0x7F);
        val_curr = val_curr >> 7;
        if(!(1 + i >= val_len))
          raw = raw | (unsigned char)0x80;

        buff[(signed long int)i] = raw;
      }
      gg_tvbuilder_write_buff(tvb, (const char *)buff, (unsigned long int)val_len);
    }
  }

}

// gg_tvbuilder_write_str
// file tvbuilder.c line 398
void gg_tvbuilder_write_str(struct gg_tvbuilder *tvb, const char *buffer, signed long int length)
{
  signed int return_value_gg_tvbuilder_is_valid$1;
  return_value_gg_tvbuilder_is_valid$1=gg_tvbuilder_is_valid(tvb);
  unsigned long int return_value_strlen$2;
  if(!(return_value_gg_tvbuilder_is_valid$1 == 0))
  {
    if(length == -1l)
    {
      return_value_strlen$2=strlen(buffer);
      length = (signed long int)return_value_strlen$2;
    }

    gg_tvbuilder_write_packed_uint(tvb, (unsigned long int)length);
    gg_tvbuilder_write_buff(tvb, buffer, (unsigned long int)length);
  }

}

// gg_tvbuilder_write_uin
// file ../include/tvbuilder.h line 48
void gg_tvbuilder_write_uin(struct gg_tvbuilder *tvb, unsigned int uin)
{
  char uin_str[16l];
  signed int uin_len;
  uin_len=snprintf(uin_str, sizeof(char [16l]) /*16ul*/ , "%u", uin);
  gg_tvbuilder_write_uint8(tvb, (unsigned char)0x00);
  gg_tvbuilder_write_str(tvb, uin_str, (signed long int)uin_len);
}

// gg_tvbuilder_write_uint32
// file tvbuilder.c line 311
void gg_tvbuilder_write_uint32(struct gg_tvbuilder *tvb, unsigned int value)
{
  value=gg_fix32(value);
  gg_tvbuilder_write_buff(tvb, (const char *)&value, (unsigned long int)4);
}

// gg_tvbuilder_write_uint64
// file tvbuilder.c line 323
void gg_tvbuilder_write_uint64(struct gg_tvbuilder *tvb, unsigned long int value)
{
  value=gg_fix64(value);
  gg_tvbuilder_write_buff(tvb, (const char *)&value, (unsigned long int)8);
}

// gg_tvbuilder_write_uint8
// file ../include/tvbuilder.h line 39
void gg_tvbuilder_write_uint8(struct gg_tvbuilder *tvb, unsigned char value)
{
  gg_tvbuilder_write_buff(tvb, (const char *)&value, (unsigned long int)1);
}

// gg_typing_notification
// file libgadu.c line 2648
signed int gg_typing_notification(struct gg_session *sess, unsigned int recipient, signed int length)
{
  struct gg_typing_notification pkt;
  unsigned int uin;
  pkt.length=gg_fix16((unsigned short int)length);
  uin=gg_fix32(recipient);
  memcpy((void *)&pkt.uin, (const void *)&uin, sizeof(unsigned int) /*4ul*/ );
  signed int return_value_gg_send_packet$1;
  return_value_gg_send_packet$1=gg_send_packet(sess, 0x0059, &pkt, sizeof(struct gg_typing_notification) /*6ul*/ , (void *)0);
  return return_value_gg_send_packet$1;
}

// gg_unregister
// file obsolete.c line 153
struct gg_http * gg_unregister(unsigned int uin, const char *password, const char *email, signed int async)
{
  gg_debug(16, "// gg_unregister() is obsolete. use gg_unregister3() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_unregister2
// file obsolete.c line 160
struct gg_http * gg_unregister2(unsigned int uin, const char *password, const char *qa, signed int async)
{
  gg_debug(16, "// gg_unregister2() is obsolete. use gg_unregister3() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_unregister3
// file pubdir.c line 186
struct gg_http * gg_unregister3(unsigned int uin, const char *password, const char *tokenid, const char *tokenval, signed int async)
{
  struct gg_http *h;
  char *__fmpwd;
  char *__pwd;
  char *__tokenid;
  char *__tokenval;
  char *form;
  char *query;
  if(password == ((const char *)NULL) || tokenid == ((const char *)NULL) || tokenval == ((const char *)NULL))
  {
    gg_debug(16, "=> unregister, NULL parameter\n");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (struct gg_http *)(void *)0;
  }

  signed int return_value_rand$2;
  return_value_rand$2=rand();
  __pwd=gg_saprintf("%d", return_value_rand$2);
  __fmpwd=gg_urlencode(password);
  __tokenid=gg_urlencode(tokenid);
  __tokenval=gg_urlencode(tokenval);
  if(__fmpwd == ((char *)NULL) || __pwd == ((char *)NULL) || __tokenid == ((char *)NULL) || __tokenval == ((char *)NULL))
  {
    gg_debug(16, "=> unregister, not enough memory for form fields\n");
    free((void *)__pwd);
    free((void *)__fmpwd);
    free((void *)__tokenid);
    free((void *)__tokenval);
    return (struct gg_http *)(void *)0;
  }

  else
  {
    signed int return_value_gg_http_hash$3;
    return_value_gg_http_hash$3=gg_http_hash("ss", (const void *)"deletedaccount@gadu-gadu.pl", __pwd);
    form=gg_saprintf("fmnumber=%d&fmpwd=%s&delete=1&pwd=%s&email=deletedaccount@gadu-gadu.pl&tokenid=%s&tokenval=%s&code=%u", uin, __fmpwd, __pwd, __tokenid, __tokenval, return_value_gg_http_hash$3);
    free((void *)__fmpwd);
    free((void *)__pwd);
    free((void *)__tokenid);
    free((void *)__tokenval);
    if(form == ((char *)NULL))
    {
      gg_debug(16, "=> unregister, not enough memory for form query\n");
      return (struct gg_http *)(void *)0;
    }

    else
    {
      gg_debug(16, "=> unregister, %s\n", form);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(form);
      query=gg_saprintf("Host: register.gadu-gadu.pl\r\nContent-Type: application/x-www-form-urlencoded\r\nUser-Agent: Mozilla/4.7 [en] (Win98; I)\r\nContent-Length: %d\r\nPragma: no-cache\r\n\r\n%s", (signed int)return_value_strlen$4, form);
      free((void *)form);
      if(query == ((char *)NULL))
      {
        gg_debug(16, "=> unregister, not enough memory for query\n");
        return (struct gg_http *)(void *)0;
      }

      else
      {
        h=gg_http_connect("register.gadu-gadu.pl", 80, async, "POST", "/appsvc/fmregister3.asp", query);
        if(h == ((struct gg_http *)NULL))
        {
          gg_debug(16, "=> unregister, gg_http_connect() failed mysteriously\n");
          free((void *)query);
          return (struct gg_http *)(void *)0;
        }

        else
        {
          h->type = 15;
          free((void *)query);
          h->callback = gg_pubdir_watch_fd;
          h->destroy = gg_pubdir_free;
          if(async == 0)
            gg_pubdir_watch_fd(h);

          return h;
        }
      }
    }
  }
}

// gg_urlencode
// file common.c line 348
char * gg_urlencode(const char *str)
{
  char *q;
  char *buf;
  const char hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
  const char *p;
  unsigned int size = (unsigned int)0;
  if(str == ((const char *)NULL))
    str = "";

  p = str;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  for( ; !(*p == 0); size = size + 1u)
  {
    if((signed int)*p >= 97)
      tmp_if_expr$1 = (signed int)*p <= 122 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if((signed int)*p >= 65)
        tmp_if_expr$2 = (signed int)*p <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if((signed int)*p >= 48)
        tmp_if_expr$4 = (signed int)*p <= 57 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)*p == 32 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$6)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)*p == 64 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = (signed int)*p == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
      tmp_if_expr$9 = (_Bool)1;

    else
      tmp_if_expr$9 = (signed int)*p == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$9)
      size = size + (unsigned int)2;

    p = p + 1l;
  }
  void *return_value_malloc$10;
  return_value_malloc$10=malloc((unsigned long int)(size + (unsigned int)1));
  buf = (char *)return_value_malloc$10;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  char *tmp_post$11;
  char *tmp_post$12;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = str;
    q = buf;
    for( ; !(*p == 0); q = q + 1l)
    {
      if((signed int)*p >= 97)
        tmp_if_expr$13 = (signed int)*p <= 122 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$13 = (_Bool)0;
      if(tmp_if_expr$13)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        if((signed int)*p >= 65)
          tmp_if_expr$14 = (signed int)*p <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$14 = (_Bool)0;
        tmp_if_expr$15 = tmp_if_expr$14 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$15)
        tmp_if_expr$17 = (_Bool)1;

      else
      {
        if((signed int)*p >= 48)
          tmp_if_expr$16 = (signed int)*p <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$16 = (_Bool)0;
        tmp_if_expr$17 = tmp_if_expr$16 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$17)
        tmp_if_expr$18 = (_Bool)1;

      else
        tmp_if_expr$18 = (signed int)*p == 64 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$18)
        tmp_if_expr$19 = (_Bool)1;

      else
        tmp_if_expr$19 = (signed int)*p == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$19)
        tmp_if_expr$20 = (_Bool)1;

      else
        tmp_if_expr$20 = (signed int)*p == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$20)
        *q = *p;

      else
        if((signed int)*p == 32)
          *q = (char)43;

        else
        {
          tmp_post$11 = q;
          q = q + 1l;
          *tmp_post$11 = (char)37;
          tmp_post$12 = q;
          q = q + 1l;
          *tmp_post$12 = hex[(signed long int)((signed int)*p >> 4 & 15)];
          *q = hex[(signed long int)((signed int)*p & 15)];
        }
      p = p + 1l;
    }
    *q = (char)0;
    return buf;
  }
}

// gg_userlist100_request
// file libgadu.c line 2597
signed int gg_userlist100_request(struct gg_session *sess, char type, unsigned int version, char format_type, const char *request)
{
  struct gg_userlist100_request pkt;
  unsigned char *zrequest;
  unsigned long int zrequest_len;
  signed int ret;
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  pkt.type = (unsigned char)type;
  pkt.version=gg_fix32(version);
  pkt.format_type = (unsigned char)format_type;
  pkt.unknown1 = (unsigned char)0x01;
  signed int return_value_gg_send_packet$3;
  if(request == ((const char *)NULL))
  {
    return_value_gg_send_packet$3=gg_send_packet(sess, 0x0040, &pkt, sizeof(struct gg_userlist100_request) /*7ul*/ , (void *)0);
    return return_value_gg_send_packet$3;
  }

  else
  {
    zrequest=gg_deflate(request, &zrequest_len);
    if(zrequest == ((unsigned char *)NULL))
    {
      gg_debug_session(sess, 16, "// gg_userlist100_request() gg_deflate() failed\n");
      return -1;
    }

    else
    {
      ret=gg_send_packet(sess, 0x0040, &pkt, sizeof(struct gg_userlist100_request) /*7ul*/ , zrequest, zrequest_len, (void *)0);
      free((void *)zrequest);
      return ret;
    }
  }
}

// gg_userlist_get
// file obsolete.c line 40
struct gg_http * gg_userlist_get(unsigned int uin, const char *passwd, signed int async)
{
  gg_debug(16, "// gg_userlist_get() is obsolete. use gg_userlist_request() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_userlist_get_free
// file obsolete.c line 53
void gg_userlist_get_free(struct gg_http *h)
{
  ;
}

// gg_userlist_get_watch_fd
// file obsolete.c line 47
signed int gg_userlist_get_watch_fd(struct gg_http *h)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return -1;
}

// gg_userlist_put
// file obsolete.c line 58
struct gg_http * gg_userlist_put(unsigned int uin, const char *password, const char *contacts, signed int async)
{
  gg_debug(16, "// gg_userlist_put() is obsolete. use gg_userlist_request() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_userlist_put_free
// file obsolete.c line 71
void gg_userlist_put_free(struct gg_http *h)
{
  ;
}

// gg_userlist_put_watch_fd
// file obsolete.c line 65
signed int gg_userlist_put_watch_fd(struct gg_http *h)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return -1;
}

// gg_userlist_remove
// file obsolete.c line 76
struct gg_http * gg_userlist_remove(unsigned int uin, const char *passwd, signed int async)
{
  gg_debug(16, "// gg_userlist_remove() is obsolete. use gg_userlist_request() instead!\n");
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (struct gg_http *)(void *)0;
}

// gg_userlist_remove_free
// file obsolete.c line 89
void gg_userlist_remove_free(struct gg_http *h)
{
  ;
}

// gg_userlist_remove_watch_fd
// file obsolete.c line 83
signed int gg_userlist_remove_watch_fd(struct gg_http *h)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return -1;
}

// gg_userlist_request
// file libgadu.c line 2531
signed int gg_userlist_request(struct gg_session *sess, char type, const char *request)
{
  signed int len;
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return -1;
  }

  if(!(sess->state == GG_STATE_CONNECTED))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 107;
    return -1;
  }

  if(request == ((const char *)NULL))
  {
    sess->userlist_blocks = 1;
    signed int return_value_gg_send_packet$3;
    return_value_gg_send_packet$3=gg_send_packet(sess, 0x0016, &type, sizeof(char) /*1ul*/ , (void *)0);
    return return_value_gg_send_packet$3;
  }

  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(request);
  len = (signed int)return_value_strlen$4;
  sess->userlist_blocks = 0;
  while(len >= 2048)
  {
    sess->userlist_blocks = sess->userlist_blocks + 1;
    signed int return_value_gg_send_packet$5;
    return_value_gg_send_packet$5=gg_send_packet(sess, 0x0016, &type, sizeof(char) /*1ul*/ , request, 2047, (void *)0);
    if(return_value_gg_send_packet$5 == -1)
      return -1;

    if((signed int)type == 0x00)
      type = (char)0x01;

    request = request + (signed long int)2047;
    len = len - 2047;
  }
  sess->userlist_blocks = sess->userlist_blocks + 1;
  signed int return_value_gg_send_packet$6;
  return_value_gg_send_packet$6=gg_send_packet(sess, 0x0016, &type, sizeof(char) /*1ul*/ , request, len, (void *)0);
  return return_value_gg_send_packet$6;
}

// gg_vsaprintf
// file common.c line 67
char * gg_vsaprintf(const char *format, void **ap)
{
  signed int size;
  char *buf = (char *)(void *)0;
  void **aq = (void **)ap;
  char tmp[2l];
  signed int return_value_vsnprintf$1;
  return_value_vsnprintf$1=vsnprintf(tmp, sizeof(char [2l]) /*2ul*/ , format, aq);
  size = return_value_vsnprintf$1 + 1;
  aq = ((void **)NULL);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)size);
  buf = (char *)return_value_malloc$2;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    vsnprintf(buf, (unsigned long int)size, format, ap);
    return buf;
  }
}

// gg_watch_fd
// file ../../include/libgadu.h line 1367
struct gg_event * gg_watch_fd(struct gg_session *sess)
{
  struct gg_event *ge;
  struct gg_session_private *priv;
  gg_debug_session(sess, 8, "** gg_watch_fd(%p);\n", sess);
  if(sess == ((struct gg_session *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 14;
    return (struct gg_event *)(void *)0;
  }

  priv = sess->private_data;
  if(!(priv->event_queue == ((struct _gg_eventqueue *)NULL)))
  {
    struct _gg_eventqueue *next;
    ge = priv->event_queue->event;
    next = priv->event_queue->next;
    free((void *)priv->event_queue);
    priv->event_queue = next;
    if(next == ((struct _gg_eventqueue *)NULL))
    {
      sess->check = priv->check_after_queue;
      sess->fd = priv->fd_after_queue;
    }

    return ge;
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct gg_event) /*96ul*/ );
  ge = (struct gg_event *)return_value_malloc$2;
  if(ge == ((struct gg_event *)NULL))
  {
    gg_debug_session(sess, 16, "// gg_watch_fd() not enough memory for event data\n");
    return (struct gg_event *)(void *)0;
  }

  else
  {
    memset((void *)ge, 0, sizeof(struct gg_event) /*96ul*/ );
    ge->type = GG_EVENT_NONE;
    do
    {
      unsigned int i;
      unsigned int found = (unsigned int)0;
      enum anonymous$27 res = (enum anonymous$27)GG_ACTION_FAIL;
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= 35ul); i = i + 1u)
        if(handlers[(signed long int)i].state == (enum gg_state_t)sess->state)
        {
          const char *return_value_gg_debug_state$3;
          return_value_gg_debug_state$3=gg_debug_state((enum gg_state_t)sess->state);
          gg_debug_session(sess, 16, "// gg_watch_fd() %s\n", return_value_gg_debug_state$3);
          res=handlers[(signed long int)i].handler(sess, ge, handlers[(signed long int)i].next_state, handlers[(signed long int)i].alt_state, handlers[(signed long int)i].alt2_state);
          found = (unsigned int)1;
          break;
        }

      if(found == 0u)
      {
        const char *return_value_gg_debug_state$4;
        return_value_gg_debug_state$4=gg_debug_state((enum gg_state_t)sess->state);
        gg_debug_session(sess, 16 | 128, "// gg_watch_fd() invalid state %s\n", return_value_gg_debug_state$4);
        ge->event.failure = (enum gg_failure_t)GG_FAILURE_INTERNAL;
      }

      if(sess->async == 0)
      {
        if(ge->type == GG_EVENT_NONE)
        {
          if((signed int)res == GG_ACTION_WAIT)
            res = (enum anonymous$27)GG_ACTION_NEXT;

        }

      }

      switch((signed int)res)
      {
        case GG_ACTION_WAIT:
        {
          if(!(priv->event_queue == ((struct _gg_eventqueue *)NULL)))
          {
            priv->fd_after_queue = sess->fd;
            priv->check_after_queue = sess->check;
            sess->fd=gg_get_dummy_fd(sess);
            if(!(sess->fd >= 0))
              sess->fd = priv->fd_after_queue;

            sess->check = 2 | 1;
          }

          return ge;
        }
        case GG_ACTION_NEXT:
          break;
        case GG_ACTION_FAIL:
        {
          sess->state = GG_STATE_IDLE;
          gg_close(sess);
          if(!((signed int)ge->event.failure == 0))
            ge->type = GG_EVENT_CONN_FAILED;

          else
          {
            free((void *)ge);
            ge = (struct gg_event *)(void *)0;
          }
          return ge;
        }
        default:
          ;
      }
    }
    while((_Bool)1);
  }
}

// gg_write
// file libgadu.c line 459
signed int gg_write(struct gg_session *sess, const char *buf, signed int length)
{
  signed int res = 0;
  signed int *return_value___errno_location$1;
  if(sess->async == 0)
  {
    signed int written = 0;
    for( ; !(written >= length); res = written)
    {
      res=gg_write_common(sess, buf + (signed long int)written, length - written);
      if(res == -1)
        return -1;

      written = written + res;
    }
  }

  else
  {
    if(sess->send_buf == ((char *)NULL))
    {
      res=gg_write_common(sess, buf, length);
      if(res == -1)
      {
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 11)
          res = 0;

      }

      if(res == -1)
        return -1;

    }

    if(!(res >= length))
    {
      char *tmp;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)sess->send_buf, (unsigned long int)((sess->send_left + length) - res));
      tmp = (char *)return_value_realloc$3;
      if(tmp == ((char *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 12;
        return -1;
      }

      sess->send_buf = tmp;
      memcpy((void *)(sess->send_buf + (signed long int)sess->send_left), (const void *)(buf + (signed long int)res), (unsigned long int)(length - res));
      sess->send_left = sess->send_left + (length - res);
    }

  }
  return res;
}

// gg_write_common
// file libgadu.c line 359
static signed int gg_write_common(struct gg_session *sess, const char *buf, signed int length)
{
  struct gg_session_private *p = sess->private_data;
  signed int res;
  signed int *return_value___errno_location$3;
  signed int *return_value___errno_location$4;
  if(!(sess->ssl == NULL))
    do
    {
      signed long int return_value_gnutls_record_send$1;
      return_value_gnutls_record_send$1=gnutls_record_send(((struct anonymous$34 *)sess->ssl)->session, (const void *)buf, (unsigned long int)length);
      res = (signed int)return_value_gnutls_record_send$1;
      if(!(res >= 0))
      {
        signed int return_value_gnutls_error_is_fatal$2;
        return_value_gnutls_error_is_fatal$2=gnutls_error_is_fatal(res);
        if(return_value_gnutls_error_is_fatal$2 == 0 || res == -52)
          continue;

        if(res == -28)
        {
          return_value___errno_location$3=__errno_location();
          *return_value___errno_location$3 = 11;
        }

        else
        {
          return_value___errno_location$4=__errno_location();
          *return_value___errno_location$4 = 22;
        }
        return -1;
      }

      return res;
    }
    while((_Bool)1);

  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  if(!(p->socket_handle == NULL))
  {
    if(p->socket_manager.write_cb == ((signed long int (*)(void *, void *, const unsigned char *, unsigned long int))NULL))
    {
      gg_debug_session(sess, 16 | 128, "// gg_write_common() socket_manager.write callback is empty\n");
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      *return_value___errno_location$5 = 22;
      return -1;
    }

    signed long int return_value;
    return_value=p->socket_manager.write_cb(p->socket_manager.cb_data, p->socket_handle, (const unsigned char *)buf, (unsigned long int)length);
    res = (signed int)return_value;
    if(!(res >= 0))
    {
      return_value___errno_location$6=__errno_location();
      tmp_if_expr$7 = *return_value___errno_location$6 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$7 = (_Bool)0;
    if(!(res >= 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      if(*return_value___errno_location$8 == 11)
        return -1;

      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      gg_debug_session(sess, 16 | 128, "// gg_read() unexpected errno=%d\n", *return_value___errno_location$9);
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      *return_value___errno_location$10 = 22;
    }

    return res;
  }

  signed int *return_value___errno_location$12;
  do
  {
    signed long int return_value_send$11;
    return_value_send$11=send(sess->fd, (const void *)buf, (unsigned long int)length, 0);
    res = (signed int)return_value_send$11;
    if(res == -1)
    {
      return_value___errno_location$12=__errno_location();
      if(!(*return_value___errno_location$12 == 4))
        goto __CPROVER_DUMP_L14;

    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      return res;
    }
  }
  while((_Bool)1);
}

// main
// file connect.c line 1196
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int test_from = 0;
  signed int test_to = 0;
  signed int exit_code = 0;
  signed int res;
  unsigned long int server_thread;
  const char *srcdir;
  unsigned long int srcdir_len;
  char cert_file_path[2000l];
  char key_file_path[2000l];
  srcdir=getenv("srcdir");
  _Bool tmp_if_expr$1;
  if(srcdir == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)srcdir[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    srcdir = ".";

  srcdir_len=strlen(srcdir);
  if(srcdir_len >= 1001ul)
  {
    fprintf(stderr, "srcdir path too long\n");
    failure();
  }

  strncpy(cert_file_path, srcdir, srcdir_len);
  strncpy(key_file_path, srcdir, srcdir_len);
  cert_file_path[(signed long int)srcdir_len] = (char)47;
  key_file_path[(signed long int)srcdir_len] = (char)47;
  strcpy(cert_file_path + (signed long int)srcdir_len + (signed long int)1, "connect.pem");
  strcpy(key_file_path + (signed long int)srcdir_len + (signed long int)1, "connect.pem");
  res=gnutls_global_init();
  if(!(res == 0))
  {
    const char *return_value_gnutls_strerror$2;
    return_value_gnutls_strerror$2=gnutls_strerror(res);
    fprintf(stderr, "gnutls_global_init: %d, %s\n", res, return_value_gnutls_strerror$2);
    failure();
  }

  res=gnutls_certificate_allocate_credentials(&x509_cred);
  if(!(res == 0))
  {
    const char *return_value_gnutls_strerror$3;
    return_value_gnutls_strerror$3=gnutls_strerror(res);
    fprintf(stderr, "gnutls_certificate_allocate_credentials: %d, %s\n", res, return_value_gnutls_strerror$3);
    failure();
  }

  res=gnutls_certificate_set_x509_key_file(x509_cred, cert_file_path, key_file_path, (enum anonymous$2)GNUTLS_X509_FMT_PEM);
  if(!(res == 0))
  {
    const char *return_value_gnutls_strerror$4;
    return_value_gnutls_strerror$4=gnutls_strerror(res);
    fprintf(stderr, "gnutls_certificate_set_x509_key_file: %d, %s\n", res, return_value_gnutls_strerror$4);
    failure();
  }

  res=gnutls_dh_params_init(&dh_params);
  if(!(res == 0))
  {
    const char *return_value_gnutls_strerror$5;
    return_value_gnutls_strerror$5=gnutls_strerror(res);
    fprintf(stderr, "gnutls_dh_params_init: %d, %s\n", res, return_value_gnutls_strerror$5);
    failure();
  }

  res=gnutls_dh_params_generate2(dh_params, (unsigned int)1024);
  if(!(res == 0))
  {
    const char *return_value_gnutls_strerror$6;
    return_value_gnutls_strerror$6=gnutls_strerror(res);
    fprintf(stderr, "gnutls_dh_params_generate2: %d, %s\n", res, return_value_gnutls_strerror$6);
    failure();
  }

  gnutls_certificate_set_dh_params(x509_cred, dh_params);
  gnutls_initialized = (_Bool)1;
  signed int return_value_strcmp$7;
  _Bool tmp_if_expr$9;
  signed int return_value_strcmp$8;
  if(argc >= 2)
  {
    return_value_strcmp$7=strcmp(argv[(signed long int)1], "-v");
    if(return_value_strcmp$7 == 0)
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      return_value_strcmp$8=strcmp(argv[(signed long int)1], "--verbose");
      tmp_if_expr$9 = return_value_strcmp$8 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$9)
    {
      verbose = (_Bool)1;
      argv = argv + 1l;
      argc = argc - 1;
    }

  }

  if(argc >= 3)
  {
    test_from=atoi(argv[(signed long int)1]);
    test_to=atoi(argv[(signed long int)2]);
  }

  if(test_from >= 649 || test_to >= 649 || !(test_from >= 1) || !(test_to >= 1) || !(test_to >= test_from) || !(argc >= 3))
  {
    test_from = 1;
    test_to = 3 * 3 * 3 * 3 * 2 * 2 * 2;
  }

  gg_debug_handler = debug_handler;
  gg_debug_level = ~0;
  signed int return_value_socketpair$10;
  return_value_socketpair$10=socketpair(1, 1, 0, server_pipe);
  if(return_value_socketpair$10 == -1)
  {
    perror("server_pipe");
    failure();
  }

  signed int return_value_socketpair$11;
  return_value_socketpair$11=socketpair(1, 1, 0, timeout_pipe);
  if(return_value_socketpair$11 == -1)
  {
    perror("timeout_pipe");
    failure();
  }

  signed int return_value_gg_fd_set_nonblocking$12;
  return_value_gg_fd_set_nonblocking$12=gg_fd_set_nonblocking(timeout_pipe[(signed long int)0]);
  if(return_value_gg_fd_set_nonblocking$12 == 0)
  {
    perror("gg_fd_set_nonblocking() failed!");
    failure();
  }

  signed int return_value_pthread_create$13;
  return_value_pthread_create$13=pthread_create(&server_thread, (const union pthread_attr_t *)(void *)0, server_func, (void *)0);
  if(!(return_value_pthread_create$13 == 0))
  {
    fprintf(stderr, "pthread_create() failed!\n");
    failure();
  }

  signed int return_value_pthread_mutex_lock$14;
  return_value_pthread_mutex_lock$14=pthread_mutex_lock(&server_mutex);
  if(!(return_value_pthread_mutex_lock$14 == 0))
  {
    fprintf(stderr, "pthread_mutex_lock() failed!\n");
    failure();
  }

  while(server_init == (_Bool)0)
  {
    signed int return_value_pthread_cond_wait$15;
    return_value_pthread_cond_wait$15=pthread_cond_wait(&server_cond, &server_mutex);
    if(!(return_value_pthread_cond_wait$15 == 0))
    {
      fprintf(stderr, "pthread_cond_wait() failed!\n");
      failure();
    }

  }
  signed int return_value_pthread_mutex_unlock$16;
  return_value_pthread_mutex_unlock$16=pthread_mutex_unlock(&server_mutex);
  if(!(return_value_pthread_mutex_unlock$16 == 0))
  {
    fprintf(stderr, "pthread_mutex_unlock() failed!\n");
    failure();
  }

  i = test_from - 1;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$30;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$31;
  for( ; !(i >= test_to); i = i + 1)
  {
    signed int j;
    signed int expect = 0;
    struct anonymous$16 *test;
    test=get_test_param();
    memset((void *)test, 0, sizeof(struct anonymous$16) /*32ul*/ );
    test->plug_80 = (enum anonymous$15)(i % 3);
    test->plug_8074 = (enum anonymous$15)((i / 3) % 3);
    test->plug_443 = (enum anonymous$15)(((i / 3) / 3) % 3);
    test->plug_resolver = (enum anonymous$15)((((i / 3) / 3) / 3) % 3);
    test->server = (_Bool)(((((i / 3) / 3) / 3) / 3) % 2);
    test->proxy_mode = (_Bool)((((((i / 3) / 3) / 3) / 3) / 2) % 2);
    test->ssl_mode = (_Bool)(((((((i / 3) / 3) / 3) / 3) / 2) / 2) % 2);
    if(test->proxy_mode == (_Bool)0)
    {
      if((signed int)test->plug_resolver == PLUG_NONE)
        tmp_if_expr$19 = (signed int)test->plug_80 == PLUG_NONE ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$19 = (_Bool)0;
      if(tmp_if_expr$19)
        tmp_if_expr$20 = (_Bool)1;

      else
        tmp_if_expr$20 = test->server != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$20)
      {
        if(test->ssl_mode == (_Bool)0)
          tmp_if_expr$17 = (signed int)test->plug_8074 == PLUG_NONE ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$17 = (_Bool)0;
        if(tmp_if_expr$17)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = (signed int)test->plug_443 == PLUG_NONE ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$18)
          expect = 1;

      }

    }

    else
      if((signed int)test->plug_resolver == PLUG_NONE)
      {
        if((signed int)test->plug_8080 == PLUG_NONE)
        {
          if((signed int)test->plug_80 == PLUG_NONE)
            tmp_if_expr$21 = (_Bool)1;

          else
            tmp_if_expr$21 = test->server != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$21)
          {
            if((signed int)test->plug_443 == PLUG_NONE)
              expect = 1;

          }

        }

      }

    j = 0;
    for( ; !(j >= 2); j = j + 1)
    {
      _Bool result;
      const char *return_value_plug_to_string$22;
      return_value_plug_to_string$22=plug_to_string(test->plug_80);
      const char *return_value_plug_to_string$23;
      return_value_plug_to_string$23=plug_to_string(test->plug_8074);
      const char *return_value_plug_to_string$24;
      return_value_plug_to_string$24=plug_to_string(test->plug_443);
      const char *return_value_plug_to_string$25;
      return_value_plug_to_string$25=plug_to_string(test->plug_resolver);
      printf("%3d/%d: %s 80 %s 8074 %s 443 %s resolver %s server %s proxy %s ssl %s\n", i + 1, 3 * 3 * 3 * 3 * 2 * 2 * 2, j != 0 ? "async," : "sync, ", return_value_plug_to_string$22, return_value_plug_to_string$23, return_value_plug_to_string$24, return_value_plug_to_string$25, test->server != (_Bool)0 ? "yes," : "no, ", test->proxy_mode != (_Bool)0 ? "yes," : "no, ", test->ssl_mode != (_Bool)0 ? "yes" : "no ");
      test->async_mode = (_Bool)j;
      signed int return_value_client_func$26;
      return_value_client_func$26=client_func(test);
      result = return_value_client_func$26 == expect;
      if(!(test->proxy_mode == (_Bool)0))
      {
        if(!(test->tried_non_8080 == (_Bool)0))
        {
          result = (_Bool)0;
          debug("Connected directly when proxy enabled\n");
        }

      }

      if(test->proxy_mode == (_Bool)0)
      {
        if(!(test->tried_8080 == (_Bool)0))
        {
          result = (_Bool)0;
          debug("Connected to proxy when proxy disabled\n");
        }

      }

      if(!(test->server == (_Bool)0))
      {
        if(test->proxy_mode == (_Bool)0)
        {
          if(!(test->tried_resolver == (_Bool)0))
            tmp_if_expr$27 = (_Bool)1;

          else
            tmp_if_expr$27 = test->tried_80 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$27)
          {
            result = (_Bool)0;
            debug("Used resolver or hub when server provided\n");
          }

        }

      }

      if(test->proxy_mode == (_Bool)0)
      {
        if(test->ssl_mode == (_Bool)0)
        {
          if(!(test->tried_443 == (_Bool)0))
          {
            if(test->tried_8074 == (_Bool)0)
            {
              result = (_Bool)0;
              debug("Didn't try 8074 although tried 443\n");
            }

          }

        }

      }

      if(test->server == (_Bool)0)
      {
        if((signed int)test->plug_resolver == PLUG_NONE)
        {
          if(test->tried_80 == (_Bool)0)
          {
            result = (_Bool)0;
            debug("Didn't use hub\n");
          }

        }

      }

      if(!(test->server == (_Bool)0))
      {
        if(test->proxy_mode == (_Bool)0)
          tmp_if_expr$28 = (_Bool)1;

        else
          tmp_if_expr$28 = (signed int)test->plug_resolver == PLUG_NONE ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$28)
        {
          if(test->tried_8074 == (_Bool)0)
          {
            if(test->tried_443 == (_Bool)0)
            {
              result = (_Bool)0;
              debug("Didn't try connecting directly\n");
            }

          }

        }

      }

      if(!(test->server == (_Bool)0))
        tmp_if_expr$30 = (_Bool)1;

      else
      {
        if((signed int)test->plug_resolver == PLUG_NONE)
          tmp_if_expr$29 = (signed int)test->plug_80 == PLUG_NONE ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$29 = (_Bool)0;
        tmp_if_expr$30 = tmp_if_expr$29 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$30)
      {
        if(!((signed int)test->plug_8074 == PLUG_NONE))
        {
          if(test->tried_443 == (_Bool)0)
          {
            if(test->proxy_mode == (_Bool)0)
            {
              result = (_Bool)0;
              debug("Didn't try 443\n");
            }

          }

        }

      }

      if(!(test->proxy_mode == (_Bool)0))
        tmp_if_expr$31 = (_Bool)1;

      else
        tmp_if_expr$31 = test->ssl_mode != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$31)
      {
        if(!(test->tried_8074 == (_Bool)0))
        {
          result = (_Bool)0;
          debug("Tried 8074 in proxy or SSL mode\n");
        }

      }

      if(result == (_Bool)0 && verbose == (_Bool)0)
        printf("%s", log_buffer);

      if(result == (_Bool)0)
        exit_code = 1;

      free((void *)log_buffer);
      log_buffer = (char *)(void *)0;
    }
  }
  signed long int return_value_send$32;
  return_value_send$32=send(server_pipe[(signed long int)1], (const void *)"", (unsigned long int)1, 0);
  if(!(return_value_send$32 == 1l))
  {
    perror("send");
    failure();
  }

  signed int return_value_pthread_join$33;
  return_value_pthread_join$33=pthread_join(server_thread, (void **)(void *)0);
  if(!(return_value_pthread_join$33 == 0))
  {
    fprintf(stderr, "pthread_join() failed!\n");
    failure();
  }

  signed int return_value_close$34;
  return_value_close$34=close(timeout_pipe[(signed long int)0]);
  _Bool tmp_if_expr$36;
  signed int return_value_close$35;
  if(return_value_close$34 == -1)
    tmp_if_expr$36 = (_Bool)1;

  else
  {
    return_value_close$35=close(timeout_pipe[(signed long int)1]);
    tmp_if_expr$36 = return_value_close$35 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$38;
  signed int return_value_close$37;
  if(tmp_if_expr$36)
    tmp_if_expr$38 = (_Bool)1;

  else
  {
    return_value_close$37=close(server_pipe[(signed long int)0]);
    tmp_if_expr$38 = return_value_close$37 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$40;
  signed int return_value_close$39;
  if(tmp_if_expr$38)
    tmp_if_expr$40 = (_Bool)1;

  else
  {
    return_value_close$39=close(server_pipe[(signed long int)1]);
    tmp_if_expr$40 = return_value_close$39 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$40)
  {
    perror("close");
    failure();
  }

  gnutls_certificate_free_credentials(x509_cred);
  gnutls_dh_params_deinit(dh_params);
  gnutls_global_deinit();
  return exit_code;
}

// plug_to_string
// file connect.c line 1182
static const char * plug_to_string(enum anonymous$15 plug)
{
  switch((signed int)plug)
  {
    case PLUG_NONE:
      return "open,   ";
    case PLUG_RESET:
      return "closed, ";
    case PLUG_TIMEOUT:
      return "timeout,";
    default:
      return "unknown,";
  }
}

// protobuf_kvp__free_unpacked
// file packets.pb-c.c line 519
void protobuf_kvp__free_unpacked(struct _ProtobufKVP *message, struct ProtobufCAllocator *allocator)
{
  /* assertion message->base.descriptor == &protobuf_kvp__descriptor */
  assert(message->base.descriptor == &protobuf_kvp__descriptor);
  protobuf_c_message_free_unpacked((struct ProtobufCMessage *)message, allocator);
}

// protobuf_kvp__get_packed_size
// file packets.pb-c.c line 489
unsigned long int protobuf_kvp__get_packed_size(const struct _ProtobufKVP *message)
{
  /* assertion message->base.descriptor == &protobuf_kvp__descriptor */
  assert(message->base.descriptor == &protobuf_kvp__descriptor);
  unsigned long int return_value_protobuf_c_message_get_packed_size$1;
  return_value_protobuf_c_message_get_packed_size$1=protobuf_c_message_get_packed_size((const struct ProtobufCMessage *)message);
  return return_value_protobuf_c_message_get_packed_size$1;
}

// protobuf_kvp__init
// file packets.pb-c.c line 483
void protobuf_kvp__init(struct _ProtobufKVP *message)
{
  static struct _ProtobufKVP init_value = { .base={ .descriptor=&protobuf_kvp__descriptor, .n_unknown_fields=(unsigned int)0,
    .unknown_fields=(struct ProtobufCMessageUnknownField *)(void *)0 }, .key=(char *)(void *)0,
    .value=(char *)(void *)0 };
  *message = init_value;
}

// protobuf_kvp__pack
// file packets.pb-c.c line 495
unsigned long int protobuf_kvp__pack(const struct _ProtobufKVP *message, unsigned char *out)
{
  /* assertion message->base.descriptor == &protobuf_kvp__descriptor */
  assert(message->base.descriptor == &protobuf_kvp__descriptor);
  unsigned long int return_value_protobuf_c_message_pack$1;
  return_value_protobuf_c_message_pack$1=protobuf_c_message_pack((const struct ProtobufCMessage *)message, out);
  return return_value_protobuf_c_message_pack$1;
}

// protobuf_kvp__pack_to_buffer
// file packets.pb-c.c line 502
unsigned long int protobuf_kvp__pack_to_buffer(const struct _ProtobufKVP *message, struct ProtobufCBuffer *buffer)
{
  /* assertion message->base.descriptor == &protobuf_kvp__descriptor */
  assert(message->base.descriptor == &protobuf_kvp__descriptor);
  unsigned long int return_value_protobuf_c_message_pack_to_buffer$1;
  return_value_protobuf_c_message_pack_to_buffer$1=protobuf_c_message_pack_to_buffer((const struct ProtobufCMessage *)message, buffer);
  return return_value_protobuf_c_message_pack_to_buffer$1;
}

// protobuf_kvp__unpack
// file packets.pb-c.c line 510
struct _ProtobufKVP * protobuf_kvp__unpack(struct ProtobufCAllocator *allocator, unsigned long int len, const unsigned char *data)
{
  struct ProtobufCMessage *return_value_protobuf_c_message_unpack$1;
  return_value_protobuf_c_message_unpack$1=protobuf_c_message_unpack(&protobuf_kvp__descriptor, allocator, len, data);
  return (struct _ProtobufKVP *)return_value_protobuf_c_message_unpack$1;
}

// server_func
// file connect.c line 734
static void * server_func(void *arg)
{
  signed int server_fds[5l];
  signed int client_fd = -1;
  /* #anon_enum$CLIENT_UNKNOWN=0$CLIENT_HUB=1$CLIENT_GG=2$CLIENT_GG_SSL=3$CLIENT_PROXY=4 */
enum anonymous$22 { CLIENT_UNKNOWN=0, CLIENT_HUB=1, CLIENT_GG=2, CLIENT_GG_SSL=3, CLIENT_PROXY=4 };

/* */
  ;
  enum anonymous$22 ctype = (enum anonymous$22)CLIENT_UNKNOWN;
  signed int i;
  char buf[4096l];
  unsigned long int len = (unsigned long int)0;
  const char welcome_packet[12l] = { (const char)1, (const char)0, (const char)0, (const char)0, (const char)4, (const char)0, (const char)0, (const char)0, (const char)1, (const char)2, (const char)3, (const char)4 };
  const char login_ok_packet[8l] = { (const char)3, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0 };
  const char hub_reply[50l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '2', '0', '0', ' ', 'O', 'K', '\r', '\n', '\r', '\n', '0', ' ', '0', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', '8', '0', '7', '4', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', '\r', '\n', 0 };
  const char hub_ssl_reply[49l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '2', '0', '0', ' ', 'O', 'K', '\r', '\n', '\r', '\n', '0', ' ', '0', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', '4', '4', '3', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', '\r', '\n', 0 };
  const char proxy_reply[20l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '2', '0', '0', ' ', 'O', 'K', '\r', '\n', '\r', '\n', 0 };
  const char proxy_error[42l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '4', '0', '4', ' ', 'N', 'o', 't', ' ', 'F', 'o', 'u', 'n', 'd', '\r', '\n', '\r', '\n', '4', '0', '4', ' ', 'N', 'o', 't', ' ', 'F', 'o', 'u', 'n', 'd', '\r', '\n', 0 };
  struct gnutls_session_int *session = (struct gnutls_session_int *)(void *)0;
  i = 0;
  for( ; !(i >= 5); i = i + 1)
  {
    struct sockaddr_in sin;
    unsigned int sin_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    signed int value = 1;
    server_fds[(signed long int)i]=socket(2, 1, 0);
    if(server_fds[(signed long int)i] == -1)
    {
      perror("socket");
      failure();
    }

    signed int return_value_setsockopt$1;
    return_value_setsockopt$1=setsockopt(server_fds[(signed long int)i], 1, 2, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(return_value_setsockopt$1 == -1)
    {
      perror("setsockopt");
      failure();
    }

    memset((void *)&sin, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    sin.sin_family = (unsigned short int)2;
    sin.sin_addr.s_addr=inet_addr("127.0.0.1");
    signed int return_value_bind$2;
    return_value_bind$2=bind(server_fds[(signed long int)i], (struct sockaddr *)&sin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(return_value_bind$2 == -1)
    {
      perror("bind");
      failure();
    }

    signed int return_value_getsockname$3;
    return_value_getsockname$3=getsockname(server_fds[(signed long int)i], (struct sockaddr *)&sin, &sin_len);
    if(return_value_getsockname$3 == -1)
    {
      perror("getsockname");
      failure();
    }

    unsigned short int return_value_ntohs$4;
    return_value_ntohs$4=ntohs(sin.sin_port);
    server_ports[(signed long int)i] = (signed int)return_value_ntohs$4;
    if(!(i == 4))
    {
      signed int return_value_listen$5;
      return_value_listen$5=listen(server_fds[(signed long int)i], 1);
      if(return_value_listen$5 == -1)
      {
        perror("listen");
        failure();
      }

    }

  }
  signed int return_value_pthread_mutex_lock$6;
  return_value_pthread_mutex_lock$6=pthread_mutex_lock(&server_mutex);
  if(!(return_value_pthread_mutex_lock$6 == 0))
  {
    fprintf(stderr, "pthread_mutex_lock failed!\n");
    failure();
  }

  server_init = (_Bool)1;
  signed int return_value_pthread_cond_signal$7;
  return_value_pthread_cond_signal$7=pthread_cond_signal(&server_cond);
  if(!(return_value_pthread_cond_signal$7 == 0))
  {
    fprintf(stderr, "pthread_cond_signal failed!\n");
    failure();
  }

  signed int return_value_pthread_mutex_unlock$8;
  return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&server_mutex);
  if(!(return_value_pthread_mutex_unlock$8 == 0))
  {
    fprintf(stderr, "pthread_mutex_unlock failed!\n");
    failure();
  }

  signed int *return_value___errno_location$9;
  signed long int return_value_gnutls_record_recv$10;
  signed long int return_value_recv$11;
  char *return_value_strstr$20;
  unsigned int return_value_get32$22;
  unsigned int return_value_get32$24;
  char *return_value_strstr$53;
  unsigned long int return_value_strlen$49;
  signed int return_value_strncmp$50;
  _Bool tmp_if_expr$56;
  signed int return_value_close$55;
  _Bool tmp_if_expr$62;
  struct anonymous$16 *return_value_get_test_param$61;
  do
  {
    struct timeval tv;
    struct anonymous$19 rd;
    struct anonymous$19 wr;
    signed int max_fd = -1;
    signed int server_func$$1$$5$$1$$res;
    tv.tv_sec = (signed long int)1;
    tv.tv_usec = (signed long int)0;
    do
    {
      signed int server_func$$1$$5$$1$$1$$__d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(server_func$$1$$5$$1$$1$$__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rd)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int __d0;
      signed int server_func$$1$$5$$1$$2$$__d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(server_func$$1$$5$$1$$2$$__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wr)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= 5); i = i + 1)
      if(!(i == 4))
      {
        (&rd)->__fds_bits[(signed long int)(server_fds[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rd)->__fds_bits[(signed long int)(server_fds[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << server_fds[(signed long int)i] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(max_fd >= server_fds[(signed long int)i]))
          max_fd = server_fds[(signed long int)i];

      }

    if(!(client_fd == -1))
    {
      (&rd)->__fds_bits[(signed long int)(client_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rd)->__fds_bits[(signed long int)(client_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << client_fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(!(max_fd >= client_fd))
        max_fd = client_fd;

    }

    (&rd)->__fds_bits[(signed long int)(server_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rd)->__fds_bits[(signed long int)(server_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << server_pipe[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(max_fd >= server_pipe[0l]))
      max_fd = server_pipe[(signed long int)0];

    server_func$$1$$5$$1$$res=select(max_fd + 1, &rd, &wr, (struct anonymous$19 *)(void *)0, &tv);
    if(server_func$$1$$5$$1$$res == -1)
    {
      return_value___errno_location$9=__errno_location();
      if(!(*return_value___errno_location$9 == 4))
      {
        perror("select");
        failure();
      }

    }

    if(!(server_func$$1$$5$$1$$res == -1))
    {
      if(!(client_fd == -1))
      {
        if(!((rd.__fds_bits[(signed long int)(client_fd / 8)] & (signed long int)(1UL << client_fd % 8)) == 0l))
        {
          signed int res;
          struct anonymous$16 *test;
          test=get_test_param();
          if((signed int)ctype == CLIENT_GG_SSL)
          {
            return_value_gnutls_record_recv$10=gnutls_record_recv(session, (void *)(buf + (signed long int)len), (sizeof(char [4096l]) /*4096ul*/  - len) - (unsigned long int)1);
            res = (signed int)return_value_gnutls_record_recv$10;
          }

          else
          {
            return_value_recv$11=recv(client_fd, (void *)(buf + (signed long int)len), (sizeof(char [4096l]) /*4096ul*/  - len) - (unsigned long int)1, 0);
            res = (signed int)return_value_recv$11;
          }
          if(!(res >= 1))
          {
            server_ssl_deinit(&session);
            signed int return_value_close$12;
            return_value_close$12=close(client_fd);
            if(return_value_close$12 == -1)
            {
              perror("close");
              failure();
            }

            client_fd = -1;
            continue;
          }

          buf[(signed long int)(len + (unsigned long int)res)] = (char)0;
          len = len + (unsigned long int)res;
          switch((signed int)ctype)
          {
            case CLIENT_UNKNOWN:
              break;
            case CLIENT_HUB:
            {
              return_value_strstr$20=strstr(buf, "\r\n\r\n");
              if(!(return_value_strstr$20 == ((char *)NULL)))
              {
                if(test->ssl_mode == (_Bool)0)
                {
                  unsigned long int return_value_strlen$13;
                  return_value_strlen$13=strlen(hub_reply);
                  signed long int return_value_send$14;
                  return_value_send$14=send(client_fd, (const void *)hub_reply, return_value_strlen$13, 0);
                  unsigned long int return_value_strlen$15;
                  return_value_strlen$15=strlen(hub_reply);
                  if(!(return_value_send$14 == (signed long int)return_value_strlen$15))
                  {
                    fprintf(stderr, "send() not completed\n");
                    failure();
                  }

                }

                else
                {
                  unsigned long int return_value_strlen$16;
                  return_value_strlen$16=strlen(hub_ssl_reply);
                  signed long int return_value_send$17;
                  return_value_send$17=send(client_fd, (const void *)hub_ssl_reply, return_value_strlen$16, 0);
                  unsigned long int return_value_strlen$18;
                  return_value_strlen$18=strlen(hub_ssl_reply);
                  if(!(return_value_send$17 == (signed long int)return_value_strlen$18))
                  {
                    fprintf(stderr, "send() not completed\n");
                    failure();
                  }

                }
                signed int return_value_close$19;
                return_value_close$19=close(client_fd);
                if(return_value_close$19 == -1)
                {
                  perror("close");
                  failure();
                }

                client_fd = -1;
              }

              break;
            }
            case CLIENT_GG:
            {
              if(len >= 9ul)
              {
                return_value_get32$22=get32(buf + (signed long int)4);
                if(len >= (unsigned long int)return_value_get32$22)
                {
                  signed long int return_value_send$21;
                  return_value_send$21=send(client_fd, (const void *)login_ok_packet, sizeof(const char [8l]) /*8ul*/ , 0);
                  if(!((unsigned long int)return_value_send$21 == sizeof(const char [8l]) /*8ul*/ ))
                  {
                    fprintf(stderr, "send() not completed\n");
                    failure();
                  }

                }

              }

              break;
            }
            case CLIENT_GG_SSL:
            {
              if(len >= 9ul)
              {
                return_value_get32$24=get32(buf + (signed long int)4);
                if(len >= (unsigned long int)return_value_get32$24)
                {
                  signed long int return_value_gnutls_record_send$23;
                  return_value_gnutls_record_send$23=gnutls_record_send(session, (const void *)login_ok_packet, sizeof(const char [8l]) /*8ul*/ );
                  if(!((unsigned long int)return_value_gnutls_record_send$23 == sizeof(const char [8l]) /*8ul*/ ))
                  {
                    fprintf(stderr, "gnutls_record_send() not completed\n");
                    failure();
                  }

                }

              }

              break;
            }
            case CLIENT_PROXY:
            {
              return_value_strstr$53=strstr(buf, "\r\n\r\n");
              if(!(return_value_strstr$53 == ((char *)NULL)))
              {
                struct anonymous$16 *server_func$$1$$5$$1$$6$$2$$4$$test;
                server_func$$1$$5$$1$$6$$2$$4$$test=get_test_param();
                unsigned long int return_value_strlen$51;
                return_value_strlen$51=strlen("GET http://appmsg.gadu-gadu.pl");
                signed int return_value_strncmp$52;
                return_value_strncmp$52=strncmp(buf, "GET http://appmsg.gadu-gadu.pl", return_value_strlen$51);
                if(return_value_strncmp$52 == 0)
                {
                  server_func$$1$$5$$1$$6$$2$$4$$test->tried_80 = (_Bool)1;
                  if((signed int)server_func$$1$$5$$1$$6$$2$$4$$test->plug_80 == PLUG_NONE)
                  {
                    if(server_func$$1$$5$$1$$6$$2$$4$$test->ssl_mode == (_Bool)0)
                    {
                      unsigned long int return_value_strlen$25;
                      return_value_strlen$25=strlen(hub_reply);
                      signed long int return_value_send$26;
                      return_value_send$26=send(client_fd, (const void *)hub_reply, return_value_strlen$25, 0);
                      unsigned long int return_value_strlen$27;
                      return_value_strlen$27=strlen(hub_reply);
                      if(!(return_value_send$26 == (signed long int)return_value_strlen$27))
                      {
                        fprintf(stderr, "send() not completed\n");
                        failure();
                      }

                    }

                    else
                    {
                      unsigned long int return_value_strlen$28;
                      return_value_strlen$28=strlen(hub_ssl_reply);
                      signed long int return_value_send$29;
                      return_value_send$29=send(client_fd, (const void *)hub_ssl_reply, return_value_strlen$28, 0);
                      unsigned long int return_value_strlen$30;
                      return_value_strlen$30=strlen(hub_ssl_reply);
                      if(!(return_value_send$29 == (signed long int)return_value_strlen$30))
                      {
                        fprintf(stderr, "send() not completed\n");
                        failure();
                      }

                    }
                  }

                  else
                  {
                    unsigned long int return_value_strlen$31;
                    return_value_strlen$31=strlen(proxy_error);
                    signed long int return_value_send$32;
                    return_value_send$32=send(client_fd, (const void *)proxy_error, return_value_strlen$31, 0);
                    unsigned long int return_value_strlen$33;
                    return_value_strlen$33=strlen(proxy_error);
                    if(!(return_value_send$32 == (signed long int)return_value_strlen$33))
                    {
                      fprintf(stderr, "send() not completed\n");
                      failure();
                    }

                  }
                  signed int return_value_close$34;
                  return_value_close$34=close(client_fd);
                  if(return_value_close$34 == -1)
                  {
                    perror("close");
                    failure();
                  }

                  client_fd = -1;
                }

                else
                {
                  return_value_strlen$49=strlen("CONNECT 127.0.0.1:443 ");
                  return_value_strncmp$50=strncmp(buf, "CONNECT 127.0.0.1:443 ", return_value_strlen$49);
                  if(return_value_strncmp$50 == 0)
                  {
                    server_func$$1$$5$$1$$6$$2$$4$$test->tried_443 = (_Bool)1;
                    if((signed int)server_func$$1$$5$$1$$6$$2$$4$$test->plug_443 == PLUG_NONE)
                    {
                      unsigned long int return_value_strlen$35;
                      return_value_strlen$35=strlen(proxy_reply);
                      signed long int return_value_send$36;
                      return_value_send$36=send(client_fd, (const void *)proxy_reply, return_value_strlen$35, 0);
                      unsigned long int return_value_strlen$37;
                      return_value_strlen$37=strlen(proxy_reply);
                      if(!(return_value_send$36 == (signed long int)return_value_strlen$37))
                      {
                        fprintf(stderr, "send() not completed\n");
                        failure();
                      }

                      if(!(server_func$$1$$5$$1$$6$$2$$4$$test->ssl_mode == (_Bool)0))
                      {
                        signed int server_func$$1$$5$$1$$6$$2$$4$$2$$1$$2$$res;
                        server_func$$1$$5$$1$$6$$2$$4$$2$$1$$2$$res=server_ssl_init(&session, client_fd);
                        if(!(server_func$$1$$5$$1$$6$$2$$4$$2$$1$$2$$res == 0))
                        {
                          const char *return_value_gnutls_strerror$38;
                          return_value_gnutls_strerror$38=gnutls_strerror(server_func$$1$$5$$1$$6$$2$$4$$2$$1$$2$$res);
                          debug("Handshake failed: %d, %s\n", server_func$$1$$5$$1$$6$$2$$4$$2$$1$$2$$res, return_value_gnutls_strerror$38);
                          signed int return_value_close$39;
                          return_value_close$39=close(client_fd);
                          if(return_value_close$39 == -1)
                          {
                            perror("close");
                            failure();
                          }

                          client_fd = -1;
                          goto __CPROVER_DUMP_L84;
                        }

                        signed long int return_value_gnutls_record_send$40;
                        return_value_gnutls_record_send$40=gnutls_record_send(session, (const void *)welcome_packet, sizeof(const char [12l]) /*12ul*/ );
                        if(!((unsigned long int)return_value_gnutls_record_send$40 == sizeof(const char [12l]) /*12ul*/ ))
                        {
                          fprintf(stderr, "gnutls_record_send() not completed\n");
                          failure();
                        }

                        ctype = (enum anonymous$22)CLIENT_GG_SSL;
                      }

                      else
                      {
                        signed long int return_value_send$41;
                        return_value_send$41=send(client_fd, (const void *)welcome_packet, sizeof(const char [12l]) /*12ul*/ , 0);
                        if(!((unsigned long int)return_value_send$41 == sizeof(const char [12l]) /*12ul*/ ))
                        {
                          fprintf(stderr, "send() not completed\n");
                          failure();
                        }

                        ctype = (enum anonymous$22)CLIENT_GG;
                      }
                    }

                    else
                    {
                      unsigned long int return_value_strlen$42;
                      return_value_strlen$42=strlen(proxy_error);
                      signed long int return_value_send$43;
                      return_value_send$43=send(client_fd, (const void *)proxy_error, return_value_strlen$42, 0);
                      unsigned long int return_value_strlen$44;
                      return_value_strlen$44=strlen(proxy_error);
                      if(!(return_value_send$43 == (signed long int)return_value_strlen$44))
                      {
                        fprintf(stderr, "send() not completed\n");
                        failure();
                      }

                    }
                    len = (unsigned long int)0;
                  }

                  else
                  {
                    debug("Invalid proxy request");
                    unsigned long int return_value_strlen$45;
                    return_value_strlen$45=strlen(proxy_error);
                    signed long int return_value_send$46;
                    return_value_send$46=send(client_fd, (const void *)proxy_error, return_value_strlen$45, 0);
                    unsigned long int return_value_strlen$47;
                    return_value_strlen$47=strlen(proxy_error);
                    if(!(return_value_send$46 == (signed long int)return_value_strlen$47))
                    {
                      fprintf(stderr, "send() not completed\n");
                      failure();
                    }

                    signed int return_value_close$48;
                    return_value_close$48=close(client_fd);
                    if(return_value_close$48 == -1)
                    {
                      perror("close");
                      failure();
                    }

                    client_fd = -1;
                  }
                }
              }

            }
          }
        }

      }

      i = 0;
      for( ; !(i >= 5); i = i + 1)
      {
        if(!(i == 4))
        {
          if(!((rd.__fds_bits[(signed long int)(server_fds[(signed long int)i] / 8)] & (signed long int)(1UL << server_fds[(signed long int)i] % 8)) == 0l))
          {
            struct sockaddr_in server_func$$1$$5$$1$$7$$1$$1$$sin;
            unsigned int server_func$$1$$5$$1$$7$$1$$1$$sin_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
            signed int new_fd;
            new_fd=accept(server_fds[(signed long int)i], (struct sockaddr *)&server_func$$1$$5$$1$$7$$1$$1$$sin, &server_func$$1$$5$$1$$7$$1$$1$$sin_len);
            if(new_fd == -1)
            {
              perror("accept");
              failure();
            }

            if(!(client_fd == -1))
            {
              debug("Overlapping connections\n");
              signed int return_value_close$54;
              return_value_close$54=close(new_fd);
              if(return_value_close$54 == -1)
                tmp_if_expr$56 = (_Bool)1;

              else
              {
                return_value_close$55=close(client_fd);
                tmp_if_expr$56 = return_value_close$55 == -1 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$56)
              {
                perror("close");
                failure();
              }

              client_fd = -1;
              goto __CPROVER_DUMP_L82;
            }

            client_fd = new_fd;
            memset((void *)buf, 0, sizeof(char [4096l]) /*4096ul*/ );
            len = (unsigned long int)0;
            if(i == 0)
              ctype = (enum anonymous$22)CLIENT_HUB;

            else
            {
              if(i == 1)
              {
                return_value_get_test_param$61=get_test_param();
                tmp_if_expr$62 = return_value_get_test_param$61->ssl_mode != (_Bool)0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$62 = (_Bool)0;
              if(tmp_if_expr$62)
              {
                signed int server_func$$1$$5$$1$$7$$1$$1$$3$$res;
                ctype = (enum anonymous$22)CLIENT_GG_SSL;
                server_func$$1$$5$$1$$7$$1$$1$$3$$res=server_ssl_init(&session, client_fd);
                if(!(server_func$$1$$5$$1$$7$$1$$1$$3$$res == 0))
                {
                  const char *return_value_gnutls_strerror$57;
                  return_value_gnutls_strerror$57=gnutls_strerror(server_func$$1$$5$$1$$7$$1$$1$$3$$res);
                  debug("Handshake failed: %d, %s\n", server_func$$1$$5$$1$$7$$1$$1$$3$$res, return_value_gnutls_strerror$57);
                  signed int return_value_close$58;
                  return_value_close$58=close(client_fd);
                  if(return_value_close$58 == -1)
                  {
                    perror("close");
                    failure();
                  }

                  client_fd = -1;
                  goto __CPROVER_DUMP_L82;
                }

                signed long int return_value_gnutls_record_send$59;
                return_value_gnutls_record_send$59=gnutls_record_send(session, (const void *)welcome_packet, sizeof(const char [12l]) /*12ul*/ );
                if(!((unsigned long int)return_value_gnutls_record_send$59 == sizeof(const char [12l]) /*12ul*/ ))
                {
                  fprintf(stderr, "gnutls_record_send() not completed\n");
                  failure();
                }

              }

              else
                if(i == 1 || i == 2)
                {
                  ctype = (enum anonymous$22)CLIENT_GG;
                  signed long int return_value_send$60;
                  return_value_send$60=send(client_fd, (const void *)welcome_packet, sizeof(const char [12l]) /*12ul*/ , 0);
                  if(!((unsigned long int)return_value_send$60 == sizeof(const char [12l]) /*12ul*/ ))
                  {
                    fprintf(stderr, "send() not completed\n");
                    failure();
                  }

                }

                else
                  if(i == 3)
                    ctype = (enum anonymous$22)CLIENT_PROXY;

            }
          }

        }


      __CPROVER_DUMP_L82:
        ;
      }
      if(!((rd.__fds_bits[(signed long int)(server_pipe[0l] / 8)] & (signed long int)(1UL << server_pipe[0l] % 8)) == 0l))
        break;

    }


  __CPROVER_DUMP_L84:
    ;
  }
  while((_Bool)1);
  i = 0;
  signed int return_value_close$63;
  for( ; !(i >= 5); i = i + 1)
  {
    return_value_close$63=close(server_fds[(signed long int)i]);
    if(return_value_close$63 == -1)
    {
      perror("close");
      failure();
    }

  }
  signed int return_value_close$64;
  if(!(client_fd == -1))
  {
    return_value_close$64=close(client_fd);
    if(return_value_close$64 == -1)
    {
      perror("close");
      failure();
    }

  }

  return (void *)0;
}

// server_ssl_deinit
// file connect.c line 727
static void server_ssl_deinit(struct gnutls_session_int **session)
{
  gnutls_deinit(*session);
  *session = (struct gnutls_session_int *)(void *)0;
}

// server_ssl_init
// file connect.c line 696
static signed int server_ssl_init(struct gnutls_session_int **session, signed int client_fd)
{
  signed int res;
  if(!(*session == ((struct gnutls_session_int *)NULL)))
  {
    gnutls_deinit(*session);
    *session = (struct gnutls_session_int *)(void *)0;
  }

  res=gnutls_init(session, (unsigned int)1);
  if(res == 0)
  {
    res=gnutls_set_default_priority(*session);
    if(!(res == 0))
      goto fail;

    res=gnutls_credentials_set(*session, (enum anonymous$11)GNUTLS_CRD_CERTIFICATE, (void *)x509_cred);
    if(!(res == 0))
      goto fail;

    gnutls_transport_set_ptr(*session, (void *)(signed long int)client_fd);
    res=gnutls_handshake(*session);
    if(!(res == 0))
      goto fail;

    return 0;
  }

  else
  {

  fail:
    ;
    gnutls_deinit(*session);
    *session = (struct gnutls_session_int *)(void *)0;
    return res;
  }
}

