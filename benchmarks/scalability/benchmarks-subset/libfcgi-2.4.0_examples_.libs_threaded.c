// tag-#anon#ST[*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'stdio_stream'||*{SYM#tag-FCGX_Stream#}$SYM#tag-FCGX_Stream#$'fcgx_stream'|]
// file ../include/fcgi_stdio.h line 38
struct anonymous$16;

// tag-#anon#ST[*{V(*{V}$V$|S32)->V}$V(*{V}$V$|S32)->V$'procPtr'||*{V}$V$'clientData'||S32'fd'||S32'len'||S32'offset'||U32'$pad0'||*{V}$V$'buf'||S32'inUse'||U32'$pad1'|]
// file os_unix.c line 70
struct anonymous;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$20;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$18;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$0;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$3;

// tag-#anon#ST[S32'__count'||SYM#tag-#anon#UN[U32'__wch'||ARR4{S8}$S8$'__wchb'|]#'__value'|]
// file /usr/include/wchar.h line 82
struct anonymous$9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$10;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$17;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$14;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$5;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$12;

// tag-#anon#ST[S64'__pos'||SYM#tag-#anon#ST[S32'__count'||SYM#tag-#anon#UN[U32'__wch'||ARR4{S8}$S8$'__wchb'|]#'__value'|]#'__state'|]
// file /usr/include/_G_config.h line 21
struct anonymous$11;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$19;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'version'||U8'type'||U8'requestIdB1'||U8'requestIdB0'||U8'contentLengthB1'||U8'contentLengthB0'||U8'paddingLength'||U8'reserved'|]#'header'||SYM#tag-#anon#ST[U8'appStatusB3'||U8'appStatusB2'||U8'appStatusB1'||U8'appStatusB0'||U8'protocolStatus'||ARR3{U8}$U8$'reserved'|]#'body'|]
// file ../include/fastcgi.h line 103
struct anonymous$21;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'version'||U8'type'||U8'requestIdB1'||U8'requestIdB0'||U8'contentLengthB1'||U8'contentLengthB0'||U8'paddingLength'||U8'reserved'|]#'header'||SYM#tag-#anon#ST[U8'type'||ARR7{U8}$U8$'reserved'|]#'body'|]
// file ../include/fastcgi.h line 130
struct anonymous$22;

// tag-#anon#ST[U8'appStatusB3'||U8'appStatusB2'||U8'appStatusB1'||U8'appStatusB0'||U8'protocolStatus'||ARR3{U8}$U8$'reserved'|]
// file ../include/fastcgi.h line 94
struct anonymous$15;

// tag-#anon#ST[U8'roleB1'||U8'roleB0'||U8'flags'||ARR5{U8}$U8$'reserved'|]
// file ../include/fastcgi.h line 69
struct anonymous$23;

// tag-#anon#ST[U8'type'||ARR7{U8}$U8$'reserved'|]
// file ../include/fastcgi.h line 125
struct anonymous$1;

// tag-#anon#ST[U8'version'||U8'type'||U8'requestIdB1'||U8'requestIdB0'||U8'contentLengthB1'||U8'contentLengthB0'||U8'paddingLength'||U8'reserved'|]
// file ../include/fastcgi.h line 23
struct anonymous$13;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$6;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$24;

// tag-#anon#UN[U32'__wch'||ARR4{S8}$S8$'__wchb'|]
// file /usr/include/wchar.h line 85
union anonymous$8;

// tag-FCGX_Request
// file ../include/fcgiapp.h line 91
struct FCGX_Request;

// tag-FCGX_Stream
// file ../include/fcgiapp.h line 53
struct FCGX_Stream;

// tag-FCGX_Stream_Data
// file fcgiapp.c line 1296
struct FCGX_Stream_Data;

// tag-Params
// file ../include/fcgiapp.h line 101
struct Params;

// tag-SockAddrUnion
// file os_unix.c line 277
union SockAddrUnion;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// AcquireLock
// file os_unix.c line 1000
static signed int AcquireLock(signed int sock, signed int fail_on_intr);
// AlignInt8
// file fcgiapp.c line 1272
static signed int AlignInt8(unsigned int n);
// AlignPtr8
// file fcgiapp.c line 1286
static unsigned char * AlignPtr8(unsigned char *p);
// ClientAddrOK
// file os_unix.c line 956
static signed int ClientAddrOK(struct sockaddr_in *saPtr, const char *clientList);
// CopyAndAdvance
// file fcgiapp.c line 858
static void CopyAndAdvance(char **destPtr, char **srcPtr, signed int n);
// EmptyBuffProc
// file fcgiapp.c line 1386
static void EmptyBuffProc(struct FCGX_Stream *stream, signed int doClose);
// FCGI_Accept
// file fcgi_stdio.c line 113
signed int FCGI_Accept(void);
// FCGI_Finish
// file fcgi_stdio.c line 180
void FCGI_Finish(void);
// FCGI_OpenFromFILE
// file fcgi_stdio.c line 270
static struct anonymous$16 * FCGI_OpenFromFILE(struct _IO_FILE *stream);
// FCGI_SetExitStatus
// file fcgi_stdio.c line 233
void FCGI_SetExitStatus(signed int status);
// FCGI_StartFilterData
// file fcgi_stdio.c line 210
signed int FCGI_StartFilterData(void);
// FCGI_clearerr
// file fcgi_stdio.c line 716
void FCGI_clearerr(struct anonymous$16 *fp);
// FCGI_fclose
// file fcgi_stdio.c line 307
signed int FCGI_fclose(struct anonymous$16 *fp);
// FCGI_fdopen
// file fcgi_stdio.c line 763
struct anonymous$16 * FCGI_fdopen(signed int fd, const char *mode);
// FCGI_feof
// file fcgi_stdio.c line 695
signed int FCGI_feof(struct anonymous$16 *fp);
// FCGI_ferror
// file fcgi_stdio.c line 706
signed int FCGI_ferror(struct anonymous$16 *fp);
// FCGI_fflush
// file fcgi_stdio.c line 323
signed int FCGI_fflush(struct anonymous$16 *fp);
// FCGI_fgetc
// file fcgi_stdio.c line 450
signed int FCGI_fgetc(struct anonymous$16 *fp);
// FCGI_fgetpos
// file fcgi_stdio.c line 417
signed int FCGI_fgetpos(struct anonymous$16 *fp, struct anonymous$11 *pos);
// FCGI_fgets
// file fcgi_stdio.c line 482
char * FCGI_fgets(char *str, signed int size, struct anonymous$16 *fp);
// FCGI_fileno
// file fcgi_stdio.c line 755
signed int FCGI_fileno(struct anonymous$16 *fp);
// FCGI_fopen
// file fcgi_stdio.c line 296
struct anonymous$16 * FCGI_fopen(const char *path, const char *mode);
// FCGI_fprintf
// file fcgi_stdio.c line 597
signed int FCGI_fprintf(struct anonymous$16 *fp, const char *format, ...);
// FCGI_fputc
// file fcgi_stdio.c line 537
signed int FCGI_fputc(signed int c, struct anonymous$16 *fp);
// FCGI_fputs
// file fcgi_stdio.c line 560
signed int FCGI_fputs(const char *str, struct anonymous$16 *fp);
// FCGI_fread
// file fcgi_stdio.c line 656
unsigned long int FCGI_fread(void *ptr, unsigned long int size, unsigned long int nmemb, struct anonymous$16 *fp);
// FCGI_freopen
// file fcgi_stdio.c line 334
struct anonymous$16 * FCGI_freopen(const char *path, const char *mode, struct anonymous$16 *fp);
// FCGI_fseek
// file fcgi_stdio.c line 388
signed int FCGI_fseek(struct anonymous$16 *fp, signed long int offset, signed int whence);
// FCGI_fsetpos
// file fcgi_stdio.c line 427
signed int FCGI_fsetpos(struct anonymous$16 *fp, const struct anonymous$11 *pos);
// FCGI_ftell
// file fcgi_stdio.c line 398
signed int FCGI_ftell(struct anonymous$16 *fp);
// FCGI_fwrite
// file fcgi_stdio.c line 671
unsigned long int FCGI_fwrite(void *ptr, unsigned long int size, unsigned long int nmemb, struct anonymous$16 *fp);
// FCGI_getchar
// file fcgi_stdio.c line 459
signed int FCGI_getchar(void);
// FCGI_gets
// file fcgi_stdio.c line 497
char * FCGI_gets(char *str);
// FCGI_pclose
// file fcgi_stdio.c line 785
signed int FCGI_pclose(struct anonymous$16 *fp);
// FCGI_perror
// file fcgi_stdio.c line 249
void FCGI_perror(const char *str);
// FCGI_popen
// file fcgi_stdio.c line 774
struct anonymous$16 * FCGI_popen(const char *cmd, const char *type);
// FCGI_printf
// file fcgi_stdio.c line 610
signed int FCGI_printf(const char *format, ...);
// FCGI_putchar
// file fcgi_stdio.c line 546
signed int FCGI_putchar(signed int c);
// FCGI_puts
// file fcgi_stdio.c line 569
signed int FCGI_puts(const char *str);
// FCGI_rewind
// file fcgi_stdio.c line 408
void FCGI_rewind(struct anonymous$16 *fp);
// FCGI_setbuf
// file fcgi_stdio.c line 373
void FCGI_setbuf(struct anonymous$16 *fp, char *buf);
// FCGI_setvbuf
// file fcgi_stdio.c line 364
signed int FCGI_setvbuf(struct anonymous$16 *fp, char *buf, signed int bufmode, unsigned long int size);
// FCGI_tmpfile
// file fcgi_stdio.c line 735
struct anonymous$16 * FCGI_tmpfile(void);
// FCGI_ungetc
// file fcgi_stdio.c line 464
signed int FCGI_ungetc(signed int c, struct anonymous$16 *fp);
// FCGI_vfprintf
// file fcgi_stdio.c line 629
signed int FCGI_vfprintf(struct anonymous$16 *fp, const char *format, void **ap);
// FCGI_vprintf
// file fcgi_stdio.c line 638
signed int FCGI_vprintf(const char *format, void **ap);
// FCGX_Accept
// file fcgiapp.c line 2127
signed int FCGX_Accept(struct FCGX_Stream **in, struct FCGX_Stream **out, struct FCGX_Stream **err, char ***envp);
// FCGX_Accept_r
// file ../include/fcgiapp.h line 207
signed int FCGX_Accept_r(struct FCGX_Request *reqDataPtr);
// FCGX_ClearError
// file fcgiapp.c line 977
void FCGX_ClearError(struct FCGX_Stream *stream);
// FCGX_CreateWriter
// file fcgiapp.c line 1903
struct FCGX_Stream * FCGX_CreateWriter(signed int ipcFd, signed int requestId, signed int bufflen, signed int streamType);
// FCGX_FClose
// file fcgiapp.c line 912
signed int FCGX_FClose(struct FCGX_Stream *stream);
// FCGX_FFlush
// file fcgiapp.c line 887
signed int FCGX_FFlush(struct FCGX_Stream *stream);
// FCGX_FPrintF
// file ../include/fcgiapp.h line 510
signed int FCGX_FPrintF(struct FCGX_Stream *stream, const char *format, ...);
// FCGX_Finish
// file fcgiapp.c line 1979
void FCGX_Finish(void);
// FCGX_Finish_r
// file ../include/fcgiapp.h line 228
void FCGX_Finish_r(struct FCGX_Request *reqDataPtr);
// FCGX_Free
// file fcgiapp.c line 2024
void FCGX_Free(struct FCGX_Request *request, signed int close);
// FCGX_FreeStream
// file fcgiapp.c line 1822
void FCGX_FreeStream(struct FCGX_Stream **streamPtr);
// FCGX_GetChar
// file fcgiapp.c line 108
signed int FCGX_GetChar(struct FCGX_Stream *stream);
// FCGX_GetError
// file fcgiapp.c line 964
signed int FCGX_GetError(struct FCGX_Stream *stream);
// FCGX_GetLine
// file fcgiapp.c line 200
char * FCGX_GetLine(char *str, signed int n, struct FCGX_Stream *stream);
// FCGX_GetParam
// file ../include/fcgiapp.h line 349
char * FCGX_GetParam(const char *name, char **envp);
// FCGX_GetStr
// file fcgiapp.c line 143
signed int FCGX_GetStr(char *str, signed int n, struct FCGX_Stream *stream);
// FCGX_HasSeenEOF
// file fcgiapp.c line 266
signed int FCGX_HasSeenEOF(struct FCGX_Stream *stream);
// FCGX_Init
// file ../include/fcgiapp.h line 142
signed int FCGX_Init(void);
// FCGX_InitRequest
// file ../include/fcgiapp.h line 175
signed int FCGX_InitRequest(struct FCGX_Request *request, signed int sock, signed int flags);
// FCGX_IsCGI
// file fcgiapp.c line 1940
signed int FCGX_IsCGI(void);
// FCGX_OpenSocket
// file fcgiapp.c line 2040
signed int FCGX_OpenSocket(const char *path, signed int backlog);
// FCGX_PutChar
// file fcgiapp.c line 282
signed int FCGX_PutChar(signed int c, struct FCGX_Stream *stream);
// FCGX_PutS
// file fcgiapp.c line 356
signed int FCGX_PutS(const char *str, struct FCGX_Stream *stream);
// FCGX_PutStr
// file fcgiapp.c line 310
signed int FCGX_PutStr(const char *str, signed int n, struct FCGX_Stream *stream);
// FCGX_SetExitStatus
// file fcgiapp.c line 2305
void FCGX_SetExitStatus(signed int status, struct FCGX_Stream *stream);
// FCGX_ShutdownPending
// file fcgiapp.c line 74
void FCGX_ShutdownPending(void);
// FCGX_StartFilterData
// file fcgiapp.c line 2277
signed int FCGX_StartFilterData(struct FCGX_Stream *stream);
// FCGX_UnGetChar
// file fcgiapp.c line 237
signed int FCGX_UnGetChar(signed int c, struct FCGX_Stream *stream);
// FCGX_VFPrintF
// file fcgiapp.c line 411
signed int FCGX_VFPrintF(struct FCGX_Stream *stream, const char *format, __builtin_va_list arg);
// FillBuffProc
// file fcgiapp.c line 1625
static void FillBuffProc(struct FCGX_Stream *stream);
// FreeParams
// file fcgiapp.c line 1046
static void FreeParams(struct Params **paramsPtrPtr);
// GrowAsyncTable
// file os_unix.c line 605
static void GrowAsyncTable(void);
// MakeEndRequestBody
// file fcgiapp.c line 1230
static struct anonymous$15 MakeEndRequestBody(signed int appStatus, signed int protocolStatus);
// MakeHeader
// file fcgiapp.c line 1201
static struct anonymous$13 MakeHeader(signed int type, signed int requestId, signed int contentLength, signed int paddingLength);
// MakeUnknownTypeBody
// file fcgiapp.c line 1253
static struct anonymous$1 MakeUnknownTypeBody(signed int type);
// Malloc
// file fcgiapp.c line 79
static void * Malloc(unsigned long int size);
// NewParams
// file fcgiapp.c line 1023
static struct Params * NewParams(signed int length);
// NewReader
// file fcgiapp.c line 1870
static struct FCGX_Stream * NewReader(struct FCGX_Request *reqDataPtr, signed int bufflen, signed int streamType);
// NewStream
// file fcgiapp.c line 1755
static struct FCGX_Stream * NewStream(struct FCGX_Request *reqDataPtr, signed int bufflen, signed int isReader, signed int streamType);
// NewWriter
// file fcgiapp.c line 1886
static struct FCGX_Stream * NewWriter(struct FCGX_Request *reqDataPtr, signed int bufflen, signed int streamType);
// OS_Accept
// file ../include/fcgios.h line 119
signed int OS_Accept(signed int listen_sock, signed int fail_on_intr, const char *webServerAddrs);
// OS_AsyncRead
// file os_unix.c line 644
signed int OS_AsyncRead(signed int fd, signed int offset, void *buf, signed int len, void (*procPtr)(void *, signed int), void *clientData);
// OS_AsyncRead::procPtr$object
// 
void procPtr$object(void *, signed int);
// OS_AsyncReadStdin
// file os_unix.c line 585
signed int OS_AsyncReadStdin(void *buf, signed int len, void (*procPtr)(void *, signed int), void *clientData);
// OS_AsyncReadStdin::procPtr$object
// 
void procPtr$object(void *, signed int);
// OS_AsyncWrite
// file os_unix.c line 694
signed int OS_AsyncWrite(signed int fd, signed int offset, void *buf, signed int len, void (*procPtr)(void *, signed int), void *clientData);
// OS_AsyncWrite::procPtr$object
// 
void procPtr$object(void *, signed int);
// OS_BuildSockAddrUn
// file os_unix.c line 249
static signed int OS_BuildSockAddrUn(const char *bindPath, struct sockaddr_un *servAddrPtr, signed int *servAddrLen);
// OS_Close
// file os_unix.c line 736
signed int OS_Close(signed int fd);
// OS_CloseRead
// file os_unix.c line 803
signed int OS_CloseRead(signed int fd);
// OS_CreateLocalIpcFd
// file ../include/fcgios.h line 105
signed int OS_CreateLocalIpcFd(const char *bindPath, signed int backlog);
// OS_DoIo
// file os_unix.c line 830
signed int OS_DoIo(struct timeval *tmo);
// OS_DoIo::1::procPtr$object
// 
void procPtr$object(void *, signed int);
// OS_FcgiConnect
// file os_unix.c line 402
signed int OS_FcgiConnect(char *bindPath);
// OS_InstallSignalHandlers
// file os_unix.c line 137
static void OS_InstallSignalHandlers(signed int force);
// OS_IpcClose
// file ../include/fcgios.h line 120
signed int OS_IpcClose(signed int ipcFd);
// OS_IsFcgi
// file ../include/fcgios.h line 121
signed int OS_IsFcgi(signed int sock);
// OS_LibInit
// file ../include/fcgios.h line 103
signed int OS_LibInit(signed int *stdioFds);
// OS_LibShutdown
// file os_unix.c line 220
void OS_LibShutdown(void);
// OS_Read
// file ../include/fcgios.h line 107
signed int OS_Read(signed int fd, char *buf, unsigned long int len);
// OS_SetFlags
// file os_unix.c line 1292
void OS_SetFlags(signed int fd, signed int flags);
// OS_ShutdownPending
// file ../include/fcgios.h line 124
void OS_ShutdownPending(void);
// OS_SigpipeHandler
// file os_unix.c line 120
static void OS_SigpipeHandler(signed int signo);
// OS_Sigusr1Handler
// file os_unix.c line 115
static void OS_Sigusr1Handler(signed int signo);
// OS_SpawnChild
// file os_unix.c line 514
signed int OS_SpawnChild(char *appPath, signed int listenFd);
// OS_Write
// file ../include/fcgios.h line 108
signed int OS_Write(signed int fd, char *buf, unsigned long int len);
// ProcessBeginRecord
// file fcgiapp.c line 1528
static signed int ProcessBeginRecord(signed int requestId, struct FCGX_Stream *stream);
// ProcessHeader
// file fcgiapp.c line 1589
static signed int ProcessHeader(struct anonymous$13 header, struct FCGX_Stream *stream);
// ProcessManagementRecord
// file fcgiapp.c line 1454
static signed int ProcessManagementRecord(signed int type, struct FCGX_Stream *stream);
// PutParam
// file fcgiapp.c line 1076
static void PutParam(struct Params *paramsPtr, char *nameValue);
// ReadParams
// file fcgiapp.c line 1138
static signed int ReadParams(struct Params *paramsPtr, struct FCGX_Stream *stream);
// ReleaseLock
// file os_unix.c line 1040
static signed int ReleaseLock(signed int sock);
// SetError
// file fcgiapp.c line 942
static void SetError(struct FCGX_Stream *stream, signed int FCGI_errno);
// SetReaderType
// file fcgiapp.c line 1846
static struct FCGX_Stream * SetReaderType(struct FCGX_Stream *stream, signed int streamType);
// StringCopy
// file fcgiapp.c line 86
static char * StringCopy(char *str);
// WriteCloseRecords
// file fcgiapp.c line 1326
static void WriteCloseRecords(struct FCGX_Stream *stream);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// clearerr
// file /usr/include/stdio.h line 826
extern void clearerr(struct _IO_FILE *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// doit
// file threaded.c line 25
static void * doit(void *a);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgetpos
// file /usr/include/stdio.h line 798
extern signed int fgetpos(struct _IO_FILE *, struct anonymous$11 *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freopen
// file /usr/include/stdio.h line 278
extern struct _IO_FILE * freopen(const char *, const char *, struct _IO_FILE *);
// frexp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 103
extern double frexp(double, signed int *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fsetpos
// file /usr/include/stdio.h line 803
extern signed int fsetpos(struct _IO_FILE *, const struct anonymous$11 *);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// installSignalHandler
// file os_unix.c line 125
static void installSignalHandler(signed int signo, struct sigaction *act, signed int force);
// is_af_unix_keeper
// file os_unix.c line 1128
static signed int is_af_unix_keeper(const signed int fd);
// is_reasonable_accept_errno
// file os_unix.c line 1066
static signed int is_reasonable_accept_errno(const signed int error);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$24 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$24 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$0 *, struct anonymous$0 *, struct anonymous$0 *, struct timeval *);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$3 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// str_dup
// file os_unix.c line 933
static char * str_dup(const char *str);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// tmpfile
// file /usr/include/stdio.h line 195
extern struct _IO_FILE * tmpfile(void);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_it_all
// file fcgiapp.c line 1362
static signed int write_it_all(signed int fd, char *buf, signed int len);

struct anonymous$16
{
  // stdio_stream
  struct _IO_FILE *stdio_stream;
  // fcgx_stream
  struct FCGX_Stream *fcgx_stream;
};

struct anonymous
{
  // procPtr
  void (*procPtr)(void *, signed int);
  // clientData
  void *clientData;
  // fd
  signed int fd;
  // len
  signed int len;
  // offset
  signed int offset;
  // buf
  void *buf;
  // inUse
  signed int inUse;
};

struct anonymous$20
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$18
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$0
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$3
{
  // __val
  unsigned long int __val[16l];
};

union anonymous$8
{
  // __wch
  unsigned int __wch;
  // __wchb
  char __wchb[4l];
};

struct anonymous$9
{
  // __count
  signed int __count;
  // __value
  union anonymous$8 __value;
};

struct anonymous$10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$17
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$12
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$19
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$7
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$10 _kill;
  // _timer
  struct anonymous$12 _timer;
  // _rt
  struct anonymous$14 _rt;
  // _sigchld
  struct anonymous$17 _sigchld;
  // _sigfault
  struct anonymous$18 _sigfault;
  // _sigpoll
  struct anonymous$19 _sigpoll;
  // _sigsys
  struct anonymous$20 _sigsys;
};

struct anonymous$5
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$7 _sifields;
};

struct anonymous$11
{
  // __pos
  signed long int __pos;
  // __state
  struct anonymous$9 __state;
};

struct anonymous$13
{
  // version
  unsigned char version;
  // type
  unsigned char type;
  // requestIdB1
  unsigned char requestIdB1;
  // requestIdB0
  unsigned char requestIdB0;
  // contentLengthB1
  unsigned char contentLengthB1;
  // contentLengthB0
  unsigned char contentLengthB0;
  // paddingLength
  unsigned char paddingLength;
  // reserved
  unsigned char reserved;
};

struct anonymous$15
{
  // appStatusB3
  unsigned char appStatusB3;
  // appStatusB2
  unsigned char appStatusB2;
  // appStatusB1
  unsigned char appStatusB1;
  // appStatusB0
  unsigned char appStatusB0;
  // protocolStatus
  unsigned char protocolStatus;
  // reserved
  unsigned char reserved[3l];
};

struct anonymous$21
{
  // header
  struct anonymous$13 header;
  // body
  struct anonymous$15 body;
};

struct anonymous$1
{
  // type
  unsigned char type;
  // reserved
  unsigned char reserved[7l];
};

struct anonymous$22
{
  // header
  struct anonymous$13 header;
  // body
  struct anonymous$1 body;
};

struct anonymous$23
{
  // roleB1
  unsigned char roleB1;
  // roleB0
  unsigned char roleB0;
  // flags
  unsigned char flags;
  // reserved
  unsigned char reserved[5l];
};

union anonymous$6
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$5 *, void *);
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$24
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct FCGX_Request
{
  // requestId
  signed int requestId;
  // role
  signed int role;
  // in
  struct FCGX_Stream *in;
  // out
  struct FCGX_Stream *out;
  // err
  struct FCGX_Stream *err;
  // envp
  char **envp;
  // paramsPtr
  struct Params *paramsPtr;
  // ipcFd
  signed int ipcFd;
  // isBeginProcessed
  signed int isBeginProcessed;
  // keepConnection
  signed int keepConnection;
  // appStatus
  signed int appStatus;
  // nWriters
  signed int nWriters;
  // flags
  signed int flags;
  // listen_sock
  signed int listen_sock;
};

struct FCGX_Stream
{
  // rdNext
  unsigned char *rdNext;
  // wrNext
  unsigned char *wrNext;
  // stop
  unsigned char *stop;
  // stopUnget
  unsigned char *stopUnget;
  // isReader
  signed int isReader;
  // isClosed
  signed int isClosed;
  // wasFCloseCalled
  signed int wasFCloseCalled;
  // FCGI_errno
  signed int FCGI_errno;
  // fillBuffProc
  void (*fillBuffProc)(struct FCGX_Stream *);
  // emptyBuffProc
  void (*emptyBuffProc)(struct FCGX_Stream *, signed int);
  // data
  void *data;
};

struct FCGX_Stream_Data
{
  // buff
  unsigned char *buff;
  // bufflen
  signed int bufflen;
  // mBuff
  unsigned char *mBuff;
  // buffStop
  unsigned char *buffStop;
  // type
  signed int type;
  // eorStop
  signed int eorStop;
  // skip
  signed int skip;
  // contentLen
  signed int contentLen;
  // paddingLen
  signed int paddingLen;
  // isAnythingWritten
  signed int isAnythingWritten;
  // rawWrite
  signed int rawWrite;
  // reqDataPtr
  struct FCGX_Request *reqDataPtr;
};

struct Params
{
  // vec
  char **vec;
  // length
  signed int length;
  // cur
  char **cur;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

union SockAddrUnion
{
  // unixVariant
  struct sockaddr_un unixVariant;
  // inetVariant
  struct sockaddr_in inetVariant;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$6 __sigaction_handler;
  // sa_mask
  struct anonymous$3 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// _fcgi_sF
// file fcgi_stdio.c line 62
struct anonymous$16 _fcgi_sF[3l];
// acceptCalled
// file fcgi_stdio.c line 110
static signed int acceptCalled = 0;
// asyncIoInUse
// file os_unix.c line 89
static signed int asyncIoInUse = 0;
// asyncIoTable
// file os_unix.c line 91
static struct anonymous *asyncIoTable = (struct anonymous *)(void *)0;
// asyncIoTableSize
// file os_unix.c line 90
static signed int asyncIoTableSize = 16;
// counts
// file threaded.c line 23
static signed int counts[20l];
// environ
// file fcgi_stdio.c line 43
extern char **environ;
// isCGI
// file fcgi_stdio.c line 111
static signed int isCGI = 0;
// isFastCGI
// file fcgiapp.c line 70
static signed int isFastCGI = -1;
// libInitialized
// file fcgiapp.c line 69
static signed int libInitialized = 0;
// libInitialized$link1
// file os_unix.c line 93
static signed int libInitialized$link1 = 0;
// libfcgiIsAfUnixKeeperPollTimeout
// file os_unix.c line 108
static signed int libfcgiIsAfUnixKeeperPollTimeout = 2000;
// libfcgiOsClosePollTimeout
// file os_unix.c line 107
static signed int libfcgiOsClosePollTimeout = 2000;
// maxFd
// file os_unix.c line 102
static volatile signed int maxFd = -1;
// numRdPosted
// file os_unix.c line 99
static signed int numRdPosted = 0;
// numWrPosted
// file os_unix.c line 101
static signed int numWrPosted = 0;
// readFdSet
// file os_unix.c line 95
static struct anonymous$0 readFdSet;
// readFdSetPost
// file os_unix.c line 98
static struct anonymous$0 readFdSetPost;
// shutdownNow
// file os_unix.c line 105
static signed int shutdownNow = 0;
// shutdownPending
// file os_unix.c line 104
static signed int shutdownPending = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// the_request
// file fcgiapp.c line 72
static struct FCGX_Request the_request;
// webServerAddressList
// file fcgiapp.c line 71
static char *webServerAddressList = (char *)(void *)0;
// writeFdSet
// file os_unix.c line 96
static struct anonymous$0 writeFdSet;
// writeFdSetPost
// file os_unix.c line 100
static struct anonymous$0 writeFdSetPost;

// AcquireLock
// file os_unix.c line 1000
static signed int AcquireLock(signed int sock, signed int fail_on_intr)
{
  return 0;
}

// AlignInt8
// file fcgiapp.c line 1272
static signed int AlignInt8(unsigned int n)
{
  return (signed int)(n + (unsigned int)7 & ((unsigned int)0x7fffffff * 2U + 1U) - (unsigned int)7);
}

// AlignPtr8
// file fcgiapp.c line 1286
static unsigned char * AlignPtr8(unsigned char *p)
{
  unsigned long int u = (unsigned long int)p;
  u = (u + (unsigned long int)7 & ((unsigned long int)0x7fffffffffffffffL * 2UL + 1UL) - (unsigned long int)7) - u;
  return p + (signed long int)u;
}

// ClientAddrOK
// file os_unix.c line 956
static signed int ClientAddrOK(struct sockaddr_in *saPtr, const char *clientList)
{
  signed int result = 0;
  char *clientListCopy;
  char *cur;
  char *next;
  _Bool tmp_if_expr$1;
  if(clientList == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*clientList == 0 ? (_Bool)1 : (_Bool)0;
  char *tmp_post$2;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    clientListCopy=str_dup(clientList);
    cur = clientListCopy;
    for( ; !(cur == ((char *)NULL)); cur = next)
    {
      next=strchr(cur, 44);
      if(!(next == ((char *)NULL)))
      {
        tmp_post$2 = next;
        next = next + 1l;
        *tmp_post$2 = (char)0;
      }

      unsigned int return_value_inet_addr$3;
      return_value_inet_addr$3=inet_addr(cur);
      if(return_value_inet_addr$3 == saPtr->sin_addr.s_addr)
      {
        result = 1;
        break;
      }

    }
    free((void *)clientListCopy);
    return result;
  }
}

// CopyAndAdvance
// file fcgiapp.c line 858
static void CopyAndAdvance(char **destPtr, char **srcPtr, signed int n)
{
  char *dest = *destPtr;
  char *src = *srcPtr;
  signed int i = 0;
  char *tmp_post$1;
  char *tmp_post$2;
  for( ; !(i >= n); i = i + 1)
  {
    tmp_post$1 = dest;
    dest = dest + 1l;
    tmp_post$2 = src;
    src = src + 1l;
    *tmp_post$1 = *tmp_post$2;
  }
  *destPtr = dest;
  *srcPtr = src;
}

// EmptyBuffProc
// file fcgiapp.c line 1386
static void EmptyBuffProc(struct FCGX_Stream *stream, signed int doClose)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  signed int cLen;
  signed int eLen;
  if(data->rawWrite == 0)
  {
    cLen = (signed int)((unsigned long int)(stream->wrNext - data->buff) - sizeof(struct anonymous$13) /*8ul*/ );
    if(cLen >= 1)
    {
      eLen=AlignInt8((unsigned int)cLen);
      memset((void *)stream->wrNext, 0, (unsigned long int)(eLen - cLen));
      stream->wrNext = stream->wrNext + (signed long int)(eLen - cLen);
      *((struct anonymous$13 *)data->buff)=MakeHeader(data->type, data->reqDataPtr->requestId, cLen, eLen - cLen);
    }

    else
      stream->wrNext = data->buff;
  }

  if(!(doClose == 0))
    WriteCloseRecords(stream);

  if(!(stream->wrNext == data->buff))
  {
    data->isAnythingWritten = 1;
    signed int return_value_write_it_all$2;
    return_value_write_it_all$2=write_it_all(data->reqDataPtr->ipcFd, (char *)data->buff, (signed int)(stream->wrNext - data->buff));
    if(!(return_value_write_it_all$2 >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      SetError(stream, *return_value___errno_location$1);
      goto __CPROVER_DUMP_L7;
    }

    stream->wrNext = data->buff;
  }

  if(data->rawWrite == 0)
    stream->wrNext = stream->wrNext + (signed long int)sizeof(struct anonymous$13) /*8ul*/ ;


__CPROVER_DUMP_L7:
  ;
}

// FCGI_Accept
// file fcgi_stdio.c line 113
signed int FCGI_Accept(void)
{
  if(acceptCalled == 0)
  {
    isCGI=FCGX_IsCGI();
    acceptCalled = 1;
    atexit(FCGI_Finish);
  }

  else
    if(!(isCGI == 0))
      return -1;

  if(!(isCGI == 0))
  {
    (&_fcgi_sF[(signed long int)0])->stdio_stream = stdin;
    (&_fcgi_sF[(signed long int)0])->fcgx_stream = (struct FCGX_Stream *)(void *)0;
    (&_fcgi_sF[(signed long int)1])->stdio_stream = stdout;
    (&_fcgi_sF[(signed long int)1])->fcgx_stream = (struct FCGX_Stream *)(void *)0;
    (&_fcgi_sF[(signed long int)2])->stdio_stream = stderr;
    (&_fcgi_sF[(signed long int)2])->fcgx_stream = (struct FCGX_Stream *)(void *)0;
  }

  else
  {
    struct FCGX_Stream *in;
    struct FCGX_Stream *out;
    struct FCGX_Stream *error;
    char **envp;
    signed int acceptResult;
    acceptResult=FCGX_Accept(&in, &out, &error, &envp);
    if(!(acceptResult >= 0))
      return acceptResult;

    (&_fcgi_sF[(signed long int)0])->stdio_stream = (struct _IO_FILE *)(void *)0;
    (&_fcgi_sF[(signed long int)0])->fcgx_stream = in;
    (&_fcgi_sF[(signed long int)1])->stdio_stream = (struct _IO_FILE *)(void *)0;
    (&_fcgi_sF[(signed long int)1])->fcgx_stream = out;
    (&_fcgi_sF[(signed long int)2])->stdio_stream = (struct _IO_FILE *)(void *)0;
    (&_fcgi_sF[(signed long int)2])->fcgx_stream = error;
    environ = envp;
  }
  return 0;
}

// FCGI_Finish
// file fcgi_stdio.c line 180
void FCGI_Finish(void)
{
  if(!(acceptCalled == 0) && isCGI == 0)
  {
    FCGX_Finish();
    (&_fcgi_sF[(signed long int)0])->fcgx_stream = (struct FCGX_Stream *)(void *)0;
    (&_fcgi_sF[(signed long int)1])->fcgx_stream = (struct FCGX_Stream *)(void *)0;
    (&_fcgi_sF[(signed long int)2])->fcgx_stream = (struct FCGX_Stream *)(void *)0;
    environ = (char **)(void *)0;
  }

}

// FCGI_OpenFromFILE
// file fcgi_stdio.c line 270
static struct anonymous$16 * FCGI_OpenFromFILE(struct _IO_FILE *stream)
{
  struct anonymous$16 *fp;
  if(stream == ((struct _IO_FILE *)NULL))
    return (struct anonymous$16 *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$16) /*16ul*/ );
    fp = (struct anonymous$16 *)return_value_malloc$1;
    if(!(fp == ((struct anonymous$16 *)NULL)))
    {
      fp->stdio_stream = stream;
      fp->fcgx_stream = (struct FCGX_Stream *)(void *)0;
    }

    return fp;
  }
}

// FCGI_SetExitStatus
// file fcgi_stdio.c line 233
void FCGI_SetExitStatus(signed int status)
{
  if(!(_fcgi_sF[0l].fcgx_stream == ((struct FCGX_Stream *)NULL)))
    FCGX_SetExitStatus(status, (&_fcgi_sF[(signed long int)0])->fcgx_stream);

}

// FCGI_StartFilterData
// file fcgi_stdio.c line 210
signed int FCGI_StartFilterData(void)
{
  if(!(_fcgi_sF[0l].stdio_stream == ((struct _IO_FILE *)NULL)))
    return -1;

  else
  {
    signed int return_value_FCGX_StartFilterData$1;
    return_value_FCGX_StartFilterData$1=FCGX_StartFilterData((&_fcgi_sF[(signed long int)0])->fcgx_stream);
    return return_value_FCGX_StartFilterData$1;
  }
}

// FCGI_clearerr
// file fcgi_stdio.c line 716
void FCGI_clearerr(struct anonymous$16 *fp)
{
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
    clearerr(fp->stdio_stream);

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
      FCGX_ClearError(fp->fcgx_stream);

}

// FCGI_fclose
// file fcgi_stdio.c line 307
signed int FCGI_fclose(struct anonymous$16 *fp)
{
  signed int n = -1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    n=fclose(fp->stdio_stream);
    fp->stdio_stream = (struct _IO_FILE *)(void *)0;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      n=FCGX_FClose(fp->fcgx_stream);
      fp->fcgx_stream = (struct FCGX_Stream *)(void *)0;
    }

  if(!(fp == _fcgi_sF))
  {
    if(!(fp == _fcgi_sF + 1l))
    {
      if(!(fp == _fcgi_sF + 2l))
        free((void *)fp);

    }

  }

  return n;
}

// FCGI_fdopen
// file fcgi_stdio.c line 763
struct anonymous$16 * FCGI_fdopen(signed int fd, const char *mode)
{
  struct _IO_FILE *file;
  file=fdopen(fd, mode);
  struct anonymous$16 *fcgi_file;
  fcgi_file=FCGI_OpenFromFILE(file);
  if(fcgi_file == ((struct anonymous$16 *)NULL) && !(file == ((struct _IO_FILE *)NULL)))
    fclose(file);

  return fcgi_file;
}

// FCGI_feof
// file fcgi_stdio.c line 695
signed int FCGI_feof(struct anonymous$16 *fp)
{
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_feof$1;
    return_value_feof$1=feof(fp->stdio_stream);
    return return_value_feof$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      signed int return_value_FCGX_HasSeenEOF$2;
      return_value_FCGX_HasSeenEOF$2=FCGX_HasSeenEOF(fp->fcgx_stream);
      return return_value_FCGX_HasSeenEOF$2;
    }

  return -1;
}

// FCGI_ferror
// file fcgi_stdio.c line 706
signed int FCGI_ferror(struct anonymous$16 *fp)
{
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_ferror$1;
    return_value_ferror$1=ferror(fp->stdio_stream);
    return return_value_ferror$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      signed int return_value_FCGX_GetError$2;
      return_value_FCGX_GetError$2=FCGX_GetError(fp->fcgx_stream);
      return return_value_FCGX_GetError$2;
    }

  return -1;
}

// FCGI_fflush
// file fcgi_stdio.c line 323
signed int FCGI_fflush(struct anonymous$16 *fp)
{
  signed int return_value_fflush$1;
  signed int return_value_fflush$2;
  signed int return_value_FCGX_FFlush$3;
  if(fp == ((struct anonymous$16 *)NULL))
  {
    return_value_fflush$1=fflush((struct _IO_FILE *)(void *)0);
    return return_value_fflush$1;
  }

  else
  {
    if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
    {
      return_value_fflush$2=fflush(fp->stdio_stream);
      return return_value_fflush$2;
    }

    else
      if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
      {
        return_value_FCGX_FFlush$3=FCGX_FFlush(fp->fcgx_stream);
        return return_value_FCGX_FFlush$3;
      }

    return -1;
  }
}

// FCGI_fgetc
// file fcgi_stdio.c line 450
signed int FCGI_fgetc(struct anonymous$16 *fp)
{
  signed int return_value_fgetc$1;
  signed int return_value_FCGX_GetChar$2;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fgetc$1=fgetc(fp->stdio_stream);
    return return_value_fgetc$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      return_value_FCGX_GetChar$2=FCGX_GetChar(fp->fcgx_stream);
      return return_value_FCGX_GetChar$2;
    }

  return -1;
}

// FCGI_fgetpos
// file fcgi_stdio.c line 417
signed int FCGI_fgetpos(struct anonymous$16 *fp, struct anonymous$11 *pos)
{
  signed int return_value_fgetpos$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fgetpos$1=fgetpos(fp->stdio_stream, pos);
    return return_value_fgetpos$1;
  }

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 29;
    return -1;
  }
}

// FCGI_fgets
// file fcgi_stdio.c line 482
char * FCGI_fgets(char *str, signed int size, struct anonymous$16 *fp)
{
  char *return_value_fgets$1;
  char *return_value_FCGX_GetLine$2;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fgets$1=fgets(str, size, fp->stdio_stream);
    return return_value_fgets$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      return_value_FCGX_GetLine$2=FCGX_GetLine(str, size, fp->fcgx_stream);
      return return_value_FCGX_GetLine$2;
    }

  return (char *)(void *)0;
}

// FCGI_fileno
// file fcgi_stdio.c line 755
signed int FCGI_fileno(struct anonymous$16 *fp)
{
  signed int return_value_fileno$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fileno$1=fileno(fp->stdio_stream);
    return return_value_fileno$1;
  }

  else
    return -1;
}

// FCGI_fopen
// file fcgi_stdio.c line 296
struct anonymous$16 * FCGI_fopen(const char *path, const char *mode)
{
  struct _IO_FILE *file;
  file=fopen(path, mode);
  struct anonymous$16 *fcgi_file;
  fcgi_file=FCGI_OpenFromFILE(file);
  if(fcgi_file == ((struct anonymous$16 *)NULL) && !(file == ((struct _IO_FILE *)NULL)))
    fclose(file);

  return fcgi_file;
}

// FCGI_fprintf
// file fcgi_stdio.c line 597
signed int FCGI_fprintf(struct anonymous$16 *fp, const char *format, ...)
{
  void **ap;
  signed int n = 0;
  ap = (void **)&format;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
    n=vfprintf(fp->stdio_stream, format, ap);

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
      n=FCGX_VFPrintF(fp->fcgx_stream, format, ap);

  ap = ((void **)NULL);
  return n;
}

// FCGI_fputc
// file fcgi_stdio.c line 537
signed int FCGI_fputc(signed int c, struct anonymous$16 *fp)
{
  signed int return_value_fputc$1;
  signed int return_value_FCGX_PutChar$2;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fputc$1=fputc(c, fp->stdio_stream);
    return return_value_fputc$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      return_value_FCGX_PutChar$2=FCGX_PutChar(c, fp->fcgx_stream);
      return return_value_FCGX_PutChar$2;
    }

    else
      return -1;
}

// FCGI_fputs
// file fcgi_stdio.c line 560
signed int FCGI_fputs(const char *str, struct anonymous$16 *fp)
{
  signed int return_value_fputs$1;
  signed int return_value_FCGX_PutS$2;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fputs$1=fputs(str, fp->stdio_stream);
    return return_value_fputs$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      return_value_FCGX_PutS$2=FCGX_PutS(str, fp->fcgx_stream);
      return return_value_FCGX_PutS$2;
    }

  return -1;
}

// FCGI_fread
// file fcgi_stdio.c line 656
unsigned long int FCGI_fread(void *ptr, unsigned long int size, unsigned long int nmemb, struct anonymous$16 *fp)
{
  signed int n;
  unsigned long int return_value_fread$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fread$1=fread(ptr, size, nmemb, fp->stdio_stream);
    return return_value_fread$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      if(nmemb * size == 0ul)
        return (unsigned long int)0;

      n=FCGX_GetStr((char *)ptr, (signed int)(size * nmemb), fp->fcgx_stream);
      return (unsigned long int)n / size;
    }

  return (unsigned long int)-1;
}

// FCGI_freopen
// file fcgi_stdio.c line 334
struct anonymous$16 * FCGI_freopen(const char *path, const char *mode, struct anonymous$16 *fp)
{
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    struct _IO_FILE *return_value_freopen$1;
    return_value_freopen$1=freopen(path, mode, fp->stdio_stream);
    if(return_value_freopen$1 == ((struct _IO_FILE *)NULL))
      return (struct anonymous$16 *)(void *)0;

    else
      return fp;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      FCGX_FClose(fp->fcgx_stream);
      fp->stdio_stream=fopen(path, mode);
      if(fp->stdio_stream == ((struct _IO_FILE *)NULL))
        return (struct anonymous$16 *)(void *)0;

      else
      {
        fp->fcgx_stream = (struct FCGX_Stream *)(void *)0;
        return fp;
      }
    }

  return (struct anonymous$16 *)(void *)0;
}

// FCGI_fseek
// file fcgi_stdio.c line 388
signed int FCGI_fseek(struct anonymous$16 *fp, signed long int offset, signed int whence)
{
  signed int return_value_fseek$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fseek$1=fseek(fp->stdio_stream, offset, whence);
    return return_value_fseek$1;
  }

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 29;
    return -1;
  }
}

// FCGI_fsetpos
// file fcgi_stdio.c line 427
signed int FCGI_fsetpos(struct anonymous$16 *fp, const struct anonymous$11 *pos)
{
  signed int return_value_fsetpos$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fsetpos$1=fsetpos(fp->stdio_stream, pos);
    return return_value_fsetpos$1;
  }

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 29;
    return -1;
  }
}

// FCGI_ftell
// file fcgi_stdio.c line 398
signed int FCGI_ftell(struct anonymous$16 *fp)
{
  signed long int return_value_ftell$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_ftell$1=ftell(fp->stdio_stream);
    return (signed int)return_value_ftell$1;
  }

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 29;
    return -1;
  }
}

// FCGI_fwrite
// file fcgi_stdio.c line 671
unsigned long int FCGI_fwrite(void *ptr, unsigned long int size, unsigned long int nmemb, struct anonymous$16 *fp)
{
  signed int n;
  unsigned long int return_value_fwrite$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_fwrite$1=fwrite(ptr, size, nmemb, fp->stdio_stream);
    return return_value_fwrite$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      if(nmemb * size == 0ul)
        return (unsigned long int)0;

      n=FCGX_PutStr((char *)ptr, (signed int)(size * nmemb), fp->fcgx_stream);
      return (unsigned long int)n / size;
    }

  return (unsigned long int)-1;
}

// FCGI_getchar
// file fcgi_stdio.c line 459
signed int FCGI_getchar(void)
{
  signed int return_value_FCGI_fgetc$1;
  return_value_FCGI_fgetc$1=FCGI_fgetc(&_fcgi_sF[(signed long int)0]);
  return return_value_FCGI_fgetc$1;
}

// FCGI_gets
// file fcgi_stdio.c line 497
char * FCGI_gets(char *str)
{
  char *s;
  signed int c;
  s = str;
  char *tmp_post$1;
  do
  {
    c=FCGI_getchar();
    if(c == 10)
      break;

    if(c == -1)
    {
      if(s == str)
        return (char *)(void *)0;

      else
        break;
    }

    else
    {
      tmp_post$1 = s;
      s = s + 1l;
      *tmp_post$1 = (char)c;
    }
  }
  while((_Bool)1);
  *s = (char)0;
  return str;
}

// FCGI_pclose
// file fcgi_stdio.c line 785
signed int FCGI_pclose(struct anonymous$16 *fp)
{
  signed int n = -1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    n=pclose(fp->stdio_stream);
    fp->stdio_stream = (struct _IO_FILE *)(void *)0;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
      return -1;

  if(!(fp == _fcgi_sF))
  {
    if(!(fp == _fcgi_sF + 1l))
    {
      if(!(fp == _fcgi_sF + 2l))
        free((void *)fp);

    }

  }

  return n;
}

// FCGI_perror
// file fcgi_stdio.c line 249
void FCGI_perror(const char *str)
{
  FCGI_fputs(str, &_fcgi_sF[(signed long int)2]);
  FCGI_fputs(": ", &_fcgi_sF[(signed long int)2]);
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(*return_value___errno_location$1);
  FCGI_fputs(return_value_strerror$2, &_fcgi_sF[(signed long int)2]);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// FCGI_popen
// file fcgi_stdio.c line 774
struct anonymous$16 * FCGI_popen(const char *cmd, const char *type)
{
  struct _IO_FILE *file;
  file=popen(cmd, type);
  struct anonymous$16 *fcgi_file;
  fcgi_file=FCGI_OpenFromFILE(file);
  if(fcgi_file == ((struct anonymous$16 *)NULL) && !(file == ((struct _IO_FILE *)NULL)))
    pclose(file);

  return fcgi_file;
}

// FCGI_printf
// file fcgi_stdio.c line 610
signed int FCGI_printf(const char *format, ...)
{
  void **ap;
  signed int n;
  ap = (void **)&format;
  n=FCGI_vfprintf(&_fcgi_sF[(signed long int)1], format, ap);
  ap = ((void **)NULL);
  return n;
}

// FCGI_putchar
// file fcgi_stdio.c line 546
signed int FCGI_putchar(signed int c)
{
  signed int return_value_FCGI_fputc$1;
  return_value_FCGI_fputc$1=FCGI_fputc(c, &_fcgi_sF[(signed long int)1]);
  return return_value_FCGI_fputc$1;
}

// FCGI_puts
// file fcgi_stdio.c line 569
signed int FCGI_puts(const char *str)
{
  signed int n;
  signed int return_value_fputc$1;
  signed int return_value_FCGX_PutChar$2;
  if(!(_fcgi_sF[1l].stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    n=fputs(str, (&_fcgi_sF[(signed long int)1])->stdio_stream);
    if(!(n >= 0))
      return n;

    else
    {
      return_value_fputc$1=fputc(10, (&_fcgi_sF[(signed long int)1])->stdio_stream);
      return return_value_fputc$1;
    }
  }

  else
    if(!(_fcgi_sF[1l].fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      n=FCGX_PutS(str, (&_fcgi_sF[(signed long int)1])->fcgx_stream);
      if(!(n >= 0))
        return n;

      else
      {
        return_value_FCGX_PutChar$2=FCGX_PutChar(10, (&_fcgi_sF[(signed long int)1])->fcgx_stream);
        return return_value_FCGX_PutChar$2;
      }
    }

  return -1;
}

// FCGI_rewind
// file fcgi_stdio.c line 408
void FCGI_rewind(struct anonymous$16 *fp)
{
  signed int *return_value___errno_location$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
    rewind(fp->stdio_stream);

  else
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 29;
  }
}

// FCGI_setbuf
// file fcgi_stdio.c line 373
void FCGI_setbuf(struct anonymous$16 *fp, char *buf)
{
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
    setbuf(fp->stdio_stream, buf);

}

// FCGI_setvbuf
// file fcgi_stdio.c line 364
signed int FCGI_setvbuf(struct anonymous$16 *fp, char *buf, signed int bufmode, unsigned long int size)
{
  signed int return_value_setvbuf$1;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_setvbuf$1=setvbuf(fp->stdio_stream, buf, bufmode, size);
    return return_value_setvbuf$1;
  }

  else
    return -1;
}

// FCGI_tmpfile
// file fcgi_stdio.c line 735
struct anonymous$16 * FCGI_tmpfile(void)
{
  struct _IO_FILE *file;
  file=tmpfile();
  struct anonymous$16 *fcgi_file;
  fcgi_file=FCGI_OpenFromFILE(file);
  if(fcgi_file == ((struct anonymous$16 *)NULL) && !(file == ((struct _IO_FILE *)NULL)))
    fclose(file);

  return fcgi_file;
}

// FCGI_ungetc
// file fcgi_stdio.c line 464
signed int FCGI_ungetc(signed int c, struct anonymous$16 *fp)
{
  signed int return_value_ungetc$1;
  signed int return_value_FCGX_UnGetChar$2;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_ungetc$1=ungetc(c, fp->stdio_stream);
    return return_value_ungetc$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      return_value_FCGX_UnGetChar$2=FCGX_UnGetChar(c, fp->fcgx_stream);
      return return_value_FCGX_UnGetChar$2;
    }

  return -1;
}

// FCGI_vfprintf
// file fcgi_stdio.c line 629
signed int FCGI_vfprintf(struct anonymous$16 *fp, const char *format, void **ap)
{
  signed int return_value_vfprintf$1;
  signed int return_value_FCGX_VFPrintF$2;
  if(!(fp->stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_vfprintf$1=vfprintf(fp->stdio_stream, format, ap);
    return return_value_vfprintf$1;
  }

  else
    if(!(fp->fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      return_value_FCGX_VFPrintF$2=FCGX_VFPrintF(fp->fcgx_stream, format, ap);
      return return_value_FCGX_VFPrintF$2;
    }

  return -1;
}

// FCGI_vprintf
// file fcgi_stdio.c line 638
signed int FCGI_vprintf(const char *format, void **ap)
{
  signed int return_value_vfprintf$1;
  signed int return_value_FCGX_VFPrintF$2;
  if(!(_fcgi_sF[1l].stdio_stream == ((struct _IO_FILE *)NULL)))
  {
    return_value_vfprintf$1=vfprintf((&_fcgi_sF[(signed long int)1])->stdio_stream, format, ap);
    return return_value_vfprintf$1;
  }

  else
    if(!(_fcgi_sF[1l].fcgx_stream == ((struct FCGX_Stream *)NULL)))
    {
      return_value_FCGX_VFPrintF$2=FCGX_VFPrintF((&_fcgi_sF[(signed long int)1])->fcgx_stream, format, ap);
      return return_value_FCGX_VFPrintF$2;
    }

  return -1;
}

// FCGX_Accept
// file fcgiapp.c line 2127
signed int FCGX_Accept(struct FCGX_Stream **in, struct FCGX_Stream **out, struct FCGX_Stream **err, char ***envp)
{
  signed int rc;
  if(libInitialized == 0)
  {
    rc=FCGX_Init();
    if(rc == 0)
      goto __CPROVER_DUMP_L1;

    return rc;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    rc=FCGX_Accept_r(&the_request);
    *in = the_request.in;
    *out = the_request.out;
    *err = the_request.err;
    *envp = the_request.envp;
    return rc;
  }
}

// FCGX_Accept_r
// file ../include/fcgiapp.h line 207
signed int FCGX_Accept_r(struct FCGX_Request *reqDataPtr)
{
  signed int tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  signed int return_value_ReadParams$5;
  if(libInitialized == 0)
    return -9998;

  else
  {
    FCGX_Finish_r(reqDataPtr);
    while((_Bool)1)
    {
      if(!(reqDataPtr->ipcFd >= 0))
      {
        signed int fail_on_intr = reqDataPtr->flags & 1;
        reqDataPtr->ipcFd=OS_Accept(reqDataPtr->listen_sock, fail_on_intr, webServerAddressList);
        if(!(reqDataPtr->ipcFd >= 0))
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          if(*return_value___errno_location$1 >= 1)
          {
            return_value___errno_location$2=__errno_location();
            tmp_if_expr$3 = 0 - *return_value___errno_location$2;
          }

          else
            tmp_if_expr$3 = -9999;
          return tmp_if_expr$3;
        }

      }

      reqDataPtr->isBeginProcessed = 0;
      reqDataPtr->in=NewReader(reqDataPtr, 8192, 0);
      FillBuffProc(reqDataPtr->in);
      if(!(reqDataPtr->isBeginProcessed == 0))
      {
        char *roleStr;
        switch(reqDataPtr->role)
        {
          case 1:
          {
            roleStr = "FCGI_ROLE=RESPONDER";
            break;
          }
          case 2:
          {
            roleStr = "FCGI_ROLE=AUTHORIZER";
            break;
          }
          case 3:
          {
            roleStr = "FCGI_ROLE=FILTER";
            break;
          }
          default:
            goto TryAgain;
        }
        reqDataPtr->paramsPtr=NewParams(30);
        char *return_value_StringCopy$4;
        return_value_StringCopy$4=StringCopy(roleStr);
        PutParam(reqDataPtr->paramsPtr, return_value_StringCopy$4);
        SetReaderType(reqDataPtr->in, 4);
        return_value_ReadParams$5=ReadParams(reqDataPtr->paramsPtr, reqDataPtr->in);
        if(return_value_ReadParams$5 >= 0)
          break;

      }


    TryAgain:
      ;
      FCGX_Free(reqDataPtr, 1);
    }
    SetReaderType(reqDataPtr->in, 5);
    reqDataPtr->out=NewWriter(reqDataPtr, 8192, 6);
    reqDataPtr->err=NewWriter(reqDataPtr, 512, 7);
    reqDataPtr->nWriters = 2;
    reqDataPtr->envp = reqDataPtr->paramsPtr->vec;
    return 0;
  }
}

// FCGX_ClearError
// file fcgiapp.c line 977
void FCGX_ClearError(struct FCGX_Stream *stream)
{
  stream->FCGI_errno = 0;
}

// FCGX_CreateWriter
// file fcgiapp.c line 1903
struct FCGX_Stream * FCGX_CreateWriter(signed int ipcFd, signed int requestId, signed int bufflen, signed int streamType)
{
  struct FCGX_Request *reqDataPtr;
  void *return_value_Malloc$1;
  return_value_Malloc$1=Malloc(sizeof(struct FCGX_Request) /*80ul*/ );
  reqDataPtr = (struct FCGX_Request *)return_value_Malloc$1;
  reqDataPtr->ipcFd = ipcFd;
  reqDataPtr->requestId = requestId;
  reqDataPtr->nWriters = 2;
  struct FCGX_Stream *return_value_NewWriter$2;
  return_value_NewWriter$2=NewWriter(reqDataPtr, bufflen, streamType);
  return return_value_NewWriter$2;
}

// FCGX_FClose
// file fcgiapp.c line 912
signed int FCGX_FClose(struct FCGX_Stream *stream)
{
  if(stream == ((struct FCGX_Stream *)NULL))
    return 0;

  else
  {
    if(stream->wasFCloseCalled == 0)
    {
      if(stream->isReader == 0)
        stream->emptyBuffProc(stream, 1);

      stream->wasFCloseCalled = 1;
      stream->isClosed = 1;
      if(!(stream->isReader == 0))
      {
        stream->stop = stream->rdNext;
        stream->wrNext = stream->stop;
      }

      else
      {
        stream->stop = stream->wrNext;
        stream->rdNext = stream->stop;
      }
    }

    return stream->FCGI_errno == 0 ? 0 : -1;
  }
}

// FCGX_FFlush
// file fcgiapp.c line 887
signed int FCGX_FFlush(struct FCGX_Stream *stream)
{
  _Bool tmp_if_expr$1;
  if(!(stream->isClosed == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = stream->isReader != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    stream->emptyBuffProc(stream, 0);
    return stream->isClosed != 0 ? -1 : 0;
  }
}

// FCGX_FPrintF
// file ../include/fcgiapp.h line 510
signed int FCGX_FPrintF(struct FCGX_Stream *stream, const char *format, ...)
{
  signed int result;
  void **ap = (void **)&format;
  result=FCGX_VFPrintF(stream, format, ap);
  ap = ((void **)NULL);
  return result;
}

// FCGX_Finish
// file fcgiapp.c line 1979
void FCGX_Finish(void)
{
  FCGX_Finish_r(&the_request);
}

// FCGX_Finish_r
// file ../include/fcgiapp.h line 228
void FCGX_Finish_r(struct FCGX_Request *reqDataPtr)
{
  signed int FCGX_Finish_r$$1$$close;
  if(!(reqDataPtr == ((struct FCGX_Request *)NULL)))
  {
    FCGX_Finish_r$$1$$close = (signed int)!(reqDataPtr->keepConnection != 0);
    if(!(reqDataPtr->in == ((struct FCGX_Stream *)NULL)))
    {
      signed int return_value_FCGX_FClose$1;
      return_value_FCGX_FClose$1=FCGX_FClose(reqDataPtr->err);
      FCGX_Finish_r$$1$$close = FCGX_Finish_r$$1$$close | return_value_FCGX_FClose$1;
      signed int return_value_FCGX_FClose$2;
      return_value_FCGX_FClose$2=FCGX_FClose(reqDataPtr->out);
      FCGX_Finish_r$$1$$close = FCGX_Finish_r$$1$$close | return_value_FCGX_FClose$2;
      signed int return_value_FCGX_GetError$3;
      return_value_FCGX_GetError$3=FCGX_GetError(reqDataPtr->in);
      FCGX_Finish_r$$1$$close = FCGX_Finish_r$$1$$close | return_value_FCGX_GetError$3;
    }

    FCGX_Free(reqDataPtr, FCGX_Finish_r$$1$$close);
  }

}

// FCGX_Free
// file fcgiapp.c line 2024
void FCGX_Free(struct FCGX_Request *request, signed int close)
{
  if(!(request == ((struct FCGX_Request *)NULL)))
  {
    FCGX_FreeStream(&request->in);
    FCGX_FreeStream(&request->out);
    FCGX_FreeStream(&request->err);
    FreeParams(&request->paramsPtr);
    if(!(close == 0))
    {
      OS_IpcClose(request->ipcFd);
      request->ipcFd = -1;
    }

  }

}

// FCGX_FreeStream
// file fcgiapp.c line 1822
void FCGX_FreeStream(struct FCGX_Stream **streamPtr)
{
  struct FCGX_Stream *stream = *streamPtr;
  struct FCGX_Stream_Data *data;
  if(!(stream == ((struct FCGX_Stream *)NULL)))
  {
    data = (struct FCGX_Stream_Data *)stream->data;
    data->reqDataPtr = (struct FCGX_Request *)(void *)0;
    free((void *)data->mBuff);
    free((void *)data);
    free((void *)stream);
    *streamPtr = (struct FCGX_Stream *)(void *)0;
  }

}

// FCGX_GetChar
// file fcgiapp.c line 108
signed int FCGX_GetChar(struct FCGX_Stream *stream)
{
  _Bool tmp_if_expr$1;
  if(!(stream->isClosed == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(stream->isReader != 0) ? (_Bool)1 : (_Bool)0;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  if(tmp_if_expr$1)
    return -1;

  else
    if(!(stream->rdNext == stream->stop))
    {
      tmp_post$2 = stream->rdNext;
      stream->rdNext = stream->rdNext + 1l;
      return (signed int)*tmp_post$2;
    }

    else
    {
      stream->fillBuffProc(stream);
      if(!(stream->isClosed == 0))
        return -1;

      else
      {
        stream->stopUnget = stream->rdNext;
        if(!(stream->rdNext == stream->stop))
        {
          tmp_post$3 = stream->rdNext;
          stream->rdNext = stream->rdNext + 1l;
          return (signed int)*tmp_post$3;
        }

        else
        {
          /* assertion stream->isClosed */
          assert(stream->isClosed != 0);
          return -1;
        }
      }
    }
}

// FCGX_GetError
// file fcgiapp.c line 964
signed int FCGX_GetError(struct FCGX_Stream *stream)
{
  return stream->FCGI_errno;
}

// FCGX_GetLine
// file fcgiapp.c line 200
char * FCGX_GetLine(char *str, signed int n, struct FCGX_Stream *stream)
{
  signed int c;
  char *p = str;
  n = n - 1;
  char *tmp_post$1;
  while(n >= 1)
  {
    c=FCGX_GetChar(stream);
    if(c == -1)
    {
      if(p == str)
        return (char *)(void *)0;

      else
        break;
    }

    tmp_post$1 = p;
    p = p + 1l;
    *tmp_post$1 = (char)c;
    n = n - 1;
    if(c == 10)
      break;

  }
  *p = (char)0;
  return str;
}

// FCGX_GetParam
// file ../include/fcgiapp.h line 349
char * FCGX_GetParam(const char *name, char **envp)
{
  signed int len;
  char **p;
  if(envp == ((char **)NULL) || name == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(name);
    len = (signed int)return_value_strlen$1;
    p = envp;
    for( ; !(*p == ((char *)NULL)); p = p + 1l)
    {
      signed int return_value_strncmp$2;
      return_value_strncmp$2=strncmp(name, *p, (unsigned long int)len);
      if(return_value_strncmp$2 == 0)
      {
        if((signed int)(*p)[(signed long int)len] == 61)
          return *p + (signed long int)len + (signed long int)1;

      }

    }
    return (char *)(void *)0;
  }
}

// FCGX_GetStr
// file fcgiapp.c line 143
signed int FCGX_GetStr(char *str, signed int n, struct FCGX_Stream *stream)
{
  signed int m;
  signed int bytesMoved;
  _Bool tmp_if_expr$1;
  if(!(stream->isClosed == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(stream->isReader != 0) ? (_Bool)1 : (_Bool)0;
  signed long int tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!(n >= 1) || tmp_if_expr$1)
    return 0;

  else
    if(stream->stop - stream->rdNext >= (signed long int)n)
    {
      memcpy((void *)str, (const void *)stream->rdNext, (unsigned long int)n);
      stream->rdNext = stream->rdNext + (signed long int)n;
      return n;
    }

    else
    {
      bytesMoved = 0;
      if(!(stream->rdNext == stream->stop))
      {
        if(!((signed long int)(n + -bytesMoved) >= stream->stop - stream->rdNext))
          tmp_if_expr$2 = (signed long int)(n - bytesMoved);

        else
          tmp_if_expr$2 = stream->stop - stream->rdNext;
        m = (signed int)tmp_if_expr$2;
        memcpy((void *)str, (const void *)stream->rdNext, (unsigned long int)m);
        bytesMoved = bytesMoved + m;
        stream->rdNext = stream->rdNext + (signed long int)m;
        if(bytesMoved == n)
          return bytesMoved;

        str = str + (signed long int)m;
      }

      if(!(stream->isClosed == 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = !(stream->isReader != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        return bytesMoved;

      else
      {
        stream->fillBuffProc(stream);
        if(!(stream->isClosed == 0))
          return bytesMoved;

        else
          stream->stopUnget = stream->rdNext;
      }
    }
}

// FCGX_HasSeenEOF
// file fcgiapp.c line 266
signed int FCGX_HasSeenEOF(struct FCGX_Stream *stream)
{
  return stream->isClosed != 0 ? -1 : 0;
}

// FCGX_Init
// file ../include/fcgiapp.h line 142
signed int FCGX_Init(void)
{
  char *p;
  signed int tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  char *tmp_if_expr$6;
  char *return_value_StringCopy$5;
  if(!(libInitialized == 0))
    return 0;

  else
  {
    FCGX_InitRequest(&the_request, 0, 0);
    signed int return_value_OS_LibInit$4;
    return_value_OS_LibInit$4=OS_LibInit((signed int *)(void *)0);
    if(return_value_OS_LibInit$4 == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 0))
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2;
      }

      else
        tmp_if_expr$3 = -9997;
      return tmp_if_expr$3;
    }

    p=getenv("FCGI_WEB_SERVER_ADDRS");
    if(!(p == ((char *)NULL)))
    {
      return_value_StringCopy$5=StringCopy(p);
      tmp_if_expr$6 = return_value_StringCopy$5;
    }

    else
      tmp_if_expr$6 = (char *)(void *)0;
    webServerAddressList = tmp_if_expr$6;
    libInitialized = 1;
    return 0;
  }
}

// FCGX_InitRequest
// file ../include/fcgiapp.h line 175
signed int FCGX_InitRequest(struct FCGX_Request *request, signed int sock, signed int flags)
{
  memset((void *)request, 0, sizeof(struct FCGX_Request) /*80ul*/ );
  request->listen_sock = sock;
  request->flags = flags;
  request->ipcFd = -1;
  return 0;
}

// FCGX_IsCGI
// file fcgiapp.c line 1940
signed int FCGX_IsCGI(void)
{
  if(!(isFastCGI == -1))
    return (signed int)!(isFastCGI != 0);

  else
  {
    if(libInitialized == 0)
    {
      signed int rc;
      rc=FCGX_Init();
      if(!(rc == 0))
        exit(rc < 0 ? rc : -rc);

    }

    isFastCGI=OS_IsFcgi(0);
    return (signed int)!(isFastCGI != 0);
  }
}

// FCGX_OpenSocket
// file fcgiapp.c line 2040
signed int FCGX_OpenSocket(const char *path, signed int backlog)
{
  signed int rc;
  rc=OS_CreateLocalIpcFd(path, backlog);
  if(rc == 0 && isFastCGI == 0)
    isFastCGI = 1;

  return rc;
}

// FCGX_PutChar
// file fcgiapp.c line 282
signed int FCGX_PutChar(signed int c, struct FCGX_Stream *stream)
{
  unsigned char *tmp_post$1;
  _Bool tmp_if_expr$2;
  unsigned char *tmp_post$3;
  if(!(stream->wrNext == stream->stop))
  {
    tmp_post$1 = stream->wrNext;
    stream->wrNext = stream->wrNext + 1l;
    *tmp_post$1 = (unsigned char)c;
    return (signed int)*tmp_post$1;
  }

  else
  {
    if(!(stream->isClosed == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = stream->isReader != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return -1;

    else
    {
      stream->emptyBuffProc(stream, 0);
      if(!(stream->wrNext == stream->stop))
      {
        tmp_post$3 = stream->wrNext;
        stream->wrNext = stream->wrNext + 1l;
        *tmp_post$3 = (unsigned char)c;
        return (signed int)*tmp_post$3;
      }

      else
      {
        /* assertion stream->isClosed */
        assert(stream->isClosed != 0);
        return -1;
      }
    }
  }
}

// FCGX_PutS
// file fcgiapp.c line 356
signed int FCGX_PutS(const char *str, struct FCGX_Stream *stream)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  signed int return_value_FCGX_PutStr$2;
  return_value_FCGX_PutStr$2=FCGX_PutStr(str, (signed int)return_value_strlen$1, stream);
  return return_value_FCGX_PutStr$2;
}

// FCGX_PutStr
// file fcgiapp.c line 310
signed int FCGX_PutStr(const char *str, signed int n, struct FCGX_Stream *stream)
{
  signed int m;
  signed int bytesMoved;
  signed long int tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(stream->stop - stream->wrNext >= (signed long int)n)
  {
    memcpy((void *)stream->wrNext, (const void *)str, (unsigned long int)n);
    stream->wrNext = stream->wrNext + (signed long int)n;
    return n;
  }

  else
  {
    bytesMoved = 0;
    if(!(stream->wrNext == stream->stop))
    {
      if(!((signed long int)(n + -bytesMoved) >= stream->stop - stream->wrNext))
        tmp_if_expr$1 = (signed long int)(n - bytesMoved);

      else
        tmp_if_expr$1 = stream->stop - stream->wrNext;
      m = (signed int)tmp_if_expr$1;
      memcpy((void *)stream->wrNext, (const void *)str, (unsigned long int)m);
      bytesMoved = bytesMoved + m;
      stream->wrNext = stream->wrNext + (signed long int)m;
      if(bytesMoved == n)
        return bytesMoved;

      str = str + (signed long int)m;
    }

    if(!(stream->isClosed == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = stream->isReader != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return -1;

    else
      stream->emptyBuffProc(stream, 0);
  }
}

// FCGX_SetExitStatus
// file fcgiapp.c line 2305
void FCGX_SetExitStatus(signed int status, struct FCGX_Stream *stream)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  data->reqDataPtr->appStatus = status;
}

// FCGX_ShutdownPending
// file fcgiapp.c line 74
void FCGX_ShutdownPending(void)
{
  OS_ShutdownPending();
}

// FCGX_StartFilterData
// file fcgiapp.c line 2277
signed int FCGX_StartFilterData(struct FCGX_Stream *stream)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  _Bool tmp_if_expr$1;
  if(!(data->reqDataPtr->role == 3))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(stream->isReader != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(stream->isClosed != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = data->type != 5 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    SetError(stream, -5);
    return -1;
  }

  else
  {
    SetReaderType(stream, 8);
    return 0;
  }
}

// FCGX_UnGetChar
// file fcgiapp.c line 237
signed int FCGX_UnGetChar(signed int c, struct FCGX_Stream *stream)
{
  _Bool tmp_if_expr$1;
  if(c == -1)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = stream->isClosed != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(stream->isReader != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = stream->rdNext == stream->stopUnget ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    return -1;

  else
  {
    stream->rdNext = stream->rdNext - 1l;
    *stream->rdNext = (unsigned char)c;
    return c;
  }
}

// FCGX_VFPrintF
// file fcgiapp.c line 411
signed int FCGX_VFPrintF(struct FCGX_Stream *stream, const char *format, __builtin_va_list arg)
{
  char *f;
  char *fStop;
  char *percentPtr;
  char *p;
  char *fmtBuffPtr;
  char *buffPtr;
  signed int op;
  signed int performedOp;
  signed int sizeModifier;
  signed int buffCount = 0;
  signed int buffLen;
  signed int specifierLength;
  signed int fastPath;
  signed int n;
  signed int auxBuffLen = 0;
  signed int buffReqd;
  signed int minWidth;
  signed int precision;
  signed int exp;
  char *auxBuffPtr = (char *)(void *)0;
  signed int streamCount = 0;
  char fmtBuff[25l];
  char buff[100l];
  signed int intArg;
  signed short int shortArg;
  signed long int longArg;
  unsigned int unsignedArg;
  unsigned long int uLongArg;
  unsigned short int uShortArg;
  char *charPtrArg = (char *)(void *)0;
  void *voidPtrArg;
  signed int *intPtrArg;
  signed long int *longPtrArg;
  signed short int *shortPtrArg;
  double doubleArg = 0.0;
  long double lDoubleArg = 0.0L;
  fmtBuff[(signed long int)0] = (char)37;
  f = (char *)format;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(f);
  fStop = f + (signed long int)return_value_strlen$1;
  unsigned long int return_value_strlen$15;
  unsigned long int return_value_strlen$16;
  signed int return_value_gcc_builtin_va_arg$17;
  unsigned long int return_value_strlen$18;
  unsigned long int return_value_strlen$19;
  unsigned long int return_value_strlen$20;
  signed int return_value_gcc_builtin_va_arg$21;
  unsigned long int return_value_strlen$22;
  unsigned long int return_value_strlen$23;
  unsigned long int return_value_strlen$26;
  signed short int *return_value_gcc_builtin_va_arg$27;
  unsigned long int return_value_strlen$28;
  unsigned long int return_value_strlen$29;
  unsigned long int return_value_strlen$30;
  unsigned long int return_value_strlen$31;
  while(!(f == fStop))
  {
    void *return_value_memchr$2;
    return_value_memchr$2=memchr((const void *)f, 37, (unsigned long int)(fStop - f));
    percentPtr = (char *)return_value_memchr$2;
    if(percentPtr == ((char *)NULL))
      percentPtr = fStop;

    if(!(percentPtr == f))
    {
      signed int return_value_FCGX_PutStr$3;
      return_value_FCGX_PutStr$3=FCGX_PutStr(f, (signed int)(percentPtr - f), stream);
      if(!(return_value_FCGX_PutStr$3 >= 0))
        goto ErrorReturn;

      streamCount = streamCount + (signed int)(percentPtr - f);
      f = percentPtr;
      if(f == fStop)
        break;

    }

    fastPath = 1;
    for( ; (_Bool)1; fastPath = 0)
    {
      if(!(fastPath == 0))
      {
        op = (signed int)percentPtr[(signed long int)1];
        if(op == 76 || op == 104 || op == 108)
        {
          sizeModifier = op;
          op = (signed int)percentPtr[(signed long int)2];
          fmtBuff[(signed long int)1] = (char)sizeModifier;
          fmtBuff[(signed long int)2] = (char)op;
          fmtBuff[(signed long int)3] = (char)0;
          specifierLength = 3;
          goto __CPROVER_DUMP_L8;
        }

        sizeModifier = 32;
        fmtBuff[(signed long int)1] = (char)op;
        fmtBuff[(signed long int)2] = (char)0;
        specifierLength = 2;

      __CPROVER_DUMP_L8:
        ;
        buffPtr = buff;
        buffLen = 100;
      }

      else
      {
        p = percentPtr + (signed long int)1;
        fmtBuffPtr = &fmtBuff[(signed long int)1];
        unsigned long int return_value_strspn$4;
        return_value_strspn$4=strspn(p, "-0+ #");
        n = (signed int)return_value_strspn$4;
        if(n >= 6)
          goto ErrorReturn;

        CopyAndAdvance(&fmtBuffPtr, &p, n);
        unsigned long int return_value_strspn$5;
        return_value_strspn$5=strspn(p, "0123456789");
        n = (signed int)return_value_strspn$5;
        if(n == 0)
        {
          if((signed int)*p == 42)
          {
            minWidth=va_arg(arg, __typeof__(minWidth));
            signed int return_value_abs$6;
            return_value_abs$6=abs(minWidth);
            if(return_value_abs$6 >= 1000000)
              goto ErrorReturn;

            sprintf(fmtBuffPtr, "%d", minWidth);
            unsigned long int return_value_strlen$7;
            return_value_strlen$7=strlen(fmtBuffPtr);
            fmtBuffPtr = fmtBuffPtr + (signed long int)return_value_strlen$7;
            p = p + 1l;
          }

          else
            minWidth = 0;
        }

        else
          if(!(n >= 7))
          {
            signed long int return_value_strtol$8;
            return_value_strtol$8=strtol(p, (char ** restrict )(void *)0, 10);
            minWidth = (signed int)return_value_strtol$8;
            CopyAndAdvance(&fmtBuffPtr, &p, n);
          }

          else
            goto ErrorReturn;
        if((signed int)*p == 46)
        {
          CopyAndAdvance(&fmtBuffPtr, &p, 1);
          unsigned long int return_value_strspn$9;
          return_value_strspn$9=strspn(p, "0123456789");
          n = (signed int)return_value_strspn$9;
          if(n == 0)
          {
            if((signed int)*p == 42)
            {
              precision=va_arg(arg, __typeof__(precision));
              if(!(precision >= 0))
                precision = 0;

              if(precision >= 1000000)
                goto ErrorReturn;

              sprintf(fmtBuffPtr, "%d", precision);
              unsigned long int return_value_strlen$10;
              return_value_strlen$10=strlen(fmtBuffPtr);
              fmtBuffPtr = fmtBuffPtr + (signed long int)return_value_strlen$10;
              p = p + 1l;
            }

            else
              precision = 0;
          }

          else
            if(!(n >= 7))
            {
              signed long int return_value_strtol$11;
              return_value_strtol$11=strtol(p, (char ** restrict )(void *)0, 10);
              precision = (signed int)return_value_strtol$11;
              CopyAndAdvance(&fmtBuffPtr, &p, n);
            }

            else
              goto ErrorReturn;
        }

        else
          precision = -1;
        if((signed int)*p == 76 || (signed int)*p == 104 || (signed int)*p == 108)
        {
          sizeModifier = (signed int)*p;
          CopyAndAdvance(&fmtBuffPtr, &p, 1);
          goto __CPROVER_DUMP_L25;
        }

        sizeModifier = 32;

      __CPROVER_DUMP_L25:
        ;
        op = (signed int)*p;
        CopyAndAdvance(&fmtBuffPtr, &p, 1);
        /* assertion fmtBuffPtr - fmtBuff < 25 */
        assert(fmtBuffPtr - fmtBuff < (signed long int)25);
        *fmtBuffPtr = (char)0;
        specifierLength = (signed int)(p - percentPtr);
        switch(op)
        {
          case 100:

          case 105:

          case 117:

          case 111:

          case 120:

          case 88:

          case 99:

          case 112:
          {
            buffReqd = precision > 46 ? precision : 46;
            break;
          }
          case 115:
          {
            charPtrArg=va_arg(arg, __typeof__(charPtrArg));
            if(charPtrArg == ((char *)NULL))
              charPtrArg = "(null)";

            if(precision == -1)
            {
              unsigned long int return_value_strlen$12;
              return_value_strlen$12=strlen(charPtrArg);
              buffReqd = (signed int)return_value_strlen$12;
            }

            else
            {
              void *return_value_memchr$13;
              return_value_memchr$13=memchr((const void *)charPtrArg, 0, (unsigned long int)precision);
              p = (char *)return_value_memchr$13;
              buffReqd = (signed int)(p == (char *)(void *)0 ? (signed long int)precision : p - charPtrArg);
            }
            break;
          }
          case 102:
          {
            switch(sizeModifier)
            {
              case 32:
              {
                doubleArg=va_arg(arg, __typeof__(doubleArg));
                frexp(doubleArg, &exp);
                break;
              }
              case 76:
              {
                lDoubleArg=va_arg(arg, __typeof__(lDoubleArg));
                frexp((double)lDoubleArg, &exp);
                break;
              }
              default:
                goto ErrorReturn;
            }
            if(precision == -1)
              precision = 6;

            buffReqd = precision + 3 + (exp > 0 ? exp / 3 : 0);
            break;
          }
          case 101:

          case 69:

          case 103:

          case 71:
          {
            if(precision == -1)
              precision = 6;

            buffReqd = precision + 8;
            break;
          }
          case 110:

          case 37:

          default:
            goto ErrorReturn;
        }
        buffReqd = buffReqd + 10 > minWidth ? buffReqd + 10 : minWidth;
        if(!(buffReqd >= 101))
        {
          buffPtr = buff;
          buffLen = 100;
        }

        else
        {
          if(auxBuffPtr == ((char *)NULL) || !(auxBuffLen >= buffReqd))
          {
            if(!(auxBuffPtr == ((char *)NULL)))
              free((void *)auxBuffPtr);

            void *return_value_Malloc$14;
            return_value_Malloc$14=Malloc((unsigned long int)buffReqd);
            auxBuffPtr = (char *)return_value_Malloc$14;
            auxBuffLen = buffReqd;
            if(auxBuffPtr == ((char *)NULL))
              goto ErrorReturn;

          }

          buffPtr = auxBuffPtr;
          buffLen = auxBuffLen;
        }
      }
      performedOp = 1;
      switch(op)
      {
        case 100:

        case 105:
        {
          switch(sizeModifier)
          {
            case 32:
            {
              intArg=va_arg(arg, __typeof__(intArg));
              sprintf(buffPtr, fmtBuff, intArg);
              return_value_strlen$15=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$15;
              break;
            }
            case 108:
            {
              longArg=va_arg(arg, __typeof__(longArg));
              sprintf(buffPtr, fmtBuff, longArg);
              return_value_strlen$16=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$16;
              break;
            }
            case 104:
            {
              return_value_gcc_builtin_va_arg$17=va_arg(arg, __typeof__(return_value_gcc_builtin_va_arg$17));
              shortArg = (signed short int)return_value_gcc_builtin_va_arg$17;
              sprintf(buffPtr, fmtBuff, shortArg);
              return_value_strlen$18=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$18;
              break;
            }
            default:
              goto ErrorReturn;
          }
          break;
        }
        case 117:

        case 111:

        case 120:

        case 88:
        {
          switch(sizeModifier)
          {
            case 32:
            {
              unsignedArg=va_arg(arg, __typeof__(unsignedArg));
              sprintf(buffPtr, fmtBuff, unsignedArg);
              return_value_strlen$19=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$19;
              break;
            }
            case 108:
            {
              uLongArg=va_arg(arg, __typeof__(uLongArg));
              sprintf(buffPtr, fmtBuff, uLongArg);
              return_value_strlen$20=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$20;
              break;
            }
            case 104:
            {
              return_value_gcc_builtin_va_arg$21=va_arg(arg, __typeof__(return_value_gcc_builtin_va_arg$21));
              uShortArg = (unsigned short int)return_value_gcc_builtin_va_arg$21;
              sprintf(buffPtr, fmtBuff, uShortArg);
              return_value_strlen$22=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$22;
              break;
            }
            default:
              goto ErrorReturn;
          }
          break;
        }
        case 99:
        {
          switch(sizeModifier)
          {
            case 32:
            {
              intArg=va_arg(arg, __typeof__(intArg));
              sprintf(buffPtr, fmtBuff, intArg);
              return_value_strlen$23=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$23;
              break;
            }
            case 108:
              goto ErrorReturn;
            default:
              goto ErrorReturn;
          }
          break;
        }
        case 115:
        {
          switch(sizeModifier)
          {
            case 32:
            {
              if(!(fastPath == 0))
              {
                buffPtr=va_arg(arg, __typeof__(buffPtr));
                unsigned long int return_value_strlen$24;
                return_value_strlen$24=strlen(buffPtr);
                buffCount = (signed int)return_value_strlen$24;
                buffLen = buffCount + 1;
              }

              else
              {
                sprintf(buffPtr, fmtBuff, charPtrArg);
                unsigned long int return_value_strlen$25;
                return_value_strlen$25=strlen(buffPtr);
                buffCount = (signed int)return_value_strlen$25;
              }
              break;
            }
            case 108:
              goto ErrorReturn;
            default:
              goto ErrorReturn;
          }
          break;
        }
        case 112:
        {
          if(!(sizeModifier == 32))
            goto ErrorReturn;

          voidPtrArg=va_arg(arg, __typeof__(voidPtrArg));
          sprintf(buffPtr, fmtBuff, voidPtrArg);
          return_value_strlen$26=strlen(buffPtr);
          buffCount = (signed int)return_value_strlen$26;
          break;
        }
        case 110:
        {
          switch(sizeModifier)
          {
            case 32:
            {
              intPtrArg=va_arg(arg, __typeof__(intPtrArg));
              *intPtrArg = streamCount;
              break;
            }
            case 108:
            {
              longPtrArg=va_arg(arg, __typeof__(longPtrArg));
              *longPtrArg = (signed long int)streamCount;
              break;
            }
            case 104:
            {
              return_value_gcc_builtin_va_arg$27=va_arg(arg, __typeof__(return_value_gcc_builtin_va_arg$27));
              shortPtrArg = (signed short int *)return_value_gcc_builtin_va_arg$27;
              *shortPtrArg = (signed short int)streamCount;
              break;
            }
            default:
              goto ErrorReturn;
          }
          buffCount = 0;
          break;
        }
        case 102:
        {
          if(!(fastPath == 0))
          {
            performedOp = 0;
            break;
          }

          switch(sizeModifier)
          {
            case 32:
            {
              sprintf(buffPtr, fmtBuff, doubleArg);
              return_value_strlen$28=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$28;
              break;
            }
            case 76:
            {
              sprintf(buffPtr, fmtBuff, lDoubleArg);
              return_value_strlen$29=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$29;
              break;
            }
            default:
              goto ErrorReturn;
          }
          break;
        }
        case 101:

        case 69:

        case 103:

        case 71:
        {
          switch(sizeModifier)
          {
            case 32:
            {
              doubleArg=va_arg(arg, __typeof__(doubleArg));
              sprintf(buffPtr, fmtBuff, doubleArg);
              return_value_strlen$30=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$30;
              break;
            }
            case 76:
            {
              lDoubleArg=va_arg(arg, __typeof__(lDoubleArg));
              sprintf(buffPtr, fmtBuff, lDoubleArg);
              return_value_strlen$31=strlen(buffPtr);
              buffCount = (signed int)return_value_strlen$31;
              break;
            }
            default:
              goto ErrorReturn;
          }
          break;
        }
        case 37:
        {
          if(!(sizeModifier == 32))
            goto ErrorReturn;

          buff[(signed long int)0] = (char)37;
          buffCount = 1;
          break;
        }
        case 0:
          goto ErrorReturn;
        default:
          performedOp = 0;
      }
      if(!(performedOp == 0))
        break;

      if(fastPath == 0)
        goto ErrorReturn;

    }
    /* assertion buffCount < buffLen */
    assert(buffCount < buffLen);
    if(buffCount >= 1)
    {
      signed int return_value_FCGX_PutStr$32;
      return_value_FCGX_PutStr$32=FCGX_PutStr(buffPtr, buffCount, stream);
      if(!(return_value_FCGX_PutStr$32 >= 0))
        goto ErrorReturn;

      streamCount = streamCount + buffCount;
    }

    else
      if(!(buffCount >= 0))
        goto ErrorReturn;

    f = f + (signed long int)specifierLength;
  }
  goto NormalReturn;

ErrorReturn:
  ;
  streamCount = -1;

NormalReturn:
  ;
  if(!(auxBuffPtr == ((char *)NULL)))
    free((void *)auxBuffPtr);

  return streamCount;
}

// FillBuffProc
// file fcgiapp.c line 1625
static void FillBuffProc(struct FCGX_Stream *stream)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  struct anonymous$13 header;
  signed int headerLen = 0;
  signed int status;
  signed int count;
  signed int tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  signed long int tmp_if_expr$3;
  signed long int tmp_if_expr$4;
  signed long int tmp_if_expr$5;
  while((_Bool)1)
  {
    if(stream->rdNext == data->buffStop)
    {
      count=OS_Read(data->reqDataPtr->ipcFd, (char *)data->buff, (unsigned long int)data->bufflen);
      if(!(count >= 1))
      {
        if(count == 0)
          tmp_if_expr$2 = -3;

        else
        {
          return_value___errno_location$1=__errno_location();
          tmp_if_expr$2 = *return_value___errno_location$1;
        }
        SetError(stream, tmp_if_expr$2);
        goto __CPROVER_DUMP_L24;
      }

      stream->rdNext = data->buff;
      data->buffStop = data->buff + (signed long int)count;
    }

    if(data->contentLen >= 1)
    {
      if(!((signed long int)data->contentLen >= data->buffStop - stream->rdNext))
        tmp_if_expr$3 = (signed long int)data->contentLen;

      else
        tmp_if_expr$3 = data->buffStop - stream->rdNext;
      count = (signed int)tmp_if_expr$3;
      data->contentLen = data->contentLen - count;
      if(data->skip == 0)
      {
        stream->stop = stream->rdNext + (signed long int)count;
        stream->wrNext = stream->stop;
        break;
      }

      else
      {
        stream->rdNext = stream->rdNext + (signed long int)count;
        if(data->contentLen >= 1)
          continue;

        else
          data->skip = 0;
      }
    }

    if(data->paddingLen >= 1)
    {
      if(!((signed long int)data->paddingLen >= data->buffStop - stream->rdNext))
        tmp_if_expr$4 = (signed long int)data->paddingLen;

      else
        tmp_if_expr$4 = data->buffStop - stream->rdNext;
      count = (signed int)tmp_if_expr$4;
      data->paddingLen = data->paddingLen - count;
      stream->rdNext = stream->rdNext + (signed long int)count;
      if(data->paddingLen >= 1)
        continue;

    }

    if(!(data->eorStop == 0))
    {
      stream->stop = stream->rdNext;
      stream->isClosed = 1;
      break;
    }

    if(!((signed long int)((signed int)sizeof(struct anonymous$13) /*8*/  + -headerLen) >= data->buffStop - stream->rdNext))
      tmp_if_expr$5 = (signed long int)((signed int)sizeof(struct anonymous$13) /*8ul*/  - headerLen);

    else
      tmp_if_expr$5 = data->buffStop - stream->rdNext;
    count = (signed int)tmp_if_expr$5;
    memcpy((void *)((char *)&header + (signed long int)headerLen), (const void *)stream->rdNext, (unsigned long int)count);
    headerLen = headerLen + count;
    stream->rdNext = stream->rdNext + (signed long int)count;
    if((unsigned long int)headerLen >= sizeof(struct anonymous$13) /*8ul*/ )
    {
      headerLen = 0;
      data->eorStop = 1;
      stream->stop = stream->rdNext;
      status=ProcessHeader(header, stream);
      data->eorStop = 0;
      stream->isClosed = 0;
      switch(status)
      {
        case 0:
        {
          if(data->contentLen == 0)
          {
            stream->stop = stream->rdNext;
            stream->wrNext = stream->stop;
            stream->isClosed = 1;
            goto __CPROVER_DUMP_L24;
          }

          break;
        }
        case 1:
        {
          data->skip = 1;
          break;
        }
        case 2:
          goto __CPROVER_DUMP_L24;
        case 3:
          break;
        default:
        {
          /* assertion status < 0 */
          assert(status < 0);
          SetError(stream, status);
          goto __CPROVER_DUMP_L24;
        }
      }
    }

  }

__CPROVER_DUMP_L24:
  ;
}

// FreeParams
// file fcgiapp.c line 1046
static void FreeParams(struct Params **paramsPtrPtr)
{
  struct Params *paramsPtr = *paramsPtrPtr;
  char **p;
  if(!(paramsPtr == ((struct Params *)NULL)))
  {
    p = paramsPtr->vec;
    for( ; !(p >= paramsPtr->cur); p = p + 1l)
      free((void *)*p);
    free((void *)paramsPtr->vec);
    free((void *)paramsPtr);
    *paramsPtrPtr = (struct Params *)(void *)0;
  }

}

// GrowAsyncTable
// file os_unix.c line 605
static void GrowAsyncTable(void)
{
  signed int oldTableSize = asyncIoTableSize;
  asyncIoTableSize = asyncIoTableSize * 2;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)asyncIoTable, (unsigned long int)asyncIoTableSize * sizeof(struct anonymous) /*48ul*/ );
  asyncIoTable = (struct anonymous *)return_value_realloc$1;
  if(asyncIoTable == ((struct anonymous *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    exit(*return_value___errno_location$3);
  }

  memset((void *)(char *)&asyncIoTable[(signed long int)oldTableSize], 0, (unsigned long int)oldTableSize * sizeof(struct anonymous) /*48ul*/ );
}

// MakeEndRequestBody
// file fcgiapp.c line 1230
static struct anonymous$15 MakeEndRequestBody(signed int appStatus, signed int protocolStatus)
{
  struct anonymous$15 body;
  body.appStatusB3 = (unsigned char)(appStatus >> 24 & 0xff);
  body.appStatusB2 = (unsigned char)(appStatus >> 16 & 0xff);
  body.appStatusB1 = (unsigned char)(appStatus >> 8 & 0xff);
  body.appStatusB0 = (unsigned char)(appStatus & 0xff);
  body.protocolStatus = (unsigned char)protocolStatus;
  memset((void *)body.reserved, 0, sizeof(unsigned char [3l]) /*3ul*/ );
  return body;
}

// MakeHeader
// file fcgiapp.c line 1201
static struct anonymous$13 MakeHeader(signed int type, signed int requestId, signed int contentLength, signed int paddingLength)
{
  struct anonymous$13 header;
  /* assertion contentLength >= 0 && contentLength <= 0xffff */
  assert(contentLength >= 0 && contentLength <= 0xffff);
  /* assertion paddingLength >= 0 && paddingLength <= 0xff */
  assert(paddingLength >= 0 && paddingLength <= 0xff);
  header.version = (unsigned char)1;
  header.type = (unsigned char)type;
  header.requestIdB1 = (unsigned char)(requestId >> 8 & 0xff);
  header.requestIdB0 = (unsigned char)(requestId & 0xff);
  header.contentLengthB1 = (unsigned char)(contentLength >> 8 & 0xff);
  header.contentLengthB0 = (unsigned char)(contentLength & 0xff);
  header.paddingLength = (unsigned char)paddingLength;
  header.reserved = (unsigned char)0;
  return header;
}

// MakeUnknownTypeBody
// file fcgiapp.c line 1253
static struct anonymous$1 MakeUnknownTypeBody(signed int type)
{
  struct anonymous$1 body;
  body.type = (unsigned char)type;
  memset((void *)body.reserved, 0, sizeof(unsigned char [7l]) /*7ul*/ );
  return body;
}

// Malloc
// file fcgiapp.c line 79
static void * Malloc(unsigned long int size)
{
  void *result;
  result=malloc(size);
  /* assertion size == 0 || result != ((void *)0) */
  assert(size == (unsigned long int)0 || result != (void *)0);
  return result;
}

// NewParams
// file fcgiapp.c line 1023
static struct Params * NewParams(signed int length)
{
  struct Params *result;
  void *return_value_Malloc$1;
  return_value_Malloc$1=Malloc(sizeof(struct Params) /*24ul*/ );
  result = (struct Params *)return_value_Malloc$1;
  void *return_value_Malloc$2;
  return_value_Malloc$2=Malloc((unsigned long int)length * sizeof(char *) /*8ul*/ );
  result->vec = (char **)return_value_Malloc$2;
  result->length = length;
  result->cur = result->vec;
  *result->cur = (char *)(void *)0;
  return result;
}

// NewReader
// file fcgiapp.c line 1870
static struct FCGX_Stream * NewReader(struct FCGX_Request *reqDataPtr, signed int bufflen, signed int streamType)
{
  struct FCGX_Stream *return_value_NewStream$1;
  return_value_NewStream$1=NewStream(reqDataPtr, bufflen, 1, streamType);
  return return_value_NewStream$1;
}

// NewStream
// file fcgiapp.c line 1755
static struct FCGX_Stream * NewStream(struct FCGX_Request *reqDataPtr, signed int bufflen, signed int isReader, signed int streamType)
{
  struct FCGX_Stream *stream;
  void *return_value_Malloc$1;
  return_value_Malloc$1=Malloc(sizeof(struct FCGX_Stream) /*72ul*/ );
  stream = (struct FCGX_Stream *)return_value_Malloc$1;
  struct FCGX_Stream_Data *data;
  void *return_value_Malloc$2;
  return_value_Malloc$2=Malloc(sizeof(struct FCGX_Stream_Data) /*72ul*/ );
  data = (struct FCGX_Stream_Data *)return_value_Malloc$2;
  data->reqDataPtr = reqDataPtr;
  bufflen=AlignInt8((unsigned int)((bufflen > 32 ? bufflen : 32) < 0xffff + 1 ? (bufflen > 32 ? bufflen : 32) : 0xffff + 1));
  data->bufflen = bufflen;
  void *return_value_Malloc$3;
  return_value_Malloc$3=Malloc((unsigned long int)bufflen);
  data->mBuff = (unsigned char *)return_value_Malloc$3;
  data->buff=AlignPtr8(data->mBuff);
  if(!(data->buff == data->mBuff))
    data->bufflen = data->bufflen - 8;

  if(!(isReader == 0))
    data->buffStop = data->buff;

  else
    data->buffStop = data->buff + (signed long int)data->bufflen;
  data->type = streamType;
  data->eorStop = 0;
  data->skip = 0;
  data->contentLen = 0;
  data->paddingLen = 0;
  data->isAnythingWritten = 0;
  data->rawWrite = 0;
  stream->data = (void *)data;
  stream->isReader = isReader;
  stream->isClosed = 0;
  stream->wasFCloseCalled = 0;
  stream->FCGI_errno = 0;
  if(!(isReader == 0))
  {
    stream->fillBuffProc = FillBuffProc;
    stream->emptyBuffProc = (void (*)(struct FCGX_Stream *, signed int))(void *)0;
    stream->rdNext = data->buff;
    stream->stop = stream->rdNext;
    stream->stopUnget = data->buff;
    stream->wrNext = stream->stop;
  }

  else
  {
    stream->fillBuffProc = (void (*)(struct FCGX_Stream *))(void *)0;
    stream->emptyBuffProc = EmptyBuffProc;
    stream->wrNext = data->buff + (signed long int)sizeof(struct anonymous$13) /*8ul*/ ;
    stream->stop = data->buffStop;
    stream->stopUnget = (unsigned char *)(void *)0;
    stream->rdNext = stream->stop;
  }
  return stream;
}

// NewWriter
// file fcgiapp.c line 1886
static struct FCGX_Stream * NewWriter(struct FCGX_Request *reqDataPtr, signed int bufflen, signed int streamType)
{
  struct FCGX_Stream *return_value_NewStream$1;
  return_value_NewStream$1=NewStream(reqDataPtr, bufflen, 0, streamType);
  return return_value_NewStream$1;
}

// OS_Accept
// file ../include/fcgios.h line 119
signed int OS_Accept(signed int listen_sock, signed int fail_on_intr, const char *webServerAddrs)
{
  signed int OS_Accept$$1$$socket = -1;
  /* tag-#anon#lUN[lSYM#tag-sockaddr_un#'un'||lSYM#tag-sockaddr_in#'in'||U896'$pad'|] */
union anonymous$2
{
  // un
  struct sockaddr_un un;
  // in
  struct sockaddr_in in;
};

/* */
  ;
  union anonymous$2 sa;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$6;
  signed int return_value_is_reasonable_accept_errno$7;
  _Bool tmp_if_expr$13;
  signed int return_value_is_af_unix_keeper$12;
  do
  {
    signed int return_value_AcquireLock$1;
    return_value_AcquireLock$1=AcquireLock(listen_sock, fail_on_intr);
    if(!(return_value_AcquireLock$1 == 0))
      return -1;

    do
    {

    __CPROVER_DUMP_L2:
      ;
      signed int len = (signed int)sizeof(union anonymous$2) /*112ul*/ ;
      if(shutdownPending == 0)
      {
        OS_Accept$$1$$socket=accept(listen_sock, (struct sockaddr *)&sa, (unsigned int *)&len);
        if(!(OS_Accept$$1$$socket >= 0))
        {
          return_value___errno_location$2=__errno_location();
          tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        if(fail_on_intr == 0 && shutdownPending == 0 && tmp_if_expr$3)
          goto __CPROVER_DUMP_L2;

      }

      if(!(OS_Accept$$1$$socket >= 0))
      {
        if(!(shutdownPending == 0))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value___errno_location$6=__errno_location();
          return_value_is_reasonable_accept_errno$7=is_reasonable_accept_errno(*return_value___errno_location$6);
          tmp_if_expr$8 = !(return_value_is_reasonable_accept_errno$7 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          signed int errnoSave;
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          errnoSave = *return_value___errno_location$4;
          ReleaseLock(listen_sock);
          if(shutdownPending == 0)
          {
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            *return_value___errno_location$5 = errnoSave;
          }

          return -1;
        }

        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        *return_value___errno_location$9 = 0;
      }

      else
      {
        signed int set = 1;
        if(!((signed int)sa.in.sin_family == 2))
          break;

        setsockopt(OS_Accept$$1$$socket, 6, 1, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
        signed int return_value_ClientAddrOK$10;
        return_value_ClientAddrOK$10=ClientAddrOK(&sa.in, webServerAddrs);
        if(!(return_value_ClientAddrOK$10 == 0))
          break;

        close(OS_Accept$$1$$socket);
      }
    }
    while((_Bool)1);
    signed int return_value_ReleaseLock$11;
    return_value_ReleaseLock$11=ReleaseLock(listen_sock);
    if(!(return_value_ReleaseLock$11 == 0))
      return -1;

    if(!((signed int)sa.in.sin_family == 1))
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      return_value_is_af_unix_keeper$12=is_af_unix_keeper(OS_Accept$$1$$socket);
      tmp_if_expr$13 = return_value_is_af_unix_keeper$12 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$13)
      break;

    close(OS_Accept$$1$$socket);
  }
  while((_Bool)1);
  return OS_Accept$$1$$socket;
}

// OS_AsyncRead
// file os_unix.c line 644
signed int OS_AsyncRead(signed int fd, signed int offset, void *buf, signed int len, void (*procPtr)(void *, signed int), void *clientData)
{
  signed int index = fd * 2;
  /* assertion asyncIoTable != ((void *)0) */
  assert(asyncIoTable != (struct anonymous *)(void *)0);
  asyncIoInUse = 1;
  if(!(maxFd >= fd))
    maxFd = fd;

  while(index >= asyncIoTableSize)
    GrowAsyncTable();
  /* assertion asyncIoTable[index].inUse == 0 */
  assert((asyncIoTable + (signed long int)index)->inUse == 0);
  (asyncIoTable + (signed long int)index)->procPtr = procPtr;
  (asyncIoTable + (signed long int)index)->clientData = clientData;
  (asyncIoTable + (signed long int)index)->fd = fd;
  (asyncIoTable + (signed long int)index)->len = len;
  (asyncIoTable + (signed long int)index)->offset = offset;
  (asyncIoTable + (signed long int)index)->buf = buf;
  (asyncIoTable + (signed long int)index)->inUse = 1;
  (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  return 0;
}

// OS_AsyncReadStdin
// file os_unix.c line 585
signed int OS_AsyncReadStdin(void *buf, signed int len, void (*procPtr)(void *, signed int), void *clientData)
{
  signed int index = 0 * 2;
  asyncIoInUse = 1;
  /* assertion asyncIoTable[index].inUse == 0 */
  assert((asyncIoTable + (signed long int)index)->inUse == 0);
  (asyncIoTable + (signed long int)index)->procPtr = procPtr;
  (asyncIoTable + (signed long int)index)->clientData = clientData;
  (asyncIoTable + (signed long int)index)->fd = 0;
  (asyncIoTable + (signed long int)index)->len = len;
  (asyncIoTable + (signed long int)index)->offset = 0;
  (asyncIoTable + (signed long int)index)->buf = buf;
  (asyncIoTable + (signed long int)index)->inUse = 1;
  (&readFdSet)->__fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSet)->__fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << 0 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(!(maxFd >= 0))
    maxFd = 0;

  return 0;
}

// OS_AsyncWrite
// file os_unix.c line 694
signed int OS_AsyncWrite(signed int fd, signed int offset, void *buf, signed int len, void (*procPtr)(void *, signed int), void *clientData)
{
  signed int index = fd * 2 + 1;
  asyncIoInUse = 1;
  if(!(maxFd >= fd))
    maxFd = fd;

  while(index >= asyncIoTableSize)
    GrowAsyncTable();
  /* assertion asyncIoTable[index].inUse == 0 */
  assert((asyncIoTable + (signed long int)index)->inUse == 0);
  (asyncIoTable + (signed long int)index)->procPtr = procPtr;
  (asyncIoTable + (signed long int)index)->clientData = clientData;
  (asyncIoTable + (signed long int)index)->fd = fd;
  (asyncIoTable + (signed long int)index)->len = len;
  (asyncIoTable + (signed long int)index)->offset = offset;
  (asyncIoTable + (signed long int)index)->buf = buf;
  (asyncIoTable + (signed long int)index)->inUse = 1;
  (&writeFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  return 0;
}

// OS_BuildSockAddrUn
// file os_unix.c line 249
static signed int OS_BuildSockAddrUn(const char *bindPath, struct sockaddr_un *servAddrPtr, signed int *servAddrLen)
{
  signed int bindPathLen;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(bindPath);
  bindPathLen = (signed int)return_value_strlen$1;
  if((unsigned long int)bindPathLen >= 109ul)
    return -1;

  else
  {
    memset((void *)(char *)servAddrPtr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
    servAddrPtr->sun_family = (unsigned short int)1;
    memcpy((void *)servAddrPtr->sun_path, (const void *)bindPath, (unsigned long int)bindPathLen);
    *servAddrLen = (signed int)(sizeof(unsigned short int) /*2ul*/  + (unsigned long int)bindPathLen);
    return 0;
  }
}

// OS_Close
// file os_unix.c line 736
signed int OS_Close(signed int fd)
{
  _Bool tmp_if_expr$2;
  signed long int return_value_read$1;
  if(fd == -1)
    return 0;

  else
  {
    if(!(asyncIoInUse == 0))
    {
      signed int index = fd * 2;
      (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      (&readFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      if(!((asyncIoTable + (signed long int)index)->inUse == 0))
        (asyncIoTable + (signed long int)index)->inUse = 0;

      (&writeFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      (&writeFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      index = fd * 2 + 1;
      if(!((asyncIoTable + (signed long int)index)->inUse == 0))
        (asyncIoTable + (signed long int)index)->inUse = 0;

      if(maxFd == fd)
        maxFd = maxFd - 1;

    }

    signed int return_value_shutdown$3;
    return_value_shutdown$3=shutdown(fd, 1);
    if(return_value_shutdown$3 == 0)
    {
      struct pollfd pfd;
      signed int rv;
      char trash[1024l];
      pfd.fd = fd;
      pfd.events = (signed short int)0x001;
      do
      {
        rv=poll(&pfd, (unsigned long int)1, libfcgiOsClosePollTimeout);
        if(rv >= 1)
        {
          return_value_read$1=read(fd, (void *)trash, sizeof(char [1024l]) /*1024ul*/ );
          tmp_if_expr$2 = return_value_read$1 > (signed long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
      }
      while(tmp_if_expr$2);
    }

    signed int return_value_close$4;
    return_value_close$4=close(fd);
    return return_value_close$4;
  }
}

// OS_CloseRead
// file os_unix.c line 803
signed int OS_CloseRead(signed int fd)
{
  if(!((asyncIoTable + (signed long int)(2 * fd))->inUse == 0))
  {
    (asyncIoTable + (signed long int)(fd * 2))->inUse = 0;
    (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
  }

  signed int return_value_shutdown$1;
  return_value_shutdown$1=shutdown(fd, 0);
  return return_value_shutdown$1;
}

// OS_CreateLocalIpcFd
// file ../include/fcgios.h line 105
signed int OS_CreateLocalIpcFd(const char *bindPath, signed int backlog)
{
  signed int listenSock;
  signed int servLen;
  union SockAddrUnion sa;
  signed int tcp = 0;
  unsigned long int tcp_ia = (unsigned long int)0;
  char *tp;
  signed short int port = (signed short int)0;
  char host[1024l];
  strcpy(host, bindPath);
  tp=strchr(host, 58);
  char *tmp_post$1;
  if(!(tp == ((char *)NULL)))
  {
    tmp_post$1 = tp;
    tp = tp + 1l;
    *tmp_post$1 = (char)0;
    signed int return_value_atoi$2;
    return_value_atoi$2=atoi(tp);
    port = (signed short int)return_value_atoi$2;
    if((signed int)port == 0)
    {
      tp = tp - 1l;
      *tp = (char)58;
    }

    else
      tcp = 1;
  }

  _Bool tmp_if_expr$8;
  signed int return_value_strcmp$7;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(!(tcp == 0))
  {
    if(host[0l] == 0)
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      return_value_strcmp$7=strcmp(host, "*");
      tmp_if_expr$8 = !(return_value_strcmp$7 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
    {
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl((unsigned int)0x00000000);
      tcp_ia = (unsigned long int)return_value_htonl$3;
    }

    else
    {
      unsigned int return_value_inet_addr$4;
      return_value_inet_addr$4=inet_addr(host);
      tcp_ia = (unsigned long int)return_value_inet_addr$4;
      if(tcp_ia == 4294967295ul)
      {
        struct hostent *hep;
        hep=gethostbyname(host);
        if(hep == ((struct hostent *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          if(!(hep->h_addrtype == 2))
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = !(hep->h_addr_list[(signed long int)0] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
        {
          fprintf(stderr, "Cannot resolve host name %s -- exiting!\n", (const void *)host);
          exit(1);
        }

        if(!(hep->h_addr_list[1l] == ((char *)NULL)))
        {
          fprintf(stderr, "Host %s has multiple addresses ---\n", (const void *)host);
          fprintf(stderr, "you must choose one explicitly!!!\n");
          exit(1);
        }

        tcp_ia = (unsigned long int)((struct in_addr *)hep->h_addr_list[(signed long int)0])->s_addr;
      }

    }
  }

  if(!(tcp == 0))
  {
    listenSock=socket(2, 1, 0);
    if(listenSock >= 0)
    {
      signed int flag = 1;
      signed int return_value_setsockopt$9;
      return_value_setsockopt$9=setsockopt(listenSock, 1, 2, (const void *)(char *)&flag, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt$9 >= 0))
      {
        fprintf(stderr, "Can't set SO_REUSEADDR.\n");
        exit(1001);
      }

    }

  }

  else
    listenSock=socket(1, 1, 0);
  _Bool tmp_if_expr$14;
  signed int return_value_listen$13;
  if(!(listenSock >= 0))
    return -1;

  else
  {
    if(!(tcp == 0))
    {
      memset((void *)(char *)&sa.inetVariant, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      sa.inetVariant.sin_family = (unsigned short int)2;
      sa.inetVariant.sin_addr.s_addr = (unsigned int)tcp_ia;
      sa.inetVariant.sin_port=htons((unsigned short int)port);
      servLen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
    }

    else
    {
      unlink(bindPath);
      signed int return_value_OS_BuildSockAddrUn$10;
      return_value_OS_BuildSockAddrUn$10=OS_BuildSockAddrUn(bindPath, &sa.unixVariant, &servLen);
      if(!(return_value_OS_BuildSockAddrUn$10 == 0))
      {
        fprintf(stderr, "Listening socket's path name is too long.\n");
        exit(1000);
      }

    }
    signed int return_value_bind$12;
    return_value_bind$12=bind(listenSock, (struct sockaddr *)&sa.unixVariant, (unsigned int)servLen);
    if(!(return_value_bind$12 >= 0))
      tmp_if_expr$14 = (_Bool)1;

    else
    {
      return_value_listen$13=listen(listenSock, backlog);
      tmp_if_expr$14 = return_value_listen$13 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$14)
    {
      perror("bind/listen");
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      exit(*return_value___errno_location$11);
    }

    return listenSock;
  }
}

// OS_DoIo
// file os_unix.c line 830
signed int OS_DoIo(struct timeval *tmo)
{
  signed int fd;
  signed int len;
  signed int selectStatus;
  void (*procPtr)(void *, signed int);
  void *clientData;
  struct anonymous *aioPtr;
  struct anonymous$0 readFdSetCpy;
  struct anonymous$0 writeFdSetCpy;
  asyncIoInUse = 1;
  do
  {
    signed int OS_DoIo$$1$$1$$__d0;
    signed int OS_DoIo$$1$$1$$__d1;
    asm("cld; rep; stosq" : "=c"(OS_DoIo$$1$$1$$__d0), "=D"(OS_DoIo$$1$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous$0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readFdSetCpy)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writeFdSetCpy)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  fd = 0;
  for( ; maxFd >= fd; fd = fd + 1)
  {
    if(!((readFdSet.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      (&readFdSetCpy)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSetCpy)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    if(!((writeFdSet.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      (&writeFdSetCpy)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeFdSetCpy)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

  }
  if(numRdPosted == 0 && numWrPosted == 0)
  {
    selectStatus=select(maxFd + 1, &readFdSetCpy, &writeFdSetCpy, (struct anonymous$0 *)(void *)0, tmo);
    if(!(selectStatus >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      exit(*return_value___errno_location$1);
    }

    fd = 0;
    for( ; maxFd >= fd; fd = fd + 1)
    {
      if(!((readFdSetCpy.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      {
        numRdPosted = numRdPosted + 1;
        (&readFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      }

      if(!((writeFdSetCpy.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      {
        numWrPosted = numWrPosted + 1;
        (&writeFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        (&writeFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeFdSet)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      }

    }
  }

  if(numRdPosted == 0 && numWrPosted == 0)
    return 0;

  else
  {
    fd = 0;
    for( ; maxFd >= fd; fd = fd + 1)
    {
      if(!((readFdSetPost.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      {
        if(!((asyncIoTable + (signed long int)(2 * fd))->inUse == 0))
        {
          numRdPosted = numRdPosted - 1;
          (&readFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
          aioPtr = &asyncIoTable[(signed long int)(fd * 2)];
          signed long int return_value_read$2;
          return_value_read$2=read(aioPtr->fd, aioPtr->buf, (unsigned long int)aioPtr->len);
          len = (signed int)return_value_read$2;
          procPtr = aioPtr->procPtr;
          aioPtr->procPtr = (void (*)(void *, signed int))(void *)0;
          clientData = aioPtr->clientData;
          aioPtr->inUse = 0;
          procPtr(clientData, len);
        }

      }

      if(!((writeFdSetPost.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      {
        if(!((asyncIoTable + (signed long int)(2 * fd + 1))->inUse == 0))
        {
          numWrPosted = numWrPosted - 1;
          (&writeFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeFdSetPost)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
          aioPtr = &asyncIoTable[(signed long int)(fd * 2 + 1)];
          signed long int return_value_write$3;
          return_value_write$3=write(aioPtr->fd, aioPtr->buf, (unsigned long int)aioPtr->len);
          len = (signed int)return_value_write$3;
          procPtr = aioPtr->procPtr;
          aioPtr->procPtr = (void (*)(void *, signed int))(void *)0;
          clientData = aioPtr->clientData;
          aioPtr->inUse = 0;
          procPtr(clientData, len);
        }

      }

    }
    return 0;
  }
}

// OS_FcgiConnect
// file os_unix.c line 402
signed int OS_FcgiConnect(char *bindPath)
{
  union SockAddrUnion sa;
  signed int servLen;
  signed int resultSock;
  signed int connectStatus;
  char *tp;
  char host[1024l];
  signed short int port = (signed short int)0;
  signed int tcp = 0;
  strcpy(host, bindPath);
  tp=strchr(host, 58);
  char *tmp_post$1;
  if(!(tp == ((char *)NULL)))
  {
    tmp_post$1 = tp;
    tp = tp + 1l;
    *tmp_post$1 = (char)0;
    signed int return_value_atoi$2;
    return_value_atoi$2=atoi(tp);
    port = (signed short int)return_value_atoi$2;
    if((signed int)port == 0)
    {
      tp = tp - 1l;
      *tp = (char)58;
    }

    else
      tcp = 1;
  }

  char *tmp_if_expr$3;
  if(tcp == 1)
  {
    struct hostent *hp;
    if(!(host[0l] == 0))
      tmp_if_expr$3 = host;

    else
      tmp_if_expr$3 = "localhost";
    hp=gethostbyname(tmp_if_expr$3);
    if(hp == ((struct hostent *)NULL))
    {
      fprintf(stderr, "Unknown host: %s\n", bindPath);
      exit(1000);
    }

    sa.inetVariant.sin_family = (unsigned short int)2;
    memcpy((void *)&sa.inetVariant.sin_addr, (const void *)hp->h_addr_list[(signed long int)0], (unsigned long int)hp->h_length);
    sa.inetVariant.sin_port=htons((unsigned short int)port);
    servLen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
    resultSock=socket(2, 1, 0);
  }

  else
  {
    signed int return_value_OS_BuildSockAddrUn$4;
    return_value_OS_BuildSockAddrUn$4=OS_BuildSockAddrUn(bindPath, &sa.unixVariant, &servLen);
    if(!(return_value_OS_BuildSockAddrUn$4 == 0))
    {
      fprintf(stderr, "Listening socket's path name is too long.\n");
      exit(1000);
    }

    resultSock=socket(1, 1, 0);
  }
  /* assertion resultSock >= 0 */
  assert(resultSock >= 0);
  connectStatus=connect(resultSock, (struct sockaddr *)&sa.unixVariant, (unsigned int)servLen);
  if(connectStatus >= 0)
    return resultSock;

  else
  {
    close(resultSock);
    return -1;
  }
}

// OS_InstallSignalHandlers
// file os_unix.c line 137
static void OS_InstallSignalHandlers(signed int force)
{
  struct sigaction sa;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  sa.__sigaction_handler.sa_handler = OS_SigpipeHandler;
  installSignalHandler(13, &sa, force);
  sa.__sigaction_handler.sa_handler = OS_Sigusr1Handler;
  installSignalHandler(10, &sa, force);
}

// OS_IpcClose
// file ../include/fcgios.h line 120
signed int OS_IpcClose(signed int ipcFd)
{
  signed int return_value_OS_Close$1;
  return_value_OS_Close$1=OS_Close(ipcFd);
  return return_value_OS_Close$1;
}

// OS_IsFcgi
// file ../include/fcgios.h line 121
signed int OS_IsFcgi(signed int sock)
{
  /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'in'||lSYM#tag-sockaddr_un#'un'||U896'$pad'|] */
union anonymous$4
{
  // in
  struct sockaddr_in in;
  // un
  struct sockaddr_un un;
};

/* */
  ;
  union anonymous$4 sa;
  signed int len = (signed int)sizeof(union anonymous$4) /*112ul*/ ;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  signed int return_value_getpeername$2;
  return_value_getpeername$2=getpeername(sock, (struct sockaddr *)&sa, (unsigned int *)&len);
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if(!(return_value_getpeername$2 == 0))
  {
    return_value___errno_location$3=__errno_location();
    tmp_if_expr$4 = *return_value___errno_location$3 == 107 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$4 = (_Bool)0;
  if(tmp_if_expr$4)
    return 1;

  else
    return 0;
}

// OS_LibInit
// file ../include/fcgios.h line 103
signed int OS_LibInit(signed int *stdioFds)
{
  if(!(libInitialized$link1 == 0))
    return 0;

  else
  {
    char *libfcgiOsClosePollTimeoutStr;
    libfcgiOsClosePollTimeoutStr=getenv("LIBFCGI_OS_CLOSE_POLL_TIMEOUT");
    if(!(libfcgiOsClosePollTimeoutStr == ((char *)NULL)))
      libfcgiOsClosePollTimeout=atoi(libfcgiOsClosePollTimeoutStr);

    char *libfcgiIsAfUnixKeeperPollTimeoutStr;
    libfcgiIsAfUnixKeeperPollTimeoutStr=getenv("LIBFCGI_IS_AF_UNIX_KEEPER_POLL_TIMEOUT");
    if(!(libfcgiIsAfUnixKeeperPollTimeoutStr == ((char *)NULL)))
      libfcgiIsAfUnixKeeperPollTimeout=atoi(libfcgiIsAfUnixKeeperPollTimeoutStr);

    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)asyncIoTableSize * sizeof(struct anonymous) /*48ul*/ );
    asyncIoTable = (struct anonymous *)return_value_malloc$1;
    if(asyncIoTable == ((struct anonymous *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 12;
      return -1;
    }

    memset((void *)(char *)asyncIoTable, 0, (unsigned long int)asyncIoTableSize * sizeof(struct anonymous) /*48ul*/ );
    do
    {
      signed int OS_LibInit$$1$$4$$__d0;
      signed int OS_LibInit$$1$$4$$__d1;
      asm("cld; rep; stosq" : "=c"(OS_LibInit$$1$$4$$__d0), "=D"(OS_LibInit$$1$$4$$__d1) : "a"(0), "0"(sizeof(struct anonymous$0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readFdSet)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writeFdSet)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int OS_LibInit$$1$$6$$__d0;
      signed int OS_LibInit$$1$$6$$__d1;
      asm("cld; rep; stosq" : "=c"(OS_LibInit$$1$$6$$__d0), "=D"(OS_LibInit$$1$$6$$__d1) : "a"(0), "0"(sizeof(struct anonymous$0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readFdSetPost)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int OS_LibInit$$1$$7$$__d0;
      signed int OS_LibInit$$1$$7$$__d1;
      asm("cld; rep; stosq" : "=c"(OS_LibInit$$1$$7$$__d0), "=D"(OS_LibInit$$1$$7$$__d1) : "a"(0), "0"(sizeof(struct anonymous$0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writeFdSetPost)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    OS_InstallSignalHandlers(0);
    libInitialized$link1 = 1;
    return 0;
  }
}

// OS_LibShutdown
// file os_unix.c line 220
void OS_LibShutdown(void)
{
  if(!(libInitialized$link1 == 0))
  {
    free((void *)asyncIoTable);
    asyncIoTable = (struct anonymous *)(void *)0;
    libInitialized$link1 = 0;
  }

}

// OS_Read
// file ../include/fcgios.h line 107
signed int OS_Read(signed int fd, char *buf, unsigned long int len)
{
  if(!(shutdownNow == 0))
    return -1;

  else
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)buf, len);
    return (signed int)return_value_read$1;
  }
}

// OS_SetFlags
// file os_unix.c line 1292
void OS_SetFlags(signed int fd, signed int flags)
{
  signed int val;
  val=fcntl(fd, 3, 0);
  if(!(val >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    exit(*return_value___errno_location$1);
  }

  val = val | flags;
  signed int return_value_fcntl$3;
  return_value_fcntl$3=fcntl(fd, 4, val);
  if(!(return_value_fcntl$3 >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    exit(*return_value___errno_location$2);
  }

}

// OS_ShutdownPending
// file ../include/fcgios.h line 124
void OS_ShutdownPending(void)
{
  shutdownPending = 1;
}

// OS_SigpipeHandler
// file os_unix.c line 120
static void OS_SigpipeHandler(signed int signo)
{
  ;
}

// OS_Sigusr1Handler
// file os_unix.c line 115
static void OS_Sigusr1Handler(signed int signo)
{
  OS_ShutdownPending();
}

// OS_SpawnChild
// file os_unix.c line 514
signed int OS_SpawnChild(char *appPath, signed int listenFd)
{
  signed int forkResult;
  forkResult=fork();
  if(!(forkResult >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    exit(*return_value___errno_location$1);
  }

  if(forkResult == 0)
  {
    close(0);
    if(!(listenFd == 0))
    {
      dup2(listenFd, 0);
      close(listenFd);
    }

    close(1);
    close(2);
    execl(appPath, appPath, (void *)0);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    exit(*return_value___errno_location$2);
  }

  return 0;
}

// OS_Write
// file ../include/fcgios.h line 108
signed int OS_Write(signed int fd, char *buf, unsigned long int len)
{
  if(!(shutdownNow == 0))
    return -1;

  else
  {
    signed long int return_value_write$1;
    return_value_write$1=write(fd, (const void *)buf, len);
    return (signed int)return_value_write$1;
  }
}

// ProcessBeginRecord
// file fcgiapp.c line 1528
static signed int ProcessBeginRecord(signed int requestId, struct FCGX_Stream *stream)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  struct anonymous$23 body;
  _Bool tmp_if_expr$1;
  if(requestId == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (unsigned long int)data->contentLen != sizeof(struct anonymous$23) /*8ul*/  ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -3;

  else
  {
    if(!(data->reqDataPtr->isBeginProcessed == 0))
    {
      struct anonymous$21 endRequestRecord;
      endRequestRecord.header=MakeHeader(3, requestId, (signed int)sizeof(struct anonymous$15) /*8ul*/ , 0);
      endRequestRecord.body=MakeEndRequestBody(0, 1);
      signed int return_value_write_it_all$3;
      return_value_write_it_all$3=write_it_all(data->reqDataPtr->ipcFd, (char *)&endRequestRecord, (signed int)sizeof(struct anonymous$21) /*16ul*/ );
      if(!(return_value_write_it_all$3 >= 0))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        SetError(stream, *return_value___errno_location$2);
        return -1;
      }

      return 1;
    }

    data->reqDataPtr->requestId = requestId;
    signed int return_value_FCGX_GetStr$4;
    return_value_FCGX_GetStr$4=FCGX_GetStr((char *)&body, (signed int)sizeof(struct anonymous$23) /*8ul*/ , stream);
    if(!((unsigned long int)return_value_FCGX_GetStr$4 == sizeof(struct anonymous$23) /*8ul*/ ))
      return -3;

    else
    {
      data->reqDataPtr->keepConnection = (signed int)body.flags & 1;
      data->reqDataPtr->role = ((signed int)body.roleB1 << 8) + (signed int)body.roleB0;
      data->reqDataPtr->isBeginProcessed = 1;
      return 2;
    }
  }
}

// ProcessHeader
// file fcgiapp.c line 1589
static signed int ProcessHeader(struct anonymous$13 header, struct FCGX_Stream *stream)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  signed int requestId;
  if(!((signed int)header.version == 1))
    return -2;

  else
  {
    requestId = ((signed int)header.requestIdB1 << 8) + (signed int)header.requestIdB0;
    data->contentLen = ((signed int)header.contentLengthB1 << 8) + (signed int)header.contentLengthB0;
    data->paddingLen = (signed int)header.paddingLength;
    if((signed int)header.type == 1)
    {
      signed int return_value_ProcessBeginRecord$1;
      return_value_ProcessBeginRecord$1=ProcessBeginRecord(requestId, stream);
      return return_value_ProcessBeginRecord$1;
    }

    if(requestId == 0)
    {
      signed int return_value_ProcessManagementRecord$2;
      return_value_ProcessManagementRecord$2=ProcessManagementRecord((signed int)header.type, stream);
      return return_value_ProcessManagementRecord$2;
    }

    if(!(requestId == data->reqDataPtr->requestId))
      return 1;

    else
      if(!((signed int)header.type == data->type))
        return -3;

      else
        return 0;
  }
}

// ProcessManagementRecord
// file fcgiapp.c line 1454
static signed int ProcessManagementRecord(signed int type, struct FCGX_Stream *stream)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  struct Params *paramsPtr;
  paramsPtr=NewParams(3);
  char **pPtr;
  char response[64l];
  char *responseP = &response[(signed long int)8];
  char *name;
  char value = (char)0;
  signed int len;
  signed int paddedLen;
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  if(type == 9)
  {
    ReadParams(paramsPtr, stream);
    signed int return_value_FCGX_GetError$1;
    return_value_FCGX_GetError$1=FCGX_GetError(stream);
    if(!(return_value_FCGX_GetError$1 == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = data->contentLen != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      FreeParams(&paramsPtr);
      return -3;
    }

    pPtr = paramsPtr->vec;
    for( ; !(pPtr >= paramsPtr->cur); pPtr = pPtr + 1l)
    {
      name = *pPtr;
      char *return_value_strchr$3;
      return_value_strchr$3=strchr(name, 61);
      *return_value_strchr$3 = (char)0;
      signed int return_value_strcmp$6;
      return_value_strcmp$6=strcmp(name, "FCGI_MAX_CONNS");
      if(return_value_strcmp$6 == 0)
        value = (char)49;

      else
      {
        return_value_strcmp$5=strcmp(name, "FCGI_MAX_REQS");
        if(return_value_strcmp$5 == 0)
          value = (char)49;

        else
        {
          return_value_strcmp$4=strcmp(name, "FCGI_MPXS_CONNS");
          if(return_value_strcmp$4 == 0)
            value = (char)48;

          else
            name = (char *)(void *)0;
        }
      }
      if(!(name == ((char *)NULL)))
      {
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(name);
        len = (signed int)return_value_strlen$7;
        sprintf(responseP, "%c%c%s%c", len, 1, name, value);
        responseP = responseP + (signed long int)(len + 3);
      }

    }
    len = (signed int)(responseP - &response[(signed long int)8]);
    paddedLen=AlignInt8((unsigned int)len);
    struct anonymous$13 *header = (struct anonymous$13 *)response;
    *header=MakeHeader(10, 0, len, paddedLen - len);
    FreeParams(&paramsPtr);
  }

  else
  {
    len = (signed int)sizeof(struct anonymous$1) /*8ul*/ ;
    paddedLen = len;
    struct anonymous$22 *utr = (struct anonymous$22 *)response;
    utr->header=MakeHeader(11, 0, len, 0);
    utr->body=MakeUnknownTypeBody(type);
  }
  signed int return_value_write_it_all$9;
  return_value_write_it_all$9=write_it_all(data->reqDataPtr->ipcFd, response, 8 + paddedLen);
  if(!(return_value_write_it_all$9 >= 0))
  {
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    SetError(stream, *return_value___errno_location$8);
    return -1;
  }

  return 3;
}

// PutParam
// file fcgiapp.c line 1076
static void PutParam(struct Params *paramsPtr, char *nameValue)
{
  signed int size;
  char **tmp_post$1 = paramsPtr->cur;
  paramsPtr->cur = paramsPtr->cur + 1l;
  *tmp_post$1 = nameValue;
  size = (signed int)(paramsPtr->cur - paramsPtr->vec);
  if(size >= paramsPtr->length)
  {
    paramsPtr->length = paramsPtr->length * 2;
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)paramsPtr->vec, (unsigned long int)paramsPtr->length * sizeof(char *) /*8ul*/ );
    paramsPtr->vec = (char **)return_value_realloc$2;
    paramsPtr->cur = paramsPtr->vec + (signed long int)size;
  }

  *paramsPtr->cur = (char *)(void *)0;
}

// ReadParams
// file fcgiapp.c line 1138
static signed int ReadParams(struct Params *paramsPtr, struct FCGX_Stream *stream)
{
  signed int nameLen;
  signed int valueLen;
  unsigned char lenBuff[3l];
  char *nameValue;
  do
  {
    nameLen=FCGX_GetChar(stream);
    if(nameLen == -1)
      break;

    if(!((0x80 & nameLen) == 0))
    {
      signed int return_value_FCGX_GetStr$1;
      return_value_FCGX_GetStr$1=FCGX_GetStr((char *)&lenBuff[(signed long int)0], 3, stream);
      if(!(return_value_FCGX_GetStr$1 == 3))
      {
        SetError(stream, -4);
        return -1;
      }

      nameLen = ((nameLen & 0x7f) << 24) + ((signed int)lenBuff[(signed long int)0] << 16) + ((signed int)lenBuff[(signed long int)1] << 8) + (signed int)lenBuff[(signed long int)2];
    }

    valueLen=FCGX_GetChar(stream);
    if(valueLen == -1)
    {
      SetError(stream, -4);
      return -1;
    }

    if(!((0x80 & valueLen) == 0))
    {
      signed int return_value_FCGX_GetStr$2;
      return_value_FCGX_GetStr$2=FCGX_GetStr((char *)&lenBuff[(signed long int)0], 3, stream);
      if(!(return_value_FCGX_GetStr$2 == 3))
      {
        SetError(stream, -4);
        return -1;
      }

      valueLen = ((valueLen & 0x7f) << 24) + ((signed int)lenBuff[(signed long int)0] << 16) + ((signed int)lenBuff[(signed long int)1] << 8) + (signed int)lenBuff[(signed long int)2];
    }

    void *return_value_Malloc$3;
    return_value_Malloc$3=Malloc((unsigned long int)(nameLen + valueLen + 2));
    nameValue = (char *)return_value_Malloc$3;
    signed int return_value_FCGX_GetStr$4;
    return_value_FCGX_GetStr$4=FCGX_GetStr(nameValue, nameLen, stream);
    if(!(return_value_FCGX_GetStr$4 == nameLen))
    {
      SetError(stream, -4);
      free((void *)nameValue);
      return -1;
    }

    nameValue[(signed long int)nameLen] = (char)61;
    signed int return_value_FCGX_GetStr$5;
    return_value_FCGX_GetStr$5=FCGX_GetStr(nameValue + (signed long int)nameLen + (signed long int)1, valueLen, stream);
    if(!(return_value_FCGX_GetStr$5 == valueLen))
    {
      SetError(stream, -4);
      free((void *)nameValue);
      return -1;
    }

    (nameValue + (signed long int)nameLen + (signed long int)valueLen)[(signed long int)1] = (char)0;
    PutParam(paramsPtr, nameValue);
  }
  while((_Bool)1);
  return 0;
}

// ReleaseLock
// file os_unix.c line 1040
static signed int ReleaseLock(signed int sock)
{
  return 0;
}

// SetError
// file fcgiapp.c line 942
static void SetError(struct FCGX_Stream *stream, signed int FCGI_errno)
{
  if(stream->FCGI_errno == 0)
    stream->FCGI_errno = FCGI_errno;

  stream->isClosed = 1;
}

// SetReaderType
// file fcgiapp.c line 1846
static struct FCGX_Stream * SetReaderType(struct FCGX_Stream *stream, signed int streamType)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  /* assertion stream->isReader */
  assert(stream->isReader != 0);
  data->type = streamType;
  data->eorStop = 0;
  data->skip = 0;
  data->contentLen = 0;
  data->paddingLen = 0;
  stream->stop = stream->rdNext;
  stream->wrNext = stream->stop;
  stream->isClosed = 0;
  return stream;
}

// StringCopy
// file fcgiapp.c line 86
static char * StringCopy(char *str)
{
  signed int strLen;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  strLen = (signed int)return_value_strlen$1;
  char *newString;
  void *return_value_Malloc$2;
  return_value_Malloc$2=Malloc((unsigned long int)(strLen + 1));
  newString = (char *)return_value_Malloc$2;
  memcpy((void *)newString, (const void *)str, (unsigned long int)strLen);
  newString[(signed long int)strLen] = (char)0;
  return newString;
}

// WriteCloseRecords
// file fcgiapp.c line 1326
static void WriteCloseRecords(struct FCGX_Stream *stream)
{
  struct FCGX_Stream_Data *data = (struct FCGX_Stream_Data *)stream->data;
  data->rawWrite = 1;
  _Bool tmp_if_expr$1;
  if(data->type == 7)
    tmp_if_expr$1 = stream->wrNext == data->buff ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = !(data->isAnythingWritten != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(!tmp_if_expr$2)
  {
    struct anonymous$13 header;
    header=MakeHeader(data->type, data->reqDataPtr->requestId, 0, 0);
    FCGX_PutStr((char *)&header, (signed int)sizeof(struct anonymous$13) /*8ul*/ , stream);
  }

  if(data->reqDataPtr->nWriters == 1)
  {
    struct anonymous$21 endRequestRecord;
    endRequestRecord.header=MakeHeader(3, data->reqDataPtr->requestId, (signed int)sizeof(struct anonymous$15) /*8ul*/ , 0);
    endRequestRecord.body=MakeEndRequestBody(data->reqDataPtr->appStatus, 0);
    FCGX_PutStr((char *)&endRequestRecord, (signed int)sizeof(struct anonymous$21) /*16ul*/ , stream);
  }

  data->reqDataPtr->nWriters = data->reqDataPtr->nWriters - 1;
}

// doit
// file threaded.c line 25
static void * doit(void *a)
{
  signed int rc;
  signed int i;
  signed int thread_id = (signed int)a;
  signed int pid;
  pid=getpid();
  struct FCGX_Request request;
  char *server_name;
  FCGX_InitRequest(&request, 0, 0);
  do
  {
    static union anonymous$24 accept_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
    pthread_mutex_lock(&accept_mutex);
    rc=FCGX_Accept_r(&request);
    pthread_mutex_unlock(&accept_mutex);
    if(!(rc >= 0))
      break;

    server_name=FCGX_GetParam("SERVER_NAME", request.envp);
    FCGX_FPrintF(request.out, "Content-type: text/html\r\n\r\n<title>FastCGI Hello! (multi-threaded C, fcgiapp library)</title><h1>FastCGI Hello! (multi-threaded C, fcgiapp library)</h1>Thread %d, Process %ld<p>Request counts for %d threads running on host <i>%s</i><p><code>", thread_id, pid, 20, server_name != ((char *)NULL) ? server_name : "?");
    sleep((unsigned int)2);
    static union anonymous$24 counts_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
    pthread_mutex_lock(&counts_mutex);
    counts[(signed long int)thread_id] = counts[(signed long int)thread_id] + 1;
    i = 0;
    for( ; !(i >= 20); i = i + 1)
      FCGX_FPrintF(request.out, "%5d ", counts[(signed long int)i]);
    pthread_mutex_unlock(&counts_mutex);
    FCGX_Finish_r(&request);
  }
  while((_Bool)1);
  return (void *)0;
}

// installSignalHandler
// file os_unix.c line 125
static void installSignalHandler(signed int signo, struct sigaction *act, signed int force)
{
  struct sigaction sa;
  sigaction(signo, (struct sigaction *)(void *)0, &sa);
  if(sa.__sigaction_handler.sa_handler == ((void (*)(signed int))NULL) || !(force == 0))
    sigaction(signo, act, (struct sigaction *)(void *)0);

}

// is_af_unix_keeper
// file os_unix.c line 1128
static signed int is_af_unix_keeper(const signed int fd)
{
  struct pollfd pfd;
  pfd.fd = fd;
  pfd.events = (signed short int)0x001;
  signed int return_value_poll$1;
  return_value_poll$1=poll(&pfd, (unsigned long int)1, libfcgiIsAfUnixKeeperPollTimeout);
  return (signed int)(return_value_poll$1 >= 0 ? (((signed int)pfd.revents & 0x001) != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0);
}

// is_reasonable_accept_errno
// file os_unix.c line 1066
static signed int is_reasonable_accept_errno(const signed int error)
{
  if(error == 71 || error == 101 || error == 103 || error == 104 || error == 110 || error == 113)
    return 1;

  return 0;
}

// main
// file threaded.c line 72
signed int main(void)
{
  signed int i;
  unsigned long int id[20l];
  FCGX_Init();
  i = 1;
  for( ; !(i >= 20); i = i + 1)
    pthread_create(&id[(signed long int)i], (const union pthread_attr_t *)(void *)0, doit, (void *)i);
  doit(NULL);
  return 0;
}

// str_dup
// file os_unix.c line 933
static char * str_dup(const char *str)
{
  char *sdup;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
  sdup = (char *)return_value_malloc$2;
  if(!(sdup == ((char *)NULL)))
    strcpy(sdup, str);

  return sdup;
}

// write_it_all
// file fcgiapp.c line 1362
static signed int write_it_all(signed int fd, char *buf, signed int len)
{
  signed int wrote;
  for( ; !(len == 0); buf = buf + (signed long int)wrote)
  {
    wrote=OS_Write(fd, buf, (unsigned long int)len);
    if(!(wrote >= 0))
      return wrote;

    len = len - wrote;
  }
  return len;
}

