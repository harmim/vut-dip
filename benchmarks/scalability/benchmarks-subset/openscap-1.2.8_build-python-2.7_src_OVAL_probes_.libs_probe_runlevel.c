// #anon_enum$CURLE_OK=0$CURLE_UNSUPPORTED_PROTOCOL=1$CURLE_FAILED_INIT=2$CURLE_URL_MALFORMAT=3$CURLE_NOT_BUILT_IN=4$CURLE_COULDNT_RESOLVE_PROXY=5$CURLE_COULDNT_RESOLVE_HOST=6$CURLE_COULDNT_CONNECT=7$CURLE_FTP_WEIRD_SERVER_REPLY=8$CURLE_REMOTE_ACCESS_DENIED=9$CURLE_FTP_ACCEPT_FAILED=10$CURLE_FTP_WEIRD_PASS_REPLY=11$CURLE_FTP_ACCEPT_TIMEOUT=12$CURLE_FTP_WEIRD_PASV_REPLY=13$CURLE_FTP_WEIRD_227_FORMAT=14$CURLE_FTP_CANT_GET_HOST=15$CURLE_HTTP2=16$CURLE_FTP_COULDNT_SET_TYPE=17$CURLE_PARTIAL_FILE=18$CURLE_FTP_COULDNT_RETR_FILE=19$CURLE_OBSOLETE20=20$CURLE_QUOTE_ERROR=21$CURLE_HTTP_RETURNED_ERROR=22$CURLE_WRITE_ERROR=23$CURLE_OBSOLETE24=24$CURLE_UPLOAD_FAILED=25$CURLE_READ_ERROR=26$CURLE_OUT_OF_MEMORY=27$CURLE_OPERATION_TIMEDOUT=28$CURLE_OBSOLETE29=29$CURLE_FTP_PORT_FAILED=30$CURLE_FTP_COULDNT_USE_REST=31$CURLE_OBSOLETE32=32$CURLE_RANGE_ERROR=33$CURLE_HTTP_POST_ERROR=34$CURLE_SSL_CONNECT_ERROR=35$CURLE_BAD_DOWNLOAD_RESUME=36$CURLE_FILE_COULDNT_READ_FILE=37$CURLE_LDAP_CANNOT_BIND=38$CURLE_LDAP_SEARCH_FAILED=39$CURLE_OBSOLETE40=40$CURLE_FUNCTION_NOT_FOUND=41$CURLE_ABORTED_BY_CALLBACK=42$CURLE_BAD_FUNCTION_ARGUMENT=43$CURLE_OBSOLETE44=44$CURLE_INTERFACE_FAILED=45$CURLE_OBSOLETE46=46$CURLE_TOO_MANY_REDIRECTS=47$CURLE_UNKNOWN_OPTION=48$CURLE_TELNET_OPTION_SYNTAX=49$CURLE_OBSOLETE50=50$CURLE_PEER_FAILED_VERIFICATION=51$CURLE_GOT_NOTHING=52$CURLE_SSL_ENGINE_NOTFOUND=53$CURLE_SSL_ENGINE_SETFAILED=54$CURLE_SEND_ERROR=55$CURLE_RECV_ERROR=56$CURLE_OBSOLETE57=57$CURLE_SSL_CERTPROBLEM=58$CURLE_SSL_CIPHER=59$CURLE_SSL_CACERT=60$CURLE_BAD_CONTENT_ENCODING=61$CURLE_LDAP_INVALID_URL=62$CURLE_FILESIZE_EXCEEDED=63$CURLE_USE_SSL_FAILED=64$CURLE_SEND_FAIL_REWIND=65$CURLE_SSL_ENGINE_INITFAILED=66$CURLE_LOGIN_DENIED=67$CURLE_TFTP_NOTFOUND=68$CURLE_TFTP_PERM=69$CURLE_REMOTE_DISK_FULL=70$CURLE_TFTP_ILLEGAL=71$CURLE_TFTP_UNKNOWNID=72$CURLE_REMOTE_FILE_EXISTS=73$CURLE_TFTP_NOSUCHUSER=74$CURLE_CONV_FAILED=75$CURLE_CONV_REQD=76$CURLE_SSL_CACERT_BADFILE=77$CURLE_REMOTE_FILE_NOT_FOUND=78$CURLE_SSH=79$CURLE_SSL_SHUTDOWN_FAILED=80$CURLE_AGAIN=81$CURLE_SSL_CRL_BADFILE=82$CURLE_SSL_ISSUER_ERROR=83$CURLE_FTP_PRET_FAILED=84$CURLE_RTSP_CSEQ_ERROR=85$CURLE_RTSP_SESSION_ERROR=86$CURLE_FTP_BAD_FILE_LIST=87$CURLE_CHUNK_FAILED=88$CURLE_NO_CONNECTION_AVAILABLE=89$CURLE_SSL_PINNEDPUBKEYNOTMATCH=90$CURLE_SSL_INVALIDCERTSTATUS=91$CURL_LAST=92
// file /usr/include/curl/curl.h line 413
enum anonymous$28 { CURLE_OK=0, CURLE_UNSUPPORTED_PROTOCOL=1, CURLE_FAILED_INIT=2, CURLE_URL_MALFORMAT=3, CURLE_NOT_BUILT_IN=4, CURLE_COULDNT_RESOLVE_PROXY=5, CURLE_COULDNT_RESOLVE_HOST=6, CURLE_COULDNT_CONNECT=7, CURLE_FTP_WEIRD_SERVER_REPLY=8, CURLE_REMOTE_ACCESS_DENIED=9, CURLE_FTP_ACCEPT_FAILED=10, CURLE_FTP_WEIRD_PASS_REPLY=11, CURLE_FTP_ACCEPT_TIMEOUT=12, CURLE_FTP_WEIRD_PASV_REPLY=13, CURLE_FTP_WEIRD_227_FORMAT=14, CURLE_FTP_CANT_GET_HOST=15, CURLE_HTTP2=16, CURLE_FTP_COULDNT_SET_TYPE=17, CURLE_PARTIAL_FILE=18, CURLE_FTP_COULDNT_RETR_FILE=19, CURLE_OBSOLETE20=20, CURLE_QUOTE_ERROR=21, CURLE_HTTP_RETURNED_ERROR=22, CURLE_WRITE_ERROR=23, CURLE_OBSOLETE24=24, CURLE_UPLOAD_FAILED=25, CURLE_READ_ERROR=26, CURLE_OUT_OF_MEMORY=27, CURLE_OPERATION_TIMEDOUT=28, CURLE_OBSOLETE29=29, CURLE_FTP_PORT_FAILED=30, CURLE_FTP_COULDNT_USE_REST=31, CURLE_OBSOLETE32=32, CURLE_RANGE_ERROR=33, CURLE_HTTP_POST_ERROR=34, CURLE_SSL_CONNECT_ERROR=35, CURLE_BAD_DOWNLOAD_RESUME=36, CURLE_FILE_COULDNT_READ_FILE=37, CURLE_LDAP_CANNOT_BIND=38, CURLE_LDAP_SEARCH_FAILED=39, CURLE_OBSOLETE40=40, CURLE_FUNCTION_NOT_FOUND=41, CURLE_ABORTED_BY_CALLBACK=42, CURLE_BAD_FUNCTION_ARGUMENT=43, CURLE_OBSOLETE44=44, CURLE_INTERFACE_FAILED=45, CURLE_OBSOLETE46=46, CURLE_TOO_MANY_REDIRECTS=47, CURLE_UNKNOWN_OPTION=48, CURLE_TELNET_OPTION_SYNTAX=49, CURLE_OBSOLETE50=50, CURLE_PEER_FAILED_VERIFICATION=51, CURLE_GOT_NOTHING=52, CURLE_SSL_ENGINE_NOTFOUND=53, CURLE_SSL_ENGINE_SETFAILED=54, CURLE_SEND_ERROR=55, CURLE_RECV_ERROR=56, CURLE_OBSOLETE57=57, CURLE_SSL_CERTPROBLEM=58, CURLE_SSL_CIPHER=59, CURLE_SSL_CACERT=60, CURLE_BAD_CONTENT_ENCODING=61, CURLE_LDAP_INVALID_URL=62, CURLE_FILESIZE_EXCEEDED=63, CURLE_USE_SSL_FAILED=64, CURLE_SEND_FAIL_REWIND=65, CURLE_SSL_ENGINE_INITFAILED=66, CURLE_LOGIN_DENIED=67, CURLE_TFTP_NOTFOUND=68, CURLE_TFTP_PERM=69, CURLE_REMOTE_DISK_FULL=70, CURLE_TFTP_ILLEGAL=71, CURLE_TFTP_UNKNOWNID=72, CURLE_REMOTE_FILE_EXISTS=73, CURLE_TFTP_NOSUCHUSER=74, CURLE_CONV_FAILED=75, CURLE_CONV_REQD=76, CURLE_SSL_CACERT_BADFILE=77, CURLE_REMOTE_FILE_NOT_FOUND=78, CURLE_SSH=79, CURLE_SSL_SHUTDOWN_FAILED=80, CURLE_AGAIN=81, CURLE_SSL_CRL_BADFILE=82, CURLE_SSL_ISSUER_ERROR=83, CURLE_FTP_PRET_FAILED=84, CURLE_RTSP_CSEQ_ERROR=85, CURLE_RTSP_SESSION_ERROR=86, CURLE_FTP_BAD_FILE_LIST=87, CURLE_CHUNK_FAILED=88, CURLE_NO_CONNECTION_AVAILABLE=89, CURLE_SSL_PINNEDPUBKEYNOTMATCH=90, CURLE_SSL_INVALIDCERTSTATUS=91, CURL_LAST=92 };

// #anon_enum$CURLOPT_WRITEDATA=10001$CURLOPT_URL=10002$CURLOPT_PORT=3$CURLOPT_PROXY=10004$CURLOPT_USERPWD=10005$CURLOPT_PROXYUSERPWD=10006$CURLOPT_RANGE=10007$CURLOPT_READDATA=10009$CURLOPT_ERRORBUFFER=10010$CURLOPT_WRITEFUNCTION=20011$CURLOPT_READFUNCTION=20012$CURLOPT_TIMEOUT=13$CURLOPT_INFILESIZE=14$CURLOPT_POSTFIELDS=10015$CURLOPT_REFERER=10016$CURLOPT_FTPPORT=10017$CURLOPT_USERAGENT=10018$CURLOPT_LOW_SPEED_LIMIT=19$CURLOPT_LOW_SPEED_TIME=20$CURLOPT_RESUME_FROM=21$CURLOPT_COOKIE=10022$CURLOPT_HTTPHEADER=10023$CURLOPT_HTTPPOST=10024$CURLOPT_SSLCERT=10025$CURLOPT_KEYPASSWD=10026$CURLOPT_CRLF=27$CURLOPT_QUOTE=10028$CURLOPT_HEADERDATA=10029$CURLOPT_COOKIEFILE=10031$CURLOPT_SSLVERSION=32$CURLOPT_TIMECONDITION=33$CURLOPT_TIMEVALUE=34$CURLOPT_CUSTOMREQUEST=10036$CURLOPT_STDERR=10037$CURLOPT_POSTQUOTE=10039$CURLOPT_OBSOLETE40=10040$CURLOPT_VERBOSE=41$CURLOPT_HEADER=42$CURLOPT_NOPROGRESS=43$CURLOPT_NOBODY=44$CURLOPT_FAILONERROR=45$CURLOPT_UPLOAD=46$CURLOPT_POST=47$CURLOPT_DIRLISTONLY=48$CURLOPT_APPEND=50$CURLOPT_NETRC=51$CURLOPT_FOLLOWLOCATION=52$CURLOPT_TRANSFERTEXT=53$CURLOPT_PUT=54$CURLOPT_PROGRESSFUNCTION=20056$CURLOPT_PROGRESSDATA=10057$CURLOPT_AUTOREFERER=58$CURLOPT_PROXYPORT=59$CURLOPT_POSTFIELDSIZE=60$CURLOPT_HTTPPROXYTUNNEL=61$CURLOPT_INTERFACE=10062$CURLOPT_KRBLEVEL=10063$CURLOPT_SSL_VERIFYPEER=64$CURLOPT_CAINFO=10065$CURLOPT_MAXREDIRS=68$CURLOPT_FILETIME=69$CURLOPT_TELNETOPTIONS=10070$CURLOPT_MAXCONNECTS=71$CURLOPT_OBSOLETE72=72$CURLOPT_FRESH_CONNECT=74$CURLOPT_FORBID_REUSE=75$CURLOPT_RANDOM_FILE=10076$CURLOPT_EGDSOCKET=10077$CURLOPT_CONNECTTIMEOUT=78$CURLOPT_HEADERFUNCTION=20079$CURLOPT_HTTPGET=80$CURLOPT_SSL_VERIFYHOST=81$CURLOPT_COOKIEJAR=10082$CURLOPT_SSL_CIPHER_LIST=10083$CURLOPT_HTTP_VERSION=84$CURLOPT_FTP_USE_EPSV=85$CURLOPT_SSLCERTTYPE=10086$CURLOPT_SSLKEY=10087$CURLOPT_SSLKEYTYPE=10088$CURLOPT_SSLENGINE=10089$CURLOPT_SSLENGINE_DEFAULT=90$CURLOPT_DNS_USE_GLOBAL_CACHE=91$CURLOPT_DNS_CACHE_TIMEOUT=92$CURLOPT_PREQUOTE=10093$CURLOPT_DEBUGFUNCTION=20094$CURLOPT_DEBUGDATA=10095$CURLOPT_COOKIESESSION=96$CURLOPT_CAPATH=10097$CURLOPT_BUFFERSIZE=98$CURLOPT_NOSIGNAL=99$CURLOPT_SHARE=10100$CURLOPT_PROXYTYPE=101$CURLOPT_ACCEPT_ENCODING=10102$CURLOPT_PRIVATE=10103$CURLOPT_HTTP200ALIASES=10104$CURLOPT_UNRESTRICTED_AUTH=105$CURLOPT_FTP_USE_EPRT=106$CURLOPT_HTTPAUTH=107$CURLOPT_SSL_CTX_FUNCTION=20108$CURLOPT_SSL_CTX_DATA=10109$CURLOPT_FTP_CREATE_MISSING_DIRS=110$CURLOPT_PROXYAUTH=111$CURLOPT_FTP_RESPONSE_TIMEOUT=112$CURLOPT_IPRESOLVE=113$CURLOPT_MAXFILESIZE=114$CURLOPT_INFILESIZE_LARGE=30115$CURLOPT_RESUME_FROM_LARGE=30116$CURLOPT_MAXFILESIZE_LARGE=30117$CURLOPT_NETRC_FILE=10118$CURLOPT_USE_SSL=119$CURLOPT_POSTFIELDSIZE_LARGE=30120$CURLOPT_TCP_NODELAY=121$CURLOPT_FTPSSLAUTH=129$CURLOPT_IOCTLFUNCTION=20130$CURLOPT_IOCTLDATA=10131$CURLOPT_FTP_ACCOUNT=10134$CURLOPT_COOKIELIST=10135$CURLOPT_IGNORE_CONTENT_LENGTH=136$CURLOPT_FTP_SKIP_PASV_IP=137$CURLOPT_FTP_FILEMETHOD=138$CURLOPT_LOCALPORT=139$CURLOPT_LOCALPORTRANGE=140$CURLOPT_CONNECT_ONLY=141$CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142$CURLOPT_CONV_TO_NETWORK_FUNCTION=20143$CURLOPT_CONV_FROM_UTF8_FUNCTION=20144$CURLOPT_MAX_SEND_SPEED_LARGE=30145$CURLOPT_MAX_RECV_SPEED_LARGE=30146$CURLOPT_FTP_ALTERNATIVE_TO_USER=10147$CURLOPT_SOCKOPTFUNCTION=20148$CURLOPT_SOCKOPTDATA=10149$CURLOPT_SSL_SESSIONID_CACHE=150$CURLOPT_SSH_AUTH_TYPES=151$CURLOPT_SSH_PUBLIC_KEYFILE=10152$CURLOPT_SSH_PRIVATE_KEYFILE=10153$CURLOPT_FTP_SSL_CCC=154$CURLOPT_TIMEOUT_MS=155$CURLOPT_CONNECTTIMEOUT_MS=156$CURLOPT_HTTP_TRANSFER_DECODING=157$CURLOPT_HTTP_CONTENT_DECODING=158$CURLOPT_NEW_FILE_PERMS=159$CURLOPT_NEW_DIRECTORY_PERMS=160$CURLOPT_POSTREDIR=161$CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162$CURLOPT_OPENSOCKETFUNCTION=20163$CURLOPT_OPENSOCKETDATA=10164$CURLOPT_COPYPOSTFIELDS=10165$CURLOPT_PROXY_TRANSFER_MODE=166$CURLOPT_SEEKFUNCTION=20167$CURLOPT_SEEKDATA=10168$CURLOPT_CRLFILE=10169$CURLOPT_ISSUERCERT=10170$CURLOPT_ADDRESS_SCOPE=171$CURLOPT_CERTINFO=172$CURLOPT_USERNAME=10173$CURLOPT_PASSWORD=10174$CURLOPT_PROXYUSERNAME=10175$CURLOPT_PROXYPASSWORD=10176$CURLOPT_NOPROXY=10177$CURLOPT_TFTP_BLKSIZE=178$CURLOPT_SOCKS5_GSSAPI_SERVICE=10179$CURLOPT_SOCKS5_GSSAPI_NEC=180$CURLOPT_PROTOCOLS=181$CURLOPT_REDIR_PROTOCOLS=182$CURLOPT_SSH_KNOWNHOSTS=10183$CURLOPT_SSH_KEYFUNCTION=20184$CURLOPT_SSH_KEYDATA=10185$CURLOPT_MAIL_FROM=10186$CURLOPT_MAIL_RCPT=10187$CURLOPT_FTP_USE_PRET=188$CURLOPT_RTSP_REQUEST=189$CURLOPT_RTSP_SESSION_ID=10190$CURLOPT_RTSP_STREAM_URI=10191$CURLOPT_RTSP_TRANSPORT=10192$CURLOPT_RTSP_CLIENT_CSEQ=193$CURLOPT_RTSP_SERVER_CSEQ=194$CURLOPT_INTERLEAVEDATA=10195$CURLOPT_INTERLEAVEFUNCTION=20196$CURLOPT_WILDCARDMATCH=197$CURLOPT_CHUNK_BGN_FUNCTION=20198$CURLOPT_CHUNK_END_FUNCTION=20199$CURLOPT_FNMATCH_FUNCTION=20200$CURLOPT_CHUNK_DATA=10201$CURLOPT_FNMATCH_DATA=10202$CURLOPT_RESOLVE=10203$CURLOPT_TLSAUTH_USERNAME=10204$CURLOPT_TLSAUTH_PASSWORD=10205$CURLOPT_TLSAUTH_TYPE=10206$CURLOPT_TRANSFER_ENCODING=207$CURLOPT_CLOSESOCKETFUNCTION=20208$CURLOPT_CLOSESOCKETDATA=10209$CURLOPT_GSSAPI_DELEGATION=210$CURLOPT_DNS_SERVERS=10211$CURLOPT_ACCEPTTIMEOUT_MS=212$CURLOPT_TCP_KEEPALIVE=213$CURLOPT_TCP_KEEPIDLE=214$CURLOPT_TCP_KEEPINTVL=215$CURLOPT_SSL_OPTIONS=216$CURLOPT_MAIL_AUTH=10217$CURLOPT_SASL_IR=218$CURLOPT_XFERINFOFUNCTION=20219$CURLOPT_XOAUTH2_BEARER=10220$CURLOPT_DNS_INTERFACE=10221$CURLOPT_DNS_LOCAL_IP4=10222$CURLOPT_DNS_LOCAL_IP6=10223$CURLOPT_LOGIN_OPTIONS=10224$CURLOPT_SSL_ENABLE_NPN=225$CURLOPT_SSL_ENABLE_ALPN=226$CURLOPT_EXPECT_100_TIMEOUT_MS=227$CURLOPT_PROXYHEADER=10228$CURLOPT_HEADEROPT=229$CURLOPT_PINNEDPUBLICKEY=10230$CURLOPT_UNIX_SOCKET_PATH=10231$CURLOPT_SSL_VERIFYSTATUS=232$CURLOPT_SSL_FALSESTART=233$CURLOPT_PATH_AS_IS=234$CURLOPT_PROXY_SERVICE_NAME=10235$CURLOPT_SERVICE_NAME=10236$CURLOPT_PIPEWAIT=237$CURLOPT_DEFAULT_PROTOCOL=10238$CURLOPT_STREAM_WEIGHT=239$CURLOPT_STREAM_DEPENDS=10240$CURLOPT_STREAM_DEPENDS_E=10241$CURLOPT_LASTENTRY=10242
// file /usr/include/curl/curl.h line 863
enum anonymous$19 { CURLOPT_WRITEDATA=10001, CURLOPT_URL=10002, CURLOPT_PORT=3, CURLOPT_PROXY=10004, CURLOPT_USERPWD=10005, CURLOPT_PROXYUSERPWD=10006, CURLOPT_RANGE=10007, CURLOPT_READDATA=10009, CURLOPT_ERRORBUFFER=10010, CURLOPT_WRITEFUNCTION=20011, CURLOPT_READFUNCTION=20012, CURLOPT_TIMEOUT=13, CURLOPT_INFILESIZE=14, CURLOPT_POSTFIELDS=10015, CURLOPT_REFERER=10016, CURLOPT_FTPPORT=10017, CURLOPT_USERAGENT=10018, CURLOPT_LOW_SPEED_LIMIT=19, CURLOPT_LOW_SPEED_TIME=20, CURLOPT_RESUME_FROM=21, CURLOPT_COOKIE=10022, CURLOPT_HTTPHEADER=10023, CURLOPT_HTTPPOST=10024, CURLOPT_SSLCERT=10025, CURLOPT_KEYPASSWD=10026, CURLOPT_CRLF=27, CURLOPT_QUOTE=10028, CURLOPT_HEADERDATA=10029, CURLOPT_COOKIEFILE=10031, CURLOPT_SSLVERSION=32, CURLOPT_TIMECONDITION=33, CURLOPT_TIMEVALUE=34, CURLOPT_CUSTOMREQUEST=10036, CURLOPT_STDERR=10037, CURLOPT_POSTQUOTE=10039, CURLOPT_OBSOLETE40=10040, CURLOPT_VERBOSE=41, CURLOPT_HEADER=42, CURLOPT_NOPROGRESS=43, CURLOPT_NOBODY=44, CURLOPT_FAILONERROR=45, CURLOPT_UPLOAD=46, CURLOPT_POST=47, CURLOPT_DIRLISTONLY=48, CURLOPT_APPEND=50, CURLOPT_NETRC=51, CURLOPT_FOLLOWLOCATION=52, CURLOPT_TRANSFERTEXT=53, CURLOPT_PUT=54, CURLOPT_PROGRESSFUNCTION=20056, CURLOPT_PROGRESSDATA=10057, CURLOPT_AUTOREFERER=58, CURLOPT_PROXYPORT=59, CURLOPT_POSTFIELDSIZE=60, CURLOPT_HTTPPROXYTUNNEL=61, CURLOPT_INTERFACE=10062, CURLOPT_KRBLEVEL=10063, CURLOPT_SSL_VERIFYPEER=64, CURLOPT_CAINFO=10065, CURLOPT_MAXREDIRS=68, CURLOPT_FILETIME=69, CURLOPT_TELNETOPTIONS=10070, CURLOPT_MAXCONNECTS=71, CURLOPT_OBSOLETE72=72, CURLOPT_FRESH_CONNECT=74, CURLOPT_FORBID_REUSE=75, CURLOPT_RANDOM_FILE=10076, CURLOPT_EGDSOCKET=10077, CURLOPT_CONNECTTIMEOUT=78, CURLOPT_HEADERFUNCTION=20079, CURLOPT_HTTPGET=80, CURLOPT_SSL_VERIFYHOST=81, CURLOPT_COOKIEJAR=10082, CURLOPT_SSL_CIPHER_LIST=10083, CURLOPT_HTTP_VERSION=84, CURLOPT_FTP_USE_EPSV=85, CURLOPT_SSLCERTTYPE=10086, CURLOPT_SSLKEY=10087, CURLOPT_SSLKEYTYPE=10088, CURLOPT_SSLENGINE=10089, CURLOPT_SSLENGINE_DEFAULT=90, CURLOPT_DNS_USE_GLOBAL_CACHE=91, CURLOPT_DNS_CACHE_TIMEOUT=92, CURLOPT_PREQUOTE=10093, CURLOPT_DEBUGFUNCTION=20094, CURLOPT_DEBUGDATA=10095, CURLOPT_COOKIESESSION=96, CURLOPT_CAPATH=10097, CURLOPT_BUFFERSIZE=98, CURLOPT_NOSIGNAL=99, CURLOPT_SHARE=10100, CURLOPT_PROXYTYPE=101, CURLOPT_ACCEPT_ENCODING=10102, CURLOPT_PRIVATE=10103, CURLOPT_HTTP200ALIASES=10104, CURLOPT_UNRESTRICTED_AUTH=105, CURLOPT_FTP_USE_EPRT=106, CURLOPT_HTTPAUTH=107, CURLOPT_SSL_CTX_FUNCTION=20108, CURLOPT_SSL_CTX_DATA=10109, CURLOPT_FTP_CREATE_MISSING_DIRS=110, CURLOPT_PROXYAUTH=111, CURLOPT_FTP_RESPONSE_TIMEOUT=112, CURLOPT_IPRESOLVE=113, CURLOPT_MAXFILESIZE=114, CURLOPT_INFILESIZE_LARGE=30115, CURLOPT_RESUME_FROM_LARGE=30116, CURLOPT_MAXFILESIZE_LARGE=30117, CURLOPT_NETRC_FILE=10118, CURLOPT_USE_SSL=119, CURLOPT_POSTFIELDSIZE_LARGE=30120, CURLOPT_TCP_NODELAY=121, CURLOPT_FTPSSLAUTH=129, CURLOPT_IOCTLFUNCTION=20130, CURLOPT_IOCTLDATA=10131, CURLOPT_FTP_ACCOUNT=10134, CURLOPT_COOKIELIST=10135, CURLOPT_IGNORE_CONTENT_LENGTH=136, CURLOPT_FTP_SKIP_PASV_IP=137, CURLOPT_FTP_FILEMETHOD=138, CURLOPT_LOCALPORT=139, CURLOPT_LOCALPORTRANGE=140, CURLOPT_CONNECT_ONLY=141, CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142, CURLOPT_CONV_TO_NETWORK_FUNCTION=20143, CURLOPT_CONV_FROM_UTF8_FUNCTION=20144, CURLOPT_MAX_SEND_SPEED_LARGE=30145, CURLOPT_MAX_RECV_SPEED_LARGE=30146, CURLOPT_FTP_ALTERNATIVE_TO_USER=10147, CURLOPT_SOCKOPTFUNCTION=20148, CURLOPT_SOCKOPTDATA=10149, CURLOPT_SSL_SESSIONID_CACHE=150, CURLOPT_SSH_AUTH_TYPES=151, CURLOPT_SSH_PUBLIC_KEYFILE=10152, CURLOPT_SSH_PRIVATE_KEYFILE=10153, CURLOPT_FTP_SSL_CCC=154, CURLOPT_TIMEOUT_MS=155, CURLOPT_CONNECTTIMEOUT_MS=156, CURLOPT_HTTP_TRANSFER_DECODING=157, CURLOPT_HTTP_CONTENT_DECODING=158, CURLOPT_NEW_FILE_PERMS=159, CURLOPT_NEW_DIRECTORY_PERMS=160, CURLOPT_POSTREDIR=161, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162, CURLOPT_OPENSOCKETFUNCTION=20163, CURLOPT_OPENSOCKETDATA=10164, CURLOPT_COPYPOSTFIELDS=10165, CURLOPT_PROXY_TRANSFER_MODE=166, CURLOPT_SEEKFUNCTION=20167, CURLOPT_SEEKDATA=10168, CURLOPT_CRLFILE=10169, CURLOPT_ISSUERCERT=10170, CURLOPT_ADDRESS_SCOPE=171, CURLOPT_CERTINFO=172, CURLOPT_USERNAME=10173, CURLOPT_PASSWORD=10174, CURLOPT_PROXYUSERNAME=10175, CURLOPT_PROXYPASSWORD=10176, CURLOPT_NOPROXY=10177, CURLOPT_TFTP_BLKSIZE=178, CURLOPT_SOCKS5_GSSAPI_SERVICE=10179, CURLOPT_SOCKS5_GSSAPI_NEC=180, CURLOPT_PROTOCOLS=181, CURLOPT_REDIR_PROTOCOLS=182, CURLOPT_SSH_KNOWNHOSTS=10183, CURLOPT_SSH_KEYFUNCTION=20184, CURLOPT_SSH_KEYDATA=10185, CURLOPT_MAIL_FROM=10186, CURLOPT_MAIL_RCPT=10187, CURLOPT_FTP_USE_PRET=188, CURLOPT_RTSP_REQUEST=189, CURLOPT_RTSP_SESSION_ID=10190, CURLOPT_RTSP_STREAM_URI=10191, CURLOPT_RTSP_TRANSPORT=10192, CURLOPT_RTSP_CLIENT_CSEQ=193, CURLOPT_RTSP_SERVER_CSEQ=194, CURLOPT_INTERLEAVEDATA=10195, CURLOPT_INTERLEAVEFUNCTION=20196, CURLOPT_WILDCARDMATCH=197, CURLOPT_CHUNK_BGN_FUNCTION=20198, CURLOPT_CHUNK_END_FUNCTION=20199, CURLOPT_FNMATCH_FUNCTION=20200, CURLOPT_CHUNK_DATA=10201, CURLOPT_FNMATCH_DATA=10202, CURLOPT_RESOLVE=10203, CURLOPT_TLSAUTH_USERNAME=10204, CURLOPT_TLSAUTH_PASSWORD=10205, CURLOPT_TLSAUTH_TYPE=10206, CURLOPT_TRANSFER_ENCODING=207, CURLOPT_CLOSESOCKETFUNCTION=20208, CURLOPT_CLOSESOCKETDATA=10209, CURLOPT_GSSAPI_DELEGATION=210, CURLOPT_DNS_SERVERS=10211, CURLOPT_ACCEPTTIMEOUT_MS=212, CURLOPT_TCP_KEEPALIVE=213, CURLOPT_TCP_KEEPIDLE=214, CURLOPT_TCP_KEEPINTVL=215, CURLOPT_SSL_OPTIONS=216, CURLOPT_MAIL_AUTH=10217, CURLOPT_SASL_IR=218, CURLOPT_XFERINFOFUNCTION=20219, CURLOPT_XOAUTH2_BEARER=10220, CURLOPT_DNS_INTERFACE=10221, CURLOPT_DNS_LOCAL_IP4=10222, CURLOPT_DNS_LOCAL_IP6=10223, CURLOPT_LOGIN_OPTIONS=10224, CURLOPT_SSL_ENABLE_NPN=225, CURLOPT_SSL_ENABLE_ALPN=226, CURLOPT_EXPECT_100_TIMEOUT_MS=227, CURLOPT_PROXYHEADER=10228, CURLOPT_HEADEROPT=229, CURLOPT_PINNEDPUBLICKEY=10230, CURLOPT_UNIX_SOCKET_PATH=10231, CURLOPT_SSL_VERIFYSTATUS=232, CURLOPT_SSL_FALSESTART=233, CURLOPT_PATH_AS_IS=234, CURLOPT_PROXY_SERVICE_NAME=10235, CURLOPT_SERVICE_NAME=10236, CURLOPT_PIPEWAIT=237, CURLOPT_DEFAULT_PROTOCOL=10238, CURLOPT_STREAM_WEIGHT=239, CURLOPT_STREAM_DEPENDS=10240, CURLOPT_STREAM_DEPENDS_E=10241, CURLOPT_LASTENTRY=10242 };

// #anon_enum$DBG_E=1$DBG_W=2$DBG_I=3$DBG_D=4$DBG_UNKNOWN=-1
// file ../../../src/common/public/oscap_debug.h line 26
enum anonymous$2 { DBG_E=1, DBG_W=2, DBG_I=3, DBG_D=4, DBG_UNKNOWN=-1 };

// #anon_enum$OVAL_CHECK_UNKNOWN=0$OVAL_CHECK_ALL=1$OVAL_CHECK_AT_LEAST_ONE=2$OVAL_CHECK_NONE_EXIST=3$OVAL_CHECK_NONE_SATISFY=4$OVAL_CHECK_ONLY_ONE=5
// file ../../../../../src/OVAL/public/oval_definitions.h line 113
enum anonymous$48 { OVAL_CHECK_UNKNOWN=0, OVAL_CHECK_ALL=1, OVAL_CHECK_AT_LEAST_ONE=2, OVAL_CHECK_NONE_EXIST=3, OVAL_CHECK_NONE_SATISFY=4, OVAL_CHECK_ONLY_ONE=5 };

// #anon_enum$OVAL_DATATYPE_UNKNOWN=0$OVAL_DATATYPE_BINARY=1$OVAL_DATATYPE_BOOLEAN=2$OVAL_DATATYPE_EVR_STRING=3$OVAL_DATATYPE_FILESET_REVISION=4$OVAL_DATATYPE_FLOAT=5$OVAL_DATATYPE_INTEGER=6$OVAL_DATATYPE_IOS_VERSION=7$OVAL_DATATYPE_IPV4ADDR=8$OVAL_DATATYPE_IPV6ADDR=9$OVAL_DATATYPE_RECORD=10$OVAL_DATATYPE_SEXP=11$OVAL_DATATYPE_STRING=12$OVAL_DATATYPE_STRING_M=13$OVAL_DATATYPE_VERSION=14$OVAL_DATATYPE_DEBIAN_EVR_STRING=15
// file ../../../../src/OVAL/public/oval_definitions.h line 149
enum anonymous$10 { OVAL_DATATYPE_UNKNOWN=0, OVAL_DATATYPE_BINARY=1, OVAL_DATATYPE_BOOLEAN=2, OVAL_DATATYPE_EVR_STRING=3, OVAL_DATATYPE_FILESET_REVISION=4, OVAL_DATATYPE_FLOAT=5, OVAL_DATATYPE_INTEGER=6, OVAL_DATATYPE_IOS_VERSION=7, OVAL_DATATYPE_IPV4ADDR=8, OVAL_DATATYPE_IPV6ADDR=9, OVAL_DATATYPE_RECORD=10, OVAL_DATATYPE_SEXP=11, OVAL_DATATYPE_STRING=12, OVAL_DATATYPE_STRING_M=13, OVAL_DATATYPE_VERSION=14, OVAL_DATATYPE_DEBIAN_EVR_STRING=15 };

// #anon_enum$OVAL_MESSAGE_LEVEL_NONE=0$OVAL_MESSAGE_LEVEL_DEBUG=1$OVAL_MESSAGE_LEVEL_INFO=2$OVAL_MESSAGE_LEVEL_WARNING=3$OVAL_MESSAGE_LEVEL_ERROR=4$OVAL_MESSAGE_LEVEL_FATAL=5
// file ../../../../src/OVAL/public/oval_system_characteristics.h line 69
enum anonymous$9 { OVAL_MESSAGE_LEVEL_NONE=0, OVAL_MESSAGE_LEVEL_DEBUG=1, OVAL_MESSAGE_LEVEL_INFO=2, OVAL_MESSAGE_LEVEL_WARNING=3, OVAL_MESSAGE_LEVEL_ERROR=4, OVAL_MESSAGE_LEVEL_FATAL=5 };

// #anon_enum$OVAL_OPERATION_UNKNOWN=0$OVAL_OPERATION_BITWISE_AND=1$OVAL_OPERATION_BITWISE_OR=2$OVAL_OPERATION_CASE_INSENSITIVE_EQUALS=3$OVAL_OPERATION_CASE_INSENSITIVE_NOT_EQUAL=4$OVAL_OPERATION_EQUALS=5$OVAL_OPERATION_GREATER_THAN=6$OVAL_OPERATION_GREATER_THAN_OR_EQUAL=7$OVAL_OPERATION_LESS_THAN=8$OVAL_OPERATION_LESS_THAN_OR_EQUAL=9$OVAL_OPERATION_NOT_EQUAL=10$OVAL_OPERATION_PATTERN_MATCH=11$OVAL_OPERATION_SUBSET_OF=12$OVAL_OPERATION_SUPERSET_OF=13
// file ../../../../../src/OVAL/public/oval_definitions.h line 84
enum anonymous$36 { OVAL_OPERATION_UNKNOWN=0, OVAL_OPERATION_BITWISE_AND=1, OVAL_OPERATION_BITWISE_OR=2, OVAL_OPERATION_CASE_INSENSITIVE_EQUALS=3, OVAL_OPERATION_CASE_INSENSITIVE_NOT_EQUAL=4, OVAL_OPERATION_EQUALS=5, OVAL_OPERATION_GREATER_THAN=6, OVAL_OPERATION_GREATER_THAN_OR_EQUAL=7, OVAL_OPERATION_LESS_THAN=8, OVAL_OPERATION_LESS_THAN_OR_EQUAL=9, OVAL_OPERATION_NOT_EQUAL=10, OVAL_OPERATION_PATTERN_MATCH=11, OVAL_OPERATION_SUBSET_OF=12, OVAL_OPERATION_SUPERSET_OF=13 };

// #anon_enum$OVAL_OPERATOR_UNKNOWN=0$OVAL_OPERATOR_AND=1$OVAL_OPERATOR_ONE=2$OVAL_OPERATOR_OR=3$OVAL_OPERATOR_XOR=4
// file ../../../../../src/OVAL/public/oval_definitions.h line 75
enum anonymous$49 { OVAL_OPERATOR_UNKNOWN=0, OVAL_OPERATOR_AND=1, OVAL_OPERATOR_ONE=2, OVAL_OPERATOR_OR=3, OVAL_OPERATOR_XOR=4 };

// #anon_enum$OVAL_RESULT_TRUE=1$OVAL_RESULT_FALSE=2$OVAL_RESULT_UNKNOWN=4$OVAL_RESULT_ERROR=8$OVAL_RESULT_NOT_EVALUATED=16$OVAL_RESULT_NOT_APPLICABLE=32
// file ../../../../src/OVAL/public/oval_types.h line 327
enum anonymous$18 { OVAL_RESULT_TRUE=1, OVAL_RESULT_FALSE=2, OVAL_RESULT_UNKNOWN=4, OVAL_RESULT_ERROR=8, OVAL_RESULT_NOT_EVALUATED=16, OVAL_RESULT_NOT_APPLICABLE=32 };

// #anon_enum$OVAL_SET_OPERATION_UNKNOWN=0$OVAL_SET_OPERATION_COMPLEMENT=1$OVAL_SET_OPERATION_INTERSECTION=2$OVAL_SET_OPERATION_UNION=3
// file ../../../../../src/OVAL/public/oval_definitions.h line 184
enum anonymous$34 { OVAL_SET_OPERATION_UNKNOWN=0, OVAL_SET_OPERATION_COMPLEMENT=1, OVAL_SET_OPERATION_INTERSECTION=2, OVAL_SET_OPERATION_UNION=3 };

// #anon_enum$OVAL_SUBTYPE_UNKNOWN=0$OVAL_SUBTYPE_ALL=1$OVAL_SUBTYPE_SYSINFO=2
// file ../../../../src/OVAL/public/oval_types.h line 120
enum anonymous$17 { OVAL_SUBTYPE_UNKNOWN=0, OVAL_SUBTYPE_ALL=1, OVAL_SUBTYPE_SYSINFO=2 };

// #anon_enum$PROBE_OFFLINE_NONE=0$PROBE_OFFLINE_CHROOT=1$PROBE_OFFLINE_RPMDB=2$PROBE_OFFLINE_ALL=15
// file ../../../../../src/OVAL/probes/probe/probe.h line 74
enum anonymous$25 { PROBE_OFFLINE_NONE=0, PROBE_OFFLINE_CHROOT=1, PROBE_OFFLINE_RPMDB=2, PROBE_OFFLINE_ALL=15 };

// #anon_enum$RBT_GENKEY=0$RBT_STRKEY=1$RBT_I32KEY=2$RBT_I64KEY=3
// file ../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_common.h line 42
enum anonymous$12 { RBT_GENKEY=0, RBT_STRKEY=1, RBT_I32KEY=2, RBT_I64KEY=3 };

// #anon_enum$RBT_WALK_PREORDER=1$RBT_WALK_INORDER=2$RBT_WALK_POSTORDER=3$RBT_WALK_LEVELORDER=4$RBT_WALK_RAWNODE=16
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_common.h line 49
enum anonymous$47 { RBT_WALK_PREORDER=1, RBT_WALK_INORDER=2, RBT_WALK_POSTORDER=3, RBT_WALK_LEVELORDER=4, RBT_WALK_RAWNODE=16 };

// #anon_enum$SYSCHAR_FLAG_UNKNOWN=0$SYSCHAR_FLAG_ERROR=1$SYSCHAR_FLAG_COMPLETE=2$SYSCHAR_FLAG_INCOMPLETE=3$SYSCHAR_FLAG_DOES_NOT_EXIST=4$SYSCHAR_FLAG_NOT_COLLECTED=5$SYSCHAR_FLAG_NOT_APPLICABLE=6
// file ../../../../src/OVAL/public/oval_system_characteristics.h line 49
enum anonymous$8 { SYSCHAR_FLAG_UNKNOWN=0, SYSCHAR_FLAG_ERROR=1, SYSCHAR_FLAG_COMPLETE=2, SYSCHAR_FLAG_INCOMPLETE=3, SYSCHAR_FLAG_DOES_NOT_EXIST=4, SYSCHAR_FLAG_NOT_COLLECTED=5, SYSCHAR_FLAG_NOT_APPLICABLE=6 };

// #anon_enum$SYSCHAR_STATUS_UNKNOWN=0$SYSCHAR_STATUS_ERROR=1$SYSCHAR_STATUS_EXISTS=2$SYSCHAR_STATUS_DOES_NOT_EXIST=3$SYSCHAR_STATUS_NOT_COLLECTED=4
// file ../../../../../src/OVAL/public/oval_system_characteristics.h line 60
enum anonymous$33 { SYSCHAR_STATUS_UNKNOWN=0, SYSCHAR_STATUS_ERROR=1, SYSCHAR_STATUS_EXISTS=2, SYSCHAR_STATUS_DOES_NOT_EXIST=3, SYSCHAR_STATUS_NOT_COLLECTED=4 };

// #anon_enum$XML_ATTRIBUTE_CDATA=1$XML_ATTRIBUTE_ID=2$XML_ATTRIBUTE_IDREF=3$XML_ATTRIBUTE_IDREFS=4$XML_ATTRIBUTE_ENTITY=5$XML_ATTRIBUTE_ENTITIES=6$XML_ATTRIBUTE_NMTOKEN=7$XML_ATTRIBUTE_NMTOKENS=8$XML_ATTRIBUTE_ENUMERATION=9$XML_ATTRIBUTE_NOTATION=10
// file /usr/include/libxml2/libxml/tree.h line 206
enum anonymous$4 { XML_ATTRIBUTE_CDATA=1, XML_ATTRIBUTE_ID=2, XML_ATTRIBUTE_IDREF=3, XML_ATTRIBUTE_IDREFS=4, XML_ATTRIBUTE_ENTITY=5, XML_ATTRIBUTE_ENTITIES=6, XML_ATTRIBUTE_NMTOKEN=7, XML_ATTRIBUTE_NMTOKENS=8, XML_ATTRIBUTE_ENUMERATION=9, XML_ATTRIBUTE_NOTATION=10 };

// #anon_enum$XML_BUFFER_ALLOC_DOUBLEIT=0$XML_BUFFER_ALLOC_EXACT=1$XML_BUFFER_ALLOC_IMMUTABLE=2$XML_BUFFER_ALLOC_IO=3$XML_BUFFER_ALLOC_HYBRID=4$XML_BUFFER_ALLOC_BOUNDED=5
// file /usr/include/libxml2/libxml/tree.h line 74
enum anonymous$35 { XML_BUFFER_ALLOC_DOUBLEIT=0, XML_BUFFER_ALLOC_EXACT=1, XML_BUFFER_ALLOC_IMMUTABLE=2, XML_BUFFER_ALLOC_IO=3, XML_BUFFER_ALLOC_HYBRID=4, XML_BUFFER_ALLOC_BOUNDED=5 };

// #anon_enum$XML_ELEMENT_NODE=1$XML_ATTRIBUTE_NODE=2$XML_TEXT_NODE=3$XML_CDATA_SECTION_NODE=4$XML_ENTITY_REF_NODE=5$XML_ENTITY_NODE=6$XML_PI_NODE=7$XML_COMMENT_NODE=8$XML_DOCUMENT_NODE=9$XML_DOCUMENT_TYPE_NODE=10$XML_DOCUMENT_FRAG_NODE=11$XML_NOTATION_NODE=12$XML_HTML_DOCUMENT_NODE=13$XML_DTD_NODE=14$XML_ELEMENT_DECL=15$XML_ATTRIBUTE_DECL=16$XML_ENTITY_DECL=17$XML_NAMESPACE_DECL=18$XML_XINCLUDE_START=19$XML_XINCLUDE_END=20$XML_DOCB_DOCUMENT_NODE=21
// file /usr/include/libxml2/libxml/tree.h line 159
enum anonymous$3 { XML_ELEMENT_NODE=1, XML_ATTRIBUTE_NODE=2, XML_TEXT_NODE=3, XML_CDATA_SECTION_NODE=4, XML_ENTITY_REF_NODE=5, XML_ENTITY_NODE=6, XML_PI_NODE=7, XML_COMMENT_NODE=8, XML_DOCUMENT_NODE=9, XML_DOCUMENT_TYPE_NODE=10, XML_DOCUMENT_FRAG_NODE=11, XML_NOTATION_NODE=12, XML_HTML_DOCUMENT_NODE=13, XML_DTD_NODE=14, XML_ELEMENT_DECL=15, XML_ATTRIBUTE_DECL=16, XML_ENTITY_DECL=17, XML_NAMESPACE_DECL=18, XML_XINCLUDE_START=19, XML_XINCLUDE_END=20, XML_DOCB_DOCUMENT_NODE=21 };

// #anon_enum$XML_ERR_NONE=0$XML_ERR_WARNING=1$XML_ERR_ERROR=2$XML_ERR_FATAL=3
// file /usr/include/libxml2/libxml/xmlerror.h line 24
enum anonymous$5 { XML_ERR_NONE=0, XML_ERR_WARNING=1, XML_ERR_ERROR=2, XML_ERR_FATAL=3 };

// tag-#anon#ST[*{*{SYM#tag-#anon#ST[U32'sid'||U32'$pad0'||U64'tid'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'msg_handler'||*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$'msg'|]#}$SYM#tag-#anon#ST[U32'sid'||U32'$pad0'||U64'tid'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'msg_handler'||*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$'msg'|]#$}$*{SYM#tag-#anon#ST[U32'sid'||U32'$pad0'||U64'tid'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'msg_handler'||*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$'msg'|]#}$SYM#tag-#anon#ST[U32'sid'||U32'$pad0'||U64'tid'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'msg_handler'||*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$'msg'|]#$$'thr'||U64'cnt'|]
// file ../../../../../src/OVAL/probes/probe/signal_handler.c line 42
struct anonymous$46;

// tag-#anon#ST[*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'item'||U16'count'||U48'$pad0'|]
// file ../../../../../src/OVAL/probes/probe/icache.h line 56
struct anonymous$51;

// tag-#anon#ST[*{S32()->S32}$S32()->S32$'distrop'||*{S32(*{SYM#tag-runlevel_req#}$SYM#tag-runlevel_req#$|*{*{SYM#tag-runlevel_rep#}$SYM#tag-runlevel_rep#$}$*{SYM#tag-runlevel_rep#}$SYM#tag-runlevel_rep#$$)->S32}$S32(*{SYM#tag-runlevel_req#}$SYM#tag-runlevel_req#$|*{*{SYM#tag-runlevel_rep#}$SYM#tag-runlevel_rep#$}$*{SYM#tag-runlevel_rep#}$SYM#tag-runlevel_rep#$$)->S32$'get_runlevel'|]
// file ../../../../src/OVAL/probes/unix/runlevel.c line 303
struct anonymous$16;

// tag-#anon#ST[*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$'probe'||*{SYM#tag-#anon#ST[U32'sid'||U32'$pad0'||U64'tid'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'msg_handler'||*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$'msg'|]#}$SYM#tag-#anon#ST[U32'sid'||U32'$pad0'||U64'tid'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'msg_handler'||*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$'msg'|]#$'pth'|]
// file ../../../../../src/OVAL/probes/probe/worker.h line 45
struct anonymous$32;

// tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]
// file ../../../../src/OVAL/probes/probe/icache.h line 33
struct anonymous$14;

// tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]
// file ../../../../../src/OVAL/probes/probe/rcache.h line 32
struct anonymous$21;

// tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]
// file ../../../../src/OVAL/probes/probe/icache.h line 41
struct anonymous$15;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$43;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$41;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$24;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous$30;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous$29;

// tag-#anon#ST[EN#anon_enum$OVAL_DATATYPE_UNKNOWN=0$OVAL_DATATYPE_BINARY=1$OVAL_DATATYPE_BOOLEAN=2$OVAL_DATATYPE_EVR_STRING=3$OVAL_DATATYPE_FILESET_REVISION=4$OVAL_DATATYPE_FLOAT=5$OVAL_DATATYPE_INTEGER=6$OVAL_DATATYPE_IOS_VERSION=7$OVAL_DATATYPE_IPV4ADDR=8$OVAL_DATATYPE_IPV6ADDR=9$OVAL_DATATYPE_RECORD=10$OVAL_DATATYPE_SEXP=11$OVAL_DATATYPE_STRING=12$OVAL_DATATYPE_STRING_M=13$OVAL_DATATYPE_VERSION=14$OVAL_DATATYPE_DEBIAN_EVR_STRING=15#{U32}$U32$'type'||U32'$pad0'||*{V}$V$'value'|]
// file ../../../../src/OVAL/probes/public/probe-api.h line 506
struct anonymous$11;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$6;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous$26;

// tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]
// file ../../../../../src/OVAL/probes/probe/option.h line 15
struct anonymous$1;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$37;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$40;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$39;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$45;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$38;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$42;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]
// file ../../../../../src/OVAL/probes/probe/ncache.h line 36
struct anonymous$22;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]
// file ../../../../../src/OVAL/probes/probe/probe.h line 39
struct anonymous$23;

// tag-#anon#ST[U32'sid'||U32'$pad0'||U64'tid'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$(*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'rwlock'||U32'flags'||U32'$pad0'||*{S8}$S8$'name'||S32'pid'||U32'$pad1'||*{V}$V$'probe_arg'||S32'probe_exitcode'||U32'$pad2'||*{SYM#tag-SEAP_CTX#}$SYM#tag-SEAP_CTX#$'SEAP_ctx'||S32'sd'||U32'$pad3'||U64'th_input'||U64'th_signal'||*{SYM#tag-rbt#}$SYM#tag-rbt#$'workers'||U32'max_threads'||U32'max_chdepth'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'|]#$'rcache'||*{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'lock'||*{*{SYM#tag-SEXP#}$SYM#tag-SEXP#$}$*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'name'||U64'real'||U64'size'|]#$'ncache'||*{SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#}$SYM#tag-#anon#ST[*{SYM#tag-rbt#}$SYM#tag-rbt#$'tree'||U64'thid'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'queue_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notempty'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'queue_notfull'||ARR1024{SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#}$SYM#tag-#anon#ST[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'cobj'||SYM#tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]#'p'|]#$'queue'||U16'queue_beg'||U16'queue_end'||U16'queue_cnt'||U16'queue_max'|]#$'icache'||*{SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#}$SYM#tag-#anon#ST[S32'option'||U32'$pad0'||*{S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32}$S32(S32|S32|*{*{V}$V$}$*{V}$V$$)->S32$'handler'|]#$'option'||U64'optcnt'|]#$|*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$|*{S32}$S32$)->*{SYM#tag-SEXP#}$SYM#tag-SEXP#$$'msg_handler'||*{SYM#tag-SEAP_msg#}$SYM#tag-SEAP_msg#$'msg'|]
// file ../../../../../src/OVAL/probes/probe/worker.h line 38
struct anonymous$31;

// tag-#anon#UN[*{SYM#tag-SEXP#}$SYM#tag-SEXP#$'item'||*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#$'cond'|]
// file ../../../../src/OVAL/probes/probe/icache.h line 35
union anonymous$13;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$50;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$44;

// tag-#anon#UN[ARR32{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous$27;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$0;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$7;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous$20;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-FTW
// file /usr/include/ftw.h line 105
struct FTW;

// tag-SEAP_CTX
// file ../../../../../src/OVAL/probes/SEAP/public/seap-types.h line 34
struct SEAP_CTX;

// tag-SEAP_msg
// file ../../../../../src/OVAL/probes/SEAP/public/seap-message.h line 41
struct SEAP_msg;

// tag-SEXP
// file ../../../../src/OVAL/probes/SEAP/public/sexp-types.h line 82
struct SEXP;

// tag-SEXP_list_it
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 463
struct SEXP_list_it;

// tag-UConverter
// file /usr/include/x86_64-linux-gnu/unicode/ucnv_err.h line 91
struct UConverter;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_oresults
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 453
struct _oresults;

// tag-_uconv_t
// file /usr/include/libxml2/libxml/encoding.h line 132
struct _uconv_t;

// tag-_xmlAttr
// file /usr/include/libxml2/libxml/tree.h line 432
struct _xmlAttr;

// tag-_xmlBuf
// file /usr/include/libxml2/libxml/tree.h line 105
struct _xmlBuf;

// tag-_xmlBuffer
// file /usr/include/libxml2/libxml/tree.h line 89
struct _xmlBuffer;

// tag-_xmlCharEncodingHandler
// file /usr/include/libxml2/libxml/encoding.h line 139
struct _xmlCharEncodingHandler;

// tag-_xmlDict
// file /usr/include/libxml2/libxml/dict.h line 25
struct _xmlDict;

// tag-_xmlDoc
// file /usr/include/libxml2/libxml/tree.h line 262
struct _xmlDoc;

// tag-_xmlDtd
// file /usr/include/libxml2/libxml/tree.h line 259
struct _xmlDtd;

// tag-_xmlError
// file /usr/include/libxml2/libxml/xmlerror.h line 76
struct _xmlError;

// tag-_xmlNode
// file /usr/include/libxml2/libxml/tree.h line 257
struct _xmlNode;

// tag-_xmlNs
// file /usr/include/libxml2/libxml/tree.h line 387
struct _xmlNs;

// tag-_xmlOutputBuffer
// file /usr/include/libxml2/libxml/tree.h line 31
struct _xmlOutputBuffer;

// tag-_xmlTextReader
// file /usr/include/libxml2/libxml/xmlreader.h line 99
struct _xmlTextReader;

// tag-_xmlTextWriter
// file /usr/include/libxml2/libxml/xmlwriter.h line 26
struct _xmlTextWriter;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-err_queue
// file ../../../src/common/err_queue.h line 36
struct err_queue;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-oscap_buffer
// file ../../../src/common/oscap_buffer.h line 29
struct oscap_buffer;

// tag-oscap_document_type
// file ../../../src/common/public/oscap.h line 84
enum oscap_document_type { OSCAP_DOCUMENT_UNKNOWN=0, OSCAP_DOCUMENT_OVAL_DEFINITIONS=1, OSCAP_DOCUMENT_OVAL_VARIABLES=2, OSCAP_DOCUMENT_OVAL_SYSCHAR=3, OSCAP_DOCUMENT_OVAL_RESULTS=4, OSCAP_DOCUMENT_OVAL_DIRECTIVES=5, OSCAP_DOCUMENT_XCCDF=6, OSCAP_DOCUMENT_CPE_LANGUAGE=7, OSCAP_DOCUMENT_CPE_DICTIONARY=8, OSCAP_DOCUMENT_CVE_FEED=9, OSCAP_DOCUMENT_SCE_RESULT=10, OSCAP_DOCUMENT_SDS=11, OSCAP_DOCUMENT_ARF=12, OSCAP_DOCUMENT_XCCDF_TAILORING=13 };

// tag-oscap_err_t
// file ../../../src/common/_error.h line 40
struct oscap_err_t;

// tag-oscap_htable
// file ../../../src/common/list.h line 183
struct oscap_htable;

// tag-oscap_htable_item
// file ../../../src/common/list.h line 176
struct oscap_htable_item;

// tag-oscap_htable_iterator
// file ../../../src/common/list.h line 247
struct oscap_htable_iterator;

// tag-oscap_iterator
// file ../../../src/common/list.h line 84
struct oscap_iterator;

// tag-oscap_list
// file ../../../src/common/list.h line 54
struct oscap_list;

// tag-oscap_list_item
// file ../../../src/common/list.h line 49
struct oscap_list_item;

// tag-oscap_reference
// file ../../../src/common/public/oscap_reference.h line 31
struct oscap_reference;

// tag-oscap_reference_iterator
// file ../../../src/common/public/oscap_reference.h line 34
struct oscap_reference_iterator;

// tag-oscap_source
// file ../../../src/source/public/oscap_source.h line 56
struct oscap_source;

// tag-oscap_string
// file ../../../src/common/oscap_string.h line 32
struct oscap_string;

// tag-oscap_string_iterator
// file ../../../src/common/public/oscap_text.h line 105
struct oscap_string_iterator;

// tag-oscap_string_map
// file ../../../src/common/util.h line 309
struct oscap_string_map;

// tag-oscap_stringlist
// file ../../../src/common/public/oscap_text.h line 65
struct oscap_stringlist;

// tag-oscap_stringlist_iterator
// file ../../../src/common/public/oscap_text.h line 220
struct oscap_stringlist_iterator;

// tag-oscap_text
// file ../../../src/common/public/oscap_text.h line 59
struct oscap_text;

// tag-oscap_text_iterator
// file ../../../src/common/public/oscap_text.h line 184
struct oscap_text_iterator;

// tag-oscap_text_traits
// file ../../../src/common/text_priv.h line 39
struct oscap_text_traits;

// tag-oscap_tsort_context
// file ../../../src/common/tsort.c line 32
struct oscap_tsort_context;

// tag-oval_sysent
// file ../../../../src/OVAL/public/oval_system_characteristics.h line 160
struct oval_sysent;

// tag-pcre_extra
// file /usr/include/pcre.h line 376
struct pcre_extra;

// tag-probe_ctx
// file ../../../../src/OVAL/probes/public/probe-api.h line 474
struct probe_ctx;

// tag-probe_varref_ctx
// file ../../../../../src/OVAL/probes/probe/worker.c line 150
struct probe_varref_ctx;

// tag-probe_varref_ctx_ent
// file ../../../../../src/OVAL/probes/probe/worker.c line 153
struct probe_varref_ctx_ent;

// tag-proc_memusage
// file ../../../../../src/common/memusage.h line 11
struct proc_memusage;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-rbt
// file ../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_common.h line 129
struct rbt;

// tag-rbt_i32_node
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i32.h line 27
struct rbt_i32_node;

// tag-rbt_i64_node
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i64.h line 27
struct rbt_i64_node;

// tag-rbt_node
// file ../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_common.h line 64
struct rbt_node;

// tag-real_pcre
// file /usr/include/pcre.h line 324
struct real_pcre;

// tag-runlevel_rep
// file ../../../../src/OVAL/probes/unix/runlevel.c line 77
struct runlevel_rep;

// tag-runlevel_req
// file ../../../../src/OVAL/probes/unix/runlevel.c line 72
struct runlevel_req;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stat_parser
// file ../../../src/common/memusage.c line 63
struct stat_parser;

// tag-sys_memusage
// file ../../../../../src/common/memusage.h line 21
struct sys_memusage;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/wchar.h line 137
struct tm;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// SEAP_CTX_free
// file ../../../../../src/OVAL/probes/SEAP/public/seap.h line 52
void SEAP_CTX_free(struct SEAP_CTX *);
// SEAP_CTX_new
// file ../../../../../src/OVAL/probes/SEAP/public/seap.h line 50
struct SEAP_CTX * SEAP_CTX_new(void);
// SEAP_close
// file ../../../../../src/OVAL/probes/SEAP/public/seap.h line 61
signed int SEAP_close(struct SEAP_CTX *, signed int);
// SEAP_cmd_exec
// file ../../../../../src/OVAL/probes/SEAP/public/seap-command.h line 59
struct SEXP * SEAP_cmd_exec(struct SEAP_CTX *, signed int, unsigned int, unsigned short int, struct SEXP *, unsigned char, struct SEXP * (*)(struct SEXP *, void *), void *);
// SEAP_cmd_register
// file ../../../../../src/OVAL/probes/SEAP/public/seap-command.h line 49
signed int SEAP_cmd_register(struct SEAP_CTX *, unsigned short int, unsigned int, struct SEXP * (*)(struct SEXP *, void *), ...);
// SEAP_msg_free
// file ../../../../../src/OVAL/probes/SEAP/public/seap-message.h line 46
void SEAP_msg_free(struct SEAP_msg *);
// SEAP_msg_get
// file ../../../../../src/OVAL/probes/SEAP/public/seap-message.h line 52
struct SEXP * SEAP_msg_get(struct SEAP_msg *);
// SEAP_msg_id
// file ../../../../../src/OVAL/probes/SEAP/public/seap-message.h line 48
unsigned int SEAP_msg_id(struct SEAP_msg *);
// SEAP_msg_new
// file ../../../../../src/OVAL/probes/SEAP/public/seap-message.h line 44
struct SEAP_msg * SEAP_msg_new(void);
// SEAP_msg_set
// file ../../../../../src/OVAL/probes/SEAP/public/seap-message.h line 50
signed int SEAP_msg_set(struct SEAP_msg *, struct SEXP *);
// SEAP_openfd2
// file ../../../../../src/OVAL/probes/SEAP/public/seap.h line 64
signed int SEAP_openfd2(struct SEAP_CTX *, signed int, signed int, unsigned int);
// SEAP_recvmsg
// file ../../../../../src/OVAL/probes/SEAP/public/seap.h line 75
signed int SEAP_recvmsg(struct SEAP_CTX *, signed int, struct SEAP_msg **);
// SEAP_reply
// file ../../../../../src/OVAL/probes/SEAP/public/seap.h line 80
signed int SEAP_reply(struct SEAP_CTX *, signed int, struct SEAP_msg *, struct SEAP_msg *);
// SEAP_replyerr
// file ../../../../../src/OVAL/probes/SEAP/public/seap.h line 86
signed int SEAP_replyerr(struct SEAP_CTX *, signed int, struct SEAP_msg *, unsigned int);
// SEXP_ID_v
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-ID.h line 33
unsigned long int SEXP_ID_v(const struct SEXP *);
// SEXP_deepcmp
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 535
_Bool SEXP_deepcmp(const struct SEXP *, const struct SEXP *);
// SEXP_fprintfa
// file ../../../src/OVAL/probes/SEAP/public/sexp-output.h line 38
unsigned long int SEXP_fprintfa(struct _IO_FILE *, const struct SEXP *);
// SEXP_free
// file ../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 558
void SEXP_free(struct SEXP *);
// SEXP_free_r
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip_r.h line 65
void SEXP_free_r(struct SEXP *);
// SEXP_list_add
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 382
struct SEXP * SEXP_list_add(struct SEXP *, const struct SEXP *);
// SEXP_list_first
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 352
struct SEXP * SEXP_list_first(const struct SEXP *);
// SEXP_list_it_free
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 467
void SEXP_list_it_free(struct SEXP_list_it *);
// SEXP_list_it_new
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 465
struct SEXP_list_it * SEXP_list_it_new(const struct SEXP *);
// SEXP_list_it_next
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 466
struct SEXP * SEXP_list_it_next(struct SEXP_list_it *);
// SEXP_list_join
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 390
struct SEXP * SEXP_list_join(const struct SEXP *, const struct SEXP *);
// SEXP_list_length
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 345
unsigned long int SEXP_list_length(const struct SEXP *);
// SEXP_list_new
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 327
struct SEXP * SEXP_list_new(struct SEXP *, ...);
// SEXP_list_nth
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 374
struct SEXP * SEXP_list_nth(const struct SEXP *, unsigned int);
// SEXP_list_replace
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 420
struct SEXP * SEXP_list_replace(struct SEXP *, unsigned int, const struct SEXP *);
// SEXP_list_rest
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 359
struct SEXP * SEXP_list_rest(const struct SEXP *);
// SEXP_list_rest_r
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip_r.h line 60
struct SEXP * SEXP_list_rest_r(struct SEXP *, const struct SEXP *);
// SEXP_list_sort
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 410
struct SEXP * SEXP_list_sort(struct SEXP *, signed int (*)(const struct SEXP *, const struct SEXP *));
// SEXP_listref_first
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 427
struct SEXP * SEXP_listref_first(struct SEXP *);
// SEXP_listref_nth
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 449
struct SEXP * SEXP_listref_nth(struct SEXP *, unsigned int);
// SEXP_number_getf
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 185
double SEXP_number_getf(const struct SEXP *);
// SEXP_number_geti_32
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 119
signed int SEXP_number_geti_32(const struct SEXP *);
// SEXP_number_geti_64
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 161
signed long int SEXP_number_geti_64(const struct SEXP *);
// SEXP_number_getu_32
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 149
unsigned int SEXP_number_getu_32(const struct SEXP *);
// SEXP_number_newi_32
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 107
struct SEXP * SEXP_number_newi_32(signed int);
// SEXP_number_newu_32
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 137
struct SEXP * SEXP_number_newu_32(unsigned int);
// SEXP_ref
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 506
struct SEXP * SEXP_ref(const struct SEXP *);
// SEXP_refcmp
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 533
signed int SEXP_refcmp(const struct SEXP *, const struct SEXP *);
// SEXP_softref
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 514
struct SEXP * SEXP_softref(struct SEXP *);
// SEXP_string_cmp
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 309
signed int SEXP_string_cmp(const struct SEXP *, const struct SEXP *);
// SEXP_string_cstr
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 280
char * SEXP_string_cstr(const struct SEXP *);
// SEXP_string_cstr_r
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 289
unsigned long int SEXP_string_cstr_r(const struct SEXP *, char *, unsigned long int);
// SEXP_string_new
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 228
struct SEXP * SEXP_string_new(const void *, unsigned long int);
// SEXP_string_newf
// file ../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 235
struct SEXP * SEXP_string_newf(const char *, ...);
// SEXP_string_newf_r
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip_r.h line 54
struct SEXP * SEXP_string_newf_r(struct SEXP *, const char *, ...);
// SEXP_strtype
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 613
const char * SEXP_strtype(const struct SEXP *);
// SEXP_typeof
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 607
unsigned char SEXP_typeof(const struct SEXP *);
// __SEXP_vfree
// file ../../../../../src/OVAL/probes/SEAP/public/sexp-manip.h line 566
void __SEXP_vfree(signed int, struct SEXP *, ...);
// __abort_cb
// file ../../../../../src/OVAL/probes/probe/signal_handler.c line 47
static signed int __abort_cb(void *n, void *u);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __oscap_alloc
// file ../../../../src/common/alloc.h line 49
void * __oscap_alloc(unsigned long int s);
// __oscap_calloc
// file ../../../src/common/alloc.c line 61
void * __oscap_calloc(unsigned long int n, unsigned long int s);
// __oscap_debuglog_close
// file ../../../src/common/debug.c line 75
static void __oscap_debuglog_close(void);
// __oscap_debuglog_object
// file ../../../../../src/common/debug_priv.h line 69
void __oscap_debuglog_object(const char *file, const char *fn, unsigned long int line, signed int objtype, void *obj);
// __oscap_dlprintf
// file ../../../../src/common/debug_priv.h line 60
void __oscap_dlprintf(signed int level, const char *file, const char *fn, unsigned long int line, const char *fmt, ...);
// __oscap_err_check
// file ../../../src/common/alloc.c line 37
static void __oscap_err_check(void *m);
// __oscap_free
// file ../../../../src/common/alloc.h line 73
void __oscap_free(void *p);
// __oscap_path_rstrip
// file ../../../src/common/debug.c line 125
static const char * __oscap_path_rstrip(const char *path);
// __oscap_realloc
// file ../../../../../src/common/alloc.h line 61
void * __oscap_realloc(void *p, unsigned long int s);
// __oscap_reallocf
// file ../../../src/common/alloc.c line 90
void * __oscap_reallocf(void *p, unsigned long int s);
// __oscap_seterr
// file ../../../src/common/_error.h line 58
void __oscap_seterr(const char *file, unsigned int line, const char *func, unsigned short int family, ...);
// __oscap_setxmlerr
// file ../../../src/common/_error.h line 38
void __oscap_setxmlerr(const char *file, unsigned int line, const char *func, struct _xmlError *error);
// __probe_icache_add_nolock
// file ../../../../../src/OVAL/probes/probe/icache.c line 313
static signed int __probe_icache_add_nolock(struct anonymous$15 *cache, struct SEXP *cobj, struct SEXP *item, union anonymous$7 *cond);
// __probe_option_op
// file ../../../../../src/OVAL/probes/probe/option.c line 11
static signed int __probe_option_op(signed int option, signed int op, void **ap);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$30 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$30 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$30 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __unlink_cb
// file ../../../src/common/oscap_acquire.c line 64
static signed int __unlink_cb(const char *fpath, struct stat *sb, signed int typeflag, struct FTW *ftwbuf);
// __xpg_basename
// file /usr/include/libgen.h line 34
extern char * __xpg_basename(char *);
// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void);
// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void);
// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void);
// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void);
// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void);
// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void);
// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void);
// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void);
// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void);
// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void);
// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void);
// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void);
// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void);
// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void);
// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void);
// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void);
// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void);
// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void);
// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void);
// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void);
// _oscap_iterator_has_more_internal
// file ../../../src/common/list.c line 315
static inline _Bool _oscap_iterator_has_more_internal(struct oscap_iterator *it);
// _probe_entste_cmp_record
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 292
static enum anonymous$18 _probe_entste_cmp_record(struct SEXP *ent_ste, struct SEXP *ent_itm);
// _push_err
// file ../../../src/common/error.c line 69
static inline void _push_err(struct oscap_err_t *err);
// _xhtml_to_plaintext
// file ../../../src/common/text.c line 176
char * _xhtml_to_plaintext(const char *xhtml_in);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// cmp_float
// file ../../../../src/OVAL/results/oval_cmp_basic.c line 79
static inline signed int cmp_float(double a, double b);
// cmpkey
// file ../../../src/common/memusage.c line 69
static signed int cmpkey(const char *a, struct stat_parser *b);
// compare_values
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 105
static signed int compare_values(const char *str1, const char *str2);
// cstr_to_double
// file ../../../../src/OVAL/results/oval_cmp.c line 68
static _Bool cstr_to_double(const char *cstr, double *result);
// cstr_to_intmax
// file ../../../../src/OVAL/results/oval_cmp.c line 45
static _Bool cstr_to_intmax(const char *cstr, signed long int *result);
// curl_easy_cleanup
// file /usr/include/curl/easy.h line 31
void curl_easy_cleanup(void *);
// curl_easy_escape
// file /usr/include/curl/curl.h line 1965
char * curl_easy_escape(void *, const char *, signed int);
// curl_easy_init
// file /usr/include/curl/easy.h line 28
void * curl_easy_init(void);
// curl_easy_perform
// file /usr/include/curl/easy.h line 30
enum anonymous$28 curl_easy_perform(void *);
// curl_easy_setopt
// file /usr/include/curl/easy.h line 29
enum anonymous$28 curl_easy_setopt(void *, enum anonymous$19, ...);
// curl_easy_strerror
// file /usr/include/curl/curl.h line 2352
const char * curl_easy_strerror(enum anonymous$28);
// curl_free
// file /usr/include/curl/curl.h line 2002
void curl_free(void *);
// curl_global_cleanup
// file /usr/include/curl/curl.h line 2044
void curl_global_cleanup(void);
// curl_global_init
// file /usr/include/curl/curl.h line 2014
enum anonymous$28 curl_global_init(signed long int);
// debug_message_devel_metadata
// file ../../../src/common/debug.c line 169
static void debug_message_devel_metadata(const char *file, const char *fn, unsigned long int line);
// debug_message_end
// file ../../../src/common/debug.c line 186
static void debug_message_end();
// debug_message_start
// file ../../../src/common/debug.c line 136
static void debug_message_start(signed int level);
// dirfd
// file /usr/include/dirent.h line 223
extern signed int dirfd(struct __dirstream *);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// err_queue_free
// file ../../../src/common/err_queue.c line 91
void err_queue_free(struct err_queue *q, void (*destructor)(void *));
// err_queue_free::destructor$object
// 
void destructor$object(void *);
// err_queue_get_last
// file ../../../src/common/err_queue.c line 82
struct oscap_err_t * err_queue_get_last(struct err_queue *q);
// err_queue_is_empty
// file ../../../src/common/err_queue.c line 59
_Bool err_queue_is_empty(struct err_queue *q);
// err_queue_new
// file ../../../src/common/err_queue.c line 35
struct err_queue * err_queue_new(void);
// err_queue_pop_first
// file ../../../src/common/err_queue.c line 68
struct oscap_err_t * err_queue_pop_first(struct err_queue *q);
// err_queue_push
// file ../../../src/common/err_queue.c line 40
_Bool err_queue_push(struct err_queue *q, struct oscap_err_t *error);
// err_queue_to_string
// file ../../../src/common/err_queue.c line 102
signed int err_queue_to_string(struct err_queue *q, char **result);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exsltRegisterAll
// file /usr/include/libexslt/exslt.h line 87
void exsltRegisterAll(void);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fail
// file ../../../../../src/OVAL/probes/probe/main.c line 48
static signed int fail(signed int err, const char *who, signed int line);
// fchdir
// file /usr/include/unistd.h line 501
extern signed int fchdir(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// flock
// file /usr/include/x86_64-linux-gnu/sys/file.h line 51
extern signed int flock(signed int, signed int);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_runlevel
// file ../../../../src/OVAL/probes/unix/runlevel.c line 343
static signed int get_runlevel(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_arch
// file ../../../../src/OVAL/probes/unix/runlevel.c line 225
static signed int get_runlevel_arch(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_common
// file ../../../../src/OVAL/probes/unix/runlevel.c line 240
static signed int get_runlevel_common(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_debian
// file ../../../../src/OVAL/probes/unix/runlevel.c line 210
static signed int get_runlevel_debian(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_generic
// file ../../../../src/OVAL/probes/unix/runlevel.c line 322
static signed int get_runlevel_generic(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_gentoo
// file ../../../../src/OVAL/probes/unix/runlevel.c line 220
static signed int get_runlevel_gentoo(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_mandriva
// file ../../../../src/OVAL/probes/unix/runlevel.c line 230
static signed int get_runlevel_mandriva(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_slack
// file ../../../../src/OVAL/probes/unix/runlevel.c line 215
static signed int get_runlevel_slack(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_suse
// file ../../../../src/OVAL/probes/unix/runlevel.c line 235
static signed int get_runlevel_suse(struct runlevel_req *req, struct runlevel_rep **rep);
// get_runlevel_sysv
// file ../../../../src/OVAL/probes/unix/runlevel.c line 88
static signed int get_runlevel_sysv(struct runlevel_req *req, struct runlevel_rep **rep);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// ipaddr_cmp
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 53
static inline signed int ipaddr_cmp(signed int af, const void *addr1, const void *addr2);
// ipaddr_mask
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 63
static inline void ipaddr_mask(signed int af, const void *ip_addr, unsigned int mask);
// ipaddr_parse
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 74
static inline signed int ipaddr_parse(signed int af, const char *oval_ip_string, unsigned int *mask_out, void *ip_out);
// ipv4addr_mask
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 227
static inline void ipv4addr_mask(struct in_addr *ip_addr, unsigned int netmask);
// ipv4addr_parse
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 196
static inline signed int ipv4addr_parse(const char *oval_ipv4_string, unsigned int *netmask_out, struct in_addr *ip_out);
// ipv6addr_mask
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 255
static inline void ipv6addr_mask(struct in6_addr *addr, signed int prefix_len);
// ipv6addr_parse
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 232
static inline signed int ipv6addr_parse(const char *oval_ipv6_string, unsigned int *len_out, struct in6_addr *ip_out);
// is_arch
// file ../../../../src/OVAL/probes/unix/runlevel.c line 272
static signed int is_arch(void);
// is_common
// file ../../../../src/OVAL/probes/unix/runlevel.c line 298
static signed int is_common(void);
// is_debian
// file ../../../../src/OVAL/probes/unix/runlevel.c line 253
static signed int is_debian(void);
// is_gentoo
// file ../../../../src/OVAL/probes/unix/runlevel.c line 266
static signed int is_gentoo(void);
// is_mandriva
// file ../../../../src/OVAL/probes/unix/runlevel.c line 278
static signed int is_mandriva(void);
// is_redhat
// file ../../../../src/OVAL/probes/unix/runlevel.c line 247
static signed int is_redhat(void);
// is_slack
// file ../../../../src/OVAL/probes/unix/runlevel.c line 260
static signed int is_slack(void);
// is_solaris
// file ../../../../src/OVAL/probes/unix/runlevel.c line 292
static signed int is_solaris(void);
// is_suse
// file ../../../../src/OVAL/probes/unix/runlevel.c line 284
static signed int is_suse(void);
// istrcmp
// file ../../../../src/OVAL/results/oval_cmp_basic.c line 118
static signed int istrcmp(const char *st1, const char *st2);
// lookup_xsi_ns
// file ../../../src/common/elements.c line 257
struct _xmlNs * lookup_xsi_ns(struct _xmlDoc *doc);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkdtemp
// file /usr/include/stdlib.h line 662
extern char * mkdtemp(char *);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// mktime
// file /usr/include/time.h line 199
extern signed long int mktime(struct tm *);
// nftw
// file /usr/include/ftw.h line 158
extern signed int nftw(const char *, signed int (*)(const char *, struct stat *, signed int, struct FTW *), signed int, signed int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// oscap_acquire_cleanup_dir
// file ../../../src/common/oscap_acquire.c line 75
void oscap_acquire_cleanup_dir(char **dir_path);
// oscap_acquire_ensure_parent_dir
// file ../../../src/common/oscap_acquire.c line 257
signed int oscap_acquire_ensure_parent_dir(const char *filepath);
// oscap_acquire_guess_realpath
// file ../../../src/common/oscap_acquire.c line 204
char * oscap_acquire_guess_realpath(const char *filepath);
// oscap_acquire_mkdir_p
// file ../../../src/common/oscap_acquire.c line 224
signed int oscap_acquire_mkdir_p(const char *path);
// oscap_acquire_pipe_to_string
// file ../../../src/common/oscap_acquire.c line 183
char * oscap_acquire_pipe_to_string(signed int fd);
// oscap_acquire_temp_dir
// file ../../../src/common/oscap_acquire.c line 52
char * oscap_acquire_temp_dir(void);
// oscap_acquire_temp_file
// file ../../../src/common/oscap_acquire.c line 86
signed int oscap_acquire_temp_file(const char *dir, const char *template, char **filename);
// oscap_acquire_url_download
// file ../../../src/common/oscap_acquire.c line 146
char * oscap_acquire_url_download(const char *url, unsigned long int *memory_size);
// oscap_acquire_url_is_supported
// file ../../../src/common/oscap_acquire.c line 109
_Bool oscap_acquire_url_is_supported(const char *url);
// oscap_acquire_url_to_filename
// file ../../../src/common/oscap_acquire.c line 115
char * oscap_acquire_url_to_filename(const char *url);
// oscap_apply_xslt
// file ../../../src/common/oscapxml.c line 145
signed int oscap_apply_xslt(const char *xmlfile, const char *xsltfile, const char *outfile, const char **params);
// oscap_bfind
// file ../../../../../src/common/bfind.h line 32
void * oscap_bfind(void *ptr, unsigned long int nmemb, unsigned long int size, void *key, signed int (*cmpfn)(void *, void *));
// oscap_bfind::cmpfn$object
// 
signed int cmpfn$object(void *, void *);
// oscap_bfind_i
// file ../../../src/common/bfind.c line 60
signed int oscap_bfind_i(void *ptr, unsigned long int nmemb, unsigned long int size, void *key, signed int (*cmpfn)(void *, void *), unsigned long int *save);
// oscap_bfind_i::cmpfn$object
// 
signed int cmpfn$object(void *, void *);
// oscap_buffer_append_binary_data
// file ../../../src/common/oscap_buffer.h line 69
void oscap_buffer_append_binary_data(struct oscap_buffer *s, const char *data, const unsigned long int append_length);
// oscap_buffer_append_string
// file ../../../src/common/oscap_buffer.c line 97
void oscap_buffer_append_string(struct oscap_buffer *s, const char *t);
// oscap_buffer_bequeath
// file ../../../src/common/oscap_buffer.h line 48
char * oscap_buffer_bequeath(struct oscap_buffer *s);
// oscap_buffer_clear
// file ../../../src/common/oscap_buffer.c line 58
void oscap_buffer_clear(struct oscap_buffer *s);
// oscap_buffer_free
// file ../../../src/common/oscap_buffer.h line 41
void oscap_buffer_free(struct oscap_buffer *s);
// oscap_buffer_get_length
// file ../../../src/common/oscap_buffer.h line 90
unsigned long int oscap_buffer_get_length(struct oscap_buffer *s);
// oscap_buffer_get_raw
// file ../../../src/common/oscap_buffer.c line 105
char * oscap_buffer_get_raw(struct oscap_buffer *s);
// oscap_buffer_new
// file ../../../src/common/oscap_buffer.h line 35
struct oscap_buffer * oscap_buffer_new(void);
// oscap_cleanup
// file ../../../src/common/oscapxml.c line 110
void oscap_cleanup(void);
// oscap_clearerr
// file ../../../src/common/error.c line 127
void oscap_clearerr(void);
// oscap_create_lists
// file ../../../src/common/list.c line 41
void oscap_create_lists(struct oscap_list **first, ...);
// oscap_determine_document_type
// file ../../../src/common/oscapxml.c line 153
signed int oscap_determine_document_type(const char *document, enum oscap_document_type *doc_type);
// oscap_document_type_to_string
// file ../../../src/common/oscapxml.c line 160
const char * oscap_document_type_to_string(enum oscap_document_type type);
// oscap_element_depth
// file ../../../src/common/elements.c line 142
signed int oscap_element_depth(struct _xmlTextReader *reader);
// oscap_element_string_copy
// file ../../../src/common/elements.c line 116
char * oscap_element_string_copy(struct _xmlTextReader *reader);
// oscap_element_string_get
// file ../../../src/common/elements.c line 132
const char * oscap_element_string_get(struct _xmlTextReader *reader);
// oscap_enum_to_string
// file ../../../src/common/util.c line 48
const char * oscap_enum_to_string(struct oscap_string_map *map, signed int val);
// oscap_err
// file ../../../src/common/error.c line 138
_Bool oscap_err(void);
// oscap_err_desc
// file ../../../src/common/error.c line 157
const char * oscap_err_desc(void);
// oscap_err_family
// file ../../../src/common/error.c line 145
unsigned short int oscap_err_family(void);
// oscap_err_free
// file ../../../src/common/error.c line 62
static void oscap_err_free(struct oscap_err_t *err);
// oscap_err_get_full_error
// file ../../../src/common/error.c line 169
char * oscap_err_get_full_error(void);
// oscap_err_new
// file ../../../src/common/error.c line 45
static struct oscap_err_t * oscap_err_new(unsigned short int family, const char *desc, const char *func, unsigned int line, const char *file);
// oscap_errkey_init
// file ../../../src/common/error.c line 40
static void oscap_errkey_init(void);
// oscap_expand_ipv6
// file ../../../src/common/util.c line 219
char * oscap_expand_ipv6(const char *input);
// oscap_free
// file ../../../src/common/alloc.h line 74
static void oscap_free(void *p);
// oscap_get_date
// file ../../../src/common/elements.c line 160
signed long int oscap_get_date(const char *date);
// oscap_get_datetime
// file ../../../src/common/elements.c line 174
signed long int oscap_get_datetime(const char *date);
// oscap_get_version
// file ../../../src/common/oscapxml.c line 117
const char * oscap_get_version(void);
// oscap_get_xml
// file ../../../src/common/elements.c line 155
char * oscap_get_xml(struct _xmlTextReader *reader);
// oscap_htable_add
// file ../../../src/common/list.c line 451
_Bool oscap_htable_add(struct oscap_htable *htable, const char *key, void *item);
// oscap_htable_clone
// file ../../../src/common/list.c line 405
struct oscap_htable * oscap_htable_clone(struct oscap_htable *table, void * (*cloner)(void *));
// oscap_htable_clone::cloner$object
// 
void * cloner$object(void *);
// oscap_htable_cmp
// file ../../../src/common/list.c line 422
static signed int oscap_htable_cmp(const char *s1, const char *s2);
// oscap_htable_detach
// file ../../../src/common/list.c line 478
void * oscap_htable_detach(struct oscap_htable *htable, const char *key);
// oscap_htable_dump
// file ../../../src/common/list.c line 501
void oscap_htable_dump(struct oscap_htable *htable, void (*dumper)(), signed int depth);
// oscap_htable_dump::dumper$object
// 
void dumper$object();
// oscap_htable_free
// file ../../../src/common/list.c line 520
void oscap_htable_free(struct oscap_htable *htable, void (*destructor)(void *));
// oscap_htable_free0
// file ../../../src/common/list.c line 543
void oscap_htable_free0(struct oscap_htable *htable);
// oscap_htable_free::destructor$object
// 
void destructor$object(void *);
// oscap_htable_get
// file ../../../src/common/list.c line 492
void * oscap_htable_get(struct oscap_htable *htable, const char *key);
// oscap_htable_hash
// file ../../../src/common/list.c line 376
static inline unsigned int oscap_htable_hash(const char *str, unsigned long int htable_size);
// oscap_htable_iterator_free
// file ../../../src/common/list.c line 647
void oscap_htable_iterator_free(struct oscap_htable_iterator *hit);
// oscap_htable_iterator_has_more
// file ../../../src/common/list.c line 565
_Bool oscap_htable_iterator_has_more(struct oscap_htable_iterator *hit);
// oscap_htable_iterator_new
// file ../../../src/common/list.c line 555
struct oscap_htable_iterator * oscap_htable_iterator_new(struct oscap_htable *htable);
// oscap_htable_iterator_next
// file ../../../src/common/list.c line 590
struct oscap_htable_item * oscap_htable_iterator_next(struct oscap_htable_iterator *hit);
// oscap_htable_iterator_next_key
// file ../../../src/common/list.c line 615
const char * oscap_htable_iterator_next_key(struct oscap_htable_iterator *hit);
// oscap_htable_iterator_next_kv
// file ../../../src/common/list.c line 628
void oscap_htable_iterator_next_kv(struct oscap_htable_iterator *hit, const char **key, void **value);
// oscap_htable_iterator_next_value
// file ../../../src/common/list.c line 622
void * oscap_htable_iterator_next_value(struct oscap_htable_iterator *hit);
// oscap_htable_iterator_reset
// file ../../../src/common/list.c line 639
void oscap_htable_iterator_reset(struct oscap_htable_iterator *hit);
// oscap_htable_lookup
// file ../../../src/common/list.c line 436
static struct oscap_htable_item * oscap_htable_lookup(struct oscap_htable *htable, const char *key);
// oscap_htable_new
// file ../../../src/common/list.c line 431
struct oscap_htable * oscap_htable_new(void);
// oscap_htable_new1
// file ../../../src/common/list.c line 385
struct oscap_htable * oscap_htable_new1(signed int (*cmp)(const char *, const char *), unsigned long int hsize);
// oscap_htable_new1::cmp$object
// 
signed int cmp$object(const char *, const char *);
// oscap_init
// file ../../../src/common/oscapxml.c line 103
void oscap_init(void);
// oscap_iterator_detach
// file ../../../src/common/list.c line 263
void * oscap_iterator_detach(struct oscap_iterator *it);
// oscap_iterator_find_nearest
// file ../../../src/common/list.c line 230
static inline void oscap_iterator_find_nearest(struct oscap_iterator *it);
// oscap_iterator_free
// file ../../../src/common/list.c line 303
void oscap_iterator_free(struct oscap_iterator *it);
// oscap_iterator_get_itemcount
// file ../../../src/common/list.c line 257
unsigned long int oscap_iterator_get_itemcount(struct oscap_iterator *it);
// oscap_iterator_has_more
// file ../../../src/common/list.c line 320
_Bool oscap_iterator_has_more(struct oscap_iterator *it);
// oscap_iterator_new
// file ../../../src/common/list.c line 240
void * oscap_iterator_new(struct oscap_list *list);
// oscap_iterator_new_filter
// file ../../../src/common/list.c line 249
void * oscap_iterator_new_filter(struct oscap_list *list, _Bool (*filter)(void *, void *), void *user_data);
// oscap_iterator_new_filter::filter$object
// 
_Bool filter$object(void *, void *);
// oscap_iterator_next
// file ../../../src/common/list.c line 308
void * oscap_iterator_next(struct oscap_iterator *it);
// oscap_iterator_no_filter
// file ../../../src/common/list.c line 225
static _Bool oscap_iterator_no_filter(void *foo, void *bar);
// oscap_iterator_reset
// file ../../../src/common/list.c line 335
void oscap_iterator_reset(struct oscap_iterator *it);
// oscap_list_add
// file ../../../src/common/list.c line 50
_Bool oscap_list_add(struct oscap_list *list, void *value);
// oscap_list_clone
// file ../../../src/common/list.c line 125
struct oscap_list * oscap_list_clone(struct oscap_list *list, void * (*cloner)(void *));
// oscap_list_clone::cloner$object
// 
void * cloner$object(void *);
// oscap_list_contains
// file ../../../src/common/list.c line 206
_Bool oscap_list_contains(struct oscap_list *list, void *what, _Bool (*compare)(void *, void *));
// oscap_list_contains::compare$object
// 
_Bool compare$object(void *, void *);
// oscap_list_destructive_join
// file ../../../src/common/list.c line 144
struct oscap_list * oscap_list_destructive_join(struct oscap_list *list1, struct oscap_list *list2);
// oscap_list_dump
// file ../../../src/common/list.c line 211
void oscap_list_dump(struct oscap_list *list, void (*dumper)(), signed int depth);
// oscap_list_dump::dumper$object
// 
void dumper$object();
// oscap_list_find
// file ../../../src/common/list.c line 187
void * oscap_list_find(struct oscap_list *list, void *what, _Bool (*compare)(void *, void *));
// oscap_list_find::compare$object
// 
_Bool compare$object(void *, void *);
// oscap_list_free
// file ../../../src/common/list.c line 161
void oscap_list_free(struct oscap_list *list, void (*destructor)(void *));
// oscap_list_free0
// file ../../../src/common/list.c line 177
void oscap_list_free0(struct oscap_list *list);
// oscap_list_free::destructor$object
// 
void destructor$object(void *);
// oscap_list_get_itemcount
// file ../../../src/common/list.c line 155
signed int oscap_list_get_itemcount(struct oscap_list *list);
// oscap_list_new
// file ../../../src/common/list.c line 35
struct oscap_list * oscap_list_new(void);
// oscap_list_pop
// file ../../../src/common/list.c line 74
_Bool oscap_list_pop(struct oscap_list *list, void (*destructor)(void *));
// oscap_list_pop::destructor$object
// 
void destructor$object(void *);
// oscap_list_push
// file ../../../src/common/list.c line 69
_Bool oscap_list_push(struct oscap_list *list, void *value);
// oscap_list_remove
// file ../../../src/common/list.c line 96
_Bool oscap_list_remove(struct oscap_list *list, void *value, _Bool (*compare)(void *, void *), void (*destructor)(void *));
// oscap_list_remove::compare$object
// 
_Bool compare$object(void *, void *);
// oscap_list_remove::destructor$object
// 
void destructor$object(void *);
// oscap_parser_text_value
// file ../../../src/common/elements.c line 85
signed int oscap_parser_text_value(struct _xmlTextReader *reader, void (*consumer)(char *, void *), void *user);
// oscap_parser_text_value::consumer$object
// 
void consumer$object(char *, void *);
// oscap_path_to
// file ../../../src/common/oscapxml.c line 71
static const char * oscap_path_to(const char *pathvar, const char *defpath);
// oscap_path_to_cpe
// file ../../../src/common/oscapxml.c line 99
const char * oscap_path_to_cpe(void);
// oscap_path_to_schemas
// file ../../../src/common/oscapxml.c line 83
const char * oscap_path_to_schemas(void);
// oscap_path_to_schematron
// file ../../../src/common/oscapxml.c line 92
const char * oscap_path_to_schematron(void);
// oscap_path_to_xslt
// file ../../../src/common/oscapxml.c line 87
const char * oscap_path_to_xslt(void);
// oscap_print_depth
// file ../../../src/common/list.c line 652
void oscap_print_depth(signed int depth);
// oscap_proc_memusage
// file ../../../../../src/common/memusage.h line 31
signed int oscap_proc_memusage(struct proc_memusage *mu);
// oscap_ptr_cmp
// file ../../../src/common/list.c line 182
_Bool oscap_ptr_cmp(void *node1, void *node2);
// oscap_reference_clone
// file ../../../src/common/reference.c line 183
struct oscap_reference * oscap_reference_clone(struct oscap_reference *ref);
// oscap_reference_free
// file ../../../src/common/reference.c line 63
void oscap_reference_free(struct oscap_reference *ref);
// oscap_reference_get_contributor
// file ../../../src/common/reference.c line 45
const char * oscap_reference_get_contributor(struct oscap_reference *item);
// oscap_reference_get_coverage
// file ../../../src/common/reference.c line 53
const char * oscap_reference_get_coverage(struct oscap_reference *item);
// oscap_reference_get_creator
// file ../../../src/common/reference.c line 41
const char * oscap_reference_get_creator(struct oscap_reference *item);
// oscap_reference_get_date
// file ../../../src/common/reference.c line 46
const char * oscap_reference_get_date(struct oscap_reference *item);
// oscap_reference_get_description
// file ../../../src/common/reference.c line 43
const char * oscap_reference_get_description(struct oscap_reference *item);
// oscap_reference_get_format
// file ../../../src/common/reference.c line 48
const char * oscap_reference_get_format(struct oscap_reference *item);
// oscap_reference_get_href
// file ../../../src/common/reference.c line 39
const char * oscap_reference_get_href(struct oscap_reference *item);
// oscap_reference_get_identifier
// file ../../../src/common/reference.c line 49
const char * oscap_reference_get_identifier(struct oscap_reference *item);
// oscap_reference_get_is_dublincore
// file ../../../src/common/reference.c line 38
_Bool oscap_reference_get_is_dublincore(struct oscap_reference *item);
// oscap_reference_get_language
// file ../../../src/common/reference.c line 51
const char * oscap_reference_get_language(struct oscap_reference *item);
// oscap_reference_get_publisher
// file ../../../src/common/reference.c line 44
const char * oscap_reference_get_publisher(struct oscap_reference *item);
// oscap_reference_get_relation
// file ../../../src/common/reference.c line 52
const char * oscap_reference_get_relation(struct oscap_reference *item);
// oscap_reference_get_rights
// file ../../../src/common/reference.c line 54
const char * oscap_reference_get_rights(struct oscap_reference *item);
// oscap_reference_get_source
// file ../../../src/common/reference.c line 50
const char * oscap_reference_get_source(struct oscap_reference *item);
// oscap_reference_get_subject
// file ../../../src/common/reference.c line 42
const char * oscap_reference_get_subject(struct oscap_reference *item);
// oscap_reference_get_title
// file ../../../src/common/reference.c line 40
const char * oscap_reference_get_title(struct oscap_reference *item);
// oscap_reference_get_type
// file ../../../src/common/reference.c line 47
const char * oscap_reference_get_type(struct oscap_reference *item);
// oscap_reference_iterator_free
// file ../../../src/common/reference.c line 56
void oscap_reference_iterator_free(struct oscap_reference_iterator *it);
// oscap_reference_iterator_has_more
// file ../../../src/common/reference.c line 56
_Bool oscap_reference_iterator_has_more(struct oscap_reference_iterator *it);
// oscap_reference_iterator_next
// file ../../../src/common/reference.c line 56
struct oscap_reference * oscap_reference_iterator_next(struct oscap_reference_iterator *it);
// oscap_reference_iterator_reset
// file ../../../src/common/reference.c line 56
void oscap_reference_iterator_reset(struct oscap_reference_iterator *it);
// oscap_reference_new
// file ../../../src/common/reference.c line 58
struct oscap_reference * oscap_reference_new(void);
// oscap_reference_new_parse
// file ../../../src/common/reference.c line 132
struct oscap_reference * oscap_reference_new_parse(struct _xmlTextReader *reader);
// oscap_reference_set_contributor
// file ../../../src/common/reference.c line 45
_Bool oscap_reference_set_contributor(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_coverage
// file ../../../src/common/reference.c line 53
_Bool oscap_reference_set_coverage(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_creator
// file ../../../src/common/reference.c line 41
_Bool oscap_reference_set_creator(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_date
// file ../../../src/common/reference.c line 46
_Bool oscap_reference_set_date(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_description
// file ../../../src/common/reference.c line 43
_Bool oscap_reference_set_description(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_format
// file ../../../src/common/reference.c line 48
_Bool oscap_reference_set_format(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_href
// file ../../../src/common/reference.c line 39
_Bool oscap_reference_set_href(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_identifier
// file ../../../src/common/reference.c line 49
_Bool oscap_reference_set_identifier(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_is_dublincore
// file ../../../src/common/reference.c line 38
_Bool oscap_reference_set_is_dublincore(struct oscap_reference *obj, _Bool newval);
// oscap_reference_set_language
// file ../../../src/common/reference.c line 51
_Bool oscap_reference_set_language(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_publisher
// file ../../../src/common/reference.c line 44
_Bool oscap_reference_set_publisher(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_relation
// file ../../../src/common/reference.c line 52
_Bool oscap_reference_set_relation(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_rights
// file ../../../src/common/reference.c line 54
_Bool oscap_reference_set_rights(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_source
// file ../../../src/common/reference.c line 50
_Bool oscap_reference_set_source(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_subject
// file ../../../src/common/reference.c line 42
_Bool oscap_reference_set_subject(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_title
// file ../../../src/common/reference.c line 40
_Bool oscap_reference_set_title(struct oscap_reference *obj, const char *newval);
// oscap_reference_set_type
// file ../../../src/common/reference.c line 47
_Bool oscap_reference_set_type(struct oscap_reference *obj, const char *newval);
// oscap_reference_to_dom
// file ../../../src/common/reference.c line 91
struct _xmlNode * oscap_reference_to_dom(struct oscap_reference *ref, struct _xmlNode *parent, struct _xmlDoc *doc, const char *elname);
// oscap_rtrim
// file ../../../src/common/util.c line 203
char * oscap_rtrim(char *str, char ch);
// oscap_schematron_validate_document
// file ../../../src/common/oscapxml.c line 137
signed int oscap_schematron_validate_document(const char *xmlfile, enum oscap_document_type doctype, const char *version, const char *outfile);
// oscap_set_verbose
// file ../../../../../src/common/public/oscap_debug.h line 43
_Bool oscap_set_verbose(const char *verbosity_level, const char *filename, _Bool is_probe);
// oscap_source_apply_xslt_path
// file ../../../src/source/xslt_priv.h line 45
signed int oscap_source_apply_xslt_path(struct oscap_source *, const char *, const char *, const char **, const char *);
// oscap_source_free
// file ../../../src/source/public/oscap_source.h line 86
void oscap_source_free(struct oscap_source *);
// oscap_source_get_scap_type
// file ../../../src/source/public/oscap_source.h line 98
enum oscap_document_type oscap_source_get_scap_type(struct oscap_source *);
// oscap_source_new_from_file
// file ../../../src/source/public/oscap_source.h line 65
struct oscap_source * oscap_source_new_from_file(const char *);
// oscap_source_validate_priv
// file ../../../src/source/validate_priv.h line 44
signed int oscap_source_validate_priv(struct oscap_source *, enum oscap_document_type, const char *, signed int (*)(const char *, signed int, const char *, void *), void *);
// oscap_source_validate_schematron_priv
// file ../../../src/source/schematron_priv.h line 34
signed int oscap_source_validate_schematron_priv(struct oscap_source *, enum oscap_document_type, const char *, const char *);
// oscap_split
// file ../../../src/common/util.c line 83
char ** oscap_split(char *str, const char *delim);
// oscap_sprintf
// file ../../../src/common/util.h line 370
char * oscap_sprintf(const char *fmt, ...);
// oscap_str_endswith
// file ../../../src/common/util.c line 130
_Bool oscap_str_endswith(const char *str, const char *with);
// oscap_str_startswith
// file ../../../src/common/util.h line 359
_Bool oscap_str_startswith(const char *str, const char *with);
// oscap_strcmp
// file ../../../src/common/util.c line 113
signed int oscap_strcmp(const char *s1, const char *s2);
// oscap_strdup
// file ../../../src/common/util.h line 334
char * oscap_strdup(const char *str);
// oscap_streq
// file ../../../src/common/util.h line 358
_Bool oscap_streq(const char *s1, const char *s2);
// oscap_string_append_char
// file ../../../src/common/oscap_string.h line 45
void oscap_string_append_char(struct oscap_string *s, char c);
// oscap_string_append_string
// file ../../../src/common/oscap_string.h line 52
void oscap_string_append_string(struct oscap_string *s, const char *t);
// oscap_string_bequeath
// file ../../../src/common/oscap_string.h line 75
char * oscap_string_bequeath(struct oscap_string *s);
// oscap_string_clear
// file ../../../src/common/oscap_string.c line 48
void oscap_string_clear(struct oscap_string *s);
// oscap_string_empty
// file ../../../src/common/oscap_string.c line 68
_Bool oscap_string_empty(struct oscap_string *s);
// oscap_string_free
// file ../../../src/common/oscap_string.c line 38
void oscap_string_free(struct oscap_string *s);
// oscap_string_get_cstr
// file ../../../src/common/oscap_string.c line 63
const char * oscap_string_get_cstr(struct oscap_string *s);
// oscap_string_iterator_free
// file ../../../src/common/list.c line 368
void oscap_string_iterator_free(struct oscap_string_iterator *it);
// oscap_string_iterator_has_more
// file ../../../src/common/list.c line 368
_Bool oscap_string_iterator_has_more(struct oscap_string_iterator *it);
// oscap_string_iterator_next
// file ../../../src/common/list.c line 368
const char * oscap_string_iterator_next(struct oscap_string_iterator *it);
// oscap_string_iterator_remove
// file ../../../src/common/list.c line 369
void oscap_string_iterator_remove(struct oscap_string_iterator *it);
// oscap_string_iterator_reset
// file ../../../src/common/list.c line 368
void oscap_string_iterator_reset(struct oscap_string_iterator *it);
// oscap_string_new
// file ../../../src/common/oscap_string.h line 32
struct oscap_string * oscap_string_new(void);
// oscap_string_to_enum
// file ../../../src/common/util.h line 320
signed int oscap_string_to_enum(struct oscap_string_map *map, const char *str);
// oscap_stringlist_add_string
// file ../../../src/common/list.c line 353
_Bool oscap_stringlist_add_string(struct oscap_stringlist *list, const char *str);
// oscap_stringlist_clone
// file ../../../src/common/list.c line 340
struct oscap_stringlist * oscap_stringlist_clone(struct oscap_stringlist *list);
// oscap_stringlist_free
// file ../../../src/common/list.c line 363
void oscap_stringlist_free(struct oscap_stringlist *list);
// oscap_stringlist_get_strings
// file ../../../src/common/list.c line 348
struct oscap_string_iterator * oscap_stringlist_get_strings(struct oscap_stringlist *list);
// oscap_stringlist_iterator_free
// file ../../../src/common/list.c line 370
void oscap_stringlist_iterator_free(struct oscap_stringlist_iterator *it);
// oscap_stringlist_iterator_has_more
// file ../../../src/common/list.c line 370
_Bool oscap_stringlist_iterator_has_more(struct oscap_stringlist_iterator *it);
// oscap_stringlist_iterator_next
// file ../../../src/common/list.c line 370
struct oscap_stringlist * oscap_stringlist_iterator_next(struct oscap_stringlist_iterator *it);
// oscap_stringlist_iterator_remove
// file ../../../src/common/list.c line 371
void oscap_stringlist_iterator_remove(struct oscap_stringlist_iterator *it);
// oscap_stringlist_iterator_reset
// file ../../../src/common/list.c line 370
void oscap_stringlist_iterator_reset(struct oscap_stringlist_iterator *it);
// oscap_stringlist_new
// file ../../../src/common/list.c line 358
struct oscap_stringlist * oscap_stringlist_new(void);
// oscap_strlist_find_value
// file ../../../src/common/elements.c line 204
const char * oscap_strlist_find_value(char ** const kvalues, const char *key);
// oscap_strtol
// file ../../../src/common/util.c line 73
float oscap_strtol(const char *str, char **endptr, signed int base);
// oscap_strtoupper
// file ../../../src/common/util.c line 213
void oscap_strtoupper(char *str);
// oscap_sys_memusage
// file ../../../../../src/common/memusage.h line 32
signed int oscap_sys_memusage(struct sys_memusage *mu);
// oscap_text_clone
// file ../../../src/common/text.c line 91
struct oscap_text * oscap_text_clone(struct oscap_text *text);
// oscap_text_consumer
// file ../../../src/common/elements.c line 67
void oscap_text_consumer(char *text, void *user);
// oscap_text_export
// file ../../../src/common/text.c line 156
_Bool oscap_text_export(struct oscap_text *text, struct _xmlTextWriter *writer, const char *elname);
// oscap_text_free
// file ../../../src/common/text.c line 67
void oscap_text_free(struct oscap_text *text);
// oscap_text_get_can_override
// file ../../../src/common/text.c line 54
_Bool oscap_text_get_can_override(struct oscap_text *item);
// oscap_text_get_can_substitute
// file ../../../src/common/text.c line 53
_Bool oscap_text_get_can_substitute(struct oscap_text *item);
// oscap_text_get_is_html
// file ../../../src/common/text.c line 52
_Bool oscap_text_get_is_html(struct oscap_text *item);
// oscap_text_get_lang
// file ../../../src/common/text.c line 51
const char * oscap_text_get_lang(struct oscap_text *item);
// oscap_text_get_overrides
// file ../../../src/common/text.c line 55
_Bool oscap_text_get_overrides(struct oscap_text *item);
// oscap_text_get_plaintext
// file ../../../src/common/text.c line 199
char * oscap_text_get_plaintext(struct oscap_text *text);
// oscap_text_get_text
// file ../../../src/common/text.c line 50
const char * oscap_text_get_text(struct oscap_text *item);
// oscap_text_iterator_free
// file ../../../src/common/text.c line 56
void oscap_text_iterator_free(struct oscap_text_iterator *it);
// oscap_text_iterator_has_more
// file ../../../src/common/text.c line 56
_Bool oscap_text_iterator_has_more(struct oscap_text_iterator *it);
// oscap_text_iterator_next
// file ../../../src/common/text.c line 56
struct oscap_text * oscap_text_iterator_next(struct oscap_text_iterator *it);
// oscap_text_iterator_remove
// file ../../../src/common/text.c line 58
void oscap_text_iterator_remove(struct oscap_text_iterator *it);
// oscap_text_iterator_reset
// file ../../../src/common/text.c line 56
void oscap_text_iterator_reset(struct oscap_text_iterator *it);
// oscap_text_new
// file ../../../src/common/text.c line 86
struct oscap_text * oscap_text_new(void);
// oscap_text_new_full
// file ../../../src/common/text.c line 76
struct oscap_text * oscap_text_new_full(struct oscap_text_traits traits, const char *string, const char *lang);
// oscap_text_new_html
// file ../../../src/common/text.c line 96
struct oscap_text * oscap_text_new_html(void);
// oscap_text_new_parse
// file ../../../src/common/text.c line 102
struct oscap_text * oscap_text_new_parse(struct oscap_text_traits traits, struct _xmlTextReader *reader);
// oscap_text_set_lang
// file ../../../src/common/text.c line 51
_Bool oscap_text_set_lang(struct oscap_text *obj, const char *newval);
// oscap_text_set_overrides
// file ../../../src/common/text.c line 61
_Bool oscap_text_set_overrides(struct oscap_text *text, _Bool overrides);
// oscap_text_set_text
// file ../../../src/common/text.c line 50
_Bool oscap_text_set_text(struct oscap_text *obj, const char *newval);
// oscap_text_to_dom
// file ../../../src/common/text.c line 129
struct _xmlNode * oscap_text_to_dom(struct oscap_text *text, struct _xmlNode *parent, const char *elname);
// oscap_textlist_export
// file ../../../src/common/text.c line 208
_Bool oscap_textlist_export(struct oscap_text_iterator *texts, struct _xmlTextWriter *writer, const char *elname);
// oscap_textlist_get_preferred_plaintext
// file ../../../src/common/text.c line 252
char * oscap_textlist_get_preferred_plaintext(struct oscap_text_iterator *texts, const char *preferred_lang);
// oscap_textlist_get_preferred_text
// file ../../../src/common/text.c line 218
struct oscap_text * oscap_textlist_get_preferred_text(struct oscap_text_iterator *texts, const char *preferred_lang);
// oscap_to_start_element
// file ../../../src/common/elements.c line 50
_Bool oscap_to_start_element(struct _xmlTextReader *reader, signed int depth);
// oscap_trim
// file ../../../src/common/util.c line 139
char * oscap_trim(char *str);
// oscap_tsort
// file ../../../src/common/tsort.c line 105
_Bool oscap_tsort(struct oscap_list *input, struct oscap_list **output, struct oscap_list * (*edge_func)(void *, void *), _Bool (*cmp_func)(void *, void *), void *userdata);
// oscap_tsort::cmp_func$object
// 
_Bool cmp_func$object(void *, void *);
// oscap_tsort::edge_func$object
// 
struct oscap_list * edge_func$object(void *, void *);
// oscap_tsort_context_free
// file ../../../src/common/tsort.c line 53
static void oscap_tsort_context_free(struct oscap_tsort_context *ctx);
// oscap_tsort_context_new
// file ../../../src/common/tsort.c line 41
static struct oscap_tsort_context * oscap_tsort_context_new(struct oscap_list * (*edge_func)(void *, void *), _Bool (*cmp_func)(void *, void *), void *userdata);
// oscap_tsort_context_new::cmp_func$object
// 
_Bool cmp_func$object(void *, void *);
// oscap_tsort_context_new::edge_func$object
// 
struct oscap_list * edge_func$object(void *, void *);
// oscap_tsort_visit
// file ../../../src/common/tsort.c line 81
static _Bool oscap_tsort_visit(void *node, struct oscap_tsort_context *ctx);
// oscap_tsort_visit_all
// file ../../../src/common/tsort.c line 65
static inline _Bool oscap_tsort_visit_all(struct oscap_list *nodelist, struct oscap_tsort_context *ctx);
// oscap_validate_document
// file ../../../src/common/oscapxml.c line 119
signed int oscap_validate_document(const char *xmlfile, enum oscap_document_type doctype, const char *version, signed int (*reporter)(const char *, signed int, const char *, void *), void *arg);
// oscap_validate_document::reporter$object
// 
signed int reporter$object(const char *, signed int, const char *, void *);
// oscap_verbosity_level_from_cstr
// file ../../../src/common/debug.c line 80
enum anonymous$2 oscap_verbosity_level_from_cstr(const char *level_name);
// oscap_vsprintf
// file ../../../src/common/util.h line 364
char * oscap_vsprintf(const char *fmt, void **ap);
// oscap_xml_save_filename
// file ../../../src/common/elements.c line 215
signed int oscap_xml_save_filename(const char *filename, struct _xmlDoc *doc);
// oscap_xml_save_filename_free
// file ../../../src/common/elements.c line 250
signed int oscap_xml_save_filename_free(const char *filename, struct _xmlDoc *doc);
// oscap_xmlstr_to_dom
// file ../../../src/common/elements.c line 190
struct _xmlNode * oscap_xmlstr_to_dom(struct _xmlNode *parent, const char *elname, const char *content);
// oval_binary_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 40
enum anonymous$18 oval_binary_cmp(const char *state, const char *syschar, enum anonymous$36 operation);
// oval_boolean_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 32
enum anonymous$18 oval_boolean_cmp(const _Bool state, const _Bool syschar, enum anonymous$36 operation);
// oval_datatype_get_text
// file ../../../../src/OVAL/public/oval_definitions.h line 258
const char * oval_datatype_get_text(enum anonymous$10);
// oval_ent_cmp_str
// file ../../../../src/OVAL/results/oval_cmp.c line 159
enum anonymous$18 oval_ent_cmp_str(char *state_data, enum anonymous$10 state_data_type, struct oval_sysent *sysent, enum anonymous$36 operation);
// oval_evr_string_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_evr_string_impl.h line 49
enum anonymous$18 oval_evr_string_cmp(const char *state, const char *sys, enum anonymous$36 operation);
// oval_float_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 36
enum anonymous$18 oval_float_cmp(const double state_val, const double sys_val, enum anonymous$36 operation);
// oval_int_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 34
enum anonymous$18 oval_int_cmp(const signed long int state, const signed long int syschar, enum anonymous$36 operation);
// oval_ipaddr_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_ip_address_impl.h line 51
enum anonymous$18 oval_ipaddr_cmp(signed int af, const char *s1, const char *s2, enum anonymous$36 op);
// oval_operation_get_text
// file ../../../../src/OVAL/public/oval_definitions.h line 260
const char * oval_operation_get_text(enum anonymous$36);
// oval_str_cmp_str
// file ../../../../src/OVAL/results/oval_cmp.c line 91
enum anonymous$18 oval_str_cmp_str(char *state_data, enum anonymous$10 state_data_type, const char *sys_data, enum anonymous$36 operation);
// oval_string_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 38
enum anonymous$18 oval_string_cmp(const char *state, const char *syschar, enum anonymous$36 operation);
// oval_sysent_get_value
// file ../../../../src/OVAL/public/oval_system_characteristics.h line 772
char * oval_sysent_get_value(struct oval_sysent *);
// oval_versiontype_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_evr_string_impl.h line 51
enum anonymous$18 oval_versiontype_cmp(const char *state, const char *syschar, enum anonymous$36 operation);
// parseEVR
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 119
static void parseEVR(char *evr, const char **ep, const char **vp, const char **rp);
// pcre_compile
// file /usr/include/pcre.h line 540
extern struct real_pcre * pcre_compile(const char *, signed int, const char **, signed int *, const unsigned char *);
// pcre_exec
// file /usr/include/pcre.h line 573
extern signed int pcre_exec(const struct real_pcre *, const struct pcre_extra *, const char *, signed int, signed int, signed int, signed int *, signed int);
// pcre_free$object
// 
void pcre_free$object(void *);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// probe_cobj_add_item
// file ../../../../../src/OVAL/probes/public/probe-api.h line 282
signed int probe_cobj_add_item(struct SEXP *, const struct SEXP *);
// probe_cobj_add_msg
// file ../../../../src/OVAL/probes/public/probe-api.h line 279
signed int probe_cobj_add_msg(struct SEXP *, const struct SEXP *);
// probe_cobj_combine_flags
// file ../../../../../src/OVAL/probes/public/probe-api.h line 286
enum anonymous$8 probe_cobj_combine_flags(enum anonymous$8, enum anonymous$8, enum anonymous$34);
// probe_cobj_compute_flag
// file ../../../../../src/OVAL/probes/public/probe-api.h line 289
enum anonymous$8 probe_cobj_compute_flag(struct SEXP *);
// probe_cobj_get_flag
// file ../../../../../src/OVAL/probes/public/probe-api.h line 285
enum anonymous$8 probe_cobj_get_flag(const struct SEXP *);
// probe_cobj_get_items
// file ../../../../../src/OVAL/probes/public/probe-api.h line 283
struct SEXP * probe_cobj_get_items(const struct SEXP *);
// probe_cobj_get_mask
// file ../../../../../src/OVAL/probes/public/probe-api.h line 281
struct SEXP * probe_cobj_get_mask(const struct SEXP *);
// probe_cobj_memcheck
// file ../../../../../src/OVAL/probes/probe/icache.c line 450
static signed int probe_cobj_memcheck(unsigned long int item_cnt);
// probe_cobj_new
// file ../../../../../src/OVAL/probes/public/probe-api.h line 278
struct SEXP * probe_cobj_new(enum anonymous$8, struct SEXP *, struct SEXP *, struct SEXP *);
// probe_cobj_set_flag
// file ../../../../src/OVAL/probes/public/probe-api.h line 284
void probe_cobj_set_flag(struct SEXP *, enum anonymous$8);
// probe_ctx_getobject
// file ../../../../src/OVAL/probes/public/probe-api.h line 497
struct SEXP * probe_ctx_getobject(struct probe_ctx *ctx);
// probe_ctx_getresult
// file ../../../../src/OVAL/probes/public/probe-api.h line 504
struct SEXP * probe_ctx_getresult(struct probe_ctx *ctx);
// probe_ent_attrexists
// file ../../../../../src/OVAL/probes/probe/../public/probe-api.h line 370
_Bool probe_ent_attrexists(const struct SEXP *, const char *);
// probe_ent_cmp
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 220
static enum anonymous$18 probe_ent_cmp(struct SEXP *ent, struct SEXP *val2);
// probe_ent_cmp_binary
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 53
enum anonymous$18 probe_ent_cmp_binary(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_bool
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 69
enum anonymous$18 probe_ent_cmp_bool(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_debian_evr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 92
enum anonymous$18 probe_ent_cmp_debian_evr(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_evr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 79
enum anonymous$18 probe_ent_cmp_evr(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_filesetrev
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 100
enum anonymous$18 probe_ent_cmp_filesetrev(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_float
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 109
enum anonymous$18 probe_ent_cmp_float(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_int
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 119
enum anonymous$18 probe_ent_cmp_int(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_ios
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 132
enum anonymous$18 probe_ent_cmp_ios(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_ipaddr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 169
static enum anonymous$18 probe_ent_cmp_ipaddr(signed int af, struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_single
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 182
static inline enum anonymous$18 probe_ent_cmp_single(struct SEXP *state_ent, enum anonymous$10 state_data_type, struct SEXP *sysent, enum anonymous$36 op);
// probe_ent_cmp_string
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 153
enum anonymous$18 probe_ent_cmp_string(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_cmp_version
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 141
enum anonymous$18 probe_ent_cmp_version(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op);
// probe_ent_getattrval
// file ../../../../../src/OVAL/probes/public/probe-api.h line 363
struct SEXP * probe_ent_getattrval(const struct SEXP *, const char *);
// probe_ent_getdatatype
// file ../../../../../src/OVAL/probes/probe/../public/probe-api.h line 383
enum anonymous$10 probe_ent_getdatatype(const struct SEXP *);
// probe_ent_getname
// file ../../../../../src/OVAL/probes/probe/../public/probe-api.h line 415
char * probe_ent_getname(const struct SEXP *);
// probe_ent_getname_r
// file ../../../../../src/OVAL/probes/public/probe-api.h line 424
unsigned long int probe_ent_getname_r(const struct SEXP *, char *, unsigned long int);
// probe_ent_getstatus
// file ../../../../../src/OVAL/probes/public/probe-api.h line 409
enum anonymous$33 probe_ent_getstatus(const struct SEXP *);
// probe_ent_getval
// file ../../../../../src/OVAL/probes/public/probe-api.h line 347
struct SEXP * probe_ent_getval(const struct SEXP *);
// probe_ent_getvals
// file ../../../../../src/OVAL/probes/probe/../public/probe-api.h line 356
signed int probe_ent_getvals(const struct SEXP *, struct SEXP **);
// probe_ent_result_bychk
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 494
enum anonymous$18 probe_ent_result_bychk(struct SEXP *res_lst, enum anonymous$48 check);
// probe_ent_result_byopr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 583
enum anonymous$18 probe_ent_result_byopr(struct SEXP *res_lst, enum anonymous$49 operator);
// probe_entobj_cmp
// file ../../../../src/OVAL/probes/probe/entcmp.h line 61
enum anonymous$18 probe_entobj_cmp(struct SEXP *ent_obj, struct SEXP *val);
// probe_entste_cmp
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 391
enum anonymous$18 probe_entste_cmp(struct SEXP *ent_ste, struct SEXP *ent_itm);
// probe_fini
// file ../../../../../src/OVAL/probes/probe/fini.c line 38
void probe_fini(void *arg);
// probe_getoption
// file ../../../../../src/OVAL/probes/probe/option.c line 36
signed int probe_getoption(signed int option, ...);
// probe_icache_add
// file ../../../../../src/OVAL/probes/probe/icache.c line 349
signed int probe_icache_add(struct anonymous$15 *cache, struct SEXP *cobj, struct SEXP *item);
// probe_icache_free
// file ../../../../../src/OVAL/probes/probe/icache.h line 64
void probe_icache_free(struct anonymous$15 *cache);
// probe_icache_free_node
// file ../../../../../src/OVAL/probes/probe/icache.c line 554
static void probe_icache_free_node(struct rbt_i64_node *n);
// probe_icache_item_setID
// file ../../../../../src/OVAL/probes/probe/icache.c line 49
static void probe_icache_item_setID(struct SEXP *item, unsigned long int item_ID);
// probe_icache_new
// file ../../../../../src/OVAL/probes/probe/icache.h line 61
struct anonymous$15 * probe_icache_new(void);
// probe_icache_nop
// file ../../../../../src/OVAL/probes/probe/icache.h line 63
signed int probe_icache_nop(struct anonymous$15 *cache);
// probe_icache_worker
// file ../../../../../src/OVAL/probes/probe/icache.c line 87
static void * probe_icache_worker(void *arg);
// probe_init
// file ../../../../src/OVAL/probes/unix/runlevel.c line 360
void * probe_init(void);
// probe_input_handler
// file ../../../../../src/OVAL/probes/probe/input_handler.h line 25
void * probe_input_handler(void *arg);
// probe_input_handler::1::2::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// probe_item_collect
// file ../../../../src/OVAL/probes/public/probe-api.h line 489
signed int probe_item_collect(struct probe_ctx *ctx, struct SEXP *item);
// probe_item_create
// file ../../../../src/OVAL/probes/public/probe-api.h line 511
struct SEXP * probe_item_create(enum anonymous$17, struct anonymous$11 **, ...);
// probe_item_filtered
// file ../../../../../src/OVAL/probes/public/probe-api.h line 478
_Bool probe_item_filtered(const struct SEXP *, const struct SEXP *);
// probe_main
// file ../../../../src/OVAL/probes/unix/runlevel.c line 366
signed int probe_main(struct probe_ctx *ctx, void *arg);
// probe_msg_creat
// file ../../../../src/OVAL/probes/public/probe-api.h line 300
struct SEXP * probe_msg_creat(enum anonymous$9, char *);
// probe_msg_creatf
// file ../../../../../src/OVAL/probes/public/probe-api.h line 308
struct SEXP * probe_msg_creatf(enum anonymous$9, const char *, ...);
// probe_ncache_free
// file ../../../../../src/OVAL/probes/probe/ncache.h line 57
void probe_ncache_free(struct anonymous$22 *);
// probe_ncache_new
// file ../../../../../src/OVAL/probes/probe/ncache.h line 47
struct anonymous$22 * probe_ncache_new(void);
// probe_obj_eval
// file ../../../../../src/OVAL/probes/probe/worker.c line 367
static struct SEXP * probe_obj_eval(struct anonymous$23 *probe, struct SEXP *id);
// probe_obj_getattrval
// file ../../../../../src/OVAL/probes/public/probe-api.h line 234
struct SEXP * probe_obj_getattrval(const struct SEXP *, const char *);
// probe_obj_getent
// file ../../../../src/OVAL/probes/public/probe-api.h line 207
struct SEXP * probe_obj_getent(const struct SEXP *, const char *, unsigned int);
// probe_obj_getmask
// file ../../../../../src/OVAL/probes/public/probe-api.h line 579
struct SEXP * probe_obj_getmask(struct SEXP *);
// probe_optecmp
// file ../../../../../src/OVAL/probes/probe/main.c line 66
static signed int probe_optecmp(char **a, char **b);
// probe_opthandler_offlinemode
// file ../../../../../src/OVAL/probes/probe/main.c line 125
static signed int probe_opthandler_offlinemode(signed int option, signed int op, __builtin_va_list args);
// probe_opthandler_rcache
// file ../../../../../src/OVAL/probes/probe/main.c line 120
static signed int probe_opthandler_rcache(signed int option, signed int op, void **args);
// probe_opthandler_varref
// file ../../../../../src/OVAL/probes/probe/main.c line 86
static signed int probe_opthandler_varref(signed int option, signed int op, __builtin_va_list args);
// probe_prepare_filters
// file ../../../../../src/OVAL/probes/probe/worker.c line 380
static struct SEXP * probe_prepare_filters(struct anonymous$23 *probe, struct SEXP *obj);
// probe_rcache_free
// file ../../../../../src/OVAL/probes/probe/rcache.h line 47
void probe_rcache_free(struct anonymous$21 *);
// probe_rcache_new
// file ../../../../../src/OVAL/probes/probe/rcache.h line 40
struct anonymous$21 * probe_rcache_new(void);
// probe_rcache_sexp_add
// file ../../../../../src/OVAL/probes/probe/rcache.h line 57
signed int probe_rcache_sexp_add(struct anonymous$21 *, const struct SEXP *, struct SEXP *);
// probe_rcache_sexp_get
// file ../../../../../src/OVAL/probes/probe/rcache.h line 97
struct SEXP * probe_rcache_sexp_get(struct anonymous$21 *, const struct SEXP *);
// probe_reset
// file ../../../../../src/OVAL/probes/probe/main.c line 71
static struct SEXP * probe_reset(struct SEXP *arg0, void *arg1);
// probe_set_apply_filters
// file ../../../../../src/OVAL/probes/probe/worker.c line 554
static struct SEXP * probe_set_apply_filters(struct SEXP *cobj, struct SEXP *filters);
// probe_set_combine
// file ../../../../../src/OVAL/probes/probe/worker.c line 425
static struct SEXP * probe_set_combine(struct SEXP *cobj0, struct SEXP *cobj1, enum anonymous$34 op);
// probe_set_eval
// file ../../../../../src/OVAL/probes/probe/worker.c line 615
static struct SEXP * probe_set_eval(struct anonymous$23 *probe, struct SEXP *set, unsigned long int depth);
// probe_setoption
// file ../../../../src/OVAL/probes/probe/option.h line 23
signed int probe_setoption(signed int option, ...);
// probe_signal_handler
// file ../../../../../src/OVAL/probes/probe/signal_handler.h line 25
void * probe_signal_handler(void *arg);
// probe_ste_fetch
// file ../../../../../src/OVAL/probes/probe/worker.c line 313
static struct SEXP * probe_ste_fetch(struct anonymous$23 *probe, struct SEXP *id_list);
// probe_varref_create_ctx
// file ../../../../../src/OVAL/probes/probe/worker.c line 164
static signed int probe_varref_create_ctx(const struct SEXP *probe_in, struct SEXP *varrefs, struct probe_varref_ctx **octx);
// probe_varref_destroy_ctx
// file ../../../../../src/OVAL/probes/probe/worker.c line 246
static void probe_varref_destroy_ctx(struct probe_varref_ctx *ctx);
// probe_varref_iterate_ctx
// file ../../../../../src/OVAL/probes/probe/worker.c line 264
static signed int probe_varref_iterate_ctx(struct probe_varref_ctx *ctx);
// probe_worker
// file ../../../../../src/OVAL/probes/probe/worker.h line 52
struct SEXP * probe_worker(struct anonymous$23 *probe, struct SEAP_msg *msg_in, signed int *ret);
// probe_worker_new
// file ../../../../../src/OVAL/probes/probe/worker.h line 50
struct anonymous$31 * probe_worker_new(void);
// probe_worker_runfn
// file ../../../../../src/OVAL/probes/probe/worker.h line 51
void * probe_worker_runfn(void *arg);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_barrier_init
// file /usr/include/pthread.h line 1070
extern signed int pthread_barrier_init(union anonymous$27 *, const union anonymous$0 *, unsigned int);
// pthread_barrier_wait
// file /usr/include/pthread.h line 1080
extern signed int pthread_barrier_wait(union anonymous$27 *);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$7 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$7 *, const union anonymous$0 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$7 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$7 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_getname_np
// file /usr/include/pthread.h line 448
extern signed int pthread_getname_np(unsigned long int, char *, unsigned long int);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// pthread_setname_np
// file /usr/include/pthread.h line 453
extern signed int pthread_setname_np(unsigned long int, const char *);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$24 *, struct anonymous$24 *);
// pthread_timedjoin_np
// file /usr/include/pthread.h line 265
extern signed int pthread_timedjoin_np(unsigned long int, void **, struct timespec *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// rbt_i32_add
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i32.h line 44
signed int rbt_i32_add(struct rbt *, signed int, void *, void **);
// rbt_i32_del
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i32.h line 46
signed int rbt_i32_del(struct rbt *, signed int, void **);
// rbt_i32_free
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i32.h line 41
void rbt_i32_free(struct rbt *);
// rbt_i32_new
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i32.h line 40
struct rbt * rbt_i32_new(void);
// rbt_i64_add
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i64.h line 44
signed int rbt_i64_add(struct rbt *, signed long int, void *, void **);
// rbt_i64_free
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i64.h line 41
void rbt_i64_free(struct rbt *);
// rbt_i64_free_cb
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i64.h line 42
void rbt_i64_free_cb(struct rbt *, void (*)(struct rbt_i64_node *));
// rbt_i64_get
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i64.h line 47
signed int rbt_i64_get(struct rbt *, signed long int, void **);
// rbt_i64_new
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_i64.h line 40
struct rbt * rbt_i64_new(void);
// rbt_walk_inorder2
// file ../../../../../src/OVAL/probes/probe/../SEAP/generic/rbt/rbt_common.h line 192
signed int rbt_walk_inorder2(struct rbt *, signed int (*)(void *, void *), void *, enum anonymous$47);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_common_sizet
// file ../../../src/common/memusage.c line 41
static signed int read_common_sizet(void *szp, char *strval);
// read_status
// file ../../../src/common/memusage.c line 74
static signed int read_status(const char *source, void *base, struct stat_parser *spt, unsigned long int spt_size);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// results_parser
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 457
static signed int results_parser(struct SEXP *res_lst, struct _oresults *ores);
// risdigit
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 46
static signed int risdigit(signed int c);
// rpmevrcmp
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 78
static inline signed int rpmevrcmp(const char *a, const char *b);
// rpmvercmp
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 164
static signed int rpmvercmp(const char *a, const char *b);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$24 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$24 *);
// sigwaitinfo
// file /usr/include/signal.h line 278
extern signed int sigwaitinfo(const struct anonymous$24 *, struct anonymous$45 *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stpcpy
// file /usr/include/string.h line 568
extern char * stpcpy(char *, const char *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strregcomp
// file ../../../../src/OVAL/results/oval_cmp_basic.c line 127
static enum anonymous$18 strregcomp(const char *pattern, const char *test_str);
// strsep
// file /usr/include/string.h line 556
extern char * strsep(char ** restrict , const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtoimax
// file /usr/include/inttypes.h line 297
extern signed long int strtoimax(const char *, char ** restrict , signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// write_to_memory_callback
// file ../../../src/common/oscap_acquire.c line 175
unsigned long int write_to_memory_callback(char *ptr, unsigned long int size, unsigned long int nmemb, void *userdata);
// xmlAddChild
// file /usr/include/libxml2/libxml/tree.h line 942
struct _xmlNode * xmlAddChild(struct _xmlNode *, struct _xmlNode *);
// xmlBufferContent
// file /usr/include/libxml2/libxml/tree.h line 739
const unsigned char * xmlBufferContent(const struct _xmlBuffer *);
// xmlBufferCreate
// file /usr/include/libxml2/libxml/tree.h line 702
struct _xmlBuffer * xmlBufferCreate(void);
// xmlBufferFree
// file /usr/include/libxml2/libxml/tree.h line 712
void xmlBufferFree(struct _xmlBuffer *);
// xmlCleanupParser
// file /usr/include/libxml2/libxml/parser.h line 825
void xmlCleanupParser(void);
// xmlCopyNode
// file /usr/include/libxml2/libxml/tree.h line 884
struct _xmlNode * xmlCopyNode(struct _xmlNode *, signed int);
// xmlCtxtGetLastError
// file /usr/include/libxml2/libxml/xmlerror.h line 904
struct _xmlError * xmlCtxtGetLastError(void *);
// xmlDocGetRootElement
// file /usr/include/libxml2/libxml/tree.h line 920
struct _xmlNode * xmlDocGetRootElement(const struct _xmlDoc *);
// xmlFreeDoc
// file /usr/include/libxml2/libxml/tree.h line 782
void xmlFreeDoc(struct _xmlDoc *);
// xmlGetLastError
// file /usr/include/libxml2/libxml/xmlerror.h line 900
struct _xmlError * xmlGetLastError(void);
// xmlGetProp
// file /usr/include/libxml2/libxml/tree.h line 1029
unsigned char * xmlGetProp(const struct _xmlNode *, const unsigned char *);
// xmlInitParser
// file /usr/include/libxml2/libxml/parser.h line 823
void xmlInitParser(void);
// xmlNewChild
// file /usr/include/libxml2/libxml/tree.h line 844
struct _xmlNode * xmlNewChild(struct _xmlNode *, struct _xmlNs *, const unsigned char *, const unsigned char *);
// xmlNewNs
// file /usr/include/libxml2/libxml/tree.h line 772
struct _xmlNs * xmlNewNs(struct _xmlNode *, const unsigned char *, const unsigned char *);
// xmlNewProp
// file /usr/include/libxml2/libxml/tree.h line 790
struct _xmlAttr * xmlNewProp(struct _xmlNode *, const unsigned char *, const unsigned char *);
// xmlNewTextChild
// file /usr/include/libxml2/libxml/tree.h line 897
struct _xmlNode * xmlNewTextChild(struct _xmlNode *, struct _xmlNs *, const unsigned char *, const unsigned char *);
// xmlNodeAddContent
// file /usr/include/libxml2/libxml/tree.h line 1069
void xmlNodeAddContent(struct _xmlNode *, const unsigned char *);
// xmlNodeDump
// file /usr/include/libxml2/libxml/tree.h line 1199
signed int xmlNodeDump(struct _xmlBuffer *, struct _xmlDoc *, struct _xmlNode *, signed int, signed int);
// xmlNodeGetContent
// file /usr/include/libxml2/libxml/tree.h line 1076
unsigned char * xmlNodeGetContent(const struct _xmlNode *);
// xmlNodeSetLang
// file /usr/include/libxml2/libxml/tree.h line 1091
void xmlNodeSetLang(struct _xmlNode *, const unsigned char *);
// xmlNodeSetName
// file /usr/include/libxml2/libxml/tree.h line 938
void xmlNodeSetName(struct _xmlNode *, const unsigned char *);
// xmlOutputBufferCreateFd
// file /usr/include/libxml2/libxml/xmlIO.h line 239
struct _xmlOutputBuffer * xmlOutputBufferCreateFd(signed int, struct _xmlCharEncodingHandler *);
// xmlParseMemory
// file /usr/include/libxml2/libxml/parser.h line 846
struct _xmlDoc * xmlParseMemory(const char *, signed int);
// xmlReadMemory
// file /usr/include/libxml2/libxml/parser.h line 1138
struct _xmlDoc * xmlReadMemory(const char *, signed int, const char *, const char *, signed int);
// xmlSaveFormatFileEnc
// file /usr/include/libxml2/libxml/tree.h line 1223
signed int xmlSaveFormatFileEnc(const char *, struct _xmlDoc *, const char *, signed int);
// xmlSaveFormatFileTo
// file /usr/include/libxml2/libxml/tree.h line 1210
signed int xmlSaveFormatFileTo(struct _xmlOutputBuffer *, struct _xmlDoc *, const char *, signed int);
// xmlSearchNsByHref
// file /usr/include/libxml2/libxml/tree.h line 991
struct _xmlNs * xmlSearchNsByHref(struct _xmlDoc *, struct _xmlNode *, const unsigned char *);
// xmlSetNs
// file /usr/include/libxml2/libxml/tree.h line 1002
void xmlSetNs(struct _xmlNode *, struct _xmlNs *);
// xmlStrcmp
// file /usr/include/libxml2/libxml/xmlstring.h line 64
signed int xmlStrcmp(const unsigned char *, const unsigned char *);
// xmlTextReaderConstLocalName
// file /usr/include/libxml2/libxml/xmlreader.h line 171
const unsigned char * xmlTextReaderConstLocalName(struct _xmlTextReader *);
// xmlTextReaderConstValue
// file /usr/include/libxml2/libxml/xmlreader.h line 184
const unsigned char * xmlTextReaderConstValue(struct _xmlTextReader *);
// xmlTextReaderDepth
// file /usr/include/libxml2/libxml/xmlreader.h line 150
signed int xmlTextReaderDepth(struct _xmlTextReader *);
// xmlTextReaderExpand
// file /usr/include/libxml2/libxml/xmlreader.h line 276
struct _xmlNode * xmlTextReaderExpand(struct _xmlTextReader *);
// xmlTextReaderHasValue
// file /usr/include/libxml2/libxml/xmlreader.h line 154
signed int xmlTextReaderHasValue(struct _xmlTextReader *);
// xmlTextReaderIsEmptyElement
// file /usr/include/libxml2/libxml/xmlreader.h line 158
signed int xmlTextReaderIsEmptyElement(struct _xmlTextReader *);
// xmlTextReaderMoveToAttribute
// file /usr/include/libxml2/libxml/xmlreader.h line 229
signed int xmlTextReaderMoveToAttribute(struct _xmlTextReader *, const unsigned char *);
// xmlTextReaderMoveToElement
// file /usr/include/libxml2/libxml/xmlreader.h line 240
signed int xmlTextReaderMoveToElement(struct _xmlTextReader *);
// xmlTextReaderNextElement
// file ../../../src/common/xmltext_priv.c line 29
signed int xmlTextReaderNextElement(struct _xmlTextReader *reader);
// xmlTextReaderNextElementWE
// file ../../../src/common/xmltext_priv.c line 60
signed int xmlTextReaderNextElementWE(struct _xmlTextReader *reader, unsigned char *end_tag);
// xmlTextReaderNextNode
// file ../../../src/common/xmltext_priv.c line 49
signed int xmlTextReaderNextNode(struct _xmlTextReader *reader);
// xmlTextReaderNodeType
// file /usr/include/libxml2/libxml/xmlreader.h line 160
signed int xmlTextReaderNodeType(struct _xmlTextReader *);
// xmlTextReaderRead
// file /usr/include/libxml2/libxml/xmlreader.h line 129
signed int xmlTextReaderRead(struct _xmlTextReader *);
// xmlTextReaderReadInnerXml
// file /usr/include/libxml2/libxml/xmlreader.h line 133
unsigned char * xmlTextReaderReadInnerXml(struct _xmlTextReader *);
// xmlTextReaderValue
// file /usr/include/libxml2/libxml/xmlreader.h line 203
unsigned char * xmlTextReaderValue(struct _xmlTextReader *);
// xmlTextReaderXmlLang
// file /usr/include/libxml2/libxml/xmlreader.h line 201
unsigned char * xmlTextReaderXmlLang(struct _xmlTextReader *);
// xmlTextWriterEndElement
// file /usr/include/libxml2/libxml/xmlwriter.h line 96
signed int xmlTextWriterEndElement(struct _xmlTextWriter *);
// xmlTextWriterStartElement
// file /usr/include/libxml2/libxml/xmlwriter.h line 87
signed int xmlTextWriterStartElement(struct _xmlTextWriter *, const unsigned char *);
// xmlTextWriterWriteAttribute
// file /usr/include/libxml2/libxml/xmlwriter.h line 213
signed int xmlTextWriterWriteAttribute(struct _xmlTextWriter *, const unsigned char *, const unsigned char *);
// xmlTextWriterWriteRaw
// file /usr/include/libxml2/libxml/xmlwriter.h line 159
signed int xmlTextWriterWriteRaw(struct _xmlTextWriter *, const unsigned char *);
// xmlTextWriterWriteString
// file /usr/include/libxml2/libxml/xmlwriter.h line 172
signed int xmlTextWriterWriteString(struct _xmlTextWriter *, const unsigned char *);
// xml_element_dfs_callback
// file ../../../src/common/xml_iterate.c line 29
static signed int xml_element_dfs_callback(struct _xmlNode **node, signed int (*user_fn)(struct _xmlNode **, void *), void *user_data);
// xml_element_dfs_callback::user_fn$object
// 
signed int user_fn$object(struct _xmlNode **, void *);
// xml_iterate_dfs
// file ../../../src/common/xml_iterate.c line 46
signed int xml_iterate_dfs(const char *input_text, char **output_text, signed int (*user_fn)(struct _xmlNode **, void *), void *user_data);
// xml_iterate_dfs::user_fn$object
// 
signed int user_fn$object(struct _xmlNode **, void *);
// xsltCleanupGlobals
// file /usr/include/libxslt/xslt.h line 103
void xsltCleanupGlobals(void);
// xsltInit
// file /usr/include/libxslt/xslt.h line 97
void xsltInit(void);

struct anonymous$46
{
  // thr
  struct anonymous$31 **thr;
  // cnt
  unsigned long int cnt;
};

struct anonymous$51
{
  // item
  struct SEXP **item;
  // count
  unsigned short int count;
};

struct anonymous$16
{
  // distrop
  signed int (*distrop)(void);
  // get_runlevel
  signed int (*get_runlevel)(struct runlevel_req *, struct runlevel_rep **);
};

struct anonymous$32
{
  // probe
  struct anonymous$23 *probe;
  // pth
  struct anonymous$31 *pth;
};

union anonymous$13
{
  // item
  struct SEXP *item;
  // cond
  union anonymous$7 *cond;
};

struct anonymous$14
{
  // cobj
  struct SEXP *cobj;
  // p
  union anonymous$13 p;
};

struct anonymous$21
{
  // tree
  struct rbt *tree;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$6
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous$7
{
  // __data
  struct anonymous$6 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous$15
{
  // tree
  struct rbt *tree;
  // thid
  unsigned long int thid;
  // queue_mutex
  union anonymous queue_mutex;
  // queue_notempty
  union anonymous$7 queue_notempty;
  // queue_notfull
  union anonymous$7 queue_notfull;
  // queue
  struct anonymous$14 queue[1024l];
  // queue_beg
  unsigned short int queue_beg;
  // queue_end
  unsigned short int queue_end;
  // queue_cnt
  unsigned short int queue_cnt;
  // queue_max
  unsigned short int queue_max;
};

struct anonymous$43
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$41
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$24
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$29
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$30
{
  // __cancel_jmp_buf
  struct anonymous$29 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$11
{
  // type
  enum anonymous$10 type;
  // value
  void *value;
};

struct anonymous$26
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous$1
{
  // option
  signed int option;
  // handler
  signed int (*handler)(signed int, signed int, void **);
};

struct anonymous$37
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$40
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$39
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$38
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$42
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$44
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$37 _kill;
  // _timer
  struct anonymous$38 _timer;
  // _rt
  struct anonymous$39 _rt;
  // _sigchld
  struct anonymous$40 _sigchld;
  // _sigfault
  struct anonymous$41 _sigfault;
  // _sigpoll
  struct anonymous$42 _sigpoll;
  // _sigsys
  struct anonymous$43 _sigsys;
};

struct anonymous$45
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$44 _sifields;
};

union anonymous$20
{
  // __data
  struct anonymous$26 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct anonymous$22
{
  // lock
  union anonymous$20 lock;
  // name
  struct SEXP **name;
  // real
  unsigned long int real;
  // size
  unsigned long int size;
};

struct anonymous$23
{
  // rwlock
  union anonymous$20 rwlock;
  // flags
  unsigned int flags;
  // name
  char *name;
  // pid
  signed int pid;
  // probe_arg
  void *probe_arg;
  // probe_exitcode
  signed int probe_exitcode;
  // SEAP_ctx
  struct SEAP_CTX *SEAP_ctx;
  // sd
  signed int sd;
  // th_input
  unsigned long int th_input;
  // th_signal
  unsigned long int th_signal;
  // workers
  struct rbt *workers;
  // max_threads
  unsigned int max_threads;
  // max_chdepth
  unsigned int max_chdepth;
  // rcache
  struct anonymous$21 *rcache;
  // ncache
  struct anonymous$22 *ncache;
  // icache
  struct anonymous$15 *icache;
  // option
  struct anonymous$1 *option;
  // optcnt
  unsigned long int optcnt;
};

struct anonymous$31
{
  // sid
  unsigned int sid;
  // tid
  unsigned long int tid;
  // msg_handler
  struct SEXP * (*msg_handler)(struct anonymous$23 *, struct SEAP_msg *, signed int *);
  // msg
  struct SEAP_msg *msg;
};

union anonymous$50
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$27
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous$0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct FTW
{
  // base
  signed int base;
  // level
  signed int level;
};

struct SEXP
{
  // s_type
  void *s_type;
  // s_valp
  unsigned long int s_valp;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _oresults
{
  // true_cnt
  signed int true_cnt;
  // false_cnt
  signed int false_cnt;
  // unknown_cnt
  signed int unknown_cnt;
  // error_cnt
  signed int error_cnt;
  // noteval_cnt
  signed int noteval_cnt;
  // notappl_cnt
  signed int notappl_cnt;
};

struct _uconv_t
{
  // uconv
  struct UConverter *uconv;
  // utf8
  struct UConverter *utf8;
};

struct _xmlAttr
{
  // _private
  void *_private;
  // type
  enum anonymous$3 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlAttr *next;
  // prev
  struct _xmlAttr *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // atype
  enum anonymous$4 atype;
  // psvi
  void *psvi;
};

struct _xmlBuffer
{
  // content
  unsigned char *content;
  // use
  unsigned int use;
  // size
  unsigned int size;
  // alloc
  enum anonymous$35 alloc;
  // contentIO
  unsigned char *contentIO;
};

struct _xmlCharEncodingHandler
{
  // name
  char *name;
  // input
  signed int (*input)(unsigned char *, signed int *, const unsigned char *, signed int *);
  // output
  signed int (*output)(unsigned char *, signed int *, const unsigned char *, signed int *);
  // iconv_in
  void *iconv_in;
  // iconv_out
  void *iconv_out;
  // uconv_in
  struct _uconv_t *uconv_in;
  // uconv_out
  struct _uconv_t *uconv_out;
};

struct _xmlDoc
{
  // _private
  void *_private;
  // type
  enum anonymous$3 type;
  // name
  char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // compression
  signed int compression;
  // standalone
  signed int standalone;
  // intSubset
  struct _xmlDtd *intSubset;
  // extSubset
  struct _xmlDtd *extSubset;
  // oldNs
  struct _xmlNs *oldNs;
  // version
  const unsigned char *version;
  // encoding
  const unsigned char *encoding;
  // ids
  void *ids;
  // refs
  void *refs;
  // URL
  const unsigned char *URL;
  // charset
  signed int charset;
  // dict
  struct _xmlDict *dict;
  // psvi
  void *psvi;
  // parseFlags
  signed int parseFlags;
  // properties
  signed int properties;
};

struct _xmlDtd
{
  // _private
  void *_private;
  // type
  enum anonymous$3 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlDoc *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // notations
  void *notations;
  // elements
  void *elements;
  // attributes
  void *attributes;
  // entities
  void *entities;
  // ExternalID
  const unsigned char *ExternalID;
  // SystemID
  const unsigned char *SystemID;
  // pentities
  void *pentities;
};

struct _xmlError
{
  // domain
  signed int domain;
  // code
  signed int code;
  // message
  char *message;
  // level
  enum anonymous$5 level;
  // file
  char *file;
  // line
  signed int line;
  // str1
  char *str1;
  // str2
  char *str2;
  // str3
  char *str3;
  // int1
  signed int int1;
  // int2
  signed int int2;
  // ctxt
  void *ctxt;
  // node
  void *node;
};

struct _xmlNode
{
  // _private
  void *_private;
  // type
  enum anonymous$3 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // content
  unsigned char *content;
  // properties
  struct _xmlAttr *properties;
  // nsDef
  struct _xmlNs *nsDef;
  // psvi
  void *psvi;
  // line
  unsigned short int line;
  // extra
  unsigned short int extra;
};

struct _xmlNs
{
  // next
  struct _xmlNs *next;
  // type
  enum anonymous$3 type;
  // href
  const unsigned char *href;
  // prefix
  const unsigned char *prefix;
  // _private
  void *_private;
  // context
  struct _xmlDoc *context;
};

struct _xmlOutputBuffer
{
  // context
  void *context;
  // writecallback
  signed int (*writecallback)(void *, const char *, signed int);
  // closecallback
  signed int (*closecallback)(void *);
  // encoder
  struct _xmlCharEncodingHandler *encoder;
  // buffer
  struct _xmlBuf *buffer;
  // conv
  struct _xmlBuf *conv;
  // written
  signed int written;
  // error
  signed int error;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct err_queue
{
  // first
  struct oscap_err_t *first;
  // last
  struct oscap_err_t *last;
};

struct in6_addr
{
  // __in6_u
  union anonymous$50 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct oscap_buffer
{
  // data
  char *data;
  // length
  unsigned long int length;
  // capacity
  unsigned long int capacity;
};

struct oscap_err_t
{
  // family
  unsigned short int family;
  // desc
  char *desc;
  // func
  const char *func;
  // file
  const char *file;
  // line
  unsigned int line;
  // next
  struct oscap_err_t *next;
};

struct oscap_htable
{
  // hsize
  unsigned long int hsize;
  // itemcount
  unsigned long int itemcount;
  // table
  struct oscap_htable_item **table;
  // cmp
  signed int (*cmp)(const char *, const char *);
};

struct oscap_htable_item
{
  // next
  struct oscap_htable_item *next;
  // key
  char *key;
  // value
  void *value;
};

struct oscap_htable_iterator
{
  // htable
  struct oscap_htable *htable;
  // cur
  struct oscap_htable_item *cur;
  // hpos
  unsigned long int hpos;
};

struct oscap_iterator
{
  // cur
  struct oscap_list_item *cur;
  // list
  struct oscap_list *list;
  // filter
  _Bool (*filter)(void *, void *);
  // user_data
  void *user_data;
};

struct oscap_list
{
  // first
  struct oscap_list_item *first;
  // last
  struct oscap_list_item *last;
  // itemcount
  unsigned long int itemcount;
};

struct oscap_list_item
{
  // data
  void *data;
  // next
  struct oscap_list_item *next;
};

struct oscap_reference
{
  // title
  char *title;
  // creator
  char *creator;
  // subject
  char *subject;
  // description
  char *description;
  // publisher
  char *publisher;
  // contributor
  char *contributor;
  // date
  char *date;
  // type
  char *type;
  // format
  char *format;
  // identifier
  char *identifier;
  // source
  char *source;
  // language
  char *language;
  // relation
  char *relation;
  // coverage
  char *coverage;
  // rights
  char *rights;
  // is_dublincore
  _Bool is_dublincore;
  // href
  char *href;
};

struct oscap_string_map
{
  // value
  signed int value;
  // string
  const char *string;
};

struct oscap_text_traits
{
  // override_given
  _Bool override_given : 1;
  // html
  _Bool html : 1;
  // can_override
  _Bool can_override : 1;
  // can_substitute
  _Bool can_substitute : 1;
  // overrides
  _Bool overrides : 1;
};

struct oscap_text
{
  // lang
  char *lang;
  // text
  char *text;
  // traits
  struct oscap_text_traits traits;
};

struct oscap_tsort_context
{
  // visited
  struct oscap_list *visited;
  // cur_stack
  struct oscap_list *cur_stack;
  // result
  struct oscap_list *result;
  // edge_func
  struct oscap_list * (*edge_func)(void *, void *);
  // cmp_func
  _Bool (*cmp_func)(void *, void *);
  // userdata
  void *userdata;
};

struct pcre_extra
{
  // flags
  unsigned long int flags;
  // study_data
  void *study_data;
  // match_limit
  unsigned long int match_limit;
  // callout_data
  void *callout_data;
  // tables
  const unsigned char *tables;
  // match_limit_recursion
  unsigned long int match_limit_recursion;
  // mark
  unsigned char **mark;
  // executable_jit
  void *executable_jit;
};

struct probe_ctx
{
  // probe_in
  struct SEXP *probe_in;
  // probe_out
  struct SEXP *probe_out;
  // filters
  struct SEXP *filters;
  // icache
  struct anonymous$15 *icache;
};

struct probe_varref_ctx
{
  // pi2
  struct SEXP *pi2;
  // ent_cnt
  unsigned int ent_cnt;
  // ent_lst
  struct probe_varref_ctx_ent *ent_lst;
};

struct probe_varref_ctx_ent
{
  // ent_name_sref
  struct SEXP *ent_name_sref;
  // val_cnt
  unsigned int val_cnt;
  // next_val_idx
  unsigned int next_val_idx;
};

struct proc_memusage
{
  // mu_rss
  unsigned long int mu_rss;
  // mu_hwm
  unsigned long int mu_hwm;
  // mu_lib
  unsigned long int mu_lib;
  // mu_text
  unsigned long int mu_text;
  // mu_data
  unsigned long int mu_data;
  // mu_stack
  unsigned long int mu_stack;
  // mu_lock
  unsigned long int mu_lock;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rbt
{
  // root
  struct rbt_node *root;
  // size
  unsigned long int size;
  // type
  enum anonymous$12 type;
};

struct rbt_i32_node
{
  // key
  signed int key;
  // data
  void *data;
};

struct rbt_i64_node
{
  // key
  signed long int key;
  // data
  void *data;
};

struct rbt_node
{
  // _chld
  struct rbt_node *_chld[2l];
  // _node
  unsigned char _node[0l];
};

struct runlevel_rep
{
  // service_name
  char *service_name;
  // runlevel
  char *runlevel;
  // start
  _Bool start;
  // kill
  _Bool kill;
  // next
  struct runlevel_rep *next;
};

struct runlevel_req
{
  // service_name_ent
  struct SEXP *service_name_ent;
  // runlevel_ent
  struct SEXP *runlevel_ent;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stat_parser
{
  // keyword
  char *keyword;
  // storval
  signed int (*storval)(void *, char *);
  // offset
  signed long int offset;
};

struct sys_memusage
{
  // mu_total
  unsigned long int mu_total;
  // mu_free
  unsigned long int mu_free;
  // mu_realfree
  unsigned long int mu_realfree;
  // mu_buffers
  unsigned long int mu_buffers;
  // mu_cached
  unsigned long int mu_cached;
  // mu_active
  unsigned long int mu_active;
  // mu_inactive
  unsigned long int mu_inactive;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// CPE_SPLIT_INIT_ALLOC
// file ../../../src/common/util.c line 81
static const unsigned long int CPE_SPLIT_INIT_ALLOC = (const unsigned long int)8;
// OSCAP_BOOL_MAP
// file ../../../src/common/elements.c line 43
struct oscap_string_map OSCAP_BOOL_MAP[8l] = { { .value=1, .string="true" }, { .value=1, .string="True" }, { .value=1, .string="TRUE" }, { .value=1, .string="yes" }, { .value=1, .string="Yes" }, { .value=1, .string="YES" }, { .value=1, .string="1" }, { .value=0, .string=(const char *)(void *)0 } };
// OSCAP_CPE_PATH
// file ../../../src/common/oscapxml.c line 67
const char * const OSCAP_CPE_PATH = "/usr/share/openscap/cpe";
// OSCAP_LANG_DEFAULT
// file ../../../src/common/text.c line 44
const char * const OSCAP_LANG_DEFAULT = "en-US";
// OSCAP_LANG_ENGLISH
// file ../../../src/common/text.c line 42
const char * const OSCAP_LANG_ENGLISH = "en";
// OSCAP_LANG_ENGLISH_US
// file ../../../src/common/text.c line 43
const char * const OSCAP_LANG_ENGLISH_US = "en-US";
// OSCAP_SCHEMA_PATH
// file ../../../src/common/oscapxml.c line 55
const char * const OSCAP_SCHEMA_PATH = "/usr/share/openscap/schemas";
// OSCAP_TEXT_TRAITS_HTML
// file ../../../src/common/text.c line 47
struct oscap_text_traits OSCAP_TEXT_TRAITS_HTML = { .override_given=0, .html=1, .can_override=0, .can_substitute=0,
    .overrides=0 };
// OSCAP_TEXT_TRAITS_PLAIN
// file ../../../src/common/text.c line 46
struct oscap_text_traits OSCAP_TEXT_TRAITS_PLAIN = { .override_given=0, .html=0, .can_override=0, .can_substitute=0,
    .overrides=0 };
// OSCAP_VERBOSITY_LEVELS
// file ../../../src/common/debug.c line 50
static struct oscap_string_map OSCAP_VERBOSITY_LEVELS[5l] = { { .value=DBG_E, .string="ERROR" }, { .value=DBG_W, .string="WARNING" }, { .value=DBG_I, .string="INFO" }, { .value=DBG_D, .string="DEVEL" }, { .value=DBG_UNKNOWN, .string=(const char *)(void *)0 } };
// OSCAP_XSLT_PATH
// file ../../../src/common/oscapxml.c line 61
const char * const OSCAP_XSLT_PATH = "/usr/share/openscap/xsl";
// ___G_ncache
// file ../../../../../src/OVAL/probes/probe/main.c line 64
extern struct anonymous$22 *___G_ncache;
// ___G_no_varref_ents
// file ../../../../../src/OVAL/probes/probe/main.c line 56
char **___G_no_varref_ents = (char **)(void *)0;
// ___G_no_varref_ents_cnt
// file ../../../../../src/OVAL/probes/probe/main.c line 57
unsigned long int ___G_no_varref_ents_cnt = (unsigned long int)0;
// ___G_offline_mode
// file ../../../../../src/OVAL/probes/probe/main.c line 58
enum anonymous$25 ___G_offline_mode = (enum anonymous$25)PROBE_OFFLINE_NONE;
// ___G_offline_mode_cobjflag
// file ../../../../../src/OVAL/probes/probe/main.c line 60
signed int ___G_offline_mode_cobjflag = SYSCHAR_FLAG_NOT_APPLICABLE;
// ___G_offline_mode_supported
// file ../../../../../src/OVAL/probes/probe/main.c line 59
enum anonymous$25 ___G_offline_mode_supported = (enum anonymous$25)PROBE_OFFLINE_NONE;
// ___G_probe_arg
// file ../../../../../src/OVAL/probes/probe/main.c line 54
void *___G_probe_arg = (void *)0;
// ___G_probe_optdef
// file ../../../../../src/OVAL/probes/probe/option.c line 9
struct anonymous$1 *___G_probe_optdef = (struct anonymous$1 *)(void *)0;
// ___G_probe_optdef_count
// file ../../../../../src/OVAL/probes/probe/option.c line 8
unsigned long int ___G_probe_optdef_count = (unsigned long int)0;
// ___G_th_barrier
// file ../../../../../src/OVAL/probes/probe/main.c line 62
union anonymous$27 ___G_th_barrier;
// ___G_varref_handling
// file ../../../../../src/OVAL/probes/probe/main.c line 55
_Bool ___G_varref_handling = (_Bool)1;
// __debuglog_fp
// file ../../../src/common/debug.c line 62
static struct _IO_FILE *__debuglog_fp = (struct _IO_FILE *)(void *)0;
// __debuglog_level
// file ../../../src/common/debug.c line 63
static enum anonymous$2 __debuglog_level = (enum anonymous$2)DBG_UNKNOWN;
// __debuglog_mutex
// file ../../../src/common/debug.c line 60
static union anonymous __debuglog_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// __key
// file ../../../src/common/error.c line 37
static unsigned int __key;
// __once
// file ../../../src/common/error.c line 38
static signed int __once = 0;
// __proc_stat_ptable
// file ../../../src/common/memusage.c line 165
struct stat_parser __proc_stat_ptable[7l];
// __proc_stat_ptable
// file ../../../src/common/memusage.c line 165
struct stat_parser __proc_stat_ptable[7l] = { { .keyword="VmData", .storval=read_common_sizet, .offset=(signed long int)32ul }, 
    { .keyword="VmExe", .storval=read_common_sizet, .offset=(signed long int)24ul }, 
    { .keyword="VmHWM", .storval=read_common_sizet, .offset=(signed long int)8ul }, 
    { .keyword="VmLck", .storval=read_common_sizet, .offset=(signed long int)48ul }, 
    { .keyword="VmLib", .storval=read_common_sizet, .offset=(signed long int)16ul }, 
    { .keyword="VmRSS", .storval=read_common_sizet, .offset=(signed long int)0ul }, 
    { .keyword="VmStk", .storval=read_common_sizet, .offset=(signed long int)40ul } };
// __sys_stat_ptable
// file ../../../src/common/memusage.c line 156
struct stat_parser __sys_stat_ptable[6l];
// __sys_stat_ptable
// file ../../../src/common/memusage.c line 156
struct stat_parser __sys_stat_ptable[6l] = { { .keyword="Active", .storval=read_common_sizet, .offset=(signed long int)40ul }, 
    { .keyword="Buffers", .storval=read_common_sizet, .offset=(signed long int)24ul }, 
    { .keyword="Cached", .storval=read_common_sizet, .offset=(signed long int)32ul }, 
    { .keyword="Inactive", .storval=read_common_sizet, .offset=(signed long int)48ul }, 
    { .keyword="MemFree", .storval=read_common_sizet, .offset=(signed long int)8ul }, 
    { .keyword="MemTotal", .storval=read_common_sizet, .offset=(signed long int)0ul } };
// distro_tbl
// file ../../../../src/OVAL/probes/unix/runlevel.c line 308
const struct anonymous$16 distro_tbl[9l];
// distro_tbl
// file ../../../../src/OVAL/probes/unix/runlevel.c line 308
const struct anonymous$16 distro_tbl[9l] = { { .distrop=is_debian, .get_runlevel=get_runlevel_debian }, 
    { .distrop=is_redhat, .get_runlevel=get_runlevel_sysv }, 
    { .distrop=is_slack, .get_runlevel=get_runlevel_slack }, 
    { .distrop=is_gentoo, .get_runlevel=get_runlevel_gentoo }, 
    { .distrop=is_arch, .get_runlevel=get_runlevel_arch }, 
    { .distrop=is_mandriva, .get_runlevel=get_runlevel_mandriva }, 
    { .distrop=is_suse, .get_runlevel=get_runlevel_suse }, 
    { .distrop=is_solaris, .get_runlevel=get_runlevel_sysv }, 
    { .distrop=is_common, .get_runlevel=get_runlevel_common } };
// next_ID
// file ../../../../../src/OVAL/probes/probe/icache.c line 43
static volatile unsigned int next_ID = (volatile unsigned int)0;
// next_ID_mutex
// file ../../../../../src/OVAL/probes/probe/icache.c line 46
union anonymous next_ID_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// pcre_free
// file /usr/include/pcre.h line 490
extern void (*pcre_free)(void *);
// program_invocation_short_name
// file /usr/include/errno.h line 54
extern char *program_invocation_short_name;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// __abort_cb
// file ../../../../../src/OVAL/probes/probe/signal_handler.c line 47
static signed int __abort_cb(void *n, void *u)
{
  struct anonymous$46 *coll = (struct anonymous$46 *)u;
  struct rbt_i32_node *node = (struct rbt_i32_node *)n;
  struct anonymous$31 *thr = (struct anonymous$31 *)node->data;
  pthread_cancel(thr->tid);
  coll->cnt = coll->cnt + 1ul;
  void *return_value___oscap_realloc$1;
  return_value___oscap_realloc$1=__oscap_realloc((void *)coll->thr, sizeof(struct SEAP_msg *) /*8ul*/  * coll->cnt);
  coll->thr = (struct anonymous$31 **)return_value___oscap_realloc$1;
  coll->thr[(signed long int)(coll->cnt - (unsigned long int)1)] = thr;
  return 0;
}

// __oscap_alloc
// file ../../../../src/common/alloc.h line 49
void * __oscap_alloc(unsigned long int s)
{
  void *m;
  m=malloc(s);
  __oscap_err_check(m);
  return m;
}

// __oscap_calloc
// file ../../../src/common/alloc.c line 61
void * __oscap_calloc(unsigned long int n, unsigned long int s)
{
  void *m;
  m=calloc(n, s);
  __oscap_err_check(m);
  return m;
}

// __oscap_debuglog_close
// file ../../../src/common/debug.c line 75
static void __oscap_debuglog_close(void)
{
  fclose(__debuglog_fp);
}

// __oscap_debuglog_object
// file ../../../../../src/common/debug_priv.h line 69
void __oscap_debuglog_object(const char *file, const char *fn, unsigned long int line, signed int objtype, void *obj)
{
  if(!(__debuglog_fp == ((struct _IO_FILE *)NULL)))
  {
    if((signed int)__debuglog_level >= DBG_D)
    {
      debug_message_start(DBG_D);
      if(objtype == 1)
      {
        SEXP_fprintfa(__debuglog_fp, (struct SEXP *)obj);
        goto __CPROVER_DUMP_L3;
      }

      fprintf(__debuglog_fp, "Attempt to dump a not supported object.");

    __CPROVER_DUMP_L3:
      ;
      debug_message_devel_metadata(file, fn, line);
      debug_message_end();
    }

  }

}

// __oscap_dlprintf
// file ../../../../src/common/debug_priv.h line 60
void __oscap_dlprintf(signed int level, const char *file, const char *fn, unsigned long int line, const char *fmt, ...)
{
  void **ap;
  if(!(__debuglog_fp == ((struct _IO_FILE *)NULL)))
  {
    if((signed int)__debuglog_level >= level)
    {
      ap = (void **)&fmt;
      debug_message_start(level);
      vfprintf(__debuglog_fp, fmt, ap);
      if((signed int)__debuglog_level == DBG_D)
        debug_message_devel_metadata(file, fn, line);

      debug_message_end();
      ap = ((void **)NULL);
    }

  }

}

// __oscap_err_check
// file ../../../src/common/alloc.c line 37
static void __oscap_err_check(void *m)
{
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(m == NULL)
  {
    return_value___errno_location$1=__errno_location();
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    __oscap_seterr("../../../src/common/alloc.c", (unsigned int)41, "__oscap_err_check", (unsigned short int)1, return_value_strerror$2);
  }

}

// __oscap_free
// file ../../../../src/common/alloc.h line 73
void __oscap_free(void *p)
{
  if(!(p == NULL))
    free(p);

}

// __oscap_path_rstrip
// file ../../../src/common/debug.c line 125
static const char * __oscap_path_rstrip(const char *path)
{
  const char *separator;
  separator=strrchr(path, 47);
  if(!(separator == ((const char *)NULL)))
    return separator + (signed long int)1;

  else
    return path;
}

// __oscap_realloc
// file ../../../../../src/common/alloc.h line 61
void * __oscap_realloc(void *p, unsigned long int s)
{
  void *m;
  m=realloc(p, s);
  __oscap_err_check(m);
  return m;
}

// __oscap_reallocf
// file ../../../src/common/alloc.c line 90
void * __oscap_reallocf(void *p, unsigned long int s)
{
  void *m;
  m=realloc(p, s);
  __oscap_err_check(m);
  if(m == NULL && s >= 1ul)
    __oscap_free((void *)p);

  return m;
}

// __oscap_seterr
// file ../../../src/common/_error.h line 58
void __oscap_seterr(const char *file, unsigned int line, const char *func, unsigned short int family, ...)
{
  struct oscap_err_t *err;
  char *msg;
  __builtin_va_list ap;
  const char *fmt;
  pthread_once(&__once, oscap_errkey_init);
  va_start(ap, family);
  fmt=va_arg(ap, __typeof__(fmt));
  msg=oscap_vsprintf(fmt, ap);
  va_end(ap);
  err=oscap_err_new(family, msg, func, line, file);
  __oscap_free((void *)msg);
  _push_err(err);
}

// __oscap_setxmlerr
// file ../../../src/common/_error.h line 38
void __oscap_setxmlerr(const char *file, unsigned int line, const char *func, struct _xmlError *error)
{
  if(!(error == ((struct _xmlError *)NULL)))
  {
    struct oscap_err_t *err;
    pthread_once(&__once, oscap_errkey_init);
    signed int len;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(error->message);
    len = (signed int)return_value_strlen$1;
    if(!(len == 0))
    {
      if((signed int)error->message[(signed long int)(len + -1)] == 10)
        error->message[(signed long int)(len - 1)] = (char)0;

    }

    if(!(error->file == ((char *)NULL)))
    {
      char *msg;
      msg=oscap_sprintf("%s [%s:%d]", error->message, error->file, error->line);
      if(!(msg == ((char *)NULL)))
      {
        err=oscap_err_new((unsigned short int)2, msg, func, line, file);
        __oscap_free((void *)msg);
        _push_err(err);
        goto __CPROVER_DUMP_L4;
      }

    }

    err=oscap_err_new((unsigned short int)2, error->message, func, line, file);
    _push_err(err);
  }


__CPROVER_DUMP_L4:
  ;
}

// __probe_icache_add_nolock
// file ../../../../../src/OVAL/probes/probe/icache.c line 313
static signed int __probe_icache_add_nolock(struct anonymous$15 *cache, struct SEXP *cobj, struct SEXP *item, union anonymous$7 *cond)
{
  while((_Bool)0)
    ;

retry:
  ;
  signed int return_value_pthread_cond_wait$4;
  while((_Bool)1)
  {
    if(!((signed int)cache->queue_cnt >= (signed int)cache->queue_max))
    {
      cache->queue[(signed long int)cache->queue_end].cobj = cobj;
      if(!(item == ((struct SEXP *)NULL)))
      {
        while((_Bool)0)
          ;
        cache->queue[(signed long int)cache->queue_end].p.item = item;
      }

      else
      {
        while((_Bool)0)
          ;
        cache->queue[(signed long int)cache->queue_end].p.cond = cond;
      }
      cache->queue_cnt = cache->queue_cnt + 1;
      cache->queue_end = cache->queue_end + 1;
      if(cache->queue_end == cache->queue_max)
        cache->queue_end = (unsigned short int)0;

      goto __CPROVER_DUMP_L12;
    }

    return_value_pthread_cond_wait$4=pthread_cond_wait(&cache->queue_notfull, &cache->queue_mutex);
    if(!(return_value_pthread_cond_wait$4 == 0))
      break;

  }
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  char *return_value_strerror$3;
  return_value_strerror$3=strerror(*return_value___errno_location$2);
  __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "__probe_icache_add_nolock", (unsigned long int)341, "An error ocured while waiting for the `notfull' queue condition: %u, %s", *return_value___errno_location$1, return_value_strerror$3);
  return -1;

__CPROVER_DUMP_L12:
  ;
  return 0;
}

// __probe_option_op
// file ../../../../../src/OVAL/probes/probe/option.c line 11
static signed int __probe_option_op(signed int option, signed int op, void **ap)
{
  struct anonymous$1 *optdef = ___G_probe_optdef;
  unsigned long int i;
  unsigned long int optdef_count = ___G_probe_optdef_count;
  signed int ret = -1;
  i = (unsigned long int)0;
  for( ; !(i >= optdef_count); i = i + 1ul)
    if(option == (optdef + (signed long int)i)->option)
      ret=(optdef + (signed long int)i)->handler(option, op, ap);

  return ret;
}

// __unlink_cb
// file ../../../src/common/oscap_acquire.c line 64
static signed int __unlink_cb(const char *fpath, struct stat *sb, signed int typeflag, struct FTW *ftwbuf)
{
  signed int rv;
  rv=remove(fpath);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(rv == 0))
  {
    return_value___errno_location$1=__errno_location();
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)69, "__unlink_cb", (unsigned short int)1, (const void *)"Could not remove %s. %s", fpath, return_value_strerror$2);
  }

  return rv;
}

// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void)
{
  asm("");
}

// _oscap_iterator_has_more_internal
// file ../../../src/common/list.c line 315
static inline _Bool _oscap_iterator_has_more_internal(struct oscap_iterator *it)
{
  _Bool tmp_if_expr$1;
  if(it->cur == ((struct oscap_list_item *)NULL))
    tmp_if_expr$1 = it->list->first != ((struct oscap_list_item *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(!(it->cur == ((struct oscap_list_item *)NULL)))
      tmp_if_expr$2 = it->cur->next != ((struct oscap_list_item *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr$3;
}

// _probe_entste_cmp_record
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 292
static enum anonymous$18 _probe_entste_cmp_record(struct SEXP *ent_ste, struct SEXP *ent_itm)
{
  enum anonymous$18 res;
  enum anonymous$36 op;
  enum anonymous$48 ochk;
  struct SEXP *stmp;
  struct SEXP *ste_res;
  struct SEXP *ste_record_fields;
  struct SEXP *ste_rf;
  struct SEXP *itm_record_fields;
  signed int val_cnt;
  stmp=probe_ent_getattrval(ent_ste, "operation");
  if(stmp == ((struct SEXP *)NULL))
    op = (enum anonymous$36)OVAL_OPERATION_EQUALS;

  else
  {
    unsigned int return_value_SEXP_number_getu_32$1;
    return_value_SEXP_number_getu_32$1=SEXP_number_getu_32(stmp);
    op = (enum anonymous$36)return_value_SEXP_number_getu_32$1;
    SEXP_free(stmp);
    if(!((signed int)op == OVAL_OPERATION_EQUALS))
      return (enum anonymous$18)OVAL_RESULT_ERROR;

  }
  val_cnt=probe_ent_getvals(ent_ste, &ste_record_fields);
  if(!(val_cnt >= 1))
  {
    SEXP_free(ste_record_fields);
    return (enum anonymous$18)OVAL_RESULT_ERROR;
  }

  else
  {
    val_cnt=probe_ent_getvals(ent_itm, &itm_record_fields);
    if(!(val_cnt >= 1))
    {
      SEXP_free(ste_record_fields);
      SEXP_free(itm_record_fields);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }

    else
    {
      ste_res=SEXP_list_new((struct SEXP *)(void *)0);
      unsigned int i324 = (unsigned int)1;
      do
      {
        ste_rf=SEXP_list_nth(ste_record_fields, i324);
        if(ste_rf == ((struct SEXP *)NULL))
          break;

        struct SEXP *itm_rf;
        struct SEXP *itm_res;
        const char *sname;
        _Bool matched;
        sname=probe_ent_getname(ste_rf);
        itm_res=SEXP_list_new((struct SEXP *)(void *)0);
        matched = (_Bool)0;
        unsigned int i333 = (unsigned int)1;
        do
        {
          itm_rf=SEXP_list_nth(itm_record_fields, i333);
          if(itm_rf == ((struct SEXP *)NULL))
            break;

          const char *iname;
          iname=probe_ent_getname(itm_rf);
          signed int return_value_strcmp$2;
          return_value_strcmp$2=strcmp(sname, iname);
          if(!(return_value_strcmp$2 == 0))
            __oscap_free((void *)iname);

          else
          {
            __oscap_free((void *)iname);
            matched = (_Bool)1;
            res=probe_entste_cmp(ste_rf, itm_rf);
            stmp=SEXP_number_newu_32((unsigned int)res);
            SEXP_list_add(itm_res, stmp);
            SEXP_free(stmp);
          }
          i333 = i333 + 1u;
          SEXP_free(itm_rf);
          itm_rf = (struct SEXP *)(void *)0;
        }
        while((_Bool)1);
        __oscap_free((void *)sname);
        if(matched == (_Bool)0)
        {
          stmp=SEXP_number_newu_32((unsigned int)OVAL_RESULT_ERROR);
          SEXP_list_add(itm_res, stmp);
          SEXP_free(stmp);
        }

        stmp=probe_ent_getattrval(ste_rf, "entity_check");
        if(stmp == ((struct SEXP *)NULL))
          ochk = (enum anonymous$48)OVAL_CHECK_ALL;

        else
        {
          unsigned int return_value_SEXP_number_getu_32$3;
          return_value_SEXP_number_getu_32$3=SEXP_number_getu_32(stmp);
          ochk = (enum anonymous$48)return_value_SEXP_number_getu_32$3;
          SEXP_free(stmp);
        }
        res=probe_ent_result_bychk(itm_res, ochk);
        SEXP_free(itm_res);
        stmp=SEXP_number_newu_32((unsigned int)res);
        SEXP_list_add(ste_res, stmp);
        SEXP_free(stmp);
        i324 = i324 + 1u;
        SEXP_free(ste_rf);
        ste_rf = (struct SEXP *)(void *)0;
      }
      while((_Bool)1);
      SEXP_free(ste_record_fields);
      SEXP_free(itm_record_fields);
      stmp=probe_ent_getattrval(ent_ste, "entity_check");
      if(stmp == ((struct SEXP *)NULL))
        ochk = (enum anonymous$48)OVAL_CHECK_ALL;

      else
      {
        unsigned int return_value_SEXP_number_getu_32$4;
        return_value_SEXP_number_getu_32$4=SEXP_number_getu_32(stmp);
        ochk = (enum anonymous$48)return_value_SEXP_number_getu_32$4;
        SEXP_free(stmp);
      }
      res=probe_ent_result_bychk(ste_res, ochk);
      SEXP_free(ste_res);
      return res;
    }
  }
}

// _push_err
// file ../../../src/common/error.c line 69
static inline void _push_err(struct oscap_err_t *err)
{
  struct err_queue *q;
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(__key);
  q = (struct err_queue *)return_value_pthread_getspecific$1;
  if(q == ((struct err_queue *)NULL))
  {
    q=err_queue_new();
    pthread_setspecific(__key, (const void *)q);
  }

  err_queue_push(q, err);
}

// _xhtml_to_plaintext
// file ../../../src/common/text.c line 176
char * _xhtml_to_plaintext(const char *xhtml_in)
{
  char *out = (char *)(void *)0;
  char *str;
  str=oscap_sprintf("<x xmlns='http://www.w3.org/1999/xhtml'>%s</x>", xhtml_in);
  struct _xmlDoc *doc;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  doc=xmlParseMemory(str, (signed int)return_value_strlen$1);
  if(doc == ((struct _xmlDoc *)NULL))
  {
    __oscap_free((void *)str);
    return (char *)(void *)0;
  }

  else
  {
    struct _xmlNode *root;
    root=xmlDocGetRootElement(doc);
    if(root == ((struct _xmlNode *)NULL))
    {
      __oscap_free((void *)str);
      return out;
    }

    else
    {
      unsigned char *return_value_xmlNodeGetContent$2;
      return_value_xmlNodeGetContent$2=xmlNodeGetContent(root);
      out = (char *)return_value_xmlNodeGetContent$2;
      xmlFreeDoc(doc);
      __oscap_free((void *)str);
      return out;
    }
  }
}

// cmp_float
// file ../../../../src/OVAL/results/oval_cmp_basic.c line 79
static inline signed int cmp_float(double a, double b)
{
  double relative_err;
  signed int r;
  if(IEEE_FLOAT_EQUAL(a, b))
    return 0;

  else
  {
    r = a > b ? 1 : -1;
    double return_value_fabs$1;
    return_value_fabs$1=fabs(a);
    double return_value_fabs$2;
    return_value_fabs$2=fabs(b);
    if(return_value_fabs$1 > return_value_fabs$2)
      relative_err=fabs((a - b) / a);

    else
      relative_err=fabs((a - b) / b);
    if(relative_err <= 0.000000001)
      return 0;

    else
      return r;
  }
}

// cmpkey
// file ../../../src/common/memusage.c line 69
static signed int cmpkey(const char *a, struct stat_parser *b)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(a, b->keyword);
  return return_value_strcmp$1;
}

// compare_values
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 105
static signed int compare_values(const char *str1, const char *str2)
{
  if(str1 == ((const char *)NULL) && str2 == ((const char *)NULL))
    return 0;

  else
    if(str2 == ((const char *)NULL) && !(str1 == ((const char *)NULL)))
      return 1;

    else
      if(str1 == ((const char *)NULL) && !(str2 == ((const char *)NULL)))
        return -1;

  signed int return_value_rpmvercmp$1;
  return_value_rpmvercmp$1=rpmvercmp(str1, str2);
  return return_value_rpmvercmp$1;
}

// cstr_to_double
// file ../../../../src/OVAL/results/oval_cmp.c line 68
static _Bool cstr_to_double(const char *cstr, double *result)
{
  char *endptr = (char *)(void *)0;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  *result=strtod(cstr, &endptr);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  if(*return_value___errno_location$2 == 34)
    return (_Bool)0;

  else
  {
    if(endptr == cstr)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      return (_Bool)0;
    }

    if(!((signed int)*endptr == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 22;
      return (_Bool)0;
    }

    return (_Bool)1;
  }
}

// cstr_to_intmax
// file ../../../../src/OVAL/results/oval_cmp.c line 45
static _Bool cstr_to_intmax(const char *cstr, signed long int *result)
{
  char *endptr = (char *)(void *)0;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  *result=strtoimax(cstr, &endptr, 10);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  if(*return_value___errno_location$2 == 34)
    return (_Bool)0;

  else
  {
    if(endptr == cstr)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      return (_Bool)0;
    }

    if(!((signed int)*endptr == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 22;
      return (_Bool)0;
    }

    return (_Bool)1;
  }
}

// debug_message_devel_metadata
// file ../../../src/common/debug.c line 169
static void debug_message_devel_metadata(const char *file, const char *fn, unsigned long int line)
{
  const char *f;
  f=__oscap_path_rstrip(file);
  char thread_name[16l];
  unsigned long int thread;
  thread=pthread_self();
  pthread_getname_np(thread, thread_name, (unsigned long int)16);
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  fprintf(__debuglog_fp, " [%s(%ld):%s(%llx):%s:%zu:%s]", program_invocation_short_name, (signed long int)return_value_getpid$1, (const void *)thread_name, (unsigned long long int)thread, f, line, fn);
}

// debug_message_end
// file ../../../src/common/debug.c line 186
static void debug_message_end()
{
  fputc(10, __debuglog_fp);
  signed int return_value_fileno$1;
  return_value_fileno$1=fileno(__debuglog_fp);
  signed int return_value_flock$2;
  return_value_flock$2=flock(return_value_fileno$1, 8);
  if(return_value_flock$2 == -1)
    abort();

  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&__debuglog_mutex);
    if(!(return_value_pthread_mutex_unlock$3 == 0))
      abort();

  }
  while((_Bool)0);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// debug_message_start
// file ../../../src/common/debug.c line 136
static void debug_message_start(signed int level)
{
  char l;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&__debuglog_mutex);
    if(!(return_value_pthread_mutex_lock$1 == 0))
      abort();

  }
  while((_Bool)0);
  signed int return_value_fileno$3;
  return_value_fileno$3=fileno(__debuglog_fp);
  signed int return_value_flock$4;
  return_value_flock$4=flock(return_value_fileno$3, 2);
  if(return_value_flock$4 == -1)
    do
    {
      signed int return_value_pthread_mutex_unlock$2;
      return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&__debuglog_mutex);
      if(!(return_value_pthread_mutex_unlock$2 == 0))
        abort();

    }
    while((_Bool)0);

  else
  {
    switch(level)
    {
      case DBG_E:
      {
        l = (char)69;
        break;
      }
      case DBG_W:
      {
        l = (char)87;
        break;
      }
      case DBG_I:
      {
        l = (char)73;
        break;
      }
      case DBG_D:
      {
        l = (char)68;
        break;
      }
      default:
        l = (char)48;
    }
    fprintf(__debuglog_fp, "%c: %s: ", l, program_invocation_short_name);
  }
}

// err_queue_free
// file ../../../src/common/err_queue.c line 91
void err_queue_free(struct err_queue *q, void (*destructor)(void *))
{
  _Bool return_value_err_queue_is_empty$1;
  struct oscap_err_t *return_value_err_queue_pop_first$2;
  if(!(q == ((struct err_queue *)NULL)))
  {
    if(!(destructor == ((void (*)(void *))NULL)))
    {
      return_value_err_queue_is_empty$1=err_queue_is_empty(q);
      if(return_value_err_queue_is_empty$1 == (_Bool)0)
      {
        return_value_err_queue_pop_first$2=err_queue_pop_first(q);
        destructor((void *)return_value_err_queue_pop_first$2);
      }

    }

    free((void *)q);
  }

}

// err_queue_get_last
// file ../../../src/common/err_queue.c line 82
struct oscap_err_t * err_queue_get_last(struct err_queue *q)
{
  _Bool tmp_if_expr$1;
  if(q == ((struct err_queue *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = q->last == (struct oscap_err_t *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (struct oscap_err_t *)(void *)0;

  else
    return q->last;
}

// err_queue_is_empty
// file ../../../src/common/err_queue.c line 59
_Bool err_queue_is_empty(struct err_queue *q)
{
  if(q == ((struct err_queue *)NULL))
    return (_Bool)1;

  else
    return q->last == (struct oscap_err_t *)(void *)0;
}

// err_queue_new
// file ../../../src/common/err_queue.c line 35
struct err_queue * err_queue_new(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct err_queue) /*16ul*/ );
  return (struct err_queue *)return_value_calloc$1;
}

// err_queue_pop_first
// file ../../../src/common/err_queue.c line 68
struct oscap_err_t * err_queue_pop_first(struct err_queue *q)
{
  _Bool tmp_if_expr$1;
  if(q == ((struct err_queue *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = q->first == (struct oscap_err_t *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (struct oscap_err_t *)(void *)0;

  else
  {
    struct oscap_err_t *pom = q->first;
    q->first = pom->next;
    if(q->last == pom)
      q->last = (struct oscap_err_t *)(void *)0;

    return pom;
  }
}

// err_queue_push
// file ../../../src/common/err_queue.c line 40
_Bool err_queue_push(struct err_queue *q, struct oscap_err_t *error)
{
  if(q == ((struct err_queue *)NULL) || error == ((struct oscap_err_t *)NULL))
    return (_Bool)0;

  else
  {
    error->next = (struct oscap_err_t *)(void *)0;
    if(q->last == ((struct oscap_err_t *)NULL))
    {
      q->first = error;
      q->last = error;
    }

    else
    {
      q->last->next = error;
      q->last = error;
    }
    return (_Bool)1;
  }
}

// err_queue_to_string
// file ../../../src/common/err_queue.c line 102
signed int err_queue_to_string(struct err_queue *q, char **result)
{
  if(result == ((char **)NULL) || q == ((struct err_queue *)NULL))
    return 1;

  else
  {
    unsigned long int size = (unsigned long int)0;
    struct oscap_err_t *err = q->first;
    for( ; !(err == ((struct oscap_err_t *)NULL)); err = err->next)
      if(!(err->desc == ((char *)NULL)))
      {
        signed int pom;
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(err->desc);
        pom = (signed int)return_value_strlen$1;
        if(!(pom == 0))
          size = size + (unsigned long int)(pom + 1);

      }

    if(size == 0ul)
    {
      *result = (char *)(void *)0;
      return 0;
    }

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(size + (unsigned long int)1);
      *result = (char *)return_value_malloc$2;
      if(*result == ((char *)NULL))
        return 1;

      else
      {
        char *pos = *result;
        pos[(signed long int)0] = (char)0;
        err = q->first;
        for( ; !(err == ((struct oscap_err_t *)NULL)); err = err->next)
          if(!(err->desc == ((char *)NULL)))
          {
            pos=stpcpy(pos, err->desc);
            pos=stpcpy(pos, "\n");
          }

        (*result)[(signed long int)(size - (unsigned long int)1)] = (char)0;
        return 0;
      }
    }
  }
}

// fail
// file ../../../../../src/OVAL/probes/probe/main.c line 48
static signed int fail(signed int err, const char *who, signed int line)
{
  char *return_value_strerror$1;
  return_value_strerror$1=strerror(err);
  fprintf(stderr, "FAIL: %d:%s: %d, %s\n", line, who, err, return_value_strerror$1);
  exit(err);
}

// get_runlevel
// file ../../../../src/OVAL/probes/unix/runlevel.c line 343
static signed int get_runlevel(struct runlevel_req *req, struct runlevel_rep **rep)
{
  signed int return_value_get_runlevel_generic$1;
  return_value_get_runlevel_generic$1=get_runlevel_generic(req, rep);
  return return_value_get_runlevel_generic$1;
}

// get_runlevel_arch
// file ../../../../src/OVAL/probes/unix/runlevel.c line 225
static signed int get_runlevel_arch(struct runlevel_req *req, struct runlevel_rep **rep)
{
  return -1;
}

// get_runlevel_common
// file ../../../../src/OVAL/probes/unix/runlevel.c line 240
static signed int get_runlevel_common(struct runlevel_req *req, struct runlevel_rep **rep)
{
  return -1;
}

// get_runlevel_debian
// file ../../../../src/OVAL/probes/unix/runlevel.c line 210
static signed int get_runlevel_debian(struct runlevel_req *req, struct runlevel_rep **rep)
{
  return -1;
}

// get_runlevel_generic
// file ../../../../src/OVAL/probes/unix/runlevel.c line 322
static signed int get_runlevel_generic(struct runlevel_req *req, struct runlevel_rep **rep)
{
  unsigned short int i = (unsigned short int)0;
  signed int return_value_1;
  signed int return_value;
  if(!((unsigned long int)i >= 9ul))
  {
    return_value_1=distro_tbl[(signed long int)i].distrop();
    if(!(return_value_1 == 0))
    {
      return_value=distro_tbl[(signed long int)i].get_runlevel(req, rep);
      return return_value;
    }

    i = i + 1;
  }

  abort();
  return -1;
}

// get_runlevel_gentoo
// file ../../../../src/OVAL/probes/unix/runlevel.c line 220
static signed int get_runlevel_gentoo(struct runlevel_req *req, struct runlevel_rep **rep)
{
  return -1;
}

// get_runlevel_mandriva
// file ../../../../src/OVAL/probes/unix/runlevel.c line 230
static signed int get_runlevel_mandriva(struct runlevel_req *req, struct runlevel_rep **rep)
{
  return -1;
}

// get_runlevel_slack
// file ../../../../src/OVAL/probes/unix/runlevel.c line 215
static signed int get_runlevel_slack(struct runlevel_req *req, struct runlevel_rep **rep)
{
  return -1;
}

// get_runlevel_suse
// file ../../../../src/OVAL/probes/unix/runlevel.c line 235
static signed int get_runlevel_suse(struct runlevel_req *req, struct runlevel_rep **rep)
{
  return -1;
}

// get_runlevel_sysv
// file ../../../../src/OVAL/probes/unix/runlevel.c line 88
static signed int get_runlevel_sysv(struct runlevel_req *req, struct runlevel_rep **rep)
{
  const char runlevel_list[7l] = { (const char)48, (const char)49, (const char)50, (const char)51, (const char)52, (const char)53, (const char)54 };
  const char *init_path = "/etc/rc.d/init.d";
  const char *rc_path = "/etc/rc%c.d";
  char pathbuf[4096l];
  struct __dirstream *init_dir;
  struct __dirstream *rc_dir;
  struct dirent *init_dp;
  struct dirent *rc_dp;
  struct stat init_st;
  struct stat rc_st;
  struct runlevel_rep *rep_lst = (struct runlevel_rep *)(void *)0;
  init_dir=opendir(init_path);
  if(init_dir == ((struct __dirstream *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "get_runlevel_sysv", (unsigned long int)109, "Can't open directory \"%s\": errno=%d, %s.", init_path, *return_value___errno_location$1, return_value_strerror$3);
    return -1;
  }

  do
  {
    init_dp=readdir(init_dir);
    if(init_dp == ((struct dirent *)NULL))
      break;

    char *service_name;
    unsigned int i;
    struct SEXP *r0;
    signed int return_value_dirfd$7;
    return_value_dirfd$7=dirfd(init_dir);
    signed int return_value_fchdir$8;
    return_value_fchdir$8=fchdir(return_value_dirfd$7);
    if(!(return_value_fchdir$8 == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "get_runlevel_sysv", (unsigned long int)122, "Can't fchdir to \"%s\": errno=%d, %s.", init_path, *return_value___errno_location$4, return_value_strerror$6);
      closedir(init_dir);
      return -1;
    }

    signed int return_value_stat$12;
    return_value_stat$12=stat(init_dp->d_name, &init_st);
    if(!(return_value_stat$12 == 0))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      char *return_value_strerror$11;
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "get_runlevel_sysv", (unsigned long int)129, "Can't stat file %s/%s: errno=%d, %s.", init_path, (const void *)init_dp->d_name, *return_value___errno_location$9, return_value_strerror$11);
      continue;
    }

    r0=SEXP_string_newf("%s", (const void *)init_dp->d_name);
    enum anonymous$18 return_value_probe_entobj_cmp$13;
    return_value_probe_entobj_cmp$13=probe_entobj_cmp(req->service_name_ent, r0);
    if(!((signed int)return_value_probe_entobj_cmp$13 == OVAL_RESULT_TRUE))
      SEXP_free(r0);

    else
    {
      SEXP_free(r0);
      service_name = init_dp->d_name;
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= sizeof(const char [7l]) /*7ul*/ ); i = i + 1u)
      {
        char runlevel[2l] = { (char)0, (char)0 };
        _Bool start;
        _Bool kill;
        r0=SEXP_string_newf("%c", runlevel_list[(signed long int)i]);
        enum anonymous$18 return_value_probe_entobj_cmp$14;
        return_value_probe_entobj_cmp$14=probe_entobj_cmp(req->runlevel_ent, r0);
        if(!((signed int)return_value_probe_entobj_cmp$14 == OVAL_RESULT_TRUE))
          SEXP_free(r0);

        else
        {
          SEXP_free(r0);
          runlevel[(signed long int)0] = runlevel_list[(signed long int)i];
          snprintf(pathbuf, sizeof(char [4096l]) /*4096ul*/ , rc_path, runlevel_list[(signed long int)i]);
          rc_dir=opendir(pathbuf);
          if(rc_dir == ((struct __dirstream *)NULL))
          {
            signed int *return_value___errno_location$15;
            return_value___errno_location$15=__errno_location();
            signed int *return_value___errno_location$16;
            return_value___errno_location$16=__errno_location();
            char *return_value_strerror$17;
            return_value_strerror$17=strerror(*return_value___errno_location$16);
            __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "get_runlevel_sysv", (unsigned long int)157, "Can't open directory \"%s\": errno=%d, %s.", rc_path, *return_value___errno_location$15, return_value_strerror$17);
            goto __CPROVER_DUMP_L18;
          }

          signed int return_value_chdir$21;
          return_value_chdir$21=chdir(pathbuf);
          if(!(return_value_chdir$21 == 0))
          {
            signed int *return_value___errno_location$18;
            return_value___errno_location$18=__errno_location();
            signed int *return_value___errno_location$19;
            return_value___errno_location$19=__errno_location();
            char *return_value_strerror$20;
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "get_runlevel_sysv", (unsigned long int)162, "Can't fchdir to \"%s\": errno=%d, %s.", rc_path, *return_value___errno_location$18, return_value_strerror$20);
            closedir(rc_dir);
            goto __CPROVER_DUMP_L18;
          }

          kill = (_Bool)0;
          start = kill;
          do
          {
            rc_dp=readdir(rc_dir);
            if(rc_dp == ((struct dirent *)NULL))
              break;

            signed int return_value_stat$25;
            return_value_stat$25=stat(rc_dp->d_name, &rc_st);
            if(!(return_value_stat$25 == 0))
            {
              signed int *return_value___errno_location$22;
              return_value___errno_location$22=__errno_location();
              signed int *return_value___errno_location$23;
              return_value___errno_location$23=__errno_location();
              char *return_value_strerror$24;
              return_value_strerror$24=strerror(*return_value___errno_location$23);
              __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "get_runlevel_sysv", (unsigned long int)172, "Can't stat file %s/%s: errno=%d, %s.", rc_path, (const void *)rc_dp->d_name, *return_value___errno_location$22, return_value_strerror$24);
              continue;
            }

            if(init_st.st_ino == rc_st.st_ino)
            {
              if((signed int)rc_dp->d_name[0l] == 83)
              {
                start = (_Bool)1;
                break;
              }

              else
                if((signed int)rc_dp->d_name[0l] == 75)
                {
                  kill = (_Bool)1;
                  break;
                }

                else
                  __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "get_runlevel_sysv", (unsigned long int)185, "Unexpected character in filename: %c, %s/%s.", rc_dp->d_name[(signed long int)0], (const void *)pathbuf, (const void *)rc_dp->d_name);
            }

          }
          while((_Bool)1);
          closedir(rc_dir);
          if(rep_lst == ((struct runlevel_rep *)NULL))
          {
            void *return_value___oscap_alloc$26;
            return_value___oscap_alloc$26=__oscap_alloc(sizeof(struct runlevel_rep) /*32ul*/ );
            *rep = (struct runlevel_rep *)return_value___oscap_alloc$26;
            rep_lst = *rep;
          }

          else
          {
            void *return_value___oscap_alloc$27;
            return_value___oscap_alloc$27=__oscap_alloc(sizeof(struct runlevel_rep) /*32ul*/ );
            rep_lst->next = (struct runlevel_rep *)return_value___oscap_alloc$27;
            rep_lst = rep_lst->next;
          }
          rep_lst->service_name=strdup(service_name);
          rep_lst->runlevel=strdup(runlevel);
          rep_lst->start = start;
          rep_lst->kill = kill;
          rep_lst->next = (struct runlevel_rep *)(void *)0;
        }

      __CPROVER_DUMP_L18:
        ;
      }
    }
  }
  while((_Bool)1);
  closedir(init_dir);
  return 1;
}

// ipaddr_cmp
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 53
static inline signed int ipaddr_cmp(signed int af, const void *addr1, const void *addr2)
{
  signed int return_value_memcmp$1;
  if(af == 2)
  {
    return_value_memcmp$1=memcmp(addr1, addr2, sizeof(struct in_addr) /*4ul*/ );
    return return_value_memcmp$1;
  }

  else
  {
    signed int return_value_memcmp$2;
    return_value_memcmp$2=memcmp(addr1, addr2, sizeof(struct in6_addr) /*16ul*/ );
    return return_value_memcmp$2;
  }
}

// ipaddr_mask
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 63
static inline void ipaddr_mask(signed int af, const void *ip_addr, unsigned int mask)
{
  if(af == 2)
    ipv4addr_mask((struct in_addr *)ip_addr, mask);

  else
    if(af == 10)
      ipv6addr_mask((struct in6_addr *)ip_addr, (signed int)mask);

}

// ipaddr_parse
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 74
static inline signed int ipaddr_parse(signed int af, const char *oval_ip_string, unsigned int *mask_out, void *ip_out)
{
  signed int return_value_ipv4addr_parse$1;
  if(af == 2)
  {
    return_value_ipv4addr_parse$1=ipv4addr_parse(oval_ip_string, mask_out, (struct in_addr *)ip_out);
    return return_value_ipv4addr_parse$1;
  }

  else
  {
    signed int return_value_ipv6addr_parse$2;
    return_value_ipv6addr_parse$2=ipv6addr_parse(oval_ip_string, mask_out, (struct in6_addr *)ip_out);
    return return_value_ipv6addr_parse$2;
  }
}

// ipv4addr_mask
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 227
static inline void ipv4addr_mask(struct in_addr *ip_addr, unsigned int netmask)
{
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl(netmask);
  ip_addr->s_addr = ip_addr->s_addr & return_value_htonl$1;
}

// ipv4addr_parse
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 196
static inline signed int ipv4addr_parse(const char *oval_ipv4_string, unsigned int *netmask_out, struct in_addr *ip_out)
{
  char *s;
  char *pfx;
  signed int result = -1;
  s=strdup(oval_ipv4_string);
  pfx=strchr(s, 47);
  char *tmp_post$1;
  if(!(pfx == ((char *)NULL)))
  {
    signed int cnt;
    unsigned char nm[4l];
    tmp_post$1 = pfx;
    pfx = pfx + 1l;
    *tmp_post$1 = (char)0;
    cnt=sscanf(pfx, "%hhu.%hhu.%hhu.%hhu", &nm[(signed long int)0], &nm[(signed long int)1], &nm[(signed long int)2], &nm[(signed long int)3]);
    if(cnt >= 2)
      *netmask_out = (unsigned int)(((signed int)nm[(signed long int)0] << 24) + ((signed int)nm[(signed long int)1] << 16) + ((signed int)nm[(signed long int)2] << 8) + (signed int)nm[(signed long int)3]);

    else
      *netmask_out = (unsigned int)(~0 << 32 - (signed int)nm[(signed long int)0]);
  }

  else
    *netmask_out = (unsigned int)~0;
  signed int return_value_inet_pton$2;
  return_value_inet_pton$2=inet_pton(2, s, (void *)ip_out);
  if(!(return_value_inet_pton$2 >= 1))
    __oscap_dlprintf(DBG_W, "../../../../src/OVAL/results/oval_cmp_ip_address.c", "ipv4addr_parse", (unsigned long int)219, "inet_pton() failed.");

  else
    result = 0;
  __oscap_free((void *)s);
  return result;
}

// ipv6addr_mask
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 255
static inline void ipv6addr_mask(struct in6_addr *addr, signed int prefix_len)
{
  unsigned char mask = (unsigned char)(~0 << 8 - prefix_len % 8);
  signed int i = prefix_len / 8;
  for( ; !(i >= 16); i = i + 1)
  {
    addr->__in6_u.__u6_addr8[(signed long int)i] = addr->__in6_u.__u6_addr8[(signed long int)i] & mask;
    mask = (unsigned char)0;
  }
}

// ipv6addr_parse
// file ../../../../src/OVAL/results/oval_cmp_ip_address.c line 232
static inline signed int ipv6addr_parse(const char *oval_ipv6_string, unsigned int *len_out, struct in6_addr *ip_out)
{
  char *s;
  char *pfx;
  signed int result = -1;
  s=strdup(oval_ipv6_string);
  pfx=strchr(s, 47);
  char *tmp_post$1;
  if(!(pfx == ((char *)NULL)))
  {
    tmp_post$1 = pfx;
    pfx = pfx + 1l;
    *tmp_post$1 = (char)0;
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(pfx, (char ** restrict )(void *)0, 10);
    *len_out = (unsigned int)return_value_strtol$2;
  }

  else
    *len_out = (unsigned int)128;
  signed int return_value_inet_pton$3;
  return_value_inet_pton$3=inet_pton(10, s, (void *)ip_out);
  if(!(return_value_inet_pton$3 >= 1))
    __oscap_dlprintf(DBG_W, "../../../../src/OVAL/results/oval_cmp_ip_address.c", "ipv6addr_parse", (unsigned long int)247, "inet_pton() failed.");

  else
    result = 0;
  __oscap_free((void *)s);
  return result;
}

// is_arch
// file ../../../../src/OVAL/probes/unix/runlevel.c line 272
static signed int is_arch(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/arch-release", &st);
  return (signed int)(return_value_stat$1 == 0);
}

// is_common
// file ../../../../src/OVAL/probes/unix/runlevel.c line 298
static signed int is_common(void)
{
  return 1;
}

// is_debian
// file ../../../../src/OVAL/probes/unix/runlevel.c line 253
static signed int is_debian(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/debian_version", &st);
  _Bool tmp_if_expr$3;
  signed int return_value_stat$2;
  if(return_value_stat$1 == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_stat$2=stat("/etc/debian_release", &st);
    tmp_if_expr$3 = return_value_stat$2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$3;
}

// is_gentoo
// file ../../../../src/OVAL/probes/unix/runlevel.c line 266
static signed int is_gentoo(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/gentoo-release", &st);
  return (signed int)(return_value_stat$1 == 0);
}

// is_mandriva
// file ../../../../src/OVAL/probes/unix/runlevel.c line 278
static signed int is_mandriva(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/mandriva-release", &st);
  return (signed int)(return_value_stat$1 == 0);
}

// is_redhat
// file ../../../../src/OVAL/probes/unix/runlevel.c line 247
static signed int is_redhat(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/redhat-release", &st);
  return (signed int)(return_value_stat$1 == 0);
}

// is_slack
// file ../../../../src/OVAL/probes/unix/runlevel.c line 260
static signed int is_slack(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/slackware-release", &st);
  return (signed int)(return_value_stat$1 == 0);
}

// is_solaris
// file ../../../../src/OVAL/probes/unix/runlevel.c line 292
static signed int is_solaris(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/release", &st);
  return (signed int)(return_value_stat$1 == 0);
}

// is_suse
// file ../../../../src/OVAL/probes/unix/runlevel.c line 284
static signed int is_suse(void)
{
  struct stat st;
  signed int return_value_stat$1;
  return_value_stat$1=stat("/etc/SuSE-release", &st);
  _Bool tmp_if_expr$3;
  signed int return_value_stat$2;
  if(return_value_stat$1 == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_stat$2=stat("/etc/sles-release", &st);
    tmp_if_expr$3 = return_value_stat$2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_stat$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_stat$4=stat("/etc/novell-release", &st);
    tmp_if_expr$5 = return_value_stat$4 == 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$5;
}

// istrcmp
// file ../../../../src/OVAL/results/oval_cmp_basic.c line 118
static signed int istrcmp(const char *st1, const char *st2)
{
  if(st1 == ((const char *)NULL))
    st1 = "";

  if(st2 == ((const char *)NULL))
    st2 = "";

  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(st1, st2);
  return return_value_strcasecmp$1;
}

// lookup_xsi_ns
// file ../../../src/common/elements.c line 257
struct _xmlNs * lookup_xsi_ns(struct _xmlDoc *doc)
{
  struct _xmlNs *ns_xsi;
  struct _xmlNode *return_value_xmlDocGetRootElement$1;
  return_value_xmlDocGetRootElement$1=xmlDocGetRootElement(doc);
  ns_xsi=xmlSearchNsByHref(doc, return_value_xmlDocGetRootElement$1, (unsigned char *)"http://www.w3.org/2001/XMLSchema-instance");
  if(ns_xsi == ((struct _xmlNs *)NULL))
  {
    struct _xmlNode *return_value_xmlDocGetRootElement$2;
    return_value_xmlDocGetRootElement$2=xmlDocGetRootElement(doc);
    ns_xsi=xmlNewNs(return_value_xmlDocGetRootElement$2, (unsigned char *)"http://www.w3.org/2001/XMLSchema-instance", (unsigned char *)"xsi");
  }

  return ns_xsi;
}

// main
// file ../../../../../src/OVAL/probes/probe/main.c line 164
signed int main(signed int argc, char **argv)
{
  union pthread_attr_t th_attr;
  struct anonymous$24 sigmask;
  struct anonymous$23 probe;
  char *rootdir = (char *)(void *)0;
  char *verbosity_level;
  verbosity_level=getenv("OSCAP_PROBE_VERBOSITY_LEVEL");
  char *verbose_log_file;
  verbose_log_file=getenv("OSCAP_PROBE_VERBOSE_LOG_FILE");
  oscap_set_verbose(verbosity_level, verbose_log_file, (_Bool)1);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2=pthread_barrier_init(&___G_th_barrier, (const union anonymous$0 *)(void *)0, (unsigned int)(1 + 1 + 1 + 0));
  if(!(*return_value___errno_location$2 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    fail(*return_value___errno_location$1, "pthread_barrier_init", 182 - 6);
  }

  sigemptyset(&sigmask);
  sigaddset(&sigmask, 1);
  sigaddset(&sigmask, 10);
  sigaddset(&sigmask, 12);
  sigaddset(&sigmask, 2);
  sigaddset(&sigmask, 15);
  sigaddset(&sigmask, 3);
  sigaddset(&sigmask, 13);
  signed int return_value_pthread_sigmask$4;
  return_value_pthread_sigmask$4=pthread_sigmask(0, &sigmask, (struct anonymous$24 *)(void *)0);
  signed int *return_value___errno_location$3;
  if(!(return_value_pthread_sigmask$4 == 0))
  {
    return_value___errno_location$3=__errno_location();
    fail(*return_value___errno_location$3, "pthread_sigmask", 199 - 1);
  }

  probe.flags = (unsigned int)0;
  probe.pid=getpid();
  probe.name=__xpg_basename(argv[(signed long int)0]);
  probe.probe_exitcode = 0;
  probe.SEAP_ctx=SEAP_CTX_new();
  probe.sd=SEAP_openfd2(probe.SEAP_ctx, 0, 1, (unsigned int)0);
  signed int *return_value___errno_location$5;
  if(!(probe.sd >= 0))
  {
    return_value___errno_location$5=__errno_location();
    fail(*return_value___errno_location$5, "SEAP_openfd2", 213 - 3);
  }

  signed int return_value_SEAP_cmd_register$7;
  return_value_SEAP_cmd_register$7=SEAP_cmd_register(probe.SEAP_ctx, (unsigned short int)3, (unsigned int)0, probe_reset);
  signed int *return_value___errno_location$6;
  if(!(return_value_SEAP_cmd_register$7 == 0))
  {
    return_value___errno_location$6=__errno_location();
    fail(*return_value___errno_location$6, "SEAP_cmd_register", 216 - 1);
  }

  probe.rcache=probe_rcache_new();
  probe.ncache=probe_ncache_new();
  probe.icache=probe_icache_new();
  ___G_ncache = probe.ncache;
  void *return_value___oscap_alloc$8;
  return_value___oscap_alloc$8=__oscap_alloc(sizeof(struct anonymous$1) /*16ul*/  * (unsigned long int)3);
  probe.option = (struct anonymous$1 *)return_value___oscap_alloc$8;
  probe.optcnt = (unsigned long int)3;
  (probe.option + (signed long int)0)->option = 0;
  (probe.option + (signed long int)0)->handler = probe_opthandler_varref;
  (probe.option + (signed long int)1)->option = 1;
  (probe.option + (signed long int)1)->handler = probe_opthandler_rcache;
  (probe.option + (signed long int)2)->option = 2;
  (probe.option + (signed long int)2)->handler = probe_opthandler_offlinemode;
  ___G_probe_optdef = probe.option;
  ___G_probe_optdef_count = probe.optcnt;
  pthread_attr_init(&th_attr);
  signed int return_value_pthread_attr_setdetachstate$10;
  return_value_pthread_attr_setdetachstate$10=pthread_attr_setdetachstate(&th_attr, 0);
  signed int *return_value___errno_location$9;
  if(!(return_value_pthread_attr_setdetachstate$10 == 0))
  {
    return_value___errno_location$9=__errno_location();
    fail(*return_value___errno_location$9, "pthread_attr_setdetachstate", 251 - 1);
  }

  signed int return_value_pthread_create$12;
  return_value_pthread_create$12=pthread_create(&probe.th_signal, &th_attr, probe_signal_handler, (void *)&probe);
  signed int *return_value___errno_location$11;
  if(!(return_value_pthread_create$12 == 0))
  {
    return_value___errno_location$11=__errno_location();
    fail(*return_value___errno_location$11, "pthread_create(probe_signal_handler)", 254 - 1);
  }

  pthread_attr_destroy(&th_attr);
  rootdir=getenv("OSCAP_PROBE_ROOT");
  if(!(rootdir == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$17;
    return_value_strlen$17=strlen(rootdir);
    if(return_value_strlen$17 >= 1ul)
    {
      signed int return_value_chdir$14;
      return_value_chdir$14=chdir(rootdir);
      if(!(return_value_chdir$14 == 0))
      {
        signed int *return_value___errno_location$13;
        return_value___errno_location$13=__errno_location();
        fail(*return_value___errno_location$13, "chdir", 264 - 1);
      }

      signed int return_value_chroot$16;
      return_value_chroot$16=chroot(rootdir);
      if(!(return_value_chroot$16 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        fail(*return_value___errno_location$15, "chroot", 267 - 1);
      }

      ___G_offline_mode = ___G_offline_mode | (enum anonymous$25)PROBE_OFFLINE_CHROOT;
    }

  }

  char *return_value_getenv$18;
  return_value_getenv$18=getenv("OSCAP_PROBE_RPMDB_PATH");
  if(!(return_value_getenv$18 == ((char *)NULL)))
    ___G_offline_mode = ___G_offline_mode | (enum anonymous$25)PROBE_OFFLINE_RPMDB;

  probe.workers=rbt_i32_new();
  probe.probe_arg=probe_init();
  pthread_attr_init(&th_attr);
  signed int return_value_pthread_create$20;
  return_value_pthread_create$20=pthread_create(&probe.th_input, &th_attr, probe_input_handler, (void *)&probe);
  signed int *return_value___errno_location$19;
  if(!(return_value_pthread_create$20 == 0))
  {
    return_value___errno_location$19=__errno_location();
    fail(*return_value___errno_location$19, "pthread_create(probe_input_handler)", 292 - 1);
  }

  pthread_attr_destroy(&th_attr);
  signed int return_value_pthread_join$22;
  return_value_pthread_join$22=pthread_join(probe.th_signal, (void **)(void *)0);
  signed int *return_value___errno_location$21;
  if(!(return_value_pthread_join$22 == 0))
  {
    return_value___errno_location$21=__errno_location();
    fail(*return_value___errno_location$21, "pthread_join", 300 - 1);
  }

  struct timespec j_tm;
  signed int return_value_clock_gettime$24;
  return_value_clock_gettime$24=clock_gettime(0, &j_tm);
  signed int *return_value___errno_location$23;
  if(return_value_clock_gettime$24 == -1)
  {
    return_value___errno_location$23=__errno_location();
    fail(*return_value___errno_location$23, "clock_gettime", 310 - 1);
  }

  j_tm.tv_sec = j_tm.tv_sec + (signed long int)3;
  signed int return_value_pthread_timedjoin_np$26;
  return_value_pthread_timedjoin_np$26=pthread_timedjoin_np(probe.th_input, (void **)(void *)0, &j_tm);
  signed int *return_value___errno_location$25;
  if(!(return_value_pthread_timedjoin_np$26 == 0))
  {
    return_value___errno_location$25=__errno_location();
    fail(*return_value___errno_location$25, "pthread_timedjoin_np", 315 - 1);
  }

  probe_fini(probe.probe_arg);
  probe_ncache_free(probe.ncache);
  probe_rcache_free(probe.rcache);
  probe_icache_free(probe.icache);
  rbt_i32_free(probe.workers);
  if(!(probe.sd == -1))
    SEAP_close(probe.SEAP_ctx, probe.sd);

  SEAP_CTX_free(probe.SEAP_ctx);
  __oscap_free((void *)probe.option);
  return probe.probe_exitcode;
}

// oscap_acquire_cleanup_dir
// file ../../../src/common/oscap_acquire.c line 75
void oscap_acquire_cleanup_dir(char **dir_path)
{
  if(!(*dir_path == ((char *)NULL)))
  {
    nftw(*dir_path, __unlink_cb, 64, 8 | 1 | 2);
    free((void *)*dir_path);
    *dir_path = (char *)(void *)0;
  }

}

// oscap_acquire_ensure_parent_dir
// file ../../../src/common/oscap_acquire.c line 257
signed int oscap_acquire_ensure_parent_dir(const char *filepath)
{
  char *filepath_cpy;
  filepath_cpy=oscap_strdup(filepath);
  char *dirpath;
  dirpath=dirname(filepath_cpy);
  signed int ret;
  ret=oscap_acquire_mkdir_p(dirpath);
  if(!(ret == 0))
    __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)263, "oscap_acquire_ensure_parent_dir", (unsigned short int)1, (const void *)"Error making directory '%s' to ensure correct path of '%s'.", dirpath, filepath);

  free((void *)filepath_cpy);
  return ret;
}

// oscap_acquire_guess_realpath
// file ../../../src/common/oscap_acquire.c line 204
char * oscap_acquire_guess_realpath(const char *filepath)
{
  char *rpath;
  rpath=realpath(filepath, (char *)(void *)0);
  if(rpath == ((char *)NULL))
  {
    char *copy;
    copy=strdup(filepath);
    char *real_dir;
    char *return_value_dirname$1;
    return_value_dirname$1=dirname(copy);
    real_dir=realpath(return_value_dirname$1, (char *)(void *)0);
    if(real_dir == ((char *)NULL))
    {
      __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)213, "oscap_acquire_guess_realpath", (unsigned short int)3, (const void *)"Cannot guess realpath for %s, directory: %s does not exists!", filepath, real_dir);
      free((void *)copy);
      return (char *)(void *)0;
    }

    char *return_value___xpg_basename$2;
    return_value___xpg_basename$2=__xpg_basename((char *)filepath);
    rpath=oscap_sprintf("%s/%s", real_dir, return_value___xpg_basename$2);
    free((void *)real_dir);
    free((void *)copy);
  }

  return rpath;
}

// oscap_acquire_mkdir_p
// file ../../../src/common/oscap_acquire.c line 224
signed int oscap_acquire_mkdir_p(const char *path)
{
  unsigned long int return_value_strlen$8;
  return_value_strlen$8=strlen(path);
  unsigned long int return_value_strlen$1;
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$5;
  if(return_value_strlen$8 >= 4097ul)
    return -1;

  else
  {
    char temp[4097l];
    unsigned int i = (unsigned int)0;
    do
    {
      return_value_strlen$1=strlen(path);
      if(!(return_value_strlen$1 >= (unsigned long int)i))
        break;

      if((signed int)path[(signed long int)i] == 47)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)path[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        strncpy(temp, path, (unsigned long int)i);
        temp[(signed long int)i] = (char)0;
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(temp);
        if(!(return_value_strlen$2 == 0ul))
        {
          signed int return_value_mkdir$6;
          return_value_mkdir$6=mkdir(temp, (unsigned int)(0400 | 0200 | 0100));
          if(!(return_value_mkdir$6 == 0))
          {
            return_value___errno_location$5=__errno_location();
            if(!(*return_value___errno_location$5 == 17))
            {
              signed int *return_value___errno_location$3;
              return_value___errno_location$3=__errno_location();
              char *return_value_strerror$4;
              return_value_strerror$4=strerror(*return_value___errno_location$3);
              __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)247, "oscap_acquire_mkdir_p", (unsigned short int)1, (const void *)"Error making directory '%s', while doing recursive mkdir for '%s', error was '%s'.", (const void *)temp, path, return_value_strerror$4);
              return -1;
            }

          }

        }

      }

      i = i + 1u;
    }
    while((_Bool)1);
    return 0;
  }
}

// oscap_acquire_pipe_to_string
// file ../../../src/common/oscap_acquire.c line 183
char * oscap_acquire_pipe_to_string(signed int fd)
{
  struct oscap_string *pipe_string;
  pipe_string=oscap_string_new();
  char readbuf;
  signed long int return_value_read$1;
  do
  {
    return_value_read$1=read(fd, (void *)&readbuf, (unsigned long int)1);
    if(!(return_value_read$1 >= 1l))
      break;

    if((signed int)readbuf == 38)
      oscap_string_append_string(pipe_string, "&amp;");

    else
      oscap_string_append_char(pipe_string, readbuf);
  }
  while((_Bool)1);
  close(fd);
  char *return_value_oscap_string_bequeath$2;
  return_value_oscap_string_bequeath$2=oscap_string_bequeath(pipe_string);
  return return_value_oscap_string_bequeath$2;
}

// oscap_acquire_temp_dir
// file ../../../src/common/oscap_acquire.c line 52
char * oscap_acquire_temp_dir(void)
{
  char *temp_dir;
  temp_dir=strdup("/tmp/oscap.XXXXXX");
  char *return_value_mkdtemp$3;
  return_value_mkdtemp$3=mkdtemp(temp_dir);
  if(return_value_mkdtemp$3 == ((char *)NULL))
  {
    free((void *)temp_dir);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)57, "oscap_acquire_temp_dir", (unsigned short int)1, (const void *)"Could not create temp directory /tmp/oscap.XXXXXX. %s", return_value_strerror$2);
    return (char *)(void *)0;
  }

  return temp_dir;
}

// oscap_acquire_temp_file
// file ../../../src/common/oscap_acquire.c line 86
signed int oscap_acquire_temp_file(const char *dir, const char *template, char **filename)
{
  unsigned int old_mode;
  signed int fd;
  if(filename == ((char **)NULL) || dir == ((const char *)NULL) || template == ((const char *)NULL))
    return -1;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)4096 * sizeof(char) /*1ul*/ );
    *filename = (char *)return_value_malloc$1;
    snprintf(*filename, (unsigned long int)4096, "%s/%s", dir, template);
    old_mode=umask((unsigned int)077);
    fd=mkstemp(*filename);
    umask(old_mode);
    if(!(fd >= 1))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)101, "oscap_acquire_temp_file", (unsigned short int)1, (const void *)"mkstemp for %s failed: %s", *filename, return_value_strerror$3);
      free((void *)*filename);
      *filename = (char *)(void *)0;
    }

    return fd;
  }
}

// oscap_acquire_url_download
// file ../../../src/common/oscap_acquire.c line 146
char * oscap_acquire_url_download(const char *url, unsigned long int *memory_size)
{
  void *curl;
  curl=curl_easy_init();
  if(curl == NULL)
  {
    __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)151, "oscap_acquire_url_download", (unsigned short int)7, (const void *)"Failed to initialize libcurl.");
    return (char *)(void *)0;
  }

  else
  {
    struct oscap_buffer *buffer;
    buffer=oscap_buffer_new();
    signed int oscap_acquire_url_download$$1$$2$$_curl_opt = CURLOPT_URL;
    curl_easy_setopt(curl, (enum anonymous$19)oscap_acquire_url_download$$1$$2$$_curl_opt, url);
    signed int oscap_acquire_url_download$$1$$3$$_curl_opt = CURLOPT_WRITEFUNCTION;
    curl_easy_setopt(curl, (enum anonymous$19)oscap_acquire_url_download$$1$$3$$_curl_opt, write_to_memory_callback);
    signed int _curl_opt = CURLOPT_WRITEDATA;
    curl_easy_setopt(curl, (enum anonymous$19)_curl_opt, buffer);
    enum anonymous$28 res;
    res=curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    if(!((signed int)res == 0))
    {
      const char *return_value_curl_easy_strerror$1;
      return_value_curl_easy_strerror$1=curl_easy_strerror(res);
      __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)165, "oscap_acquire_url_download", (unsigned short int)7, (const void *)"Download failed: %s", return_value_curl_easy_strerror$1);
      oscap_buffer_free(buffer);
      return (char *)(void *)0;
    }

    *memory_size=oscap_buffer_get_length(buffer);
    char *data;
    data=oscap_buffer_bequeath(buffer);
    return data;
  }
}

// oscap_acquire_url_is_supported
// file ../../../src/common/oscap_acquire.c line 109
_Bool oscap_acquire_url_is_supported(const char *url)
{
  _Bool return_value_oscap_str_startswith$1;
  return_value_oscap_str_startswith$1=oscap_str_startswith(url, "http://");
  _Bool tmp_if_expr$3;
  _Bool return_value_oscap_str_startswith$2;
  if(!(return_value_oscap_str_startswith$1 == (_Bool)0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_oscap_str_startswith$2=oscap_str_startswith(url, "https://");
    tmp_if_expr$3 = return_value_oscap_str_startswith$2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr$3;
}

// oscap_acquire_url_to_filename
// file ../../../src/common/oscap_acquire.c line 115
char * oscap_acquire_url_to_filename(const char *url)
{
  char *curl_filename = (char *)(void *)0;
  char *filename = (char *)(void *)0;
  void *curl;
  enum anonymous$28 return_value_curl_global_init$1;
  return_value_curl_global_init$1=curl_global_init((signed long int)(1 << 0 | 1 << 1));
  if(!((signed int)return_value_curl_global_init$1 == 0))
  {
    __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)123, "oscap_acquire_url_to_filename", (unsigned short int)7, (const void *)"Failed to initialize libcurl.");
    return (char *)(void *)0;
  }

  else
  {
    curl=curl_easy_init();
    if(curl == NULL)
    {
      __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)128, "oscap_acquire_url_to_filename", (unsigned short int)7, (const void *)"Failed to initialize libcurl.");
      return (char *)(void *)0;
    }

    else
    {
      curl_filename=curl_easy_escape(curl, url, 0);
      if(curl_filename == ((char *)NULL))
      {
        curl_easy_cleanup(curl);
        curl_global_cleanup();
        __oscap_seterr("../../../src/common/oscap_acquire.c", (unsigned int)136, "oscap_acquire_url_to_filename", (unsigned short int)7, (const void *)"Failed to escape the given url %s", url);
        return (char *)(void *)0;
      }

      else
      {
        filename=strdup(curl_filename);
        curl_free((void *)curl_filename);
        curl_easy_cleanup(curl);
        curl_global_cleanup();
        return filename;
      }
    }
  }
}

// oscap_apply_xslt
// file ../../../src/common/oscapxml.c line 145
signed int oscap_apply_xslt(const char *xmlfile, const char *xsltfile, const char *outfile, const char **params)
{
  struct oscap_source *source;
  source=oscap_source_new_from_file(xmlfile);
  signed int ret;
  const char *return_value_oscap_path_to_xslt$1;
  return_value_oscap_path_to_xslt$1=oscap_path_to_xslt();
  ret=oscap_source_apply_xslt_path(source, xsltfile, outfile, params, return_value_oscap_path_to_xslt$1);
  oscap_source_free(source);
  return ret;
}

// oscap_bfind
// file ../../../../../src/common/bfind.h line 32
void * oscap_bfind(void *ptr, unsigned long int nmemb, unsigned long int size, void *key, signed int (*cmpfn)(void *, void *))
{
  unsigned long int w;
  unsigned long int s;
  signed int cmp;
  unsigned char *p;
  w = nmemb;
  s = (unsigned long int)0;
  p = (unsigned char *)ptr;
  if(w >= 1ul)
  {
    cmp=cmpfn(key, (void *)(p + (signed long int)(size * (s + w / (unsigned long int)2))));
    if(cmp >= 1)
    {
      s = s + w / (unsigned long int)2 + (unsigned long int)1;
      w = (w - w / (unsigned long int)2) - (unsigned long int)1;
    }

    else
      if(!(cmp >= 0))
        w = w / (unsigned long int)2;

      else
        return (void *)(p + (signed long int)(size * (s + w / (unsigned long int)2)));
  }

  return (void *)0;
}

// oscap_bfind_i
// file ../../../src/common/bfind.c line 60
signed int oscap_bfind_i(void *ptr, unsigned long int nmemb, unsigned long int size, void *key, signed int (*cmpfn)(void *, void *), unsigned long int *save)
{
  unsigned long int w;
  unsigned long int s;
  signed int cmp;
  unsigned char *p;
  w = nmemb;
  s = (unsigned long int)0;
  p = (unsigned char *)ptr;
  if(w >= 1ul)
  {
    cmp=cmpfn(key, (void *)(p + (signed long int)(size * (s + w / (unsigned long int)2))));
    if(cmp >= 1)
    {
      s = s + w / (unsigned long int)2 + (unsigned long int)1;
      w = (w - w / (unsigned long int)2) - (unsigned long int)1;
    }

    else
      if(!(cmp >= 0))
        w = w / (unsigned long int)2;

      else
        return (signed int)(s + w / (unsigned long int)2);
  }

  if(!(save == ((unsigned long int *)NULL)))
    *save = s;

  return -1;
}

// oscap_buffer_append_binary_data
// file ../../../src/common/oscap_buffer.h line 69
void oscap_buffer_append_binary_data(struct oscap_buffer *s, const char *data, const unsigned long int append_length)
{
  if(!(data == ((const char *)NULL)) && !(s == ((struct oscap_buffer *)NULL)))
  {
    if(!(s->capacity >= 1ul + s->length + append_length))
    {
      s->capacity = (((s->capacity + append_length) - (unsigned long int)1) / (unsigned long int)64 + (unsigned long int)1) * (unsigned long int)64;
      void *return_value___oscap_realloc$1;
      return_value___oscap_realloc$1=__oscap_realloc((void *)s->data, s->capacity);
      s->data = (char *)return_value___oscap_realloc$1;
    }

    memcpy((void *)(s->data + (signed long int)s->length), (const void *)data, append_length);
    s->length = s->length + append_length;
    s->data[(signed long int)s->length] = (char)0;
  }

}

// oscap_buffer_append_string
// file ../../../src/common/oscap_buffer.c line 97
void oscap_buffer_append_string(struct oscap_buffer *s, const char *t)
{
  if(!(t == ((const char *)NULL)))
  {
    unsigned long int append_length;
    append_length=strlen(t);
    oscap_buffer_append_binary_data(s, t, append_length);
  }

}

// oscap_buffer_bequeath
// file ../../../src/common/oscap_buffer.h line 48
char * oscap_buffer_bequeath(struct oscap_buffer *s)
{
  char *str = s->data;
  __oscap_free((void *)s);
  return str;
}

// oscap_buffer_clear
// file ../../../src/common/oscap_buffer.c line 58
void oscap_buffer_clear(struct oscap_buffer *s)
{
  s->data[(signed long int)0] = (char)0;
  s->length = (unsigned long int)0;
}

// oscap_buffer_free
// file ../../../src/common/oscap_buffer.h line 41
void oscap_buffer_free(struct oscap_buffer *s)
{
  if(!(s == ((struct oscap_buffer *)NULL)))
  {
    __oscap_free((void *)s->data);
    __oscap_free((void *)s);
  }

}

// oscap_buffer_get_length
// file ../../../src/common/oscap_buffer.h line 90
unsigned long int oscap_buffer_get_length(struct oscap_buffer *s)
{
  return s->length;
}

// oscap_buffer_get_raw
// file ../../../src/common/oscap_buffer.c line 105
char * oscap_buffer_get_raw(struct oscap_buffer *s)
{
  return s->data;
}

// oscap_buffer_new
// file ../../../src/common/oscap_buffer.h line 35
struct oscap_buffer * oscap_buffer_new(void)
{
  struct oscap_buffer *s;
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc(sizeof(struct oscap_buffer) /*24ul*/ );
  s = (struct oscap_buffer *)return_value___oscap_alloc$1;
  void *return_value___oscap_alloc$2;
  return_value___oscap_alloc$2=__oscap_alloc((unsigned long int)64);
  s->data = (char *)return_value___oscap_alloc$2;
  s->data[(signed long int)0] = (char)0;
  s->length = (unsigned long int)0;
  s->capacity = (unsigned long int)64;
  return s;
}

// oscap_cleanup
// file ../../../src/common/oscapxml.c line 110
void oscap_cleanup(void)
{
  oscap_clearerr();
  xsltCleanupGlobals();
  xmlCleanupParser();
}

// oscap_clearerr
// file ../../../src/common/error.c line 127
void oscap_clearerr(void)
{
  struct err_queue *q;
  pthread_once(&__once, oscap_errkey_init);
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(__key);
  q = (struct err_queue *)return_value_pthread_getspecific$1;
  pthread_setspecific(__key, (void *)0);
  err_queue_free(q, (void (*)(void *))oscap_err_free);
}

// oscap_create_lists
// file ../../../src/common/list.c line 41
void oscap_create_lists(struct oscap_list **first, ...)
{
  __builtin_va_list ap;
  va_start(ap, first);
  struct oscap_list **cur = first;
  while(!(cur == ((struct oscap_list **)NULL)))
  {
    *cur=oscap_list_new();
    cur=va_arg(ap, __typeof__(cur));
  }
  va_end(ap);
}

// oscap_determine_document_type
// file ../../../src/common/oscapxml.c line 153
signed int oscap_determine_document_type(const char *document, enum oscap_document_type *doc_type)
{
  struct oscap_source *source;
  source=oscap_source_new_from_file(document);
  *doc_type=oscap_source_get_scap_type(source);
  oscap_source_free(source);
  return (signed int)*doc_type == OSCAP_DOCUMENT_UNKNOWN ? -1 : 0;
}

// oscap_document_type_to_string
// file ../../../src/common/oscapxml.c line 160
const char * oscap_document_type_to_string(enum oscap_document_type type)
{
  switch((signed int)type)
  {
    case OSCAP_DOCUMENT_OVAL_DEFINITIONS:
      return "OVAL Definition";
    case OSCAP_DOCUMENT_OVAL_DIRECTIVES:
      return "OVAL Directives";
    case OSCAP_DOCUMENT_OVAL_RESULTS:
      return "OVAL Results";
    case OSCAP_DOCUMENT_OVAL_SYSCHAR:
      return "OVAL System Characteristics";
    case OSCAP_DOCUMENT_OVAL_VARIABLES:
      return "OVAL Variables";
    case OSCAP_DOCUMENT_SDS:
      return "SCAP Source Datastream";
    case OSCAP_DOCUMENT_XCCDF:
      return "XCCDF Checklist";
    case OSCAP_DOCUMENT_XCCDF_TAILORING:
      return "XCCDF Tailoring";
    case OSCAP_DOCUMENT_SCE_RESULT:
      return "SCE Results";
    case OSCAP_DOCUMENT_CPE_DICTIONARY:
      return "CPE Dictionary";
    case OSCAP_DOCUMENT_CPE_LANGUAGE:
      return "CPE Language";
    case OSCAP_DOCUMENT_ARF:
      return "ARF Result Datastream";
    case OSCAP_DOCUMENT_CVE_FEED:
      return "CVE NVD Feed";
    default:
      return (const char *)(void *)0;
  }
}

// oscap_element_depth
// file ../../../src/common/elements.c line 142
signed int oscap_element_depth(struct _xmlTextReader *reader)
{
  signed int depth;
  depth=xmlTextReaderDepth(reader);
  signed int return_value_xmlTextReaderNodeType$1;
  return_value_xmlTextReaderNodeType$1=xmlTextReaderNodeType(reader);
  if(return_value_xmlTextReaderNodeType$1 == 2 || return_value_xmlTextReaderNodeType$1 == 3 || return_value_xmlTextReaderNodeType$1 == 5)
    return depth - 1;

  return depth;
}

// oscap_element_string_copy
// file ../../../src/common/elements.c line 116
char * oscap_element_string_copy(struct _xmlTextReader *reader)
{
  signed int t;
  signed int return_value_xmlTextReaderIsEmptyElement$1;
  return_value_xmlTextReaderIsEmptyElement$1=xmlTextReaderIsEmptyElement(reader);
  unsigned char *return_value_xmlTextReaderValue$2;
  void *return_value_calloc$3;
  if(!(return_value_xmlTextReaderIsEmptyElement$1 == 0))
    return (char *)(void *)0;

  else
  {
    t=xmlTextReaderNodeType(reader);
    if(t == XML_ELEMENT_NODE || t == XML_ATTRIBUTE_NODE)
      xmlTextReaderRead(reader);

    signed int return_value_xmlTextReaderHasValue$4;
    return_value_xmlTextReaderHasValue$4=xmlTextReaderHasValue(reader);
    if(!(return_value_xmlTextReaderHasValue$4 == 0))
    {
      return_value_xmlTextReaderValue$2=xmlTextReaderValue(reader);
      return (char *)return_value_xmlTextReaderValue$2;
    }

    else
    {
      return_value_calloc$3=calloc((unsigned long int)1, (unsigned long int)1);
      return (char *)return_value_calloc$3;
    }
  }
}

// oscap_element_string_get
// file ../../../src/common/elements.c line 132
const char * oscap_element_string_get(struct _xmlTextReader *reader)
{
  signed int return_value_xmlTextReaderNodeType$1;
  return_value_xmlTextReaderNodeType$1=xmlTextReaderNodeType(reader);
  _Bool tmp_if_expr$3;
  signed int return_value_xmlTextReaderNodeType$2;
  if(return_value_xmlTextReaderNodeType$1 == 1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_xmlTextReaderNodeType$2=xmlTextReaderNodeType(reader);
    tmp_if_expr$3 = return_value_xmlTextReaderNodeType$2 == 2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    xmlTextReaderRead(reader);

  signed int return_value_xmlTextReaderHasValue$5;
  return_value_xmlTextReaderHasValue$5=xmlTextReaderHasValue(reader);
  const unsigned char *return_value_xmlTextReaderConstValue$4;
  if(!(return_value_xmlTextReaderHasValue$5 == 0))
  {
    return_value_xmlTextReaderConstValue$4=xmlTextReaderConstValue(reader);
    return (const char *)return_value_xmlTextReaderConstValue$4;
  }

  else
    return (const char *)(void *)0;
}

// oscap_enum_to_string
// file ../../../src/common/util.c line 48
const char * oscap_enum_to_string(struct oscap_string_map *map, signed int val)
{
  for( ; !(map->string == ((const char *)NULL)); map = map + 1l)
    if(map->value == val)
      break;

  return map->string;
}

// oscap_err
// file ../../../src/common/error.c line 138
_Bool oscap_err(void)
{
  pthread_once(&__once, oscap_errkey_init);
  struct err_queue *q;
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(__key);
  q = (struct err_queue *)return_value_pthread_getspecific$1;
  _Bool tmp_if_expr$3;
  _Bool return_value_err_queue_is_empty$2;
  if(!(q == ((struct err_queue *)NULL)))
  {
    return_value_err_queue_is_empty$2=err_queue_is_empty(q);
    tmp_if_expr$3 = !(return_value_err_queue_is_empty$2 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return tmp_if_expr$3;
}

// oscap_err_desc
// file ../../../src/common/error.c line 157
const char * oscap_err_desc(void)
{
  struct err_queue *q;
  pthread_once(&__once, oscap_errkey_init);
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(__key);
  q = (struct err_queue *)return_value_pthread_getspecific$1;
  _Bool tmp_if_expr$3;
  _Bool return_value_err_queue_is_empty$2;
  if(q == ((struct err_queue *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_err_queue_is_empty$2=err_queue_is_empty(q);
    tmp_if_expr$3 = return_value_err_queue_is_empty$2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return ((const char *)NULL);

  else
  {
    struct oscap_err_t *return_value_err_queue_get_last$4;
    return_value_err_queue_get_last$4=err_queue_get_last(q);
    return (const char *)return_value_err_queue_get_last$4->desc;
  }
}

// oscap_err_family
// file ../../../src/common/error.c line 145
unsigned short int oscap_err_family(void)
{
  struct err_queue *q;
  pthread_once(&__once, oscap_errkey_init);
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(__key);
  q = (struct err_queue *)return_value_pthread_getspecific$1;
  _Bool tmp_if_expr$3;
  _Bool return_value_err_queue_is_empty$2;
  if(q == ((struct err_queue *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_err_queue_is_empty$2=err_queue_is_empty(q);
    tmp_if_expr$3 = return_value_err_queue_is_empty$2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return (unsigned short int)0;

  else
  {
    struct oscap_err_t *return_value_err_queue_get_last$4;
    return_value_err_queue_get_last$4=err_queue_get_last(q);
    return return_value_err_queue_get_last$4->family;
  }
}

// oscap_err_free
// file ../../../src/common/error.c line 62
static void oscap_err_free(struct oscap_err_t *err)
{
  if(!(err->desc == ((char *)NULL)))
    __oscap_free((void *)err->desc);

  __oscap_free((void *)err);
}

// oscap_err_get_full_error
// file ../../../src/common/error.c line 169
char * oscap_err_get_full_error(void)
{
  struct err_queue *q;
  char *res = (char *)(void *)0;
  pthread_once(&__once, oscap_errkey_init);
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(__key);
  q = (struct err_queue *)return_value_pthread_getspecific$1;
  _Bool tmp_if_expr$3;
  _Bool return_value_err_queue_is_empty$2;
  if(q == ((struct err_queue *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_err_queue_is_empty$2=err_queue_is_empty(q);
    tmp_if_expr$3 = return_value_err_queue_is_empty$2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return (char *)(void *)0;

  else
  {
    signed int return_value_err_queue_to_string$4;
    return_value_err_queue_to_string$4=err_queue_to_string(q, &res);
    if(!(return_value_err_queue_to_string$4 == 0))
      return (char *)(void *)0;

    else
    {
      pthread_setspecific(__key, (void *)0);
      err_queue_free(q, (void (*)(void *))oscap_err_free);
      return res;
    }
  }
}

// oscap_err_new
// file ../../../src/common/error.c line 45
static struct oscap_err_t * oscap_err_new(unsigned short int family, const char *desc, const char *func, unsigned int line, const char *file)
{
  struct oscap_err_t *err;
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc(sizeof(struct oscap_err_t) /*48ul*/ );
  err = (struct oscap_err_t *)return_value___oscap_alloc$1;
  err->family = family;
  err->desc=oscap_sprintf("%s [%s:%d]", desc, file, line);
  err->func = func;
  err->line = line;
  err->file = file;
  __oscap_dlprintf(DBG_E, "../../../src/common/error.c", "oscap_err_new", (unsigned long int)57, "(%s:%d:%s()) %s", file, line, func, desc);
  return err;
}

// oscap_errkey_init
// file ../../../src/common/error.c line 40
static void oscap_errkey_init(void)
{
  pthread_key_create(&__key, (void (*)(void *))(void *)0);
}

// oscap_expand_ipv6
// file ../../../src/common/util.c line 219
char * oscap_expand_ipv6(const char *input)
{
  const char *input_it = input;
  unsigned short int component_count = (unsigned short int)1;
  for( ; !(*input_it == 0); input_it = input_it + 1l)
    if((signed int)*input_it == 58)
    {
      if(!(input_it == input))
        component_count = component_count + 1;

      input_it = input_it + 1l;
    }

  char *ret;
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc((unsigned long int)(8 * 4) * sizeof(char) /*1ul*/  + (unsigned long int)7 + (unsigned long int)1);
  ret = (char *)return_value___oscap_alloc$1;
  char *output_it = ret;
  input_it = input;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  while(!(*input_it == 0))
  {
    _Bool closed_component = (_Bool)0;
    if((signed int)*input_it == 58)
    {
      const char next = input_it[(signed long int)((unsigned long int)1 * sizeof(char) /*1ul*/ )];
      if((signed int)next == 58)
      {
        input_it = input_it + 1l;
        unsigned short int i = component_count;
        for( ; !((signed int)i >= 8); i = i + 1)
        {
          if(!(output_it == ret))
          {
            tmp_post$2 = output_it;
            output_it = output_it + 1l;
            *tmp_post$2 = (char)58;
          }

          tmp_post$3 = output_it;
          output_it = output_it + 1l;
          *tmp_post$3 = (char)48;
          closed_component = (_Bool)1;
        }
      }

      else
        closed_component = (_Bool)1;
    }

    else
    {
      tmp_post$4 = output_it;
      output_it = output_it + 1l;
      *tmp_post$4 = *input_it;
    }
    input_it = input_it + 1l;
    if(!(closed_component == (_Bool)0))
    {
      if(!(*input_it == 0))
      {
        tmp_post$5 = output_it;
        output_it = output_it + 1l;
        *tmp_post$5 = (char)58;
      }

    }

  }
  *output_it = (char)0;
  return ret;
}

// oscap_free
// file ../../../src/common/alloc.h line 74
static void oscap_free(void *p)
{
  __oscap_free(p);
}

// oscap_get_date
// file ../../../src/common/elements.c line 160
signed long int oscap_get_date(const char *date)
{
  if(!(date == ((const char *)NULL)))
  {
    struct tm tm;
    memset((void *)&tm, 0, sizeof(struct tm) /*56ul*/ );
    signed int return_value_sscanf$2;
    return_value_sscanf$2=sscanf(date, "%d-%d-%d", &tm.tm_year, &tm.tm_mon, &tm.tm_mday);
    if(return_value_sscanf$2 == 3)
    {
      tm.tm_mon = tm.tm_mon - 1;
      tm.tm_year = tm.tm_year - 1900;
      signed long int return_value_mktime$1;
      return_value_mktime$1=mktime(&tm);
      return return_value_mktime$1;
    }

  }

  return (signed long int)0;
}

// oscap_get_datetime
// file ../../../src/common/elements.c line 174
signed long int oscap_get_datetime(const char *date)
{
  if(!(date == ((const char *)NULL)))
  {
    struct tm tm;
    memset((void *)&tm, 0, sizeof(struct tm) /*56ul*/ );
    signed int return_value_sscanf$2;
    return_value_sscanf$2=sscanf(date, "%d-%d-%dT%d:%d:%d", &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec);
    if(return_value_sscanf$2 == 6)
    {
      tm.tm_mon = tm.tm_mon - 1;
      tm.tm_year = tm.tm_year - 1900;
      signed long int return_value_mktime$1;
      return_value_mktime$1=mktime(&tm);
      return return_value_mktime$1;
    }

  }

  return (signed long int)0;
}

// oscap_get_version
// file ../../../src/common/oscapxml.c line 117
const char * oscap_get_version(void)
{
  return "1.2.8";
}

// oscap_get_xml
// file ../../../src/common/elements.c line 155
char * oscap_get_xml(struct _xmlTextReader *reader)
{
  unsigned char *return_value_xmlTextReaderReadInnerXml$1;
  return_value_xmlTextReaderReadInnerXml$1=xmlTextReaderReadInnerXml(reader);
  return (char *)return_value_xmlTextReaderReadInnerXml$1;
}

// oscap_htable_add
// file ../../../src/common/list.c line 451
_Bool oscap_htable_add(struct oscap_htable *htable, const char *key, void *item)
{
  struct oscap_htable_item *return_value_oscap_htable_lookup$1;
  return_value_oscap_htable_lookup$1=oscap_htable_lookup(htable, key);
  if(!(return_value_oscap_htable_lookup$1 == ((struct oscap_htable_item *)NULL)))
    return (_Bool)0;

  else
  {
    unsigned int hashcode;
    hashcode=oscap_htable_hash(key, htable->hsize);
    struct oscap_htable_item *newhtitem;
    void *return_value___oscap_alloc$2;
    return_value___oscap_alloc$2=__oscap_alloc(sizeof(struct oscap_htable_item) /*24ul*/ );
    newhtitem = (struct oscap_htable_item *)return_value___oscap_alloc$2;
    newhtitem->key=strdup(key);
    newhtitem->value = item;
    newhtitem->next = htable->table[(signed long int)hashcode];
    htable->table[(signed long int)hashcode] = newhtitem;
    htable->itemcount = htable->itemcount + 1ul;
    return (_Bool)1;
  }
}

// oscap_htable_clone
// file ../../../src/common/list.c line 405
struct oscap_htable * oscap_htable_clone(struct oscap_htable *table, void * (*cloner)(void *))
{
  struct oscap_htable *t;
  t=oscap_htable_new();
  if(t == ((struct oscap_htable *)NULL))
    return (struct oscap_htable *)(void *)0;

  else
  {
    unsigned long int i = (unsigned long int)0;
    for( ; !(i >= table->hsize); i = i + 1ul)
    {
      struct oscap_htable_item *item = table->table[(signed long int)i];
      if(!(item == ((struct oscap_htable_item *)NULL)))
      {
        void *return_value;
        return_value=cloner(item->value);
        oscap_htable_add(t, item->key, (void *)return_value);
        item = item->next;
      }

    }
    return t;
  }
}

// oscap_htable_cmp
// file ../../../src/common/list.c line 422
static signed int oscap_htable_cmp(const char *s1, const char *s2)
{
  if(s1 == ((const char *)NULL))
    return -1;

  else
    if(s2 == ((const char *)NULL))
      return 1;

    else
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(s1, s2);
      return return_value_strcmp$1;
    }
}

// oscap_htable_detach
// file ../../../src/common/list.c line 478
void * oscap_htable_detach(struct oscap_htable *htable, const char *key)
{
  struct oscap_htable_item *htitem;
  htitem=oscap_htable_lookup(htable, key);
  if(!(htitem == ((struct oscap_htable_item *)NULL)))
  {
    void *val = htitem->value;
    free((void *)htitem->key);
    htitem->key = (char *)(void *)0;
    htitem->value = (void *)0;
    htable->itemcount = htable->itemcount - 1ul;
    return val;
  }

  return (void *)0;
}

// oscap_htable_dump
// file ../../../src/common/list.c line 501
void oscap_htable_dump(struct oscap_htable *htable, void (*dumper)(), signed int depth)
{
  if(htable == ((struct oscap_htable *)NULL))
    printf(" (NULL hash table)\n");

  else
  {
    printf(" (hash table, %u item%s)\n", (unsigned int)htable->itemcount, htable->itemcount == (unsigned long int)1 ? "" : "s");
    signed int i = 0;
    for( ; !(i >= (signed int)htable->hsize); i = i + 1)
    {
      struct oscap_htable_item *item = htable->table[(signed long int)i];
      if(!(item == ((struct oscap_htable_item *)NULL)))
      {
        oscap_print_depth(depth);
        printf("'%s':\n", item->key);
        dumper(item->value, depth + 1);
        item = item->next;
      }

    }
  }
}

// oscap_htable_free
// file ../../../src/common/list.c line 520
void oscap_htable_free(struct oscap_htable *htable, void (*destructor)(void *))
{
  if(!(htable == ((struct oscap_htable *)NULL)))
  {
    unsigned long int ht;
    struct oscap_htable_item *cur;
    struct oscap_htable_item *next;
    ht = (unsigned long int)0;
    for( ; !(ht >= htable->hsize); ht = ht + 1ul)
    {
      cur = htable->table[(signed long int)ht];
      for( ; !(cur == ((struct oscap_htable_item *)NULL)); cur = next)
      {
        next = cur->next;
        free((void *)cur->key);
        if(!(destructor == ((void (*)(void *))NULL)))
          destructor(cur->value);

        free((void *)cur);
      }
    }
    free((void *)htable->table);
    free((void *)htable);
  }

}

// oscap_htable_free0
// file ../../../src/common/list.c line 543
void oscap_htable_free0(struct oscap_htable *htable)
{
  oscap_htable_free(htable, (void (*)(void *))(void *)0);
}

// oscap_htable_get
// file ../../../src/common/list.c line 492
void * oscap_htable_get(struct oscap_htable *htable, const char *key)
{
  struct oscap_htable_item *htitem;
  htitem=oscap_htable_lookup(htable, key);
  void *tmp_if_expr$1;
  if(!(htitem == ((struct oscap_htable_item *)NULL)))
    tmp_if_expr$1 = htitem->value;

  else
    tmp_if_expr$1 = (void *)0;
  return tmp_if_expr$1;
}

// oscap_htable_hash
// file ../../../src/common/list.c line 376
static inline unsigned int oscap_htable_hash(const char *str, unsigned long int htable_size)
{
  unsigned int h = (unsigned int)0;
  unsigned char *p = (unsigned char *)str;
  for( ; !((signed int)*p == 0); p = p + 1l)
    h = (unsigned int)97 * h + (unsigned int)*p;
  return (unsigned int)((unsigned long int)h % htable_size);
}

// oscap_htable_iterator_free
// file ../../../src/common/list.c line 647
void oscap_htable_iterator_free(struct oscap_htable_iterator *hit)
{
  __oscap_free((void *)hit);
}

// oscap_htable_iterator_has_more
// file ../../../src/common/list.c line 565
_Bool oscap_htable_iterator_has_more(struct oscap_htable_iterator *hit)
{
  if(hit->htable == ((struct oscap_htable *)NULL))
    return (_Bool)0;

  else
  {
    unsigned long int i = hit->hpos;
    if(!(hit->cur == ((struct oscap_htable_item *)NULL)))
    {
      if(!(hit->cur->next == ((struct oscap_htable_item *)NULL)))
        return (_Bool)1;

      if(1ul + i >= hit->htable->hsize)
        return (_Bool)0;

      i = i + 1ul;
    }

    for( ; !(i >= hit->htable->hsize); i = i + 1ul)
      if(!(hit->htable->table[(signed long int)i] == ((struct oscap_htable_item *)NULL)))
      {
        if(!(i == hit->hpos))
          hit->hpos = i - (unsigned long int)1;

        return (_Bool)1;
      }

    hit->hpos = i;
    return (_Bool)0;
  }
}

// oscap_htable_iterator_new
// file ../../../src/common/list.c line 555
struct oscap_htable_iterator * oscap_htable_iterator_new(struct oscap_htable *htable)
{
  struct oscap_htable_iterator *hit;
  void *return_value___oscap_calloc$1;
  return_value___oscap_calloc$1=__oscap_calloc((unsigned long int)1, sizeof(struct oscap_htable_iterator) /*24ul*/ );
  hit = (struct oscap_htable_iterator *)return_value___oscap_calloc$1;
  hit->htable = htable;
  hit->cur = (struct oscap_htable_item *)(void *)0;
  hit->hpos = (unsigned long int)0;
  return hit;
}

// oscap_htable_iterator_next
// file ../../../src/common/list.c line 590
struct oscap_htable_item * oscap_htable_iterator_next(struct oscap_htable_iterator *hit)
{
  if(!(hit->cur == ((struct oscap_htable_item *)NULL)))
  {
    if(!(hit->cur->next == ((struct oscap_htable_item *)NULL)))
    {
      hit->cur = hit->cur->next;
      return hit->cur;
    }

    if(1ul + hit->hpos >= hit->htable->hsize)
      return (struct oscap_htable_item *)(void *)0;

    hit->hpos = hit->hpos + 1ul;
  }

  for( ; !(hit->hpos >= hit->htable->hsize); hit->hpos = hit->hpos + 1ul)
    if(!(hit->htable->table[(signed long int)hit->hpos] == ((struct oscap_htable_item *)NULL)))
    {
      hit->cur = hit->htable->table[(signed long int)hit->hpos];
      return hit->cur;
    }

  return (struct oscap_htable_item *)(void *)0;
}

// oscap_htable_iterator_next_key
// file ../../../src/common/list.c line 615
const char * oscap_htable_iterator_next_key(struct oscap_htable_iterator *hit)
{
  struct oscap_htable_item *item;
  item=oscap_htable_iterator_next(hit);
  char *tmp_if_expr$1;
  if(item == ((struct oscap_htable_item *)NULL))
    tmp_if_expr$1 = (char *)(void *)0;

  else
    tmp_if_expr$1 = item->key;
  return tmp_if_expr$1;
}

// oscap_htable_iterator_next_kv
// file ../../../src/common/list.c line 628
void oscap_htable_iterator_next_kv(struct oscap_htable_iterator *hit, const char **key, void **value)
{
  struct oscap_htable_item *item;
  item=oscap_htable_iterator_next(hit);
  if(!(item == ((struct oscap_htable_item *)NULL)))
  {
    *key = item->key;
    *value = item->value;
  }

}

// oscap_htable_iterator_next_value
// file ../../../src/common/list.c line 622
void * oscap_htable_iterator_next_value(struct oscap_htable_iterator *hit)
{
  struct oscap_htable_item *item;
  item=oscap_htable_iterator_next(hit);
  void *tmp_if_expr$1;
  if(item == ((struct oscap_htable_item *)NULL))
    tmp_if_expr$1 = (void *)0;

  else
    tmp_if_expr$1 = item->value;
  return tmp_if_expr$1;
}

// oscap_htable_iterator_reset
// file ../../../src/common/list.c line 639
void oscap_htable_iterator_reset(struct oscap_htable_iterator *hit)
{
  hit->cur = (struct oscap_htable_item *)(void *)0;
  hit->hpos = (unsigned long int)0;
}

// oscap_htable_lookup
// file ../../../src/common/list.c line 436
static struct oscap_htable_item * oscap_htable_lookup(struct oscap_htable *htable, const char *key)
{
  if(key == ((const char *)NULL))
    return (struct oscap_htable_item *)(void *)0;

  else
  {
    unsigned int hashcode;
    hashcode=oscap_htable_hash(key, htable->hsize);
    struct oscap_htable_item *htitem = htable->table[(signed long int)hashcode];
    if(!(htitem == ((struct oscap_htable_item *)NULL)))
    {
      signed int return_value;
      return_value=htable->cmp(htitem->key, key);
      if(return_value == 0)
        return htitem;

      htitem = htitem->next;
    }

    return (struct oscap_htable_item *)(void *)0;
  }
}

// oscap_htable_new
// file ../../../src/common/list.c line 431
struct oscap_htable * oscap_htable_new(void)
{
  struct oscap_htable *return_value_oscap_htable_new1$1;
  return_value_oscap_htable_new1$1=oscap_htable_new1(oscap_htable_cmp, (unsigned long int)389);
  return return_value_oscap_htable_new1$1;
}

// oscap_htable_new1
// file ../../../src/common/list.c line 385
struct oscap_htable * oscap_htable_new1(signed int (*cmp)(const char *, const char *), unsigned long int hsize)
{
  struct oscap_htable *t;
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc(sizeof(struct oscap_htable) /*32ul*/ );
  t = (struct oscap_htable *)return_value___oscap_alloc$1;
  if(t == ((struct oscap_htable *)NULL))
    return (struct oscap_htable *)(void *)0;

  else
  {
    t->hsize = hsize;
    t->itemcount = (unsigned long int)0;
    void *return_value___oscap_calloc$2;
    return_value___oscap_calloc$2=__oscap_calloc(hsize, sizeof(struct oscap_list_item *) /*8ul*/ );
    t->table = (struct oscap_htable_item **)return_value___oscap_calloc$2;
    if(t->table == ((struct oscap_htable_item **)NULL))
    {
      free((void *)t);
      return (struct oscap_htable *)(void *)0;
    }

    else
    {
      t->cmp = cmp;
      return t;
    }
  }
}

// oscap_init
// file ../../../src/common/oscapxml.c line 103
void oscap_init(void)
{
  xmlInitParser();
  xsltInit();
  exsltRegisterAll();
}

// oscap_iterator_detach
// file ../../../src/common/list.c line 263
void * oscap_iterator_detach(struct oscap_iterator *it)
{
  if(it->cur == ((struct oscap_list_item *)NULL))
    return (void *)0;

  else
  {
    struct oscap_list_item *item = it->cur;
    void *value = item->data;
    if(it->list->first == it->list->last)
    {
      it->list->last = (struct oscap_list_item *)(void *)0;
      it->list->first = it->list->last;
      it->cur = (struct oscap_list_item *)(void *)0;
    }

    else
      if(item == it->list->first)
      {
        it->list->first = item->next;
        it->cur = (struct oscap_list_item *)(void *)0;
      }

      else
      {
        struct oscap_list_item *cur = it->list->first;
        for( ; !(cur->next == item); cur = cur->next)
          ;
        cur->next = item->next;
        if(item == it->list->last)
          it->list->last = cur;

        it->cur = cur;
      }
    free((void *)item);
    it->list->itemcount = it->list->itemcount - 1ul;
    return value;
  }
}

// oscap_iterator_find_nearest
// file ../../../src/common/list.c line 230
static inline void oscap_iterator_find_nearest(struct oscap_iterator *it)
{
  struct oscap_list_item *tmp_if_expr$4;
  _Bool tmp_if_expr$1;
  _Bool return_value;
  _Bool tmp_if_expr$3;
  _Bool return_value__oscap_iterator_has_more_internal$2;
  do
  {
    if(!(it->cur == ((struct oscap_list_item *)NULL)))
      tmp_if_expr$4 = it->cur->next;

    else
      tmp_if_expr$4 = it->list->first;
    it->cur = tmp_if_expr$4;
    if(!(it->cur == ((struct oscap_list_item *)NULL)))
    {
      return_value=it->filter(it->cur->data, it->user_data);
      tmp_if_expr$1 = !(return_value != (_Bool)0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      return_value__oscap_iterator_has_more_internal$2=_oscap_iterator_has_more_internal(it);
      tmp_if_expr$3 = return_value__oscap_iterator_has_more_internal$2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
}

// oscap_iterator_free
// file ../../../src/common/list.c line 303
void oscap_iterator_free(struct oscap_iterator *it)
{
  __oscap_free((void *)it);
}

// oscap_iterator_get_itemcount
// file ../../../src/common/list.c line 257
unsigned long int oscap_iterator_get_itemcount(struct oscap_iterator *it)
{
  return it->list->itemcount;
}

// oscap_iterator_has_more
// file ../../../src/common/list.c line 320
_Bool oscap_iterator_has_more(struct oscap_iterator *it)
{
  _Bool tmp_if_expr$1;
  if(it == ((struct oscap_iterator *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(it->list != ((struct oscap_list *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(it->list->first != ((struct oscap_list_item *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool return_value_1;
  if(tmp_if_expr$2)
    return (_Bool)0;

  else
  {
    if(it->cur == ((struct oscap_list_item *)NULL))
    {
      _Bool return_value;
      return_value=it->filter(it->list->first->data, it->user_data);
      if(!(return_value == (_Bool)0))
        return (_Bool)1;

      else
        it->cur = it->list->first;
    }

    if(!(it->cur->next == ((struct oscap_list_item *)NULL)))
    {
      return_value_1=it->filter(it->cur->next->data, it->user_data);
      if(return_value_1 == (_Bool)0)
        it->cur = it->cur->next;

    }

    return it->cur->next != (struct oscap_list_item *)(void *)0;
  }
}

// oscap_iterator_new
// file ../../../src/common/list.c line 240
void * oscap_iterator_new(struct oscap_list *list)
{
  struct oscap_iterator *it;
  void *return_value___oscap_calloc$1;
  return_value___oscap_calloc$1=__oscap_calloc((unsigned long int)1, sizeof(struct oscap_iterator) /*32ul*/ );
  it = (struct oscap_iterator *)return_value___oscap_calloc$1;
  it->cur = (struct oscap_list_item *)(void *)0;
  it->filter = oscap_iterator_no_filter;
  it->list = list;
  return (void *)it;
}

// oscap_iterator_new_filter
// file ../../../src/common/list.c line 249
void * oscap_iterator_new_filter(struct oscap_list *list, _Bool (*filter)(void *, void *), void *user_data)
{
  struct oscap_iterator *it;
  void *return_value_oscap_iterator_new$1;
  return_value_oscap_iterator_new$1=oscap_iterator_new(list);
  it = (struct oscap_iterator *)return_value_oscap_iterator_new$1;
  it->filter = filter;
  it->user_data = user_data;
  return (void *)it;
}

// oscap_iterator_next
// file ../../../src/common/list.c line 308
void * oscap_iterator_next(struct oscap_iterator *it)
{
  oscap_iterator_find_nearest(it);
  return it->cur->data;
}

// oscap_iterator_no_filter
// file ../../../src/common/list.c line 225
static _Bool oscap_iterator_no_filter(void *foo, void *bar)
{
  return (_Bool)1;
}

// oscap_iterator_reset
// file ../../../src/common/list.c line 335
void oscap_iterator_reset(struct oscap_iterator *it)
{
  it->cur = (struct oscap_list_item *)(void *)0;
}

// oscap_list_add
// file ../../../src/common/list.c line 50
_Bool oscap_list_add(struct oscap_list *list, void *value)
{
  if(value == NULL)
    return (_Bool)0;

  else
  {
    struct oscap_list_item *item;
    void *return_value___oscap_alloc$1;
    return_value___oscap_alloc$1=__oscap_alloc(sizeof(struct oscap_list_item) /*16ul*/ );
    item = (struct oscap_list_item *)return_value___oscap_alloc$1;
    item->next = (struct oscap_list_item *)(void *)0;
    item->data = value;
    list->itemcount = list->itemcount + 1ul;
    if(list->last == ((struct oscap_list_item *)NULL))
    {
      list->last = item;
      list->first = list->last;
    }

    else
    {
      list->last->next = item;
      list->last = item;
    }
    return (_Bool)1;
  }
}

// oscap_list_clone
// file ../../../src/common/list.c line 125
struct oscap_list * oscap_list_clone(struct oscap_list *list, void * (*cloner)(void *))
{
  void *return_value;
  if(list == ((struct oscap_list *)NULL))
    return (struct oscap_list *)(void *)0;

  else
  {
    struct oscap_list *copy;
    copy=oscap_list_new();
    struct oscap_list_item *item = list->first;
    while(!(item == ((struct oscap_list_item *)NULL)))
    {
      if(!(cloner == ((void * (*)(void *))NULL)))
      {
        return_value=cloner(item->data);
        oscap_list_add(copy, return_value);
      }

      else
        oscap_list_add(copy, item->data);
      item = item->next;
    }
    return copy;
  }
}

// oscap_list_contains
// file ../../../src/common/list.c line 206
_Bool oscap_list_contains(struct oscap_list *list, void *what, _Bool (*compare)(void *, void *))
{
  void *return_value_oscap_list_find$1;
  return_value_oscap_list_find$1=oscap_list_find(list, what, compare);
  return return_value_oscap_list_find$1 != (void *)0;
}

// oscap_list_destructive_join
// file ../../../src/common/list.c line 144
struct oscap_list * oscap_list_destructive_join(struct oscap_list *list1, struct oscap_list *list2)
{
  if(list1->first == ((struct oscap_list_item *)NULL))
    list1->first = list2->first;

  else
    list1->last->next = list2->first;
  if(!(list2->last == ((struct oscap_list_item *)NULL)))
    list1->last = list2->last;

  list1->itemcount = list1->itemcount + list2->itemcount;
  __oscap_free((void *)list2);
  return list1;
}

// oscap_list_dump
// file ../../../src/common/list.c line 211
void oscap_list_dump(struct oscap_list *list, void (*dumper)(), signed int depth)
{
  if(list == ((struct oscap_list *)NULL))
    printf(" (NULL list)\n");

  else
  {
    printf(" (list, %u item%s)\n", (unsigned int)list->itemcount, list->itemcount == (unsigned long int)1 ? "" : "s");
    struct oscap_list_item *item = list->first;
    if(!(item == ((struct oscap_list_item *)NULL)))
    {
      dumper(item->data, depth);
      item = item->next;
    }

  }
}

// oscap_list_find
// file ../../../src/common/list.c line 187
void * oscap_list_find(struct oscap_list *list, void *what, _Bool (*compare)(void *, void *))
{
  if(list == ((struct oscap_list *)NULL))
    return NULL;

  else
  {
    if(compare == ((_Bool (*)(void *, void *))NULL))
      compare = oscap_ptr_cmp;

    struct oscap_iterator *it;
    void *return_value_oscap_iterator_new$1;
    return_value_oscap_iterator_new$1=oscap_iterator_new(list);
    it = (struct oscap_iterator *)return_value_oscap_iterator_new$1;
    _Bool return_value__oscap_iterator_has_more_internal$2;
    return_value__oscap_iterator_has_more_internal$2=_oscap_iterator_has_more_internal(it);
    if(!(return_value__oscap_iterator_has_more_internal$2 == (_Bool)0))
    {
      void *item;
      item=oscap_iterator_next(it);
      _Bool return_value;
      return_value=compare(item, what);
      if(!(return_value == (_Bool)0))
      {
        oscap_iterator_free(it);
        return item;
      }

    }

    oscap_iterator_free(it);
    return (void *)0;
  }
}

// oscap_list_free
// file ../../../src/common/list.c line 161
void oscap_list_free(struct oscap_list *list, void (*destructor)(void *))
{
  struct oscap_list_item *item;
  struct oscap_list_item *to_del;
  if(!(list == ((struct oscap_list *)NULL)))
  {
    item = list->first;
    while(!(item == ((struct oscap_list_item *)NULL)))
    {
      to_del = item;
      item = item->next;
      if(!(destructor == ((void (*)(void *))NULL)))
        destructor(to_del->data);

      free((void *)to_del);
    }
    free((void *)list);
  }

}

// oscap_list_free0
// file ../../../src/common/list.c line 177
void oscap_list_free0(struct oscap_list *list)
{
  oscap_list_free(list, (void (*)(void *))(void *)0);
}

// oscap_list_get_itemcount
// file ../../../src/common/list.c line 155
signed int oscap_list_get_itemcount(struct oscap_list *list)
{
  return (signed int)list->itemcount;
}

// oscap_list_new
// file ../../../src/common/list.c line 35
struct oscap_list * oscap_list_new(void)
{
  struct oscap_list *list;
  void *return_value___oscap_calloc$1;
  return_value___oscap_calloc$1=__oscap_calloc((unsigned long int)1, sizeof(struct oscap_list) /*24ul*/ );
  list = (struct oscap_list *)return_value___oscap_calloc$1;
  return list;
}

// oscap_list_pop
// file ../../../src/common/list.c line 74
_Bool oscap_list_pop(struct oscap_list *list, void (*destructor)(void *))
{
  _Bool tmp_if_expr$1;
  if(list == ((struct oscap_list *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = list->first == (struct oscap_list_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (_Bool)0;

  else
  {
    struct oscap_list_item *cur = list->first;
    struct oscap_list_item *prev = (struct oscap_list_item *)(void *)0;
    for( ; !(cur == list->last); cur = cur->next)
      prev = cur;
    if(!(destructor == ((void (*)(void *))NULL)))
      destructor(cur->data);

    __oscap_free((void *)cur);
    list->last = prev;
    if(!(prev == ((struct oscap_list_item *)NULL)))
      prev->next = (struct oscap_list_item *)(void *)0;

    else
      list->first = (struct oscap_list_item *)(void *)0;
    list->itemcount = list->itemcount - 1ul;
    return (_Bool)1;
  }
}

// oscap_list_push
// file ../../../src/common/list.c line 69
_Bool oscap_list_push(struct oscap_list *list, void *value)
{
  _Bool return_value_oscap_list_add$1;
  return_value_oscap_list_add$1=oscap_list_add(list, value);
  return return_value_oscap_list_add$1;
}

// oscap_list_remove
// file ../../../src/common/list.c line 96
_Bool oscap_list_remove(struct oscap_list *list, void *value, _Bool (*compare)(void *, void *), void (*destructor)(void *))
{
  _Bool tmp_if_expr$1;
  if(list == ((struct oscap_list *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = list->first == (struct oscap_list_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool return_value;
  if(tmp_if_expr$1)
    return (_Bool)0;

  else
  {
    struct oscap_list_item *cur = list->first;
    struct oscap_list_item *prev = (struct oscap_list_item *)(void *)0;
    if(!(cur == list->last))
    {
      return_value=compare(cur->data, value);
      if(return_value == (_Bool)0)
      {
        prev = cur;
        cur = cur->next;
      }

    }

    _Bool return_value_1;
    return_value_1=compare(cur->data, value);
    if(!(return_value_1 == (_Bool)0))
    {
      if(!(prev == ((struct oscap_list_item *)NULL)))
        prev->next = cur->next;

      else
        list->first = cur->next;
      if(cur == list->last)
        list->last = prev;

      if(!(destructor == ((void (*)(void *))NULL)))
        destructor(cur->data);

      __oscap_free((void *)cur);
      list->itemcount = list->itemcount - 1ul;
      return (_Bool)1;
    }

    else
      return (_Bool)0;
  }
}

// oscap_parser_text_value
// file ../../../src/common/elements.c line 85
signed int oscap_parser_text_value(struct _xmlTextReader *reader, void (*consumer)(char *, void *), void *user)
{
  signed int depth;
  depth=xmlTextReaderDepth(reader);
  _Bool has_value = (_Bool)0;
  signed int ret = 0;
  signed int return_value_xmlTextReaderIsEmptyElement$1;
  return_value_xmlTextReaderIsEmptyElement$1=xmlTextReaderIsEmptyElement(reader);
  signed int return_value_xmlTextReaderDepth$2;
  if(!(return_value_xmlTextReaderIsEmptyElement$1 == 0))
    return ret;

  else
  {
    xmlTextReaderRead(reader);
    do
    {
      return_value_xmlTextReaderDepth$2=xmlTextReaderDepth(reader);
      if(depth >= return_value_xmlTextReaderDepth$2)
        break;

      signed int nodetype;
      nodetype=xmlTextReaderNodeType(reader);
      if(nodetype == 3 || nodetype == 4)
      {
        char *value;
        unsigned char *return_value_xmlTextReaderValue$3;
        return_value_xmlTextReaderValue$3=xmlTextReaderValue(reader);
        value = (char *)return_value_xmlTextReaderValue$3;
        consumer(value, user);
        __oscap_free((void *)value);
        has_value = (_Bool)1;
      }

      signed int return_value_xmlTextReaderRead$4;
      return_value_xmlTextReaderRead$4=xmlTextReaderRead(reader);
      if(!(return_value_xmlTextReaderRead$4 == 1))
      {
        ret = -1;
        break;
      }

    }
    while((_Bool)1);
    if(has_value == (_Bool)0)
      consumer("", user);

    return ret;
  }
}

// oscap_path_to
// file ../../../src/common/oscapxml.c line 71
static const char * oscap_path_to(const char *pathvar, const char *defpath)
{
  const char *path = (const char *)(void *)0;
  if(!(pathvar == ((const char *)NULL)))
    path=getenv(pathvar);

  _Bool tmp_if_expr$2;
  _Bool return_value_oscap_streq$1;
  if(path == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_oscap_streq$1=oscap_streq(path, "");
    tmp_if_expr$2 = return_value_oscap_streq$1 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    path = defpath;

  return path;
}

// oscap_path_to_cpe
// file ../../../src/common/oscapxml.c line 99
const char * oscap_path_to_cpe(void)
{
  const char *return_value_oscap_path_to$1;
  return_value_oscap_path_to$1=oscap_path_to("OSCAP_CPE_PATH", OSCAP_CPE_PATH);
  return return_value_oscap_path_to$1;
}

// oscap_path_to_schemas
// file ../../../src/common/oscapxml.c line 83
const char * oscap_path_to_schemas(void)
{
  const char *return_value_oscap_path_to$1;
  return_value_oscap_path_to$1=oscap_path_to("OSCAP_SCHEMA_PATH", OSCAP_SCHEMA_PATH);
  return return_value_oscap_path_to$1;
}

// oscap_path_to_schematron
// file ../../../src/common/oscapxml.c line 92
const char * oscap_path_to_schematron(void)
{
  const char *return_value_oscap_path_to_xslt$1;
  return_value_oscap_path_to_xslt$1=oscap_path_to_xslt();
  return return_value_oscap_path_to_xslt$1;
}

// oscap_path_to_xslt
// file ../../../src/common/oscapxml.c line 87
const char * oscap_path_to_xslt(void)
{
  const char *return_value_oscap_path_to$1;
  return_value_oscap_path_to$1=oscap_path_to("OSCAP_XSLT_PATH", OSCAP_XSLT_PATH);
  return return_value_oscap_path_to$1;
}

// oscap_print_depth
// file ../../../src/common/list.c line 652
void oscap_print_depth(signed int depth)
{
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = depth;
    depth = depth - 1;
    if(tmp_post$1 == 0)
      break;

    printf("  ");
  }
  while((_Bool)1);
}

// oscap_proc_memusage
// file ../../../../../src/common/memusage.h line 31
signed int oscap_proc_memusage(struct proc_memusage *mu)
{
  if(mu == ((struct proc_memusage *)NULL))
    return -1;

  else
  {
    signed int return_value_read_status$1;
    return_value_read_status$1=read_status("/proc/self/status", (void *)mu, __proc_stat_ptable, sizeof(struct stat_parser [7l]) /*168ul*/  / sizeof(struct stat_parser) /*24ul*/ );
    if(!(return_value_read_status$1 == 0))
      return -1;

    else
      return 0;
  }
}

// oscap_ptr_cmp
// file ../../../src/common/list.c line 182
_Bool oscap_ptr_cmp(void *node1, void *node2)
{
  return node1 == node2;
}

// oscap_reference_clone
// file ../../../src/common/reference.c line 183
struct oscap_reference * oscap_reference_clone(struct oscap_reference *ref)
{
  if(ref == ((struct oscap_reference *)NULL))
    return (struct oscap_reference *)(void *)0;

  else
  {
    struct oscap_reference *new_ref;
    new_ref=oscap_reference_new();
    new_ref->is_dublincore = ref->is_dublincore;
    do
      new_ref->title=oscap_strdup(ref->title);
    while((_Bool)0);
    do
      new_ref->creator=oscap_strdup(ref->creator);
    while((_Bool)0);
    do
      new_ref->subject=oscap_strdup(ref->subject);
    while((_Bool)0);
    do
      new_ref->description=oscap_strdup(ref->description);
    while((_Bool)0);
    do
      new_ref->publisher=oscap_strdup(ref->publisher);
    while((_Bool)0);
    do
      new_ref->contributor=oscap_strdup(ref->contributor);
    while((_Bool)0);
    do
      new_ref->date=oscap_strdup(ref->date);
    while((_Bool)0);
    do
      new_ref->type=oscap_strdup(ref->type);
    while((_Bool)0);
    do
      new_ref->format=oscap_strdup(ref->format);
    while((_Bool)0);
    do
      new_ref->identifier=oscap_strdup(ref->identifier);
    while((_Bool)0);
    do
      new_ref->source=oscap_strdup(ref->source);
    while((_Bool)0);
    do
      new_ref->language=oscap_strdup(ref->language);
    while((_Bool)0);
    do
      new_ref->relation=oscap_strdup(ref->relation);
    while((_Bool)0);
    do
      new_ref->coverage=oscap_strdup(ref->coverage);
    while((_Bool)0);
    do
      new_ref->rights=oscap_strdup(ref->rights);
    while((_Bool)0);
    do
      new_ref->href=oscap_strdup(ref->href);
    while((_Bool)0);
    return new_ref;
  }
}

// oscap_reference_free
// file ../../../src/common/reference.c line 63
void oscap_reference_free(struct oscap_reference *ref)
{
  if(!(ref == ((struct oscap_reference *)NULL)))
  {
    __oscap_free((void *)ref->title);
    __oscap_free((void *)ref->creator);
    __oscap_free((void *)ref->subject);
    __oscap_free((void *)ref->description);
    __oscap_free((void *)ref->publisher);
    __oscap_free((void *)ref->contributor);
    __oscap_free((void *)ref->date);
    __oscap_free((void *)ref->type);
    __oscap_free((void *)ref->format);
    __oscap_free((void *)ref->identifier);
    __oscap_free((void *)ref->source);
    __oscap_free((void *)ref->language);
    __oscap_free((void *)ref->relation);
    __oscap_free((void *)ref->coverage);
    __oscap_free((void *)ref->rights);
    __oscap_free((void *)ref->href);
    __oscap_free((void *)ref);
  }

}

// oscap_reference_get_contributor
// file ../../../src/common/reference.c line 45
const char * oscap_reference_get_contributor(struct oscap_reference *item)
{
  return item->contributor;
}

// oscap_reference_get_coverage
// file ../../../src/common/reference.c line 53
const char * oscap_reference_get_coverage(struct oscap_reference *item)
{
  return item->coverage;
}

// oscap_reference_get_creator
// file ../../../src/common/reference.c line 41
const char * oscap_reference_get_creator(struct oscap_reference *item)
{
  return item->creator;
}

// oscap_reference_get_date
// file ../../../src/common/reference.c line 46
const char * oscap_reference_get_date(struct oscap_reference *item)
{
  return item->date;
}

// oscap_reference_get_description
// file ../../../src/common/reference.c line 43
const char * oscap_reference_get_description(struct oscap_reference *item)
{
  return item->description;
}

// oscap_reference_get_format
// file ../../../src/common/reference.c line 48
const char * oscap_reference_get_format(struct oscap_reference *item)
{
  return item->format;
}

// oscap_reference_get_href
// file ../../../src/common/reference.c line 39
const char * oscap_reference_get_href(struct oscap_reference *item)
{
  return item->href;
}

// oscap_reference_get_identifier
// file ../../../src/common/reference.c line 49
const char * oscap_reference_get_identifier(struct oscap_reference *item)
{
  return item->identifier;
}

// oscap_reference_get_is_dublincore
// file ../../../src/common/reference.c line 38
_Bool oscap_reference_get_is_dublincore(struct oscap_reference *item)
{
  return item->is_dublincore;
}

// oscap_reference_get_language
// file ../../../src/common/reference.c line 51
const char * oscap_reference_get_language(struct oscap_reference *item)
{
  return item->language;
}

// oscap_reference_get_publisher
// file ../../../src/common/reference.c line 44
const char * oscap_reference_get_publisher(struct oscap_reference *item)
{
  return item->publisher;
}

// oscap_reference_get_relation
// file ../../../src/common/reference.c line 52
const char * oscap_reference_get_relation(struct oscap_reference *item)
{
  return item->relation;
}

// oscap_reference_get_rights
// file ../../../src/common/reference.c line 54
const char * oscap_reference_get_rights(struct oscap_reference *item)
{
  return item->rights;
}

// oscap_reference_get_source
// file ../../../src/common/reference.c line 50
const char * oscap_reference_get_source(struct oscap_reference *item)
{
  return item->source;
}

// oscap_reference_get_subject
// file ../../../src/common/reference.c line 42
const char * oscap_reference_get_subject(struct oscap_reference *item)
{
  return item->subject;
}

// oscap_reference_get_title
// file ../../../src/common/reference.c line 40
const char * oscap_reference_get_title(struct oscap_reference *item)
{
  return item->title;
}

// oscap_reference_get_type
// file ../../../src/common/reference.c line 47
const char * oscap_reference_get_type(struct oscap_reference *item)
{
  return item->type;
}

// oscap_reference_iterator_free
// file ../../../src/common/reference.c line 56
void oscap_reference_iterator_free(struct oscap_reference_iterator *it)
{
  oscap_iterator_free((struct oscap_iterator *)it);
}

// oscap_reference_iterator_has_more
// file ../../../src/common/reference.c line 56
_Bool oscap_reference_iterator_has_more(struct oscap_reference_iterator *it)
{
  _Bool return_value_oscap_iterator_has_more$1;
  return_value_oscap_iterator_has_more$1=oscap_iterator_has_more((struct oscap_iterator *)it);
  return return_value_oscap_iterator_has_more$1;
}

// oscap_reference_iterator_next
// file ../../../src/common/reference.c line 56
struct oscap_reference * oscap_reference_iterator_next(struct oscap_reference_iterator *it)
{
  void *return_value_oscap_iterator_next$1;
  return_value_oscap_iterator_next$1=oscap_iterator_next((struct oscap_iterator *)it);
  return (struct oscap_reference *)return_value_oscap_iterator_next$1;
}

// oscap_reference_iterator_reset
// file ../../../src/common/reference.c line 56
void oscap_reference_iterator_reset(struct oscap_reference_iterator *it)
{
  oscap_iterator_reset((struct oscap_iterator *)it);
}

// oscap_reference_new
// file ../../../src/common/reference.c line 58
struct oscap_reference * oscap_reference_new(void)
{
  void *return_value___oscap_calloc$1;
  return_value___oscap_calloc$1=__oscap_calloc((unsigned long int)1, sizeof(struct oscap_reference) /*136ul*/ );
  return (struct oscap_reference *)return_value___oscap_calloc$1;
}

// oscap_reference_new_parse
// file ../../../src/common/reference.c line 132
struct oscap_reference * oscap_reference_new_parse(struct _xmlTextReader *reader)
{
  struct oscap_reference *ref;
  void *return_value___oscap_calloc$1;
  return_value___oscap_calloc$1=__oscap_calloc((unsigned long int)1, sizeof(struct oscap_reference) /*136ul*/ );
  ref = (struct oscap_reference *)return_value___oscap_calloc$1;
  signed int depth;
  depth=oscap_element_depth(reader);
  struct _xmlNode *ref_node;
  ref_node=xmlTextReaderExpand(reader);
  unsigned char *return_value_xmlGetProp$2;
  return_value_xmlGetProp$2=xmlGetProp(ref_node, (unsigned char *)"href");
  ref->href = (char *)return_value_xmlGetProp$2;
  struct _xmlNode *cur = ref_node->children;
  for( ; !(cur == ((struct _xmlNode *)NULL)); cur = cur->next)
    if((signed int)cur->type == XML_ELEMENT_NODE)
    {
      ref->is_dublincore = (_Bool)1;
      break;
    }

  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool return_value_oscap_streq$4;
  unsigned char *return_value_xmlNodeGetContent$6;
  unsigned char *return_value_xmlNodeGetContent$8;
  unsigned char *return_value_xmlNodeGetContent$10;
  unsigned char *return_value_xmlNodeGetContent$12;
  unsigned char *return_value_xmlNodeGetContent$14;
  unsigned char *return_value_xmlNodeGetContent$16;
  unsigned char *return_value_xmlNodeGetContent$18;
  unsigned char *return_value_xmlNodeGetContent$20;
  unsigned char *return_value_xmlNodeGetContent$22;
  unsigned char *return_value_xmlNodeGetContent$24;
  unsigned char *return_value_xmlNodeGetContent$26;
  unsigned char *return_value_xmlNodeGetContent$28;
  unsigned char *return_value_xmlNodeGetContent$30;
  unsigned char *return_value_xmlNodeGetContent$32;
  unsigned char *return_value_xmlNodeGetContent$34;
  if(!(ref->is_dublincore == (_Bool)0))
  {
    struct _xmlNode *oscap_reference_new_parse$$1$$2$$1$$cur = ref_node->children;
    for( ; !(oscap_reference_new_parse$$1$$2$$1$$cur == ((struct _xmlNode *)NULL)); oscap_reference_new_parse$$1$$2$$1$$cur = oscap_reference_new_parse$$1$$2$$1$$cur->next)
    {
      if(!((signed int)oscap_reference_new_parse$$1$$2$$1$$cur->type == XML_ELEMENT_NODE))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = oscap_reference_new_parse$$1$$2$$1$$cur->ns == (struct _xmlNs *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_oscap_streq$4=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->ns->href, (const char *)(unsigned char *)"http://purl.org/dc/elements/1.1/");
        tmp_if_expr$5 = !(return_value_oscap_streq$4 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$5)
      {
        do
        {
          _Bool return_value_oscap_streq$7;
          return_value_oscap_streq$7=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "title");
          if(!(return_value_oscap_streq$7 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$6=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->title = (char *)return_value_xmlNodeGetContent$6;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$9;
          return_value_oscap_streq$9=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "creator");
          if(!(return_value_oscap_streq$9 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$8=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->creator = (char *)return_value_xmlNodeGetContent$8;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$11;
          return_value_oscap_streq$11=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "subject");
          if(!(return_value_oscap_streq$11 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$10=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->subject = (char *)return_value_xmlNodeGetContent$10;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$13;
          return_value_oscap_streq$13=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "description");
          if(!(return_value_oscap_streq$13 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$12=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->description = (char *)return_value_xmlNodeGetContent$12;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$15;
          return_value_oscap_streq$15=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "publisher");
          if(!(return_value_oscap_streq$15 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$14=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->publisher = (char *)return_value_xmlNodeGetContent$14;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$17;
          return_value_oscap_streq$17=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "contributor");
          if(!(return_value_oscap_streq$17 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$16=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->contributor = (char *)return_value_xmlNodeGetContent$16;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$19;
          return_value_oscap_streq$19=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "date");
          if(!(return_value_oscap_streq$19 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$18=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->date = (char *)return_value_xmlNodeGetContent$18;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$21;
          return_value_oscap_streq$21=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "type");
          if(!(return_value_oscap_streq$21 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$20=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->type = (char *)return_value_xmlNodeGetContent$20;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$23;
          return_value_oscap_streq$23=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "format");
          if(!(return_value_oscap_streq$23 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$22=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->format = (char *)return_value_xmlNodeGetContent$22;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$25;
          return_value_oscap_streq$25=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "identifier");
          if(!(return_value_oscap_streq$25 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$24=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->identifier = (char *)return_value_xmlNodeGetContent$24;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$27;
          return_value_oscap_streq$27=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "source");
          if(!(return_value_oscap_streq$27 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$26=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->source = (char *)return_value_xmlNodeGetContent$26;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$29;
          return_value_oscap_streq$29=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "language");
          if(!(return_value_oscap_streq$29 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$28=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->language = (char *)return_value_xmlNodeGetContent$28;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$31;
          return_value_oscap_streq$31=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "relation");
          if(!(return_value_oscap_streq$31 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$30=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->relation = (char *)return_value_xmlNodeGetContent$30;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$33;
          return_value_oscap_streq$33=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "coverage");
          if(!(return_value_oscap_streq$33 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$32=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->coverage = (char *)return_value_xmlNodeGetContent$32;
          }

        }
        while((_Bool)0);
        do
        {
          _Bool return_value_oscap_streq$35;
          return_value_oscap_streq$35=oscap_streq((const char *)oscap_reference_new_parse$$1$$2$$1$$cur->name, "rights");
          if(!(return_value_oscap_streq$35 == (_Bool)0))
          {
            return_value_xmlNodeGetContent$34=xmlNodeGetContent(oscap_reference_new_parse$$1$$2$$1$$cur);
            ref->rights = (char *)return_value_xmlNodeGetContent$34;
          }

        }
        while((_Bool)0);
      }

    }
  }

  else
  {
    unsigned char *return_value_xmlNodeGetContent$36;
    return_value_xmlNodeGetContent$36=xmlNodeGetContent(ref_node);
    ref->title = (char *)return_value_xmlNodeGetContent$36;
  }
  _Bool return_value_oscap_to_start_element$37;
  return_value_oscap_to_start_element$37=oscap_to_start_element(reader, depth);
  if(return_value_oscap_to_start_element$37 == (_Bool)0)
    __oscap_dlprintf(DBG_W, "../../../src/common/reference.c", "oscap_reference_new_parse", (unsigned long int)176, "oscap_to_start_element returned `false'");

  return ref;
}

// oscap_reference_set_contributor
// file ../../../src/common/reference.c line 45
_Bool oscap_reference_set_contributor(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->contributor);
  obj->contributor=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_coverage
// file ../../../src/common/reference.c line 53
_Bool oscap_reference_set_coverage(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->coverage);
  obj->coverage=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_creator
// file ../../../src/common/reference.c line 41
_Bool oscap_reference_set_creator(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->creator);
  obj->creator=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_date
// file ../../../src/common/reference.c line 46
_Bool oscap_reference_set_date(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->date);
  obj->date=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_description
// file ../../../src/common/reference.c line 43
_Bool oscap_reference_set_description(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->description);
  obj->description=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_format
// file ../../../src/common/reference.c line 48
_Bool oscap_reference_set_format(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->format);
  obj->format=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_href
// file ../../../src/common/reference.c line 39
_Bool oscap_reference_set_href(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->href);
  obj->href=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_identifier
// file ../../../src/common/reference.c line 49
_Bool oscap_reference_set_identifier(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->identifier);
  obj->identifier=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_is_dublincore
// file ../../../src/common/reference.c line 38
_Bool oscap_reference_set_is_dublincore(struct oscap_reference *obj, _Bool newval)
{
  obj->is_dublincore = newval;
  return (_Bool)1;
}

// oscap_reference_set_language
// file ../../../src/common/reference.c line 51
_Bool oscap_reference_set_language(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->language);
  obj->language=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_publisher
// file ../../../src/common/reference.c line 44
_Bool oscap_reference_set_publisher(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->publisher);
  obj->publisher=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_relation
// file ../../../src/common/reference.c line 52
_Bool oscap_reference_set_relation(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->relation);
  obj->relation=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_rights
// file ../../../src/common/reference.c line 54
_Bool oscap_reference_set_rights(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->rights);
  obj->rights=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_source
// file ../../../src/common/reference.c line 50
_Bool oscap_reference_set_source(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->source);
  obj->source=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_subject
// file ../../../src/common/reference.c line 42
_Bool oscap_reference_set_subject(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->subject);
  obj->subject=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_title
// file ../../../src/common/reference.c line 40
_Bool oscap_reference_set_title(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->title);
  obj->title=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_set_type
// file ../../../src/common/reference.c line 47
_Bool oscap_reference_set_type(struct oscap_reference *obj, const char *newval)
{
  free((void *)obj->type);
  obj->type=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_reference_to_dom
// file ../../../src/common/reference.c line 91
struct _xmlNode * oscap_reference_to_dom(struct oscap_reference *ref, struct _xmlNode *parent, struct _xmlDoc *doc, const char *elname)
{
  if(ref == ((struct oscap_reference *)NULL))
    return (struct _xmlNode *)(void *)0;

  else
  {
    struct _xmlNode *ref_node;
    ref_node=xmlNewChild(parent, (struct _xmlNs *)(void *)0, (unsigned char *)elname, (const unsigned char *)(void *)0);
    if(!(ref->href == ((char *)NULL)))
      xmlNewProp(ref_node, (unsigned char *)"href", (unsigned char *)ref->href);

    if(ref->is_dublincore == (_Bool)0)
    {
      xmlNodeAddContent(ref_node, (unsigned char *)ref->title);
      return ref_node;
    }

    else
    {
      struct _xmlNs *ns_dc;
      ns_dc=xmlSearchNsByHref(doc, parent, (unsigned char *)"http://purl.org/dc/elements/1.1/");
      if(ns_dc == ((struct _xmlNs *)NULL))
        ns_dc=xmlNewNs(ref_node, (unsigned char *)"http://purl.org/dc/elements/1.1/", (unsigned char *)"dc");

      do
        if(!(ref->title == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"title", (unsigned char *)ref->title);

      while((_Bool)0);
      do
        if(!(ref->creator == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"creator", (unsigned char *)ref->creator);

      while((_Bool)0);
      do
        if(!(ref->subject == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"subject", (unsigned char *)ref->subject);

      while((_Bool)0);
      do
        if(!(ref->description == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"description", (unsigned char *)ref->description);

      while((_Bool)0);
      do
        if(!(ref->publisher == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"publisher", (unsigned char *)ref->publisher);

      while((_Bool)0);
      do
        if(!(ref->contributor == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"contributor", (unsigned char *)ref->contributor);

      while((_Bool)0);
      do
        if(!(ref->date == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"date", (unsigned char *)ref->date);

      while((_Bool)0);
      do
        if(!(ref->type == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"type", (unsigned char *)ref->type);

      while((_Bool)0);
      do
        if(!(ref->format == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"format", (unsigned char *)ref->format);

      while((_Bool)0);
      do
        if(!(ref->identifier == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"identifier", (unsigned char *)ref->identifier);

      while((_Bool)0);
      do
        if(!(ref->source == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"source", (unsigned char *)ref->source);

      while((_Bool)0);
      do
        if(!(ref->language == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"language", (unsigned char *)ref->language);

      while((_Bool)0);
      do
        if(!(ref->relation == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"relation", (unsigned char *)ref->relation);

      while((_Bool)0);
      do
        if(!(ref->coverage == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"coverage", (unsigned char *)ref->coverage);

      while((_Bool)0);
      do
        if(!(ref->rights == ((char *)NULL)))
          xmlNewTextChild(ref_node, ns_dc, (unsigned char *)"rights", (unsigned char *)ref->rights);

      while((_Bool)0);
      return ref_node;
    }
  }
}

// oscap_rtrim
// file ../../../src/common/util.c line 203
char * oscap_rtrim(char *str, char ch)
{
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *pos;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    pos = (str + (signed long int)return_value_strlen$1) - (signed long int)1;
    for( ; pos >= str; pos = pos - 1l)
      if(*pos == ch)
        *pos = (char)0;

      else
        break;
    return str;
  }
}

// oscap_schematron_validate_document
// file ../../../src/common/oscapxml.c line 137
signed int oscap_schematron_validate_document(const char *xmlfile, enum oscap_document_type doctype, const char *version, const char *outfile)
{
  struct oscap_source *source;
  source=oscap_source_new_from_file(xmlfile);
  signed int ret;
  ret=oscap_source_validate_schematron_priv(source, doctype, version, outfile);
  oscap_source_free(source);
  return ret;
}

// oscap_set_verbose
// file ../../../../../src/common/public/oscap_debug.h line 43
_Bool oscap_set_verbose(const char *verbosity_level, const char *filename, _Bool is_probe)
{
  if(filename == ((const char *)NULL) || verbosity_level == ((const char *)NULL))
    return (_Bool)1;

  else
  {
    __debuglog_level=oscap_verbosity_level_from_cstr(verbosity_level);
    if((signed int)__debuglog_level == DBG_UNKNOWN)
      return (_Bool)0;

    else
    {
      signed int fd;
      if(!(is_probe == (_Bool)0))
        fd=open(filename, 02000 | 01);

      else
      {
        setenv("OSCAP_PROBE_VERBOSITY_LEVEL", verbosity_level, 1);
        setenv("OSCAP_PROBE_VERBOSE_LOG_FILE", filename, 1);
        fd=open(filename, 02000 | 0100 | 01000 | 01, 0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3);
      }
      if(fd == -1)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        __oscap_seterr("../../../src/common/debug.c", (unsigned int)111, "oscap_set_verbose", (unsigned short int)3, (const void *)"Failed to open file %s: %s.", filename, return_value_strerror$2);
        return (_Bool)0;
      }

      __debuglog_fp=fdopen(fd, "a");
      if(__debuglog_fp == ((struct _IO_FILE *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        __oscap_seterr("../../../src/common/debug.c", (unsigned int)116, "oscap_set_verbose", (unsigned short int)3, (const void *)"Failed to associate stream with file %s: %s.", filename, return_value_strerror$4);
        return (_Bool)0;
      }

      setbuf(__debuglog_fp, (char *)(void *)0);
      atexit(__oscap_debuglog_close);
      return (_Bool)1;
    }
  }
}

// oscap_split
// file ../../../src/common/util.c line 83
char ** oscap_split(char *str, const char *delim)
{
  char **stringp = &str;
  signed int alloc = (signed int)CPE_SPLIT_INIT_ALLOC;
  char **fields;
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc((unsigned long int)alloc * sizeof(char *) /*8ul*/ );
  fields = (char **)return_value___oscap_alloc$1;
  signed int tmp_post$3;
  if(fields == ((char **)NULL))
    return (char **)(void *)0;

  else
  {
    signed int i = 0;
    while(!(*stringp == ((char *)NULL)))
    {
      if(!(alloc >= 2 + i))
      {
        void *old = (void *)fields;
        alloc = alloc * 2;
        void *return_value___oscap_realloc$2;
        return_value___oscap_realloc$2=__oscap_realloc((void *)fields, (unsigned long int)alloc * sizeof(char *) /*8ul*/ );
        fields = (char **)return_value___oscap_realloc$2;
        if(fields == ((char **)NULL))
        {
          __oscap_free((void *)old);
          return (char **)(void *)0;
        }

      }

      tmp_post$3 = i;
      i = i + 1;
      fields[(signed long int)tmp_post$3]=strsep(stringp, delim);
    }
    fields[(signed long int)i] = (char *)(void *)0;
    return fields;
  }
}

// oscap_sprintf
// file ../../../src/common/util.h line 370
char * oscap_sprintf(const char *fmt, ...)
{
  char *ret = (char *)(void *)0;
  void **ap = (void **)&fmt;
  ret=oscap_vsprintf(fmt, ap);
  ap = ((void **)NULL);
  return ret;
}

// oscap_str_endswith
// file ../../../src/common/util.c line 130
_Bool oscap_str_endswith(const char *str, const char *with)
{
  unsigned long int str_len;
  str_len=strlen(str);
  unsigned long int with_len;
  with_len=strlen(with);
  if(!(str_len >= with_len))
    return (_Bool)0;

  else
  {
    signed int return_value_strncmp$1;
    return_value_strncmp$1=strncmp((str + (signed long int)str_len) - (signed long int)with_len, with, with_len);
    return return_value_strncmp$1 == 0;
  }
}

// oscap_str_startswith
// file ../../../src/common/util.h line 359
_Bool oscap_str_startswith(const char *str, const char *with)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(with);
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(str, with, return_value_strlen$1);
  return !(return_value_strncmp$2 != 0);
}

// oscap_strcmp
// file ../../../src/common/util.c line 113
signed int oscap_strcmp(const char *s1, const char *s2)
{
  if(s1 == ((const char *)NULL))
    s1 = "";

  if(s2 == ((const char *)NULL))
    s2 = "";

  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(s1, s2);
  return return_value_strcmp$1;
}

// oscap_strdup
// file ../../../src/common/util.h line 334
char * oscap_strdup(const char *str)
{
  char *m;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(str == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    m=strdup(str);
    if(m == ((char *)NULL))
    {
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      __oscap_seterr("../../../src/common/util.c", (unsigned int)68, "oscap_strdup", (unsigned short int)1, return_value_strerror$2);
    }

    return m;
  }
}

// oscap_streq
// file ../../../src/common/util.h line 358
_Bool oscap_streq(const char *s1, const char *s2)
{
  signed int return_value_oscap_strcmp$1;
  return_value_oscap_strcmp$1=oscap_strcmp(s1, s2);
  return return_value_oscap_strcmp$1 == 0;
}

// oscap_string_append_char
// file ../../../src/common/oscap_string.h line 45
void oscap_string_append_char(struct oscap_string *s, char c)
{
  oscap_buffer_append_binary_data((struct oscap_buffer *)s, &c, (const unsigned long int)1);
}

// oscap_string_append_string
// file ../../../src/common/oscap_string.h line 52
void oscap_string_append_string(struct oscap_string *s, const char *t)
{
  oscap_buffer_append_string((struct oscap_buffer *)s, t);
}

// oscap_string_bequeath
// file ../../../src/common/oscap_string.h line 75
char * oscap_string_bequeath(struct oscap_string *s)
{
  char *return_value_oscap_buffer_bequeath$1;
  return_value_oscap_buffer_bequeath$1=oscap_buffer_bequeath((struct oscap_buffer *)s);
  return return_value_oscap_buffer_bequeath$1;
}

// oscap_string_clear
// file ../../../src/common/oscap_string.c line 48
void oscap_string_clear(struct oscap_string *s)
{
  oscap_buffer_clear((struct oscap_buffer *)s);
}

// oscap_string_empty
// file ../../../src/common/oscap_string.c line 68
_Bool oscap_string_empty(struct oscap_string *s)
{
  unsigned long int return_value_oscap_buffer_get_length$1;
  return_value_oscap_buffer_get_length$1=oscap_buffer_get_length((struct oscap_buffer *)s);
  return return_value_oscap_buffer_get_length$1 == (unsigned long int)0;
}

// oscap_string_free
// file ../../../src/common/oscap_string.c line 38
void oscap_string_free(struct oscap_string *s)
{
  oscap_buffer_free((struct oscap_buffer *)s);
}

// oscap_string_get_cstr
// file ../../../src/common/oscap_string.c line 63
const char * oscap_string_get_cstr(struct oscap_string *s)
{
  char *return_value_oscap_buffer_get_raw$1;
  return_value_oscap_buffer_get_raw$1=oscap_buffer_get_raw((struct oscap_buffer *)s);
  return return_value_oscap_buffer_get_raw$1;
}

// oscap_string_iterator_free
// file ../../../src/common/list.c line 368
void oscap_string_iterator_free(struct oscap_string_iterator *it)
{
  oscap_iterator_free((struct oscap_iterator *)it);
}

// oscap_string_iterator_has_more
// file ../../../src/common/list.c line 368
_Bool oscap_string_iterator_has_more(struct oscap_string_iterator *it)
{
  _Bool return_value_oscap_iterator_has_more$1;
  return_value_oscap_iterator_has_more$1=oscap_iterator_has_more((struct oscap_iterator *)it);
  return return_value_oscap_iterator_has_more$1;
}

// oscap_string_iterator_next
// file ../../../src/common/list.c line 368
const char * oscap_string_iterator_next(struct oscap_string_iterator *it)
{
  void *return_value_oscap_iterator_next$1;
  return_value_oscap_iterator_next$1=oscap_iterator_next((struct oscap_iterator *)it);
  return (const char *)return_value_oscap_iterator_next$1;
}

// oscap_string_iterator_remove
// file ../../../src/common/list.c line 369
void oscap_string_iterator_remove(struct oscap_string_iterator *it)
{
  void *return_value_oscap_iterator_detach$1;
  return_value_oscap_iterator_detach$1=oscap_iterator_detach((struct oscap_iterator *)it);
  free(return_value_oscap_iterator_detach$1);
}

// oscap_string_iterator_reset
// file ../../../src/common/list.c line 368
void oscap_string_iterator_reset(struct oscap_string_iterator *it)
{
  oscap_iterator_reset((struct oscap_iterator *)it);
}

// oscap_string_new
// file ../../../src/common/oscap_string.h line 32
struct oscap_string * oscap_string_new(void)
{
  struct oscap_buffer *return_value_oscap_buffer_new$1;
  return_value_oscap_buffer_new$1=oscap_buffer_new();
  return (struct oscap_string *)return_value_oscap_buffer_new$1;
}

// oscap_string_to_enum
// file ../../../src/common/util.h line 320
signed int oscap_string_to_enum(struct oscap_string_map *map, const char *str)
{
  signed int return_value_strcmp$1;
  for( ; !(map->string == ((const char *)NULL)); map = map + 1l)
    if(!(str == ((const char *)NULL)))
    {
      return_value_strcmp$1=strcmp(map->string, str);
      if(return_value_strcmp$1 == 0)
        break;

    }

  return map->value;
}

// oscap_stringlist_add_string
// file ../../../src/common/list.c line 353
_Bool oscap_stringlist_add_string(struct oscap_stringlist *list, const char *str)
{
  char *return_value_strdup$1;
  return_value_strdup$1=strdup(str);
  _Bool return_value_oscap_list_add$2;
  return_value_oscap_list_add$2=oscap_list_add((struct oscap_list *)list, (void *)return_value_strdup$1);
  return return_value_oscap_list_add$2;
}

// oscap_stringlist_clone
// file ../../../src/common/list.c line 340
struct oscap_stringlist * oscap_stringlist_clone(struct oscap_stringlist *list)
{
  void *clone;
  struct oscap_list *return_value_oscap_list_new$1;
  return_value_oscap_list_new$1=oscap_list_new();
  clone = (void *)return_value_oscap_list_new$1;
  const char *str = (const char *)(void *)0;
  struct oscap_string_iterator *str_iter;
  str_iter=oscap_stringlist_get_strings(list);
  _Bool return_value_oscap_string_iterator_has_more$2;
  signed int tmp_if_expr$3;
  char *return_value_oscap_strdup$4;
  do
  {
    return_value_oscap_string_iterator_has_more$2=oscap_string_iterator_has_more(str_iter);
    if(!(return_value_oscap_string_iterator_has_more$2 == (_Bool)0))
    {
      str=oscap_string_iterator_next(str_iter);
      tmp_if_expr$3 = 1;
    }

    else
    {
      oscap_string_iterator_free(str_iter);
      str_iter = (struct oscap_string_iterator *)(void *)0;
      tmp_if_expr$3 = 0;
    }
    if(tmp_if_expr$3 == 0)
      break;

    return_value_oscap_strdup$4=oscap_strdup(str);
    oscap_list_add((struct oscap_list *)clone, (void *)return_value_oscap_strdup$4);
  }
  while((_Bool)1);
  return (struct oscap_stringlist *)clone;
}

// oscap_stringlist_free
// file ../../../src/common/list.c line 363
void oscap_stringlist_free(struct oscap_stringlist *list)
{
  oscap_list_free((struct oscap_list *)list, oscap_free);
}

// oscap_stringlist_get_strings
// file ../../../src/common/list.c line 348
struct oscap_string_iterator * oscap_stringlist_get_strings(struct oscap_stringlist *list)
{
  void *return_value_oscap_iterator_new$1;
  return_value_oscap_iterator_new$1=oscap_iterator_new((struct oscap_list *)list);
  return (struct oscap_string_iterator *)return_value_oscap_iterator_new$1;
}

// oscap_stringlist_iterator_free
// file ../../../src/common/list.c line 370
void oscap_stringlist_iterator_free(struct oscap_stringlist_iterator *it)
{
  oscap_iterator_free((struct oscap_iterator *)it);
}

// oscap_stringlist_iterator_has_more
// file ../../../src/common/list.c line 370
_Bool oscap_stringlist_iterator_has_more(struct oscap_stringlist_iterator *it)
{
  _Bool return_value_oscap_iterator_has_more$1;
  return_value_oscap_iterator_has_more$1=oscap_iterator_has_more((struct oscap_iterator *)it);
  return return_value_oscap_iterator_has_more$1;
}

// oscap_stringlist_iterator_next
// file ../../../src/common/list.c line 370
struct oscap_stringlist * oscap_stringlist_iterator_next(struct oscap_stringlist_iterator *it)
{
  void *return_value_oscap_iterator_next$1;
  return_value_oscap_iterator_next$1=oscap_iterator_next((struct oscap_iterator *)it);
  return (struct oscap_stringlist *)return_value_oscap_iterator_next$1;
}

// oscap_stringlist_iterator_remove
// file ../../../src/common/list.c line 371
void oscap_stringlist_iterator_remove(struct oscap_stringlist_iterator *it)
{
  void *return_value_oscap_iterator_detach$1;
  return_value_oscap_iterator_detach$1=oscap_iterator_detach((struct oscap_iterator *)it);
  oscap_stringlist_free((struct oscap_stringlist *)return_value_oscap_iterator_detach$1);
}

// oscap_stringlist_iterator_reset
// file ../../../src/common/list.c line 370
void oscap_stringlist_iterator_reset(struct oscap_stringlist_iterator *it)
{
  oscap_iterator_reset((struct oscap_iterator *)it);
}

// oscap_stringlist_new
// file ../../../src/common/list.c line 358
struct oscap_stringlist * oscap_stringlist_new(void)
{
  struct oscap_list *return_value_oscap_list_new$1;
  return_value_oscap_list_new$1=oscap_list_new();
  return (struct oscap_stringlist *)return_value_oscap_list_new$1;
}

// oscap_strlist_find_value
// file ../../../src/common/elements.c line 204
const char * oscap_strlist_find_value(char ** const kvalues, const char *key)
{
  _Bool tmp_if_expr$1;
  signed int return_value_strcmp$2;
  if(kvalues == ((char ** const )NULL) || key == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    signed int i = 0;
    do
    {
      if(!(kvalues[(signed long int)i] == ((char *)NULL)))
        tmp_if_expr$1 = kvalues[(signed long int)(i + 1)] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      return_value_strcmp$2=strcmp(kvalues[(signed long int)i], key);
      if(return_value_strcmp$2 == 0)
        return kvalues[(signed long int)(i + 1)];

      i = i + 2;
    }
    while((_Bool)1);
    return (const char *)(void *)0;
  }
}

// oscap_strtol
// file ../../../src/common/util.c line 73
float oscap_strtol(const char *str, char **endptr, signed int base)
{
  signed long int return_value_strtol$2;
  if(str == ((const char *)NULL))
  {
    float return_value___builtin_nanf$1;
    return_value___builtin_nanf$1=__builtin_nanf("");
    return return_value___builtin_nanf$1;
  }

  else
  {
    return_value_strtol$2=strtol(str, endptr, base);
    return (float)return_value_strtol$2;
  }
}

// oscap_strtoupper
// file ../../../src/common/util.c line 213
void oscap_strtoupper(char *str)
{
  signed int return_value_toupper$1;
  if(!(str == ((char *)NULL)))
    for( ; !(*str == 0); str = str + 1l)
    {
      return_value_toupper$1=toupper((signed int)*str);
      *str = (char)return_value_toupper$1;
    }

}

// oscap_sys_memusage
// file ../../../../../src/common/memusage.h line 32
signed int oscap_sys_memusage(struct sys_memusage *mu)
{
  if(mu == ((struct sys_memusage *)NULL))
    return -1;

  else
  {
    signed int return_value_read_status$1;
    return_value_read_status$1=read_status("/proc/meminfo", (void *)mu, __sys_stat_ptable, sizeof(struct stat_parser [6l]) /*144ul*/  / sizeof(struct stat_parser) /*24ul*/ );
    if(!(return_value_read_status$1 == 0))
      return -1;

    else
    {
      mu->mu_realfree = mu->mu_free + mu->mu_cached + mu->mu_buffers;
      return 0;
    }
  }
}

// oscap_text_clone
// file ../../../src/common/text.c line 91
struct oscap_text * oscap_text_clone(struct oscap_text *text)
{
  struct oscap_text *return_value_oscap_text_new_full$1;
  return_value_oscap_text_new_full$1=oscap_text_new_full(text->traits, text->text, text->lang);
  return return_value_oscap_text_new_full$1;
}

// oscap_text_consumer
// file ../../../src/common/elements.c line 67
void oscap_text_consumer(char *text, void *user)
{
  char *platform = *((char **)user);
  if(platform == ((char *)NULL))
    platform=oscap_strdup(text);

  else
  {
    signed int size;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(platform);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(text);
    size = (signed int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
    char *newtext;
    void *return_value___oscap_alloc$3;
    return_value___oscap_alloc$3=__oscap_alloc((unsigned long int)size * sizeof(char) /*1ul*/ );
    newtext = (char *)return_value___oscap_alloc$3;
    *newtext = (char)0;
    strcat(newtext, platform);
    strcat(newtext, text);
    __oscap_free((void *)platform);
    platform = newtext;
  }
  *((char **)user) = platform;
}

// oscap_text_export
// file ../../../src/common/text.c line 156
_Bool oscap_text_export(struct oscap_text *text, struct _xmlTextWriter *writer, const char *elname)
{
  _Bool tmp_if_expr$1;
  if(writer == ((struct _xmlTextWriter *)NULL) || text == ((struct oscap_text *)NULL))
    return (_Bool)0;

  else
  {
    if(!(elname == ((const char *)NULL)))
      xmlTextWriterStartElement(writer, (unsigned char *)elname);

    if(!(text->lang == ((char *)NULL)))
      xmlTextWriterWriteAttribute(writer, (unsigned char *)"xml:lang", (unsigned char *)text->lang);

    if(!(text->traits.can_override == 0))
    {
      if(!(text->traits.override_given == 0))
        xmlTextWriterWriteAttribute(writer, (unsigned char *)"override", (unsigned char *)(text->traits.overrides != 0 ? "true" : "false"));

    }

    if(!(text->traits.html == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = text->traits.can_substitute != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      xmlTextWriterWriteRaw(writer, (unsigned char *)text->text);

    else
      xmlTextWriterWriteString(writer, (unsigned char *)text->text);
    if(!(elname == ((const char *)NULL)))
      xmlTextWriterEndElement(writer);

    return (_Bool)1;
  }
}

// oscap_text_free
// file ../../../src/common/text.c line 67
void oscap_text_free(struct oscap_text *text)
{
  if(!(text == ((struct oscap_text *)NULL)))
  {
    __oscap_free((void *)text->lang);
    __oscap_free((void *)text->text);
    free((void *)text);
  }

}

// oscap_text_get_can_override
// file ../../../src/common/text.c line 54
_Bool oscap_text_get_can_override(struct oscap_text *item)
{
  return (_Bool)item->traits.can_override;
}

// oscap_text_get_can_substitute
// file ../../../src/common/text.c line 53
_Bool oscap_text_get_can_substitute(struct oscap_text *item)
{
  return (_Bool)item->traits.can_substitute;
}

// oscap_text_get_is_html
// file ../../../src/common/text.c line 52
_Bool oscap_text_get_is_html(struct oscap_text *item)
{
  return (_Bool)item->traits.html;
}

// oscap_text_get_lang
// file ../../../src/common/text.c line 51
const char * oscap_text_get_lang(struct oscap_text *item)
{
  return item->lang;
}

// oscap_text_get_overrides
// file ../../../src/common/text.c line 55
_Bool oscap_text_get_overrides(struct oscap_text *item)
{
  return (_Bool)item->traits.overrides;
}

// oscap_text_get_plaintext
// file ../../../src/common/text.c line 199
char * oscap_text_get_plaintext(struct oscap_text *text)
{
  char *return_value_oscap_strdup$1;
  if(text == ((struct oscap_text *)NULL))
    return (char *)(void *)0;

  else
    if(text->traits.html == 0)
    {
      return_value_oscap_strdup$1=oscap_strdup(text->text);
      return return_value_oscap_strdup$1;
    }

    else
    {
      char *return_value__xhtml_to_plaintext$2;
      return_value__xhtml_to_plaintext$2=_xhtml_to_plaintext(text->text);
      return return_value__xhtml_to_plaintext$2;
    }
}

// oscap_text_get_text
// file ../../../src/common/text.c line 50
const char * oscap_text_get_text(struct oscap_text *item)
{
  return item->text;
}

// oscap_text_iterator_free
// file ../../../src/common/text.c line 56
void oscap_text_iterator_free(struct oscap_text_iterator *it)
{
  oscap_iterator_free((struct oscap_iterator *)it);
}

// oscap_text_iterator_has_more
// file ../../../src/common/text.c line 56
_Bool oscap_text_iterator_has_more(struct oscap_text_iterator *it)
{
  _Bool return_value_oscap_iterator_has_more$1;
  return_value_oscap_iterator_has_more$1=oscap_iterator_has_more((struct oscap_iterator *)it);
  return return_value_oscap_iterator_has_more$1;
}

// oscap_text_iterator_next
// file ../../../src/common/text.c line 56
struct oscap_text * oscap_text_iterator_next(struct oscap_text_iterator *it)
{
  void *return_value_oscap_iterator_next$1;
  return_value_oscap_iterator_next$1=oscap_iterator_next((struct oscap_iterator *)it);
  return (struct oscap_text *)return_value_oscap_iterator_next$1;
}

// oscap_text_iterator_remove
// file ../../../src/common/text.c line 58
void oscap_text_iterator_remove(struct oscap_text_iterator *it)
{
  void *return_value_oscap_iterator_detach$1;
  return_value_oscap_iterator_detach$1=oscap_iterator_detach((struct oscap_iterator *)it);
  oscap_text_free((struct oscap_text *)return_value_oscap_iterator_detach$1);
}

// oscap_text_iterator_reset
// file ../../../src/common/text.c line 56
void oscap_text_iterator_reset(struct oscap_text_iterator *it)
{
  oscap_iterator_reset((struct oscap_iterator *)it);
}

// oscap_text_new
// file ../../../src/common/text.c line 86
struct oscap_text * oscap_text_new(void)
{
  struct oscap_text *return_value_oscap_text_new_full$1;
  return_value_oscap_text_new_full$1=oscap_text_new_full(OSCAP_TEXT_TRAITS_PLAIN, (const char *)(void *)0, (const char *)(void *)0);
  return return_value_oscap_text_new_full$1;
}

// oscap_text_new_full
// file ../../../src/common/text.c line 76
struct oscap_text * oscap_text_new_full(struct oscap_text_traits traits, const char *string, const char *lang)
{
  struct oscap_text *text;
  void *return_value___oscap_calloc$1;
  return_value___oscap_calloc$1=__oscap_calloc((unsigned long int)1, sizeof(struct oscap_text) /*24ul*/ );
  text = (struct oscap_text *)return_value___oscap_calloc$1;
  text->traits = traits;
  text->text=oscap_strdup(string);
  text->lang=oscap_strdup(lang);
  return text;
}

// oscap_text_new_html
// file ../../../src/common/text.c line 96
struct oscap_text * oscap_text_new_html(void)
{
  struct oscap_text *return_value_oscap_text_new_full$1;
  return_value_oscap_text_new_full$1=oscap_text_new_full(OSCAP_TEXT_TRAITS_HTML, (const char *)(void *)0, (const char *)(void *)0);
  return return_value_oscap_text_new_full$1;
}

// oscap_text_new_parse
// file ../../../src/common/text.c line 102
struct oscap_text * oscap_text_new_parse(struct oscap_text_traits traits, struct _xmlTextReader *reader)
{
  struct oscap_text *text;
  text=oscap_text_new_full(traits, (const char *)(void *)0, (const char *)(void *)0);
  if(!(text->traits.can_override == 0))
  {
    xmlTextReaderMoveToAttribute(reader, (unsigned char *)"override");
    const unsigned char *return_value_xmlTextReaderConstValue$1;
    return_value_xmlTextReaderConstValue$1=xmlTextReaderConstValue(reader);
    signed int return_value_oscap_string_to_enum$2;
    return_value_oscap_string_to_enum$2=oscap_string_to_enum(OSCAP_BOOL_MAP, (const char *)return_value_xmlTextReaderConstValue$1);
    text->traits.overrides = (_Bool)return_value_oscap_string_to_enum$2;
    const unsigned char *return_value_xmlTextReaderConstValue$3;
    return_value_xmlTextReaderConstValue$3=xmlTextReaderConstValue(reader);
    if(!(return_value_xmlTextReaderConstValue$3 == ((const unsigned char *)NULL)))
      text->traits.override_given = (_Bool)1;

  }

  unsigned char *return_value_xmlTextReaderXmlLang$4;
  return_value_xmlTextReaderXmlLang$4=xmlTextReaderXmlLang(reader);
  text->lang = (char *)return_value_xmlTextReaderXmlLang$4;
  xmlTextReaderMoveToElement(reader);
  _Bool tmp_if_expr$5;
  if(!(text->traits.html == 0))
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = text->traits.can_substitute != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
    text->text=oscap_get_xml(reader);

  else
    text->text=oscap_element_string_copy(reader);
  return text;
}

// oscap_text_set_lang
// file ../../../src/common/text.c line 51
_Bool oscap_text_set_lang(struct oscap_text *obj, const char *newval)
{
  free((void *)obj->lang);
  obj->lang=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_text_set_overrides
// file ../../../src/common/text.c line 61
_Bool oscap_text_set_overrides(struct oscap_text *text, _Bool overrides)
{
  text->traits.overrides = overrides;
  return (_Bool)text->traits.can_override;
}

// oscap_text_set_text
// file ../../../src/common/text.c line 50
_Bool oscap_text_set_text(struct oscap_text *obj, const char *newval)
{
  free((void *)obj->text);
  obj->text=oscap_strdup(newval);
  return (_Bool)1;
}

// oscap_text_to_dom
// file ../../../src/common/text.c line 129
struct _xmlNode * oscap_text_to_dom(struct oscap_text *text, struct _xmlNode *parent, const char *elname)
{
  _Bool tmp_if_expr$1;
  if(text == ((struct oscap_text *)NULL))
    return (struct _xmlNode *)(void *)0;

  else
  {
    struct _xmlNode *text_node = (struct _xmlNode *)(void *)0;
    if(!(text->traits.html == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = text->traits.can_substitute != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      text_node=oscap_xmlstr_to_dom(parent, elname, text->text);
      xmlSetNs(text_node, parent->ns);
    }

    else
      text_node=xmlNewTextChild(parent, (struct _xmlNs *)(void *)0, (unsigned char *)elname, (unsigned char *)text->text);
    if(text_node == ((struct _xmlNode *)NULL))
      return (struct _xmlNode *)(void *)0;

    else
    {
      if(!(text->lang == ((char *)NULL)))
        xmlNodeSetLang(text_node, (unsigned char *)text->lang);

      if(!(text->traits.can_override == 0))
      {
        if(!(text->traits.override_given == 0))
          xmlNewProp(text_node, (unsigned char *)"override", (unsigned char *)(text->traits.overrides != 0 ? "true" : "false"));

      }

      return text_node;
    }
  }
}

// oscap_textlist_export
// file ../../../src/common/text.c line 208
_Bool oscap_textlist_export(struct oscap_text_iterator *texts, struct _xmlTextWriter *writer, const char *elname)
{
  _Bool return_value_oscap_text_iterator_has_more$1;
  signed int tmp_if_expr$2;
  if(elname == ((const char *)NULL) || writer == ((struct _xmlTextWriter *)NULL) || texts == ((struct oscap_text_iterator *)NULL))
    return (_Bool)0;

  else
  {
    struct oscap_text *text = (struct oscap_text *)(void *)0;
    struct oscap_text_iterator *text_iter = texts;
    do
    {
      return_value_oscap_text_iterator_has_more$1=oscap_text_iterator_has_more(text_iter);
      if(!(return_value_oscap_text_iterator_has_more$1 == (_Bool)0))
      {
        text=oscap_text_iterator_next(text_iter);
        tmp_if_expr$2 = 1;
      }

      else
      {
        oscap_text_iterator_free(text_iter);
        text_iter = (struct oscap_text_iterator *)(void *)0;
        tmp_if_expr$2 = 0;
      }
      if(tmp_if_expr$2 == 0)
        break;

      oscap_text_export(text, writer, elname);
    }
    while((_Bool)1);
    return (_Bool)1;
  }
}

// oscap_textlist_get_preferred_plaintext
// file ../../../src/common/text.c line 252
char * oscap_textlist_get_preferred_plaintext(struct oscap_text_iterator *texts, const char *preferred_lang)
{
  struct oscap_text *text;
  text=oscap_textlist_get_preferred_text(texts, preferred_lang);
  char *tmp_if_expr$2;
  char *return_value_oscap_text_get_plaintext$1;
  if(!(text == ((struct oscap_text *)NULL)))
  {
    return_value_oscap_text_get_plaintext$1=oscap_text_get_plaintext(text);
    tmp_if_expr$2 = return_value_oscap_text_get_plaintext$1;
  }

  else
    tmp_if_expr$2 = (char *)(void *)0;
  return tmp_if_expr$2;
}

// oscap_textlist_get_preferred_text
// file ../../../src/common/text.c line 218
struct oscap_text * oscap_textlist_get_preferred_text(struct oscap_text_iterator *texts, const char *preferred_lang)
{
  if(preferred_lang == ((const char *)NULL))
    preferred_lang = OSCAP_LANG_DEFAULT;

  oscap_text_iterator_reset(texts);
  _Bool return_value_oscap_text_iterator_has_more$1;
  signed int return_value_strcmp$2;
  do
  {
    return_value_oscap_text_iterator_has_more$1=oscap_text_iterator_has_more(texts);
    if(return_value_oscap_text_iterator_has_more$1 == (_Bool)0)
      break;

    struct oscap_text *oscap_textlist_get_preferred_text$$1$$1$$text;
    oscap_textlist_get_preferred_text$$1$$1$$text=oscap_text_iterator_next(texts);
    const char *oscap_textlist_get_preferred_text$$1$$1$$lang;
    oscap_textlist_get_preferred_text$$1$$1$$lang=oscap_text_get_lang(oscap_textlist_get_preferred_text$$1$$1$$text);
    if(!(oscap_textlist_get_preferred_text$$1$$1$$lang == ((const char *)NULL)))
    {
      return_value_strcmp$2=strcmp(oscap_textlist_get_preferred_text$$1$$1$$lang, preferred_lang);
      if(return_value_strcmp$2 == 0)
        return oscap_textlist_get_preferred_text$$1$$1$$text;

    }

  }
  while((_Bool)1);
  oscap_text_iterator_reset(texts);
  _Bool return_value_oscap_text_iterator_has_more$3;
  do
  {
    return_value_oscap_text_iterator_has_more$3=oscap_text_iterator_has_more(texts);
    if(return_value_oscap_text_iterator_has_more$3 == (_Bool)0)
      break;

    struct oscap_text *oscap_textlist_get_preferred_text$$1$$2$$text;
    oscap_textlist_get_preferred_text$$1$$2$$text=oscap_text_iterator_next(texts);
    const char *lang;
    lang=oscap_text_get_lang(oscap_textlist_get_preferred_text$$1$$2$$text);
    if(lang == ((const char *)NULL))
      return oscap_textlist_get_preferred_text$$1$$2$$text;

  }
  while((_Bool)1);
  oscap_text_iterator_reset(texts);
  _Bool return_value_oscap_text_iterator_has_more$4;
  return_value_oscap_text_iterator_has_more$4=oscap_text_iterator_has_more(texts);
  if(!(return_value_oscap_text_iterator_has_more$4 == (_Bool)0))
  {
    struct oscap_text *text;
    text=oscap_text_iterator_next(texts);
    return text;
  }

  return (struct oscap_text *)(void *)0;
}

// oscap_to_start_element
// file ../../../src/common/elements.c line 50
_Bool oscap_to_start_element(struct _xmlTextReader *reader, signed int depth)
{
  signed int return_value_xmlTextReaderDepth$1;
  signed int return_value_xmlTextReaderDepth$3;
  do
  {
    return_value_xmlTextReaderDepth$1=xmlTextReaderDepth(reader);
    if(!(return_value_xmlTextReaderDepth$1 >= depth))
      break;

    signed int return_value_xmlTextReaderNodeType$2;
    return_value_xmlTextReaderNodeType$2=xmlTextReaderNodeType(reader);
    if(return_value_xmlTextReaderNodeType$2 == 1)
    {
      return_value_xmlTextReaderDepth$3=xmlTextReaderDepth(reader);
      if(return_value_xmlTextReaderDepth$3 == depth)
        return (_Bool)1;

    }

    signed int return_value_xmlTextReaderRead$4;
    return_value_xmlTextReaderRead$4=xmlTextReaderRead(reader);
    if(!(return_value_xmlTextReaderRead$4 == 1))
      break;

  }
  while((_Bool)1);
  return (_Bool)0;
}

// oscap_trim
// file ../../../src/common/util.c line 139
char * oscap_trim(char *str)
{
  signed int off;
  signed int i = 0;
  const unsigned short int **return_value___ctype_b_loc$1;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)str[(signed long int)i]]) == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    off = i;
    for( ; (_Bool)1; i = i + 1)
    {
      str[(signed long int)(i - off)] = str[(signed long int)i];
      if((signed int)str[(signed long int)i] == 0)
        break;

    }
    i = i - off;
    while(i >= 1)
    {
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      i = i - 1;
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)str[(signed long int)i]]) == 0)
      {
        str[(signed long int)(i + 1)] = (char)0;
        break;
      }

    }
    return str;
  }
}

// oscap_tsort
// file ../../../src/common/tsort.c line 105
_Bool oscap_tsort(struct oscap_list *input, struct oscap_list **output, struct oscap_list * (*edge_func)(void *, void *), _Bool (*cmp_func)(void *, void *), void *userdata)
{
  if(!(output == ((struct oscap_list **)NULL)))
    *output = (struct oscap_list *)(void *)0;

  if(cmp_func == ((_Bool (*)(void *, void *))NULL))
    cmp_func = oscap_ptr_cmp;

  struct oscap_tsort_context *ctx;
  ctx=oscap_tsort_context_new(edge_func, cmp_func, userdata);
  _Bool ret;
  ret=oscap_tsort_visit_all(input, ctx);
  if(!(output == ((struct oscap_list **)NULL)))
  {
    if(!(ret == (_Bool)0))
    {
      *output = ctx->result;
      ctx->result = (struct oscap_list *)(void *)0;
    }

    else
    {
      *output = ctx->cur_stack;
      ctx->cur_stack = (struct oscap_list *)(void *)0;
    }
  }

  oscap_tsort_context_free(ctx);
  return ret;
}

// oscap_tsort_context_free
// file ../../../src/common/tsort.c line 53
static void oscap_tsort_context_free(struct oscap_tsort_context *ctx)
{
  if(!(ctx == ((struct oscap_tsort_context *)NULL)))
  {
    oscap_list_free(ctx->visited, (void (*)(void *))(void *)0);
    oscap_list_free(ctx->cur_stack, (void (*)(void *))(void *)0);
    oscap_list_free(ctx->result, (void (*)(void *))(void *)0);
    __oscap_free((void *)ctx);
  }

}

// oscap_tsort_context_new
// file ../../../src/common/tsort.c line 41
static struct oscap_tsort_context * oscap_tsort_context_new(struct oscap_list * (*edge_func)(void *, void *), _Bool (*cmp_func)(void *, void *), void *userdata)
{
  struct oscap_tsort_context *ctx;
  void *return_value___oscap_calloc$1;
  return_value___oscap_calloc$1=__oscap_calloc((unsigned long int)1, sizeof(struct oscap_tsort_context) /*48ul*/ );
  ctx = (struct oscap_tsort_context *)return_value___oscap_calloc$1;
  ctx->visited=oscap_list_new();
  ctx->cur_stack=oscap_list_new();
  ctx->result=oscap_list_new();
  ctx->edge_func = edge_func;
  ctx->cmp_func = cmp_func;
  ctx->userdata = userdata;
  return ctx;
}

// oscap_tsort_visit
// file ../../../src/common/tsort.c line 81
static _Bool oscap_tsort_visit(void *node, struct oscap_tsort_context *ctx)
{
  _Bool return_value_oscap_list_contains$1;
  return_value_oscap_list_contains$1=oscap_list_contains(ctx->cur_stack, node, ctx->cmp_func);
  if(!(return_value_oscap_list_contains$1 == (_Bool)0))
    return (_Bool)0;

  else
  {
    _Bool return_value_oscap_list_contains$2;
    return_value_oscap_list_contains$2=oscap_list_contains(ctx->visited, node, ctx->cmp_func);
    if(!(return_value_oscap_list_contains$2 == (_Bool)0))
      return (_Bool)1;

    else
    {
      oscap_list_add(ctx->visited, node);
      oscap_list_push(ctx->cur_stack, node);
      struct oscap_list *next;
      next=ctx->edge_func(node, ctx->userdata);
      _Bool ret;
      ret=oscap_tsort_visit_all(next, ctx);
      oscap_list_free(next, (void (*)(void *))(void *)0);
      if(!(ret == (_Bool)0))
        oscap_list_pop(ctx->cur_stack, (void (*)(void *))(void *)0);

      oscap_list_add(ctx->result, node);
      return ret;
    }
  }
}

// oscap_tsort_visit_all
// file ../../../src/common/tsort.c line 65
static inline _Bool oscap_tsort_visit_all(struct oscap_list *nodelist, struct oscap_tsort_context *ctx)
{
  _Bool ret = (_Bool)1;
  struct oscap_iterator *it;
  void *return_value_oscap_iterator_new$1;
  return_value_oscap_iterator_new$1=oscap_iterator_new(nodelist);
  it = (struct oscap_iterator *)return_value_oscap_iterator_new$1;
  _Bool return_value_oscap_iterator_has_more$2;
  do
  {
    return_value_oscap_iterator_has_more$2=oscap_iterator_has_more(it);
    if(return_value_oscap_iterator_has_more$2 == (_Bool)0)
      break;

    void *return_value_oscap_iterator_next$3;
    return_value_oscap_iterator_next$3=oscap_iterator_next(it);
    _Bool return_value_oscap_tsort_visit$4;
    return_value_oscap_tsort_visit$4=oscap_tsort_visit(return_value_oscap_iterator_next$3, ctx);
    if(return_value_oscap_tsort_visit$4 == (_Bool)0)
    {
      ret = (_Bool)0;
      break;
    }

  }
  while((_Bool)1);
  oscap_iterator_free(it);
  return ret;
}

// oscap_validate_document
// file ../../../src/common/oscapxml.c line 119
signed int oscap_validate_document(const char *xmlfile, enum oscap_document_type doctype, const char *version, signed int (*reporter)(const char *, signed int, const char *, void *), void *arg)
{
  if(xmlfile == ((const char *)NULL))
  {
    __oscap_seterr("../../../src/common/oscapxml.c", (unsigned int)122, "oscap_validate_document", (unsigned short int)3, (const void *)"'xmlfile' == NULL");
    return -1;
  }

  else
  {
    signed int return_value_access$3;
    return_value_access$3=access(xmlfile, 4);
    if(!(return_value_access$3 == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      __oscap_seterr("../../../src/common/oscapxml.c", (unsigned int)127, "oscap_validate_document", (unsigned short int)1, (const void *)"%s '%s'", return_value_strerror$2, xmlfile);
      return -1;
    }

    struct oscap_source *source;
    source=oscap_source_new_from_file(xmlfile);
    signed int ret;
    ret=oscap_source_validate_priv(source, doctype, version, reporter, arg);
    oscap_source_free(source);
    return ret;
  }
}

// oscap_verbosity_level_from_cstr
// file ../../../src/common/debug.c line 80
enum anonymous$2 oscap_verbosity_level_from_cstr(const char *level_name)
{
  signed int return_value_oscap_string_to_enum$1;
  return_value_oscap_string_to_enum$1=oscap_string_to_enum(OSCAP_VERBOSITY_LEVELS, level_name);
  return (enum anonymous$2)return_value_oscap_string_to_enum$1;
}

// oscap_vsprintf
// file ../../../src/common/util.h line 364
char * oscap_vsprintf(const char *fmt, void **ap)
{
  void *return_value___oscap_alloc$1;
  if(fmt == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *ret = (char *)(void *)0;
    void **args = (void **)ap;
    char foo[2l];
    signed int length;
    length=vsnprintf(foo, (unsigned long int)1, fmt, ap);
    if(length >= 0)
    {
      return_value___oscap_alloc$1=__oscap_alloc(sizeof(char) /*1ul*/  * (unsigned long int)(length + 1));
      ret = (char *)return_value___oscap_alloc$1;
      vsprintf(ret, fmt, args);
    }


  cleanup:
    ;
    args = ((void **)NULL);
    return ret;
  }
}

// oscap_xml_save_filename
// file ../../../src/common/elements.c line 215
signed int oscap_xml_save_filename(const char *filename, struct _xmlDoc *doc)
{
  struct _xmlOutputBuffer *buff;
  signed int xmlCode;
  signed int return_value_strcmp$4;
  return_value_strcmp$4=strcmp(filename, "-");
  if(return_value_strcmp$4 == 0)
    xmlCode=xmlSaveFormatFileEnc(filename, doc, "UTF-8", 1);

  else
  {
    signed int fd;
    fd=open(filename, 0100 | 01000 | 01, 0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      __oscap_seterr("../../../src/common/elements.c", (unsigned int)227, "oscap_xml_save_filename", (unsigned short int)1, (const void *)"%s '%s'", return_value_strerror$2, filename);
      return -1;
    }

    buff=xmlOutputBufferCreateFd(fd, (struct _xmlCharEncodingHandler *)(void *)0);
    if(buff == ((struct _xmlOutputBuffer *)NULL))
    {
      close(fd);
      struct _xmlError *return_value_xmlGetLastError$3;
      return_value_xmlGetLastError$3=xmlGetLastError();
      __oscap_setxmlerr("../../../src/common/elements.c", (unsigned int)234, "oscap_xml_save_filename", return_value_xmlGetLastError$3);
      __oscap_dlprintf(DBG_W, "../../../src/common/elements.c", "oscap_xml_save_filename", (unsigned long int)235, "xmlOutputBufferCreateFile() failed.");
      return -1;
    }

    xmlCode=xmlSaveFormatFileTo(buff, doc, "UTF-8", 1);
    close(fd);
  }
  if(!(xmlCode >= 1))
  {
    struct _xmlError *return_value_xmlGetLastError$5;
    return_value_xmlGetLastError$5=xmlGetLastError();
    __oscap_setxmlerr("../../../src/common/elements.c", (unsigned int)243, "oscap_xml_save_filename", return_value_xmlGetLastError$5);
    __oscap_dlprintf(DBG_W, "../../../src/common/elements.c", "oscap_xml_save_filename", (unsigned long int)244, "No bytes exported: xmlCode: %d.", xmlCode);
  }

  return xmlCode >= 1 ? 1 : -1;
}

// oscap_xml_save_filename_free
// file ../../../src/common/elements.c line 250
signed int oscap_xml_save_filename_free(const char *filename, struct _xmlDoc *doc)
{
  signed int ret;
  ret=oscap_xml_save_filename(filename, doc);
  xmlFreeDoc(doc);
  return ret;
}

// oscap_xmlstr_to_dom
// file ../../../src/common/elements.c line 190
struct _xmlNode * oscap_xmlstr_to_dom(struct _xmlNode *parent, const char *elname, const char *content)
{
  char *str;
  str=oscap_sprintf("<x xmlns:xhtml='http://www.w3.org/1999/xhtml'>%s</x>", content);
  struct _xmlDoc *doc;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  doc=xmlReadMemory(str, (signed int)return_value_strlen$1, (const char *)(void *)0, (const char *)(void *)0, 1 | 32 | 64 | 2048 | 8192);
  struct _xmlNode *text_node;
  struct _xmlNode *return_value_xmlDocGetRootElement$2;
  return_value_xmlDocGetRootElement$2=xmlDocGetRootElement(doc);
  text_node=xmlCopyNode(return_value_xmlDocGetRootElement$2, 1);
  xmlNodeSetName(text_node, (unsigned char *)elname);
  xmlAddChild(parent, text_node);
  xmlFreeDoc(doc);
  __oscap_free((void *)str);
  return text_node;
}

// oval_binary_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 40
enum anonymous$18 oval_binary_cmp(const char *state, const char *syschar, enum anonymous$36 operation)
{
  signed int return_value_istrcmp$1;
  signed int return_value_istrcmp$2;
  switch((signed int)operation)
  {
    case OVAL_OPERATION_EQUALS:
    {
      return_value_istrcmp$1=istrcmp(state, syschar);
      return (enum anonymous$18)(return_value_istrcmp$1 == 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    }
    case OVAL_OPERATION_NOT_EQUAL:
    {
      return_value_istrcmp$2=istrcmp(state, syschar);
      return (enum anonymous$18)(return_value_istrcmp$2 != 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    }
    default:
    {
      __oscap_seterr("../../../../src/OVAL/results/oval_cmp_basic.c", (unsigned int)209, "oval_binary_cmp", (unsigned short int)4, (const void *)"Invalid type of operation in binary evalu\023ation: %d.", operation);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }
  }
}

// oval_boolean_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 32
enum anonymous$18 oval_boolean_cmp(const _Bool state, const _Bool syschar, enum anonymous$36 operation)
{
  switch((signed int)operation)
  {
    case OVAL_OPERATION_EQUALS:
      return (enum anonymous$18)(state == syschar ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_NOT_EQUAL:
      return (enum anonymous$18)(state != syschar ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    default:
    {
      __oscap_seterr("../../../../src/OVAL/results/oval_cmp_basic.c", (unsigned int)49, "oval_boolean_cmp", (unsigned short int)4, (const void *)"Invalid type of operation in boolean evaluation: %d.", operation);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }
  }
}

// oval_ent_cmp_str
// file ../../../../src/OVAL/results/oval_cmp.c line 159
enum anonymous$18 oval_ent_cmp_str(char *state_data, enum anonymous$10 state_data_type, struct oval_sysent *sysent, enum anonymous$36 operation)
{
  const char *sys_data;
  sys_data=oval_sysent_get_value(sysent);
  enum anonymous$18 return_value_oval_str_cmp_str$1;
  return_value_oval_str_cmp_str$1=oval_str_cmp_str(state_data, state_data_type, sys_data, operation);
  return return_value_oval_str_cmp_str$1;
}

// oval_evr_string_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_evr_string_impl.h line 49
enum anonymous$18 oval_evr_string_cmp(const char *state, const char *sys, enum anonymous$36 operation)
{
  signed int result;
  result=rpmevrcmp(sys, state);
  if((signed int)operation == OVAL_OPERATION_EQUALS)
    return (enum anonymous$18)(result == 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);

  else
    if((signed int)operation == OVAL_OPERATION_NOT_EQUAL)
      return (enum anonymous$18)(result != 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);

    else
      if((signed int)operation == OVAL_OPERATION_GREATER_THAN)
        return (enum anonymous$18)(result == 1 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);

      else
        if((signed int)operation == OVAL_OPERATION_GREATER_THAN_OR_EQUAL)
          return (enum anonymous$18)(result != -1 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);

        else
          if((signed int)operation == OVAL_OPERATION_LESS_THAN)
            return (enum anonymous$18)(result == -1 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);

          else
            if((signed int)operation == OVAL_OPERATION_LESS_THAN_OR_EQUAL)
              return (enum anonymous$18)(result != 1 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);

  __oscap_seterr("../../../../src/OVAL/results/oval_cmp_evr_string.c", (unsigned int)74, "oval_evr_string_cmp", (unsigned short int)4, (const void *)"Invalid type of operation in rpm version comparison: %d.", operation);
  return (enum anonymous$18)OVAL_RESULT_ERROR;
}

// oval_float_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 36
enum anonymous$18 oval_float_cmp(const double state_val, const double sys_val, enum anonymous$36 operation)
{
  if((signed int)operation == OVAL_OPERATION_EQUALS)
  {
    signed int return_value_cmp_float$1;
    return_value_cmp_float$1=cmp_float(sys_val, state_val);
    return (enum anonymous$18)(return_value_cmp_float$1 == 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
  }

  else
    if((signed int)operation == OVAL_OPERATION_NOT_EQUAL)
    {
      signed int return_value_cmp_float$2;
      return_value_cmp_float$2=cmp_float(sys_val, state_val);
      return (enum anonymous$18)(return_value_cmp_float$2 != 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    }

    else
      if((signed int)operation == OVAL_OPERATION_GREATER_THAN)
      {
        signed int return_value_cmp_float$3;
        return_value_cmp_float$3=cmp_float(sys_val, state_val);
        return (enum anonymous$18)(return_value_cmp_float$3 == 1 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
      }

      else
        if((signed int)operation == OVAL_OPERATION_GREATER_THAN_OR_EQUAL)
        {
          signed int return_value_cmp_float$4;
          return_value_cmp_float$4=cmp_float(sys_val, state_val);
          return (enum anonymous$18)(return_value_cmp_float$4 >= 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
        }

        else
          if((signed int)operation == OVAL_OPERATION_LESS_THAN)
          {
            signed int return_value_cmp_float$5;
            return_value_cmp_float$5=cmp_float(sys_val, state_val);
            return (enum anonymous$18)(return_value_cmp_float$5 == -1 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
          }

          else
            if((signed int)operation == OVAL_OPERATION_LESS_THAN_OR_EQUAL)
            {
              signed int return_value_cmp_float$6;
              return_value_cmp_float$6=cmp_float(sys_val, state_val);
              return (enum anonymous$18)(return_value_cmp_float$6 <= 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
            }

            else
            {
              const char *return_value_oval_operation_get_text$7;
              return_value_oval_operation_get_text$7=oval_operation_get_text(operation);
              __oscap_seterr("../../../../src/OVAL/results/oval_cmp_basic.c", (unsigned int)113, "oval_float_cmp", (unsigned short int)4, (const void *)"Invalid type of operation in float evaluation: %s.", return_value_oval_operation_get_text$7);
              return (enum anonymous$18)OVAL_RESULT_ERROR;
            }
}

// oval_int_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 34
enum anonymous$18 oval_int_cmp(const signed long int state, const signed long int syschar, enum anonymous$36 operation)
{
  switch((signed int)operation)
  {
    case OVAL_OPERATION_EQUALS:
      return (enum anonymous$18)(state == syschar ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_NOT_EQUAL:
      return (enum anonymous$18)(state != syschar ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_GREATER_THAN:
      return (enum anonymous$18)(syschar > state ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_GREATER_THAN_OR_EQUAL:
      return (enum anonymous$18)(syschar >= state ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_LESS_THAN:
      return (enum anonymous$18)(syschar < state ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_LESS_THAN_OR_EQUAL:
      return (enum anonymous$18)(syschar <= state ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_BITWISE_AND:
      return (enum anonymous$18)((syschar & state) == state ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    case OVAL_OPERATION_BITWISE_OR:
      return (enum anonymous$18)((syschar | state) == state ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    default:
    {
      __oscap_seterr("../../../../src/OVAL/results/oval_cmp_basic.c", (unsigned int)74, "oval_int_cmp", (unsigned short int)4, (const void *)"Invalid type of operation in integer evaluation: %d.", operation);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }
  }
}

// oval_ipaddr_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_ip_address_impl.h line 51
enum anonymous$18 oval_ipaddr_cmp(signed int af, const char *s1, const char *s2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  unsigned int mask1 = (unsigned int)0;
  unsigned int mask2 = (unsigned int)0;
  char addr1[46l];
  char addr2[46l];
  signed int return_value_ipaddr_parse$1;
  return_value_ipaddr_parse$1=ipaddr_parse(af, s1, &mask1, (void *)&addr1);
  _Bool tmp_if_expr$3;
  signed int return_value_ipaddr_parse$2;
  if(!(return_value_ipaddr_parse$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_ipaddr_parse$2=ipaddr_parse(af, s2, &mask2, (void *)&addr2);
    tmp_if_expr$3 = return_value_ipaddr_parse$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_ipaddr_cmp$4;
  signed int return_value_ipaddr_cmp$5;
  signed int return_value_ipaddr_cmp$6;
  signed int return_value_ipaddr_cmp$7;
  signed int return_value_ipaddr_cmp$8;
  signed int return_value_ipaddr_cmp$9;
  signed int return_value_ipaddr_cmp$10;
  signed int return_value_ipaddr_cmp$11;
  if(tmp_if_expr$3)
    return result;

  else
  {
    switch((signed int)op)
    {
      case OVAL_OPERATION_EQUALS:
      {
        return_value_ipaddr_cmp$4=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(return_value_ipaddr_cmp$4 == 0 && mask1 == mask2)
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      case OVAL_OPERATION_NOT_EQUAL:
      {
        return_value_ipaddr_cmp$5=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(!(return_value_ipaddr_cmp$5 == 0) || !(mask1 == mask2))
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      case OVAL_OPERATION_SUBSET_OF:
      {
        if(!(mask2 >= mask1))
        {
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
          break;
        }

        ipaddr_mask(af, (const void *)&addr1, mask1);
        ipaddr_mask(af, (const void *)&addr2, mask1);
        return_value_ipaddr_cmp$6=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(return_value_ipaddr_cmp$6 == 0)
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      case OVAL_OPERATION_GREATER_THAN:
      {
        if(!(mask1 == mask2))
          return (enum anonymous$18)OVAL_RESULT_ERROR;

        ipaddr_mask(af, (const void *)&addr1, mask1);
        ipaddr_mask(af, (const void *)&addr2, mask2);
        return_value_ipaddr_cmp$7=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(!(return_value_ipaddr_cmp$7 >= 0))
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      case OVAL_OPERATION_GREATER_THAN_OR_EQUAL:
      {
        if(!(mask1 == mask2))
          return (enum anonymous$18)OVAL_RESULT_ERROR;

        ipaddr_mask(af, (const void *)&addr1, mask1);
        ipaddr_mask(af, (const void *)&addr2, mask2);
        return_value_ipaddr_cmp$8=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(!(return_value_ipaddr_cmp$8 >= 1))
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      case OVAL_OPERATION_SUPERSET_OF:
      {
        if(!(mask1 >= mask2))
        {
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
          break;
        }

        ipaddr_mask(af, (const void *)&addr1, mask2);
        ipaddr_mask(af, (const void *)&addr2, mask2);
        return_value_ipaddr_cmp$9=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(return_value_ipaddr_cmp$9 == 0)
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      case OVAL_OPERATION_LESS_THAN:
      {
        if(!(mask1 == mask2))
          return (enum anonymous$18)OVAL_RESULT_ERROR;

        ipaddr_mask(af, (const void *)&addr1, mask1);
        ipaddr_mask(af, (const void *)&addr2, mask2);
        return_value_ipaddr_cmp$10=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(return_value_ipaddr_cmp$10 >= 1)
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      case OVAL_OPERATION_LESS_THAN_OR_EQUAL:
      {
        if(!(mask1 == mask2))
          return (enum anonymous$18)OVAL_RESULT_ERROR;

        ipaddr_mask(af, (const void *)&addr1, mask1);
        ipaddr_mask(af, (const void *)&addr2, mask2);
        return_value_ipaddr_cmp$11=ipaddr_cmp(af, (const void *)&addr1, (const void *)&addr2);
        if(return_value_ipaddr_cmp$11 >= 0)
          result = (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          result = (enum anonymous$18)OVAL_RESULT_FALSE;
        break;
      }
      default:
        __oscap_dlprintf(DBG_E, "../../../../src/OVAL/results/oval_cmp_ip_address.c", "oval_ipaddr_cmp", (unsigned long int)189, "Unexpected compare operation: %d.", op);
    }
    return result;
  }
}

// oval_str_cmp_str
// file ../../../../src/OVAL/results/oval_cmp.c line 91
enum anonymous$18 oval_str_cmp_str(char *state_data, enum anonymous$10 state_data_type, const char *sys_data, enum anonymous$36 operation)
{
  _Bool tmp_if_expr$18;
  signed int return_value_strcmp$17;
  _Bool tmp_if_expr$21;
  signed int return_value_strcmp$20;
  if((signed int)state_data_type == OVAL_DATATYPE_STRING)
  {
    enum anonymous$18 return_value_oval_string_cmp$1;
    return_value_oval_string_cmp$1=oval_string_cmp(state_data, sys_data, operation);
    return return_value_oval_string_cmp$1;
  }

  else
    if((signed int)state_data_type == OVAL_DATATYPE_INTEGER)
    {
      signed long int state_val;
      signed long int syschar_val;
      _Bool return_value_cstr_to_intmax$4;
      return_value_cstr_to_intmax$4=cstr_to_intmax(state_data, &state_val);
      if(return_value_cstr_to_intmax$4 == (_Bool)0)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        __oscap_seterr("../../../../src/OVAL/results/oval_cmp.c", (unsigned int)103, "oval_str_cmp_str", (unsigned short int)4, (const void *)"Conversion of the string \"%s\" to an integer (%u bits) failed: %s", state_data, sizeof(signed long int) /*8ul*/  * (unsigned long int)8, return_value_strerror$3);
        return (enum anonymous$18)OVAL_RESULT_ERROR;
      }

      _Bool return_value_cstr_to_intmax$7;
      return_value_cstr_to_intmax$7=cstr_to_intmax(sys_data, &syschar_val);
      if(return_value_cstr_to_intmax$7 == (_Bool)0)
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        __oscap_seterr("../../../../src/OVAL/results/oval_cmp.c", (unsigned int)110, "oval_str_cmp_str", (unsigned short int)4, (const void *)"Conversion of the string \"%s\" to an integer (%u bits) failed: %s", sys_data, sizeof(signed long int) /*8ul*/  * (unsigned long int)8, return_value_strerror$6);
        return (enum anonymous$18)OVAL_RESULT_ERROR;
      }

      enum anonymous$18 return_value_oval_int_cmp$8;
      return_value_oval_int_cmp$8=oval_int_cmp(state_val, syschar_val, operation);
      return return_value_oval_int_cmp$8;
    }

    else
      if((signed int)state_data_type == OVAL_DATATYPE_FLOAT)
      {
        double oval_str_cmp_str$$1$$3$$state_val;
        double sys_val;
        _Bool return_value_cstr_to_double$11;
        return_value_cstr_to_double$11=cstr_to_double(state_data, &oval_str_cmp_str$$1$$3$$state_val);
        if(return_value_cstr_to_double$11 == (_Bool)0)
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          char *return_value_strerror$10;
          return_value_strerror$10=strerror(*return_value___errno_location$9);
          __oscap_seterr("../../../../src/OVAL/results/oval_cmp.c", (unsigned int)120, "oval_str_cmp_str", (unsigned short int)4, (const void *)"Conversion of the string \"%s\" to a floating type (double) failed: %s", state_data, return_value_strerror$10);
          return (enum anonymous$18)OVAL_RESULT_ERROR;
        }

        _Bool return_value_cstr_to_double$14;
        return_value_cstr_to_double$14=cstr_to_double(sys_data, &sys_val);
        if(return_value_cstr_to_double$14 == (_Bool)0)
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          __oscap_seterr("../../../../src/OVAL/results/oval_cmp.c", (unsigned int)127, "oval_str_cmp_str", (unsigned short int)4, (const void *)"Conversion of the string \"%s\" to a floating type (double) failed: %s", sys_data, return_value_strerror$13);
          return (enum anonymous$18)OVAL_RESULT_ERROR;
        }

        enum anonymous$18 return_value_oval_float_cmp$15;
        return_value_oval_float_cmp$15=oval_float_cmp(oval_str_cmp_str$$1$$3$$state_val, sys_val, operation);
        return return_value_oval_float_cmp$15;
      }

      else
        if((signed int)state_data_type == OVAL_DATATYPE_BOOLEAN)
        {
          signed int state_int;
          signed int sys_int;
          signed int return_value_strcmp$16;
          return_value_strcmp$16=strcmp(state_data, "true");
          if(return_value_strcmp$16 == 0)
            tmp_if_expr$18 = (_Bool)1;

          else
          {
            return_value_strcmp$17=strcmp(state_data, "1");
            tmp_if_expr$18 = return_value_strcmp$17 == 0 ? (_Bool)1 : (_Bool)0;
          }
          state_int = tmp_if_expr$18 ? 1 : 0;
          signed int return_value_strcmp$19;
          return_value_strcmp$19=strcmp(sys_data, "true");
          if(return_value_strcmp$19 == 0)
            tmp_if_expr$21 = (_Bool)1;

          else
          {
            return_value_strcmp$20=strcmp(sys_data, "1");
            tmp_if_expr$21 = return_value_strcmp$20 == 0 ? (_Bool)1 : (_Bool)0;
          }
          sys_int = tmp_if_expr$21 ? 1 : 0;
          enum anonymous$18 return_value_oval_boolean_cmp$22;
          return_value_oval_boolean_cmp$22=oval_boolean_cmp((const _Bool)state_int, (const _Bool)sys_int, operation);
          return return_value_oval_boolean_cmp$22;
        }

        else
          if((signed int)state_data_type == OVAL_DATATYPE_BINARY)
          {
            enum anonymous$18 return_value_oval_binary_cmp$23;
            return_value_oval_binary_cmp$23=oval_binary_cmp(state_data, sys_data, operation);
            return return_value_oval_binary_cmp$23;
          }

          else
            if((signed int)state_data_type == OVAL_DATATYPE_EVR_STRING)
            {
              enum anonymous$18 return_value_oval_evr_string_cmp$24;
              return_value_oval_evr_string_cmp$24=oval_evr_string_cmp(state_data, sys_data, operation);
              return return_value_oval_evr_string_cmp$24;
            }

            else
              if((signed int)state_data_type == OVAL_DATATYPE_DEBIAN_EVR_STRING)
              {
                enum anonymous$18 return_value_oval_evr_string_cmp$25;
                return_value_oval_evr_string_cmp$25=oval_evr_string_cmp(state_data, sys_data, operation);
                return return_value_oval_evr_string_cmp$25;
              }

              else
                if((signed int)state_data_type == OVAL_DATATYPE_VERSION)
                {
                  enum anonymous$18 return_value_oval_versiontype_cmp$26;
                  return_value_oval_versiontype_cmp$26=oval_versiontype_cmp(state_data, sys_data, operation);
                  return return_value_oval_versiontype_cmp$26;
                }

                else
                  if((signed int)state_data_type == OVAL_DATATYPE_IPV4ADDR)
                  {
                    enum anonymous$18 return_value_oval_ipaddr_cmp$27;
                    return_value_oval_ipaddr_cmp$27=oval_ipaddr_cmp(2, state_data, sys_data, operation);
                    return return_value_oval_ipaddr_cmp$27;
                  }

                  else
                    if((signed int)state_data_type == OVAL_DATATYPE_IPV6ADDR)
                    {
                      enum anonymous$18 return_value_oval_ipaddr_cmp$28;
                      return_value_oval_ipaddr_cmp$28=oval_ipaddr_cmp(10, state_data, sys_data, operation);
                      return return_value_oval_ipaddr_cmp$28;
                    }

                    else
                      if((signed int)state_data_type == OVAL_DATATYPE_FILESET_REVISION || (signed int)state_data_type == OVAL_DATATYPE_IOS_VERSION)
                      {
                        const char *return_value_oval_datatype_get_text$29;
                        return_value_oval_datatype_get_text$29=oval_datatype_get_text(state_data_type);
                        __oscap_dlprintf(DBG_W, "../../../../src/OVAL/results/oval_cmp.c", "oval_str_cmp_str", (unsigned long int)151, "Unsupported data type: %s.", return_value_oval_datatype_get_text$29);
                        return (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;
                      }

  __oscap_seterr("../../../../src/OVAL/results/oval_cmp.c", (unsigned int)155, "oval_str_cmp_str", (unsigned short int)4, (const void *)"Invalid OVAL data type: %d.", state_data_type);
  return (enum anonymous$18)OVAL_RESULT_ERROR;
}

// oval_string_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_basic_impl.h line 38
enum anonymous$18 oval_string_cmp(const char *state, const char *syschar, enum anonymous$36 operation)
{
  syschar = syschar != ((const char *)NULL) ? syschar : "";
  signed int return_value_oscap_strcmp$1;
  signed int return_value_istrcmp$2;
  signed int return_value_oscap_strcmp$3;
  signed int return_value_istrcmp$4;
  enum anonymous$18 return_value_strregcomp$5;
  switch((signed int)operation)
  {
    case OVAL_OPERATION_EQUALS:
    {
      return_value_oscap_strcmp$1=oscap_strcmp(state, syschar);
      return (enum anonymous$18)(return_value_oscap_strcmp$1 != 0 ? OVAL_RESULT_FALSE : OVAL_RESULT_TRUE);
    }
    case OVAL_OPERATION_CASE_INSENSITIVE_EQUALS:
    {
      return_value_istrcmp$2=istrcmp(state, syschar);
      return (enum anonymous$18)(return_value_istrcmp$2 != 0 ? OVAL_RESULT_FALSE : OVAL_RESULT_TRUE);
    }
    case OVAL_OPERATION_NOT_EQUAL:
    {
      return_value_oscap_strcmp$3=oscap_strcmp(state, syschar);
      return (enum anonymous$18)(return_value_oscap_strcmp$3 != 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    }
    case OVAL_OPERATION_CASE_INSENSITIVE_NOT_EQUAL:
    {
      return_value_istrcmp$4=istrcmp(state, syschar);
      return (enum anonymous$18)(return_value_istrcmp$4 != 0 ? OVAL_RESULT_TRUE : OVAL_RESULT_FALSE);
    }
    case OVAL_OPERATION_PATTERN_MATCH:
    {
      return_value_strregcomp$5=strregcomp(state, syschar);
      return return_value_strregcomp$5;
    }
    default:
    {
      __oscap_seterr("../../../../src/OVAL/results/oval_cmp_basic.c", (unsigned int)195, "oval_string_cmp", (unsigned short int)4, (const void *)"Invalid type of operation in string evaluation: %d.", operation);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }
  }
}

// oval_versiontype_cmp
// file ../../../../../src/OVAL/probes/probe/../../results/oval_cmp_evr_string_impl.h line 51
enum anonymous$18 oval_versiontype_cmp(const char *state, const char *syschar, enum anonymous$36 operation)
{
  signed int state_idx = 0;
  signed int sys_idx = 0;
  signed int result = -1;
  state_idx = 0;
  sys_idx = 0;
  _Bool tmp_if_expr$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  do
  {
    if(!(state[(signed long int)state_idx] == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = syschar[(signed long int)sys_idx] != 0 ? (_Bool)1 : (_Bool)0;
    if(!(result == -1) || !tmp_if_expr$1)
      break;

    signed int tmp_state_int;
    signed int tmp_sys_int;
    tmp_state_int=atoi(&state[(signed long int)state_idx]);
    tmp_sys_int=atoi(&syschar[(signed long int)sys_idx]);
    if((signed int)operation == OVAL_OPERATION_EQUALS)
    {
      if(!(tmp_state_int == tmp_sys_int))
        return (enum anonymous$18)OVAL_RESULT_FALSE;

    }

    else
      if((signed int)operation == OVAL_OPERATION_NOT_EQUAL)
      {
        if(!(tmp_state_int == tmp_sys_int))
          return (enum anonymous$18)OVAL_RESULT_TRUE;

      }

      else
        if((signed int)operation == OVAL_OPERATION_GREATER_THAN || (signed int)operation == OVAL_OPERATION_GREATER_THAN_OR_EQUAL)
        {
          if(!(tmp_state_int >= tmp_sys_int))
            return (enum anonymous$18)OVAL_RESULT_TRUE;

          if(!(tmp_sys_int >= tmp_state_int))
            return (enum anonymous$18)OVAL_RESULT_FALSE;

        }

        else
          if((signed int)operation == OVAL_OPERATION_LESS_THAN || (signed int)operation == OVAL_OPERATION_LESS_THAN_OR_EQUAL)
          {
            if(!(tmp_sys_int >= tmp_state_int))
              return (enum anonymous$18)OVAL_RESULT_TRUE;

            if(!(tmp_state_int >= tmp_sys_int))
              return (enum anonymous$18)OVAL_RESULT_FALSE;

          }

          else
          {
            __oscap_seterr("../../../../src/OVAL/results/oval_cmp_evr_string.c", (unsigned int)316, "oval_versiontype_cmp", (unsigned short int)4, (const void *)"Invalid type of operation in version comparison: %d.", operation);
            return (enum anonymous$18)OVAL_RESULT_ERROR;
          }
    if(!(state[(signed long int)state_idx] == 0))
      state_idx = state_idx + 1;

    for( ; !(state[(signed long int)state_idx] == 0); state_idx = state_idx + 1)
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)state[(signed long int)state_idx]]) == 0)
        break;

    }
    if(!(state[(signed long int)state_idx] == 0))
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)state[(signed long int)state_idx]]) == 0)
        state_idx = state_idx + 1;

    }

    if(!(syschar[(signed long int)sys_idx] == 0))
      sys_idx = sys_idx + 1;

    for( ; !(syschar[(signed long int)sys_idx] == 0); sys_idx = sys_idx + 1)
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)syschar[(signed long int)sys_idx]]) == 0)
        break;

    }
    if(!(syschar[(signed long int)sys_idx] == 0))
    {
      return_value___ctype_b_loc$5=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)syschar[(signed long int)sys_idx]]) == 0)
        sys_idx = sys_idx + 1;

    }

  }
  while((_Bool)1);
  if((signed int)operation == OVAL_OPERATION_EQUALS)
    return (enum anonymous$18)OVAL_RESULT_TRUE;

  else
    if((signed int)operation == OVAL_OPERATION_NOT_EQUAL)
      return (enum anonymous$18)OVAL_RESULT_FALSE;

    else
      if((signed int)operation == OVAL_OPERATION_GREATER_THAN)
        return (enum anonymous$18)OVAL_RESULT_FALSE;

      else
        if((signed int)operation == OVAL_OPERATION_GREATER_THAN_OR_EQUAL)
          return (enum anonymous$18)OVAL_RESULT_TRUE;

        else
          if((signed int)operation == OVAL_OPERATION_LESS_THAN)
            return (enum anonymous$18)OVAL_RESULT_FALSE;

          else
            if((signed int)operation == OVAL_OPERATION_LESS_THAN_OR_EQUAL)
              return (enum anonymous$18)OVAL_RESULT_TRUE;

  return (enum anonymous$18)OVAL_RESULT_ERROR;
}

// parseEVR
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 119
static void parseEVR(char *evr, const char **ep, const char **vp, const char **rp)
{
  const char *epoch;
  const char *version;
  const char *release;
  char *s;
  char *se;
  s = evr;
  signed int return_value_risdigit$1;
  for( ; !(*s == 0); s = s + 1l)
  {
    return_value_risdigit$1=risdigit((signed int)*s);
    if(return_value_risdigit$1 == 0)
      break;

  }
  se=strrchr(s, 45);
  char *tmp_post$2;
  if((signed int)*s == 58)
  {
    epoch = evr;
    tmp_post$2 = s;
    s = s + 1l;
    *tmp_post$2 = (char)0;
    version = s;
    if((signed int)*epoch == 0)
      epoch = "0";

  }

  else
  {
    epoch = (const char *)(void *)0;
    version = evr;
  }
  char *tmp_post$3;
  if(!(se == ((char *)NULL)))
  {
    tmp_post$3 = se;
    se = se + 1l;
    *tmp_post$3 = (char)0;
    release = se;
  }

  else
    release = (const char *)(void *)0;
  if(!(ep == ((const char **)NULL)))
    *ep = epoch;

  if(!(vp == ((const char **)NULL)))
    *vp = version;

  if(!(rp == ((const char **)NULL)))
    *rp = release;

}

// probe_cobj_memcheck
// file ../../../../../src/OVAL/probes/probe/icache.c line 450
static signed int probe_cobj_memcheck(unsigned long int item_cnt)
{
  if(item_cnt >= 32769ul)
  {
    struct proc_memusage mu_proc;
    struct sys_memusage mu_sys;
    double c_ratio;
    signed int return_value_oscap_proc_memusage$1;
    return_value_oscap_proc_memusage$1=oscap_proc_memusage(&mu_proc);
    if(!(return_value_oscap_proc_memusage$1 == 0))
      return -1;

    signed int return_value_oscap_sys_memusage$2;
    return_value_oscap_sys_memusage$2=oscap_sys_memusage(&mu_sys);
    if(!(return_value_oscap_sys_memusage$2 == 0))
      return -1;

    c_ratio = (double)mu_proc.mu_rss / (double)mu_sys.mu_total;
    if(c_ratio > 0.8)
    {
      __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/icache.c", "probe_cobj_memcheck", (unsigned long int)468, "Memory usage ratio limit reached! limit=%f, current=%f", 0.8, c_ratio);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 12;
      return 1;
    }

    if(!(mu_sys.mu_realfree / 1024ul >= 512ul))
    {
      __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/icache.c", "probe_cobj_memcheck", (unsigned long int)475, "Minimum free memory limit reached! limit=%zu, current=%zu", 512, mu_sys.mu_realfree / (unsigned long int)1024);
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 12;
      return 1;
    }

  }

  return 0;
}

// probe_ctx_getobject
// file ../../../../src/OVAL/probes/public/probe-api.h line 497
struct SEXP * probe_ctx_getobject(struct probe_ctx *ctx)
{
  return ctx->probe_in;
}

// probe_ctx_getresult
// file ../../../../src/OVAL/probes/public/probe-api.h line 504
struct SEXP * probe_ctx_getresult(struct probe_ctx *ctx)
{
  return ctx->probe_out;
}

// probe_ent_cmp
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 220
static enum anonymous$18 probe_ent_cmp(struct SEXP *ent, struct SEXP *val2)
{
  enum anonymous$36 op;
  enum anonymous$10 dtype;
  struct SEXP *stmp;
  struct SEXP *val1;
  struct SEXP *vals;
  struct SEXP *res_lst;
  struct SEXP *r0;
  signed int val_cnt;
  signed int is_var;
  enum anonymous$48 ochk;
  enum anonymous$18 ores;
  enum anonymous$18 result;
  ores = (enum anonymous$18)OVAL_RESULT_ERROR;
  result = (enum anonymous$18)OVAL_RESULT_ERROR;
  vals = (struct SEXP *)(void *)0;
  val_cnt=probe_ent_getvals(ent, &vals);
  _Bool return_value_probe_ent_attrexists$1;
  return_value_probe_ent_attrexists$1=probe_ent_attrexists(ent, "var_ref");
  if(!(return_value_probe_ent_attrexists$1 == (_Bool)0))
    is_var = 1;

  else
  {
    if(!(val_cnt == 1))
    {
      SEXP_free(vals);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }

    is_var = 0;
  }
  dtype=probe_ent_getdatatype(ent);
  stmp=probe_ent_getattrval(ent, "operation");
  signed int return_value_SEXP_number_geti_32$2;
  if(stmp == ((struct SEXP *)NULL))
    op = (enum anonymous$36)OVAL_OPERATION_EQUALS;

  else
  {
    return_value_SEXP_number_geti_32$2=SEXP_number_geti_32(stmp);
    op = (enum anonymous$36)return_value_SEXP_number_geti_32$2;
  }
  SEXP_free(stmp);
  res_lst=SEXP_list_new((struct SEXP *)(void *)0);
  unsigned int i254 = (unsigned int)1;
  do
  {
    val1=SEXP_list_nth(vals, i254);
    if(val1 == ((struct SEXP *)NULL))
      break;

    unsigned char return_value_SEXP_typeof$5;
    return_value_SEXP_typeof$5=SEXP_typeof(val1);
    unsigned char return_value_SEXP_typeof$6;
    return_value_SEXP_typeof$6=SEXP_typeof(val2);
    if(!(return_value_SEXP_typeof$5 == return_value_SEXP_typeof$6))
    {
      unsigned char return_value_SEXP_typeof$3;
      return_value_SEXP_typeof$3=SEXP_typeof(val1);
      unsigned char return_value_SEXP_typeof$4;
      return_value_SEXP_typeof$4=SEXP_typeof(val2);
      __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/entcmp.c", "probe_ent_cmp", (unsigned long int)257, "Types of values to compare don't match: val1: %d, val2: %d", return_value_SEXP_typeof$3, return_value_SEXP_typeof$4);
      SEXP_free(vals);
      SEXP_free(val1);
      SEXP_free(res_lst);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }

    ores=probe_ent_cmp_single(val1, dtype, val2, op);
    r0=SEXP_number_newi_32((signed int)ores);
    SEXP_list_add(res_lst, r0);
    SEXP_free(r0);
    i254 = i254 + 1u;
    SEXP_free(val1);
    val1 = (struct SEXP *)(void *)0;
  }
  while((_Bool)1);
  if(!(is_var == 0))
  {
    stmp=probe_ent_getattrval(ent, "var_check");
    if(stmp == ((struct SEXP *)NULL))
      ochk = (enum anonymous$48)OVAL_CHECK_ALL;

    else
    {
      signed int return_value_SEXP_number_geti_32$7;
      return_value_SEXP_number_geti_32$7=SEXP_number_geti_32(stmp);
      ochk = (enum anonymous$48)return_value_SEXP_number_geti_32$7;
      SEXP_free(stmp);
    }
    result=probe_ent_result_bychk(res_lst, ochk);
  }

  else
    result = ores;
  SEXP_free(res_lst);
  SEXP_free(vals);
  return result;
}

// probe_ent_cmp_binary
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 53
enum anonymous$18 probe_ent_cmp_binary(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  char *s1;
  char *s2;
  s1=SEXP_string_cstr(val1);
  s2=SEXP_string_cstr(val2);
  result=oval_binary_cmp(s1, s2, op);
  __oscap_free((void *)s1);
  __oscap_free((void *)s2);
  return result;
}

// probe_ent_cmp_bool
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 69
enum anonymous$18 probe_ent_cmp_bool(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  signed int v1;
  signed int v2;
  v1=SEXP_number_geti_32(val1);
  v2=SEXP_number_geti_32(val2);
  enum anonymous$18 return_value_oval_boolean_cmp$1;
  return_value_oval_boolean_cmp$1=oval_boolean_cmp((const _Bool)v1, (const _Bool)v2, op);
  return return_value_oval_boolean_cmp$1;
}

// probe_ent_cmp_debian_evr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 92
enum anonymous$18 probe_ent_cmp_debian_evr(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/entcmp.c", "probe_ent_cmp_debian_evr", (unsigned long int)96, "Using RPM algorithm to compare epoch, version and release.");
  enum anonymous$18 return_value_probe_ent_cmp_evr$1;
  return_value_probe_ent_cmp_evr$1=probe_ent_cmp_evr(val1, val2, op);
  return return_value_probe_ent_cmp_evr$1;
}

// probe_ent_cmp_evr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 79
enum anonymous$18 probe_ent_cmp_evr(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  char *s1;
  s1=SEXP_string_cstr(val1);
  char *s2;
  s2=SEXP_string_cstr(val2);
  result=oval_evr_string_cmp(s1, s2, op);
  __oscap_free((void *)s1);
  __oscap_free((void *)s2);
  return result;
}

// probe_ent_cmp_filesetrev
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 100
enum anonymous$18 probe_ent_cmp_filesetrev(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  return result;
}

// probe_ent_cmp_float
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 109
enum anonymous$18 probe_ent_cmp_float(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  double v1;
  double v2;
  v1=SEXP_number_getf(val1);
  v2=SEXP_number_getf(val2);
  enum anonymous$18 return_value_oval_float_cmp$1;
  return_value_oval_float_cmp$1=oval_float_cmp(v1, v2, op);
  return return_value_oval_float_cmp$1;
}

// probe_ent_cmp_int
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 119
enum anonymous$18 probe_ent_cmp_int(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  signed long int v1;
  signed long int v2;
  v1=SEXP_number_geti_64(val1);
  v2=SEXP_number_geti_64(val2);
  result=oval_int_cmp(v1, v2, op);
  return result;
}

// probe_ent_cmp_ios
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 132
enum anonymous$18 probe_ent_cmp_ios(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  return result;
}

// probe_ent_cmp_ipaddr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 169
static enum anonymous$18 probe_ent_cmp_ipaddr(signed int af, struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  char *addr1;
  addr1=SEXP_string_cstr(val1);
  char *addr2;
  addr2=SEXP_string_cstr(val2);
  result=oval_ipaddr_cmp(af, addr1, addr2, op);
  __oscap_free((void *)addr1);
  __oscap_free((void *)addr2);
  return result;
}

// probe_ent_cmp_single
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 182
static inline enum anonymous$18 probe_ent_cmp_single(struct SEXP *state_ent, enum anonymous$10 state_data_type, struct SEXP *sysent, enum anonymous$36 op)
{
  enum anonymous$18 return_value_probe_ent_cmp_binary$1;
  enum anonymous$18 return_value_probe_ent_cmp_bool$2;
  enum anonymous$18 return_value_probe_ent_cmp_evr$3;
  enum anonymous$18 return_value_probe_ent_cmp_debian_evr$4;
  enum anonymous$18 return_value_probe_ent_cmp_filesetrev$5;
  enum anonymous$18 return_value_probe_ent_cmp_float$6;
  enum anonymous$18 return_value_probe_ent_cmp_ios$7;
  enum anonymous$18 return_value_probe_ent_cmp_version$8;
  enum anonymous$18 return_value_probe_ent_cmp_int$9;
  enum anonymous$18 return_value_probe_ent_cmp_string$10;
  enum anonymous$18 return_value_probe_ent_cmp_ipaddr$11;
  enum anonymous$18 return_value_probe_ent_cmp_ipaddr$12;
  switch((signed int)state_data_type)
  {
    case OVAL_DATATYPE_BINARY:
    {
      return_value_probe_ent_cmp_binary$1=probe_ent_cmp_binary(state_ent, sysent, op);
      return return_value_probe_ent_cmp_binary$1;
    }
    case OVAL_DATATYPE_BOOLEAN:
    {
      return_value_probe_ent_cmp_bool$2=probe_ent_cmp_bool(state_ent, sysent, op);
      return return_value_probe_ent_cmp_bool$2;
    }
    case OVAL_DATATYPE_EVR_STRING:
    {
      return_value_probe_ent_cmp_evr$3=probe_ent_cmp_evr(state_ent, sysent, op);
      return return_value_probe_ent_cmp_evr$3;
    }
    case OVAL_DATATYPE_DEBIAN_EVR_STRING:
    {
      return_value_probe_ent_cmp_debian_evr$4=probe_ent_cmp_debian_evr(state_ent, sysent, op);
      return return_value_probe_ent_cmp_debian_evr$4;
    }
    case OVAL_DATATYPE_FILESET_REVISION:
    {
      return_value_probe_ent_cmp_filesetrev$5=probe_ent_cmp_filesetrev(state_ent, sysent, op);
      return return_value_probe_ent_cmp_filesetrev$5;
    }
    case OVAL_DATATYPE_FLOAT:
    {
      return_value_probe_ent_cmp_float$6=probe_ent_cmp_float(state_ent, sysent, op);
      return return_value_probe_ent_cmp_float$6;
    }
    case OVAL_DATATYPE_IOS_VERSION:
    {
      return_value_probe_ent_cmp_ios$7=probe_ent_cmp_ios(state_ent, sysent, op);
      return return_value_probe_ent_cmp_ios$7;
    }
    case OVAL_DATATYPE_VERSION:
    {
      return_value_probe_ent_cmp_version$8=probe_ent_cmp_version(state_ent, sysent, op);
      return return_value_probe_ent_cmp_version$8;
    }
    case OVAL_DATATYPE_INTEGER:
    {
      return_value_probe_ent_cmp_int$9=probe_ent_cmp_int(state_ent, sysent, op);
      return return_value_probe_ent_cmp_int$9;
    }
    case OVAL_DATATYPE_STRING:
    {
      return_value_probe_ent_cmp_string$10=probe_ent_cmp_string(state_ent, sysent, op);
      return return_value_probe_ent_cmp_string$10;
    }
    case OVAL_DATATYPE_IPV4ADDR:
    {
      return_value_probe_ent_cmp_ipaddr$11=probe_ent_cmp_ipaddr(2, state_ent, sysent, op);
      return return_value_probe_ent_cmp_ipaddr$11;
    }
    case OVAL_DATATYPE_IPV6ADDR:
    {
      return_value_probe_ent_cmp_ipaddr$12=probe_ent_cmp_ipaddr(10, state_ent, sysent, op);
      return return_value_probe_ent_cmp_ipaddr$12;
    }
    default:
    {
      __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/entcmp.c", "probe_ent_cmp_single", (unsigned long int)213, "Unexpected data type: %d", state_data_type);
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    }
  }
}

// probe_ent_cmp_string
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 153
enum anonymous$18 probe_ent_cmp_string(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  char *s1;
  char *s2;
  s1=SEXP_string_cstr(val1);
  s2=SEXP_string_cstr(val2);
  result=oval_string_cmp(s1, s2, op);
  __oscap_free((void *)s1);
  __oscap_free((void *)s2);
  return result;
}

// probe_ent_cmp_version
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 141
enum anonymous$18 probe_ent_cmp_version(struct SEXP *val1, struct SEXP *val2, enum anonymous$36 op)
{
  const char *state_version;
  state_version=SEXP_string_cstr(val1);
  const char *sys_version;
  sys_version=SEXP_string_cstr(val2);
  enum anonymous$18 result;
  result=oval_versiontype_cmp(state_version, sys_version, op);
  __oscap_free((void *)state_version);
  __oscap_free((void *)sys_version);
  return result;
}

// probe_ent_result_bychk
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 494
enum anonymous$18 probe_ent_result_bychk(struct SEXP *res_lst, enum anonymous$48 check)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;
  struct _oresults ores;
  unsigned long int return_value_SEXP_list_length$1;
  return_value_SEXP_list_length$1=SEXP_list_length(res_lst);
  if(return_value_SEXP_list_length$1 == 0ul)
    return (enum anonymous$18)OVAL_RESULT_UNKNOWN;

  else
  {
    signed int return_value_results_parser$2;
    return_value_results_parser$2=results_parser(res_lst, &ores);
    if(!(return_value_results_parser$2 == 0))
      return (enum anonymous$18)OVAL_RESULT_ERROR;

    else
      if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.notappl_cnt >= 1)
        return (enum anonymous$18)OVAL_RESULT_NOT_APPLICABLE;

      else
      {
        switch((signed int)check)
        {
          case OVAL_CHECK_ALL:
          {
            if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.noteval_cnt == 0 && ores.unknown_cnt == 0 && ores.true_cnt >= 1)
              result = (enum anonymous$18)OVAL_RESULT_TRUE;

            else
              if(ores.false_cnt >= 1)
                result = (enum anonymous$18)OVAL_RESULT_FALSE;

              else
                if(ores.false_cnt == 0 && ores.error_cnt >= 1)
                  result = (enum anonymous$18)OVAL_RESULT_ERROR;

                else
                  if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.unknown_cnt >= 1)
                    result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                  else
                    if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.unknown_cnt == 0 && ores.noteval_cnt >= 1)
                      result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

            break;
          }
          case OVAL_CHECK_AT_LEAST_ONE:
          {
            if(ores.true_cnt >= 1)
              result = (enum anonymous$18)OVAL_RESULT_TRUE;

            else
              if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.false_cnt >= 1)
                result = (enum anonymous$18)OVAL_RESULT_FALSE;

              else
                if(ores.true_cnt == 0 && ores.error_cnt >= 1)
                  result = (enum anonymous$18)OVAL_RESULT_ERROR;

                else
                  if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.unknown_cnt >= 1)
                    result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                  else
                    if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.unknown_cnt == 0 && ores.noteval_cnt >= 1)
                      result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

            break;
          }
          case OVAL_CHECK_NONE_EXIST:
            __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/entcmp.c", "probe_ent_result_bychk", (unsigned long int)543, "The 'none exist' CheckEnumeration value has been deprecated. Converted to check='none satisfy'.");
          case OVAL_CHECK_NONE_SATISFY:
          {
            if(ores.true_cnt >= 1)
              result = (enum anonymous$18)OVAL_RESULT_FALSE;

            else
              if(ores.true_cnt == 0 && ores.error_cnt >= 1)
                result = (enum anonymous$18)OVAL_RESULT_ERROR;

              else
                if(ores.error_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt >= 1)
                  result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                else
                  if(ores.error_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.noteval_cnt >= 1)
                    result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

                  else
                    if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.false_cnt >= 1)
                      result = (enum anonymous$18)OVAL_RESULT_TRUE;

            break;
          }
          case OVAL_CHECK_ONLY_ONE:
            if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 1 && ores.unknown_cnt == 0)
              result = (enum anonymous$18)OVAL_RESULT_TRUE;

            else
              if(ores.true_cnt >= 2)
                result = (enum anonymous$18)OVAL_RESULT_FALSE;

              else
                if(ores.error_cnt >= 1 && !(ores.true_cnt >= 2))
                  result = (enum anonymous$18)OVAL_RESULT_ERROR;

                else
                  if(ores.error_cnt == 0 && ores.unknown_cnt >= 1 && !(ores.true_cnt >= 2))
                    result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                  else
                    if(ores.error_cnt == 0 && ores.unknown_cnt == 0 && ores.noteval_cnt >= 1 && !(ores.true_cnt >= 2))
                      result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

                    else
                      if(ores.false_cnt >= 1 && !(ores.true_cnt == 1))
                        result = (enum anonymous$18)OVAL_RESULT_FALSE;

        }
        return result;
      }
  }
}

// probe_ent_result_byopr
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 583
enum anonymous$18 probe_ent_result_byopr(struct SEXP *res_lst, enum anonymous$49 operator)
{
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;
  struct _oresults ores;
  unsigned long int return_value_SEXP_list_length$1;
  return_value_SEXP_list_length$1=SEXP_list_length(res_lst);
  if(return_value_SEXP_list_length$1 == 0ul)
    return (enum anonymous$18)OVAL_RESULT_UNKNOWN;

  else
  {
    signed int return_value_results_parser$2;
    return_value_results_parser$2=results_parser(res_lst, &ores);
    if(!(return_value_results_parser$2 == 0))
      return (enum anonymous$18)OVAL_RESULT_ERROR;

    else
      if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.notappl_cnt >= 1)
        return (enum anonymous$18)OVAL_RESULT_NOT_APPLICABLE;

      else
      {
        switch((signed int)operator)
        {
          case OVAL_OPERATOR_AND:
          {
            if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.noteval_cnt == 0 && ores.unknown_cnt == 0 && ores.true_cnt >= 1)
              result = (enum anonymous$18)OVAL_RESULT_TRUE;

            else
              if(ores.false_cnt >= 1)
                result = (enum anonymous$18)OVAL_RESULT_FALSE;

              else
                if(ores.false_cnt == 0 && ores.error_cnt >= 1)
                  result = (enum anonymous$18)OVAL_RESULT_ERROR;

                else
                  if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.unknown_cnt >= 1)
                    result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                  else
                    if(ores.error_cnt == 0 && ores.false_cnt == 0 && ores.unknown_cnt == 0 && ores.noteval_cnt >= 1)
                      result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

            break;
          }
          case OVAL_OPERATOR_ONE:
          {
            if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 1 && ores.unknown_cnt == 0 && ores.false_cnt >= 0 && ores.notappl_cnt >= 0)
              result = (enum anonymous$18)OVAL_RESULT_TRUE;

            else
              if(ores.error_cnt >= 0 && ores.false_cnt >= 0 && ores.notappl_cnt >= 0 && ores.noteval_cnt >= 0 && ores.true_cnt >= 2 && ores.unknown_cnt >= 0)
                result = (enum anonymous$18)OVAL_RESULT_FALSE;

              else
                if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.false_cnt >= 0 && ores.notappl_cnt >= 0)
                  result = (enum anonymous$18)OVAL_RESULT_FALSE;

                else
                  if(ores.error_cnt >= 1 && ores.false_cnt >= 0 && ores.notappl_cnt >= 0 && ores.noteval_cnt >= 0 && ores.unknown_cnt >= 0 && !(ores.true_cnt >= 2))
                    result = (enum anonymous$18)OVAL_RESULT_ERROR;

                  else
                    if(ores.error_cnt == 0 && ores.false_cnt >= 0 && ores.notappl_cnt >= 0 && ores.noteval_cnt >= 0 && ores.unknown_cnt >= 1 && !(ores.true_cnt >= 2))
                      result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                    else
                      if(ores.error_cnt == 0 && ores.unknown_cnt == 0 && ores.false_cnt >= 0 && ores.notappl_cnt >= 0 && ores.noteval_cnt >= 1 && !(ores.true_cnt >= 2))
                        result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

            break;
          }
          case OVAL_OPERATOR_OR:
          {
            if(ores.true_cnt >= 1)
              result = (enum anonymous$18)OVAL_RESULT_TRUE;

            else
              if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.false_cnt >= 1)
                result = (enum anonymous$18)OVAL_RESULT_FALSE;

              else
                if(ores.true_cnt == 0 && ores.error_cnt >= 1)
                  result = (enum anonymous$18)OVAL_RESULT_ERROR;

                else
                  if(ores.error_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt >= 1)
                    result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                  else
                    if(ores.error_cnt == 0 && ores.true_cnt == 0 && ores.unknown_cnt == 0 && ores.noteval_cnt >= 1)
                      result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

            break;
          }
          case OVAL_OPERATOR_XOR:
            if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.unknown_cnt == 0 && ores.true_cnt % 2 == 1)
              result = (enum anonymous$18)OVAL_RESULT_TRUE;

            else
              if(ores.error_cnt == 0 && ores.noteval_cnt == 0 && ores.unknown_cnt == 0 && ores.true_cnt % 2 == 0)
                result = (enum anonymous$18)OVAL_RESULT_FALSE;

              else
                if(ores.error_cnt >= 1)
                  result = (enum anonymous$18)OVAL_RESULT_ERROR;

                else
                  if(ores.error_cnt == 0 && ores.unknown_cnt >= 1)
                    result = (enum anonymous$18)OVAL_RESULT_UNKNOWN;

                  else
                    if(ores.error_cnt == 0 && ores.unknown_cnt == 0 && ores.noteval_cnt >= 1)
                      result = (enum anonymous$18)OVAL_RESULT_NOT_EVALUATED;

        }
        return result;
      }
  }
}

// probe_entobj_cmp
// file ../../../../src/OVAL/probes/probe/entcmp.h line 61
enum anonymous$18 probe_entobj_cmp(struct SEXP *ent_obj, struct SEXP *val)
{
  enum anonymous$18 ores;
  struct SEXP *r0 = (struct SEXP *)(void *)0;
  signed int valcnt;
  valcnt=probe_ent_getvals(ent_obj, &r0);
  SEXP_free(r0);
  if(valcnt == 0)
  {
    __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/entcmp.c", "probe_entobj_cmp", (unsigned long int)440, "valcnt == 0.");
    return (enum anonymous$18)OVAL_RESULT_FALSE;
  }

  else
  {
    ores=probe_ent_cmp(ent_obj, val);
    if((signed int)ores == OVAL_RESULT_NOT_EVALUATED)
      return (enum anonymous$18)OVAL_RESULT_FALSE;

    else
      return ores;
  }
}

// probe_entste_cmp
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 391
enum anonymous$18 probe_entste_cmp(struct SEXP *ent_ste, struct SEXP *ent_itm)
{
  enum anonymous$10 ste_dt;
  enum anonymous$33 item_status;
  enum anonymous$18 ores;
  struct SEXP *val2;
  signed int valcnt;
  item_status=probe_ent_getstatus(ent_itm);
  enum anonymous$10 return_value_probe_ent_getdatatype$1;
  enum anonymous$18 return_value__probe_entste_cmp_record$2;
  switch((signed int)item_status)
  {
    case SYSCHAR_STATUS_DOES_NOT_EXIST:
      return (enum anonymous$18)OVAL_RESULT_FALSE;
    case SYSCHAR_STATUS_ERROR:

    case SYSCHAR_STATUS_NOT_COLLECTED:
      return (enum anonymous$18)OVAL_RESULT_ERROR;
    default:
    {
      ste_dt=probe_ent_getdatatype(ent_ste);
      return_value_probe_ent_getdatatype$1=probe_ent_getdatatype(ent_itm);
      if(!(ste_dt == return_value_probe_ent_getdatatype$1))
        return (enum anonymous$18)OVAL_RESULT_ERROR;

      if((signed int)ste_dt == OVAL_DATATYPE_RECORD)
      {
        return_value__probe_entste_cmp_record$2=_probe_entste_cmp_record(ent_ste, ent_itm);
        return return_value__probe_entste_cmp_record$2;
      }

      valcnt=probe_ent_getvals(ent_ste, (struct SEXP **)(void *)0);
      if(valcnt == 0)
        return (enum anonymous$18)OVAL_RESULT_ERROR;

      val2=probe_ent_getval(ent_itm);
      ores=probe_ent_cmp(ent_ste, val2);
      SEXP_free(val2);
      if((signed int)ores == OVAL_RESULT_NOT_EVALUATED)
        return (enum anonymous$18)OVAL_RESULT_ERROR;

      return ores;
    }
  }
}

// probe_fini
// file ../../../../../src/OVAL/probes/probe/fini.c line 38
void probe_fini(void *arg)
{
  (void)arg;
}

// probe_getoption
// file ../../../../../src/OVAL/probes/probe/option.c line 36
signed int probe_getoption(signed int option, ...)
{
  signed int ret;
  void **ap = (void **)&option;
  ret=__probe_option_op(option, 1, ap);
  ap = ((void **)NULL);
  return ret;
}

// probe_icache_add
// file ../../../../../src/OVAL/probes/probe/icache.c line 349
signed int probe_icache_add(struct anonymous$15 *cache, struct SEXP *cobj, struct SEXP *item)
{
  signed int ret;
  if(cache == ((struct anonymous$15 *)NULL) || cobj == ((struct SEXP *)NULL) || item == ((struct SEXP *)NULL))
    return -1;

  else
  {
    signed int return_value_pthread_mutex_lock$4;
    return_value_pthread_mutex_lock$4=pthread_mutex_lock(&cache->queue_mutex);
    if(!(return_value_pthread_mutex_lock$4 == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_add", (unsigned long int)358, "An error ocured while locking the queue mutex: %u, %s", *return_value___errno_location$1, return_value_strerror$3);
      return -1;
    }

    ret=__probe_icache_add_nolock(cache, cobj, item, (union anonymous$7 *)(void *)0);
    signed int return_value_pthread_mutex_unlock$8;
    return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&cache->queue_mutex);
    if(!(return_value_pthread_mutex_unlock$8 == 0))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_add", (unsigned long int)366, "An error ocured while unlocking the queue mutex: %u, %s", *return_value___errno_location$5, return_value_strerror$7);
      abort();
    }

    if(!(ret == 0))
      return -1;

    else
    {
      signed int return_value_pthread_cond_signal$12;
      return_value_pthread_cond_signal$12=pthread_cond_signal(&cache->queue_notempty);
      if(!(return_value_pthread_cond_signal$12 == 0))
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        char *return_value_strerror$11;
        return_value_strerror$11=strerror(*return_value___errno_location$10);
        __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_add", (unsigned long int)375, "An error ocured while signaling the `notempty' condition: %u, %s", *return_value___errno_location$9, return_value_strerror$11);
        return -1;
      }

      return 0;
    }
  }
}

// probe_icache_free
// file ../../../../../src/OVAL/probes/probe/icache.h line 64
void probe_icache_free(struct anonymous$15 *cache)
{
  void *ret = (void *)0;
  pthread_cancel(cache->thid);
  pthread_join(cache->thid, &ret);
  pthread_mutex_destroy(&cache->queue_mutex);
  pthread_cond_destroy(&cache->queue_notempty);
  pthread_cond_destroy(&cache->queue_notfull);
  rbt_i64_free_cb(cache->tree, probe_icache_free_node);
  __oscap_free((void *)cache);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// probe_icache_free_node
// file ../../../../../src/OVAL/probes/probe/icache.c line 554
static void probe_icache_free_node(struct rbt_i64_node *n)
{
  struct anonymous$51 *ci = (struct anonymous$51 *)n->data;
  for( ; (signed int)ci->count >= 1; ci->count = ci->count - 1)
    SEXP_free(ci->item[(signed long int)((signed int)ci->count - 1)]);
  __oscap_free((void *)ci->item);
  __oscap_free((void *)ci);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// probe_icache_item_setID
// file ../../../../../src/OVAL/probes/probe/icache.c line 49
static void probe_icache_item_setID(struct SEXP *item, unsigned long int item_ID)
{
  struct SEXP *name_ref;
  struct SEXP *prev_id;
  struct SEXP uniq_id;
  unsigned int local_id;
  while((_Bool)0)
    ;
  while((_Bool)0)
    ;
  signed int return_value_pthread_mutex_lock$4;
  return_value_pthread_mutex_lock$4=pthread_mutex_lock(&next_ID_mutex);
  if(!(return_value_pthread_mutex_lock$4 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_item_setID", (unsigned long int)64, "Can't lock the next_ID_mutex: %u, %s", *return_value___errno_location$1, return_value_strerror$3);
    abort();
  }

  next_ID = next_ID + 1u;
  local_id = next_ID;
  signed int return_value_pthread_mutex_unlock$8;
  return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&next_ID_mutex);
  if(!(return_value_pthread_mutex_unlock$8 == 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_item_setID", (unsigned long int)71, "Can't unlock the next_ID_mutex: %u, %s", *return_value___errno_location$5, return_value_strerror$7);
    abort();
  }

  signed int return_value_getpid$9;
  return_value_getpid$9=getpid();
  SEXP_string_newf_r(&uniq_id, "1%05u%u", return_value_getpid$9, local_id);
  name_ref=SEXP_listref_first(item);
  prev_id=SEXP_list_replace(name_ref, (unsigned int)3, &uniq_id);
  SEXP_free(prev_id);
  SEXP_free_r(&uniq_id);
  SEXP_free(name_ref);
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// probe_icache_new
// file ../../../../../src/OVAL/probes/probe/icache.h line 61
struct anonymous$15 * probe_icache_new(void)
{
  struct anonymous$15 *cache;
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc(sizeof(struct anonymous$15) /*16544ul*/ );
  cache = (struct anonymous$15 *)return_value___oscap_alloc$1;
  cache->tree=rbt_i64_new();
  signed int return_value_pthread_mutex_init$5;
  return_value_pthread_mutex_init$5=pthread_mutex_init(&cache->queue_mutex, (const union anonymous$0 *)(void *)0);
  if(!(return_value_pthread_mutex_init$5 == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_new", (unsigned long int)273, "Can't initialize icache mutex: %u, %s", *return_value___errno_location$2, return_value_strerror$4);
    goto fail;
  }

  cache->queue_beg = (unsigned short int)0;
  cache->queue_end = (unsigned short int)0;
  cache->queue_cnt = (unsigned short int)0;
  cache->queue_max = (unsigned short int)1024;
  signed int return_value_pthread_cond_init$9;
  return_value_pthread_cond_init$9=pthread_cond_init(&cache->queue_notempty, (const union anonymous$0 *)(void *)0);
  if(!(return_value_pthread_cond_init$9 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_new", (unsigned long int)284, "Can't initialize icache queue condition variable (notempty): %u, %s", *return_value___errno_location$6, return_value_strerror$8);
    goto fail;
  }

  signed int return_value_pthread_cond_init$13;
  return_value_pthread_cond_init$13=pthread_cond_init(&cache->queue_notfull, (const union anonymous$0 *)(void *)0);
  if(!(return_value_pthread_cond_init$13 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    signed int *return_value___errno_location$11;
    return_value___errno_location$11=__errno_location();
    char *return_value_strerror$12;
    return_value_strerror$12=strerror(*return_value___errno_location$11);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_new", (unsigned long int)290, "Can't initialize icache queue condition variable (notfull): %u, %s", *return_value___errno_location$10, return_value_strerror$12);
    goto fail;
  }

  signed int return_value_pthread_create$17;
  return_value_pthread_create$17=pthread_create(&cache->thid, (const union pthread_attr_t *)(void *)0, probe_icache_worker, (void *)cache);
  if(!(return_value_pthread_create$17 == 0))
  {
    signed int *return_value___errno_location$14;
    return_value___errno_location$14=__errno_location();
    signed int *return_value___errno_location$15;
    return_value___errno_location$15=__errno_location();
    char *return_value_strerror$16;
    return_value_strerror$16=strerror(*return_value___errno_location$15);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_new", (unsigned long int)297, "Can't start the icache worker: %u, %s", *return_value___errno_location$14, return_value_strerror$16);
    goto fail;
  }

  return cache;

fail:
  ;
  if(!(cache->tree == ((struct rbt *)NULL)))
    rbt_i64_free(cache->tree);

  pthread_mutex_destroy(&cache->queue_mutex);
  pthread_cond_destroy(&cache->queue_notempty);
  __oscap_free((void *)cache);
  return (struct anonymous$15 *)(void *)0;
}

// probe_icache_nop
// file ../../../../../src/OVAL/probes/probe/icache.h line 63
signed int probe_icache_nop(struct anonymous$15 *cache)
{
  union anonymous$7 cond;
  __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)386, "NOP");
  signed int return_value_pthread_mutex_lock$4;
  return_value_pthread_mutex_lock$4=pthread_mutex_lock(&cache->queue_mutex);
  if(!(return_value_pthread_mutex_lock$4 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)390, "An error ocured while locking the queue mutex: %u, %s", *return_value___errno_location$1, return_value_strerror$3);
    return -1;
  }

  signed int return_value_pthread_cond_init$8;
  return_value_pthread_cond_init$8=pthread_cond_init(&cond, (const union anonymous$0 *)(void *)0);
  if(!(return_value_pthread_cond_init$8 == 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)396, "Can't initialize icache queue condition variable (NOP): %u, %s", *return_value___errno_location$5, return_value_strerror$7);
    return -1;
  }

  signed int return_value___probe_icache_add_nolock$13;
  return_value___probe_icache_add_nolock$13=__probe_icache_add_nolock(cache, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0, &cond);
  if(!(return_value___probe_icache_add_nolock$13 == 0))
  {
    signed int return_value_pthread_mutex_unlock$12;
    return_value_pthread_mutex_unlock$12=pthread_mutex_unlock(&cache->queue_mutex);
    if(!(return_value_pthread_mutex_unlock$12 == 0))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      char *return_value_strerror$11;
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)403, "An error ocured while unlocking the queue mutex: %u, %s", *return_value___errno_location$9, return_value_strerror$11);
      abort();
    }

    pthread_cond_destroy(&cond);
    return -1;
  }

  __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)411, "Signaling `notempty'");
  signed int return_value_pthread_cond_signal$17;
  return_value_pthread_cond_signal$17=pthread_cond_signal(&cache->queue_notempty);
  if(!(return_value_pthread_cond_signal$17 == 0))
  {
    signed int *return_value___errno_location$14;
    return_value___errno_location$14=__errno_location();
    signed int *return_value___errno_location$15;
    return_value___errno_location$15=__errno_location();
    char *return_value_strerror$16;
    return_value_strerror$16=strerror(*return_value___errno_location$15);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)415, "An error ocured while signaling the `notempty' condition: %u, %s", *return_value___errno_location$14, return_value_strerror$16);
    pthread_cond_destroy(&cond);
    return -1;
  }

  __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)421, "Waiting for icache worker to handle the NOP");
  signed int return_value_pthread_cond_wait$21;
  return_value_pthread_cond_wait$21=pthread_cond_wait(&cond, &cache->queue_mutex);
  if(!(return_value_pthread_cond_wait$21 == 0))
  {
    signed int *return_value___errno_location$18;
    return_value___errno_location$18=__errno_location();
    signed int *return_value___errno_location$19;
    return_value___errno_location$19=__errno_location();
    char *return_value_strerror$20;
    return_value_strerror$20=strerror(*return_value___errno_location$19);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)425, "An error ocured while waiting for the `NOP' queue condition: %u, %s", *return_value___errno_location$18, return_value_strerror$20);
    return -1;
  }

  __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)429, "Sync");
  signed int return_value_pthread_mutex_unlock$25;
  return_value_pthread_mutex_unlock$25=pthread_mutex_unlock(&cache->queue_mutex);
  if(!(return_value_pthread_mutex_unlock$25 == 0))
  {
    signed int *return_value___errno_location$22;
    return_value___errno_location$22=__errno_location();
    signed int *return_value___errno_location$23;
    return_value___errno_location$23=__errno_location();
    char *return_value_strerror$24;
    return_value_strerror$24=strerror(*return_value___errno_location$23);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_nop", (unsigned long int)433, "An error ocured while unlocking the queue mutex: %u, %s", *return_value___errno_location$22, return_value_strerror$24);
    abort();
  }

  pthread_cond_destroy(&cond);
  return 0;
}

// probe_icache_worker
// file ../../../../../src/OVAL/probes/probe/icache.c line 87
static void * probe_icache_worker(void *arg)
{
  struct anonymous$15 *cache = (struct anonymous$15 *)arg;
  struct anonymous$14 *pair;
  struct anonymous$14 pair_mem;
  unsigned long int item_ID;
  while((_Bool)0)
    ;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_setname_np(return_value_pthread_self$1, "icache_worker");
  signed int return_value_pthread_mutex_lock$5;
  return_value_pthread_mutex_lock$5=pthread_mutex_lock(&cache->queue_mutex);
  if(!(return_value_pthread_mutex_lock$5 == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)99, "An error ocured while locking the queue mutex: %u, %s", *return_value___errno_location$2, return_value_strerror$4);
    return (void *)0;
  }

  pair = &pair_mem;
  __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)104, "icache worker ready");
  signed int *return_value___errno_location$6;
  return_value___errno_location$6=__errno_location();
  *return_value___errno_location$6=pthread_barrier_wait(&___G_th_barrier);
  if(*return_value___errno_location$6 == 0 || *return_value___errno_location$6 == -1)
    goto __CPROVER_DUMP_L6;

  signed int *return_value___errno_location$7;
  return_value___errno_location$7=__errno_location();
  signed int *return_value___errno_location$8;
  return_value___errno_location$8=__errno_location();
  char *return_value_strerror$9;
  return_value_strerror$9=strerror(*return_value___errno_location$8);
  __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)113, "pthread_barrier_wait: %d, %s.", *return_value___errno_location$7, return_value_strerror$9);
  pthread_mutex_unlock(&cache->queue_mutex);
  return (void *)0;
  signed int return_value_pthread_cond_wait$10;
  signed int return_value_pthread_mutex_unlock$14;
  signed int return_value_pthread_cond_signal$18;
  signed int return_value_pthread_mutex_lock$35;
  do
  {

  __CPROVER_DUMP_L6:
    ;
    return_value_pthread_cond_wait$10=pthread_cond_wait(&cache->queue_notempty, &cache->queue_mutex);
    if(!(return_value_pthread_cond_wait$10 == 0))
      break;

    while((_Bool)0)
      ;
    do
    {

    next:
      ;
      __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)121, "Extracting item from the cache queue: cnt=%u, beg=%u", cache->queue_cnt, cache->queue_beg);
      pair_mem = cache->queue[(signed long int)cache->queue_beg];
      cache->queue_cnt = cache->queue_cnt - 1;
      cache->queue_beg = cache->queue_beg + 1;
      if(cache->queue_beg == cache->queue_max)
        cache->queue_beg = (unsigned short int)0;

      while((_Bool)0)
        ;
      return_value_pthread_mutex_unlock$14=pthread_mutex_unlock(&cache->queue_mutex);
      if(!(return_value_pthread_mutex_unlock$14 == 0))
      {
        signed int *return_value___errno_location$11;
        return_value___errno_location$11=__errno_location();
        signed int *return_value___errno_location$12;
        return_value___errno_location$12=__errno_location();
        char *return_value_strerror$13;
        return_value_strerror$13=strerror(*return_value___errno_location$12);
        __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)144, "An error ocured while unlocking the queue mutex: %u, %s", *return_value___errno_location$11, return_value_strerror$13);
        abort();
      }

      __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)148, "Signaling `notfull'");
      return_value_pthread_cond_signal$18=pthread_cond_signal(&cache->queue_notfull);
      if(!(return_value_pthread_cond_signal$18 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        signed int *return_value___errno_location$16;
        return_value___errno_location$16=__errno_location();
        char *return_value_strerror$17;
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)152, "An error ocured while signaling the `notfull' condition: %u, %s", *return_value___errno_location$15, return_value_strerror$17);
        abort();
      }

      if(pair->cobj == ((struct SEXP *)NULL))
      {
        while((_Bool)0)
          ;
        __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)162, "Handling NOP");
        signed int return_value_pthread_cond_signal$22;
        return_value_pthread_cond_signal$22=pthread_cond_signal(pair->p.cond);
        if(!(return_value_pthread_cond_signal$22 == 0))
        {
          signed int *return_value___errno_location$19;
          return_value___errno_location$19=__errno_location();
          signed int *return_value___errno_location$20;
          return_value___errno_location$20=__errno_location();
          char *return_value_strerror$21;
          return_value_strerror$21=strerror(*return_value___errno_location$20);
          __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)166, "An error ocured while signaling NOP condition: %u, %s", *return_value___errno_location$19, return_value_strerror$21);
          abort();
        }

      }

      else
      {
        struct anonymous$51 *cached = (struct anonymous$51 *)(void *)0;
        __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)172, "Handling cache request");
        item_ID=SEXP_ID_v(pair->p.item);
        __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)178, "item ID=%lu", item_ID);
        signed int return_value_rbt_i64_get$30;
        return_value_rbt_i64_get$30=rbt_i64_get(cache->tree, (signed long int)item_ID, (void **)(void *)&cached);
        if(return_value_rbt_i64_get$30 == 0)
        {
          unsigned short int i;
          struct SEXP rest1;
          struct SEXP rest2;
          __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)189, "cache HIT #1");
          i = (unsigned short int)0;
          for( ; !((signed int)i >= (signed int)cached->count); i = i + 1)
          {
            struct SEXP *return_value_SEXP_list_rest_r$23;
            return_value_SEXP_list_rest_r$23=SEXP_list_rest_r(&rest1, pair->p.item);
            struct SEXP *return_value_SEXP_list_rest_r$24;
            return_value_SEXP_list_rest_r$24=SEXP_list_rest_r(&rest2, cached->item[(signed long int)i]);
            _Bool return_value_SEXP_deepcmp$25;
            return_value_SEXP_deepcmp$25=SEXP_deepcmp(return_value_SEXP_list_rest_r$23, return_value_SEXP_list_rest_r$24);
            if(!(return_value_SEXP_deepcmp$25 == (_Bool)0))
            {
              SEXP_free_r(&rest1);
              SEXP_free_r(&rest2);
              break;
            }

            SEXP_free_r(&rest1);
            SEXP_free_r(&rest2);
          }
          if(i == cached->count)
          {
            __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)208, "cache MISS");
            cached->count = cached->count + 1;
            void *return_value___oscap_realloc$26;
            return_value___oscap_realloc$26=__oscap_realloc((void *)cached->item, sizeof(struct SEXP *) /*8ul*/  * (unsigned long int)cached->count);
            cached->item = (struct SEXP **)return_value___oscap_realloc$26;
            cached->item[(signed long int)((signed int)cached->count - 1)] = pair->p.item;
            probe_icache_item_setID(pair->p.item, item_ID);
          }

          else
          {
            __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)219, "cache HIT #2 -> real HIT");
            SEXP_free(pair->p.item);
            pair->p.item = cached->item[(signed long int)i];
          }
        }

        else
        {
          __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)227, "cache MISS");
          void *return_value___oscap_alloc$27;
          return_value___oscap_alloc$27=__oscap_alloc(sizeof(struct anonymous$51) /*16ul*/ );
          cached = (struct anonymous$51 *)return_value___oscap_alloc$27;
          void *return_value___oscap_alloc$28;
          return_value___oscap_alloc$28=__oscap_alloc(sizeof(struct SEXP *) /*8ul*/ );
          cached->item = (struct SEXP **)return_value___oscap_alloc$28;
          cached->item[(signed long int)0] = pair->p.item;
          cached->count = (unsigned short int)1;
          probe_icache_item_setID(pair->p.item, item_ID);
          signed int return_value_rbt_i64_add$29;
          return_value_rbt_i64_add$29=rbt_i64_add(cache->tree, (signed long int)item_ID, (void *)cached, (void **)(void *)0);
          if(!(return_value_rbt_i64_add$29 == 0))
          {
            __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)237, "Can't add item (k=%li to the cache (%p)", (signed long int)item_ID, cache->tree);
            __oscap_free((void *)cached->item);
            __oscap_free((void *)cached);
            abort();
          }

        }
        signed int return_value_probe_cobj_add_item$31;
        return_value_probe_cobj_add_item$31=probe_cobj_add_item(pair->cobj, pair->p.item);
        if(!(return_value_probe_cobj_add_item$31 == 0))
          __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)248, "An error ocured while adding the item to the collected object");

      }
      return_value_pthread_mutex_lock$35=pthread_mutex_lock(&cache->queue_mutex);
      if(!(return_value_pthread_mutex_lock$35 == 0))
      {
        signed int *return_value___errno_location$32;
        return_value___errno_location$32=__errno_location();
        signed int *return_value___errno_location$33;
        return_value___errno_location$33=__errno_location();
        char *return_value_strerror$34;
        return_value_strerror$34=strerror(*return_value___errno_location$33);
        __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_icache_worker", (unsigned long int)254, "An error ocured while re-locking the queue mutex: %u, %s", *return_value___errno_location$32, return_value_strerror$34);
        abort();
      }

    }
    while((signed int)cache->queue_cnt >= 1);
  }
  while((_Bool)1);
  return (void *)0;
}

// probe_init
// file ../../../../src/OVAL/probes/unix/runlevel.c line 360
void * probe_init(void)
{
  probe_setoption(2, PROBE_OFFLINE_CHROOT);
  return (void *)0;
}

// probe_input_handler
// file ../../../../../src/OVAL/probes/probe/input_handler.h line 25
void * probe_input_handler(void *arg)
{
  union pthread_attr_t pth_attr;
  struct anonymous$23 *probe = (struct anonymous$23 *)arg;
  signed int probe_ret;
  signed int cstate;
  struct SEAP_msg *seap_request;
  struct SEAP_msg *seap_reply;
  struct SEXP *probe_in;
  struct SEXP *probe_out;
  struct SEXP *oid;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_setname_np(return_value_pthread_self$1, "input_handler");
  pthread_setcancelstate(1, &cstate);
  signed int return_value_pthread_attr_init$2;
  return_value_pthread_attr_init$2=pthread_attr_init(&pth_attr);
  if(!(return_value_pthread_attr_init$2 == 0))
    return (void *)0;

  else
  {
    signed int return_value_pthread_attr_setdetachstate$3;
    return_value_pthread_attr_setdetachstate$3=pthread_attr_setdetachstate(&pth_attr, 0);
    if(!(return_value_pthread_attr_setdetachstate$3 == 0))
    {
      pthread_attr_destroy(&pth_attr);
      return (void *)0;
    }

    else
    {
      do
      {
        struct anonymous$30 __cancel_buf;
        void (*__cancel_routine)(void *) = (void (*)(void *))pthread_attr_destroy;
        void *__cancel_arg = (void *)&pth_attr;
        signed int __not_first_call;
        __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)__not_first_call == 0l))
        {
          __cancel_routine(__cancel_arg);
          __pthread_unwind_next(&__cancel_buf);
        }

        __pthread_register_cancel(&__cancel_buf);
        do
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          *return_value___errno_location$4=pthread_barrier_wait(&___G_th_barrier);
          if(*return_value___errno_location$4 == 0 || *return_value___errno_location$4 == -1)
            goto __CPROVER_DUMP_L7;

          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)79, "pthread_barrier_wait: %d, %s.", *return_value___errno_location$5, return_value_strerror$7);
          return (void *)0;

        __CPROVER_DUMP_L7:
          ;
          while((_Bool)1)
          {
            pthread_setcancelstate(0, &cstate);
            signed int return_value_SEAP_recvmsg$11;
            return_value_SEAP_recvmsg$11=SEAP_recvmsg(probe->SEAP_ctx, probe->sd, &seap_request);
            if(return_value_SEAP_recvmsg$11 == -1)
            {
              signed int *return_value___errno_location$8;
              return_value___errno_location$8=__errno_location();
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              char *return_value_strerror$10;
              return_value_strerror$10=strerror(*return_value___errno_location$9);
              __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)87, "An error ocured while receiving SEAP message. errno=%u, %s.", *return_value___errno_location$8, return_value_strerror$10);
              break;
            }

            pthread_setcancelstate(1, &cstate);
            probe_in=SEAP_msg_get(seap_request);
            if(probe_in == ((struct SEXP *)NULL))
              abort();

            oid=probe_obj_getattrval(probe_in, "id");
            if(!(oid == ((struct SEXP *)NULL)))
            {
              __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)114, "offline_mode=%08x", ___G_offline_mode);
              __oscap_dlprintf(DBG_D, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)115, "offline_mode_supported=%08x", ___G_offline_mode_supported);
              if(((signed int)___G_offline_mode & (signed int)___G_offline_mode_supported) == 0 && !((signed int)___G_offline_mode == PROBE_OFFLINE_NONE))
              {
                __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)119, "Requested offline mode is not supported by %s.", probe->name);
                probe_out=probe_cobj_new((enum anonymous$8)___G_offline_mode_cobjflag, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0);
                probe_ret = 0;
                SEXP_free(oid);
                SEXP_free(probe_in);
                oid = (struct SEXP *)(void *)0;
                probe_in = (struct SEXP *)(void *)0;
              }

              else
              {
                probe_out=probe_rcache_sexp_get(probe->rcache, oid);
                if(probe_out == ((struct SEXP *)NULL))
                {
                  struct SEXP *skip_flag;
                  struct SEXP *obj_mask;
                  skip_flag=probe_obj_getattrval(probe_in, "skip_eval");
                  obj_mask=probe_obj_getmask(probe_in);
                  SEXP_free(probe_in);
                  probe_in = (struct SEXP *)(void *)0;
                  if(!(skip_flag == ((struct SEXP *)NULL)))
                  {
                    enum anonymous$8 cobj_flag;
                    signed int return_value_SEXP_number_geti_32$12;
                    return_value_SEXP_number_geti_32$12=SEXP_number_geti_32(skip_flag);
                    cobj_flag = (enum anonymous$8)return_value_SEXP_number_geti_32$12;
                    probe_out=probe_cobj_new(cobj_flag, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0, obj_mask);
                    signed int return_value_probe_rcache_sexp_add$13;
                    return_value_probe_rcache_sexp_add$13=probe_rcache_sexp_add(probe->rcache, oid, probe_out);
                    if(!(return_value_probe_rcache_sexp_add$13 == 0))
                      abort();

                    probe_ret = 0;
                    SEXP_free(oid);
                    SEXP_free(skip_flag);
                    SEXP_free(obj_mask);
                  }

                  else
                  {
                    struct anonymous$32 *pair;
                    SEXP_free(oid);
                    SEXP_free(skip_flag);
                    SEXP_free(obj_mask);
                    void *return_value___oscap_alloc$14;
                    return_value___oscap_alloc$14=__oscap_alloc(sizeof(struct anonymous$32) /*16ul*/ );
                    pair = (struct anonymous$32 *)return_value___oscap_alloc$14;
                    pair->probe = probe;
                    pair->pth=probe_worker_new();
                    pair->pth->sid=SEAP_msg_id(seap_request);
                    pair->pth->msg = seap_request;
                    pair->pth->msg_handler = probe_worker;
                    signed int return_value_rbt_i32_add$20;
                    return_value_rbt_i32_add$20=rbt_i32_add(probe->workers, (signed int)pair->pth->sid, (void *)pair->pth, (void **)(void *)0);
                    if(!(return_value_rbt_i32_add$20 == 0))
                    {
                      __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)176, "Attempt to evaluate an object (ID=%u) which is already being evaluated by an other thread.", pair->pth->sid);
                      __oscap_free((void *)pair->pth);
                      __oscap_free((void *)pair);
                      SEAP_msg_free(seap_request);
                    }

                    else
                    {
                      signed int return_value_pthread_create$19;
                      return_value_pthread_create$19=pthread_create(&pair->pth->tid, &pth_attr, probe_worker_runfn, (void *)pair);
                      if(!(return_value_pthread_create$19 == 0))
                      {
                        signed int *return_value___errno_location$15;
                        return_value___errno_location$15=__errno_location();
                        signed int *return_value___errno_location$16;
                        return_value___errno_location$16=__errno_location();
                        char *return_value_strerror$17;
                        return_value_strerror$17=strerror(*return_value___errno_location$16);
                        __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)186, "Cannot start a new worker thread: %d, %s.", *return_value___errno_location$15, return_value_strerror$17);
                        signed int return_value_rbt_i32_del$18;
                        return_value_rbt_i32_del$18=rbt_i32_del(probe->workers, (signed int)pair->pth->sid, (void **)(void *)0);
                        if(!(return_value_rbt_i32_del$18 == 0))
                          __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)189, "rbt_i32_del: failed to remove worker thread (ID=%u)", pair->pth->sid);

                        SEAP_msg_free(pair->pth->msg);
                        __oscap_free((void *)pair->pth);
                        __oscap_free((void *)pair);
                        probe_ret = 255;
                        probe_out = (struct SEXP *)(void *)0;
                        goto __error_reply;
                      }

                    }
                    seap_request = (struct SEAP_msg *)(void *)0;
                    continue;
                  }
                }

                else
                {
                  SEXP_free(oid);
                  SEXP_free(probe_in);
                  probe_ret = 0;
                }
              }
            }

            else
            {
              __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)214, "No `id' attribute");
              probe_ret = 4;
              probe_out = (struct SEXP *)(void *)0;
            }
            if(probe_out == ((struct SEXP *)NULL) || !(probe_ret == 0))
            {

            __error_reply:
              ;
              signed int return_value_SEAP_replyerr$24;
              return_value_SEAP_replyerr$24=SEAP_replyerr(probe->SEAP_ctx, probe->sd, seap_request, (unsigned int)probe_ret);
              if(return_value_SEAP_replyerr$24 == -1)
              {
                signed int *return_value___errno_location$21;
                return_value___errno_location$21=__errno_location();
                signed int *return_value___errno_location$22;
                return_value___errno_location$22=__errno_location();
                char *return_value_strerror$23;
                return_value_strerror$23=strerror(*return_value___errno_location$22);
                __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)224, "An error ocured while sending error status. errno=%u, %s.", *return_value___errno_location$21, return_value_strerror$23);
                SEAP_msg_free(seap_request);
                SEXP_free(probe_in);
                break;
              }

            }

            else
            {
              seap_reply=SEAP_msg_new();
              SEAP_msg_set(seap_reply, probe_out);
              SEXP_free(probe_out);
              signed int return_value_SEAP_reply$28;
              return_value_SEAP_reply$28=SEAP_reply(probe->SEAP_ctx, probe->sd, seap_reply, seap_request);
              if(return_value_SEAP_reply$28 == -1)
              {
                signed int *return_value___errno_location$25;
                return_value___errno_location$25=__errno_location();
                signed int *return_value___errno_location$26;
                return_value___errno_location$26=__errno_location();
                char *return_value_strerror$27;
                return_value_strerror$27=strerror(*return_value___errno_location$26);
                __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/input_handler.c", "probe_input_handler", (unsigned long int)240, "An error ocured while sending SEAP message. errno=%u, %s.", *return_value___errno_location$25, return_value_strerror$27);
                SEAP_msg_free(seap_reply);
                SEAP_msg_free(seap_request);
                break;
              }

              SEAP_msg_free(seap_reply);
            }
            SEAP_msg_free(seap_request);
          }

        __CPROVER_DUMP_L28:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&__cancel_buf);
        __cancel_routine(__cancel_arg);
      }
      while((_Bool)0);
      return (void *)0;
    }
  }
}

// probe_item_collect
// file ../../../../src/OVAL/probes/public/probe-api.h line 489
signed int probe_item_collect(struct probe_ctx *ctx, struct SEXP *item)
{
  struct SEXP *cobj_content;
  unsigned long int cobj_itemcnt;
  while((_Bool)0)
    ;
  while((_Bool)0)
    ;
  while((_Bool)0)
    ;
  cobj_content=SEXP_listref_nth(ctx->probe_out, (unsigned int)3);
  cobj_itemcnt=SEXP_list_length(cobj_content);
  SEXP_free(cobj_content);
  signed int return_value_probe_cobj_memcheck$3;
  return_value_probe_cobj_memcheck$3=probe_cobj_memcheck(cobj_itemcnt);
  if(!(return_value_probe_cobj_memcheck$3 == 0))
  {
    enum anonymous$8 return_value_probe_cobj_get_flag$2;
    return_value_probe_cobj_get_flag$2=probe_cobj_get_flag(ctx->probe_out);
    if(!((signed int)return_value_probe_cobj_get_flag$2 == SYSCHAR_FLAG_INCOMPLETE))
    {
      struct SEXP *msg;
      signed int return_value_probe_icache_nop$1;
      return_value_probe_icache_nop$1=probe_icache_nop(ctx->icache);
      if(!(return_value_probe_icache_nop$1 == 0))
        return -1;

      msg=probe_msg_creat((enum anonymous$9)OVAL_MESSAGE_LEVEL_WARNING, "Object is incomplete due to memory constraints.");
      probe_cobj_add_msg(ctx->probe_out, msg);
      probe_cobj_set_flag(ctx->probe_out, (enum anonymous$8)SYSCHAR_FLAG_INCOMPLETE);
      SEXP_free(msg);
    }

    return 2;
  }

  _Bool return_value_probe_item_filtered$4;
  if(!(ctx->filters == ((struct SEXP *)NULL)))
  {
    return_value_probe_item_filtered$4=probe_item_filtered(item, ctx->filters);
    if(return_value_probe_item_filtered$4 == (_Bool)0)
      goto __CPROVER_DUMP_L8;

    SEXP_free(item);
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    signed int return_value_probe_icache_add$5;
    return_value_probe_icache_add$5=probe_icache_add(ctx->icache, ctx->probe_out, item);
    if(!(return_value_probe_icache_add$5 == 0))
    {
      __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/icache.c", "probe_item_collect", (unsigned long int)546, "Can't add item (%p) to the item cache (%p)", item, ctx->icache);
      SEXP_free(item);
      return -1;
    }

    else
      return 0;
  }
}

// probe_main
// file ../../../../src/OVAL/probes/unix/runlevel.c line 366
signed int probe_main(struct probe_ctx *ctx, void *arg)
{
  struct SEXP *object;
  struct runlevel_req request_st;
  struct runlevel_rep *reply_st = (struct runlevel_rep *)(void *)0;
  object=probe_ctx_getobject(ctx);
  request_st.service_name_ent=probe_obj_getent(object, "service_name", (unsigned int)1);
  if(request_st.service_name_ent == ((struct SEXP *)NULL))
  {
    __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "probe_main", (unsigned long int)376, "%s: element not found", (const void *)"service_name");
    return 2;
  }

  else
  {
    request_st.runlevel_ent=probe_obj_getent(object, "runlevel", (unsigned int)1);
    if(request_st.runlevel_ent == ((struct SEXP *)NULL))
    {
      SEXP_free(request_st.service_name_ent);
      __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "probe_main", (unsigned long int)384, "%s: element not found", (const void *)"runlevel");
      return 2;
    }

    else
    {
      signed int return_value_get_runlevel$3;
      return_value_get_runlevel$3=get_runlevel(&request_st, &reply_st);
      if(return_value_get_runlevel$3 == -1)
      {
        struct SEXP *msg;
        msg=probe_msg_creat((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "get_runlevel failed.");
        struct SEXP *return_value_probe_ctx_getresult$1;
        return_value_probe_ctx_getresult$1=probe_ctx_getresult(ctx);
        probe_cobj_add_msg(return_value_probe_ctx_getresult$1, msg);
        SEXP_free(msg);
        struct SEXP *return_value_probe_ctx_getresult$2;
        return_value_probe_ctx_getresult$2=probe_ctx_getresult(ctx);
        probe_cobj_set_flag(return_value_probe_ctx_getresult$2, (enum anonymous$8)SYSCHAR_FLAG_ERROR);
      }

      else
      {
        struct runlevel_rep *next_rep;
        struct SEXP *item;
        for( ; !(reply_st == ((struct runlevel_rep *)NULL)); reply_st = next_rep)
        {
          __oscap_dlprintf(DBG_I, "../../../../src/OVAL/probes/unix/runlevel.c", "probe_main", (unsigned long int)402, "get_runlevel: [0]=\"%s\", [1]=\"%s\", [2]=\"%d\", [3]=\"%d\"", reply_st->service_name, reply_st->runlevel, reply_st->start, reply_st->kill);
          item=probe_item_create((enum anonymous$17)13006, (struct anonymous$11 **)(void *)0, (const void *)"service_name", OVAL_DATATYPE_STRING, reply_st->service_name, (const void *)"runlevel", OVAL_DATATYPE_STRING, reply_st->runlevel, (const void *)"start", OVAL_DATATYPE_BOOLEAN, reply_st->start, (const void *)"kill", OVAL_DATATYPE_BOOLEAN, reply_st->kill, (void *)0);
          probe_item_collect(ctx, item);
          next_rep = reply_st->next;
          __oscap_free((void *)reply_st->service_name);
          __oscap_free((void *)reply_st->runlevel);
          __oscap_free((void *)reply_st);
        }
      }
      SEXP_free(request_st.runlevel_ent);
      SEXP_free(request_st.service_name_ent);
      return 0;
    }
  }
}

// probe_obj_eval
// file ../../../../../src/OVAL/probes/probe/worker.c line 367
static struct SEXP * probe_obj_eval(struct anonymous$23 *probe, struct SEXP *id)
{
  struct SEXP *res;
  struct SEXP *rid;
  res=SEAP_cmd_exec(probe->SEAP_ctx, probe->sd, (unsigned int)0, (unsigned short int)2, id, (unsigned char)1, (struct SEXP * (*)(struct SEXP *, void *))(void *)0, (void *)0);
  rid=SEXP_list_first(res);
  do
  {
    signed int return_value_SEXP_string_cmp$1;
    return_value_SEXP_string_cmp$1=SEXP_string_cmp(id, rid);
    if(!(return_value_SEXP_string_cmp$1 == 0))
    {
      signed int __cont374 = 1;
      while((_Bool)0)
        ;
      do
        __cont374 = 0;
      while(!(__cont374 == 0));
      if(__cont374 == 0)
        return (struct SEXP *)(void *)0;

    }

    else

      __CPROVER_DUMP_L5:
        ;
  }
  while((_Bool)0);
  __SEXP_vfree(3, res, rid, (void *)0);
  struct SEXP *return_value_probe_rcache_sexp_get$2;
  return_value_probe_rcache_sexp_get$2=probe_rcache_sexp_get(probe->rcache, id);
  return return_value_probe_rcache_sexp_get$2;
}

// probe_optecmp
// file ../../../../../src/OVAL/probes/probe/main.c line 66
static signed int probe_optecmp(char **a, char **b)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(*a, *b);
  return return_value_strcmp$1;
}

// probe_opthandler_offlinemode
// file ../../../../../src/OVAL/probes/probe/main.c line 125
static signed int probe_opthandler_offlinemode(signed int option, signed int op, __builtin_va_list args)
{
  if(op == 0)
  {
    enum anonymous$25 o_offline_mode;
    signed int o_cobjflag = ___G_offline_mode_cobjflag;
    signed int return_value_gcc_builtin_va_arg$1;
    return_value_gcc_builtin_va_arg$1=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$1));
    o_offline_mode = (enum anonymous$25)return_value_gcc_builtin_va_arg$1;
    if(!((signed int)o_offline_mode == PROBE_OFFLINE_ALL))
      o_cobjflag = SYSCHAR_FLAG_NOT_COLLECTED;

    ___G_offline_mode_supported = o_offline_mode;
    ___G_offline_mode_cobjflag = o_cobjflag;
  }

  else
    if(op == 1)
    {
      signed int *offline_mode_supported;
      offline_mode_supported=va_arg(args, __typeof__(offline_mode_supported));
      signed int *offline_mode;
      offline_mode=va_arg(args, __typeof__(offline_mode));
      if(!(offline_mode_supported == ((signed int *)NULL)))
        *offline_mode_supported = (signed int)___G_offline_mode_supported;

      if(!(offline_mode == ((signed int *)NULL)))
        *offline_mode = (signed int)___G_offline_mode;

    }

  return 0;
}

// probe_opthandler_rcache
// file ../../../../../src/OVAL/probes/probe/main.c line 120
static signed int probe_opthandler_rcache(signed int option, signed int op, void **args)
{
  return 0;
}

// probe_opthandler_varref
// file ../../../../../src/OVAL/probes/probe/main.c line 86
static signed int probe_opthandler_varref(signed int option, signed int op, __builtin_va_list args)
{
  _Bool o_switch;
  char *o_name;
  char *o_temp;
  if(op == 1)
    return -1;

  else
  {
    signed int return_value_gcc_builtin_va_arg$1;
    return_value_gcc_builtin_va_arg$1=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$1));
    o_switch = (_Bool)return_value_gcc_builtin_va_arg$1;
    o_name=va_arg(args, __typeof__(o_name));
    if(o_name == ((char *)NULL))
    {
      ___G_varref_handling = o_switch;
      return 0;
    }

    else
    {
      void *return_value_oscap_bfind$2;
      return_value_oscap_bfind$2=oscap_bfind((void *)___G_no_varref_ents, ___G_no_varref_ents_cnt, sizeof(char *) /*8ul*/ , (void *)o_name, (signed int (*)(void *, void *))probe_optecmp);
      o_temp = (char *)return_value_oscap_bfind$2;
      if(!(o_temp == ((char *)NULL)))
        return 0;

      else
      {
        ___G_no_varref_ents_cnt = ___G_no_varref_ents_cnt + 1ul;
        void *return_value___oscap_realloc$3;
        return_value___oscap_realloc$3=__oscap_realloc((void *)___G_no_varref_ents, sizeof(char *) /*8ul*/  * ___G_no_varref_ents_cnt);
        ___G_no_varref_ents = (char **)return_value___oscap_realloc$3;
        ___G_no_varref_ents[(signed long int)(___G_no_varref_ents_cnt - (unsigned long int)1)]=strdup(o_name);
        qsort((void *)___G_no_varref_ents, ___G_no_varref_ents_cnt, sizeof(char *) /*8ul*/ , (signed int (*)(const void *, const void *))probe_optecmp);
        return 0;
      }
    }
  }
}

// probe_prepare_filters
// file ../../../../../src/OVAL/probes/probe/worker.c line 380
static struct SEXP * probe_prepare_filters(struct anonymous$23 *probe, struct SEXP *obj)
{
  struct SEXP *filters;
  signed int i;
  filters=SEXP_list_new((struct SEXP *)(void *)0);
  i = 1;
  do
  {
    struct SEXP *of;
    struct SEXP *f;
    struct SEXP *ste;
    struct SEXP *ste_id;
    struct SEXP *act;
    of=probe_obj_getent(obj, "filter", (unsigned int)i);
    if(of == ((struct SEXP *)NULL))
      break;

    act=probe_ent_getattrval(of, "action");
    ste_id=probe_ent_getval(of);
    ste=probe_rcache_sexp_get(probe->rcache, ste_id);
    if(ste == ((struct SEXP *)NULL))
    {
      struct SEXP *r0;
      struct SEXP *r1;
      r0=SEXP_list_new(ste_id, (void *)0);
      r1=probe_ste_fetch(probe, r0);
      ste=SEXP_list_first(r1);
      __SEXP_vfree(3, r0, r1, (void *)0);
    }

    __SEXP_vfree(3, of, ste_id, (void *)0);
    f=SEXP_list_new(act, ste, (void *)0);
    SEXP_list_add(filters, f);
    __SEXP_vfree(4, act, ste, f, (void *)0);
    i = i + 1;
  }
  while((_Bool)1);
  return filters;
}

// probe_reset
// file ../../../../../src/OVAL/probes/probe/main.c line 71
static struct SEXP * probe_reset(struct SEXP *arg0, void *arg1)
{
  struct anonymous$23 *probe = (struct anonymous$23 *)arg1;
  probe_rcache_free(probe->rcache);
  probe_ncache_free(probe->ncache);
  probe->rcache=probe_rcache_new();
  probe->ncache=probe_ncache_new();
  return (struct SEXP *)(void *)0;
}

// probe_set_apply_filters
// file ../../../../../src/OVAL/probes/probe/worker.c line 554
static struct SEXP * probe_set_apply_filters(struct SEXP *cobj, struct SEXP *filters)
{
  struct SEXP *result_items;
  struct SEXP *items;
  struct SEXP *item;
  struct SEXP *mask;
  enum anonymous$33 item_status;
  enum anonymous$8 flag;
  result_items=SEXP_list_new((struct SEXP *)(void *)0);
  flag=probe_cobj_get_flag(cobj);
  items=probe_cobj_get_items(cobj);
  mask=probe_cobj_get_mask(cobj);
  unsigned int i565 = (unsigned int)1;
  struct SEXP *r0;
  struct SEXP *r1;
  do
  {
    item=SEXP_list_nth(items, i565);
    if(item == ((struct SEXP *)NULL))
      break;

    item_status=probe_ent_getstatus(item);
    switch((signed int)item_status)
    {
      case SYSCHAR_STATUS_DOES_NOT_EXIST:
        break;
      case SYSCHAR_STATUS_ERROR:
        goto __CPROVER_DUMP_L5;
      case SYSCHAR_STATUS_NOT_COLLECTED:
      {
        r0=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "Supplied item has an invalid status: %d.", item_status);
        r1=SEXP_list_new(r0, (void *)0);
        cobj=probe_cobj_new((enum anonymous$8)SYSCHAR_FLAG_ERROR, r1, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0);
        __SEXP_vfree(6, items, item, result_items, r0, r1, (void *)0);
        return cobj;
      }
      default:
      {

      __CPROVER_DUMP_L5:
        ;
        _Bool return_value_probe_item_filtered$1;
        return_value_probe_item_filtered$1=probe_item_filtered(item, filters);
        if(return_value_probe_item_filtered$1 == (_Bool)0)
          SEXP_list_add(result_items, item);

      }
    }
    i565 = i565 + 1u;
    SEXP_free(item);
    item = (struct SEXP *)(void *)0;
  }
  while((_Bool)1);
  unsigned long int return_value_SEXP_list_length$2;
  if((signed int)flag == SYSCHAR_FLAG_COMPLETE)
  {
    return_value_SEXP_list_length$2=SEXP_list_length(result_items);
    if(return_value_SEXP_list_length$2 == 0ul)
      flag = (enum anonymous$8)SYSCHAR_FLAG_DOES_NOT_EXIST;

  }

  cobj=probe_cobj_new(flag, (struct SEXP *)(void *)0, result_items, mask);
  __SEXP_vfree(3, items, result_items, mask);
  return cobj;
}

// probe_set_combine
// file ../../../../../src/OVAL/probes/probe/worker.c line 425
static struct SEXP * probe_set_combine(struct SEXP *cobj0, struct SEXP *cobj1, enum anonymous$34 op)
{
  struct SEXP *set0;
  struct SEXP *set1;
  struct SEXP *res_cobj;
  struct SEXP *cobj0_mask;
  struct SEXP *cobj1_mask;
  struct SEXP *res_mask;
  signed int cmp;
  struct SEXP *item0;
  struct SEXP *item1;
  struct SEXP *res;
  struct SEXP_list_it *sit0;
  struct SEXP_list_it *sit1;
  enum anonymous$8 res_flag;
  struct SEXP *return_value_SEXP_ref$1;
  struct SEXP *return_value_SEXP_ref$2;
  unsigned long int return_value_SEXP_list_length$5;
  if(cobj0 == ((struct SEXP *)NULL))
  {
    return_value_SEXP_ref$1=SEXP_ref(cobj1);
    return return_value_SEXP_ref$1;
  }

  else
    if(cobj1 == ((struct SEXP *)NULL))
    {
      return_value_SEXP_ref$2=SEXP_ref(cobj0);
      return return_value_SEXP_ref$2;
    }

    else
    {
      set0=probe_cobj_get_items(cobj0);
      set1=probe_cobj_get_items(cobj1);
      cobj0_mask=probe_cobj_get_mask(cobj0);
      cobj1_mask=probe_cobj_get_mask(cobj1);
      res=SEXP_list_new((struct SEXP *)(void *)0);
      enum anonymous$8 return_value_probe_cobj_get_flag$3;
      return_value_probe_cobj_get_flag$3=probe_cobj_get_flag(cobj0);
      enum anonymous$8 return_value_probe_cobj_get_flag$4;
      return_value_probe_cobj_get_flag$4=probe_cobj_get_flag(cobj1);
      res_flag=probe_cobj_combine_flags(return_value_probe_cobj_get_flag$3, return_value_probe_cobj_get_flag$4, op);
      res_mask=SEXP_list_join(cobj0_mask, cobj1_mask);
      sit0=SEXP_list_it_new(set0);
      sit1=SEXP_list_it_new(set1);
      item0=SEXP_list_it_next(sit0);
      item1=SEXP_list_it_next(sit1);
      switch((signed int)op)
      {
        case OVAL_SET_OPERATION_UNION:
        {
          while(!(item0 == ((struct SEXP *)NULL)) && !(item1 == ((struct SEXP *)NULL)))
          {
            cmp=SEXP_refcmp(item0, item1);
            if(!(cmp >= 0))
            {
              SEXP_list_add(res, item0);
              item0=SEXP_list_it_next(sit0);
            }

            else
              if(cmp >= 1)
              {
                SEXP_list_add(res, item1);
                item1=SEXP_list_it_next(sit1);
              }

              else
              {
                SEXP_list_add(res, item0);
                item0=SEXP_list_it_next(sit0);
                item1=SEXP_list_it_next(sit1);
              }
          }
          if(!(item0 == ((struct SEXP *)NULL)))
            do
            {
              SEXP_list_add(res, item0);
              item0=SEXP_list_it_next(sit0);
            }
            while(!(item0 == ((struct SEXP *)NULL)));

          else
            if(!(item1 == ((struct SEXP *)NULL)))
              do
              {
                SEXP_list_add(res, item1);
                item1=SEXP_list_it_next(sit1);
              }
              while(!(item1 == ((struct SEXP *)NULL)));

          break;
        }
        case OVAL_SET_OPERATION_INTERSECTION:
        {
          while(!(item0 == ((struct SEXP *)NULL)) && !(item1 == ((struct SEXP *)NULL)))
          {
            cmp=SEXP_refcmp(item0, item1);
            if(!(cmp >= 0))
              item0=SEXP_list_it_next(sit0);

            else
              if(cmp >= 1)
                item1=SEXP_list_it_next(sit1);

              else
              {
                SEXP_list_add(res, item0);
                item0=SEXP_list_it_next(sit0);
                item1=SEXP_list_it_next(sit1);
              }
          }
          break;
        }
        case OVAL_SET_OPERATION_COMPLEMENT:
        {
          while(!(item0 == ((struct SEXP *)NULL)) && !(item1 == ((struct SEXP *)NULL)))
          {
            cmp=SEXP_refcmp(item0, item1);
            if(!(cmp >= 0))
            {
              SEXP_list_add(res, item0);
              item0=SEXP_list_it_next(sit0);
            }

            else
              if(cmp >= 1)
                item1=SEXP_list_it_next(sit1);

              else
              {
                item0=SEXP_list_it_next(sit0);
                item1=SEXP_list_it_next(sit1);
              }
          }
          if(!(item0 == ((struct SEXP *)NULL)))
            do
            {
              SEXP_list_add(res, item0);
              item0=SEXP_list_it_next(sit0);
            }
            while(!(item0 == ((struct SEXP *)NULL)));

          break;
        }
        default:
        {
          __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/worker.c", "probe_set_combine", (unsigned long int)524, "Unknown set operation: %d", op);
          abort();
        }
      }
      SEXP_list_it_free(sit0);
      SEXP_list_it_free(sit1);
      if((signed int)res_flag == SYSCHAR_FLAG_COMPLETE)
      {
        return_value_SEXP_list_length$5=SEXP_list_length(res);
        if(return_value_SEXP_list_length$5 == 0ul)
          res_flag = (enum anonymous$8)SYSCHAR_FLAG_DOES_NOT_EXIST;

      }

      res_cobj=probe_cobj_new(res_flag, (struct SEXP *)(void *)0, res, res_mask);
      __SEXP_vfree(4, set0, set1, res, res_mask);
      __SEXP_vfree(2, cobj0_mask, cobj1_mask);
      return res_cobj;
    }
}

// probe_set_eval
// file ../../../../../src/OVAL/probes/probe/worker.c line 615
static struct SEXP * probe_set_eval(struct anonymous$23 *probe, struct SEXP *set, unsigned long int depth)
{
  struct SEXP *filters_u;
  struct SEXP *filters_a;
  struct SEXP *filters_req;
  struct SEXP *s_subset[2l];
  unsigned long int s_subset_i;
  struct SEXP *o_subset[2l];
  unsigned long int o_subset_i;
  struct SEXP *member;
  char member_name[24l];
  struct SEXP *op_val;
  signed int op_num;
  struct SEXP *r0;
  struct SEXP *r1;
  struct SEXP *result;
  struct SEXP *Omsg = (struct SEXP *)(void *)0;
  if(depth >= 9ul)
  {
    char *fmt = "probe_set_eval: Too many levels: max=%zu.";
    r0=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, fmt, (unsigned long int)8);
    r1=SEXP_list_new(r0, (void *)0);
    result=probe_cobj_new((enum anonymous$8)SYSCHAR_FLAG_ERROR, r1, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0);
    __SEXP_vfree(3, r0, r1, (void *)0);
    return result;
  }

  filters_u=SEXP_list_new((struct SEXP *)(void *)0);
  filters_a=SEXP_list_new((struct SEXP *)(void *)0);
  filters_req=SEXP_list_new((struct SEXP *)(void *)0);
  s_subset[(signed long int)0] = (struct SEXP *)(void *)0;
  s_subset[(signed long int)1] = (struct SEXP *)(void *)0;
  s_subset_i = (unsigned long int)0;
  o_subset[(signed long int)0] = (struct SEXP *)(void *)0;
  o_subset[(signed long int)1] = (struct SEXP *)(void *)0;
  o_subset_i = (unsigned long int)0;
  result = (struct SEXP *)(void *)0;
  op_val=probe_ent_getattrval(set, "operation");
  if(!(op_val == ((struct SEXP *)NULL)))
    op_num=SEXP_number_geti_32(op_val);

  else
    op_num = OVAL_SET_OPERATION_UNION;
  SEXP_free(op_val);
  unsigned int i674 = (unsigned int)2;
  _Bool tmp_if_expr$1;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  do
  {
    if(!((unsigned long int)i674 >= 1001ul))
    {
      member=SEXP_list_nth(set, i674);
      tmp_if_expr$1 = member != (struct SEXP *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    unsigned long int return_value_probe_ent_getname_r$3;
    return_value_probe_ent_getname_r$3=probe_ent_getname_r(member, member_name, sizeof(char [24l]) /*24ul*/ );
    if(return_value_probe_ent_getname_r$3 == 0ul)
    {
      const char *return_value_SEXP_strtype$2;
      return_value_SEXP_strtype$2=SEXP_strtype(member);
      Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "probe_set_eval: Invalid set element: ptr=%p, type=%s.", member, return_value_SEXP_strtype$2);
      goto eval_fail;
    }

    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp("set", member_name);
    if(return_value_strcmp$6 == 0)
    {
      if(!(s_subset_i >= 2ul))
      {
        s_subset[(signed long int)s_subset_i]=probe_set_eval(probe, member, depth + (unsigned long int)1);
        if(s_subset[(signed long int)s_subset_i] == ((struct SEXP *)NULL))
        {
          Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "probe_set_eval: Recursive set evaluation failed: m=%p, d=%zu.", member, depth + (unsigned long int)1);
          goto eval_fail;
        }

        s_subset_i = s_subset_i + 1ul;
      }

      else
      {
        Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "probe_set_eval: More than 2 \"set\".");
        goto eval_fail;
      }
    }

    else
    {
      return_value_strcmp$5=strcmp("obj_ref", member_name);
      if(return_value_strcmp$5 == 0)
      {
        struct SEXP *OID;
        struct SEXP *objres;
        char OID_cstr[128l];
        __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_set_eval", (unsigned long int)709, "Handling object_reference");
        OID=probe_ent_getval(member);
        if(OID == ((struct SEXP *)NULL))
        {
          Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "%s: missing object_reference entity value!", (const void *)"probe_set_eval");
          goto eval_fail;
        }

        objres=probe_rcache_sexp_get(probe->rcache, OID);
        if(objres == ((struct SEXP *)NULL))
        {
          __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_set_eval", (unsigned long int)721, "MISS => requesting object evaluation from the library");
          objres=probe_obj_eval(probe, OID);
          __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_set_eval", (unsigned long int)725, "EVAL: result=%p", objres);
          if(!(objres == ((struct SEXP *)NULL)))
            __oscap_debuglog_object("../../../../../src/OVAL/probes/probe/worker.c", "probe_set_eval", (unsigned long int)727, 1, (void *)objres);

          else
          {
            SEXP_string_cstr_r(OID, OID_cstr, sizeof(char [128l]) /*128ul*/ );
            Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "%s: evaluation failed: OID=%s", (const void *)"probe_set_eval", (const void *)OID_cstr);
            SEXP_free(OID);
            goto eval_fail;
          }
        }

        SEXP_free(OID);
        if(!(o_subset_i >= 2ul))
        {
          o_subset[(signed long int)o_subset_i] = objres;
          o_subset_i = o_subset_i + 1ul;
        }

        else
        {
          Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "%s: more than 2 obj_refs.", (const void *)"probe_set_eval");
          SEXP_free(objres);
          goto eval_fail;
        }
      }

      else
      {
        return_value_strcmp$4=strcmp("filter", member_name);
        if(return_value_strcmp$4 == 0)
        {
          struct SEXP *SID;
          struct SEXP *action;
          struct SEXP *state;
          SID=probe_ent_getval(member);
          if(SID == ((struct SEXP *)NULL))
          {
            Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "%s: missing filter entity value.", (const void *)"probe_set_eval");
            goto eval_fail;
          }

          action=probe_ent_getattrval(member, "action");
          if(action == ((struct SEXP *)NULL))
          {
            Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "%s: missing filter action.", (const void *)"probe_set_eval");
            SEXP_free(SID);
            goto eval_fail;
          }

          state=probe_rcache_sexp_get(probe->rcache, SID);
          if(state == ((struct SEXP *)NULL))
          {
            SEXP_list_add(filters_req, SID);
            r0=SEXP_list_new(action, SID, (void *)0);
            SEXP_list_add(filters_u, r0);
          }

          else
          {
            r0=SEXP_list_new(action, state, (void *)0);
            SEXP_list_add(filters_a, r0);
            SEXP_free(state);
          }
          SEXP_free(SID);
          SEXP_free(action);
          SEXP_free(r0);
        }

        else
          abort();
      }
    }
    i674 = i674 + 1u;
    SEXP_free(member);
    member = (struct SEXP *)(void *)0;
  }
  while((_Bool)1);
  member = (struct SEXP *)(void *)0;
  result=probe_ste_fetch(probe, filters_req);
  if(result == ((struct SEXP *)NULL))
    Omsg=probe_msg_creatf((enum anonymous$9)OVAL_MESSAGE_LEVEL_ERROR, "%s: Can't get unavailable filters.", (const void *)"probe_set_eval");

  else
  {
    __SEXP_vfree(3, filters_req, result, (void *)0);
    unsigned int i803 = (unsigned int)1;
    do
    {
      member=SEXP_list_nth(filters_u, i803);
      if(member == ((struct SEXP *)NULL))
        break;

      struct SEXP *id;
      struct SEXP *act;
      struct SEXP *ste;
      act=SEXP_list_first(member);
      id=SEXP_list_nth(member, (unsigned int)2);
      ste=probe_rcache_sexp_get(probe->rcache, id);
      r0=SEXP_list_new(act, ste, (void *)0);
      SEXP_list_add(filters_a, r0);
      __SEXP_vfree(5, act, id, ste, r0, (void *)0);
      i803 = i803 + 1u;
      SEXP_free(member);
      member = (struct SEXP *)(void *)0;
    }
    while((_Bool)1);
    SEXP_free(filters_u);
    if(o_subset_i >= 1ul)
    {
      s_subset_i = (unsigned long int)0;
      for( ; !(s_subset_i >= o_subset_i); s_subset_i = s_subset_i + 1ul)
      {
        s_subset[(signed long int)s_subset_i]=probe_set_apply_filters(o_subset[(signed long int)s_subset_i], filters_a);
        SEXP_free(o_subset[(signed long int)s_subset_i]);
        o_subset[(signed long int)s_subset_i] = (struct SEXP *)(void *)0;
      }
    }

    SEXP_free(filters_a);
    result=probe_set_combine(s_subset[(signed long int)0], s_subset[(signed long int)1], (enum anonymous$34)op_num);
    SEXP_free(s_subset[(signed long int)0]);
    SEXP_free(s_subset[(signed long int)1]);
    __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_set_eval", (unsigned long int)867, "=== RESULT ===");
    __oscap_debuglog_object("../../../../../src/OVAL/probes/probe/worker.c", "probe_set_eval", (unsigned long int)868, 1, (void *)result);
    __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_set_eval", (unsigned long int)869, "");
    return result;
  }

eval_fail:
  ;
  SEXP_free(member);
  for( ; s_subset_i >= 1ul; s_subset_i = s_subset_i - 1ul)
    SEXP_free(s_subset[(signed long int)(s_subset_i - (unsigned long int)1)]);
  for( ; o_subset_i >= 1ul; o_subset_i = o_subset_i - 1ul)
    SEXP_free(o_subset[(signed long int)(o_subset_i - (unsigned long int)1)]);
  SEXP_free(filters_u);
  SEXP_free(filters_a);
  SEXP_free(filters_req);
  SEXP_free(result);
  r1=SEXP_list_new(Omsg, (void *)0);
  result=probe_cobj_new((enum anonymous$8)SYSCHAR_FLAG_ERROR, r1, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0);
  __SEXP_vfree(3, Omsg, r1, (void *)0);
  return result;
}

// probe_setoption
// file ../../../../src/OVAL/probes/probe/option.h line 23
signed int probe_setoption(signed int option, ...)
{
  signed int ret;
  void **ap = (void **)&option;
  ret=__probe_option_op(option, 0, ap);
  ap = ((void **)NULL);
  return ret;
}

// probe_signal_handler
// file ../../../../../src/OVAL/probes/probe/signal_handler.h line 25
void * probe_signal_handler(void *arg)
{
  struct anonymous$23 *probe = (struct anonymous$23 *)arg;
  struct anonymous$45 siinf;
  struct anonymous$24 siset;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_setname_np(return_value_pthread_self$1, "signal_handler");
  sigemptyset(&siset);
  sigaddset(&siset, 1);
  sigaddset(&siset, 10);
  sigaddset(&siset, 12);
  sigaddset(&siset, 2);
  sigaddset(&siset, 15);
  sigaddset(&siset, 3);
  sigaddset(&siset, 13);
  signed int return_value_prctl$2;
  return_value_prctl$2=prctl(1, 15);
  if(!(return_value_prctl$2 == 0))
    __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/signal_handler.c", "probe_signal_handler", (unsigned long int)80, "prctl(PR_SET_PDEATHSIG, SIGTERM) failed");

  __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/signal_handler.c", "probe_signal_handler", (unsigned long int)83, "Signal handler ready");
  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  *return_value___errno_location$3=pthread_barrier_wait(&___G_th_barrier);
  if(*return_value___errno_location$3 == 0 || *return_value___errno_location$3 == -1)
    goto __CPROVER_DUMP_L4;

  signed int *return_value___errno_location$4;
  return_value___errno_location$4=__errno_location();
  signed int *return_value___errno_location$5;
  return_value___errno_location$5=__errno_location();
  char *return_value_strerror$6;
  return_value_strerror$6=strerror(*return_value___errno_location$5);
  __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/signal_handler.c", "probe_signal_handler", (unsigned long int)90, "pthread_barrier_wait: %d, %s.", *return_value___errno_location$4, return_value_strerror$6);
  return (void *)0;
  signed int return_value_sigwaitinfo$7;
  struct anonymous$46 coll;
  do
  {

  __CPROVER_DUMP_L4:
    ;
    return_value_sigwaitinfo$7=sigwaitinfo(&siset, &siinf);
    if(return_value_sigwaitinfo$7 == -1)
      break;

    signed int return_value_getppid$8;
    return_value_getppid$8=getppid();
    __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/signal_handler.c", "probe_signal_handler", (unsigned long int)98, "Received signal %d from %u (%s)", siinf.si_signo, (unsigned int)siinf._sifields._kill.si_pid, return_value_getppid$8 == siinf._sifields._kill.si_pid ? "parent" : "not my parent");
    switch(siinf.si_signo)
    {
      case 10:
        probe->probe_exitcode = 103;
      case 2:

      case 15:

      case 3:

      case 13:
      {
        coll.thr = (struct anonymous$31 **)(void *)0;
        coll.cnt = (unsigned long int)0;
        pthread_cancel(probe->th_input);
        rbt_walk_inorder2(probe->workers, __abort_cb, (void *)&coll, (enum anonymous$47)0);
        for( ; coll.cnt >= 1ul; coll.cnt = coll.cnt - 1ul)
        {
          struct anonymous$31 *thr = coll.thr[(signed long int)(coll.cnt - (unsigned long int)1)];
          struct timespec j_tm;
          signed int return_value_clock_gettime$12;
          return_value_clock_gettime$12=clock_gettime(0, &j_tm);
          if(return_value_clock_gettime$12 == -1)
          {
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            char *return_value_strerror$11;
            return_value_strerror$11=strerror(*return_value___errno_location$10);
            __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/signal_handler.c", "probe_signal_handler", (unsigned long int)135, "clock_gettime(CLOCK_REALTIME): %d, %s.", *return_value___errno_location$9, return_value_strerror$11);
            goto __CPROVER_DUMP_L10;
          }

          j_tm.tv_sec = j_tm.tv_sec + (signed long int)60;
          signed int *return_value___errno_location$16;
          return_value___errno_location$16=__errno_location();
          *return_value___errno_location$16=pthread_timedjoin_np(thr->tid, (void **)(void *)0, &j_tm);
          if(!(*return_value___errno_location$16 == 0))
          {
            signed int *return_value___errno_location$13;
            return_value___errno_location$13=__errno_location();
            signed int *return_value___errno_location$14;
            return_value___errno_location$14=__errno_location();
            char *return_value_strerror$15;
            return_value_strerror$15=strerror(*return_value___errno_location$14);
            __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/signal_handler.c", "probe_signal_handler", (unsigned long int)142, "[%llu] pthread_timedjoin_np: %d, %s.", (unsigned long int)thr->sid, *return_value___errno_location$13, return_value_strerror$15);
            goto __CPROVER_DUMP_L10;
          }

          SEAP_msg_free(coll.thr[(signed long int)(coll.cnt - (unsigned long int)1)]->msg);
          __oscap_free((void *)coll.thr[(signed long int)(coll.cnt - (unsigned long int)1)]);

        __CPROVER_DUMP_L10:
          ;
        }
        __oscap_free((void *)coll.thr);
        goto exitloop;
      }
      case 12:

      case 1:

      default:
        ;
    }
  }
  while((_Bool)1);

exitloop:
  ;
  return (void *)0;
}

// probe_ste_fetch
// file ../../../../../src/OVAL/probes/probe/worker.c line 313
static struct SEXP * probe_ste_fetch(struct anonymous$23 *probe, struct SEXP *id_list)
{
  struct SEXP *res;
  struct SEXP *ste;
  struct SEXP *id;
  unsigned int i_len;
  unsigned int r_len;
  unsigned long int return_value_SEXP_list_length$1;
  return_value_SEXP_list_length$1=SEXP_list_length(id_list);
  i_len = (unsigned int)return_value_SEXP_list_length$1;
  struct SEXP *return_value_SEXP_list_new$2;
  if(i_len == 0u)
  {
    return_value_SEXP_list_new$2=SEXP_list_new((struct SEXP *)(void *)0);
    return return_value_SEXP_list_new$2;
  }

  else
  {
    res=SEAP_cmd_exec(probe->SEAP_ctx, probe->sd, (unsigned int)0, (unsigned short int)1, id_list, (unsigned char)1, (struct SEXP * (*)(struct SEXP *, void *))(void *)0, (void *)0);
    unsigned long int return_value_SEXP_list_length$3;
    return_value_SEXP_list_length$3=SEXP_list_length(res);
    r_len = (unsigned int)return_value_SEXP_list_length$3;
    if(!(i_len == r_len))
    {
      SEXP_free(res);
      return (struct SEXP *)(void *)0;
    }

    else
    {
      for( ; i_len >= 1u; i_len = i_len - 1u)
      {
        ste=SEXP_list_nth(res, i_len);
        id=SEXP_list_nth(id_list, i_len);
        signed int return_value_probe_rcache_sexp_add$4;
        return_value_probe_rcache_sexp_add$4=probe_rcache_sexp_add(probe->rcache, id, ste);
        if(!(return_value_probe_rcache_sexp_add$4 == 0))
        {
          SEXP_free(res);
          SEXP_free(ste);
          SEXP_free(id);
          return (struct SEXP *)(void *)0;
        }

        SEXP_free(ste);
        SEXP_free(id);
      }
      return res;
    }
  }
}

// probe_varref_create_ctx
// file ../../../../../src/OVAL/probes/probe/worker.c line 164
static signed int probe_varref_create_ctx(const struct SEXP *probe_in, struct SEXP *varrefs, struct probe_varref_ctx **octx)
{
  unsigned int i;
  unsigned int ent_cnt;
  unsigned int val_cnt;
  struct SEXP *ent_name;
  struct SEXP *ent;
  struct SEXP *varref;
  struct SEXP *val_lst;
  struct SEXP *r0;
  struct SEXP *r1;
  struct SEXP *r2;
  struct SEXP *r3;
  struct SEXP *vid;
  struct SEXP *vidx_name;
  struct SEXP *vidx_val;
  struct probe_varref_ctx *ctx;
  r1=SEXP_list_nth(varrefs, (unsigned int)3);
  ent_cnt=SEXP_number_getu_32(r1);
  SEXP_free(r1);
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc(sizeof(struct probe_varref_ctx) /*24ul*/ );
  ctx = (struct probe_varref_ctx *)return_value___oscap_alloc$1;
  ctx->pi2=SEXP_softref((struct SEXP *)probe_in);
  ctx->ent_cnt = ent_cnt;
  void *return_value___oscap_alloc$2;
  return_value___oscap_alloc$2=__oscap_alloc((unsigned long int)ent_cnt * sizeof(struct probe_varref_ctx_ent) /*16ul*/ );
  ctx->ent_lst = (struct probe_varref_ctx_ent *)return_value___oscap_alloc$2;
  vidx_name=SEXP_string_new((const void *)":val_idx", (unsigned long int)8);
  vidx_val=SEXP_number_newu_32((unsigned int)0);
  i = (unsigned int)0;
  _Bool tmp_if_expr$3;
  for( ; !(i >= ent_cnt); i = i + 1u)
  {
    r0=SEXP_list_nth(ctx->pi2, i + (unsigned int)2);
    vid=probe_ent_getattrval(r0, "var_ref");
    r1=SEXP_list_first(r0);
    r2=SEXP_list_first(r1);
    r3=SEXP_list_new(r2, vidx_name, vidx_val, (void *)0);
    SEXP_free(r0);
    r0=SEXP_list_rest(r1);
    ent_name=SEXP_list_join(r3, r0);
    __SEXP_vfree(5, r0, r1, r2, r3, (void *)0);
    unsigned int i201 = (unsigned int)4;
    do
    {
      if(!((unsigned long int)i201 >= 4294967295ul))
      {
        varref=SEXP_list_nth(varrefs, i201);
        tmp_if_expr$3 = varref != (struct SEXP *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      r0=SEXP_list_first(varref);
      signed int return_value_SEXP_string_cmp$4;
      return_value_SEXP_string_cmp$4=SEXP_string_cmp(vid, r0);
      if(return_value_SEXP_string_cmp$4 == 0)
      {
        SEXP_free(r0);
        break;
      }

      SEXP_free(r0);
      i201 = i201 + 1u;
      SEXP_free(varref);
      varref = (struct SEXP *)(void *)0;
    }
    while((_Bool)1);
    if(varref == ((struct SEXP *)NULL))
    {
      char *var_id;
      var_id=SEXP_string_cstr(vid);
      __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/worker.c", "probe_varref_create_ctx", (unsigned long int)212, "Unexpected error: variable id \"%s\" not found in varrefs.", var_id);
      free((void *)var_id);
      __SEXP_vfree(5, vid, ent_name, vidx_name, vidx_val, (void *)0);
      probe_varref_destroy_ctx(ctx);
      return -1;
    }

    SEXP_free(vid);
    r0=SEXP_list_nth(varref, (unsigned int)2);
    val_cnt=SEXP_number_getu_32(r0);
    val_lst=SEXP_list_nth(varref, (unsigned int)3);
    __SEXP_vfree(3, varref, r0, (void *)0);
    ent=SEXP_list_new(ent_name, val_lst, (void *)0);
    __SEXP_vfree(3, ent_name, val_lst, (void *)0);
    r0=SEXP_list_replace(ctx->pi2, i + (unsigned int)2, ent);
    __SEXP_vfree(3, r0, ent, (void *)0);
    r0=SEXP_listref_nth(ctx->pi2, i + (unsigned int)2);
    (ctx->ent_lst + (signed long int)i)->ent_name_sref=SEXP_listref_first(r0);
    SEXP_free(r0);
    (ctx->ent_lst + (signed long int)i)->val_cnt = val_cnt;
    (ctx->ent_lst + (signed long int)i)->next_val_idx = (unsigned int)0;
  }
  __SEXP_vfree(3, vidx_name, vidx_val, (void *)0);
  *octx = ctx;
  return 0;
}

// probe_varref_destroy_ctx
// file ../../../../../src/OVAL/probes/probe/worker.c line 246
static void probe_varref_destroy_ctx(struct probe_varref_ctx *ctx)
{
  struct probe_varref_ctx_ent *ent;
  struct probe_varref_ctx_ent *ent_end;
  SEXP_free(ctx->pi2);
  ent = ctx->ent_lst;
  ent_end = ent + (signed long int)ctx->ent_cnt;
  for( ; !(ent == ent_end); ent = ent + 1l)
    SEXP_free(ent->ent_name_sref);
  free((void *)ctx->ent_lst);
  free((void *)ctx);
}

// probe_varref_iterate_ctx
// file ../../../../../src/OVAL/probes/probe/worker.c line 264
static signed int probe_varref_iterate_ctx(struct probe_varref_ctx *ctx)
{
  unsigned int val_cnt;
  unsigned int *next_val_idx;
  struct SEXP *ent_name_sref;
  struct SEXP *r0;
  struct SEXP *r1;
  struct SEXP *r2;
  struct probe_varref_ctx_ent *ent;
  struct probe_varref_ctx_ent *ent_end;
  ent = ctx->ent_lst;
  ent_end = ent + (signed long int)ctx->ent_cnt;
  val_cnt = ent->val_cnt;
  next_val_idx = &ent->next_val_idx;
  ent_name_sref = ent->ent_name_sref;
  r0=SEXP_number_newu_32((unsigned int)0);
  do
  {
    *next_val_idx = *next_val_idx + 1u;
    if(!(*next_val_idx >= val_cnt))
      break;

    ent = ent + 1l;
    if(ent == ent_end)
    {
      SEXP_free(r0);
      return 0;
    }

    *next_val_idx = (unsigned int)0;
    r1=SEXP_list_replace(ent_name_sref, (unsigned int)3, r0);
    SEXP_free(r1);
    val_cnt = ent->val_cnt;
    next_val_idx = &ent->next_val_idx;
    ent_name_sref = ent->ent_name_sref;
  }
  while((_Bool)1);
  r2=SEXP_number_newu_32(*next_val_idx);
  r1=SEXP_list_replace(ent_name_sref, (unsigned int)3, r2);
  __SEXP_vfree(4, r0, r1, r2, (void *)0);
  return 1;
}

// probe_worker
// file ../../../../../src/OVAL/probes/probe/worker.h line 52
struct SEXP * probe_worker(struct anonymous$23 *probe, struct SEAP_msg *msg_in, signed int *ret)
{
  struct SEXP *probe_in;
  struct SEXP *probe_out;
  struct SEXP *set;
  _Bool tmp_if_expr$3;
  signed int return_value_probe_varref_iterate_ctx$2;
  if(msg_in == ((struct SEAP_msg *)NULL))
  {
    *ret = 1;
    return (struct SEXP *)(void *)0;
  }

  else
  {
    probe_in=SEAP_msg_get(msg_in);
    probe_out = (struct SEXP *)(void *)0;
    if(probe_in == ((struct SEXP *)NULL))
    {
      *ret = 14;
      return (struct SEXP *)(void *)0;
    }

    else
    {
      set=probe_obj_getent(probe_in, "set", (unsigned int)1);
      if(!(set == ((struct SEXP *)NULL)))
      {
        probe_out=probe_set_eval(probe, set, (unsigned long int)0);
        SEXP_free(set);
        *ret = 0;
      }

      else
      {
        struct probe_ctx pctx;
        struct SEXP *varrefs;
        struct SEXP *mask;
        pctx.icache = probe->icache;
        pctx.filters=probe_prepare_filters(probe, probe_in);
        mask=probe_obj_getmask(probe_in);
        if(!(___G_varref_handling == (_Bool)0))
          varrefs=probe_obj_getent(probe_in, "varrefs", (unsigned int)1);

        else
          varrefs = (struct SEXP *)(void *)0;
        if(___G_varref_handling == (_Bool)0 || varrefs == ((struct SEXP *)NULL))
        {
          probe_out=probe_cobj_new((enum anonymous$8)SYSCHAR_FLAG_UNKNOWN, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0, mask);
          SEXP_free(mask);
          pctx.probe_in = probe_in;
          pctx.probe_out = probe_out;
          signed int __unused_oldstate;
          pthread_setcanceltype(1, &__unused_oldstate);
          *ret=probe_main(&pctx, probe->probe_arg);
          pthread_setcanceltype(0, &__unused_oldstate);
          probe_icache_nop(probe->icache);
          probe_cobj_compute_flag(probe_out);
        }

        else
        {
          struct probe_varref_ctx *ctx;
          __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_worker", (unsigned long int)969, "handling varrefs in object");
          signed int return_value_probe_varref_create_ctx$1;
          return_value_probe_varref_create_ctx$1=probe_varref_create_ctx(probe_in, varrefs, &ctx);
          if(!(return_value_probe_varref_create_ctx$1 == 0))
          {
            __SEXP_vfree(5, varrefs, pctx.filters, probe_in, mask, (void *)0);
            *ret = 255;
            return (struct SEXP *)(void *)0;
          }

          SEXP_free(varrefs);
          do
          {
            struct SEXP *cobj;
            struct SEXP *r0;
            cobj=probe_cobj_new((enum anonymous$8)SYSCHAR_FLAG_UNKNOWN, (struct SEXP *)(void *)0, (struct SEXP *)(void *)0, mask);
            pctx.probe_in = ctx->pi2;
            pctx.probe_out = cobj;
            *ret=probe_main(&pctx, probe->probe_arg);
            probe_icache_nop(probe->icache);
            probe_cobj_compute_flag(cobj);
            r0 = probe_out;
            probe_out=probe_set_combine(r0, cobj, (enum anonymous$34)OVAL_SET_OPERATION_UNION);
            __SEXP_vfree(3, cobj, r0, (void *)0);
            if(*ret == 0)
            {
              return_value_probe_varref_iterate_ctx$2=probe_varref_iterate_ctx(ctx);
              tmp_if_expr$3 = return_value_probe_varref_iterate_ctx$2 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$3 = (_Bool)0;
          }
          while(tmp_if_expr$3);
          SEXP_free(mask);
          probe_varref_destroy_ctx(ctx);
        }
        SEXP_free(pctx.filters);
      }
      SEXP_free(probe_in);
      return probe_out;
    }
  }
}

// probe_worker_new
// file ../../../../../src/OVAL/probes/probe/worker.h line 50
struct anonymous$31 * probe_worker_new(void)
{
  struct anonymous$31 *pth;
  void *return_value___oscap_alloc$1;
  return_value___oscap_alloc$1=__oscap_alloc(sizeof(struct anonymous$31) /*32ul*/ );
  pth = (struct anonymous$31 *)return_value___oscap_alloc$1;
  pth->sid = (unsigned int)0;
  pth->tid = (unsigned long int)0;
  pth->msg_handler = (struct SEXP * (*)(struct anonymous$23 *, struct SEAP_msg *, signed int *))(void *)0;
  pth->msg = (struct SEAP_msg *)(void *)0;
  return pth;
}

// probe_worker_runfn
// file ../../../../../src/OVAL/probes/probe/worker.h line 51
void * probe_worker_runfn(void *arg)
{
  struct anonymous$32 *pair = (struct anonymous$32 *)arg;
  struct SEXP *probe_res;
  struct SEXP *obj;
  struct SEXP *oid;
  signed int probe_ret;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_setname_np(return_value_pthread_self$1, "probe_worker");
  __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_worker_runfn", (unsigned long int)51, "handling SEAP message ID %u", pair->pth->sid);
  probe_ret = -1;
  probe_res=pair->pth->msg_handler(pair->probe, pair->pth->msg, &probe_ret);
  __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_worker_runfn", (unsigned long int)56, "handler result = %p, return code = %d", probe_res, probe_ret);
  signed int return_value_rbt_i32_del$3;
  return_value_rbt_i32_del$3=rbt_i32_del(pair->probe->workers, (signed int)pair->pth->sid, (void **)(void *)0);
  if(!(return_value_rbt_i32_del$3 == 0))
  {
    __oscap_dlprintf(DBG_W, "../../../../../src/OVAL/probes/probe/worker.c", "probe_worker_runfn", (unsigned long int)60, "thread not found in the probe thread tree, probably canceled by an external signal");
    arg = (void *)0;
    SEAP_msg_free(pair->pth->msg);
    SEXP_free(probe_res);
    __oscap_free((void *)pair);
    return (void *)0;
  }

  else
  {
    struct SEXP *items;
    __oscap_dlprintf(DBG_I, "../../../../../src/OVAL/probes/probe/worker.c", "probe_worker_runfn", (unsigned long int)75, "probe thread deleted");
    obj=SEAP_msg_get(pair->pth->msg);
    oid=probe_obj_getattrval(obj, "id");
    items=probe_cobj_get_items(probe_res);
    if(!(items == ((struct SEXP *)NULL)))
    {
      SEXP_list_sort(items, SEXP_refcmp);
      SEXP_free(items);
    }

    signed int return_value_probe_rcache_sexp_add$2;
    return_value_probe_rcache_sexp_add$2=probe_rcache_sexp_add(pair->probe->rcache, oid, probe_res);
    if(!(return_value_probe_rcache_sexp_add$2 == 0))
      abort();

    __SEXP_vfree(3, obj, oid, (void *)0);
  }
  if(!(probe_ret == 0))
  {
    signed int return_value_SEAP_replyerr$8;
    return_value_SEAP_replyerr$8=SEAP_replyerr(pair->probe->SEAP_ctx, pair->probe->sd, pair->pth->msg, (unsigned int)probe_ret);
    if(return_value_SEAP_replyerr$8 == -1)
    {
      signed int ret;
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      ret = *return_value___errno_location$4;
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      __oscap_dlprintf(DBG_E, "../../../../../src/OVAL/probes/probe/worker.c", "probe_worker_runfn", (unsigned long int)102, "An error ocured while sending error status. errno=%u, %s.", *return_value___errno_location$5, return_value_strerror$7);
      SEXP_free(probe_res);
      exit(ret);
    }

    SEXP_free(probe_res);
  }

  else
  {
    struct SEAP_msg *seap_reply;
    seap_reply=SEAP_msg_new();
    SEAP_msg_set(seap_reply, probe_res);
    signed int return_value_SEAP_reply$10;
    return_value_SEAP_reply$10=SEAP_reply(pair->probe->SEAP_ctx, pair->probe->sd, seap_reply, pair->pth->msg);
    if(return_value_SEAP_reply$10 == -1)
    {
      signed int probe_worker_runfn$$1$$4$$1$$ret;
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      probe_worker_runfn$$1$$4$$1$$ret = *return_value___errno_location$9;
      SEAP_msg_free(seap_reply);
      SEXP_free(probe_res);
      exit(probe_worker_runfn$$1$$4$$1$$ret);
    }

    SEAP_msg_free(seap_reply);
    SEXP_free(probe_res);
  }
  SEAP_msg_free(pair->pth->msg);
  __oscap_free((void *)pair->pth);
  __oscap_free((void *)pair);
  unsigned long int return_value_pthread_self$11;
  return_value_pthread_self$11=pthread_self();
  pthread_detach(return_value_pthread_self$11);
  return (void *)0;
}

// read_common_sizet
// file ../../../src/common/memusage.c line 41
static signed int read_common_sizet(void *szp, char *strval)
{
  char *end;
  while((_Bool)0)
    ;
  while((_Bool)0)
    ;
  end=strchr(strval, 32);
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if(end == ((char *)NULL))
    return -1;

  else
  {
    *end = (char)0;
    signed long long int return_value_strtoll$1;
    return_value_strtoll$1=strtoll(strval, (char ** restrict )(void *)0, 10);
    *((unsigned long int *)szp) = (unsigned long int)return_value_strtoll$1;
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 22)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value___errno_location$3=__errno_location();
      tmp_if_expr$4 = *return_value___errno_location$3 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      return -1;

    else
      return 0;
  }
}

// read_status
// file ../../../src/common/memusage.c line 74
static signed int read_status(const char *source, void *base, struct stat_parser *spt, unsigned long int spt_size)
{
  struct _IO_FILE *fp;
  unsigned long int processed;
  fp=fopen(source, "r");
  char *return_value_fgets$1;
  char *tmp_post$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  char *return_value_strchr$5;
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    char linebuf[256l];
    char *strval;
    struct stat_parser *sp;
    processed = (unsigned long int)0;
    do
    {
      return_value_fgets$1=fgets(linebuf, (signed int)(sizeof(char [256l]) /*256ul*/  - (unsigned long int)1), fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      strval=strchr(linebuf, 58);
      if(strval == ((char *)NULL))
      {
        fclose(fp);
        return -1;
      }

      tmp_post$2 = strval;
      strval = strval + 1l;
      *tmp_post$2 = (char)0;
      do
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*strval]) == 0)
          break;

        strval = strval + 1l;
      }
      while((_Bool)1);
      void *return_value_oscap_bfind$4;
      return_value_oscap_bfind$4=oscap_bfind((void *)spt, spt_size, sizeof(struct stat_parser) /*24ul*/ , (void *)linebuf, (signed int (*)(void *, void *))cmpkey);
      sp = (struct stat_parser *)return_value_oscap_bfind$4;
      __oscap_dlprintf(DBG_I, "../../../src/common/memusage.c", "read_status", (unsigned long int)120, "spt: %s", (const void *)linebuf);
      if(sp == ((struct stat_parser *)NULL))
      {
        do
        {
          return_value_strchr$5=strchr(strval, 10);
          if(!(return_value_strchr$5 == ((char *)NULL)))
            break;

          linebuf[(signed long int)0] = (char)10;
          fgets(linebuf, (signed int)(sizeof(char [256l]) /*256ul*/  - (unsigned long int)1), fp);
          strval = linebuf;
        }
        while((_Bool)1);
        continue;
      }

      char *return_value_strchr$6;
      return_value_strchr$6=strchr(strval, 10);
      if(return_value_strchr$6 == ((char *)NULL))
      {
        __oscap_dlprintf(DBG_E, "../../../src/common/memusage.c", "read_status", (unsigned long int)134, "value for %s key is too long", (const void *)linebuf);
        fclose(fp);
        return -1;
      }

      signed int return_value;
      return_value=sp->storval((void *)((unsigned long int)base + (unsigned long int)sp->offset), strval);
      if(!(return_value == 0))
      {
        fclose(fp);
        return -1;
      }

      processed = processed + 1ul;
    }
    while((_Bool)1);
    fclose(fp);
  }
  return processed == spt_size ? 0 : 1;
}

// results_parser
// file ../../../../../src/OVAL/probes/probe/entcmp.c line 457
static signed int results_parser(struct SEXP *res_lst, struct _oresults *ores)
{
  enum anonymous$18 r;
  struct SEXP *res;
  memset((void *)ores, 0, sizeof(struct _oresults) /*24ul*/ );
  unsigned int i464 = (unsigned int)1;
  do
  {
    res=SEXP_list_nth(res_lst, i464);
    if(res == ((struct SEXP *)NULL))
      break;

    signed int return_value_SEXP_number_geti_32$1;
    return_value_SEXP_number_geti_32$1=SEXP_number_geti_32(res);
    r = (enum anonymous$18)return_value_SEXP_number_geti_32$1;
    switch((signed int)r)
    {
      case OVAL_RESULT_TRUE:
      {
        ores->true_cnt = ores->true_cnt + 1;
        break;
      }
      case OVAL_RESULT_FALSE:
      {
        ores->false_cnt = ores->false_cnt + 1;
        break;
      }
      case OVAL_RESULT_UNKNOWN:
      {
        ores->unknown_cnt = ores->unknown_cnt + 1;
        break;
      }
      case OVAL_RESULT_ERROR:
      {
        ores->error_cnt = ores->error_cnt + 1;
        break;
      }
      case OVAL_RESULT_NOT_EVALUATED:
      {
        ores->noteval_cnt = ores->noteval_cnt + 1;
        break;
      }
      case OVAL_RESULT_NOT_APPLICABLE:
      {
        ores->notappl_cnt = ores->notappl_cnt + 1;
        break;
      }
      default:
        return -1;
    }
    i464 = i464 + 1u;
    SEXP_free(res);
    res = (struct SEXP *)(void *)0;
  }
  while((_Bool)1);
  return 0;
}

// risdigit
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 46
static signed int risdigit(signed int c)
{
  return (signed int)(c >= 48 && c <= 57);
}

// rpmevrcmp
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 78
static inline signed int rpmevrcmp(const char *a, const char *b)
{
  const char *a_epoch;
  const char *a_version;
  const char *a_release;
  const char *b_epoch;
  const char *b_version;
  const char *b_release;
  char *a_copy;
  char *b_copy;
  signed int result;
  a_copy=oscap_strdup(a);
  b_copy=oscap_strdup(b);
  parseEVR(a_copy, &a_epoch, &a_version, &a_release);
  parseEVR(b_copy, &b_epoch, &b_version, &b_release);
  result=compare_values(a_epoch, b_epoch);
  if(result == 0)
  {
    result=compare_values(a_version, b_version);
    if(result == 0)
      result=compare_values(a_release, b_release);

  }

  __oscap_free((void *)a_copy);
  __oscap_free((void *)b_copy);
  return result;
}

// rpmvercmp
// file ../../../../src/OVAL/results/oval_cmp_evr_string.c line 164
static signed int rpmvercmp(const char *a, const char *b)
{
  char oldch1;
  char oldch2;
  char *str1;
  char *str2;
  char *one;
  char *two;
  signed int rc;
  signed int isnum;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(a, b);
  const unsigned short int **return_value___ctype_b_loc$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  _Bool tmp_if_expr$8;
  const unsigned short int **return_value___ctype_b_loc$9;
  const unsigned short int **return_value___ctype_b_loc$10;
  const unsigned short int **return_value___ctype_b_loc$11;
  const unsigned short int **return_value___ctype_b_loc$12;
  if(return_value_strcmp$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(a);
    void *return_value___builtin_alloca$3;
    return_value___builtin_alloca$3=__builtin_alloca(return_value_strlen$2 + (unsigned long int)1);
    str1 = (char *)return_value___builtin_alloca$3;
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(b);
    void *return_value___builtin_alloca$5;
    return_value___builtin_alloca$5=__builtin_alloca(return_value_strlen$4 + (unsigned long int)1);
    str2 = (char *)return_value___builtin_alloca$5;
    strcpy(str1, a);
    strcpy(str2, b);
    one = str1;
    two = str2;
    while(!(*one == 0))
    {
      if(*two == 0)
        break;

      for( ; !(*one == 0); one = one + 1l)
      {
        return_value___ctype_b_loc$6=__ctype_b_loc();
        if(!((8 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*one]) == 0))
          break;

      }
      for( ; !(*two == 0); two = two + 1l)
      {
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if(!((8 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*two]) == 0))
          break;

      }
      if(!(*one == 0))
        tmp_if_expr$8 = *two != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      if(!tmp_if_expr$8)
        break;

      str1 = one;
      str2 = two;
      const unsigned short int **return_value___ctype_b_loc$13;
      return_value___ctype_b_loc$13=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)*str1]) == 0))
      {
        for( ; !(*str1 == 0); str1 = str1 + 1l)
        {
          return_value___ctype_b_loc$9=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)*str1]) == 0)
            break;

        }
        for( ; !(*str2 == 0); str2 = str2 + 1l)
        {
          return_value___ctype_b_loc$10=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)*str2]) == 0)
            break;

        }
        isnum = 1;
      }

      else
      {
        for( ; !(*str1 == 0); str1 = str1 + 1l)
        {
          return_value___ctype_b_loc$11=__ctype_b_loc();
          if((1024 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)*str1]) == 0)
            break;

        }
        for( ; !(*str2 == 0); str2 = str2 + 1l)
        {
          return_value___ctype_b_loc$12=__ctype_b_loc();
          if((1024 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)*str2]) == 0)
            break;

        }
        isnum = 0;
      }
      oldch1 = *str1;
      *str1 = (char)0;
      oldch2 = *str2;
      *str2 = (char)0;
      if(one == str1)
        return -1;

      if(two == str2)
        return isnum != 0 ? 1 : -1;

      if(!(isnum == 0))
      {
        for( ; (signed int)*one == 48; one = one + 1l)
          ;
        for( ; (signed int)*two == 48; two = two + 1l)
          ;
        unsigned long int return_value_strlen$14;
        return_value_strlen$14=strlen(one);
        unsigned long int return_value_strlen$15;
        return_value_strlen$15=strlen(two);
        if(!(return_value_strlen$15 >= return_value_strlen$14))
          return 1;

        unsigned long int return_value_strlen$16;
        return_value_strlen$16=strlen(two);
        unsigned long int return_value_strlen$17;
        return_value_strlen$17=strlen(one);
        if(!(return_value_strlen$17 >= return_value_strlen$16))
          return -1;

      }

      rc=strcmp(one, two);
      if(!(rc == 0))
        return rc < 1 ? -1 : 1;

      *str1 = oldch1;
      one = str1;
      *str2 = oldch2;
      two = str2;
    }
    if(*one == 0)
    {
      if(!(*two == 0))
        goto __CPROVER_DUMP_L25;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L25:
      ;
      if(*one == 0)
        return -1;

      else
        return 1;
    }
  }
}

// strregcomp
// file ../../../../src/OVAL/results/oval_cmp_basic.c line 127
static enum anonymous$18 strregcomp(const char *pattern, const char *test_str)
{
  signed int ret;
  enum anonymous$18 result = (enum anonymous$18)OVAL_RESULT_ERROR;
  struct real_pcre *re;
  const char *err;
  signed int errofs;
  re=pcre_compile(pattern, 0x00000800, &err, &errofs, (const unsigned char *)(void *)0);
  if(re == ((struct real_pcre *)NULL))
  {
    __oscap_dlprintf(DBG_E, "../../../../src/OVAL/results/oval_cmp_basic.c", "strregcomp", (unsigned long int)139, "Unable to compile regex pattern, pcre_compile() returned error (offset: %d): '%s'.\n", errofs, err);
    return (enum anonymous$18)OVAL_RESULT_ERROR;
  }

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(test_str);
    ret=pcre_exec(re, (const struct pcre_extra *)(void *)0, test_str, (signed int)return_value_strlen$1, 0, 0, (signed int *)(void *)0, 0);
    if(ret >= 0)
      result = (enum anonymous$18)OVAL_RESULT_TRUE;

    else
      if(ret == -1)
        result = (enum anonymous$18)OVAL_RESULT_FALSE;

      else
      {
        __oscap_dlprintf(DBG_E, "../../../../src/OVAL/results/oval_cmp_basic.c", "strregcomp", (unsigned long int)150, "Unable to match regex pattern, pcre_exec() returned error: %d.\n", ret);
        result = (enum anonymous$18)OVAL_RESULT_ERROR;
      }
    pcre_free((void *)re);
    return result;
  }
}

// write_to_memory_callback
// file ../../../src/common/oscap_acquire.c line 175
unsigned long int write_to_memory_callback(char *ptr, unsigned long int size, unsigned long int nmemb, void *userdata)
{
  unsigned long int new_received_size = size * nmemb;
  oscap_buffer_append_binary_data((struct oscap_buffer *)userdata, ptr, new_received_size);
  return new_received_size;
}

// xmlTextReaderNextElement
// file ../../../src/common/xmltext_priv.c line 29
signed int xmlTextReaderNextElement(struct _xmlTextReader *reader)
{
  signed int ret;
  signed int return_value_xmlTextReaderNodeType$1;
  do
  {
    ret=xmlTextReaderRead(reader);
    if(!(ret >= 1))
      break;

    return_value_xmlTextReaderNodeType$1=xmlTextReaderNodeType(reader);
  }
  while(!(return_value_xmlTextReaderNodeType$1 == 1));
  if(ret == -1)
  {
    struct _xmlError *return_value_xmlCtxtGetLastError$2;
    return_value_xmlCtxtGetLastError$2=xmlCtxtGetLastError((void *)reader);
    __oscap_setxmlerr("../../../src/common/xmltext_priv.c", (unsigned int)42, "xmlTextReaderNextElement", return_value_xmlCtxtGetLastError$2);
  }

  return ret;
}

// xmlTextReaderNextElementWE
// file ../../../src/common/xmltext_priv.c line 60
signed int xmlTextReaderNextElementWE(struct _xmlTextReader *reader, unsigned char *end_tag)
{
  signed int ret;
  signed int return_value_xmlTextReaderNodeType$1;
  do
  {
    ret=xmlTextReaderRead(reader);
    if(!(ret >= 1))
      break;

    signed int return_value_xmlTextReaderNodeType$4;
    return_value_xmlTextReaderNodeType$4=xmlTextReaderNodeType(reader);
    if(return_value_xmlTextReaderNodeType$4 == 15)
    {
      const unsigned char *return_value_xmlTextReaderConstLocalName$2;
      return_value_xmlTextReaderConstLocalName$2=xmlTextReaderConstLocalName(reader);
      signed int return_value_xmlStrcmp$3;
      return_value_xmlStrcmp$3=xmlStrcmp(return_value_xmlTextReaderConstLocalName$2, end_tag);
      if(return_value_xmlStrcmp$3 == 0)
      {
        ret = 0;
        break;
      }

    }

    return_value_xmlTextReaderNodeType$1=xmlTextReaderNodeType(reader);
  }
  while(!(return_value_xmlTextReaderNodeType$1 == 1));
  if(ret == -1)
  {
    struct _xmlError *return_value_xmlCtxtGetLastError$5;
    return_value_xmlCtxtGetLastError$5=xmlCtxtGetLastError((void *)reader);
    __oscap_setxmlerr("../../../src/common/xmltext_priv.c", (unsigned int)80, "xmlTextReaderNextElementWE", return_value_xmlCtxtGetLastError$5);
  }

  return ret;
}

// xmlTextReaderNextNode
// file ../../../src/common/xmltext_priv.c line 49
signed int xmlTextReaderNextNode(struct _xmlTextReader *reader)
{
  signed int ret;
  ret=xmlTextReaderRead(reader);
  struct _xmlError *return_value_xmlGetLastError$1;
  if(ret == -1)
  {
    return_value_xmlGetLastError$1=xmlGetLastError();
    __oscap_setxmlerr("../../../src/common/xmltext_priv.c", (unsigned int)55, "xmlTextReaderNextNode", return_value_xmlGetLastError$1);
  }

  return ret;
}

// xml_element_dfs_callback
// file ../../../src/common/xml_iterate.c line 29
static signed int xml_element_dfs_callback(struct _xmlNode **node, signed int (*user_fn)(struct _xmlNode **, void *), void *user_data)
{
  signed int result;
  result=user_fn(node, user_data);
  if(result == 1)
    return result;

  else
  {
    struct _xmlNode *child = (*node)->children;
    if(!(child == ((struct _xmlNode *)NULL)))
    {
      signed int res;
      res=xml_element_dfs_callback(&child, user_fn, user_data);
      if(res == 1)
        return res;

      if(result == 0)
        result = res;

      child = child->next;
    }

    return result;
  }
}

// xml_iterate_dfs
// file ../../../src/common/xml_iterate.c line 46
signed int xml_iterate_dfs(const char *input_text, char **output_text, signed int (*user_fn)(struct _xmlNode **, void *), void *user_data)
{
  char *input_document = (char *)(void *)0;
  struct _xmlDoc *doc = (struct _xmlDoc *)(void *)0;
  struct _xmlNode *root = (struct _xmlNode *)(void *)0;
  signed int res = 0;
  if(user_fn == ((signed int (*)(struct _xmlNode **, void *))NULL))
    return 1;

  else
  {
    input_document=oscap_sprintf("<x xmlns='http://www.w3.org/1999/xhtml'>%s</x>", input_text);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(input_document);
    doc=xmlParseMemory(input_document, (signed int)return_value_strlen$1);
    if(doc == ((struct _xmlDoc *)NULL))
    {
      __oscap_dlprintf(DBG_W, "../../../src/common/xml_iterate.c", "xml_iterate_dfs", (unsigned long int)58, "Could not xmlParseMemory: '%s'", input_document);
      free((void *)input_document);
      return 1;
    }

    else
    {
      root=xmlDocGetRootElement(doc);
      if(root == ((struct _xmlNode *)NULL))
      {
        __oscap_dlprintf(DBG_W, "../../../src/common/xml_iterate.c", "xml_iterate_dfs", (unsigned long int)63, "Could not xmlDocGetRootElement: '%s'", input_document);
        xmlFreeDoc(doc);
        free((void *)input_document);
        return 1;
      }

      else
      {
        free((void *)input_document);
        res=xml_element_dfs_callback(&root, user_fn, user_data);
        if(!(output_text == ((char **)NULL)))
        {
          root=xmlDocGetRootElement(doc);
          if(root == ((struct _xmlNode *)NULL))
          {
            __oscap_dlprintf(DBG_W, "../../../src/common/xml_iterate.c", "xml_iterate_dfs", (unsigned long int)74, "Could not get xmlDocGetRootElement of result document.");
            xmlFreeDoc(doc);
            return 1;
          }

          struct _xmlBuffer *buff;
          buff=xmlBufferCreate();
          struct _xmlNode *child = root->children;
          while(!(child == ((struct _xmlNode *)NULL)))
          {
            signed int size;
            size=xmlNodeDump(buff, doc, child, 0, 0);
            if(size == 0)
              __oscap_dlprintf(DBG_W, "../../../src/common/xml_iterate.c", "xml_iterate_dfs", (unsigned long int)83, "xmlBufNodeDump returns zero.");

            child = child->next;
          }
          const unsigned char *return_value_xmlBufferContent$2;
          return_value_xmlBufferContent$2=xmlBufferContent(buff);
          *output_text=oscap_strdup((const char *)return_value_xmlBufferContent$2);
          xmlBufferFree(buff);
        }

        xmlFreeDoc(doc);
        return res;
      }
    }
  }
}

