// tag-#anon#ST[*{SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#$'rfds'||*{SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#$'xfds'||*{SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#$'wfds'|]
// file libslack/agent.c line 165
struct anonymous$24;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$20;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$18;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$10;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$6;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous$13;

// tag-#anon#ST[S32'init'||U32'$pad0'||*{SYM#tag-Prop#}$SYM#tag-Prop#$'prop'||*{S8}$S8$'home'||S32'dirty'||U32'$pad1'||*{SYM#tag-Locker#}$SYM#tag-Locker#$'locker'|]
// file libslack/prop.c line 133
struct anonymous$5;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous$7;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$17;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$16;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$22;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$15;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$19;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'||*{S8}$S8$'pidfile'|]
// file libslack/daemon.c line 104
struct anonymous$26;

// tag-#anon#UN[*{S8}$S8$'ifcu_buf'||*{SYM#tag-ifreq#}$SYM#tag-ifreq#$'ifcu_req'|]
// file /usr/include/net/if.h line 179
union anonymous$2;

// tag-#anon#UN[*{SYM#tag-pollfd#}$SYM#tag-pollfd#$'pfds'||SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#$'rfds'||*{SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#$'xfds'||*{SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]#$'wfds'|]#'s'|]
// file libslack/agent.c line 160
union anonymous$23;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$9;

// tag-#anon#UN[ARR16{S8}$S8$'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous$0;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$21;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous$12;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$11;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}$S8$'ifru_slave'||ARR16{S8}$S8$'ifru_newname'||*{S8}$S8$'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous$1;

// tag-#anon#cST[ARR19{SYM#tag-conf_t#}$SYM#tag-conf_t#$'conf'|]
// file libslack/lim.c line 130
struct anonymous$27;

// tag-Agent
// file libslack/agent.h line 30
struct Agent;

// tag-List
// file libslack/list.h line 34
struct List;

// tag-Lister
// file libslack/list.h line 35
struct Lister;

// tag-Locker
// file libslack/slack/locker.h line 31
struct Locker;

// tag-Map
// file libslack/map.h line 31
struct Map;

// tag-Mapper
// file libslack/map.h line 32
struct Mapper;

// tag-Mapping
// file libslack/map.h line 33
struct Mapping;

// tag-Msg
// file libslack/msg.h line 38
struct Msg;

// tag-MsgFileData
// file libslack/msg.c line 117
struct MsgFileData;

// tag-MsgPlexData
// file libslack/msg.c line 119
struct MsgPlexData;

// tag-MsgSyslogData
// file libslack/msg.c line 118
struct MsgSyslogData;

// tag-Option
// file libslack/prog.h line 43
struct Option;

// tag-OptionAction
// file libslack/prog.h line 60
enum OptionAction { OPT_NOTHING=0, OPT_VARIABLE=1, OPT_FUNCTION=2 };

// tag-OptionArgument
// file libslack/prog.h line 53
enum OptionArgument { OPT_NONE=0, OPT_INTEGER=1, OPT_STRING=2 };

// tag-Options
// file libslack/prog.h line 44
struct Options;

// tag-Point
// file libslack/map.c line 2420
struct Point;

// tag-Pool
// file libslack/mem.h line 40
struct Pool;

// tag-Prog
// file libslack/prog.c line 201
struct Prog;

// tag-Prop
// file libslack/prop.c line 123
struct Prop;

// tag-String
// file libslack/str.h line 36
struct String;

// tag-StringAlignment
// file libslack/str.h line 39
enum StringAlignment { ALIGN_LEFT=60, ALIGN_RIGHT=62, ALIGN_CENTRE=124, ALIGN_CENTER=124, ALIGN_FULL=61 };

// tag-StringTR
// file libslack/str.h line 37
struct StringTR;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-action_t
// file libslack/agent.c line 144
struct action_t;

// tag-activity_t
// file libslack/agent.c line 146
struct activity_t;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-conf_t
// file libslack/lim.c line 119
struct conf_t;

// tag-dlink_t
// file libslack/link.h line 30
struct dlink_t;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip_mreq
// file /usr/include/netinet/in.h line 264
struct ip_mreq;

// tag-ipv6_mreq
// file /usr/include/netinet/in.h line 288
struct ipv6_mreq;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-net_interface_t
// file libslack/net.h line 48
struct net_interface_t;

// tag-option
// file libslack/getopt.h line 83
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-reaction_t
// file libslack/agent.c line 145
struct reaction_t;

// tag-real_signal_handler_t
// file libslack/sig.c line 98
struct real_signal_handler_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rudp_t
// file libslack/net.h line 49
struct rudp_t;

// tag-servent
// file /usr/include/netdb.h line 257
struct servent;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-slink_t
// file libslack/link.h line 29
struct slink_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_any_t
// file libslack/net.h line 41
union sockaddr_any_t;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-sockopt_t
// file libslack/net.h line 39
struct sockopt_t;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-syslog_map_t
// file libslack/msg.c line 153
struct syslog_map_t;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timewheel_t
// file libslack/agent.c line 143
struct timewheel_t;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __ctype_tolower_loc
// file /usr/include/ctype.h line 81
extern const signed int ** __ctype_tolower_loc(void);
// __ctype_toupper_loc
// file /usr/include/ctype.h line 83
extern const signed int ** __ctype_toupper_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 398
extern signed int __fxstat(signed int, signed int, struct stat *);
// __lxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 402
extern signed int __lxstat(signed int, const char *, struct stat *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 947
static inline unsigned long int __strcspn_c1(const char *__s, signed int __reject);
// __strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 958
static inline unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2);
// __strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
static inline unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3);
// __uflow
// file /usr/include/libio.h line 391
extern signed int __uflow(struct _IO_FILE *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// act
// file libslack/agent.c line 1927
static signed int act(signed int (*action)(struct Agent *, void *), struct Agent *agent, void *arg);
// act::action$object
// 
//signed int action$object(struct Agent *, void *);
// adjust
// file libslack/list.c line 318
static signed int adjust(struct List *list, signed long int index, unsigned long int range, unsigned long int length);
// adjust$link1
// file libslack/str.c line 497
static signed int adjust$link1(struct String *str, signed long int index$link1, unsigned long int range$link1, unsigned long int length$link1);
// agent_acceleration
// file libslack/agent.c line 1423
signed int agent_acceleration(struct Agent *agent, signed int fd);
// agent_acceleration_unlocked
// file libslack/agent.c line 1452
signed int agent_acceleration_unlocked(struct Agent *agent, signed int fd);
// agent_cancel
// file libslack/agent.c line 1740
signed int agent_cancel(struct Agent *agent, void *action_id);
// agent_cancel_unlocked
// file libslack/agent.c line 1768
signed int agent_cancel_unlocked(struct Agent *agent, void *action_id);
// agent_connect
// file libslack/agent.c line 620
signed int agent_connect(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_connect::reaction$object
// 
signed int reaction$object(struct Agent *, signed int, signed int, void *);
// agent_connect_unlocked
// file libslack/agent.c line 648
signed int agent_connect_unlocked(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_connect_unlocked::reaction$object
// 
signed int reaction$object(struct Agent *, signed int, signed int, void *);
// agent_create
// file libslack/agent.c line 325
struct Agent * agent_create(void);
// agent_create_measured
// file libslack/agent.c line 386
struct Agent * agent_create_measured(void);
// agent_create_measured_with_locker
// file libslack/agent.c line 402
struct Agent * agent_create_measured_with_locker(struct Locker *locker);
// agent_create_using_select
// file libslack/agent.c line 442
struct Agent * agent_create_using_select(void);
// agent_create_using_select_with_locker
// file libslack/agent.c line 458
struct Agent * agent_create_using_select_with_locker(struct Locker *locker);
// agent_create_with_locker
// file libslack/agent.c line 341
struct Agent * agent_create_with_locker(struct Locker *locker);
// agent_dadt
// file libslack/agent.c line 1507
signed int agent_dadt(struct Agent *agent, signed int fd);
// agent_dadt_unlocked
// file libslack/agent.c line 1535
signed int agent_dadt_unlocked(struct Agent *agent, signed int fd);
// agent_destroy
// file libslack/agent.c line 526
void * agent_destroy(struct Agent **agent);
// agent_detail
// file libslack/agent.c line 1192
signed int agent_detail(struct Agent *agent, signed int fd);
// agent_detail_unlocked
// file libslack/agent.c line 1220
signed int agent_detail_unlocked(struct Agent *agent, signed int fd);
// agent_disconnect
// file libslack/agent.c line 811
signed int agent_disconnect(struct Agent *agent, signed int fd);
// agent_disconnect_unlocked
// file libslack/agent.c line 840
signed int agent_disconnect_unlocked(struct Agent *agent, signed int fd);
// agent_last
// file libslack/agent.c line 1262
struct timeval * agent_last(struct Agent *agent, signed int fd);
// agent_last_unlocked
// file libslack/agent.c line 1291
struct timeval * agent_last_unlocked(struct Agent *agent, signed int fd);
// agent_rdlock
// file libslack/agent.c line 558
signed int agent_rdlock(const struct Agent *agent);
// agent_recv
// file libslack/agent.c line 1101
signed int agent_recv(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_recv::reaction$object
// 
signed int reaction$object(struct Agent *, signed int, signed int, void *);
// agent_recv_unlocked
// file libslack/agent.c line 1129
signed int agent_recv_unlocked(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_recv_unlocked::reaction$object
// 
signed int reaction$object(struct Agent *, signed int, signed int, void *);
// agent_release
// file libslack/agent.c line 482
void agent_release(struct Agent *agent);
// agent_schedule
// file libslack/agent.c line 1585
void * agent_schedule(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg);
// agent_schedule::action$object
// 
//signed int action$object(struct Agent *, void *);
// agent_schedule_unlocked
// file libslack/agent.c line 1645
void * agent_schedule_unlocked(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg);
// agent_schedule_unlocked::action$object
// 
//signed int action$object(struct Agent *, void *);
// agent_send
// file libslack/agent.c line 1027
signed int agent_send(struct Agent *agent, signed int fd, signed int sockfd);
// agent_send_unlocked
// file libslack/agent.c line 1055
signed int agent_send_unlocked(struct Agent *agent, signed int fd, signed int sockfd);
// agent_start
// file libslack/agent.c line 2270
signed int agent_start(struct Agent *agent);
// agent_start_unlocked
// file libslack/agent.c line 2087
static signed int agent_start_unlocked(struct Agent *agent);
// agent_start_unlocked::1::1::1::2::1::1::1::reaction$object
// 
signed int reaction$object(struct Agent *, signed int, signed int, void *);
// agent_start_unlocked::1::1::2::2::1::1::1::reaction$object
// 
signed int reaction$object(struct Agent *, signed int, signed int, void *);
// agent_stop
// file libslack/agent.c line 2312
signed int agent_stop(struct Agent *agent);
// agent_stop_unlocked
// file libslack/agent.c line 2302
static signed int agent_stop_unlocked(struct Agent *agent);
// agent_transfer
// file libslack/agent.c line 927
signed int agent_transfer(struct Agent *agent, signed int fd, struct Agent *dst);
// agent_transfer_unlocked
// file libslack/agent.c line 956
signed int agent_transfer_unlocked(struct Agent *agent, signed int fd, struct Agent *dst);
// agent_unlock
// file libslack/agent.c line 596
signed int agent_unlock(const struct Agent *agent);
// agent_velocity
// file libslack/agent.c line 1342
signed int agent_velocity(struct Agent *agent, signed int fd);
// agent_velocity_unlocked
// file libslack/agent.c line 1370
signed int agent_velocity_unlocked(struct Agent *agent, signed int fd);
// agent_wrlock
// file libslack/agent.c line 579
signed int agent_wrlock(const struct Agent *agent);
// alert
// file libslack/err.c line 456
void alert(signed int priority, const char *format, ...);
// alertsys
// file libslack/err.c line 677
void alertsys(signed int priority, const char *format, ...);
// asprintf
// file libslack/str.c line 6826
signed int asprintf(char **str, const char *format, ...);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// bin
// file libslack/str.c line 6284
signed int bin(const char *str);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// build_sockopts
// file libslack/net.c line 286
static struct sockopt_t * build_sockopts(struct sockopt_t *sockopts, signed int *rcvbufsz, signed int *sndbufsz);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// chomp
// file libslack/str.c line 6204
signed int chomp(char *str);
// chop
// file libslack/str.c line 6113
signed int chop(char *str);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// consume
// file libslack/map.c line 2517
void * consume(void *arg);
// contract
// file libslack/list.c line 296
static signed int contract(struct List *list, signed long int index, unsigned long int range);
// contract$link1
// file libslack/str.c line 475
static signed int contract$link1(struct String *str, signed long int index$link1, unsigned long int range$link1);
// coproc_close
// file libslack/coproc.c line 348
signed int coproc_close(signed int pid, signed int *to, signed int *from, signed int *err);
// coproc_open
// file libslack/coproc.c line 216
signed int coproc_open(signed int *to, signed int *from, signed int *err, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data);
// coproc_open::action$object
// 
//void action$object(void *);
// coproc_pty_close
// file libslack/coproc.c line 464
signed int coproc_pty_close(signed int pid, signed int *masterfd, const char *slavename);
// coproc_pty_open
// file libslack/coproc.c line 405
signed int coproc_pty_open(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data);
// coproc_pty_open::action$object
// 
//void action$object(void *);
// cstr
// file libslack/str.h line 82
char * cstr(const struct String *str);
// cstrcat
// file libslack/str.c line 6689
char * cstrcat(char *dst, const char *src);
// cstrchr
// file libslack/str.c line 6714
char * cstrchr(const char *str, signed int c);
// cstrcpy
// file libslack/str.c line 6666
char * cstrcpy(char *dst, const char *src);
// cstrpbrk
// file libslack/str.c line 6736
char * cstrpbrk(const char *str, const char *brk);
// cstrrchr
// file libslack/str.c line 6762
char * cstrrchr(const char *str, signed int c);
// cstrstr
// file libslack/str.c line 6787
char * cstrstr(const char *str, const char *srch);
// daemon_absolute_path
// file libslack/daemon.c line 273
char * daemon_absolute_path(const char *path);
// daemon_become_user
// file libslack/daemon.c line 233
signed int daemon_become_user(unsigned int uid, unsigned int gid, char *user);
// daemon_check_path
// file libslack/daemon.c line 395
static signed int daemon_check_path(char *path, char *explanation, unsigned long int explanation_size, signed int level);
// daemon_close
// file libslack/daemon.c line 1038
signed int daemon_close(void);
// daemon_construct_pidfile
// file libslack/daemon.c line 598
static signed int daemon_construct_pidfile(const char *name, char **pidfile);
// daemon_getpid
// file libslack/daemon.c line 1069
signed int daemon_getpid(const char *name);
// daemon_init
// file libslack/daemon.c line 876
signed int daemon_init(const char *name);
// daemon_is_running
// file libslack/daemon.c line 1126
signed int daemon_is_running(const char *name);
// daemon_lock_pidfile
// file libslack/daemon.c line 633
static signed int daemon_lock_pidfile(char *pidfile);
// daemon_parse_config
// file libslack/daemon.c line 525
void * daemon_parse_config(const char *path, void *obj, void (*parser)(void *, const char *, char *, unsigned long int));
// daemon_parse_config::parser$object
// 
void parser$object(void *, const char *, char *, unsigned long int);
// daemon_path_is_safe
// file libslack/daemon.c line 490
signed int daemon_path_is_safe(const char *path, char *explanation, unsigned long int explanation_size);
// daemon_pidfile
// file libslack/daemon.c line 790
signed int daemon_pidfile(const char *name);
// daemon_pidfile_unlocked
// file libslack/daemon.c line 728
static signed int daemon_pidfile_unlocked(const char *name);
// daemon_prevent_core
// file libslack/daemon.c line 169
signed int daemon_prevent_core(void);
// daemon_revoke_privileges
// file libslack/daemon.c line 200
signed int daemon_revoke_privileges(void);
// daemon_started_by_inetd
// file libslack/daemon.c line 149
signed int daemon_started_by_inetd(void);
// daemon_started_by_init
// file libslack/daemon.c line 130
signed int daemon_started_by_init(void);
// daemon_stop
// file libslack/daemon.c line 1195
signed int daemon_stop(const char *name);
// debug_invoke
// file libslack/locker.c line 243
static signed int debug_invoke(const char *name, signed int (*action)(void *), void *lock);
// debug_invoke::action$object
// 
//signed int action$object(void *);
// debug_level_match
// file libslack/err.c line 250
static signed int debug_level_match(unsigned long int level);
// debug_pthread_mutex_lock
// file libslack/locker.c line 261
static signed int debug_pthread_mutex_lock(union anonymous$11 *mutex);
// debug_pthread_mutex_trylock
// file libslack/locker.c line 256
static signed int debug_pthread_mutex_trylock(union anonymous$11 *mutex);
// debug_pthread_mutex_unlock
// file libslack/locker.c line 266
static signed int debug_pthread_mutex_unlock(union anonymous$11 *mutex);
// debug_pthread_rwlock_rdlock
// file libslack/locker.c line 307
static signed int debug_pthread_rwlock_rdlock(union anonymous$12 *rwlock);
// debug_pthread_rwlock_tryrdlock
// file libslack/locker.c line 302
static signed int debug_pthread_rwlock_tryrdlock(union anonymous$12 *rwlock);
// debug_pthread_rwlock_trywrlock
// file libslack/locker.c line 312
static signed int debug_pthread_rwlock_trywrlock(union anonymous$12 *rwlock);
// debug_pthread_rwlock_unlock
// file libslack/locker.c line 322
static signed int debug_pthread_rwlock_unlock(union anonymous$12 *rwlock);
// debug_pthread_rwlock_wrlock
// file libslack/locker.c line 317
static signed int debug_pthread_rwlock_wrlock(union anonymous$12 *rwlock);
// debugf
// file libslack/err.c line 263
void debugf(unsigned long int level, const char *format, ...);
// debugsysf
// file libslack/err.c line 514
void debugsysf(unsigned long int level, const char *format, ...);
// decode
// file libslack/str.h line 226
struct String * decode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// decode_with_locker
// file libslack/str.c line 5738
struct String * decode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// direct_cmp
// file libslack/map.c line 2471
static signed int direct_cmp(signed int a, signed int b);
// direct_copy
// file libslack/map.c line 2466
static signed int direct_copy(signed int key);
// direct_hash
// file libslack/map.c line 2476
static unsigned long int direct_hash(unsigned long int size, signed int key);
// dlink_alloc
// file libslack/link.c line 489
void * dlink_alloc(void **freelist);
// dlink_free
// file libslack/link.c line 539
void * dlink_free(void **freelist, void *item);
// dlink_freelist_attach
// file libslack/link.c line 428
void * dlink_freelist_attach(void *freelist1, void *freelist2);
// dlink_freelist_init
// file libslack/link.c line 363
void * dlink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size);
// dlink_has_next
// file libslack/link.c line 143
signed int dlink_has_next(void *link);
// dlink_has_prev
// file libslack/link.c line 181
signed int dlink_has_prev(void *link);
// dlink_insert
// file libslack/link.h line 51
void * dlink_insert(void *link, void *item);
// dlink_next
// file libslack/link.h line 47
void * dlink_next(void *link);
// dlink_prev
// file libslack/link.c line 200
void * dlink_prev(void *link);
// dlink_remove
// file libslack/link.h line 53
void * dlink_remove(void *link);
// do_decode_with_locker
// file libslack/str.c line 5388
static struct String * do_decode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable);
// do_encode_with_locker
// file libslack/str.c line 5336
static struct String * do_encode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable);
// do_exec
// file libslack/coproc.c line 159
static void do_exec(signed int has_meta, const char *cmd, char * const *argv, char * const *envv);
// do_split_with_locker
// file libslack/str.c line 3966
static struct List * do_split_with_locker(struct Locker *locker, const char *str, signed long int length, const char *delim);
// do_tr_compile_table
// file libslack/str.c line 2680
static struct StringTR * do_tr_compile_table(struct StringTR *table, const char *from, signed long int fromlen, const char *to, signed long int tolen, signed int option);
// do_tr_compiled
// file libslack/str.c line 2866
static signed int do_tr_compiled(unsigned char *str, unsigned long int *length, struct StringTR *table);
// dump
// file libslack/err.c line 411
void dump(const char *format, ...);
// dumpsys
// file libslack/err.c line 638
void dumpsys(const char *format, ...);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// encode
// file libslack/str.h line 224
struct String * encode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// encode_with_locker
// file libslack/str.c line 5704
struct String * encode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// endgrent
// file /usr/include/grp.h line 70
extern void endgrent(void);
// endpwent
// file /usr/include/pwd.h line 78
extern void endpwent(void);
// error
// file libslack/err.c line 316
signed int error(const char *format, ...);
// errorsys
// file libslack/err.c line 559
signed int errorsys(const char *format, ...);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expand
// file libslack/list.c line 275
static signed int expand(struct List *list, signed long int index, unsigned long int range);
// expand$link1
// file libslack/str.c line 454
static signed int expand$link1(struct String *str, signed long int index$link1, unsigned long int range$link1);
// expire
// file libslack/agent.c line 1957
static signed int expire(struct Agent *agent);
// expire::1::1::action$object
// 
//signed int action$object(struct Agent *, void *);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fatal
// file libslack/err.c line 367
void fatal(const char *format, ...);
// fatalsys
// file libslack/err.c line 599
void fatalsys(const char *format, ...);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fcntl_clear_flag
// file libslack/fio.c line 399
signed int fcntl_clear_flag(signed int fd, signed int flag);
// fcntl_lock
// file libslack/fio.h line 41
signed int fcntl_lock(signed int fd, signed int cmd, signed int type, signed int whence, signed int start, signed int len);
// fcntl_set_flag
// file libslack/fio.c line 376
signed int fcntl_set_flag(signed int fd, signed int flag);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetline
// file libslack/fio.c line 122
char * fgetline(char *line, unsigned long int size, struct _IO_FILE *stream);
// fgetline_unlocked
// file libslack/fio.c line 143
char * fgetline_unlocked(char *line, unsigned long int size, struct _IO_FILE *stream);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fifo_exists
// file libslack/fio.c line 503
signed int fifo_exists(const char *path, signed int prepare);
// fifo_has_reader
// file libslack/fio.c line 535
signed int fifo_has_reader(const char *path, signed int prepare);
// fifo_open
// file libslack/fio.c line 598
signed int fifo_open(const char *path, unsigned int mode, signed int lock, signed int *writefd);
// flockfile
// file /usr/include/stdio.h line 912
extern void flockfile(struct _IO_FILE *);
// fmt
// file libslack/str.c line 3757
struct List * fmt(const char *str, unsigned long int line_width, enum StringAlignment alignment);
// fmt_with_locker
// file libslack/str.c line 3773
struct List * fmt_with_locker(struct Locker *locker, const char *str, unsigned long int line_width, enum StringAlignment alignment);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fpathconf
// file /usr/include/unistd.h line 616
extern signed long int fpathconf(signed int, signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf);
// fstat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat$link1(signed int __fd$link1, struct stat *__statbuf$link1);
// funlockfile
// file /usr/include/stdio.h line 919
extern void funlockfile(struct _IO_FILE *);
// getc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 63
static inline signed int getc_unlocked(struct _IO_FILE *__fp);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getegid
// file /usr/include/unistd.h line 684
extern unsigned int getegid(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getgroups
// file /usr/include/unistd.h line 689
extern signed int getgroups(signed int, unsigned int *);
// gethostbyname_r
// file /usr/include/netdb.h line 179
extern signed int gethostbyname_r(const char *, struct hostent *, char *, unsigned long int, struct hostent ** restrict , signed int *);
// getopt_long
// file libslack/getopt.h line 139
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// getprotonamebysocktype
// file libslack/net.c line 496
static const char * getprotonamebysocktype(signed int socktype);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(signed int, struct rlimit *);
// getservbyname_r
// file /usr/include/netdb.h line 312
extern signed int getservbyname_r(const char *, const char *, struct servent *, char *, unsigned long int, struct servent ** restrict );
// getservportbynameandtype
// file libslack/net.c line 506
static unsigned short int getservportbynameandtype(const char *name, signed int type);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// groupname2gid
// file libslack/pseudo.c line 174
static signed int groupname2gid(const char *groupname);
// grow
// file libslack/list.c line 218
static signed int grow(struct List *list, unsigned long int items);
// grow$link1
// file libslack/str.c line 397
static signed int grow$link1(struct String *str, unsigned long int bytes);
// handle_debug_option
// file libslack/prog.c line 1719
static void handle_debug_option(signed int *arg);
// handle_verbose_option
// file libslack/prog.c line 1714
static void handle_verbose_option(signed int *arg);
// hash
// file libslack/map.c line 217
static unsigned long int hash(unsigned long int size, const void *key);
// hex
// file libslack/str.c line 6370
signed int hex(const char *str);
// hsort
// file libslack/hsort.c line 201
void hsort(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *));
// hsort::cmp$object
// 
//signed int cmp$object(const void *, const void *);
// hsort_closure
// file libslack/hsort.c line 295
void hsort_closure(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *, const void *), const void *data);
// hsort_closure::cmp$object
// 
//signed int cmp$object(const void *, const void *, const void *);
// if_indextoname
// file /usr/include/net/if.h line 194
extern char * if_indextoname(unsigned int, char *);
// if_nametoindex
// file /usr/include/net/if.h line 193
extern unsigned int if_nametoindex(const char *);
// iface_release
// file libslack/net.c line 2007
static void iface_release(struct net_interface_t *iface);
// inet6_required
// file libslack/net.c line 468
static signed int inet6_required(void);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// install
// file libslack/agent.c line 1639
static void install(struct action_t **parent, struct action_t *action);
// int_arg
// file libslack/prog.c line 1862
static signed int int_arg(const char *argument);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_multicast
// file libslack/net.c line 555
static signed int is_multicast(struct sockaddr *address);
// iterate_builtin
// file libslack/map.c line 2548
void * iterate_builtin(void *arg);
// iterate_rdlocked
// file libslack/map.c line 2583
void * iterate_rdlocked(void *arg);
// iterate_wrlocked
// file libslack/map.c line 2610
void * iterate_wrlocked(void *arg);
// join
// file libslack/str.c line 4465
struct String * join(const struct List *list, const char *delim);
// join_with_locker
// file libslack/str.c line 4481
struct String * join_with_locker(struct Locker *locker, const struct List *list, const char *delim);
// key_cmp
// file libslack/prop.c line 192
static signed int key_cmp(const char **a, const char **b);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// killitems
// file libslack/list.c line 337
static void killitems(struct List *list, unsigned long int index, unsigned long int range);
// lc
// file libslack/str.c line 5810
char * lc(char *str);
// lcfirst
// file libslack/str.c line 5885
char * lcfirst(char *str);
// limit_arg
// file libslack/lim.c line 238
signed long int limit_arg(void);
// limit_canon
// file libslack/lim.c line 429
signed long int limit_canon(void);
// limit_child
// file libslack/lim.c line 254
signed long int limit_child(void);
// limit_chown
// file libslack/lim.c line 801
signed long int limit_chown(void);
// limit_fcanon
// file libslack/lim.c line 413
signed long int limit_fcanon(signed int fd);
// limit_fchown
// file libslack/lim.c line 785
signed long int limit_fchown(signed int fd);
// limit_finput
// file libslack/lim.c line 461
signed long int limit_finput(signed int fd);
// limit_flink
// file libslack/lim.c line 557
signed long int limit_flink(signed int fd);
// limit_fname
// file libslack/lim.c line 607
signed long int limit_fname(signed int fd);
// limit_fnotrunc
// file libslack/lim.c line 737
signed long int limit_fnotrunc(signed int fd);
// limit_fpath
// file libslack/lim.c line 657
signed long int limit_fpath(signed int fd);
// limit_fpathconf
// file libslack/lim.c line 217
static signed long int limit_fpathconf(signed int limit, signed int fd);
// limit_fpipe
// file libslack/lim.c line 705
signed long int limit_fpipe(signed int fd);
// limit_fvdisable
// file libslack/lim.c line 509
signed long int limit_fvdisable(signed int fd);
// limit_group
// file libslack/lim.c line 286
signed long int limit_group(void);
// limit_input
// file libslack/lim.c line 477
signed long int limit_input(void);
// limit_job
// file libslack/lim.c line 349
signed long int limit_job(void);
// limit_link
// file libslack/lim.c line 573
signed long int limit_link(void);
// limit_name
// file libslack/lim.c line 623
signed long int limit_name(void);
// limit_notrunc
// file libslack/lim.c line 753
signed long int limit_notrunc(void);
// limit_open
// file libslack/lim.h line 34
signed long int limit_open(void);
// limit_path
// file libslack/lim.h line 57
signed long int limit_path(void);
// limit_pathconf
// file libslack/lim.c line 193
static signed long int limit_pathconf(signed int limit, const char *path);
// limit_pcanon
// file libslack/lim.c line 397
signed long int limit_pcanon(const char *path);
// limit_pchown
// file libslack/lim.c line 769
signed long int limit_pchown(const char *path);
// limit_pinput
// file libslack/lim.c line 445
signed long int limit_pinput(const char *path);
// limit_plink
// file libslack/lim.c line 541
signed long int limit_plink(const char *path);
// limit_pname
// file libslack/lim.c line 590
signed long int limit_pname(const char *path);
// limit_pnotrunc
// file libslack/lim.c line 721
signed long int limit_pnotrunc(const char *path);
// limit_ppath
// file libslack/lim.c line 640
signed long int limit_ppath(const char *path);
// limit_ppipe
// file libslack/lim.c line 689
signed long int limit_ppipe(const char *path);
// limit_pvdisable
// file libslack/lim.c line 493
signed long int limit_pvdisable(const char *path);
// limit_save_ids
// file libslack/lim.c line 365
signed long int limit_save_ids(void);
// limit_stream
// file libslack/lim.c line 318
signed long int limit_stream(void);
// limit_sysconf
// file libslack/lim.c line 169
static signed long int limit_sysconf(signed int limit);
// limit_tick
// file libslack/lim.c line 270
signed long int limit_tick(void);
// limit_tzname
// file libslack/lim.c line 334
signed long int limit_tzname(void);
// limit_vdisable
// file libslack/lim.c line 525
signed long int limit_vdisable(void);
// limit_version
// file libslack/lim.c line 381
signed long int limit_version(void);
// list_append
// file libslack/slack/list.h line 81
struct List * list_append(struct List *list, void *item);
// list_append_int
// file libslack/list.c line 1307
struct List * list_append_int(struct List *list, signed int item);
// list_append_int_unlocked
// file libslack/list.c line 1322
struct List * list_append_int_unlocked(struct List *list, signed int item);
// list_append_list
// file libslack/list.c line 1339
struct List * list_append_list(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_append_list::copy$object
// 
void * copy$object(const void *);
// list_append_list_unlocked
// file libslack/list.c line 1355
struct List * list_append_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_append_list_unlocked::copy$object
// 
void * copy$object(const void *);
// list_append_unlocked
// file libslack/list.c line 1292
struct List * list_append_unlocked(struct List *list, void *item);
// list_apply
// file libslack/list.c line 2245
void list_apply(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply::action$object
// 
//void action$object(void *, unsigned long int *, void *);
// list_apply_rdlocked
// file libslack/list.c line 2262
void list_apply_rdlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply_rdlocked::action$object
// 
//void action$object(void *, unsigned long int *, void *);
// list_apply_unlocked
// file libslack/list.c line 2327
void list_apply_unlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply_unlocked::action$object
// 
//void action$object(void *, unsigned long int *, void *);
// list_apply_wrlocked
// file libslack/list.c line 2295
void list_apply_wrlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply_wrlocked::action$object
// 
//void action$object(void *, unsigned long int *, void *);
// list_break
// file libslack/list.c line 2950
void list_break(struct List *list);
// list_copy
// file libslack/list.c line 418
struct List * list_copy(const struct List *src, void * (*copy)(const void *));
// list_copy::copy$object
// 
void * copy$object(const void *);
// list_copy_with_locker
// file libslack/list.c line 513
struct List * list_copy_with_locker(struct Locker *locker, const struct List *src, void * (*copy)(const void *));
// list_copy_with_locker::copy$object
// 
void * copy$object(const void *);
// list_create
// file libslack/slack/list.h line 44
struct List * list_create(void (*destroy)(void *));
// list_create::destroy$object
// 
void destroy$object(void *);
// list_create_with_locker
// file libslack/list.c line 434
struct List * list_create_with_locker(struct Locker *locker, void (*destroy)(void *));
// list_create_with_locker::destroy$object
// 
void destroy$object(void *);
// list_destroy
// file libslack/slack/list.h line 56
void * list_destroy(struct List **list);
// list_disown
// file libslack/list.c line 703
void (*list_disown(struct List *list))(void *);
// list_disown::$tmp::return_value_set_errnullf$1$object
// 
void return_value_set_errnullf$1$object();
// list_disown::$tmp::return_value_set_errnullf$2$object
// 
void return_value_set_errnullf$2$object();
// list_disown::$tmp::return_value_set_errnullf$5$object
// 
void return_value_set_errnullf$5$object();
// list_disown::1::destroy$object
// 
void destroy$object(void *);
// list_disown_unlocked
// file libslack/list.c line 732
void (*list_disown_unlocked(struct List *list))(void *);
// list_disown_unlocked::$tmp::return_value_set_errnullf$1$object
// 
void return_value_set_errnullf$1$object();
// list_disown_unlocked::1::destroy$object
// 
void destroy$object(void *);
// list_empty
// file libslack/list.c line 846
signed int list_empty(const struct List *list);
// list_empty_unlocked
// file libslack/list.c line 875
signed int list_empty_unlocked(const struct List *list);
// list_extract
// file libslack/list.c line 1669
struct List * list_extract(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_extract::copy$object
// 
void * copy$object(const void *);
// list_extract_unlocked
// file libslack/list.c line 1684
struct List * list_extract_unlocked(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_extract_unlocked::copy$object
// 
void * copy$object(const void *);
// list_extract_with_locker
// file libslack/list.c line 1700
struct List * list_extract_with_locker(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_extract_with_locker::copy$object
// 
void * copy$object(const void *);
// list_extract_with_locker_unlocked
// file libslack/list.c line 1730
struct List * list_extract_with_locker_unlocked(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_extract_with_locker_unlocked::$tmp::tmp_if_expr$6$object
// 
void tmp_if_expr$6$object(void *);
// list_extract_with_locker_unlocked::copy$object
// 
void * copy$object(const void *);
// list_grep
// file libslack/list.c line 2461
struct List * list_grep(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep::grep$object
// 
signed int grep$object(void *, unsigned long int *, void *);
// list_grep_unlocked
// file libslack/list.c line 2476
struct List * list_grep_unlocked(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep_unlocked::grep$object
// 
signed int grep$object(void *, unsigned long int *, void *);
// list_grep_with_locker
// file libslack/list.c line 2492
struct List * list_grep_with_locker(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep_with_locker::grep$object
// 
signed int grep$object(void *, unsigned long int *, void *);
// list_grep_with_locker_unlocked
// file libslack/list.c line 2525
struct List * list_grep_with_locker_unlocked(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep_with_locker_unlocked::grep$object
// 
signed int grep$object(void *, unsigned long int *, void *);
// list_has_next
// file libslack/list.c line 2922
signed int list_has_next(struct List *list);
// list_insert
// file libslack/list.c line 1099
struct List * list_insert(struct List *list, signed long int index, void *item);
// list_insert_int
// file libslack/list.c line 1160
struct List * list_insert_int(struct List *list, signed long int index, signed int item);
// list_insert_int_unlocked
// file libslack/list.c line 1175
struct List * list_insert_int_unlocked(struct List *list, signed long int index, signed int item);
// list_insert_list
// file libslack/list.c line 1195
struct List * list_insert_list(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *));
// list_insert_list::copy$object
// 
void * copy$object(const void *);
// list_insert_list_unlocked
// file libslack/list.c line 1241
struct List * list_insert_list_unlocked(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *));
// list_insert_list_unlocked::copy$object
// 
void * copy$object(const void *);
// list_insert_unlocked
// file libslack/list.c line 1128
struct List * list_insert_unlocked(struct List *list, signed long int index, void *item);
// list_item
// file libslack/slack/list.h line 61
void * list_item(const struct List *list, signed long int index);
// list_item_int
// file libslack/list.c line 815
signed int list_item_int(const struct List *list, signed long int index);
// list_item_int_unlocked
// file libslack/list.c line 830
signed int list_item_int_unlocked(const struct List *list, signed long int index);
// list_item_unlocked
// file libslack/list.c line 787
void * list_item_unlocked(const struct List *list, signed long int index);
// list_last
// file libslack/list.c line 942
signed long int list_last(const struct List *list);
// list_last_unlocked
// file libslack/list.c line 971
signed long int list_last_unlocked(const struct List *list);
// list_length
// file libslack/slack/list.h line 67
signed long int list_length(const struct List *list);
// list_length_unlocked
// file libslack/list.c line 923
signed long int list_length_unlocked(const struct List *list);
// list_make
// file libslack/list.c line 379
struct List * list_make(void (*destroy)(void *), ...);
// list_make::destroy$object
// 
void destroy$object(void *);
// list_make_with_locker
// file libslack/list.c line 461
struct List * list_make_with_locker(struct Locker *locker, void (*destroy)(void *), ...);
// list_make_with_locker::destroy$object
// 
void destroy$object(void *);
// list_map
// file libslack/list.c line 2357
struct List * list_map(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map::destroy$object
// 
void destroy$object(void *);
// list_map::map$object
// 
void * map$object(void *, unsigned long int *, void *);
// list_map_unlocked
// file libslack/list.c line 2372
struct List * list_map_unlocked(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map_unlocked::destroy$object
// 
void destroy$object(void *);
// list_map_unlocked::map$object
// 
void * map$object(void *, unsigned long int *, void *);
// list_map_with_locker
// file libslack/list.c line 2388
struct List * list_map_with_locker(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map_with_locker::destroy$object
// 
void destroy$object(void *);
// list_map_with_locker::map$object
// 
void * map$object(void *, unsigned long int *, void *);
// list_map_with_locker_unlocked
// file libslack/list.c line 2421
struct List * list_map_with_locker_unlocked(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map_with_locker_unlocked::destroy$object
// 
void destroy$object(void *);
// list_map_with_locker_unlocked::map$object
// 
void * map$object(void *, unsigned long int *, void *);
// list_next
// file libslack/list.c line 2972
void * list_next(struct List *list);
// list_next_int
// file libslack/list.c line 2990
signed int list_next_int(struct List *list);
// list_own
// file libslack/list.c line 652
signed int list_own(struct List *list, void (*destroy)(void *));
// list_own::destroy$object
// 
void destroy$object(void *);
// list_own_unlocked
// file libslack/list.c line 680
signed int list_own_unlocked(struct List *list, void (*destroy)(void *));
// list_own_unlocked::destroy$object
// 
void destroy$object(void *);
// list_pop
// file libslack/list.c line 1841
void * list_pop(struct List *list);
// list_pop_int
// file libslack/list.c line 1903
signed int list_pop_int(struct List *list);
// list_pop_int_unlocked
// file libslack/list.c line 1918
signed int list_pop_int_unlocked(struct List *list);
// list_pop_unlocked
// file libslack/list.c line 1870
void * list_pop_unlocked(struct List *list);
// list_prepend
// file libslack/list.c line 1371
struct List * list_prepend(struct List *list, void *item);
// list_prepend_int
// file libslack/list.c line 1401
struct List * list_prepend_int(struct List *list, signed int item);
// list_prepend_int_unlocked
// file libslack/list.c line 1417
struct List * list_prepend_int_unlocked(struct List *list, signed int item);
// list_prepend_list
// file libslack/list.c line 1434
struct List * list_prepend_list(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_prepend_list::copy$object
// 
void * copy$object(const void *);
// list_prepend_list_unlocked
// file libslack/list.c line 1450
struct List * list_prepend_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_prepend_list_unlocked::copy$object
// 
void * copy$object(const void *);
// list_prepend_unlocked
// file libslack/list.c line 1386
struct List * list_prepend_unlocked(struct List *list, void *item);
// list_push
// file libslack/list.c line 1780
struct List * list_push(struct List *list, void *item);
// list_push_int
// file libslack/list.c line 1810
struct List * list_push_int(struct List *list, signed int item);
// list_push_int_unlocked
// file libslack/list.c line 1825
struct List * list_push_int_unlocked(struct List *list, signed int item);
// list_push_unlocked
// file libslack/list.c line 1795
struct List * list_push_unlocked(struct List *list, void *item);
// list_query
// file libslack/list.c line 2566
signed long int list_query(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data);
// list_query::query$object
// 
signed int query$object(void *, unsigned long int *, void *);
// list_query_unlocked
// file libslack/list.c line 2595
signed long int list_query_unlocked(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data);
// list_query_unlocked::query$object
// 
signed int query$object(void *, unsigned long int *, void *);
// list_rdlock
// file libslack/list.c line 548
signed int list_rdlock(const struct List *list);
// list_release
// file libslack/list.c line 602
void list_release(struct List *list);
// list_remove
// file libslack/list.c line 993
struct List * list_remove(struct List *list, signed long int index);
// list_remove_current
// file libslack/list.c line 3010
void list_remove_current(struct List *list);
// list_remove_range
// file libslack/list.c line 1027
struct List * list_remove_range(struct List *list, signed long int index, signed long int range);
// list_remove_range_unlocked
// file libslack/list.c line 1057
struct List * list_remove_range_unlocked(struct List *list, signed long int index, signed long int range);
// list_remove_unlocked
// file libslack/list.c line 1008
struct List * list_remove_unlocked(struct List *list, signed long int index);
// list_replace
// file libslack/list.c line 1469
struct List * list_replace(struct List *list, signed long int index, signed long int range, void *item);
// list_replace_int
// file libslack/list.c line 1538
struct List * list_replace_int(struct List *list, signed long int index, signed long int range, signed int item);
// list_replace_int_unlocked
// file libslack/list.c line 1553
struct List * list_replace_int_unlocked(struct List *list, signed long int index, signed long int range, signed int item);
// list_replace_list
// file libslack/list.c line 1573
struct List * list_replace_list(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *));
// list_replace_list::copy$object
// 
void * copy$object(const void *);
// list_replace_list_unlocked
// file libslack/list.c line 1617
struct List * list_replace_list_unlocked(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *));
// list_replace_list_unlocked::copy$object
// 
void * copy$object(const void *);
// list_replace_unlocked
// file libslack/list.c line 1498
struct List * list_replace_unlocked(struct List *list, signed long int index, signed long int range, void *item);
// list_shift
// file libslack/list.c line 1934
void * list_shift(struct List *list);
// list_shift_int
// file libslack/list.c line 1996
signed int list_shift_int(struct List *list);
// list_shift_int_unlocked
// file libslack/list.c line 2011
signed int list_shift_int_unlocked(struct List *list);
// list_shift_unlocked
// file libslack/list.c line 1963
void * list_shift_unlocked(struct List *list);
// list_sort
// file libslack/slack/list.h line 123
struct List * list_sort(struct List *list, signed int (*cmp)(const void *, const void *));
// list_sort::cmp$object
// 
//signed int cmp$object(const void *, const void *);
// list_sort_unlocked
// file libslack/list.c line 2220
struct List * list_sort_unlocked(struct List *list, signed int (*cmp)(const void *, const void *));
// list_sort_unlocked::cmp$object
// 
//signed int cmp$object(const void *, const void *);
// list_splice
// file libslack/list.c line 2095
struct List * list_splice(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice::copy$object
// 
void * copy$object(const void *);
// list_splice_unlocked
// file libslack/list.c line 2110
struct List * list_splice_unlocked(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice_unlocked::copy$object
// 
void * copy$object(const void *);
// list_splice_with_locker
// file libslack/list.c line 2126
struct List * list_splice_with_locker(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice_with_locker::copy$object
// 
void * copy$object(const void *);
// list_splice_with_locker_unlocked
// file libslack/list.c line 2159
struct List * list_splice_with_locker_unlocked(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice_with_locker_unlocked::copy$object
// 
void * copy$object(const void *);
// list_unlock
// file libslack/list.c line 586
signed int list_unlock(const struct List *list);
// list_unshift
// file libslack/list.c line 2027
struct List * list_unshift(struct List *list, void *item);
// list_unshift_int
// file libslack/list.c line 2057
struct List * list_unshift_int(struct List *list, signed int item);
// list_unshift_int_unlocked
// file libslack/list.c line 2073
struct List * list_unshift_int_unlocked(struct List *list, signed int item);
// list_unshift_unlocked
// file libslack/list.c line 2042
struct List * list_unshift_unlocked(struct List *list, void *item);
// list_vmake
// file libslack/list.c line 400
struct List * list_vmake(void (*destroy)(void *), void **args);
// list_vmake::destroy$object
// 
void destroy$object(void *);
// list_vmake_with_locker
// file libslack/list.c line 482
struct List * list_vmake_with_locker(struct Locker *locker, void (*destroy)(void *), __builtin_va_list args);
// list_vmake_with_locker::destroy$object
// 
void destroy$object(void *);
// list_wrlock
// file libslack/list.c line 569
signed int list_wrlock(const struct List *list);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lister_create
// file libslack/list.c line 2629
struct Lister * lister_create(struct List *list);
// lister_create_rdlocked
// file libslack/list.c line 2646
struct Lister * lister_create_rdlocked(struct List *list);
// lister_create_unlocked
// file libslack/list.c line 2693
struct Lister * lister_create_unlocked(const struct List *list);
// lister_create_wrlocked
// file libslack/list.c line 2670
struct Lister * lister_create_wrlocked(struct List *list);
// lister_destroy
// file libslack/list.c line 2765
void * lister_destroy(struct Lister **lister);
// lister_destroy_unlocked
// file libslack/list.c line 2787
void * lister_destroy_unlocked(struct Lister **lister);
// lister_has_next
// file libslack/list.c line 2810
signed int lister_has_next(struct Lister *lister);
// lister_next
// file libslack/list.c line 2829
void * lister_next(struct Lister *lister);
// lister_next_int
// file libslack/list.c line 2847
signed int lister_next_int(struct Lister *lister);
// lister_release
// file libslack/list.c line 2719
void lister_release(struct Lister *lister);
// lister_release_unlocked
// file libslack/list.c line 2746
void lister_release_unlocked(struct Lister *lister);
// lister_remove
// file libslack/list.c line 2868
void lister_remove(struct Lister *lister);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// locker_create
// file libslack/locker.c line 359
struct Locker * locker_create(void *lock, signed int (*tryrdlock)(void *), signed int (*rdlock)(void *), signed int (*trywrlock)(void *), signed int (*wrlock)(void *), signed int (*unlock)(void *));
// locker_create::rdlock$object
// 
signed int rdlock$object(void *);
// locker_create::tryrdlock$object
// 
signed int tryrdlock$object(void *);
// locker_create::trywrlock$object
// 
signed int trywrlock$object(void *);
// locker_create::unlock$object
// 
signed int unlock$object(void *);
// locker_create::wrlock$object
// 
signed int wrlock$object(void *);
// locker_create_debug_mutex
// file libslack/slack/locker.h line 66
struct Locker * locker_create_debug_mutex(union anonymous$11 *mutex);
// locker_create_debug_rwlock
// file libslack/slack/locker.h line 67
struct Locker * locker_create_debug_rwlock(union anonymous$12 *rwlock);
// locker_create_mutex
// file libslack/slack/locker.h line 64
struct Locker * locker_create_mutex(union anonymous$11 *mutex);
// locker_create_rwlock
// file libslack/slack/locker.h line 65
struct Locker * locker_create_rwlock(union anonymous$12 *rwlock);
// locker_destroy
// file libslack/slack/locker.h line 70
void * locker_destroy(struct Locker **locker);
// locker_rdlock
// file libslack/locker.c line 453
signed int locker_rdlock(struct Locker *locker);
// locker_release
// file libslack/locker.c line 390
void locker_release(struct Locker *locker);
// locker_tryrdlock
// file libslack/locker.c line 435
signed int locker_tryrdlock(struct Locker *locker);
// locker_trywrlock
// file libslack/locker.c line 472
signed int locker_trywrlock(struct Locker *locker);
// locker_unlock
// file libslack/locker.c line 508
signed int locker_unlock(struct Locker *locker);
// locker_wrlock
// file libslack/locker.c line 490
signed int locker_wrlock(struct Locker *locker);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat(const char *__path, struct stat *__statbuf);
// mail
// file libslack/net.c line 4142
signed int mail(const char *server, const char *sender, const char *recipients, const char *subject, const char *message);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// map_add
// file libslack/map.h line 62
signed int map_add(struct Map *map, const void *key, void *value);
// map_add_unlocked
// file libslack/map.c line 887
signed int map_add_unlocked(struct Map *map, const void *key, void *value);
// map_apply
// file libslack/map.h line 99
void map_apply(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply::action$object
// 
//void action$object(void *, void *, void *);
// map_apply_rdlocked
// file libslack/map.c line 1907
void map_apply_rdlocked(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply_rdlocked::action$object
// 
//void action$object(void *, void *, void *);
// map_apply_unlocked
// file libslack/map.c line 1978
void map_apply_unlocked(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply_unlocked::action$object
// 
//void action$object(void *, void *, void *);
// map_apply_wrlocked
// file libslack/map.c line 1943
void map_apply_wrlocked(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply_wrlocked::action$object
// 
//void action$object(void *, void *, void *);
// map_break
// file libslack/map.h line 85
void map_break(struct Map *map);
// map_create
// file libslack/map.h line 41
struct Map * map_create(void (*destroy)(void *));
// map_create::destroy$object
// 
void destroy$object(void *);
// map_create_generic
// file libslack/map.h line 49
struct Map * map_create_generic(void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic::cmp$object
// 
//signed int cmp$object(const void *, const void *);
// map_create_generic::copy$object
// 
void * copy$object(const void *);
// map_create_generic::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_create_generic::key_destroy$object
// 
void key_destroy$object(void *);
// map_create_generic::value_destroy$object
// 
void value_destroy$object(void *);
// map_create_generic_sized
// file libslack/map.c line 450
struct Map * map_create_generic_sized(unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic_sized::cmp$object
// 
//signed int cmp$object(const void *, const void *);
// map_create_generic_sized::copy$object
// 
void * copy$object(const void *);
// map_create_generic_sized::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_create_generic_sized::key_destroy$object
// 
void key_destroy$object(void *);
// map_create_generic_sized::value_destroy$object
// 
void value_destroy$object(void *);
// map_create_generic_with_locker
// file libslack/map.h line 51
struct Map * map_create_generic_with_locker(struct Locker *locker, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic_with_locker::cmp$object
// 
//signed int cmp$object(const void *, const void *);
// map_create_generic_with_locker::copy$object
// 
void * copy$object(const void *);
// map_create_generic_with_locker::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_create_generic_with_locker::key_destroy$object
// 
void key_destroy$object(void *);
// map_create_generic_with_locker::value_destroy$object
// 
void value_destroy$object(void *);
// map_create_generic_with_locker_sized
// file libslack/map.c line 482
struct Map * map_create_generic_with_locker_sized(struct Locker *locker, unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic_with_locker_sized::cmp$object
// 
//signed int cmp$object(const void *, const void *);
// map_create_generic_with_locker_sized::copy$object
// 
void * copy$object(const void *);
// map_create_generic_with_locker_sized::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_create_generic_with_locker_sized::key_destroy$object
// 
void key_destroy$object(void *);
// map_create_generic_with_locker_sized::value_destroy$object
// 
void value_destroy$object(void *);
// map_create_sized
// file libslack/map.c line 306
struct Map * map_create_sized(unsigned long int size, void (*destroy)(void *));
// map_create_sized::destroy$object
// 
void destroy$object(void *);
// map_create_sized_with_hash
// file libslack/map.c line 342
struct Map * map_create_sized_with_hash(unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_sized_with_hash::destroy$object
// 
void destroy$object(void *);
// map_create_sized_with_hash::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_create_with_hash
// file libslack/map.c line 324
struct Map * map_create_with_hash(unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_with_hash::destroy$object
// 
void destroy$object(void *);
// map_create_with_hash::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_create_with_locker
// file libslack/map.c line 358
struct Map * map_create_with_locker(struct Locker *locker, void (*destroy)(void *));
// map_create_with_locker::destroy$object
// 
void destroy$object(void *);
// map_create_with_locker_sized
// file libslack/map.c line 374
struct Map * map_create_with_locker_sized(struct Locker *locker, unsigned long int size, void (*destroy)(void *));
// map_create_with_locker_sized::destroy$object
// 
void destroy$object(void *);
// map_create_with_locker_sized_with_hash
// file libslack/map.c line 406
struct Map * map_create_with_locker_sized_with_hash(struct Locker *locker, unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_with_locker_sized_with_hash::destroy$object
// 
void destroy$object(void *);
// map_create_with_locker_sized_with_hash::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_create_with_locker_with_hash
// file libslack/map.c line 390
struct Map * map_create_with_locker_with_hash(struct Locker *locker, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_with_locker_with_hash::destroy$object
// 
void destroy$object(void *);
// map_create_with_locker_with_hash::hash$object
// 
unsigned long int hash$object(unsigned long int, const void *);
// map_destroy
// file libslack/map.h line 57
void * map_destroy(struct Map **map);
// map_disown
// file libslack/map.c line 721
void (*map_disown(struct Map *map))(void *);
// map_disown::$tmp::return_value_set_errnullf$1$object
// 
void return_value_set_errnullf$1$object();
// map_disown::$tmp::return_value_set_errnullf$2$object
// 
void return_value_set_errnullf$2$object();
// map_disown::$tmp::return_value_set_errnullf$5$object
// 
void return_value_set_errnullf$5$object();
// map_disown::1::ret$object
// 
void ret$object(void *);
// map_disown_unlocked
// file libslack/map.c line 750
void (*map_disown_unlocked(struct Map *map))(void *);
// map_disown_unlocked::$tmp::return_value_set_errnullf$1$object
// 
void return_value_set_errnullf$1$object();
// map_disown_unlocked::1::destroy$object
// 
void destroy$object(void *);
// map_get
// file libslack/map.h line 70
void * map_get(struct Map *map, const void *key);
// map_get_unlocked
// file libslack/map.h line 71
void * map_get_unlocked(const struct Map *map, const void *key);
// map_has_next
// file libslack/map.h line 84
signed int map_has_next(struct Map *map);
// map_histogram
// file libslack/map.c line 2306
static void map_histogram(const char *name, struct Map *map);
// map_insert
// file libslack/map.c line 938
signed int map_insert(struct Map *map, const void *key, void *value, signed int replace);
// map_insert_unlocked
// file libslack/map.c line 967
signed int map_insert_unlocked(struct Map *map, const void *key, void *value, signed int replace);
// map_keys
// file libslack/map.h line 91
struct List * map_keys(struct Map *map);
// map_keys_unlocked
// file libslack/map.c line 1691
struct List * map_keys_unlocked(struct Map *map);
// map_keys_with_locker
// file libslack/map.c line 1707
struct List * map_keys_with_locker(struct Locker *locker, struct Map *map);
// map_keys_with_locker_unlocked
// file libslack/map.c line 1737
struct List * map_keys_with_locker_unlocked(struct Locker *locker, struct Map *map);
// map_next
// file libslack/map.h line 86
void * map_next(struct Map *map);
// map_next_mapping
// file libslack/map.h line 87
const struct Mapping * map_next_mapping(struct Map *map);
// map_own
// file libslack/map.c line 646
signed int map_own(struct Map *map, void (*destroy)(void *));
// map_own::destroy$object
// 
void destroy$object(void *);
// map_own_unlocked
// file libslack/map.c line 675
signed int map_own_unlocked(struct Map *map, void (*destroy)(void *));
// map_own_unlocked::destroy$object
// 
void destroy$object(void *);
// map_put
// file libslack/map.c line 904
signed int map_put(struct Map *map, const void *key, void *value);
// map_put_unlocked
// file libslack/map.c line 919
signed int map_put_unlocked(struct Map *map, const void *key, void *value);
// map_rdlock
// file libslack/map.h line 53
signed int map_rdlock(const struct Map *map);
// map_release
// file libslack/map.h line 56
void map_release(struct Map *map);
// map_remove
// file libslack/map.h line 68
signed int map_remove(struct Map *map, const void *key);
// map_remove_current
// file libslack/map.h line 88
void map_remove_current(struct Map *map);
// map_remove_unlocked
// file libslack/map.c line 1061
signed int map_remove_unlocked(struct Map *map, const void *key);
// map_resize
// file libslack/map.c line 795
static signed int map_resize(struct Map *map);
// map_resize::$tmp::return_value_map_disown_unlocked$7$object
// 
void return_value_map_disown_unlocked$7$object(void *);
// map_size
// file libslack/map.h line 103
signed long int map_size(struct Map *map);
// map_size_unlocked
// file libslack/map.h line 104
signed long int map_size_unlocked(const struct Map *map);
// map_unlock
// file libslack/map.h line 55
signed int map_unlock(const struct Map *map);
// map_values
// file libslack/map.h line 95
struct List * map_values(struct Map *map);
// map_values_unlocked
// file libslack/map.c line 1799
struct List * map_values_unlocked(struct Map *map);
// map_values_with_locker
// file libslack/map.c line 1815
struct List * map_values_with_locker(struct Locker *locker, struct Map *map);
// map_values_with_locker_unlocked
// file libslack/map.c line 1845
struct List * map_values_with_locker_unlocked(struct Locker *locker, struct Map *map);
// map_wrlock
// file libslack/map.h line 54
signed int map_wrlock(const struct Map *map);
// mapper_create
// file libslack/map.h line 72
struct Mapper * mapper_create(struct Map *map);
// mapper_create_rdlocked
// file libslack/map.h line 73
struct Mapper * mapper_create_rdlocked(struct Map *map);
// mapper_create_unlocked
// file libslack/map.c line 1244
struct Mapper * mapper_create_unlocked(struct Map *map);
// mapper_create_wrlocked
// file libslack/map.h line 74
struct Mapper * mapper_create_wrlocked(struct Map *map);
// mapper_destroy
// file libslack/map.h line 78
void * mapper_destroy(struct Mapper **mapper);
// mapper_destroy_unlocked
// file libslack/map.c line 1341
void * mapper_destroy_unlocked(struct Mapper **mapper);
// mapper_has_next
// file libslack/map.h line 80
signed int mapper_has_next(struct Mapper *mapper);
// mapper_next
// file libslack/map.h line 81
void * mapper_next(struct Mapper *mapper);
// mapper_next_mapping
// file libslack/map.h line 82
const struct Mapping * mapper_next_mapping(struct Mapper *mapper);
// mapper_release
// file libslack/map.h line 76
void mapper_release(struct Mapper *mapper);
// mapper_release_unlocked
// file libslack/map.c line 1300
void mapper_release_unlocked(struct Mapper *mapper);
// mapper_remove
// file libslack/map.h line 83
void mapper_remove(struct Mapper *mapper);
// mapping_create
// file libslack/map.c line 238
static struct Mapping * mapping_create(void *key, void *value, void (*key_destroy)(void *), void (*value_destroy)(void *));
// mapping_create::key_destroy$object
// 
void key_destroy$object(void *);
// mapping_create::value_destroy$object
// 
void value_destroy$object(void *);
// mapping_key
// file libslack/map.h line 89
const void * mapping_key(const struct Mapping *mapping);
// mapping_release
// file libslack/map.c line 261
static void mapping_release(struct Mapping *mapping);
// mapping_value
// file libslack/map.h line 90
const void * mapping_value(const struct Mapping *mapping);
// measure
// file libslack/agent.c line 2017
static void measure(struct Agent *agent, signed int fd, struct timeval *now);
// mem_create_secure
// file libslack/mem.c line 270
void * mem_create_secure(unsigned long int size);
// mem_create_space
// file libslack/mem.c line 469
void * mem_create_space(unsigned long int size, ...);
// mem_destroy
// file libslack/mem.h line 48
void * mem_destroy(void **mem);
// mem_destroy_secure
// file libslack/mem.c line 373
void * mem_destroy_secure(void **mem);
// mem_release_secure
// file libslack/mem.c line 333
void mem_release_secure(void *mem);
// mem_resize_fn
// file libslack/mem.h line 46
void * mem_resize_fn(void **mem, unsigned long int size);
// mem_space_start
// file libslack/mem.c line 526
unsigned long int mem_space_start(unsigned long int size, ...);
// mem_strdup
// file libslack/mem.h line 54
char * mem_strdup(const char *str);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkfifo
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 349
extern signed int mkfifo(const char *, unsigned int);
// mlock
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 103
extern signed int mlock(const void *, unsigned long int);
// msg
// file libslack/err.c line 149
void msg(const char *format, ...);
// msg_add_plex
// file libslack/msg.c line 1222
signed int msg_add_plex(struct Msg *mesg, struct Msg *item);
// msg_add_plex_unlocked
// file libslack/msg.c line 1251
signed int msg_add_plex_unlocked(struct Msg *mesg, struct Msg *item);
// msg_create
// file libslack/msg.c line 230
struct Msg * msg_create(signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *));
// msg_create::destroy$object
// 
void destroy$object(void *);
// msg_create::out$object
// 
void out$object(void *, const void *, unsigned long int);
// msg_create_fd
// file libslack/msg.c line 533
struct Msg * msg_create_fd(signed int fd);
// msg_create_fd_with_locker
// file libslack/msg.c line 549
struct Msg * msg_create_fd_with_locker(struct Locker *locker, signed int fd);
// msg_create_file
// file libslack/msg.c line 763
struct Msg * msg_create_file(const char *path);
// msg_create_file_with_locker
// file libslack/msg.c line 779
struct Msg * msg_create_file_with_locker(struct Locker *locker, const char *path);
// msg_create_plex
// file libslack/msg.c line 1177
struct Msg * msg_create_plex(struct Msg *msg1, struct Msg *msg2);
// msg_create_plex_with_locker
// file libslack/msg.c line 1193
struct Msg * msg_create_plex_with_locker(struct Locker *locker, struct Msg *msg1, struct Msg *msg2);
// msg_create_stderr
// file libslack/msg.c line 579
struct Msg * msg_create_stderr(void);
// msg_create_stderr_with_locker
// file libslack/msg.c line 595
struct Msg * msg_create_stderr_with_locker(struct Locker *locker);
// msg_create_stdout
// file libslack/msg.c line 613
struct Msg * msg_create_stdout(void);
// msg_create_stdout_with_locker
// file libslack/msg.c line 629
struct Msg * msg_create_stdout_with_locker(struct Locker *locker);
// msg_create_syslog
// file libslack/msg.c line 897
struct Msg * msg_create_syslog(const char *ident, signed int option, signed int facility, signed int priority);
// msg_create_syslog_with_locker
// file libslack/msg.c line 913
struct Msg * msg_create_syslog_with_locker(struct Locker *locker, const char *ident, signed int option, signed int facility, signed int priority);
// msg_create_with_locker
// file libslack/msg.c line 246
struct Msg * msg_create_with_locker(struct Locker *locker, signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *));
// msg_create_with_locker::destroy$object
// 
void destroy$object(void *);
// msg_create_with_locker::out$object
// 
void out$object(void *, const void *, unsigned long int);
// msg_destroy
// file libslack/msg.c line 358
void * msg_destroy(struct Msg **mesg);
// msg_fddata_create
// file libslack/msg.c line 478
static signed int * msg_fddata_create(signed int fd);
// msg_fddata_release
// file libslack/msg.c line 499
static void msg_fddata_release(signed int *data);
// msg_filedata_create
// file libslack/msg.c line 671
static struct MsgFileData * msg_filedata_create(const char *path);
// msg_filedata_init
// file libslack/msg.c line 646
static signed int msg_filedata_init(struct MsgFileData *data, const char *path);
// msg_filedata_release
// file libslack/msg.c line 696
static void msg_filedata_release(struct MsgFileData *data);
// msg_out
// file libslack/msg.h line 50
void msg_out(struct Msg *dst, const char *format, ...);
// msg_out_fd
// file libslack/msg.c line 513
static void msg_out_fd(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_file
// file libslack/msg.c line 717
static void msg_out_file(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_plex
// file libslack/msg.c line 1147
static void msg_out_plex(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_syslog
// file libslack/msg.c line 875
static void msg_out_syslog(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_unlocked
// file libslack/msg.h line 51
void msg_out_unlocked(struct Msg *dst, const char *format, ...);
// msg_plexdata_add
// file libslack/msg.c line 1070
static signed int msg_plexdata_add(struct MsgPlexData *data, struct Msg *mesg);
// msg_plexdata_create
// file libslack/msg.c line 1099
static struct MsgPlexData * msg_plexdata_create(struct Msg *msg1, struct Msg *msg2);
// msg_plexdata_init
// file libslack/msg.c line 1048
static signed int msg_plexdata_init(struct MsgPlexData *data, struct Msg *msg1, struct Msg *msg2);
// msg_plexdata_release
// file libslack/msg.c line 1124
static void msg_plexdata_release(struct MsgPlexData *data);
// msg_rdlock
// file libslack/msg.c line 282
signed int msg_rdlock(struct Msg *mesg);
// msg_release
// file libslack/msg.c line 337
void msg_release(struct Msg *mesg);
// msg_set_timestamp_format
// file libslack/msg.c line 1271
const char * msg_set_timestamp_format(const char *format);
// msg_set_timestamp_format_locker
// file libslack/msg.c line 1304
signed int msg_set_timestamp_format_locker(struct Locker *locker);
// msg_sysdata_create
// file libslack/msg.c line 832
static struct MsgSyslogData * msg_sysdata_create(const char *ident, signed int option, signed int facility, signed int priority);
// msg_sysdata_init
// file libslack/msg.c line 808
static signed int msg_sysdata_init(struct MsgSyslogData *data, const char *ident, signed int option, signed int facility, signed int priority);
// msg_sysdata_release
// file libslack/msg.c line 857
static void msg_sysdata_release(struct MsgSyslogData *data);
// msg_syslog_set_facility
// file libslack/msg.c line 941
struct Msg * msg_syslog_set_facility(struct Msg *mesg, signed int facility);
// msg_syslog_set_facility_unlocked
// file libslack/msg.c line 971
struct Msg * msg_syslog_set_facility_unlocked(struct Msg *mesg, signed int facility);
// msg_syslog_set_priority
// file libslack/msg.c line 995
struct Msg * msg_syslog_set_priority(struct Msg *mesg, signed int priority);
// msg_syslog_set_priority_unlocked
// file libslack/msg.h line 67
struct Msg * msg_syslog_set_priority_unlocked(struct Msg *mesg, signed int priority);
// msg_unlock
// file libslack/msg.h line 47
signed int msg_unlock(struct Msg *mesg);
// msg_wrlock
// file libslack/msg.h line 46
signed int msg_wrlock(struct Msg *mesg);
// mt_test
// file libslack/map.c line 2675
void mt_test(signed int test, struct Locker *locker);
// munlock
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 106
extern signed int munlock(const void *, unsigned long int);
// nap
// file libslack/fio.c line 350
signed int nap(signed long int sec, signed long int usec);
// net_client
// file libslack/net.c line 369
signed int net_client(const char *host, const char *service, unsigned short int port, signed long int timeout, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_client_connect
// file libslack/net.c line 709
static signed int net_client_connect(struct sockaddr *remoteaddr, unsigned long int remotesize, unsigned short int localport, signed int type, signed int protocol, signed int timeout, struct sockopt_t *sockopts);
// net_create_client
// file libslack/net.c line 825
signed int net_create_client(const char *host, const char *service, unsigned short int port, unsigned short int localport, signed int type, signed int protocol, signed long int timeout, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize);
// net_create_server
// file libslack/net.c line 577
signed int net_create_server(const char *interface, const char *service, unsigned short int port, signed int type, signed int protocol, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize);
// net_expect
// file libslack/net.c line 3761
signed long int net_expect(signed int sockfd, signed long int timeout, const char *format, ...);
// net_gethostbyname
// file libslack/net.c line 1779
struct hostent * net_gethostbyname(const char *name, struct hostent *hostbuf, void **buf, unsigned long int *size, signed int *herrno);
// net_getservbyname
// file libslack/net.c line 1895
struct servent * net_getservbyname(const char *name, const char *proto, struct servent *servbuf, void **buf, unsigned long int *size);
// net_in6addr
// file libslack/net.c line 457
static struct sockaddr * net_in6addr(struct sockaddr_in6 *in6, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port);
// net_inaddr
// file libslack/net.c line 447
static struct sockaddr * net_inaddr(struct sockaddr_in *in, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port);
// net_interfaces
// file libslack/net.c line 2039
struct List * net_interfaces(void);
// net_interfaces_by_family
// file libslack/net.c line 2080
struct List * net_interfaces_by_family(signed int family);
// net_interfaces_by_family_with_locker
// file libslack/net.c line 2096
struct List * net_interfaces_by_family_with_locker(signed int family, struct Locker *locker);
// net_interfaces_with_locker
// file libslack/net.c line 2055
struct List * net_interfaces_with_locker(struct Locker *locker);
// net_multicast_get_interface
// file libslack/net.c line 1389
signed int net_multicast_get_interface(signed int sockfd);
// net_multicast_get_loopback
// file libslack/net.c line 1509
signed int net_multicast_get_loopback(signed int sockfd);
// net_multicast_get_ttl
// file libslack/net.c line 1603
signed int net_multicast_get_ttl(signed int sockfd);
// net_multicast_join
// file libslack/net.c line 1158
signed int net_multicast_join(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex);
// net_multicast_leave
// file libslack/net.c line 1238
signed int net_multicast_leave(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex);
// net_multicast_receiver
// file libslack/net.c line 1054
signed int net_multicast_receiver(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex);
// net_multicast_sender
// file libslack/net.c line 995
signed int net_multicast_sender(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex, signed int ttl, unsigned int noloopback);
// net_multicast_set_interface
// file libslack/net.c line 1319
signed int net_multicast_set_interface(signed int sockfd, const char *ifname, unsigned int ifindex);
// net_multicast_set_loopback
// file libslack/net.c line 1465
signed int net_multicast_set_loopback(signed int sockfd, unsigned int loopback);
// net_multicast_set_ttl
// file libslack/net.c line 1561
signed int net_multicast_set_ttl(signed int sockfd, signed int ttl);
// net_options
// file libslack/net.c line 1989
signed int net_options(signed int sockfd, struct sockopt_t *sockopts);
// net_pack
// file libslack/net.c line 2706
signed long int net_pack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...);
// net_packto
// file libslack/net.c line 2760
signed long int net_packto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, ...);
// net_read
// file libslack/net.c line 3687
signed long int net_read(signed int sockfd, signed long int timeout, char *buf, unsigned long int count);
// net_rudp_transact
// file libslack/net.c line 2557
signed long int net_rudp_transact(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, void *ibuf, unsigned long int isize);
// net_rudp_transactwith
// file libslack/net.c line 2582
signed long int net_rudp_transactwith(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, signed int oflags, void *ibuf, unsigned long int isize, signed int iflags, union sockaddr_any_t *addr, unsigned long int addrsize);
// net_send
// file libslack/net.c line 3813
signed long int net_send(signed int sockfd, signed long int timeout, const char *format, ...);
// net_server
// file libslack/net.c line 313
signed int net_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_tos_lowcost
// file libslack/net.c line 1718
signed int net_tos_lowcost(signed int sockfd);
// net_tos_lowdelay
// file libslack/net.c line 1655
signed int net_tos_lowdelay(signed int sockfd);
// net_tos_normal
// file libslack/net.c line 1736
signed int net_tos_normal(signed int sockfd);
// net_tos_reliability
// file libslack/net.c line 1695
signed int net_tos_reliability(signed int sockfd);
// net_tos_throughput
// file libslack/net.c line 1675
signed int net_tos_throughput(signed int sockfd);
// net_udp_client
// file libslack/net.c line 415
signed int net_udp_client(const char *host, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_udp_server
// file libslack/net.c line 392
signed int net_udp_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_unaddr
// file libslack/net.c line 439
static struct sockaddr * net_unaddr(struct sockaddr_un *un, unsigned long int family, const char *path);
// net_unpack
// file libslack/net.c line 2818
signed long int net_unpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...);
// net_unpackfrom
// file libslack/net.c line 2873
signed long int net_unpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, ...);
// net_vexpect
// file libslack/net.c line 3784
signed long int net_vexpect(signed int sockfd, signed long int timeout, const char *format, void **args);
// net_vpack
// file libslack/net.c line 2729
signed long int net_vpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args);
// net_vpackto
// file libslack/net.c line 2783
signed long int net_vpackto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, void **args);
// net_vsend
// file libslack/net.c line 3836
signed long int net_vsend(signed int sockfd, signed long int timeout, const char *format, void **args);
// net_vunpack
// file libslack/net.c line 2841
signed long int net_vunpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args);
// net_vunpackfrom
// file libslack/net.c line 2896
signed long int net_vunpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, void **args);
// net_write
// file libslack/net.c line 3720
signed long int net_write(signed int sockfd, signed long int timeout, const char *buf, unsigned long int count);
// new_shargv
// file libslack/coproc.c line 137
static char * const * new_shargv(const char *cmd, char * const *argv);
// next_day
// file libslack/agent.c line 1809
static void next_day(struct Agent *agent);
// next_hour
// file libslack/agent.c line 1846
static void next_hour(struct Agent *agent);
// next_minute
// file libslack/agent.c line 1867
static void next_minute(struct Agent *agent);
// next_second
// file libslack/agent.c line 1888
static void next_second(struct Agent *agent);
// nonblock_off
// file libslack/fio.c line 485
signed int nonblock_off(signed int fd);
// nonblock_on
// file libslack/fio.c line 468
signed int nonblock_on(signed int fd);
// nonblock_set
// file libslack/fio.c line 451
signed int nonblock_set(signed int fd, signed int arg);
// oct
// file libslack/str.c line 6469
signed int oct(const char *str);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// openpty
// file /usr/include/pty.h line 33
extern signed int openpty(signed int *, signed int *, char *, struct termios *, struct winsize *);
// opt_action
// file libslack/prog.c line 1889
static void opt_action(struct Options *options, signed int rc, signed int longindex, const char *argument);
// opt_convert
// file libslack/prog.c line 1762
static struct option * opt_convert(struct Options *options);
// opt_optstring
// file libslack/prog.c line 1806
static char * opt_optstring(struct Options *options);
// opt_process
// file libslack/prog.c line 2051
signed int opt_process(signed int argc, char **argv, struct Options *options, char *msgbuf, unsigned long int bufsize);
// opt_usage
// file libslack/prog.c line 2139
char * opt_usage(char *buf, unsigned long int size, struct Options *options);
// pack
// file libslack/net.c line 3000
signed long int pack(void *buf, unsigned long int size, const char *format, ...);
// pathconf
// file /usr/include/unistd.h line 612
extern signed long int pathconf(const char *, signed int);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// point_cmp
// file libslack/map.c line 2445
static signed int point_cmp(struct Point *a, struct Point *b);
// point_copy
// file libslack/map.c line 2440
static struct Point * point_copy(struct Point *point);
// point_create
// file libslack/map.c line 2427
static struct Point * point_create(signed int x, signed int y);
// point_hash
// file libslack/map.c line 2456
static unsigned long int point_hash(unsigned long int size, struct Point *point);
// point_release
// file libslack/map.c line 2461
static void point_release(struct Point *point);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// pool_alloc
// file libslack/mem.c line 919
void * pool_alloc(struct Pool *pool, unsigned long int size);
// pool_clear
// file libslack/mem.c line 980
void pool_clear(struct Pool *pool);
// pool_clear_secure
// file libslack/mem.c line 859
void pool_clear_secure(struct Pool *pool);
// pool_clear_unlocked
// file libslack/mem.c line 975
static void pool_clear_unlocked(struct Pool *pool);
// pool_clear_with_locker
// file libslack/mem.c line 956
static void pool_clear_with_locker(struct Pool *pool, signed int lock_pool);
// pool_create
// file libslack/mem.c line 616
struct Pool * pool_create(unsigned long int size);
// pool_create_secure
// file libslack/mem.c line 743
struct Pool * pool_create_secure(unsigned long int size);
// pool_create_secure_with_locker
// file libslack/mem.c line 759
struct Pool * pool_create_secure_with_locker(struct Locker *locker, unsigned long int size);
// pool_create_with_locker
// file libslack/mem.c line 632
struct Pool * pool_create_with_locker(struct Locker *locker, unsigned long int size);
// pool_destroy
// file libslack/mem.c line 714
void * pool_destroy(struct Pool **pool);
// pool_destroy_secure
// file libslack/mem.c line 834
void * pool_destroy_secure(struct Pool **pool);
// pool_release
// file libslack/mem.c line 680
void pool_release(struct Pool *pool);
// pool_release_secure
// file libslack/mem.c line 797
void pool_release_secure(struct Pool *pool);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// produce
// file libslack/map.c line 2497
void * produce(void *arg);
// prog_alert
// file libslack/prog.h line 123
struct Msg * prog_alert(void);
// prog_alert_fd
// file libslack/prog.c line 1305
signed int prog_alert_fd(signed int fd);
// prog_alert_file
// file libslack/prog.c line 1367
signed int prog_alert_file(const char *path);
// prog_alert_none
// file libslack/prog.c line 1423
signed int prog_alert_none(void);
// prog_alert_stderr
// file libslack/prog.c line 1350
signed int prog_alert_stderr(void);
// prog_alert_stdout
// file libslack/prog.c line 1333
signed int prog_alert_stdout(void);
// prog_alert_syslog
// file libslack/prog.c line 1395
signed int prog_alert_syslog(const char *id, signed int option, signed int facility, signed int priority);
// prog_author
// file libslack/prog.c line 757
const char * prog_author(void);
// prog_basename
// file libslack/prog.c line 1668
const char * prog_basename(const char *path);
// prog_contact
// file libslack/prog.c line 773
const char * prog_contact(void);
// prog_date
// file libslack/prog.c line 741
const char * prog_date(void);
// prog_dbg
// file libslack/prog.h line 122
struct Msg * prog_dbg(void);
// prog_dbg_fd
// file libslack/prog.c line 1170
signed int prog_dbg_fd(signed int fd);
// prog_dbg_file
// file libslack/prog.c line 1232
signed int prog_dbg_file(const char *path);
// prog_dbg_none
// file libslack/prog.c line 1288
signed int prog_dbg_none(void);
// prog_dbg_stderr
// file libslack/prog.c line 1215
signed int prog_dbg_stderr(void);
// prog_dbg_stdout
// file libslack/prog.c line 1198
signed int prog_dbg_stdout(void);
// prog_dbg_syslog
// file libslack/prog.c line 1260
signed int prog_dbg_syslog(const char *id, signed int option, signed int facility, signed int priority);
// prog_debug_level
// file libslack/prog.h line 124
unsigned long int prog_debug_level(void);
// prog_desc
// file libslack/prog.c line 709
const char * prog_desc(void);
// prog_err
// file libslack/prog.h line 121
struct Msg * prog_err(void);
// prog_err_fd
// file libslack/prog.c line 1052
signed int prog_err_fd(signed int fd);
// prog_err_file
// file libslack/prog.c line 1097
signed int prog_err_file(const char *path);
// prog_err_none
// file libslack/prog.c line 1153
signed int prog_err_none(void);
// prog_err_stderr
// file libslack/prog.c line 1080
signed int prog_err_stderr(void);
// prog_err_syslog
// file libslack/prog.c line 1125
signed int prog_err_syslog(const char *ident, signed int option, signed int facility, signed int priority);
// prog_help_msg
// file libslack/prog.c line 1540
void prog_help_msg(void);
// prog_init
// file libslack/prog.c line 245
void prog_init(void);
// prog_legal
// file libslack/prog.c line 821
const char * prog_legal(void);
// prog_name
// file libslack/prog.h line 109
const char * prog_name(void);
// prog_opt_process
// file libslack/prog.c line 1452
signed int prog_opt_process(signed int ac, char **av);
// prog_options
// file libslack/prog.c line 677
const struct Options * prog_options(void);
// prog_out
// file libslack/prog.h line 120
struct Msg * prog_out(void);
// prog_out_fd
// file libslack/prog.c line 934
signed int prog_out_fd(signed int fd);
// prog_out_file
// file libslack/prog.c line 978
signed int prog_out_file(const char *path);
// prog_out_none
// file libslack/prog.c line 1033
signed int prog_out_none(void);
// prog_out_stdout
// file libslack/prog.c line 961
signed int prog_out_stdout(void);
// prog_out_syslog
// file libslack/prog.c line 1006
signed int prog_out_syslog(const char *ident, signed int option, signed int facility, signed int priority);
// prog_set_alert
// file libslack/prog.c line 555
struct Msg * prog_set_alert(struct Msg *alert);
// prog_set_author
// file libslack/prog.c line 408
const char * prog_set_author(const char *author);
// prog_set_contact
// file libslack/prog.c line 426
const char * prog_set_contact(const char *contact);
// prog_set_date
// file libslack/prog.c line 391
const char * prog_set_date(const char *date);
// prog_set_dbg
// file libslack/prog.c line 537
struct Msg * prog_set_dbg(struct Msg *dbg);
// prog_set_debug_level
// file libslack/prog.c line 603
signed long int prog_set_debug_level(unsigned long int debug_level);
// prog_set_desc
// file libslack/prog.c line 357
const char * prog_set_desc(const char *desc);
// prog_set_err
// file libslack/prog.c line 519
struct Msg * prog_set_err(struct Msg *err);
// prog_set_legal
// file libslack/prog.c line 478
const char * prog_set_legal(const char *legal);
// prog_set_locker
// file libslack/prog.c line 640
signed int prog_set_locker(struct Locker *locker);
// prog_set_name
// file libslack/prog.c line 305
const char * prog_set_name(const char *name);
// prog_set_options
// file libslack/prog.c line 322
struct Options * prog_set_options(struct Options *options);
// prog_set_out
// file libslack/prog.c line 499
struct Msg * prog_set_out(struct Msg *out);
// prog_set_syntax
// file libslack/prog.c line 340
const char * prog_set_syntax(const char *syntax);
// prog_set_url
// file libslack/prog.c line 460
const char * prog_set_url(const char *url);
// prog_set_vendor
// file libslack/prog.c line 443
const char * prog_set_vendor(const char *vendor);
// prog_set_verbosity_level
// file libslack/prog.c line 622
signed long int prog_set_verbosity_level(unsigned long int verbosity_level);
// prog_set_version
// file libslack/prog.c line 374
const char * prog_set_version(const char *version);
// prog_syntax
// file libslack/prog.c line 693
const char * prog_syntax(void);
// prog_url
// file libslack/prog.c line 805
const char * prog_url(void);
// prog_usage_msg
// file libslack/prog.c line 1495
void prog_usage_msg(const char *format, ...);
// prog_vendor
// file libslack/prog.c line 789
const char * prog_vendor(void);
// prog_verbosity_level
// file libslack/prog.h line 125
unsigned long int prog_verbosity_level(void);
// prog_version
// file libslack/prog.c line 725
const char * prog_version(void);
// prog_version_msg
// file libslack/prog.c line 1634
void prog_version_msg(void);
// prop_clear
// file libslack/prop.c line 1121
signed int prop_clear(void);
// prop_create
// file libslack/prop.c line 153
static struct Prop * prop_create(struct Map *map, struct Prop *defaults);
// prop_get
// file libslack/prop.c line 540
const char * prop_get(const char *name);
// prop_get_bool
// file libslack/prop.c line 759
signed int prop_get_bool(const char *name);
// prop_get_bool_or
// file libslack/prop.c line 779
signed int prop_get_bool_or(const char *name, signed int default_value);
// prop_get_double
// file libslack/prop.c line 701
double prop_get_double(const char *name);
// prop_get_double_or
// file libslack/prop.c line 718
double prop_get_double_or(const char *name, double default_value);
// prop_get_int
// file libslack/prop.c line 644
signed int prop_get_int(const char *name);
// prop_get_int_or
// file libslack/prop.c line 661
signed int prop_get_int_or(const char *name, signed int default_value);
// prop_get_or
// file libslack/prop.c line 576
const char * prop_get_or(const char *name, const char *default_value);
// prop_init
// file libslack/prop.c line 434
static signed int prop_init(void);
// prop_load
// file libslack/prop.c line 392
static struct Prop * prop_load(const char *path, struct Prop *defaults);
// prop_locker
// file libslack/prop.c line 1152
signed int prop_locker(struct Locker *locker);
// prop_parse
// file libslack/prop.c line 299
static void prop_parse(struct Map *map, const char *path, char *line, unsigned long int lineno);
// prop_release
// file libslack/prop.c line 174
static void prop_release(struct Prop *prop);
// prop_save
// file libslack/prop.c line 914
signed int prop_save(void);
// prop_set
// file libslack/prop.c line 597
const char * prop_set(const char *name, const char *value);
// prop_set_bool
// file libslack/prop.c line 847
signed int prop_set_bool(const char *name, signed int value);
// prop_set_double
// file libslack/prop.c line 739
double prop_set_double(const char *name, double value);
// prop_set_int
// file libslack/prop.c line 682
signed int prop_set_int(const char *name, signed int value);
// prop_unset
// file libslack/prop.c line 866
signed int prop_unset(const char *name);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$11 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$11 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$11 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous$12 *);
// pthread_rwlock_tryrdlock
// file /usr/include/pthread.h line 903
extern signed int pthread_rwlock_tryrdlock(union anonymous$12 *);
// pthread_rwlock_trywrlock
// file /usr/include/pthread.h line 918
extern signed int pthread_rwlock_trywrlock(union anonymous$12 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous$12 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous$12 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pty_change_window_size
// file libslack/pseudo.c line 716
signed int pty_change_window_size(signed int masterfd, signed int row, signed int col, signed int xpixel, signed int ypixel);
// pty_fork
// file libslack/pseudo.h line 54
signed int pty_fork(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize);
// pty_make_controlling_tty
// file libslack/pseudo.c line 637
signed int pty_make_controlling_tty(signed int *slavefd, const char *slavename);
// pty_make_controlling_tty::1::old$object
// 
void old$object(signed int);
// pty_open
// file libslack/pseudo.c line 217
signed int pty_open(signed int *masterfd, signed int *slavefd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize);
// pty_release
// file libslack/pseudo.h line 50
signed int pty_release(const char *slavename);
// pty_set_owner
// file libslack/pseudo.c line 595
signed int pty_set_owner(const char *slavename, unsigned int uid);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// quote
// file libslack/str.c line 5126
struct String * quote(const char *str, const char *quotable, char quote_char);
// quote_equals
// file libslack/prop.c line 244
static struct String * quote_equals(const char *src);
// quote_special
// file libslack/prop.c line 213
static struct String * quote_special(const char *src);
// quote_with_locker
// file libslack/str.c line 5142
struct String * quote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// rcpt
// file libslack/net.c line 4112
static signed int rcpt(signed int smtp, const char *recipients);
// react
// file libslack/agent.c line 1942
static signed int react(signed int (*reaction)(struct Agent *, signed int, signed int, void *), struct Agent *agent, signed int fd, signed int revents, void *arg);
// react::reaction$object
// 
signed int reaction$object(struct Agent *, signed int, signed int, void *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_timeout
// file libslack/fio.c line 201
signed int read_timeout(signed int fd, signed long int sec, signed long int usec);
// reader
// file libslack/map.c line 2639
void * reader(void *arg);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// readv
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 39
extern signed long int readv(signed int, struct iovec *, signed int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfd
// file libslack/net.h line 142
signed long int recvfd(signed int sockfd, void *buf, unsigned long int nbytes, signed int flags, signed int *fd);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$7 *, signed int);
// regexpr
// file libslack/str.c line 3117
struct List * regexpr(const char *pattern, const char *text, signed int cflags, signed int eflags);
// regexpr_compile
// file libslack/str.c line 3166
signed int regexpr_compile(struct re_pattern_buffer *compiled, const char *pattern, signed int cflags);
// regexpr_compiled
// file libslack/str.c line 3291
struct List * regexpr_compiled(const struct re_pattern_buffer *compiled, const char *text, signed int eflags);
// regexpr_compiled_with_locker
// file libslack/str.c line 3307
struct List * regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const char *text, signed int eflags);
// regexpr_release
// file libslack/str.c line 3184
void regexpr_release(struct re_pattern_buffer *compiled);
// regexpr_split
// file libslack/str.c line 4236
struct List * regexpr_split(const char *str, const char *delim, signed int cflags, signed int eflags);
// regexpr_split_with_locker
// file libslack/str.c line 4252
struct List * regexpr_split_with_locker(struct Locker *locker, const char *str, const char *delim, signed int cflags, signed int eflags);
// regexpr_with_locker
// file libslack/str.c line 3133
struct List * regexpr_with_locker(struct Locker *locker, const char *pattern, const char *text, signed int cflags, signed int eflags);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// release_action
// file libslack/agent.c line 273
static struct action_t * release_action(struct action_t *action);
// release_actions
// file libslack/agent.c line 282
static void release_actions(struct action_t *action);
// rudp_create
// file libslack/net.c line 2363
struct rudp_t * rudp_create(void);
// rudp_destroy
// file libslack/net.c line 2406
void * rudp_destroy(struct rudp_t **rudp);
// rudp_init
// file libslack/net.c line 2342
static signed int rudp_init(struct rudp_t *rudp);
// rudp_minmax
// file libslack/net.c line 2331
static double rudp_minmax(double rto);
// rudp_newpack
// file libslack/net.c line 2453
static unsigned int rudp_newpack(struct rudp_t *rudp);
// rudp_release
// file libslack/net.c line 2390
void rudp_release(struct rudp_t *rudp);
// rudp_start
// file libslack/net.c line 2473
static double rudp_start(struct rudp_t *rudp);
// rudp_stop
// file libslack/net.c line 2492
static signed int rudp_stop(struct rudp_t *rudp, unsigned int rtt);
// rudp_timeout
// file libslack/net.c line 2520
static signed int rudp_timeout(struct rudp_t *rudp);
// rudp_timestamp
// file libslack/net.c line 2428
static unsigned int rudp_timestamp(struct rudp_t *rudp);
// rw_timeout
// file libslack/fio.c line 297
signed int rw_timeout(signed int fd, signed long int sec, signed long int usec);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$10 *, struct anonymous$10 *, struct anonymous$10 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendfd
// file libslack/net.h line 141
signed long int sendfd(signed int sockfd, const void *buf, unsigned long int nbytes, signed int flags, signed int fd);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// service_number
// file libslack/net.c line 525
static signed int service_number(const char *service);
// service_port
// file libslack/net.c line 539
static unsigned short int service_port(const char *service, signed int type, signed int port);
// set_errno
// file libslack/err.h line 83
signed int set_errno(signed int errnum);
// set_errnull
// file libslack/err.h line 84
void * set_errnull(signed int errnum);
// set_errnullf
// file libslack/err.c line 748
void (*set_errnullf(signed int errnum))();
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setgroups
// file /usr/include/grp.h line 179
extern signed int setgroups(unsigned long int, const unsigned int *);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(signed int, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// shrink
// file libslack/list.c line 247
static signed int shrink(struct List *list, unsigned long int items);
// shrink$link1
// file libslack/str.c line 426
static signed int shrink$link1(struct String *str, unsigned long int bytes);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$6 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$6 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signal_addset
// file libslack/sig.c line 201
signed int signal_addset(signed int signo_handled, signed int signo_blocked);
// signal_catcher
// file libslack/sig.c line 120
static void signal_catcher(signed int signo);
// signal_handle
// file libslack/sig.c line 264
signed int signal_handle(signed int signo);
// signal_handle_all
// file libslack/sig.c line 292
void signal_handle_all(void);
// signal_raise
// file libslack/sig.c line 242
signed int signal_raise(signed int signo);
// signal_received
// file libslack/sig.c line 221
signed int signal_received(signed int signo);
// signal_set_handler
// file libslack/sig.c line 149
signed int signal_set_handler(signed int signo, signed int flags, void (*handler)(signed int));
// signal_set_handler::handler$object
// 
void handler$object(signed int);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous$6 *, struct anonymous$6 *);
// slink_alloc
// file libslack/link.c line 460
void * slink_alloc(void **freelist);
// slink_free
// file libslack/link.c line 518
void * slink_free(void **freelist, void *item);
// slink_freelist_attach
// file libslack/link.c line 396
void * slink_freelist_attach(void *freelist1, void *freelist2);
// slink_freelist_init
// file libslack/link.c line 334
void * slink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size);
// slink_has_next
// file libslack/link.c line 105
signed int slink_has_next(void *link);
// slink_insert
// file libslack/link.c line 220
void * slink_insert(void *link, void *item);
// slink_next
// file libslack/link.c line 124
void * slink_next(void *link);
// slink_remove
// file libslack/link.c line 280
void * slink_remove(void *link);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_cmp
// file libslack/map.c line 2409
static signed int sort_cmp(const char **a, const char **b);
// soundex
// file libslack/str.c line 4592
signed int soundex(const char *str);
// split
// file libslack/str.h line 175
struct List * split(const char *str, const char *delim);
// split_with_locker
// file libslack/str.c line 4128
struct List * split_with_locker(struct Locker *locker, const char *str, const char *delim);
// squeeze
// file libslack/str.c line 4982
char * squeeze(char *str);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// stat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link1(const char *__path$link1, struct stat *__statbuf$link1);
// stat$link2
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link2(const char *__path$link2, struct stat *__statbuf$link2);
// stat$link3
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link3(const char *__path$link3, struct stat *__statbuf$link3);
// str_append
// file libslack/str.c line 1538
struct String * str_append(struct String *str, const char *format, ...);
// str_append_str
// file libslack/str.c line 1610
struct String * str_append_str(struct String *str, const struct String *src);
// str_append_str_unlocked
// file libslack/str.c line 1628
struct String * str_append_str_unlocked(struct String *str, const struct String *src);
// str_append_unlocked
// file libslack/str.c line 1558
struct String * str_append_unlocked(struct String *str, const char *format, ...);
// str_bin
// file libslack/str.c line 6235
signed int str_bin(const struct String *str);
// str_bin_unlocked
// file libslack/str.c line 6264
signed int str_bin_unlocked(const struct String *str);
// str_chomp
// file libslack/str.c line 6141
signed int str_chomp(struct String *str);
// str_chomp_unlocked
// file libslack/str.c line 6170
signed int str_chomp_unlocked(struct String *str);
// str_chop
// file libslack/str.c line 6055
signed int str_chop(struct String *str);
// str_chop_unlocked
// file libslack/str.c line 6084
signed int str_chop_unlocked(struct String *str);
// str_clear
// file libslack/str.c line 1212
struct String * str_clear(struct String *str);
// str_clear_unlocked
// file libslack/str.c line 1227
struct String * str_clear_unlocked(struct String *str);
// str_copy
// file libslack/str.c line 740
struct String * str_copy(const struct String *str);
// str_copy_unlocked
// file libslack/str.c line 755
struct String * str_copy_unlocked(const struct String *str);
// str_copy_with_locker
// file libslack/str.c line 771
struct String * str_copy_with_locker(struct Locker *locker, const struct String *str);
// str_copy_with_locker_unlocked
// file libslack/str.c line 787
struct String * str_copy_with_locker_unlocked(struct Locker *locker, const struct String *str);
// str_create
// file libslack/str.c line 531
struct String * str_create(const char *format, ...);
// str_create_sized
// file libslack/str.c line 609
struct String * str_create_sized(unsigned long int size, const char *format, ...);
// str_create_with_locker
// file libslack/str.c line 552
struct String * str_create_with_locker(struct Locker *locker, const char *format, ...);
// str_create_with_locker_sized
// file libslack/str.c line 630
struct String * str_create_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, ...);
// str_decode
// file libslack/str.c line 5606
struct String * str_decode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_decode_unlocked
// file libslack/str.c line 5621
struct String * str_decode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_decode_with_locker
// file libslack/str.c line 5637
struct String * str_decode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_decode_with_locker_unlocked
// file libslack/str.c line 5670
struct String * str_decode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_destroy
// file libslack/str.c line 894
void * str_destroy(struct String **str);
// str_empty
// file libslack/str.c line 987
signed int str_empty(const struct String *str);
// str_empty_unlocked
// file libslack/str.c line 1016
signed int str_empty_unlocked(const struct String *str);
// str_encode
// file libslack/str.c line 5517
struct String * str_encode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_encode_unlocked
// file libslack/str.c line 5532
struct String * str_encode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_encode_with_locker
// file libslack/str.c line 5548
struct String * str_encode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_encode_with_locker_unlocked
// file libslack/str.c line 5581
struct String * str_encode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_fgetline
// file libslack/str.c line 812
struct String * str_fgetline(struct _IO_FILE *stream);
// str_fgetline_with_locker
// file libslack/str.c line 828
struct String * str_fgetline_with_locker(struct Locker *locker, struct _IO_FILE *stream);
// str_fmt
// file libslack/str.c line 3675
struct List * str_fmt(const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_fmt_unlocked
// file libslack/str.c line 3690
struct List * str_fmt_unlocked(const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_fmt_with_locker
// file libslack/str.c line 3706
struct List * str_fmt_with_locker(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_fmt_with_locker_unlocked
// file libslack/str.c line 3739
struct List * str_fmt_with_locker_unlocked(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_hex
// file libslack/str.c line 6321
signed int str_hex(const struct String *str);
// str_hex_unlocked
// file libslack/str.c line 6350
signed int str_hex_unlocked(const struct String *str);
// str_insert
// file libslack/str.h line 93
struct String * str_insert(struct String *str, signed long int index, const char *format, ...);
// str_insert_str
// file libslack/str.c line 1457
struct String * str_insert_str(struct String *str, signed long int index, const struct String *src);
// str_insert_str_unlocked
// file libslack/str.c line 1501
struct String * str_insert_str_unlocked(struct String *str, signed long int index, const struct String *src);
// str_insert_unlocked
// file libslack/str.c line 1368
struct String * str_insert_unlocked(struct String *str, signed long int index, const char *format, ...);
// str_join
// file libslack/str.c line 4341
struct String * str_join(const struct List *list, const char *delim);
// str_join_unlocked
// file libslack/str.c line 4356
struct String * str_join_unlocked(const struct List *list, const char *delim);
// str_join_with_locker
// file libslack/str.c line 4372
struct String * str_join_with_locker(struct Locker *locker, const struct List *list, const char *delim);
// str_join_with_locker_unlocked
// file libslack/str.c line 4402
struct String * str_join_with_locker_unlocked(struct Locker *locker, const struct List *list, const char *delim);
// str_lc
// file libslack/str.c line 5757
struct String * str_lc(struct String *str);
// str_lc_unlocked
// file libslack/str.c line 5786
struct String * str_lc_unlocked(struct String *str);
// str_lcfirst
// file libslack/str.c line 5834
struct String * str_lcfirst(struct String *str);
// str_lcfirst_unlocked
// file libslack/str.c line 5863
struct String * str_lcfirst_unlocked(struct String *str);
// str_length
// file libslack/str.h line 80
signed long int str_length(const struct String *str);
// str_length_unlocked
// file libslack/str.c line 1063
signed long int str_length_unlocked(const struct String *str);
// str_oct
// file libslack/str.c line 6418
signed int str_oct(const struct String *str);
// str_oct_unlocked
// file libslack/str.c line 6447
signed int str_oct_unlocked(const struct String *str);
// str_prepend
// file libslack/str.c line 1644
struct String * str_prepend(struct String *str, const char *format, ...);
// str_prepend_str
// file libslack/str.c line 1716
struct String * str_prepend_str(struct String *str, const struct String *src);
// str_prepend_str_unlocked
// file libslack/str.c line 1734
struct String * str_prepend_str_unlocked(struct String *str, const struct String *src);
// str_prepend_unlocked
// file libslack/str.c line 1664
struct String * str_prepend_unlocked(struct String *str, const char *format, ...);
// str_quote
// file libslack/str.c line 5023
struct String * str_quote(const struct String *str, const char *quotable, char quote_char);
// str_quote_unlocked
// file libslack/str.c line 5038
struct String * str_quote_unlocked(const struct String *str, const char *quotable, char quote_char);
// str_quote_with_locker
// file libslack/str.c line 5054
struct String * str_quote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_quote_with_locker_unlocked
// file libslack/str.c line 5090
struct String * str_quote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_rdlock
// file libslack/str.c line 929
signed int str_rdlock(const struct String *str);
// str_recalc_length
// file libslack/str.c line 1161
signed long int str_recalc_length(struct String *str);
// str_recalc_length_unlocked
// file libslack/str.c line 1191
signed long int str_recalc_length_unlocked(struct String *str);
// str_regexpr
// file libslack/str.c line 3035
struct List * str_regexpr(const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regexpr_compiled
// file libslack/str.c line 3208
struct List * str_regexpr_compiled(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_compiled_unlocked
// file libslack/str.c line 3224
struct List * str_regexpr_compiled_unlocked(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_compiled_with_locker
// file libslack/str.c line 3240
struct List * str_regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_compiled_with_locker_unlocked
// file libslack/str.c line 3273
struct List * str_regexpr_compiled_with_locker_unlocked(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_split
// file libslack/str.c line 4154
struct List * str_regexpr_split(const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_split_unlocked
// file libslack/str.c line 4169
struct List * str_regexpr_split_unlocked(const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_split_with_locker
// file libslack/str.c line 4185
struct List * str_regexpr_split_with_locker(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_split_with_locker_unlocked
// file libslack/str.c line 4218
struct List * str_regexpr_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_unlocked
// file libslack/str.c line 3050
struct List * str_regexpr_unlocked(const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regexpr_with_locker
// file libslack/str.c line 3066
struct List * str_regexpr_with_locker(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regexpr_with_locker_unlocked
// file libslack/str.c line 3099
struct List * str_regexpr_with_locker_unlocked(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regsub
// file libslack/str.c line 3382
struct String * str_regsub(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all);
// str_regsub_compiled
// file libslack/str.c line 3439
struct String * str_regsub_compiled(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all);
// str_regsub_compiled_unlocked
// file libslack/str.c line 3469
struct String * str_regsub_compiled_unlocked(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all);
// str_regsub_unlocked
// file libslack/str.c line 3410
struct String * str_regsub_unlocked(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all);
// str_release
// file libslack/str.h line 73
void str_release(struct String *str);
// str_remove
// file libslack/str.c line 1246
struct String * str_remove(struct String *str, signed long int index);
// str_remove_range
// file libslack/str.c line 1280
struct String * str_remove_range(struct String *str, signed long int index, signed long int range);
// str_remove_range_unlocked
// file libslack/str.c line 1309
struct String * str_remove_range_unlocked(struct String *str, signed long int index, signed long int range);
// str_remove_unlocked
// file libslack/str.c line 1261
struct String * str_remove_unlocked(struct String *str, signed long int index);
// str_repeat
// file libslack/str.c line 2211
struct String * str_repeat(unsigned long int count, const char *format, ...);
// str_repeat_with_locker
// file libslack/str.c line 2232
struct String * str_repeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, ...);
// str_replace
// file libslack/str.c line 1754
struct String * str_replace(struct String *str, signed long int index, signed long int range, const char *format, ...);
// str_replace_str
// file libslack/str.c line 1852
struct String * str_replace_str(struct String *str, signed long int index, signed long int range, const struct String *src);
// str_replace_str_unlocked
// file libslack/str.c line 1896
struct String * str_replace_str_unlocked(struct String *str, signed long int index, signed long int range, const struct String *src);
// str_replace_unlocked
// file libslack/str.c line 1774
struct String * str_replace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, ...);
// str_set_length
// file libslack/str.c line 1107
signed long int str_set_length(struct String *str, unsigned long int length);
// str_set_length_unlocked
// file libslack/str.c line 1136
signed long int str_set_length_unlocked(struct String *str, unsigned long int length);
// str_soundex
// file libslack/str.c line 4545
signed int str_soundex(const struct String *str);
// str_soundex_unlocked
// file libslack/str.c line 4574
signed int str_soundex_unlocked(const struct String *str);
// str_splice
// file libslack/str.c line 2114
struct String * str_splice(struct String *str, signed long int index, signed long int range);
// str_splice_unlocked
// file libslack/str.c line 2129
struct String * str_splice_unlocked(struct String *str, signed long int index, signed long int range);
// str_splice_with_locker
// file libslack/str.c line 2145
struct String * str_splice_with_locker(struct Locker *locker, struct String *str, signed long int index, signed long int range);
// str_splice_with_locker_unlocked
// file libslack/str.c line 2178
struct String * str_splice_with_locker_unlocked(struct Locker *locker, struct String *str, signed long int index, signed long int range);
// str_split
// file libslack/str.c line 4030
struct List * str_split(const struct String *str, const char *delim);
// str_split_unlocked
// file libslack/str.c line 4045
struct List * str_split_unlocked(const struct String *str, const char *delim);
// str_split_with_locker
// file libslack/str.c line 4061
struct List * str_split_with_locker(struct Locker *locker, const struct String *str, const char *delim);
// str_split_with_locker_unlocked
// file libslack/str.c line 4094
struct List * str_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim);
// str_squeeze
// file libslack/str.c line 4914
struct String * str_squeeze(struct String *str);
// str_squeeze_unlocked
// file libslack/str.c line 4943
struct String * str_squeeze_unlocked(struct String *str);
// str_substr
// file libslack/str.c line 1945
struct String * str_substr(const struct String *str, signed long int index, signed long int range);
// str_substr_unlocked
// file libslack/str.c line 1960
struct String * str_substr_unlocked(const struct String *str, signed long int index, signed long int range);
// str_substr_with_locker
// file libslack/str.c line 1976
struct String * str_substr_with_locker(struct Locker *locker, const struct String *str, signed long int index, signed long int range);
// str_substr_with_locker_unlocked
// file libslack/str.c line 2006
struct String * str_substr_with_locker_unlocked(struct Locker *locker, const struct String *str, signed long int index, signed long int range);
// str_tr
// file libslack/str.c line 2371
signed int str_tr(struct String *str, const char *from, const char *to, signed int option);
// str_tr_compile
// file libslack/str.c line 2549
struct StringTR * str_tr_compile(const struct String *from, const struct String *to, signed int option);
// str_tr_compile_table
// file libslack/str.c line 2808
static struct StringTR * str_tr_compile_table(struct StringTR *table, const struct String *from, const struct String *to, signed int option);
// str_tr_compile_table_unlocked
// file libslack/str.c line 2845
static struct StringTR * str_tr_compile_table_unlocked(struct StringTR *table, const struct String *from, const struct String *to, signed int option);
// str_tr_compile_unlocked
// file libslack/str.c line 2565
struct StringTR * str_tr_compile_unlocked(const struct String *from, const struct String *to, signed int option);
// str_tr_compile_with_locker
// file libslack/str.c line 2581
struct StringTR * str_tr_compile_with_locker(struct Locker *locker, const struct String *from, const struct String *to, signed int option);
// str_tr_compile_with_locker_unlocked
// file libslack/str.c line 2606
struct StringTR * str_tr_compile_with_locker_unlocked(struct Locker *locker, const struct String *from, const struct String *to, signed int option);
// str_tr_compiled
// file libslack/str.c line 2930
signed int str_tr_compiled(struct String *str, struct StringTR *table);
// str_tr_compiled_unlocked
// file libslack/str.c line 2971
signed int str_tr_compiled_unlocked(struct String *str, struct StringTR *table);
// str_tr_str
// file libslack/str.c line 2425
signed int str_tr_str(struct String *str, const struct String *from, const struct String *to, signed int option);
// str_tr_str_unlocked
// file libslack/str.c line 2455
signed int str_tr_str_unlocked(struct String *str, const struct String *from, const struct String *to, signed int option);
// str_tr_unlocked
// file libslack/str.c line 2396
signed int str_tr_unlocked(struct String *str, const char *from, const char *to, signed int option);
// str_trim
// file libslack/str.c line 4644
struct String * str_trim(struct String *str);
// str_trim_left
// file libslack/str.c line 4744
struct String * str_trim_left(struct String *str);
// str_trim_left_unlocked
// file libslack/str.c line 4773
struct String * str_trim_left_unlocked(struct String *str);
// str_trim_right
// file libslack/str.c line 4830
struct String * str_trim_right(struct String *str);
// str_trim_right_unlocked
// file libslack/str.c line 4859
struct String * str_trim_right_unlocked(struct String *str);
// str_trim_unlocked
// file libslack/str.c line 4673
struct String * str_trim_unlocked(struct String *str);
// str_uc
// file libslack/str.c line 5906
struct String * str_uc(struct String *str);
// str_uc_unlocked
// file libslack/str.c line 5935
struct String * str_uc_unlocked(struct String *str);
// str_ucfirst
// file libslack/str.c line 5983
struct String * str_ucfirst(struct String *str);
// str_ucfirst_unlocked
// file libslack/str.c line 6012
struct String * str_ucfirst_unlocked(struct String *str);
// str_unlock
// file libslack/str.c line 971
signed int str_unlock(const struct String *str);
// str_unquote
// file libslack/str.c line 5182
struct String * str_unquote(const struct String *str, const char *quotable, char quote_char);
// str_unquote_unlocked
// file libslack/str.c line 5197
struct String * str_unquote_unlocked(const struct String *str, const char *quotable, char quote_char);
// str_unquote_with_locker
// file libslack/str.c line 5213
struct String * str_unquote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_unquote_with_locker_unlocked
// file libslack/str.c line 5250
struct String * str_unquote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_vappend
// file libslack/str.c line 1579
struct String * str_vappend(struct String *str, const char *format, void **args);
// str_vappend_unlocked
// file libslack/str.c line 1594
struct String * str_vappend_unlocked(struct String *str, const char *format, void **args);
// str_vcreate
// file libslack/str.c line 573
struct String * str_vcreate(const char *format, void **args);
// str_vcreate_sized
// file libslack/str.c line 651
struct String * str_vcreate_sized(unsigned long int size, const char *format, void **args);
// str_vcreate_with_locker
// file libslack/str.c line 589
struct String * str_vcreate_with_locker(struct Locker *locker, const char *format, void **args);
// str_vcreate_with_locker_sized
// file libslack/str.c line 671
struct String * str_vcreate_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, void **args);
// str_vinsert
// file libslack/str.c line 1389
struct String * str_vinsert(struct String *str, signed long int index, const char *format, void **args);
// str_vinsert_unlocked
// file libslack/str.c line 1418
struct String * str_vinsert_unlocked(struct String *str, signed long int index, const char *format, void **args);
// str_vprepend
// file libslack/str.c line 1685
struct String * str_vprepend(struct String *str, const char *format, void **args);
// str_vprepend_unlocked
// file libslack/str.c line 1700
struct String * str_vprepend_unlocked(struct String *str, const char *format, void **args);
// str_vrepeat
// file libslack/str.c line 2253
struct String * str_vrepeat(unsigned long int count, const char *format, void **args);
// str_vrepeat_with_locker
// file libslack/str.c line 2269
struct String * str_vrepeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, void **args);
// str_vreplace
// file libslack/str.c line 1795
struct String * str_vreplace(struct String *str, signed long int index, signed long int range, const char *format, void **args);
// str_vreplace_unlocked
// file libslack/str.c line 1821
struct String * str_vreplace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, void **args);
// str_wrlock
// file libslack/str.c line 954
signed int str_wrlock(const struct String *str);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlcat
// file libslack/str.c line 6619
unsigned long int strlcat(char *dst, const char *src, unsigned long int size);
// strlcpy
// file libslack/str.h line 257
unsigned long int strlcpy(char *dst, const char *src, unsigned long int size);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// substr
// file libslack/str.c line 2048
struct String * substr(const char *str, signed long int index, signed long int range);
// substr_with_locker
// file libslack/str.c line 2065
struct String * substr_with_locker(struct Locker *locker, const char *str, signed long int index, signed long int range);
// swap
// file libslack/hsort.c line 156
static void swap(char *p1, char *p2, unsigned long int n);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// syslog_facility_str
// file libslack/msg.c line 1395
const char * syslog_facility_str(signed int spec);
// syslog_lookup
// file libslack/msg.c line 1323
static signed int syslog_lookup(const struct syslog_map_t *map, const char *name);
// syslog_lookup_facility
// file libslack/msg.c line 1364
signed int syslog_lookup_facility(const char *facility);
// syslog_lookup_priority
// file libslack/msg.c line 1379
signed int syslog_lookup_priority(const char *priority);
// syslog_lookup_str
// file libslack/msg.c line 1343
static const char * syslog_lookup_str(const struct syslog_map_t *map, signed int spec, signed int mask);
// syslog_parse
// file libslack/msg.c line 1451
signed int syslog_parse(const char *spec, signed int *facility, signed int *priority);
// syslog_priority_str
// file libslack/msg.c line 1411
const char * syslog_priority_str(signed int spec);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// test_action
// file libslack/map.c line 2414
static void test_action(char *key, char *value, char *cat);
// test_hash
// file libslack/map.c line 2345
static void test_hash(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout
// file libslack/agent.c line 1909
static signed int timeout(struct Agent *agent);
// timeval_add
// file libslack/agent.c line 1624
static void timeval_add(struct timeval *absolute, struct timeval *relative, struct timeval *result);
// timeval_diff
// file libslack/agent.c line 1614
static void timeval_diff(struct timeval *start, struct timeval *end, struct timeval *diff);
// timeval_set
// file libslack/agent.c line 1633
static void timeval_set(struct timeval *tv, signed long int tv_sec, signed long int tv_usec);
// timewheel_create
// file libslack/agent.c line 250
static struct timewheel_t * timewheel_create();
// timewheel_release
// file libslack/agent.c line 288
static void timewheel_release(struct timewheel_t *timewheel);
// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c);
// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c);
// tr
// file libslack/str.c line 2480
signed int tr(char *str, const char *from, const char *to, signed int option);
// tr_compile
// file libslack/str.c line 2509
struct StringTR * tr_compile(const char *from, const char *to, signed int option);
// tr_compile_table
// file libslack/str.c line 2793
static struct StringTR * tr_compile_table(struct StringTR *table, const char *from, const char *to, signed int option);
// tr_compile_with_locker
// file libslack/str.c line 2525
struct StringTR * tr_compile_with_locker(struct Locker *locker, const char *from, const char *to, signed int option);
// tr_compiled
// file libslack/str.c line 2989
signed int tr_compiled(char *str, struct StringTR *table);
// tr_destroy
// file libslack/str.c line 2655
void * tr_destroy(struct StringTR **table);
// tr_release
// file libslack/str.c line 2628
void tr_release(struct StringTR *table);
// translate
// file libslack/agent.c line 2065
static signed int translate(signed int revents);
// trim
// file libslack/str.c line 4711
char * trim(char *str);
// trim_left
// file libslack/str.c line 4800
char * trim_left(char *str);
// trim_right
// file libslack/str.c line 4886
char * trim_right(char *str);
// ttyname_r
// file /usr/include/unistd.h line 774
extern signed int ttyname_r(signed int, char *, unsigned long int);
// uc
// file libslack/str.c line 5959
char * uc(char *str);
// ucfirst
// file libslack/str.c line 6034
char * ucfirst(char *str);
// uid2gid
// file libslack/pseudo.c line 196
static signed int uid2gid(unsigned int uid);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unpack
// file libslack/net.c line 3346
signed long int unpack(void *buf, unsigned long int size, const char *format, ...);
// unquote
// file libslack/str.c line 5286
struct String * unquote(const char *str, const char *quotable, char quote_char);
// unquote_equals
// file libslack/prop.c line 258
static struct String * unquote_equals(const char *src);
// unquote_special
// file libslack/prop.c line 230
static struct String * unquote_special(const char *src);
// unquote_with_locker
// file libslack/str.c line 5302
struct String * unquote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char);
// update
// file libslack/agent.c line 1976
static signed int update(struct Agent *agent);
// user_home
// file libslack/prop.c line 272
static char * user_home(void);
// valert
// file libslack/err.c line 475
void valert(signed int priority, const char *format, void **args);
// valertsys
// file libslack/err.c line 696
void valertsys(signed int priority, const char *format, void **args);
// vasprintf
// file libslack/str.c line 6852
signed int vasprintf(char **str, const char *format, void **args);
// vdebugf
// file libslack/err.c line 285
void vdebugf(unsigned long int level, const char *format, void **args);
// vdebugsysf
// file libslack/err.c line 536
void vdebugsysf(unsigned long int level, const char *format, void **args);
// vdump
// file libslack/err.c line 430
void vdump(const char *format, void **args);
// vdumpsys
// file libslack/err.c line 657
void vdumpsys(const char *format, void **args);
// verbose
// file libslack/err.c line 190
void verbose(unsigned long int level, const char *format, ...);
// verror
// file libslack/err.c line 337
signed int verror(const char *format, void **args);
// verrorsys
// file libslack/err.c line 579
signed int verrorsys(const char *format, void **args);
// vfatal
// file libslack/err.c line 386
void vfatal(const char *format, void **args);
// vfatalsys
// file libslack/err.c line 618
void vfatalsys(const char *format, void **args);
// vhangup
// file /usr/include/unistd.h line 906
extern signed int vhangup(void);
// vmsg
// file libslack/err.c line 168
void vmsg(const char *format, void **args);
// vmsg_out
// file libslack/msg.h line 52
void vmsg_out(struct Msg *dst, const char *format, void **args);
// vmsg_out_unlocked
// file libslack/msg.c line 455
void vmsg_out_unlocked(struct Msg *dst, const char *format, void **args);
// vpack
// file libslack/net.c line 3037
signed long int vpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsscanf
// file /usr/include/stdio.h line 483
extern signed int vsscanf(const char *, const char *, void **);
// vunpack
// file libslack/net.c line 3400
signed long int vunpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args);
// vverbose
// file libslack/err.c line 212
void vverbose(unsigned long int level, const char *format, void **args);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_timeout
// file libslack/fio.c line 246
signed int write_timeout(signed int fd, signed long int sec, signed long int usec);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);

struct anonymous$24
{
  // rfds
  struct anonymous$10 *rfds;
  // xfds
  struct anonymous$10 *xfds;
  // wfds
  struct anonymous$10 *wfds;
};

struct anonymous$20
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$18
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$10
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$6
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$13
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous$5
{
  // init
  signed int init;
  // prop
  struct Prop *prop;
  // home
  char *home;
  // dirty
  signed int dirty;
  // locker
  struct Locker *locker;
};

struct anonymous$7
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$17
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$16
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$15
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$19
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$21
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$14 _kill;
  // _timer
  struct anonymous$15 _timer;
  // _rt
  struct anonymous$16 _rt;
  // _sigchld
  struct anonymous$17 _sigchld;
  // _sigfault
  struct anonymous$18 _sigfault;
  // _sigpoll
  struct anonymous$19 _sigpoll;
  // _sigsys
  struct anonymous$20 _sigsys;
};

struct anonymous$22
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$21 _sifields;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$11
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$26
{
  // lock
  union anonymous$11 lock;
  // pidfile
  char *pidfile;
};

union anonymous$2
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous$23
{
  // pfds
  struct pollfd *pfds;
  // s
  struct anonymous$24 s;
};

union anonymous$9
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$22 *, void *);
};

union anonymous$0
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$12
{
  // __data
  struct anonymous$13 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous$1
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

struct conf_t
{
  // name
  const signed int name;
  // value
  const signed long int value;
  // offset
  const signed long int offset;
};

struct anonymous$27
{
  // conf
  struct conf_t conf[19l];
};

struct Agent
{
  // state
  signed int state;
  // ids
  signed long int *ids;
  // ids_size
  unsigned long int ids_size;
  // method
  signed int method;
  // u
  union anonymous$23 u;
  // reactions
  struct reaction_t *reactions;
  // tempo
  struct activity_t *tempo;
  // activity
  struct activity_t *activity;
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // timewheel
  struct timewheel_t *timewheel;
  // timers
  unsigned long int timers;
  // locker
  struct Locker *locker;
};

struct List
{
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // list
  void **list;
  // destroy
  void (*destroy)(void *);
  // lister
  struct Lister *lister;
  // locker
  struct Locker *locker;
};

struct Lister
{
  // list
  struct List *list;
  // index
  signed long int index;
};

struct Locker
{
  // lock
  void *lock;
  // tryrdlock
  signed int (*tryrdlock)(void *);
  // rdlock
  signed int (*rdlock)(void *);
  // trywrlock
  signed int (*trywrlock)(void *);
  // wrlock
  signed int (*wrlock)(void *);
  // unlock
  signed int (*unlock)(void *);
};

struct Map
{
  // size
  unsigned long int size;
  // items
  unsigned long int items;
  // chain
  struct List **chain;
  // hash
  unsigned long int (*hash)(unsigned long int, const void *);
  // copy
  void * (*copy)(const void *);
  // cmp
  signed int (*cmp)(const void *, const void *);
  // key_destroy
  void (*key_destroy)(void *);
  // value_destroy
  void (*value_destroy)(void *);
  // mapper
  struct Mapper *mapper;
  // locker
  struct Locker *locker;
};

struct Mapper
{
  // map
  struct Map *map;
  // chain_index
  signed long int chain_index;
  // item_index
  signed long int item_index;
  // next_chain_index
  signed long int next_chain_index;
  // next_item_index
  signed long int next_item_index;
};

struct Mapping
{
  // key
  void *key;
  // value
  void *value;
  // key_destroy
  void (*key_destroy)(void *);
  // value_destroy
  void (*value_destroy)(void *);
};

struct Msg
{
  // type
  signed int type;
  // out
  void (*out)(void *, const void *, unsigned long int);
  // data
  void *data;
  // destroy
  void (*destroy)(void *);
  // locker
  struct Locker *locker;
};

struct MsgFileData
{
  // fd
  signed int fd;
};

struct MsgPlexData
{
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // list
  struct Msg **list;
};

struct MsgSyslogData
{
  // facility
  signed int facility;
  // priority
  signed int priority;
};

struct Option
{
  // name
  const char *name;
  // short_name
  char short_name;
  // argname
  const char *argname;
  // desc
  const char *desc;
  // has_arg
  signed int has_arg;
  // arg_type
  enum OptionArgument arg_type;
  // action
  enum OptionAction action;
  // object
  void *object;
  // function
  void (*function)(void);
};

struct Options
{
  // parent
  struct Options *parent;
  // options
  struct Option *options;
};

struct Point
{
  // x
  signed int x;
  // y
  signed int y;
};

struct Pool
{
  // size
  unsigned long int size;
  // used
  unsigned long int used;
  // pool
  char *pool;
  // locker
  struct Locker *locker;
};

struct Prog
{
  // name
  const char *name;
  // options
  struct Options *options;
  // syntax
  const char *syntax;
  // desc
  const char *desc;
  // version
  const char *version;
  // date
  const char *date;
  // author
  const char *author;
  // contact
  const char *contact;
  // vendor
  const char *vendor;
  // url
  const char *url;
  // legal
  const char *legal;
  // out
  struct Msg *out;
  // err
  struct Msg *err;
  // dbg
  struct Msg *dbg;
  // log
  struct Msg *log;
  // debug_level
  unsigned long int debug_level;
  // verbosity_level
  unsigned long int verbosity_level;
  // locker
  struct Locker *locker;
};

struct Prop
{
  // map
  struct Map *map;
  // defaults
  struct Prop *defaults;
};

struct String
{
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // str
  char *str;
  // locker
  struct Locker *locker;
};

struct StringTR
{
  // squash
  signed int squash;
  // table
  signed short int table[256l];
  // locker
  struct Locker *locker;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct action_t
{
  // next
  struct action_t *next;
  // prev
  struct action_t *prev;
  // parent
  struct action_t **parent;
  // when
  struct timeval when;
  // action
  signed int (*action)(struct Agent *, void *);
  // arg
  void *arg;
  // day
  unsigned long int day;
  // hour
  unsigned long int hour;
  // minute
  unsigned long int minute;
  // second
  unsigned long int second;
  // jiffy
  unsigned long int jiffy;
};

struct activity_t
{
  // since
  struct timeval since;
  // detail
  unsigned long int detail;
  // dt
  signed int dt;
  // ddt
  signed int ddt;
  // dddt
  signed int dddt;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct dlink_t
{
  // next
  void *next;
  // prev
  void *prev;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous$2 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous$0 ifr_ifrn;
  // ifr_ifru
  union anonymous$1 ifr_ifru;
};

struct in6_addr
{
  // __in6_u
  union anonymous __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip_mreq
{
  // imr_multiaddr
  struct in_addr imr_multiaddr;
  // imr_interface
  struct in_addr imr_interface;
};

struct ipv6_mreq
{
  // ipv6mr_multiaddr
  struct in6_addr ipv6mr_multiaddr;
  // ipv6mr_interface
  unsigned int ipv6mr_interface;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct net_interface_t
{
  // name
  char name[16l];
  // index
  unsigned int index;
  // flags
  signed short int flags;
  // mtu
  signed int mtu;
  // addr
  union sockaddr_any_t *addr;
  // brdaddr
  union sockaddr_any_t *brdaddr;
  // dstaddr
  union sockaddr_any_t *dstaddr;
  // hwaddr
  union sockaddr_any_t *hwaddr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // __buffer
  unsigned char *__buffer;
  // __allocated
  unsigned long int __allocated;
  // __used
  unsigned long int __used;
  // __syntax
  unsigned long int __syntax;
  // __fastmap
  char *__fastmap;
  // __translate
  unsigned char *__translate;
  // re_nsub
  unsigned long int re_nsub;
  // __can_be_null
  unsigned int __can_be_null : 1;
  // __regs_allocated
  unsigned int __regs_allocated : 2;
  // __fastmap_accurate
  unsigned int __fastmap_accurate : 1;
  // __no_sub
  unsigned int __no_sub : 1;
  // __not_bol
  unsigned int __not_bol : 1;
  // __not_eol
  unsigned int __not_eol : 1;
  // __newline_anchor
  unsigned int __newline_anchor : 1;
};

struct reaction_t
{
  // fd
  signed int fd;
  // events
  signed int events;
  // reaction
  signed int (*reaction)(struct Agent *, signed int, signed int, void *);
  // arg
  void *arg;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$9 __sigaction_handler;
  // sa_mask
  struct anonymous$6 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct real_signal_handler_t
{
  // action
  struct sigaction action[1l];
  // handler
  void (*handler)(signed int);
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct rudp_t
{
  // rtt
  double rtt;
  // srtt
  double srtt;
  // rttvar
  double rttvar;
  // rto
  double rto;
  // nrexmt
  signed int nrexmt;
  // base
  unsigned int base;
  // sequence
  unsigned int sequence;
};

struct servent
{
  // s_name
  char *s_name;
  // s_aliases
  char **s_aliases;
  // s_port
  signed int s_port;
  // s_proto
  char *s_proto;
};

struct slink_t
{
  // next
  void *next;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

union sockaddr_any_t
{
  // any
  struct sockaddr any;
  // un
  struct sockaddr_un un;
  // in
  struct sockaddr_in in;
  // in6
  struct sockaddr_in6 in6;
};

struct sockopt_t
{
  // level
  signed int level;
  // optname
  signed int optname;
  // optval
  const void *optval;
  // optlen
  signed int optlen;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct syslog_map_t
{
  // name
  char *name;
  // val
  signed int val;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timewheel_t
{
  // now
  struct timeval now[1l];
  // day
  unsigned long int day;
  // hour
  unsigned long int hour;
  // minute
  unsigned long int minute;
  // second
  unsigned long int second;
  // jiffy
  unsigned long int jiffy;
  // days
  struct action_t *days[10l];
  // hours
  struct action_t *hours[24l];
  // minutes
  struct action_t *minutes[60l];
  // seconds
  struct action_t *seconds[60l];
  // jiffies
  struct action_t *jiffies[100l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};


// MIN_EMPTY_STRING_SIZE
// file libslack/str.c line 377
static const unsigned long int MIN_EMPTY_STRING_SIZE = (const unsigned long int)1024;
// MIN_LIST_SIZE
// file libslack/list.c line 207
static const unsigned long int MIN_LIST_SIZE = (const unsigned long int)4;
// MIN_STRING_SIZE
// file libslack/str.c line 373
static const unsigned long int MIN_STRING_SIZE = (const unsigned long int)32;
// barrier
// file libslack/map.c line 2491
signed int barrier[2l];
// debug
// file libslack/map.c line 2494
signed int debug = 0;
// environ
// file libslack/coproc.c line 71
extern char **environ;
// eq
// file libslack/prop.c line 199
static const char *eq = "=";
// errors
// file libslack/map.c line 2495
signed int errors = 0;
// g
// file libslack/daemon.c line 109
static struct anonymous$26 g = { .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, .pidfile=(char *)(void *)0 };
// g$link1
// file libslack/lim.c line 134
static struct anonymous$27 g$link1 = { .conf={ { .name=0, .value=(const signed long int)131072, .offset=(const signed long int)0 }, 
    { .name=1, .value=(const signed long int)1024, .offset=(const signed long int)0 }, 
    { .name=2, .value=(const signed long int)-1, .offset=(const signed long int)0 }, 
    { .name=3, .value=(const signed long int)32, .offset=(const signed long int)0 }, 
    { .name=4, .value=(const signed long int)1024, .offset=(const signed long int)0 }, 
    { .name=5, .value=(const signed long int)1024, .offset=(const signed long int)0 }, 
    { .name=6, .value=(const signed long int)3, .offset=(const signed long int)0 }, 
    { .name=7, .value=(const signed long int)0, .offset=(const signed long int)0 }, 
    { .name=8, .value=(const signed long int)0, .offset=(const signed long int)0 }, 
    { .name=29, .value=(const signed long int)0, .offset=(const signed long int)0 }, 
    { .name=1, .value=(const signed long int)255, .offset=(const signed long int)0 }, 
    { .name=2, .value=(const signed long int)255, .offset=(const signed long int)0 }, 
    { .name=8, .value=(const signed long int)0, .offset=(const signed long int)0 }, 
    { .name=0, .value=(const signed long int)32768, .offset=(const signed long int)0 }, 
    { .name=3, .value=(const signed long int)1024, .offset=(const signed long int)0 }, 
    { .name=4, .value=(const signed long int)4096, .offset=(const signed long int)2 }, 
    { .name=5, .value=(const signed long int)4096, .offset=(const signed long int)0 }, 
    { .name=7, .value=(const signed long int)0, .offset=(const signed long int)0 }, 
    { .name=6, .value=(const signed long int)0, .offset=(const signed long int)0 } } };
// g$link2
// file libslack/prog.c line 227
static struct Prog g$link2 = { .name=(const char *)(void *)0, .options=(struct Options *)(void *)0, .syntax=(const char *)(void *)0,
    .desc=(const char *)(void *)0, .version=(const char *)(void *)0,
    .date=(const char *)(void *)0, .author=(const char *)(void *)0,
    .contact=(const char *)(void *)0, .vendor=(const char *)(void *)0,
    .url=(const char *)(void *)0, .legal=(const char *)(void *)0,
    .out=(struct Msg *)(void *)0, .err=(struct Msg *)(void *)0,
    .dbg=(struct Msg *)(void *)0, .log=(struct Msg *)(void *)0,
    .debug_level=(unsigned long int)0, .verbosity_level=(unsigned long int)0,
    .locker=(struct Locker *)(void *)0 };
// g$link3
// file libslack/prop.c line 141
static struct anonymous$5 g$link3 = { .init=0, .prop=(struct Prop *)(void *)0, .home=(char *)(void *)0,
    .dirty=0, .locker=(struct Locker *)(void *)0 };
// g_handler
// file libslack/sig.c line 108
static struct real_signal_handler_t g_handler[65l];
// g_received
// file libslack/sig.c line 109
static volatile signed int g_received[65l];
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// in6addr_loopback
// file /usr/include/netinet/in.h line 228
extern struct in6_addr in6addr_loopback;
// lim
// file libslack/map.c line 2493
const signed int lim = 1000;
// locker
// file libslack/map.c line 2484
struct Locker *locker = (struct Locker *)(void *)0;
// mtmap
// file libslack/map.c line 2483
struct Map *mtmap = (struct Map *)(void *)0;
// mutex
// file libslack/map.c line 2485
union anonymous$11 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// num_table_sizes
// file libslack/map.c line 180
static const unsigned long int num_table_sizes = sizeof(const unsigned long int [22l]) /*176ul*/  / sizeof(const unsigned long int) /*8ul*/ ;
// optarg
// file libslack/getopt.h line 36
extern char *optarg;
// optind
// file libslack/getopt.h line 50
extern signed int optind;
// prog_optab
// file libslack/prog.c line 1724
static struct Option prog_optab[5l];
// prog_optab
// file libslack/prog.c line 1724
static struct Option prog_optab[5l] = { { .name="help", .short_name=(char)104, .argname=(const char *)(void *)0, .desc="Print a help message then exit",
    .has_arg=0,
    .arg_type=(enum OptionArgument)0, .action=(enum OptionAction)2,
    .object=(void *)0, .function=(void (*)(void))prog_help_msg }, 
    { .name="version", .short_name=(char)86, .argname=(const char *)(void *)0,
    .desc="Print a version message then exit", .has_arg=0,
    .arg_type=(enum OptionArgument)0, .action=(enum OptionAction)2,
    .object=(void *)0, .function=(void (*)(void))prog_version_msg }, 
    { .name="verbose", .short_name=(char)118, .argname="level",
    .desc="Set the verbosity level", .has_arg=2,
    .arg_type=(enum OptionArgument)1, .action=(enum OptionAction)2,
    .object=(void *)0, .function=(void (*)(void))handle_verbose_option }, 
    { .name="debug", .short_name=(char)100, .argname="level", .desc="Set the debugging level",
    .has_arg=2, .arg_type=(enum OptionArgument)1,
    .action=(enum OptionAction)2, .object=(void *)0,
    .function=(void (*)(void))handle_debug_option }, 
    { .name=(const char *)(void *)0, .short_name=(char)0, .argname=(const char *)(void *)0,
    .desc=(const char *)(void *)0, .has_arg=0,
    .arg_type=(enum OptionArgument)0, .action=(enum OptionAction)0,
    .object=(void *)0, .function=(void (*)(void))(void *)0 } };
// prog_options_table
// file libslack/prog.c line 1749
struct Options prog_options_table[1l];
// prog_options_table
// file libslack/prog.c line 1749
struct Options prog_options_table[1l] = { { .parent=(struct Options *)(void *)0, .options=prog_optab } };
// rand_mutex
// file libslack/map.c line 2637
union anonymous$11 rand_mutex[1l] = { { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// rwlock
// file libslack/map.c line 2487
union anonymous$12 rwlock = { .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } };
// size
// file libslack/map.c line 2492
signed int size[2l];
// special_char
// file libslack/prop.c line 198
static const char *special_char = "\a\b\f\n\r\t\v";
// special_code
// file libslack/prop.c line 197
static const char *special_code = "abfnrtv";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// syslog_facility_map
// file libslack/msg.c line 173
static const struct syslog_map_t syslog_facility_map[19l] = { { .name="kern", .val=0 << 3 }, { .name="user", .val=1 << 3 }, { .name="mail", .val=2 << 3 }, { .name="daemon", .val=3 << 3 }, { .name="auth", .val=4 << 3 }, { .name="syslog", .val=5 << 3 }, { .name="lpr", .val=6 << 3 }, { .name="news", .val=7 << 3 }, { .name="uucp", .val=8 << 3 }, { .name="cron", .val=9 << 3 }, { .name="local0", .val=16 << 3 }, { .name="local1", .val=17 << 3 }, { .name="local2", .val=18 << 3 }, { .name="local3", .val=19 << 3 }, { .name="local4", .val=20 << 3 }, { .name="local5", .val=21 << 3 }, { .name="local6", .val=22 << 3 }, { .name="local7", .val=23 << 3 }, { .name=(char *)(void *)0, .val=-1 } };
// syslog_priority_map
// file libslack/msg.c line 196
static const struct syslog_map_t syslog_priority_map[9l] = { { .name="emerg", .val=0 }, { .name="alert", .val=1 }, { .name="crit", .val=2 }, { .name="err", .val=3 }, { .name="warning", .val=4 }, { .name="notice", .val=5 }, { .name="info", .val=6 }, { .name="debug", .val=7 }, { .name=(char *)(void *)0, .val=-1 } };
// table_resize_factor
// file libslack/map.c line 184
static const double table_resize_factor = 2.0;
// table_sizes
// file libslack/map.c line 173
static const unsigned long int table_sizes[22l] = { (const unsigned long int)11, (const unsigned long int)23, (const unsigned long int)47, (const unsigned long int)101, (const unsigned long int)199, (const unsigned long int)401, (const unsigned long int)797, (const unsigned long int)1601, (const unsigned long int)3203, (const unsigned long int)6397, (const unsigned long int)12799, (const unsigned long int)25601, (const unsigned long int)51199, (const unsigned long int)102397, (const unsigned long int)204803, (const unsigned long int)409597, (const unsigned long int)819187, (const unsigned long int)1638431, (const unsigned long int)3276799, (const unsigned long int)6553621, (const unsigned long int)13107197, (const unsigned long int)26214401 };
// timestamp_format
// file libslack/msg.c line 213
static const char *timestamp_format = "%Y%m%d %H:%M:%S ";
// timestamp_format_locker
// file libslack/msg.c line 214
static struct Locker *timestamp_format_locker = (struct Locker *)(void *)0;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1)
{
  signed long int return_value___builtin_bswap32$1$link1;
  return_value___builtin_bswap32$1$link1=__builtin_bswap32((signed long int)__bsx$link1);
  return (unsigned int)return_value___builtin_bswap32$1$link1;
}

// __strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 947
static inline unsigned long int __strcspn_c1(const char *__s, signed int __reject)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
    if((signed int)__s[(signed long int)__result] == __reject)
      break;

  return __result;
}

// __strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 958
static inline unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      break;

    if((signed int)__s[(signed long int)__result] == __reject2)
      break;

  }
  return __result;
}

// __strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
static inline unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      break;

    if((signed int)__s[(signed long int)__result] == __reject2)
      break;

    if((signed int)__s[(signed long int)__result] == __reject3)
      break;

  }
  return __result;
}

// act
// file libslack/agent.c line 1927
static signed int act(signed int (*action)(struct Agent *, void *), struct Agent *agent, void *arg)
{
  signed int err;
  signed int ret;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->unlock(agent->locker->lock);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  err = tmp_if_expr$2;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int return_value_1;
  signed int return_value_set_errno$3;
  if(!(err == 0))
  {
    return_value_set_errno$1=set_errno(err);
    return return_value_set_errno$1;
  }

  else
  {
    ret=action(agent, arg);
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value_1=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$4 = return_value_1;
    }

    else
      tmp_if_expr$4 = 0;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$3=set_errno(err);
      return return_value_set_errno$3;
    }

    else
      return ret;
  }
}

// adjust
// file libslack/list.c line 318
static signed int adjust(struct List *list, signed long int index, unsigned long int range, unsigned long int length)
{
  signed int return_value_expand$1;
  signed int return_value_contract$2;
  if(!(range >= length))
  {
    return_value_expand$1=expand(list, (signed long int)((unsigned long int)index + range), length - range);
    return return_value_expand$1;
  }

  else
    if(!(length >= range))
    {
      return_value_contract$2=contract(list, (signed long int)((unsigned long int)index + length), range - length);
      return return_value_contract$2;
    }

    else
      return 0;
}

// adjust$link1
// file libslack/str.c line 497
static signed int adjust$link1(struct String *str, signed long int index$link1, unsigned long int range$link1, unsigned long int length$link1)
{
  signed int return_value_expand$1$link1;
  signed int return_value_contract$2$link1;
  if(!(range$link1 >= length$link1))
  {
    return_value_expand$1$link1=expand$link1(str, (signed long int)((unsigned long int)index$link1 + range$link1), length$link1 - range$link1);
    return return_value_expand$1$link1;
  }

  else
    if(!(length$link1 >= range$link1))
    {
      return_value_contract$2$link1=contract$link1(str, (signed long int)((unsigned long int)index$link1 + length$link1), range$link1 - length$link1);
      return return_value_contract$2$link1;
    }

    else
      return 0;
}

// agent_acceleration
// file libslack/agent.c line 1423
signed int agent_acceleration(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_acceleration_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_acceleration_unlocked
// file libslack/agent.c line 1452
signed int agent_acceleration_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$7;
  signed int return_value_set_errno$8;
  signed int return_value_set_errno$9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      if(fd == -1)
      {
        if(!(agent->tempo->detail >= 3ul))
        {
          return_value_set_errno$7=set_errno(22);
          return return_value_set_errno$7;
        }

        return agent->tempo->ddt;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno$8=set_errno(22);
        return return_value_set_errno$8;
      }

      else
        if(!((agent->activity + id)->detail >= 3ul))
        {
          return_value_set_errno$9=set_errno(22);
          return return_value_set_errno$9;
        }

        else
          return (agent->activity + id)->ddt;
    }
  }
}

// agent_cancel
// file libslack/agent.c line 1740
signed int agent_cancel(struct Agent *agent, void *action_id)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_cancel_unlocked(agent, action_id);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_cancel_unlocked
// file libslack/agent.c line 1768
signed int agent_cancel_unlocked(struct Agent *agent, void *action_id)
{
  struct action_t *event = (struct action_t *)action_id;
  struct action_t *next;
  _Bool tmp_if_expr$2;
  if(agent == ((struct Agent *)NULL) || event == ((struct action_t *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(agent->timewheel != ((struct timewheel_t *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = !(agent->timers != 0ul) ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$3)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    void *return_value_dlink_remove$4;
    return_value_dlink_remove$4=dlink_remove((void *)event);
    next = (struct action_t *)return_value_dlink_remove$4;
    if(*event->parent == event)
      *event->parent = next;

    free((void *)event);
    agent->timers = agent->timers - 1ul;
    return 0;
  }
}

// agent_connect
// file libslack/agent.c line 620
signed int agent_connect(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_connect_unlocked(agent, fd, events, reaction, arg);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_connect_unlocked
// file libslack/agent.c line 648
signed int agent_connect_unlocked(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  signed int return_value_set_errno$1;
  unsigned long int tmp_post$10;
  if((7 & events) == 0 || reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL) || agent == ((struct Agent *)NULL) || !((-8 & events) == 0) || !(fd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)(fd + 1) * sizeof(signed long int) /*8ul*/ );
      agent->ids = (signed long int *)return_value_malloc$2;
      if(agent->ids == ((signed long int *)NULL))
        return -1;

      memset((void *)agent->ids, 0xff, (unsigned long int)(fd + 1) * sizeof(signed long int) /*8ul*/ );
      agent->ids_size = (unsigned long int)(fd + 1);
    }

    else
      if((unsigned long int)fd >= agent->ids_size)
      {
        void *return_value_mem_resize_fn$3;
        return_value_mem_resize_fn$3=mem_resize_fn((void **)&agent->ids, (agent->ids_size << 1) * sizeof(signed long int) /*8ul*/ );
        agent->ids = (signed long int *)return_value_mem_resize_fn$3;
        if(agent->ids == ((signed long int *)NULL))
          return -1;

        memset((void *)(agent->ids + (signed long int)agent->ids_size), 0xff, agent->ids_size * sizeof(signed long int) /*8ul*/ );
        agent->ids_size = agent->ids_size << 1;
      }

    if(agent->reactions == ((struct reaction_t *)NULL))
    {
      if(agent->method == 0)
      {
        void *return_value_malloc$4;
        return_value_malloc$4=malloc((unsigned long int)16 * sizeof(struct pollfd) /*8ul*/ );
        agent->u.pfds = (struct pollfd *)return_value_malloc$4;
        if(agent->u.pfds == ((struct pollfd *)NULL))
          return -1;

        memset((void *)agent->u.pfds, 0, (unsigned long int)16 * sizeof(struct pollfd) /*8ul*/ );
      }

      void *return_value_malloc$5;
      return_value_malloc$5=malloc((unsigned long int)16 * sizeof(struct reaction_t) /*24ul*/ );
      agent->reactions = (struct reaction_t *)return_value_malloc$5;
      if(agent->reactions == ((struct reaction_t *)NULL))
        return -1;

      memset((void *)agent->reactions, 0, (unsigned long int)16 * sizeof(struct reaction_t) /*24ul*/ );
      if(!(agent->tempo == ((struct activity_t *)NULL)))
      {
        void *return_value_malloc$6;
        return_value_malloc$6=malloc((unsigned long int)16 * sizeof(struct activity_t) /*40ul*/ );
        agent->activity = (struct activity_t *)return_value_malloc$6;
        if(agent->activity == ((struct activity_t *)NULL))
          return -1;

        memset((void *)agent->activity, 0, (unsigned long int)16 * sizeof(struct activity_t) /*40ul*/ );
      }

      agent->size = (unsigned long int)16;
    }

    else
      if(agent->length == agent->size)
      {
        if(agent->method == 0)
        {
          void *return_value_mem_resize_fn$7;
          return_value_mem_resize_fn$7=mem_resize_fn((void **)&agent->u.pfds, (agent->size << 1) * sizeof(struct pollfd) /*8ul*/ );
          if(return_value_mem_resize_fn$7 == NULL)
            return -1;

          memset((void *)(agent->u.pfds + (signed long int)agent->size), 0, agent->size * sizeof(struct pollfd) /*8ul*/ );
        }

        void *return_value_mem_resize_fn$8;
        return_value_mem_resize_fn$8=mem_resize_fn((void **)&agent->reactions, (agent->size << 1) * sizeof(struct reaction_t) /*24ul*/ );
        if(return_value_mem_resize_fn$8 == NULL)
          return -1;

        memset((void *)(agent->reactions + (signed long int)agent->size), 0, agent->size * sizeof(struct reaction_t) /*24ul*/ );
        if(!(agent->tempo == ((struct activity_t *)NULL)))
        {
          void *return_value_mem_resize_fn$9;
          return_value_mem_resize_fn$9=mem_resize_fn((void **)&agent->activity, (agent->size << 1) * sizeof(struct activity_t) /*40ul*/ );
          if(return_value_mem_resize_fn$9 == NULL)
            return -1;

          memset((void *)(agent->activity + (signed long int)agent->size), 0, agent->size * sizeof(struct activity_t) /*40ul*/ );
        }

        agent->size = agent->size << 1;
      }

    if(agent->ids[(signed long int)fd] == -1l)
    {
      tmp_post$10 = agent->length;
      agent->length = agent->length + 1ul;
      agent->ids[(signed long int)fd] = (signed long int)tmp_post$10;
    }

    if(agent->method == 0)
    {
      (agent->u.pfds + agent->ids[(signed long int)fd])->fd = fd;
      (agent->u.pfds + agent->ids[(signed long int)fd])->events = (signed short int)0;
      (agent->u.pfds + agent->ids[(signed long int)fd])->revents = (signed short int)0;
      if(!((4 & events) == 0))
        (agent->u.pfds + agent->ids[(signed long int)fd])->events = (agent->u.pfds + agent->ids[(signed long int)fd])->events | (signed short int)0x001;

      if(!((1 & events) == 0))
        (agent->u.pfds + agent->ids[(signed long int)fd])->events = (agent->u.pfds + agent->ids[(signed long int)fd])->events | (signed short int)0x002;

      if(!((2 & events) == 0))
        (agent->u.pfds + agent->ids[(signed long int)fd])->events = (agent->u.pfds + agent->ids[(signed long int)fd])->events | (signed short int)0x004;

    }

    else
    {
      if(!((4 & events) == 0))
      {
        if(agent->u.s.rfds == ((struct anonymous$10 *)NULL))
        {
          void *return_value_malloc$11;
          return_value_malloc$11=malloc(sizeof(struct anonymous$10) /*128ul*/ );
          agent->u.s.rfds = (struct anonymous$10 *)return_value_malloc$11;
          if(agent->u.s.rfds == ((struct anonymous$10 *)NULL))
            return -1;

          do
          {
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&agent->u.s.rfds->fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
        }

      }

      if(!((1 & events) == 0))
      {
        if(agent->u.s.xfds == ((struct anonymous$10 *)NULL))
        {
          void *return_value_malloc$12;
          return_value_malloc$12=malloc(sizeof(struct anonymous$10) /*128ul*/ );
          agent->u.s.xfds = (struct anonymous$10 *)return_value_malloc$12;
          if(agent->u.s.xfds == ((struct anonymous$10 *)NULL))
            return -1;

          do
          {
            signed int agent_connect_unlocked$$1$$6$$2$$1$$__d0;
            signed int agent_connect_unlocked$$1$$6$$2$$1$$__d1;
            asm("cld; rep; stosq" : "=c"(agent_connect_unlocked$$1$$6$$2$$1$$__d0), "=D"(agent_connect_unlocked$$1$$6$$2$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous$10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&agent->u.s.xfds->fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
        }

      }

      if(!((2 & events) == 0))
      {
        if(agent->u.s.wfds == ((struct anonymous$10 *)NULL))
        {
          void *return_value_malloc$13;
          return_value_malloc$13=malloc(sizeof(struct anonymous$10) /*128ul*/ );
          agent->u.s.wfds = (struct anonymous$10 *)return_value_malloc$13;
          if(agent->u.s.wfds == ((struct anonymous$10 *)NULL))
            return -1;

          do
          {
            signed int agent_connect_unlocked$$1$$6$$3$$1$$__d0;
            signed int agent_connect_unlocked$$1$$6$$3$$1$$__d1;
            asm("cld; rep; stosq" : "=c"(agent_connect_unlocked$$1$$6$$3$$1$$__d0), "=D"(agent_connect_unlocked$$1$$6$$3$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous$10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&agent->u.s.wfds->fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
        }

      }

      if(!((4 & events) == 0))
        agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      if(!((1 & events) == 0))
        agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      if(!((2 & events) == 0))
        agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    }
    (agent->reactions + agent->ids[(signed long int)fd])->fd = fd;
    (agent->reactions + agent->ids[(signed long int)fd])->events = events;
    (agent->reactions + agent->ids[(signed long int)fd])->reaction = reaction;
    (agent->reactions + agent->ids[(signed long int)fd])->arg = arg;
    return 0;
  }
}

// agent_create
// file libslack/agent.c line 325
struct Agent * agent_create(void)
{
  struct Agent *return_value_agent_create_with_locker$1;
  return_value_agent_create_with_locker$1=agent_create_with_locker((struct Locker *)(void *)0);
  return return_value_agent_create_with_locker$1;
}

// agent_create_measured
// file libslack/agent.c line 386
struct Agent * agent_create_measured(void)
{
  struct Agent *return_value_agent_create_measured_with_locker$1;
  return_value_agent_create_measured_with_locker$1=agent_create_measured_with_locker((struct Locker *)(void *)0);
  return return_value_agent_create_measured_with_locker$1;
}

// agent_create_measured_with_locker
// file libslack/agent.c line 402
struct Agent * agent_create_measured_with_locker(struct Locker *locker)
{
  struct Agent *agent;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct Agent) /*120ul*/ );
  agent = (struct Agent *)return_value_malloc$1;
  if(agent == ((struct Agent *)NULL))
    return (struct Agent *)(void *)0;

  else
  {
    memset((void *)agent, 0, sizeof(struct Agent) /*120ul*/ );
    agent->method = 0;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct activity_t) /*40ul*/ );
    agent->tempo = (struct activity_t *)return_value_malloc$2;
    if(agent->tempo == ((struct activity_t *)NULL))
    {
      free((void *)agent);
      return (struct Agent *)(void *)0;
    }

    else
    {
      memset((void *)agent->tempo, 0, sizeof(struct activity_t) /*40ul*/ );
      agent->locker = locker;
      return agent;
    }
  }
}

// agent_create_using_select
// file libslack/agent.c line 442
struct Agent * agent_create_using_select(void)
{
  struct Agent *return_value_agent_create_using_select_with_locker$1;
  return_value_agent_create_using_select_with_locker$1=agent_create_using_select_with_locker((struct Locker *)(void *)0);
  return return_value_agent_create_using_select_with_locker$1;
}

// agent_create_using_select_with_locker
// file libslack/agent.c line 458
struct Agent * agent_create_using_select_with_locker(struct Locker *locker)
{
  struct Agent *agent;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct Agent) /*120ul*/ );
  agent = (struct Agent *)return_value_malloc$1;
  if(agent == ((struct Agent *)NULL))
    return (struct Agent *)(void *)0;

  else
  {
    memset((void *)agent, 0, sizeof(struct Agent) /*120ul*/ );
    agent->method = 1;
    agent->locker = locker;
    return agent;
  }
}

// agent_create_with_locker
// file libslack/agent.c line 341
struct Agent * agent_create_with_locker(struct Locker *locker)
{
  struct Agent *agent;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct Agent) /*120ul*/ );
  agent = (struct Agent *)return_value_malloc$1;
  if(agent == ((struct Agent *)NULL))
    return (struct Agent *)(void *)0;

  else
  {
    memset((void *)agent, 0, sizeof(struct Agent) /*120ul*/ );
    agent->method = 0;
    agent->locker = locker;
    return agent;
  }
}

// agent_dadt
// file libslack/agent.c line 1507
signed int agent_dadt(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_dadt_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_dadt_unlocked
// file libslack/agent.c line 1535
signed int agent_dadt_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$7;
  signed int return_value_set_errno$8;
  signed int return_value_set_errno$9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      if(fd == -1)
      {
        if(!(agent->tempo->detail >= 4ul))
        {
          return_value_set_errno$7=set_errno(22);
          return return_value_set_errno$7;
        }

        return agent->tempo->dddt;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno$8=set_errno(22);
        return return_value_set_errno$8;
      }

      else
        if(!((agent->activity + id)->detail >= 4ul))
        {
          return_value_set_errno$9=set_errno(22);
          return return_value_set_errno$9;
        }

        else
          return (agent->activity + id)->dddt;
    }
  }
}

// agent_destroy
// file libslack/agent.c line 526
void * agent_destroy(struct Agent **agent)
{
  if(!(agent == ((struct Agent **)NULL)))
  {
    if(!(*agent == ((struct Agent *)NULL)))
    {
      agent_release(*agent);
      *agent = (struct Agent *)(void *)0;
    }

  }

  return (void *)0;
}

// agent_detail
// file libslack/agent.c line 1192
signed int agent_detail(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_detail_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_detail_unlocked
// file libslack/agent.c line 1220
signed int agent_detail_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$7;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
      if(fd == -1)
        return (signed int)agent->tempo->detail;

      else
      {
        id = agent->ids[(signed long int)fd];
        if(id == -1l)
        {
          return_value_set_errno$7=set_errno(22);
          return return_value_set_errno$7;
        }

        else
          return (signed int)(agent->activity + id)->detail;
      }
  }
}

// agent_disconnect
// file libslack/agent.c line 811
signed int agent_disconnect(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_disconnect_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_disconnect_unlocked
// file libslack/agent.c line 840
signed int agent_disconnect_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed long int last_id;
  signed int last_fd;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  signed int return_value_set_errno$4;
  signed int return_value_set_errno$9;
  if(agent == ((struct Agent *)NULL) || !(fd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->method == 0)
    {
      if(agent->u.pfds == ((struct pollfd *)NULL))
      {
        return_value_set_errno$2=set_errno(22);
        return return_value_set_errno$2;
      }

    }

    else
      if(agent->u.s.rfds == ((struct anonymous$10 *)NULL))
      {
        if(agent->u.s.wfds == ((struct anonymous$10 *)NULL))
        {
          if(agent->u.s.xfds == ((struct anonymous$10 *)NULL))
          {
            return_value_set_errno$3=set_errno(22);
            return return_value_set_errno$3;
          }

        }

      }

    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      if(!(agent->tempo == ((struct activity_t *)NULL)))
        tmp_if_expr$6 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
    {
      return_value_set_errno$4=set_errno(22);
      return return_value_set_errno$4;
    }

    else
    {
      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno$9=set_errno(22);
        return return_value_set_errno$9;
      }

      else
      {
        last_fd = (agent->reactions + (signed long int)(agent->length - (unsigned long int)1))->fd;
        last_id = agent->ids[(signed long int)last_fd];
        if(agent->method == 0)
        {
          agent->u.pfds[id] = agent->u.pfds[last_id];
          memset((void *)&agent->u.pfds[last_id], 0, sizeof(struct pollfd) /*8ul*/ );
        }

        else
        {
          if(!(agent->u.s.rfds == ((struct anonymous$10 *)NULL)))
            agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

          if(!(agent->u.s.xfds == ((struct anonymous$10 *)NULL)))
            agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

          if(!(agent->u.s.wfds == ((struct anonymous$10 *)NULL)))
            agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

        }
        agent->reactions[id] = agent->reactions[last_id];
        if(!(agent->tempo == ((struct activity_t *)NULL)))
          agent->activity[id] = agent->activity[last_id];

        agent->ids[(signed long int)last_fd] = id;
        agent->length = agent->length - 1ul;
        memset((void *)&agent->reactions[last_id], 0, sizeof(struct reaction_t) /*24ul*/ );
        if(!(agent->tempo == ((struct activity_t *)NULL)))
          memset((void *)&agent->activity[last_id], 0, sizeof(struct activity_t) /*40ul*/ );

        agent->ids[(signed long int)fd] = (signed long int)-1;
        return 0;
      }
    }
  }
}

// agent_last
// file libslack/agent.c line 1262
struct timeval * agent_last(struct Agent *agent, signed int fd)
{
  struct timeval *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  void *return_value_set_errnull$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct timeval *)return_value_set_errnull$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct timeval *)return_value_set_errnull$2;
    }

    else
    {
      ret=agent_last_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errnull$4=set_errnull(err);
        return (struct timeval *)return_value_set_errnull$4;
      }

      else
        return ret;
    }
  }
}

// agent_last_unlocked
// file libslack/agent.c line 1291
struct timeval * agent_last_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  void *return_value_set_errnull$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$7;
  void *return_value_set_errnull$8;
  void *return_value_set_errnull$9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct timeval *)return_value_set_errnull$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct timeval *)return_value_set_errnull$2;
    }

    else
    {
      if(fd == -1)
      {
        if(agent->tempo->detail == 0ul)
        {
          return_value_set_errnull$7=set_errnull(22);
          return (struct timeval *)return_value_set_errnull$7;
        }

        return &agent->tempo->since;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errnull$8=set_errnull(22);
        return (struct timeval *)return_value_set_errnull$8;
      }

      else
        if((agent->activity + id)->detail == 0ul)
        {
          return_value_set_errnull$9=set_errnull(22);
          return (struct timeval *)return_value_set_errnull$9;
        }

        else
          return &(agent->activity + id)->since;
    }
  }
}

// agent_rdlock
// file libslack/agent.c line 558
signed int agent_rdlock(const struct Agent *agent)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->rdlock(agent->locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// agent_recv
// file libslack/agent.c line 1101
signed int agent_recv(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL) || agent == ((struct Agent *)NULL) || !(sockfd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_recv_unlocked(agent, sockfd, reaction, arg);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_recv_unlocked
// file libslack/agent.c line 1129
signed int agent_recv_unlocked(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  /* tag-#anon#lST[SYM#tag-reaction_t#'reaction'||SYM#tag-activity_t#'activity'|] */
struct anonymous$25
{
  // reaction
  struct reaction_t reaction;
  // activity
  struct activity_t activity;
};

/* */
  ;
  struct anonymous$25 buf;
  signed long int id;
  signed int fd;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$4;
  if(reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL) || agent == ((struct Agent *)NULL) || !(sockfd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed long int return_value_recvfd$2;
    return_value_recvfd$2=recvfd(sockfd, (void *)&buf, sizeof(struct anonymous$25) /*64ul*/ , 0, &fd);
    if(!((unsigned long int)return_value_recvfd$2 == sizeof(struct anonymous$25) /*64ul*/ ))
      return -1;

    else
    {
      if(reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL))
        reaction = buf.reaction.reaction;

      if(arg == NULL)
        arg = buf.reaction.arg;

      signed int return_value_agent_connect_unlocked$3;
      return_value_agent_connect_unlocked$3=agent_connect_unlocked(agent, fd, buf.reaction.events, reaction, arg);
      if(return_value_agent_connect_unlocked$3 == -1)
        return -1;

      else
      {
        id = agent->ids[(signed long int)fd];
        if(id == -1l)
        {
          return_value_set_errno$4=set_errno(22);
          return return_value_set_errno$4;
        }

        else
        {
          agent->activity[id] = buf.activity;
          return 0;
        }
      }
    }
  }
}

// agent_release
// file libslack/agent.c line 482
void agent_release(struct Agent *agent)
{
  struct Locker *agent_release$$1$$locker;
  if(!(agent == ((struct Agent *)NULL)))
  {
    signed int return_value_agent_wrlock$1;
    return_value_agent_wrlock$1=agent_wrlock(agent);
    if(return_value_agent_wrlock$1 == 0)
    {
      agent_release$$1$$locker = agent->locker;
      free((void *)agent->ids);
      if(agent->method == 0)
        free((void *)agent->u.pfds);

      else
      {
        free((void *)agent->u.s.rfds);
        free((void *)agent->u.s.wfds);
        free((void *)agent->u.s.xfds);
      }
      free((void *)agent->reactions);
      free((void *)agent->tempo);
      free((void *)agent->activity);
      timewheel_release(agent->timewheel);
      free((void *)agent);
      if(!(agent_release$$1$$locker == ((struct Locker *)NULL)))
        agent_release$$1$$locker->unlock(agent_release$$1$$locker->lock);

      else
        0;
    }

  }

}

// agent_schedule
// file libslack/agent.c line 1585
void * agent_schedule(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg)
{
  void *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  void *return_value_set_errnull$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return return_value_set_errnull$2;
    }

    else
    {
      ret=agent_schedule_unlocked(agent, sec, usec, action, arg);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errnull$4=set_errnull(err);
        return return_value_set_errnull$4;
      }

      else
        return ret;
    }
  }
}

// agent_schedule_unlocked
// file libslack/agent.c line 1645
void * agent_schedule_unlocked(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg)
{
  struct action_t *event;
  struct timeval now[1l];
  struct timeval delta[1l];
  struct timeval when[1l];
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$3;
  if(action == ((signed int (*)(struct Agent *, void *))NULL) || agent == ((struct Agent *)NULL) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    if(agent->timewheel == ((struct timewheel_t *)NULL))
    {
      agent->timewheel=timewheel_create();
      if(!(agent->timewheel == ((struct timewheel_t *)NULL)))
        goto __CPROVER_DUMP_L2;

      return (void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_gettimeofday$2;
      return_value_gettimeofday$2=gettimeofday(now, (struct timezone *)(void *)0);
      if(return_value_gettimeofday$2 == -1)
        return (void *)0;

      else
      {
        if(now[0l].tv_sec == agent->timewheel->now[0l].tv_sec)
          tmp_if_expr$3 = (signed int)(now[0l].tv_usec < agent->timewheel->now[0l].tv_usec);

        else
          tmp_if_expr$3 = (signed int)(now[0l].tv_sec < agent->timewheel->now[0l].tv_sec);
        if(!(tmp_if_expr$3 == 0))
          agent->timewheel->now[0l] = now[0l];

        void *return_value_malloc$4;
        return_value_malloc$4=malloc(sizeof(struct action_t) /*96ul*/ );
        event = (struct action_t *)return_value_malloc$4;
        if(event == ((struct action_t *)NULL))
          return (void *)0;

        else
        {
          timeval_set(delta, sec, usec);
          timeval_add(now, delta, when);
          event->when = when[0l];
          event->action = action;
          event->arg = arg;
          timeval_diff(agent->timewheel->now, when, delta);
          event->day = (unsigned long int)(delta[0l].tv_sec / (signed long int)(24 * 60 * 60));
          delta[0l].tv_sec = delta[0l].tv_sec - (signed long int)(event->day * (unsigned long int)24 * (unsigned long int)60 * (unsigned long int)60);
          event->hour = (unsigned long int)(delta[0l].tv_sec / (signed long int)(60 * 60));
          delta[0l].tv_sec = delta[0l].tv_sec - (signed long int)(event->hour * (unsigned long int)60 * (unsigned long int)60);
          event->minute = (unsigned long int)(delta[0l].tv_sec / (signed long int)60);
          delta[0l].tv_sec = delta[0l].tv_sec - (signed long int)(event->minute * (unsigned long int)60);
          event->second = (unsigned long int)delta[0l].tv_sec;
          event->jiffy = (unsigned long int)(delta[0l].tv_usec / (signed long int)10000);
          event->jiffy = event->jiffy + agent->timewheel->jiffy;
          if(event->jiffy >= 100ul)
          {
            event->jiffy = event->jiffy - (unsigned long int)100;
            event->second = event->second + 1ul;
          }

          event->second = event->second + agent->timewheel->second;
          if(event->second >= 60ul)
          {
            event->second = event->second - (unsigned long int)60;
            event->minute = event->minute + 1ul;
          }

          event->minute = event->minute + agent->timewheel->minute;
          if(event->minute >= 60ul)
          {
            event->minute = event->minute - (unsigned long int)60;
            event->hour = event->hour + 1ul;
          }

          event->hour = event->hour + agent->timewheel->hour;
          if(event->hour >= 24ul)
          {
            event->hour = event->hour - (unsigned long int)24;
            event->day = event->day + 1ul;
          }

          event->day = event->day + agent->timewheel->day;
          if(!(event->day == agent->timewheel->day))
            install(&agent->timewheel->days[(signed long int)(event->day % (unsigned long int)10)], event);

          else
            if(!(event->hour == agent->timewheel->hour))
              install(&agent->timewheel->hours[(signed long int)event->hour], event);

            else
              if(!(event->minute == agent->timewheel->minute))
                install(&agent->timewheel->minutes[(signed long int)event->minute], event);

              else
                if(!(event->second == agent->timewheel->second))
                  install(&agent->timewheel->seconds[(signed long int)event->second], event);

                else
                  install(&agent->timewheel->jiffies[(signed long int)event->jiffy], event);
          agent->timers = agent->timers + 1ul;
          return (void *)event;
        }
      }
    }
}

// agent_send
// file libslack/agent.c line 1027
signed int agent_send(struct Agent *agent, signed int fd, signed int sockfd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_send_unlocked(agent, fd, sockfd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_send_unlocked
// file libslack/agent.c line 1055
signed int agent_send_unlocked(struct Agent *agent, signed int fd, signed int sockfd)
{
  /* tag-#anon#lST[SYM#tag-reaction_t#'reaction'||SYM#tag-activity_t#'activity'|] */
struct anonymous$25
{
  // reaction
  struct reaction_t reaction;
  // activity
  struct activity_t activity;
};

/* */
  ;
  struct anonymous$25 buf;
  signed long int id;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$7;
  if(agent == ((struct Agent *)NULL) || !(fd >= 0) || !(sockfd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno$7=set_errno(22);
        return return_value_set_errno$7;
      }

      else
      {
        buf.reaction = agent->reactions[id];
        buf.activity = agent->activity[id];
        signed long int return_value_sendfd$8;
        return_value_sendfd$8=sendfd(sockfd, (const void *)&buf, sizeof(struct anonymous$25) /*64ul*/ , 0, fd);
        if(return_value_sendfd$8 == -1l)
          return -1;

        else
        {
          signed int return_value_agent_disconnect_unlocked$9;
          return_value_agent_disconnect_unlocked$9=agent_disconnect_unlocked(agent, fd);
          if(return_value_agent_disconnect_unlocked$9 == -1)
            return -1;

          else
            return 0;
        }
      }
    }
  }
}

// agent_start
// file libslack/agent.c line 2270
signed int agent_start(struct Agent *agent)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_start_unlocked(agent);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_start_unlocked
// file libslack/agent.c line 2087
static signed int agent_start_unlocked(struct Agent *agent)
{
  _Bool tmp_if_expr$2;
  if(agent == ((struct Agent *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = agent->state != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  signed int return_value_update$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$10;
  signed int return_value_update$13;
  if(tmp_if_expr$2)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    agent->state = 1;
    if(!(agent->timers == 0ul))
    {
      return_value_update$3=update(agent);
      if(!(return_value_update$3 == -1))
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      while((_Bool)1)
      {
        if(agent->length == 0ul)
        {
          if(agent->timers == 0ul)
            goto __CPROVER_DUMP_L46;

        }

        if(agent->state == 2)
          break;

        signed int nfds;
        signed int timo;
        unsigned long int i;
        timo=timeout(agent);
        if(agent->method == 0)
        {
          nfds=poll(agent->u.pfds, agent->length, timo > 10 ? timo - 10 : timo);
          if(nfds == -1)
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            if(*return_value___errno_location$4 == 4)
              agent->state = 0;

            return -1;
          }

          if(!(nfds == 0))
          {
            struct timeval now[1l];
            signed int return_value_gettimeofday$5;
            return_value_gettimeofday$5=gettimeofday(now, (struct timezone *)(void *)0);
            if(return_value_gettimeofday$5 == -1)
              return -1;

            if(!(agent->tempo == ((struct activity_t *)NULL)))
              measure(agent, -1, now);

            i = (unsigned long int)0;
            do
            {
              if(!(nfds == 0))
                tmp_if_expr$6 = i < agent->length ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$6 = (_Bool)0;
              if(!tmp_if_expr$6)
                break;

              if(!((agent->u.pfds + (signed long int)i)->revents == 0))
              {
                signed int (*agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$reaction)(struct Agent *, signed int, signed int, void *) = (agent->reactions + (signed long int)i)->reaction;
                signed int agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$fd = (agent->reactions + (signed long int)i)->fd;
                signed int agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$revents;
                agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$revents=translate((signed int)(agent->u.pfds + (signed long int)i)->revents);
                void *agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$arg = (agent->reactions + (signed long int)i)->arg;
                (agent->u.pfds + (signed long int)i)->revents = (signed short int)0;
                if(!(agent->tempo == ((struct activity_t *)NULL)))
                  measure(agent, agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$fd, now);

                signed int return_value_react$7;
                return_value_react$7=react(agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$reaction, agent, agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$fd, agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$revents, agent_start_unlocked$$1$$1$$1$$2$$1$$1$$1$$arg);
                if(return_value_react$7 == -1)
                  return -1;

                nfds = nfds - 1;
              }

              i = i + 1ul;
            }
            while((_Bool)1);
          }

          else
          {
            struct timeval agent_start_unlocked$$1$$1$$1$$3$$delta[1l];
            struct timeval agent_start_unlocked$$1$$1$$1$$3$$result[1l];
            timeval_set(agent_start_unlocked$$1$$1$$1$$3$$delta, (signed long int)0, (signed long int)(timo * 1000));
            timeval_add(agent->timewheel->now, agent_start_unlocked$$1$$1$$1$$3$$delta, agent_start_unlocked$$1$$1$$1$$3$$result);
            agent->timewheel->now[0l] = agent_start_unlocked$$1$$1$$1$$3$$result[0l];
            agent->timewheel->jiffy = agent->timewheel->jiffy + (unsigned long int)(timo / 10);
            if(agent->timewheel->jiffy == 100ul)
              next_second(agent);

            signed int return_value_expire$8;
            return_value_expire$8=expire(agent);
            if(return_value_expire$8 == -1)
              return -1;

          }
        }

        else
        {
          struct timeval tv[1l];
          struct timeval *to;
          struct anonymous$10 readset[1l];
          struct anonymous$10 *rfds = (struct anonymous$10 *)(void *)0;
          struct anonymous$10 writeset[1l];
          struct anonymous$10 *wfds = (struct anonymous$10 *)(void *)0;
          struct anonymous$10 exceptset[1l];
          struct anonymous$10 *xfds = (struct anonymous$10 *)(void *)0;
          if(!(agent->u.s.rfds == ((struct anonymous$10 *)NULL)))
          {
            rfds = readset;
            *rfds = *agent->u.s.rfds;
          }

          if(!(agent->u.s.wfds == ((struct anonymous$10 *)NULL)))
          {
            wfds = writeset;
            *wfds = *agent->u.s.wfds;
          }

          if(!(agent->u.s.xfds == ((struct anonymous$10 *)NULL)))
          {
            xfds = exceptset;
            *xfds = *agent->u.s.xfds;
          }

          if(timo == -1)
            to = (struct timeval *)(void *)0;

          else
          {
            tv[0l].tv_sec = (signed long int)(timo / 1000);
            tv[0l].tv_usec = (signed long int)((timo % 1000) * 1000);
            to = tv;
          }
          nfds=select((signed int)agent->ids_size, rfds, wfds, xfds, to);
          if(nfds == -1)
            return -1;

          if(!(nfds == 0))
          {
            struct timeval agent_start_unlocked$$1$$1$$2$$2$$now[1l];
            signed int return_value_gettimeofday$9;
            return_value_gettimeofday$9=gettimeofday(agent_start_unlocked$$1$$1$$2$$2$$now, (struct timezone *)(void *)0);
            if(return_value_gettimeofday$9 == -1)
              return -1;

            if(!(agent->tempo == ((struct activity_t *)NULL)))
              measure(agent, -1, agent_start_unlocked$$1$$1$$2$$2$$now);

            i = (unsigned long int)0;
            do
            {
              if(!(nfds == 0))
                tmp_if_expr$10 = i < agent->length ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$10 = (_Bool)0;
              if(!tmp_if_expr$10)
                break;

              signed int fd = (agent->reactions + (signed long int)i)->fd;
              signed int revents = 0;
              if(!(rfds == ((struct anonymous$10 *)NULL)))
              {
                if(!((rfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  revents = revents | 4;

              }

              if(!(wfds == ((struct anonymous$10 *)NULL)))
              {
                if(!((wfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  revents = revents | 2;

              }

              if(!(xfds == ((struct anonymous$10 *)NULL)))
              {
                if(!((xfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  revents = revents | 1;

              }

              if(!(revents == 0))
              {
                signed int (*reaction)(struct Agent *, signed int, signed int, void *) = (agent->reactions + (signed long int)i)->reaction;
                void *arg = (agent->reactions + (signed long int)i)->arg;
                if(!(agent->tempo == ((struct activity_t *)NULL)))
                  measure(agent, fd, agent_start_unlocked$$1$$1$$2$$2$$now);

                signed int return_value_react$11;
                return_value_react$11=react(reaction, agent, fd, revents, arg);
                if(return_value_react$11 == -1)
                  return -1;

                nfds = nfds - 1;
              }

              i = i + 1ul;
            }
            while((_Bool)1);
          }

          else
          {
            struct timeval delta[1l];
            struct timeval result[1l];
            timeval_set(delta, (signed long int)0, (signed long int)(timo * 1000));
            timeval_add(agent->timewheel->now, delta, result);
            agent->timewheel->now[0l] = result[0l];
            agent->timewheel->jiffy = agent->timewheel->jiffy + (unsigned long int)(timo / 10);
            if(agent->timewheel->jiffy == 100ul)
              next_second(agent);

            signed int return_value_expire$12;
            return_value_expire$12=expire(agent);
            if(return_value_expire$12 == -1)
              return -1;

          }
        }
        if(!(agent->timers == 0ul))
        {
          return_value_update$13=update(agent);
          if(return_value_update$13 == -1)
            return -1;

        }

      }

    __CPROVER_DUMP_L46:
      ;
      agent->state = 0;
      return 0;
    }
  }
}

// agent_stop
// file libslack/agent.c line 2312
signed int agent_stop(struct Agent *agent)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_stop_unlocked(agent);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_stop_unlocked
// file libslack/agent.c line 2302
static signed int agent_stop_unlocked(struct Agent *agent)
{
  _Bool tmp_if_expr$2;
  if(agent == ((struct Agent *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = agent->state != 1 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    agent->state = 2;
    return 0;
  }
}

// agent_transfer
// file libslack/agent.c line 927
signed int agent_transfer(struct Agent *agent, signed int fd, struct Agent *dst)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_transfer_unlocked(agent, fd, dst);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_transfer_unlocked
// file libslack/agent.c line 956
signed int agent_transfer_unlocked(struct Agent *agent, signed int fd, struct Agent *dst)
{
  struct reaction_t reaction;
  struct activity_t activity;
  signed long int id;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$7;
  signed int return_value_set_errno$8;
  if(agent == ((struct Agent *)NULL) || dst == ((struct Agent *)NULL) || !(fd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
      if(dst->tempo == ((struct activity_t *)NULL))
      {
        return_value_set_errno$7=set_errno(22);
        return return_value_set_errno$7;
      }

      else
      {
        id = agent->ids[(signed long int)fd];
        if(id == -1l)
        {
          return_value_set_errno$8=set_errno(22);
          return return_value_set_errno$8;
        }

        else
        {
          reaction = agent->reactions[id];
          activity = agent->activity[id];
          signed int return_value_agent_connect$9;
          return_value_agent_connect$9=agent_connect(dst, reaction.fd, reaction.events, reaction.reaction, reaction.arg);
          if(return_value_agent_connect$9 == -1)
            return -1;

          else
          {
            dst->activity[dst->ids[(signed long int)fd]] = activity;
            signed int return_value_agent_disconnect_unlocked$10;
            return_value_agent_disconnect_unlocked$10=agent_disconnect_unlocked(agent, fd);
            if(return_value_agent_disconnect_unlocked$10 == -1)
            {
              agent_disconnect(dst, fd);
              return -1;
            }

            else
              return 0;
          }
        }
      }
  }
}

// agent_unlock
// file libslack/agent.c line 596
signed int agent_unlock(const struct Agent *agent)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->unlock(agent->locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// agent_velocity
// file libslack/agent.c line 1342
signed int agent_velocity(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=agent_velocity_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// agent_velocity_unlocked
// file libslack/agent.c line 1370
signed int agent_velocity_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$7;
  signed int return_value_set_errno$8;
  signed int return_value_set_errno$9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      if(fd == -1)
      {
        if(!(agent->tempo->detail >= 2ul))
        {
          return_value_set_errno$7=set_errno(22);
          return return_value_set_errno$7;
        }

        return agent->tempo->dt;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno$8=set_errno(22);
        return return_value_set_errno$8;
      }

      else
        if(!((agent->activity + id)->detail >= 2ul))
        {
          return_value_set_errno$9=set_errno(22);
          return return_value_set_errno$9;
        }

        else
          return (agent->activity + id)->dt;
    }
  }
}

// agent_wrlock
// file libslack/agent.c line 579
signed int agent_wrlock(const struct Agent *agent)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->wrlock(agent->locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// alert
// file libslack/err.c line 456
void alert(signed int priority, const char *format, ...)
{
  void **args = (void **)&format;
  valert(priority, format, args);
  args = ((void **)NULL);
}

// alertsys
// file libslack/err.c line 677
void alertsys(signed int priority, const char *format, ...)
{
  void **args = (void **)&format;
  valertsys(priority, format, args);
  args = ((void **)NULL);
}

// asprintf
// file libslack/str.c line 6826
signed int asprintf(char **str, const char *format, ...)
{
  signed int ret;
  void **args = (void **)&format;
  ret=vasprintf(str, format, args);
  args = ((void **)NULL);
  return ret;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// bin
// file libslack/str.c line 6284
signed int bin(const char *str)
{
  signed int ret = 0;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  if(str == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if((signed int)*str == 48)
    {
      if((signed int)str[1l] == 98)
        str = str + (signed long int)2;

    }

    for( ; !(*str == 0); str = str + 1l)
    {
      ret = ret << 1;
      switch((signed int)*str)
      {
        case 48:
          break;
        case 49:
        {
          ret = ret | 1;
          break;
        }
        default:
        {
          return_value_set_errno$2=set_errno(22);
          return return_value_set_errno$2;
        }
      }
    }
    return ret;
  }
}

// build_sockopts
// file libslack/net.c line 286
static struct sockopt_t * build_sockopts(struct sockopt_t *sockopts, signed int *rcvbufsz, signed int *sndbufsz)
{
  unsigned long int so = (unsigned long int)0;
  if(!(*rcvbufsz == 0))
  {
    (sockopts + (signed long int)so)->level = 1;
    (sockopts + (signed long int)so)->optname = 8;
    (sockopts + (signed long int)so)->optval = (const void *)rcvbufsz;
    (sockopts + (signed long int)so)->optlen = (signed int)sizeof(signed int) /*4ul*/ ;
    so = so + 1ul;
  }

  if(!(*sndbufsz == 0))
  {
    (sockopts + (signed long int)so)->level = 1;
    (sockopts + (signed long int)so)->optname = 7;
    (sockopts + (signed long int)so)->optval = (const void *)sndbufsz;
    (sockopts + (signed long int)so)->optlen = (signed int)sizeof(signed int) /*4ul*/ ;
    so = so + 1ul;
  }

  (sockopts + (signed long int)so)->optval = (void *)0;
  return sockopts;
}

// chomp
// file libslack/str.c line 6204
signed int chomp(char *str)
{
  char *s;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$2;
  if(str == ((char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if((signed int)*str == 0)
      return 0;

    else
    {
      for( ; !(str[1l] == 0); str = str + 1l)
        ;
      s = str;
      do
      {
        if((signed int)*s == 10)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*s == 13 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        *s = (char)0;
        s = s - 1l;
      }
      while((_Bool)1);
      return (signed int)(str - s);
    }
}

// chop
// file libslack/str.c line 6113
signed int chop(char *str)
{
  signed int ret;
  _Bool tmp_if_expr$2;
  if(str == ((char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*str != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    for( ; !(str[1l] == 0); str = str + 1l)
      ;
    ret = (signed int)*str;
    *str = (char)0;
    return ret;
  }
}

// consume
// file libslack/map.c line 2517
void * consume(void *arg)
{
  signed int i;
  signed int test = *((signed int *)arg);
  char ack;
  i = 1;
  signed long int return_value_read$1;
  signed int *return_value___errno_location$2;
  for( ; lim >= i; i = i + 1)
  {
    if(!(debug == 0))
      printf("c: pop\n");

    do
    {
      return_value_read$1=read(size[(signed long int)0], (void *)&ack, (unsigned long int)1);
      if(!(return_value_read$1 == -1l))
        break;

      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 4))
        break;

    }
    while((_Bool)1);
    signed int return_value_map_remove$3;
    return_value_map_remove$3=map_remove(mtmap, (void *)(signed long int)i);
    if(return_value_map_remove$3 == -1)
    {
      errors = errors + 1;
      printf("Test%d: map_remove(mtmap, %d), failed\n", test, i);
      break;
    }

    if(!(debug == 0))
      printf("c: remove %d\n", i);

  }
  if(!(i == 1 + lim))
  {
    errors = errors + 1;
    printf("Test%d: consumer read %d items, not %d\n", test, i - 1, lim);
  }

  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// contract
// file libslack/list.c line 296
static signed int contract(struct List *list, signed long int index, unsigned long int range)
{
  memmove((void *)(list->list + index), (const void *)(list->list + index + (signed long int)range), ((list->length - (unsigned long int)index) - range) * sizeof(void *) /*8ul*/ );
  signed int return_value_shrink$1;
  return_value_shrink$1=shrink(list, range);
  if(return_value_shrink$1 == -1)
    return -1;

  else
  {
    list->length = list->length - range;
    return 0;
  }
}

// contract$link1
// file libslack/str.c line 475
static signed int contract$link1(struct String *str, signed long int index$link1, unsigned long int range$link1)
{
  memmove((void *)(str->str + index$link1), (const void *)(str->str + index$link1 + (signed long int)range$link1), ((str->length - (unsigned long int)index$link1) - range$link1) * sizeof(char) /*1ul*/ );
  signed int return_value_shrink$1$link1;
  return_value_shrink$1$link1=shrink$link1(str, range$link1);
  if(return_value_shrink$1$link1 == -1)
    return -1;

  else
  {
    str->length = str->length - range$link1;
    return 0;
  }
}

// coproc_close
// file libslack/coproc.c line 348
signed int coproc_close(signed int pid, signed int *to, signed int *from, signed int *err)
{
  signed int status = 0;
  signed int return_value_set_errno$1;
  if(!(pid >= 1))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(to == ((signed int *)NULL)))
    {
      if(!(*to == -1))
      {
        close(*to);
        *to = -1;
      }

    }

    if(!(from == ((signed int *)NULL)))
    {
      if(!(*from == -1))
      {
        close(*from);
        *from = -1;
      }

    }

    if(!(err == ((signed int *)NULL)))
    {
      if(!(*err == -1))
      {
        close(*err);
        *err = -1;
      }

    }

    signed int return_value_waitpid$2;
    return_value_waitpid$2=waitpid(pid, &status, 0);
    if(return_value_waitpid$2 == -1)
      return -1;

    else
      return status;
  }
}

// coproc_open
// file libslack/coproc.c line 216
signed int coproc_open(signed int *to, signed int *from, signed int *err, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data)
{
  signed int to_pipe[2l];
  signed int from_pipe[2l];
  signed int err_pipe[2l];
  signed int pid;
  signed int has_meta;
  signed int return_value_set_errno$1;
  unsigned long int tmp_statement_expression$2;
  signed int return_value_set_errno$4;
  if(err == ((signed int *)NULL) || from == ((signed int *)NULL) || to == ((signed int *)NULL) || cmd == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    char __r0;
    char __r1;
    char __r2;
    unsigned long int return_value___builtin_strcspn$3;
    return_value___builtin_strcspn$3=__builtin_strcspn(cmd, "|&;()<>[]{}$`'~\"\\*? \t\r\n");
    tmp_statement_expression$2 = return_value___builtin_strcspn$3;
    has_meta = (signed int)((signed int)cmd[(signed long int)tmp_statement_expression$2] != 0);
    if(argv == ((char * const *)NULL) && has_meta == 0 || !(argv == ((char * const *)NULL)) && !(has_meta == 0))
    {
      return_value_set_errno$4=set_errno(22);
      return return_value_set_errno$4;
    }

    else
    {
      signed int return_value_pipe$5;
      return_value_pipe$5=pipe(to_pipe);
      if(return_value_pipe$5 == -1)
        return -1;

      else
      {
        signed int return_value_pipe$6;
        return_value_pipe$6=pipe(from_pipe);
        if(return_value_pipe$6 == -1)
        {
          close(to_pipe[(signed long int)0]);
          close(to_pipe[(signed long int)1]);
          return -1;
        }

        else
        {
          signed int return_value_pipe$7;
          return_value_pipe$7=pipe(err_pipe);
          if(return_value_pipe$7 == -1)
          {
            close(to_pipe[(signed long int)0]);
            close(to_pipe[(signed long int)1]);
            close(from_pipe[(signed long int)0]);
            close(from_pipe[(signed long int)1]);
            return -1;
          }

          else
          {
            pid=fork();
            if(!(pid == -1))
            {
              if(pid == 0)
                goto __CPROVER_DUMP_L7;

            }

            else
            {
              close(to_pipe[(signed long int)0]);
              close(to_pipe[(signed long int)1]);
              close(from_pipe[(signed long int)0]);
              close(from_pipe[(signed long int)1]);
              close(err_pipe[(signed long int)0]);
              close(err_pipe[(signed long int)1]);
              return -1;

            __CPROVER_DUMP_L7:
              ;
              if(!(action == ((void (*)(void *))NULL)))
                action(data);

              close(to_pipe[(signed long int)1]);
              close(from_pipe[(signed long int)0]);
              close(err_pipe[(signed long int)0]);
              if(!(to_pipe[0l] == 0))
              {
                signed int return_value_dup2$8;
                return_value_dup2$8=dup2(to_pipe[(signed long int)0], 0);
                if(return_value_dup2$8 == -1)
                  _exit(1);

                close(to_pipe[(signed long int)0]);
              }

              if(!(from_pipe[1l] == 1))
              {
                signed int return_value_dup2$9;
                return_value_dup2$9=dup2(from_pipe[(signed long int)1], 1);
                if(return_value_dup2$9 == -1)
                  _exit(1);

                close(from_pipe[(signed long int)1]);
              }

              if(!(err_pipe[1l] == 2))
              {
                signed int return_value_dup2$10;
                return_value_dup2$10=dup2(err_pipe[(signed long int)1], 2);
                if(return_value_dup2$10 == -1)
                  _exit(1);

                close(err_pipe[(signed long int)1]);
              }

              do_exec(has_meta, cmd, argv, envv);
              _exit(1);
            }
            close(to_pipe[(signed long int)0]);
            close(from_pipe[(signed long int)1]);
            close(err_pipe[(signed long int)1]);
            *to = to_pipe[(signed long int)1];
            *from = from_pipe[(signed long int)0];
            *err = err_pipe[(signed long int)0];
            return pid;
          }
        }
      }
    }
  }
}

// coproc_pty_close
// file libslack/coproc.c line 464
signed int coproc_pty_close(signed int pid, signed int *masterfd, const char *slavename)
{
  signed int status = 0;
  signed int return_value_set_errno$1;
  if(!(pid >= 1))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(masterfd == ((signed int *)NULL)))
    {
      if(!(*masterfd == -1))
      {
        pty_release(slavename);
        close(*masterfd);
        *masterfd = -1;
      }

    }

    signed int return_value_waitpid$2;
    return_value_waitpid$2=waitpid(pid, &status, 0);
    if(return_value_waitpid$2 == -1)
      return -1;

    else
      return status;
  }
}

// coproc_pty_open
// file libslack/coproc.c line 405
signed int coproc_pty_open(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data)
{
  signed int pid;
  signed int has_meta;
  signed int return_value_set_errno$1;
  unsigned long int tmp_statement_expression$2;
  signed int return_value_set_errno$4;
  if(masterfd == ((signed int *)NULL) || cmd == ((const char *)NULL) || slavename == ((char *)NULL) || !(slavenamesize >= 64ul))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    char __r0;
    char __r1;
    char __r2;
    unsigned long int return_value___builtin_strcspn$3;
    return_value___builtin_strcspn$3=__builtin_strcspn(cmd, "|&;()<>[]{}$`'~\"\\*? \t\r\n");
    tmp_statement_expression$2 = return_value___builtin_strcspn$3;
    has_meta = (signed int)((signed int)cmd[(signed long int)tmp_statement_expression$2] != 0);
    if(argv == ((char * const *)NULL) && has_meta == 0 || !(argv == ((char * const *)NULL)) && !(has_meta == 0))
    {
      return_value_set_errno$4=set_errno(22);
      return return_value_set_errno$4;
    }

    else
    {
      pid=pty_fork(masterfd, slavename, slavenamesize, slave_termios, slave_winsize);
      if(!(pid == -1))
      {
        if(pid == 0)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        return -1;

      __CPROVER_DUMP_L4:
        ;
        if(!(action == ((void (*)(void *))NULL)))
          action(data);

        do_exec(has_meta, cmd, argv, envv);
        _exit(1);
      }
      return pid;
    }
  }
}

// cstr
// file libslack/str.h line 82
char * cstr(const struct String *str)
{
  void *return_value_set_errnull$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
    return str->str;
}

// cstrcat
// file libslack/str.c line 6689
char * cstrcat(char *dst, const char *src)
{
  for( ; !(*dst == 0); dst = dst + 1l)
    ;
  char *tmp_post$1;
  const char *tmp_post$2;
  do
  {
    tmp_post$1 = dst;
    dst = dst + 1l;
    tmp_post$2 = src;
    src = src + 1l;
    *tmp_post$1 = *tmp_post$2;
    if(*tmp_post$1 == 0)
      break;

  }
  while((_Bool)1);
  return dst - (signed long int)1;
}

// cstrchr
// file libslack/str.c line 6714
char * cstrchr(const char *str, signed int c)
{
  for( ; !(*str == 0); str = str + 1l)
    if(*str == (char)c)
      break;

  return (char *)str;
}

// cstrcpy
// file libslack/str.c line 6666
char * cstrcpy(char *dst, const char *src)
{
  char *tmp_post$1;
  const char *tmp_post$2;
  do
  {
    tmp_post$1 = dst;
    dst = dst + 1l;
    tmp_post$2 = src;
    src = src + 1l;
    *tmp_post$1 = *tmp_post$2;
    if(*tmp_post$1 == 0)
      break;

  }
  while((_Bool)1);
  return dst - (signed long int)1;
}

// cstrpbrk
// file libslack/str.c line 6736
char * cstrpbrk(const char *str, const char *brk)
{
  const char *b;
  for( ; !(*str == 0); str = str + 1l)
  {
    b = brk;
    for( ; !(*b == 0); b = b + 1l)
      if(*str == *b)
        return (char *)str;

  }
  return (char *)str;
}

// cstrrchr
// file libslack/str.c line 6762
char * cstrrchr(const char *str, signed int c)
{
  char *match = (char *)(void *)0;
  for( ; !(*str == 0); str = str + 1l)
    if(*str == (char)c)
      match = (char *)str;

  return match != ((char *)NULL) ? match : (char *)str;
}

// cstrstr
// file libslack/str.c line 6787
char * cstrstr(const char *str, const char *srch)
{
  if((signed int)*srch == 0)
    return (char *)str;

  else
  {
    do
    {
      str=cstrchr(str, (signed int)*srch);
      if(*str == 0)
        break;

      char *s = (char *)str;
      char *r = (char *)srch;
      do
      {
        r = r + 1l;
        if((signed int)*r == 0)
          return (char *)str;

        s = s + 1l;
        if(!(*s == *r))
          break;

      }
      while((_Bool)1);
      str = str + 1l;
    }
    while((_Bool)1);
    return (char *)str;
  }
}

// daemon_absolute_path
// file libslack/daemon.c line 273
char * daemon_absolute_path(const char *path)
{
  unsigned long int path_len;
  char *abs_path;
  char *p;
  void *return_value_set_errnull$1;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  if(path == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    if(!((signed int)*path == 47))
    {
      signed long int daemon_absolute_path$$1$$1$$lim;
      daemon_absolute_path$$1$$1$$lim=limit_path();
      char *cwd;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)daemon_absolute_path$$1$$1$$lim * sizeof(char) /*1ul*/ );
      cwd = (char *)return_value_malloc$2;
      unsigned long int cwd_len;
      signed int rc;
      if(cwd == ((char *)NULL))
        return (char *)(void *)0;

      char *return_value_getcwd$3;
      return_value_getcwd$3=getcwd(cwd, (unsigned long int)daemon_absolute_path$$1$$1$$lim);
      if(return_value_getcwd$3 == ((char *)NULL))
      {
        free((void *)cwd);
        return (char *)(void *)0;
      }

      cwd_len=strlen(cwd);
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(path);
      if(1ul + return_value_strlen$5 + cwd_len >= (unsigned long int)daemon_absolute_path$$1$$1$$lim)
      {
        free((void *)cwd);
        void *return_value_set_errnull$4;
        return_value_set_errnull$4=set_errnull(36);
        return (char *)return_value_set_errnull$4;
      }

      rc=snprintf(cwd + (signed long int)cwd_len, (unsigned long int)daemon_absolute_path$$1$$1$$lim - cwd_len, "%c%s", 47, path);
      if(rc == -1 || (unsigned long int)rc >= (unsigned long int)daemon_absolute_path$$1$$1$$lim + -cwd_len)
      {
        free((void *)cwd);
        void *return_value_set_errnull$6;
        return_value_set_errnull$6=set_errnull(36);
        return (char *)return_value_set_errnull$6;
      }

      abs_path = cwd;
    }

    else
    {
      abs_path=mem_strdup(path);
      if(abs_path == ((char *)NULL))
        return (char *)(void *)0;

    }
    path_len=strlen(abs_path);
    p = abs_path;
    for( ; !(*p == 0); p = p + 1l)
      if((signed int)*p == 47)
      {
        if((signed int)p[1l] == 47)
        {
          memmove((void *)p, (const void *)(p + (signed long int)1), (path_len + (unsigned long int)1) - (unsigned long int)((p + (signed long int)1) - abs_path));
          path_len = path_len - 1ul;
          p = p - 1l;
        }

        else
          if((signed int)p[1l] == 46)
          {
            if((signed int)p[2l] == 47)
              tmp_if_expr$10 = (_Bool)1;

            else
              tmp_if_expr$10 = (signed int)p[(signed long int)2] == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$10)
            {
              signed int keep_sep;
              if(p == abs_path)
                tmp_if_expr$7 = (signed int)p[(signed long int)2] == 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$7 = (_Bool)0;
              keep_sep = (signed int)tmp_if_expr$7;
              memmove((void *)(p + (signed long int)keep_sep), (const void *)(p + (signed long int)2), (path_len + (unsigned long int)1) - (unsigned long int)((p + (signed long int)2) - abs_path));
              path_len = path_len - (unsigned long int)(2 - keep_sep);
              p = p - 1l;
            }

            else
              if((signed int)p[2l] == 46)
              {
                if((signed int)p[3l] == 47)
                  tmp_if_expr$9 = (_Bool)1;

                else
                  tmp_if_expr$9 = (signed int)p[(signed long int)3] == 0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$9)
                {
                  char *scan;
                  char *parent;
                  signed int daemon_absolute_path$$1$$3$$1$$1$$2$$2$$keep_sep;
                  parent = p;
                  scan = parent;
                  while(!(abs_path >= scan))
                  {
                    scan = scan - 1l;
                    if((signed int)*scan == 47)
                    {
                      parent = scan;
                      break;
                    }

                  }
                  if(parent == abs_path)
                    tmp_if_expr$8 = (signed int)p[(signed long int)3] == 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$8 = (_Bool)0;
                  daemon_absolute_path$$1$$3$$1$$1$$2$$2$$keep_sep = (signed int)tmp_if_expr$8;
                  memmove((void *)(parent + (signed long int)daemon_absolute_path$$1$$3$$1$$1$$2$$2$$keep_sep), (const void *)(p + (signed long int)3), (path_len + (unsigned long int)1) - (unsigned long int)((p + (signed long int)3) - abs_path));
                  path_len = path_len - (unsigned long int)((p + (signed long int)3) - parent);
                  p = parent - (signed long int)1;
                }

              }

          }

      }

    for( ; path_len >= 2ul; abs_path[(signed long int)path_len] = (char)0)
    {
      if(!((signed int)abs_path[-1l + (signed long int)path_len] == 47))
        break;

      path_len = path_len - 1ul;
    }
    return abs_path;
  }
}

// daemon_become_user
// file libslack/daemon.c line 233
signed int daemon_become_user(unsigned int uid, unsigned int gid, char *user)
{
  unsigned int gids[10l];
  signed int daemon_become_user$$1$$g = 0;
  signed int return_value_setgroups$5;
  return_value_setgroups$5=setgroups((unsigned long int)0, (const unsigned int *)(void *)0);
  _Bool tmp_if_expr$6;
  if(return_value_setgroups$5 == -1)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    daemon_become_user$$1$$g=getgroups(0, (unsigned int *)(void *)0);
    tmp_if_expr$6 = daemon_become_user$$1$$g != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  signed int return_value_getgroups$1;
  _Bool tmp_if_expr$4;
  unsigned int return_value_getgid$3;
  if(tmp_if_expr$6)
  {
    if(!(daemon_become_user$$1$$g == 1))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_getgroups$1=getgroups(10, gids);
      tmp_if_expr$2 = return_value_getgroups$1 != 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_getgid$3=getgid();
      tmp_if_expr$4 = gids[(signed long int)0] != return_value_getgid$3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      return -1;

  }

  signed int return_value_setgid$7;
  return_value_setgid$7=setgid(gid);
  _Bool tmp_if_expr$9;
  unsigned int return_value_getgid$8;
  if(return_value_setgid$7 == -1)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_getgid$8=getgid();
    tmp_if_expr$9 = return_value_getgid$8 != gid ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$11;
  unsigned int return_value_getegid$10;
  if(tmp_if_expr$9)
    tmp_if_expr$11 = (_Bool)1;

  else
  {
    return_value_getegid$10=getegid();
    tmp_if_expr$11 = return_value_getegid$10 != gid ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_initgroups$12;
  _Bool tmp_if_expr$15;
  unsigned int return_value_getuid$14;
  _Bool tmp_if_expr$17;
  unsigned int return_value_geteuid$16;
  if(tmp_if_expr$11)
    return -1;

  else
    if(!(user == ((char *)NULL)))
    {
      return_value_initgroups$12=initgroups(user, gid);
      if(!(return_value_initgroups$12 == -1))
        goto __CPROVER_DUMP_L14;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      signed int return_value_setuid$13;
      return_value_setuid$13=setuid(uid);
      if(return_value_setuid$13 == -1)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value_getuid$14=getuid();
        tmp_if_expr$15 = return_value_getuid$14 != uid ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$15)
        tmp_if_expr$17 = (_Bool)1;

      else
      {
        return_value_geteuid$16=geteuid();
        tmp_if_expr$17 = return_value_geteuid$16 != uid ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$17)
        return -1;

      else
        return 0;
    }
}

// daemon_check_path
// file libslack/daemon.c line 395
static signed int daemon_check_path(char *path, char *explanation, unsigned long int explanation_size, signed int level)
{
  struct stat status[1l];
  char *sep;
  signed int rc;
  signed int return_value_set_errno$1;
  if(level >= 17)
  {
    return_value_set_errno$1=set_errno(40);
    return return_value_set_errno$1;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(path);
    sep = path + (signed long int)return_value_strlen$2;
    while(!(sep == ((char *)NULL)))
    {
      sep[(signed long int)(sep == path)] = (char)0;
      signed int return_value_lstat$3;
      return_value_lstat$3=lstat(path, status);
      if(return_value_lstat$3 == -1)
        return -1;

      if((61440u & status[0l].st_mode) == 40960u)
      {
        unsigned long int daemon_check_path$$1$$1$$1$$1$$lim;
        char *sym_linked;
        char *tmp;
        signed long int return_value_limit_path$4;
        return_value_limit_path$4=limit_path();
        daemon_check_path$$1$$1$$1$$1$$lim = (unsigned long int)return_value_limit_path$4;
        void *return_value_malloc$5;
        return_value_malloc$5=malloc(daemon_check_path$$1$$1$$1$$1$$lim * sizeof(char) /*1ul*/ );
        sym_linked = (char *)return_value_malloc$5;
        if(sym_linked == ((char *)NULL))
          return -1;

        memset((void *)sym_linked, 0, daemon_check_path$$1$$1$$1$$1$$lim);
        signed long int return_value_readlink$6;
        return_value_readlink$6=readlink(path, sym_linked, daemon_check_path$$1$$1$$1$$1$$lim);
        if(return_value_readlink$6 == -1l)
        {
          free((void *)sym_linked);
          return -1;
        }

        if(!((signed int)*sym_linked == 47))
        {
          void *return_value_malloc$7;
          return_value_malloc$7=malloc(daemon_check_path$$1$$1$$1$$1$$lim * sizeof(char) /*1ul*/ );
          tmp = (char *)return_value_malloc$7;
          if(tmp == ((char *)NULL))
          {
            free((void *)sym_linked);
            return -1;
          }

          rc=snprintf(tmp, daemon_check_path$$1$$1$$1$$1$$lim, "%s%c..%c%s", path, 47, 47, sym_linked);
          if(rc == -1 || (unsigned long int)rc >= daemon_check_path$$1$$1$$1$$1$$lim)
          {
            free((void *)sym_linked);
            free((void *)tmp);
            signed int return_value_set_errno$8;
            return_value_set_errno$8=set_errno(36);
            return return_value_set_errno$8;
          }

          rc=snprintf(sym_linked, daemon_check_path$$1$$1$$1$$1$$lim, "%s", tmp);
          free((void *)tmp);
          if(rc == -1 || (unsigned long int)rc >= daemon_check_path$$1$$1$$1$$1$$lim)
          {
            free((void *)sym_linked);
            signed int return_value_set_errno$9;
            return_value_set_errno$9=set_errno(36);
            return return_value_set_errno$9;
          }

        }

        tmp=daemon_absolute_path(sym_linked);
        free((void *)sym_linked);
        sym_linked = tmp;
        if(sym_linked == ((char *)NULL))
          return -1;

        rc=daemon_check_path(sym_linked, explanation, explanation_size, level + 1);
        free((void *)sym_linked);
        if(!(rc == -1))
        {
          if(rc == 0)
            goto __CPROVER_DUMP_L12;

          if(rc == 1)
            goto __CPROVER_DUMP_L13;

        }

        else
        {
          return -1;

        __CPROVER_DUMP_L12:
          ;
          return 0;
        }
      }

      else
        if(!((18u & status[0l].st_mode) == 0u))
        {
          if(!(explanation == ((char *)NULL)))
            snprintf(explanation, explanation_size, "%s is %s%s%s writable", path, (status[0l].st_mode & (unsigned int)(0200 >> 3)) != 0u ? "group" : "", (status[0l].st_mode & (unsigned int)(0200 >> 3 | (0200 >> 3) >> 3)) == (unsigned int)(0200 >> 3 | (0200 >> 3) >> 3) ? " and " : "", (status[0l].st_mode & (unsigned int)((0200 >> 3) >> 3)) != 0u ? "world" : "");

          return 0;
        }


    __CPROVER_DUMP_L13:
      ;
      if(sep == path)
        break;

      sep=strrchr(path, 47);
    }
    return 1;
  }
}

// daemon_close
// file libslack/daemon.c line 1038
signed int daemon_close(void)
{
  signed int err;
  err=pthread_mutex_lock(&g.lock);
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  if(!(err == 0))
  {
    return_value_set_errno$1=set_errno(err);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(g.pidfile == ((char *)NULL)))
    {
      unlink(g.pidfile);
      mem_destroy((void **)&g.pidfile);
    }

    signed int daemon_close$$1$$3$$err;
    daemon_close$$1$$3$$err=pthread_mutex_unlock(&g.lock);
    if(!(daemon_close$$1$$3$$err == 0))
    {
      return_value_set_errno$2=set_errno(daemon_close$$1$$3$$err);
      return return_value_set_errno$2;
    }

    else
      return 0;
  }
}

// daemon_construct_pidfile
// file libslack/daemon.c line 598
static signed int daemon_construct_pidfile(const char *name, char **pidfile)
{
  signed long int path_len;
  const char *pid_dir;
  char *suffix = ".pid";
  unsigned long int daemon_construct_pidfile$$1$$size;
  path_len=limit_path();
  unsigned int return_value_getuid$1;
  return_value_getuid$1=getuid();
  pid_dir = return_value_getuid$1 != 0u ? "/tmp" : "/var/run";
  unsigned long int tmp_if_expr$5;
  unsigned long int return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  unsigned long int return_value_strlen$4;
  if((signed int)*name == 47)
  {
    return_value_strlen$2=strlen(name);
    tmp_if_expr$5 = return_value_strlen$2;
  }

  else
  {
    return_value_strlen$3=strlen(name);
    return_value_strlen$4=strlen(suffix);
    tmp_if_expr$5 = sizeof(const char *) /*8ul*/  + (unsigned long int)1 + return_value_strlen$3 + return_value_strlen$4;
  }
  daemon_construct_pidfile$$1$$size = tmp_if_expr$5 + (unsigned long int)1;
  signed int return_value_set_errno$6;
  void *return_value_malloc$7;
  if(!((unsigned long int)path_len >= daemon_construct_pidfile$$1$$size))
  {
    return_value_set_errno$6=set_errno(36);
    return return_value_set_errno$6;
  }

  else
    if(*pidfile == ((char *)NULL))
    {
      return_value_malloc$7=malloc((unsigned long int)path_len * sizeof(char) /*1ul*/ );
      *pidfile = (char *)return_value_malloc$7;
      if(!(*pidfile == ((char *)NULL)))
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      if((signed int)*name == 47)
        snprintf(*pidfile, (unsigned long int)path_len, "%s", name);

      else
        snprintf(*pidfile, (unsigned long int)path_len, "%s%c%s%s", pid_dir, 47, name, suffix);
      return 0;
    }
}

// daemon_getpid
// file libslack/daemon.c line 1069
signed int daemon_getpid(const char *name)
{
  char *pidfile = (char *)(void *)0;
  char buf[8192l];
  signed long int bytes;
  signed int pid_fd;
  signed int pid = 0;
  signed int return_value_set_errno$1;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile$2;
    return_value_daemon_construct_pidfile$2=daemon_construct_pidfile(name, &pidfile);
    if(return_value_daemon_construct_pidfile$2 == -1)
      return -1;

    else
    {
      pid_fd=open(pidfile, 00);
      free((void *)pidfile);
      if(pid_fd == -1)
        return -1;

      else
      {
        bytes=read(pid_fd, (void *)buf, (unsigned long int)8192);
        close(pid_fd);
        if(bytes == -1l)
          return -1;

        else
        {
          signed int return_value_sscanf$3;
          return_value_sscanf$3=sscanf(buf, "%d", &pid);
          if(!(return_value_sscanf$3 == 1))
            return -1;

          else
            return (signed int)pid;
        }
      }
    }
  }
}

// daemon_init
// file libslack/daemon.c line 876
signed int daemon_init(const char *name)
{
  signed int pid;
  signed long int nopen;
  signed int fd;
  signed int return_value_daemon_started_by_init$2;
  return_value_daemon_started_by_init$2=daemon_started_by_init();
  _Bool tmp_if_expr$4;
  signed int return_value_daemon_started_by_inetd$3;
  if(!(return_value_daemon_started_by_init$2 == 0))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_daemon_started_by_inetd$3=daemon_started_by_inetd();
    tmp_if_expr$4 = return_value_daemon_started_by_inetd$3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr$4)
  {
    pid=fork();
    if(pid == -1)
      return -1;

    if(!(pid == 0))
      exit(0);

    setsid();
    struct sigaction daemon_init$$1$$1$$1$$act[1l];
    daemon_init$$1$$1$$1$$act[0l].__sigaction_handler.sa_handler = (void (*)(signed int))1;
    sigemptyset(&daemon_init$$1$$1$$1$$act[0l].sa_mask);
    daemon_init$$1$$1$$1$$act[0l].sa_flags = 0;
    signed int return_value_sigaction$1;
    return_value_sigaction$1=sigaction(1, daemon_init$$1$$1$$1$$act, (struct sigaction *)(void *)0);
    if(return_value_sigaction$1 == -1)
      return -1;

    pid=fork();
    if(pid == -1)
      return -1;

    if(!(pid == 0))
      exit(0);

  }

  signed int return_value_chdir$5;
  return_value_chdir$5=chdir("/");
  signed int return_value_daemon_pidfile$10;
  if(return_value_chdir$5 == -1)
    return -1;

  else
  {
    umask((unsigned int)0);
    nopen=limit_open();
    if(nopen == -1l)
      return -1;

    else
    {
      signed int return_value_daemon_started_by_inetd$9;
      return_value_daemon_started_by_inetd$9=daemon_started_by_inetd();
      if(!(return_value_daemon_started_by_inetd$9 == 0))
      {
        fd = 0;
        for( ; !((signed long int)fd >= nopen); fd = fd + 1)
        {
          if(fd == 0 || fd == 1 || fd == 2)
            goto __CPROVER_DUMP_L13;

          close(fd);

        __CPROVER_DUMP_L13:
          ;
        }
      }

      else
      {
        fd = 0;
        for( ; !((signed long int)fd >= nopen); fd = fd + 1)
          close(fd);
        fd=open("/dev/null", 02);
        if(fd == -1)
          return -1;

        if(!(fd == 0))
        {
          signed int return_value_dup2$6;
          return_value_dup2$6=dup2(fd, 0);
          if(return_value_dup2$6 == -1)
            return -1;

          close(fd);
        }

        signed int return_value_dup2$7;
        return_value_dup2$7=dup2(0, 1);
        if(return_value_dup2$7 == -1)
          return -1;

        signed int return_value_dup2$8;
        return_value_dup2$8=dup2(0, 2);
        if(return_value_dup2$8 == -1)
          return -1;

      }
      if(!(name == ((const char *)NULL)))
      {
        return_value_daemon_pidfile$10=daemon_pidfile(name);
        return return_value_daemon_pidfile$10;
      }

      else
        return 0;
    }
  }
}

// daemon_is_running
// file libslack/daemon.c line 1126
signed int daemon_is_running(const char *name)
{
  char *pidfile = (char *)(void *)0;
  signed int pid_fd;
  signed int return_value_set_errno$1;
  signed int *return_value___errno_location$4;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile$2;
    return_value_daemon_construct_pidfile$2=daemon_construct_pidfile(name, &pidfile);
    if(return_value_daemon_construct_pidfile$2 == -1)
      return -1;

    else
    {
      pid_fd=open(pidfile, 00);
      if(pid_fd == -1)
      {
        free((void *)pidfile);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 2))
          return -1;

        return 0;
      }

      signed int return_value_fcntl_lock$6;
      return_value_fcntl_lock$6=fcntl_lock(pid_fd, 6, 0, 0, 0, 0);
      if(return_value_fcntl_lock$6 == -1)
      {
        free((void *)pidfile);
        close(pid_fd);
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        if(!(*return_value___errno_location$5 == 13))
        {
          return_value___errno_location$4=__errno_location();
          if(!(*return_value___errno_location$4 == 11))
            return -1;

        }

        return 1;
      }

      free((void *)pidfile);
      close(pid_fd);
      return 0;
    }
  }
}

// daemon_lock_pidfile
// file libslack/daemon.c line 633
static signed int daemon_lock_pidfile(char *pidfile)
{
  unsigned int mode = (unsigned int)(0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
  struct stat statbuf_fd[1l];
  struct stat statbuf_fs[1l];
  signed int pid_fd;
  signed int return_value_fcntl_lock$3;
  signed int return_value_fstat$4;
  signed int return_value_stat$6;
  do
  {

  start:
    ;
    pid_fd=open(pidfile, 02 | 0100 | 0200, mode);
    if(pid_fd == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 17))
        return -1;

      pid_fd=open(pidfile, 02);
      if(pid_fd == -1)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        if(*return_value___errno_location$2 == 2)
          goto start;

        return -1;
      }

    }

    return_value_fcntl_lock$3=fcntl_lock(pid_fd, 6, 1, 0, 0, 0);
    if(return_value_fcntl_lock$3 == -1)
    {
      close(pid_fd);
      return -1;
    }

    return_value_fstat$4=fstat(pid_fd, statbuf_fd);
    if(return_value_fstat$4 == -1)
    {
      close(pid_fd);
      return -1;
    }

    return_value_stat$6=stat(pidfile, statbuf_fs);
    if(return_value_stat$6 == -1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      if(*return_value___errno_location$5 == 2)
      {
        close(pid_fd);
        goto start;
      }

      close(pid_fd);
      return -1;
      break;
    }

    if(statbuf_fd[0l].st_ino == statbuf_fs[0l].st_ino)
      break;

    close(pid_fd);
  }
  while((_Bool)1);
  return pid_fd;
}

// daemon_parse_config
// file libslack/daemon.c line 525
void * daemon_parse_config(const char *path, void *obj, void (*parser)(void *, const char *, char *, unsigned long int))
{
  struct _IO_FILE *conf;
  char line[8192l];
  char buf[8192l];
  signed int lineno;
  signed int rc;
  conf=fopen(path, "r");
  char *return_value_fgets$1;
  unsigned long int return_value_strlen$2;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(conf == ((struct _IO_FILE *)NULL))
    return (void *)0;

  else
  {
    line[(signed long int)0] = (char)0;
    lineno = 1;
    do
    {
      return_value_fgets$1=fgets(buf, 8192, conf);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      char *start = buf;
      char *end;
      unsigned long int length;
      signed int cont_line;
      char *return_value___builtin_strchr$3;
      return_value___builtin_strchr$3=__builtin_strchr(start, 35);
      end = return_value___builtin_strchr$3;
      if(!(end == ((char *)NULL)))
        *end = (char)0;

      else
      {
        return_value_strlen$2=strlen(start);
        end = start + (signed long int)return_value_strlen$2;
      }
      for( ; !(start >= end); end = end - 1l)
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)end[-1l]]) == 0)
          break;

      }
      if(!(start == end) && !((signed int)*start == 0))
      {
        cont_line = (signed int)((signed int)end[(signed long int)-1] == 92);
        if(!(cont_line == 0))
          end = end - 1l;

        length=strlen(line);
        rc=snprintf(line + (signed long int)length, (unsigned long int)8192 - length, "%*.*s", (signed int)(end - start), (signed int)(end - start), start);
        if(rc == -1 || (unsigned long int)rc >= 8192ul + -length)
          return (void *)0;

        if(cont_line == 0)
        {
          parser(obj, path, line, (unsigned long int)lineno);
          line[(signed long int)0] = (char)0;
        }

      }

      lineno = lineno + 1;
    }
    while((_Bool)1);
    fclose(conf);
    return obj;
  }
}

// daemon_path_is_safe
// file libslack/daemon.c line 490
signed int daemon_path_is_safe(const char *path, char *explanation, unsigned long int explanation_size)
{
  char *abs_path;
  signed int rc;
  signed int return_value_set_errno$1;
  if(path == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    abs_path=daemon_absolute_path(path);
    if(abs_path == ((char *)NULL))
      return -1;

    else
    {
      rc=daemon_check_path(abs_path, explanation, explanation_size, 0);
      free((void *)abs_path);
      return rc;
    }
  }
}

// daemon_pidfile
// file libslack/daemon.c line 790
signed int daemon_pidfile(const char *name)
{
  signed int rc;
  signed int err;
  err=pthread_mutex_lock(&g.lock);
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  if(!(err == 0))
  {
    return_value_set_errno$1=set_errno(err);
    return return_value_set_errno$1;
  }

  else
  {
    rc=daemon_pidfile_unlocked(name);
    signed int daemon_pidfile$$1$$2$$err;
    daemon_pidfile$$1$$2$$err=pthread_mutex_unlock(&g.lock);
    if(!(daemon_pidfile$$1$$2$$err == 0))
    {
      return_value_set_errno$2=set_errno(daemon_pidfile$$1$$2$$err);
      return return_value_set_errno$2;
    }

    else
      return rc;
  }
}

// daemon_pidfile_unlocked
// file libslack/daemon.c line 728
static signed int daemon_pidfile_unlocked(const char *name)
{
  char pid[32l];
  signed int pid_fd;
  signed int return_value_set_errno$1;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile$2;
    return_value_daemon_construct_pidfile$2=daemon_construct_pidfile(name, &g.pidfile);
    if(return_value_daemon_construct_pidfile$2 == -1)
      return -1;

    else
    {
      pid_fd=daemon_lock_pidfile(g.pidfile);
      if(pid_fd == -1)
      {
        mem_destroy((void **)&g.pidfile);
        return -1;
      }

      else
      {
        signed int return_value_getpid$3;
        return_value_getpid$3=getpid();
        snprintf(pid, (unsigned long int)32, "%d\n", (signed int)return_value_getpid$3);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(pid);
        signed long int return_value_write$5;
        return_value_write$5=write(pid_fd, (const void *)pid, return_value_strlen$4);
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(pid);
        if(!((unsigned long int)return_value_write$5 == return_value_strlen$6))
        {
          daemon_close();
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// daemon_prevent_core
// file libslack/daemon.c line 169
signed int daemon_prevent_core(void)
{
  struct rlimit limit[1l] = { { .rlim_cur=(unsigned long int)0, .rlim_max=(unsigned long int)0 } };
  signed int return_value_getrlimit$1;
  return_value_getrlimit$1=getrlimit(4, limit);
  if(return_value_getrlimit$1 == -1)
    return -1;

  else
  {
    limit[0l].rlim_cur = (unsigned long int)0;
    signed int return_value_setrlimit$2;
    return_value_setrlimit$2=setrlimit(4, limit);
    return return_value_setrlimit$2;
  }
}

// daemon_revoke_privileges
// file libslack/daemon.c line 200
signed int daemon_revoke_privileges(void)
{
  unsigned int uid;
  uid=getuid();
  unsigned int gid;
  gid=getgid();
  unsigned int euid;
  euid=geteuid();
  unsigned int egid;
  egid=getegid();
  signed int return_value_setgid$1;
  _Bool tmp_if_expr$4;
  unsigned int return_value_getegid$2;
  unsigned int return_value_getgid$3;
  signed int return_value_setuid$5;
  _Bool tmp_if_expr$8;
  unsigned int return_value_geteuid$6;
  unsigned int return_value_getuid$7;
  if(!(egid == gid))
  {
    return_value_setgid$1=setgid(gid);
    if(return_value_setgid$1 == -1)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_getegid$2=getegid();
      return_value_getgid$3=getgid();
      tmp_if_expr$4 = return_value_getegid$2 != return_value_getgid$3 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$4)
      goto __CPROVER_DUMP_L3;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!(euid == uid))
    {
      return_value_setuid$5=setuid(uid);
      if(return_value_setuid$5 == -1)
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value_geteuid$6=geteuid();
        return_value_getuid$7=getuid();
        tmp_if_expr$8 = return_value_geteuid$6 != return_value_getuid$7 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$8)
        goto __CPROVER_DUMP_L6;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      endpwent();
      endgrent();
      return 0;
    }
  }
}

// daemon_started_by_inetd
// file libslack/daemon.c line 149
signed int daemon_started_by_inetd(void)
{
  unsigned long int optlen = sizeof(signed int) /*4ul*/ ;
  signed int optval;
  signed int return_value_getsockopt$1;
  return_value_getsockopt$1=getsockopt(0, 1, 3, (void *)&optval, (unsigned int *)(void *)&optlen);
  return (signed int)(return_value_getsockopt$1 == 0);
}

// daemon_started_by_init
// file libslack/daemon.c line 130
signed int daemon_started_by_init(void)
{
  signed int return_value_getppid$1;
  return_value_getppid$1=getppid();
  return (signed int)(return_value_getppid$1 == 1);
}

// daemon_stop
// file libslack/daemon.c line 1195
signed int daemon_stop(const char *name)
{
  char *pidfile = (char *)(void *)0;
  char pidbuf[32l];
  signed long int bytes;
  signed int pid_fd;
  signed int pid = -1;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$7;
  signed int return_value_set_errno$3;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile$2;
    return_value_daemon_construct_pidfile$2=daemon_construct_pidfile(name, &pidfile);
    if(return_value_daemon_construct_pidfile$2 == -1)
      return -1;

    else
    {
      pid_fd=daemon_lock_pidfile(pidfile);
      if(pid_fd == -1)
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        if(*return_value___errno_location$6 == 13)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value___errno_location$7=__errno_location();
          tmp_if_expr$8 = *return_value___errno_location$7 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          pid_fd=open(pidfile, 00);
          if(pid_fd == -1)
          {
            free((void *)pidfile);
            return -1;
          }

          free((void *)pidfile);
          bytes=read(pid_fd, (void *)pidbuf, (unsigned long int)32);
          if(!(bytes >= 1l))
          {
            close(pid_fd);
            return -1;
          }

          close(pid_fd);
          signed int return_value_sscanf$4;
          return_value_sscanf$4=sscanf(pidbuf, "%d", &pid);
          if(!(return_value_sscanf$4 == 1) || !(pid >= 1))
          {
            return_value_set_errno$3=set_errno(22);
            return return_value_set_errno$3;
          }

          signed int return_value_kill$5;
          return_value_kill$5=kill((signed int)pid, 15);
          return return_value_kill$5;
        }

        free((void *)pidfile);
        return -1;
      }

      close(pid_fd);
      unlink(pidfile);
      free((void *)pidfile);
      signed int return_value_set_errno$9;
      return_value_set_errno$9=set_errno(3);
      return return_value_set_errno$9;
    }
  }
}

// debug_invoke
// file libslack/locker.c line 243
static signed int debug_invoke(const char *name, signed int (*action)(void *), void *lock)
{
  signed int err;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  printf("[%lu] %s(%p) ...\n", (unsigned long int)return_value_pthread_self$1, name, lock);
  err=action(lock);
  unsigned long int return_value_pthread_self$2;
  char *return_value_strerror$3;
  unsigned long int return_value_pthread_self$4;
  if(!(err == 0))
  {
    return_value_pthread_self$2=pthread_self();
    return_value_strerror$3=strerror(err);
    printf("[%lu] %s(%p) done (%s)\n", (unsigned long int)return_value_pthread_self$2, name, lock, return_value_strerror$3);
  }

  else
  {
    return_value_pthread_self$4=pthread_self();
    printf("[%lu] %s(%p) done\n", (unsigned long int)return_value_pthread_self$4, name, lock);
  }
  return err;
}

// debug_level_match
// file libslack/err.c line 250
static signed int debug_level_match(unsigned long int level)
{
  unsigned long int debug_level;
  unsigned long int debug_section;
  unsigned long int section;
  debug_level=prog_debug_level();
  debug_section = debug_level & (unsigned long int)0xffffff00;
  debug_level = debug_level & (unsigned long int)0x000000ff;
  section = level & (unsigned long int)0xffffff00;
  level = level & (unsigned long int)0x000000ff;
  return (signed int)((!(debug_section != 0ul) || (debug_section & section) != 0ul) && debug_level >= level);
}

// debug_pthread_mutex_lock
// file libslack/locker.c line 261
static signed int debug_pthread_mutex_lock(union anonymous$11 *mutex)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_mutex_lock", (signed int (*)(void *))pthread_mutex_lock, (void *)mutex);
  return return_value_debug_invoke$1;
}

// debug_pthread_mutex_trylock
// file libslack/locker.c line 256
static signed int debug_pthread_mutex_trylock(union anonymous$11 *mutex)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_mutex_trylock", (signed int (*)(void *))pthread_mutex_trylock, (void *)mutex);
  return return_value_debug_invoke$1;
}

// debug_pthread_mutex_unlock
// file libslack/locker.c line 266
static signed int debug_pthread_mutex_unlock(union anonymous$11 *mutex)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_mutex_unlock", (signed int (*)(void *))pthread_mutex_unlock, (void *)mutex);
  return return_value_debug_invoke$1;
}

// debug_pthread_rwlock_rdlock
// file libslack/locker.c line 307
static signed int debug_pthread_rwlock_rdlock(union anonymous$12 *rwlock)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_rwlock_rdlock", (signed int (*)(void *))pthread_rwlock_rdlock, (void *)rwlock);
  return return_value_debug_invoke$1;
}

// debug_pthread_rwlock_tryrdlock
// file libslack/locker.c line 302
static signed int debug_pthread_rwlock_tryrdlock(union anonymous$12 *rwlock)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_rwlock_tryrdlock", (signed int (*)(void *))pthread_rwlock_tryrdlock, (void *)rwlock);
  return return_value_debug_invoke$1;
}

// debug_pthread_rwlock_trywrlock
// file libslack/locker.c line 312
static signed int debug_pthread_rwlock_trywrlock(union anonymous$12 *rwlock)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_rwlock_trywrlock", (signed int (*)(void *))pthread_rwlock_trywrlock, (void *)rwlock);
  return return_value_debug_invoke$1;
}

// debug_pthread_rwlock_unlock
// file libslack/locker.c line 322
static signed int debug_pthread_rwlock_unlock(union anonymous$12 *rwlock)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_rwlock_unlock", (signed int (*)(void *))pthread_rwlock_unlock, (void *)rwlock);
  return return_value_debug_invoke$1;
}

// debug_pthread_rwlock_wrlock
// file libslack/locker.c line 317
static signed int debug_pthread_rwlock_wrlock(union anonymous$12 *rwlock)
{
  signed int return_value_debug_invoke$1;
  return_value_debug_invoke$1=debug_invoke("pthread_rwlock_wrlock", (signed int (*)(void *))pthread_rwlock_wrlock, (void *)rwlock);
  return return_value_debug_invoke$1;
}

// debugf
// file libslack/err.c line 263
void debugf(unsigned long int level, const char *format, ...)
{
  signed int return_value_debug_level_match$1;
  return_value_debug_level_match$1=debug_level_match(level);
  if(!(return_value_debug_level_match$1 == 0))
  {
    void **args = (void **)&format;
    vdebugf(level, format, args);
    args = ((void **)NULL);
  }

}

// debugsysf
// file libslack/err.c line 514
void debugsysf(unsigned long int level, const char *format, ...)
{
  signed int return_value_debug_level_match$1;
  return_value_debug_level_match$1=debug_level_match(level);
  if(!(return_value_debug_level_match$1 == 0))
  {
    void **args = (void **)&format;
    vdebugsysf(level, format, args);
    args = ((void **)NULL);
  }

}

// decode
// file libslack/str.h line 226
struct String * decode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_decode_with_locker$1;
  return_value_decode_with_locker$1=decode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_decode_with_locker$1;
}

// decode_with_locker
// file libslack/str.c line 5738
struct String * decode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull$1;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str);
    struct String *return_value_do_decode_with_locker$3;
    return_value_do_decode_with_locker$3=do_decode_with_locker(locker, str, return_value_strlen$2, uncoded, coded, quote_char, printable);
    return return_value_do_decode_with_locker$3;
  }
}

// direct_cmp
// file libslack/map.c line 2471
static signed int direct_cmp(signed int a, signed int b)
{
  return a - b;
}

// direct_copy
// file libslack/map.c line 2466
static signed int direct_copy(signed int key)
{
  return key;
}

// direct_hash
// file libslack/map.c line 2476
static unsigned long int direct_hash(unsigned long int size, signed int key)
{
  return (unsigned long int)key % size;
}

// dlink_alloc
// file libslack/link.c line 489
void * dlink_alloc(void **freelist)
{
  void *alloc;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(freelist == ((void **)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    if(*freelist == NULL)
    {
      return_value_set_errnull$2=set_errnull(28);
      return return_value_set_errnull$2;
    }

    else
    {
      alloc = *freelist;
      *freelist=dlink_remove(*freelist);
      return alloc;
    }
}

// dlink_free
// file libslack/link.c line 539
void * dlink_free(void **freelist, void *item)
{
  void *return_value_set_errnull$1;
  if(item == NULL || freelist == ((void **)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    *freelist=dlink_insert(*freelist, item);
    return *freelist;
  }
}

// dlink_freelist_attach
// file libslack/link.c line 428
void * dlink_freelist_attach(void *freelist1, void *freelist2)
{
  char *freelist;
  void *return_value_set_errnull$1;
  signed int return_value_dlink_has_next$2;
  void *return_value_dlink_next$3;
  if(freelist2 == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    freelist = (char *)freelist1;
    if(freelist == ((char *)NULL))
      return freelist2;

    else
    {
      do
      {
        return_value_dlink_has_next$2=dlink_has_next((void *)freelist);
        if(return_value_dlink_has_next$2 == 0)
          break;

        return_value_dlink_next$3=dlink_next((void *)freelist);
        freelist = (char *)return_value_dlink_next$3;
      }
      while((_Bool)1);
      ((struct dlink_t *)freelist)->next = freelist2;
      ((struct dlink_t *)freelist2)->prev = (void *)freelist;
      return freelist1;
    }
  }
}

// dlink_freelist_init
// file libslack/link.c line 363
void * dlink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size)
{
  char *link;
  char *prev;
  void *return_value_set_errnull$1;
  if(freelist == NULL || nelem == 0ul || size == 0ul)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    prev = (char *)(void *)0;
    link = (char *)freelist;
    do
    {
      nelem = nelem - 1ul;
      if(nelem == 0ul)
        break;

      ((struct dlink_t *)link)->next = (void *)(link + (signed long int)size);
      ((struct dlink_t *)link)->prev = (void *)prev;
      prev = link;
      link = link + (signed long int)size;
    }
    while((_Bool)1);
    ((struct dlink_t *)link)->next = (void *)0;
    ((struct dlink_t *)link)->prev = (void *)prev;
    return freelist;
  }
}

// dlink_has_next
// file libslack/link.c line 143
signed int dlink_has_next(void *link)
{
  signed int return_value_set_errno$1;
  if(link == NULL)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    return (signed int)(((struct dlink_t *)link)->next != (void *)0);
}

// dlink_has_prev
// file libslack/link.c line 181
signed int dlink_has_prev(void *link)
{
  signed int return_value_set_errno$1;
  if(link == NULL)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    return (signed int)(((struct dlink_t *)link)->prev != (void *)0);
}

// dlink_insert
// file libslack/link.h line 51
void * dlink_insert(void *link, void *item)
{
  struct dlink_t *insert;
  struct dlink_t *next;
  struct dlink_t *prev;
  void *return_value_set_errnull$1;
  void *tmp_if_expr$2;
  if(item == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    insert = (struct dlink_t *)item;
    next = (struct dlink_t *)link;
    if(!(next == ((struct dlink_t *)NULL)))
      tmp_if_expr$2 = next->prev;

    else
      tmp_if_expr$2 = (void *)0;
    prev = (struct dlink_t *)tmp_if_expr$2;
    insert->next = (void *)next;
    insert->prev = (void *)prev;
    if(!(next == ((struct dlink_t *)NULL)))
      next->prev = (void *)insert;

    if(!(prev == ((struct dlink_t *)NULL)))
      prev->next = (void *)insert;

    return (void *)insert;
  }
}

// dlink_next
// file libslack/link.h line 47
void * dlink_next(void *link)
{
  void *return_value_set_errnull$1;
  if(link == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    return ((struct dlink_t *)link)->next;
}

// dlink_prev
// file libslack/link.c line 200
void * dlink_prev(void *link)
{
  void *return_value_set_errnull$1;
  if(link == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    return ((struct dlink_t *)link)->prev;
}

// dlink_remove
// file libslack/link.h line 53
void * dlink_remove(void *link)
{
  struct dlink_t *remove;
  void *return_value_set_errnull$1;
  if(link == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    remove = (struct dlink_t *)link;
    if(!(remove->next == NULL))
      ((struct dlink_t *)remove->next)->prev = remove->prev;

    if(!(remove->prev == NULL))
      ((struct dlink_t *)remove->prev)->next = remove->next;

    return remove->next;
  }
}

// do_decode_with_locker
// file libslack/str.c line 5388
static struct String * do_decode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *decoded;
  const char *start;
  const char *slosh;
  char *target;
  void *return_value_set_errnull$1;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$7;
  _Bool tmp_if_expr$6;
  const unsigned short int **return_value___ctype_b_loc$5;
  _Bool tmp_if_expr$13;
  char *return_value___builtin_strchr$12;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    decoded=str_create_with_locker_sized(locker, length + (unsigned long int)1, "");
    if(decoded == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      start = str;
      for( ; !((unsigned long int)(start - str) >= length); start = slosh + (signed long int)1)
      {
        slosh = start;
        for( ; !((unsigned long int)(slosh - str) >= length); slosh = slosh + 1l)
          if(*slosh == quote_char)
            break;

        if((unsigned long int)(slosh - str) == length)
          break;

        if(!(printable == 0))
        {
          signed int digits = 0;
          const char *s = slosh + (signed long int)1;
          char c = (char)0;
          const unsigned short int **return_value___ctype_b_loc$8;
          return_value___ctype_b_loc$8=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)(unsigned char)*s]) == 0))
            tmp_if_expr$9 = (signed int)*s <= 55 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$9 = (_Bool)0;
          if(tmp_if_expr$9)
          {
            s = s - 1l;
            do
            {
              digits = digits + 1;
              c = c << 3;
              s = s + 1l;
              c = c | (char)((signed int)*s - 48);
              if(!(digits >= 3))
              {
                return_value___ctype_b_loc$2=__ctype_b_loc();
                tmp_if_expr$3 = ((signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)s[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
                tmp_if_expr$4 = (signed int)s[(signed long int)1] <= 55 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$4 = (_Bool)0;
            }
            while(tmp_if_expr$4);
          }

          else
            if((signed int)*s == 120)
            {
              return_value___ctype_b_loc$7=__ctype_b_loc();
              if(!((4096 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)(unsigned char)s[1l]]) == 0))
                do
                {
                  digits = digits + 1;
                  c = c << 4;
                  s = s + 1l;
                  switch((signed int)*s)
                  {
                    case 48:

                    case 49:

                    case 50:

                    case 51:

                    case 52:

                    case 53:

                    case 54:

                    case 55:

                    case 56:

                    case 57:
                    {
                      c = c | (char)((signed int)*s - 48);
                      goto __CPROVER_DUMP_L18;
                    }
                    case 97:

                    case 98:

                    case 99:

                    case 100:

                    case 101:

                    case 102:
                    {
                      c = c | (char)(((signed int)*s - 97) + 10);
                      goto __CPROVER_DUMP_L18;
                    }
                    case 65:

                    case 66:

                    case 67:

                    case 68:

                    case 69:

                    case 70:
                      c = c | (char)(((signed int)*s - 65) + 10);
                    default:
                    {

                    __CPROVER_DUMP_L18:
                      ;
                      if(!(digits >= 2))
                      {
                        return_value___ctype_b_loc$5=__ctype_b_loc();
                        tmp_if_expr$6 = ((signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned char)s[(signed long int)1]] & (signed int)(unsigned short int)4096) != 0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr$6 = (_Bool)0;
                    }
                  }
                }
                while(tmp_if_expr$6);

            }

          if(!(digits == 0))
          {
            struct String *return_value_str_append$10;
            return_value_str_append$10=str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start, c);
            if(return_value_str_append$10 == ((struct String *)NULL))
            {
              str_release(decoded);
              return (struct String *)(void *)0;
            }

            slosh = s;
            goto __CPROVER_DUMP_L30;
          }

        }

        if(slosh[1l] == 0)
          tmp_if_expr$13 = (_Bool)1;

        else
        {
          return_value___builtin_strchr$12=__builtin_strchr(coded, (signed int)slosh[(signed long int)1]);
          target = return_value___builtin_strchr$12;
          tmp_if_expr$13 = !(target != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$13)
        {
          struct String *return_value_str_append$11;
          return_value_str_append$11=str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start, quote_char);
          if(return_value_str_append$11 == ((struct String *)NULL))
          {
            str_release(decoded);
            return (struct String *)(void *)0;
          }

          goto __CPROVER_DUMP_L30;
        }

        struct String *return_value_str_append$14;
        return_value_str_append$14=str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start, uncoded[target - coded]);
        if(return_value_str_append$14 == ((struct String *)NULL))
        {
          str_release(decoded);
          return (struct String *)(void *)0;
        }

        slosh = slosh + 1l;

      __CPROVER_DUMP_L30:
        ;
      }
      struct String *return_value_str_append$15;
      return_value_str_append$15=str_append(decoded, "%s", start);
      if(return_value_str_append$15 == ((struct String *)NULL))
      {
        str_release(decoded);
        return (struct String *)(void *)0;
      }

      else
        return decoded;
    }
  }
}

// do_encode_with_locker
// file libslack/str.c line 5336
static struct String * do_encode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *encoded;
  const char *target;
  const char *s;
  void *return_value_set_errnull$1;
  _Bool tmp_if_expr$8;
  char *return_value___builtin_strchr$7;
  _Bool tmp_if_expr$6;
  const unsigned short int **return_value___ctype_b_loc$5;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    encoded=str_create_with_locker_sized(locker, length * (unsigned long int)4 + (unsigned long int)1, "");
    if(encoded == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      s = str;
      for( ; !((unsigned long int)(s - str) >= length); s = s + 1l)
      {
        if(!(*s == 0))
        {
          return_value___builtin_strchr$7=__builtin_strchr(uncoded, (signed int)(unsigned char)*s);
          target = return_value___builtin_strchr$7;
          tmp_if_expr$8 = target != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
        {
          struct String *return_value_str_append$2;
          return_value_str_append$2=str_append(encoded, "%c%c", (unsigned char)quote_char, coded[target - uncoded]);
          if(return_value_str_append$2 == ((struct String *)NULL))
          {
            str_release(encoded);
            return (struct String *)(void *)0;
          }

        }

        else
        {
          if(!(printable == 0))
          {
            return_value___ctype_b_loc$5=__ctype_b_loc();
            tmp_if_expr$6 = !(((signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)16384) != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
          {
            struct String *return_value_str_append$3;
            static const char do_encode_with_locker$$1$$hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
            return_value_str_append$3=str_append(encoded, "%cx%c%c", (unsigned char)quote_char, do_encode_with_locker$$1$$hex[(signed long int)((signed int)(unsigned char)*s >> 4)], do_encode_with_locker$$1$$hex[(signed long int)((signed int)(unsigned char)*s & 0x0f)]);
            if(return_value_str_append$3 == ((struct String *)NULL))
            {
              str_release(encoded);
              return (struct String *)(void *)0;
            }

          }

          else
          {
            struct String *return_value_str_append$4;
            return_value_str_append$4=str_append(encoded, "%c", (unsigned char)*s);
            if(return_value_str_append$4 == ((struct String *)NULL))
            {
              str_release(encoded);
              return (struct String *)(void *)0;
            }

          }
        }
      }
      return encoded;
    }
  }
}

// do_exec
// file libslack/coproc.c line 159
static void do_exec(signed int has_meta, const char *cmd, char * const *argv, char * const *envv)
{
  char *return_value___builtin_strchr$9;
  unsigned int return_value_geteuid$2;
  unsigned long int return_value_strlen$3;
  if(!(has_meta == 0))
  {
    const char *do_exec$$1$$1$$shargv[4l];
    do_exec$$1$$1$$shargv[(signed long int)0] = "sh";
    do_exec$$1$$1$$shargv[(signed long int)1] = "-c";
    do_exec$$1$$1$$shargv[(signed long int)2] = cmd;
    do_exec$$1$$1$$shargv[(signed long int)3] = (const char *)(void *)0;
    execve("/bin/sh", (char * const *)do_exec$$1$$1$$shargv, envv != ((char * const *)NULL) ? envv : environ);
  }

  else
  {
    return_value___builtin_strchr$9=__builtin_strchr(cmd, 47);
    if(!(return_value___builtin_strchr$9 == ((char *)NULL)))
    {
      execve(cmd, argv, envv != ((char * const *)NULL) ? envv : environ);
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 8)
      {
        char * const *do_exec$$1$$2$$1$$shargv;
        do_exec$$1$$2$$1$$shargv=new_shargv(cmd, argv);
        execve("/bin/sh", do_exec$$1$$2$$1$$shargv, envv != ((char * const *)NULL) ? envv : environ);
        free((void *)do_exec$$1$$2$$1$$shargv);
      }

    }

    else
    {
      char *path;
      char *s;
      char *f;
      char cmdbuf[512l];
      path=getenv("PATH");
      if(path == ((char *)NULL))
      {
        return_value_geteuid$2=geteuid();
        path = return_value_geteuid$2 != 0u ? ":/bin:/usr/bin" : "/bin:/usr/bin";
      }

      s = path;
      for( ; !(s == ((char *)NULL)); s = *f != 0 ? f + (signed long int)1 : (char *)(void *)0)
      {
        char *return_value___builtin_strchr$4;
        return_value___builtin_strchr$4=__builtin_strchr(s, 58);
        f = return_value___builtin_strchr$4;
        if(f == ((char *)NULL))
        {
          return_value_strlen$3=strlen(s);
          f = s + (signed long int)return_value_strlen$3;
        }

        signed int return_value_snprintf$5;
        return_value_snprintf$5=snprintf(cmdbuf, (unsigned long int)512, "%.*s%s%s", (signed int)(f - s), s, f - s != 0l ? "/" : "", cmd);
        if(!(return_value_snprintf$5 >= 512))
        {
          signed int return_value_execve$8;
          return_value_execve$8=execve(cmdbuf, argv, envv != ((char * const *)NULL) ? envv : environ);
          if(return_value_execve$8 == -1)
          {
            signed int *return_value___errno_location$6;
            return_value___errno_location$6=__errno_location();
            if(*return_value___errno_location$6 == 13)
              goto __CPROVER_DUMP_L11;

            signed int *return_value___errno_location$7;
            return_value___errno_location$7=__errno_location();
            if(*return_value___errno_location$7 == 8)
            {
              char * const *shargv;
              shargv=new_shargv(cmdbuf, argv);
              execve("/bin/sh", shargv, envv != ((char * const *)NULL) ? envv : environ);
              free((void *)shargv);
              break;
            }

          }

        }


      __CPROVER_DUMP_L11:
        ;
      }
    }
  }
}

// do_split_with_locker
// file libslack/str.c line 3966
static struct List * do_split_with_locker(struct Locker *locker, const char *str, signed long int length, const char *delim)
{
  struct List *ret;
  const char *s;
  const char *r;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$8;
  _Bool tmp_if_expr$4;
  char *return_value___builtin_strchr$3;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  char *return_value___builtin_strchr$5;
  signed int tmp_if_expr$14;
  _Bool tmp_if_expr$10;
  char *return_value___builtin_strchr$9;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$12;
  char *return_value___builtin_strchr$11;
  signed int tmp_if_expr$16;
  if(delim == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    ret=list_create_with_locker(locker, (void (*)(void *))str_release);
    if(ret == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      s = str;
      do
      {
        if(length == -1l)
          tmp_if_expr$2 = (signed int)*s;

        else
          tmp_if_expr$2 = (signed int)(s - str < length);
        if(tmp_if_expr$2 == 0)
          break;

        do
        {
          if(length == -1l)
          {
            if(!(*s == 0))
            {
              return_value___builtin_strchr$3=__builtin_strchr(delim, (signed int)*s);
              tmp_if_expr$4 = return_value___builtin_strchr$3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$4 = (_Bool)0;
            tmp_if_expr$8 = (signed int)tmp_if_expr$4;
          }

          else
          {
            if(!(s - str >= length))
            {
              if(!(*s == 0))
              {
                return_value___builtin_strchr$5=__builtin_strchr(delim, (signed int)*s);
                tmp_if_expr$6 = return_value___builtin_strchr$5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$6 = (_Bool)0;
              tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$7 = (_Bool)0;
            tmp_if_expr$8 = (signed int)tmp_if_expr$7;
          }
          if(tmp_if_expr$8 == 0)
            break;

          s = s + 1l;
        }
        while((_Bool)1);
        if(*delim == 0)
          r = s + (signed long int)1;

        else
        {
          r = s;
          do
          {
            if(length == -1l)
            {
              if(!(*r == 0))
              {
                return_value___builtin_strchr$9=__builtin_strchr(delim, (signed int)*r);
                tmp_if_expr$10 = !(return_value___builtin_strchr$9 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$10 = (_Bool)0;
              tmp_if_expr$14 = (signed int)tmp_if_expr$10;
            }

            else
            {
              if(!(r - str >= length))
              {
                if(*r == 0)
                  tmp_if_expr$12 = (_Bool)1;

                else
                {
                  return_value___builtin_strchr$11=__builtin_strchr(delim, (signed int)*r);
                  tmp_if_expr$12 = !(return_value___builtin_strchr$11 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr$13 = tmp_if_expr$12 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$13 = (_Bool)0;
              tmp_if_expr$14 = (signed int)tmp_if_expr$13;
            }
            if(tmp_if_expr$14 == 0)
              break;

            r = r + 1l;
          }
          while((_Bool)1);
        }
        if(!(s >= r))
        {
          struct String *token;
          token=substr(s, (signed long int)0, r - s);
          if(token == ((struct String *)NULL))
          {
            list_release(ret);
            return (struct List *)(void *)0;
          }

          struct List *return_value_list_append$15;
          return_value_list_append$15=list_append(ret, (void *)token);
          if(return_value_list_append$15 == ((struct List *)NULL))
          {
            str_release(token);
            list_release(ret);
            return (struct List *)(void *)0;
          }

          s = r;
          if(*delim == 0)
            s = s - 1l;

        }

        if(length == -1l)
          tmp_if_expr$16 = (signed int)!(*s != 0);

        else
          tmp_if_expr$16 = (signed int)(s - str == length);
        if(!(tmp_if_expr$16 == 0))
          break;

        s = s + 1l;
      }
      while((_Bool)1);
      return ret;
    }
  }
}

// do_tr_compile_table
// file libslack/str.c line 2680
static struct StringTR * do_tr_compile_table(struct StringTR *table, const char *from, signed long int fromlen, const char *to, signed long int tolen, signed int option)
{
  const char *f;
  const char *t;
  char *xf;
  char *xt;
  char xfrom[256l];
  char xto[256l];
  signed short int tbl[256l];
  signed int i;
  signed int j;
  signed int k;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  void *return_value_set_errnull$4;
  char *tmp_post$5;
  void *return_value_set_errnull$6;
  char *tmp_post$7;
  _Bool tmp_if_expr$9;
  signed int tmp_if_expr$8;
  signed int tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  void *return_value_set_errnull$12;
  char *tmp_post$13;
  void *return_value_set_errnull$14;
  signed int tmp_if_expr$16;
  signed int return_value;
  void *return_value_set_errnull$15;
  signed int tmp_if_expr$18;
  signed int return_value_1;
  void *return_value_set_errnull$17;
  if(from == ((const char *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct StringTR *)return_value_set_errnull$1;
  }

  else
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
      tbl[(signed long int)i] = (signed short int)-1;
    xf = xfrom;
    f = from;
    do
    {
      if(fromlen == -1l)
        tmp_if_expr$2 = (signed int)*f;

      else
        tmp_if_expr$2 = (signed int)(f - from < fromlen);
      if(!(tmp_if_expr$2 == 0))
        tmp_if_expr$3 = xf - xfrom < (signed long int)256 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      j = (signed int)*f;
      i = j;
      if((signed int)f[1l] == 45)
      {
        if(!(f[2l] == 0))
        {
          j = (signed int)f[(signed long int)2];
          f = f + (signed long int)2;
        }

      }

      if(!((signed int)(unsigned char)j >= (signed int)(unsigned char)i))
      {
        return_value_set_errnull$4=set_errnull(22);
        return (struct StringTR *)return_value_set_errnull$4;
      }

      k = (signed int)(unsigned char)i;
      for( ; (signed int)(unsigned char)j >= k; k = k + 1)
      {
        tmp_post$5 = xf;
        xf = xf + 1l;
        tbl[(signed long int)k] = (signed short int)k;
        *tmp_post$5 = (char)tbl[(signed long int)k];
      }
      f = f + 1l;
    }
    while((_Bool)1);
    if(xf - xfrom == 256l)
    {
      return_value_set_errnull$6=set_errnull(22);
      return (struct StringTR *)return_value_set_errnull$6;
    }

    else
    {
      if(!((1 & option) == 0))
      {
        char tmp[256l];
        xf = tmp;
        k = 0;
        for( ; !(k >= 256); k = k + 1)
          if((signed int)tbl[(signed long int)k] == -1)
          {
            tmp_post$7 = xf;
            xf = xf + 1l;
            *tmp_post$7 = (char)k;
          }

        memcpy((void *)xfrom, (const void *)tmp, (unsigned long int)(xf - tmp));
        xf = xfrom + (xf - tmp);
      }

      if(to == ((const char *)NULL))
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        if(tolen == -1l)
          tmp_if_expr$8 = (signed int)((signed int)*to == 0);

        else
          tmp_if_expr$8 = (signed int)(tolen == (signed long int)0);
        tmp_if_expr$9 = tmp_if_expr$8 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
        to = (option & 2) != 0 ? "" : from;

      xt = xto;
      t = to;
      do
      {
        if(tolen == -1l)
          tmp_if_expr$10 = (signed int)*t;

        else
          tmp_if_expr$10 = (signed int)(t - to < tolen);
        if(!(tmp_if_expr$10 == 0))
          tmp_if_expr$11 = xt - xto < (signed long int)256 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        if(!tmp_if_expr$11)
          break;

        j = (signed int)*t;
        i = j;
        if((signed int)t[1l] == 45)
        {
          if(!(t[2l] == 0))
          {
            j = (signed int)t[(signed long int)2];
            t = t + (signed long int)2;
          }

        }

        if(!((signed int)(unsigned char)j >= (signed int)(unsigned char)i))
        {
          return_value_set_errnull$12=set_errnull(22);
          return (struct StringTR *)return_value_set_errnull$12;
        }

        k = (signed int)(unsigned char)i;
        for( ; (signed int)(unsigned char)j >= k; k = k + 1)
        {
          tmp_post$13 = xt;
          xt = xt + 1l;
          *tmp_post$13 = (char)k;
        }
        t = t + 1l;
      }
      while((_Bool)1);
      if(xt - xto == 256l)
      {
        return_value_set_errnull$14=set_errnull(22);
        return (struct StringTR *)return_value_set_errnull$14;
      }

      else
      {
        if((2 & option) == 0)
        {
          unsigned long int flen = (unsigned long int)(xf - xfrom);
          unsigned long int tlen = (unsigned long int)(xt - xto);
          if(!(tlen >= flen))
          {
            memset((void *)xt, (signed int)xt[(signed long int)-1], flen - tlen);
            xt = xt + (signed long int)(flen - tlen);
          }

        }

        if(!(table->locker == ((struct Locker *)NULL)))
        {
          return_value=table->locker->wrlock(table->locker->lock);
          tmp_if_expr$16 = return_value;
        }

        else
          tmp_if_expr$16 = 0;
        err = tmp_if_expr$16;
        if(!(err == 0))
        {
          return_value_set_errnull$15=set_errnull(err);
          return (struct StringTR *)return_value_set_errnull$15;
        }

        else
        {
          table->squash = option & 4;
          i = 0;
          for( ; !(i >= 256); i = i + 1)
            table->table[(signed long int)i] = (signed short int)-1;
          j = 0;
          i = j;
          for( ; !(xfrom + (signed long int)i >= xf); j = j + 1)
          {
            unsigned char fc = (unsigned char)xfrom[(signed long int)i];
            unsigned char tc = (unsigned char)xto[(signed long int)j];
            if((signed int)table->table[(signed long int)fc] == -1)
              table->table[(signed long int)fc] = (signed short int)(xto + (signed long int)j < xt ? (signed int)tc : -2);

            i = i + 1;
          }
          if(!(table->locker == ((struct Locker *)NULL)))
          {
            return_value_1=table->locker->unlock(table->locker->lock);
            tmp_if_expr$18 = return_value_1;
          }

          else
            tmp_if_expr$18 = 0;
          err = tmp_if_expr$18;
          if(!(err == 0))
          {
            return_value_set_errnull$17=set_errnull(err);
            return (struct StringTR *)return_value_set_errnull$17;
          }

          else
            return table;
        }
      }
    }
  }
}

// do_tr_compiled
// file libslack/str.c line 2866
static signed int do_tr_compiled(unsigned char *str, unsigned long int *length, struct StringTR *table)
{
  signed int ret = 0;
  signed int deleted = 0;
  unsigned char *r;
  unsigned char *s;
  signed short int t;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  unsigned char *tmp_post$5;
  _Bool tmp_if_expr$8;
  unsigned char *tmp_post$7;
  signed int tmp_if_expr$10;
  signed int return_value_1;
  signed int return_value_set_errno$9;
  if(table == ((struct StringTR *)NULL) || str == ((unsigned char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(table->locker == ((struct Locker *)NULL)))
    {
      return_value=table->locker->rdlock(table->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      s = str;
      r = s;
      do
      {
        if(!(length == ((unsigned long int *)NULL)))
          tmp_if_expr$4 = (signed int)((unsigned long int)(s - str) < *length - (unsigned long int)1);

        else
          tmp_if_expr$4 = (signed int)*s;
        if(tmp_if_expr$4 == 0)
          break;

        t = table->table[(signed long int)(signed int)*s];
        switch((signed int)t)
        {
          case -2:
          {
            deleted = deleted + 1;
            ret = ret + 1;
            break;
          }
          case -1:
          {
            if(table->squash == 0 || r == str)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = r[(signed long int)-1] != *s ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
            {
              tmp_post$5 = r;
              r = r + 1l;
              *tmp_post$5 = *s;
            }

            else
              deleted = deleted + 1;
            break;
          }
          default:
          {
            if(table->squash == 0 || r == str)
              tmp_if_expr$8 = (_Bool)1;

            else
              tmp_if_expr$8 = (signed int)r[(signed long int)-1] != (signed int)t ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$8)
            {
              tmp_post$7 = r;
              r = r + 1l;
              *tmp_post$7 = (unsigned char)t;
            }

            else
              deleted = deleted + 1;
            ret = ret + 1;
          }
        }
        s = s + 1l;
      }
      while((_Bool)1);
      if(!(table->locker == ((struct Locker *)NULL)))
      {
        return_value_1=table->locker->unlock(table->locker->lock);
        tmp_if_expr$10 = return_value_1;
      }

      else
        tmp_if_expr$10 = 0;
      err = tmp_if_expr$10;
      if(!(err == 0))
      {
        return_value_set_errno$9=set_errno(err);
        return return_value_set_errno$9;
      }

      else
      {
        *r = (unsigned char)0;
        if(!(length == ((unsigned long int *)NULL)) && !(deleted == 0))
          *length = *length - (unsigned long int)deleted;

        return ret;
      }
    }
  }
}

// dump
// file libslack/err.c line 411
void dump(const char *format, ...)
{
  void **args = (void **)&format;
  vdump(format, args);
  args = ((void **)NULL);
}

// dumpsys
// file libslack/err.c line 638
void dumpsys(const char *format, ...)
{
  void **args = (void **)&format;
  vdumpsys(format, args);
  args = ((void **)NULL);
}

// encode
// file libslack/str.h line 224
struct String * encode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_encode_with_locker$1;
  return_value_encode_with_locker$1=encode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_encode_with_locker$1;
}

// encode_with_locker
// file libslack/str.c line 5704
struct String * encode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull$1;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str);
    struct String *return_value_do_encode_with_locker$3;
    return_value_do_encode_with_locker$3=do_encode_with_locker(locker, str, return_value_strlen$2, uncoded, coded, quote_char, printable);
    return return_value_do_encode_with_locker$3;
  }
}

// error
// file libslack/err.c line 316
signed int error(const char *format, ...)
{
  void **args = (void **)&format;
  verror(format, args);
  args = ((void **)NULL);
  return -1;
}

// errorsys
// file libslack/err.c line 559
signed int errorsys(const char *format, ...)
{
  void **args = (void **)&format;
  verrorsys(format, args);
  args = ((void **)NULL);
  return -1;
}

// expand
// file libslack/list.c line 275
static signed int expand(struct List *list, signed long int index, unsigned long int range)
{
  signed int return_value_grow$1;
  return_value_grow$1=grow(list, range);
  if(return_value_grow$1 == -1)
    return -1;

  else
  {
    memmove((void *)(list->list + index + (signed long int)range), (const void *)(list->list + index), (list->length - (unsigned long int)index) * sizeof(void *) /*8ul*/ );
    list->length = list->length + range;
    return 0;
  }
}

// expand$link1
// file libslack/str.c line 454
static signed int expand$link1(struct String *str, signed long int index$link1, unsigned long int range$link1)
{
  signed int return_value_grow$1$link1;
  return_value_grow$1$link1=grow$link1(str, range$link1);
  if(return_value_grow$1$link1 == -1)
    return -1;

  else
  {
    memmove((void *)(str->str + index$link1 + (signed long int)range$link1), (const void *)(str->str + index$link1), (str->length - (unsigned long int)index$link1) * sizeof(char) /*1ul*/ );
    str->length = str->length + range$link1;
    return 0;
  }
}

// expire
// file libslack/agent.c line 1957
static signed int expire(struct Agent *agent)
{
  struct action_t *event;
  do
  {
    event = agent->timewheel->jiffies[(signed long int)agent->timewheel->jiffy];
    if(event == ((struct action_t *)NULL))
      break;

    signed int (*action)(struct Agent *, void *) = event->action;
    void *arg = event->arg;
    signed int return_value_agent_cancel_unlocked$1;
    return_value_agent_cancel_unlocked$1=agent_cancel_unlocked(agent, (void *)event);
    if(return_value_agent_cancel_unlocked$1 == -1)
      return -1;

    signed int return_value_act$2;
    return_value_act$2=act(action, agent, arg);
    if(return_value_act$2 == -1)
      return -1;

  }
  while((_Bool)1);
  return 0;
}

// fatal
// file libslack/err.c line 367
void fatal(const char *format, ...)
{
  void **args = (void **)&format;
  vfatal(format, args);
  args = ((void **)NULL);
}

// fatalsys
// file libslack/err.c line 599
void fatalsys(const char *format, ...)
{
  void **args = (void **)&format;
  vfatalsys(format, args);
  args = ((void **)NULL);
}

// fcntl_clear_flag
// file libslack/fio.c line 399
signed int fcntl_clear_flag(signed int fd, signed int flag)
{
  signed int flags;
  flags=fcntl(fd, 3, 0);
  if(flags == -1)
    return -1;

  else
  {
    signed int return_value_fcntl$1;
    return_value_fcntl$1=fcntl(fd, 4, flags & ~flag);
    return return_value_fcntl$1;
  }
}

// fcntl_lock
// file libslack/fio.h line 41
signed int fcntl_lock(signed int fd, signed int cmd, signed int type, signed int whence, signed int start, signed int len)
{
  struct flock lock[1l];
  lock[0l].l_type = (signed short int)type;
  lock[0l].l_whence = (signed short int)whence;
  lock[0l].l_start = (signed long int)start;
  lock[0l].l_len = (signed long int)len;
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(fd, cmd, (const void *)lock);
  return return_value_fcntl$1;
}

// fcntl_set_flag
// file libslack/fio.c line 376
signed int fcntl_set_flag(signed int fd, signed int flag)
{
  signed int flags;
  flags=fcntl(fd, 3, 0);
  if(flags == -1)
    return -1;

  else
  {
    signed int return_value_fcntl$1;
    return_value_fcntl$1=fcntl(fd, 4, flags | flag);
    return return_value_fcntl$1;
  }
}

// fgetline
// file libslack/fio.c line 122
char * fgetline(char *line, unsigned long int size, struct _IO_FILE *stream)
{
  char *ret;
  flockfile(stream);
  ret=fgetline_unlocked(line, size, stream);
  funlockfile(stream);
  return ret;
}

// fgetline_unlocked
// file libslack/fio.c line 143
char * fgetline_unlocked(char *line, unsigned long int size, struct _IO_FILE *stream)
{
  char *s = line;
  char *end = (line + (signed long int)size) - (signed long int)1;
  signed int c = 0;
  signed int c2;
  char *tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  _Bool tmp_if_expr$5;
  signed int return_value_ferror$4;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    while(!(s >= end))
    {
      c=getc_unlocked(stream);
      if(c == -1)
        break;

      if(c == 10)
      {
        tmp_post$1 = s;
        s = s + 1l;
        *tmp_post$1 = (char)c;
        break;
      }

      else
        if(c == 13)
        {
          tmp_post$2 = s;
          s = s + 1l;
          *tmp_post$2 = (char)10;
          c2=getc_unlocked(stream);
          if(c2 == 10)
            break;

          ungetc(c2, stream);
          break;
        }

        else
        {
          tmp_post$3 = s;
          s = s + 1l;
          *tmp_post$3 = (char)c;
        }
    }
    *s = (char)0;
    if(c == -1)
    {
      if(s == line)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_ferror$4=ferror(stream);
        tmp_if_expr$5 = return_value_ferror$4 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$5)
        goto __CPROVER_DUMP_L8;

      return (char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      return line;
    }
  }
}

// fifo_exists
// file libslack/fio.c line 503
signed int fifo_exists(const char *path, signed int prepare)
{
  struct stat status[1l];
  signed int return_value_stat$2;
  return_value_stat$2=stat$link1(path, status);
  signed int *return_value___errno_location$1;
  if(return_value_stat$2 == -1)
  {
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1 == 2 ? 0 : -1;
  }

  else
    if(!((61440u & status[0l].st_mode) == 4096u))
    {
      if(!(prepare == 0))
        unlink(path);

      return 0;
    }

    else
      return 1;
}

// fifo_has_reader
// file libslack/fio.c line 535
signed int fifo_has_reader(const char *path, signed int prepare)
{
  signed int fd;
  signed int return_value_fifo_exists$1;
  return_value_fifo_exists$1=fifo_exists(path, prepare);
  if(!(return_value_fifo_exists$1 == 0))
  {
    if(return_value_fifo_exists$1 == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    return 0;

  __CPROVER_DUMP_L2:
    ;
    return -1;
  }
  fd=open(path, 01 | 04000);
  signed int *return_value___errno_location$2;
  if(fd == -1)
  {
    return_value___errno_location$2=__errno_location();
    return *return_value___errno_location$2 == 6 ? 0 : -1;
  }

  else
  {
    signed int return_value_close$3;
    return_value_close$3=close(fd);
    if(return_value_close$3 == -1)
      return -1;

    else
      return 1;
  }
}

// fifo_open
// file libslack/fio.c line 598
signed int fifo_open(const char *path, unsigned int mode, signed int lock, signed int *writefd)
{
  struct stat status[1l];
  signed int rfd;
  signed int wfd;
  signed int mine = 0;
  signed int return_value_fifo_has_reader$1;
  return_value_fifo_has_reader$1=fifo_has_reader(path, 1);
  if(!(return_value_fifo_has_reader$1 == 1))
  {
    if(return_value_fifo_has_reader$1 == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    signed int return_value_set_errno$2;
    return_value_set_errno$2=set_errno(98);
    return return_value_set_errno$2;

  __CPROVER_DUMP_L2:
    ;
    return -1;
  }
  signed int return_value_mkfifo$4;
  return_value_mkfifo$4=mkfifo(path, mode);
  signed int *return_value___errno_location$3;
  if(!(return_value_mkfifo$4 == -1))
    mine = 1;

  else
  {
    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 17))
      return -1;

  }
  rfd=open(path, 00 | 04000);
  _Bool tmp_if_expr$6;
  signed int return_value_fcntl_lock$13;
  signed int *return_value___errno_location$12;
  signed int *return_value___errno_location$11;
  signed int *return_value___errno_location$10;
  signed int tmp_if_expr$9;
  signed int return_value_set_errno$8;
  _Bool tmp_if_expr$15;
  if(rfd == -1)
  {
    if(!(mine == 0))
      unlink(path);

    return -1;
  }

  else
  {
    signed int return_value_fstat$5;
    return_value_fstat$5=fstat$link1(rfd, status);
    if(return_value_fstat$5 == -1)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)((status[0l].st_mode & (unsigned int)0170000) == (unsigned int)0010000) == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      if(!(mine == 0))
        unlink(path);

      close(rfd);
      return -1;
    }

    else
    {
      wfd=open(path, 01);
      if(wfd == -1)
      {
        if(!(mine == 0))
          unlink(path);

        close(rfd);
        return -1;
      }

      else
      {
        if(!(lock == 0))
        {
          return_value_fcntl_lock$13=fcntl_lock(wfd, 6, 1, 0, 0, 0);
          if(return_value_fcntl_lock$13 == -1)
          {
            return_value___errno_location$12=__errno_location();
            if(!(*return_value___errno_location$12 == 95))
            {
              return_value___errno_location$11=__errno_location();
              if(!(*return_value___errno_location$11 == 95))
              {
                return_value___errno_location$10=__errno_location();
                if(!(*return_value___errno_location$10 == 9))
                {
                  if(!(mine == 0))
                    unlink(path);

                  close(rfd);
                  close(wfd);
                  signed int *return_value___errno_location$7;
                  return_value___errno_location$7=__errno_location();
                  if(*return_value___errno_location$7 == 13)
                  {
                    return_value_set_errno$8=set_errno(98);
                    tmp_if_expr$9 = return_value_set_errno$8;
                  }

                  else
                    tmp_if_expr$9 = -1;
                  return tmp_if_expr$9;
                }

              }

            }

          }

        }

        signed int return_value_fstat$14;
        return_value_fstat$14=fstat$link1(wfd, status);
        if(return_value_fstat$14 == -1)
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = (signed int)((status[0l].st_mode & (unsigned int)0170000) == (unsigned int)0010000) == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
        {
          if(!(mine == 0))
            unlink(path);

          close(rfd);
          close(wfd);
          return -1;
        }

        else
        {
          signed int return_value_nonblock_off$16;
          return_value_nonblock_off$16=nonblock_off(rfd);
          if(return_value_nonblock_off$16 == -1)
          {
            if(!(mine == 0))
              unlink(path);

            close(rfd);
            close(wfd);
            return -1;
          }

          else
          {
            if(!(writefd == ((signed int *)NULL)))
              *writefd = wfd;

            return rfd;
          }
        }
      }
    }
  }
}

// fmt
// file libslack/str.c line 3757
struct List * fmt(const char *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *return_value_fmt_with_locker$1;
  return_value_fmt_with_locker$1=fmt_with_locker((struct Locker *)(void *)0, str, line_width, alignment);
  return return_value_fmt_with_locker$1;
}

// fmt_with_locker
// file libslack/str.c line 3773
struct List * fmt_with_locker(struct Locker *locker, const char *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *para;
  struct String *line = (struct String *)(void *)0;
  const char *s;
  const char *r;
  signed long int len;
  void *return_value_set_errnull$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  struct List *return_value_list_append$5;
  struct String *return_value_str_append$6;
  signed long int return_value_str_length$8;
  struct List *return_value_list_append$7;
  signed int return_value_list_has_next$9;
  _Bool tmp_if_expr$13;
  signed int return_value_list_has_next$15;
  struct String *return_value_str_prepend$17;
  void *return_value_set_errnull$18;
  if(str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    switch((signed int)alignment)
    {
      case ALIGN_LEFT:

      case ALIGN_RIGHT:

      case ALIGN_FULL:
      {
        para=list_create_with_locker(locker, (void (*)(void *))str_release);
        if(para == ((struct List *)NULL))
          return (struct List *)(void *)0;

        s = str;
        for( ; !(*s == 0); s = s + 1l)
        {
          do
          {
            return_value___ctype_b_loc$2=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
              break;

            s = s + 1l;
          }
          while((_Bool)1);
          r = s;
          do
          {
            if(!(*r == 0))
            {
              return_value___ctype_b_loc$3=__ctype_b_loc();
              tmp_if_expr$4 = !(((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)(unsigned char)*r] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$4 = (_Bool)0;
            if(!tmp_if_expr$4)
              break;

            r = r + 1l;
          }
          while((_Bool)1);
          if(!(s >= r))
          {
            len=str_length(line);
            if(len == -1l)
              len = len + 1l;

            if(!(line_width >= (unsigned long int)(r - s) + (unsigned long int)len + (unsigned long int)(signed long int)!(len == 0l)))
            {
              if(!(len == 0l))
              {
                return_value_list_append$5=list_append(para, (void *)line);
                if(return_value_list_append$5 == ((struct List *)NULL))
                {
                  str_release(line);
                  list_release(para);
                  return (struct List *)(void *)0;
                }

              }

              line = (struct String *)(void *)0;
            }

            if(line == ((struct String *)NULL))
            {
              line=str_create_sized(line_width, "%.*s", r - s, s);
              if(line == ((struct String *)NULL))
              {
                list_release(para);
                return (struct List *)(void *)0;
              }

            }

            else
            {
              return_value_str_append$6=str_append(line, " %.*s", r - s, s);
              if(return_value_str_append$6 == ((struct String *)NULL))
              {
                str_release(line);
                list_release(para);
                return (struct List *)(void *)0;
              }

            }
            s = r;
            if(*s == 0)
              s = s - 1l;

          }

        }
        return_value_str_length$8=str_length(line);
        if(return_value_str_length$8 >= 1l)
        {
          return_value_list_append$7=list_append(para, (void *)line);
          if(return_value_list_append$7 == ((struct List *)NULL))
          {
            str_release(line);
            list_release(para);
            return (struct List *)(void *)0;
          }

        }

        if((signed int)alignment == ALIGN_RIGHT)
          do
          {
            return_value_list_has_next$9=list_has_next(para);
            if(!(return_value_list_has_next$9 == 1))
              break;

            void *return_value_list_next$10;
            return_value_list_next$10=list_next(para);
            line = (struct String *)return_value_list_next$10;
            len=str_length(line);
            if(!((unsigned long int)len >= line_width))
            {
              struct String *return_value_str_prepend$11;
              return_value_str_prepend$11=str_prepend(line, "%*s", line_width - (unsigned long int)len, (const void *)"");
              if(return_value_str_prepend$11 == ((struct String *)NULL))
              {
                list_release(para);
                return (struct List *)(void *)0;
              }

            }

          }
          while((_Bool)1);

        else
          if((signed int)alignment == ALIGN_FULL)
          {
            signed long int lines;
            signed int i;
            lines=list_length(para);
            if(lines == -1l)
            {
              list_release(para);
              return (struct List *)(void *)0;
            }

            i = 0;
            for( ; !((signed long int)i >= lines + -1l); i = i + 1)
            {
              unsigned long int extra;
              unsigned long int gaps;
              void *return_value_list_item$12;
              return_value_list_item$12=list_item(para, (signed long int)i);
              line = (struct String *)return_value_list_item$12;
              len=str_length(line);
              if(!((unsigned long int)len >= line_width))
              {
                extra = line_width - (unsigned long int)len;
                gaps = (unsigned long int)0;
                s = line->str;
                for( ; !(*s == 0); s = s + 1l)
                  if((signed int)*s == 32)
                    gaps = gaps + 1ul;

                s = line->str;
                do
                {
                  if(!(gaps == 0ul))
                    tmp_if_expr$13 = *s != 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$13 = (_Bool)0;
                  if(!tmp_if_expr$13)
                    break;

                  if((signed int)*s == 32)
                  {
                    signed int gap = (signed int)(extra / gaps);
                    struct String *return_value_str_insert$14;
                    return_value_str_insert$14=str_insert(line, s - line->str, "%*s", gap, (const void *)"");
                    if(return_value_str_insert$14 == ((struct String *)NULL))
                    {
                      list_release(para);
                      return (struct List *)(void *)0;
                    }

                    extra = extra - (unsigned long int)gap;
                    gaps = gaps - 1ul;
                    s = s + (signed long int)gap;
                  }

                  s = s + 1l;
                }
                while((_Bool)1);
              }

            }
          }

        break;
      }
      case ALIGN_CENTRE:
      {
        para=split_with_locker(locker, str, "\n");
        if(para == ((struct List *)NULL))
          return (struct List *)(void *)0;

        do
        {
          return_value_list_has_next$15=list_has_next(para);
          if(!(return_value_list_has_next$15 == 1))
            break;

          unsigned long int fmt_with_locker$$1$$1$$2$$1$$extra;
          void *return_value_list_next$16;
          return_value_list_next$16=list_next(para);
          line = (struct String *)return_value_list_next$16;
          str_squeeze(line);
          len=str_length(line);
          if(!((unsigned long int)len >= line_width))
          {
            fmt_with_locker$$1$$1$$2$$1$$extra = (line_width - (unsigned long int)len) / (unsigned long int)2;
            if(!(fmt_with_locker$$1$$1$$2$$1$$extra == 0ul))
            {
              return_value_str_prepend$17=str_prepend(line, "%*s", fmt_with_locker$$1$$1$$2$$1$$extra, (const void *)"");
              if(return_value_str_prepend$17 == ((struct String *)NULL))
              {
                list_release(para);
                return (struct List *)(void *)0;
              }

            }

          }

        }
        while((_Bool)1);
        break;
      }
      default:
      {
        return_value_set_errnull$18=set_errnull(22);
        return (struct List *)return_value_set_errnull$18;
      }
    }
    return para;
  }
}

// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf)
{
  signed int return_value___fxstat$1;
  return_value___fxstat$1=__fxstat(1, __fd, __statbuf);
  return return_value___fxstat$1;
}

// fstat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat$link1(signed int __fd$link1, struct stat *__statbuf$link1)
{
  signed int return_value___fxstat$1$link1;
  return_value___fxstat$1$link1=__fxstat(1, __fd$link1, __statbuf$link1);
  return return_value___fxstat$1$link1;
}

// getc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 63
static inline signed int getc_unlocked(struct _IO_FILE *__fp)
{
  signed int tmp_if_expr$3;
  signed int return_value___uflow$1;
  char *tmp_post$2;
  if(__fp->_IO_read_ptr >= __fp->_IO_read_end)
  {
    return_value___uflow$1=__uflow(__fp);
    tmp_if_expr$3 = return_value___uflow$1;
  }

  else
  {
    tmp_post$2 = __fp->_IO_read_ptr;
    __fp->_IO_read_ptr = __fp->_IO_read_ptr + 1l;
    tmp_if_expr$3 = (signed int)*((unsigned char *)tmp_post$2);
  }
  return tmp_if_expr$3;
}

// getprotonamebysocktype
// file libslack/net.c line 496
static const char * getprotonamebysocktype(signed int socktype)
{
  switch(socktype)
  {
    case 1:
      return "tcp";
    case 2:
      return "udp";
    default:
      return (const char *)(void *)0;
  }
}

// getservportbynameandtype
// file libslack/net.c line 506
static unsigned short int getservportbynameandtype(const char *name, signed int type)
{
  struct servent servbuf[1l];
  struct servent *serv;
  void *buf = (void *)0;
  unsigned long int getservportbynameandtype$$1$$size = (unsigned long int)0;
  unsigned short int port = (unsigned short int)0;
  const char *proto;
  proto=getprotonamebysocktype(type);
  serv=net_getservbyname(name, proto, servbuf, &buf, &getservportbynameandtype$$1$$size);
  if(!(serv == ((struct servent *)NULL)))
    port = (unsigned short int)serv->s_port;

  free(buf);
  return port;
}

// groupname2gid
// file libslack/pseudo.c line 174
static signed int groupname2gid(const char *groupname)
{
  struct _IO_FILE *group;
  group=fopen("/etc/group", "r");
  char line[8192l];
  char *gid;
  signed int ret = -1;
  char *return_value_fgets$1;
  do
  {
    return_value_fgets$1=fgets(line, 8192, group);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(line, "tty:", (unsigned long int)4);
    if(return_value_strncmp$3 == 0)
    {
      char *return_value___builtin_strchr$2;
      return_value___builtin_strchr$2=__builtin_strchr(line + (signed long int)4, 58);
      gid = return_value___builtin_strchr$2;
      if(!(gid == ((char *)NULL)))
        ret=atoi(gid + (signed long int)1);

      break;
    }

  }
  while((_Bool)1);
  fclose(group);
  return ret;
}

// grow
// file libslack/list.c line 218
static signed int grow(struct List *list, unsigned long int items)
{
  signed int grown = 0;
  for( ; !(list->size >= list->length + items); grown = 1)
    if(!(list->size == 0ul))
      list->size = list->size << 1;

    else
      list->size = MIN_LIST_SIZE;
  void *return_value_mem_resize_fn$1;
  if(!(grown == 0))
  {
    return_value_mem_resize_fn$1=mem_resize_fn((void **)&list->list, list->size * sizeof(void *) /*8ul*/ );
    return return_value_mem_resize_fn$1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// grow$link1
// file libslack/str.c line 397
static signed int grow$link1(struct String *str, unsigned long int bytes)
{
  signed int grown$link1 = 0;
  for( ; !(str->size >= str->length + bytes); grown$link1 = 1)
    if(!(str->size == 0ul))
      str->size = str->size << 1;

    else
      str->size = MIN_STRING_SIZE;
  void *return_value_mem_resize_fn$1$link1;
  if(!(grown$link1 == 0))
  {
    return_value_mem_resize_fn$1$link1=mem_resize_fn((void **)&str->str, str->size * sizeof(char) /*1ul*/ );
    return return_value_mem_resize_fn$1$link1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// handle_debug_option
// file libslack/prog.c line 1719
static void handle_debug_option(signed int *arg)
{
  signed int tmp_if_expr$1;
  if(!(arg == ((signed int *)NULL)))
    tmp_if_expr$1 = *arg;

  else
    tmp_if_expr$1 = 1;
  prog_set_debug_level((unsigned long int)tmp_if_expr$1);
}

// handle_verbose_option
// file libslack/prog.c line 1714
static void handle_verbose_option(signed int *arg)
{
  signed int tmp_if_expr$1;
  if(!(arg == ((signed int *)NULL)))
    tmp_if_expr$1 = *arg;

  else
    tmp_if_expr$1 = 1;
  prog_set_verbosity_level((unsigned long int)tmp_if_expr$1);
}

// hash
// file libslack/map.c line 217
static unsigned long int hash(unsigned long int size, const void *key)
{
  const unsigned char *k = (const unsigned char *)key;
  unsigned long int h = (unsigned long int)0;
  const unsigned char *tmp_post$1;
  for( ; !(*k == 0); h = h + (unsigned long int)*tmp_post$1)
  {
    h = h * (unsigned long int)31;
    tmp_post$1 = k;
    k = k + 1l;
  }
  return h % size;
}

// hex
// file libslack/str.c line 6370
signed int hex(const char *str)
{
  signed int ret = 0;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  if(str == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if((signed int)*str == 48)
    {
      if((signed int)str[1l] == 120)
        str = str + (signed long int)2;

    }

    for( ; !(*str == 0); str = str + 1l)
    {
      ret = ret << 4;
      switch((signed int)*str)
      {
        case 48:

        case 49:

        case 50:

        case 51:

        case 52:

        case 53:

        case 54:

        case 55:

        case 56:

        case 57:
        {
          ret = ret | (signed int)*str - 48;
          break;
        }
        case 97:

        case 98:

        case 99:

        case 100:

        case 101:

        case 102:
        {
          ret = ret | ((signed int)*str - 97) + 10;
          break;
        }
        case 65:

        case 66:

        case 67:

        case 68:

        case 69:

        case 70:
        {
          ret = ret | ((signed int)*str - 65) + 10;
          break;
        }
        default:
        {
          return_value_set_errno$2=set_errno(22);
          return return_value_set_errno$2;
        }
      }
    }
    return ret;
  }
}

// hsort
// file libslack/hsort.c line 201
void hsort(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *))
{
  char *p;
  char *q;
  char *base0;
  char *hi;
  unsigned int gap;
  unsigned int hsort$$1$$g;
  signed int return_value;
  signed int return_value_2;
  if(n >= 2ul)
  {
    base0 = (char *)base - (signed long int)size;
    gap = (unsigned int)((n >> 1) * size);
    hi = base0 + (signed long int)gap + (signed long int)gap;
    if(!((1ul & n) == 0ul))
      hi = hi + (signed long int)size;

    for( ; !((unsigned long int)gap == size); gap = gap - (unsigned int)size)
    {
      hsort$$1$$g = gap;
      p = base0 + (signed long int)hsort$$1$$g;
      q = p + (signed long int)hsort$$1$$g;
      if(hi >= q)
      {
        hsort$$1$$g = hsort$$1$$g + hsort$$1$$g;
        if(!(q == hi))
        {
          return_value=cmp((const void *)(q + (signed long int)size), (const void *)q);
          if(return_value >= 1)
          {
            q = q + (signed long int)size;
            hsort$$1$$g = hsort$$1$$g + (unsigned int)size;
          }

        }

        signed int return_value_1;
        return_value_1=cmp((const void *)p, (const void *)q);
        if(!(return_value_1 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

    }
    for( ; !(hi == (char *)base); hi = hi - (signed long int)size)
    {
      p = (char *)base;
      hsort$$1$$g = (unsigned int)size;
      q = p + (signed long int)hsort$$1$$g;
      if(hi >= q)
      {
        hsort$$1$$g = hsort$$1$$g + hsort$$1$$g;
        if(!(q == hi))
        {
          return_value_2=cmp((const void *)(q + (signed long int)size), (const void *)q);
          if(return_value_2 >= 1)
          {
            q = q + (signed long int)size;
            hsort$$1$$g = hsort$$1$$g + (unsigned int)size;
          }

        }

        signed int return_value_3;
        return_value_3=cmp((const void *)p, (const void *)q);
        if(!(return_value_3 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

      swap((char *)base, hi, size);
    }
  }

}

// hsort_closure
// file libslack/hsort.c line 295
void hsort_closure(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *, const void *), const void *data)
{
  char *p;
  char *q;
  char *base0;
  char *hi;
  unsigned int gap;
  unsigned int hsort_closure$$1$$g;
  signed int return_value;
  signed int return_value_2;
  if(n >= 2ul)
  {
    base0 = (char *)base - (signed long int)size;
    gap = (unsigned int)((n >> 1) * size);
    hi = base0 + (signed long int)gap + (signed long int)gap;
    if(!((1ul & n) == 0ul))
      hi = hi + (signed long int)size;

    for( ; !((unsigned long int)gap == size); gap = gap - (unsigned int)size)
    {
      hsort_closure$$1$$g = gap;
      p = base0 + (signed long int)hsort_closure$$1$$g;
      q = p + (signed long int)hsort_closure$$1$$g;
      if(hi >= q)
      {
        hsort_closure$$1$$g = hsort_closure$$1$$g + hsort_closure$$1$$g;
        if(!(q == hi))
        {
          return_value=cmp((const void *)(q + (signed long int)size), (const void *)q, data);
          if(return_value >= 1)
          {
            q = q + (signed long int)size;
            hsort_closure$$1$$g = hsort_closure$$1$$g + (unsigned int)size;
          }

        }

        signed int return_value_1;
        return_value_1=cmp((const void *)p, (const void *)q, data);
        if(!(return_value_1 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

    }
    for( ; !(hi == (char *)base); hi = hi - (signed long int)size)
    {
      p = (char *)base;
      hsort_closure$$1$$g = (unsigned int)size;
      q = p + (signed long int)hsort_closure$$1$$g;
      if(hi >= q)
      {
        hsort_closure$$1$$g = hsort_closure$$1$$g + hsort_closure$$1$$g;
        if(!(q == hi))
        {
          return_value_2=cmp((const void *)(q + (signed long int)size), (const void *)q, data);
          if(return_value_2 >= 1)
          {
            q = q + (signed long int)size;
            hsort_closure$$1$$g = hsort_closure$$1$$g + (unsigned int)size;
          }

        }

        signed int return_value_3;
        return_value_3=cmp((const void *)p, (const void *)q, data);
        if(!(return_value_3 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

      swap((char *)base, hi, size);
    }
  }

}

// iface_release
// file libslack/net.c line 2007
static void iface_release(struct net_interface_t *iface)
{
  if(!(iface == ((struct net_interface_t *)NULL)))
  {
    free((void *)iface->addr);
    free((void *)iface->brdaddr);
    free((void *)iface->dstaddr);
    free((void *)iface->hwaddr);
    free((void *)iface);
  }

}

// inet6_required
// file libslack/net.c line 468
static signed int inet6_required(void)
{
  char *res_options;
  struct _IO_FILE *resolv_conf;
  res_options=getenv("RES_OPTIONS");
  char *return_value_strstr$1;
  char *return_value_fgets$2;
  char *return_value_strstr$3;
  if(!(res_options == ((char *)NULL)))
  {
    return_value_strstr$1=strstr(res_options, "inet6");
    if(return_value_strstr$1 == ((char *)NULL))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    resolv_conf=fopen("/etc/resolv.conf", "r");
    if(!(resolv_conf == ((struct _IO_FILE *)NULL)))
    {
      char line[8192l];
      do
      {
        return_value_fgets$2=fgets(line, 8192, resolv_conf);
        if(return_value_fgets$2 == ((char *)NULL))
          break;

        signed int return_value_strncmp$4;
        return_value_strncmp$4=strncmp(line, "options", (unsigned long int)7);
        if(return_value_strncmp$4 == 0)
        {
          return_value_strstr$3=strstr(line + (signed long int)8, "inet6");
          if(!(return_value_strstr$3 == ((char *)NULL)))
          {
            fclose(resolv_conf);
            return 1;
          }

        }

      }
      while((_Bool)1);
      fclose(resolv_conf);
    }

    return 0;
  }
}

// install
// file libslack/agent.c line 1639
static void install(struct action_t **parent, struct action_t *action)
{
  void *return_value_dlink_insert$1;
  return_value_dlink_insert$1=dlink_insert((void *)*parent, (void *)action);
  *parent = (struct action_t *)return_value_dlink_insert$1;
  action->parent = parent;
}

// int_arg
// file libslack/prog.c line 1862
static signed int int_arg(const char *argument)
{
  char *endptr = (char *)(void *)0;
  signed long int val;
  val=strtol(argument, &endptr, 0);
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if(val >= 2147483648l)
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 34;
    return 0x7fffffff;
  }

  else
    if(!(val >= -2147483648l))
    {
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 34;
      return -0x7fffffff - 1;
    }

    else
    {
      if(endptr == argument)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        return_value___errno_location$3=__errno_location();
        *return_value___errno_location$3 = 33;
        return 0;
      }

      else
        return (signed int)val;
    }
}

// is_multicast
// file libslack/net.c line 555
static signed int is_multicast(struct sockaddr *address)
{
  union sockaddr_any_t *addr = (union sockaddr_any_t *)address;
  signed long int *longptr;
  unsigned int return_value___bswap_32$1;
  switch((signed int)addr->any.sa_family)
  {
    case 2:
    {
      longptr = (signed long int *)&addr->in.sin_addr;
      return_value___bswap_32$1=__bswap_32((unsigned int)*longptr);
      return (signed int)(((unsigned int)return_value___bswap_32$1 & 0xf0000000) == 0xe0000000);
    }
    case 10:
      return (signed int)((signed int)((const unsigned char *)&addr->in6.sin6_addr)[(signed long int)0] == 0xff);
    default:
      return 0;
  }
}

// iterate_builtin
// file libslack/map.c line 2548
void * iterate_builtin(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  signed int broken = 0;
  if(!(debug == 0))
    printf("i%d: loop\n", t);

  i = 0;
  signed int return_value_map_has_next$1;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    map_wrlock(mtmap);
    do
    {
      return_value_map_has_next$1=map_has_next(mtmap);
      if(!(return_value_map_has_next$1 == 1))
        break;

      signed int val;
      void *return_value_map_next$2;
      return_value_map_next$2=map_next(mtmap);
      val = (signed int)(signed long int)return_value_map_next$2;
      if(!(debug == 0))
        printf("i%d: loop %d/%d val %d\n", t, i, lim / 10, val);

      if(broken == 0)
      {
        map_break(mtmap);
        broken = 1;
        break;
      }

    }
    while((_Bool)1);
    map_unlock(mtmap);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// iterate_rdlocked
// file libslack/map.c line 2583
void * iterate_rdlocked(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  if(!(debug == 0))
    printf("j%d: loop\n", t);

  i = 0;
  signed int return_value_mapper_has_next$1;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    struct Mapper *mapper;
    mapper=mapper_create_rdlocked(mtmap);
    do
    {
      return_value_mapper_has_next$1=mapper_has_next(mapper);
      if(!(return_value_mapper_has_next$1 == 1))
        break;

      signed int val;
      void *return_value_mapper_next$2;
      return_value_mapper_next$2=mapper_next(mapper);
      val = (signed int)(signed long int)return_value_mapper_next$2;
      if(!(debug == 0))
        printf("j%d: loop %d/%d val %d\n", t, i, lim / 10, val);

    }
    while((_Bool)1);
    mapper_release(mapper);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// iterate_wrlocked
// file libslack/map.c line 2610
void * iterate_wrlocked(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  if(!(debug == 0))
    printf("k%d: loop\n", t);

  i = 0;
  signed int return_value_mapper_has_next$1;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    struct Mapper *mapper;
    mapper=mapper_create_wrlocked(mtmap);
    do
    {
      return_value_mapper_has_next$1=mapper_has_next(mapper);
      if(!(return_value_mapper_has_next$1 == 1))
        break;

      signed int val;
      void *return_value_mapper_next$2;
      return_value_mapper_next$2=mapper_next(mapper);
      val = (signed int)(signed long int)return_value_mapper_next$2;
      if(!(debug == 0))
        printf("k%d: loop %d/%d val %d\n", t, i, lim / 10, val);

    }
    while((_Bool)1);
    mapper_release(mapper);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// join
// file libslack/str.c line 4465
struct String * join(const struct List *list, const char *delim)
{
  struct String *return_value_join_with_locker$1;
  return_value_join_with_locker$1=join_with_locker((struct Locker *)(void *)0, list, delim);
  return return_value_join_with_locker$1;
}

// join_with_locker
// file libslack/str.c line 4481
struct String * join_with_locker(struct Locker *locker, const struct List *list, const char *delim)
{
  struct String *ret;
  struct String *del;
  struct Lister *lister;
  signed int i;
  void *return_value_set_errnull$1;
  signed int return_value_lister_has_next$2;
  struct String *return_value_str_append_str$4;
  struct String *return_value_str_append$5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_create_with_locker(locker, (const char *)(void *)0);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      del=str_create(delim != ((const char *)NULL) ? "%s" : (char *)(void *)0, delim);
      if(del == ((struct String *)NULL))
      {
        str_release(ret);
        return (struct String *)(void *)0;
      }

      else
      {
        lister=lister_create((struct List *)list);
        if(lister == ((struct Lister *)NULL))
        {
          str_release(ret);
          str_release(del);
          return (struct String *)(void *)0;
        }

        else
        {
          i = 0;
          do
          {
            return_value_lister_has_next$2=lister_has_next(lister);
            if(!(return_value_lister_has_next$2 == 1))
              break;

            char *s;
            void *return_value_lister_next$3;
            return_value_lister_next$3=lister_next(lister);
            s = (char *)return_value_lister_next$3;
            if(!(i == 0))
            {
              return_value_str_append_str$4=str_append_str(ret, del);
              if(return_value_str_append_str$4 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release(lister);
                return (struct String *)(void *)0;
              }

            }

            if(!(s == ((char *)NULL)))
            {
              return_value_str_append$5=str_append(ret, "%s", s);
              if(return_value_str_append$5 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release(lister);
                return (struct String *)(void *)0;
              }

            }

            i = i + 1;
          }
          while((_Bool)1);
          str_release(del);
          lister_release(lister);
          return ret;
        }
      }
    }
  }
}

// key_cmp
// file libslack/prop.c line 192
static signed int key_cmp(const char **a, const char **b)
{
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(*a, *b);
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  return tmp_statement_expression$1;
}

// killitems
// file libslack/list.c line 337
static void killitems(struct List *list, unsigned long int index, unsigned long int range)
{
  unsigned long int tmp_post$1;
  unsigned long int tmp_post$2;
  do
  {
    tmp_post$1 = range;
    range = range - 1ul;
    if(tmp_post$1 == 0ul)
      break;

    if(!(list->destroy == ((void (*)(void *))NULL)))
      list->destroy(list->list[(signed long int)index]);

    tmp_post$2 = index;
    index = index + 1ul;
    list->list[(signed long int)tmp_post$2] = (void *)0;
  }
  while((_Bool)1);
}

// lc
// file libslack/str.c line 5810
char * lc(char *str)
{
  char *s;
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_tolower_loc$3;
  const signed int **return_value___ctype_tolower_loc$5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    s = str;
    for( ; !(*s == 0); s = s + 1l)
    {
      signed int __res;
      __res=tolower((signed int)(unsigned char)*s);
      tmp_statement_expression$2 = __res;
      *s = (char)tmp_statement_expression$2;
    }
    return str;
  }
}

// lcfirst
// file libslack/str.c line 5885
char * lcfirst(char *str)
{
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_tolower_loc$3;
  const signed int **return_value___ctype_tolower_loc$5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    signed int __res;
    __res=tolower((signed int)(unsigned char)*str);
    tmp_statement_expression$2 = __res;
    *str = (char)tmp_statement_expression$2;
    return str;
  }
}

// limit_arg
// file libslack/lim.c line 238
signed long int limit_arg(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(0);
  return return_value_limit_sysconf$1;
}

// limit_canon
// file libslack/lim.c line 429
signed long int limit_canon(void)
{
  signed long int return_value_limit_pcanon$1;
  return_value_limit_pcanon$1=limit_pcanon("/dev/tty");
  return return_value_limit_pcanon$1;
}

// limit_child
// file libslack/lim.c line 254
signed long int limit_child(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(1);
  return return_value_limit_sysconf$1;
}

// limit_chown
// file libslack/lim.c line 801
signed long int limit_chown(void)
{
  signed long int return_value_limit_pchown$1;
  return_value_limit_pchown$1=limit_pchown("/");
  return return_value_limit_pchown$1;
}

// limit_fcanon
// file libslack/lim.c line 413
signed long int limit_fcanon(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(10, fd);
  return return_value_limit_fpathconf$1;
}

// limit_fchown
// file libslack/lim.c line 785
signed long int limit_fchown(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(18, fd);
  return return_value_limit_fpathconf$1;
}

// limit_finput
// file libslack/lim.c line 461
signed long int limit_finput(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(11, fd);
  return return_value_limit_fpathconf$1;
}

// limit_flink
// file libslack/lim.c line 557
signed long int limit_flink(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(13, fd);
  return return_value_limit_fpathconf$1;
}

// limit_fname
// file libslack/lim.c line 607
signed long int limit_fname(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(14, fd);
  return return_value_limit_fpathconf$1;
}

// limit_fnotrunc
// file libslack/lim.c line 737
signed long int limit_fnotrunc(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(17, fd);
  return return_value_limit_fpathconf$1;
}

// limit_fpath
// file libslack/lim.c line 657
signed long int limit_fpath(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(15, fd);
  return return_value_limit_fpathconf$1;
}

// limit_fpathconf
// file libslack/lim.c line 217
static signed long int limit_fpathconf(signed int limit, signed int fd)
{
  signed long int value;
  value=fpathconf(fd, g$link1.conf[(signed long int)limit].name);
  if(value == -1l)
    return g$link1.conf[(signed long int)limit].value;

  else
    return value + g$link1.conf[(signed long int)limit].offset;
}

// limit_fpipe
// file libslack/lim.c line 705
signed long int limit_fpipe(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(16, fd);
  return return_value_limit_fpathconf$1;
}

// limit_fvdisable
// file libslack/lim.c line 509
signed long int limit_fvdisable(signed int fd)
{
  signed long int return_value_limit_fpathconf$1;
  return_value_limit_fpathconf$1=limit_fpathconf(12, fd);
  return return_value_limit_fpathconf$1;
}

// limit_group
// file libslack/lim.c line 286
signed long int limit_group(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(3);
  return return_value_limit_sysconf$1;
}

// limit_input
// file libslack/lim.c line 477
signed long int limit_input(void)
{
  signed long int return_value_limit_pinput$1;
  return_value_limit_pinput$1=limit_pinput("/dev/tty");
  return return_value_limit_pinput$1;
}

// limit_job
// file libslack/lim.c line 349
signed long int limit_job(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(7);
  return return_value_limit_sysconf$1;
}

// limit_link
// file libslack/lim.c line 573
signed long int limit_link(void)
{
  signed long int return_value_limit_plink$1;
  return_value_limit_plink$1=limit_plink("/");
  return return_value_limit_plink$1;
}

// limit_name
// file libslack/lim.c line 623
signed long int limit_name(void)
{
  signed long int return_value_limit_pname$1;
  return_value_limit_pname$1=limit_pname("/");
  return return_value_limit_pname$1;
}

// limit_notrunc
// file libslack/lim.c line 753
signed long int limit_notrunc(void)
{
  signed long int return_value_limit_pnotrunc$1;
  return_value_limit_pnotrunc$1=limit_pnotrunc("/");
  return return_value_limit_pnotrunc$1;
}

// limit_open
// file libslack/lim.h line 34
signed long int limit_open(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(4);
  return return_value_limit_sysconf$1;
}

// limit_path
// file libslack/lim.h line 57
signed long int limit_path(void)
{
  signed long int return_value_limit_ppath$1;
  return_value_limit_ppath$1=limit_ppath("/");
  return return_value_limit_ppath$1;
}

// limit_pathconf
// file libslack/lim.c line 193
static signed long int limit_pathconf(signed int limit, const char *path)
{
  signed long int value;
  value=pathconf(path, g$link1.conf[(signed long int)limit].name);
  if(value == -1l)
    return g$link1.conf[(signed long int)limit].value;

  else
    return value + g$link1.conf[(signed long int)limit].offset;
}

// limit_pcanon
// file libslack/lim.c line 397
signed long int limit_pcanon(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(10, path);
  return return_value_limit_pathconf$1;
}

// limit_pchown
// file libslack/lim.c line 769
signed long int limit_pchown(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(18, path);
  return return_value_limit_pathconf$1;
}

// limit_pinput
// file libslack/lim.c line 445
signed long int limit_pinput(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(11, path);
  return return_value_limit_pathconf$1;
}

// limit_plink
// file libslack/lim.c line 541
signed long int limit_plink(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(13, path);
  return return_value_limit_pathconf$1;
}

// limit_pname
// file libslack/lim.c line 590
signed long int limit_pname(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(14, path);
  return return_value_limit_pathconf$1;
}

// limit_pnotrunc
// file libslack/lim.c line 721
signed long int limit_pnotrunc(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(17, path);
  return return_value_limit_pathconf$1;
}

// limit_ppath
// file libslack/lim.c line 640
signed long int limit_ppath(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(15, path);
  return return_value_limit_pathconf$1;
}

// limit_ppipe
// file libslack/lim.c line 689
signed long int limit_ppipe(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(16, path);
  return return_value_limit_pathconf$1;
}

// limit_pvdisable
// file libslack/lim.c line 493
signed long int limit_pvdisable(const char *path)
{
  signed long int return_value_limit_pathconf$1;
  return_value_limit_pathconf$1=limit_pathconf(12, path);
  return return_value_limit_pathconf$1;
}

// limit_save_ids
// file libslack/lim.c line 365
signed long int limit_save_ids(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(8);
  return return_value_limit_sysconf$1;
}

// limit_stream
// file libslack/lim.c line 318
signed long int limit_stream(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(5);
  return return_value_limit_sysconf$1;
}

// limit_sysconf
// file libslack/lim.c line 169
static signed long int limit_sysconf(signed int limit)
{
  signed long int value;
  value=sysconf(g$link1.conf[(signed long int)limit].name);
  if(value == -1l)
    return g$link1.conf[(signed long int)limit].value;

  else
    return value;
}

// limit_tick
// file libslack/lim.c line 270
signed long int limit_tick(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(2);
  return return_value_limit_sysconf$1;
}

// limit_tzname
// file libslack/lim.c line 334
signed long int limit_tzname(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(6);
  return return_value_limit_sysconf$1;
}

// limit_vdisable
// file libslack/lim.c line 525
signed long int limit_vdisable(void)
{
  signed long int return_value_limit_pvdisable$1;
  return_value_limit_pvdisable$1=limit_pvdisable("/dev/tty");
  return return_value_limit_pvdisable$1;
}

// limit_version
// file libslack/lim.c line 381
signed long int limit_version(void)
{
  signed long int return_value_limit_sysconf$1;
  return_value_limit_sysconf$1=limit_sysconf(9);
  return return_value_limit_sysconf$1;
}

// list_append
// file libslack/slack/list.h line 81
struct List * list_append(struct List *list, void *item)
{
  struct List *return_value_list_insert$1;
  return_value_list_insert$1=list_insert(list, (signed long int)-1, item);
  return return_value_list_insert$1;
}

// list_append_int
// file libslack/list.c line 1307
struct List * list_append_int(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int$1;
  return_value_list_insert_int$1=list_insert_int(list, (signed long int)-1, item);
  return return_value_list_insert_int$1;
}

// list_append_int_unlocked
// file libslack/list.c line 1322
struct List * list_append_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int_unlocked$1;
  return_value_list_insert_int_unlocked$1=list_insert_int_unlocked(list, (signed long int)-1, item);
  return return_value_list_insert_int_unlocked$1;
}

// list_append_list
// file libslack/list.c line 1339
struct List * list_append_list(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list$1;
  return_value_list_insert_list$1=list_insert_list(list, (signed long int)-1, src, copy);
  return return_value_list_insert_list$1;
}

// list_append_list_unlocked
// file libslack/list.c line 1355
struct List * list_append_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list_unlocked$1;
  return_value_list_insert_list_unlocked$1=list_insert_list_unlocked(list, (signed long int)-1, src, copy);
  return return_value_list_insert_list_unlocked$1;
}

// list_append_unlocked
// file libslack/list.c line 1292
struct List * list_append_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_insert_unlocked$1;
  return_value_list_insert_unlocked$1=list_insert_unlocked(list, (signed long int)-1, item);
  return return_value_list_insert_unlocked$1;
}

// list_apply
// file libslack/list.c line 2245
void list_apply(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  list_apply_wrlocked(list, action, data);
}

// list_apply_rdlocked
// file libslack/list.c line 2262
void list_apply_rdlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value_1;
  if(action == ((void (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
    set_errno(22);

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }

    else
      tmp_if_expr$2 = 22;
    err = tmp_if_expr$2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      list_apply_unlocked(list, action, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$3 = return_value_1;
        }

        else
          tmp_if_expr$3 = 0;
        tmp_if_expr$4 = tmp_if_expr$3;
      }

      else
        tmp_if_expr$4 = 22;
      err = tmp_if_expr$4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// list_apply_unlocked
// file libslack/list.c line 2327
void list_apply_unlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  unsigned long int i;
  if(action == ((void (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
    set_errno(22);

  else
  {
    i = (unsigned long int)0;
    if(!(i >= list->length))
    {
      action(list->list[(signed long int)i], &i, data);
      i = i + 1ul;
    }

  }
}

// list_apply_wrlocked
// file libslack/list.c line 2295
void list_apply_wrlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value_1;
  if(action == ((void (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
    set_errno(22);

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }

    else
      tmp_if_expr$2 = 22;
    err = tmp_if_expr$2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      list_apply_unlocked(list, action, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$3 = return_value_1;
        }

        else
          tmp_if_expr$3 = 0;
        tmp_if_expr$4 = tmp_if_expr$3;
      }

      else
        tmp_if_expr$4 = 22;
      err = tmp_if_expr$4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// list_break
// file libslack/list.c line 2950
void list_break(struct List *list)
{
  if(list == ((struct List *)NULL))
    set_errno(22);

  else
    lister_destroy_unlocked(&list->lister);
}

// list_copy
// file libslack/list.c line 418
struct List * list_copy(const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_copy_with_locker$1;
  return_value_list_copy_with_locker$1=list_copy_with_locker((struct Locker *)(void *)0, src, copy);
  return return_value_list_copy_with_locker$1;
}

// list_copy_with_locker
// file libslack/list.c line 513
struct List * list_copy_with_locker(struct Locker *locker, const struct List *src, void * (*copy)(const void *))
{
  struct List *list;
  void *return_value_set_errnull$1;
  if(src == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    list=list_extract(src, (signed long int)0, (signed long int)src->length, copy);
    if(list == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      list->locker = locker;
      return list;
    }
  }
}

// list_create
// file libslack/slack/list.h line 44
struct List * list_create(void (*destroy)(void *))
{
  struct List *return_value_list_create_with_locker$1;
  return_value_list_create_with_locker$1=list_create_with_locker((struct Locker *)(void *)0, destroy);
  return return_value_list_create_with_locker$1;
}

// list_create_with_locker
// file libslack/list.c line 434
struct List * list_create_with_locker(struct Locker *locker, void (*destroy)(void *))
{
  struct List *list;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct List) /*48ul*/ );
  list = (struct List *)return_value_malloc$1;
  if(list == ((struct List *)NULL))
    return (struct List *)(void *)0;

  else
  {
    list->length = (unsigned long int)0;
    list->size = list->length;
    list->list = (void **)(void *)0;
    list->destroy = destroy;
    list->lister = (struct Lister *)(void *)0;
    list->locker = locker;
    return list;
  }
}

// list_destroy
// file libslack/slack/list.h line 56
void * list_destroy(struct List **list)
{
  if(!(list == ((struct List **)NULL)))
  {
    if(!(*list == ((struct List *)NULL)))
    {
      list_release(*list);
      *list = (struct List *)(void *)0;
    }

  }

  return (void *)0;
}

// list_disown
// file libslack/list.c line 703
void (*list_disown(struct List *list))(void *)
{
  void (*destroy)(void *);
  signed int err;
  void (*return_value_set_errnullf$1)();
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void (*return_value_set_errnullf$2)();
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void (*return_value_set_errnullf$5)();
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnullf$1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnullf$2=set_errnullf(err);
      return (void (*)(void *))return_value_set_errnullf$2;
    }

    else
    {
      destroy=list_disown_unlocked(list);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnullf$5=set_errnullf(err);
        return (void (*)(void *))return_value_set_errnullf$5;
      }

      else
        return destroy;
    }
  }
}

// list_disown_unlocked
// file libslack/list.c line 732
void (*list_disown_unlocked(struct List *list))(void *)
{
  void (*destroy)(void *);
  void (*return_value_set_errnullf$1)();
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnullf$1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf$1;
  }

  else
  {
    destroy = list->destroy;
    list->destroy = (void (*)(void *))(void *)0;
    return destroy;
  }
}

// list_empty
// file libslack/list.c line 846
signed int list_empty(const struct List *list)
{
  signed int empty;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      empty = (signed int)(list->length == (unsigned long int)0);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return empty;
    }
  }
}

// list_empty_unlocked
// file libslack/list.c line 875
signed int list_empty_unlocked(const struct List *list)
{
  signed int return_value_set_errno$1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    return (signed int)(list->length == (unsigned long int)0);
}

// list_extract
// file libslack/list.c line 1669
struct List * list_extract(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_extract_with_locker$1;
  return_value_list_extract_with_locker$1=list_extract_with_locker((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_extract_with_locker$1;
}

// list_extract_unlocked
// file libslack/list.c line 1684
struct List * list_extract_unlocked(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_extract_with_locker_unlocked$1;
  return_value_list_extract_with_locker_unlocked$1=list_extract_with_locker_unlocked((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_extract_with_locker_unlocked$1;
}

// list_extract_with_locker
// file libslack/list.c line 1700
struct List * list_extract_with_locker(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_extract_with_locker_unlocked(locker, list, index, range, copy);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// list_extract_with_locker_unlocked
// file libslack/list.c line 1730
struct List * list_extract_with_locker_unlocked(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  _Bool tmp_if_expr$5;
  void *return_value_set_errnull$4;
  void (*tmp_if_expr$6)(void *);
  signed long int tmp_post$7;
  void *tmp_if_expr$10;
  signed long int tmp_post$8;
  void *return_value;
  signed long int tmp_post$9;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct List *)return_value_set_errnull$3;
      }

      else
      {
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = ((signed int)!(list->destroy != ((void (*)(void *))NULL)) ^ (signed int)!(copy != ((void * (*)(const void *))NULL))) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          return_value_set_errnull$4=set_errnull(22);
          return (struct List *)return_value_set_errnull$4;
        }

        else
        {
          if(!(copy == ((void * (*)(const void *))NULL)))
            tmp_if_expr$6 = list->destroy;

          else
            tmp_if_expr$6 = (void (*)(void *))(void *)0;
          ret=list_create_with_locker(locker, tmp_if_expr$6);
          if(ret == ((struct List *)NULL))
            return (struct List *)(void *)0;

          else
          {
            do
            {
              tmp_post$7 = range;
              range = range - 1l;
              if(tmp_post$7 == 0l)
                break;

              if(!(copy == ((void * (*)(const void *))NULL)))
              {
                tmp_post$8 = index;
                index = index + 1l;
                return_value=copy(list->list[tmp_post$8]);
                tmp_if_expr$10 = return_value;
              }

              else
              {
                tmp_post$9 = index;
                index = index + 1l;
                tmp_if_expr$10 = list->list[tmp_post$9];
              }
              struct List *return_value_list_append$11;
              return_value_list_append$11=list_append(ret, tmp_if_expr$10);
              if(return_value_list_append$11 == ((struct List *)NULL))
              {
                list_release(ret);
                return (struct List *)(void *)0;
              }

            }
            while((_Bool)1);
            return ret;
          }
        }
      }
    }
  }
}

// list_grep
// file libslack/list.c line 2461
struct List * list_grep(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_grep_with_locker$1;
  return_value_list_grep_with_locker$1=list_grep_with_locker((struct Locker *)(void *)0, list, grep, data);
  return return_value_list_grep_with_locker$1;
}

// list_grep_unlocked
// file libslack/list.c line 2476
struct List * list_grep_unlocked(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_grep_with_locker_unlocked$1;
  return_value_list_grep_with_locker_unlocked$1=list_grep_with_locker_unlocked((struct Locker *)(void *)0, list, grep, data);
  return return_value_list_grep_with_locker_unlocked$1;
}

// list_grep_with_locker
// file libslack/list.c line 2492
struct List * list_grep_with_locker(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *grepping;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      grepping=list_grep_with_locker_unlocked(locker, list, grep, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(grepping);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return grepping;
    }
  }
}

// list_grep_with_locker_unlocked
// file libslack/list.c line 2525
struct List * list_grep_with_locker_unlocked(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *grepping;
  unsigned long int i;
  void *return_value_set_errnull$1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    grepping=list_create((void (*)(void *))(void *)0);
    if(grepping == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      if(!(i >= list->length))
      {
        signed int return_value;
        return_value=grep(list->list[(signed long int)i], &i, data);
        if(!(return_value == 0))
        {
          struct List *return_value_list_append$2;
          return_value_list_append$2=list_append(grepping, list->list[(signed long int)i]);
          if(return_value_list_append$2 == ((struct List *)NULL))
          {
            list_release(grepping);
            return (struct List *)(void *)0;
          }

        }

        i = i + 1ul;
      }

      return grepping;
    }
  }
}

// list_has_next
// file libslack/list.c line 2922
signed int list_has_next(struct List *list)
{
  signed int has;
  signed int return_value_set_errno$1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if(list->lister == ((struct Lister *)NULL))
    {
      list->lister=lister_create_unlocked(list);
      if(!(list->lister == ((struct Lister *)NULL)))
        goto __CPROVER_DUMP_L2;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      has=lister_has_next(list->lister);
      if(!(has == 1))
        list_break(list);

      return has;
    }
}

// list_insert
// file libslack/list.c line 1099
struct List * list_insert(struct List *list, signed long int index, void *item)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_insert_unlocked(list, index, item);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// list_insert_int
// file libslack/list.c line 1160
struct List * list_insert_int(struct List *list, signed long int index, signed int item)
{
  struct List *return_value_list_insert$1;
  return_value_list_insert$1=list_insert(list, index, (void *)(signed long int)item);
  return return_value_list_insert$1;
}

// list_insert_int_unlocked
// file libslack/list.c line 1175
struct List * list_insert_int_unlocked(struct List *list, signed long int index, signed int item)
{
  struct List *return_value_list_insert_unlocked$1;
  return_value_list_insert_unlocked$1=list_insert_unlocked(list, index, (void *)(signed long int)item);
  return return_value_list_insert_unlocked$1;
}

// list_insert_list
// file libslack/list.c line 1195
struct List * list_insert_list(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int tmp_if_expr$10;
  signed int tmp_if_expr$9;
  signed int return_value_2;
  signed int tmp_if_expr$13;
  signed int tmp_if_expr$12;
  signed int return_value_3;
  void *return_value_set_errnull$11;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_1=src->locker->rdlock(src->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      ret=list_insert_list_unlocked(list, index, src, copy);
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_2=src->locker->unlock(src->locker->lock);
          tmp_if_expr$9 = return_value_2;
        }

        else
          tmp_if_expr$9 = 0;
        tmp_if_expr$10 = tmp_if_expr$9;
      }

      else
        tmp_if_expr$10 = 22;
      err = tmp_if_expr$10;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$8;
        return_value_set_errnull$8=set_errnull(err);
        return (struct List *)return_value_set_errnull$8;
      }

      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_3=list->locker->unlock(list->locker->lock);
          tmp_if_expr$12 = return_value_3;
        }

        else
          tmp_if_expr$12 = 0;
        tmp_if_expr$13 = tmp_if_expr$12;
      }

      else
        tmp_if_expr$13 = 22;
      err = tmp_if_expr$13;
      if(!(err == 0))
      {
        return_value_set_errnull$11=set_errnull(err);
        return (struct List *)return_value_set_errnull$11;
      }

      else
        return ret;
    }
  }
}

// list_insert_list_unlocked
// file libslack/list.c line 1241
struct List * list_insert_list_unlocked(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *))
{
  unsigned long int i;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  _Bool tmp_if_expr$4;
  void *return_value_set_errnull$3;
  void *tmp_if_expr$6;
  void *return_value;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      if(!(list->length >= (unsigned long int)index))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = ((signed int)!(list->destroy != ((void (*)(void *))NULL)) ^ (signed int)!(copy != ((void * (*)(const void *))NULL))) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct List *)return_value_set_errnull$3;
      }

      else
      {
        signed int return_value_expand$5;
        return_value_expand$5=expand(list, index, src->length);
        if(return_value_expand$5 == -1)
          return (struct List *)(void *)0;

        else
        {
          i = (unsigned long int)0;
          for( ; !(i >= src->length); i = i + 1ul)
          {
            if(!(copy == ((void * (*)(const void *))NULL)))
            {
              return_value=copy(src->list[(signed long int)i]);
              tmp_if_expr$6 = return_value;
            }

            else
              tmp_if_expr$6 = src->list[(signed long int)i];
            list->list[(signed long int)((unsigned long int)index + i)] = tmp_if_expr$6;
          }
          return list;
        }
      }
    }
  }
}

// list_insert_unlocked
// file libslack/list.c line 1128
struct List * list_insert_unlocked(struct List *list, signed long int index, void *item)
{
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct List *)return_value_set_errnull$2;
    }

    else
      if(!(list->length >= (unsigned long int)index))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct List *)return_value_set_errnull$3;
      }

      else
      {
        signed int return_value_expand$4;
        return_value_expand$4=expand(list, index, (unsigned long int)1);
        if(return_value_expand$4 == -1)
          return (struct List *)(void *)0;

        else
        {
          list->list[index] = item;
          return list;
        }
      }
  }
}

// list_item
// file libslack/slack/list.h line 61
void * list_item(const struct List *list, signed long int index)
{
  void *item;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return return_value_set_errnull$2;
    }

    else
    {
      item=list_item_unlocked(list, index);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return return_value_set_errnull$5;
      }

      else
        return item;
    }
  }
}

// list_item_int
// file libslack/list.c line 815
signed int list_item_int(const struct List *list, signed long int index)
{
  void *return_value_list_item$1;
  return_value_list_item$1=list_item(list, index);
  return (signed int)(signed long int)return_value_list_item$1;
}

// list_item_int_unlocked
// file libslack/list.c line 830
signed int list_item_int_unlocked(const struct List *list, signed long int index)
{
  void *return_value_list_item_unlocked$1;
  return_value_list_item_unlocked$1=list_item_unlocked(list, index);
  return (signed int)(signed long int)return_value_list_item_unlocked$1;
}

// list_item_unlocked
// file libslack/list.c line 787
void * list_item_unlocked(const struct List *list, signed long int index)
{
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return return_value_set_errnull$2;
    }

    else
      if((unsigned long int)index >= list->length)
      {
        return_value_set_errnull$3=set_errnull(22);
        return return_value_set_errnull$3;
      }

      else
        return list->list[index];
  }
}

// list_last
// file libslack/list.c line 942
signed long int list_last(const struct List *list)
{
  signed long int last;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      last = (signed long int)(list->length - (unsigned long int)1);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return (signed long int)return_value_set_errno$5;
      }

      else
        return last;
    }
  }
}

// list_last_unlocked
// file libslack/list.c line 971
signed long int list_last_unlocked(const struct List *list)
{
  signed int return_value_set_errno$1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
    return (signed long int)(list->length - (unsigned long int)1);
}

// list_length
// file libslack/slack/list.h line 67
signed long int list_length(const struct List *list)
{
  unsigned long int length;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      length = list->length;
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return (signed long int)return_value_set_errno$5;
      }

      else
        return (signed long int)length;
    }
  }
}

// list_length_unlocked
// file libslack/list.c line 923
signed long int list_length_unlocked(const struct List *list)
{
  signed int return_value_set_errno$1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
    return (signed long int)list->length;
}

// list_make
// file libslack/list.c line 379
struct List * list_make(void (*destroy)(void *), ...)
{
  struct List *list;
  void **args = (void **)&destroy;
  list=list_vmake_with_locker((struct Locker *)(void *)0, destroy, args);
  args = ((void **)NULL);
  return list;
}

// list_make_with_locker
// file libslack/list.c line 461
struct List * list_make_with_locker(struct Locker *locker, void (*destroy)(void *), ...)
{
  struct List *list;
  void **args = (void **)&destroy;
  list=list_vmake_with_locker(locker, destroy, args);
  args = ((void **)NULL);
  return list;
}

// list_map
// file libslack/list.c line 2357
struct List * list_map(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_map_with_locker$1;
  return_value_list_map_with_locker$1=list_map_with_locker((struct Locker *)(void *)0, list, destroy, map, data);
  return return_value_list_map_with_locker$1;
}

// list_map_unlocked
// file libslack/list.c line 2372
struct List * list_map_unlocked(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_map_with_locker_unlocked$1;
  return_value_list_map_with_locker_unlocked$1=list_map_with_locker_unlocked((struct Locker *)(void *)0, list, destroy, map, data);
  return return_value_list_map_with_locker_unlocked$1;
}

// list_map_with_locker
// file libslack/list.c line 2388
struct List * list_map_with_locker(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *mapping;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(map == ((void * (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      mapping=list_map_with_locker_unlocked(locker, list, destroy, map, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(mapping);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return mapping;
    }
  }
}

// list_map_with_locker_unlocked
// file libslack/list.c line 2421
struct List * list_map_with_locker_unlocked(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *mapping;
  unsigned long int i;
  void *return_value_set_errnull$1;
  if(map == ((void * (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    mapping=list_create_with_locker(locker, destroy);
    if(mapping == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      if(!(i >= list->length))
      {
        void *return_value;
        return_value=map(list->list[(signed long int)i], &i, data);
        struct List *return_value_list_append$2;
        return_value_list_append$2=list_append(mapping, return_value);
        if(return_value_list_append$2 == ((struct List *)NULL))
        {
          list_release(mapping);
          return (struct List *)(void *)0;
        }

        i = i + 1ul;
      }

      return mapping;
    }
  }
}

// list_next
// file libslack/list.c line 2972
void * list_next(struct List *list)
{
  _Bool tmp_if_expr$2;
  if(list == ((struct List *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(list->lister != ((struct Lister *)NULL)) ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    void *return_value_lister_next$3;
    return_value_lister_next$3=lister_next(list->lister);
    return return_value_lister_next$3;
  }
}

// list_next_int
// file libslack/list.c line 2990
signed int list_next_int(struct List *list)
{
  _Bool tmp_if_expr$2;
  if(list == ((struct List *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(list->lister != ((struct Lister *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_lister_next_int$3;
    return_value_lister_next_int$3=lister_next_int(list->lister);
    return return_value_lister_next_int$3;
  }
}

// list_own
// file libslack/list.c line 652
signed int list_own(struct List *list, void (*destroy)(void *))
{
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(destroy == ((void (*)(void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      list->destroy = destroy;
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return 0;
    }
  }
}

// list_own_unlocked
// file libslack/list.c line 680
signed int list_own_unlocked(struct List *list, void (*destroy)(void *))
{
  signed int return_value_set_errno$1;
  if(destroy == ((void (*)(void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    list->destroy = destroy;
    return 0;
  }
}

// list_pop
// file libslack/list.c line 1841
void * list_pop(struct List *list)
{
  void *item;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return return_value_set_errnull$2;
    }

    else
    {
      item=list_pop_unlocked(list);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return return_value_set_errnull$5;
      }

      else
        return item;
    }
  }
}

// list_pop_int
// file libslack/list.c line 1903
signed int list_pop_int(struct List *list)
{
  void *return_value_list_pop$1;
  return_value_list_pop$1=list_pop(list);
  return (signed int)(signed long int)return_value_list_pop$1;
}

// list_pop_int_unlocked
// file libslack/list.c line 1918
signed int list_pop_int_unlocked(struct List *list)
{
  void *return_value_list_pop_unlocked$1;
  return_value_list_pop_unlocked$1=list_pop_unlocked(list);
  return (signed int)(signed long int)return_value_list_pop_unlocked$1;
}

// list_pop_unlocked
// file libslack/list.c line 1870
void * list_pop_unlocked(struct List *list)
{
  void *item;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    if(list->length == 0ul)
    {
      return_value_set_errnull$2=set_errnull(22);
      return return_value_set_errnull$2;
    }

    else
    {
      item = list->list[(signed long int)(list->length - (unsigned long int)1)];
      list->list[(signed long int)(list->length - (unsigned long int)1)] = (void *)0;
      struct List *return_value_list_remove_unlocked$3;
      return_value_list_remove_unlocked$3=list_remove_unlocked(list, (signed long int)(list->length - (unsigned long int)1));
      if(return_value_list_remove_unlocked$3 == ((struct List *)NULL))
      {
        list->list[(signed long int)(list->length - (unsigned long int)1)] = item;
        return (void *)0;
      }

      else
        return item;
    }
}

// list_prepend
// file libslack/list.c line 1371
struct List * list_prepend(struct List *list, void *item)
{
  struct List *return_value_list_insert$1;
  return_value_list_insert$1=list_insert(list, (signed long int)0, item);
  return return_value_list_insert$1;
}

// list_prepend_int
// file libslack/list.c line 1401
struct List * list_prepend_int(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int$1;
  return_value_list_insert_int$1=list_insert_int(list, (signed long int)0, item);
  return return_value_list_insert_int$1;
}

// list_prepend_int_unlocked
// file libslack/list.c line 1417
struct List * list_prepend_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int_unlocked$1;
  return_value_list_insert_int_unlocked$1=list_insert_int_unlocked(list, (signed long int)0, item);
  return return_value_list_insert_int_unlocked$1;
}

// list_prepend_list
// file libslack/list.c line 1434
struct List * list_prepend_list(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list$1;
  return_value_list_insert_list$1=list_insert_list(list, (signed long int)0, src, copy);
  return return_value_list_insert_list$1;
}

// list_prepend_list_unlocked
// file libslack/list.c line 1450
struct List * list_prepend_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list_unlocked$1;
  return_value_list_insert_list_unlocked$1=list_insert_list_unlocked(list, (signed long int)0, src, copy);
  return return_value_list_insert_list_unlocked$1;
}

// list_prepend_unlocked
// file libslack/list.c line 1386
struct List * list_prepend_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_insert_unlocked$1;
  return_value_list_insert_unlocked$1=list_insert_unlocked(list, (signed long int)0, item);
  return return_value_list_insert_unlocked$1;
}

// list_push
// file libslack/list.c line 1780
struct List * list_push(struct List *list, void *item)
{
  struct List *return_value_list_append$1;
  return_value_list_append$1=list_append(list, item);
  return return_value_list_append$1;
}

// list_push_int
// file libslack/list.c line 1810
struct List * list_push_int(struct List *list, signed int item)
{
  struct List *return_value_list_append_int$1;
  return_value_list_append_int$1=list_append_int(list, item);
  return return_value_list_append_int$1;
}

// list_push_int_unlocked
// file libslack/list.c line 1825
struct List * list_push_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_append_int_unlocked$1;
  return_value_list_append_int_unlocked$1=list_append_int_unlocked(list, item);
  return return_value_list_append_int_unlocked$1;
}

// list_push_unlocked
// file libslack/list.c line 1795
struct List * list_push_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_append_unlocked$1;
  return_value_list_append_unlocked$1=list_append_unlocked(list, item);
  return return_value_list_append_unlocked$1;
}

// list_query
// file libslack/list.c line 2566
signed long int list_query(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data)
{
  signed long int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(query == ((signed int (*)(void *, unsigned long int *, void *))NULL) || index == ((signed long int *)NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      ret=list_query_unlocked(list, index, query, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return (signed long int)return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// list_query_unlocked
// file libslack/list.c line 2595
signed long int list_query_unlocked(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data)
{
  unsigned long int i;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  if(query == ((signed int (*)(void *, unsigned long int *, void *))NULL) || index == ((signed long int *)NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
    if((unsigned long int)*index >= list->length)
    {
      return_value_set_errno$2=set_errno(22);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      i = (unsigned long int)*index;
      if(!(i >= list->length))
      {
        signed int return_value;
        return_value=query(list->list[(signed long int)i], (unsigned long int *)index, data);
        if(!(return_value == 0))
        {
          *index = (signed long int)i;
          return *index;
        }

        i = i + 1ul;
      }

      *index = (signed long int)-1;
      return *index;
    }
}

// list_rdlock
// file libslack/list.c line 548
signed int list_rdlock(const struct List *list)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(list == ((const struct List *)NULL)))
  {
    if(!(list->locker == ((struct Locker *)NULL)))
    {
      return_value=list->locker->rdlock(list->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// list_release
// file libslack/list.c line 602
void list_release(struct List *list)
{
  if(!(list == ((struct List *)NULL)))
  {
    if(!(list->list == ((void **)NULL)))
    {
      killitems(list, (unsigned long int)0, list->length);
      free((void *)list->list);
    }

    free((void *)list);
  }

}

// list_remove
// file libslack/list.c line 993
struct List * list_remove(struct List *list, signed long int index)
{
  struct List *return_value_list_remove_range$1;
  return_value_list_remove_range$1=list_remove_range(list, index, (signed long int)1);
  return return_value_list_remove_range$1;
}

// list_remove_current
// file libslack/list.c line 3010
void list_remove_current(struct List *list)
{
  _Bool tmp_if_expr$1;
  if(list == ((struct List *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(list->lister != ((struct Lister *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    set_errno(22);

  else
    lister_remove(list->lister);
}

// list_remove_range
// file libslack/list.c line 1027
struct List * list_remove_range(struct List *list, signed long int index, signed long int range)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_remove_range_unlocked(list, index, range);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// list_remove_range_unlocked
// file libslack/list.c line 1057
struct List * list_remove_range_unlocked(struct List *list, signed long int index, signed long int range)
{
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  void *return_value_set_errnull$4;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct List *)return_value_set_errnull$3;
      }

      else
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull$4=set_errnull(22);
          return (struct List *)return_value_set_errnull$4;
        }

        else
        {
          killitems(list, (unsigned long int)index, (unsigned long int)range);
          signed int return_value_contract$5;
          return_value_contract$5=contract(list, index, (unsigned long int)range);
          if(return_value_contract$5 == -1)
            return (struct List *)(void *)0;

          else
            return list;
        }
    }
  }
}

// list_remove_unlocked
// file libslack/list.c line 1008
struct List * list_remove_unlocked(struct List *list, signed long int index)
{
  struct List *return_value_list_remove_range_unlocked$1;
  return_value_list_remove_range_unlocked$1=list_remove_range_unlocked(list, index, (signed long int)1);
  return return_value_list_remove_range_unlocked$1;
}

// list_replace
// file libslack/list.c line 1469
struct List * list_replace(struct List *list, signed long int index, signed long int range, void *item)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_replace_unlocked(list, index, range, item);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// list_replace_int
// file libslack/list.c line 1538
struct List * list_replace_int(struct List *list, signed long int index, signed long int range, signed int item)
{
  struct List *return_value_list_replace$1;
  return_value_list_replace$1=list_replace(list, index, range, (void *)(signed long int)item);
  return return_value_list_replace$1;
}

// list_replace_int_unlocked
// file libslack/list.c line 1553
struct List * list_replace_int_unlocked(struct List *list, signed long int index, signed long int range, signed int item)
{
  struct List *return_value_list_replace_unlocked$1;
  return_value_list_replace_unlocked$1=list_replace_unlocked(list, index, range, (void *)(signed long int)item);
  return return_value_list_replace_unlocked$1;
}

// list_replace_list
// file libslack/list.c line 1573
struct List * list_replace_list(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int tmp_if_expr$10;
  signed int tmp_if_expr$9;
  signed int return_value_2;
  signed int tmp_if_expr$13;
  signed int tmp_if_expr$12;
  signed int return_value_3;
  void *return_value_set_errnull$11;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_1=src->locker->rdlock(src->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      ret=list_replace_list_unlocked(list, index, range, src, copy);
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_2=src->locker->unlock(src->locker->lock);
          tmp_if_expr$9 = return_value_2;
        }

        else
          tmp_if_expr$9 = 0;
        tmp_if_expr$10 = tmp_if_expr$9;
      }

      else
        tmp_if_expr$10 = 22;
      err = tmp_if_expr$10;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$8;
        return_value_set_errnull$8=set_errnull(err);
        return (struct List *)return_value_set_errnull$8;
      }

      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_3=list->locker->unlock(list->locker->lock);
          tmp_if_expr$12 = return_value_3;
        }

        else
          tmp_if_expr$12 = 0;
        tmp_if_expr$13 = tmp_if_expr$12;
      }

      else
        tmp_if_expr$13 = 22;
      err = tmp_if_expr$13;
      if(!(err == 0))
      {
        return_value_set_errnull$11=set_errnull(err);
        return (struct List *)return_value_set_errnull$11;
      }

      else
        return ret;
    }
  }
}

// list_replace_list_unlocked
// file libslack/list.c line 1617
struct List * list_replace_list_unlocked(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *))
{
  signed long int length;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  _Bool tmp_if_expr$5;
  void *return_value_set_errnull$4;
  signed long int tmp_post$7;
  void *tmp_if_expr$8;
  void *return_value;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct List *)return_value_set_errnull$3;
      }

      else
      {
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = ((signed int)!(list->destroy != ((void (*)(void *))NULL)) ^ (signed int)!(copy != ((void * (*)(const void *))NULL))) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          return_value_set_errnull$4=set_errnull(22);
          return (struct List *)return_value_set_errnull$4;
        }

        else
        {
          killitems(list, (unsigned long int)index, (unsigned long int)range);
          length = (signed long int)src->length;
          signed int return_value_adjust$6;
          return_value_adjust$6=adjust(list, index, (unsigned long int)range, (unsigned long int)length);
          if(return_value_adjust$6 == -1)
            return (struct List *)(void *)0;

          else
          {
            do
            {
              tmp_post$7 = length;
              length = length - 1l;
              if(tmp_post$7 == 0l)
                break;

              if(!(copy == ((void * (*)(const void *))NULL)))
              {
                return_value=copy(src->list[length]);
                tmp_if_expr$8 = return_value;
              }

              else
                tmp_if_expr$8 = src->list[length];
              list->list[index + length] = tmp_if_expr$8;
            }
            while((_Bool)1);
            return list;
          }
        }
      }
    }
  }
}

// list_replace_unlocked
// file libslack/list.c line 1498
struct List * list_replace_unlocked(struct List *list, signed long int index, signed long int range, void *item)
{
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  void *return_value_set_errnull$4;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct List *)return_value_set_errnull$3;
      }

      else
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull$4=set_errnull(22);
          return (struct List *)return_value_set_errnull$4;
        }

        else
        {
          killitems(list, (unsigned long int)index, (unsigned long int)range);
          signed int return_value_adjust$5;
          return_value_adjust$5=adjust(list, index, (unsigned long int)range, (unsigned long int)1);
          if(return_value_adjust$5 == -1)
            return (struct List *)(void *)0;

          else
          {
            list->list[index] = item;
            return list;
          }
        }
    }
  }
}

// list_shift
// file libslack/list.c line 1934
void * list_shift(struct List *list)
{
  void *item;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return return_value_set_errnull$2;
    }

    else
    {
      item=list_shift_unlocked(list);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return return_value_set_errnull$5;
      }

      else
        return item;
    }
  }
}

// list_shift_int
// file libslack/list.c line 1996
signed int list_shift_int(struct List *list)
{
  void *return_value_list_shift$1;
  return_value_list_shift$1=list_shift(list);
  return (signed int)(signed long int)return_value_list_shift$1;
}

// list_shift_int_unlocked
// file libslack/list.c line 2011
signed int list_shift_int_unlocked(struct List *list)
{
  void *return_value_list_shift_unlocked$1;
  return_value_list_shift_unlocked$1=list_shift_unlocked(list);
  return (signed int)(signed long int)return_value_list_shift_unlocked$1;
}

// list_shift_unlocked
// file libslack/list.c line 1963
void * list_shift_unlocked(struct List *list)
{
  void *item;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    if(list->length == 0ul)
    {
      return_value_set_errnull$2=set_errnull(22);
      return return_value_set_errnull$2;
    }

    else
    {
      item = list->list[(signed long int)0];
      list->list[(signed long int)0] = (void *)0;
      struct List *return_value_list_remove_unlocked$3;
      return_value_list_remove_unlocked$3=list_remove_unlocked(list, (signed long int)0);
      if(return_value_list_remove_unlocked$3 == ((struct List *)NULL))
      {
        list->list[(signed long int)0] = item;
        return (void *)0;
      }

      else
        return item;
    }
}

// list_sort
// file libslack/slack/list.h line 123
struct List * list_sort(struct List *list, signed int (*cmp)(const void *, const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_sort_unlocked(list, cmp);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// list_sort_unlocked
// file libslack/list.c line 2220
struct List * list_sort_unlocked(struct List *list, signed int (*cmp)(const void *, const void *))
{
  void *return_value_set_errnull$1;
  _Bool tmp_if_expr$3;
  void *return_value_set_errnull$2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(list->list == ((void **)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(list->length != 0ul) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      (list->length >= (unsigned long int)10000 ? hsort : qsort)((void *)list->list, list->length, sizeof(void *) /*8ul*/ , cmp);
      return list;
    }
  }
}

// list_splice
// file libslack/list.c line 2095
struct List * list_splice(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_splice_with_locker$1;
  return_value_list_splice_with_locker$1=list_splice_with_locker((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_splice_with_locker$1;
}

// list_splice_unlocked
// file libslack/list.c line 2110
struct List * list_splice_unlocked(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_splice_with_locker_unlocked$1;
  return_value_list_splice_with_locker_unlocked$1=list_splice_with_locker_unlocked((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_splice_with_locker_unlocked$1;
}

// list_splice_with_locker
// file libslack/list.c line 2126
struct List * list_splice_with_locker(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_splice_with_locker_unlocked(locker, list, index, range, copy);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// list_splice_with_locker_unlocked
// file libslack/list.c line 2159
struct List * list_splice_with_locker_unlocked(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  void *return_value_set_errnull$1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    ret=list_extract_with_locker_unlocked(locker, list, index, range, copy);
    if(ret == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      struct List *return_value_list_remove_range_unlocked$2;
      return_value_list_remove_range_unlocked$2=list_remove_range_unlocked(list, index, range);
      if(return_value_list_remove_range_unlocked$2 == ((struct List *)NULL))
      {
        list_release(ret);
        return (struct List *)(void *)0;
      }

      else
        return ret;
    }
  }
}

// list_unlock
// file libslack/list.c line 586
signed int list_unlock(const struct List *list)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(list == ((const struct List *)NULL)))
  {
    if(!(list->locker == ((struct Locker *)NULL)))
    {
      return_value=list->locker->unlock(list->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// list_unshift
// file libslack/list.c line 2027
struct List * list_unshift(struct List *list, void *item)
{
  struct List *return_value_list_prepend$1;
  return_value_list_prepend$1=list_prepend(list, item);
  return return_value_list_prepend$1;
}

// list_unshift_int
// file libslack/list.c line 2057
struct List * list_unshift_int(struct List *list, signed int item)
{
  struct List *return_value_list_prepend_int$1;
  return_value_list_prepend_int$1=list_prepend_int(list, item);
  return return_value_list_prepend_int$1;
}

// list_unshift_int_unlocked
// file libslack/list.c line 2073
struct List * list_unshift_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_prepend_int_unlocked$1;
  return_value_list_prepend_int_unlocked$1=list_prepend_int_unlocked(list, item);
  return return_value_list_prepend_int_unlocked$1;
}

// list_unshift_unlocked
// file libslack/list.c line 2042
struct List * list_unshift_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_prepend_unlocked$1;
  return_value_list_prepend_unlocked$1=list_prepend_unlocked(list, item);
  return return_value_list_prepend_unlocked$1;
}

// list_vmake
// file libslack/list.c line 400
struct List * list_vmake(void (*destroy)(void *), void **args)
{
  struct List *return_value_list_vmake_with_locker$1;
  return_value_list_vmake_with_locker$1=list_vmake_with_locker((struct Locker *)(void *)0, destroy, args);
  return return_value_list_vmake_with_locker$1;
}

// list_vmake_with_locker
// file libslack/list.c line 482
struct List * list_vmake_with_locker(struct Locker *locker, void (*destroy)(void *), __builtin_va_list args)
{
  struct List *list;
  void *item;
  list=list_create_with_locker(locker, destroy);
  if(list == ((struct List *)NULL))
    return (struct List *)(void *)0;

  else
  {
    do
    {
      item=va_arg(args, __typeof__(item));
      if(item == NULL)
        break;

      struct List *return_value_list_append$1;
      return_value_list_append$1=list_append(list, item);
      if(return_value_list_append$1 == ((struct List *)NULL))
      {
        list_release(list);
        return (struct List *)(void *)0;
      }

    }
    while((_Bool)1);
    return list;
  }
}

// list_wrlock
// file libslack/list.c line 569
signed int list_wrlock(const struct List *list)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(list == ((const struct List *)NULL)))
  {
    if(!(list->locker == ((struct Locker *)NULL)))
    {
      return_value=list->locker->wrlock(list->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// lister_create
// file libslack/list.c line 2629
struct Lister * lister_create(struct List *list)
{
  struct Lister *return_value_lister_create_wrlocked$1;
  return_value_lister_create_wrlocked$1=lister_create_wrlocked(list);
  return return_value_lister_create_wrlocked$1;
}

// lister_create_rdlocked
// file libslack/list.c line 2646
struct Lister * lister_create_rdlocked(struct List *list)
{
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Lister *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct Lister *)return_value_set_errnull$2;
    }

    else
    {
      struct Lister *return_value_lister_create_unlocked$5;
      return_value_lister_create_unlocked$5=lister_create_unlocked(list);
      return return_value_lister_create_unlocked$5;
    }
  }
}

// lister_create_unlocked
// file libslack/list.c line 2693
struct Lister * lister_create_unlocked(const struct List *list)
{
  struct Lister *lister;
  void *return_value_set_errnull$1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Lister *)return_value_set_errnull$1;
  }

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct Lister) /*16ul*/ );
    lister = (struct Lister *)return_value_malloc$2;
    if(lister == ((struct Lister *)NULL))
      return (struct Lister *)(void *)0;

    else
    {
      lister->list = (struct List *)list;
      lister->index = (signed long int)-1;
      return lister;
    }
  }
}

// lister_create_wrlocked
// file libslack/list.c line 2670
struct Lister * lister_create_wrlocked(struct List *list)
{
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Lister *)return_value_set_errnull$1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct Lister *)return_value_set_errnull$2;
    }

    else
    {
      struct Lister *return_value_lister_create_unlocked$5;
      return_value_lister_create_unlocked$5=lister_create_unlocked(list);
      return return_value_lister_create_unlocked$5;
    }
  }
}

// lister_destroy
// file libslack/list.c line 2765
void * lister_destroy(struct Lister **lister)
{
  if(!(lister == ((struct Lister **)NULL)))
  {
    if(!(*lister == ((struct Lister *)NULL)))
    {
      lister_release(*lister);
      *lister = (struct Lister *)(void *)0;
    }

  }

  return (void *)0;
}

// lister_destroy_unlocked
// file libslack/list.c line 2787
void * lister_destroy_unlocked(struct Lister **lister)
{
  if(!(lister == ((struct Lister **)NULL)))
  {
    if(!(*lister == ((struct Lister *)NULL)))
    {
      lister_release_unlocked(*lister);
      *lister = (struct Lister *)(void *)0;
    }

  }

  return (void *)0;
}

// lister_has_next
// file libslack/list.c line 2810
signed int lister_has_next(struct Lister *lister)
{
  signed int return_value_set_errno$1;
  if(lister == ((struct Lister *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    return (signed int)((unsigned long int)(lister->index + (signed long int)1) < lister->list->length);
}

// lister_next
// file libslack/list.c line 2829
void * lister_next(struct Lister *lister)
{
  void *return_value_set_errnull$1;
  if(lister == ((struct Lister *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    lister->index = lister->index + 1l;
    void *return_value_list_item_unlocked$2;
    return_value_list_item_unlocked$2=list_item_unlocked(lister->list, (signed long int)(unsigned long int)lister->index);
    return return_value_list_item_unlocked$2;
  }
}

// lister_next_int
// file libslack/list.c line 2847
signed int lister_next_int(struct Lister *lister)
{
  signed int return_value_set_errno$1;
  if(lister == ((struct Lister *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    lister->index = lister->index + 1l;
    signed int return_value_list_item_int_unlocked$2;
    return_value_list_item_int_unlocked$2=list_item_int_unlocked(lister->list, (signed long int)(unsigned long int)lister->index);
    return return_value_list_item_int_unlocked$2;
  }
}

// lister_release
// file libslack/list.c line 2719
void lister_release(struct Lister *lister)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(lister == ((struct Lister *)NULL)))
  {
    if(!(lister->list == ((struct List *)NULL)))
    {
      if(!(lister->list->locker == ((struct Locker *)NULL)))
      {
        return_value=lister->list->locker->unlock(lister->list->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }

    else
      tmp_if_expr$2 = 22;
    err = tmp_if_expr$2;
    if(!(err == 0))
      set_errno(err);

    else
      free((void *)lister);
  }

}

// lister_release_unlocked
// file libslack/list.c line 2746
void lister_release_unlocked(struct Lister *lister)
{
  if(!(lister == ((struct Lister *)NULL)))
    free((void *)lister);

}

// lister_remove
// file libslack/list.c line 2868
void lister_remove(struct Lister *lister)
{
  signed long int tmp_post$1;
  if(lister == ((struct Lister *)NULL))
    set_errno(22);

  else
    if(lister->index == -1l)
      set_errno(22);

    else
    {
      tmp_post$1 = lister->index;
      lister->index = lister->index - 1l;
      list_remove_unlocked(lister->list, (signed long int)(unsigned long int)tmp_post$1);
    }
}

// locker_create
// file libslack/locker.c line 359
struct Locker * locker_create(void *lock, signed int (*tryrdlock)(void *), signed int (*rdlock)(void *), signed int (*trywrlock)(void *), signed int (*wrlock)(void *), signed int (*unlock)(void *))
{
  struct Locker *locker_create$$1$$locker;
  void *return_value_set_errnull$1;
  if(rdlock == ((signed int (*)(void *))NULL) || tryrdlock == ((signed int (*)(void *))NULL) || trywrlock == ((signed int (*)(void *))NULL) || unlock == ((signed int (*)(void *))NULL) || wrlock == ((signed int (*)(void *))NULL) || lock == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Locker *)return_value_set_errnull$1;
  }

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct Locker) /*48ul*/ );
    locker_create$$1$$locker = (struct Locker *)return_value_malloc$2;
    if(locker_create$$1$$locker == ((struct Locker *)NULL))
      return (struct Locker *)(void *)0;

    else
    {
      locker_create$$1$$locker->lock = lock;
      locker_create$$1$$locker->tryrdlock = tryrdlock;
      locker_create$$1$$locker->rdlock = rdlock;
      locker_create$$1$$locker->trywrlock = trywrlock;
      locker_create$$1$$locker->wrlock = wrlock;
      locker_create$$1$$locker->unlock = unlock;
      return locker_create$$1$$locker;
    }
  }
}

// locker_create_debug_mutex
// file libslack/slack/locker.h line 66
struct Locker * locker_create_debug_mutex(union anonymous$11 *mutex)
{
  struct Locker *return_value_locker_create$1;
  return_value_locker_create$1=locker_create((void *)mutex, (signed int (*)(void *))debug_pthread_mutex_trylock, (signed int (*)(void *))debug_pthread_mutex_lock, (signed int (*)(void *))debug_pthread_mutex_trylock, (signed int (*)(void *))debug_pthread_mutex_lock, (signed int (*)(void *))debug_pthread_mutex_unlock);
  return return_value_locker_create$1;
}

// locker_create_debug_rwlock
// file libslack/slack/locker.h line 67
struct Locker * locker_create_debug_rwlock(union anonymous$12 *rwlock)
{
  struct Locker *return_value_locker_create$1;
  return_value_locker_create$1=locker_create((void *)rwlock, (signed int (*)(void *))debug_pthread_rwlock_tryrdlock, (signed int (*)(void *))debug_pthread_rwlock_rdlock, (signed int (*)(void *))debug_pthread_rwlock_trywrlock, (signed int (*)(void *))debug_pthread_rwlock_wrlock, (signed int (*)(void *))debug_pthread_rwlock_unlock);
  return return_value_locker_create$1;
}

// locker_create_mutex
// file libslack/slack/locker.h line 64
struct Locker * locker_create_mutex(union anonymous$11 *mutex)
{
  struct Locker *return_value_locker_create$1;
  return_value_locker_create$1=locker_create((void *)mutex, (signed int (*)(void *))pthread_mutex_trylock, (signed int (*)(void *))pthread_mutex_lock, (signed int (*)(void *))pthread_mutex_trylock, (signed int (*)(void *))pthread_mutex_lock, (signed int (*)(void *))pthread_mutex_unlock);
  return return_value_locker_create$1;
}

// locker_create_rwlock
// file libslack/slack/locker.h line 65
struct Locker * locker_create_rwlock(union anonymous$12 *rwlock)
{
  struct Locker *return_value_locker_create$1;
  return_value_locker_create$1=locker_create((void *)rwlock, (signed int (*)(void *))pthread_rwlock_tryrdlock, (signed int (*)(void *))pthread_rwlock_rdlock, (signed int (*)(void *))pthread_rwlock_trywrlock, (signed int (*)(void *))pthread_rwlock_wrlock, (signed int (*)(void *))pthread_rwlock_unlock);
  return return_value_locker_create$1;
}

// locker_destroy
// file libslack/slack/locker.h line 70
void * locker_destroy(struct Locker **locker)
{
  if(!(locker == ((struct Locker **)NULL)))
  {
    if(!(*locker == ((struct Locker *)NULL)))
    {
      locker_release(*locker);
      *locker = (struct Locker *)(void *)0;
    }

  }

  return (void *)0;
}

// locker_rdlock
// file libslack/locker.c line 453
signed int locker_rdlock(struct Locker *locker)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->rdlock(locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// locker_release
// file libslack/locker.c line 390
void locker_release(struct Locker *locker)
{
  if(!(locker == ((struct Locker *)NULL)))
    free((void *)locker);

}

// locker_tryrdlock
// file libslack/locker.c line 435
signed int locker_tryrdlock(struct Locker *locker)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->tryrdlock(locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// locker_trywrlock
// file libslack/locker.c line 472
signed int locker_trywrlock(struct Locker *locker)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->trywrlock(locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// locker_unlock
// file libslack/locker.c line 508
signed int locker_unlock(struct Locker *locker)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->unlock(locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// locker_wrlock
// file libslack/locker.c line 490
signed int locker_wrlock(struct Locker *locker)
{
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->wrlock(locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___lxstat$1;
  return_value___lxstat$1=__lxstat(1, __path, __statbuf);
  return return_value___lxstat$1;
}

// mail
// file libslack/net.c line 4142
signed int mail(const char *server, const char *sender, const char *recipients, const char *subject, const char *message)
{
  signed int smtp;
  signed int code;
  signed int rc;
  char c;
  signed int return_value_set_errno$1;
  signed long int return_value_net_expect$4;
  if(recipients == ((const char *)NULL) || sender == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    smtp=net_client(server, "smtp", (unsigned short int)25, (signed long int)5, 0, 0, (struct sockaddr *)(void *)0, (unsigned long int *)(void *)0);
    if(smtp == -1)
      return -1;

    else
    {
      net_tos_lowdelay(smtp);
      signed long int return_value_net_expect$2;
      return_value_net_expect$2=net_expect(smtp, (signed long int)10, "%d%c", &code, &c);
      rc = (signed int)return_value_net_expect$2;
      if(rc == -1)
      {
        close(smtp);
        return -1;
      }

      else
      {
        if(!(code == 220) || !(rc == 2))
        {
          close(smtp);
          signed int return_value_set_errno$3;
          return_value_set_errno$3=set_errno(71);
          return return_value_set_errno$3;
        }

        while((signed int)c == 45)
        {
          return_value_net_expect$4=net_expect(smtp, (signed long int)10, "%d%c", &code, &c);
          rc = (signed int)return_value_net_expect$4;
          if(rc == -1)
          {
            close(smtp);
            return -1;
          }

        }
        if(!(code == 220) || !(rc == 2))
        {
          close(smtp);
          signed int return_value_set_errno$5;
          return_value_set_errno$5=set_errno(71);
          return return_value_set_errno$5;
        }

        signed long int return_value_net_send$6;
        return_value_net_send$6=net_send(smtp, (signed long int)10, "HELO localhost\r\n");
        if(return_value_net_send$6 == -1l)
        {
          close(smtp);
          return -1;
        }

        else
        {
          signed long int return_value_net_expect$7;
          return_value_net_expect$7=net_expect(smtp, (signed long int)10, "%d", &code);
          rc = (signed int)return_value_net_expect$7;
          if(rc == -1)
          {
            close(smtp);
            return -1;
          }

          else
          {
            if(!(code == 250) || !(rc == 1))
            {
              close(smtp);
              signed int return_value_set_errno$8;
              return_value_set_errno$8=set_errno(71);
              return return_value_set_errno$8;
            }

            signed long int return_value_net_send$9;
            return_value_net_send$9=net_send(smtp, (signed long int)10, "MAIL FROM: <%s>\r\n", sender);
            if(return_value_net_send$9 == -1l)
            {
              close(smtp);
              return -1;
            }

            else
            {
              signed long int return_value_net_expect$10;
              return_value_net_expect$10=net_expect(smtp, (signed long int)10, "%d", &code);
              rc = (signed int)return_value_net_expect$10;
              if(rc == -1)
              {
                close(smtp);
                return -1;
              }

              else
              {
                if(!(code == 250) || !(rc == 1))
                {
                  close(smtp);
                  signed int return_value_set_errno$11;
                  return_value_set_errno$11=set_errno(71);
                  return return_value_set_errno$11;
                }

                signed int return_value_rcpt$12;
                return_value_rcpt$12=rcpt(smtp, recipients);
                if(return_value_rcpt$12 == -1)
                {
                  close(smtp);
                  return -1;
                }

                else
                {
                  signed long int return_value_net_send$13;
                  return_value_net_send$13=net_send(smtp, (signed long int)10, "DATA\r\n");
                  if(return_value_net_send$13 == -1l)
                  {
                    close(smtp);
                    return -1;
                  }

                  else
                  {
                    signed long int return_value_net_expect$14;
                    return_value_net_expect$14=net_expect(smtp, (signed long int)10, "%d", &code);
                    rc = (signed int)return_value_net_expect$14;
                    if(rc == -1)
                    {
                      close(smtp);
                      return -1;
                    }

                    else
                    {
                      if(!(code == 354) || !(rc == 1))
                      {
                        close(smtp);
                        signed int return_value_set_errno$15;
                        return_value_set_errno$15=set_errno(71);
                        return return_value_set_errno$15;
                      }

                      net_tos_throughput(smtp);
                      signed long int return_value_net_send$16;
                      return_value_net_send$16=net_send(smtp, (signed long int)10, "From: %s\r\n", sender);
                      if(return_value_net_send$16 == -1l)
                      {
                        close(smtp);
                        return -1;
                      }

                      else
                      {
                        signed long int return_value_net_send$17;
                        return_value_net_send$17=net_send(smtp, (signed long int)10, "To: %s\r\n", recipients);
                        if(return_value_net_send$17 == -1l)
                        {
                          close(smtp);
                          return -1;
                        }

                        else
                        {
                          signed long int return_value_net_send$18;
                          return_value_net_send$18=net_send(smtp, (signed long int)10, "Subject: %s\r\n\r\n", subject != ((const char *)NULL) ? subject : "");
                          if(return_value_net_send$18 == -1l)
                          {
                            close(smtp);
                            return -1;
                          }

                          else
                          {
                            signed long int return_value_net_send$19;
                            return_value_net_send$19=net_send(smtp, (signed long int)10, "%s\r\n.\r\n", message != ((const char *)NULL) ? message : "");
                            if(return_value_net_send$19 == -1l)
                            {
                              close(smtp);
                              return -1;
                            }

                            else
                            {
                              signed long int return_value_net_expect$20;
                              return_value_net_expect$20=net_expect(smtp, (signed long int)10, "%d", &code);
                              rc = (signed int)return_value_net_expect$20;
                              if(rc == -1)
                              {
                                close(smtp);
                                return -1;
                              }

                              else
                              {
                                if(!(code == 250) || !(rc == 1))
                                {
                                  close(smtp);
                                  signed int return_value_set_errno$21;
                                  return_value_set_errno$21=set_errno(71);
                                  return return_value_set_errno$21;
                                }

                                net_tos_lowdelay(smtp);
                                signed long int return_value_net_send$22;
                                return_value_net_send$22=net_send(smtp, (signed long int)10, "QUIT\r\n");
                                if(return_value_net_send$22 == -1l)
                                {
                                  close(smtp);
                                  return -1;
                                }

                                else
                                {
                                  signed long int return_value_net_expect$23;
                                  return_value_net_expect$23=net_expect(smtp, (signed long int)10, "%d", &code);
                                  rc = (signed int)return_value_net_expect$23;
                                  if(rc == -1)
                                  {
                                    close(smtp);
                                    return -1;
                                  }

                                  else
                                  {
                                    if(!(code == 221) || !(rc == 1))
                                    {
                                      close(smtp);
                                      signed int return_value_set_errno$24;
                                      return_value_set_errno$24=set_errno(71);
                                      return return_value_set_errno$24;
                                    }

                                    close(smtp);
                                    return 0;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// main
// file libslack/map.c line 2765
signed int main(signed int ac, char **av)
{
  struct Map *map;
  struct Mapper *mapper;
  struct List *keys;
  struct List *values;
  const void *ckey;
  const char *cvalue;
  char *value;
  char cat[8192l];
  void *ptr;
  signed int val;
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$2;
  _Bool tmp_if_expr$9;
  signed int return_value_strcmp$8;
  _Bool tmp_if_expr$12;
  signed int return_value_strcmp$11;
  _Bool tmp_if_expr$15;
  signed int return_value_strcmp$14;
  _Bool tmp_if_expr$18;
  signed int return_value_strcmp$17;
  signed int return_value_mapper_has_next$20;
  struct List *return_value_list_append$21;
  signed long int return_value_list_length$22;
  _Bool tmp_if_expr$28;
  void *return_value_list_item$26;
  signed int return_value_strcmp$27;
  void *return_value_list_item$24;
  _Bool tmp_if_expr$33;
  void *return_value_list_item$31;
  signed int return_value_strcmp$32;
  void *return_value_list_item$29;
  _Bool tmp_if_expr$38;
  void *return_value_list_item$36;
  signed int return_value_strcmp$37;
  void *return_value_list_item$34;
  _Bool tmp_if_expr$43;
  void *return_value_list_item$41;
  signed int return_value_strcmp$42;
  void *return_value_list_item$39;
  signed int return_value_mapper_has_next$45;
  struct List *return_value_list_append$46;
  struct List *return_value_list_append$47;
  signed long int return_value_list_length$49;
  _Bool tmp_if_expr$55;
  void *return_value_list_item$53;
  signed int return_value_strcmp$54;
  void *return_value_list_item$51;
  _Bool tmp_if_expr$60;
  void *return_value_list_item$58;
  signed int return_value_strcmp$59;
  void *return_value_list_item$56;
  _Bool tmp_if_expr$65;
  void *return_value_list_item$63;
  signed int return_value_strcmp$64;
  void *return_value_list_item$61;
  _Bool tmp_if_expr$70;
  void *return_value_list_item$68;
  signed int return_value_strcmp$69;
  void *return_value_list_item$66;
  signed long int return_value_list_length$72;
  _Bool tmp_if_expr$78;
  void *return_value_list_item$76;
  signed int return_value_strcmp$77;
  void *return_value_list_item$74;
  _Bool tmp_if_expr$83;
  void *return_value_list_item$81;
  signed int return_value_strcmp$82;
  void *return_value_list_item$79;
  _Bool tmp_if_expr$88;
  void *return_value_list_item$86;
  signed int return_value_strcmp$87;
  void *return_value_list_item$84;
  _Bool tmp_if_expr$93;
  void *return_value_list_item$91;
  signed int return_value_strcmp$92;
  void *return_value_list_item$89;
  signed int return_value_map_has_next$95;
  struct List *return_value_list_append$96;
  signed long int return_value_list_length$97;
  _Bool tmp_if_expr$103;
  void *return_value_list_item$101;
  signed int return_value_strcmp$102;
  void *return_value_list_item$99;
  _Bool tmp_if_expr$108;
  void *return_value_list_item$106;
  signed int return_value_strcmp$107;
  void *return_value_list_item$104;
  _Bool tmp_if_expr$113;
  void *return_value_list_item$111;
  signed int return_value_strcmp$112;
  void *return_value_list_item$109;
  _Bool tmp_if_expr$118;
  void *return_value_list_item$116;
  signed int return_value_strcmp$117;
  void *return_value_list_item$114;
  signed int return_value_map_has_next$120;
  struct List *return_value_list_append$121;
  struct List *return_value_list_append$122;
  signed long int return_value_list_length$124;
  _Bool tmp_if_expr$130;
  void *return_value_list_item$128;
  signed int return_value_strcmp$129;
  void *return_value_list_item$126;
  _Bool tmp_if_expr$135;
  void *return_value_list_item$133;
  signed int return_value_strcmp$134;
  void *return_value_list_item$131;
  _Bool tmp_if_expr$140;
  void *return_value_list_item$138;
  signed int return_value_strcmp$139;
  void *return_value_list_item$136;
  _Bool tmp_if_expr$145;
  void *return_value_list_item$143;
  signed int return_value_strcmp$144;
  void *return_value_list_item$141;
  signed long int return_value_list_length$147;
  _Bool tmp_if_expr$153;
  void *return_value_list_item$151;
  signed int return_value_strcmp$152;
  void *return_value_list_item$149;
  _Bool tmp_if_expr$158;
  void *return_value_list_item$156;
  signed int return_value_strcmp$157;
  void *return_value_list_item$154;
  _Bool tmp_if_expr$163;
  void *return_value_list_item$161;
  signed int return_value_strcmp$162;
  void *return_value_list_item$159;
  _Bool tmp_if_expr$168;
  void *return_value_list_item$166;
  signed int return_value_strcmp$167;
  void *return_value_list_item$164;
  signed long int return_value_list_length$170;
  _Bool tmp_if_expr$176;
  void *return_value_list_item$174;
  signed int return_value_strcmp$175;
  void *return_value_list_item$172;
  _Bool tmp_if_expr$181;
  void *return_value_list_item$179;
  signed int return_value_strcmp$180;
  void *return_value_list_item$177;
  _Bool tmp_if_expr$186;
  void *return_value_list_item$184;
  signed int return_value_strcmp$185;
  void *return_value_list_item$182;
  _Bool tmp_if_expr$191;
  void *return_value_list_item$189;
  signed int return_value_strcmp$190;
  void *return_value_list_item$187;
  signed long int return_value_list_length$193;
  _Bool tmp_if_expr$199;
  void *return_value_list_item$197;
  signed int return_value_strcmp$198;
  void *return_value_list_item$195;
  _Bool tmp_if_expr$204;
  void *return_value_list_item$202;
  signed int return_value_strcmp$203;
  void *return_value_list_item$200;
  _Bool tmp_if_expr$209;
  void *return_value_list_item$207;
  signed int return_value_strcmp$208;
  void *return_value_list_item$205;
  _Bool tmp_if_expr$214;
  void *return_value_list_item$212;
  signed int return_value_strcmp$213;
  void *return_value_list_item$210;
  _Bool tmp_if_expr$230;
  signed int return_value_strcmp$229;
  _Bool tmp_if_expr$233;
  signed int return_value_strcmp$232;
  _Bool tmp_if_expr$236;
  signed int return_value_strcmp$235;
  _Bool tmp_if_expr$239;
  signed int return_value_strcmp$238;
  _Bool tmp_if_expr$242;
  signed int return_value_strcmp$241;
  _Bool tmp_if_expr$245;
  signed int return_value_strcmp$244;
  _Bool tmp_if_expr$248;
  signed int return_value_strcmp$247;
  signed int return_value_mapper_has_next$257;
  signed int return_value_map_has_next$263;
  signed int return_value_strcmp$280;
  signed int return_value_strcmp$282;
  signed int return_value_strcmp$284;
  signed int return_value_strcmp$286;
  signed int return_value_strcmp$288;
  signed int return_value_strcmp$290;
  signed int return_value_strcmp$292;
  signed int return_value_strcmp$294;
  signed int return_value_strcmp$296;
  signed int return_value_strcmp$298;
  signed int return_value_strcmp$300;
  signed int return_value_strcmp$302;
  signed int return_value_strcmp$304;
  _Bool tmp_if_expr$359;
  signed int return_value_strcmp$358;
  if(ac == 2)
  {
    return_value_strcmp$1=strcmp(av[(signed long int)1], "help");
    if(!(return_value_strcmp$1 == 0))
      goto __CPROVER_DUMP_L1;

    printf("usage: %s [debug|hash]\n", *av);
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(ac == 2)
    {
      return_value_strcmp$2=strcmp(av[(signed long int)1], "hash");
      if(return_value_strcmp$2 == 0)
        test_hash();

    }

    printf("Testing: %s\n", (const void *)"map");
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 1, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add$3;
      return_value_map_add$3=map_add(map, (const void *)"abc", (void *)"abc");
      if(return_value_map_add$3 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 2, (const void *)"map_add(map, \"abc\", \"abc\")");
      }

      signed int return_value_map_add$4;
      return_value_map_add$4=map_add(map, (const void *)"def", (void *)"def");
      if(return_value_map_add$4 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 3, (const void *)"map_add(map, \"def\", \"def\")");
      }

      signed int return_value_map_add$5;
      return_value_map_add$5=map_add(map, (const void *)"ghi", (void *)"ghi");
      if(return_value_map_add$5 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 4, (const void *)"map_add(map, \"ghi\", \"ghi\")");
      }

      signed int return_value_map_add$6;
      return_value_map_add$6=map_add(map, (const void *)"jkl", (void *)"jkl");
      if(return_value_map_add$6 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 5, (const void *)"map_add(map, \"jkl\", \"jkl\")");
      }

      void *return_value_map_get$7;
      return_value_map_get$7=map_get(map, (const void *)"abc");
      value = (char *)return_value_map_get$7;
      if(value == ((char *)NULL))
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_strcmp$8=strcmp(value, "abc");
        tmp_if_expr$9 = return_value_strcmp$8 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 6, (const void *)"map_get(map, \"abc\")", (const void *)"abc", value, (const void *)"abc");
      }

      void *return_value_map_get$10;
      return_value_map_get$10=map_get(map, (const void *)"def");
      value = (char *)return_value_map_get$10;
      if(value == ((char *)NULL))
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value_strcmp$11=strcmp(value, "def");
        tmp_if_expr$12 = return_value_strcmp$11 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 7, (const void *)"map_get(map, \"def\")", (const void *)"def", value, (const void *)"def");
      }

      void *return_value_map_get$13;
      return_value_map_get$13=map_get(map, (const void *)"ghi");
      value = (char *)return_value_map_get$13;
      if(value == ((char *)NULL))
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value_strcmp$14=strcmp(value, "ghi");
        tmp_if_expr$15 = return_value_strcmp$14 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$15)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 8, (const void *)"map_get(map, \"ghi\")", (const void *)"ghi", value, (const void *)"ghi");
      }

      void *return_value_map_get$16;
      return_value_map_get$16=map_get(map, (const void *)"jkl");
      value = (char *)return_value_map_get$16;
      if(value == ((char *)NULL))
        tmp_if_expr$18 = (_Bool)1;

      else
      {
        return_value_strcmp$17=strcmp(value, "jkl");
        tmp_if_expr$18 = return_value_strcmp$17 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$18)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 9, (const void *)"map_get(map, \"jkl\")", (const void *)"jkl", value, (const void *)"jkl");
      }

      void *return_value_map_get$19;
      return_value_map_get$19=map_get(map, (const void *)"zzz");
      value = (char *)return_value_map_get$19;
      if(!(value == ((char *)NULL)))
      {
        errors = errors + 1;
        printf("Test10: map_get(\"zzz\") failed\n");
      }

      mapper=mapper_create(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 11, (const void *)"mapper = mapper_create(map)");
      }

      else
      {
        keys=list_create((void (*)(void *))(void *)0);
        if(keys == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 12, (const void *)"keys = list_create(NULL)");
        }

        do
        {
          return_value_mapper_has_next$20=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next$20 == 1))
            break;

          void *item;
          item=mapper_next(mapper);
          if(item == NULL)
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 13, (const void *)"item");
          }

          else
          {
            return_value_list_append$21=list_append(keys, item);
            if(return_value_list_append$21 == ((struct List *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 13, (const void *)"list_append(keys, item)");
            }

          }
        }
        while((_Bool)1);
        mapper_destroy(&mapper);
        if(!(mapper == ((struct Mapper *)NULL)))
        {
          errors = errors + 1;
          printf("Test14: mapper_destroy(&mapper) failed (%p, not NULL)", (void *)mapper);
        }

        signed long int return_value_list_length$44;
        return_value_list_length$44=list_length(keys);
        if(!(return_value_list_length$44 == 4l))
        {
          errors = errors + 1;
          return_value_list_length$22=list_length(keys);
          printf("Test%d: %s failed (%d items, not 4)\n", 15, (const void *)"mapper_has_next/mapper_next", (signed int)return_value_list_length$22);
        }

        else
        {
          struct List *return_value_list_sort$23;
          return_value_list_sort$23=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort$23 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 15, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item$25;
          return_value_list_item$25=list_item(keys, (signed long int)0);
          if(return_value_list_item$25 == NULL)
            tmp_if_expr$28 = (_Bool)1;

          else
          {
            return_value_list_item$26=list_item(keys, (signed long int)0);
            return_value_strcmp$27=strcmp((const char *)return_value_list_item$26, "abc");
            tmp_if_expr$28 = return_value_strcmp$27 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$28)
          {
            errors = errors + 1;
            return_value_list_item$24=list_item(keys, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item$24, (const void *)"abc");
          }

          void *return_value_list_item$30;
          return_value_list_item$30=list_item(keys, (signed long int)1);
          if(return_value_list_item$30 == NULL)
            tmp_if_expr$33 = (_Bool)1;

          else
          {
            return_value_list_item$31=list_item(keys, (signed long int)1);
            return_value_strcmp$32=strcmp((const char *)return_value_list_item$31, "def");
            tmp_if_expr$33 = return_value_strcmp$32 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$33)
          {
            errors = errors + 1;
            return_value_list_item$29=list_item(keys, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item$29, (const void *)"def");
          }

          void *return_value_list_item$35;
          return_value_list_item$35=list_item(keys, (signed long int)2);
          if(return_value_list_item$35 == NULL)
            tmp_if_expr$38 = (_Bool)1;

          else
          {
            return_value_list_item$36=list_item(keys, (signed long int)2);
            return_value_strcmp$37=strcmp((const char *)return_value_list_item$36, "ghi");
            tmp_if_expr$38 = return_value_strcmp$37 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$38)
          {
            errors = errors + 1;
            return_value_list_item$34=list_item(keys, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item$34, (const void *)"ghi");
          }

          void *return_value_list_item$40;
          return_value_list_item$40=list_item(keys, (signed long int)3);
          if(return_value_list_item$40 == NULL)
            tmp_if_expr$43 = (_Bool)1;

          else
          {
            return_value_list_item$41=list_item(keys, (signed long int)3);
            return_value_strcmp$42=strcmp((const char *)return_value_list_item$41, "jkl");
            tmp_if_expr$43 = return_value_strcmp$42 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$43)
          {
            errors = errors + 1;
            return_value_list_item$39=list_item(keys, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item$39, (const void *)"jkl");
          }

        }
        list_destroy(&keys);
      }
      mapper=mapper_create(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 16, (const void *)"mapper = mapper_create(map)");
      }

      else
      {
        keys=list_create((void (*)(void *))(void *)0);
        if(keys == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 16, (const void *)"keys = list_create(NULL)");
        }

        values=list_create((void (*)(void *))(void *)0);
        if(values == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 16, (const void *)"values = list_create(NULL)");
        }

        do
        {
          return_value_mapper_has_next$45=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next$45 == 1))
            break;

          const struct Mapping *mapping;
          mapping=mapper_next_mapping(mapper);
          if(mapping == ((const struct Mapping *)NULL))
          {
            errors = errors + 1;
            printf("Test17: mapper_next_mapping() failed\n");
          }

          else
          {
            ckey=mapping_key((const struct Mapping *)(void *)mapping);
            if(ckey == NULL)
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 17, (const void *)"ckey = mapping_key((void *)mapping)");
            }

            else
            {
              return_value_list_append$46=list_append(keys, (void *)ckey);
              if(return_value_list_append$46 == ((struct List *)NULL))
              {
                errors = errors + 1;
                printf("Test%d: %s failed\n", 17, (const void *)"list_append(keys, (void *)ckey)");
              }

            }
            const void *return_value_mapping_value$48;
            return_value_mapping_value$48=mapping_value(mapping);
            cvalue = (const char *)return_value_mapping_value$48;
            if(cvalue == ((const char *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 17, (const void *)"cvalue = mapping_value(mapping)");
            }

            else
            {
              return_value_list_append$47=list_append(values, (void *)cvalue);
              if(return_value_list_append$47 == ((struct List *)NULL))
              {
                errors = errors + 1;
                printf("Test%d: %s failed\n", 17, (const void *)"list_append(values, (void *)cvalue)");
              }

            }
          }
        }
        while((_Bool)1);
        mapper_destroy(&mapper);
        if(!(mapper == ((struct Mapper *)NULL)))
        {
          errors = errors + 1;
          printf("Test18: mapper_destroy(&mapper) failed (%p, not NULL)", (void *)mapper);
        }

        signed long int return_value_list_length$71;
        return_value_list_length$71=list_length(keys);
        if(!(return_value_list_length$71 == 4l))
        {
          errors = errors + 1;
          return_value_list_length$49=list_length(keys);
          printf("Test%d: %s failed (%d items, not 4)\n", 19, (const void *)"mapper_has_next/mapper_next_mapping", (signed int)return_value_list_length$49);
        }

        else
        {
          struct List *return_value_list_sort$50;
          return_value_list_sort$50=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort$50 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 19, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item$52;
          return_value_list_item$52=list_item(keys, (signed long int)0);
          if(return_value_list_item$52 == NULL)
            tmp_if_expr$55 = (_Bool)1;

          else
          {
            return_value_list_item$53=list_item(keys, (signed long int)0);
            return_value_strcmp$54=strcmp((const char *)return_value_list_item$53, "abc");
            tmp_if_expr$55 = return_value_strcmp$54 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$55)
          {
            errors = errors + 1;
            return_value_list_item$51=list_item(keys, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item$51, (const void *)"abc");
          }

          void *return_value_list_item$57;
          return_value_list_item$57=list_item(keys, (signed long int)1);
          if(return_value_list_item$57 == NULL)
            tmp_if_expr$60 = (_Bool)1;

          else
          {
            return_value_list_item$58=list_item(keys, (signed long int)1);
            return_value_strcmp$59=strcmp((const char *)return_value_list_item$58, "def");
            tmp_if_expr$60 = return_value_strcmp$59 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$60)
          {
            errors = errors + 1;
            return_value_list_item$56=list_item(keys, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item$56, (const void *)"def");
          }

          void *return_value_list_item$62;
          return_value_list_item$62=list_item(keys, (signed long int)2);
          if(return_value_list_item$62 == NULL)
            tmp_if_expr$65 = (_Bool)1;

          else
          {
            return_value_list_item$63=list_item(keys, (signed long int)2);
            return_value_strcmp$64=strcmp((const char *)return_value_list_item$63, "ghi");
            tmp_if_expr$65 = return_value_strcmp$64 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$65)
          {
            errors = errors + 1;
            return_value_list_item$61=list_item(keys, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item$61, (const void *)"ghi");
          }

          void *return_value_list_item$67;
          return_value_list_item$67=list_item(keys, (signed long int)3);
          if(return_value_list_item$67 == NULL)
            tmp_if_expr$70 = (_Bool)1;

          else
          {
            return_value_list_item$68=list_item(keys, (signed long int)3);
            return_value_strcmp$69=strcmp((const char *)return_value_list_item$68, "jkl");
            tmp_if_expr$70 = return_value_strcmp$69 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$70)
          {
            errors = errors + 1;
            return_value_list_item$66=list_item(keys, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item$66, (const void *)"jkl");
          }

        }
        list_destroy(&keys);
        signed long int return_value_list_length$94;
        return_value_list_length$94=list_length(values);
        if(!(return_value_list_length$94 == 4l))
        {
          errors = errors + 1;
          return_value_list_length$72=list_length(values);
          printf("Test%d: %s failed (%d items, not 4)\n", 20, (const void *)"mapper_has_next/mapper_next_mapping", (signed int)return_value_list_length$72);
        }

        else
        {
          struct List *return_value_list_sort$73;
          return_value_list_sort$73=list_sort(values, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort$73 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 20, (const void *)"list_sort((values), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item$75;
          return_value_list_item$75=list_item(values, (signed long int)0);
          if(return_value_list_item$75 == NULL)
            tmp_if_expr$78 = (_Bool)1;

          else
          {
            return_value_list_item$76=list_item(values, (signed long int)0);
            return_value_strcmp$77=strcmp((const char *)return_value_list_item$76, "abc");
            tmp_if_expr$78 = return_value_strcmp$77 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$78)
          {
            errors = errors + 1;
            return_value_list_item$74=list_item(values, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 0, (char *)return_value_list_item$74, (const void *)"abc");
          }

          void *return_value_list_item$80;
          return_value_list_item$80=list_item(values, (signed long int)1);
          if(return_value_list_item$80 == NULL)
            tmp_if_expr$83 = (_Bool)1;

          else
          {
            return_value_list_item$81=list_item(values, (signed long int)1);
            return_value_strcmp$82=strcmp((const char *)return_value_list_item$81, "def");
            tmp_if_expr$83 = return_value_strcmp$82 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$83)
          {
            errors = errors + 1;
            return_value_list_item$79=list_item(values, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 1, (char *)return_value_list_item$79, (const void *)"def");
          }

          void *return_value_list_item$85;
          return_value_list_item$85=list_item(values, (signed long int)2);
          if(return_value_list_item$85 == NULL)
            tmp_if_expr$88 = (_Bool)1;

          else
          {
            return_value_list_item$86=list_item(values, (signed long int)2);
            return_value_strcmp$87=strcmp((const char *)return_value_list_item$86, "ghi");
            tmp_if_expr$88 = return_value_strcmp$87 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$88)
          {
            errors = errors + 1;
            return_value_list_item$84=list_item(values, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 2, (char *)return_value_list_item$84, (const void *)"ghi");
          }

          void *return_value_list_item$90;
          return_value_list_item$90=list_item(values, (signed long int)3);
          if(return_value_list_item$90 == NULL)
            tmp_if_expr$93 = (_Bool)1;

          else
          {
            return_value_list_item$91=list_item(values, (signed long int)3);
            return_value_strcmp$92=strcmp((const char *)return_value_list_item$91, "jkl");
            tmp_if_expr$93 = return_value_strcmp$92 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$93)
          {
            errors = errors + 1;
            return_value_list_item$89=list_item(values, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 3, (char *)return_value_list_item$89, (const void *)"jkl");
          }

        }
        list_destroy(&values);
      }
      keys=list_create((void (*)(void *))(void *)0);
      if(keys == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 21, (const void *)"keys = list_create(NULL)");
      }

      do
      {
        return_value_map_has_next$95=map_has_next(map);
        if(!(return_value_map_has_next$95 == 1))
          break;

        void *main$$1$$2$$3$$item;
        main$$1$$2$$3$$item=map_next(map);
        if(main$$1$$2$$3$$item == NULL)
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 22, (const void *)"item = map_next(map)");
        }

        else
        {
          return_value_list_append$96=list_append(keys, main$$1$$2$$3$$item);
          if(return_value_list_append$96 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 22, (const void *)"list_append(keys, item)");
          }

        }
      }
      while((_Bool)1);
      signed long int return_value_list_length$119;
      return_value_list_length$119=list_length(keys);
      if(!(return_value_list_length$119 == 4l))
      {
        errors = errors + 1;
        return_value_list_length$97=list_length(keys);
        printf("Test%d: %s failed (%d items, not 4)\n", 23, (const void *)"map_has_next/map_next", (signed int)return_value_list_length$97);
      }

      else
      {
        struct List *return_value_list_sort$98;
        return_value_list_sort$98=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
        if(return_value_list_sort$98 == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 23, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
        }

        void *return_value_list_item$100;
        return_value_list_item$100=list_item(keys, (signed long int)0);
        if(return_value_list_item$100 == NULL)
          tmp_if_expr$103 = (_Bool)1;

        else
        {
          return_value_list_item$101=list_item(keys, (signed long int)0);
          return_value_strcmp$102=strcmp((const char *)return_value_list_item$101, "abc");
          tmp_if_expr$103 = return_value_strcmp$102 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$103)
        {
          errors = errors + 1;
          return_value_list_item$99=list_item(keys, (signed long int)0);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item$99, (const void *)"abc");
        }

        void *return_value_list_item$105;
        return_value_list_item$105=list_item(keys, (signed long int)1);
        if(return_value_list_item$105 == NULL)
          tmp_if_expr$108 = (_Bool)1;

        else
        {
          return_value_list_item$106=list_item(keys, (signed long int)1);
          return_value_strcmp$107=strcmp((const char *)return_value_list_item$106, "def");
          tmp_if_expr$108 = return_value_strcmp$107 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$108)
        {
          errors = errors + 1;
          return_value_list_item$104=list_item(keys, (signed long int)1);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item$104, (const void *)"def");
        }

        void *return_value_list_item$110;
        return_value_list_item$110=list_item(keys, (signed long int)2);
        if(return_value_list_item$110 == NULL)
          tmp_if_expr$113 = (_Bool)1;

        else
        {
          return_value_list_item$111=list_item(keys, (signed long int)2);
          return_value_strcmp$112=strcmp((const char *)return_value_list_item$111, "ghi");
          tmp_if_expr$113 = return_value_strcmp$112 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$113)
        {
          errors = errors + 1;
          return_value_list_item$109=list_item(keys, (signed long int)2);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item$109, (const void *)"ghi");
        }

        void *return_value_list_item$115;
        return_value_list_item$115=list_item(keys, (signed long int)3);
        if(return_value_list_item$115 == NULL)
          tmp_if_expr$118 = (_Bool)1;

        else
        {
          return_value_list_item$116=list_item(keys, (signed long int)3);
          return_value_strcmp$117=strcmp((const char *)return_value_list_item$116, "jkl");
          tmp_if_expr$118 = return_value_strcmp$117 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$118)
        {
          errors = errors + 1;
          return_value_list_item$114=list_item(keys, (signed long int)3);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item$114, (const void *)"jkl");
        }

      }
      list_destroy(&keys);
      keys=list_create((void (*)(void *))(void *)0);
      if(keys == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 24, (const void *)"keys = list_create(NULL)");
      }

      values=list_create((void (*)(void *))(void *)0);
      if(values == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 24, (const void *)"values = list_create(NULL)");
      }

      do
      {
        return_value_map_has_next$120=map_has_next(map);
        if(!(return_value_map_has_next$120 == 1))
          break;

        const struct Mapping *main$$1$$2$$5$$mapping;
        main$$1$$2$$5$$mapping=map_next_mapping(map);
        if(main$$1$$2$$5$$mapping == ((const struct Mapping *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 25, (const void *)"mapping = map_next_mapping(map)");
        }

        else
        {
          ckey=mapping_key(main$$1$$2$$5$$mapping);
          if(ckey == NULL)
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 25, (const void *)"ckey = mapping_key(mapping)");
          }

          else
          {
            return_value_list_append$121=list_append(keys, (void *)ckey);
            if(return_value_list_append$121 == ((struct List *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 25, (const void *)"list_append(keys, (void *)ckey)");
            }

          }
          const void *return_value_mapping_value$123;
          return_value_mapping_value$123=mapping_value(main$$1$$2$$5$$mapping);
          cvalue = (const char *)return_value_mapping_value$123;
          if(cvalue == ((const char *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 25, (const void *)"cvalue = mapping_value(mapping)");
          }

          else
          {
            return_value_list_append$122=list_append(values, (void *)cvalue);
            if(return_value_list_append$122 == ((struct List *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 25, (const void *)"list_append(values, (void *)cvalue)");
            }

          }
        }
      }
      while((_Bool)1);
      signed long int return_value_list_length$146;
      return_value_list_length$146=list_length(keys);
      if(!(return_value_list_length$146 == 4l))
      {
        errors = errors + 1;
        return_value_list_length$124=list_length(keys);
        printf("Test%d: %s failed (%d items, not 4)\n", 26, (const void *)"map_has_next/map_next_mapping", (signed int)return_value_list_length$124);
      }

      else
      {
        struct List *return_value_list_sort$125;
        return_value_list_sort$125=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
        if(return_value_list_sort$125 == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 26, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
        }

        void *return_value_list_item$127;
        return_value_list_item$127=list_item(keys, (signed long int)0);
        if(return_value_list_item$127 == NULL)
          tmp_if_expr$130 = (_Bool)1;

        else
        {
          return_value_list_item$128=list_item(keys, (signed long int)0);
          return_value_strcmp$129=strcmp((const char *)return_value_list_item$128, "abc");
          tmp_if_expr$130 = return_value_strcmp$129 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$130)
        {
          errors = errors + 1;
          return_value_list_item$126=list_item(keys, (signed long int)0);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item$126, (const void *)"abc");
        }

        void *return_value_list_item$132;
        return_value_list_item$132=list_item(keys, (signed long int)1);
        if(return_value_list_item$132 == NULL)
          tmp_if_expr$135 = (_Bool)1;

        else
        {
          return_value_list_item$133=list_item(keys, (signed long int)1);
          return_value_strcmp$134=strcmp((const char *)return_value_list_item$133, "def");
          tmp_if_expr$135 = return_value_strcmp$134 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$135)
        {
          errors = errors + 1;
          return_value_list_item$131=list_item(keys, (signed long int)1);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item$131, (const void *)"def");
        }

        void *return_value_list_item$137;
        return_value_list_item$137=list_item(keys, (signed long int)2);
        if(return_value_list_item$137 == NULL)
          tmp_if_expr$140 = (_Bool)1;

        else
        {
          return_value_list_item$138=list_item(keys, (signed long int)2);
          return_value_strcmp$139=strcmp((const char *)return_value_list_item$138, "ghi");
          tmp_if_expr$140 = return_value_strcmp$139 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$140)
        {
          errors = errors + 1;
          return_value_list_item$136=list_item(keys, (signed long int)2);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item$136, (const void *)"ghi");
        }

        void *return_value_list_item$142;
        return_value_list_item$142=list_item(keys, (signed long int)3);
        if(return_value_list_item$142 == NULL)
          tmp_if_expr$145 = (_Bool)1;

        else
        {
          return_value_list_item$143=list_item(keys, (signed long int)3);
          return_value_strcmp$144=strcmp((const char *)return_value_list_item$143, "jkl");
          tmp_if_expr$145 = return_value_strcmp$144 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$145)
        {
          errors = errors + 1;
          return_value_list_item$141=list_item(keys, (signed long int)3);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item$141, (const void *)"jkl");
        }

      }
      list_destroy(&keys);
      signed long int return_value_list_length$169;
      return_value_list_length$169=list_length(values);
      if(!(return_value_list_length$169 == 4l))
      {
        errors = errors + 1;
        return_value_list_length$147=list_length(values);
        printf("Test%d: %s failed (%d items, not 4)\n", 27, (const void *)"map_has_next/map_next_mapping", (signed int)return_value_list_length$147);
      }

      else
      {
        struct List *return_value_list_sort$148;
        return_value_list_sort$148=list_sort(values, (signed int (*)(const void *, const void *))sort_cmp);
        if(return_value_list_sort$148 == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 27, (const void *)"list_sort((values), (list_cmp_t *)sort_cmp)");
        }

        void *return_value_list_item$150;
        return_value_list_item$150=list_item(values, (signed long int)0);
        if(return_value_list_item$150 == NULL)
          tmp_if_expr$153 = (_Bool)1;

        else
        {
          return_value_list_item$151=list_item(values, (signed long int)0);
          return_value_strcmp$152=strcmp((const char *)return_value_list_item$151, "abc");
          tmp_if_expr$153 = return_value_strcmp$152 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$153)
        {
          errors = errors + 1;
          return_value_list_item$149=list_item(values, (signed long int)0);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 0, (char *)return_value_list_item$149, (const void *)"abc");
        }

        void *return_value_list_item$155;
        return_value_list_item$155=list_item(values, (signed long int)1);
        if(return_value_list_item$155 == NULL)
          tmp_if_expr$158 = (_Bool)1;

        else
        {
          return_value_list_item$156=list_item(values, (signed long int)1);
          return_value_strcmp$157=strcmp((const char *)return_value_list_item$156, "def");
          tmp_if_expr$158 = return_value_strcmp$157 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$158)
        {
          errors = errors + 1;
          return_value_list_item$154=list_item(values, (signed long int)1);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 1, (char *)return_value_list_item$154, (const void *)"def");
        }

        void *return_value_list_item$160;
        return_value_list_item$160=list_item(values, (signed long int)2);
        if(return_value_list_item$160 == NULL)
          tmp_if_expr$163 = (_Bool)1;

        else
        {
          return_value_list_item$161=list_item(values, (signed long int)2);
          return_value_strcmp$162=strcmp((const char *)return_value_list_item$161, "ghi");
          tmp_if_expr$163 = return_value_strcmp$162 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$163)
        {
          errors = errors + 1;
          return_value_list_item$159=list_item(values, (signed long int)2);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 2, (char *)return_value_list_item$159, (const void *)"ghi");
        }

        void *return_value_list_item$165;
        return_value_list_item$165=list_item(values, (signed long int)3);
        if(return_value_list_item$165 == NULL)
          tmp_if_expr$168 = (_Bool)1;

        else
        {
          return_value_list_item$166=list_item(values, (signed long int)3);
          return_value_strcmp$167=strcmp((const char *)return_value_list_item$166, "jkl");
          tmp_if_expr$168 = return_value_strcmp$167 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$168)
        {
          errors = errors + 1;
          return_value_list_item$164=list_item(values, (signed long int)3);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 3, (char *)return_value_list_item$164, (const void *)"jkl");
        }

      }
      list_destroy(&values);
      keys=map_keys(map);
      if(keys == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 28, (const void *)"keys = map_keys(map)");
      }

      else
      {
        signed long int return_value_list_length$192;
        return_value_list_length$192=list_length(keys);
        if(!(return_value_list_length$192 == 4l))
        {
          errors = errors + 1;
          return_value_list_length$170=list_length(keys);
          printf("Test%d: %s failed (%d items, not 4)\n", 29, (const void *)"map_keys", (signed int)return_value_list_length$170);
        }

        else
        {
          struct List *return_value_list_sort$171;
          return_value_list_sort$171=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort$171 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 29, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item$173;
          return_value_list_item$173=list_item(keys, (signed long int)0);
          if(return_value_list_item$173 == NULL)
            tmp_if_expr$176 = (_Bool)1;

          else
          {
            return_value_list_item$174=list_item(keys, (signed long int)0);
            return_value_strcmp$175=strcmp((const char *)return_value_list_item$174, "abc");
            tmp_if_expr$176 = return_value_strcmp$175 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$176)
          {
            errors = errors + 1;
            return_value_list_item$172=list_item(keys, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item$172, (const void *)"abc");
          }

          void *return_value_list_item$178;
          return_value_list_item$178=list_item(keys, (signed long int)1);
          if(return_value_list_item$178 == NULL)
            tmp_if_expr$181 = (_Bool)1;

          else
          {
            return_value_list_item$179=list_item(keys, (signed long int)1);
            return_value_strcmp$180=strcmp((const char *)return_value_list_item$179, "def");
            tmp_if_expr$181 = return_value_strcmp$180 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$181)
          {
            errors = errors + 1;
            return_value_list_item$177=list_item(keys, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item$177, (const void *)"def");
          }

          void *return_value_list_item$183;
          return_value_list_item$183=list_item(keys, (signed long int)2);
          if(return_value_list_item$183 == NULL)
            tmp_if_expr$186 = (_Bool)1;

          else
          {
            return_value_list_item$184=list_item(keys, (signed long int)2);
            return_value_strcmp$185=strcmp((const char *)return_value_list_item$184, "ghi");
            tmp_if_expr$186 = return_value_strcmp$185 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$186)
          {
            errors = errors + 1;
            return_value_list_item$182=list_item(keys, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item$182, (const void *)"ghi");
          }

          void *return_value_list_item$188;
          return_value_list_item$188=list_item(keys, (signed long int)3);
          if(return_value_list_item$188 == NULL)
            tmp_if_expr$191 = (_Bool)1;

          else
          {
            return_value_list_item$189=list_item(keys, (signed long int)3);
            return_value_strcmp$190=strcmp((const char *)return_value_list_item$189, "jkl");
            tmp_if_expr$191 = return_value_strcmp$190 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$191)
          {
            errors = errors + 1;
            return_value_list_item$187=list_item(keys, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item$187, (const void *)"jkl");
          }

        }
        list_destroy(&keys);
      }
      values=map_values(map);
      if(values == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 30, (const void *)"values = map_values(map)");
      }

      else
      {
        signed long int return_value_list_length$215;
        return_value_list_length$215=list_length(values);
        if(!(return_value_list_length$215 == 4l))
        {
          errors = errors + 1;
          return_value_list_length$193=list_length(values);
          printf("Test%d: %s failed (%d items, not 4)\n", 31, (const void *)"map_values", (signed int)return_value_list_length$193);
        }

        else
        {
          struct List *return_value_list_sort$194;
          return_value_list_sort$194=list_sort(values, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort$194 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 31, (const void *)"list_sort((values), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item$196;
          return_value_list_item$196=list_item(values, (signed long int)0);
          if(return_value_list_item$196 == NULL)
            tmp_if_expr$199 = (_Bool)1;

          else
          {
            return_value_list_item$197=list_item(values, (signed long int)0);
            return_value_strcmp$198=strcmp((const char *)return_value_list_item$197, "abc");
            tmp_if_expr$199 = return_value_strcmp$198 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$199)
          {
            errors = errors + 1;
            return_value_list_item$195=list_item(values, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 0, (char *)return_value_list_item$195, (const void *)"abc");
          }

          void *return_value_list_item$201;
          return_value_list_item$201=list_item(values, (signed long int)1);
          if(return_value_list_item$201 == NULL)
            tmp_if_expr$204 = (_Bool)1;

          else
          {
            return_value_list_item$202=list_item(values, (signed long int)1);
            return_value_strcmp$203=strcmp((const char *)return_value_list_item$202, "def");
            tmp_if_expr$204 = return_value_strcmp$203 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$204)
          {
            errors = errors + 1;
            return_value_list_item$200=list_item(values, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 1, (char *)return_value_list_item$200, (const void *)"def");
          }

          void *return_value_list_item$206;
          return_value_list_item$206=list_item(values, (signed long int)2);
          if(return_value_list_item$206 == NULL)
            tmp_if_expr$209 = (_Bool)1;

          else
          {
            return_value_list_item$207=list_item(values, (signed long int)2);
            return_value_strcmp$208=strcmp((const char *)return_value_list_item$207, "ghi");
            tmp_if_expr$209 = return_value_strcmp$208 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$209)
          {
            errors = errors + 1;
            return_value_list_item$205=list_item(values, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 2, (char *)return_value_list_item$205, (const void *)"ghi");
          }

          void *return_value_list_item$211;
          return_value_list_item$211=list_item(values, (signed long int)3);
          if(return_value_list_item$211 == NULL)
            tmp_if_expr$214 = (_Bool)1;

          else
          {
            return_value_list_item$212=list_item(values, (signed long int)3);
            return_value_strcmp$213=strcmp((const char *)return_value_list_item$212, "jkl");
            tmp_if_expr$214 = return_value_strcmp$213 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$214)
          {
            errors = errors + 1;
            return_value_list_item$210=list_item(values, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 3, (char *)return_value_list_item$210, (const void *)"jkl");
          }

        }
        list_destroy(&values);
      }
      signed int return_value_map_remove$216;
      return_value_map_remove$216=map_remove(map, (const void *)"zzz");
      if(!(return_value_map_remove$216 == -1))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 32, (const void *)"map_remove(map, \"zzz\") == -1");
      }

      signed int return_value_map_remove$217;
      return_value_map_remove$217=map_remove(map, (const void *)"abc");
      if(return_value_map_remove$217 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 33, (const void *)"map_remove(map, \"abc\") != -1");
      }

      signed int return_value_map_remove$218;
      return_value_map_remove$218=map_remove(map, (const void *)"def");
      if(return_value_map_remove$218 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 34, (const void *)"map_remove(map, \"def\") != -1");
      }

      signed int return_value_map_remove$219;
      return_value_map_remove$219=map_remove(map, (const void *)"ghi");
      if(return_value_map_remove$219 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 35, (const void *)"map_remove(map, \"ghi\") != -1");
      }

      signed int return_value_map_remove$220;
      return_value_map_remove$220=map_remove(map, (const void *)"jkl");
      if(return_value_map_remove$220 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 36, (const void *)"map_remove(map, \"jkl\") != -1");
      }

      map_destroy(&map);
      if(!(map == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test37: map_destroy(&map) failed (%p, not NULL)\n", (void *)map);
      }

    }
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 38, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add$221;
      return_value_map_add$221=map_add(map, (const void *)"1", (void *)"7");
      if(!(return_value_map_add$221 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 39, (const void *)"map_add(map, \"1\", \"7\") == 0");
      }

      signed int return_value_map_add$222;
      return_value_map_add$222=map_add(map, (const void *)"2", (void *)"6");
      if(!(return_value_map_add$222 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 40, (const void *)"map_add(map, \"2\", \"6\") == 0");
      }

      signed int return_value_map_add$223;
      return_value_map_add$223=map_add(map, (const void *)"3", (void *)"5");
      if(!(return_value_map_add$223 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 41, (const void *)"map_add(map, \"3\", \"5\") == 0");
      }

      signed int return_value_map_add$224;
      return_value_map_add$224=map_add(map, (const void *)"4", (void *)"4");
      if(!(return_value_map_add$224 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 42, (const void *)"map_add(map, \"4\", \"4\") == 0");
      }

      signed int return_value_map_add$225;
      return_value_map_add$225=map_add(map, (const void *)"5", (void *)"3");
      if(!(return_value_map_add$225 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 43, (const void *)"map_add(map, \"5\", \"3\") == 0");
      }

      signed int return_value_map_add$226;
      return_value_map_add$226=map_add(map, (const void *)"6", (void *)"2");
      if(!(return_value_map_add$226 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 44, (const void *)"map_add(map, \"6\", \"2\") == 0");
      }

      signed int return_value_map_add$227;
      return_value_map_add$227=map_add(map, (const void *)"7", (void *)"1");
      if(!(return_value_map_add$227 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 45, (const void *)"map_add(map, \"7\", \"1\") == 0");
      }

      void *return_value_map_get$228;
      return_value_map_get$228=map_get(map, (const void *)"1");
      value = (char *)return_value_map_get$228;
      if(value == ((char *)NULL))
        tmp_if_expr$230 = (_Bool)1;

      else
      {
        return_value_strcmp$229=strcmp(value, "7");
        tmp_if_expr$230 = return_value_strcmp$229 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$230)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 46, (const void *)"map_get(map, \"1\")", (const void *)"1", value, (const void *)"7");
      }

      void *return_value_map_get$231;
      return_value_map_get$231=map_get(map, (const void *)"2");
      value = (char *)return_value_map_get$231;
      if(value == ((char *)NULL))
        tmp_if_expr$233 = (_Bool)1;

      else
      {
        return_value_strcmp$232=strcmp(value, "6");
        tmp_if_expr$233 = return_value_strcmp$232 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$233)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 47, (const void *)"map_get(map, \"2\")", (const void *)"2", value, (const void *)"6");
      }

      void *return_value_map_get$234;
      return_value_map_get$234=map_get(map, (const void *)"3");
      value = (char *)return_value_map_get$234;
      if(value == ((char *)NULL))
        tmp_if_expr$236 = (_Bool)1;

      else
      {
        return_value_strcmp$235=strcmp(value, "5");
        tmp_if_expr$236 = return_value_strcmp$235 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$236)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 48, (const void *)"map_get(map, \"3\")", (const void *)"3", value, (const void *)"5");
      }

      void *return_value_map_get$237;
      return_value_map_get$237=map_get(map, (const void *)"4");
      value = (char *)return_value_map_get$237;
      if(value == ((char *)NULL))
        tmp_if_expr$239 = (_Bool)1;

      else
      {
        return_value_strcmp$238=strcmp(value, "4");
        tmp_if_expr$239 = return_value_strcmp$238 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$239)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 49, (const void *)"map_get(map, \"4\")", (const void *)"4", value, (const void *)"4");
      }

      void *return_value_map_get$240;
      return_value_map_get$240=map_get(map, (const void *)"5");
      value = (char *)return_value_map_get$240;
      if(value == ((char *)NULL))
        tmp_if_expr$242 = (_Bool)1;

      else
      {
        return_value_strcmp$241=strcmp(value, "3");
        tmp_if_expr$242 = return_value_strcmp$241 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$242)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 50, (const void *)"map_get(map, \"5\")", (const void *)"5", value, (const void *)"3");
      }

      void *return_value_map_get$243;
      return_value_map_get$243=map_get(map, (const void *)"6");
      value = (char *)return_value_map_get$243;
      if(value == ((char *)NULL))
        tmp_if_expr$245 = (_Bool)1;

      else
      {
        return_value_strcmp$244=strcmp(value, "2");
        tmp_if_expr$245 = return_value_strcmp$244 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$245)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 51, (const void *)"map_get(map, \"6\")", (const void *)"6", value, (const void *)"2");
      }

      void *return_value_map_get$246;
      return_value_map_get$246=map_get(map, (const void *)"7");
      value = (char *)return_value_map_get$246;
      if(value == ((char *)NULL))
        tmp_if_expr$248 = (_Bool)1;

      else
      {
        return_value_strcmp$247=strcmp(value, "1");
        tmp_if_expr$248 = return_value_strcmp$247 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$248)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 52, (const void *)"map_get(map, \"7\")", (const void *)"7", value, (const void *)"1");
      }

      cat[(signed long int)0] = (char)0;
      map_apply(map, (void (*)(void *, void *, void *))test_action, (void *)cat);
      signed int return_value_strcmp$249;
      return_value_strcmp$249=strcmp(cat, "7=1, 1=7, 2=6, 3=5, 4=4, 5=3, 6=2");
      if(!(return_value_strcmp$249 == 0))
      {
        errors = errors + 1;
        printf("Test53: map_apply(cat) failed (cat = \"%s\", not \"%s\")\n", (const void *)cat, (const void *)"7=1, 1=7, 2=6, 3=5, 4=4, 5=3, 6=2");
      }

      map_destroy(&map);
      if(!(map == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test54: map_destroy(&map) failed (%p, not NULL)\n", (void *)map);
      }

    }
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 55, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add$250;
      return_value_map_add$250=map_add(map, (const void *)"1", (void *)"7");
      if(!(return_value_map_add$250 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 56, (const void *)"map_add(map, \"1\", \"7\") == 0");
      }

      signed int return_value_map_add$251;
      return_value_map_add$251=map_add(map, (const void *)"2", (void *)"6");
      if(!(return_value_map_add$251 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 57, (const void *)"map_add(map, \"2\", \"6\") == 0");
      }

      signed int return_value_map_add$252;
      return_value_map_add$252=map_add(map, (const void *)"3", (void *)"5");
      if(!(return_value_map_add$252 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 58, (const void *)"map_add(map, \"3\", \"5\") == 0");
      }

      signed int return_value_map_add$253;
      return_value_map_add$253=map_add(map, (const void *)"4", (void *)"4");
      if(!(return_value_map_add$253 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 59, (const void *)"map_add(map, \"4\", \"4\") == 0");
      }

      signed int return_value_map_add$254;
      return_value_map_add$254=map_add(map, (const void *)"5", (void *)"3");
      if(!(return_value_map_add$254 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 60, (const void *)"map_add(map, \"5\", \"3\") == 0");
      }

      signed int return_value_map_add$255;
      return_value_map_add$255=map_add(map, (const void *)"6", (void *)"2");
      if(!(return_value_map_add$255 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 61, (const void *)"map_add(map, \"6\", \"2\") == 0");
      }

      signed int return_value_map_add$256;
      return_value_map_add$256=map_add(map, (const void *)"7", (void *)"1");
      if(!(return_value_map_add$256 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 62, (const void *)"map_add(map, \"7\", \"1\") == 0");
      }

      mapper=mapper_create(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 63, (const void *)"mapper = mapper_create(map)");
      }

      else
      {
        do
        {
          return_value_mapper_has_next$257=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next$257 == 1))
            break;

          void *main$$1$$4$$1$$1$$item;
          main$$1$$4$$1$$1$$item=mapper_next(mapper);
          if(main$$1$$4$$1$$1$$item == NULL)
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 64, (const void *)"item = mapper_next(mapper)");
          }

          mapper_remove(mapper);
        }
        while((_Bool)1);
        mapper_destroy(&mapper);
        if(!(mapper == ((struct Mapper *)NULL)))
        {
          errors = errors + 1;
          printf("Test65: mapper_destroy(&mapper) failed (%p, not NULL)\n", (void *)mapper);
        }

        signed long int return_value_map_size$258;
        return_value_map_size$258=map_size(map);
        val = (signed int)return_value_map_size$258;
        if(!(val == 0))
        {
          errors = errors + 1;
          printf("Test%d: %s failed (returned %d, not %d)\n", 66, (const void *)"map_size(map)", val, 0);
        }

      }
      map_destroy(&map);
      if(!(map == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test67: map_destroy(&map) failed (%p, not NULL)\n", (void *)map);
      }

    }
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 68, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add$259;
      return_value_map_add$259=map_add(map, (const void *)"1", (void *)"1");
      if(!(return_value_map_add$259 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 69, (const void *)"map_add(map, \"1\", \"1\") == 0");
      }

      signed int return_value_map_add$260;
      return_value_map_add$260=map_add(map, (const void *)"2", (void *)"2");
      if(!(return_value_map_add$260 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 70, (const void *)"map_add(map, \"2\", \"2\") == 0");
      }

      signed int return_value_map_add$261;
      return_value_map_add$261=map_add(map, (const void *)"3", (void *)"3");
      if(!(return_value_map_add$261 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 71, (const void *)"map_add(map, \"3\", \"3\") == 0");
      }

      signed int return_value_map_add$262;
      return_value_map_add$262=map_add(map, (const void *)"4", (void *)"4");
      if(!(return_value_map_add$262 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 72, (const void *)"map_add(map, \"4\", \"4\") == 0");
      }

      do
      {
        return_value_map_has_next$263=map_has_next(map);
        if(!(return_value_map_has_next$263 == 1))
          break;

        void *main$$1$$5$$1$$item;
        main$$1$$5$$1$$item=map_next(map);
        if(main$$1$$5$$1$$item == NULL)
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 73, (const void *)"item = map_next(map)");
        }

        map_remove_current(map);
      }
      while((_Bool)1);
      signed long int return_value_map_size$264;
      return_value_map_size$264=map_size(map);
      val = (signed int)return_value_map_size$264;
      if(!(val == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 74, (const void *)"map_size(map)", val, 0);
      }

      mapper_destroy(&mapper);
      map_destroy(&map);
    }
    map=map_create_generic((void * (*)(const void *))point_copy, (signed int (*)(const void *, const void *))point_cmp, (unsigned long int (*)(unsigned long int, const void *))point_hash, (void (*)(void *))point_release, (void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 75, (const void *)"map = map_create_generic((map_copy_t *)point_copy, (map_cmp_t *)point_cmp, (map_hash_t *)point_hash, (map_release_t *)point_release, NULL)");
    }

    else
    {
      struct Point *point;
      point=point_create(0, 0);
      point->x = 0;
      point->y = 0;
      signed int return_value_map_add$265;
      return_value_map_add$265=map_add(map, (const void *)point, (void *)"(0, 0)");
      if(!(return_value_map_add$265 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 76, (const void *)"map_add(map, point, (\"(0, 0)\")) == (0)");
      }

      point->x = 1;
      point->y = 0;
      signed int return_value_map_add$266;
      return_value_map_add$266=map_add(map, (const void *)point, (void *)"(1, 0)");
      if(!(return_value_map_add$266 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 77, (const void *)"map_add(map, point, (\"(1, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = 1;
      signed int return_value_map_add$267;
      return_value_map_add$267=map_add(map, (const void *)point, (void *)"(0, 1)");
      if(!(return_value_map_add$267 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 78, (const void *)"map_add(map, point, (\"(0, 1)\")) == (0)");
      }

      point->x = 1;
      point->y = 1;
      signed int return_value_map_add$268;
      return_value_map_add$268=map_add(map, (const void *)point, (void *)"(1, 1)");
      if(!(return_value_map_add$268 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 79, (const void *)"map_add(map, point, (\"(1, 1)\")) == (0)");
      }

      point->x = -1;
      point->y = 0;
      signed int return_value_map_add$269;
      return_value_map_add$269=map_add(map, (const void *)point, (void *)"(-1, 0)");
      if(!(return_value_map_add$269 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 80, (const void *)"map_add(map, point, (\"(-1, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = -1;
      signed int return_value_map_add$270;
      return_value_map_add$270=map_add(map, (const void *)point, (void *)"(0, -1)");
      if(!(return_value_map_add$270 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 81, (const void *)"map_add(map, point, (\"(0, -1)\")) == (0)");
      }

      point->x = -1;
      point->y = -1;
      signed int return_value_map_add$271;
      return_value_map_add$271=map_add(map, (const void *)point, (void *)"(-1, -1)");
      if(!(return_value_map_add$271 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 82, (const void *)"map_add(map, point, (\"(-1, -1)\")) == (0)");
      }

      point->x = 2;
      point->y = 0;
      signed int return_value_map_add$272;
      return_value_map_add$272=map_add(map, (const void *)point, (void *)"(2, 0)");
      if(!(return_value_map_add$272 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 83, (const void *)"map_add(map, point, (\"(2, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = 2;
      signed int return_value_map_add$273;
      return_value_map_add$273=map_add(map, (const void *)point, (void *)"(0, 2)");
      if(!(return_value_map_add$273 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 84, (const void *)"map_add(map, point, (\"(0, 2)\")) == (0)");
      }

      point->x = 2;
      point->y = 2;
      signed int return_value_map_add$274;
      return_value_map_add$274=map_add(map, (const void *)point, (void *)"(2, 2)");
      if(!(return_value_map_add$274 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 85, (const void *)"map_add(map, point, (\"(2, 2)\")) == (0)");
      }

      point->x = -2;
      point->y = 0;
      signed int return_value_map_add$275;
      return_value_map_add$275=map_add(map, (const void *)point, (void *)"(-2, 0)");
      if(!(return_value_map_add$275 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 86, (const void *)"map_add(map, point, (\"(-2, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = -2;
      signed int return_value_map_add$276;
      return_value_map_add$276=map_add(map, (const void *)point, (void *)"(0, -2)");
      if(!(return_value_map_add$276 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 87, (const void *)"map_add(map, point, (\"(0, -2)\")) == (0)");
      }

      point->x = -2;
      point->y = -2;
      signed int return_value_map_add$277;
      return_value_map_add$277=map_add(map, (const void *)point, (void *)"(-2, -2)");
      if(!(return_value_map_add$277 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 88, (const void *)"map_add(map, point, (\"(-2, -2)\")) == (0)");
      }

      point->x = 0;
      point->y = 0;
      signed int return_value_map_add$278;
      return_value_map_add$278=map_add(map, (const void *)point, (void *)"(0, 0)");
      if(!(return_value_map_add$278 == -1))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 89, (const void *)"map_add(map, point, (\"(0, 0)\")) == (-1)");
      }

      signed long int return_value_map_size$279;
      return_value_map_size$279=map_size(map);
      val = (signed int)return_value_map_size$279;
      if(!(val == 13))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 90, (const void *)"map_size(map)", val, 13);
      }

      point->x = 0;
      point->y = 0;
      void *return_value_map_get$281;
      return_value_map_get$281=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$281;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 91);
      }

      else
      {
        return_value_strcmp$280=strcmp(value, "(0, 0)");
        if(!(return_value_strcmp$280 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 91, value, (const void *)"(0, 0)");
        }

      }
      point->x = 1;
      point->y = 0;
      void *return_value_map_get$283;
      return_value_map_get$283=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$283;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 92);
      }

      else
      {
        return_value_strcmp$282=strcmp(value, "(1, 0)");
        if(!(return_value_strcmp$282 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 92, value, (const void *)"(1, 0)");
        }

      }
      point->x = 0;
      point->y = 1;
      void *return_value_map_get$285;
      return_value_map_get$285=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$285;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 93);
      }

      else
      {
        return_value_strcmp$284=strcmp(value, "(0, 1)");
        if(!(return_value_strcmp$284 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 93, value, (const void *)"(0, 1)");
        }

      }
      point->x = 1;
      point->y = 1;
      void *return_value_map_get$287;
      return_value_map_get$287=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$287;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 94);
      }

      else
      {
        return_value_strcmp$286=strcmp(value, "(1, 1)");
        if(!(return_value_strcmp$286 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 94, value, (const void *)"(1, 1)");
        }

      }
      point->x = -1;
      point->y = 0;
      void *return_value_map_get$289;
      return_value_map_get$289=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$289;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 95);
      }

      else
      {
        return_value_strcmp$288=strcmp(value, "(-1, 0)");
        if(!(return_value_strcmp$288 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 95, value, (const void *)"(-1, 0)");
        }

      }
      point->x = 0;
      point->y = -1;
      void *return_value_map_get$291;
      return_value_map_get$291=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$291;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 96);
      }

      else
      {
        return_value_strcmp$290=strcmp(value, "(0, -1)");
        if(!(return_value_strcmp$290 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 96, value, (const void *)"(0, -1)");
        }

      }
      point->x = -1;
      point->y = -1;
      void *return_value_map_get$293;
      return_value_map_get$293=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$293;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 97);
      }

      else
      {
        return_value_strcmp$292=strcmp(value, "(-1, -1)");
        if(!(return_value_strcmp$292 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 97, value, (const void *)"(-1, -1)");
        }

      }
      point->x = 2;
      point->y = 0;
      void *return_value_map_get$295;
      return_value_map_get$295=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$295;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 98);
      }

      else
      {
        return_value_strcmp$294=strcmp(value, "(2, 0)");
        if(!(return_value_strcmp$294 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 98, value, (const void *)"(2, 0)");
        }

      }
      point->x = 0;
      point->y = 2;
      void *return_value_map_get$297;
      return_value_map_get$297=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$297;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 99);
      }

      else
      {
        return_value_strcmp$296=strcmp(value, "(0, 2)");
        if(!(return_value_strcmp$296 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 99, value, (const void *)"(0, 2)");
        }

      }
      point->x = 2;
      point->y = 2;
      void *return_value_map_get$299;
      return_value_map_get$299=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$299;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 100);
      }

      else
      {
        return_value_strcmp$298=strcmp(value, "(2, 2)");
        if(!(return_value_strcmp$298 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 100, value, (const void *)"(2, 2)");
        }

      }
      point->x = -2;
      point->y = 0;
      void *return_value_map_get$301;
      return_value_map_get$301=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$301;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 101);
      }

      else
      {
        return_value_strcmp$300=strcmp(value, "(-2, 0)");
        if(!(return_value_strcmp$300 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 101, value, (const void *)"(-2, 0)");
        }

      }
      point->x = 0;
      point->y = -2;
      void *return_value_map_get$303;
      return_value_map_get$303=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$303;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 102);
      }

      else
      {
        return_value_strcmp$302=strcmp(value, "(0, -2)");
        if(!(return_value_strcmp$302 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 102, value, (const void *)"(0, -2)");
        }

      }
      point->x = -2;
      point->y = -2;
      void *return_value_map_get$305;
      return_value_map_get$305=map_get(map, (const void *)point);
      value = (char *)return_value_map_get$305;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 103);
      }

      else
      {
        return_value_strcmp$304=strcmp(value, "(-2, -2)");
        if(!(return_value_strcmp$304 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 103, value, (const void *)"(-2, -2)");
        }

      }
      point_release(point);
      map_destroy(&map);
    }
    map=map_create_generic((void * (*)(const void *))direct_copy, (signed int (*)(const void *, const void *))direct_cmp, (unsigned long int (*)(unsigned long int, const void *))direct_hash, (void (*)(void *))(void *)0, (void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 104, (const void *)"map = map_create_generic((map_copy_t *)direct_copy, (map_cmp_t *)direct_cmp, (map_hash_t *)direct_hash, NULL, NULL)");
    }

    else
    {
      signed int return_value_map_add$306;
      return_value_map_add$306=map_add(map, (void *)1, (void *)1);
      if(!(return_value_map_add$306 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 105, (const void *)"map_add(map, (void *)1, (void *)1) == 0");
      }

      signed int return_value_map_add$307;
      return_value_map_add$307=map_add(map, (void *)2, (void *)2);
      if(!(return_value_map_add$307 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 106, (const void *)"map_add(map, (void *)2, (void *)2) == 0");
      }

      signed int return_value_map_add$308;
      return_value_map_add$308=map_add(map, (void *)3, (void *)3);
      if(!(return_value_map_add$308 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 107, (const void *)"map_add(map, (void *)3, (void *)3) == 0");
      }

      signed int return_value_map_add$309;
      return_value_map_add$309=map_add(map, (void *)4, (void *)4);
      if(!(return_value_map_add$309 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 108, (const void *)"map_add(map, (void *)4, (void *)4) == 0");
      }

      signed int return_value_map_add$310;
      return_value_map_add$310=map_add(map, (void *)5, (void *)5);
      if(!(return_value_map_add$310 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 109, (const void *)"map_add(map, (void *)5, (void *)5) == 0");
      }

      signed int return_value_map_add$311;
      return_value_map_add$311=map_add(map, (void *)6, (void *)6);
      if(!(return_value_map_add$311 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 110, (const void *)"map_add(map, (void *)6, (void *)6) == 0");
      }

      signed int return_value_map_add$312;
      return_value_map_add$312=map_add(map, (void *)7, (void *)7);
      if(!(return_value_map_add$312 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 111, (const void *)"map_add(map, (void *)7, (void *)7) == 0");
      }

      signed int return_value_map_add$313;
      return_value_map_add$313=map_add(map, (void *)8, (void *)8);
      if(!(return_value_map_add$313 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 112, (const void *)"map_add(map, (void *)8, (void *)8) == 0");
      }

      signed int return_value_map_add$314;
      return_value_map_add$314=map_add(map, (void *)9, (void *)9);
      if(!(return_value_map_add$314 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 113, (const void *)"map_add(map, (void *)9, (void *)9) == 0");
      }

      signed int return_value_map_add$315;
      return_value_map_add$315=map_add(map, (void *)10, (void *)10);
      if(!(return_value_map_add$315 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 114, (const void *)"map_add(map, (void *)10, (void *)10) == 0");
      }

      signed int return_value_map_add$316;
      return_value_map_add$316=map_add(map, (void *)11, (void *)11);
      if(!(return_value_map_add$316 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 115, (const void *)"map_add(map, (void *)11, (void *)11) == 0");
      }

      signed int return_value_map_add$317;
      return_value_map_add$317=map_add(map, (void *)12, (void *)12);
      if(!(return_value_map_add$317 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 116, (const void *)"map_add(map, (void *)12, (void *)12) == 0");
      }

      signed int return_value_map_add$318;
      return_value_map_add$318=map_add(map, (void *)13, (void *)13);
      if(!(return_value_map_add$318 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 117, (const void *)"map_add(map, (void *)13, (void *)13) == 0");
      }

      signed int return_value_map_add$319;
      return_value_map_add$319=map_add(map, (void *)14, (void *)14);
      if(!(return_value_map_add$319 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 118, (const void *)"map_add(map, (void *)14, (void *)14) == 0");
      }

      signed int return_value_map_add$320;
      return_value_map_add$320=map_add(map, (void *)15, (void *)15);
      if(!(return_value_map_add$320 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 119, (const void *)"map_add(map, (void *)15, (void *)15) == 0");
      }

      signed int return_value_map_add$321;
      return_value_map_add$321=map_add(map, (void *)16, (void *)16);
      if(!(return_value_map_add$321 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 120, (const void *)"map_add(map, (void *)16, (void *)16) == 0");
      }

      signed int return_value_map_add$322;
      return_value_map_add$322=map_add(map, (void *)17, (void *)17);
      if(!(return_value_map_add$322 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 121, (const void *)"map_add(map, (void *)17, (void *)17) == 0");
      }

      signed int return_value_map_add$323;
      return_value_map_add$323=map_add(map, (void *)18, (void *)18);
      if(!(return_value_map_add$323 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 122, (const void *)"map_add(map, (void *)18, (void *)18) == 0");
      }

      signed int return_value_map_add$324;
      return_value_map_add$324=map_add(map, (void *)19, (void *)19);
      if(!(return_value_map_add$324 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 123, (const void *)"map_add(map, (void *)19, (void *)19) == 0");
      }

      signed int return_value_map_add$325;
      return_value_map_add$325=map_add(map, (void *)20, (void *)20);
      if(!(return_value_map_add$325 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 124, (const void *)"map_add(map, (void *)20, (void *)20) == 0");
      }

      signed int return_value_map_add$326;
      return_value_map_add$326=map_add(map, (void *)21, (void *)21);
      if(!(return_value_map_add$326 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 125, (const void *)"map_add(map, (void *)21, (void *)21) == 0");
      }

      signed int return_value_map_add$327;
      return_value_map_add$327=map_add(map, (void *)22, (void *)22);
      if(!(return_value_map_add$327 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 126, (const void *)"map_add(map, (void *)22, (void *)22) == 0");
      }

      signed int return_value_map_add$328;
      return_value_map_add$328=map_add(map, (void *)23, (void *)23);
      if(!(return_value_map_add$328 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 127, (const void *)"map_add(map, (void *)23, (void *)23) == 0");
      }

      signed int return_value_map_add$329;
      return_value_map_add$329=map_add(map, (void *)24, (void *)24);
      if(!(return_value_map_add$329 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 128, (const void *)"map_add(map, (void *)24, (void *)24) == 0");
      }

      signed int return_value_map_add$330;
      return_value_map_add$330=map_add(map, (void *)25, (void *)25);
      if(!(return_value_map_add$330 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 129, (const void *)"map_add(map, (void *)25, (void *)25) == 0");
      }

      signed int return_value_map_add$331;
      return_value_map_add$331=map_add(map, (void *)25, (void *)25);
      if(return_value_map_add$331 == 0)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 130, (const void *)"map_add(map, (void *)25, (void *)25) != 0");
      }

      signed long int return_value_map_size$332;
      return_value_map_size$332=map_size(map);
      val = (signed int)return_value_map_size$332;
      if(!(val == 25))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 130, (const void *)"map_size(map)", val, 25);
      }

      void *return_value_map_get$333;
      return_value_map_get$333=map_get(map, (void *)1);
      val = (signed int)(signed long int)return_value_map_get$333;
      if(!(val == 1))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 131, (const void *)"(int)(long)map_get(map, (void *)1)", val, 1);
      }

      void *return_value_map_get$334;
      return_value_map_get$334=map_get(map, (void *)2);
      val = (signed int)(signed long int)return_value_map_get$334;
      if(!(val == 2))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 132, (const void *)"(int)(long)map_get(map, (void *)2)", val, 2);
      }

      void *return_value_map_get$335;
      return_value_map_get$335=map_get(map, (void *)3);
      val = (signed int)(signed long int)return_value_map_get$335;
      if(!(val == 3))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 133, (const void *)"(int)(long)map_get(map, (void *)3)", val, 3);
      }

      void *return_value_map_get$336;
      return_value_map_get$336=map_get(map, (void *)4);
      val = (signed int)(signed long int)return_value_map_get$336;
      if(!(val == 4))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 134, (const void *)"(int)(long)map_get(map, (void *)4)", val, 4);
      }

      void *return_value_map_get$337;
      return_value_map_get$337=map_get(map, (void *)5);
      val = (signed int)(signed long int)return_value_map_get$337;
      if(!(val == 5))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 135, (const void *)"(int)(long)map_get(map, (void *)5)", val, 5);
      }

      void *return_value_map_get$338;
      return_value_map_get$338=map_get(map, (void *)6);
      val = (signed int)(signed long int)return_value_map_get$338;
      if(!(val == 6))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 136, (const void *)"(int)(long)map_get(map, (void *)6)", val, 6);
      }

      void *return_value_map_get$339;
      return_value_map_get$339=map_get(map, (void *)7);
      val = (signed int)(signed long int)return_value_map_get$339;
      if(!(val == 7))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 137, (const void *)"(int)(long)map_get(map, (void *)7)", val, 7);
      }

      void *return_value_map_get$340;
      return_value_map_get$340=map_get(map, (void *)8);
      val = (signed int)(signed long int)return_value_map_get$340;
      if(!(val == 8))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 138, (const void *)"(int)(long)map_get(map, (void *)8)", val, 8);
      }

      void *return_value_map_get$341;
      return_value_map_get$341=map_get(map, (void *)9);
      val = (signed int)(signed long int)return_value_map_get$341;
      if(!(val == 9))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 139, (const void *)"(int)(long)map_get(map, (void *)9)", val, 9);
      }

      void *return_value_map_get$342;
      return_value_map_get$342=map_get(map, (void *)10);
      val = (signed int)(signed long int)return_value_map_get$342;
      if(!(val == 10))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 140, (const void *)"(int)(long)map_get(map, (void *)10)", val, 10);
      }

      void *return_value_map_get$343;
      return_value_map_get$343=map_get(map, (void *)11);
      val = (signed int)(signed long int)return_value_map_get$343;
      if(!(val == 11))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 141, (const void *)"(int)(long)map_get(map, (void *)11)", val, 11);
      }

      void *return_value_map_get$344;
      return_value_map_get$344=map_get(map, (void *)12);
      val = (signed int)(signed long int)return_value_map_get$344;
      if(!(val == 12))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 142, (const void *)"(int)(long)map_get(map, (void *)12)", val, 12);
      }

      void *return_value_map_get$345;
      return_value_map_get$345=map_get(map, (void *)13);
      val = (signed int)(signed long int)return_value_map_get$345;
      if(!(val == 13))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 143, (const void *)"(int)(long)map_get(map, (void *)13)", val, 13);
      }

      void *return_value_map_get$346;
      return_value_map_get$346=map_get(map, (void *)14);
      val = (signed int)(signed long int)return_value_map_get$346;
      if(!(val == 14))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 144, (const void *)"(int)(long)map_get(map, (void *)14)", val, 14);
      }

      void *return_value_map_get$347;
      return_value_map_get$347=map_get(map, (void *)15);
      val = (signed int)(signed long int)return_value_map_get$347;
      if(!(val == 15))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 145, (const void *)"(int)(long)map_get(map, (void *)15)", val, 15);
      }

      void *return_value_map_get$348;
      return_value_map_get$348=map_get(map, (void *)16);
      val = (signed int)(signed long int)return_value_map_get$348;
      if(!(val == 16))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 146, (const void *)"(int)(long)map_get(map, (void *)16)", val, 16);
      }

      void *return_value_map_get$349;
      return_value_map_get$349=map_get(map, (void *)17);
      val = (signed int)(signed long int)return_value_map_get$349;
      if(!(val == 17))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 147, (const void *)"(int)(long)map_get(map, (void *)17)", val, 17);
      }

      void *return_value_map_get$350;
      return_value_map_get$350=map_get(map, (void *)18);
      val = (signed int)(signed long int)return_value_map_get$350;
      if(!(val == 18))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 148, (const void *)"(int)(long)map_get(map, (void *)18)", val, 18);
      }

      void *return_value_map_get$351;
      return_value_map_get$351=map_get(map, (void *)19);
      val = (signed int)(signed long int)return_value_map_get$351;
      if(!(val == 19))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 149, (const void *)"(int)(long)map_get(map, (void *)19)", val, 19);
      }

      void *return_value_map_get$352;
      return_value_map_get$352=map_get(map, (void *)20);
      val = (signed int)(signed long int)return_value_map_get$352;
      if(!(val == 20))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 150, (const void *)"(int)(long)map_get(map, (void *)20)", val, 20);
      }

      void *return_value_map_get$353;
      return_value_map_get$353=map_get(map, (void *)21);
      val = (signed int)(signed long int)return_value_map_get$353;
      if(!(val == 21))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 151, (const void *)"(int)(long)map_get(map, (void *)21)", val, 21);
      }

      void *return_value_map_get$354;
      return_value_map_get$354=map_get(map, (void *)22);
      val = (signed int)(signed long int)return_value_map_get$354;
      if(!(val == 22))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 152, (const void *)"(int)(long)map_get(map, (void *)22)", val, 22);
      }

      void *return_value_map_get$355;
      return_value_map_get$355=map_get(map, (void *)23);
      val = (signed int)(signed long int)return_value_map_get$355;
      if(!(val == 23))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 153, (const void *)"(int)(long)map_get(map, (void *)23)", val, 23);
      }

      void *return_value_map_get$356;
      return_value_map_get$356=map_get(map, (void *)24);
      val = (signed int)(signed long int)return_value_map_get$356;
      if(!(val == 24))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 154, (const void *)"(int)(long)map_get(map, (void *)24)", val, 24);
      }

      void *return_value_map_get$357;
      return_value_map_get$357=map_get(map, (void *)25);
      val = (signed int)(signed long int)return_value_map_get$357;
      if(!(val == 25))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 155, (const void *)"(int)(long)map_get(map, (void *)25)", val, 25);
      }

      map_destroy(&map);
    }
    if(ac == 2)
    {
      return_value_strcmp$358=strcmp(av[(signed long int)1], "debug");
      tmp_if_expr$359 = !(return_value_strcmp$358 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$359 = (_Bool)0;
    debug = (signed int)tmp_if_expr$359;
    if(!(debug == 0))
      setbuf(stdout, (char *)(void *)0);

    if(!(debug == 0))
      locker=locker_create_debug_rwlock(&rwlock);

    else
      locker=locker_create_rwlock(&rwlock);
    if(locker == ((struct Locker *)NULL))
    {
      errors = errors + 1;
      printf("Test220: locker_create_rwlock() failed\n");
    }

    else
    {
      mt_test(220, locker);
      locker_destroy(&locker);
    }
    if(!(debug == 0))
      locker=locker_create_debug_mutex(&mutex);

    else
      locker=locker_create_mutex(&mutex);
    if(locker == ((struct Locker *)NULL))
    {
      errors = errors + 1;
      printf("Test221: locker_create_mutex() failed\n");
    }

    else
    {
      mt_test(221, locker);
      locker_destroy(&locker);
    }
    memset((void *)&ptr, 0, sizeof(void *) /*8ul*/ );
    if(!(ptr == NULL))
    {
      errors = errors + 1;
      printf("Test223: assumption failed: memset(&ptr, 0, sizeof(void *)) not same as NULL\n");
    }

    if(!(errors == 0))
      printf("%d/223 tests failed\n", errors);

    else
      printf("All tests passed\n");
    return errors == 0 ? 0 : 1;
  }
}

// map_add
// file libslack/map.h line 62
signed int map_add(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert$1;
  return_value_map_insert$1=map_insert(map, key, value, 0);
  return return_value_map_insert$1;
}

// map_add_unlocked
// file libslack/map.c line 887
signed int map_add_unlocked(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert_unlocked$1;
  return_value_map_insert_unlocked$1=map_insert_unlocked(map, key, value, 0);
  return return_value_map_insert_unlocked$1;
}

// map_apply
// file libslack/map.h line 99
void map_apply(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  map_apply_wrlocked(map, action, data);
}

// map_apply_rdlocked
// file libslack/map.c line 1907
void map_apply_rdlocked(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value_1;
  if(action == ((void (*)(void *, void *, void *))NULL) || map == ((struct Map *)NULL))
    set_errno(22);

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }

    else
      tmp_if_expr$2 = 22;
    err = tmp_if_expr$2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      map_apply_unlocked(map, action, data);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$3 = return_value_1;
        }

        else
          tmp_if_expr$3 = 0;
        tmp_if_expr$4 = tmp_if_expr$3;
      }

      else
        tmp_if_expr$4 = 22;
      err = tmp_if_expr$4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// map_apply_unlocked
// file libslack/map.c line 1978
void map_apply_unlocked(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  struct Mapper *mapper;
  if(action == ((void (*)(void *, void *, void *))NULL) || map == ((struct Map *)NULL))
    set_errno(22);

  else
  {
    mapper=mapper_create_unlocked(map);
    if(!(mapper == ((struct Mapper *)NULL)))
    {
      signed int return_value_mapper_has_next$1;
      return_value_mapper_has_next$1=mapper_has_next(mapper);
      if(return_value_mapper_has_next$1 == 1)
      {
        const struct Mapping *mapping;
        mapping=mapper_next_mapping(mapper);
        action(mapping->key, mapping->value, data);
      }

      mapper_release_unlocked(mapper);
    }

  }
}

// map_apply_wrlocked
// file libslack/map.c line 1943
void map_apply_wrlocked(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value_1;
  if(action == ((void (*)(void *, void *, void *))NULL) || map == ((struct Map *)NULL))
    set_errno(22);

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }

    else
      tmp_if_expr$2 = 22;
    err = tmp_if_expr$2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      map_apply_unlocked(map, action, data);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$3 = return_value_1;
        }

        else
          tmp_if_expr$3 = 0;
        tmp_if_expr$4 = tmp_if_expr$3;
      }

      else
        tmp_if_expr$4 = 22;
      err = tmp_if_expr$4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// map_break
// file libslack/map.h line 85
void map_break(struct Map *map)
{
  if(map == ((struct Map *)NULL))
    set_errno(22);

  else
    mapper_destroy_unlocked(&map->mapper);
}

// map_create
// file libslack/map.h line 41
struct Map * map_create(void (*destroy)(void *))
{
  struct Map *return_value_map_create_sized_with_hash$1;
  return_value_map_create_sized_with_hash$1=map_create_sized_with_hash(table_sizes[(signed long int)0], (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_sized_with_hash$1;
}

// map_create_generic
// file libslack/map.h line 49
struct Map * map_create_generic(void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized$1;
  return_value_map_create_generic_with_locker_sized$1=map_create_generic_with_locker_sized((struct Locker *)(void *)0, table_sizes[(signed long int)0], copy, cmp, hash, key_destroy, value_destroy);
  return return_value_map_create_generic_with_locker_sized$1;
}

// map_create_generic_sized
// file libslack/map.c line 450
struct Map * map_create_generic_sized(unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized$1;
  return_value_map_create_generic_with_locker_sized$1=map_create_generic_with_locker_sized((struct Locker *)(void *)0, size, copy, cmp, hash, key_destroy, value_destroy);
  return return_value_map_create_generic_with_locker_sized$1;
}

// map_create_generic_with_locker
// file libslack/map.h line 51
struct Map * map_create_generic_with_locker(struct Locker *locker, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized$1;
  return_value_map_create_generic_with_locker_sized$1=map_create_generic_with_locker_sized(locker, table_sizes[(signed long int)0], copy, cmp, hash, key_destroy, value_destroy);
  return return_value_map_create_generic_with_locker_sized$1;
}

// map_create_generic_with_locker_sized
// file libslack/map.c line 482
struct Map * map_create_generic_with_locker_sized(struct Locker *locker, unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *map;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= num_table_sizes); i = i + 1ul)
    if(table_sizes[(signed long int)i] >= size)
    {
      size = table_sizes[(signed long int)i];
      break;
    }

  void *return_value_set_errnull$1;
  if(i == num_table_sizes)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Map *)return_value_set_errnull$1;
  }

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct Map) /*80ul*/ );
    map = (struct Map *)return_value_malloc$2;
    if(map == ((struct Map *)NULL))
      return (struct Map *)(void *)0;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(size * sizeof(struct List *) /*8ul*/ );
      map->chain = (struct List **)return_value_malloc$3;
      if(map->chain == ((struct List **)NULL))
      {
        free((void *)map);
        return (struct Map *)(void *)0;
      }

      else
      {
        map->size = size;
        map->items = (unsigned long int)0;
        memset((void *)map->chain, 0, map->size * sizeof(struct List *) /*8ul*/ );
        map->hash = hash;
        map->copy = copy;
        map->cmp = cmp;
        map->key_destroy = key_destroy;
        map->value_destroy = value_destroy;
        map->mapper = (struct Mapper *)(void *)0;
        map->locker = locker;
        return map;
      }
    }
  }
}

// map_create_sized
// file libslack/map.c line 306
struct Map * map_create_sized(unsigned long int size, void (*destroy)(void *))
{
  struct Map *return_value_map_create_sized_with_hash$1;
  return_value_map_create_sized_with_hash$1=map_create_sized_with_hash(size, (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_sized_with_hash$1;
}

// map_create_sized_with_hash
// file libslack/map.c line 342
struct Map * map_create_sized_with_hash(unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_generic_sized$1;
  return_value_map_create_generic_sized$1=map_create_generic_sized(size, (void * (*)(const void *))mem_strdup, (signed int (*)(const void *, const void *))strcmp, hash, (void (*)(void *))free, destroy);
  return return_value_map_create_generic_sized$1;
}

// map_create_with_hash
// file libslack/map.c line 324
struct Map * map_create_with_hash(unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_sized_with_hash$1;
  return_value_map_create_sized_with_hash$1=map_create_sized_with_hash(table_sizes[(signed long int)0], hash, destroy);
  return return_value_map_create_sized_with_hash$1;
}

// map_create_with_locker
// file libslack/map.c line 358
struct Map * map_create_with_locker(struct Locker *locker, void (*destroy)(void *))
{
  struct Map *return_value_map_create_with_locker_sized_with_hash$1;
  return_value_map_create_with_locker_sized_with_hash$1=map_create_with_locker_sized_with_hash(locker, table_sizes[(signed long int)0], (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_with_locker_sized_with_hash$1;
}

// map_create_with_locker_sized
// file libslack/map.c line 374
struct Map * map_create_with_locker_sized(struct Locker *locker, unsigned long int size, void (*destroy)(void *))
{
  struct Map *return_value_map_create_with_locker_sized_with_hash$1;
  return_value_map_create_with_locker_sized_with_hash$1=map_create_with_locker_sized_with_hash(locker, size, (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_with_locker_sized_with_hash$1;
}

// map_create_with_locker_sized_with_hash
// file libslack/map.c line 406
struct Map * map_create_with_locker_sized_with_hash(struct Locker *locker, unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized$1;
  return_value_map_create_generic_with_locker_sized$1=map_create_generic_with_locker_sized(locker, size, (void * (*)(const void *))mem_strdup, (signed int (*)(const void *, const void *))strcmp, hash, (void (*)(void *))free, destroy);
  return return_value_map_create_generic_with_locker_sized$1;
}

// map_create_with_locker_with_hash
// file libslack/map.c line 390
struct Map * map_create_with_locker_with_hash(struct Locker *locker, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_with_locker_sized_with_hash$1;
  return_value_map_create_with_locker_sized_with_hash$1=map_create_with_locker_sized_with_hash(locker, table_sizes[(signed long int)0], hash, destroy);
  return return_value_map_create_with_locker_sized_with_hash$1;
}

// map_destroy
// file libslack/map.h line 57
void * map_destroy(struct Map **map)
{
  if(!(map == ((struct Map **)NULL)))
  {
    if(!(*map == ((struct Map *)NULL)))
    {
      map_release(*map);
      *map = (struct Map *)(void *)0;
    }

  }

  return (void *)0;
}

// map_disown
// file libslack/map.c line 721
void (*map_disown(struct Map *map))(void *)
{
  void (*ret)(void *);
  signed int err;
  void (*return_value_set_errnullf$1)();
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void (*return_value_set_errnullf$2)();
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void (*return_value_set_errnullf$5)();
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnullf$1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnullf$2=set_errnullf(err);
      return (void (*)(void *))return_value_set_errnullf$2;
    }

    else
    {
      ret=map_disown_unlocked(map);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnullf$5=set_errnullf(err);
        return (void (*)(void *))return_value_set_errnullf$5;
      }

      else
        return ret;
    }
  }
}

// map_disown_unlocked
// file libslack/map.c line 750
void (*map_disown_unlocked(struct Map *map))(void *)
{
  signed long int length;
  unsigned long int c;
  unsigned long int i;
  void (*destroy)(void *);
  void (*return_value_set_errnullf$1)();
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnullf$1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf$1;
  }

  else
    if(map->value_destroy == ((void (*)(void *))NULL))
      return (void (*)(void *))(void *)0;

    else
    {
      destroy = map->value_destroy;
      map->value_destroy = (void (*)(void *))(void *)0;
      c = (unsigned long int)0;
      for( ; !(c >= map->size); c = c + 1ul)
      {
        struct List *chain = map->chain[(signed long int)c];
        if(!(chain == ((struct List *)NULL)))
        {
          length=list_length_unlocked(chain);
          if(length == -1l)
            return (void (*)(void *))(void *)0;

          i = (unsigned long int)0;
          for( ; !(i >= (unsigned long int)length); i = i + 1ul)
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked$2;
            return_value_list_item_unlocked$2=list_item_unlocked(chain, (signed long int)i);
            mapping = (struct Mapping *)return_value_list_item_unlocked$2;
            mapping->value_destroy = (void (*)(void *))(void *)0;
          }
        }

      }
      return destroy;
    }
}

// map_get
// file libslack/map.h line 70
void * map_get(struct Map *map, const void *key)
{
  void *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return return_value_set_errnull$2;
    }

    else
    {
      ret=map_get_unlocked(map, key);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// map_get_unlocked
// file libslack/map.h line 71
void * map_get_unlocked(const struct Map *map, const void *key)
{
  struct List *chain;
  signed long int length;
  unsigned long int h;
  unsigned long int c;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  if(key == NULL || map == ((const struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    h=map->hash(map->size, key);
    if(h >= map->size)
    {
      return_value_set_errnull$2=set_errnull(22);
      return return_value_set_errnull$2;
    }

    else
    {
      chain = map->chain[(signed long int)h];
      if(chain == ((struct List *)NULL))
      {
        return_value_set_errnull$3=set_errnull(2);
        return return_value_set_errnull$3;
      }

      else
      {
        length=list_length_unlocked(chain);
        if(length == -1l)
          return (void *)0;

        else
        {
          c = (unsigned long int)0;
          if(!(c >= (unsigned long int)length))
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked$4;
            return_value_list_item_unlocked$4=list_item_unlocked(chain, (signed long int)c);
            mapping = (struct Mapping *)return_value_list_item_unlocked$4;
            signed int return_value;
            return_value=map->cmp(mapping->key, key);
            if(return_value == 0)
              return mapping->value;

            c = c + 1ul;
          }

          void *return_value_set_errnull$5;
          return_value_set_errnull$5=set_errnull(2);
          return return_value_set_errnull$5;
        }
      }
    }
  }
}

// map_has_next
// file libslack/map.h line 84
signed int map_has_next(struct Map *map)
{
  signed int has;
  signed int return_value_set_errno$1;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if(map->mapper == ((struct Mapper *)NULL))
    {
      map->mapper=mapper_create_unlocked(map);
      if(!(map->mapper == ((struct Mapper *)NULL)))
        goto __CPROVER_DUMP_L2;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      has=mapper_has_next(map->mapper);
      if(!(has == 1))
        map_break(map);

      return has;
    }
}

// map_histogram
// file libslack/map.c line 2306
static void map_histogram(const char *name, struct Map *map)
{
  unsigned long int i;
  signed int *histogram;
  if(map == ((struct Map *)NULL))
    printf("%s = nil\n", name);

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(map->items * sizeof(signed int) /*4ul*/ );
    histogram = (signed int *)return_value_malloc$1;
    if(histogram == ((signed int *)NULL))
      printf("Failed to allocate histogram for map %s\n", name);

    else
    {
      memset((void *)histogram, 0, map->items * sizeof(signed int) /*4ul*/ );
      i = (unsigned long int)0;
      for( ; !(i >= map->size); i = i + 1ul)
      {
        unsigned long int length;
        signed long int return_value_list_length$2;
        return_value_list_length$2=list_length(map->chain[(signed long int)i]);
        length = (unsigned long int)return_value_list_length$2;
        if(length == 18446744073709551615ul)
          printf("  length[%d] = -1\n", (signed int)i);

        else
          histogram[(signed long int)length] = histogram[(signed long int)length] + 1;
      }
      printf("\nhistogram %s =\n{\n", name);
      i = (unsigned long int)0;
      for( ; !(i >= map->items); i = i + 1ul)
        if(!(histogram[(signed long int)i] == 0))
          printf("    %d chain%s of length %d\n", histogram[(signed long int)i], histogram[(signed long int)i] == 1 ? "" : "s", (signed int)i);

      printf("}\n");
    }
  }
}

// map_insert
// file libslack/map.c line 938
signed int map_insert(struct Map *map, const void *key, void *value, signed int replace)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=map_insert_unlocked(map, key, value, replace);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// map_insert_unlocked
// file libslack/map.c line 967
signed int map_insert_unlocked(struct Map *map, const void *key, void *value, signed int replace)
{
  struct Mapping *mapping;
  struct List *chain;
  signed long int length;
  unsigned long int h;
  unsigned long int c;
  signed int return_value_set_errno$1;
  signed int return_value_map_resize$2;
  signed int return_value_set_errno$3;
  struct List *return_value_list_remove_unlocked$5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if((double)map->items / (double)map->size >= table_resize_factor)
    {
      return_value_map_resize$2=map_resize(map);
      if(!(return_value_map_resize$2 == -1))
        goto __CPROVER_DUMP_L2;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      h=map->hash(map->size, key);
      if(h >= map->size)
      {
        return_value_set_errno$3=set_errno(22);
        return return_value_set_errno$3;
      }

      else
        if(map->chain[(signed long int)h] == ((struct List *)NULL))
        {
          map->chain[(signed long int)h]=list_create((void (*)(void *))mapping_release);
          return -1;
        }

        else
        {
          chain = map->chain[(signed long int)h];
          length=list_length_unlocked(chain);
          if(length == -1l)
            return -1;

          else
          {
            c = (unsigned long int)0;
            if(!(c >= (unsigned long int)length))
            {
              void *return_value_list_item_unlocked$4;
              return_value_list_item_unlocked$4=list_item_unlocked(chain, (signed long int)c);
              mapping = (struct Mapping *)return_value_list_item_unlocked$4;
              signed int return_value;
              return_value=map->cmp(mapping->key, key);
              if(return_value == 0)
              {
                if(!(replace == 0))
                  return_value_list_remove_unlocked$5=list_remove_unlocked(chain, (signed long int)c);

                return -1;
              }

              c = c + 1ul;
            }

            void *return_value_1;
            return_value_1=map->copy(key);
            mapping=mapping_create(return_value_1, value, map->key_destroy, map->value_destroy);
            if(mapping == ((struct Mapping *)NULL))
              return -1;

            else
            {
              struct List *return_value_list_append_unlocked$6;
              return_value_list_append_unlocked$6=list_append_unlocked(chain, (void *)mapping);
              if(return_value_list_append_unlocked$6 == ((struct List *)NULL))
              {
                mapping_release(mapping);
                return -1;
              }

              else
              {
                map->items = map->items + 1ul;
                return 0;
              }
            }
          }
        }
    }
}

// map_keys
// file libslack/map.h line 91
struct List * map_keys(struct Map *map)
{
  struct List *return_value_map_keys_with_locker$1;
  return_value_map_keys_with_locker$1=map_keys_with_locker((struct Locker *)(void *)0, map);
  return return_value_map_keys_with_locker$1;
}

// map_keys_unlocked
// file libslack/map.c line 1691
struct List * map_keys_unlocked(struct Map *map)
{
  struct List *return_value_map_keys_with_locker_unlocked$1;
  return_value_map_keys_with_locker_unlocked$1=map_keys_with_locker_unlocked((struct Locker *)(void *)0, map);
  return return_value_map_keys_with_locker_unlocked$1;
}

// map_keys_with_locker
// file libslack/map.c line 1707
struct List * map_keys_with_locker(struct Locker *locker, struct Map *map)
{
  struct List *keys;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      keys=map_keys_with_locker_unlocked(locker, map);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      else
        return keys;
    }
  }
}

// map_keys_with_locker_unlocked
// file libslack/map.c line 1737
struct List * map_keys_with_locker_unlocked(struct Locker *locker, struct Map *map)
{
  struct Mapper *mapper;
  struct List *keys;
  void *return_value_set_errnull$1;
  signed int return_value_mapper_has_next$2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    keys=list_create_with_locker(locker, (void (*)(void *))(void *)0);
    if(keys == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      mapper=mapper_create_unlocked(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        list_release(keys);
        return (struct List *)(void *)0;
      }

      else
      {
        do
        {
          return_value_mapper_has_next$2=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next$2 == 1))
            break;

          const struct Mapping *mapping;
          mapping=mapper_next_mapping(mapper);
          struct List *return_value_list_append$3;
          return_value_list_append$3=list_append(keys, mapping->key);
          if(return_value_list_append$3 == ((struct List *)NULL))
          {
            list_destroy(&keys);
            break;
          }

        }
        while((_Bool)1);
        mapper_release_unlocked(mapper);
        return keys;
      }
    }
  }
}

// map_next
// file libslack/map.h line 86
void * map_next(struct Map *map)
{
  _Bool tmp_if_expr$2;
  if(map == ((struct Map *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(map->mapper != ((struct Mapper *)NULL)) ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    void *return_value_mapper_next$3;
    return_value_mapper_next$3=mapper_next(map->mapper);
    return return_value_mapper_next$3;
  }
}

// map_next_mapping
// file libslack/map.h line 87
const struct Mapping * map_next_mapping(struct Map *map)
{
  _Bool tmp_if_expr$2;
  if(map == ((struct Map *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(map->mapper != ((struct Mapper *)NULL)) ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (const struct Mapping *)return_value_set_errnull$1;
  }

  else
  {
    const struct Mapping *return_value_mapper_next_mapping$3;
    return_value_mapper_next_mapping$3=mapper_next_mapping(map->mapper);
    return return_value_mapper_next_mapping$3;
  }
}

// map_own
// file libslack/map.c line 646
signed int map_own(struct Map *map, void (*destroy)(void *))
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(destroy == ((void (*)(void *))NULL) || map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=map_own_unlocked(map, destroy);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// map_own_unlocked
// file libslack/map.c line 675
signed int map_own_unlocked(struct Map *map, void (*destroy)(void *))
{
  signed long int length;
  unsigned long int c;
  unsigned long int i;
  signed int return_value_set_errno$1;
  if(destroy == ((void (*)(void *))NULL) || map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if(destroy == map->value_destroy)
      return 0;

    else
    {
      map->value_destroy = destroy;
      c = (unsigned long int)0;
      for( ; !(c >= map->size); c = c + 1ul)
      {
        struct List *chain = map->chain[(signed long int)c];
        if(!(chain == ((struct List *)NULL)))
        {
          length=list_length_unlocked(chain);
          if(length == -1l)
            return -1;

          i = (unsigned long int)0;
          for( ; !(i >= (unsigned long int)length); i = i + 1ul)
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked$2;
            return_value_list_item_unlocked$2=list_item_unlocked(chain, (signed long int)i);
            mapping = (struct Mapping *)return_value_list_item_unlocked$2;
            mapping->value_destroy = destroy;
          }
        }

      }
      return 0;
    }
}

// map_put
// file libslack/map.c line 904
signed int map_put(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert$1;
  return_value_map_insert$1=map_insert(map, key, value, 1);
  return return_value_map_insert$1;
}

// map_put_unlocked
// file libslack/map.c line 919
signed int map_put_unlocked(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert_unlocked$1;
  return_value_map_insert_unlocked$1=map_insert_unlocked(map, key, value, 1);
  return return_value_map_insert_unlocked$1;
}

// map_rdlock
// file libslack/map.h line 53
signed int map_rdlock(const struct Map *map)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(map == ((const struct Map *)NULL)))
  {
    if(!(map->locker == ((struct Locker *)NULL)))
    {
      return_value=map->locker->rdlock(map->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// map_release
// file libslack/map.h line 56
void map_release(struct Map *map)
{
  unsigned long int i;
  if(!(map == ((struct Map *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= map->size); i = i + 1ul)
      list_release(map->chain[(signed long int)i]);
    free((void *)map->chain);
    free((void *)map);
  }

}

// map_remove
// file libslack/map.h line 68
signed int map_remove(struct Map *map, const void *key)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=map_remove_unlocked(map, key);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// map_remove_current
// file libslack/map.h line 88
void map_remove_current(struct Map *map)
{
  _Bool tmp_if_expr$1;
  if(map == ((struct Map *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(map->mapper != ((struct Mapper *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    set_errno(22);

  else
    mapper_remove(map->mapper);
}

// map_remove_unlocked
// file libslack/map.c line 1061
signed int map_remove_unlocked(struct Map *map, const void *key)
{
  struct List *chain;
  signed long int length;
  unsigned long int h;
  unsigned long int c;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  signed int return_value_set_errno$3;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    h=map->hash(map->size, key);
    if(h >= map->size)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      chain = map->chain[(signed long int)h];
      if(chain == ((struct List *)NULL))
      {
        return_value_set_errno$3=set_errno(2);
        return return_value_set_errno$3;
      }

      else
      {
        length=list_length_unlocked(chain);
        if(length == -1l)
          return -1;

        else
        {
          c = (unsigned long int)0;
          if(!(c >= (unsigned long int)length))
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked$4;
            return_value_list_item_unlocked$4=list_item_unlocked(chain, (signed long int)c);
            mapping = (struct Mapping *)return_value_list_item_unlocked$4;
            signed int return_value;
            return_value=map->cmp(mapping->key, key);
            if(return_value == 0)
            {
              struct List *return_value_list_remove_unlocked$5;
              return_value_list_remove_unlocked$5=list_remove_unlocked(chain, (signed long int)c);
              if(return_value_list_remove_unlocked$5 == ((struct List *)NULL))
                return -1;

              map->items = map->items - 1ul;
              return 0;
            }

            c = c + 1ul;
          }

          signed int return_value_set_errno$6;
          return_value_set_errno$6=set_errno(2);
          return return_value_set_errno$6;
        }
      }
    }
  }
}

// map_resize
// file libslack/map.c line 795
static signed int map_resize(struct Map *map)
{
  unsigned long int map_resize$$1$$size = (unsigned long int)0;
  unsigned long int i;
  struct Mapper *mapper;
  struct Map *new_map;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  signed int return_value_mapper_has_next$3;
  signed int *return_value___errno_location$6;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    i = (unsigned long int)1;
    for( ; !(i >= num_table_sizes); i = i + 1ul)
      if(!(map->size >= table_sizes[(signed long int)i]))
      {
        map_resize$$1$$size = table_sizes[(signed long int)i];
        break;
      }

    if(i == num_table_sizes || map_resize$$1$$size == 0ul)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      new_map=map_create_generic_sized(map_resize$$1$$size, map->copy, map->cmp, map->hash, map->key_destroy, map->value_destroy);
      if(new_map == ((struct Map *)NULL))
        return -1;

      else
      {
        mapper=mapper_create_unlocked(map);
        if(mapper == ((struct Mapper *)NULL))
        {
          map_release(new_map);
          return -1;
        }

        else
        {
          do
          {
            return_value_mapper_has_next$3=mapper_has_next(mapper);
            if(!(return_value_mapper_has_next$3 == 1))
              break;

            const struct Mapping *mapping;
            mapping=mapper_next_mapping(mapper);
            signed int return_value_map_add_unlocked$4;
            return_value_map_add_unlocked$4=map_add_unlocked(new_map, mapping->key, mapping->value);
            if(return_value_map_add_unlocked$4 == -1)
            {
              mapper_release_unlocked(mapper);
              map_release(new_map);
              return -1;
            }

          }
          while((_Bool)1);
          mapper_release_unlocked(mapper);
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          *return_value___errno_location$5 = 0;
          void (*return_value_map_disown_unlocked$7)(void *);
          return_value_map_disown_unlocked$7=map_disown_unlocked(map);
          if(return_value_map_disown_unlocked$7 == ((void (*)(void *))NULL))
          {
            return_value___errno_location$6=__errno_location();
            if(*return_value___errno_location$6 == 0)
              goto __CPROVER_DUMP_L10;

            map_release(new_map);
            return -1;
          }

          else
          {

          __CPROVER_DUMP_L10:
            ;
            i = (unsigned long int)0;
            for( ; !(i >= map->size); i = i + 1ul)
              list_release(map->chain[(signed long int)i]);
            free((void *)map->chain);
            map->size = new_map->size;
            map->items = new_map->items;
            map->chain = new_map->chain;
            map->value_destroy = new_map->value_destroy;
            free((void *)new_map);
            return 0;
          }
        }
      }
    }
  }
}

// map_size
// file libslack/map.h line 103
signed long int map_size(struct Map *map)
{
  unsigned long int map_size$$1$$size;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      map_size$$1$$size = map->items;
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return (signed long int)return_value_set_errno$5;
      }

      else
        return (signed long int)map_size$$1$$size;
    }
  }
}

// map_size_unlocked
// file libslack/map.h line 104
signed long int map_size_unlocked(const struct Map *map)
{
  signed int return_value_set_errno$1;
  if(map == ((const struct Map *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
    return (signed long int)map->items;
}

// map_unlock
// file libslack/map.h line 55
signed int map_unlock(const struct Map *map)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(map == ((const struct Map *)NULL)))
  {
    if(!(map->locker == ((struct Locker *)NULL)))
    {
      return_value=map->locker->unlock(map->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// map_values
// file libslack/map.h line 95
struct List * map_values(struct Map *map)
{
  struct List *return_value_map_values_with_locker$1;
  return_value_map_values_with_locker$1=map_values_with_locker((struct Locker *)(void *)0, map);
  return return_value_map_values_with_locker$1;
}

// map_values_unlocked
// file libslack/map.c line 1799
struct List * map_values_unlocked(struct Map *map)
{
  struct List *return_value_map_values_with_locker_unlocked$1;
  return_value_map_values_with_locker_unlocked$1=map_values_with_locker_unlocked((struct Locker *)(void *)0, map);
  return return_value_map_values_with_locker_unlocked$1;
}

// map_values_with_locker
// file libslack/map.c line 1815
struct List * map_values_with_locker(struct Locker *locker, struct Map *map)
{
  struct List *values;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      values=map_values_with_locker_unlocked(locker, map);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      else
        return values;
    }
  }
}

// map_values_with_locker_unlocked
// file libslack/map.c line 1845
struct List * map_values_with_locker_unlocked(struct Locker *locker, struct Map *map)
{
  struct Mapper *mapper;
  struct List *values;
  void *return_value_set_errnull$1;
  signed int return_value_mapper_has_next$2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    values=list_create_with_locker(locker, (void (*)(void *))(void *)0);
    if(values == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      mapper=mapper_create_unlocked(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        list_release(values);
        return (struct List *)(void *)0;
      }

      else
      {
        do
        {
          return_value_mapper_has_next$2=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next$2 == 1))
            break;

          const struct Mapping *mapping;
          mapping=mapper_next_mapping(mapper);
          struct List *return_value_list_append$3;
          return_value_list_append$3=list_append(values, mapping->value);
          if(return_value_list_append$3 == ((struct List *)NULL))
          {
            list_destroy(&values);
            break;
          }

        }
        while((_Bool)1);
        mapper_release_unlocked(mapper);
        return values;
      }
    }
  }
}

// map_wrlock
// file libslack/map.h line 54
signed int map_wrlock(const struct Map *map)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(map == ((const struct Map *)NULL)))
  {
    if(!(map->locker == ((struct Locker *)NULL)))
    {
      return_value=map->locker->wrlock(map->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// mapper_create
// file libslack/map.h line 72
struct Mapper * mapper_create(struct Map *map)
{
  struct Mapper *return_value_mapper_create_wrlocked$1;
  return_value_mapper_create_wrlocked$1=mapper_create_wrlocked(map);
  return return_value_mapper_create_wrlocked$1;
}

// mapper_create_rdlocked
// file libslack/map.h line 73
struct Mapper * mapper_create_rdlocked(struct Map *map)
{
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Mapper *)return_value_set_errnull$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct Mapper *)return_value_set_errnull$2;
    }

    else
    {
      struct Mapper *return_value_mapper_create_unlocked$5;
      return_value_mapper_create_unlocked$5=mapper_create_unlocked(map);
      return return_value_mapper_create_unlocked$5;
    }
  }
}

// mapper_create_unlocked
// file libslack/map.c line 1244
struct Mapper * mapper_create_unlocked(struct Map *map)
{
  struct Mapper *mapper;
  void *return_value_set_errnull$1;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Mapper *)return_value_set_errnull$1;
  }

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct Mapper) /*40ul*/ );
    mapper = (struct Mapper *)return_value_malloc$2;
    if(mapper == ((struct Mapper *)NULL))
      return (struct Mapper *)(void *)0;

    else
    {
      mapper->map = map;
      mapper->chain_index = (signed long int)-1;
      mapper->item_index = (signed long int)-1;
      mapper->next_chain_index = (signed long int)-1;
      mapper->next_item_index = (signed long int)-1;
      return mapper;
    }
  }
}

// mapper_create_wrlocked
// file libslack/map.h line 74
struct Mapper * mapper_create_wrlocked(struct Map *map)
{
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Mapper *)return_value_set_errnull$1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct Mapper *)return_value_set_errnull$2;
    }

    else
    {
      struct Mapper *return_value_mapper_create_unlocked$5;
      return_value_mapper_create_unlocked$5=mapper_create_unlocked(map);
      return return_value_mapper_create_unlocked$5;
    }
  }
}

// mapper_destroy
// file libslack/map.h line 78
void * mapper_destroy(struct Mapper **mapper)
{
  if(!(mapper == ((struct Mapper **)NULL)))
  {
    if(!(*mapper == ((struct Mapper *)NULL)))
    {
      mapper_release(*mapper);
      *mapper = (struct Mapper *)(void *)0;
    }

  }

  return (void *)0;
}

// mapper_destroy_unlocked
// file libslack/map.c line 1341
void * mapper_destroy_unlocked(struct Mapper **mapper)
{
  if(!(mapper == ((struct Mapper **)NULL)))
  {
    if(!(*mapper == ((struct Mapper *)NULL)))
    {
      mapper_release_unlocked(*mapper);
      *mapper = (struct Mapper *)(void *)0;
    }

  }

  return (void *)0;
}

// mapper_has_next
// file libslack/map.h line 80
signed int mapper_has_next(struct Mapper *mapper)
{
  struct List *chain;
  signed long int length;
  signed int return_value_set_errno$1;
  if(mapper == ((struct Mapper *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    mapper->next_chain_index = mapper->chain_index;
    mapper->next_item_index = mapper->item_index;
    if(mapper->next_chain_index == -1l)
      mapper->next_chain_index = mapper->next_chain_index + 1l;

    for( ; !((unsigned long int)mapper->next_chain_index >= mapper->map->size); mapper->next_chain_index = mapper->next_chain_index + 1l)
      if(!(mapper->map->chain[mapper->next_chain_index] == ((struct List *)NULL)))
        break;

    if((unsigned long int)mapper->next_chain_index == mapper->map->size)
      return 0;

    else
    {
      chain = mapper->map->chain[mapper->next_chain_index];
      length=list_length_unlocked(chain);
      if(length == -1l)
        return -1;

      else
      {
        mapper->next_item_index = mapper->next_item_index + 1l;
        if(!(mapper->next_item_index >= length))
          return 1;

        else
        {
          do
          {
            mapper->next_chain_index = mapper->next_chain_index + 1l;
            for( ; !((unsigned long int)mapper->next_chain_index >= mapper->map->size); mapper->next_chain_index = mapper->next_chain_index + 1l)
              if(!(mapper->map->chain[mapper->next_chain_index] == ((struct List *)NULL)))
                break;

            if((unsigned long int)mapper->next_chain_index == mapper->map->size)
              return 0;

            chain = mapper->map->chain[mapper->next_chain_index];
            length=list_length_unlocked(chain);
            if(length == -1l)
              return -1;

          }
          while(length == 0l);
          mapper->next_item_index = (signed long int)0;
          return 1;
        }
      }
    }
  }
}

// mapper_next
// file libslack/map.h line 81
void * mapper_next(struct Mapper *mapper)
{
  void *return_value_set_errnull$1;
  if(mapper == ((struct Mapper *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    const struct Mapping *return_value_mapper_next_mapping$2;
    return_value_mapper_next_mapping$2=mapper_next_mapping(mapper);
    return return_value_mapper_next_mapping$2->value;
  }
}

// mapper_next_mapping
// file libslack/map.h line 82
const struct Mapping * mapper_next_mapping(struct Mapper *mapper)
{
  void *return_value_set_errnull$1;
  if(mapper == ((struct Mapper *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (const struct Mapping *)return_value_set_errnull$1;
  }

  else
  {
    mapper->chain_index = mapper->next_chain_index;
    mapper->item_index = mapper->next_item_index;
    void *return_value_list_item_unlocked$2;
    return_value_list_item_unlocked$2=list_item_unlocked(mapper->map->chain[mapper->chain_index], mapper->item_index);
    return (struct Mapping *)return_value_list_item_unlocked$2;
  }
}

// mapper_release
// file libslack/map.h line 76
void mapper_release(struct Mapper *mapper)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(mapper == ((struct Mapper *)NULL)))
  {
    if(!(mapper->map == ((struct Map *)NULL)))
    {
      if(!(mapper->map->locker == ((struct Locker *)NULL)))
      {
        return_value=mapper->map->locker->unlock(mapper->map->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }

    else
      tmp_if_expr$2 = 22;
    err = tmp_if_expr$2;
    if(!(err == 0))
      set_errno(err);

    else
      free((void *)mapper);
  }

}

// mapper_release_unlocked
// file libslack/map.c line 1300
void mapper_release_unlocked(struct Mapper *mapper)
{
  if(!(mapper == ((struct Mapper *)NULL)))
    free((void *)mapper);

}

// mapper_remove
// file libslack/map.h line 83
void mapper_remove(struct Mapper *mapper)
{
  signed long int tmp_post$1;
  if(mapper == ((struct Mapper *)NULL))
    set_errno(22);

  else
    if(mapper->item_index == -1l)
      set_errno(22);

    else
    {
      tmp_post$1 = mapper->item_index;
      mapper->item_index = mapper->item_index - 1l;
      list_remove_unlocked(mapper->map->chain[mapper->chain_index], (signed long int)(unsigned long int)tmp_post$1);
      mapper->map->items = mapper->map->items - 1ul;
    }
}

// mapping_create
// file libslack/map.c line 238
static struct Mapping * mapping_create(void *key, void *value, void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Mapping *mapping;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct Mapping) /*32ul*/ );
  mapping = (struct Mapping *)return_value_malloc$1;
  if(mapping == ((struct Mapping *)NULL))
    return (struct Mapping *)(void *)0;

  else
  {
    mapping->key = key;
    mapping->value = value;
    mapping->key_destroy = key_destroy;
    mapping->value_destroy = value_destroy;
    return mapping;
  }
}

// mapping_key
// file libslack/map.h line 89
const void * mapping_key(const struct Mapping *mapping)
{
  void *return_value_set_errnull$1;
  if(mapping == ((const struct Mapping *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    return mapping->key;
}

// mapping_release
// file libslack/map.c line 261
static void mapping_release(struct Mapping *mapping)
{
  if(!(mapping == ((struct Mapping *)NULL)))
  {
    if(!(mapping->key_destroy == ((void (*)(void *))NULL)))
      mapping->key_destroy(mapping->key);

    if(!(mapping->value_destroy == ((void (*)(void *))NULL)))
      mapping->value_destroy(mapping->value);

    free((void *)mapping);
  }

}

// mapping_value
// file libslack/map.h line 90
const void * mapping_value(const struct Mapping *mapping)
{
  void *return_value_set_errnull$1;
  if(mapping == ((const struct Mapping *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    return mapping->value;
}

// measure
// file libslack/agent.c line 2017
static void measure(struct Agent *agent, signed int fd, struct timeval *now)
{
  struct activity_t *activity;
  struct timeval delta[1l];
  signed int msec;
  signed int prev_dt;
  signed int prev_ddt;
  struct activity_t *tmp_if_expr$1;
  if(fd == -1)
    tmp_if_expr$1 = agent->tempo;

  else
    tmp_if_expr$1 = &agent->activity[agent->ids[(signed long int)fd]];
  activity = tmp_if_expr$1;
  switch(activity->detail)
  {
    case (unsigned long int)0:
    {
      activity->since = *now;
      activity->detail = (unsigned long int)1;
      goto __CPROVER_DUMP_L7;
    }
    case (unsigned long int)1:
    {
      timeval_diff(&activity->since, now, delta);
      msec = (signed int)(delta[0l].tv_sec * (signed long int)1000 + delta[0l].tv_usec / (signed long int)1000);
      activity->dt = msec;
      activity->since = *now;
      activity->detail = (unsigned long int)2;
      goto __CPROVER_DUMP_L7;
    }
    case (unsigned long int)2:
    {
      timeval_diff(&activity->since, now, delta);
      msec = (signed int)(delta[0l].tv_sec * (signed long int)1000 + delta[0l].tv_usec / (signed long int)1000);
      prev_dt = activity->dt;
      activity->dt = msec;
      activity->ddt = activity->dt - prev_dt;
      activity->since = *now;
      activity->detail = (unsigned long int)3;
      goto __CPROVER_DUMP_L7;
    }
    case (unsigned long int)3:

    case (unsigned long int)4:
    {
      timeval_diff(&activity->since, now, delta);
      msec = (signed int)(delta[0l].tv_sec * (signed long int)1000 + delta[0l].tv_usec / (signed long int)1000);
      prev_dt = activity->dt;
      activity->dt = msec;
      prev_ddt = activity->ddt;
      activity->ddt = activity->dt - prev_dt;
      activity->dddt = activity->ddt - prev_ddt;
      activity->since = *now;
      activity->detail = (unsigned long int)4;
    }
    default:

      __CPROVER_DUMP_L7:
        ;
  }
}

// mem_create_secure
// file libslack/mem.c line 270
void * mem_create_secure(unsigned long int size)
{
  char *addr;
  char *lock;
  size = size + sizeof(unsigned long int) /*8ul*/ ;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  addr = (char *)return_value_malloc$1;
  if(addr == ((char *)NULL))
    return (void *)0;

  else
  {
    lock = addr;
    signed int return_value_mlock$2;
    return_value_mlock$2=mlock((const void *)lock, size);
    if(return_value_mlock$2 == -1)
    {
      free((void *)addr);
      return (void *)0;
    }

    else
    {
      *((unsigned long int *)lock) = size;
      lock = lock + (signed long int)sizeof(unsigned long int) /*8ul*/ ;
      return (void *)lock;
    }
  }
}

// mem_create_space
// file libslack/mem.c line 469
void * mem_create_space(unsigned long int size, ...)
{
  unsigned long int dim[32l];
  unsigned long int d;
  unsigned long int i;
  unsigned long int j;
  unsigned long int lengths[32l];
  unsigned long int starts[32l];
  unsigned long int sizes[32l];
  char *space;
  unsigned long int arg;
  unsigned long int length;
  __builtin_va_list args;
  va_start(args, size);
  d = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(d >= 32ul))
    {
      arg=va_arg(args, __typeof__(arg));
      tmp_if_expr$1 = arg != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    dim[(signed long int)d] = arg;
    d = d + 1ul;
  }
  while((_Bool)1);
  va_end(args);
  i = (unsigned long int)0;
  length = i;
  for( ; !(i >= d); i = i + 1ul)
  {
    starts[(signed long int)i] = length;
    sizes[(signed long int)i] = i == d - (unsigned long int)1 ? size : sizeof(void *) /*8ul*/ ;
    lengths[(signed long int)i] = sizes[(signed long int)i];
    j = (unsigned long int)0;
    for( ; i >= j; j = j + 1ul)
      lengths[(signed long int)i] = lengths[(signed long int)i] * dim[(signed long int)j];
    length = length + lengths[(signed long int)i];
  }
  void *return_value_calloc$2;
  return_value_calloc$2=calloc(length, (unsigned long int)1);
  space = (char *)return_value_calloc$2;
  if(space == ((char *)NULL))
    return (void *)0;

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= d + 18446744073709551615ul); i = i + 1ul)
    {
      unsigned long int num = dim[(signed long int)i];
      j = (unsigned long int)0;
      for( ; !(j >= i); j = j + 1ul)
        num = num * dim[(signed long int)j];
      j = (unsigned long int)0;
      for( ; !(j >= num); j = j + 1ul)
        *((char **)(space + (signed long int)starts[(signed long int)i] + (signed long int)(j * sizes[(signed long int)i]))) = space + (signed long int)starts[(signed long int)(i + (unsigned long int)1)] + (signed long int)(j * dim[(signed long int)(i + (unsigned long int)1)] * sizes[(signed long int)(i + (unsigned long int)1)]);
    }
    return (void *)space;
  }
}

// mem_destroy
// file libslack/mem.h line 48
void * mem_destroy(void **mem)
{
  if(!(mem == ((void **)NULL)))
  {
    if(!(*mem == NULL))
    {
      free(*mem);
      *mem = (void *)0;
    }

  }

  return (void *)0;
}

// mem_destroy_secure
// file libslack/mem.c line 373
void * mem_destroy_secure(void **mem)
{
  if(!(mem == ((void **)NULL)))
  {
    if(!(*mem == NULL))
    {
      mem_release_secure(*mem);
      *mem = (void *)0;
    }

  }

  return (void *)0;
}

// mem_release_secure
// file libslack/mem.c line 333
void mem_release_secure(void *mem)
{
  char *addr;
  char *lock;
  unsigned long int mem_release_secure$$1$$size;
  if(!(mem == NULL))
  {
    lock = (char *)mem;
    lock = lock - (signed long int)sizeof(unsigned long int) /*8ul*/ ;
    mem_release_secure$$1$$size = *((unsigned long int *)lock);
    addr = lock;
    memset((void *)lock, 0xff, mem_release_secure$$1$$size);
    memset((void *)lock, 0xaa, mem_release_secure$$1$$size);
    memset((void *)lock, 0x55, mem_release_secure$$1$$size);
    memset((void *)lock, 0x00, mem_release_secure$$1$$size);
    munlock((const void *)lock, mem_release_secure$$1$$size);
    free((void *)addr);
  }

}

// mem_resize_fn
// file libslack/mem.h line 46
void * mem_resize_fn(void **mem, unsigned long int size)
{
  void *ptr;
  void *return_value_set_errnull$1;
  if(mem == ((void **)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    ptr=realloc(*mem, size);
    if(ptr == NULL && !(size == 0ul))
      return (void *)0;

    else
    {
      *mem = ptr;
      return *mem;
    }
  }
}

// mem_space_start
// file libslack/mem.c line 526
unsigned long int mem_space_start(unsigned long int size, ...)
{
  unsigned long int dim[32l];
  unsigned long int d;
  unsigned long int i;
  unsigned long int j;
  unsigned long int lengths[32l];
  unsigned long int arg;
  unsigned long int length;
  __builtin_va_list args;
  va_start(args, size);
  d = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(d >= 32ul))
    {
      arg=va_arg(args, __typeof__(arg));
      tmp_if_expr$1 = arg != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    dim[(signed long int)d] = arg;
    d = d + 1ul;
  }
  while((_Bool)1);
  va_end(args);
  i = (unsigned long int)0;
  length = i;
  for( ; !(i >= d); i = i + 1ul)
  {
    lengths[(signed long int)i] = i == d - (unsigned long int)1 ? size : sizeof(void *) /*8ul*/ ;
    j = (unsigned long int)0;
    for( ; i >= j; j = j + 1ul)
      lengths[(signed long int)i] = lengths[(signed long int)i] * dim[(signed long int)j];
    length = length + lengths[(signed long int)i];
  }
  return length - lengths[(signed long int)(d - (unsigned long int)1)];
}

// mem_strdup
// file libslack/mem.h line 54
char * mem_strdup(const char *str)
{
  unsigned long int mem_strdup$$1$$size;
  char *copy;
  void *return_value_set_errnull$1;
  if(str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str);
    mem_strdup$$1$$size = return_value_strlen$2 + (unsigned long int)1;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(mem_strdup$$1$$size * sizeof(char) /*1ul*/ );
    copy = (char *)return_value_malloc$3;
    if(copy == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      void *return_value_memcpy$4;
      return_value_memcpy$4=memcpy((void *)copy, (const void *)str, mem_strdup$$1$$size);
      return (char *)return_value_memcpy$4;
    }
  }
}

// msg
// file libslack/err.c line 149
void msg(const char *format, ...)
{
  void **args = (void **)&format;
  vmsg(format, args);
  args = ((void **)NULL);
}

// msg_add_plex
// file libslack/msg.c line 1222
signed int msg_add_plex(struct Msg *mesg, struct Msg *item)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(mesg == ((struct Msg *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(mesg == ((struct Msg *)NULL)))
    {
      if(!(mesg->locker == ((struct Locker *)NULL)))
      {
        return_value=mesg->locker->wrlock(mesg->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=msg_add_plex_unlocked(mesg, item);
      if(!(mesg == ((struct Msg *)NULL)))
      {
        if(!(mesg->locker == ((struct Locker *)NULL)))
        {
          return_value_1=mesg->locker->unlock(mesg->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// msg_add_plex_unlocked
// file libslack/msg.c line 1251
signed int msg_add_plex_unlocked(struct Msg *mesg, struct Msg *item)
{
  _Bool tmp_if_expr$2;
  if(mesg == ((struct Msg *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = mesg->type != 4 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_msg_plexdata_add$3;
    return_value_msg_plexdata_add$3=msg_plexdata_add((struct MsgPlexData *)mesg->data, item);
    return return_value_msg_plexdata_add$3;
  }
}

// msg_create
// file libslack/msg.c line 230
struct Msg * msg_create(signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *))
{
  struct Msg *return_value_msg_create_with_locker$1;
  return_value_msg_create_with_locker$1=msg_create_with_locker((struct Locker *)(void *)0, type, out, data, destroy);
  return return_value_msg_create_with_locker$1;
}

// msg_create_fd
// file libslack/msg.c line 533
struct Msg * msg_create_fd(signed int fd)
{
  struct Msg *return_value_msg_create_fd_with_locker$1;
  return_value_msg_create_fd_with_locker$1=msg_create_fd_with_locker((struct Locker *)(void *)0, fd);
  return return_value_msg_create_fd_with_locker$1;
}

// msg_create_fd_with_locker
// file libslack/msg.c line 549
struct Msg * msg_create_fd_with_locker(struct Locker *locker, signed int fd)
{
  signed int *data;
  struct Msg *mesg;
  data=msg_fddata_create(fd);
  if(data == ((signed int *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 1, msg_out_fd, (void *)data, (void (*)(void *))msg_fddata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_fddata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_file
// file libslack/msg.c line 763
struct Msg * msg_create_file(const char *path)
{
  struct Msg *return_value_msg_create_file_with_locker$1;
  return_value_msg_create_file_with_locker$1=msg_create_file_with_locker((struct Locker *)(void *)0, path);
  return return_value_msg_create_file_with_locker$1;
}

// msg_create_file_with_locker
// file libslack/msg.c line 779
struct Msg * msg_create_file_with_locker(struct Locker *locker, const char *path)
{
  struct MsgFileData *data;
  struct Msg *mesg;
  data=msg_filedata_create(path);
  if(data == ((struct MsgFileData *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 2, msg_out_file, (void *)data, (void (*)(void *))msg_filedata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_filedata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_plex
// file libslack/msg.c line 1177
struct Msg * msg_create_plex(struct Msg *msg1, struct Msg *msg2)
{
  struct Msg *return_value_msg_create_plex_with_locker$1;
  return_value_msg_create_plex_with_locker$1=msg_create_plex_with_locker((struct Locker *)(void *)0, msg1, msg2);
  return return_value_msg_create_plex_with_locker$1;
}

// msg_create_plex_with_locker
// file libslack/msg.c line 1193
struct Msg * msg_create_plex_with_locker(struct Locker *locker, struct Msg *msg1, struct Msg *msg2)
{
  struct MsgPlexData *data;
  struct Msg *mesg;
  data=msg_plexdata_create(msg1, msg2);
  if(data == ((struct MsgPlexData *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 4, msg_out_plex, (void *)data, (void (*)(void *))msg_plexdata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_plexdata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_stderr
// file libslack/msg.c line 579
struct Msg * msg_create_stderr(void)
{
  struct Msg *return_value_msg_create_fd_with_locker$1;
  return_value_msg_create_fd_with_locker$1=msg_create_fd_with_locker((struct Locker *)(void *)0, 2);
  return return_value_msg_create_fd_with_locker$1;
}

// msg_create_stderr_with_locker
// file libslack/msg.c line 595
struct Msg * msg_create_stderr_with_locker(struct Locker *locker)
{
  struct Msg *return_value_msg_create_fd_with_locker$1;
  return_value_msg_create_fd_with_locker$1=msg_create_fd_with_locker(locker, 2);
  return return_value_msg_create_fd_with_locker$1;
}

// msg_create_stdout
// file libslack/msg.c line 613
struct Msg * msg_create_stdout(void)
{
  struct Msg *return_value_msg_create_fd_with_locker$1;
  return_value_msg_create_fd_with_locker$1=msg_create_fd_with_locker((struct Locker *)(void *)0, 1);
  return return_value_msg_create_fd_with_locker$1;
}

// msg_create_stdout_with_locker
// file libslack/msg.c line 629
struct Msg * msg_create_stdout_with_locker(struct Locker *locker)
{
  struct Msg *return_value_msg_create_fd_with_locker$1;
  return_value_msg_create_fd_with_locker$1=msg_create_fd_with_locker(locker, 1);
  return return_value_msg_create_fd_with_locker$1;
}

// msg_create_syslog
// file libslack/msg.c line 897
struct Msg * msg_create_syslog(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct Msg *return_value_msg_create_syslog_with_locker$1;
  return_value_msg_create_syslog_with_locker$1=msg_create_syslog_with_locker((struct Locker *)(void *)0, ident, option, facility, priority);
  return return_value_msg_create_syslog_with_locker$1;
}

// msg_create_syslog_with_locker
// file libslack/msg.c line 913
struct Msg * msg_create_syslog_with_locker(struct Locker *locker, const char *ident, signed int option, signed int facility, signed int priority)
{
  struct MsgSyslogData *data;
  struct Msg *mesg;
  data=msg_sysdata_create(ident, option, facility, priority);
  if(data == ((struct MsgSyslogData *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 3, msg_out_syslog, (void *)data, (void (*)(void *))msg_sysdata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_sysdata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_with_locker
// file libslack/msg.c line 246
struct Msg * msg_create_with_locker(struct Locker *locker, signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *))
{
  struct Msg *mesg;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct Msg) /*40ul*/ );
  mesg = (struct Msg *)return_value_malloc$1;
  if(mesg == ((struct Msg *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg->type = type;
    mesg->out = out;
    mesg->data = data;
    mesg->destroy = destroy;
    mesg->locker = locker;
    return mesg;
  }
}

// msg_destroy
// file libslack/msg.c line 358
void * msg_destroy(struct Msg **mesg)
{
  if(!(mesg == ((struct Msg **)NULL)))
  {
    if(!(*mesg == ((struct Msg *)NULL)))
    {
      msg_release(*mesg);
      *mesg = (struct Msg *)(void *)0;
    }

  }

  return (void *)0;
}

// msg_fddata_create
// file libslack/msg.c line 478
static signed int * msg_fddata_create(signed int fd)
{
  signed int *data;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(signed int) /*4ul*/ );
  data = (signed int *)return_value_malloc$1;
  if(data == ((signed int *)NULL))
    return (signed int *)(void *)0;

  else
  {
    *data = fd;
    return data;
  }
}

// msg_fddata_release
// file libslack/msg.c line 499
static void msg_fddata_release(signed int *data)
{
  free((void *)data);
}

// msg_filedata_create
// file libslack/msg.c line 671
static struct MsgFileData * msg_filedata_create(const char *path)
{
  struct MsgFileData *data;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct MsgFileData) /*4ul*/ );
  data = (struct MsgFileData *)return_value_malloc$1;
  if(data == ((struct MsgFileData *)NULL))
    return (struct MsgFileData *)(void *)0;

  else
  {
    signed int return_value_msg_filedata_init$2;
    return_value_msg_filedata_init$2=msg_filedata_init(data, path);
    if(return_value_msg_filedata_init$2 == -1)
    {
      free((void *)data);
      return (struct MsgFileData *)(void *)0;
    }

    else
      return data;
  }
}

// msg_filedata_init
// file libslack/msg.c line 646
static signed int msg_filedata_init(struct MsgFileData *data, const char *path)
{
  unsigned int mode;
  signed int return_value_set_errno$1;
  if(path == ((const char *)NULL) || data == ((struct MsgFileData *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    mode = (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3);
    data->fd=open(path, 01 | 0100 | 02000, mode);
    if(data->fd == -1)
      return -1;

    else
      return 0;
  }
}

// msg_filedata_release
// file libslack/msg.c line 696
static void msg_filedata_release(struct MsgFileData *data)
{
  if(!(data == ((struct MsgFileData *)NULL)))
  {
    if(!(data->fd == -1))
      close(data->fd);

    free((void *)data);
  }

}

// msg_out
// file libslack/msg.h line 50
void msg_out(struct Msg *dst, const char *format, ...)
{
  void **args = (void **)&format;
  vmsg_out(dst, format, args);
  args = ((void **)NULL);
}

// msg_out_fd
// file libslack/msg.c line 513
static void msg_out_fd(void *data, const void *mesg, unsigned long int mesglen)
{
  signed long int return_value_write$1;
  if(!(data == NULL) && !(mesg == NULL))
    return_value_write$1=write(*((signed int *)data), mesg, mesglen);

}

// msg_out_file
// file libslack/msg.c line 717
static void msg_out_file(void *data, const void *mesg, unsigned long int mesglen)
{
  struct MsgFileData *dst = (struct MsgFileData *)data;
  char buf[8192l];
  unsigned long int buflen;
  signed int err;
  signed long int t;
  t=time((signed long int *)(void *)0);
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(timestamp_format_locker == ((struct Locker *)NULL)))
  {
    return_value=timestamp_format_locker->rdlock(timestamp_format_locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  err = tmp_if_expr$1;
  signed int tmp_if_expr$3;
  signed int return_value_1;
  signed long int return_value_write$4;
  if(!(err == 0))
    set_errno(err);

  else
  {
    struct tm *return_value_localtime$2;
    return_value_localtime$2=localtime(&t);
    strftime(buf, (unsigned long int)8192, timestamp_format, return_value_localtime$2);
    if(!(timestamp_format_locker == ((struct Locker *)NULL)))
    {
      return_value_1=timestamp_format_locker->unlock(timestamp_format_locker->lock);
      tmp_if_expr$3 = return_value_1;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
      set_errno(err);

    else
    {
      buflen=strlen(buf);
      if(buflen + mesglen >= 8192ul)
        mesglen = mesglen - ((unsigned long int)8192 - buflen);

      memmove((void *)(buf + (signed long int)buflen), mesg, mesglen);
      if(!(mesg == NULL) && !(dst == ((struct MsgFileData *)NULL)))
      {
        if(!(dst->fd == -1))
          return_value_write$4=write(dst->fd, (const void *)buf, buflen + mesglen);

      }

    }
  }
}

// msg_out_plex
// file libslack/msg.c line 1147
static void msg_out_plex(void *data, const void *mesg, unsigned long int mesglen)
{
  struct MsgPlexData *dst = (struct MsgPlexData *)data;
  unsigned long int i;
  if(!(mesg == NULL) && !(dst == ((struct MsgPlexData *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= dst->length); i = i + 1ul)
    {
      struct Msg *out = dst->list[(signed long int)i];
      if(!(out == ((struct Msg *)NULL)))
      {
        if(!(out->out == ((void (*)(void *, const void *, unsigned long int))NULL)))
          out->out(out->data, mesg, mesglen);

      }

    }
  }

}

// msg_out_syslog
// file libslack/msg.c line 875
static void msg_out_syslog(void *data, const void *mesg, unsigned long int mesglen)
{
  struct MsgSyslogData *dst = (struct MsgSyslogData *)data;
  if(!(mesg == NULL) && !(dst == ((struct MsgSyslogData *)NULL)))
  {
    if(!(dst->facility == -1))
      syslog(dst->facility | dst->priority, "%*.*s", (signed int)mesglen, (signed int)mesglen, (char *)mesg);

  }

}

// msg_out_unlocked
// file libslack/msg.h line 51
void msg_out_unlocked(struct Msg *dst, const char *format, ...)
{
  void **args = (void **)&format;
  vmsg_out_unlocked(dst, format, args);
  args = ((void **)NULL);
}

// msg_plexdata_add
// file libslack/msg.c line 1070
static signed int msg_plexdata_add(struct MsgPlexData *data, struct Msg *mesg)
{
  if(data->length == data->size)
  {
    unsigned long int new_size = data->size << 1;
    struct Msg **new_list;
    void *return_value_mem_resize_fn$1;
    return_value_mem_resize_fn$1=mem_resize_fn((void **)&data->list, new_size * sizeof(struct Msg *) /*8ul*/ );
    new_list = (struct Msg **)return_value_mem_resize_fn$1;
    if(new_list == ((struct Msg **)NULL))
      return -1;

    data->size = new_size;
    data->list = new_list;
  }

  unsigned long int tmp_post$2 = data->length;
  data->length = data->length + 1ul;
  data->list[(signed long int)tmp_post$2] = mesg;
  return 0;
}

// msg_plexdata_create
// file libslack/msg.c line 1099
static struct MsgPlexData * msg_plexdata_create(struct Msg *msg1, struct Msg *msg2)
{
  struct MsgPlexData *data;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct MsgPlexData) /*24ul*/ );
  data = (struct MsgPlexData *)return_value_malloc$1;
  if(data == ((struct MsgPlexData *)NULL))
    return (struct MsgPlexData *)(void *)0;

  else
  {
    signed int return_value_msg_plexdata_init$2;
    return_value_msg_plexdata_init$2=msg_plexdata_init(data, msg1, msg2);
    if(return_value_msg_plexdata_init$2 == -1)
    {
      free((void *)data);
      return (struct MsgPlexData *)(void *)0;
    }

    else
      return data;
  }
}

// msg_plexdata_init
// file libslack/msg.c line 1048
static signed int msg_plexdata_init(struct MsgPlexData *data, struct Msg *msg1, struct Msg *msg2)
{
  data->size = (unsigned long int)2;
  data->length = data->size;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(data->size * sizeof(struct Msg *) /*8ul*/ );
  data->list = (struct Msg **)return_value_malloc$1;
  if(data->list == ((struct Msg **)NULL))
    return -1;

  else
  {
    data->list[(signed long int)0] = msg1;
    data->list[(signed long int)1] = msg2;
    return 0;
  }
}

// msg_plexdata_release
// file libslack/msg.c line 1124
static void msg_plexdata_release(struct MsgPlexData *data)
{
  unsigned long int i;
  if(!(data == ((struct MsgPlexData *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= data->length); i = i + 1ul)
      msg_destroy(data->list + (signed long int)i);
    free((void *)data->list);
    free((void *)data);
  }

}

// msg_rdlock
// file libslack/msg.c line 282
signed int msg_rdlock(struct Msg *mesg)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->locker == ((struct Locker *)NULL)))
    {
      return_value=mesg->locker->rdlock(mesg->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// msg_release
// file libslack/msg.c line 337
void msg_release(struct Msg *mesg)
{
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->destroy == ((void (*)(void *))NULL)))
      mesg->destroy(mesg->data);

    free((void *)mesg);
  }

}

// msg_set_timestamp_format
// file libslack/msg.c line 1271
const char * msg_set_timestamp_format(const char *format)
{
  const char *save;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  void *return_value_set_errnull$4;
  if(format == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (const char *)return_value_set_errnull$1;
  }

  else
  {
    if(!(timestamp_format_locker == ((struct Locker *)NULL)))
    {
      return_value=timestamp_format_locker->wrlock(timestamp_format_locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (const char *)return_value_set_errnull$2;
    }

    else
    {
      save = timestamp_format;
      timestamp_format = format;
      if(!(timestamp_format_locker == ((struct Locker *)NULL)))
      {
        return_value_1=timestamp_format_locker->unlock(timestamp_format_locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errnull$4=set_errnull(err);
        return (const char *)return_value_set_errnull$4;
      }

      else
        return save;
    }
  }
}

// msg_set_timestamp_format_locker
// file libslack/msg.c line 1304
signed int msg_set_timestamp_format_locker(struct Locker *locker)
{
  signed int return_value_set_errno$1;
  if(!(timestamp_format_locker == ((struct Locker *)NULL)))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    timestamp_format_locker = locker;
    return 0;
  }
}

// msg_sysdata_create
// file libslack/msg.c line 832
static struct MsgSyslogData * msg_sysdata_create(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct MsgSyslogData *data;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct MsgSyslogData) /*8ul*/ );
  data = (struct MsgSyslogData *)return_value_malloc$1;
  if(data == ((struct MsgSyslogData *)NULL))
    return (struct MsgSyslogData *)(void *)0;

  else
  {
    signed int return_value_msg_sysdata_init$2;
    return_value_msg_sysdata_init$2=msg_sysdata_init(data, ident, option, facility, priority);
    if(return_value_msg_sysdata_init$2 == -1)
    {
      free((void *)data);
      return (struct MsgSyslogData *)(void *)0;
    }

    else
      return data;
  }
}

// msg_sysdata_init
// file libslack/msg.c line 808
static signed int msg_sysdata_init(struct MsgSyslogData *data, const char *ident, signed int option, signed int facility, signed int priority)
{
  signed int return_value_set_errno$1;
  if(data == ((struct MsgSyslogData *)NULL) || facility == -1)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    data->facility = facility & 0x03f8;
    data->priority = priority & 0x07;
    openlog(ident, option, 0);
    return 0;
  }
}

// msg_sysdata_release
// file libslack/msg.c line 857
static void msg_sysdata_release(struct MsgSyslogData *data)
{
  if(!(data == ((struct MsgSyslogData *)NULL)))
  {
    free((void *)data);
    closelog();
  }

}

// msg_syslog_set_facility
// file libslack/msg.c line 941
struct Msg * msg_syslog_set_facility(struct Msg *mesg, signed int facility)
{
  struct Msg *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(mesg == ((struct Msg *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull$1;
  }

  else
  {
    if(!(mesg == ((struct Msg *)NULL)))
    {
      if(!(mesg->locker == ((struct Locker *)NULL)))
      {
        return_value=mesg->locker->wrlock(mesg->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct Msg *)return_value_set_errnull$2;
    }

    else
    {
      ret=msg_syslog_set_facility_unlocked(mesg, facility);
      if(!(mesg == ((struct Msg *)NULL)))
      {
        if(!(mesg->locker == ((struct Locker *)NULL)))
        {
          return_value_1=mesg->locker->unlock(mesg->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct Msg *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// msg_syslog_set_facility_unlocked
// file libslack/msg.c line 971
struct Msg * msg_syslog_set_facility_unlocked(struct Msg *mesg, signed int facility)
{
  struct MsgSyslogData *data;
  _Bool tmp_if_expr$2;
  if(mesg == ((struct Msg *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = mesg->type != 3 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull$1;
  }

  else
  {
    data = (struct MsgSyslogData *)mesg->data;
    data->facility = facility;
    return mesg;
  }
}

// msg_syslog_set_priority
// file libslack/msg.c line 995
struct Msg * msg_syslog_set_priority(struct Msg *mesg, signed int priority)
{
  struct Msg *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(mesg == ((struct Msg *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull$1;
  }

  else
  {
    if(!(mesg == ((struct Msg *)NULL)))
    {
      if(!(mesg->locker == ((struct Locker *)NULL)))
      {
        return_value=mesg->locker->wrlock(mesg->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct Msg *)return_value_set_errnull$2;
    }

    else
    {
      ret=msg_syslog_set_priority_unlocked(mesg, priority);
      if(!(mesg == ((struct Msg *)NULL)))
      {
        if(!(mesg->locker == ((struct Locker *)NULL)))
        {
          return_value_1=mesg->locker->unlock(mesg->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct Msg *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// msg_syslog_set_priority_unlocked
// file libslack/msg.h line 67
struct Msg * msg_syslog_set_priority_unlocked(struct Msg *mesg, signed int priority)
{
  struct MsgSyslogData *data;
  _Bool tmp_if_expr$2;
  if(mesg == ((struct Msg *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = mesg->type != 3 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull$1;
  }

  else
  {
    data = (struct MsgSyslogData *)mesg->data;
    data->priority = priority;
    return mesg;
  }
}

// msg_unlock
// file libslack/msg.h line 47
signed int msg_unlock(struct Msg *mesg)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->locker == ((struct Locker *)NULL)))
    {
      return_value=mesg->locker->unlock(mesg->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// msg_wrlock
// file libslack/msg.h line 46
signed int msg_wrlock(struct Msg *mesg)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->locker == ((struct Locker *)NULL)))
    {
      return_value=mesg->locker->wrlock(mesg->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// mt_test
// file libslack/map.c line 2675
void mt_test(signed int test, struct Locker *locker)
{
  mtmap=map_create_generic_with_locker(locker, (void * (*)(const void *))direct_copy, (signed int (*)(const void *, const void *))direct_cmp, (unsigned long int (*)(unsigned long int, const void *))direct_hash, (void (*)(void *))(void *)0, (void (*)(void *))(void *)0);
  _Bool tmp_if_expr$3;
  signed int return_value_pipe$2;
  signed long int return_value_read$6;
  signed int *return_value___errno_location$7;
  if(mtmap == ((struct Map *)NULL))
  {
    errors = errors + 1;
    printf("Test%d: map_create_generic_with_locker(NULL) failed\n", test);
  }

  else
  {
    union pthread_attr_t attr;
    unsigned long int id;
    signed int i;
    char ack;
    signed int return_value_pipe$1;
    return_value_pipe$1=pipe(size);
    if(return_value_pipe$1 == -1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_pipe$2=pipe(barrier);
      tmp_if_expr$3 = return_value_pipe$2 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      errors = errors + 1;
      printf("Test%d: failed to perform test: pipe() failed\n", test);
    }

    else
    {
      signed int return_value_getpid$4;
      return_value_getpid$4=getpid();
      signed long int return_value_time$5;
      return_value_time$5=time((signed long int *)(void *)0);
      srand((unsigned int)((signed long int)return_value_getpid$4 ^ return_value_time$5));
      pthread_attr_init(&attr);
      pthread_attr_setdetachstate(&attr, 1);
      pthread_create(&id, &attr, produce, (void *)&test);
      pthread_create(&id, &attr, consume, (void *)&test);
      static signed int iid[13l] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)0));
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)1));
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)2));
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)3));
      pthread_create(&id, &attr, iterate_rdlocked, (void *)(iid + (signed long int)4));
      pthread_create(&id, &attr, iterate_rdlocked, (void *)(iid + (signed long int)5));
      pthread_create(&id, &attr, iterate_rdlocked, (void *)(iid + (signed long int)6));
      pthread_create(&id, &attr, iterate_wrlocked, (void *)(iid + (signed long int)7));
      pthread_create(&id, &attr, iterate_wrlocked, (void *)(iid + (signed long int)8));
      pthread_create(&id, &attr, iterate_wrlocked, (void *)(iid + (signed long int)9));
      pthread_create(&id, &attr, reader, (void *)(iid + (signed long int)10));
      pthread_create(&id, &attr, reader, (void *)(iid + (signed long int)11));
      pthread_create(&id, &attr, reader, (void *)(iid + (signed long int)12));
      pthread_attr_destroy(&attr);
      i = 0;
      for( ; !(i >= 15); i = i + 1)
        do
        {
          return_value_read$6=read(barrier[(signed long int)0], (void *)&ack, (unsigned long int)1);
          if(!(return_value_read$6 == -1l))
            break;

          return_value___errno_location$7=__errno_location();
          if(!(*return_value___errno_location$7 == 4))
            break;

        }
        while((_Bool)1);
      map_destroy(&mtmap);
      if(!(mtmap == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test%d: map_destroy(&mtmap) failed\n", test);
      }

      close(size[(signed long int)0]);
      close(size[(signed long int)1]);
      close(barrier[(signed long int)0]);
      close(barrier[(signed long int)1]);
    }
  }
}

// nap
// file libslack/fio.c line 350
signed int nap(signed long int sec, signed long int usec)
{
  struct timeval tv[1l];
  signed int return_value_set_errno$1;
  if(!(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    tv[0l].tv_sec = sec;
    tv[0l].tv_usec = usec;
    signed int return_value_select$2;
    return_value_select$2=select(0, (struct anonymous$10 *)(void *)0, (struct anonymous$10 *)(void *)0, (struct anonymous$10 *)(void *)0, tv);
    return return_value_select$2;
  }
}

// net_client
// file libslack/net.c line 369
signed int net_client(const char *host, const char *service, unsigned short int port, signed long int timeout, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_client$1;
  return_value_net_create_client$1=net_create_client(host, service, port, (unsigned short int)0, 1, 0, timeout, sockopts, addr, addrsize);
  return return_value_net_create_client$1;
}

// net_client_connect
// file libslack/net.c line 709
static signed int net_client_connect(struct sockaddr *remoteaddr, unsigned long int remotesize, unsigned short int localport, signed int type, signed int protocol, signed int timeout, struct sockopt_t *sockopts)
{
  signed int sockfd;
  signed int rc;
  sockfd=socket((signed int)remoteaddr->sa_family, type, protocol);
  signed int return_value_net_options$1;
  _Bool tmp_if_expr$7;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$4;
  signed int return_value_nonblock_on$8;
  signed int *return_value___errno_location$11;
  signed int return_value_set_errno$13;
  signed int return_value_nonblock_off$14;
  if(sockfd == -1)
    return -1;

  else
    if(!(sockopts == ((struct sockopt_t *)NULL)))
    {
      return_value_net_options$1=net_options(sockfd, sockopts);
      if(!(return_value_net_options$1 == -1))
        goto __CPROVER_DUMP_L2;

      close(sockfd);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(type == 2)
      {
        if(!(localport == 0))
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)remoteaddr->sa_family == 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
        {
          union sockaddr_any_t localany;
          struct sockaddr *localaddr;
          unsigned long int localsize;
          if((signed int)remoteaddr->sa_family == 1)
          {
            localaddr=net_unaddr(&localany.un, (unsigned long int)1, "");
            localsize = sizeof(struct sockaddr_un) /*110ul*/ ;
          }

          else
          {
            signed int return_value_inet6_required$5;
            return_value_inet6_required$5=inet6_required();
            if(!(return_value_inet6_required$5 == 0))
            {
              unsigned short int __v;
              unsigned short int __x = (unsigned short int)localport;
              asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
              tmp_statement_expression$2 = __v;
              localaddr=net_in6addr(&localany.in6, (unsigned long int)10, (const void *)&in6addr_any, sizeof(struct in6_addr) /*16ul*/ , tmp_statement_expression$2);
              localsize = sizeof(struct sockaddr_in6) /*28ul*/ ;
            }

            else
            {
              unsigned long int inaddr_any;
              unsigned int return_value___bswap_32$3;
              return_value___bswap_32$3=__bswap_32((unsigned int)0x00000000);
              inaddr_any = (unsigned long int)return_value___bswap_32$3;
              unsigned short int net_client_connect$$1$$1$$2$$2$$1$$__v;
              unsigned short int net_client_connect$$1$$1$$2$$2$$1$$__x = (unsigned short int)localport;
              asm("rorw $8, %w0" : "=r"(net_client_connect$$1$$1$$2$$2$$1$$__v) : "0"(net_client_connect$$1$$1$$2$$2$$1$$__x) : "cc");
              tmp_statement_expression$4 = net_client_connect$$1$$1$$2$$2$$1$$__v;
              localaddr=net_inaddr(&localany.in, (unsigned long int)2, (const void *)&inaddr_any, sizeof(unsigned long int) /*8ul*/ , tmp_statement_expression$4);
              localsize = sizeof(struct sockaddr_in) /*16ul*/ ;
            }
          }
          signed int return_value_bind$6;
          return_value_bind$6=bind(sockfd, localaddr, (unsigned int)localsize);
          if(return_value_bind$6 == -1)
          {
            close(sockfd);
            return -1;
          }

        }

      }

      if(!(timeout == 0))
      {
        return_value_nonblock_on$8=nonblock_on(sockfd);
        if(!(return_value_nonblock_on$8 == -1))
          goto __CPROVER_DUMP_L15;

        close(sockfd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L15:
        ;
        rc=connect(sockfd, remoteaddr, (unsigned int)remotesize);
        if(rc == -1)
        {
          return_value___errno_location$11=__errno_location();
          if(!(*return_value___errno_location$11 == 115))
          {
            signed int saved_errno;
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            saved_errno = *return_value___errno_location$9;
            close(sockfd);
            signed int return_value_set_errno$10;
            return_value_set_errno$10=set_errno(saved_errno);
            return return_value_set_errno$10;
          }

        }

        if(rc == -1)
        {
          signed int access;
          signed int err = 0;
          unsigned long int net_client_connect$$1$$3$$size = sizeof(signed int) /*4ul*/ ;
          access=rw_timeout(sockfd, (signed long int)timeout, (signed long int)0);
          if(access == -1)
          {
            close(sockfd);
            return -1;
          }

          if((2 & access) == 0 && (4 & access) == 0)
          {
            close(sockfd);
            return -1;
          }

          signed int return_value_getsockopt$12;
          return_value_getsockopt$12=getsockopt(sockfd, 1, 4, (void *)&err, (unsigned int *)(void *)&net_client_connect$$1$$3$$size);
          if(return_value_getsockopt$12 == -1)
          {
            close(sockfd);
            return -1;
          }

          if(!(err == 0))
          {
            close(sockfd);
            return_value_set_errno$13=set_errno(err);
            return return_value_set_errno$13;
          }

        }

        if(!(timeout == 0))
        {
          return_value_nonblock_off$14=nonblock_off(sockfd);
          if(!(return_value_nonblock_off$14 == -1))
            goto __CPROVER_DUMP_L22;

          close(sockfd);
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L22:
          ;
          return sockfd;
        }
      }
    }
}

// net_create_client
// file libslack/net.c line 825
signed int net_create_client(const char *host, const char *service, unsigned short int port, unsigned short int localport, signed int type, signed int protocol, signed long int timeout, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize)
{
  signed int sockfd;
  union sockaddr_any_t remoteany;
  struct sockaddr *remoteaddr;
  unsigned long int remotesize;
  struct hostent *hostent = (struct hostent *)(void *)0;
  struct hostent hostbuf[1l];
  void *buf = (void *)0;
  unsigned long int net_create_client$$1$$size = (unsigned long int)0;
  signed int herrno;
  unsigned long int h = (unsigned long int)0;
  _Bool tmp_if_expr$12;
  signed int tmp_statement_expression$10;
  if(!(host == ((const char *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$11;
    return_value___builtin_strcmp$11=__builtin_strcmp(host, "/unix");
    tmp_statement_expression$10 = return_value___builtin_strcmp$11;
    tmp_if_expr$12 = !(tmp_statement_expression$10 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$12 = (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$12)
  {
    if(service == ((const char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*service != 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(service[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strlen$4=strlen(service);
      tmp_if_expr$5 = return_value_strlen$4 >= sizeof(char [108l]) /*108ul*/  ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      return_value_set_errno$1=set_errno(22);
      return return_value_set_errno$1;
    }

    remoteaddr=net_unaddr(&remoteany.un, (unsigned long int)1, service);
    remotesize = sizeof(struct sockaddr_un) /*110ul*/ ;
  }

  else
  {
    port=service_port(service, type, (signed int)port);
    if(!(host == ((const char *)NULL)))
    {
      hostent=net_gethostbyname(host, hostbuf, &buf, &net_create_client$$1$$size, &herrno);
      if(hostent == ((struct hostent *)NULL))
      {
        free(buf);
        signed int return_value_set_errno$6;
        return_value_set_errno$6=set_errno(2);
        return return_value_set_errno$6;
      }

      if(hostent->h_addrtype == 2)
      {
        remoteaddr=net_inaddr(&remoteany.in, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
        remotesize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }

      else
        if(hostent->h_addrtype == 10)
        {
          remoteaddr=net_in6addr(&remoteany.in6, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
          remotesize = sizeof(struct sockaddr_in6) /*28ul*/ ;
        }

        else
        {
          free(buf);
          signed int return_value_set_errno$7;
          return_value_set_errno$7=set_errno(38);
          return return_value_set_errno$7;
        }
    }

    else
    {
      signed int return_value_inet6_required$9;
      return_value_inet6_required$9=inet6_required();
      if(!(return_value_inet6_required$9 == 0))
      {
        remoteaddr=net_in6addr(&remoteany.in6, (unsigned long int)10, (const void *)&in6addr_loopback, sizeof(struct in6_addr) /*16ul*/ , port);
        remotesize = sizeof(struct sockaddr_in6) /*28ul*/ ;
      }

      else
      {
        unsigned long int inaddr_loopback;
        unsigned int return_value___bswap_32$8;
        return_value___bswap_32$8=__bswap_32((unsigned int)0x7f000001);
        inaddr_loopback = (unsigned long int)return_value___bswap_32$8;
        remoteaddr=net_inaddr(&remoteany.in, (unsigned long int)2, (const void *)&inaddr_loopback, sizeof(unsigned long int) /*8ul*/ , port);
        remotesize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }
    }
  }
  _Bool tmp_if_expr$13;
  do
  {
    sockfd=net_client_connect(remoteaddr, remotesize, localport, type, protocol, (signed int)timeout, sockopts);
    if(!(sockfd == -1))
      break;

    if(hostent == ((struct hostent *)NULL))
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      h = h + 1ul;
      tmp_if_expr$13 = !(hostent->h_addr_list[(signed long int)h] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$13)
      break;

    if(hostent->h_addrtype == 2)
    {
      remoteaddr=net_inaddr(&remoteany.in, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)h], (unsigned long int)hostent->h_length, port);
      remotesize = sizeof(struct sockaddr_in) /*16ul*/ ;
    }

    else
      if(hostent->h_addrtype == 10)
      {
        remoteaddr=net_in6addr(&remoteany.in6, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)h], (unsigned long int)hostent->h_length, port);
        remotesize = sizeof(struct sockaddr_in6) /*28ul*/ ;
      }

  }
  while((_Bool)1);
  free(buf);
  if(sockfd == -1)
    return -1;

  else
  {
    if(!(addr == ((struct sockaddr *)NULL)) && !(addrsize == ((unsigned long int *)NULL)))
    {
      if(*addrsize >= remotesize)
        memcpy((void *)addr, (const void *)remoteaddr, remotesize);

    }

    if(!(addrsize == ((unsigned long int *)NULL)))
      *addrsize = remotesize;

    return sockfd;
  }
}

// net_create_server
// file libslack/net.c line 577
signed int net_create_server(const char *interface, const char *service, unsigned short int port, signed int type, signed int protocol, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize)
{
  signed int sockfd;
  union sockaddr_any_t localany;
  struct sockaddr *localaddr;
  unsigned long int localsize;
  struct hostent *hostent;
  signed int reuse_addr = 1;
  _Bool tmp_if_expr$12;
  signed int tmp_statement_expression$10;
  if(!(interface == ((const char *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$11;
    return_value___builtin_strcmp$11=__builtin_strcmp(interface, "/unix");
    tmp_statement_expression$10 = return_value___builtin_strcmp$11;
    tmp_if_expr$12 = !(tmp_statement_expression$10 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$12 = (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$12)
  {
    if(service == ((const char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*service != 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(service[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strlen$4=strlen(service);
      tmp_if_expr$5 = return_value_strlen$4 >= sizeof(char [108l]) /*108ul*/  ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      return_value_set_errno$1=set_errno(22);
      return return_value_set_errno$1;
    }

    localaddr=net_unaddr(&localany.un, (unsigned long int)1, service);
    localsize = sizeof(struct sockaddr_un) /*110ul*/ ;
    unlink(localany.un.sun_path);
  }

  else
  {
    port=service_port(service, type, (signed int)port);
    if(!(interface == ((const char *)NULL)))
    {
      struct hostent hostbuf[1l];
      void *buf = (void *)0;
      unsigned long int net_create_server$$1$$3$$1$$size = (unsigned long int)0;
      signed int herrno;
      hostent=net_gethostbyname(interface, hostbuf, &buf, &net_create_server$$1$$3$$1$$size, &herrno);
      if(hostent == ((struct hostent *)NULL))
      {
        free(buf);
        signed int return_value_set_errno$6;
        return_value_set_errno$6=set_errno(2);
        return return_value_set_errno$6;
      }

      if(hostent->h_addrtype == 2)
      {
        localaddr=net_inaddr(&localany.in, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
        localsize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }

      else
        if(hostent->h_addrtype == 10)
        {
          localaddr=net_in6addr(&localany.in6, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
          localsize = sizeof(struct sockaddr_in6) /*28ul*/ ;
        }

        else
        {
          free(buf);
          signed int return_value_set_errno$7;
          return_value_set_errno$7=set_errno(38);
          return return_value_set_errno$7;
        }
      free(buf);
    }

    else
    {
      signed int return_value_inet6_required$9;
      return_value_inet6_required$9=inet6_required();
      if(!(return_value_inet6_required$9 == 0))
      {
        localaddr=net_in6addr(&localany.in6, (unsigned long int)10, (const void *)&in6addr_any, sizeof(struct in6_addr) /*16ul*/ , port);
        localsize = sizeof(struct sockaddr_in6) /*28ul*/ ;
      }

      else
      {
        unsigned long int inaddr_any;
        unsigned int return_value___bswap_32$8;
        return_value___bswap_32$8=__bswap_32((unsigned int)0x00000000);
        inaddr_any = (unsigned long int)return_value___bswap_32$8;
        localaddr=net_inaddr(&localany.in, (unsigned long int)2, (const void *)&inaddr_any, sizeof(unsigned long int) /*8ul*/ , port);
        localsize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }
    }
  }
  sockfd=socket((signed int)localaddr->sa_family, type, protocol);
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$16;
  signed int return_value_is_multicast$15;
  signed int return_value_setsockopt$13;
  signed int return_value_net_options$18;
  signed int return_value_listen$20;
  if(sockfd == -1)
    return -1;

  else
  {
    if(type == 1)
      tmp_if_expr$14 = (signed int)localaddr->sa_family != 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$14 = (_Bool)0;
    if(tmp_if_expr$14)
      tmp_if_expr$17 = (_Bool)1;

    else
    {
      if(type == 2)
      {
        return_value_is_multicast$15=is_multicast(localaddr);
        tmp_if_expr$16 = return_value_is_multicast$15 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$16 = (_Bool)0;
      tmp_if_expr$17 = tmp_if_expr$16 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$17)
    {
      return_value_setsockopt$13=setsockopt(sockfd, 1, 2, (const void *)&reuse_addr, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt$13 == -1))
        goto __CPROVER_DUMP_L26;

      close(sockfd);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L26:
      ;
      if(!(sockopts == ((struct sockopt_t *)NULL)))
      {
        return_value_net_options$18=net_options(sockfd, sockopts);
        if(!(return_value_net_options$18 == -1))
          goto __CPROVER_DUMP_L27;

        close(sockfd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L27:
        ;
        signed int return_value_bind$19;
        return_value_bind$19=bind(sockfd, localaddr, (unsigned int)localsize);
        if(return_value_bind$19 == -1)
        {
          close(sockfd);
          return -1;
        }

        else
          if(type == 1)
          {
            return_value_listen$20=listen(sockfd, 1024);
            if(!(return_value_listen$20 == -1))
              goto __CPROVER_DUMP_L29;

            close(sockfd);
            return -1;
          }

          else
          {

          __CPROVER_DUMP_L29:
            ;
            if(!(addr == ((struct sockaddr *)NULL)) && !(addrsize == ((unsigned long int *)NULL)))
            {
              if(*addrsize >= localsize)
                memcpy((void *)addr, (const void *)localaddr, localsize);

            }

            if(!(addrsize == ((unsigned long int *)NULL)))
              *addrsize = localsize;

            return sockfd;
          }
      }
    }
  }
}

// net_expect
// file libslack/net.c line 3761
signed long int net_expect(signed int sockfd, signed long int timeout, const char *format, ...)
{
  void **args;
  signed long int rc;
  args = (void **)&format;
  rc=net_vexpect(sockfd, timeout, format, args);
  args = ((void **)NULL);
  return rc;
}

// net_gethostbyname
// file libslack/net.c line 1779
struct hostent * net_gethostbyname(const char *name, struct hostent *hostbuf, void **buf, unsigned long int *size, signed int *herrno)
{
  _Bool tmp_if_expr$2;
  if(buf == ((void **)NULL) || name == ((const char *)NULL) || hostbuf == ((struct hostent *)NULL) || size == ((unsigned long int *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ((signed int)!(*buf != NULL) ^ (signed int)!(*size != 0ul)) != 0 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull$1;
  signed int *return_value___errno_location$3;
  void *return_value_mem_resize_fn$4;
  if(herrno == ((signed int *)NULL) || tmp_if_expr$2)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct hostent *)return_value_set_errnull$1;
  }

  else
  {
    struct hostent *ret;
    signed int err;
    if(*size == 0ul)
    {
      *size = (unsigned long int)1024;
      *buf=malloc(*size);
      if(!(*buf == NULL))
        goto __CPROVER_DUMP_L4;

      return (struct hostent *)(void *)0;
    }

    else
    {
      do
      {

      __CPROVER_DUMP_L4:
        ;
        err=gethostbyname_r(name, hostbuf, (char *)*buf, *size, &ret, herrno);
        if(err == 0)
          break;

        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 34))
          break;

        *size = *size << 1;
        return_value_mem_resize_fn$4=mem_resize_fn((void **)(char **)buf, *size * sizeof(char) /*1ul*/ );
        if(return_value_mem_resize_fn$4 == NULL)
          return (struct hostent *)(void *)0;

      }
      while((_Bool)1);
      return err != 0 ? (struct hostent *)(void *)0 : ret;
    }
  }
}

// net_getservbyname
// file libslack/net.c line 1895
struct servent * net_getservbyname(const char *name, const char *proto, struct servent *servbuf, void **buf, unsigned long int *size)
{
  _Bool tmp_if_expr$2;
  if(buf == ((void **)NULL) || name == ((const char *)NULL) || servbuf == ((struct servent *)NULL) || size == ((unsigned long int *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ((signed int)!(*buf != NULL) ^ (signed int)!(*size != 0ul)) != 0 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull$1;
  signed int *return_value___errno_location$3;
  void *return_value_mem_resize_fn$4;
  if(tmp_if_expr$2)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct servent *)return_value_set_errnull$1;
  }

  else
  {
    struct servent *ret;
    signed int err;
    if(*size == 0ul)
    {
      *size = (unsigned long int)128;
      *buf=malloc(*size);
      if(!(*buf == NULL))
        goto __CPROVER_DUMP_L4;

      return (struct servent *)(void *)0;
    }

    else
    {
      do
      {

      __CPROVER_DUMP_L4:
        ;
        err=getservbyname_r(name, proto, servbuf, (char *)*buf, *size, &ret);
        if(err == 0)
          break;

        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 34))
          break;

        *size = *size << 1;
        return_value_mem_resize_fn$4=mem_resize_fn((void **)(char **)buf, *size * sizeof(char) /*1ul*/ );
        if(return_value_mem_resize_fn$4 == NULL)
          return (struct servent *)(void *)0;

      }
      while((_Bool)1);
      return err != 0 ? (struct servent *)(void *)0 : ret;
    }
  }
}

// net_in6addr
// file libslack/net.c line 457
static struct sockaddr * net_in6addr(struct sockaddr_in6 *in6, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port)
{
  memset((void *)in6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
  in6->sin6_family = (unsigned short int)family;
  memcpy((void *)&in6->sin6_addr, addr, addrsize);
  in6->sin6_port = port;
  return (struct sockaddr *)in6;
}

// net_inaddr
// file libslack/net.c line 447
static struct sockaddr * net_inaddr(struct sockaddr_in *in, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port)
{
  memset((void *)in, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  in->sin_family = (unsigned short int)family;
  memcpy((void *)&in->sin_addr, addr, addrsize);
  in->sin_port = port;
  return (struct sockaddr *)in;
}

// net_interfaces
// file libslack/net.c line 2039
struct List * net_interfaces(void)
{
  struct List *return_value_net_interfaces_with_locker$1;
  return_value_net_interfaces_with_locker$1=net_interfaces_with_locker((struct Locker *)(void *)0);
  return return_value_net_interfaces_with_locker$1;
}

// net_interfaces_by_family
// file libslack/net.c line 2080
struct List * net_interfaces_by_family(signed int family)
{
  struct List *return_value_net_interfaces_by_family_with_locker$1;
  return_value_net_interfaces_by_family_with_locker$1=net_interfaces_by_family_with_locker(family, (struct Locker *)(void *)0);
  return return_value_net_interfaces_by_family_with_locker$1;
}

// net_interfaces_by_family_with_locker
// file libslack/net.c line 2096
struct List * net_interfaces_by_family_with_locker(signed int family, struct Locker *locker)
{
  struct List *ret;
  signed int sockfd;
  unsigned long int net_interfaces_by_family_with_locker$$1$$size;
  unsigned long int lastsize = (unsigned long int)0;
  char *buf = (char *)(void *)0;
  char *ptr;
  struct ifconf ifc[1l];
  signed int index = 0;
  ret=list_create_with_locker(locker, (void (*)(void *))iface_release);
  if(ret == ((struct List *)NULL))
    return (struct List *)(void *)0;

  else
  {
    sockfd=socket(family, 2, 0);
    if(sockfd == -1)
    {
      list_release(ret);
      return (struct List *)(void *)0;
    }

    else
    {
      net_interfaces_by_family_with_locker$$1$$size = (unsigned long int)100 * sizeof(struct ifreq) /*40ul*/ ;
      do
      {
        void *return_value_mem_resize_fn$1;
        return_value_mem_resize_fn$1=mem_resize_fn((void **)&buf, net_interfaces_by_family_with_locker$$1$$size * sizeof(char) /*1ul*/ );
        if(return_value_mem_resize_fn$1 == NULL)
        {
          list_release(ret);
          free((void *)buf);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        ifc[0l].ifc_len = (signed int)net_interfaces_by_family_with_locker$$1$$size;
        ifc[0l].ifc_ifcu.ifcu_buf = buf;
        signed int return_value_ioctl$3;
        return_value_ioctl$3=ioctl(sockfd, (unsigned long int)0x8912, (const void *)ifc);
        if(return_value_ioctl$3 == -1)
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          if(!(*return_value___errno_location$2 == 22) || !(lastsize == 0ul))
          {
            list_release(ret);
            free((void *)buf);
            close(sockfd);
            return (struct List *)(void *)0;
          }

        }

        else
        {
          if((unsigned long int)ifc[0l].ifc_len == lastsize)
            break;

          lastsize = (unsigned long int)ifc[0l].ifc_len;
        }
        net_interfaces_by_family_with_locker$$1$$size = net_interfaces_by_family_with_locker$$1$$size + (unsigned long int)10 * sizeof(struct ifreq) /*40ul*/ ;
      }
      while((_Bool)1);
      ptr = buf;
      while(!(ptr >= buf + (signed long int)lastsize))
      {
        struct ifreq *ifr = (struct ifreq *)ptr;
        struct ifreq ifrcopy[1l];
        struct net_interface_t *iface;
        void *return_value_calloc$4;
        return_value_calloc$4=calloc((unsigned long int)1, sizeof(struct net_interface_t) /*64ul*/ );
        iface = (struct net_interface_t *)return_value_calloc$4;
        if(iface == ((struct net_interface_t *)NULL))
        {
          list_release(ret);
          free((void *)buf);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        struct List *return_value_list_append$5;
        return_value_list_append$5=list_append(ret, (void *)iface);
        if(return_value_list_append$5 == ((struct List *)NULL))
        {
          list_release(ret);
          free((void *)buf);
          free((void *)iface);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        if(!((signed int)ifr->ifr_ifru.ifru_addr.sa_family == 10))
        {
          if((signed int)ifr->ifr_ifru.ifru_addr.sa_family == 2)
            goto __CPROVER_DUMP_L14;

        }

        else
        {
          net_interfaces_by_family_with_locker$$1$$size = sizeof(struct sockaddr_in6) /*28ul*/ ;
          goto __CPROVER_DUMP_L15;
        }

      __CPROVER_DUMP_L14:
        ;
        net_interfaces_by_family_with_locker$$1$$size = sizeof(struct sockaddr) /*16ul*/ ;

      __CPROVER_DUMP_L15:
        ;
        ptr = ptr + (signed long int)(sizeof(char [16l]) /*16ul*/  + net_interfaces_by_family_with_locker$$1$$size);
        ifrcopy[0l] = *ifr;
        signed int return_value_ioctl$6;
        return_value_ioctl$6=ioctl(sockfd, (unsigned long int)0x8913, (const void *)ifrcopy);
        if(return_value_ioctl$6 == -1)
        {
          list_release(ret);
          free((void *)buf);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        iface->flags = ifrcopy[0l].ifr_ifru.ifru_flags;
        strlcpy(iface->name, ifr->ifr_ifrn.ifrn_name, (unsigned long int)16);
        if(!((1 & (signed int)iface->flags) == 0))
        {
          void *return_value_calloc$7;
          return_value_calloc$7=calloc((unsigned long int)1, net_interfaces_by_family_with_locker$$1$$size);
          iface->addr = (union sockaddr_any_t *)return_value_calloc$7;
          if(iface->addr == ((union sockaddr_any_t *)NULL))
          {
            list_release(ret);
            free((void *)buf);
            close(sockfd);
            return (struct List *)(void *)0;
          }

          memcpy((void *)iface->addr, (const void *)&ifr->ifr_ifru.ifru_addr, net_interfaces_by_family_with_locker$$1$$size);
          signed int return_value_ioctl$9;
          return_value_ioctl$9=ioctl(sockfd, (unsigned long int)0x8927, (const void *)ifrcopy);
          if(return_value_ioctl$9 == 0)
          {
            void *return_value_malloc$8;
            return_value_malloc$8=malloc(sizeof(struct sockaddr) /*16ul*/ );
            iface->hwaddr = (union sockaddr_any_t *)return_value_malloc$8;
            if(iface->hwaddr == ((union sockaddr_any_t *)NULL))
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            memcpy((void *)iface->hwaddr, (const void *)&ifrcopy[0l].ifr_ifru.ifru_hwaddr, sizeof(struct sockaddr) /*16ul*/ );
          }

          if(!((2 & (signed int)iface->flags) == 0))
          {
            signed int return_value_ioctl$10;
            return_value_ioctl$10=ioctl(sockfd, (unsigned long int)0x8919, (const void *)ifrcopy);
            if(return_value_ioctl$10 == -1)
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            void *return_value_calloc$11;
            return_value_calloc$11=calloc((unsigned long int)1, net_interfaces_by_family_with_locker$$1$$size);
            iface->brdaddr = (union sockaddr_any_t *)return_value_calloc$11;
            if(iface->brdaddr == ((union sockaddr_any_t *)NULL))
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            memcpy((void *)iface->brdaddr, (const void *)&ifrcopy[0l].ifr_ifru.ifru_broadaddr, net_interfaces_by_family_with_locker$$1$$size);
          }

          if(!((16 & (signed int)iface->flags) == 0))
          {
            signed int return_value_ioctl$12;
            return_value_ioctl$12=ioctl(sockfd, (unsigned long int)0x8917, (const void *)ifrcopy);
            if(return_value_ioctl$12 == -1)
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            void *return_value_calloc$13;
            return_value_calloc$13=calloc((unsigned long int)1, net_interfaces_by_family_with_locker$$1$$size);
            iface->dstaddr = (union sockaddr_any_t *)return_value_calloc$13;
            if(iface->dstaddr == ((union sockaddr_any_t *)NULL))
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            memcpy((void *)iface->dstaddr, (const void *)&ifrcopy[0l].ifr_ifru.ifru_dstaddr, net_interfaces_by_family_with_locker$$1$$size);
          }

        }

        signed int return_value_ioctl$14;
        return_value_ioctl$14=ioctl(sockfd, (unsigned long int)0x8921, (const void *)ifrcopy);
        if(!(return_value_ioctl$14 == -1))
          iface->mtu = ifrcopy[0l].ifr_ifru.ifru_mtu;

        else
          iface->mtu = -1;
        signed int return_value_ioctl$15;
        return_value_ioctl$15=ioctl(sockfd, (unsigned long int)0x8933, (const void *)ifrcopy);
        if(!(return_value_ioctl$15 == -1))
          iface->index = (unsigned int)ifrcopy[0l].ifr_ifru.ifru_ivalue;

        else
        {
          index = index + 1;
          iface->index = (unsigned int)index;
        }
      }
      free((void *)buf);
      close(sockfd);
      return ret;
    }
  }
}

// net_interfaces_with_locker
// file libslack/net.c line 2055
struct List * net_interfaces_with_locker(struct Locker *locker)
{
  signed int family;
  signed int return_value_inet6_required$1;
  return_value_inet6_required$1=inet6_required();
  if(!(return_value_inet6_required$1 == 0))
    family = 10;

  else
    family = 2;
  struct List *return_value_net_interfaces_by_family_with_locker$2;
  return_value_net_interfaces_by_family_with_locker$2=net_interfaces_by_family_with_locker(family, locker);
  return return_value_net_interfaces_by_family_with_locker$2;
}

// net_multicast_get_interface
// file libslack/net.c line 1389
signed int net_multicast_get_interface(signed int sockfd)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_get_interface$$1$$size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname$1;
  return_value_getsockname$1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_get_interface$$1$$size);
  struct in_addr inaddr;
  unsigned long int net_multicast_get_interface$$1$$1$$1$$size;
  unsigned int net_multicast_get_interface$$1$$1$$1$$index;
  struct List *ifaces;
  signed int return_value_getsockopt$2;
  signed int return_value_list_has_next$3;
  signed int return_value_memcmp$5;
  unsigned int index;
  unsigned long int net_multicast_get_interface$$1$$1$$2$$size;
  signed int return_value_getsockopt$6;
  signed int return_value_set_errno$7;
  if(return_value_getsockname$1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        net_multicast_get_interface$$1$$1$$1$$size = sizeof(struct in_addr) /*4ul*/ ;
        net_multicast_get_interface$$1$$1$$1$$index = (unsigned int)0;
        return_value_getsockopt$2=getsockopt(sockfd, 0, 32, (void *)&inaddr, (unsigned int *)(void *)&net_multicast_get_interface$$1$$1$$1$$size);
        if(return_value_getsockopt$2 == -1)
          return -1;

        ifaces=net_interfaces_by_family(2);
        if(ifaces == ((struct List *)NULL))
          return -1;

        do
        {
          return_value_list_has_next$3=list_has_next(ifaces);
          if(return_value_list_has_next$3 == 0)
            break;

          struct net_interface_t *iface;
          void *return_value_list_next$4;
          return_value_list_next$4=list_next(ifaces);
          iface = (struct net_interface_t *)return_value_list_next$4;
          if(!((1 & (signed int)iface->flags) == 0))
          {
            if((signed int)iface->addr->any.sa_family == 2)
            {
              return_value_memcmp$5=memcmp((const void *)&inaddr, (const void *)&iface->addr->in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
              if(return_value_memcmp$5 == 0)
              {
                net_multicast_get_interface$$1$$1$$1$$index = iface->index;
                list_break(ifaces);
                break;
              }

            }

          }

        }
        while((_Bool)1);
        list_release(ifaces);
        return (signed int)net_multicast_get_interface$$1$$1$$1$$index;
      }
      case 10:
      {
        net_multicast_get_interface$$1$$1$$2$$size = sizeof(unsigned int) /*4ul*/ ;
        return_value_getsockopt$6=getsockopt(sockfd, 41, 17, (void *)&index, (unsigned int *)(void *)&net_multicast_get_interface$$1$$1$$2$$size);
        if(return_value_getsockopt$6 == -1)
          return -1;

        return (signed int)index;
      }
      default:
      {
        return_value_set_errno$7=set_errno(93);
        return return_value_set_errno$7;
      }
    }
}

// net_multicast_get_loopback
// file libslack/net.c line 1509
signed int net_multicast_get_loopback(signed int sockfd)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_get_loopback$$1$$size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname$1;
  return_value_getsockname$1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_get_loopback$$1$$size);
  unsigned char flag;
  unsigned long int net_multicast_get_loopback$$1$$1$$1$$size;
  signed int return_value_getsockopt$2;
  unsigned int net_multicast_get_loopback$$1$$1$$2$$flag;
  unsigned long int net_multicast_get_loopback$$1$$1$$2$$size;
  signed int return_value_getsockopt$3;
  signed int return_value_set_errno$4;
  if(return_value_getsockname$1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        net_multicast_get_loopback$$1$$1$$1$$size = sizeof(unsigned char) /*1ul*/ ;
        return_value_getsockopt$2=getsockopt(sockfd, 0, 34, (void *)&flag, (unsigned int *)(void *)&net_multicast_get_loopback$$1$$1$$1$$size);
        if(return_value_getsockopt$2 == -1)
          return -1;

        return (signed int)flag;
      }
      case 10:
      {
        net_multicast_get_loopback$$1$$1$$2$$size = sizeof(unsigned int) /*4ul*/ ;
        return_value_getsockopt$3=getsockopt(sockfd, 41, 19, (void *)&net_multicast_get_loopback$$1$$1$$2$$flag, (unsigned int *)(void *)&net_multicast_get_loopback$$1$$1$$2$$size);
        if(return_value_getsockopt$3 == -1)
          return -1;

        return (signed int)net_multicast_get_loopback$$1$$1$$2$$flag;
      }
      default:
      {
        return_value_set_errno$4=set_errno(93);
        return return_value_set_errno$4;
      }
    }
}

// net_multicast_get_ttl
// file libslack/net.c line 1603
signed int net_multicast_get_ttl(signed int sockfd)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_get_ttl$$1$$size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname$1;
  return_value_getsockname$1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_get_ttl$$1$$size);
  unsigned char hops;
  unsigned long int net_multicast_get_ttl$$1$$1$$1$$size;
  signed int return_value_getsockopt$2;
  signed int net_multicast_get_ttl$$1$$1$$2$$hops;
  unsigned long int net_multicast_get_ttl$$1$$1$$2$$size;
  signed int return_value_getsockopt$3;
  signed int return_value_set_errno$4;
  if(return_value_getsockname$1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        net_multicast_get_ttl$$1$$1$$1$$size = sizeof(unsigned char) /*1ul*/ ;
        return_value_getsockopt$2=getsockopt(sockfd, 0, 33, (void *)&hops, (unsigned int *)(void *)&net_multicast_get_ttl$$1$$1$$1$$size);
        if(return_value_getsockopt$2 == -1)
          return -1;

        return (signed int)hops;
      }
      case 10:
      {
        net_multicast_get_ttl$$1$$1$$2$$size = sizeof(signed int) /*4ul*/ ;
        return_value_getsockopt$3=getsockopt(sockfd, 41, 18, (void *)&net_multicast_get_ttl$$1$$1$$2$$hops, (unsigned int *)(void *)&net_multicast_get_ttl$$1$$1$$2$$size);
        if(return_value_getsockopt$3 == -1)
          return -1;

        return net_multicast_get_ttl$$1$$1$$2$$hops;
      }
      default:
      {
        return_value_set_errno$4=set_errno(93);
        return return_value_set_errno$4;
      }
    }
}

// net_multicast_join
// file libslack/net.c line 1158
signed int net_multicast_join(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t *any = (union sockaddr_any_t *)addr;
  struct ip_mreq mreq[1l];
  struct ifreq ifreq[1l];
  signed int return_value_set_errno$1;
  signed int return_value_setsockopt$4;
  struct ipv6_mreq net_multicast_join$$1$$1$$2$$mreq[1l];
  signed int return_value_set_errno$5;
  signed int return_value_setsockopt$6;
  signed int return_value_set_errno$7;
  switch((signed int)any->any.sa_family)
  {
    case 2:
    {
      memcpy((void *)&mreq[0l].imr_multiaddr, (const void *)&any->in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
      if(ifname == ((const char *)NULL) && ifindex == 0u)
        mreq[0l].imr_interface.s_addr=__bswap_32((unsigned int)0x00000000);

      else
      {
        if(!(ifname == ((const char *)NULL)))
          strlcpy(ifreq[0l].ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);

        else
          if(!(ifindex == 0u))
          {
            char *return_value_if_indextoname$2;
            return_value_if_indextoname$2=if_indextoname(ifindex, ifreq[0l].ifr_ifrn.ifrn_name);
            if(return_value_if_indextoname$2 == ((char *)NULL))
            {
              return_value_set_errno$1=set_errno(6);
              return return_value_set_errno$1;
            }

          }

        signed int return_value_ioctl$3;
        return_value_ioctl$3=ioctl(sockfd, (unsigned long int)0x8915, (const void *)ifreq);
        if(return_value_ioctl$3 == -1)
          return -1;

        memcpy((void *)&mreq[0l].imr_interface, (const void *)&((struct sockaddr_in *)&ifreq[0l].ifr_ifru.ifru_addr)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
      }
      return_value_setsockopt$4=setsockopt(sockfd, 0, 35, (const void *)mreq, (unsigned int)sizeof(struct ip_mreq [1l]) /*8ul*/ );
      return return_value_setsockopt$4;
    }
    case 10:
    {
      memcpy((void *)&net_multicast_join$$1$$1$$2$$mreq[0l].ipv6mr_multiaddr, (const void *)&any->in6.sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
      if(!(ifname == ((const char *)NULL)))
      {
        net_multicast_join$$1$$1$$2$$mreq[0l].ipv6mr_interface=if_nametoindex(ifname);
        if(net_multicast_join$$1$$1$$2$$mreq[0l].ipv6mr_interface == 0u)
        {
          return_value_set_errno$5=set_errno(6);
          return return_value_set_errno$5;
        }

      }

      else
        net_multicast_join$$1$$1$$2$$mreq[0l].ipv6mr_interface = ifindex;
      return_value_setsockopt$6=setsockopt(sockfd, 41, 20, (const void *)net_multicast_join$$1$$1$$2$$mreq, (unsigned int)sizeof(struct ipv6_mreq [1l]) /*20ul*/ );
      return return_value_setsockopt$6;
    }
    default:
    {
      return_value_set_errno$7=set_errno(93);
      return return_value_set_errno$7;
    }
  }
}

// net_multicast_leave
// file libslack/net.c line 1238
signed int net_multicast_leave(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t *any = (union sockaddr_any_t *)addr;
  struct ip_mreq mreq[1l];
  struct ifreq ifreq[1l];
  signed int return_value_set_errno$1;
  signed int return_value_setsockopt$4;
  struct ipv6_mreq net_multicast_leave$$1$$1$$2$$mreq[1l];
  signed int return_value_set_errno$5;
  signed int return_value_setsockopt$6;
  signed int return_value_set_errno$7;
  switch((signed int)any->any.sa_family)
  {
    case 2:
    {
      memcpy((void *)&mreq[0l].imr_multiaddr, (const void *)&any->in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
      if(ifname == ((const char *)NULL) && ifindex == 0u)
        mreq[0l].imr_interface.s_addr=__bswap_32((unsigned int)0x00000000);

      else
      {
        if(!(ifname == ((const char *)NULL)))
          strlcpy(ifreq[0l].ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);

        else
          if(!(ifindex == 0u))
          {
            char *return_value_if_indextoname$2;
            return_value_if_indextoname$2=if_indextoname(ifindex, ifreq[0l].ifr_ifrn.ifrn_name);
            if(return_value_if_indextoname$2 == ((char *)NULL))
            {
              return_value_set_errno$1=set_errno(6);
              return return_value_set_errno$1;
            }

          }

        signed int return_value_ioctl$3;
        return_value_ioctl$3=ioctl(sockfd, (unsigned long int)0x8915, (const void *)ifreq);
        if(return_value_ioctl$3 == -1)
          return -1;

        memcpy((void *)&mreq[0l].imr_interface, (const void *)&((struct sockaddr_in *)&ifreq[0l].ifr_ifru.ifru_addr)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
      }
      return_value_setsockopt$4=setsockopt(sockfd, 0, 36, (const void *)mreq, (unsigned int)sizeof(struct ip_mreq [1l]) /*8ul*/ );
      return return_value_setsockopt$4;
    }
    case 10:
    {
      memcpy((void *)&net_multicast_leave$$1$$1$$2$$mreq[0l].ipv6mr_multiaddr, (const void *)&any->in6.sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
      if(!(ifname == ((const char *)NULL)))
      {
        net_multicast_leave$$1$$1$$2$$mreq[0l].ipv6mr_interface=if_nametoindex(ifname);
        if(net_multicast_leave$$1$$1$$2$$mreq[0l].ipv6mr_interface == 0u)
        {
          return_value_set_errno$5=set_errno(6);
          return return_value_set_errno$5;
        }

      }

      else
        net_multicast_leave$$1$$1$$2$$mreq[0l].ipv6mr_interface = ifindex;
      return_value_setsockopt$6=setsockopt(sockfd, 41, 21, (const void *)net_multicast_leave$$1$$1$$2$$mreq, (unsigned int)sizeof(struct ipv6_mreq [1l]) /*20ul*/ );
      return return_value_setsockopt$6;
    }
    default:
    {
      return_value_set_errno$7=set_errno(93);
      return return_value_set_errno$7;
    }
  }
}

// net_multicast_receiver
// file libslack/net.c line 1054
signed int net_multicast_receiver(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t any[1l];
  unsigned long int anysize = sizeof(union sockaddr_any_t [1l]) /*112ul*/ ;
  signed int sockfd;
  if(addr == ((struct sockaddr *)NULL))
    addr = (struct sockaddr *)any;

  if(addrsize == ((unsigned long int *)NULL))
    addrsize = &anysize;

  sockfd=net_create_server(group, service, port, 2, 0, sockopts, addr, addrsize);
  if(sockfd == -1)
    return -1;

  else
  {
    signed int return_value_net_multicast_join$1;
    return_value_net_multicast_join$1=net_multicast_join(sockfd, addr, *addrsize, ifname, ifindex);
    if(return_value_net_multicast_join$1 == -1)
    {
      close(sockfd);
      return -1;
    }

    else
      return sockfd;
  }
}

// net_multicast_sender
// file libslack/net.c line 995
signed int net_multicast_sender(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex, signed int ttl, unsigned int noloopback)
{
  signed int sockfd;
  unsigned int loopback = (unsigned int)0;
  sockfd=net_create_client(group, service, port, (unsigned short int)0, 2, 0, (signed long int)0, sockopts, addr, addrsize);
  signed int return_value_net_multicast_set_interface$1;
  signed int return_value_net_multicast_set_ttl$2;
  signed int return_value_net_multicast_set_loopback$3;
  if(sockfd == -1)
    return -1;

  else
    if(!(ifname == ((const char *)NULL)) || !(ifindex == 0u))
    {
      return_value_net_multicast_set_interface$1=net_multicast_set_interface(sockfd, ifname, ifindex);
      if(!(return_value_net_multicast_set_interface$1 == -1))
        goto __CPROVER_DUMP_L2;

      close(sockfd);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(ttl >= 2)
      {
        return_value_net_multicast_set_ttl$2=net_multicast_set_ttl(sockfd, ttl);
        if(!(return_value_net_multicast_set_ttl$2 == -1))
          goto __CPROVER_DUMP_L3;

        close(sockfd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(!(noloopback == 0u))
        {
          return_value_net_multicast_set_loopback$3=net_multicast_set_loopback(sockfd, loopback);
          if(!(return_value_net_multicast_set_loopback$3 == -1))
            goto __CPROVER_DUMP_L4;

          close(sockfd);
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          return sockfd;
        }
      }
    }
}

// net_multicast_set_interface
// file libslack/net.c line 1319
signed int net_multicast_set_interface(signed int sockfd, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_set_interface$$1$$size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname$1;
  return_value_getsockname$1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_set_interface$$1$$size);
  struct ifreq ifreq[1l];
  struct in_addr inaddr;
  signed int return_value_set_errno$2;
  signed int return_value_setsockopt$5;
  unsigned int index;
  signed int return_value_set_errno$6;
  signed int return_value_setsockopt$7;
  signed int return_value_set_errno$8;
  if(return_value_getsockname$1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        if(ifname == ((const char *)NULL) && ifindex == 0u)
          inaddr.s_addr=__bswap_32((unsigned int)0x00000000);

        else
        {
          if(!(ifname == ((const char *)NULL)))
            strlcpy(ifreq[0l].ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);

          else
            if(!(ifindex == 0u))
            {
              char *return_value_if_indextoname$3;
              return_value_if_indextoname$3=if_indextoname(ifindex, ifreq[0l].ifr_ifrn.ifrn_name);
              if(return_value_if_indextoname$3 == ((char *)NULL))
              {
                return_value_set_errno$2=set_errno(6);
                return return_value_set_errno$2;
              }

            }

          signed int return_value_ioctl$4;
          return_value_ioctl$4=ioctl(sockfd, (unsigned long int)0x8915, (const void *)ifreq);
          if(return_value_ioctl$4 == -1)
            return -1;

          memcpy((void *)&inaddr, (const void *)&((struct sockaddr_in *)&ifreq[0l].ifr_ifru.ifru_addr)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
        }
        return_value_setsockopt$5=setsockopt(sockfd, 0, 32, (const void *)&inaddr, (unsigned int)sizeof(struct in_addr) /*4ul*/ );
        return return_value_setsockopt$5;
      }
      case 10:
      {
        if(!(ifname == ((const char *)NULL)))
        {
          index=if_nametoindex(ifname);
          if(index == 0u)
          {
            return_value_set_errno$6=set_errno(6);
            return return_value_set_errno$6;
          }

        }

        index = ifindex;
        return_value_setsockopt$7=setsockopt(sockfd, 41, 17, (const void *)&index, (unsigned int)sizeof(unsigned int) /*4ul*/ );
        return return_value_setsockopt$7;
      }
      default:
      {
        return_value_set_errno$8=set_errno(93);
        return return_value_set_errno$8;
      }
    }
}

// net_multicast_set_loopback
// file libslack/net.c line 1465
signed int net_multicast_set_loopback(signed int sockfd, unsigned int loopback)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_set_loopback$$1$$size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname$1;
  return_value_getsockname$1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_set_loopback$$1$$size);
  unsigned char flag;
  signed int return_value_setsockopt$2;
  unsigned int net_multicast_set_loopback$$1$$1$$2$$flag;
  signed int return_value_setsockopt$3;
  signed int return_value_set_errno$4;
  if(return_value_getsockname$1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        flag = (unsigned char)loopback;
        return_value_setsockopt$2=setsockopt(sockfd, 0, 34, (const void *)&flag, (unsigned int)sizeof(unsigned char) /*1ul*/ );
        return return_value_setsockopt$2;
      }
      case 10:
      {
        net_multicast_set_loopback$$1$$1$$2$$flag = loopback;
        return_value_setsockopt$3=setsockopt(sockfd, 41, 19, (const void *)&net_multicast_set_loopback$$1$$1$$2$$flag, (unsigned int)sizeof(unsigned int) /*4ul*/ );
        return return_value_setsockopt$3;
      }
      default:
      {
        return_value_set_errno$4=set_errno(93);
        return return_value_set_errno$4;
      }
    }
}

// net_multicast_set_ttl
// file libslack/net.c line 1561
signed int net_multicast_set_ttl(signed int sockfd, signed int ttl)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_set_ttl$$1$$size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname$1;
  return_value_getsockname$1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_set_ttl$$1$$size);
  unsigned char hops;
  signed int return_value_setsockopt$2;
  signed int net_multicast_set_ttl$$1$$1$$2$$hops;
  signed int return_value_setsockopt$3;
  signed int return_value_set_errno$4;
  if(return_value_getsockname$1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        hops = (unsigned char)ttl;
        return_value_setsockopt$2=setsockopt(sockfd, 0, 33, (const void *)&hops, (unsigned int)sizeof(unsigned char) /*1ul*/ );
        return return_value_setsockopt$2;
      }
      case 10:
      {
        net_multicast_set_ttl$$1$$1$$2$$hops = ttl;
        return_value_setsockopt$3=setsockopt(sockfd, 41, 18, (const void *)&net_multicast_set_ttl$$1$$1$$2$$hops, (unsigned int)sizeof(signed int) /*4ul*/ );
        return return_value_setsockopt$3;
      }
      default:
      {
        return_value_set_errno$4=set_errno(93);
        return return_value_set_errno$4;
      }
    }
}

// net_options
// file libslack/net.c line 1989
signed int net_options(signed int sockfd, struct sockopt_t *sockopts)
{
  struct sockopt_t *so;
  signed int err = 0;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  signed int return_value_setsockopt$3;
  if(sockfd == -1)
  {
    return_value_set_errno$1=set_errno(9);
    return return_value_set_errno$1;
  }

  else
    if(sockopts == ((struct sockopt_t *)NULL))
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      so = sockopts;
      for( ; !(so->optval == NULL); so = so + 1l)
      {
        return_value_setsockopt$3=setsockopt(sockfd, so->level, so->optname, so->optval, (unsigned int)so->optlen);
        if(return_value_setsockopt$3 == -1)
          err = -1;

      }
      return err;
    }
}

// net_pack
// file libslack/net.c line 2706
signed long int net_pack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vpack$1;
  return_value_net_vpack$1=net_vpack(sockfd, timeout, flags, format, args);
  rc = (signed int)return_value_net_vpack$1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_packto
// file libslack/net.c line 2760
signed long int net_packto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vpackto$1;
  return_value_net_vpackto$1=net_vpackto(sockfd, timeout, flags, to, tosize, format, args);
  rc = (signed int)return_value_net_vpackto$1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_read
// file libslack/net.c line 3687
signed long int net_read(signed int sockfd, signed long int timeout, char *buf, unsigned long int count)
{
  char *b;
  signed long int bytes;
  b = buf;
  for( ; !(count == 0ul); b = b + bytes)
  {
    signed int return_value_read_timeout$1;
    return_value_read_timeout$1=read_timeout(sockfd, timeout, (signed long int)0);
    if(return_value_read_timeout$1 == -1)
      return (signed long int)-1;

    bytes=read(sockfd, (void *)b, count);
    if(bytes == -1l)
      return (signed long int)-1;

    if(bytes == 0l)
      break;

    count = count - (unsigned long int)bytes;
  }
  return b - buf;
}

// net_rudp_transact
// file libslack/net.c line 2557
signed long int net_rudp_transact(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, void *ibuf, unsigned long int isize)
{
  signed long int return_value_net_rudp_transactwith$1;
  return_value_net_rudp_transactwith$1=net_rudp_transactwith(sockfd, rudp, obuf, osize, 0, ibuf, isize, 0, (union sockaddr_any_t *)(void *)0, (unsigned long int)0);
  return return_value_net_rudp_transactwith$1;
}

// net_rudp_transactwith
// file libslack/net.c line 2582
signed long int net_rudp_transactwith(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, signed int oflags, void *ibuf, unsigned long int isize, signed int iflags, union sockaddr_any_t *addr, unsigned long int addrsize)
{
  /* tag-#anon#lST[U32'sequence'||U32'timestamp'|] */
struct anonymous$4
{
  // sequence
  unsigned int sequence;
  // timestamp
  unsigned int timestamp;
};

/* */
  ;
  struct anonymous$4 ohdr[1l];
  struct anonymous$4 ihdr[1l];
  struct msghdr omsg[1l];
  struct msghdr imsg[1l];
  struct iovec ovec[2l];
  struct iovec ivec[2l];
  signed int sequence;
  unsigned int timestamp;
  double net_rudp_transactwith$$1$$timeout;
  signed long int timeout_sec;
  signed long int timeout_usec;
  signed long int bytes;
  signed int return_value_set_errno$1;
  signed int return_value_read_timeout$7;
  signed int *return_value___errno_location$6;
  signed int return_value_rudp_timeout$5;
  _Bool tmp_if_expr$8;
  if(ibuf == NULL || obuf == NULL || rudp == ((struct rudp_t *)NULL) || isize == 0ul || osize == 0ul || !(sockfd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(addr == ((union sockaddr_any_t *)NULL)))
    {
      memset((void *)omsg, 0, sizeof(struct msghdr [1l]) /*56ul*/ );
      omsg[0l].msg_name = (void *)addr;
      omsg[0l].msg_namelen = (unsigned int)addrsize;
      omsg[0l].msg_iov = ovec;
      omsg[0l].msg_iovlen = (unsigned long int)2;
      memset((void *)imsg, 0, sizeof(struct msghdr [1l]) /*56ul*/ );
      imsg[0l].msg_iov = ivec;
      imsg[0l].msg_iovlen = (unsigned long int)2;
    }

    ovec[(signed long int)0].iov_base = (void *)ohdr;
    ovec[(signed long int)0].iov_len = sizeof(struct anonymous$4 [1l]) /*8ul*/ ;
    ovec[(signed long int)1].iov_base = (void *)obuf;
    ovec[(signed long int)1].iov_len = osize;
    ivec[(signed long int)0].iov_base = (void *)ihdr;
    ivec[(signed long int)0].iov_len = sizeof(struct anonymous$4 [1l]) /*8ul*/ ;
    ivec[(signed long int)1].iov_base = ibuf;
    ivec[(signed long int)1].iov_len = isize;
    unsigned int return_value_rudp_newpack$2;
    return_value_rudp_newpack$2=rudp_newpack(rudp);
    sequence = (signed int)return_value_rudp_newpack$2;
    if(sequence == -1)
      return (signed long int)-1;

    else
    {
      ohdr[0l].sequence = (unsigned int)sequence;
      do
      {

      sendagain:
        ;
        timestamp=rudp_timestamp(rudp);
        if(timestamp == 4294967295u)
          return (signed long int)-1;

        ohdr[0l].timestamp = timestamp;
        if(!(addr == ((union sockaddr_any_t *)NULL)))
        {
          signed long int return_value_sendmsg$3;
          return_value_sendmsg$3=sendmsg(sockfd, omsg, oflags);
          if(return_value_sendmsg$3 == -1l)
            return (signed long int)-1;

        }

        else
        {
          signed long int return_value_writev$4;
          return_value_writev$4=writev(sockfd, ovec, 2);
          if(return_value_writev$4 == -1l)
            return (signed long int)-1;

        }
        net_rudp_transactwith$$1$$timeout=rudp_start(rudp);
        if(IEEE_FLOAT_EQUAL(net_rudp_transactwith$$1$$timeout, -1.000000))
          return (signed long int)-1;

        timeout_sec = (signed long int)net_rudp_transactwith$$1$$timeout;
        timeout_usec = (signed long int)((net_rudp_transactwith$$1$$timeout - (double)timeout_sec) * (double)1000000);

      recvagain:
        ;
        return_value_read_timeout$7=read_timeout(sockfd, timeout_sec, timeout_usec);
        if(!(return_value_read_timeout$7 == -1))
          goto __CPROVER_DUMP_L13;

        return_value___errno_location$6=__errno_location();
        if(!(*return_value___errno_location$6 == 110))
          break;

        return_value_rudp_timeout$5=rudp_timeout(rudp);
      }
      while(!(return_value_rudp_timeout$5 == -1));
      rudp_init(rudp);
      return (signed long int)-1;

    __CPROVER_DUMP_L13:
      ;
      if(!(addr == ((union sockaddr_any_t *)NULL)))
      {
        bytes=recvmsg(sockfd, imsg, iflags);
        if(bytes == -1l)
          return (signed long int)-1;

      }

      else
      {
        bytes=readv(sockfd, ivec, 2);
        if(bytes == -1l)
          return (signed long int)-1;

      }
      if(!((unsigned long int)bytes >= sizeof(struct anonymous$4 [1l]) /*8ul*/ ))
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = ihdr[0l].sequence != ohdr[0l].sequence ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        goto recvagain;

      unsigned int return_value_rudp_timestamp$9;
      return_value_rudp_timestamp$9=rudp_timestamp(rudp);
      signed int return_value_rudp_stop$10;
      return_value_rudp_stop$10=rudp_stop(rudp, return_value_rudp_timestamp$9 - ihdr[0l].timestamp);
      if(return_value_rudp_stop$10 == -1)
        return (signed long int)-1;

      else
        return (signed long int)((unsigned long int)bytes - sizeof(struct anonymous$4 [1l]) /*8ul*/ );
    }
  }
}

// net_send
// file libslack/net.c line 3813
signed long int net_send(signed int sockfd, signed long int timeout, const char *format, ...)
{
  void **args;
  signed long int rc;
  args = (void **)&format;
  rc=net_vsend(sockfd, timeout, format, args);
  args = ((void **)NULL);
  return rc;
}

// net_server
// file libslack/net.c line 313
signed int net_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_server$1;
  return_value_net_create_server$1=net_create_server(interface, service, port, 1, 0, sockopts, addr, addrsize);
  return return_value_net_create_server$1;
}

// net_tos_lowcost
// file libslack/net.c line 1718
signed int net_tos_lowcost(signed int sockfd)
{
  signed int tos = 0x02;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// net_tos_lowdelay
// file libslack/net.c line 1655
signed int net_tos_lowdelay(signed int sockfd)
{
  signed int tos = 0x10;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// net_tos_normal
// file libslack/net.c line 1736
signed int net_tos_normal(signed int sockfd)
{
  signed int tos = 0x00;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// net_tos_reliability
// file libslack/net.c line 1695
signed int net_tos_reliability(signed int sockfd)
{
  signed int tos = 0x04;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// net_tos_throughput
// file libslack/net.c line 1675
signed int net_tos_throughput(signed int sockfd)
{
  signed int tos = 0x08;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// net_udp_client
// file libslack/net.c line 415
signed int net_udp_client(const char *host, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_client$1;
  return_value_net_create_client$1=net_create_client(host, service, port, (unsigned short int)0, 2, 0, (signed long int)0, sockopts, addr, addrsize);
  return return_value_net_create_client$1;
}

// net_udp_server
// file libslack/net.c line 392
signed int net_udp_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_server$1;
  return_value_net_create_server$1=net_create_server(interface, service, port, 2, 0, sockopts, addr, addrsize);
  return return_value_net_create_server$1;
}

// net_unaddr
// file libslack/net.c line 439
static struct sockaddr * net_unaddr(struct sockaddr_un *un, unsigned long int family, const char *path)
{
  memset((void *)un, 0, sizeof(struct sockaddr_un) /*110ul*/ );
  un->sun_family = (unsigned short int)family;
  strlcpy(un->sun_path, path, sizeof(char [108l]) /*108ul*/ );
  return (struct sockaddr *)un;
}

// net_unpack
// file libslack/net.c line 2818
signed long int net_unpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vunpack$1;
  return_value_net_vunpack$1=net_vunpack(sockfd, timeout, flags, format, args);
  rc = (signed int)return_value_net_vunpack$1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_unpackfrom
// file libslack/net.c line 2873
signed long int net_unpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vunpackfrom$1;
  return_value_net_vunpackfrom$1=net_vunpackfrom(sockfd, timeout, flags, from, fromsize, format, args);
  rc = (signed int)return_value_net_vunpackfrom$1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_vexpect
// file libslack/net.c line 3784
signed long int net_vexpect(signed int sockfd, signed long int timeout, const char *format, void **args)
{
  char buf[8193l];
  signed long int bytes;
  signed int return_value_read_timeout$1;
  return_value_read_timeout$1=read_timeout(sockfd, timeout, (signed long int)0);
  if(return_value_read_timeout$1 == -1)
    return (signed long int)-1;

  else
  {
    bytes=read(sockfd, (void *)buf, (unsigned long int)8192);
    if(!(bytes >= 1l))
      return bytes;

    else
    {
      buf[bytes] = (char)0;
      signed int return_value_vsscanf$2;
      return_value_vsscanf$2=vsscanf(buf, format, args);
      return (signed long int)return_value_vsscanf$2;
    }
  }
}

// net_vpack
// file libslack/net.c line 2729
signed long int net_vpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed long int return_value_vpack$1;
  return_value_vpack$1=vpack((void *)buf, (unsigned long int)8192, format, args);
  rc = (signed int)return_value_vpack$1;
  signed int return_value_write_timeout$2;
  if(rc == -1)
    return (signed long int)-1;

  else
    if(!(timeout == 0l))
    {
      return_value_write_timeout$2=write_timeout(sockfd, timeout, (signed long int)0);
      if(!(return_value_write_timeout$2 == -1))
        goto __CPROVER_DUMP_L2;

      return (signed long int)-1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed long int return_value_send$3;
      return_value_send$3=send(sockfd, (const void *)buf, (unsigned long int)rc, flags);
      return return_value_send$3;
    }
}

// net_vpackto
// file libslack/net.c line 2783
signed long int net_vpackto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed long int return_value_vpack$1;
  return_value_vpack$1=vpack((void *)buf, (unsigned long int)8192, format, args);
  rc = (signed int)return_value_vpack$1;
  signed int return_value_write_timeout$2;
  if(rc == -1)
    return (signed long int)-1;

  else
    if(!(timeout == 0l))
    {
      return_value_write_timeout$2=write_timeout(sockfd, timeout, (signed long int)0);
      if(!(return_value_write_timeout$2 == -1))
        goto __CPROVER_DUMP_L2;

      return (signed long int)-1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed long int return_value_sendto$3;
      return_value_sendto$3=sendto(sockfd, (const void *)buf, (unsigned long int)rc, flags, to, (unsigned int)tosize);
      return return_value_sendto$3;
    }
}

// net_vsend
// file libslack/net.c line 3836
signed long int net_vsend(signed int sockfd, signed long int timeout, const char *format, void **args)
{
  char buf[8193l];
  signed long int bytes;
  signed int return_value_vsnprintf$1;
  return_value_vsnprintf$1=vsnprintf(buf, (unsigned long int)(8192 + 1), format, args);
  bytes = (signed long int)return_value_vsnprintf$1;
  signed int return_value_set_errno$2;
  if(bytes == -1l || bytes >= 8193l)
  {
    return_value_set_errno$2=set_errno(28);
    return (signed long int)return_value_set_errno$2;
  }

  else
  {
    signed long int return_value_net_write$3;
    return_value_net_write$3=net_write(sockfd, timeout, buf, (unsigned long int)bytes);
    return return_value_net_write$3;
  }
}

// net_vunpack
// file libslack/net.c line 2841
signed long int net_vunpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed int return_value_read_timeout$1;
  return_value_read_timeout$1=read_timeout(sockfd, timeout, (signed long int)0);
  if(return_value_read_timeout$1 == -1)
    return (signed long int)-1;

  else
  {
    signed long int return_value_recv$2;
    return_value_recv$2=recv(sockfd, (void *)buf, (unsigned long int)8192, flags);
    rc = (signed int)return_value_recv$2;
    if(rc == -1)
      return (signed long int)-1;

    else
    {
      signed long int return_value_vunpack$3;
      return_value_vunpack$3=vunpack((void *)buf, (unsigned long int)rc, format, args);
      return return_value_vunpack$3;
    }
  }
}

// net_vunpackfrom
// file libslack/net.c line 2896
signed long int net_vunpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed int return_value_read_timeout$1;
  return_value_read_timeout$1=read_timeout(sockfd, timeout, (signed long int)0);
  if(return_value_read_timeout$1 == -1)
    return (signed long int)-1;

  else
  {
    signed long int return_value_recvfrom$2;
    return_value_recvfrom$2=recvfrom(sockfd, (void *)buf, (unsigned long int)8192, flags, from, (unsigned int *)(void *)fromsize);
    rc = (signed int)return_value_recvfrom$2;
    if(rc == -1)
      return (signed long int)-1;

    else
    {
      signed long int return_value_vunpack$3;
      return_value_vunpack$3=vunpack((void *)buf, (unsigned long int)rc, format, args);
      return return_value_vunpack$3;
    }
  }
}

// net_write
// file libslack/net.c line 3720
signed long int net_write(signed int sockfd, signed long int timeout, const char *buf, unsigned long int count)
{
  const char *b;
  signed long int bytes;
  b = buf;
  for( ; !(count == 0ul); b = b + bytes)
  {
    signed int return_value_write_timeout$1;
    return_value_write_timeout$1=write_timeout(sockfd, timeout, (signed long int)0);
    if(return_value_write_timeout$1 == -1)
      return (signed long int)-1;

    bytes=write(sockfd, (const void *)b, count);
    if(!(bytes >= 1l))
      return bytes;

    count = count - (unsigned long int)bytes;
  }
  return b - buf;
}

// new_shargv
// file libslack/coproc.c line 137
static char * const * new_shargv(const char *cmd, char * const *argv)
{
  char **shargv;
  signed int nargs = 0;
  for( ; !(argv[(signed long int)nargs] == ((char *)NULL)); nargs = nargs + 1)
    ;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(nargs + 2) * sizeof(char **) /*8ul*/ );
  shargv = (char **)return_value_malloc$1;
  if(shargv == ((char **)NULL))
    return (char * const *)(void *)0;

  else
  {
    shargv[(signed long int)0] = "/bin/sh";
    shargv[(signed long int)1] = (char *)cmd;
    nargs = 1;
    for( ; !(argv[(signed long int)nargs] == ((char *)NULL)); nargs = nargs + 1)
      shargv[(signed long int)(nargs + 1)] = argv[(signed long int)nargs];
    shargv[(signed long int)(nargs + 1)] = (char *)(void *)0;
    return (char * const *)shargv;
  }
}

// next_day
// file libslack/agent.c line 1809
static void next_day(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->hour = (unsigned long int)0;
  agent->timewheel->day = agent->timewheel->day + 1ul;
  void *return_value_dlink_next$1;
  if(agent->timewheel->day == 10ul)
  {
    unsigned long int i;
    agent->timewheel->day = (unsigned long int)0;
    i = (unsigned long int)0;
    for( ; !(i >= 10ul); i = i + 1ul)
    {
      action = agent->timewheel->days[(signed long int)i];
      for( ; !(action == ((struct action_t *)NULL)); action = (struct action_t *)return_value_dlink_next$1)
      {
        action->day = action->day - (unsigned long int)10;
        return_value_dlink_next$1=dlink_next((void *)action);
      }
    }
  }

  next = agent->timewheel->days[(signed long int)agent->timewheel->day];
  action = next;
  void *return_value_dlink_next$3;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
    if(action->day == agent->timewheel->day)
    {
      void *return_value_dlink_remove$2;
      return_value_dlink_remove$2=dlink_remove((void *)action);
      next = (struct action_t *)return_value_dlink_remove$2;
      if(*action->parent == action)
        *action->parent = next;

      install(&agent->timewheel->hours[(signed long int)action->hour], action);
    }

    else
    {
      return_value_dlink_next$3=dlink_next((void *)action);
      next = (struct action_t *)return_value_dlink_next$3;
    }
}

// next_hour
// file libslack/agent.c line 1846
static void next_hour(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->minute = (unsigned long int)0;
  agent->timewheel->hour = agent->timewheel->hour + 1ul;
  if(agent->timewheel->hour == 24ul)
    next_day(agent);

  next = agent->timewheel->hours[(signed long int)agent->timewheel->hour];
  agent->timewheel->hours[(signed long int)agent->timewheel->hour] = (struct action_t *)(void *)0;
  action = next;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
  {
    void *return_value_dlink_remove$1;
    return_value_dlink_remove$1=dlink_remove((void *)action);
    next = (struct action_t *)return_value_dlink_remove$1;
    install(&agent->timewheel->minutes[(signed long int)action->minute], action);
  }
}

// next_minute
// file libslack/agent.c line 1867
static void next_minute(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->second = (unsigned long int)0;
  agent->timewheel->minute = agent->timewheel->minute + 1ul;
  if(agent->timewheel->minute == 60ul)
    next_hour(agent);

  next = agent->timewheel->minutes[(signed long int)agent->timewheel->minute];
  agent->timewheel->minutes[(signed long int)agent->timewheel->minute] = (struct action_t *)(void *)0;
  action = next;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
  {
    void *return_value_dlink_remove$1;
    return_value_dlink_remove$1=dlink_remove((void *)action);
    next = (struct action_t *)return_value_dlink_remove$1;
    install(&agent->timewheel->seconds[(signed long int)action->second], action);
  }
}

// next_second
// file libslack/agent.c line 1888
static void next_second(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->jiffy = (unsigned long int)0;
  agent->timewheel->second = agent->timewheel->second + 1ul;
  if(agent->timewheel->second == 60ul)
    next_minute(agent);

  next = agent->timewheel->seconds[(signed long int)agent->timewheel->second];
  agent->timewheel->seconds[(signed long int)agent->timewheel->second] = (struct action_t *)(void *)0;
  action = next;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
  {
    void *return_value_dlink_remove$1;
    return_value_dlink_remove$1=dlink_remove((void *)action);
    next = (struct action_t *)return_value_dlink_remove$1;
    install(&agent->timewheel->jiffies[(signed long int)action->jiffy], action);
  }
}

// nonblock_off
// file libslack/fio.c line 485
signed int nonblock_off(signed int fd)
{
  signed int return_value_fcntl_clear_flag$1;
  return_value_fcntl_clear_flag$1=fcntl_clear_flag(fd, 04000);
  return return_value_fcntl_clear_flag$1;
}

// nonblock_on
// file libslack/fio.c line 468
signed int nonblock_on(signed int fd)
{
  signed int return_value_fcntl_set_flag$1;
  return_value_fcntl_set_flag$1=fcntl_set_flag(fd, 04000);
  return return_value_fcntl_set_flag$1;
}

// nonblock_set
// file libslack/fio.c line 451
signed int nonblock_set(signed int fd, signed int arg)
{
  signed int tmp_if_expr$3;
  signed int return_value_nonblock_on$1;
  signed int return_value_nonblock_off$2;
  if(!(arg == 0))
  {
    return_value_nonblock_on$1=nonblock_on(fd);
    tmp_if_expr$3 = return_value_nonblock_on$1;
  }

  else
  {
    return_value_nonblock_off$2=nonblock_off(fd);
    tmp_if_expr$3 = return_value_nonblock_off$2;
  }
  return tmp_if_expr$3;
}

// oct
// file libslack/str.c line 6469
signed int oct(const char *str)
{
  signed int ret = 0;
  _Bool tmp_if_expr$2;
  if(str == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)str[(signed long int)0] != 48 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  signed int return_value_bin$3;
  signed int return_value_hex$4;
  if(tmp_if_expr$2)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if((signed int)str[1l] == 98)
    {
      return_value_bin$3=bin(str);
      return return_value_bin$3;
    }

    else
      if((signed int)str[1l] == 120)
      {
        return_value_hex$4=hex(str);
        return return_value_hex$4;
      }

      else
      {
        str = str + 1l;
        for( ; !(*str == 0); str = str + 1l)
        {
          ret = ret << 3;
          if((signed int)*str == 48 || (signed int)*str == 49 || (signed int)*str == 50 || (signed int)*str == 51 || (signed int)*str == 52 || (signed int)*str == 53 || (signed int)*str == 54 || (signed int)*str == 55)
          {
            ret = ret | (signed int)*str - 48;
            goto __CPROVER_DUMP_L9;
          }

          signed int return_value_set_errno$5;
          return_value_set_errno$5=set_errno(22);
          return return_value_set_errno$5;

        __CPROVER_DUMP_L9:
          ;
        }
        return ret;
      }
}

// opt_action
// file libslack/prog.c line 1889
static void opt_action(struct Options *options, signed int rc, signed int longindex, const char *argument)
{
  struct Option *option;
  signed int i = -1;
  _Bool tmp_if_expr$1;
  if(longindex == -1 && !(rc == 0))
    for( ; !(options == ((struct Options *)NULL)); options = options->parent)
    {
      i = 0;
      for( ; !((options->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
        if((signed int)(options->options + (signed long int)i)->short_name == rc)
          break;

      if((signed int)(options->options + (signed long int)i)->short_name == rc)
        break;

    }

  else
    if(rc == 0 && !(longindex == -1))
    {
      i = 0;
      for( ; !(options == ((struct Options *)NULL)); options = options->parent)
      {
        i = 0;
        do
        {
          if(!(longindex == 0))
            tmp_if_expr$1 = (options->options + (signed long int)i)->name != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          longindex = longindex - 1;
          i = i + 1;
        }
        while((_Bool)1);
        if(!((options->options + (signed long int)i)->name == ((const char *)NULL)))
        {
          if(longindex == 0)
            break;

        }

      }
    }

    else
      goto __CPROVER_DUMP_L38;
  signed int arg;
  if(!(options == ((struct Options *)NULL)) && !(i == -1))
  {
    option = options->options + (signed long int)i;
    if(option->has_arg == 1)
    {
      if(!(argument == ((const char *)NULL)))
        goto __CPROVER_DUMP_L16;

    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      if(option->has_arg == 0)
      {
        if(argument == ((const char *)NULL))
          goto __CPROVER_DUMP_L17;

      }

      else
      {

      __CPROVER_DUMP_L17:
        ;
        if(!(argument == ((const char *)NULL)))
          switch((signed int)option->arg_type)
          {
            case OPT_NONE:
              break;
            case OPT_INTEGER:
            {
              switch((signed int)option->action)
              {
                case OPT_NOTHING:
                  break;
                case OPT_VARIABLE:
                {
                  *((signed int *)option->object)=int_arg(argument);
                  break;
                }
                case OPT_FUNCTION:
                {
                  arg=int_arg(argument);
                  if(option->has_arg == 1)
                    ((void (*)(signed int))option->function)(arg);

                  else
                    ((void (*)(signed int *))option->function)(&arg);
                }
              }
              break;
            }
            case OPT_STRING:
              switch((signed int)option->action)
              {
                case OPT_NOTHING:
                  break;
                case OPT_VARIABLE:
                {
                  *((const char **)option->object) = argument;
                  break;
                }
                case OPT_FUNCTION:
                  ((void (*)(const char *))option->function)(argument);
              }
          }

        else
          switch((signed int)option->action)
          {
            case OPT_NOTHING:
              break;
            case OPT_VARIABLE:
            {
              if(!((signed int)option->arg_type == OPT_STRING))
                *((signed int *)option->object) = *((signed int *)option->object) + 1;

              break;
            }
            case OPT_FUNCTION:
              if((signed int)option->action == 2)
                ((void (*)(signed int *))option->function)((signed int *)(void *)0);

              else
                ((void (*)(void))option->function)();
          }
      }
    }
  }


__CPROVER_DUMP_L38:
  ;
}

// opt_convert
// file libslack/prog.c line 1762
static struct option * opt_convert(struct Options *options)
{
  struct Options *opts;
  unsigned long int opt_convert$$1$$size = (unsigned long int)0;
  unsigned long int opt_convert$$1$$i;
  struct option *ret;
  signed int index = 0;
  opts = options;
  for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
  {
    opt_convert$$1$$i = (unsigned long int)0;
    for( ; !((opts->options + (signed long int)opt_convert$$1$$i)->name == ((const char *)NULL)); opt_convert$$1$$i = opt_convert$$1$$i + 1ul)
      opt_convert$$1$$size = opt_convert$$1$$size + 1ul;
  }
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((opt_convert$$1$$size + (unsigned long int)1) * sizeof(struct option) /*32ul*/ );
  ret = (struct option *)return_value_malloc$1;
  if(ret == ((struct option *)NULL))
    return (struct option *)(void *)0;

  else
  {
    opts = options;
    for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
    {
      signed int i = 0;
      for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); index = index + 1)
      {
        (ret + (signed long int)index)->name = (char *)(opts->options + (signed long int)i)->name;
        (ret + (signed long int)index)->has_arg = (opts->options + (signed long int)i)->has_arg;
        (ret + (signed long int)index)->flag = (signed int *)(void *)0;
        (ret + (signed long int)index)->val = 0;
        i = i + 1;
      }
    }
    memset((void *)(ret + (signed long int)index), 0, sizeof(struct option) /*32ul*/ );
    return ret;
  }
}

// opt_optstring
// file libslack/prog.c line 1806
static char * opt_optstring(struct Options *options)
{
  struct Options *opts;
  unsigned long int opt_optstring$$1$$size = (unsigned long int)0;
  unsigned long int i;
  char *optstring;
  char *p;
  opts = options;
  for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
  {
    i = (unsigned long int)0;
    for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1ul)
      if(!((opts->options + (signed long int)i)->short_name == 0))
        opt_optstring$$1$$size = opt_optstring$$1$$size + 1ul;

  }
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((opt_optstring$$1$$size * (unsigned long int)3 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
  optstring = (char *)return_value_malloc$1;
  p = optstring;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  if(p == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    opts = options;
    for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
    {
      signed int opt_optstring$$1$$2$$1$$i = 0;
      for( ; !((opts->options + (signed long int)opt_optstring$$1$$2$$1$$i)->name == ((const char *)NULL)); opt_optstring$$1$$2$$1$$i = opt_optstring$$1$$2$$1$$i + 1)
        if(!((opts->options + (signed long int)opt_optstring$$1$$2$$1$$i)->short_name == 0))
        {
          char short_name = (opts->options + (signed long int)opt_optstring$$1$$2$$1$$i)->short_name;
          if((signed int)short_name == 63)
            short_name = (char)1;

          tmp_post$2 = p;
          p = p + 1l;
          *tmp_post$2 = short_name;
          switch((opts->options + (signed long int)opt_optstring$$1$$2$$1$$i)->has_arg)
          {
            case 2:
            {
              tmp_post$3 = p;
              p = p + 1l;
              *tmp_post$3 = (char)58;
            }
            case 1:
            {
              tmp_post$4 = p;
              p = p + 1l;
              *tmp_post$4 = (char)58;
            }
          }
        }

    }
    *p = (char)0;
    return optstring;
  }
}

// opt_process
// file libslack/prog.c line 2051
signed int opt_process(signed int argc, char **argv, struct Options *options, char *msgbuf, unsigned long int bufsize)
{
  struct option *long_options;
  char *optstring;
  long_options=opt_convert(options);
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  if(long_options == ((struct option *)NULL))
    return optind;

  else
  {
    optstring=opt_optstring(options);
    if(optstring == ((char *)NULL))
    {
      free((void *)long_options);
      return optind;
    }

    else
    {
      do
      {
        signed int longindex = -1;
        signed int rc;
        rc=getopt_long(argc, argv, optstring, long_options, &longindex);
        if(rc == -1)
          break;

        if(rc == 58 || rc == 63)
        {
          free((void *)long_options);
          free((void *)optstring);
          signed int return_value_set_errno$1;
          return_value_set_errno$1=set_errno(22);
          return return_value_set_errno$1;
        }

        if(rc == 1)
          rc = 63;

        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 0;
        opt_action(options, rc, longindex, optarg);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        if(*return_value___errno_location$4 == 34)
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value___errno_location$5=__errno_location();
          tmp_if_expr$6 = *return_value___errno_location$5 == 33 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
        {
          if(!(msgbuf == ((char *)NULL)))
          {
            char optname[256l];
            if(longindex == -1 && !(rc == 0))
              snprintf(optname, (unsigned long int)256, "-%c", rc);

            else
              if(rc == 0 && !(longindex == -1))
                snprintf(optname, (unsigned long int)256, "--%s", (long_options + (signed long int)longindex)->name);

            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            snprintf(msgbuf, bufsize, "%s: invalid %s argument: %s", *argv, (const void *)optname, *return_value___errno_location$3 == 33 ? "not an integer" : "integer out of range");
          }

          free((void *)long_options);
          free((void *)optstring);
          return -1;
        }

      }
      while((_Bool)1);
      free((void *)long_options);
      free((void *)optstring);
      return optind;
    }
  }
}

// opt_usage
// file libslack/prog.c line 2139
char * opt_usage(char *buf, unsigned long int size, struct Options *options)
{
  const signed int total_width = 80;
  const char * const indent = "      ";
  unsigned long int indent_width;
  indent_width=strlen(indent);
  const char * const leader = " - ";
  unsigned long int leader_width;
  leader_width=strlen(leader);
  struct Options *opts;
  struct Options **stack;
  unsigned long int max_width = (unsigned long int)0;
  unsigned long int depth = (unsigned long int)0;
  unsigned long int length = (unsigned long int)0;
  unsigned long int remainder = (unsigned long int)0;
  signed int i;
  opts = options;
  for( ; !(opts == ((struct Options *)NULL)); depth = depth + 1ul)
  {
    i = 0;
    for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    {
      struct Option *opt = opts->options + (signed long int)i;
      unsigned long int width;
      width=strlen(opt->name);
      if(!(opt->argname == ((const char *)NULL)))
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(opt->argname);
        width = width + (unsigned long int)1 + return_value_strlen$1;
        if(opt->has_arg == 2)
          width = width + (unsigned long int)2;

      }

      if(!(max_width >= width))
        max_width = width;

    }
    opts = opts->parent;
  }
  max_width = max_width + (unsigned long int)6;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(depth * sizeof(struct Options *) /*8ul*/ );
  stack = (struct Options **)return_value_malloc$2;
  signed int tmp_post$3;
  unsigned long int tmp_post$4;
  signed int tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  const unsigned short int **return_value___ctype_b_loc$6;
  const unsigned short int **return_value___ctype_b_loc$8;
  const unsigned short int **return_value___ctype_b_loc$10;
  const unsigned short int **return_value___ctype_b_loc$11;
  if(stack == ((struct Options **)NULL))
    return (char *)(void *)0;

  else
  {
    opts = options;
    i = 0;
    for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
    {
      tmp_post$3 = i;
      i = i + 1;
      stack[(signed long int)tmp_post$3] = opts;
    }
    do
    {
      tmp_post$4 = depth;
      depth = depth - 1ul;
      if(tmp_post$4 == 0ul)
        break;

      opts = stack[(signed long int)depth];
      snprintf(buf + (signed long int)length, size - length, "\n");
      length=strlen(buf);
      i = 0;
      for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
      {
        struct Option *opt_usage$$1$$3$$1$$1$$opt = opts->options + (signed long int)i;
        char help[8192l];
        const char *desc;
        const char *next = (const char *)(void *)0;
        unsigned long int desc_length;
        unsigned long int help_length;
        if(!(opt_usage$$1$$3$$1$$1$$opt->short_name == 0))
          tmp_if_expr$5 = (signed int)opt_usage$$1$$3$$1$$1$$opt->short_name;

        else
          tmp_if_expr$5 = 32;
        snprintf(help, (unsigned long int)8192, "%s%c%c%c --%s", indent, opt_usage$$1$$3$$1$$1$$opt->short_name != 0 ? 45 : 32, tmp_if_expr$5, opt_usage$$1$$3$$1$$1$$opt->short_name != 0 ? 44 : 32, opt_usage$$1$$3$$1$$1$$opt->name);
        help_length=strlen(help);
        if(!(opt_usage$$1$$3$$1$$1$$opt->argname == ((const char *)NULL)))
        {
          signed int optional = (signed int)(opt_usage$$1$$3$$1$$1$$opt->has_arg == 2);
          snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%s%s%s", optional != 0 ? "[=" : "=", opt_usage$$1$$3$$1$$1$$opt->argname, optional != 0 ? "]" : "");
          help_length=strlen(help);
        }

        snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*s%s", (signed int)((max_width - help_length) + indent_width), (const void *)"", leader);
        help_length=strlen(help);
        remainder = (unsigned long int)total_width - help_length;
        desc = opt_usage$$1$$3$$1$$1$$opt->desc;
        do
        {
          desc_length=strlen(desc);
          if(remainder >= desc_length)
            break;

          if(!(desc == opt_usage$$1$$3$$1$$1$$opt->desc))
          {
            snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*s%*.*s", (signed int)(indent_width + max_width), (const void *)"", (signed int)leader_width, (signed int)leader_width, (const void *)"");
            help_length=strlen(help);
          }

          next = desc + (signed long int)remainder;
          do
          {
            if(!(desc >= next))
            {
              return_value___ctype_b_loc$6=__ctype_b_loc();
              tmp_if_expr$7 = !(((signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)(unsigned int)*next] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$7 = (_Bool)0;
            if(!tmp_if_expr$7)
              break;

            next = next - 1l;
          }
          while((_Bool)1);
          if(next == desc)
          {
            do
            {
              return_value___ctype_b_loc$8=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)(unsigned int)*next]) == 0)
                break;

              next = next + 1l;
            }
            while((_Bool)1);
            char *return_value___builtin_strchr$9;
            return_value___builtin_strchr$9=__builtin_strchr(desc, 32);
            next = return_value___builtin_strchr$9;
            if(next == ((const char *)NULL))
              next = desc + (signed long int)desc_length;

          }

          for( ; !(next == desc); next = next - 1l)
          {
            return_value___ctype_b_loc$10=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)(unsigned int)next[-1l]]) == 0)
              break;

          }
          snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*.*s\n", (signed int)(next - desc), (signed int)(next - desc), desc);
          help_length=strlen(help);
          do
          {
            return_value___ctype_b_loc$11=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)(unsigned int)*next]) == 0)
              break;

            next = next + 1l;
          }
          while((_Bool)1);
          desc = next;
        }
        while((_Bool)1);
        if(!(desc_length == 0ul))
        {
          if(!(desc == opt_usage$$1$$3$$1$$1$$opt->desc))
          {
            snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*s%*.*s", (signed int)(indent_width + max_width), (const void *)"", (signed int)leader_width, (signed int)leader_width, (const void *)"");
            help_length=strlen(help);
          }

          snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%s\n", desc);
        }

        snprintf(buf + (signed long int)length, size - length, "%s", (const void *)help);
        length=strlen(buf);
      }
    }
    while((_Bool)1);
    free((void *)stack);
    return buf;
  }
}

// pack
// file libslack/net.c line 3000
signed long int pack(void *buf, unsigned long int size, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_vpack$1;
  return_value_vpack$1=vpack(buf, size, format, args);
  rc = (signed int)return_value_vpack$1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// point_cmp
// file libslack/map.c line 2445
static signed int point_cmp(struct Point *a, struct Point *b)
{
  if(!(b->x >= a->x))
    return 1;

  else
    if(!(b->y >= a->y))
      return 1;

    else
      if(a->x == b->x)
      {
        if(!(a->y == b->y))
          goto __CPROVER_DUMP_L3;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return -1;
      }
}

// point_copy
// file libslack/map.c line 2440
static struct Point * point_copy(struct Point *point)
{
  struct Point *return_value_point_create$1;
  return_value_point_create$1=point_create(point->x, point->y);
  return return_value_point_create$1;
}

// point_create
// file libslack/map.c line 2427
static struct Point * point_create(signed int x, signed int y)
{
  struct Point *point;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1 * sizeof(struct Point) /*8ul*/ );
  point = (struct Point *)return_value_malloc$1;
  if(point == ((struct Point *)NULL))
    return (struct Point *)(void *)0;

  else
  {
    point->x = x;
    point->y = y;
    return point;
  }
}

// point_hash
// file libslack/map.c line 2456
static unsigned long int point_hash(unsigned long int size, struct Point *point)
{
  return (unsigned long int)(point->x * 31 + point->y * 37) % size;
}

// point_release
// file libslack/map.c line 2461
static void point_release(struct Point *point)
{
  free((void *)point);
}

// pool_alloc
// file libslack/mem.c line 919
void * pool_alloc(struct Pool *pool, unsigned long int size)
{
  void *addr;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(pool == ((struct Pool *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return return_value_set_errnull$2;
    }

    else
    {
      if(!(pool->size >= pool->used + size))
      {
        if(!(pool->locker == ((struct Locker *)NULL)))
          pool->locker->unlock(pool->locker->lock);

        else
          0;
        void *return_value_set_errnull$4;
        return_value_set_errnull$4=set_errnull(28);
        return return_value_set_errnull$4;
      }

      addr = (void *)(pool->pool + (signed long int)pool->used);
      pool->used = pool->used + size;
      if(!(pool->locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool->locker->unlock(pool->locker->lock);
        tmp_if_expr$6 = return_value_1;
      }

      else
        tmp_if_expr$6 = 0;
      err = tmp_if_expr$6;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return return_value_set_errnull$5;
      }

      else
        return addr;
    }
  }
}

// pool_clear
// file libslack/mem.c line 980
void pool_clear(struct Pool *pool)
{
  pool_clear_with_locker(pool, 1);
}

// pool_clear_secure
// file libslack/mem.c line 859
void pool_clear_secure(struct Pool *pool)
{
  signed int err;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    err = tmp_if_expr$1;
    if(!(err == 0))
      set_errno(err);

    else
    {
      pool_clear_unlocked(pool);
      memset((void *)pool->pool, 0xff, pool->size);
      memset((void *)pool->pool, 0xaa, pool->size);
      memset((void *)pool->pool, 0x55, pool->size);
      memset((void *)pool->pool, 0x00, pool->size);
      if(!(pool->locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool->locker->unlock(pool->locker->lock);
        tmp_if_expr$2 = return_value_1;
      }

      else
        tmp_if_expr$2 = 0;
      err = tmp_if_expr$2;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// pool_clear_unlocked
// file libslack/mem.c line 975
static void pool_clear_unlocked(struct Pool *pool)
{
  pool_clear_with_locker(pool, 0);
}

// pool_clear_with_locker
// file libslack/mem.c line 956
static void pool_clear_with_locker(struct Pool *pool, signed int lock_pool)
{
  signed int err;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(lock_pool == 0))
    {
      if(!(pool->locker == ((struct Locker *)NULL)))
      {
        return_value=pool->locker->wrlock(pool->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      err = tmp_if_expr$1;
      if(err == 0)
        goto __CPROVER_DUMP_L4;

      set_errno(err);
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      pool->used = (unsigned long int)0;
      if(!(lock_pool == 0))
      {
        if(!(pool->locker == ((struct Locker *)NULL)))
        {
          return_value_1=pool->locker->unlock(pool->locker->lock);
          tmp_if_expr$2 = return_value_1;
        }

        else
          tmp_if_expr$2 = 0;
        err = tmp_if_expr$2;
        if(!(err == 0))
          set_errno(err);

      }

    }
  }

}

// pool_create
// file libslack/mem.c line 616
struct Pool * pool_create(unsigned long int size)
{
  struct Pool *return_value_pool_create_with_locker$1;
  return_value_pool_create_with_locker$1=pool_create_with_locker((struct Locker *)(void *)0, size);
  return return_value_pool_create_with_locker$1;
}

// pool_create_secure
// file libslack/mem.c line 743
struct Pool * pool_create_secure(unsigned long int size)
{
  struct Pool *return_value_pool_create_secure_with_locker$1;
  return_value_pool_create_secure_with_locker$1=pool_create_secure_with_locker((struct Locker *)(void *)0, size);
  return return_value_pool_create_secure_with_locker$1;
}

// pool_create_secure_with_locker
// file libslack/mem.c line 759
struct Pool * pool_create_secure_with_locker(struct Locker *locker, unsigned long int size)
{
  struct Pool *pool;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1 * sizeof(struct Pool) /*32ul*/ );
  pool = (struct Pool *)return_value_malloc$1;
  if(pool == ((struct Pool *)NULL))
    return (struct Pool *)(void *)0;

  else
  {
    void *return_value_mem_create_secure$2;
    return_value_mem_create_secure$2=mem_create_secure(size);
    pool->pool = (char *)return_value_mem_create_secure$2;
    if(pool->pool == ((char *)NULL))
    {
      free((void *)pool);
      return (struct Pool *)(void *)0;
    }

    else
    {
      pool->size = size;
      pool->used = (unsigned long int)0;
      pool->locker = locker;
      return pool;
    }
  }
}

// pool_create_with_locker
// file libslack/mem.c line 632
struct Pool * pool_create_with_locker(struct Locker *locker, unsigned long int size)
{
  struct Pool *pool;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1 * sizeof(struct Pool) /*32ul*/ );
  pool = (struct Pool *)return_value_malloc$1;
  if(pool == ((struct Pool *)NULL))
    return (struct Pool *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(size);
    pool->pool = (char *)return_value_malloc$2;
    if(pool->pool == ((char *)NULL))
    {
      free((void *)pool);
      return (struct Pool *)(void *)0;
    }

    else
    {
      pool->size = size;
      pool->used = (unsigned long int)0;
      pool->locker = locker;
      return pool;
    }
  }
}

// pool_destroy
// file libslack/mem.c line 714
void * pool_destroy(struct Pool **pool)
{
  if(!(pool == ((struct Pool **)NULL)))
  {
    if(!(*pool == ((struct Pool *)NULL)))
    {
      pool_release(*pool);
      *pool = (struct Pool *)(void *)0;
    }

  }

  return (void *)0;
}

// pool_destroy_secure
// file libslack/mem.c line 834
void * pool_destroy_secure(struct Pool **pool)
{
  if(!(pool == ((struct Pool **)NULL)))
  {
    if(!(*pool == ((struct Pool *)NULL)))
    {
      pool_release_secure(*pool);
      *pool = (struct Pool *)(void *)0;
    }

  }

  return (void *)0;
}

// pool_release
// file libslack/mem.c line 680
void pool_release(struct Pool *pool)
{
  struct Locker *pool_release$$1$$locker;
  signed int err;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    err = tmp_if_expr$1;
    if(!(err == 0))
      set_errno(err);

    else
    {
      pool_release$$1$$locker = pool->locker;
      free((void *)pool->pool);
      free((void *)pool);
      if(!(pool_release$$1$$locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool_release$$1$$locker->unlock(pool_release$$1$$locker->lock);
        tmp_if_expr$2 = return_value_1;
      }

      else
        tmp_if_expr$2 = 0;
      err = tmp_if_expr$2;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// pool_release_secure
// file libslack/mem.c line 797
void pool_release_secure(struct Pool *pool)
{
  struct Locker *pool_release_secure$$1$$locker;
  signed int err;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    err = tmp_if_expr$1;
    if(!(err == 0))
      set_errno(err);

    else
    {
      pool_release_secure$$1$$locker = pool->locker;
      mem_release_secure((void *)pool->pool);
      free((void *)pool);
      if(!(pool_release_secure$$1$$locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool_release_secure$$1$$locker->unlock(pool_release_secure$$1$$locker->lock);
        tmp_if_expr$2 = return_value_1;
      }

      else
        tmp_if_expr$2 = 0;
      err = tmp_if_expr$2;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// produce
// file libslack/map.c line 2497
void * produce(void *arg)
{
  signed int i;
  signed int test = *((signed int *)arg);
  i = 1;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  for( ; lim >= i; i = i + 1)
  {
    if(!(debug == 0))
      printf("p: add %d\n", i);

    signed int return_value_map_add$3;
    return_value_map_add$3=map_add(mtmap, (void *)(signed long int)i, (void *)(signed long int)i);
    if(return_value_map_add$3 == -1)
    {
      errors = errors + 1;
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      printf("Test%d: map_add(mtmap, %d), failed (%s)\n", test, i, return_value_strerror$2);
    }

    write(size[(signed long int)1], (const void *)"", (unsigned long int)1);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// prog_alert
// file libslack/prog.h line 123
struct Msg * prog_alert(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.log;
    signed int prog_alert$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_alert$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_alert$$1$$2$$rc == 0))
    {
      set_errno(prog_alert$$1$$2$$rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_alert_fd
// file libslack/prog.c line 1305
signed int prog_alert_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g$link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_alert$1;
    return_value_prog_set_alert$1=prog_set_alert(mesg);
    if(return_value_prog_set_alert$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_alert_file
// file libslack/prog.c line 1367
signed int prog_alert_file(const char *path)
{
  struct Msg *prog_alert_file$$1$$alert;
  prog_alert_file$$1$$alert=msg_create_file_with_locker(g$link2.locker, path);
  if(prog_alert_file$$1$$alert == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_alert$1;
    return_value_prog_set_alert$1=prog_set_alert(prog_alert_file$$1$$alert);
    if(return_value_prog_set_alert$1 == ((struct Msg *)NULL))
    {
      msg_release(prog_alert_file$$1$$alert);
      return -1;
    }

    else
      return 0;
  }
}

// prog_alert_none
// file libslack/prog.c line 1423
signed int prog_alert_none(void)
{
  struct Msg *return_value_prog_set_alert$1;
  return_value_prog_set_alert$1=prog_set_alert((struct Msg *)(void *)0);
  return return_value_prog_set_alert$1 != ((struct Msg *)NULL) ? 0 : -1;
}

// prog_alert_stderr
// file libslack/prog.c line 1350
signed int prog_alert_stderr(void)
{
  signed int return_value_prog_alert_fd$1;
  return_value_prog_alert_fd$1=prog_alert_fd(2);
  return return_value_prog_alert_fd$1;
}

// prog_alert_stdout
// file libslack/prog.c line 1333
signed int prog_alert_stdout(void)
{
  signed int return_value_prog_alert_fd$1;
  return_value_prog_alert_fd$1=prog_alert_fd(1);
  return return_value_prog_alert_fd$1;
}

// prog_alert_syslog
// file libslack/prog.c line 1395
signed int prog_alert_syslog(const char *id, signed int option, signed int facility, signed int priority)
{
  struct Msg *prog_alert_syslog$$1$$alert;
  prog_alert_syslog$$1$$alert=msg_create_syslog_with_locker(g$link2.locker, id, option, facility, priority);
  if(prog_alert_syslog$$1$$alert == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_alert$1;
    return_value_prog_set_alert$1=prog_set_alert(prog_alert_syslog$$1$$alert);
    if(return_value_prog_set_alert$1 == ((struct Msg *)NULL))
    {
      msg_release(prog_alert_syslog$$1$$alert);
      return -1;
    }

    else
      return 0;
  }
}

// prog_author
// file libslack/prog.c line 757
const char * prog_author(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.author;
    signed int prog_author$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_author$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_author$$1$$2$$rc == 0))
    {
      set_errno(prog_author$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_basename
// file libslack/prog.c line 1668
const char * prog_basename(const char *path)
{
  const char *name;
  void *return_value_set_errnull$1;
  if(path == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (const char *)return_value_set_errnull$1;
  }

  else
  {
    name=strrchr(path, 47);
    return name != ((const char *)NULL) ? name + (signed long int)1 : path;
  }
}

// prog_contact
// file libslack/prog.c line 773
const char * prog_contact(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.contact;
    signed int prog_contact$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_contact$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_contact$$1$$2$$rc == 0))
    {
      set_errno(prog_contact$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_date
// file libslack/prog.c line 741
const char * prog_date(void)
{
  void *value;
  signed int prog_date$$1$$1$$rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  prog_date$$1$$1$$rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(prog_date$$1$$1$$rc == 0))
  {
    set_errno(prog_date$$1$$1$$rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.date;
    signed int rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    rc = tmp_if_expr$2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_dbg
// file libslack/prog.h line 122
struct Msg * prog_dbg(void)
{
  void *value;
  signed int prog_dbg$$1$$1$$rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  prog_dbg$$1$$1$$rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(prog_dbg$$1$$1$$rc == 0))
  {
    set_errno(prog_dbg$$1$$1$$rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.dbg;
    signed int rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    rc = tmp_if_expr$2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_dbg_fd
// file libslack/prog.c line 1170
signed int prog_dbg_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g$link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_dbg$1;
    return_value_prog_set_dbg$1=prog_set_dbg(mesg);
    if(return_value_prog_set_dbg$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_dbg_file
// file libslack/prog.c line 1232
signed int prog_dbg_file(const char *path)
{
  struct Msg *dbg;
  dbg=msg_create_file_with_locker(g$link2.locker, path);
  if(dbg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_dbg$1;
    return_value_prog_set_dbg$1=prog_set_dbg(dbg);
    if(return_value_prog_set_dbg$1 == ((struct Msg *)NULL))
    {
      msg_release(dbg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_dbg_none
// file libslack/prog.c line 1288
signed int prog_dbg_none(void)
{
  struct Msg *return_value_prog_set_dbg$1;
  return_value_prog_set_dbg$1=prog_set_dbg((struct Msg *)(void *)0);
  return return_value_prog_set_dbg$1 != ((struct Msg *)NULL) ? 0 : -1;
}

// prog_dbg_stderr
// file libslack/prog.c line 1215
signed int prog_dbg_stderr(void)
{
  signed int return_value_prog_dbg_fd$1;
  return_value_prog_dbg_fd$1=prog_dbg_fd(2);
  return return_value_prog_dbg_fd$1;
}

// prog_dbg_stdout
// file libslack/prog.c line 1198
signed int prog_dbg_stdout(void)
{
  signed int return_value_prog_dbg_fd$1;
  return_value_prog_dbg_fd$1=prog_dbg_fd(1);
  return return_value_prog_dbg_fd$1;
}

// prog_dbg_syslog
// file libslack/prog.c line 1260
signed int prog_dbg_syslog(const char *id, signed int option, signed int facility, signed int priority)
{
  struct Msg *dbg;
  dbg=msg_create_syslog_with_locker(g$link2.locker, id, option, facility, priority);
  if(dbg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_dbg$1;
    return_value_prog_set_dbg$1=prog_set_dbg(dbg);
    if(return_value_prog_set_dbg$1 == ((struct Msg *)NULL))
    {
      msg_release(dbg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_debug_level
// file libslack/prog.h line 124
unsigned long int prog_debug_level(void)
{
  signed int value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (unsigned long int)0;
  }

  else
  {
    value = (signed int)g$link2.debug_level;
    signed int prog_debug_level$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_debug_level$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_debug_level$$1$$2$$rc == 0))
    {
      set_errno(prog_debug_level$$1$$2$$rc);
      return (unsigned long int)0;
    }

    else
      return (unsigned long int)value;
  }
}

// prog_desc
// file libslack/prog.c line 709
const char * prog_desc(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.desc;
    signed int prog_desc$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_desc$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_desc$$1$$2$$rc == 0))
    {
      set_errno(prog_desc$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_err
// file libslack/prog.h line 121
struct Msg * prog_err(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.err;
    signed int prog_err$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_err$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_err$$1$$2$$rc == 0))
    {
      set_errno(prog_err$$1$$2$$rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_err_fd
// file libslack/prog.c line 1052
signed int prog_err_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g$link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_err$1;
    return_value_prog_set_err$1=prog_set_err(mesg);
    if(return_value_prog_set_err$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_err_file
// file libslack/prog.c line 1097
signed int prog_err_file(const char *path)
{
  struct Msg *mesg;
  mesg=msg_create_file_with_locker(g$link2.locker, path);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_err$1;
    return_value_prog_set_err$1=prog_set_err(mesg);
    if(return_value_prog_set_err$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_err_none
// file libslack/prog.c line 1153
signed int prog_err_none(void)
{
  struct Msg *return_value_prog_set_err$1;
  return_value_prog_set_err$1=prog_set_err((struct Msg *)(void *)0);
  return return_value_prog_set_err$1 != ((struct Msg *)NULL) ? 0 : -1;
}

// prog_err_stderr
// file libslack/prog.c line 1080
signed int prog_err_stderr(void)
{
  signed int return_value_prog_err_fd$1;
  return_value_prog_err_fd$1=prog_err_fd(2);
  return return_value_prog_err_fd$1;
}

// prog_err_syslog
// file libslack/prog.c line 1125
signed int prog_err_syslog(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct Msg *mesg;
  mesg=msg_create_syslog_with_locker(g$link2.locker, ident, option, facility, priority);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_err$1;
    return_value_prog_set_err$1=prog_set_err(mesg);
    if(return_value_prog_set_err$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_help_msg
// file libslack/prog.c line 1540
void prog_help_msg(void)
{
  char buf[8192l];
  unsigned long int length = (unsigned long int)0;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  if(!(tmp_if_expr$1 == 0))
    exit(1);

  snprintf(buf, (unsigned long int)8192, "usage: %s %s\n", g$link2.name != ((const char *)NULL) ? g$link2.name : "", g$link2.syntax != ((const char *)NULL) ? g$link2.syntax : "");
  if(!(g$link2.options == ((struct Options *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "options:\n");
    length=strlen(buf);
    opt_usage(buf + (signed long int)length, (unsigned long int)8192 - length, g$link2.options);
  }

  if(!(g$link2.desc == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "\n%s\n", g$link2.desc);
  }

  if(!(g$link2.name == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Name: %s\n", g$link2.name);
  }

  if(!(g$link2.version == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Version: %s\n", g$link2.version);
  }

  if(!(g$link2.date == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Date: %s\n", g$link2.date);
  }

  if(!(g$link2.author == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Author: %s\n", g$link2.author);
  }

  if(!(g$link2.vendor == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Vendor: %s\n", g$link2.vendor);
  }

  if(!(g$link2.url == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "URL: %s\n", g$link2.url);
  }

  if(!(g$link2.legal == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "\n%s\n", g$link2.legal);
  }

  if(!(g$link2.contact == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Report bugs to %s\n", g$link2.contact);
  }

  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
    tmp_if_expr$2 = return_value_1;
  }

  else
    tmp_if_expr$2 = 0;
  if(!(tmp_if_expr$2 == 0))
    exit(1);

  msg("%s", (const void *)buf);
  exit(0);
}

// prog_init
// file libslack/prog.c line 245
void prog_init(void)
{
  prog_out_stdout();
  prog_err_stderr();
  prog_dbg_stderr();
  prog_alert_stderr();
}

// prog_legal
// file libslack/prog.c line 821
const char * prog_legal(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.legal;
    signed int prog_legal$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_legal$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_legal$$1$$2$$rc == 0))
    {
      set_errno(prog_legal$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_name
// file libslack/prog.h line 109
const char * prog_name(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.name;
    signed int prog_name$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_name$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_name$$1$$2$$rc == 0))
    {
      set_errno(prog_name$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_opt_process
// file libslack/prog.c line 1452
signed int prog_opt_process(signed int ac, char **av)
{
  char msgbuf[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int err;
  signed int rc;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  err = tmp_if_expr$2;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int return_value_1;
  signed int return_value_set_errno$3;
  if(!(err == 0))
  {
    return_value_set_errno$1=set_errno(err);
    return return_value_set_errno$1;
  }

  else
  {
    rc=opt_process(ac, av, g$link2.options, msgbuf, (unsigned long int)256);
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$4 = return_value_1;
    }

    else
      tmp_if_expr$4 = 0;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$3=set_errno(err);
      return return_value_set_errno$3;
    }

    else
    {
      if(rc == -1)
        prog_usage_msg(msgbuf);

      return rc;
    }
  }
}

// prog_options
// file libslack/prog.c line 677
const struct Options * prog_options(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const struct Options *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.options;
    signed int prog_options$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_options$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_options$$1$$2$$rc == 0))
    {
      set_errno(prog_options$$1$$2$$rc);
      return (const struct Options *)(void *)0;
    }

    else
      return (const struct Options *)value;
  }
}

// prog_out
// file libslack/prog.h line 120
struct Msg * prog_out(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.out;
    signed int prog_out$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_out$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_out$$1$$2$$rc == 0))
    {
      set_errno(prog_out$$1$$2$$rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_out_fd
// file libslack/prog.c line 934
signed int prog_out_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g$link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_out$1;
    return_value_prog_set_out$1=prog_set_out(mesg);
    if(return_value_prog_set_out$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_out_file
// file libslack/prog.c line 978
signed int prog_out_file(const char *path)
{
  struct Msg *mesg;
  mesg=msg_create_file_with_locker(g$link2.locker, path);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_out$1;
    return_value_prog_set_out$1=prog_set_out(mesg);
    if(return_value_prog_set_out$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_out_none
// file libslack/prog.c line 1033
signed int prog_out_none(void)
{
  prog_set_out((struct Msg *)(void *)0);
  return 0;
}

// prog_out_stdout
// file libslack/prog.c line 961
signed int prog_out_stdout(void)
{
  signed int return_value_prog_out_fd$1;
  return_value_prog_out_fd$1=prog_out_fd(1);
  return return_value_prog_out_fd$1;
}

// prog_out_syslog
// file libslack/prog.c line 1006
signed int prog_out_syslog(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct Msg *mesg;
  mesg=msg_create_syslog_with_locker(g$link2.locker, ident, option, facility, priority);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_out$1;
    return_value_prog_set_out$1=prog_set_out(mesg);
    if(return_value_prog_set_out$1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_set_alert
// file libslack/prog.c line 555
struct Msg * prog_set_alert(struct Msg *alert)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g$link2.log == ((struct Msg *)NULL)) && !(g$link2.log == alert))
      msg_release(g$link2.log);

    g$link2.log = alert;
    signed int prog_set_alert$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_alert$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_alert$$1$$2$$rc == 0))
    {
      set_errno(prog_set_alert$$1$$2$$rc);
      return (struct Msg *)(void *)0;
    }

    else
      return alert;
  }
}

// prog_set_author
// file libslack/prog.c line 408
const char * prog_set_author(const char *author)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.author = author;
    signed int prog_set_author$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_author$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_author$$1$$2$$rc == 0))
    {
      set_errno(prog_set_author$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.author;
  }
}

// prog_set_contact
// file libslack/prog.c line 426
const char * prog_set_contact(const char *contact)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.contact = contact;
    signed int prog_set_contact$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_contact$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_contact$$1$$2$$rc == 0))
    {
      set_errno(prog_set_contact$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.contact;
  }
}

// prog_set_date
// file libslack/prog.c line 391
const char * prog_set_date(const char *date)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.date = date;
    signed int prog_set_date$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_date$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_date$$1$$2$$rc == 0))
    {
      set_errno(prog_set_date$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.date;
  }
}

// prog_set_dbg
// file libslack/prog.c line 537
struct Msg * prog_set_dbg(struct Msg *dbg)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g$link2.dbg == ((struct Msg *)NULL)) && !(g$link2.dbg == dbg))
      msg_release(g$link2.dbg);

    g$link2.dbg = dbg;
    signed int prog_set_dbg$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_dbg$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_dbg$$1$$2$$rc == 0))
    {
      set_errno(prog_set_dbg$$1$$2$$rc);
      return (struct Msg *)(void *)0;
    }

    else
      return dbg;
  }
}

// prog_set_debug_level
// file libslack/prog.c line 603
signed long int prog_set_debug_level(unsigned long int debug_level)
{
  unsigned long int prev;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (signed long int)-1;
  }

  else
  {
    prev = g$link2.debug_level;
    g$link2.debug_level = debug_level;
    signed int prog_set_debug_level$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_debug_level$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_debug_level$$1$$2$$rc == 0))
    {
      set_errno(prog_set_debug_level$$1$$2$$rc);
      return (signed long int)-1;
    }

    else
      return (signed long int)prev;
  }
}

// prog_set_desc
// file libslack/prog.c line 357
const char * prog_set_desc(const char *desc)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.desc = desc;
    signed int prog_set_desc$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_desc$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_desc$$1$$2$$rc == 0))
    {
      set_errno(prog_set_desc$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.desc;
  }
}

// prog_set_err
// file libslack/prog.c line 519
struct Msg * prog_set_err(struct Msg *err)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g$link2.err == ((struct Msg *)NULL)) && !(g$link2.err == err))
      msg_release(g$link2.err);

    g$link2.err = err;
    signed int prog_set_err$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_err$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_err$$1$$2$$rc == 0))
    {
      set_errno(prog_set_err$$1$$2$$rc);
      return (struct Msg *)(void *)0;
    }

    else
      return err;
  }
}

// prog_set_legal
// file libslack/prog.c line 478
const char * prog_set_legal(const char *legal)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.legal = legal;
    signed int prog_set_legal$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_legal$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_legal$$1$$2$$rc == 0))
    {
      set_errno(prog_set_legal$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.legal;
  }
}

// prog_set_locker
// file libslack/prog.c line 640
signed int prog_set_locker(struct Locker *locker)
{
  if(!(g$link2.locker == ((struct Locker *)NULL)))
    return -1;

  else
  {
    g$link2.locker = locker;
    return 0;
  }
}

// prog_set_name
// file libslack/prog.c line 305
const char * prog_set_name(const char *name)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.name = name;
    signed int prog_set_name$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_name$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_name$$1$$2$$rc == 0))
    {
      set_errno(prog_set_name$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.name;
  }
}

// prog_set_options
// file libslack/prog.c line 322
struct Options * prog_set_options(struct Options *options)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Options *)(void *)0;
  }

  else
  {
    g$link2.options = options;
    signed int prog_set_options$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_options$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_options$$1$$2$$rc == 0))
    {
      set_errno(prog_set_options$$1$$2$$rc);
      return (struct Options *)(void *)0;
    }

    else
      return g$link2.options;
  }
}

// prog_set_out
// file libslack/prog.c line 499
struct Msg * prog_set_out(struct Msg *out)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g$link2.out == ((struct Msg *)NULL)) && !(g$link2.out == out))
      msg_release(g$link2.out);

    g$link2.out = out;
    signed int prog_set_out$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_out$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_out$$1$$2$$rc == 0))
    {
      set_errno(prog_set_out$$1$$2$$rc);
      return (struct Msg *)(void *)0;
    }

    else
      return out;
  }
}

// prog_set_syntax
// file libslack/prog.c line 340
const char * prog_set_syntax(const char *syntax)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.syntax = syntax;
    signed int prog_set_syntax$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_syntax$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_syntax$$1$$2$$rc == 0))
    {
      set_errno(prog_set_syntax$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.syntax;
  }
}

// prog_set_url
// file libslack/prog.c line 460
const char * prog_set_url(const char *url)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.url = url;
    signed int prog_set_url$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_url$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_url$$1$$2$$rc == 0))
    {
      set_errno(prog_set_url$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.url;
  }
}

// prog_set_vendor
// file libslack/prog.c line 443
const char * prog_set_vendor(const char *vendor)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.vendor = vendor;
    signed int prog_set_vendor$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_vendor$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_vendor$$1$$2$$rc == 0))
    {
      set_errno(prog_set_vendor$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.vendor;
  }
}

// prog_set_verbosity_level
// file libslack/prog.c line 622
signed long int prog_set_verbosity_level(unsigned long int verbosity_level)
{
  unsigned long int prev;
  signed int prog_set_verbosity_level$$1$$1$$rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  prog_set_verbosity_level$$1$$1$$rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(prog_set_verbosity_level$$1$$1$$rc == 0))
  {
    set_errno(prog_set_verbosity_level$$1$$1$$rc);
    return (signed long int)-1;
  }

  else
  {
    prev = g$link2.verbosity_level;
    g$link2.verbosity_level = verbosity_level;
    signed int rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    rc = tmp_if_expr$2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (signed long int)-1;
    }

    else
      return (signed long int)prev;
  }
}

// prog_set_version
// file libslack/prog.c line 374
const char * prog_set_version(const char *version)
{
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->wrlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g$link2.version = version;
    signed int prog_set_version$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_set_version$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_set_version$$1$$2$$rc == 0))
    {
      set_errno(prog_set_version$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return g$link2.version;
  }
}

// prog_syntax
// file libslack/prog.c line 693
const char * prog_syntax(void)
{
  void *value;
  signed int prog_syntax$$1$$1$$rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  prog_syntax$$1$$1$$rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(prog_syntax$$1$$1$$rc == 0))
  {
    set_errno(prog_syntax$$1$$1$$rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.syntax;
    signed int rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    rc = tmp_if_expr$2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_url
// file libslack/prog.c line 805
const char * prog_url(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.url;
    signed int prog_url$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_url$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_url$$1$$2$$rc == 0))
    {
      set_errno(prog_url$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_usage_msg
// file libslack/prog.c line 1495
void prog_usage_msg(const char *format, ...)
{
  char msg_buf[8192l];
  char opt_buf[8192l];
  signed int msg_length;
  void **args = (void **)&format;
  vsnprintf(msg_buf, (unsigned long int)8192, format, args);
  args = ((void **)NULL);
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  if(!(tmp_if_expr$1 == 0))
    exit(1);

  opt_usage(opt_buf, (unsigned long int)8192, g$link2.options);
  fflush(stderr);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(msg_buf);
  msg_length = (signed int)return_value_strlen$2;
  _Bool tmp_if_expr$3;
  if(!(msg_length == 0))
    tmp_if_expr$3 = (signed int)msg_buf[(signed long int)(msg_length - 1)] != 10 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  msg_out(g$link2.err, "%s%susage: %s%s%s\n%s%s", (const void *)msg_buf, tmp_if_expr$3 ? "\n" : "", g$link2.name != ((const char *)NULL) ? g$link2.name : "", g$link2.name != ((const char *)NULL) ? " " : "", g$link2.syntax != ((const char *)NULL) ? g$link2.syntax : "", opt_buf[0l] != 0 ? "options:\n" : "", (const void *)opt_buf);
  if(!(g$link2.locker == ((struct Locker *)NULL)))
    g$link2.locker->unlock(g$link2.locker->lock);

  else
    0;
  exit(1);
}

// prog_vendor
// file libslack/prog.c line 789
const char * prog_vendor(void)
{
  void *value;
  signed int prog_vendor$$1$$1$$rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  prog_vendor$$1$$1$$rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(prog_vendor$$1$$1$$rc == 0))
  {
    set_errno(prog_vendor$$1$$1$$rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.vendor;
    signed int rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    rc = tmp_if_expr$2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_verbosity_level
// file libslack/prog.h line 125
unsigned long int prog_verbosity_level(void)
{
  signed int value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (unsigned long int)0;
  }

  else
  {
    value = (signed int)g$link2.verbosity_level;
    signed int prog_verbosity_level$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_verbosity_level$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_verbosity_level$$1$$2$$rc == 0))
    {
      set_errno(prog_verbosity_level$$1$$2$$rc);
      return (unsigned long int)0;
    }

    else
      return (unsigned long int)value;
  }
}

// prog_version
// file libslack/prog.c line 725
const char * prog_version(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  rc = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g$link2.version;
    signed int prog_version$$1$$2$$rc;
    if(!(g$link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
      tmp_if_expr$2 = return_value_1;
    }

    else
      tmp_if_expr$2 = 0;
    prog_version$$1$$2$$rc = tmp_if_expr$2;
    if(!(prog_version$$1$$2$$rc == 0))
    {
      set_errno(prog_version$$1$$2$$rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_version_msg
// file libslack/prog.c line 1634
void prog_version_msg(void)
{
  char buf[8192l];
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link2.locker->rdlock(g$link2.locker->lock);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = 0;
  if(!(tmp_if_expr$1 == 0))
    exit(1);

  if(!(g$link2.name == ((const char *)NULL)) && !(g$link2.version == ((const char *)NULL)))
    snprintf(buf, (unsigned long int)8192, "%s-%s\n", g$link2.name, g$link2.version);

  else
    if(!(g$link2.name == ((const char *)NULL)))
      snprintf(buf, (unsigned long int)8192, "%s\n", g$link2.name);

    else
      if(!(g$link2.version == ((const char *)NULL)))
        snprintf(buf, (unsigned long int)8192, "%s\n", g$link2.version);

      else
        buf[0l] = (char)0;
  signed int tmp_if_expr$2;
  signed int return_value_1;
  if(!(g$link2.locker == ((struct Locker *)NULL)))
  {
    return_value_1=g$link2.locker->unlock(g$link2.locker->lock);
    tmp_if_expr$2 = return_value_1;
  }

  else
    tmp_if_expr$2 = 0;
  if(!(tmp_if_expr$2 == 0))
    exit(1);

  msg("%s", (const void *)buf);
  exit(0);
}

// prop_clear
// file libslack/prop.c line 1121
signed int prop_clear(void)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(g$link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link3.locker->wrlock(g$link3.locker->lock);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  err = tmp_if_expr$2;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int return_value_1;
  signed int return_value_set_errno$3;
  if(!(err == 0))
  {
    return_value_set_errno$1=set_errno(err);
    return return_value_set_errno$1;
  }

  else
  {
    prop_release(g$link3.prop);
    g$link3.prop = (struct Prop *)(void *)0;
    g$link3.init = 0;
    g$link3.dirty = 0;
    if(!(g$link3.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g$link3.locker->unlock(g$link3.locker->lock);
      tmp_if_expr$4 = return_value_1;
    }

    else
      tmp_if_expr$4 = 0;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$3=set_errno(err);
      return return_value_set_errno$3;
    }

    else
      return 0;
  }
}

// prop_create
// file libslack/prop.c line 153
static struct Prop * prop_create(struct Map *map, struct Prop *defaults)
{
  struct Prop *prop;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct Prop) /*16ul*/ );
  prop = (struct Prop *)return_value_malloc$1;
  if(prop == ((struct Prop *)NULL))
    return (struct Prop *)(void *)0;

  else
  {
    prop->map = map;
    prop->defaults = defaults;
    return prop;
  }
}

// prop_get
// file libslack/prop.c line 540
const char * prop_get(const char *name)
{
  struct Prop *p;
  const char *value = (const char *)(void *)0;
  signed int err;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(g$link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link3.locker->wrlock(g$link3.locker->lock);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  err = tmp_if_expr$2;
  void *return_value_set_errnull$1;
  signed int return_value_prop_init$3;
  void *return_value_map_get$4;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(!(err == 0))
  {
    return_value_set_errnull$1=set_errnull(err);
    return (const char *)return_value_set_errnull$1;
  }

  else
    if(g$link3.init == 0)
    {
      return_value_prop_init$3=prop_init();
      if(!(return_value_prop_init$3 == -1))
        goto __CPROVER_DUMP_L6;

      if(!(g$link3.locker == ((struct Locker *)NULL)))
        g$link3.locker->unlock(g$link3.locker->lock);

      else
        0;
      return (const char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      p = g$link3.prop;
      for( ; !(p == ((struct Prop *)NULL)); p = p->defaults)
      {
        return_value_map_get$4=map_get(p->map, (const void *)name);
        value = (const char *)return_value_map_get$4;
        if(!(value == ((const char *)NULL)))
          break;

      }
      if(!(g$link3.locker == ((struct Locker *)NULL)))
      {
        return_value_1=g$link3.locker->unlock(g$link3.locker->lock);
        tmp_if_expr$6 = return_value_1;
      }

      else
        tmp_if_expr$6 = 0;
      err = tmp_if_expr$6;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (const char *)return_value_set_errnull$5;
      }

      else
        return value;
    }
}

// prop_get_bool
// file libslack/prop.c line 759
signed int prop_get_bool(const char *name)
{
  signed int return_value_prop_get_bool_or$1;
  return_value_prop_get_bool_or$1=prop_get_bool_or(name, 0);
  return return_value_prop_get_bool_or$1;
}

// prop_get_bool_or
// file libslack/prop.c line 779
signed int prop_get_bool_or(const char *name, signed int default_value)
{
  const char *prop;
  prop=prop_get(name);
  char buf[128l];
  signed int val;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$18;
  if(prop == ((const char *)NULL))
    return default_value;

  else
  {
    signed int return_value_sscanf$1;
    return_value_sscanf$1=sscanf(prop, " %d ", &val);
    if(!(return_value_sscanf$1 == 0))
      return val;

    else
    {
      signed int return_value_sscanf$21;
      return_value_sscanf$21=sscanf(prop, " %s ", (const void *)buf);
      if(!(return_value_sscanf$21 == 0))
      {
        if((signed int)buf[0l] == 116)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)buf[(signed long int)0] == 84 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          if((signed int)buf[1l] == 114)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = (signed int)buf[(signed long int)1] == 82 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
          {
            if((signed int)buf[2l] == 117)
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = (signed int)buf[(signed long int)2] == 85 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
            {
              if((signed int)buf[3l] == 101)
                tmp_if_expr$2 = (_Bool)1;

              else
                tmp_if_expr$2 = (signed int)buf[(signed long int)3] == 69 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$2)
              {
                if((signed int)buf[4l] == 0)
                  return 1;

              }

            }

          }

        }

        if((signed int)buf[0l] == 102)
          tmp_if_expr$10 = (_Bool)1;

        else
          tmp_if_expr$10 = (signed int)buf[(signed long int)0] == 70 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$10)
        {
          if((signed int)buf[1l] == 97)
            tmp_if_expr$9 = (_Bool)1;

          else
            tmp_if_expr$9 = (signed int)buf[(signed long int)1] == 65 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$9)
          {
            if((signed int)buf[2l] == 108)
              tmp_if_expr$8 = (_Bool)1;

            else
              tmp_if_expr$8 = (signed int)buf[(signed long int)2] == 76 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$8)
            {
              if((signed int)buf[3l] == 115)
                tmp_if_expr$7 = (_Bool)1;

              else
                tmp_if_expr$7 = (signed int)buf[(signed long int)3] == 83 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$7)
              {
                if((signed int)buf[4l] == 101)
                  tmp_if_expr$6 = (_Bool)1;

                else
                  tmp_if_expr$6 = (signed int)buf[(signed long int)4] == 69 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$6)
                {
                  if((signed int)buf[5l] == 0)
                    return 0;

                }

              }

            }

          }

        }

        if((signed int)buf[0l] == 121)
          tmp_if_expr$13 = (_Bool)1;

        else
          tmp_if_expr$13 = (signed int)buf[(signed long int)0] == 89 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$13)
        {
          if((signed int)buf[1l] == 101)
            tmp_if_expr$12 = (_Bool)1;

          else
            tmp_if_expr$12 = (signed int)buf[(signed long int)1] == 69 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$12)
          {
            if((signed int)buf[2l] == 115)
              tmp_if_expr$11 = (_Bool)1;

            else
              tmp_if_expr$11 = (signed int)buf[(signed long int)2] == 83 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$11)
            {
              if((signed int)buf[3l] == 0)
                return 1;

            }

          }

        }

        if((signed int)buf[0l] == 110)
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = (signed int)buf[(signed long int)0] == 78 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
        {
          if((signed int)buf[1l] == 111)
            tmp_if_expr$14 = (_Bool)1;

          else
            tmp_if_expr$14 = (signed int)buf[(signed long int)1] == 79 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$14)
          {
            if((signed int)buf[2l] == 0)
              return 0;

          }

        }

        if((signed int)buf[0l] == 111)
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = (signed int)buf[(signed long int)0] == 79 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
        {
          if((signed int)buf[1l] == 110)
            tmp_if_expr$16 = (_Bool)1;

          else
            tmp_if_expr$16 = (signed int)buf[(signed long int)1] == 78 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$16)
          {
            if((signed int)buf[2l] == 0)
              return 1;

          }

        }

        if((signed int)buf[0l] == 111)
          tmp_if_expr$20 = (_Bool)1;

        else
          tmp_if_expr$20 = (signed int)buf[(signed long int)0] == 79 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$20)
          goto __CPROVER_DUMP_L46;

        if((signed int)buf[1l] == 102)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = (signed int)buf[(signed long int)1] == 70 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$19)
          goto __CPROVER_DUMP_L46;

        if((signed int)buf[2l] == 102)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = (signed int)buf[(signed long int)2] == 70 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$18)
          goto __CPROVER_DUMP_L46;

        if(!((signed int)buf[3l] == 0))
          goto __CPROVER_DUMP_L46;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L46:
        ;
        return default_value;
      }
    }
  }
}

// prop_get_double
// file libslack/prop.c line 701
double prop_get_double(const char *name)
{
  double return_value_prop_get_double_or$1;
  return_value_prop_get_double_or$1=prop_get_double_or(name, 0.0);
  return return_value_prop_get_double_or$1;
}

// prop_get_double_or
// file libslack/prop.c line 718
double prop_get_double_or(const char *name, double default_value)
{
  const char *prop;
  prop=prop_get(name);
  double val;
  _Bool tmp_if_expr$2;
  signed int return_value_sscanf$1;
  if(!(prop == ((const char *)NULL)))
  {
    return_value_sscanf$1=sscanf(prop, "%lg", &val);
    tmp_if_expr$2 = return_value_sscanf$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  return tmp_if_expr$2 ? val : default_value;
}

// prop_get_int
// file libslack/prop.c line 644
signed int prop_get_int(const char *name)
{
  signed int return_value_prop_get_int_or$1;
  return_value_prop_get_int_or$1=prop_get_int_or(name, 0);
  return return_value_prop_get_int_or$1;
}

// prop_get_int_or
// file libslack/prop.c line 661
signed int prop_get_int_or(const char *name, signed int default_value)
{
  const char *prop;
  prop=prop_get(name);
  signed int val;
  _Bool tmp_if_expr$2;
  signed int return_value_sscanf$1;
  if(!(prop == ((const char *)NULL)))
  {
    return_value_sscanf$1=sscanf(prop, " %d ", &val);
    tmp_if_expr$2 = return_value_sscanf$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  return tmp_if_expr$2 ? val : default_value;
}

// prop_get_or
// file libslack/prop.c line 576
const char * prop_get_or(const char *name, const char *default_value)
{
  const char *prop;
  prop=prop_get(name);
  return prop != ((const char *)NULL) ? prop : default_value;
}

// prop_init
// file libslack/prop.c line 434
static signed int prop_init(void)
{
  char *path;
  struct Prop *prop = (struct Prop *)(void *)0;
  struct Prop *prop_next;
  char *home;
  signed int writable = 0;
  unsigned long int path_len;
  signed long int return_value_limit_path$1;
  return_value_limit_path$1=limit_path();
  path_len = (unsigned long int)return_value_limit_path$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(path_len * sizeof(char) /*1ul*/ );
  path = (char *)return_value_malloc$2;
  char *tmp_post$6;
  char *return_value___builtin_strchr$5;
  if(path == ((char *)NULL))
    return -1;

  else
  {
    snprintf(path, path_len, "%s%cproperties%capp", (const void *)"/etc", 47, 47);
    prop_next=prop_load(path, prop);
    if(!(prop_next == ((struct Prop *)NULL)))
      prop = prop_next;

    home=user_home();
    if(!(home == ((char *)NULL)))
    {
      snprintf(path, path_len, "%s%c.properties%capp", home, 47, 47);
      prop_next=prop_load(path, prop);
      if(!(prop_next == ((struct Prop *)NULL)))
        prop = prop_next;

    }

    const char *return_value_prog_name$7;
    return_value_prog_name$7=prog_name();
    if(!(return_value_prog_name$7 == ((const char *)NULL)))
    {
      char *progname;
      char *sep;
      const char *return_value_prog_name$3;
      return_value_prog_name$3=prog_name();
      progname=mem_strdup(return_value_prog_name$3);
      if(progname == ((char *)NULL))
      {
        free((void *)path);
        prop_release(prop);
        return -1;
      }

      char *return_value___builtin_strchr$4;
      return_value___builtin_strchr$4=__builtin_strchr(progname, 47);
      sep = return_value___builtin_strchr$4;
      for( ; !(sep == ((char *)NULL)); sep = return_value___builtin_strchr$5)
      {
        tmp_post$6 = sep;
        sep = sep + 1l;
        *tmp_post$6 = (char)45;
        return_value___builtin_strchr$5=__builtin_strchr(sep, 47);
      }
      snprintf(path, path_len, "%s%cproperties%capp.%s", (const void *)"/etc", 47, 47, progname);
      prop_next=prop_load(path, prop);
      if(!(prop_next == ((struct Prop *)NULL)))
        prop = prop_next;

      if(!(home == ((char *)NULL)))
      {
        snprintf(path, path_len, "%s%c.properties%capp.%s", home, 47, 47, progname);
        prop_next=prop_load(path, prop);
        if(!(prop_next == ((struct Prop *)NULL)))
        {
          prop = prop_next;
          writable = 1;
        }

      }

      free((void *)progname);
    }

    if(writable == 0)
    {
      struct Map *map;
      map=map_create((void (*)(void *))free);
      if(map == ((struct Map *)NULL))
      {
        free((void *)path);
        prop_release(prop);
        return -1;
      }

      prop_next=prop_create(map, prop);
      if(prop_next == ((struct Prop *)NULL))
      {
        free((void *)path);
        prop_release(prop);
        map_release(map);
        return -1;
      }

      prop = prop_next;
    }

    free((void *)path);
    g$link3.prop = prop;
    g$link3.init = 1;
    return 0;
  }
}

// prop_load
// file libslack/prop.c line 392
static struct Prop * prop_load(const char *path, struct Prop *defaults)
{
  struct Prop *prop;
  struct Map *map;
  map=map_create((void (*)(void *))free);
  if(map == ((struct Map *)NULL))
    return (struct Prop *)(void *)0;

  else
  {
    void *return_value_daemon_parse_config$1;
    return_value_daemon_parse_config$1=daemon_parse_config(path, (void *)map, (void (*)(void *, const char *, char *, unsigned long int))prop_parse);
    if(return_value_daemon_parse_config$1 == NULL)
    {
      map_release(map);
      return (struct Prop *)(void *)0;
    }

    else
    {
      prop=prop_create(map, defaults);
      if(prop == ((struct Prop *)NULL))
      {
        map_release(map);
        return (struct Prop *)(void *)0;
      }

      else
        return prop;
    }
  }
}

// prop_locker
// file libslack/prop.c line 1152
signed int prop_locker(struct Locker *locker)
{
  signed int return_value_set_errno$1;
  if(!(g$link3.locker == ((struct Locker *)NULL)))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    g$link3.locker = locker;
    return 0;
  }
}

// prop_parse
// file libslack/prop.c line 299
static void prop_parse(struct Map *map, const char *path, char *line, unsigned long int lineno)
{
  struct String *prop;
  struct String *name;
  char *p;
  char *prop_parse$$1$$eq;
  char *value;
  char *val;
  char *key;
  prop=unquote_special(line);
  _Bool tmp_if_expr$3;
  char *return_value___builtin_strchr$2;
  const unsigned short int **return_value___ctype_b_loc$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  if(prop == ((struct String *)NULL))
    error("prop: Out of memory");

  else
  {
    p=cstr(prop);
    char *return_value___builtin_strchr$1;
    return_value___builtin_strchr$1=__builtin_strchr(p, 61);
    prop_parse$$1$$eq = return_value___builtin_strchr$1;
    for( ; !(prop_parse$$1$$eq == ((char *)NULL)); prop_parse$$1$$eq = return_value___builtin_strchr$2)
    {
      if(prop_parse$$1$$eq == p)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)prop_parse$$1$$eq[(signed long int)-1] != 92 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        break;

      return_value___builtin_strchr$2=__builtin_strchr(prop_parse$$1$$eq + (signed long int)1, 61);
    }
    if(prop_parse$$1$$eq == ((char *)NULL))
    {
      error("prop: %s line %d: Expected '='\n%s", path, lineno, line);
      str_release(prop);
      set_errno(22);
    }

    else
    {
      value = prop_parse$$1$$eq + (signed long int)1;
      do
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)*value]) == 0)
          break;

        value = value + 1l;
      }
      while((_Bool)1);
      for( ; !(p >= prop_parse$$1$$eq); prop_parse$$1$$eq = prop_parse$$1$$eq - 1l)
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned char)prop_parse$$1$$eq[-1l]]) == 0)
          break;

        if(!(prop_parse$$1$$eq == p + 1l))
        {
          if((signed int)prop_parse$$1$$eq[-2l] == 92)
            break;

        }

      }
      *prop_parse$$1$$eq = (char)0;
      if(!(p + 1l >= prop_parse$$1$$eq))
      {
        return_value___ctype_b_loc$6=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)(unsigned char)prop_parse$$1$$eq[-1l]]) == 0))
        {
          if((signed int)prop_parse$$1$$eq[-2l] == 92)
          {
            prop_parse$$1$$eq[(signed long int)-2] = prop_parse$$1$$eq[(signed long int)-1];
            prop_parse$$1$$eq[(signed long int)-1] = (char)0;
          }

        }

      }

      name=unquote_equals(p);
      if(name == ((struct String *)NULL))
      {
        error("prop: Out of memory");
        str_release(prop);
      }

      else
      {
        key=cstr(name);
        if((signed int)*value == 92)
          value = value + 1l;

        val=mem_strdup(value);
        if(val == ((char *)NULL))
        {
          error("prop: Out of memory");
          str_release(prop);
          str_release(name);
        }

        else
        {
          signed int return_value_map_add$7;
          return_value_map_add$7=map_add(map, (const void *)key, (void *)val);
          if(return_value_map_add$7 == -1)
          {
            error("prop: %s line %d: Property %s already defined\n%s", path, lineno, name, line);
            free((void *)val);
          }

          str_release(prop);
          str_release(name);
        }
      }
    }
  }
}

// prop_release
// file libslack/prop.c line 174
static void prop_release(struct Prop *prop)
{
  if(!(prop == ((struct Prop *)NULL)))
  {
    map_release(prop->map);
    prop_release(prop->defaults);
    free((void *)prop);
  }

}

// prop_save
// file libslack/prop.c line 914
signed int prop_save(void)
{
  char *path;
  unsigned long int path_len;
  unsigned long int len;
  char *home;
  char *progname;
  char *sep;
  struct stat status[1l];
  struct List *keys;
  struct Lister *k;
  struct _IO_FILE *file;
  signed int err;
  signed int return_value_prop_get_bool_or$1;
  return_value_prop_get_bool_or$1=prop_get_bool_or("save", 1);
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  signed int return_value_mkdir$11;
  _Bool tmp_if_expr$15;
  char *tmp_post$19;
  char *return_value___builtin_strchr$18;
  signed int return_value_lister_has_next$21;
  const unsigned short int **return_value___ctype_b_loc$27;
  char *return_value_cstr$28;
  signed long int return_value_str_length$29;
  signed int tmp_if_expr$37;
  signed int return_value_2;
  signed int return_value_set_errno$36;
  if(return_value_prop_get_bool_or$1 == 0)
    return 0;

  else
  {
    if(!(g$link3.locker == ((struct Locker *)NULL)))
    {
      return_value=g$link3.locker->wrlock(g$link3.locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      if(g$link3.dirty == 0)
      {
        if(!(g$link3.locker == ((struct Locker *)NULL)))
        {
          return_value_1=g$link3.locker->unlock(g$link3.locker->lock);
          tmp_if_expr$5 = return_value_1;
        }

        else
          tmp_if_expr$5 = 0;
        err = tmp_if_expr$5;
        if(!(err == 0))
        {
          return_value_set_errno$4=set_errno(err);
          return return_value_set_errno$4;
        }

        return 0;
      }

      const char *return_value_prog_name$7;
      return_value_prog_name$7=prog_name();
      if(return_value_prog_name$7 == ((const char *)NULL))
      {
        if(!(g$link3.locker == ((struct Locker *)NULL)))
          g$link3.locker->unlock(g$link3.locker->lock);

        else
          0;
        signed int return_value_set_errno$6;
        return_value_set_errno$6=set_errno(22);
        return return_value_set_errno$6;
      }

      home=user_home();
      if(home == ((char *)NULL))
      {
        if(!(g$link3.locker == ((struct Locker *)NULL)))
          g$link3.locker->unlock(g$link3.locker->lock);

        else
          0;
        signed int return_value_set_errno$8;
        return_value_set_errno$8=set_errno(22);
        return return_value_set_errno$8;
      }

      signed long int return_value_limit_path$9;
      return_value_limit_path$9=limit_path();
      path_len = (unsigned long int)return_value_limit_path$9;
      void *return_value_malloc$10;
      return_value_malloc$10=malloc(path_len * sizeof(char) /*1ul*/ );
      path = (char *)return_value_malloc$10;
      if(path == ((char *)NULL))
      {
        if(!(g$link3.locker == ((struct Locker *)NULL)))
          g$link3.locker->unlock(g$link3.locker->lock);

        else
          0;
        return -1;
      }

      else
      {
        snprintf(path, path_len, "%s%c.properties", home, 47);
        signed int return_value_stat$12;
        return_value_stat$12=stat$link2(path, status);
        if(return_value_stat$12 == -1)
        {
          return_value_mkdir$11=mkdir(path, (unsigned int)(0400 | 0200 | 0100));
          if(!(return_value_mkdir$11 == -1))
            goto __CPROVER_DUMP_L20;

          free((void *)path);
          if(!(g$link3.locker == ((struct Locker *)NULL)))
            g$link3.locker->unlock(g$link3.locker->lock);

          else
            0;
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L20:
          ;
          signed int return_value_stat$14;
          return_value_stat$14=stat$link2(path, status);
          if(return_value_stat$14 == -1)
            tmp_if_expr$15 = (_Bool)1;

          else
            tmp_if_expr$15 = (signed int)((status[0l].st_mode & (unsigned int)0170000) == (unsigned int)0040000) == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$15)
          {
            free((void *)path);
            if(!(g$link3.locker == ((struct Locker *)NULL)))
              g$link3.locker->unlock(g$link3.locker->lock);

            else
              0;
            signed int return_value_set_errno$13;
            return_value_set_errno$13=set_errno(22);
            return return_value_set_errno$13;
          }

          const char *return_value_prog_name$16;
          return_value_prog_name$16=prog_name();
          progname=mem_strdup(return_value_prog_name$16);
          if(progname == ((char *)NULL))
          {
            free((void *)path);
            if(!(g$link3.locker == ((struct Locker *)NULL)))
              g$link3.locker->unlock(g$link3.locker->lock);

            else
              0;
            return -1;
          }

          else
          {
            char *return_value___builtin_strchr$17;
            return_value___builtin_strchr$17=__builtin_strchr(progname, 47);
            sep = return_value___builtin_strchr$17;
            for( ; !(sep == ((char *)NULL)); sep = return_value___builtin_strchr$18)
            {
              tmp_post$19 = sep;
              sep = sep + 1l;
              *tmp_post$19 = (char)45;
              return_value___builtin_strchr$18=__builtin_strchr(sep, 47);
            }
            len=strlen(path);
            snprintf(path + (signed long int)len, path_len - len, "%capp.%s", 47, progname);
            free((void *)progname);
            file=fopen(path, "w");
            free((void *)path);
            if(file == ((struct _IO_FILE *)NULL))
            {
              if(!(g$link3.locker == ((struct Locker *)NULL)))
                g$link3.locker->unlock(g$link3.locker->lock);

              else
                0;
              return -1;
            }

            else
            {
              keys=map_keys(g$link3.prop->map);
              if(keys == ((struct List *)NULL))
              {
                if(!(g$link3.locker == ((struct Locker *)NULL)))
                  g$link3.locker->unlock(g$link3.locker->lock);

                else
                  0;
                return -1;
              }

              else
              {
                struct List *return_value_list_sort$20;
                return_value_list_sort$20=list_sort(keys, (signed int (*)(const void *, const void *))key_cmp);
                if(return_value_list_sort$20 == ((struct List *)NULL))
                {
                  list_release(keys);
                  if(!(g$link3.locker == ((struct Locker *)NULL)))
                    g$link3.locker->unlock(g$link3.locker->lock);

                  else
                    0;
                  return -1;
                }

                else
                {
                  k=lister_create(keys);
                  if(k == ((struct Lister *)NULL))
                  {
                    list_release(keys);
                    if(!(g$link3.locker == ((struct Locker *)NULL)))
                      g$link3.locker->unlock(g$link3.locker->lock);

                    else
                      0;
                    return -1;
                  }

                  else
                  {
                    do
                    {
                      return_value_lister_has_next$21=lister_has_next(k);
                      if(!(return_value_lister_has_next$21 == 1))
                        break;

                      const char *key;
                      void *return_value_lister_next$22;
                      return_value_lister_next$22=lister_next(k);
                      key = (const char *)return_value_lister_next$22;
                      const char *value;
                      void *return_value_map_get$23;
                      return_value_map_get$23=map_get(g$link3.prop->map, (const void *)key);
                      value = (const char *)return_value_map_get$23;
                      struct String *lhs;
                      struct String *rhs;
                      struct String *lhs2;
                      lhs=quote_equals(key);
                      if(lhs == ((struct String *)NULL))
                      {
                        fclose(file);
                        lister_release(k);
                        list_release(keys);
                        if(!(g$link3.locker == ((struct Locker *)NULL)))
                          g$link3.locker->unlock(g$link3.locker->lock);

                        else
                          0;
                        return -1;
                      }

                      char *return_value_cstr$24;
                      return_value_cstr$24=cstr(lhs);
                      lhs2=quote_special(return_value_cstr$24);
                      if(lhs2 == ((struct String *)NULL))
                      {
                        fclose(file);
                        lister_release(k);
                        list_release(keys);
                        str_release(lhs);
                        if(!(g$link3.locker == ((struct Locker *)NULL)))
                          g$link3.locker->unlock(g$link3.locker->lock);

                        else
                          0;
                        return -1;
                      }

                      str_release(lhs);
                      lhs = lhs2;
                      signed long int return_value_str_length$30;
                      return_value_str_length$30=str_length(lhs);
                      if(!(return_value_str_length$30 == 0l))
                      {
                        return_value___ctype_b_loc$27=__ctype_b_loc();
                        return_value_cstr$28=cstr(lhs);
                        return_value_str_length$29=str_length(lhs);
                        if(!((8192 & (signed int)(*return_value___ctype_b_loc$27)[(signed long int)(signed int)(unsigned char)return_value_cstr$28[return_value_str_length$29 + -1l]]) == 0))
                        {
                          signed long int return_value_str_length$25;
                          return_value_str_length$25=str_length(lhs);
                          struct String *return_value_str_insert$26;
                          return_value_str_insert$26=str_insert(lhs, return_value_str_length$25 - (signed long int)1, "\\");
                          if(return_value_str_insert$26 == ((struct String *)NULL))
                          {
                            fclose(file);
                            lister_release(k);
                            list_release(keys);
                            str_release(lhs);
                            if(!(g$link3.locker == ((struct Locker *)NULL)))
                              g$link3.locker->unlock(g$link3.locker->lock);

                            else
                              0;
                            return -1;
                          }

                        }

                      }

                      rhs=quote_special(value);
                      if(rhs == ((struct String *)NULL))
                      {
                        fclose(file);
                        lister_release(k);
                        list_release(keys);
                        str_release(lhs);
                        if(!(g$link3.locker == ((struct Locker *)NULL)))
                          g$link3.locker->unlock(g$link3.locker->lock);

                        else
                          0;
                        return -1;
                      }

                      const unsigned short int **return_value___ctype_b_loc$32;
                      return_value___ctype_b_loc$32=__ctype_b_loc();
                      char *return_value_cstr$33;
                      return_value_cstr$33=cstr(rhs);
                      if(!((8192 & (signed int)(*return_value___ctype_b_loc$32)[(signed long int)(signed int)(unsigned char)*return_value_cstr$33]) == 0))
                      {
                        struct String *return_value_str_insert$31;
                        return_value_str_insert$31=str_insert(rhs, (signed long int)0, "\\");
                        if(return_value_str_insert$31 == ((struct String *)NULL))
                        {
                          fclose(file);
                          lister_release(k);
                          list_release(keys);
                          str_release(lhs);
                          if(!(g$link3.locker == ((struct Locker *)NULL)))
                            g$link3.locker->unlock(g$link3.locker->lock);

                          else
                            0;
                          return -1;
                        }

                      }

                      char *return_value_cstr$34;
                      return_value_cstr$34=cstr(lhs);
                      char *return_value_cstr$35;
                      return_value_cstr$35=cstr(rhs);
                      fprintf(file, "%s=%s\n", return_value_cstr$34, return_value_cstr$35);
                      str_release(lhs);
                      str_release(rhs);
                    }
                    while((_Bool)1);
                    fclose(file);
                    lister_release(k);
                    list_release(keys);
                    g$link3.dirty = 0;
                    if(!(g$link3.locker == ((struct Locker *)NULL)))
                    {
                      return_value_2=g$link3.locker->unlock(g$link3.locker->lock);
                      tmp_if_expr$37 = return_value_2;
                    }

                    else
                      tmp_if_expr$37 = 0;
                    err = tmp_if_expr$37;
                    if(!(err == 0))
                    {
                      return_value_set_errno$36=set_errno(err);
                      return return_value_set_errno$36;
                    }

                    else
                      return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// prop_set
// file libslack/prop.c line 597
const char * prop_set(const char *name, const char *value)
{
  char *val;
  signed int err;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(g$link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link3.locker->wrlock(g$link3.locker->lock);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  err = tmp_if_expr$2;
  void *return_value_set_errnull$1;
  signed int return_value_prop_init$3;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(!(err == 0))
  {
    return_value_set_errnull$1=set_errnull(err);
    return (const char *)return_value_set_errnull$1;
  }

  else
    if(g$link3.init == 0)
    {
      return_value_prop_init$3=prop_init();
      if(!(return_value_prop_init$3 == -1))
        goto __CPROVER_DUMP_L6;

      if(!(g$link3.locker == ((struct Locker *)NULL)))
        g$link3.locker->unlock(g$link3.locker->lock);

      else
        0;
      return (const char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      val=mem_strdup(value);
      if(val == ((char *)NULL))
      {
        if(!(g$link3.locker == ((struct Locker *)NULL)))
          g$link3.locker->unlock(g$link3.locker->lock);

        else
          0;
        return (const char *)(void *)0;
      }

      else
      {
        signed int return_value_map_put$4;
        return_value_map_put$4=map_put(g$link3.prop->map, (const void *)name, (void *)val);
        if(return_value_map_put$4 == -1)
        {
          free((void *)val);
          if(!(g$link3.locker == ((struct Locker *)NULL)))
            g$link3.locker->unlock(g$link3.locker->lock);

          else
            0;
          return (const char *)(void *)0;
        }

        else
        {
          g$link3.dirty = 1;
          if(!(g$link3.locker == ((struct Locker *)NULL)))
          {
            return_value_1=g$link3.locker->unlock(g$link3.locker->lock);
            tmp_if_expr$6 = return_value_1;
          }

          else
            tmp_if_expr$6 = 0;
          err = tmp_if_expr$6;
          if(!(err == 0))
          {
            return_value_set_errnull$5=set_errnull(err);
            return (const char *)return_value_set_errnull$5;
          }

          else
            return val;
        }
      }
    }
}

// prop_set_bool
// file libslack/prop.c line 847
signed int prop_set_bool(const char *name, signed int value)
{
  signed int return_value_prop_set_int$1;
  return_value_prop_set_int$1=prop_set_int(name, value);
  return return_value_prop_set_int$1;
}

// prop_set_double
// file libslack/prop.c line 739
double prop_set_double(const char *name, double value)
{
  char buf[128l];
  snprintf(buf, (unsigned long int)128, "%g", value);
  const char *return_value_prop_set$1;
  return_value_prop_set$1=prop_set(name, buf);
  return return_value_prop_set$1 != ((const char *)NULL) ? value : (double)-1;
}

// prop_set_int
// file libslack/prop.c line 682
signed int prop_set_int(const char *name, signed int value)
{
  char buf[128l];
  snprintf(buf, (unsigned long int)128, "%d", value);
  const char *return_value_prop_set$1;
  return_value_prop_set$1=prop_set(name, buf);
  return return_value_prop_set$1 != ((const char *)NULL) ? value : 0;
}

// prop_unset
// file libslack/prop.c line 866
signed int prop_unset(const char *name)
{
  struct Prop *p;
  signed int err;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(g$link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g$link3.locker->wrlock(g$link3.locker->lock);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  err = tmp_if_expr$2;
  signed int return_value_set_errno$1;
  signed int return_value_prop_init$3;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(!(err == 0))
  {
    return_value_set_errno$1=set_errno(err);
    return return_value_set_errno$1;
  }

  else
    if(g$link3.init == 0)
    {
      return_value_prop_init$3=prop_init();
      if(!(return_value_prop_init$3 == -1))
        goto __CPROVER_DUMP_L6;

      if(!(g$link3.locker == ((struct Locker *)NULL)))
        g$link3.locker->unlock(g$link3.locker->lock);

      else
        0;
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      p = g$link3.prop;
      for( ; !(p == ((struct Prop *)NULL)); p = p->defaults)
        map_remove(p->map, (const void *)name);
      g$link3.dirty = 1;
      if(!(g$link3.locker == ((struct Locker *)NULL)))
      {
        return_value_1=g$link3.locker->unlock(g$link3.locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return 0;
    }
}

// pty_change_window_size
// file libslack/pseudo.c line 716
signed int pty_change_window_size(signed int masterfd, signed int row, signed int col, signed int xpixel, signed int ypixel)
{
  struct winsize win;
  signed int *return_value___errno_location$1;
  if(!(col >= 0) || !(masterfd >= 0) || !(row >= 0) || !(xpixel >= 0) || !(ypixel >= 0))
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  else
  {
    win.ws_row = (unsigned short int)row;
    win.ws_col = (unsigned short int)col;
    win.ws_xpixel = (unsigned short int)xpixel;
    win.ws_ypixel = (unsigned short int)ypixel;
    signed int return_value_ioctl$2;
    return_value_ioctl$2=ioctl(masterfd, (unsigned long int)0x5414, &win);
    return return_value_ioctl$2;
  }
}

// pty_fork
// file libslack/pseudo.h line 54
signed int pty_fork(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize)
{
  signed int slavefd;
  signed int pid;
  signed int return_value_pty_open$1;
  return_value_pty_open$1=pty_open(masterfd, &slavefd, slavename, slavenamesize, slave_termios, slave_winsize);
  signed int return_value_dup2$3;
  signed int return_value_dup2$4;
  signed int return_value_dup2$5;
  if(return_value_pty_open$1 == -1)
    return -1;

  else
  {
    pid=fork();
    if(!(pid == -1))
    {
      if(pid == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      pty_release(slavename);
      close(slavefd);
      close(*masterfd);
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_pty_make_controlling_tty$2;
      return_value_pty_make_controlling_tty$2=pty_make_controlling_tty(&slavefd, slavename);
      if(return_value_pty_make_controlling_tty$2 == -1)
        _exit(1);

      if(!(slavefd == 0))
      {
        return_value_dup2$3=dup2(slavefd, 0);
        if(return_value_dup2$3 == -1)
          _exit(1);

      }

      if(!(slavefd == 1))
      {
        return_value_dup2$4=dup2(slavefd, 1);
        if(return_value_dup2$4 == -1)
          _exit(1);

      }

      if(!(slavefd == 2))
      {
        return_value_dup2$5=dup2(slavefd, 2);
        if(return_value_dup2$5 == -1)
          _exit(1);

      }

      if(!(slavefd == 0) && !(slavefd == 1) && !(slavefd == 2))
        close(slavefd);

      close(*masterfd);
      return 0;
    }
    close(slavefd);
    return pid;
  }
}

// pty_make_controlling_tty
// file libslack/pseudo.c line 637
signed int pty_make_controlling_tty(signed int *slavefd, const char *slavename)
{
  signed int fd;
  void (*old)(signed int);
  _Bool tmp_if_expr$2;
  if(slavefd == ((signed int *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = *slavefd < 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$1;
  if(slavename == ((const char *)NULL) || tmp_if_expr$2)
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  else
  {
    fd=open("/dev/tty", 02 | 0400);
    if(fd >= 0)
    {
      ioctl(fd, (unsigned long int)0x5422, (void *)0);
      close(fd);
    }

    setsid();
    signed int return_value_ioctl$3;
    return_value_ioctl$3=ioctl(*slavefd, (unsigned long int)0x540E, (void *)0);
    if(return_value_ioctl$3 == -1)
      return -1;

    else
    {
      old=signal(1, (void (*)(signed int))1);
      vhangup();
      signal(1, old);
      fd=open(slavename, 02);
      if(fd >= 0)
      {
        close(*slavefd);
        *slavefd = fd;
      }

      fd=open("/dev/tty", 02);
      if(fd == -1)
        return -1;

      else
      {
        close(fd);
        return 0;
      }
    }
  }
}

// pty_open
// file libslack/pseudo.c line 217
signed int pty_open(signed int *masterfd, signed int *slavefd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize)
{
  struct termios master_termios[1l];
  char buf[64l];
  char *name = buf;
  signed int err;
  signed int *return_value___errno_location$1;
  signed int return_value_tcsetattr$8;
  signed int return_value_ioctl$9;
  if(masterfd == ((signed int *)NULL) || slavefd == ((signed int *)NULL) || slavename == ((char *)NULL) || !(slavenamesize >= 64ul))
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  else
  {
    signed int return_value_openpty$2;
    return_value_openpty$2=openpty(masterfd, slavefd, (char *)(void *)0, (struct termios *)(void *)0, (struct winsize *)(void *)0);
    if(return_value_openpty$2 == -1)
      return -1;

    else
    {
      err=ttyname_r(*slavefd, buf, (unsigned long int)64);
      if(!(err == 0))
      {
        close(*masterfd);
        close(*slavefd);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        *return_value___errno_location$3 = err;
        return -1;
      }

      unsigned long int return_value_strlcpy$5;
      return_value_strlcpy$5=strlcpy(slavename, name, slavenamesize);
      if(return_value_strlcpy$5 >= slavenamesize)
      {
        close(*masterfd);
        close(*slavefd);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 28;
        return -1;
      }

      signed int return_value_tcgetattr$7;
      return_value_tcgetattr$7=tcgetattr(*masterfd, master_termios);
      if(!(return_value_tcgetattr$7 == -1))
      {
        if(!((8u & master_termios[0l].c_lflag) == 0u))
        {
          master_termios[0l].c_lflag = master_termios[0l].c_lflag & (unsigned int)~0000010;
          signed int return_value_tcsetattr$6;
          return_value_tcsetattr$6=tcsetattr(*masterfd, 0, master_termios);
          if(return_value_tcsetattr$6 == -1)
          {
            close(*masterfd);
            close(*slavefd);
            return -1;
          }

        }

      }

      if(!(slave_termios == ((struct termios *)NULL)))
      {
        return_value_tcsetattr$8=tcsetattr(*slavefd, 0, slave_termios);
        if(!(return_value_tcsetattr$8 == -1))
          goto __CPROVER_DUMP_L7;

        close(*masterfd);
        close(*slavefd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(slave_winsize == ((struct winsize *)NULL)))
        {
          return_value_ioctl$9=ioctl(*slavefd, (unsigned long int)0x5414, slave_winsize);
          if(!(return_value_ioctl$9 == -1))
            goto __CPROVER_DUMP_L8;

          close(*masterfd);
          close(*slavefd);
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L8:
          ;
          return 0;
        }
      }
    }
  }
}

// pty_release
// file libslack/pseudo.h line 50
signed int pty_release(const char *slavename)
{
  signed int *return_value___errno_location$1;
  if(slavename == ((const char *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  else
  {
    signed int return_value_chown$2;
    return_value_chown$2=chown(slavename, (unsigned int)0, (unsigned int)0);
    if(return_value_chown$2 == -1)
      return -1;

    else
    {
      signed int return_value_chmod$3;
      return_value_chmod$3=chmod(slavename, (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3));
      if(return_value_chmod$3 == -1)
        return -1;

      else
        return 0;
    }
  }
}

// pty_set_owner
// file libslack/pseudo.c line 595
signed int pty_set_owner(const char *slavename, unsigned int uid)
{
  unsigned int mode = (unsigned int)(0400 | 0200 | 0200 >> 3);
  struct stat status[1l];
  signed int gid;
  signed int return_value_stat$1;
  return_value_stat$1=stat$link3(slavename, status);
  _Bool tmp_if_expr$5;
  signed int return_value_chown$4;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$3;
  signed int return_value_chmod$8;
  signed int *return_value___errno_location$6;
  _Bool tmp_if_expr$7;
  if(return_value_stat$1 == -1)
    return -1;

  else
  {
    gid=groupname2gid("tty");
    if(gid == -1)
    {
      gid=uid2gid(uid);
      mode = mode | (unsigned int)((0200 >> 3) >> 3);
    }

    if(!(status[0l].st_uid == uid))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = status[0l].st_gid != (unsigned int)gid ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      return_value_chown$4=chown(slavename, uid, (unsigned int)gid);
      if(!(return_value_chown$4 == -1))
        goto __CPROVER_DUMP_L7;

      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 30))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = status[0l].st_uid != uid ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$3)
        goto __CPROVER_DUMP_L7;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      if(!((511u & status[0l].st_mode) == mode))
      {
        return_value_chmod$8=chmod(slavename, mode);
        if(!(return_value_chmod$8 == -1))
          goto __CPROVER_DUMP_L10;

        return_value___errno_location$6=__errno_location();
        if(!(*return_value___errno_location$6 == 30))
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (status[0l].st_mode & (unsigned int)(0400 >> 3 | (0400 >> 3) >> 3)) != 0u ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$7)
          goto __CPROVER_DUMP_L10;

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        return 0;
      }
    }
  }
}

// quote
// file libslack/str.c line 5126
struct String * quote(const char *str, const char *quotable, char quote_char)
{
  struct String *return_value_quote_with_locker$1;
  return_value_quote_with_locker$1=quote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_quote_with_locker$1;
}

// quote_equals
// file libslack/prop.c line 244
static struct String * quote_equals(const char *src)
{
  struct String *return_value_encode$1;
  return_value_encode$1=encode(src, eq, eq, (char)92, 0);
  return return_value_encode$1;
}

// quote_special
// file libslack/prop.c line 213
static struct String * quote_special(const char *src)
{
  struct String *return_value_encode$1;
  return_value_encode$1=encode(src, special_char, special_code, (char)92, 1);
  return return_value_encode$1;
}

// quote_with_locker
// file libslack/str.c line 5142
struct String * quote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char)
{
  struct String *ret;
  unsigned long int i;
  void *return_value_set_errnull$1;
  unsigned long int tmp_post$2;
  if(quotable == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_create_with_locker(locker, "%s", str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= ret->length + 18446744073709551615ul); i = i + 1ul)
      {
        char *return_value___builtin_strchr$4;
        return_value___builtin_strchr$4=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)i]);
        if(!(return_value___builtin_strchr$4 == ((char *)NULL)))
        {
          tmp_post$2 = i;
          i = i + 1ul;
          struct String *return_value_str_insert$3;
          return_value_str_insert$3=str_insert(ret, (signed long int)tmp_post$2, "%c", quote_char);
          if(return_value_str_insert$3 == ((struct String *)NULL))
          {
            str_release(ret);
            return (struct String *)(void *)0;
          }

        }

      }
      return ret;
    }
  }
}

// rcpt
// file libslack/net.c line 4112
static signed int rcpt(signed int smtp, const char *recipients)
{
  struct List *list;
  list=split(recipients, ", ");
  _Bool tmp_if_expr$2;
  signed long int return_value_list_length$1;
  if(list == ((struct List *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_list_length$1=list_length(list);
    tmp_if_expr$2 = return_value_list_length$1 <= (signed long int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_list_has_next$3;
  _Bool tmp_if_expr$7;
  signed long int return_value_net_expect$6;
  if(tmp_if_expr$2)
    return -1;

  else
  {
    do
    {
      return_value_list_has_next$3=list_has_next(list);
      if(!(return_value_list_has_next$3 == 1))
        break;

      char *recipient;
      void *return_value_list_next$4;
      return_value_list_next$4=list_next(list);
      recipient=cstr((struct String *)return_value_list_next$4);
      signed int rc;
      signed int code;
      signed long int return_value_net_send$5;
      return_value_net_send$5=net_send(smtp, (signed long int)10, "RCPT TO: <%s>\r\n", recipient);
      if(return_value_net_send$5 == -1l)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_net_expect$6=net_expect(smtp, (signed long int)10, "%d", &code);
        rc = (signed int)return_value_net_expect$6;
        tmp_if_expr$7 = rc == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
      {
        list_release(list);
        return -1;
      }

      if(!(code == 250) || !(rc == 1))
      {
        list_release(list);
        signed int return_value_set_errno$8;
        return_value_set_errno$8=set_errno(71);
        return return_value_set_errno$8;
      }

    }
    while((_Bool)1);
    list_release(list);
    return 0;
  }
}

// react
// file libslack/agent.c line 1942
static signed int react(signed int (*reaction)(struct Agent *, signed int, signed int, void *), struct Agent *agent, signed int fd, signed int revents, void *arg)
{
  signed int err;
  signed int ret;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->unlock(agent->locker->lock);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  err = tmp_if_expr$2;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int return_value_1;
  signed int return_value_set_errno$3;
  if(!(err == 0))
  {
    return_value_set_errno$1=set_errno(err);
    return return_value_set_errno$1;
  }

  else
  {
    ret=reaction(agent, fd, revents, arg);
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value_1=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr$4 = return_value_1;
    }

    else
      tmp_if_expr$4 = 0;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$3=set_errno(err);
      return return_value_set_errno$3;
    }

    else
      return ret;
  }
}

// read_timeout
// file libslack/fio.c line 201
signed int read_timeout(signed int fd, signed long int sec, signed long int usec)
{
  struct anonymous$10 readfds[1l];
  struct anonymous$10 exceptfds[1l];
  struct timeval read_timeout$$1$$timeout[1l];
  signed int return_value_set_errno$1;
  if(!(fd >= 0) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&readfds[0l].fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    exceptfds[0l] = readfds[0l];
    read_timeout$$1$$timeout[0l].tv_sec = sec;
    read_timeout$$1$$timeout[0l].tv_usec = usec;
    signed int return_value_select$2;
    return_value_select$2=select(fd + 1, readfds, (struct anonymous$10 *)(void *)0, exceptfds, read_timeout$$1$$timeout);
    if(!(return_value_select$2 == -1))
    {
      if(return_value_select$2 == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_set_errno$3;
      return_value_set_errno$3=set_errno(110);
      return return_value_set_errno$3;
    }
    return 0;
  }
}

// reader
// file libslack/map.c line 2639
void * reader(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  if(!(debug == 0))
    printf("r%d: loop\n", t);

  i = 0;
  signed long int return_value_list_length$3;
  signed long int return_value_list_length$4;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    signed int key;
    signed int value;
    signed int r;
    struct List *keys;
    struct List *values;
    pthread_mutex_lock(rand_mutex);
    r=rand();
    pthread_mutex_unlock(rand_mutex);
    map_rdlock(mtmap);
    signed long int return_value_map_size_unlocked$1;
    return_value_map_size_unlocked$1=map_size_unlocked(mtmap);
    key = 1 + (signed int)(((double)(return_value_map_size_unlocked$1 - (signed long int)1) * (double)r) / ((double)2147483647 + 1.0));
    void *return_value_map_get_unlocked$2;
    return_value_map_get_unlocked$2=map_get_unlocked(mtmap, (void *)(signed long int)key);
    value = (signed int)(signed long int)return_value_map_get_unlocked$2;
    map_unlock(mtmap);
    keys=map_keys(mtmap);
    values=map_values(mtmap);
    if(!(debug == 0))
    {
      return_value_list_length$3=list_length(keys);
      return_value_list_length$4=list_length(values);
      printf("r%d: loop %d/%d key/val %d/%d, #keys %d, #values %d\n", t, i, lim / 10, key, value, (signed int)return_value_list_length$3, (signed int)return_value_list_length$4);
    }

    list_destroy(&keys);
    list_destroy(&values);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// recvfd
// file libslack/net.h line 142
signed long int recvfd(signed int sockfd, void *buf, unsigned long int nbytes, signed int flags, signed int *fd)
{
  struct msghdr mesg[1l];
  struct iovec iov[1l];
  signed long int rc;
  /* tag-#anon#lUN[lSYM#tag-cmsghdr#'align'||lARR24{S8}$S8$'control'|] */
union anonymous$3
{
  // align
  struct cmsghdr align;
  // control
  char control[24l];
};

/* */
  ;
  union anonymous$3 control;
  struct cmsghdr *cmsg;
  mesg[0l].msg_control = (void *)control.control;
  mesg[0l].msg_controllen = sizeof(char [24l]) /*24ul*/ ;
  signed int return_value_set_errno$1;
  struct cmsghdr *tmp_if_expr$2;
  if(fd == ((signed int *)NULL) || !(sockfd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    mesg[0l].msg_name = (void *)0;
    mesg[0l].msg_namelen = (unsigned int)0;
    mesg[0l].msg_iov = iov;
    mesg[0l].msg_iovlen = (unsigned long int)1;
    iov[0l].iov_base = buf;
    iov[0l].iov_len = nbytes;
    rc=recvmsg(sockfd, mesg, flags);
    if(!(rc >= 1l))
      return (signed long int)-1;

    else
    {
      *fd = -1;
      if(mesg[0l].msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
        tmp_if_expr$2 = (struct cmsghdr *)mesg[0l].msg_control;

      else
        tmp_if_expr$2 = (struct cmsghdr *)0;
      cmsg = tmp_if_expr$2;
      if(!(cmsg == ((struct cmsghdr *)NULL)))
      {
        if(cmsg->cmsg_len == sizeof(signed int) * 5 /*20ul*/ )
        {
          if(cmsg->cmsg_level == 1)
          {
            if(cmsg->cmsg_type == 1)
              *fd = *((signed int *)cmsg->__cmsg_data);

          }

        }

      }

      return rc;
    }
  }
}

// regexpr
// file libslack/str.c line 3117
struct List * regexpr(const char *pattern, const char *text, signed int cflags, signed int eflags)
{
  struct List *return_value_regexpr_with_locker$1;
  return_value_regexpr_with_locker$1=regexpr_with_locker((struct Locker *)(void *)0, pattern, text, cflags, eflags);
  return return_value_regexpr_with_locker$1;
}

// regexpr_compile
// file libslack/str.c line 3166
signed int regexpr_compile(struct re_pattern_buffer *compiled, const char *pattern, signed int cflags)
{
  if(pattern == ((const char *)NULL) || compiled == ((struct re_pattern_buffer *)NULL))
    return 2;

  else
  {
    signed int return_value_regcomp$1;
    return_value_regcomp$1=regcomp(compiled, pattern, cflags | 1);
    return return_value_regcomp$1;
  }
}

// regexpr_compiled
// file libslack/str.c line 3291
struct List * regexpr_compiled(const struct re_pattern_buffer *compiled, const char *text, signed int eflags)
{
  struct List *return_value_regexpr_compiled_with_locker$1;
  return_value_regexpr_compiled_with_locker$1=regexpr_compiled_with_locker((struct Locker *)(void *)0, compiled, text, eflags);
  return return_value_regexpr_compiled_with_locker$1;
}

// regexpr_compiled_with_locker
// file libslack/str.c line 3307
struct List * regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const char *text, signed int eflags)
{
  struct anonymous$7 match[33l];
  struct List *ret;
  signed int i;
  signed int err;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  _Bool tmp_if_expr$3;
  if(text == ((const char *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    err=regexec(compiled, text, (unsigned long int)33, match, eflags);
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_create_with_locker(locker, (void (*)(void *))str_release);
      if(ret == ((struct List *)NULL))
        return (struct List *)(void *)0;

      else
      {
        i = 0;
        do
        {
          if(!(i >= 33))
            tmp_if_expr$3 = match[(signed long int)i].rm_so != -1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(!tmp_if_expr$3)
            break;

          struct String *m;
          m=substr(text, (signed long int)match[(signed long int)i].rm_so, (signed long int)(match[(signed long int)i].rm_eo - match[(signed long int)i].rm_so));
          if(m == ((struct String *)NULL))
          {
            list_release(ret);
            return (struct List *)(void *)0;
          }

          struct List *return_value_list_append$4;
          return_value_list_append$4=list_append(ret, (void *)m);
          if(return_value_list_append$4 == ((struct List *)NULL))
          {
            str_release(m);
            list_release(ret);
            return (struct List *)(void *)0;
          }

          i = i + 1;
        }
        while((_Bool)1);
        return ret;
      }
    }
  }
}

// regexpr_release
// file libslack/str.c line 3184
void regexpr_release(struct re_pattern_buffer *compiled)
{
  if(!(compiled == ((struct re_pattern_buffer *)NULL)))
    regfree(compiled);

}

// regexpr_split
// file libslack/str.c line 4236
struct List * regexpr_split(const char *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *return_value_regexpr_split_with_locker$1;
  return_value_regexpr_split_with_locker$1=regexpr_split_with_locker((struct Locker *)(void *)0, str, delim, cflags, eflags);
  return return_value_regexpr_split_with_locker$1;
}

// regexpr_split_with_locker
// file libslack/str.c line 4252
struct List * regexpr_split_with_locker(struct Locker *locker, const char *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *ret;
  struct String *token;
  struct re_pattern_buffer compiled[1l];
  struct anonymous$7 match[1l];
  signed int start;
  signed int matches;
  signed int err;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(delim == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    err=regexpr_compile(compiled, delim, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=list_create_with_locker(locker, (void (*)(void *))str_release);
      if(ret == ((struct List *)NULL))
        return (struct List *)(void *)0;

      else
      {
        start = 0;
        matches = 0;
        for( ; !(str[(signed long int)start] == 0); matches = matches + 1)
        {
          signed int return_value_regexec$3;
          return_value_regexec$3=regexec(compiled, str + (signed long int)start, (unsigned long int)1, match, eflags);
          if(!(return_value_regexec$3 == 0))
            break;

          if(match[0l].rm_so == 0)
          {
            if(match[0l].rm_eo == 0)
            {
              match[(signed long int)0].rm_so = match[(signed long int)0].rm_so + 1;
              match[(signed long int)0].rm_eo = match[(signed long int)0].rm_eo + 1;
            }

          }

          if(!(match[0l].rm_so == 0))
          {
            token=substr(str, (signed long int)start, (signed long int)match[(signed long int)0].rm_so);
            if(token == ((struct String *)NULL))
            {
              list_release(ret);
              return (struct List *)(void *)0;
            }

            struct List *return_value_list_append$4;
            return_value_list_append$4=list_append(ret, (void *)token);
            if(return_value_list_append$4 == ((struct List *)NULL))
            {
              str_release(token);
              list_release(ret);
              return (struct List *)(void *)0;
            }

          }

          start = start + match[(signed long int)0].rm_eo;
        }
        if(!(str[(signed long int)start] == 0))
        {
          token=str_create("%s", str + (signed long int)start);
          if(token == ((struct String *)NULL))
          {
            list_release(ret);
            return (struct List *)(void *)0;
          }

          struct List *return_value_list_append$5;
          return_value_list_append$5=list_append(ret, (void *)token);
          if(return_value_list_append$5 == ((struct List *)NULL))
          {
            str_release(token);
            list_release(ret);
            return (struct List *)(void *)0;
          }

        }

        return ret;
      }
    }
  }
}

// regexpr_with_locker
// file libslack/str.c line 3133
struct List * regexpr_with_locker(struct Locker *locker, const char *pattern, const char *text, signed int cflags, signed int eflags)
{
  struct re_pattern_buffer compiled[1l];
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(pattern == ((const char *)NULL) || text == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    err=regexpr_compile(compiled, pattern, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=regexpr_compiled_with_locker(locker, compiled, text, eflags);
      regfree(compiled);
      return ret;
    }
  }
}

// release_action
// file libslack/agent.c line 273
static struct action_t * release_action(struct action_t *action)
{
  struct action_t *next;
  void *return_value_dlink_next$1;
  return_value_dlink_next$1=dlink_next((void *)action);
  next = (struct action_t *)return_value_dlink_next$1;
  free((void *)action);
  return next;
}

// release_actions
// file libslack/agent.c line 282
static void release_actions(struct action_t *action)
{
  while(!(action == ((struct action_t *)NULL)))
    action=release_action(action);
}

// rudp_create
// file libslack/net.c line 2363
struct rudp_t * rudp_create(void)
{
  struct rudp_t *rudp;
  struct timeval now[1l];
  signed int return_value_gettimeofday$1;
  return_value_gettimeofday$1=gettimeofday(now, (struct timezone *)(void *)0);
  if(return_value_gettimeofday$1 == -1)
    return (struct rudp_t *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct rudp_t) /*48ul*/ );
    rudp = (struct rudp_t *)return_value_malloc$2;
    if(rudp == ((struct rudp_t *)NULL))
      return (struct rudp_t *)(void *)0;

    else
    {
      rudp->base = (unsigned int)now[0l].tv_sec;
      rudp_init(rudp);
      return rudp;
    }
  }
}

// rudp_destroy
// file libslack/net.c line 2406
void * rudp_destroy(struct rudp_t **rudp)
{
  if(!(rudp == ((struct rudp_t **)NULL)))
  {
    if(!(*rudp == ((struct rudp_t *)NULL)))
    {
      rudp_release(*rudp);
      *rudp = (struct rudp_t *)(void *)0;
    }

  }

  return (void *)0;
}

// rudp_init
// file libslack/net.c line 2342
static signed int rudp_init(struct rudp_t *rudp)
{
  signed int return_value_set_errno$1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    rudp->rtt = 0.0;
    rudp->srtt = 0.0;
    rudp->rttvar = 0.75;
    rudp->rto=rudp_minmax(rudp->srtt + 4.0 * rudp->rttvar);
    rudp->sequence = (unsigned int)0;
    return 0;
  }
}

// rudp_minmax
// file libslack/net.c line 2331
static double rudp_minmax(double rto)
{
  if(rto < 2.000000)
    return (double)2;

  else
    if(rto > 60.000000)
      return (double)60;

    else
      return rto;
}

// rudp_newpack
// file libslack/net.c line 2453
static unsigned int rudp_newpack(struct rudp_t *rudp)
{
  signed int return_value_set_errno$1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (unsigned int)return_value_set_errno$1;
  }

  else
  {
    rudp->nrexmt = 0;
    rudp->sequence = rudp->sequence + 1u;
    return rudp->sequence;
  }
}

// rudp_release
// file libslack/net.c line 2390
void rudp_release(struct rudp_t *rudp)
{
  free((void *)rudp);
}

// rudp_start
// file libslack/net.c line 2473
static double rudp_start(struct rudp_t *rudp)
{
  signed int return_value_set_errno$1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (double)return_value_set_errno$1;
  }

  else
    return rudp->rto;
}

// rudp_stop
// file libslack/net.c line 2492
static signed int rudp_stop(struct rudp_t *rudp, unsigned int rtt)
{
  double delta;
  signed int return_value_set_errno$1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    rudp->rtt = (double)rtt / 1000.0;
    delta = rudp->rtt - rudp->srtt;
    rudp->srtt = rudp->srtt + delta / (double)8;
    double return_value_fabs$2;
    return_value_fabs$2=fabs(delta);
    rudp->rttvar = rudp->rttvar + (return_value_fabs$2 - rudp->rttvar) / (double)4;
    rudp->rto=rudp_minmax(rudp->srtt + 4.0 * rudp->rttvar);
    return 0;
  }
}

// rudp_timeout
// file libslack/net.c line 2520
static signed int rudp_timeout(struct rudp_t *rudp)
{
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    rudp->rto = rudp->rto * (double)2;
    rudp->nrexmt = rudp->nrexmt + 1;
    if(rudp->nrexmt >= 4)
    {
      return_value_set_errno$2=set_errno(110);
      return return_value_set_errno$2;
    }

    else
      return 0;
  }
}

// rudp_timestamp
// file libslack/net.c line 2428
static unsigned int rudp_timestamp(struct rudp_t *rudp)
{
  struct timeval now[1l];
  signed int return_value_set_errno$1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (unsigned int)return_value_set_errno$1;
  }

  else
  {
    signed int return_value_gettimeofday$2;
    return_value_gettimeofday$2=gettimeofday(now, (struct timezone *)(void *)0);
    if(return_value_gettimeofday$2 == -1)
      return (unsigned int)-1;

    else
      return (unsigned int)((signed long int)(unsigned int)((now[0l].tv_sec - (signed long int)rudp->base) * (signed long int)1000) + now[0l].tv_usec / (signed long int)1000);
  }
}

// rw_timeout
// file libslack/fio.c line 297
signed int rw_timeout(signed int fd, signed long int sec, signed long int usec)
{
  struct anonymous$10 readfds[1l];
  struct anonymous$10 writefds[1l];
  struct anonymous$10 exceptfds[1l];
  struct timeval rw_timeout$$1$$timeout[1l];
  signed int rc = 0;
  signed int return_value_set_errno$1;
  if(!(fd >= 0) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&readfds[0l].fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    writefds[0l] = readfds[0l];
    exceptfds[0l] = readfds[0l];
    rw_timeout$$1$$timeout[0l].tv_sec = sec;
    rw_timeout$$1$$timeout[0l].tv_usec = usec;
    signed int return_value_select$2;
    return_value_select$2=select(fd + 1, readfds, writefds, exceptfds, rw_timeout$$1$$timeout);
    if(!(return_value_select$2 == -1))
    {
      if(return_value_select$2 == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_set_errno$3;
      return_value_set_errno$3=set_errno(110);
      return return_value_set_errno$3;
    }
    if(!((readfds[0l].fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      rc = rc | 4;

    if(!((writefds[0l].fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      rc = rc | 2;

    if(!((exceptfds[0l].fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      rc = rc | 1;

    return rc;
  }
}

// sendfd
// file libslack/net.h line 141
signed long int sendfd(signed int sockfd, const void *buf, unsigned long int nbytes, signed int flags, signed int fd)
{
  struct msghdr mesg[1l];
  struct iovec iov[1l];
  /* tag-#anon#lUN[lSYM#tag-cmsghdr#'align'||lARR24{S8}$S8$'control'|] */
union anonymous$3
{
  // align
  struct cmsghdr align;
  // control
  char control[24l];
};

/* */
  ;
  union anonymous$3 control;
  struct cmsghdr *cmsg;
  signed int return_value_set_errno$1;
  struct cmsghdr *tmp_if_expr$2;
  if(!(fd >= 0) || !(sockfd >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    mesg[0l].msg_control = (void *)control.control;
    mesg[0l].msg_controllen = sizeof(char [24l]) /*24ul*/ ;
    if(mesg[0l].msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
      tmp_if_expr$2 = (struct cmsghdr *)mesg[0l].msg_control;

    else
      tmp_if_expr$2 = (struct cmsghdr *)0;
    cmsg = tmp_if_expr$2;
    cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(signed int) /*4ul*/ ;
    cmsg->cmsg_level = 1;
    cmsg->cmsg_type = 1;
    *((signed int *)cmsg->__cmsg_data) = fd;
    mesg[0l].msg_name = (void *)0;
    mesg[0l].msg_namelen = (unsigned int)0;
    mesg[0l].msg_iov = iov;
    mesg[0l].msg_iovlen = (unsigned long int)1;
    iov[0l].iov_base = (void *)buf;
    iov[0l].iov_len = nbytes;
    signed long int return_value_sendmsg$3;
    return_value_sendmsg$3=sendmsg(sockfd, mesg, flags);
    return return_value_sendmsg$3;
  }
}

// service_number
// file libslack/net.c line 525
static signed int service_number(const char *service)
{
  char *endptr = (char *)(void *)0;
  unsigned long int val;
  val=strtoul(service, &endptr, 10);
  val=strtoul(service, &endptr, 10);
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$3;
  signed int return_value_set_errno$2;
  if(val >= 65536ul)
  {
    return_value_set_errno$1=set_errno(34);
    return return_value_set_errno$1;
  }

  else
  {
    if(endptr == service)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_set_errno$2=set_errno(33);
      return return_value_set_errno$2;
    }

    else
      return (signed int)val;
  }
}

// service_port
// file libslack/net.c line 539
static unsigned short int service_port(const char *service, signed int type, signed int port)
{
  unsigned short int tmp_statement_expression$1;
  if(!(service == ((const char *)NULL)))
  {
    signed int ret;
    ret=service_number(service);
    if(!(ret == -1))
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)ret;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$1 = __v;
      return tmp_statement_expression$1;
    }

    unsigned short int return_value_getservportbynameandtype$2;
    return_value_getservportbynameandtype$2=getservportbynameandtype(service, type);
    ret = (signed int)return_value_getservportbynameandtype$2;
    if(!(ret == 0))
      return (unsigned short int)ret;

  }

  unsigned short int tmp_statement_expression$3;
  unsigned short int service_port$$1$$2$$__v;
  unsigned short int service_port$$1$$2$$__x = (unsigned short int)port;
  asm("rorw $8, %w0" : "=r"(service_port$$1$$2$$__v) : "0"(service_port$$1$$2$$__x) : "cc");
  tmp_statement_expression$3 = service_port$$1$$2$$__v;
  return tmp_statement_expression$3;
}

// set_errno
// file libslack/err.h line 83
signed int set_errno(signed int errnum)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = errnum;
  return -1;
}

// set_errnull
// file libslack/err.h line 84
void * set_errnull(signed int errnum)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = errnum;
  return (void *)0;
}

// set_errnullf
// file libslack/err.c line 748
void (*set_errnullf(signed int errnum))()
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = errnum;
  return (void (*)())(void *)0;
}

// shrink
// file libslack/list.c line 247
static signed int shrink(struct List *list, unsigned long int items)
{
  signed int shrunk = 0;
  for( ; !(list->length + -items >= list->size >> 1); shrunk = 1)
  {
    if(list->size == MIN_LIST_SIZE)
      break;

    list->size = list->size >> 1;
  }
  void *return_value_mem_resize_fn$1;
  if(!(shrunk == 0))
  {
    return_value_mem_resize_fn$1=mem_resize_fn((void **)&list->list, list->size * sizeof(void *) /*8ul*/ );
    return return_value_mem_resize_fn$1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// shrink$link1
// file libslack/str.c line 426
static signed int shrink$link1(struct String *str, unsigned long int bytes)
{
  signed int shrunk$link1 = 0;
  for( ; !(str->length + -bytes >= str->size >> 1); shrunk$link1 = 1)
  {
    if(MIN_EMPTY_STRING_SIZE >= str->size)
      break;

    str->size = str->size >> 1;
  }
  void *return_value_mem_resize_fn$1$link1;
  if(!(shrunk$link1 == 0))
  {
    return_value_mem_resize_fn$1$link1=mem_resize_fn((void **)&str->str, str->size * sizeof(char) /*1ul*/ );
    return return_value_mem_resize_fn$1$link1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// signal_addset
// file libslack/sig.c line 201
signed int signal_addset(signed int signo_handled, signed int signo_blocked)
{
  struct real_signal_handler_t *h = &g_handler[(signed long int)signo_handled];
  signed int return_value_sigaddset$1;
  return_value_sigaddset$1=sigaddset(&h->action[0l].sa_mask, signo_blocked);
  return return_value_sigaddset$1;
}

// signal_catcher
// file libslack/sig.c line 120
static void signal_catcher(signed int signo)
{
  g_received[(signed long int)signo] = g_received[(signed long int)signo] + 1;
}

// signal_handle
// file libslack/sig.c line 264
signed int signal_handle(signed int signo)
{
  struct real_signal_handler_t *h = &g_handler[(signed long int)signo];
  struct anonymous$6 origmask[1l];
  signed int return_value_sigprocmask$1;
  return_value_sigprocmask$1=sigprocmask(0, &h->action[0l].sa_mask, origmask);
  if(return_value_sigprocmask$1 == -1)
    return -1;

  else
  {
    g_handler[(signed long int)signo].handler(signo);
    g_received[(signed long int)signo] = 0;
    signed int return_value_sigprocmask$2;
    return_value_sigprocmask$2=sigprocmask(2, origmask, (struct anonymous$6 *)(void *)0);
    return return_value_sigprocmask$2;
  }
}

// signal_handle_all
// file libslack/sig.c line 292
void signal_handle_all(void)
{
  signed int signo = 0;
  signed int return_value_signal_received$1;
  for( ; !(signo >= 65); signo = signo + 1)
  {
    return_value_signal_received$1=signal_received(signo);
    if(!(return_value_signal_received$1 == 0))
      signal_handle(signo);

  }
}

// signal_raise
// file libslack/sig.c line 242
signed int signal_raise(signed int signo)
{
  signed int return_value_set_errno$1;
  if(signo >= 65 || !(signo >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    g_received[(signed long int)signo] = g_received[(signed long int)signo] + 1;
    return g_received[(signed long int)signo];
  }
}

// signal_received
// file libslack/sig.c line 221
signed int signal_received(signed int signo)
{
  signed int return_value_set_errno$1;
  if(signo >= 65 || !(signo >= 0))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    return g_received[(signed long int)signo];
}

// signal_set_handler
// file libslack/sig.c line 149
signed int signal_set_handler(signed int signo, signed int flags, void (*handler)(signed int))
{
  struct real_signal_handler_t *h = &g_handler[(signed long int)signo];
  sigemptyset(&h->action[0l].sa_mask);
  sigaddset(&h->action[0l].sa_mask, signo);
  h->action[0l].sa_flags = flags;
  if(handler == ((void (*)(signed int))NULL) || handler == (void (*)(signed int))1)
    h->action[0l].__sigaction_handler.sa_handler = handler;

  else
  {
    if(signo == 4 || signo == 6 || signo == 7 || signo == 8 || signo == 11 || signo == 31)
    {
      h->action[0l].__sigaction_handler.sa_handler = handler;
      goto __CPROVER_DUMP_L4;
    }

    h->action[0l].__sigaction_handler.sa_handler = signal_catcher;
  }

__CPROVER_DUMP_L4:
  ;
  h->handler = handler;
  g_received[(signed long int)signo] = 0;
  signed int return_value_sigaction$1;
  return_value_sigaction$1=sigaction(signo, h->action, (struct sigaction *)(void *)0);
  return return_value_sigaction$1;
}

// slink_alloc
// file libslack/link.c line 460
void * slink_alloc(void **freelist)
{
  void *alloc;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(freelist == ((void **)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    if(*freelist == NULL)
    {
      return_value_set_errnull$2=set_errnull(28);
      return return_value_set_errnull$2;
    }

    else
    {
      alloc = *freelist;
      *freelist=slink_remove(*freelist);
      return alloc;
    }
}

// slink_free
// file libslack/link.c line 518
void * slink_free(void **freelist, void *item)
{
  void *return_value_set_errnull$1;
  if(item == NULL || freelist == ((void **)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    *freelist=slink_insert(*freelist, item);
    return *freelist;
  }
}

// slink_freelist_attach
// file libslack/link.c line 396
void * slink_freelist_attach(void *freelist1, void *freelist2)
{
  char *freelist;
  void *return_value_set_errnull$1;
  signed int return_value_slink_has_next$2;
  void *return_value_slink_next$3;
  if(freelist2 == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    freelist = (char *)freelist1;
    if(freelist == ((char *)NULL))
      return freelist2;

    else
    {
      do
      {
        return_value_slink_has_next$2=slink_has_next((void *)freelist);
        if(!(return_value_slink_has_next$2 == 1))
          break;

        return_value_slink_next$3=slink_next((void *)freelist);
        freelist = (char *)return_value_slink_next$3;
      }
      while((_Bool)1);
      ((struct slink_t *)freelist)->next = freelist2;
      return freelist1;
    }
  }
}

// slink_freelist_init
// file libslack/link.c line 334
void * slink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size)
{
  char *link;
  void *return_value_set_errnull$1;
  if(freelist == NULL || nelem == 0ul || size == 0ul)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    link = (char *)freelist;
    do
    {
      nelem = nelem - 1ul;
      if(nelem == 0ul)
        break;

      ((struct slink_t *)link)->next = (void *)(link + (signed long int)size);
      link = link + (signed long int)size;
    }
    while((_Bool)1);
    ((struct slink_t *)link)->next = (void *)0;
    return freelist;
  }
}

// slink_has_next
// file libslack/link.c line 105
signed int slink_has_next(void *link)
{
  signed int return_value_set_errno$1;
  if(link == NULL)
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    return (signed int)(((struct slink_t *)link)->next != (void *)0);
}

// slink_insert
// file libslack/link.c line 220
void * slink_insert(void *link, void *item)
{
  struct slink_t *insert;
  void *return_value_set_errnull$1;
  if(item == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    insert = (struct slink_t *)item;
    insert->next = link;
    return (void *)insert;
  }
}

// slink_next
// file libslack/link.c line 124
void * slink_next(void *link)
{
  void *return_value_set_errnull$1;
  if(link == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
    return ((struct slink_t *)link)->next;
}

// slink_remove
// file libslack/link.c line 280
void * slink_remove(void *link)
{
  struct slink_t *remove;
  void *return_value_set_errnull$1;
  if(link == NULL)
  {
    return_value_set_errnull$1=set_errnull(22);
    return return_value_set_errnull$1;
  }

  else
  {
    remove = (struct slink_t *)link;
    return remove->next;
  }
}

// sort_cmp
// file libslack/map.c line 2409
static signed int sort_cmp(const char **a, const char **b)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(*a, *b);
  return return_value_strcmp$1;
}

// soundex
// file libslack/str.c line 4592
signed int soundex(const char *str)
{
  const char * const soundex_table = "S\n\0-\001\002\002";
  /* tag-#anon#lUN[lARR4{S8}$S8$'c'||S32'i'|] */
union anonymous$8
{
  // c
  char c[4l];
  // i
  signed int i;
};

/* */
  ;
  union anonymous$8 soundex$$1$$soundex;
  signed int last;
  signed int small;
  signed int return_value_set_errno$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$3;
  const signed int **return_value___ctype_toupper_loc$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$9;
  if(str == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    soundex$$1$$soundex.i = 0;
    last = -1;
    small = 0;
    for( ; !(*str == 0) && !(small >= 4); str = str + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc$8;
      return_value___ctype_b_loc$8=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)(unsigned char)*str]) == 0))
      {
        signed int code;
        signed int __res;
        __res=toupper((signed int)(unsigned char)*str);
        tmp_statement_expression$2 = __res;
        code = tmp_statement_expression$2;
        if(small == 0)
        {
          tmp_post$6 = small;
          small = small + 1;
          soundex$$1$$soundex.c[(signed long int)tmp_post$6] = (char)code;
          last = (signed int)soundex_table[(signed long int)(code - 65)];
        }

        else
        {
          code = (signed int)soundex_table[(signed long int)(code - 65)];
          if(!(code == last))
          {
            if(!(code == 0))
            {
              tmp_post$7 = small;
              small = small + 1;
              soundex$$1$$soundex.c[(signed long int)tmp_post$7] = (char)code;
            }

            last = code;
          }

        }
      }

    }
    for( ; !(small >= 4); soundex$$1$$soundex.c[(signed long int)tmp_post$9] = (char)48)
    {
      tmp_post$9 = small;
      small = small + 1;
    }
    unsigned int return_value___bswap_32$10;
    return_value___bswap_32$10=__bswap_32$link1((unsigned int)soundex$$1$$soundex.i);
    return (signed int)return_value___bswap_32$10;
  }
}

// split
// file libslack/str.h line 175
struct List * split(const char *str, const char *delim)
{
  struct List *return_value_split_with_locker$1;
  return_value_split_with_locker$1=split_with_locker((struct Locker *)(void *)0, str, delim);
  return return_value_split_with_locker$1;
}

// split_with_locker
// file libslack/str.c line 4128
struct List * split_with_locker(struct Locker *locker, const char *str, const char *delim)
{
  void *return_value_set_errnull$1;
  if(delim == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    struct List *return_value_do_split_with_locker$2;
    return_value_do_split_with_locker$2=do_split_with_locker(locker, str, (signed long int)-1, delim);
    return return_value_do_split_with_locker$2;
  }
}

// squeeze
// file libslack/str.c line 4982
char * squeeze(char *str)
{
  char *s;
  char *r;
  signed int started = 0;
  signed int was_space = 0;
  void *return_value_set_errnull$1;
  char *tmp_post$2;
  char *tmp_post$3;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    s = str;
    r = s;
    for( ; !(*s == 0); s = s + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc$4;
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)*s]) == 0)
      {
        if(!(started == 0) && !(was_space == 0))
        {
          tmp_post$2 = r;
          r = r + 1l;
          *tmp_post$2 = (char)32;
        }

        tmp_post$3 = r;
        r = r + 1l;
        *tmp_post$3 = *s;
        started = 1;
      }

      const unsigned short int **return_value___ctype_b_loc$5;
      return_value___ctype_b_loc$5=__ctype_b_loc();
      was_space = (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192;
    }
    *r = (char)0;
    return str;
  }
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// stat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link1(const char *__path$link1, struct stat *__statbuf$link1)
{
  signed int return_value___xstat$1$link1;
  return_value___xstat$1$link1=__xstat(1, __path$link1, __statbuf$link1);
  return return_value___xstat$1$link1;
}

// stat$link2
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link2(const char *__path$link2, struct stat *__statbuf$link2)
{
  signed int return_value___xstat$1$link2;
  return_value___xstat$1$link2=__xstat(1, __path$link2, __statbuf$link2);
  return return_value___xstat$1$link2;
}

// stat$link3
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link3(const char *__path$link3, struct stat *__statbuf$link3)
{
  signed int return_value___xstat$1$link3;
  return_value___xstat$1$link3=__xstat(1, __path$link3, __statbuf$link3);
  return return_value___xstat$1$link3;
}

// str_append
// file libslack/str.c line 1538
struct String * str_append(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert(str, (signed long int)-1, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_append_str
// file libslack/str.c line 1610
struct String * str_append_str(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str$1;
  return_value_str_insert_str$1=str_insert_str(str, (signed long int)-1, src);
  return return_value_str_insert_str$1;
}

// str_append_str_unlocked
// file libslack/str.c line 1628
struct String * str_append_str_unlocked(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str_unlocked$1;
  return_value_str_insert_str_unlocked$1=str_insert_str_unlocked(str, (signed long int)-1, src);
  return return_value_str_insert_str_unlocked$1;
}

// str_append_unlocked
// file libslack/str.c line 1558
struct String * str_append_unlocked(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert_unlocked(str, (signed long int)-1, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_bin
// file libslack/str.c line 6235
signed int str_bin(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=str_bin_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// str_bin_unlocked
// file libslack/str.c line 6264
signed int str_bin_unlocked(const struct String *str)
{
  signed int return_value_set_errno$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_bin$2;
    return_value_bin$2=bin(str->str);
    return return_value_bin$2;
  }
}

// str_chomp
// file libslack/str.c line 6141
signed int str_chomp(struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=str_chomp_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// str_chomp_unlocked
// file libslack/str.c line 6170
signed int str_chomp_unlocked(struct String *str)
{
  char *s;
  unsigned long int length;
  signed int return_value_set_errno$1;
  _Bool tmp_if_expr$2;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if(str->length == 1ul)
      return 0;

    else
    {
      length = str->length;
      s = (str->str + (signed long int)str->length) - (signed long int)2;
      do
      {
        if((signed int)*s == 10)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*s == 13 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        signed int return_value_contract$3;
        return_value_contract$3=contract$link1(str, (signed long int)(str->length - (unsigned long int)2), (unsigned long int)1);
        if(return_value_contract$3 == -1)
          return -1;

        s = s - 1l;
      }
      while((_Bool)1);
      return (signed int)(length - str->length);
    }
}

// str_chop
// file libslack/str.c line 6055
signed int str_chop(struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=str_chop_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// str_chop_unlocked
// file libslack/str.c line 6084
signed int str_chop_unlocked(struct String *str)
{
  signed int ret;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    if(str->length == 1ul)
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      ret = (signed int)str->str[(signed long int)(str->length - (unsigned long int)2)];
      signed int return_value_contract$3;
      return_value_contract$3=contract$link1(str, (signed long int)(str->length - (unsigned long int)2), (unsigned long int)1);
      if(return_value_contract$3 == -1)
        return -1;

      else
        return ret;
    }
}

// str_clear
// file libslack/str.c line 1212
struct String * str_clear(struct String *str)
{
  struct String *return_value_str_remove_range$1;
  return_value_str_remove_range$1=str_remove_range(str, (signed long int)0, (signed long int)-1);
  return return_value_str_remove_range$1;
}

// str_clear_unlocked
// file libslack/str.c line 1227
struct String * str_clear_unlocked(struct String *str)
{
  struct String *return_value_str_remove_range_unlocked$1;
  return_value_str_remove_range_unlocked$1=str_remove_range_unlocked(str, (signed long int)0, (signed long int)-1);
  return return_value_str_remove_range_unlocked$1;
}

// str_copy
// file libslack/str.c line 740
struct String * str_copy(const struct String *str)
{
  struct String *return_value_str_copy_with_locker$1;
  return_value_str_copy_with_locker$1=str_copy_with_locker((struct Locker *)(void *)0, str);
  return return_value_str_copy_with_locker$1;
}

// str_copy_unlocked
// file libslack/str.c line 755
struct String * str_copy_unlocked(const struct String *str)
{
  struct String *return_value_str_copy_with_locker_unlocked$1;
  return_value_str_copy_with_locker_unlocked$1=str_copy_with_locker_unlocked((struct Locker *)(void *)0, str);
  return return_value_str_copy_with_locker_unlocked$1;
}

// str_copy_with_locker
// file libslack/str.c line 771
struct String * str_copy_with_locker(struct Locker *locker, const struct String *str)
{
  struct String *return_value_str_substr_with_locker$1;
  return_value_str_substr_with_locker$1=str_substr_with_locker(locker, str, (signed long int)0, (signed long int)-1);
  return return_value_str_substr_with_locker$1;
}

// str_copy_with_locker_unlocked
// file libslack/str.c line 787
struct String * str_copy_with_locker_unlocked(struct Locker *locker, const struct String *str)
{
  struct String *return_value_str_substr_with_locker_unlocked$1;
  return_value_str_substr_with_locker_unlocked$1=str_substr_with_locker_unlocked(locker, str, (signed long int)0, (signed long int)-1);
  return return_value_str_substr_with_locker_unlocked$1;
}

// str_create
// file libslack/str.c line 531
struct String * str_create(const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized((struct Locker *)(void *)0, MIN_STRING_SIZE, format, args);
  args = ((void **)NULL);
  return str;
}

// str_create_sized
// file libslack/str.c line 609
struct String * str_create_sized(unsigned long int size, const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized((struct Locker *)(void *)0, size, format, args);
  args = ((void **)NULL);
  return str;
}

// str_create_with_locker
// file libslack/str.c line 552
struct String * str_create_with_locker(struct Locker *locker, const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized(locker, MIN_STRING_SIZE, format, args);
  args = ((void **)NULL);
  return str;
}

// str_create_with_locker_sized
// file libslack/str.c line 630
struct String * str_create_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized(locker, size, format, args);
  args = ((void **)NULL);
  return str;
}

// str_decode
// file libslack/str.c line 5606
struct String * str_decode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_decode_with_locker$1;
  return_value_str_decode_with_locker$1=str_decode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_decode_with_locker$1;
}

// str_decode_unlocked
// file libslack/str.c line 5621
struct String * str_decode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_decode_with_locker_unlocked$1;
  return_value_str_decode_with_locker_unlocked$1=str_decode_with_locker_unlocked((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_decode_with_locker_unlocked$1;
}

// str_decode_with_locker
// file libslack/str.c line 5637
struct String * str_decode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_decode_with_locker_unlocked(locker, str, uncoded, coded, quote_char, printable);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        str_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_decode_with_locker_unlocked
// file libslack/str.c line 5670
struct String * str_decode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull$1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    struct String *return_value_do_decode_with_locker$2;
    return_value_do_decode_with_locker$2=do_decode_with_locker(locker, str->str, str->length - (unsigned long int)1, uncoded, coded, quote_char, printable);
    return return_value_do_decode_with_locker$2;
  }
}

// str_destroy
// file libslack/str.c line 894
void * str_destroy(struct String **str)
{
  if(!(str == ((struct String **)NULL)))
  {
    if(!(*str == ((struct String *)NULL)))
    {
      str_release(*str);
      *str = (struct String *)(void *)0;
    }

  }

  return (void *)0;
}

// str_empty
// file libslack/str.c line 987
signed int str_empty(const struct String *str)
{
  signed int empty;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      empty=str_empty_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return empty;
    }
  }
}

// str_empty_unlocked
// file libslack/str.c line 1016
signed int str_empty_unlocked(const struct String *str)
{
  signed int return_value_set_errno$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
    return (signed int)(str->length == (unsigned long int)1);
}

// str_encode
// file libslack/str.c line 5517
struct String * str_encode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_encode_with_locker$1;
  return_value_str_encode_with_locker$1=str_encode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_encode_with_locker$1;
}

// str_encode_unlocked
// file libslack/str.c line 5532
struct String * str_encode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_encode_with_locker_unlocked$1;
  return_value_str_encode_with_locker_unlocked$1=str_encode_with_locker_unlocked((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_encode_with_locker_unlocked$1;
}

// str_encode_with_locker
// file libslack/str.c line 5548
struct String * str_encode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_encode_with_locker_unlocked(locker, str, uncoded, coded, quote_char, printable);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        str_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_encode_with_locker_unlocked
// file libslack/str.c line 5581
struct String * str_encode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull$1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    struct String *return_value_do_encode_with_locker$2;
    return_value_do_encode_with_locker$2=do_encode_with_locker(locker, str->str, str->length - (unsigned long int)1, uncoded, coded, quote_char, printable);
    return return_value_do_encode_with_locker$2;
  }
}

// str_fgetline
// file libslack/str.c line 812
struct String * str_fgetline(struct _IO_FILE *stream)
{
  struct String *return_value_str_fgetline_with_locker$1;
  return_value_str_fgetline_with_locker$1=str_fgetline_with_locker((struct Locker *)(void *)0, stream);
  return return_value_str_fgetline_with_locker$1;
}

// str_fgetline_with_locker
// file libslack/str.c line 828
struct String * str_fgetline_with_locker(struct Locker *locker, struct _IO_FILE *stream)
{
  struct String *ret = (struct String *)(void *)0;
  char buf[8192l];
  flockfile(stream);
  char *return_value_fgetline_unlocked$1;
  struct String *return_value_str_append$2;
  do
  {
    return_value_fgetline_unlocked$1=fgetline_unlocked(buf, (unsigned long int)8192, stream);
    if(return_value_fgetline_unlocked$1 == ((char *)NULL))
      break;

    if(ret == ((struct String *)NULL))
    {
      ret=str_create_with_locker(locker, "%s", (const void *)buf);
      if(ret == ((struct String *)NULL))
        break;

    }

    else
    {
      return_value_str_append$2=str_append(ret, "%s", (const void *)buf);
      if(return_value_str_append$2 == ((struct String *)NULL))
      {
        str_destroy(&ret);
        break;
      }

    }
    char *return_value_cstr$3;
    return_value_cstr$3=cstr(ret);
    if((signed int)return_value_cstr$3[-2l + (signed long int)ret->length] == 10)
      break;

  }
  while((_Bool)1);
  funlockfile(stream);
  return ret;
}

// str_fmt
// file libslack/str.c line 3675
struct List * str_fmt(const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *return_value_str_fmt_with_locker$1;
  return_value_str_fmt_with_locker$1=str_fmt_with_locker((struct Locker *)(void *)0, str, line_width, alignment);
  return return_value_str_fmt_with_locker$1;
}

// str_fmt_unlocked
// file libslack/str.c line 3690
struct List * str_fmt_unlocked(const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *return_value_str_fmt_with_locker_unlocked$1;
  return_value_str_fmt_with_locker_unlocked$1=str_fmt_with_locker_unlocked((struct Locker *)(void *)0, str, line_width, alignment);
  return return_value_str_fmt_with_locker_unlocked$1;
}

// str_fmt_with_locker
// file libslack/str.c line 3706
struct List * str_fmt_with_locker(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_fmt_with_locker_unlocked(locker, str, line_width, alignment);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_fmt_with_locker_unlocked
// file libslack/str.c line 3739
struct List * str_fmt_with_locker_unlocked(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  void *return_value_set_errnull$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    struct List *return_value_fmt_with_locker$2;
    return_value_fmt_with_locker$2=fmt_with_locker(locker, str->str, line_width, alignment);
    return return_value_fmt_with_locker$2;
  }
}

// str_hex
// file libslack/str.c line 6321
signed int str_hex(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=str_hex_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// str_hex_unlocked
// file libslack/str.c line 6350
signed int str_hex_unlocked(const struct String *str)
{
  signed int return_value_set_errno$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_hex$2;
    return_value_hex$2=hex(str->str);
    return return_value_hex$2;
  }
}

// str_insert
// file libslack/str.h line 93
struct String * str_insert(struct String *str, signed long int index, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert(str, index, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_insert_str
// file libslack/str.c line 1457
struct String * str_insert_str(struct String *str, signed long int index, const struct String *src)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int tmp_if_expr$10;
  signed int tmp_if_expr$9;
  signed int return_value_2;
  signed int tmp_if_expr$13;
  signed int tmp_if_expr$12;
  signed int return_value_3;
  void *return_value_set_errnull$11;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(src == ((const struct String *)NULL)))
    {
      if(!(src->locker == ((struct Locker *)NULL)))
      {
        return_value=src->locker->rdlock(src->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->wrlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      ret=str_insert_str_unlocked(str, index, src);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_2=str->locker->unlock(str->locker->lock);
          tmp_if_expr$9 = return_value_2;
        }

        else
          tmp_if_expr$9 = 0;
        tmp_if_expr$10 = tmp_if_expr$9;
      }

      else
        tmp_if_expr$10 = 22;
      err = tmp_if_expr$10;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$8;
        return_value_set_errnull$8=set_errnull(err);
        return (struct String *)return_value_set_errnull$8;
      }

      if(!(src == ((const struct String *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_3=src->locker->unlock(src->locker->lock);
          tmp_if_expr$12 = return_value_3;
        }

        else
          tmp_if_expr$12 = 0;
        tmp_if_expr$13 = tmp_if_expr$12;
      }

      else
        tmp_if_expr$13 = 22;
      err = tmp_if_expr$13;
      if(!(err == 0))
      {
        return_value_set_errnull$11=set_errnull(err);
        return (struct String *)return_value_set_errnull$11;
      }

      else
        return ret;
    }
  }
}

// str_insert_str_unlocked
// file libslack/str.c line 1501
struct String * str_insert_str_unlocked(struct String *str, signed long int index, const struct String *src)
{
  unsigned long int length;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct String *)return_value_set_errnull$2;
    }

    else
      if(!(str->length + 18446744073709551615ul >= (unsigned long int)index))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct String *)return_value_set_errnull$3;
      }

      else
      {
        length = src->length - (unsigned long int)1;
        signed int return_value_expand$4;
        return_value_expand$4=expand$link1(str, index, length);
        if(return_value_expand$4 == -1)
          return (struct String *)(void *)0;

        else
        {
          memcpy((void *)(str->str + index), (const void *)src->str, length);
          return str;
        }
      }
  }
}

// str_insert_unlocked
// file libslack/str.c line 1368
struct String * str_insert_unlocked(struct String *str, signed long int index, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert_unlocked(str, index, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_join
// file libslack/str.c line 4341
struct String * str_join(const struct List *list, const char *delim)
{
  struct String *return_value_str_join_with_locker$1;
  return_value_str_join_with_locker$1=str_join_with_locker((struct Locker *)(void *)0, list, delim);
  return return_value_str_join_with_locker$1;
}

// str_join_unlocked
// file libslack/str.c line 4356
struct String * str_join_unlocked(const struct List *list, const char *delim)
{
  struct String *return_value_str_join_with_locker_unlocked$1;
  return_value_str_join_with_locker_unlocked$1=str_join_with_locker_unlocked((struct Locker *)(void *)0, list, delim);
  return return_value_str_join_with_locker_unlocked$1;
}

// str_join_with_locker
// file libslack/str.c line 4372
struct String * str_join_with_locker(struct Locker *locker, const struct List *list, const char *delim)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    err=list_rdlock(list);
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_join_with_locker_unlocked(locker, list, delim);
      err=list_unlock(list);
      if(!(err == 0))
      {
        return_value_set_errnull$3=set_errnull(err);
        return (struct String *)return_value_set_errnull$3;
      }

      else
        return ret;
    }
  }
}

// str_join_with_locker_unlocked
// file libslack/str.c line 4402
struct String * str_join_with_locker_unlocked(struct Locker *locker, const struct List *list, const char *delim)
{
  struct String *ret;
  struct String *del;
  struct Lister *lister;
  signed int i;
  void *return_value_set_errnull$1;
  signed int return_value_lister_has_next$2;
  struct String *return_value_str_append_str$4;
  struct String *return_value_str_append_str$5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_create_with_locker(locker, (const char *)(void *)0);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      del=str_create(delim != ((const char *)NULL) ? "%s" : (char *)(void *)0, delim);
      if(del == ((struct String *)NULL))
      {
        str_release(ret);
        return (struct String *)(void *)0;
      }

      else
      {
        lister=lister_create_unlocked(list);
        if(lister == ((struct Lister *)NULL))
        {
          str_release(ret);
          str_release(del);
          return (struct String *)(void *)0;
        }

        else
        {
          i = 0;
          do
          {
            return_value_lister_has_next$2=lister_has_next(lister);
            if(!(return_value_lister_has_next$2 == 1))
              break;

            struct String *s;
            void *return_value_lister_next$3;
            return_value_lister_next$3=lister_next(lister);
            s = (struct String *)return_value_lister_next$3;
            if(!(i == 0))
            {
              return_value_str_append_str$4=str_append_str(ret, del);
              if(return_value_str_append_str$4 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release_unlocked(lister);
                return (struct String *)(void *)0;
              }

            }

            if(!(s == ((struct String *)NULL)))
            {
              return_value_str_append_str$5=str_append_str(ret, s);
              if(return_value_str_append_str$5 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release_unlocked(lister);
                return (struct String *)(void *)0;
              }

            }

            i = i + 1;
          }
          while((_Bool)1);
          str_release(del);
          lister_release_unlocked(lister);
          return ret;
        }
      }
    }
  }
}

// str_lc
// file libslack/str.c line 5757
struct String * str_lc(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_lc_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_lc_unlocked
// file libslack/str.c line 5786
struct String * str_lc_unlocked(struct String *str)
{
  unsigned long int i;
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_tolower_loc$3;
  const signed int **return_value___ctype_tolower_loc$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= str->length + 18446744073709551615ul); i = i + 1ul)
    {
      signed int __res;
      __res=tolower((signed int)(unsigned char)str->str[(signed long int)i]);
      tmp_statement_expression$2 = __res;
      str->str[(signed long int)i] = (char)tmp_statement_expression$2;
    }
    return str;
  }
}

// str_lcfirst
// file libslack/str.c line 5834
struct String * str_lcfirst(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_lcfirst_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_lcfirst_unlocked
// file libslack/str.c line 5863
struct String * str_lcfirst_unlocked(struct String *str)
{
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_tolower_loc$3;
  const signed int **return_value___ctype_tolower_loc$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(str->length >= 2ul)
    {
      signed int __res;
      __res=tolower((signed int)(unsigned char)*str->str);
      tmp_statement_expression$2 = __res;
      *str->str = (char)tmp_statement_expression$2;
    }

    return str;
  }
}

// str_length
// file libslack/str.h line 80
signed long int str_length(const struct String *str)
{
  unsigned long int length;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$8;
  signed int tmp_if_expr$7;
  signed int return_value_1;
  signed int return_value_set_errno$6;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      signed long int return_value_str_length_unlocked$5;
      return_value_str_length_unlocked$5=str_length_unlocked(str);
      length = (unsigned long int)return_value_str_length_unlocked$5;
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$7 = return_value_1;
        }

        else
          tmp_if_expr$7 = 0;
        tmp_if_expr$8 = tmp_if_expr$7;
      }

      else
        tmp_if_expr$8 = 22;
      err = tmp_if_expr$8;
      if(!(err == 0))
      {
        return_value_set_errno$6=set_errno(err);
        return (signed long int)return_value_set_errno$6;
      }

      else
        return (signed long int)length;
    }
  }
}

// str_length_unlocked
// file libslack/str.c line 1063
signed long int str_length_unlocked(const struct String *str)
{
  signed int return_value_set_errno$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
    return (signed long int)(str->length - (unsigned long int)1);
}

// str_oct
// file libslack/str.c line 6418
signed int str_oct(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=str_oct_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// str_oct_unlocked
// file libslack/str.c line 6447
signed int str_oct_unlocked(const struct String *str)
{
  signed int return_value_set_errno$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_oct$2;
    return_value_oct$2=oct(str->str);
    return return_value_oct$2;
  }
}

// str_prepend
// file libslack/str.c line 1644
struct String * str_prepend(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert(str, (signed long int)0, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_prepend_str
// file libslack/str.c line 1716
struct String * str_prepend_str(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str$1;
  return_value_str_insert_str$1=str_insert_str(str, (signed long int)0, src);
  return return_value_str_insert_str$1;
}

// str_prepend_str_unlocked
// file libslack/str.c line 1734
struct String * str_prepend_str_unlocked(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str_unlocked$1;
  return_value_str_insert_str_unlocked$1=str_insert_str_unlocked(str, (signed long int)0, src);
  return return_value_str_insert_str_unlocked$1;
}

// str_prepend_unlocked
// file libslack/str.c line 1664
struct String * str_prepend_unlocked(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert_unlocked(str, (signed long int)0, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_quote
// file libslack/str.c line 5023
struct String * str_quote(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_quote_with_locker$1;
  return_value_str_quote_with_locker$1=str_quote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_quote_with_locker$1;
}

// str_quote_unlocked
// file libslack/str.c line 5038
struct String * str_quote_unlocked(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_quote_with_locker_unlocked$1;
  return_value_str_quote_with_locker_unlocked$1=str_quote_with_locker_unlocked((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_quote_with_locker_unlocked$1;
}

// str_quote_with_locker
// file libslack/str.c line 5054
struct String * str_quote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  unsigned long int i;
  void *return_value_set_errnull$1;
  char *return_value___builtin_strchr$4;
  unsigned long int tmp_post$2;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_copy_with_locker(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= ret->length + 18446744073709551615ul); i = i + 1ul)
        if(!(ret->str[(signed long int)i] == 0))
        {
          return_value___builtin_strchr$4=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)i]);
          if(!(return_value___builtin_strchr$4 == ((char *)NULL)))
          {
            tmp_post$2 = i;
            i = i + 1ul;
            struct String *return_value_str_insert$3;
            return_value_str_insert$3=str_insert(ret, (signed long int)tmp_post$2, "%c", quote_char);
            if(return_value_str_insert$3 == ((struct String *)NULL))
            {
              str_release(ret);
              return (struct String *)(void *)0;
            }

          }

        }

      return ret;
    }
  }
}

// str_quote_with_locker_unlocked
// file libslack/str.c line 5090
struct String * str_quote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  unsigned long int i;
  void *return_value_set_errnull$1;
  char *return_value___builtin_strchr$4;
  unsigned long int tmp_post$2;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_copy_with_locker_unlocked(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= ret->length + 18446744073709551615ul); i = i + 1ul)
        if(!(ret->str[(signed long int)i] == 0))
        {
          return_value___builtin_strchr$4=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)i]);
          if(!(return_value___builtin_strchr$4 == ((char *)NULL)))
          {
            tmp_post$2 = i;
            i = i + 1ul;
            struct String *return_value_str_insert$3;
            return_value_str_insert$3=str_insert(ret, (signed long int)tmp_post$2, "%c", quote_char);
            if(return_value_str_insert$3 == ((struct String *)NULL))
            {
              str_release(ret);
              return (struct String *)(void *)0;
            }

          }

        }

      return ret;
    }
  }
}

// str_rdlock
// file libslack/str.c line 929
signed int str_rdlock(const struct String *str)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(str == ((const struct String *)NULL)))
  {
    if(!(str->locker == ((struct Locker *)NULL)))
    {
      return_value=str->locker->rdlock(str->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// str_recalc_length
// file libslack/str.c line 1161
signed long int str_recalc_length(struct String *str)
{
  signed long int len;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      len=str_recalc_length_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return (signed long int)return_value_set_errno$5;
      }

      else
        return len;
    }
  }
}

// str_recalc_length_unlocked
// file libslack/str.c line 1191
signed long int str_recalc_length_unlocked(struct String *str)
{
  signed int return_value_set_errno$1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str->str);
    str->length = return_value_strlen$2 + (unsigned long int)1;
    return (signed long int)(str->length - (unsigned long int)1);
  }
}

// str_regexpr
// file libslack/str.c line 3035
struct List * str_regexpr(const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_with_locker$1;
  return_value_str_regexpr_with_locker$1=str_regexpr_with_locker((struct Locker *)(void *)0, pattern, text, cflags, eflags);
  return return_value_str_regexpr_with_locker$1;
}

// str_regexpr_compiled
// file libslack/str.c line 3208
struct List * str_regexpr_compiled(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  struct List *return_value_str_regexpr_compiled_with_locker$1;
  return_value_str_regexpr_compiled_with_locker$1=str_regexpr_compiled_with_locker((struct Locker *)(void *)0, compiled, text, eflags);
  return return_value_str_regexpr_compiled_with_locker$1;
}

// str_regexpr_compiled_unlocked
// file libslack/str.c line 3224
struct List * str_regexpr_compiled_unlocked(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  struct List *return_value_str_regexpr_compiled_with_locker_unlocked$1;
  return_value_str_regexpr_compiled_with_locker_unlocked$1=str_regexpr_compiled_with_locker_unlocked((struct Locker *)(void *)0, compiled, text, eflags);
  return return_value_str_regexpr_compiled_with_locker_unlocked$1;
}

// str_regexpr_compiled_with_locker
// file libslack/str.c line 3240
struct List * str_regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(text == ((const struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(text == ((const struct String *)NULL)))
    {
      if(!(text->locker == ((struct Locker *)NULL)))
      {
        return_value=text->locker->rdlock(text->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_regexpr_compiled_with_locker_unlocked(locker, compiled, text, eflags);
      if(!(text == ((const struct String *)NULL)))
      {
        if(!(text->locker == ((struct Locker *)NULL)))
        {
          return_value_1=text->locker->unlock(text->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_regexpr_compiled_with_locker_unlocked
// file libslack/str.c line 3273
struct List * str_regexpr_compiled_with_locker_unlocked(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  void *return_value_set_errnull$1;
  if(text == ((const struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    struct List *return_value_regexpr_compiled_with_locker$2;
    return_value_regexpr_compiled_with_locker$2=regexpr_compiled_with_locker(locker, compiled, text->str, eflags);
    return return_value_regexpr_compiled_with_locker$2;
  }
}

// str_regexpr_split
// file libslack/str.c line 4154
struct List * str_regexpr_split(const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_split_with_locker$1;
  return_value_str_regexpr_split_with_locker$1=str_regexpr_split_with_locker((struct Locker *)(void *)0, str, delim, cflags, eflags);
  return return_value_str_regexpr_split_with_locker$1;
}

// str_regexpr_split_unlocked
// file libslack/str.c line 4169
struct List * str_regexpr_split_unlocked(const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_split_with_locker_unlocked$1;
  return_value_str_regexpr_split_with_locker_unlocked$1=str_regexpr_split_with_locker_unlocked((struct Locker *)(void *)0, str, delim, cflags, eflags);
  return return_value_str_regexpr_split_with_locker_unlocked$1;
}

// str_regexpr_split_with_locker
// file libslack/str.c line 4185
struct List * str_regexpr_split_with_locker(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_regexpr_split_with_locker_unlocked(locker, str, delim, cflags, eflags);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_regexpr_split_with_locker_unlocked
// file libslack/str.c line 4218
struct List * str_regexpr_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  void *return_value_set_errnull$1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    struct List *return_value_regexpr_split_with_locker$2;
    return_value_regexpr_split_with_locker$2=regexpr_split_with_locker(locker, str->str, delim, cflags, eflags);
    return return_value_regexpr_split_with_locker$2;
  }
}

// str_regexpr_unlocked
// file libslack/str.c line 3050
struct List * str_regexpr_unlocked(const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_with_locker_unlocked$1;
  return_value_str_regexpr_with_locker_unlocked$1=str_regexpr_with_locker_unlocked((struct Locker *)(void *)0, pattern, text, cflags, eflags);
  return return_value_str_regexpr_with_locker_unlocked$1;
}

// str_regexpr_with_locker
// file libslack/str.c line 3066
struct List * str_regexpr_with_locker(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(pattern == ((const char *)NULL) || text == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(text == ((const struct String *)NULL)))
    {
      if(!(text->locker == ((struct Locker *)NULL)))
      {
        return_value=text->locker->rdlock(text->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_regexpr_with_locker_unlocked(locker, pattern, text, cflags, eflags);
      if(!(text == ((const struct String *)NULL)))
      {
        if(!(text->locker == ((struct Locker *)NULL)))
        {
          return_value_1=text->locker->unlock(text->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_regexpr_with_locker_unlocked
// file libslack/str.c line 3099
struct List * str_regexpr_with_locker_unlocked(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  void *return_value_set_errnull$1;
  if(pattern == ((const char *)NULL) || text == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    struct List *return_value_regexpr_with_locker$2;
    return_value_regexpr_with_locker$2=regexpr_with_locker(locker, pattern, text->str, cflags, eflags);
    return return_value_regexpr_with_locker$2;
  }
}

// str_regsub
// file libslack/str.c line 3382
struct String * str_regsub(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all)
{
  struct re_pattern_buffer compiled[1l];
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(pattern == ((const char *)NULL) || replacement == ((const char *)NULL) || text == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    err=regexpr_compile(compiled, pattern, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_regsub_compiled(compiled, replacement, text, eflags, all);
      regfree(compiled);
      return ret;
    }
  }
}

// str_regsub_compiled
// file libslack/str.c line 3439
struct String * str_regsub_compiled(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(replacement == ((const char *)NULL) || text == ((struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(text == ((struct String *)NULL)))
    {
      if(!(text->locker == ((struct Locker *)NULL)))
      {
        return_value=text->locker->wrlock(text->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_regsub_compiled_unlocked(compiled, replacement, text, eflags, all);
      if(!(text == ((struct String *)NULL)))
      {
        if(!(text->locker == ((struct Locker *)NULL)))
        {
          return_value_1=text->locker->unlock(text->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_regsub_compiled_unlocked
// file libslack/str.c line 3469
struct String * str_regsub_compiled_unlocked(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all)
{
  struct anonymous$7 match[33l];
  struct String *rep;
  signed int matches;
  unsigned long int start;
  signed int states[33l];
  signed int i;
  signed int s;
  void *return_value_set_errnull$1;
  const unsigned short int **return_value___ctype_b_loc$4;
  const unsigned short int **return_value___ctype_b_loc$7;
  _Bool tmp_if_expr$9;
  struct String *return_value_str_remove$30;
  signed int tmp_statement_expression$31;
  signed int tmp_if_expr$33;
  const signed int **return_value___ctype_tolower_loc$32;
  const signed int **return_value___ctype_tolower_loc$34;
  signed int tmp_statement_expression$35;
  signed int tmp_if_expr$37;
  const signed int **return_value___ctype_toupper_loc$36;
  const signed int **return_value___ctype_toupper_loc$38;
  const unsigned short int **return_value___ctype_b_loc$42;
  signed int tmp_post$40;
  struct String *return_value_str_insert$41;
  if(replacement == ((const char *)NULL) || text == ((struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    start = (unsigned long int)0;
    matches = 0;
    for( ; text->length + 18446744073709551615ul >= start; matches = matches + 1)
    {
      signed int return_value_regexec$2;
      return_value_regexec$2=regexec(compiled, text->str + (signed long int)start, (unsigned long int)33, match, eflags);
      if(!(return_value_regexec$2 == 0))
        return matches != 0 ? text : (struct String *)(void *)0;

      rep=str_create("%s", replacement);
      if(rep == ((struct String *)NULL))
        return (struct String *)(void *)0;

      i = 0;
      for( ; !((unsigned long int)i >= rep->length + 18446744073709551615ul); i = i + 1)
        if((signed int)rep->str[(signed long int)i] == 36)
        {
          if((signed int)rep->str[(signed long int)(1 + i)] == 36)
          {
            struct String *return_value_str_remove$3;
            return_value_str_remove$3=str_remove(rep, (signed long int)i);
            if(return_value_str_remove$3 == ((struct String *)NULL))
            {
              str_release(rep);
              return (struct String *)(void *)0;
            }

          }

          else
          {
            signed int ref;
            signed int j = i + 1;
            if((signed int)rep->str[(signed long int)j] == 123)
            {
              j = j + 1;
              ref = 0;
              do
              {
                return_value___ctype_b_loc$4=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)rep->str[(signed long int)j]]) == 0)
                  break;

                ref = ref * 10;
                ref = ref + ((signed int)rep->str[(signed long int)j] - 48);
                j = j + 1;
              }
              while((_Bool)1);
              if(!((signed int)rep->str[(signed long int)j] == 125))
              {
                str_release(rep);
                void *return_value_set_errnull$5;
                return_value_set_errnull$5=set_errnull(22);
                return (struct String *)return_value_set_errnull$5;
              }

            }

            else
            {
              return_value___ctype_b_loc$7=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)(unsigned char)rep->str[(signed long int)(1 + i)]]) == 0))
                ref = (signed int)rep->str[(signed long int)j] - 48;

              else
              {
                str_release(rep);
                void *return_value_set_errnull$6;
                return_value_set_errnull$6=set_errnull(22);
                return (struct String *)return_value_set_errnull$6;
              }
            }
            if(ref >= 33 || !(ref >= 0))
              tmp_if_expr$9 = (_Bool)1;

            else
              tmp_if_expr$9 = match[(signed long int)ref].rm_so == -1 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$9)
            {
              str_release(rep);
              void *return_value_set_errnull$8;
              return_value_set_errnull$8=set_errnull(22);
              return (struct String *)return_value_set_errnull$8;
            }

            struct String *return_value_str_replace$10;
            return_value_str_replace$10=str_replace(rep, (signed long int)i, (signed long int)((j + 1) - i), "%.*s", (signed int)(match[(signed long int)ref].rm_eo - match[(signed long int)ref].rm_so), text->str + (signed long int)match[(signed long int)ref].rm_so);
            if(return_value_str_replace$10 == ((struct String *)NULL))
            {
              str_release(rep);
              return (struct String *)(void *)0;
            }

            i = i + ((match[(signed long int)ref].rm_eo - match[(signed long int)ref].rm_so) - 1);
          }
        }

      s = 0;
      states[(signed long int)s] = 0;
      i = 0;
      for( ; !((unsigned long int)i >= rep->length + 18446744073709551615ul); i = i + 1)
        if((signed int)rep->str[(signed long int)i] == 92)
          switch((signed int)rep->str[(signed long int)(i + 1)])
          {
            case 108:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull$11;
                return_value_set_errnull$11=set_errnull(22);
                return (struct String *)return_value_set_errnull$11;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 9;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~2;
              struct String *return_value_str_remove_range$13;
              return_value_str_remove_range$13=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range$13 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$12;
                return_value_set_errnull$12=set_errnull(22);
                return (struct String *)return_value_set_errnull$12;
              }

              i = i - 1;
              break;
            }
            case 76:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull$14;
                return_value_set_errnull$14=set_errnull(22);
                return (struct String *)return_value_set_errnull$14;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 1;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~2;
              struct String *return_value_str_remove_range$16;
              return_value_str_remove_range$16=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range$16 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$15;
                return_value_set_errnull$15=set_errnull(22);
                return (struct String *)return_value_set_errnull$15;
              }

              i = i - 1;
              break;
            }
            case 117:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull$17;
                return_value_set_errnull$17=set_errnull(22);
                return (struct String *)return_value_set_errnull$17;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 10;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~1;
              struct String *return_value_str_remove_range$19;
              return_value_str_remove_range$19=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range$19 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$18;
                return_value_set_errnull$18=set_errnull(22);
                return (struct String *)return_value_set_errnull$18;
              }

              i = i - 1;
              break;
            }
            case 85:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull$20;
                return_value_set_errnull$20=set_errnull(22);
                return (struct String *)return_value_set_errnull$20;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 2;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~1;
              struct String *return_value_str_remove_range$22;
              return_value_str_remove_range$22=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range$22 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$21;
                return_value_set_errnull$21=set_errnull(22);
                return (struct String *)return_value_set_errnull$21;
              }

              i = i - 1;
              break;
            }
            case 81:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull$23;
                return_value_set_errnull$23=set_errnull(22);
                return (struct String *)return_value_set_errnull$23;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 4;
              s = s + 1;
              struct String *return_value_str_remove_range$25;
              return_value_str_remove_range$25=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range$25 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$24;
                return_value_set_errnull$24=set_errnull(22);
                return (struct String *)return_value_set_errnull$24;
              }

              i = i - 1;
              break;
            }
            case 69:
            {
              if(s == 0)
              {
                str_release(rep);
                void *return_value_set_errnull$26;
                return_value_set_errnull$26=set_errnull(22);
                return (struct String *)return_value_set_errnull$26;
              }

              s = s - 1;
              struct String *return_value_str_remove_range$28;
              return_value_str_remove_range$28=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range$28 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$27;
                return_value_set_errnull$27=set_errnull(22);
                return (struct String *)return_value_set_errnull$27;
              }

              i = i - 1;
              break;
            }
            case 92:
            {
              return_value_str_remove$30=str_remove(rep, (signed long int)i);
              if(return_value_str_remove$30 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$29;
                return_value_set_errnull$29=set_errnull(22);
                return (struct String *)return_value_set_errnull$29;
              }

            }
          }

        else
        {
          if(!((1 & states[(signed long int)s]) == 0))
          {
            signed int __res;
            __res=tolower((signed int)(unsigned char)rep->str[(signed long int)i]);
            tmp_statement_expression$31 = __res;
            rep->str[(signed long int)i] = (char)tmp_statement_expression$31;
          }

          if(!((2 & states[(signed long int)s]) == 0))
          {
            signed int str_regsub_compiled_unlocked$$1$$1$$1$$2$$1$$2$$2$$__res;
            str_regsub_compiled_unlocked$$1$$1$$1$$2$$1$$2$$2$$__res=toupper((signed int)(unsigned char)rep->str[(signed long int)i]);
            tmp_statement_expression$35 = str_regsub_compiled_unlocked$$1$$1$$1$$2$$1$$2$$2$$__res;
            rep->str[(signed long int)i] = (char)tmp_statement_expression$35;
          }

          if(!((4 & states[(signed long int)s]) == 0))
          {
            return_value___ctype_b_loc$42=__ctype_b_loc();
            if((8 & (signed int)(*return_value___ctype_b_loc$42)[(signed long int)(signed int)(unsigned char)rep->str[(signed long int)i]]) == 0)
            {
              tmp_post$40 = i;
              i = i + 1;
              return_value_str_insert$41=str_insert(rep, (signed long int)tmp_post$40, "\\");
              if(return_value_str_insert$41 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull$39;
                return_value_set_errnull$39=set_errnull(22);
                return (struct String *)return_value_set_errnull$39;
              }

            }

          }

          if(!((8 & states[(signed long int)s]) == 0))
          {
            if(s == 0)
            {
              str_release(rep);
              void *return_value_set_errnull$43;
              return_value_set_errnull$43=set_errnull(22);
              return (struct String *)return_value_set_errnull$43;
            }

            s = s - 1;
          }

        }
      struct String *return_value_str_replace_str_unlocked$44;
      return_value_str_replace_str_unlocked$44=str_replace_str_unlocked(text, (signed long int)(start + (unsigned long int)match[(signed long int)0].rm_so), (signed long int)(match[(signed long int)0].rm_eo - match[(signed long int)0].rm_so), rep);
      if(return_value_str_replace_str_unlocked$44 == ((struct String *)NULL))
      {
        str_release(rep);
        return (struct String *)(void *)0;
      }

      if(match[0l].rm_so == 0)
      {
        if(match[0l].rm_eo == 0)
        {
          match[(signed long int)0].rm_so = match[(signed long int)0].rm_so + 1;
          match[(signed long int)0].rm_eo = match[(signed long int)0].rm_eo + 1;
        }

      }

      start = start + (((unsigned long int)match[(signed long int)0].rm_so + rep->length) - (unsigned long int)1);
      str_release(rep);
      if(all == 0)
        break;

    }
    return text;
  }
}

// str_regsub_unlocked
// file libslack/str.c line 3410
struct String * str_regsub_unlocked(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all)
{
  struct re_pattern_buffer compiled[1l];
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  if(pattern == ((const char *)NULL) || replacement == ((const char *)NULL) || text == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    err=regexpr_compile(compiled, pattern, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_regsub_compiled_unlocked(compiled, replacement, text, eflags, all);
      regfree(compiled);
      return ret;
    }
  }
}

// str_release
// file libslack/str.h line 73
void str_release(struct String *str)
{
  struct Locker *str_release$$1$$locker;
  if(!(str == ((struct String *)NULL)))
  {
    signed int return_value_str_wrlock$1;
    return_value_str_wrlock$1=str_wrlock(str);
    if(return_value_str_wrlock$1 == 0)
    {
      str_release$$1$$locker = str->locker;
      free((void *)str->str);
      free((void *)str);
      if(!(str_release$$1$$locker == ((struct Locker *)NULL)))
        str_release$$1$$locker->unlock(str_release$$1$$locker->lock);

      else
        0;
    }

  }

}

// str_remove
// file libslack/str.c line 1246
struct String * str_remove(struct String *str, signed long int index)
{
  struct String *return_value_str_remove_range$1;
  return_value_str_remove_range$1=str_remove_range(str, index, (signed long int)1);
  return return_value_str_remove_range$1;
}

// str_remove_range
// file libslack/str.c line 1280
struct String * str_remove_range(struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_remove_range_unlocked(str, index, range);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_remove_range_unlocked
// file libslack/str.c line 1309
struct String * str_remove_range_unlocked(struct String *str, signed long int index, signed long int range)
{
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  void *return_value_set_errnull$4;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((str->length + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct String *)return_value_set_errnull$3;
      }

      else
        if(!(str->length + 18446744073709551615ul >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull$4=set_errnull(22);
          return (struct String *)return_value_set_errnull$4;
        }

        else
        {
          contract$link1(str, index, (unsigned long int)range);
          return str;
        }
    }
  }
}

// str_remove_unlocked
// file libslack/str.c line 1261
struct String * str_remove_unlocked(struct String *str, signed long int index)
{
  struct String *return_value_str_remove_range_unlocked$1;
  return_value_str_remove_range_unlocked$1=str_remove_range_unlocked(str, index, (signed long int)1);
  return return_value_str_remove_range_unlocked$1;
}

// str_repeat
// file libslack/str.c line 2211
struct String * str_repeat(unsigned long int count, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vrepeat_with_locker((struct Locker *)(void *)0, count, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_repeat_with_locker
// file libslack/str.c line 2232
struct String * str_repeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vrepeat_with_locker(locker, count, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_replace
// file libslack/str.c line 1754
struct String * str_replace(struct String *str, signed long int index, signed long int range, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vreplace(str, index, range, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_replace_str
// file libslack/str.c line 1852
struct String * str_replace_str(struct String *str, signed long int index, signed long int range, const struct String *src)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int tmp_if_expr$10;
  signed int tmp_if_expr$9;
  signed int return_value_2;
  signed int tmp_if_expr$13;
  signed int tmp_if_expr$12;
  signed int return_value_3;
  void *return_value_set_errnull$11;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(src == ((const struct String *)NULL)))
    {
      if(!(src->locker == ((struct Locker *)NULL)))
      {
        return_value=src->locker->rdlock(src->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->wrlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      ret=str_replace_str_unlocked(str, index, range, src);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_2=str->locker->unlock(str->locker->lock);
          tmp_if_expr$9 = return_value_2;
        }

        else
          tmp_if_expr$9 = 0;
        tmp_if_expr$10 = tmp_if_expr$9;
      }

      else
        tmp_if_expr$10 = 22;
      err = tmp_if_expr$10;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull$8;
        return_value_set_errnull$8=set_errnull(err);
        return (struct String *)return_value_set_errnull$8;
      }

      if(!(src == ((const struct String *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_3=src->locker->unlock(src->locker->lock);
          tmp_if_expr$12 = return_value_3;
        }

        else
          tmp_if_expr$12 = 0;
        tmp_if_expr$13 = tmp_if_expr$12;
      }

      else
        tmp_if_expr$13 = 22;
      err = tmp_if_expr$13;
      if(!(err == 0))
      {
        return_value_set_errnull$11=set_errnull(err);
        return (struct String *)return_value_set_errnull$11;
      }

      else
        return ret;
    }
  }
}

// str_replace_str_unlocked
// file libslack/str.c line 1896
struct String * str_replace_str_unlocked(struct String *str, signed long int index, signed long int range, const struct String *src)
{
  unsigned long int length;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  void *return_value_set_errnull$4;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((str->length + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct String *)return_value_set_errnull$3;
      }

      else
        if(!(str->length + 18446744073709551615ul >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull$4=set_errnull(22);
          return (struct String *)return_value_set_errnull$4;
        }

        else
        {
          length = src->length - (unsigned long int)1;
          signed int return_value_adjust$5;
          return_value_adjust$5=adjust$link1(str, index, (unsigned long int)range, length);
          if(return_value_adjust$5 == -1)
            return (struct String *)(void *)0;

          else
          {
            memcpy((void *)(str->str + index), (const void *)src->str, length);
            return str;
          }
        }
    }
  }
}

// str_replace_unlocked
// file libslack/str.c line 1774
struct String * str_replace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vreplace_unlocked(str, index, range, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_set_length
// file libslack/str.c line 1107
signed long int str_set_length(struct String *str, unsigned long int length)
{
  signed long int len;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return (signed long int)return_value_set_errno$2;
    }

    else
    {
      len=str_set_length_unlocked(str, length);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return (signed long int)return_value_set_errno$5;
      }

      else
        return len;
    }
  }
}

// str_set_length_unlocked
// file libslack/str.c line 1136
signed long int str_set_length_unlocked(struct String *str, unsigned long int length)
{
  _Bool tmp_if_expr$2;
  if(str == ((struct String *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = length >= str->length ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno$1;
  if(tmp_if_expr$2)
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    str->length = length + (unsigned long int)1;
    str->str[(signed long int)(str->length - (unsigned long int)1)] = (char)0;
    return (signed long int)(str->length - (unsigned long int)1);
  }
}

// str_soundex
// file libslack/str.c line 4545
signed int str_soundex(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  signed int return_value_set_errno$5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=str_soundex_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errno$5=set_errno(err);
        return return_value_set_errno$5;
      }

      else
        return ret;
    }
  }
}

// str_soundex_unlocked
// file libslack/str.c line 4574
signed int str_soundex_unlocked(const struct String *str)
{
  signed int return_value_set_errno$1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_soundex$2;
    return_value_soundex$2=soundex(str->str);
    return return_value_soundex$2;
  }
}

// str_splice
// file libslack/str.c line 2114
struct String * str_splice(struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_splice_with_locker$1;
  return_value_str_splice_with_locker$1=str_splice_with_locker((struct Locker *)(void *)0, str, index, range);
  return return_value_str_splice_with_locker$1;
}

// str_splice_unlocked
// file libslack/str.c line 2129
struct String * str_splice_unlocked(struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_splice_with_locker_unlocked$1;
  return_value_str_splice_with_locker_unlocked$1=str_splice_with_locker_unlocked((struct Locker *)(void *)0, str, index, range);
  return return_value_str_splice_with_locker_unlocked$1;
}

// str_splice_with_locker
// file libslack/str.c line 2145
struct String * str_splice_with_locker(struct Locker *locker, struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_splice_with_locker_unlocked(locker, str, index, range);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        str_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_splice_with_locker_unlocked
// file libslack/str.c line 2178
struct String * str_splice_with_locker_unlocked(struct Locker *locker, struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  void *return_value_set_errnull$1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_substr_with_locker_unlocked(locker, str, index, range);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      struct String *return_value_str_remove_range_unlocked$2;
      return_value_str_remove_range_unlocked$2=str_remove_range_unlocked(str, index, range);
      if(return_value_str_remove_range_unlocked$2 == ((struct String *)NULL))
      {
        str_release(ret);
        return (struct String *)(void *)0;
      }

      else
        return ret;
    }
  }
}

// str_split
// file libslack/str.c line 4030
struct List * str_split(const struct String *str, const char *delim)
{
  struct List *return_value_str_split_with_locker$1;
  return_value_str_split_with_locker$1=str_split_with_locker((struct Locker *)(void *)0, str, delim);
  return return_value_str_split_with_locker$1;
}

// str_split_unlocked
// file libslack/str.c line 4045
struct List * str_split_unlocked(const struct String *str, const char *delim)
{
  struct List *return_value_str_split_with_locker_unlocked$1;
  return_value_str_split_with_locker_unlocked$1=str_split_with_locker_unlocked((struct Locker *)(void *)0, str, delim);
  return return_value_str_split_with_locker_unlocked$1;
}

// str_split_with_locker
// file libslack/str.c line 4061
struct List * str_split_with_locker(struct Locker *locker, const struct String *str, const char *delim)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct List *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_split_with_locker_unlocked(locker, str, delim);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull$5;
        return_value_set_errnull$5=set_errnull(err);
        return (struct List *)return_value_set_errnull$5;
      }

      return ret;
    }
  }
}

// str_split_with_locker_unlocked
// file libslack/str.c line 4094
struct List * str_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim)
{
  void *return_value_set_errnull$1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct List *)return_value_set_errnull$1;
  }

  else
  {
    struct List *return_value_do_split_with_locker$2;
    return_value_do_split_with_locker$2=do_split_with_locker(locker, str->str, (signed long int)(str->length - (unsigned long int)1), delim);
    return return_value_do_split_with_locker$2;
  }
}

// str_squeeze
// file libslack/str.c line 4914
struct String * str_squeeze(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_squeeze_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_squeeze_unlocked
// file libslack/str.c line 4943
struct String * str_squeeze_unlocked(struct String *str)
{
  char *s;
  char *r;
  signed int started = 0;
  signed int was_space = 0;
  void *return_value_set_errnull$1;
  char *tmp_post$2;
  char *tmp_post$3;
  struct String *return_value_str_remove_range_unlocked$6;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    s = str->str;
    r = s;
    for( ; !((unsigned long int)(s - str->str) >= str->length + 18446744073709551615ul); s = s + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc$4;
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)*s]) == 0)
      {
        if(!(started == 0) && !(was_space == 0))
        {
          tmp_post$2 = r;
          r = r + 1l;
          *tmp_post$2 = (char)32;
        }

        tmp_post$3 = r;
        r = r + 1l;
        *tmp_post$3 = *s;
        started = 1;
      }

      const unsigned short int **return_value___ctype_b_loc$5;
      return_value___ctype_b_loc$5=__ctype_b_loc();
      was_space = (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192;
    }
    if(!((unsigned long int)(r - str->str) >= str->length))
    {
      return_value_str_remove_range_unlocked$6=str_remove_range_unlocked(str, r - str->str, (signed long int)((str->length - (unsigned long int)1) - (unsigned long int)(r - str->str)));
      if(!(return_value_str_remove_range_unlocked$6 == ((struct String *)NULL)))
        goto __CPROVER_DUMP_L6;

      return (struct String *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      return str;
    }
  }
}

// str_substr
// file libslack/str.c line 1945
struct String * str_substr(const struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_substr_with_locker$1;
  return_value_str_substr_with_locker$1=str_substr_with_locker((struct Locker *)(void *)0, str, index, range);
  return return_value_str_substr_with_locker$1;
}

// str_substr_unlocked
// file libslack/str.c line 1960
struct String * str_substr_unlocked(const struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_substr_with_locker_unlocked$1;
  return_value_str_substr_with_locker_unlocked$1=str_substr_with_locker_unlocked((struct Locker *)(void *)0, str, index, range);
  return return_value_str_substr_with_locker_unlocked$1;
}

// str_substr_with_locker
// file libslack/str.c line 1976
struct String * str_substr_with_locker(struct Locker *locker, const struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_substr_with_locker_unlocked(locker, str, index, range);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_substr_with_locker_unlocked
// file libslack/str.c line 2006
struct String * str_substr_with_locker_unlocked(struct Locker *locker, const struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  void *return_value_set_errnull$4;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((str->length + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct String *)return_value_set_errnull$3;
      }

      else
        if(!(str->length + 18446744073709551615ul >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull$4=set_errnull(22);
          return (struct String *)return_value_set_errnull$4;
        }

        else
        {
          ret=str_create_with_locker_sized(locker, (unsigned long int)(range + (signed long int)1), (const char *)(void *)0);
          if(ret == ((struct String *)NULL))
            return (struct String *)(void *)0;

          else
          {
            memcpy((void *)ret->str, (const void *)(str->str + index), (unsigned long int)range);
            ret->length = (unsigned long int)(range + (signed long int)1);
            ret->str[(signed long int)(ret->length - (unsigned long int)1)] = (char)0;
            return ret;
          }
        }
    }
  }
}

// str_tr
// file libslack/str.c line 2371
signed int str_tr(struct String *str, const char *from, const char *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno$1;
  if(from == ((const char *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_tr_compile_table$2;
    return_value_tr_compile_table$2=tr_compile_table(table, from, to, option);
    if(return_value_tr_compile_table$2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled$3;
      return_value_str_tr_compiled$3=str_tr_compiled(str, table);
      return return_value_str_tr_compiled$3;
    }
  }
}

// str_tr_compile
// file libslack/str.c line 2549
struct StringTR * str_tr_compile(const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *return_value_str_tr_compile_with_locker$1;
  return_value_str_tr_compile_with_locker$1=str_tr_compile_with_locker((struct Locker *)(void *)0, from, to, option);
  return return_value_str_tr_compile_with_locker$1;
}

// str_tr_compile_table
// file libslack/str.c line 2808
static struct StringTR * str_tr_compile_table(struct StringTR *table, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *ret;
  signed int err;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(from == ((const struct String *)NULL)))
  {
    if(!(from->locker == ((struct Locker *)NULL)))
    {
      return_value=from->locker->rdlock(from->locker->lock);
      tmp_if_expr$2 = return_value;
    }

    else
      tmp_if_expr$2 = 0;
    tmp_if_expr$3 = tmp_if_expr$2;
  }

  else
    tmp_if_expr$3 = 22;
  err = tmp_if_expr$3;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int tmp_if_expr$9;
  signed int tmp_if_expr$8;
  signed int return_value_2;
  signed int tmp_if_expr$12;
  signed int tmp_if_expr$11;
  signed int return_value_3;
  void *return_value_set_errnull$10;
  if(!(err == 0))
  {
    return_value_set_errnull$1=set_errnull(err);
    return (struct StringTR *)return_value_set_errnull$1;
  }

  else
  {
    if(!(to == ((const struct String *)NULL)))
    {
      if(!(to->locker == ((struct Locker *)NULL)))
      {
        return_value_1=to->locker->rdlock(to->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      tmp_if_expr$6 = tmp_if_expr$5;
    }

    else
      tmp_if_expr$6 = 22;
    err = tmp_if_expr$6;
    if(!(err == 0))
    {
      if(!(from == ((const struct String *)NULL)))
      {
        if(!(from->locker == ((struct Locker *)NULL)))
          from->locker->unlock(from->locker->lock);

        else
          0;
      }

      else
        22;
      void *return_value_set_errnull$4;
      return_value_set_errnull$4=set_errnull(err);
      return (struct StringTR *)return_value_set_errnull$4;
    }

    ret=str_tr_compile_table_unlocked(table, from, to, option);
    if(!(from == ((const struct String *)NULL)))
    {
      if(!(from->locker == ((struct Locker *)NULL)))
      {
        return_value_2=from->locker->unlock(from->locker->lock);
        tmp_if_expr$8 = return_value_2;
      }

      else
        tmp_if_expr$8 = 0;
      tmp_if_expr$9 = tmp_if_expr$8;
    }

    else
      tmp_if_expr$9 = 22;
    err = tmp_if_expr$9;
    if(!(err == 0))
    {
      if(!(to == ((const struct String *)NULL)))
      {
        if(!(to->locker == ((struct Locker *)NULL)))
          to->locker->unlock(to->locker->lock);

        else
          0;
      }

      else
        22;
      void *return_value_set_errnull$7;
      return_value_set_errnull$7=set_errnull(err);
      return (struct StringTR *)return_value_set_errnull$7;
    }

    if(!(to == ((const struct String *)NULL)))
    {
      if(!(to->locker == ((struct Locker *)NULL)))
      {
        return_value_3=to->locker->unlock(to->locker->lock);
        tmp_if_expr$11 = return_value_3;
      }

      else
        tmp_if_expr$11 = 0;
      tmp_if_expr$12 = tmp_if_expr$11;
    }

    else
      tmp_if_expr$12 = 22;
    err = tmp_if_expr$12;
    if(!(err == 0))
    {
      return_value_set_errnull$10=set_errnull(err);
      return (struct StringTR *)return_value_set_errnull$10;
    }

    else
      return ret;
  }
}

// str_tr_compile_table_unlocked
// file libslack/str.c line 2845
static struct StringTR * str_tr_compile_table_unlocked(struct StringTR *table, const struct String *from, const struct String *to, signed int option)
{
  signed long int return_value_str_length_unlocked$1;
  return_value_str_length_unlocked$1=str_length_unlocked(from);
  signed long int return_value_str_length_unlocked$2;
  return_value_str_length_unlocked$2=str_length_unlocked(to);
  struct StringTR *return_value_do_tr_compile_table$3;
  return_value_do_tr_compile_table$3=do_tr_compile_table(table, from->str, return_value_str_length_unlocked$1, to->str, return_value_str_length_unlocked$2, option);
  return return_value_do_tr_compile_table$3;
}

// str_tr_compile_unlocked
// file libslack/str.c line 2565
struct StringTR * str_tr_compile_unlocked(const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *return_value_str_tr_compile_with_locker_unlocked$1;
  return_value_str_tr_compile_with_locker_unlocked$1=str_tr_compile_with_locker_unlocked((struct Locker *)(void *)0, from, to, option);
  return return_value_str_tr_compile_with_locker_unlocked$1;
}

// str_tr_compile_with_locker
// file libslack/str.c line 2581
struct StringTR * str_tr_compile_with_locker(struct Locker *locker, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct StringTR) /*528ul*/ );
  ret = (struct StringTR *)return_value_malloc$1;
  if(ret == ((struct StringTR *)NULL))
    return (struct StringTR *)(void *)0;

  else
  {
    ret->locker = locker;
    struct StringTR *return_value_str_tr_compile_table$2;
    return_value_str_tr_compile_table$2=str_tr_compile_table(ret, from, to, option);
    return return_value_str_tr_compile_table$2;
  }
}

// str_tr_compile_with_locker_unlocked
// file libslack/str.c line 2606
struct StringTR * str_tr_compile_with_locker_unlocked(struct Locker *locker, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct StringTR) /*528ul*/ );
  ret = (struct StringTR *)return_value_malloc$1;
  if(ret == ((struct StringTR *)NULL))
    return (struct StringTR *)(void *)0;

  else
  {
    ret->locker = locker;
    struct StringTR *return_value_str_tr_compile_table_unlocked$2;
    return_value_str_tr_compile_table_unlocked$2=str_tr_compile_table_unlocked(ret, from, to, option);
    return return_value_str_tr_compile_table_unlocked$2;
  }
}

// str_tr_compiled
// file libslack/str.c line 2930
signed int str_tr_compiled(struct String *str, struct StringTR *table)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int tmp_if_expr$9;
  signed int tmp_if_expr$8;
  signed int return_value_2;
  signed int tmp_if_expr$11;
  signed int return_value_3;
  signed int return_value_set_errno$10;
  if(str == ((struct String *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(table->locker == ((struct Locker *)NULL)))
    {
      return_value=table->locker->rdlock(table->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->wrlock(str->locker->lock);
          tmp_if_expr$5 = return_value_1;
        }

        else
          tmp_if_expr$5 = 0;
        tmp_if_expr$6 = tmp_if_expr$5;
      }

      else
        tmp_if_expr$6 = 22;
      err = tmp_if_expr$6;
      if(!(err == 0))
      {
        if(!(table->locker == ((struct Locker *)NULL)))
          table->locker->unlock(table->locker->lock);

        else
          0;
        signed int return_value_set_errno$4;
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      ret=str_tr_compiled_unlocked(str, table);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_2=str->locker->unlock(str->locker->lock);
          tmp_if_expr$8 = return_value_2;
        }

        else
          tmp_if_expr$8 = 0;
        tmp_if_expr$9 = tmp_if_expr$8;
      }

      else
        tmp_if_expr$9 = 22;
      err = tmp_if_expr$9;
      if(!(err == 0))
      {
        if(!(table->locker == ((struct Locker *)NULL)))
          table->locker->unlock(table->locker->lock);

        else
          0;
        signed int return_value_set_errno$7;
        return_value_set_errno$7=set_errno(err);
        return return_value_set_errno$7;
      }

      if(!(table->locker == ((struct Locker *)NULL)))
      {
        return_value_3=table->locker->unlock(table->locker->lock);
        tmp_if_expr$11 = return_value_3;
      }

      else
        tmp_if_expr$11 = 0;
      err = tmp_if_expr$11;
      if(!(err == 0))
      {
        return_value_set_errno$10=set_errno(err);
        return return_value_set_errno$10;
      }

      else
        return ret;
    }
  }
}

// str_tr_compiled_unlocked
// file libslack/str.c line 2971
signed int str_tr_compiled_unlocked(struct String *str, struct StringTR *table)
{
  signed int return_value_set_errno$1;
  if(str == ((struct String *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    signed int return_value_do_tr_compiled$2;
    return_value_do_tr_compiled$2=do_tr_compiled((unsigned char *)str->str, &str->length, table);
    return return_value_do_tr_compiled$2;
  }
}

// str_tr_str
// file libslack/str.c line 2425
signed int str_tr_str(struct String *str, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno$1;
  if(from == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_str_tr_compile_table$2;
    return_value_str_tr_compile_table$2=str_tr_compile_table(table, from, to, option);
    if(return_value_str_tr_compile_table$2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled$3;
      return_value_str_tr_compiled$3=str_tr_compiled(str, table);
      return return_value_str_tr_compiled$3;
    }
  }
}

// str_tr_str_unlocked
// file libslack/str.c line 2455
signed int str_tr_str_unlocked(struct String *str, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno$1;
  if(from == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_str_tr_compile_table_unlocked$2;
    return_value_str_tr_compile_table_unlocked$2=str_tr_compile_table_unlocked(table, from, to, option);
    if(return_value_str_tr_compile_table_unlocked$2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled_unlocked$3;
      return_value_str_tr_compiled_unlocked$3=str_tr_compiled_unlocked(str, table);
      return return_value_str_tr_compiled_unlocked$3;
    }
  }
}

// str_tr_unlocked
// file libslack/str.c line 2396
signed int str_tr_unlocked(struct String *str, const char *from, const char *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno$1;
  if(from == ((const char *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_tr_compile_table$2;
    return_value_tr_compile_table$2=tr_compile_table(table, from, to, option);
    if(return_value_tr_compile_table$2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled_unlocked$3;
      return_value_str_tr_compiled_unlocked$3=str_tr_compiled_unlocked(str, table);
      return return_value_str_tr_compiled_unlocked$3;
    }
  }
}

// str_trim
// file libslack/str.c line 4644
struct String * str_trim(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_trim_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_trim_left
// file libslack/str.c line 4744
struct String * str_trim_left(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_trim_left_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_trim_left_unlocked
// file libslack/str.c line 4773
struct String * str_trim_left_unlocked(struct String *str)
{
  char *s;
  void *return_value_set_errnull$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  struct String *return_value_str_remove_range_unlocked$3;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    s = str->str;
    do
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if(!(str->str >= s))
    {
      return_value_str_remove_range_unlocked$3=str_remove_range_unlocked(str, (signed long int)0, s - str->str);
      if(!(return_value_str_remove_range_unlocked$3 == ((struct String *)NULL)))
        goto __CPROVER_DUMP_L4;

      return (struct String *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      return str;
    }
  }
}

// str_trim_right
// file libslack/str.c line 4830
struct String * str_trim_right(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_trim_right_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_trim_right_unlocked
// file libslack/str.c line 4859
struct String * str_trim_right_unlocked(struct String *str)
{
  char *s;
  void *return_value_set_errnull$1;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$2;
  struct String *return_value_str_remove_range_unlocked$4;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    s = (str->str + (signed long int)str->length) - (signed long int)1;
    do
    {
      if(!(str->str >= s))
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        tmp_if_expr$3 = ((signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)s[(signed long int)-1]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      s = s - 1l;
    }
    while((_Bool)1);
    const unsigned short int **return_value___ctype_b_loc$5;
    return_value___ctype_b_loc$5=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned char)*s]) == 0))
    {
      return_value_str_remove_range_unlocked$4=str_remove_range_unlocked(str, s - str->str, (signed long int)((str->length - (unsigned long int)1) - (unsigned long int)(s - str->str)));
      if(!(return_value_str_remove_range_unlocked$4 == ((struct String *)NULL)))
        goto __CPROVER_DUMP_L6;

      return (struct String *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      return str;
    }
  }
}

// str_trim_unlocked
// file libslack/str.c line 4673
struct String * str_trim_unlocked(struct String *str)
{
  char *s;
  void *return_value_set_errnull$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    s = str->str;
    do
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if(!(str->str >= s))
    {
      struct String *return_value_str_remove_range_unlocked$3;
      return_value_str_remove_range_unlocked$3=str_remove_range_unlocked(str, (signed long int)0, s - str->str);
      if(return_value_str_remove_range_unlocked$3 == ((struct String *)NULL))
        return (struct String *)(void *)0;

    }

    s = (str->str + (signed long int)str->length) - (signed long int)1;
    do
    {
      if(!(str->str >= s))
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        tmp_if_expr$5 = ((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)s[(signed long int)-1]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      s = s - 1l;
    }
    while((_Bool)1);
    const unsigned short int **return_value___ctype_b_loc$7;
    return_value___ctype_b_loc$7=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)(unsigned char)*s]) == 0))
    {
      struct String *return_value_str_remove_range_unlocked$6;
      return_value_str_remove_range_unlocked$6=str_remove_range_unlocked(str, s - str->str, (signed long int)((str->length - (unsigned long int)1) - (unsigned long int)(s - str->str)));
      if(return_value_str_remove_range_unlocked$6 == ((struct String *)NULL))
        return (struct String *)(void *)0;

    }

    return str;
  }
}

// str_uc
// file libslack/str.c line 5906
struct String * str_uc(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_uc_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_uc_unlocked
// file libslack/str.c line 5935
struct String * str_uc_unlocked(struct String *str)
{
  unsigned long int i;
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$3;
  const signed int **return_value___ctype_toupper_loc$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= str->length + 18446744073709551615ul); i = i + 1ul)
    {
      signed int __res;
      __res=toupper((signed int)(unsigned char)str->str[(signed long int)i]);
      tmp_statement_expression$2 = __res;
      str->str[(signed long int)i] = (char)tmp_statement_expression$2;
    }
    return str;
  }
}

// str_ucfirst
// file libslack/str.c line 5983
struct String * str_ucfirst(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_ucfirst_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_ucfirst_unlocked
// file libslack/str.c line 6012
struct String * str_ucfirst_unlocked(struct String *str)
{
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$3;
  const signed int **return_value___ctype_toupper_loc$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(str->length >= 2ul)
    {
      signed int __res;
      __res=toupper((signed int)(unsigned char)*str->str);
      tmp_statement_expression$2 = __res;
      *str->str = (char)tmp_statement_expression$2;
    }

    return str;
  }
}

// str_unlock
// file libslack/str.c line 971
signed int str_unlock(const struct String *str)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(str == ((const struct String *)NULL)))
  {
    if(!(str->locker == ((struct Locker *)NULL)))
    {
      return_value=str->locker->unlock(str->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// str_unquote
// file libslack/str.c line 5182
struct String * str_unquote(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_unquote_with_locker$1;
  return_value_str_unquote_with_locker$1=str_unquote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_unquote_with_locker$1;
}

// str_unquote_unlocked
// file libslack/str.c line 5197
struct String * str_unquote_unlocked(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_unquote_with_locker_unlocked$1;
  return_value_str_unquote_with_locker_unlocked$1=str_unquote_with_locker_unlocked((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_unquote_with_locker_unlocked$1;
}

// str_unquote_with_locker
// file libslack/str.c line 5213
struct String * str_unquote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  signed int i;
  void *return_value_set_errnull$1;
  char *return_value___builtin_strchr$3;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_copy_with_locker(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)ret->length + -2); i = i + 1)
        if(ret->str[(signed long int)i] == quote_char)
        {
          if(!(ret->str[(signed long int)(1 + i)] == 0))
          {
            return_value___builtin_strchr$3=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)(i + 1)]);
            if(!(return_value___builtin_strchr$3 == ((char *)NULL)))
            {
              struct String *return_value_str_remove$2;
              return_value_str_remove$2=str_remove(ret, (signed long int)i);
              if(return_value_str_remove$2 == ((struct String *)NULL))
              {
                str_release(ret);
                return (struct String *)(void *)0;
              }

            }

          }

        }

      return ret;
    }
  }
}

// str_unquote_with_locker_unlocked
// file libslack/str.c line 5250
struct String * str_unquote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  signed int i;
  void *return_value_set_errnull$1;
  char *return_value___builtin_strchr$3;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_copy_with_locker_unlocked(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)ret->length + -2); i = i + 1)
        if(ret->str[(signed long int)i] == quote_char)
        {
          if(!(ret->str[(signed long int)(1 + i)] == 0))
          {
            return_value___builtin_strchr$3=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)(i + 1)]);
            if(!(return_value___builtin_strchr$3 == ((char *)NULL)))
            {
              struct String *return_value_str_remove$2;
              return_value_str_remove$2=str_remove(ret, (signed long int)i);
              if(return_value_str_remove$2 == ((struct String *)NULL))
              {
                str_release(ret);
                return (struct String *)(void *)0;
              }

            }

          }

        }

      return ret;
    }
  }
}

// str_vappend
// file libslack/str.c line 1579
struct String * str_vappend(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert$1;
  return_value_str_vinsert$1=str_vinsert(str, (signed long int)-1, format, args);
  return return_value_str_vinsert$1;
}

// str_vappend_unlocked
// file libslack/str.c line 1594
struct String * str_vappend_unlocked(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert_unlocked$1;
  return_value_str_vinsert_unlocked$1=str_vinsert_unlocked(str, (signed long int)-1, format, args);
  return return_value_str_vinsert_unlocked$1;
}

// str_vcreate
// file libslack/str.c line 573
struct String * str_vcreate(const char *format, void **args)
{
  struct String *return_value_str_vcreate_with_locker_sized$1;
  return_value_str_vcreate_with_locker_sized$1=str_vcreate_with_locker_sized((struct Locker *)(void *)0, MIN_STRING_SIZE, format, args);
  return return_value_str_vcreate_with_locker_sized$1;
}

// str_vcreate_sized
// file libslack/str.c line 651
struct String * str_vcreate_sized(unsigned long int size, const char *format, void **args)
{
  struct String *return_value_str_vcreate_with_locker_sized$1;
  return_value_str_vcreate_with_locker_sized$1=str_vcreate_with_locker_sized((struct Locker *)(void *)0, size, format, args);
  return return_value_str_vcreate_with_locker_sized$1;
}

// str_vcreate_with_locker
// file libslack/str.c line 589
struct String * str_vcreate_with_locker(struct Locker *locker, const char *format, void **args)
{
  struct String *return_value_str_vcreate_with_locker_sized$1;
  return_value_str_vcreate_with_locker_sized$1=str_vcreate_with_locker_sized(locker, MIN_STRING_SIZE, format, args);
  return return_value_str_vcreate_with_locker_sized$1;
}

// str_vcreate_with_locker_sized
// file libslack/str.c line 671
struct String * str_vcreate_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, void **args)
{
  struct String *str;
  char *buf = (char *)(void *)0;
  signed long int length;
  unsigned int bit;
  void **args_copy;
  bit = (unsigned int)1;
  for( ; !(bit == 0u); bit = bit << 1)
    if((unsigned long int)bit >= size)
    {
      size = (unsigned long int)bit;
      break;
    }

  void *return_value_set_errnull$1;
  if(bit == 0u)
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(format == ((const char *)NULL))
      format = "";

    do
    {
      void *return_value_mem_resize_fn$2;
      return_value_mem_resize_fn$2=mem_resize_fn((void **)&buf, size * sizeof(char) /*1ul*/ );
      if(return_value_mem_resize_fn$2 == NULL)
      {
        free((void *)buf);
        return (struct String *)(void *)0;
      }

      args_copy = (void **)args;
      signed int return_value_vsnprintf$3;
      return_value_vsnprintf$3=vsnprintf(buf, size, format, args_copy);
      length = (signed long int)return_value_vsnprintf$3;
      args_copy = ((void **)NULL);
      if(!(length == -1l) && !((unsigned long int)length >= size))
        break;

      size = size << 1;
    }
    while((_Bool)1);
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct String) /*32ul*/ );
    str = (struct String *)return_value_malloc$4;
    if(str == ((struct String *)NULL))
    {
      free((void *)buf);
      return (struct String *)(void *)0;
    }

    else
    {
      str->size = size;
      str->length = (unsigned long int)(length + (signed long int)1);
      str->str = buf;
      str->locker = locker;
      return str;
    }
  }
}

// str_vinsert
// file libslack/str.c line 1389
struct String * str_vinsert(struct String *str, signed long int index, const char *format, void **args)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull$1;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value;
  void *return_value_set_errnull$2;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$6;
  signed int return_value_1;
  void *return_value_set_errnull$5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr$3 = return_value;
      }

      else
        tmp_if_expr$3 = 0;
      tmp_if_expr$4 = tmp_if_expr$3;
    }

    else
      tmp_if_expr$4 = 22;
    err = tmp_if_expr$4;
    if(!(err == 0))
    {
      return_value_set_errnull$2=set_errnull(err);
      return (struct String *)return_value_set_errnull$2;
    }

    else
    {
      ret=str_vinsert_unlocked(str, index, format, args);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr$6 = return_value_1;
        }

        else
          tmp_if_expr$6 = 0;
        tmp_if_expr$7 = tmp_if_expr$6;
      }

      else
        tmp_if_expr$7 = 22;
      err = tmp_if_expr$7;
      if(!(err == 0))
      {
        return_value_set_errnull$5=set_errnull(err);
        return (struct String *)return_value_set_errnull$5;
      }

      else
        return ret;
    }
  }
}

// str_vinsert_unlocked
// file libslack/str.c line 1418
struct String * str_vinsert_unlocked(struct String *str, signed long int index, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  void *return_value_set_errnull$1;
  void *return_value_set_errnull$2;
  void *return_value_set_errnull$3;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$2=set_errnull(22);
      return (struct String *)return_value_set_errnull$2;
    }

    else
      if(!(str->length + 18446744073709551615ul >= (unsigned long int)index))
      {
        return_value_set_errnull$3=set_errnull(22);
        return (struct String *)return_value_set_errnull$3;
      }

      else
      {
        tmp=str_vcreate(format, args);
        if(tmp == ((struct String *)NULL))
          return (struct String *)(void *)0;

        else
        {
          ret=str_insert_str_unlocked(str, index, tmp);
          str_release(tmp);
          return ret;
        }
      }
  }
}

// str_vprepend
// file libslack/str.c line 1685
struct String * str_vprepend(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert$1;
  return_value_str_vinsert$1=str_vinsert(str, (signed long int)0, format, args);
  return return_value_str_vinsert$1;
}

// str_vprepend_unlocked
// file libslack/str.c line 1700
struct String * str_vprepend_unlocked(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert_unlocked$1;
  return_value_str_vinsert_unlocked$1=str_vinsert_unlocked(str, (signed long int)0, format, args);
  return return_value_str_vinsert_unlocked$1;
}

// str_vrepeat
// file libslack/str.c line 2253
struct String * str_vrepeat(unsigned long int count, const char *format, void **args)
{
  struct String *return_value_str_vrepeat_with_locker$1;
  return_value_str_vrepeat_with_locker$1=str_vrepeat_with_locker((struct Locker *)(void *)0, count, format, args);
  return return_value_str_vrepeat_with_locker$1;
}

// str_vrepeat_with_locker
// file libslack/str.c line 2269
struct String * str_vrepeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  signed long int length;
  unsigned long int i;
  tmp=str_vcreate(format, args);
  if(tmp == ((struct String *)NULL))
    return (struct String *)(void *)0;

  else
  {
    length=str_length(tmp);
    if(length == -1l)
      return (struct String *)(void *)0;

    else
    {
      ret=str_create_with_locker_sized(locker, (unsigned long int)length * count + (unsigned long int)1, (const char *)(void *)0);
      if(ret == ((struct String *)NULL))
      {
        str_release(tmp);
        return (struct String *)(void *)0;
      }

      else
      {
        i = (unsigned long int)0;
        for( ; !(i >= count); i = i + 1ul)
        {
          struct String *return_value_str_append_str$1;
          return_value_str_append_str$1=str_append_str(ret, tmp);
          if(return_value_str_append_str$1 == ((struct String *)NULL))
          {
            str_release(tmp);
            str_release(ret);
            return (struct String *)(void *)0;
          }

        }
        str_release(tmp);
        return ret;
      }
    }
  }
}

// str_vreplace
// file libslack/str.c line 1795
struct String * str_vreplace(struct String *str, signed long int index, signed long int range, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  void *return_value_set_errnull$1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    tmp=str_vcreate(format, args);
    if(tmp == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      ret=str_replace_str(str, index, range, tmp);
      str_release(tmp);
      return ret;
    }
  }
}

// str_vreplace_unlocked
// file libslack/str.c line 1821
struct String * str_vreplace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  void *return_value_set_errnull$1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    tmp=str_vcreate(format, args);
    if(tmp == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      ret=str_replace_str_unlocked(str, index, range, tmp);
      str_release(tmp);
      return ret;
    }
  }
}

// str_wrlock
// file libslack/str.c line 954
signed int str_wrlock(const struct String *str)
{
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(str == ((const struct String *)NULL)))
  {
    if(!(str->locker == ((struct Locker *)NULL)))
    {
      return_value=str->locker->wrlock(str->locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = 22;
  return tmp_if_expr$2;
}

// strlcat
// file libslack/str.c line 6619
unsigned long int strlcat(char *dst, const char *src, unsigned long int size)
{
  const char *s = src;
  char *d = dst;
  unsigned long int n = size;
  unsigned long int dlen = (unsigned long int)0;
  unsigned long int tmp_post$1;
  do
  {
    tmp_post$1 = n;
    n = n - 1ul;
    if(tmp_post$1 == 0ul)
      break;

    if(*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = n + 1ul;
  const char *tmp_post$2;
  char *tmp_post$3;
  if(n == 0ul)
  {
    do
    {
      tmp_post$2 = s;
      s = s + 1l;
      if(*tmp_post$2 == 0)
        break;

    }
    while((_Bool)1);
    return (unsigned long int)((((signed long int)dlen + s) - src) - (signed long int)1);
  }

  else
  {
    for( ; !(*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        n = n - 1ul;
        tmp_post$3 = d;
        d = d + 1l;
        *tmp_post$3 = *s;
      }

    *d = (char)0;
    return (unsigned long int)(((signed long int)dlen + s) - src);
  }
}

// strlcpy
// file libslack/str.h line 257
unsigned long int strlcpy(char *dst, const char *src, unsigned long int size)
{
  const char *s = src;
  char *d = dst;
  unsigned long int n = size;
  char *tmp_post$1;
  const char *tmp_post$2;
  if(!(n == 0ul))
    do
    {
      n = n - 1ul;
      if(n == 0ul)
        break;

      tmp_post$1 = d;
      d = d + 1l;
      tmp_post$2 = s;
      s = s + 1l;
      *tmp_post$1 = *tmp_post$2;
      if(*tmp_post$1 == 0)
        break;

    }
    while((_Bool)1);

  const char *tmp_post$3;
  if(n == 0ul)
  {
    if(!(size == 0ul))
      *d = (char)0;

    do
    {
      tmp_post$3 = s;
      s = s + 1l;
      if(*tmp_post$3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// substr
// file libslack/str.c line 2048
struct String * substr(const char *str, signed long int index, signed long int range)
{
  struct String *return_value_substr_with_locker$1;
  return_value_substr_with_locker$1=substr_with_locker((struct Locker *)(void *)0, str, index, range);
  return return_value_substr_with_locker$1;
}

// substr_with_locker
// file libslack/str.c line 2065
struct String * substr_with_locker(struct Locker *locker, const char *str, signed long int index, signed long int range)
{
  struct String *ret;
  unsigned long int len = (unsigned long int)0;
  void *return_value_set_errnull$1;
  unsigned long int return_value_strlen$2;
  void *return_value_set_errnull$3;
  void *return_value_set_errnull$4;
  if(str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    if(!(index >= 0l) || !(range >= 0l))
    {
      return_value_strlen$2=strlen(str);
      len = return_value_strlen$2 + (unsigned long int)1;
    }

    if(!(index >= 0l))
      index = (signed long int)(len + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull$3=set_errnull(22);
      return (struct String *)return_value_set_errnull$3;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((len + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull$4=set_errnull(22);
        return (struct String *)return_value_set_errnull$4;
      }

      else
      {
        ret=str_create_with_locker_sized(locker, (unsigned long int)(range + (signed long int)1), (const char *)(void *)0);
        if(ret == ((struct String *)NULL))
          return (struct String *)(void *)0;

        else
        {
          memcpy((void *)ret->str, (const void *)(str + index), (unsigned long int)range);
          ret->length = (unsigned long int)(range + (signed long int)1);
          ret->str[(signed long int)(ret->length - (unsigned long int)1)] = (char)0;
          return ret;
        }
      }
    }
  }
}

// swap
// file libslack/hsort.c line 156
static void swap(char *p1, char *p2, unsigned long int n)
{
  char ctmp;
  unsigned long int tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  do
  {
    tmp_post$1 = n;
    n = n - 1ul;
    if(tmp_post$1 == 0ul)
      break;

    ctmp = *p1;
    tmp_post$2 = p1;
    p1 = p1 + 1l;
    *tmp_post$2 = *p2;
    tmp_post$3 = p2;
    p2 = p2 + 1l;
    *tmp_post$3 = ctmp;
  }
  while((_Bool)1);
}

// syslog_facility_str
// file libslack/msg.c line 1395
const char * syslog_facility_str(signed int spec)
{
  const char *return_value_syslog_lookup_str$1;
  return_value_syslog_lookup_str$1=syslog_lookup_str(syslog_facility_map, spec, 0x03f8);
  return return_value_syslog_lookup_str$1;
}

// syslog_lookup
// file libslack/msg.c line 1323
static signed int syslog_lookup(const struct syslog_map_t *map, const char *name)
{
  signed int i = 0;
  signed int tmp_statement_expression$1;
  for( ; !((map + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(name, (map + (signed long int)i)->name);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      break;

  }
  return (map + (signed long int)i)->val;
}

// syslog_lookup_facility
// file libslack/msg.c line 1364
signed int syslog_lookup_facility(const char *facility)
{
  signed int return_value_syslog_lookup$1;
  return_value_syslog_lookup$1=syslog_lookup(syslog_facility_map, facility);
  return return_value_syslog_lookup$1;
}

// syslog_lookup_priority
// file libslack/msg.c line 1379
signed int syslog_lookup_priority(const char *priority)
{
  signed int return_value_syslog_lookup$1;
  return_value_syslog_lookup$1=syslog_lookup(syslog_priority_map, priority);
  return return_value_syslog_lookup$1;
}

// syslog_lookup_str
// file libslack/msg.c line 1343
static const char * syslog_lookup_str(const struct syslog_map_t *map, signed int spec, signed int mask)
{
  signed int i = 0;
  for( ; !((map + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
    if((mask & spec) == (map + (signed long int)i)->val)
      break;

  return (map + (signed long int)i)->name;
}

// syslog_parse
// file libslack/msg.c line 1451
signed int syslog_parse(const char *spec, signed int *facility, signed int *priority)
{
  char fac[64l];
  char *pri;
  signed int f;
  signed int p;
  signed int return_value_set_errno$1;
  signed int return_value_set_errno$2;
  char *tmp_post$4;
  signed int return_value_set_errno$5;
  signed int return_value_set_errno$6;
  if(spec == ((const char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    strlcpy(fac, spec, (unsigned long int)64);
    char *return_value___builtin_strchr$3;
    return_value___builtin_strchr$3=__builtin_strchr(fac, 46);
    pri = return_value___builtin_strchr$3;
    if(pri == ((char *)NULL))
    {
      return_value_set_errno$2=set_errno(22);
      return return_value_set_errno$2;
    }

    else
    {
      tmp_post$4 = pri;
      pri = pri + 1l;
      *tmp_post$4 = (char)0;
      f=syslog_lookup_facility(fac);
      if(f == -1)
      {
        return_value_set_errno$5=set_errno(22);
        return return_value_set_errno$5;
      }

      else
      {
        p=syslog_lookup_priority(pri);
        if(p == -1)
        {
          return_value_set_errno$6=set_errno(22);
          return return_value_set_errno$6;
        }

        else
        {
          if(!(facility == ((signed int *)NULL)))
            *facility = f;

          if(!(priority == ((signed int *)NULL)))
            *priority = p;

          return 0;
        }
      }
    }
  }
}

// syslog_priority_str
// file libslack/msg.c line 1411
const char * syslog_priority_str(signed int spec)
{
  const char *return_value_syslog_lookup_str$1;
  return_value_syslog_lookup_str$1=syslog_lookup_str(syslog_priority_map, spec, 0x07);
  return return_value_syslog_lookup_str$1;
}

// test_action
// file libslack/map.c line 2414
static void test_action(char *key, char *value, char *cat)
{
  unsigned long int len;
  len=strlen(cat);
  snprintf(cat + (signed long int)len, (unsigned long int)8192, "%s%s=%s", len != 0ul ? ", " : "", key, value);
}

// test_hash
// file libslack/map.c line 2345
static void test_hash(void)
{
  struct _IO_FILE *words;
  words=fopen("/usr/dict/words", "r");
  char word[8192l];
  struct Map *map;
  unsigned long int c;
  unsigned long int min = (unsigned long int)0xffffffff;
  unsigned long int max = (unsigned long int)0x00000000;
  signed int sum = 0;
  if(words == ((struct _IO_FILE *)NULL))
  {
    printf("Failed to open /usr/dict/words\n");
    exit(1);
  }

  map=map_create(free);
  if(map == ((struct Map *)NULL))
  {
    printf("Failed to create map\n");
    exit(1);
  }

  char *return_value_fgets$1;
  do
  {
    return_value_fgets$1=fgets(word, 8192, words);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    char *eow;
    eow=strchr(word, 10);
    if(!(eow == ((char *)NULL)))
      *eow = (char)0;

    char *return_value_mem_strdup$2;
    return_value_mem_strdup$2=mem_strdup(word);
    map_add(map, (const void *)word, (void *)return_value_mem_strdup$2);
  }
  while((_Bool)1);
  fclose(words);
  printf("%d entries into %d buckets:\n\n", (signed int)map->items, (signed int)map->size);
  c = (unsigned long int)0;
  for( ; !(c >= map->size); c = c + 1ul)
  {
    unsigned long int length;
    if(!(map->chain[(signed long int)c] == ((struct List *)NULL)))
    {
      signed long int return_value_list_length$3;
      return_value_list_length$3=list_length(map->chain[(signed long int)c]);
      length = (unsigned long int)return_value_list_length$3;
      if(length == 18446744073709551615ul)
        printf(" length[%d] == -1\n", (signed int)c);

      else
      {
        if(!(max >= length))
          max = length;

        if(!(length >= min))
          min = length;

        sum = sum + (signed int)length;
      }
    }

  }
  printf("avg = %g\n", (double)sum / (double)map->size);
  printf("min = %d\n", (signed int)min);
  printf("max = %d\n", (signed int)max);
  map_histogram("dict", map);
  map_release(map);
  exit(0);
}

// timeout
// file libslack/agent.c line 1909
static signed int timeout(struct Agent *agent)
{
  signed int i;
  if(agent->timers == 0ul)
    return -1;

  else
  {
    i = (signed int)agent->timewheel->jiffy;
    for( ; !(i >= 100); i = i + 1)
      if(!(agent->timewheel->jiffies[(signed long int)i] == ((struct action_t *)NULL)))
        break;

    return (signed int)(((unsigned long int)i - agent->timewheel->jiffy) * (unsigned long int)10);
  }
}

// timeval_add
// file libslack/agent.c line 1624
static void timeval_add(struct timeval *absolute, struct timeval *relative, struct timeval *result)
{
  result->tv_sec = absolute->tv_sec + relative->tv_sec;
  result->tv_usec = absolute->tv_usec + relative->tv_usec;
  if(result->tv_usec >= 1000000l)
  {
    result->tv_sec = result->tv_sec + 1l;
    result->tv_usec = result->tv_usec - (signed long int)1000000;
  }

}

// timeval_diff
// file libslack/agent.c line 1614
static void timeval_diff(struct timeval *start, struct timeval *end, struct timeval *diff)
{
  diff->tv_sec = end->tv_sec - start->tv_sec;
  if(!(end->tv_usec >= start->tv_usec))
  {
    diff->tv_usec = ((signed long int)1000000 + end->tv_usec) - start->tv_usec;
    diff->tv_sec = diff->tv_sec - 1l;
  }

  else
    diff->tv_usec = end->tv_usec - start->tv_usec;
}

// timeval_set
// file libslack/agent.c line 1633
static void timeval_set(struct timeval *tv, signed long int tv_sec, signed long int tv_usec)
{
  tv->tv_sec = tv_sec;
  tv->tv_usec = tv_usec;
}

// timewheel_create
// file libslack/agent.c line 250
static struct timewheel_t * timewheel_create()
{
  struct timewheel_t *timewheel;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct timewheel_t) /*2088ul*/ );
  timewheel = (struct timewheel_t *)return_value_malloc$1;
  if(timewheel == ((struct timewheel_t *)NULL))
    return (struct timewheel_t *)(void *)0;

  else
  {
    memset((void *)timewheel, 0, sizeof(struct timewheel_t) /*2088ul*/ );
    signed int return_value_gettimeofday$2;
    return_value_gettimeofday$2=gettimeofday(timewheel->now, (struct timezone *)(void *)0);
    if(return_value_gettimeofday$2 == -1)
      return (struct timewheel_t *)(void *)0;

    else
      return timewheel;
  }
}

// timewheel_release
// file libslack/agent.c line 288
static void timewheel_release(struct timewheel_t *timewheel)
{
  unsigned long int i;
  if(!(timewheel == ((struct timewheel_t *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= 10ul); i = i + 1ul)
      release_actions(timewheel->days[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 24ul); i = i + 1ul)
      release_actions(timewheel->hours[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 60ul); i = i + 1ul)
      release_actions(timewheel->minutes[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 60ul); i = i + 1ul)
      release_actions(timewheel->seconds[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 100ul); i = i + 1ul)
      release_actions(timewheel->jiffies[(signed long int)i]);
    free((void *)timewheel);
  }

}

// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_tolower_loc$1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_tolower_loc$1=__ctype_tolower_loc();
    tmp_if_expr$2 = (*return_value___ctype_tolower_loc$1)[(signed long int)__c];
  }

  else
    tmp_if_expr$2 = __c;
  return tmp_if_expr$2;
}

// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_toupper_loc$1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_toupper_loc$1=__ctype_toupper_loc();
    tmp_if_expr$2 = (*return_value___ctype_toupper_loc$1)[(signed long int)__c];
  }

  else
    tmp_if_expr$2 = __c;
  return tmp_if_expr$2;
}

// tr
// file libslack/str.c line 2480
signed int tr(char *str, const char *from, const char *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno$1;
  if(from == ((const char *)NULL) || str == ((char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_tr_compile_table$2;
    return_value_tr_compile_table$2=tr_compile_table(table, from, to, option);
    if(return_value_tr_compile_table$2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_tr_compiled$3;
      return_value_tr_compiled$3=tr_compiled(str, table);
      return return_value_tr_compiled$3;
    }
  }
}

// tr_compile
// file libslack/str.c line 2509
struct StringTR * tr_compile(const char *from, const char *to, signed int option)
{
  struct StringTR *return_value_tr_compile_with_locker$1;
  return_value_tr_compile_with_locker$1=tr_compile_with_locker((struct Locker *)(void *)0, from, to, option);
  return return_value_tr_compile_with_locker$1;
}

// tr_compile_table
// file libslack/str.c line 2793
static struct StringTR * tr_compile_table(struct StringTR *table, const char *from, const char *to, signed int option)
{
  struct StringTR *return_value_do_tr_compile_table$1;
  return_value_do_tr_compile_table$1=do_tr_compile_table(table, from, (signed long int)-1, to, (signed long int)-1, option);
  return return_value_do_tr_compile_table$1;
}

// tr_compile_with_locker
// file libslack/str.c line 2525
struct StringTR * tr_compile_with_locker(struct Locker *locker, const char *from, const char *to, signed int option)
{
  struct StringTR *ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct StringTR) /*528ul*/ );
  ret = (struct StringTR *)return_value_malloc$1;
  if(ret == ((struct StringTR *)NULL))
    return (struct StringTR *)(void *)0;

  else
  {
    ret->locker = locker;
    struct StringTR *return_value_tr_compile_table$2;
    return_value_tr_compile_table$2=tr_compile_table(ret, from, to, option);
    return return_value_tr_compile_table$2;
  }
}

// tr_compiled
// file libslack/str.c line 2989
signed int tr_compiled(char *str, struct StringTR *table)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno$1;
  signed int tmp_if_expr$3;
  signed int return_value;
  signed int return_value_set_errno$2;
  signed int tmp_if_expr$5;
  signed int return_value_1;
  signed int return_value_set_errno$4;
  if(str == ((char *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    if(!(table->locker == ((struct Locker *)NULL)))
    {
      return_value=table->locker->rdlock(table->locker->lock);
      tmp_if_expr$3 = return_value;
    }

    else
      tmp_if_expr$3 = 0;
    err = tmp_if_expr$3;
    if(!(err == 0))
    {
      return_value_set_errno$2=set_errno(err);
      return return_value_set_errno$2;
    }

    else
    {
      ret=do_tr_compiled((unsigned char *)str, (unsigned long int *)(void *)0, table);
      if(!(table->locker == ((struct Locker *)NULL)))
      {
        return_value_1=table->locker->unlock(table->locker->lock);
        tmp_if_expr$5 = return_value_1;
      }

      else
        tmp_if_expr$5 = 0;
      err = tmp_if_expr$5;
      if(!(err == 0))
      {
        return_value_set_errno$4=set_errno(err);
        return return_value_set_errno$4;
      }

      else
        return ret;
    }
  }
}

// tr_destroy
// file libslack/str.c line 2655
void * tr_destroy(struct StringTR **table)
{
  if(!(table == ((struct StringTR **)NULL)))
  {
    if(!(*table == ((struct StringTR *)NULL)))
    {
      tr_release(*table);
      *table = (struct StringTR *)(void *)0;
    }

  }

  return (void *)0;
}

// tr_release
// file libslack/str.c line 2628
void tr_release(struct StringTR *table)
{
  struct Locker *tr_release$$1$$locker;
  signed int tmp_if_expr$1;
  signed int return_value;
  if(!(table == ((struct StringTR *)NULL)))
  {
    tr_release$$1$$locker = table->locker;
    if(!(tr_release$$1$$locker == ((struct Locker *)NULL)))
    {
      return_value=tr_release$$1$$locker->wrlock(tr_release$$1$$locker->lock);
      tmp_if_expr$1 = return_value;
    }

    else
      tmp_if_expr$1 = 0;
    if(tmp_if_expr$1 == 0)
    {
      free((void *)table);
      if(!(tr_release$$1$$locker == ((struct Locker *)NULL)))
        tr_release$$1$$locker->unlock(tr_release$$1$$locker->lock);

      else
        0;
    }

  }

}

// translate
// file libslack/agent.c line 2065
static signed int translate(signed int revents)
{
  signed int ret = 0;
  if(!((0x001 & revents) == 0))
    ret = ret | 4;

  if(!((0x002 & revents) == 0))
    ret = ret | 1;

  if(!((0x004 & revents) == 0))
    ret = ret | 2;

  return ret;
}

// trim
// file libslack/str.c line 4711
char * trim(char *str)
{
  char *s;
  unsigned long int len;
  void *return_value_set_errnull$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    s = str;
    do
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    len=strlen(s);
    if(!(str >= s))
      memmove((void *)str, (const void *)s, len + (unsigned long int)1);

    s = str + (signed long int)len;
    do
    {
      if(!(str >= s))
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        s = s - 1l;
        tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      *s = (char)0;
    }
    while((_Bool)1);
    return str;
  }
}

// trim_left
// file libslack/str.c line 4800
char * trim_left(char *str)
{
  char *s;
  unsigned long int len;
  void *return_value_set_errnull$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    s = str;
    do
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    len=strlen(s);
    if(!(str >= s))
      memmove((void *)str, (const void *)s, len + (unsigned long int)1);

    return str;
  }
}

// trim_right
// file libslack/str.c line 4886
char * trim_right(char *str)
{
  char *s;
  unsigned long int len;
  void *return_value_set_errnull$1;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$2;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    len=strlen(str);
    s = str + (signed long int)len;
    do
    {
      if(!(str >= s))
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        s = s - 1l;
        tmp_if_expr$3 = ((signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      *s = (char)0;
    }
    while((_Bool)1);
    return str;
  }
}

// uc
// file libslack/str.c line 5959
char * uc(char *str)
{
  char *s;
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$3;
  const signed int **return_value___ctype_toupper_loc$5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    s = str;
    for( ; !(*s == 0); s = s + 1l)
    {
      signed int __res;
      __res=toupper((signed int)(unsigned char)*s);
      tmp_statement_expression$2 = __res;
      *s = (char)tmp_statement_expression$2;
    }
    return str;
  }
}

// ucfirst
// file libslack/str.c line 6034
char * ucfirst(char *str)
{
  void *return_value_set_errnull$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$3;
  const signed int **return_value___ctype_toupper_loc$5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (char *)return_value_set_errnull$1;
  }

  else
  {
    signed int __res;
    __res=toupper((signed int)(unsigned char)*str);
    tmp_statement_expression$2 = __res;
    *str = (char)tmp_statement_expression$2;
    return str;
  }
}

// uid2gid
// file libslack/pseudo.c line 196
static signed int uid2gid(unsigned int uid)
{
  struct _IO_FILE *passwd;
  passwd=fopen("/etc/passwd", "r");
  char line[8192l];
  char *ptr;
  signed int ret = -1;
  char *return_value_fgets$1;
  char *return_value___builtin_strchr$4;
  signed int return_value_atoi$3;
  char *return_value___builtin_strchr$2;
  do
  {
    return_value_fgets$1=fgets(line, 8192, passwd);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    char *return_value___builtin_strchr$5;
    return_value___builtin_strchr$5=__builtin_strchr(line, 58);
    ptr = return_value___builtin_strchr$5;
    if(!(ptr == ((char *)NULL)))
    {
      return_value___builtin_strchr$4=__builtin_strchr(ptr + (signed long int)1, 58);
      ptr = return_value___builtin_strchr$4;
      if(!(ptr == ((char *)NULL)))
      {
        return_value_atoi$3=atoi(ptr + (signed long int)1);
        if(return_value_atoi$3 == (signed int)uid)
        {
          return_value___builtin_strchr$2=__builtin_strchr(ptr + (signed long int)1, 58);
          ptr = return_value___builtin_strchr$2;
          if(!(ptr == ((char *)NULL)))
          {
            ret=atoi(ptr + (signed long int)1);
            break;
          }

        }

      }

    }

  }
  while((_Bool)1);
  fclose(passwd);
  return ret;
}

// unpack
// file libslack/net.c line 3346
signed long int unpack(void *buf, unsigned long int size, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_vunpack$1;
  return_value_vunpack$1=vunpack(buf, size, format, args);
  rc = (signed int)return_value_vunpack$1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// unquote
// file libslack/str.c line 5286
struct String * unquote(const char *str, const char *quotable, char quote_char)
{
  struct String *return_value_unquote_with_locker$1;
  return_value_unquote_with_locker$1=unquote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_unquote_with_locker$1;
}

// unquote_equals
// file libslack/prop.c line 258
static struct String * unquote_equals(const char *src)
{
  struct String *return_value_decode$1;
  return_value_decode$1=decode(src, eq, eq, (char)92, 0);
  return return_value_decode$1;
}

// unquote_special
// file libslack/prop.c line 230
static struct String * unquote_special(const char *src)
{
  struct String *return_value_decode$1;
  return_value_decode$1=decode(src, special_char, special_code, (char)92, 1);
  return return_value_decode$1;
}

// unquote_with_locker
// file libslack/str.c line 5302
struct String * unquote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char)
{
  struct String *ret;
  signed int i;
  void *return_value_set_errnull$1;
  char *return_value___builtin_strchr$3;
  if(quotable == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull$1=set_errnull(22);
    return (struct String *)return_value_set_errnull$1;
  }

  else
  {
    ret=str_create_with_locker(locker, "%s", str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)ret->length + -2); i = i + 1)
        if(ret->str[(signed long int)i] == quote_char)
        {
          return_value___builtin_strchr$3=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)(i + 1)]);
          if(!(return_value___builtin_strchr$3 == ((char *)NULL)))
          {
            struct String *return_value_str_remove$2;
            return_value_str_remove$2=str_remove(ret, (signed long int)i);
            if(return_value_str_remove$2 == ((struct String *)NULL))
            {
              str_release(ret);
              return (struct String *)(void *)0;
            }

          }

        }

      return ret;
    }
  }
}

// update
// file libslack/agent.c line 1976
static signed int update(struct Agent *agent)
{
  struct timeval now[1l];
  struct timeval delta[1l];
  signed int check = 1;
  signed int tmp_if_expr$2;
  while(!(check == 0))
  {
    check = 0;
    signed int return_value_gettimeofday$1;
    return_value_gettimeofday$1=gettimeofday(now, (struct timezone *)(void *)0);
    if(return_value_gettimeofday$1 == -1)
      return -1;

    if(now[0l].tv_sec == agent->timewheel->now[0l].tv_sec)
      tmp_if_expr$2 = (signed int)(now[0l].tv_usec < agent->timewheel->now[0l].tv_usec);

    else
      tmp_if_expr$2 = (signed int)(now[0l].tv_sec < agent->timewheel->now[0l].tv_sec);
    if(!(tmp_if_expr$2 == 0))
      agent->timewheel->now[0l] = now[0l];

    timeval_diff(agent->timewheel->now, now, delta);
    delta[0l].tv_usec = delta[0l].tv_usec / (signed long int)10000;
    agent->timewheel->now[0l] = now[0l];
    while((_Bool)1)
    {
      if(delta[0l].tv_sec == 0l)
      {
        if(delta[0l].tv_usec == 0l)
          goto __CPROVER_DUMP_L12;

      }

      if(delta[0l].tv_usec == 0l)
      {
        delta[0l].tv_sec = delta[0l].tv_sec - 1l;
        delta[0l].tv_usec = (signed long int)100;
      }

      delta[0l].tv_usec = delta[0l].tv_usec - 1l;
      agent->timewheel->jiffy = agent->timewheel->jiffy + 1ul;
      if(agent->timewheel->jiffy == 100ul)
        next_second(agent);

      if(!(agent->timewheel->jiffies[(signed long int)agent->timewheel->jiffy] == ((struct action_t *)NULL)))
      {
        check = check + 1;
        signed int return_value_expire$3;
        return_value_expire$3=expire(agent);
        if(return_value_expire$3 == -1)
          return -1;

      }

    }

  __CPROVER_DUMP_L12:
    ;
  }
  return 0;
}

// user_home
// file libslack/prop.c line 272
static char * user_home(void)
{
  struct passwd *pwent;
  char *home = (char *)(void *)0;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  char *tmp_if_expr$5;
  char *return_value_mem_strdup$4;
  if(!(g$link3.home == ((char *)NULL)))
    return g$link3.home;

  else
  {
    unsigned int return_value_getuid$1;
    return_value_getuid$1=getuid();
    pwent=getpwuid(return_value_getuid$1);
    if(!(pwent == ((struct passwd *)NULL)))
      home = pwent->pw_dir;

    if(!(home == ((char *)NULL)))
    {
      return_value_strlen$2=strlen(home);
      tmp_if_expr$3 = return_value_strlen$2 != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_mem_strdup$4=mem_strdup(home);
      tmp_if_expr$5 = return_value_mem_strdup$4;
    }

    else
      tmp_if_expr$5 = (char *)(void *)0;
    g$link3.home = tmp_if_expr$5;
    return g$link3.home;
  }
}

// valert
// file libslack/err.c line 475
void valert(signed int priority, const char *format, void **args)
{
  struct Msg *valert$$1$$alert;
  char mesg[8192l];
  signed int err;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  valert$$1$$alert=prog_alert();
  err=msg_wrlock(valert$$1$$alert);
  const char *return_value_prog_name$1;
  if(!(err == 0))
    set_errno(err);

  else
  {
    msg_syslog_set_priority_unlocked(valert$$1$$alert, priority);
    const char *return_value_prog_name$2;
    return_value_prog_name$2=prog_name();
    if(!(return_value_prog_name$2 == ((const char *)NULL)))
    {
      return_value_prog_name$1=prog_name();
      msg_out_unlocked(valert$$1$$alert, "%s: %s\n", return_value_prog_name$1, (const void *)mesg);
    }

    else
      msg_out_unlocked(valert$$1$$alert, "%s\n", (const void *)mesg);
    err=msg_unlock(valert$$1$$alert);
    if(!(err == 0))
      set_errno(err);

  }
}

// valertsys
// file libslack/err.c line 696
void valertsys(signed int priority, const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errno_saved = *return_value___errno_location$1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(errno_saved);
  alert(priority, "%s: %s", (const void *)mesg, return_value_strerror$2);
}

// vasprintf
// file libslack/str.c line 6852
signed int vasprintf(char **str, const char *format, void **args)
{
  struct String *tmp;
  signed int len;
  tmp=str_vcreate(format, args);
  if(tmp == ((struct String *)NULL))
  {
    *str = (char *)(void *)0;
    return -1;
  }

  else
  {
    if(!(str == ((char **)NULL)))
      *str=cstr(tmp);

    signed long int return_value_str_length$1;
    return_value_str_length$1=str_length(tmp);
    len = (signed int)return_value_str_length$1;
    free((void *)tmp);
    return len;
  }
}

// vdebugf
// file libslack/err.c line 285
void vdebugf(unsigned long int level, const char *format, void **args)
{
  signed int return_value_debug_level_match$5;
  return_value_debug_level_match$5=debug_level_match(level);
  struct Msg *return_value_prog_dbg$1;
  const char *return_value_prog_name$2;
  struct Msg *return_value_prog_dbg$3;
  if(!(return_value_debug_level_match$5 == 0))
  {
    char mesg[8192l];
    char prefix[32l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    vsnprintf(mesg, (unsigned long int)8192, format, args);
    if(!((4294967040ul & level) == 0ul))
      snprintf(prefix, (unsigned long int)32, " [%d]", (signed int)((level & (unsigned long int)0xffffff00) >> 8));

    const char *return_value_prog_name$4;
    return_value_prog_name$4=prog_name();
    if(!(return_value_prog_name$4 == ((const char *)NULL)))
    {
      return_value_prog_dbg$1=prog_dbg();
      return_value_prog_name$2=prog_name();
      msg_out(return_value_prog_dbg$1, "%s: debug:%s%*s%s\n", return_value_prog_name$2, (const void *)prefix, level & (unsigned long int)0xff, (const void *)"", (const void *)mesg);
    }

    else
    {
      return_value_prog_dbg$3=prog_dbg();
      msg_out(return_value_prog_dbg$3, "debug:%s%*s%s\n", (const void *)prefix, level & (unsigned long int)0xff, (const void *)"", (const void *)mesg);
    }
  }

}

// vdebugsysf
// file libslack/err.c line 536
void vdebugsysf(unsigned long int level, const char *format, void **args)
{
  signed int return_value_debug_level_match$3;
  return_value_debug_level_match$3=debug_level_match(level);
  if(!(return_value_debug_level_match$3 == 0))
  {
    char mesg[8192l];
    signed int errno_saved;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    errno_saved = *return_value___errno_location$1;
    vsnprintf(mesg, (unsigned long int)8192, format, args);
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(errno_saved);
    debugf(level, "%s: %s", (const void *)mesg, return_value_strerror$2);
  }

}

// vdump
// file libslack/err.c line 430
void vdump(const char *format, void **args)
{
  char mesg[8192l];
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  error("dump: %s", (const void *)mesg);
  abort();
}

// vdumpsys
// file libslack/err.c line 657
void vdumpsys(const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errno_saved = *return_value___errno_location$1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(errno_saved);
  dump("%s: %s", (const void *)mesg, return_value_strerror$2);
}

// verbose
// file libslack/err.c line 190
void verbose(unsigned long int level, const char *format, ...)
{
  unsigned long int return_value_prog_verbosity_level$1;
  return_value_prog_verbosity_level$1=prog_verbosity_level();
  if(return_value_prog_verbosity_level$1 >= level)
  {
    void **args = (void **)&format;
    vverbose(level, format, args);
    args = ((void **)NULL);
  }

}

// verror
// file libslack/err.c line 337
signed int verror(const char *format, void **args)
{
  char mesg[8192l];
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  const char *return_value_prog_name$4;
  return_value_prog_name$4=prog_name();
  struct Msg *return_value_prog_err$1;
  const char *return_value_prog_name$2;
  struct Msg *return_value_prog_err$3;
  if(!(return_value_prog_name$4 == ((const char *)NULL)))
  {
    return_value_prog_err$1=prog_err();
    return_value_prog_name$2=prog_name();
    msg_out(return_value_prog_err$1, "%s: %s\n", return_value_prog_name$2, (const void *)mesg);
  }

  else
  {
    return_value_prog_err$3=prog_err();
    msg_out(return_value_prog_err$3, "%s\n", (const void *)mesg);
  }
  return -1;
}

// verrorsys
// file libslack/err.c line 579
signed int verrorsys(const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errno_saved = *return_value___errno_location$1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(errno_saved);
  signed int return_value_error$3;
  return_value_error$3=error("%s: %s", (const void *)mesg, return_value_strerror$2);
  return return_value_error$3;
}

// vfatal
// file libslack/err.c line 386
void vfatal(const char *format, void **args)
{
  char mesg[8192l];
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  error("fatal: %s", (const void *)mesg);
  exit(1);
}

// vfatalsys
// file libslack/err.c line 618
void vfatalsys(const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errno_saved = *return_value___errno_location$1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(errno_saved);
  fatal("%s: %s", (const void *)mesg, return_value_strerror$2);
}

// vmsg
// file libslack/err.c line 168
void vmsg(const char *format, void **args)
{
  struct Msg *return_value_prog_out$1;
  return_value_prog_out$1=prog_out();
  vmsg_out(return_value_prog_out$1, format, args);
}

// vmsg_out
// file libslack/msg.h line 52
void vmsg_out(struct Msg *dst, const char *format, void **args)
{
  signed int err;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  signed int return_value;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int return_value_1;
  if(!(dst == ((struct Msg *)NULL)))
  {
    if(!(dst == ((struct Msg *)NULL)))
    {
      if(!(dst->locker == ((struct Locker *)NULL)))
      {
        return_value=dst->locker->rdlock(dst->locker->lock);
        tmp_if_expr$1 = return_value;
      }

      else
        tmp_if_expr$1 = 0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }

    else
      tmp_if_expr$2 = 22;
    err = tmp_if_expr$2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      vmsg_out_unlocked(dst, format, args);
      if(!(dst == ((struct Msg *)NULL)))
      {
        if(!(dst->locker == ((struct Locker *)NULL)))
        {
          return_value_1=dst->locker->unlock(dst->locker->lock);
          tmp_if_expr$3 = return_value_1;
        }

        else
          tmp_if_expr$3 = 0;
        tmp_if_expr$4 = tmp_if_expr$3;
      }

      else
        tmp_if_expr$4 = 22;
      err = tmp_if_expr$4;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// vmsg_out_unlocked
// file libslack/msg.c line 455
void vmsg_out_unlocked(struct Msg *dst, const char *format, void **args)
{
  if(!(dst == ((struct Msg *)NULL)))
  {
    if(!(dst->out == ((void (*)(void *, const void *, unsigned long int))NULL)))
    {
      char mesg[8192l];
      vsnprintf(mesg, (unsigned long int)8192, format, args);
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(mesg);
      dst->out(dst->data, (const void *)mesg, return_value_strlen$1);
    }

  }

}

// vpack
// file libslack/net.c line 3037
signed long int vpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args)
{
  unsigned long int count;
  unsigned char *pkt = (unsigned char *)buf;
  unsigned char *p = pkt;
  char tmp[128l];
  signed int return_value_set_errno$1;
  const char *tmp_post$2;
  void *vpack$$1$$1$$1$$1$$data;
  signed int return_value_gcc_builtin_va_arg$3;
  const unsigned short int **return_value___ctype_b_loc$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  signed int return_value_set_errno$6;
  signed int return_value_set_errno$7;
  signed int return_value_set_errno$8;
  char *vpack$$1$$1$$1$$2$$data;
  unsigned long int vpack$$1$$1$$1$$2$$len;
  signed int return_value_gcc_builtin_va_arg$9;
  const unsigned short int **return_value___ctype_b_loc$11;
  const unsigned short int **return_value___ctype_b_loc$10;
  signed int return_value_set_errno$12;
  signed int return_value_set_errno$13;
  signed int return_value_set_errno$14;
  char *vpack$$1$$1$$1$$3$$data;
  unsigned char byte;
  signed int shift;
  signed int return_value_gcc_builtin_va_arg$15;
  const unsigned short int **return_value___ctype_b_loc$17;
  const unsigned short int **return_value___ctype_b_loc$16;
  signed int return_value_set_errno$18;
  signed int return_value_set_errno$19;
  signed int return_value_set_errno$20;
  unsigned long int tmp_post$21;
  char *tmp_post$22;
  signed int return_value_set_errno$23;
  unsigned char *tmp_post$24;
  unsigned char *tmp_post$25;
  char *vpack$$1$$1$$1$$4$$data;
  unsigned char vpack$$1$$1$$1$$4$$byte;
  signed int vpack$$1$$1$$1$$4$$shift;
  signed int return_value_gcc_builtin_va_arg$26;
  const unsigned short int **return_value___ctype_b_loc$28;
  const unsigned short int **return_value___ctype_b_loc$27;
  signed int return_value_set_errno$29;
  signed int return_value_set_errno$30;
  signed int return_value_set_errno$31;
  unsigned long int tmp_post$32;
  char *tmp_post$33;
  signed int return_value_set_errno$34;
  unsigned char *tmp_post$35;
  unsigned char *tmp_post$36;
  signed int return_value_gcc_builtin_va_arg$37;
  const unsigned short int **return_value___ctype_b_loc$39;
  const unsigned short int **return_value___ctype_b_loc$38;
  signed int return_value_set_errno$40;
  signed int return_value_set_errno$41;
  unsigned long int tmp_post$42;
  unsigned char *tmp_post$43;
  signed int return_value_gcc_builtin_va_arg$44;
  signed int return_value_gcc_builtin_va_arg$45;
  const unsigned short int **return_value___ctype_b_loc$47;
  const unsigned short int **return_value___ctype_b_loc$46;
  signed int return_value_set_errno$48;
  signed int return_value_set_errno$49;
  unsigned long int tmp_post$50;
  unsigned char *tmp_post$52;
  unsigned char *tmp_post$53;
  signed int return_value_gcc_builtin_va_arg$54;
  const unsigned short int **return_value___ctype_b_loc$56;
  const unsigned short int **return_value___ctype_b_loc$55;
  signed int return_value_set_errno$57;
  signed int return_value_set_errno$58;
  unsigned long int tmp_post$59;
  unsigned char *tmp_post$61;
  unsigned char *tmp_post$62;
  unsigned char *tmp_post$63;
  unsigned char *tmp_post$64;
  signed int return_value_gcc_builtin_va_arg$65;
  const unsigned short int **return_value___ctype_b_loc$67;
  const unsigned short int **return_value___ctype_b_loc$66;
  signed int return_value_set_errno$68;
  signed int return_value_set_errno$69;
  unsigned long int tmp_post$70;
  unsigned char *tmp_post$72;
  unsigned char *tmp_post$73;
  unsigned char *tmp_post$74;
  unsigned char *tmp_post$75;
  unsigned char *tmp_post$76;
  unsigned char *tmp_post$77;
  unsigned char *tmp_post$78;
  unsigned char *tmp_post$79;
  signed int return_value_gcc_builtin_va_arg$80;
  const unsigned short int **return_value___ctype_b_loc$82;
  const unsigned short int **return_value___ctype_b_loc$81;
  signed int return_value_set_errno$83;
  unsigned long int tmp_post$84;
  signed int return_value_set_errno$85;
  signed int return_value_set_errno$87;
  unsigned char *tmp_post$88;
  signed int return_value_gcc_builtin_va_arg$89;
  const unsigned short int **return_value___ctype_b_loc$91;
  const unsigned short int **return_value___ctype_b_loc$90;
  signed int return_value_set_errno$92;
  signed int return_value_set_errno$93;
  unsigned long int tmp_post$94;
  unsigned char *tmp_post$96;
  unsigned char *tmp_post$97;
  signed int return_value_gcc_builtin_va_arg$98;
  const unsigned short int **return_value___ctype_b_loc$100;
  const unsigned short int **return_value___ctype_b_loc$99;
  signed int return_value_set_errno$101;
  signed int return_value_set_errno$102;
  unsigned long int tmp_post$103;
  unsigned char *tmp_post$105;
  unsigned char *tmp_post$106;
  unsigned char *tmp_post$107;
  unsigned char *tmp_post$108;
  signed int return_value_gcc_builtin_va_arg$109;
  const unsigned short int **return_value___ctype_b_loc$111;
  const unsigned short int **return_value___ctype_b_loc$110;
  signed int return_value_set_errno$112;
  signed int return_value_set_errno$113;
  signed int return_value_gcc_builtin_va_arg$114;
  const unsigned short int **return_value___ctype_b_loc$116;
  const unsigned short int **return_value___ctype_b_loc$115;
  signed int return_value_set_errno$117;
  signed int return_value_set_errno$118;
  signed int return_value_gcc_builtin_va_arg$119;
  const unsigned short int **return_value___ctype_b_loc$121;
  const unsigned short int **return_value___ctype_b_loc$120;
  signed int return_value_set_errno$122;
  signed int return_value_set_errno$123;
  signed int return_value_set_errno$124;
  signed int return_value_set_errno$125;
  if(format == ((const char *)NULL) || pkt == ((unsigned char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    while(!(*format == 0))
    {
      char f;
      tmp_post$2 = format;
      format = format + 1l;
      f = *tmp_post$2;
      if((signed int)f == 112)
        f = (char)80;

      switch((signed int)f)
      {
        case 97:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$3=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$3));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$3;
          }

          else
          {
            return_value___ctype_b_loc$5=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$4=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$6=set_errno(22);
            return (signed long int)return_value_set_errno$6;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$7=set_errno(28);
            return (signed long int)return_value_set_errno$7;
          }

          vpack$$1$$1$$1$$1$$data=va_arg(args, __typeof__(vpack$$1$$1$$1$$1$$data));
          if(vpack$$1$$1$$1$$1$$data == NULL)
          {
            return_value_set_errno$8=set_errno(22);
            return (signed long int)return_value_set_errno$8;
          }

          memcpy((void *)p, vpack$$1$$1$$1$$1$$data, count);
          p = p + (signed long int)count;
          break;
        }
        case 122:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$9=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$9));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$9;
          }

          else
          {
            return_value___ctype_b_loc$11=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$10=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$12=set_errno(22);
            return (signed long int)return_value_set_errno$12;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$13=set_errno(28);
            return (signed long int)return_value_set_errno$13;
          }

          vpack$$1$$1$$1$$2$$data=va_arg(args, __typeof__(vpack$$1$$1$$1$$2$$data));
          if(vpack$$1$$1$$1$$2$$data == ((char *)NULL))
          {
            return_value_set_errno$14=set_errno(22);
            return (signed long int)return_value_set_errno$14;
          }

          vpack$$1$$1$$1$$2$$len=strlen(vpack$$1$$1$$1$$2$$data);
          if(!(count >= vpack$$1$$1$$1$$2$$len))
            vpack$$1$$1$$1$$2$$len = count;

          memcpy((void *)p, (const void *)vpack$$1$$1$$1$$2$$data, vpack$$1$$1$$1$$2$$len);
          p = p + (signed long int)vpack$$1$$1$$1$$2$$len;
          count = count - vpack$$1$$1$$1$$2$$len;
          if(!(count == 0ul))
            memset((void *)p, 0, count);

          p = p + (signed long int)count;
          break;
        }
        case 98:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$15=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$15));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$15;
          }

          else
          {
            return_value___ctype_b_loc$17=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$17)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$16=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$16)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$18=set_errno(22);
            return (signed long int)return_value_set_errno$18;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(7ul + count >> 3)))
          {
            return_value_set_errno$19=set_errno(28);
            return (signed long int)return_value_set_errno$19;
          }

          vpack$$1$$1$$1$$3$$data=va_arg(args, __typeof__(vpack$$1$$1$$1$$3$$data));
          if(vpack$$1$$1$$1$$3$$data == ((char *)NULL))
          {
            return_value_set_errno$20=set_errno(22);
            return (signed long int)return_value_set_errno$20;
          }

          byte = (unsigned char)0x00;
          shift = 7;
          do
          {
            tmp_post$21 = count;
            count = count - 1ul;
            if(tmp_post$21 == 0ul)
              break;

            tmp_post$22 = vpack$$1$$1$$1$$3$$data;
            vpack$$1$$1$$1$$3$$data = vpack$$1$$1$$1$$3$$data + 1l;
            switch((signed int)*tmp_post$22)
            {
              case 48:
                break;
              case 49:
              {
                byte = byte | (unsigned char)(1 << shift);
                break;
              }
              default:
              {
                return_value_set_errno$23=set_errno(22);
                return (signed long int)return_value_set_errno$23;
              }
            }
            shift = shift - 1;
            if(shift == -1)
            {
              tmp_post$24 = p;
              p = p + 1l;
              *tmp_post$24 = byte;
              byte = (unsigned char)0x00;
              shift = 7;
            }

          }
          while((_Bool)1);
          if(!(shift == 7))
          {
            tmp_post$25 = p;
            p = p + 1l;
            *tmp_post$25 = byte;
          }

          break;
        }
        case 104:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$26=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$26));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$26;
          }

          else
          {
            return_value___ctype_b_loc$28=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$28)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$27=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$27)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$29=set_errno(22);
            return (signed long int)return_value_set_errno$29;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(1ul + count >> 1)))
          {
            return_value_set_errno$30=set_errno(28);
            return (signed long int)return_value_set_errno$30;
          }

          vpack$$1$$1$$1$$4$$data=va_arg(args, __typeof__(vpack$$1$$1$$1$$4$$data));
          if(vpack$$1$$1$$1$$4$$data == ((char *)NULL))
          {
            return_value_set_errno$31=set_errno(22);
            return (signed long int)return_value_set_errno$31;
          }

          vpack$$1$$1$$1$$4$$byte = (unsigned char)0x00;
          vpack$$1$$1$$1$$4$$shift = 4;
          do
          {
            tmp_post$32 = count;
            count = count - 1ul;
            if(tmp_post$32 == 0ul)
              break;

            unsigned char nybble;
            tmp_post$33 = vpack$$1$$1$$1$$4$$data;
            vpack$$1$$1$$1$$4$$data = vpack$$1$$1$$1$$4$$data + 1l;
            nybble = (unsigned char)*tmp_post$33;
            switch((signed int)nybble)
            {
              case 48:

              case 49:

              case 50:

              case 51:

              case 52:

              case 53:

              case 54:

              case 55:

              case 56:

              case 57:
              {
                vpack$$1$$1$$1$$4$$byte = vpack$$1$$1$$1$$4$$byte | (unsigned char)((signed int)nybble - 48 << vpack$$1$$1$$1$$4$$shift);
                break;
              }
              case 97:

              case 98:

              case 99:

              case 100:

              case 101:

              case 102:
              {
                vpack$$1$$1$$1$$4$$byte = vpack$$1$$1$$1$$4$$byte | (unsigned char)(((signed int)nybble - 97) + 10 << vpack$$1$$1$$1$$4$$shift);
                break;
              }
              case 65:

              case 66:

              case 67:

              case 68:

              case 69:

              case 70:
              {
                vpack$$1$$1$$1$$4$$byte = vpack$$1$$1$$1$$4$$byte | (unsigned char)(((signed int)nybble - 65) + 10 << vpack$$1$$1$$1$$4$$shift);
                break;
              }
              default:
              {
                return_value_set_errno$34=set_errno(22);
                return (signed long int)return_value_set_errno$34;
              }
            }
            vpack$$1$$1$$1$$4$$shift = vpack$$1$$1$$1$$4$$shift - 4;
            if(vpack$$1$$1$$1$$4$$shift == -4)
            {
              tmp_post$35 = p;
              p = p + 1l;
              *tmp_post$35 = vpack$$1$$1$$1$$4$$byte;
              vpack$$1$$1$$1$$4$$byte = (unsigned char)0x00;
              vpack$$1$$1$$1$$4$$shift = 4;
            }

          }
          while((_Bool)1);
          if(!(vpack$$1$$1$$1$$4$$shift == 4))
          {
            tmp_post$36 = p;
            p = p + 1l;
            *tmp_post$36 = vpack$$1$$1$$1$$4$$byte;
          }

          break;
        }
        case 99:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$37=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$37));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$37;
          }

          else
          {
            return_value___ctype_b_loc$39=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$39)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$38=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$38)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$40=set_errno(22);
            return (signed long int)return_value_set_errno$40;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$41=set_errno(28);
            return (signed long int)return_value_set_errno$41;
          }

          do
          {
            tmp_post$42 = count;
            count = count - 1ul;
            if(tmp_post$42 == 0ul)
              break;

            tmp_post$43 = p;
            p = p + 1l;
            return_value_gcc_builtin_va_arg$44=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$44));
            *tmp_post$43 = (unsigned char)return_value_gcc_builtin_va_arg$44;
          }
          while((_Bool)1);
          break;
        }
        case 115:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$45=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$45));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$45;
          }

          else
          {
            return_value___ctype_b_loc$47=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$47)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$46=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$46)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$48=set_errno(22);
            return (signed long int)return_value_set_errno$48;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno$49=set_errno(28);
            return (signed long int)return_value_set_errno$49;
          }

          do
          {
            tmp_post$50 = count;
            count = count - 1ul;
            if(tmp_post$50 == 0ul)
              break;

            unsigned short int data;
            signed int return_value_gcc_builtin_va_arg$51;
            return_value_gcc_builtin_va_arg$51=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$51));
            data = (unsigned short int)return_value_gcc_builtin_va_arg$51;
            tmp_post$52 = p;
            p = p + 1l;
            *tmp_post$52 = (unsigned char)((signed int)data >> 8 & 0xff);
            tmp_post$53 = p;
            p = p + 1l;
            *tmp_post$53 = (unsigned char)((signed int)data & 0xff);
          }
          while((_Bool)1);
          break;
        }
        case 105:

        case 112:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$54=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$54));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$54;
          }

          else
          {
            return_value___ctype_b_loc$56=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$56)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$55=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$55)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$57=set_errno(22);
            return (signed long int)return_value_set_errno$57;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno$58=set_errno(28);
            return (signed long int)return_value_set_errno$58;
          }

          do
          {
            tmp_post$59 = count;
            count = count - 1ul;
            if(tmp_post$59 == 0ul)
              break;

            unsigned long int vpack$$1$$1$$1$$7$$2$$data;
            signed int return_value_gcc_builtin_va_arg$60;
            return_value_gcc_builtin_va_arg$60=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$60));
            vpack$$1$$1$$1$$7$$2$$data = (unsigned long int)return_value_gcc_builtin_va_arg$60;
            tmp_post$61 = p;
            p = p + 1l;
            *tmp_post$61 = (unsigned char)(vpack$$1$$1$$1$$7$$2$$data >> 24 & (unsigned long int)0xff);
            tmp_post$62 = p;
            p = p + 1l;
            *tmp_post$62 = (unsigned char)(vpack$$1$$1$$1$$7$$2$$data >> 16 & (unsigned long int)0xff);
            tmp_post$63 = p;
            p = p + 1l;
            *tmp_post$63 = (unsigned char)(vpack$$1$$1$$1$$7$$2$$data >> 8 & (unsigned long int)0xff);
            tmp_post$64 = p;
            p = p + 1l;
            *tmp_post$64 = (unsigned char)(vpack$$1$$1$$1$$7$$2$$data & (unsigned long int)0xff);
          }
          while((_Bool)1);
          break;
        }
        case 108:

        case 80:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$65=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$65));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$65;
          }

          else
          {
            return_value___ctype_b_loc$67=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$67)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$66=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$66)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$68=set_errno(22);
            return (signed long int)return_value_set_errno$68;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 3)))
          {
            return_value_set_errno$69=set_errno(28);
            return (signed long int)return_value_set_errno$69;
          }

          do
          {
            tmp_post$70 = count;
            count = count - 1ul;
            if(tmp_post$70 == 0ul)
              break;

            unsigned long long int vpack$$1$$1$$1$$8$$2$$data;
            signed long long int return_value_gcc_builtin_va_arg$71;
            return_value_gcc_builtin_va_arg$71=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$71));
            vpack$$1$$1$$1$$8$$2$$data = (unsigned long long int)return_value_gcc_builtin_va_arg$71;
            tmp_post$72 = p;
            p = p + 1l;
            *tmp_post$72 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data >> 56 & (unsigned long int)0xff);
            tmp_post$73 = p;
            p = p + 1l;
            *tmp_post$73 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data >> 48 & (unsigned long int)0xff);
            tmp_post$74 = p;
            p = p + 1l;
            *tmp_post$74 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data >> 40 & (unsigned long int)0xff);
            tmp_post$75 = p;
            p = p + 1l;
            *tmp_post$75 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data >> 32 & (unsigned long int)0xff);
            tmp_post$76 = p;
            p = p + 1l;
            *tmp_post$76 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data >> 24 & (unsigned long int)0xff);
            tmp_post$77 = p;
            p = p + 1l;
            *tmp_post$77 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data >> 16 & (unsigned long int)0xff);
            tmp_post$78 = p;
            p = p + 1l;
            *tmp_post$78 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data >> 8 & (unsigned long int)0xff);
            tmp_post$79 = p;
            p = p + 1l;
            *tmp_post$79 = (unsigned char)(vpack$$1$$1$$1$$8$$2$$data & (unsigned long int)0xff);
          }
          while((_Bool)1);
          break;
        }
        case 102:

        case 100:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$80=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$80));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$80;
          }

          else
          {
            return_value___ctype_b_loc$82=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$82)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$81=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$81)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$83=set_errno(22);
            return (signed long int)return_value_set_errno$83;
          }

          do
          {
            tmp_post$84 = count;
            count = count - 1ul;
            if(tmp_post$84 == 0ul)
              break;

            double vpack$$1$$1$$1$$9$$2$$data;
            vpack$$1$$1$$1$$9$$2$$data=va_arg(args, __typeof__(vpack$$1$$1$$1$$9$$2$$data));
            signed int rc;
            rc=snprintf(tmp, (unsigned long int)128, "%g", vpack$$1$$1$$1$$9$$2$$data);
            unsigned long int len;
            if(rc == -1 || rc >= 128)
            {
              return_value_set_errno$85=set_errno(28);
              return (signed long int)return_value_set_errno$85;
            }

            unsigned long int return_value_strlen$86;
            return_value_strlen$86=strlen(tmp);
            len = return_value_strlen$86 + (unsigned long int)1;
            if(!(pkt + (signed long int)size >= p + 1l + (signed long int)len))
            {
              return_value_set_errno$87=set_errno(28);
              return (signed long int)return_value_set_errno$87;
            }

            tmp_post$88 = p;
            p = p + 1l;
            *tmp_post$88 = (unsigned char)(len & (unsigned long int)0xff);
            memcpy((void *)p, (const void *)tmp, len);
            p = p + (signed long int)len;
          }
          while((_Bool)1);
          break;
        }
        case 118:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$89=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$89));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$89;
          }

          else
          {
            return_value___ctype_b_loc$91=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$91)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$90=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$90)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$92=set_errno(22);
            return (signed long int)return_value_set_errno$92;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno$93=set_errno(28);
            return (signed long int)return_value_set_errno$93;
          }

          do
          {
            tmp_post$94 = count;
            count = count - 1ul;
            if(tmp_post$94 == 0ul)
              break;

            unsigned short int vpack$$1$$1$$1$$10$$2$$data;
            signed int return_value_gcc_builtin_va_arg$95;
            return_value_gcc_builtin_va_arg$95=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$95));
            vpack$$1$$1$$1$$10$$2$$data = (unsigned short int)return_value_gcc_builtin_va_arg$95;
            tmp_post$96 = p;
            p = p + 1l;
            *tmp_post$96 = (unsigned char)((signed int)vpack$$1$$1$$1$$10$$2$$data & 0xff);
            tmp_post$97 = p;
            p = p + 1l;
            *tmp_post$97 = (unsigned char)((signed int)vpack$$1$$1$$1$$10$$2$$data >> 8 & 0xff);
          }
          while((_Bool)1);
          break;
        }
        case 119:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$98=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$98));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$98;
          }

          else
          {
            return_value___ctype_b_loc$100=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$100)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$99=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$99)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$101=set_errno(22);
            return (signed long int)return_value_set_errno$101;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno$102=set_errno(28);
            return (signed long int)return_value_set_errno$102;
          }

          do
          {
            tmp_post$103 = count;
            count = count - 1ul;
            if(tmp_post$103 == 0ul)
              break;

            unsigned int vpack$$1$$1$$1$$11$$2$$data;
            signed int return_value_gcc_builtin_va_arg$104;
            return_value_gcc_builtin_va_arg$104=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$104));
            vpack$$1$$1$$1$$11$$2$$data = (unsigned int)return_value_gcc_builtin_va_arg$104;
            tmp_post$105 = p;
            p = p + 1l;
            *tmp_post$105 = (unsigned char)(vpack$$1$$1$$1$$11$$2$$data & (unsigned int)0xff);
            tmp_post$106 = p;
            p = p + 1l;
            *tmp_post$106 = (unsigned char)(vpack$$1$$1$$1$$11$$2$$data >> 8 & (unsigned int)0xff);
            tmp_post$107 = p;
            p = p + 1l;
            *tmp_post$107 = (unsigned char)(vpack$$1$$1$$1$$11$$2$$data >> 16 & (unsigned int)0xff);
            tmp_post$108 = p;
            p = p + 1l;
            *tmp_post$108 = (unsigned char)(vpack$$1$$1$$1$$11$$2$$data >> 24 & (unsigned int)0xff);
          }
          while((_Bool)1);
          break;
        }
        case 120:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$109=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$109));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$109;
          }

          else
          {
            return_value___ctype_b_loc$111=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$111)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$110=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$110)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$112=set_errno(22);
            return (signed long int)return_value_set_errno$112;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$113=set_errno(28);
            return (signed long int)return_value_set_errno$113;
          }

          memset((void *)p, 0, count);
          p = p + (signed long int)count;
          break;
        }
        case 88:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$114=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$114));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$114;
          }

          else
          {
            return_value___ctype_b_loc$116=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$116)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$115=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$115)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$117=set_errno(22);
            return (signed long int)return_value_set_errno$117;
          }

          if(!(p + -((signed long int)count) >= pkt))
          {
            return_value_set_errno$118=set_errno(22);
            return (signed long int)return_value_set_errno$118;
          }

          p = p - (signed long int)count;
          break;
        }
        case 64:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$119=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$119));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$119;
          }

          else
          {
            return_value___ctype_b_loc$121=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$121)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$120=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$120)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$122=set_errno(22);
            return (signed long int)return_value_set_errno$122;
          }

          if(!(size >= count))
          {
            return_value_set_errno$123=set_errno(28);
            return (signed long int)return_value_set_errno$123;
          }

          if(!(pkt + (signed long int)count >= p))
          {
            return_value_set_errno$124=set_errno(22);
            return (signed long int)return_value_set_errno$124;
          }

          memset((void *)p, 0, count - (unsigned long int)(p - pkt));
          p = p + (signed long int)(count - (unsigned long int)(p - pkt));
          break;
        }
        default:
        {
          return_value_set_errno$125=set_errno(22);
          return (signed long int)return_value_set_errno$125;
        }
      }
    }
    return p - pkt;
  }
}

// vunpack
// file libslack/net.c line 3400
signed long int vunpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args)
{
  unsigned char *pkt = (unsigned char *)buf;
  unsigned char *p = pkt;
  unsigned long int count;
  unsigned long int limit;
  signed int return_value_set_errno$1;
  const char *tmp_post$2;
  void *data;
  signed int return_value_gcc_builtin_va_arg$3;
  signed int return_value_set_errno$4;
  const unsigned short int **return_value___ctype_b_loc$6;
  const unsigned short int **return_value___ctype_b_loc$5;
  signed int return_value_set_errno$7;
  signed int return_value_set_errno$8;
  signed int return_value_set_errno$9;
  char *vunpack$$1$$1$$1$$2$$data;
  unsigned long int len;
  signed int return_value_gcc_builtin_va_arg$10;
  signed int return_value_set_errno$11;
  const unsigned short int **return_value___ctype_b_loc$13;
  const unsigned short int **return_value___ctype_b_loc$12;
  signed int return_value_set_errno$14;
  signed int return_value_set_errno$15;
  signed int return_value_set_errno$16;
  _Bool tmp_if_expr$17;
  char vunpack$$1$$1$$1$$3$$bin[3l];
  char *vunpack$$1$$1$$1$$3$$data;
  signed int vunpack$$1$$1$$1$$3$$shift;
  signed int return_value_gcc_builtin_va_arg$18;
  signed int return_value_set_errno$19;
  const unsigned short int **return_value___ctype_b_loc$21;
  const unsigned short int **return_value___ctype_b_loc$20;
  signed int return_value_set_errno$22;
  signed int return_value_set_errno$23;
  signed int return_value_set_errno$24;
  unsigned long int tmp_post$25;
  char *tmp_post$26;
  char vunpack$$1$$1$$1$$4$$hex[17l];
  char *vunpack$$1$$1$$1$$4$$data;
  signed int shift;
  signed int return_value_gcc_builtin_va_arg$27;
  signed int return_value_set_errno$28;
  const unsigned short int **return_value___ctype_b_loc$30;
  const unsigned short int **return_value___ctype_b_loc$29;
  signed int return_value_set_errno$31;
  signed int return_value_set_errno$32;
  signed int return_value_set_errno$33;
  unsigned long int tmp_post$34;
  char *tmp_post$35;
  signed int return_value_gcc_builtin_va_arg$36;
  const unsigned short int **return_value___ctype_b_loc$38;
  const unsigned short int **return_value___ctype_b_loc$37;
  signed int return_value_set_errno$39;
  signed int return_value_set_errno$40;
  unsigned long int tmp_post$41;
  unsigned char *tmp_post$42;
  signed int return_value_gcc_builtin_va_arg$43;
  const unsigned short int **return_value___ctype_b_loc$45;
  const unsigned short int **return_value___ctype_b_loc$44;
  signed int return_value_set_errno$46;
  signed int return_value_set_errno$47;
  unsigned long int tmp_post$48;
  unsigned char *tmp_post$49;
  unsigned char *tmp_post$50;
  signed int return_value_gcc_builtin_va_arg$51;
  const unsigned short int **return_value___ctype_b_loc$53;
  const unsigned short int **return_value___ctype_b_loc$52;
  signed int return_value_set_errno$54;
  signed int return_value_set_errno$55;
  unsigned long int tmp_post$56;
  unsigned char *tmp_post$57;
  unsigned char *tmp_post$58;
  unsigned char *tmp_post$59;
  unsigned char *tmp_post$60;
  signed int return_value_gcc_builtin_va_arg$61;
  const unsigned short int **return_value___ctype_b_loc$63;
  const unsigned short int **return_value___ctype_b_loc$62;
  signed int return_value_set_errno$64;
  signed int return_value_set_errno$65;
  unsigned long int tmp_post$66;
  unsigned char *tmp_post$67;
  unsigned char *tmp_post$68;
  signed int return_value_gcc_builtin_va_arg$69;
  const unsigned short int **return_value___ctype_b_loc$71;
  const unsigned short int **return_value___ctype_b_loc$70;
  signed int return_value_set_errno$72;
  signed int return_value_set_errno$73;
  unsigned long int tmp_post$74;
  unsigned char *tmp_post$75;
  unsigned char *tmp_post$76;
  unsigned char *tmp_post$77;
  unsigned char *tmp_post$78;
  signed int return_value_gcc_builtin_va_arg$79;
  const unsigned short int **return_value___ctype_b_loc$81;
  const unsigned short int **return_value___ctype_b_loc$80;
  signed int return_value_set_errno$82;
  signed int return_value_set_errno$83;
  unsigned long int tmp_post$84;
  unsigned char *tmp_post$85;
  unsigned char *tmp_post$86;
  unsigned char *tmp_post$87;
  unsigned char *tmp_post$88;
  unsigned char *tmp_post$89;
  unsigned char *tmp_post$90;
  unsigned char *tmp_post$91;
  unsigned char *tmp_post$92;
  signed int return_value_gcc_builtin_va_arg$93;
  const unsigned short int **return_value___ctype_b_loc$95;
  const unsigned short int **return_value___ctype_b_loc$94;
  signed int return_value_set_errno$96;
  unsigned long int tmp_post$97;
  signed int return_value_set_errno$98;
  unsigned char *tmp_post$99;
  signed int return_value_set_errno$100;
  signed int return_value_gcc_builtin_va_arg$101;
  const unsigned short int **return_value___ctype_b_loc$103;
  const unsigned short int **return_value___ctype_b_loc$102;
  signed int return_value_set_errno$104;
  unsigned long int tmp_post$105;
  signed int return_value_set_errno$106;
  unsigned char *tmp_post$107;
  signed int return_value_set_errno$108;
  signed int return_value_gcc_builtin_va_arg$109;
  const unsigned short int **return_value___ctype_b_loc$111;
  const unsigned short int **return_value___ctype_b_loc$110;
  signed int return_value_set_errno$112;
  signed int return_value_set_errno$113;
  signed int return_value_gcc_builtin_va_arg$114;
  const unsigned short int **return_value___ctype_b_loc$116;
  const unsigned short int **return_value___ctype_b_loc$115;
  signed int return_value_set_errno$117;
  signed int return_value_set_errno$118;
  signed int return_value_gcc_builtin_va_arg$119;
  const unsigned short int **return_value___ctype_b_loc$121;
  const unsigned short int **return_value___ctype_b_loc$120;
  signed int return_value_set_errno$122;
  signed int return_value_set_errno$123;
  signed int return_value_set_errno$124;
  signed int return_value_set_errno$125;
  if(format == ((const char *)NULL) || pkt == ((unsigned char *)NULL))
  {
    return_value_set_errno$1=set_errno(22);
    return (signed long int)return_value_set_errno$1;
  }

  else
  {
    while(!(*format == 0))
    {
      char f;
      tmp_post$2 = format;
      format = format + 1l;
      f = *tmp_post$2;
      if((signed int)f == 112)
        f = (char)80;

      switch((signed int)f)
      {
        case 97:
        {
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$3=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$3));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$3;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *vunpack$$1$$1$$1$$1$$1$$countp;
              vunpack$$1$$1$$1$$1$$1$$countp=va_arg(args, __typeof__(vunpack$$1$$1$$1$$1$$1$$countp));
              if(vunpack$$1$$1$$1$$1$$1$$countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno$4=set_errno(22);
                return (signed long int)return_value_set_errno$4;
              }

              count = *vunpack$$1$$1$$1$$1$$1$$countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc$6=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc$5=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno$7=set_errno(22);
            return (signed long int)return_value_set_errno$7;
          }

          if(!(limit >= count))
          {
            return_value_set_errno$8=set_errno(28);
            return (signed long int)return_value_set_errno$8;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$9=set_errno(28);
            return (signed long int)return_value_set_errno$9;
          }

          data=va_arg(args, __typeof__(data));
          if(data == NULL)
          {
            p = p + (signed long int)count;
            break;
          }

          memcpy(data, (const void *)p, count);
          p = p + (signed long int)count;
          break;
        }
        case 122:
        {
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$10=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$10));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$10;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *vunpack$$1$$1$$1$$2$$1$$countp;
              vunpack$$1$$1$$1$$2$$1$$countp=va_arg(args, __typeof__(vunpack$$1$$1$$1$$2$$1$$countp));
              if(vunpack$$1$$1$$1$$2$$1$$countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno$11=set_errno(22);
                return (signed long int)return_value_set_errno$11;
              }

              count = *vunpack$$1$$1$$1$$2$$1$$countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc$13=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc$12=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno$14=set_errno(22);
            return (signed long int)return_value_set_errno$14;
          }

          if(!(limit >= count))
          {
            return_value_set_errno$15=set_errno(28);
            return (signed long int)return_value_set_errno$15;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$16=set_errno(28);
            return (signed long int)return_value_set_errno$16;
          }

          vunpack$$1$$1$$1$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$2$$data));
          if(vunpack$$1$$1$$1$$2$$data == ((char *)NULL))
          {
            p = p + (signed long int)count;
            break;
          }

          len = (unsigned long int)0;
          do
          {
            if(!(p + (signed long int)len >= pkt + (signed long int)size))
              tmp_if_expr$17 = p[(signed long int)len] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$17 = (_Bool)0;
            if(!tmp_if_expr$17)
              break;

            len = len + 1ul;
          }
          while((_Bool)1);
          if(!(count >= len))
            len = count;

          memcpy((void *)vunpack$$1$$1$$1$$2$$data, (const void *)p, len);
          p = p + (signed long int)len;
          count = count - len;
          memset((void *)(vunpack$$1$$1$$1$$2$$data + (signed long int)len), 0, count != 0ul ? count : (unsigned long int)1);
          p = p + (signed long int)count;
          break;
        }
        case 98:
        {
          vunpack$$1$$1$$1$$3$$bin[0] = '0';
          vunpack$$1$$1$$1$$3$$bin[1] = '1';
          vunpack$$1$$1$$1$$3$$bin[2] = 0;
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$18=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$18));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$18;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *vunpack$$1$$1$$1$$3$$1$$countp;
              vunpack$$1$$1$$1$$3$$1$$countp=va_arg(args, __typeof__(vunpack$$1$$1$$1$$3$$1$$countp));
              if(vunpack$$1$$1$$1$$3$$1$$countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno$19=set_errno(22);
                return (signed long int)return_value_set_errno$19;
              }

              count = *vunpack$$1$$1$$1$$3$$1$$countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc$21=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$21)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc$20=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc$20)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno$22=set_errno(22);
            return (signed long int)return_value_set_errno$22;
          }

          if(!(limit >= count))
          {
            return_value_set_errno$23=set_errno(28);
            return (signed long int)return_value_set_errno$23;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(7ul + count >> 3)))
          {
            return_value_set_errno$24=set_errno(28);
            return (signed long int)return_value_set_errno$24;
          }

          vunpack$$1$$1$$1$$3$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$3$$data));
          if(vunpack$$1$$1$$1$$3$$data == ((char *)NULL))
          {
            p = p + (signed long int)(count + (unsigned long int)7 >> 3);
            break;
          }

          vunpack$$1$$1$$1$$3$$shift = 7;
          do
          {
            tmp_post$25 = count;
            count = count - 1ul;
            if(tmp_post$25 == 0ul)
              break;

            tmp_post$26 = vunpack$$1$$1$$1$$3$$data;
            vunpack$$1$$1$$1$$3$$data = vunpack$$1$$1$$1$$3$$data + 1l;
            *tmp_post$26 = vunpack$$1$$1$$1$$3$$bin[(signed long int)(((signed int)*p & 0x01 << vunpack$$1$$1$$1$$3$$shift) >> vunpack$$1$$1$$1$$3$$shift)];
            vunpack$$1$$1$$1$$3$$shift = vunpack$$1$$1$$1$$3$$shift - 1;
            if(vunpack$$1$$1$$1$$3$$shift == -1)
            {
              p = p + 1l;
              vunpack$$1$$1$$1$$3$$shift = 7;
            }

          }
          while((_Bool)1);
          if(!(vunpack$$1$$1$$1$$3$$shift == 7))
            p = p + 1l;

          *vunpack$$1$$1$$1$$3$$data = (char)0;
          break;
        }
        case 104:
        {
          vunpack$$1$$1$$1$$4$$hex[0] = '0';
          vunpack$$1$$1$$1$$4$$hex[1] = '1';
          vunpack$$1$$1$$1$$4$$hex[2] = '2';
          vunpack$$1$$1$$1$$4$$hex[3] = '3';
          vunpack$$1$$1$$1$$4$$hex[4] = '4';
          vunpack$$1$$1$$1$$4$$hex[5] = '5';
          vunpack$$1$$1$$1$$4$$hex[6] = '6';
          vunpack$$1$$1$$1$$4$$hex[7] = '7';
          vunpack$$1$$1$$1$$4$$hex[8] = '8';
          vunpack$$1$$1$$1$$4$$hex[9] = '9';
          vunpack$$1$$1$$1$$4$$hex[10] = 'a';
          vunpack$$1$$1$$1$$4$$hex[11] = 'b';
          vunpack$$1$$1$$1$$4$$hex[12] = 'c';
          vunpack$$1$$1$$1$$4$$hex[13] = 'd';
          vunpack$$1$$1$$1$$4$$hex[14] = 'e';
          vunpack$$1$$1$$1$$4$$hex[15] = 'f';
          vunpack$$1$$1$$1$$4$$hex[16] = 0;
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$27=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$27));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$27;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *countp;
              countp=va_arg(args, __typeof__(countp));
              if(countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno$28=set_errno(22);
                return (signed long int)return_value_set_errno$28;
              }

              count = *countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc$30=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$30)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc$29=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc$29)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno$31=set_errno(22);
            return (signed long int)return_value_set_errno$31;
          }

          if(!(limit >= count))
          {
            return_value_set_errno$32=set_errno(28);
            return (signed long int)return_value_set_errno$32;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(1ul + count >> 1)))
          {
            return_value_set_errno$33=set_errno(28);
            return (signed long int)return_value_set_errno$33;
          }

          vunpack$$1$$1$$1$$4$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$4$$data));
          if(vunpack$$1$$1$$1$$4$$data == ((char *)NULL))
          {
            p = p + (signed long int)(count + (unsigned long int)1 >> 1);
            break;
          }

          shift = 4;
          do
          {
            tmp_post$34 = count;
            count = count - 1ul;
            if(tmp_post$34 == 0ul)
              break;

            tmp_post$35 = vunpack$$1$$1$$1$$4$$data;
            vunpack$$1$$1$$1$$4$$data = vunpack$$1$$1$$1$$4$$data + 1l;
            *tmp_post$35 = vunpack$$1$$1$$1$$4$$hex[(signed long int)(((signed int)*p & 0x0f << shift) >> shift)];
            shift = shift - 4;
            if(shift == -4)
            {
              p = p + 1l;
              shift = 4;
            }

          }
          while((_Bool)1);
          if(!(shift == 4))
            p = p + 1l;

          *vunpack$$1$$1$$1$$4$$data = (char)0;
          break;
        }
        case 99:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$36=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$36));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$36;
          }

          else
          {
            return_value___ctype_b_loc$38=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$38)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$37=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$37)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$39=set_errno(22);
            return (signed long int)return_value_set_errno$39;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$40=set_errno(28);
            return (signed long int)return_value_set_errno$40;
          }

          do
          {
            tmp_post$41 = count;
            count = count - 1ul;
            if(tmp_post$41 == 0ul)
              break;

            signed char *vunpack$$1$$1$$1$$5$$2$$data;
            vunpack$$1$$1$$1$$5$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$5$$2$$data));
            if(vunpack$$1$$1$$1$$5$$2$$data == ((signed char *)NULL))
              p = p + (signed long int)1;

            else
            {
              tmp_post$42 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$5$$2$$data = (signed char)*tmp_post$42;
            }
          }
          while((_Bool)1);
          break;
        }
        case 115:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$43=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$43));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$43;
          }

          else
          {
            return_value___ctype_b_loc$45=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$45)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$44=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$44)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$46=set_errno(22);
            return (signed long int)return_value_set_errno$46;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno$47=set_errno(28);
            return (signed long int)return_value_set_errno$47;
          }

          do
          {
            tmp_post$48 = count;
            count = count - 1ul;
            if(tmp_post$48 == 0ul)
              break;

            signed short int *vunpack$$1$$1$$1$$6$$2$$data;
            vunpack$$1$$1$$1$$6$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$6$$2$$data));
            if(vunpack$$1$$1$$1$$6$$2$$data == ((signed short int *)NULL))
              p = p + (signed long int)2;

            else
            {
              tmp_post$49 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$6$$2$$data = (signed short int)((signed int)(signed short int)*tmp_post$49 << 8);
              tmp_post$50 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$6$$2$$data = *vunpack$$1$$1$$1$$6$$2$$data | (signed short int)*tmp_post$50;
            }
          }
          while((_Bool)1);
          break;
        }
        case 105:

        case 112:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$51=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$51));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$51;
          }

          else
          {
            return_value___ctype_b_loc$53=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$53)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$52=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$52)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$54=set_errno(22);
            return (signed long int)return_value_set_errno$54;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno$55=set_errno(28);
            return (signed long int)return_value_set_errno$55;
          }

          do
          {
            tmp_post$56 = count;
            count = count - 1ul;
            if(tmp_post$56 == 0ul)
              break;

            signed int *vunpack$$1$$1$$1$$7$$2$$data;
            vunpack$$1$$1$$1$$7$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$7$$2$$data));
            if(vunpack$$1$$1$$1$$7$$2$$data == ((signed int *)NULL))
              p = p + (signed long int)4;

            else
            {
              tmp_post$57 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$7$$2$$data = (signed int)*tmp_post$57 << 24;
              tmp_post$58 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$7$$2$$data = *vunpack$$1$$1$$1$$7$$2$$data | (signed int)*tmp_post$58 << 16;
              tmp_post$59 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$7$$2$$data = *vunpack$$1$$1$$1$$7$$2$$data | (signed int)*tmp_post$59 << 8;
              tmp_post$60 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$7$$2$$data = *vunpack$$1$$1$$1$$7$$2$$data | (signed int)*tmp_post$60;
            }
          }
          while((_Bool)1);
          break;
        }
        case 118:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$61=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$61));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$61;
          }

          else
          {
            return_value___ctype_b_loc$63=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$63)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$62=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$62)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$64=set_errno(22);
            return (signed long int)return_value_set_errno$64;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno$65=set_errno(28);
            return (signed long int)return_value_set_errno$65;
          }

          do
          {
            tmp_post$66 = count;
            count = count - 1ul;
            if(tmp_post$66 == 0ul)
              break;

            signed short int *vunpack$$1$$1$$1$$8$$2$$data;
            vunpack$$1$$1$$1$$8$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$8$$2$$data));
            if(vunpack$$1$$1$$1$$8$$2$$data == ((signed short int *)NULL))
              p = p + (signed long int)2;

            else
            {
              tmp_post$67 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$8$$2$$data = (signed short int)*tmp_post$67;
              tmp_post$68 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$8$$2$$data = *vunpack$$1$$1$$1$$8$$2$$data | (signed short int)((signed int)(unsigned short int)*tmp_post$68 << 8);
            }
          }
          while((_Bool)1);
          break;
        }
        case 119:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$69=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$69));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$69;
          }

          else
          {
            return_value___ctype_b_loc$71=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$71)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$70=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$70)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$72=set_errno(22);
            return (signed long int)return_value_set_errno$72;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno$73=set_errno(28);
            return (signed long int)return_value_set_errno$73;
          }

          do
          {
            tmp_post$74 = count;
            count = count - 1ul;
            if(tmp_post$74 == 0ul)
              break;

            signed int *vunpack$$1$$1$$1$$9$$2$$data;
            vunpack$$1$$1$$1$$9$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$9$$2$$data));
            if(vunpack$$1$$1$$1$$9$$2$$data == ((signed int *)NULL))
              p = p + (signed long int)4;

            else
            {
              tmp_post$75 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$9$$2$$data = (signed int)(signed long int)*tmp_post$75;
              tmp_post$76 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$9$$2$$data = *vunpack$$1$$1$$1$$9$$2$$data | (signed int)((signed long int)*tmp_post$76 << 8);
              tmp_post$77 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$9$$2$$data = *vunpack$$1$$1$$1$$9$$2$$data | (signed int)((signed long int)*tmp_post$77 << 16);
              tmp_post$78 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$9$$2$$data = *vunpack$$1$$1$$1$$9$$2$$data | (signed int)((signed long int)*tmp_post$78 << 24);
            }
          }
          while((_Bool)1);
          break;
        }
        case 108:

        case 80:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$79=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$79));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$79;
          }

          else
          {
            return_value___ctype_b_loc$81=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$81)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$80=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$80)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$82=set_errno(22);
            return (signed long int)return_value_set_errno$82;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 3)))
          {
            return_value_set_errno$83=set_errno(28);
            return (signed long int)return_value_set_errno$83;
          }

          do
          {
            tmp_post$84 = count;
            count = count - 1ul;
            if(tmp_post$84 == 0ul)
              break;

            signed long long int *vunpack$$1$$1$$1$$10$$2$$data;
            vunpack$$1$$1$$1$$10$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$10$$2$$data));
            if(vunpack$$1$$1$$1$$10$$2$$data == ((signed long long int *)NULL))
              p = p + (signed long int)8;

            else
            {
              tmp_post$85 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = (signed long long int)*tmp_post$85 << 56;
              tmp_post$86 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = *vunpack$$1$$1$$1$$10$$2$$data | (signed long long int)*tmp_post$86 << 48;
              tmp_post$87 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = *vunpack$$1$$1$$1$$10$$2$$data | (signed long long int)*tmp_post$87 << 40;
              tmp_post$88 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = *vunpack$$1$$1$$1$$10$$2$$data | (signed long long int)*tmp_post$88 << 32;
              tmp_post$89 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = *vunpack$$1$$1$$1$$10$$2$$data | (signed long long int)*tmp_post$89 << 24;
              tmp_post$90 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = *vunpack$$1$$1$$1$$10$$2$$data | (signed long long int)*tmp_post$90 << 16;
              tmp_post$91 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = *vunpack$$1$$1$$1$$10$$2$$data | (signed long long int)*tmp_post$91 << 8;
              tmp_post$92 = p;
              p = p + 1l;
              *vunpack$$1$$1$$1$$10$$2$$data = *vunpack$$1$$1$$1$$10$$2$$data | (signed long long int)*tmp_post$92;
            }
          }
          while((_Bool)1);
          break;
        }
        case 102:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$93=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$93));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$93;
          }

          else
          {
            return_value___ctype_b_loc$95=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$95)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$94=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$94)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$96=set_errno(22);
            return (signed long int)return_value_set_errno$96;
          }

          do
          {
            tmp_post$97 = count;
            count = count - 1ul;
            if(tmp_post$97 == 0ul)
              break;

            float *vunpack$$1$$1$$1$$11$$2$$data;
            vunpack$$1$$1$$1$$11$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$11$$2$$data));
            unsigned long int vunpack$$1$$1$$1$$11$$2$$len;
            if(!(pkt + (signed long int)size >= p + 1l))
            {
              return_value_set_errno$98=set_errno(28);
              return (signed long int)return_value_set_errno$98;
            }

            tmp_post$99 = p;
            p = p + 1l;
            vunpack$$1$$1$$1$$11$$2$$len = (unsigned long int)*tmp_post$99;
            if(!(pkt + (signed long int)size >= p + (signed long int)vunpack$$1$$1$$1$$11$$2$$len))
            {
              return_value_set_errno$100=set_errno(28);
              return (signed long int)return_value_set_errno$100;
            }

            if(vunpack$$1$$1$$1$$11$$2$$data == ((float *)NULL))
              p = p + (signed long int)vunpack$$1$$1$$1$$11$$2$$len;

            else
            {
              sscanf((const char *)p, "%g", vunpack$$1$$1$$1$$11$$2$$data);
              p = p + (signed long int)vunpack$$1$$1$$1$$11$$2$$len;
            }
          }
          while((_Bool)1);
          break;
        }
        case 100:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$101=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$101));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$101;
          }

          else
          {
            return_value___ctype_b_loc$103=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$103)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$102=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$102)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$104=set_errno(22);
            return (signed long int)return_value_set_errno$104;
          }

          do
          {
            tmp_post$105 = count;
            count = count - 1ul;
            if(tmp_post$105 == 0ul)
              break;

            double *vunpack$$1$$1$$1$$12$$2$$data;
            vunpack$$1$$1$$1$$12$$2$$data=va_arg(args, __typeof__(vunpack$$1$$1$$1$$12$$2$$data));
            unsigned long int vunpack$$1$$1$$1$$12$$2$$len;
            if(!(pkt + (signed long int)size >= p + 1l))
            {
              return_value_set_errno$106=set_errno(28);
              return (signed long int)return_value_set_errno$106;
            }

            tmp_post$107 = p;
            p = p + 1l;
            vunpack$$1$$1$$1$$12$$2$$len = (unsigned long int)*tmp_post$107;
            if(!(pkt + (signed long int)size >= p + (signed long int)vunpack$$1$$1$$1$$12$$2$$len))
            {
              return_value_set_errno$108=set_errno(28);
              return (signed long int)return_value_set_errno$108;
            }

            if(vunpack$$1$$1$$1$$12$$2$$data == ((double *)NULL))
              p = p + (signed long int)vunpack$$1$$1$$1$$12$$2$$len;

            else
            {
              sscanf((const char *)p, "%lg", vunpack$$1$$1$$1$$12$$2$$data);
              p = p + (signed long int)vunpack$$1$$1$$1$$12$$2$$len;
            }
          }
          while((_Bool)1);
          break;
        }
        case 120:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$109=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$109));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$109;
          }

          else
          {
            return_value___ctype_b_loc$111=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$111)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$110=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$110)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$112=set_errno(22);
            return (signed long int)return_value_set_errno$112;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno$113=set_errno(28);
            return (signed long int)return_value_set_errno$113;
          }

          p = p + (signed long int)count;
          break;
        }
        case 88:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$114=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$114));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$114;
          }

          else
          {
            return_value___ctype_b_loc$116=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$116)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$115=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$115)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$117=set_errno(22);
            return (signed long int)return_value_set_errno$117;
          }

          if(!(p + -((signed long int)count) >= pkt))
          {
            return_value_set_errno$118=set_errno(22);
            return (signed long int)return_value_set_errno$118;
          }

          p = p - (signed long int)count;
          break;
        }
        case 64:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg$119=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$119));
            count = (unsigned long int)return_value_gcc_builtin_va_arg$119;
          }

          else
          {
            return_value___ctype_b_loc$121=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$121)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc$120=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc$120)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno$122=set_errno(22);
            return (signed long int)return_value_set_errno$122;
          }

          if(!(size >= count))
          {
            return_value_set_errno$123=set_errno(28);
            return (signed long int)return_value_set_errno$123;
          }

          if(!(pkt + (signed long int)count >= p))
          {
            return_value_set_errno$124=set_errno(22);
            return (signed long int)return_value_set_errno$124;
          }

          p = p + (signed long int)(count - (unsigned long int)(p - pkt));
          break;
        }
        default:
        {
          return_value_set_errno$125=set_errno(22);
          return (signed long int)return_value_set_errno$125;
        }
      }
    }
    return p - pkt;
  }
}

// vverbose
// file libslack/err.c line 212
void vverbose(unsigned long int level, const char *format, void **args)
{
  unsigned long int return_value_prog_verbosity_level$5;
  return_value_prog_verbosity_level$5=prog_verbosity_level();
  struct Msg *return_value_prog_out$1;
  const char *return_value_prog_name$2;
  struct Msg *return_value_prog_out$3;
  if(return_value_prog_verbosity_level$5 >= level)
  {
    char mesg[8192l];
    vsnprintf(mesg, (unsigned long int)8192, format, args);
    const char *return_value_prog_name$4;
    return_value_prog_name$4=prog_name();
    if(!(return_value_prog_name$4 == ((const char *)NULL)))
    {
      return_value_prog_out$1=prog_out();
      return_value_prog_name$2=prog_name();
      msg_out(return_value_prog_out$1, "%s: %*s%s\n", return_value_prog_name$2, level, (const void *)"", (const void *)mesg);
    }

    else
    {
      return_value_prog_out$3=prog_out();
      msg_out(return_value_prog_out$3, "%*s%s\n", level, (const void *)"", (const void *)mesg);
    }
  }

}

// write_timeout
// file libslack/fio.c line 246
signed int write_timeout(signed int fd, signed long int sec, signed long int usec)
{
  struct anonymous$10 writefds[1l];
  struct timeval write_timeout$$1$$timeout[1l];
  signed int return_value_set_errno$1;
  if(!(fd >= 0) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno$1=set_errno(22);
    return return_value_set_errno$1;
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&writefds[0l].fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    writefds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = writefds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    write_timeout$$1$$timeout[0l].tv_sec = sec;
    write_timeout$$1$$timeout[0l].tv_usec = usec;
    signed int return_value_select$2;
    return_value_select$2=select(fd + 1, (struct anonymous$10 *)(void *)0, writefds, (struct anonymous$10 *)(void *)0, write_timeout$$1$$timeout);
    if(!(return_value_select$2 == -1))
    {
      if(return_value_select$2 == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_set_errno$3;
      return_value_set_errno$3=set_errno(110);
      return return_value_set_errno$3;
    }
    return 0;
  }
}

