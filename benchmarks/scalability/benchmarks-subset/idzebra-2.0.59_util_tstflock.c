// #anon_enum$XML_ATTRIBUTE_CDATA=1$XML_ATTRIBUTE_ID=2$XML_ATTRIBUTE_IDREF=3$XML_ATTRIBUTE_IDREFS=4$XML_ATTRIBUTE_ENTITY=5$XML_ATTRIBUTE_ENTITIES=6$XML_ATTRIBUTE_NMTOKEN=7$XML_ATTRIBUTE_NMTOKENS=8$XML_ATTRIBUTE_ENUMERATION=9$XML_ATTRIBUTE_NOTATION=10
// file /usr/include/libxml2/libxml/tree.h line 206
enum anonymous$13 { XML_ATTRIBUTE_CDATA=1, XML_ATTRIBUTE_ID=2, XML_ATTRIBUTE_IDREF=3, XML_ATTRIBUTE_IDREFS=4, XML_ATTRIBUTE_ENTITY=5, XML_ATTRIBUTE_ENTITIES=6, XML_ATTRIBUTE_NMTOKEN=7, XML_ATTRIBUTE_NMTOKENS=8, XML_ATTRIBUTE_ENUMERATION=9, XML_ATTRIBUTE_NOTATION=10 };

// #anon_enum$XML_ELEMENT_NODE=1$XML_ATTRIBUTE_NODE=2$XML_TEXT_NODE=3$XML_CDATA_SECTION_NODE=4$XML_ENTITY_REF_NODE=5$XML_ENTITY_NODE=6$XML_PI_NODE=7$XML_COMMENT_NODE=8$XML_DOCUMENT_NODE=9$XML_DOCUMENT_TYPE_NODE=10$XML_DOCUMENT_FRAG_NODE=11$XML_NOTATION_NODE=12$XML_HTML_DOCUMENT_NODE=13$XML_DTD_NODE=14$XML_ELEMENT_DECL=15$XML_ATTRIBUTE_DECL=16$XML_ENTITY_DECL=17$XML_NAMESPACE_DECL=18$XML_XINCLUDE_START=19$XML_XINCLUDE_END=20$XML_DOCB_DOCUMENT_NODE=21
// file /usr/include/libxml2/libxml/tree.h line 159
enum anonymous$10 { XML_ELEMENT_NODE=1, XML_ATTRIBUTE_NODE=2, XML_TEXT_NODE=3, XML_CDATA_SECTION_NODE=4, XML_ENTITY_REF_NODE=5, XML_ENTITY_NODE=6, XML_PI_NODE=7, XML_COMMENT_NODE=8, XML_DOCUMENT_NODE=9, XML_DOCUMENT_TYPE_NODE=10, XML_DOCUMENT_FRAG_NODE=11, XML_NOTATION_NODE=12, XML_HTML_DOCUMENT_NODE=13, XML_DTD_NODE=14, XML_ELEMENT_DECL=15, XML_ATTRIBUTE_DECL=16, XML_ENTITY_DECL=17, XML_NAMESPACE_DECL=18, XML_XINCLUDE_START=19, XML_XINCLUDE_END=20, XML_DOCB_DOCUMENT_NODE=21 };

// tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'op'||*{S8}$S8$'value'|]
// file ../include/zebra_xpath.h line 30
struct anonymous$65;

// tag-#anon#ST[*{SYM#tag-nmem_control#}$SYM#tag-nmem_control#$'nmem'||S32'no_eq'||U32'$pad0'||ARR32{*{S8}$S8$}$*{S8}$S8$$'eq'|]
// file charmap.c line 83
struct anonymous$35;

// tag-#anon#ST[*{cS8}$cS8$'op'||*{SYM#tag-xpath_predicate#}$SYM#tag-xpath_predicate#$'left'||*{SYM#tag-xpath_predicate#}$SYM#tag-xpath_predicate#$'right'|]
// file ../include/zebra_xpath.h line 36
struct anonymous$68;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$92;

// tag-#anon#ST[S32'entry_size'|]
// file zebramap.c line 52
struct anonymous$46;

// tag-#anon#ST[S32'readers_reading'||S32'writers_writing'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'lock_free'|]
// file ../include/zebra-lock.h line 54
struct anonymous$56;

// tag-#anon#ST[S32'type'||S32'major'||S32'minor'||U32'$pad0'||*{*{SYM#tag-Z_AttributeElement#}$SYM#tag-Z_AttributeElement#$}$*{SYM#tag-Z_AttributeElement#}$SYM#tag-Z_AttributeElement#$$'attributeList'||S32'num_attributes'||U32'$pad1'|]
// file ../include/attrfind.h line 28
struct anonymous$89;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mutex'||S32'state'||U32'$pad0'|]
// file ../include/zebra-lock.h line 36
struct anonymous$54;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'cond'|]
// file ../include/zebra-lock.h line 70
struct anonymous$49;

// tag-#anon#UN[*{S16}$S16$'oid'||*{S8}$S8$'uri'|]
// file /usr/include/yaz/z-core.h line 811
union anonymous$62;

// tag-#anon#UN[*{S64}$S64$'actualNumber'||*{S64}$S64$'approxNumber'|]
// file /usr/include/yaz/z-exp.h line 341
union anonymous$64;

// tag-#anon#UN[*{S64}$S64$'integer'||*{S8}$S8$'internationalString'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'octetString'||*{S16}$S16$'objectIdentifier'||*{S32}$S32$'boolean'||*{V}$V$'null'||*{SYM#tag-Z_Unit#}$SYM#tag-Z_Unit#$'unit'||*{SYM#tag-Z_IntUnit#}$SYM#tag-Z_IntUnit#$'valueAndUnit'|]
// file /usr/include/yaz/z-grs.h line 152
union anonymous$59;

// tag-#anon#UN[*{S64}$S64$'integer'||*{S8}$S8$'string'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'octets'||*{S16}$S16$'oid'||*{SYM#tag-Z_Unit#}$SYM#tag-Z_Unit#$'unit'||*{SYM#tag-Z_IntUnit#}$SYM#tag-Z_IntUnit#$'valueAndUnit'|]
// file /usr/include/yaz/z-exp.h line 718
union anonymous$74;

// tag-#anon#UN[*{S64}$S64$'known'||*{S64}$S64$'zprivate'|]
// file /usr/include/yaz/z-core.h line 603
union anonymous$15;

// tag-#anon#UN[*{S64}$S64$'known'||*{SYM#tag-Z_ProxSupportPrivate#}$SYM#tag-Z_ProxSupportPrivate#$'zprivate'|]
// file /usr/include/yaz/z-exp.h line 920
union anonymous$22;

// tag-#anon#UN[*{S64}$S64$'number'||*{S8}$S8$'string'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'opaque'|]
// file /usr/include/yaz/zes-update.h line 117
union anonymous$45;

// tag-#anon#UN[*{S64}$S64$'numeric'||*{SYM#tag-Z_ComplexAttribute#}$SYM#tag-Z_ComplexAttribute#$'complex'|]
// file /usr/include/yaz/z-core.h line 583
union anonymous$8;

// tag-#anon#UN[*{S64}$S64$'primitive'||*{SYM#tag-Z_ElementInfoList#}$SYM#tag-Z_ElementInfoList#$'structured'|]
// file /usr/include/yaz/z-exp.h line 407
union anonymous$70;

// tag-#anon#UN[*{S64}$S64$'req'||*{S64}$S64$'permission'||*{S64}$S64$'immediate'|]
// file /usr/include/yaz/z-diag1.h line 261
union anonymous$2;

// tag-#anon#UN[*{S8}$S8$'character'||*{SYM#tag-Z_Encryption#}$SYM#tag-Z_Encryption#$'encrypted'|]
// file /usr/include/yaz/z-accform1.h line 59
union anonymous$52;

// tag-#anon#UN[*{S8}$S8$'characterInfo'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'binaryInfo'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'externallyDefinedInfo'||*{S16}$S16$'oid'|]
// file /usr/include/yaz/z-core.h line 1282
union anonymous$4;

// tag-#anon#UN[*{S8}$S8$'elementSetName'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'externalSpec'|]
// file /usr/include/yaz/z-core.h line 801
union anonymous$67;

// tag-#anon#UN[*{S8}$S8$'ianaType'||*{S8}$S8$'z3950type'||*{S8}$S8$'otherType'|]
// file /usr/include/yaz/z-exp.h line 789
union anonymous$75;

// tag-#anon#UN[*{S8}$S8$'package'||*{SYM#tag-Z_Query#}$SYM#tag-Z_Query#$'query'|]
// file /usr/include/yaz/zes-pquery.h line 67
union anonymous$94;

// tag-#anon#UN[*{S8}$S8$'packageName'||*{SYM#tag-Z_ESExportSpecification#}$SYM#tag-Z_ESExportSpecification#$'exportPackage'|]
// file /usr/include/yaz/zes-psched.h line 73
union anonymous$96;

// tag-#anon#UN[*{S8}$S8$'packageName'||*{SYM#tag-Z_ESExportSpecification#}$SYM#tag-Z_ESExportSpecification#$'packageSpec'|]
// file /usr/include/yaz/zes-expi.h line 68
union anonymous$87;

// tag-#anon#UN[*{S8}$S8$'phoneNumber'||*{S8}$S8$'faxNumber'||*{S8}$S8$'x400address'||*{S8}$S8$'emailAddress'||*{S8}$S8$'pagerNumber'||*{S8}$S8$'ftpAddress'||*{S8}$S8$'ftamAddress'||*{S8}$S8$'printerAddress'||*{SYM#tag-Z_ESDestinationOther#}$SYM#tag-Z_ESDestinationOther#$'other'|]
// file /usr/include/yaz/zes-exps.h line 71
union anonymous$85;

// tag-#anon#UN[*{S8}$S8$'sortField'||*{SYM#tag-Z_Specification#}$SYM#tag-Z_Specification#$'elementSpec'||*{SYM#tag-Z_SortAttributes#}$SYM#tag-Z_SortAttributes#$'sortAttributes'|]
// file /usr/include/yaz/z-core.h line 1109
union anonymous$83;

// tag-#anon#UN[*{S8}$S8$'string'||*{S32}$S32$'accept'||*{V}$V$'acknowledge'||*{SYM#tag-Z_DiagRec#}$SYM#tag-Z_DiagRec#$'diagnostic'||*{SYM#tag-Z_Encryption#}$SYM#tag-Z_Encryption#$'encrypted'|]
// file /usr/include/yaz/z-accform1.h line 88
union anonymous$55;

// tag-#anon#UN[*{S8}$S8$'string'||*{S64}$S64$'numeric'|]
// file /usr/include/yaz/z-core.h line 1320
union anonymous$7;

// tag-#anon#UN[*{S8}$S8$'timeStamp'||*{S8}$S8$'versionNumber'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'previousVersion'|]
// file /usr/include/yaz/zes-update.h line 105
union anonymous$38;

// tag-#anon#UN[*{S8}$S8$'v2Addinfo'||*{S8}$S8$'v3Addinfo'|]
// file /usr/include/yaz/z-core.h line 745
union anonymous$40;

// tag-#anon#UN[*{SYM#tag-Z_AdminEsRequest#}$SYM#tag-Z_AdminEsRequest#$'esRequest'||*{SYM#tag-Z_AdminTaskPackage#}$SYM#tag-Z_AdminTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-admin.h line 54
union anonymous$19;

// tag-#anon#UN[*{SYM#tag-Z_AttributesPlusTerm#}$SYM#tag-Z_AttributesPlusTerm#$'attributesPlusTerm'||*{S8}$S8$'resultSetId'||*{SYM#tag-Z_ResultSetPlusAttributes#}$SYM#tag-Z_ResultSetPlusAttributes#$'resultAttr'|]
// file /usr/include/yaz/z-core.h line 511
union anonymous$100;

// tag-#anon#UN[*{SYM#tag-Z_Challenge1#}$SYM#tag-Z_Challenge1#$'challenge'||*{SYM#tag-Z_Response1#}$SYM#tag-Z_Response1#$'response'|]
// file /usr/include/yaz/z-accform1.h line 47
union anonymous$39;

// tag-#anon#UN[*{SYM#tag-Z_DRNType#}$SYM#tag-Z_DRNType#$'challenge'||*{SYM#tag-Z_DRNType#}$SYM#tag-Z_DRNType#$'response'|]
// file /usr/include/yaz/z-accdes1.h line 28
union anonymous$43;

// tag-#anon#UN[*{SYM#tag-Z_DateMonthAndDay#}$SYM#tag-Z_DateMonthAndDay#$'monthAndDay'||*{S64}$S64$'julianDay'||*{S64}$S64$'weekNumber'||*{SYM#tag-Z_DateQuarter#}$SYM#tag-Z_DateQuarter#$'quarter'||*{SYM#tag-Z_DateSeason#}$SYM#tag-Z_DateSeason#$'season'|]
// file /usr/include/yaz/z-date.h line 103
union anonymous$41;

// tag-#anon#UN[*{SYM#tag-Z_DefaultDiagFormat#}$SYM#tag-Z_DefaultDiagFormat#$'defaultDiagRec'||*{SYM#tag-Z_DiagFormat#}$SYM#tag-Z_DiagFormat#$'explicitDiagnostic'|]
// file /usr/include/yaz/z-diag1.h line 86
union anonymous$20;

// tag-#anon#UN[*{SYM#tag-Z_DefaultDiagFormat#}$SYM#tag-Z_DefaultDiagFormat#$'defaultFormat'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'externallyDefined'|]
// file /usr/include/yaz/z-core.h line 733
union anonymous$5;

// tag-#anon#UN[*{SYM#tag-Z_EIExportInvocationEsRequest#}$SYM#tag-Z_EIExportInvocationEsRequest#$'esRequest'||*{SYM#tag-Z_EIExportInvocationTaskPackage#}$SYM#tag-Z_EIExportInvocationTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-expi.h line 58
union anonymous$86;

// tag-#anon#UN[*{SYM#tag-Z_ESExportSpecificationEsRequest#}$SYM#tag-Z_ESExportSpecificationEsRequest#$'esRequest'||*{SYM#tag-Z_ESExportSpecificationTaskPackage#}$SYM#tag-Z_ESExportSpecificationTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-exps.h line 51
union anonymous$84;

// tag-#anon#UN[*{SYM#tag-Z_ElementRequestCompositeElementPrimitives#}$SYM#tag-Z_ElementRequestCompositeElementPrimitives#$'primitives'||*{SYM#tag-Z_ElementRequestCompositeElementSpecs#}$SYM#tag-Z_ElementRequestCompositeElementSpecs#$'specs'|]
// file /usr/include/yaz/z-espec1.h line 77
union anonymous$26;

// tag-#anon#UN[*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'databaseRecord'||*{SYM#tag-Z_DiagRec#}$SYM#tag-Z_DiagRec#$'surrogateDiagnostic'||*{SYM#tag-Z_FragmentSyntax#}$SYM#tag-Z_FragmentSyntax#$'startingFragment'||*{SYM#tag-Z_FragmentSyntax#}$SYM#tag-Z_FragmentSyntax#$'intermediateFragment'||*{SYM#tag-Z_FragmentSyntax#}$SYM#tag-Z_FragmentSyntax#$'finalFragment'|]
// file /usr/include/yaz/z-core.h line 707
union anonymous$18;

// tag-#anon#UN[*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'externallyTagged'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'notExternallyTagged'|]
// file /usr/include/yaz/z-core.h line 723
union anonymous$36;

// tag-#anon#UN[*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'marcHoldingsRecord'||*{SYM#tag-Z_HoldingsAndCircData#}$SYM#tag-Z_HoldingsAndCircData#$'holdingsAndCirc'|]
// file /usr/include/yaz/z-opac.h line 44
union anonymous$34;

// tag-#anon#UN[*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'record'||*{SYM#tag-Z_DiagRec#}$SYM#tag-Z_DiagRec#$'diagnostic'|]
// file /usr/include/yaz/zes-update0.h line 137
union anonymous$37;

// tag-#anon#UN[*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'record'||*{SYM#tag-Z_IUTaskPackageRecordStructureSurrogateDiagnostics#}$SYM#tag-Z_IUTaskPackageRecordStructureSurrogateDiagnostics#$'surrogateDiagnostics'|]
// file /usr/include/yaz/zes-update.h line 147
union anonymous$6;

// tag-#anon#UN[*{SYM#tag-Z_IORequest#}$SYM#tag-Z_IORequest#$'esRequest'||*{SYM#tag-Z_IOTaskPackage#}$SYM#tag-Z_IOTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-order.h line 63
union anonymous$90;

// tag-#anon#UN[*{SYM#tag-Z_IU0UpdateEsRequest#}$SYM#tag-Z_IU0UpdateEsRequest#$'esRequest'||*{SYM#tag-Z_IU0UpdateTaskPackage#}$SYM#tag-Z_IU0UpdateTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-update0.h line 66
union anonymous$33;

// tag-#anon#UN[*{SYM#tag-Z_IUUpdateEsRequest#}$SYM#tag-Z_IUUpdateEsRequest#$'esRequest'||*{SYM#tag-Z_IUUpdateTaskPackage#}$SYM#tag-Z_IUUpdateTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-update.h line 69
union anonymous;

// tag-#anon#UN[*{SYM#tag-Z_IntUnit#}$SYM#tag-Z_IntUnit#$'unit'||*{V}$V$'businessDaily'||*{V}$V$'continuous'||*{S8}$S8$'other'|]
// file /usr/include/yaz/zes-psched.h line 106
union anonymous$99;

// tag-#anon#UN[*{SYM#tag-Z_Iso2022#}$SYM#tag-Z_Iso2022#$'iso2022'||*{SYM#tag-Z_Iso10646#}$SYM#tag-Z_Iso10646#$'iso10646'||*{SYM#tag-Z_PrivateCharacterSet#}$SYM#tag-Z_PrivateCharacterSet#$'zprivate'|]
// file /usr/include/yaz/z-charneg.h line 72
union anonymous$69;

// tag-#anon#UN[*{SYM#tag-Z_Iso2022#}$SYM#tag-Z_Iso2022#$'iso2022'||*{SYM#tag-Z_Iso10646#}$SYM#tag-Z_Iso10646#$'iso10646'||*{SYM#tag-Z_PrivateCharacterSet#}$SYM#tag-Z_PrivateCharacterSet#$'zprivate'||*{V}$V$'none'|]
// file /usr/include/yaz/z-charneg.h line 92
union anonymous$72;

// tag-#anon#UN[*{SYM#tag-Z_Iso2022OriginProposal#}$SYM#tag-Z_Iso2022OriginProposal#$'originProposal'||*{SYM#tag-Z_Iso2022TargetResponse#}$SYM#tag-Z_Iso2022TargetResponse#$'targetResponse'|]
// file /usr/include/yaz/z-charneg.h line 142
union anonymous$81;

// tag-#anon#UN[*{SYM#tag-Z_KRBRequest#}$SYM#tag-Z_KRBRequest#$'challenge'||*{SYM#tag-Z_KRBResponse#}$SYM#tag-Z_KRBResponse#$'response'|]
// file /usr/include/yaz/z-acckrb1.h line 32
union anonymous$44;

// tag-#anon#UN[*{SYM#tag-Z_NetworkAddressIA#}$SYM#tag-Z_NetworkAddressIA#$'internetAddress'||*{SYM#tag-Z_NetworkAddressOPA#}$SYM#tag-Z_NetworkAddressOPA#$'osiPresentationAddress'||*{SYM#tag-Z_NetworkAddressOther#}$SYM#tag-Z_NetworkAddressOther#$'other'|]
// file /usr/include/yaz/z-exp.h line 834
union anonymous$57;

// tag-#anon#UN[*{SYM#tag-Z_Operand#}$SYM#tag-Z_Operand#$'simple'||*{SYM#tag-Z_Complex#}$SYM#tag-Z_Complex#$'complex'|]
// file /usr/include/yaz/z-core.h line 501
union anonymous$27;

// tag-#anon#UN[*{SYM#tag-Z_OriginProposal#}$SYM#tag-Z_OriginProposal#$'proposal'||*{SYM#tag-Z_TargetResponse#}$SYM#tag-Z_TargetResponse#$'response'|]
// file /usr/include/yaz/z-charneg.h line 62
union anonymous$63;

// tag-#anon#UN[*{SYM#tag-Z_PQSPeriodicQueryScheduleEsRequest#}$SYM#tag-Z_PQSPeriodicQueryScheduleEsRequest#$'esRequest'||*{SYM#tag-Z_PQSPeriodicQueryScheduleTaskPackage#}$SYM#tag-Z_PQSPeriodicQueryScheduleTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-psched.h line 55
union anonymous$95;

// tag-#anon#UN[*{SYM#tag-Z_PQueryPersistentQueryEsRequest#}$SYM#tag-Z_PQueryPersistentQueryEsRequest#$'esRequest'||*{SYM#tag-Z_PQueryPersistentQueryTaskPackage#}$SYM#tag-Z_PQueryPersistentQueryTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-pquery.h line 51
union anonymous$93;

// tag-#anon#UN[*{SYM#tag-Z_PRPersistentResultSetEsRequest#}$SYM#tag-Z_PRPersistentResultSetEsRequest#$'esRequest'||*{SYM#tag-Z_PRPersistentResultSetTaskPackage#}$SYM#tag-Z_PRPersistentResultSetTaskPackage#$'taskPackage'|]
// file /usr/include/yaz/zes-pset.h line 48
union anonymous$0;

// tag-#anon#UN[*{SYM#tag-Z_PrivateCapabilities#}$SYM#tag-Z_PrivateCapabilities#$'zprivate'||*{SYM#tag-Z_RpnCapabilities#}$SYM#tag-Z_RpnCapabilities#$'rpn'||*{SYM#tag-Z_Iso8777Capabilities#}$SYM#tag-Z_Iso8777Capabilities#$'iso8777'||*{SYM#tag-Z_HumanString#}$SYM#tag-Z_HumanString#$'z39_58'||*{SYM#tag-Z_RpnCapabilities#}$SYM#tag-Z_RpnCapabilities#$'erpn'||*{SYM#tag-Z_HumanString#}$SYM#tag-Z_HumanString#$'rankedList'|]
// file /usr/include/yaz/z-exp.h line 869
union anonymous$76;

// tag-#anon#UN[*{SYM#tag-Z_PrivateCharacterSetViaOid#}$SYM#tag-Z_PrivateCharacterSetViaOid#$'viaOid'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'externallySpecified'||*{V}$V$'previouslyAgreedUpon'|]
// file /usr/include/yaz/z-charneg.h line 113
union anonymous$77;

// tag-#anon#UN[*{SYM#tag-Z_PromptIdEnumeratedPrompt#}$SYM#tag-Z_PromptIdEnumeratedPrompt#$'enumeratedPrompt'||*{S8}$S8$'nonEnumeratedPrompt'|]
// file /usr/include/yaz/z-accform1.h line 120
union anonymous$50;

// tag-#anon#UN[*{SYM#tag-Z_Query#}$SYM#tag-Z_Query#$'actualQuery'||*{S8}$S8$'packageName'|]
// file /usr/include/yaz/zes-psched.h line 83
union anonymous$98;

// tag-#anon#UN[*{SYM#tag-Z_QueryExpressionTerm#}$SYM#tag-Z_QueryExpressionTerm#$'term'||*{SYM#tag-Z_Query#}$SYM#tag-Z_Query#$'query'|]
// file /usr/include/yaz/z-uifr1.h line 87
union anonymous$79;

// tag-#anon#UN[*{SYM#tag-Z_Segment#}$SYM#tag-Z_Segment#$'records'||*{V}$V$'recordsWillFollow'|]
// file /usr/include/yaz/zes-admin.h line 89
union anonymous$17;

// tag-#anon#UN[*{SYM#tag-Z_SimpleElement#}$SYM#tag-Z_SimpleElement#$'simpleElement'||*{SYM#tag-Z_ElementRequestCompositeElement#}$SYM#tag-Z_ElementRequestCompositeElement#$'compositeElement'|]
// file /usr/include/yaz/z-espec1.h line 89
union anonymous$29;

// tag-#anon#UN[*{SYM#tag-Z_SortKey#}$SYM#tag-Z_SortKey#$'generic'||*{SYM#tag-Z_SortDbSpecificList#}$SYM#tag-Z_SortDbSpecificList#$'databaseSpecific'|]
// file /usr/include/yaz/z-core.h line 1094
union anonymous$24;

// tag-#anon#UN[*{SYM#tag-Z_SpecificTag#}$SYM#tag-Z_SpecificTag#$'specificTag'||*{SYM#tag-Z_Occurrences#}$SYM#tag-Z_Occurrences#$'wildThing'||*{V}$V$'wildPath'|]
// file /usr/include/yaz/z-espec1.h line 110
union anonymous$32;

// tag-#anon#UN[*{SYM#tag-Z_TargetInfo#}$SYM#tag-Z_TargetInfo#$'targetInfo'||*{SYM#tag-Z_DatabaseInfo#}$SYM#tag-Z_DatabaseInfo#$'databaseInfo'||*{SYM#tag-Z_SchemaInfo#}$SYM#tag-Z_SchemaInfo#$'schemaInfo'||*{SYM#tag-Z_TagSetInfo#}$SYM#tag-Z_TagSetInfo#$'tagSetInfo'||*{SYM#tag-Z_RecordSyntaxInfo#}$SYM#tag-Z_RecordSyntaxInfo#$'recordSyntaxInfo'||*{SYM#tag-Z_AttributeSetInfo#}$SYM#tag-Z_AttributeSetInfo#$'attributeSetInfo'||*{SYM#tag-Z_TermListInfo#}$SYM#tag-Z_TermListInfo#$'termListInfo'||*{SYM#tag-Z_ExtendedServicesInfo#}$SYM#tag-Z_ExtendedServicesInfo#$'extendedServicesInfo'||*{SYM#tag-Z_AttributeDetails#}$SYM#tag-Z_AttributeDetails#$'attributeDetails'||*{SYM#tag-Z_TermListDetails#}$SYM#tag-Z_TermListDetails#$'termListDetails'||*{SYM#tag-Z_ElementSetDetails#}$SYM#tag-Z_ElementSetDetails#$'elementSetDetails'||*{SYM#tag-Z_RetrievalRecordDetails#}$SYM#tag-Z_RetrievalRecordDetails#$'retrievalRecordDetails'||*{SYM#tag-Z_SortDetails#}$SYM#tag-Z_SortDetails#$'sortDetails'||*{SYM#tag-Z_ProcessingInformation#}$SYM#tag-Z_ProcessingInformation#$'processing'||*{SYM#tag-Z_VariantSetInfo#}$SYM#tag-Z_VariantSetInfo#$'variants'||*{SYM#tag-Z_UnitInfo#}$SYM#tag-Z_UnitInfo#$'units'||*{SYM#tag-Z_CategoryList#}$SYM#tag-Z_CategoryList#$'categoryList'|]
// file /usr/include/yaz/z-exp.h line 257
union anonymous$51;

// tag-#anon#UN[*{SYM#tag-Z_TooMany#}$SYM#tag-Z_TooMany#$'tooMany'||*{SYM#tag-Z_BadSpec#}$SYM#tag-Z_BadSpec#$'badSpec'||*{SYM#tag-Z_DbUnavail#}$SYM#tag-Z_DbUnavail#$'dbUnavail'||*{S64}$S64$'unSupOp'||*{SYM#tag-Z_Attribute#}$SYM#tag-Z_Attribute#$'attribute'||*{SYM#tag-Z_AttCombo#}$SYM#tag-Z_AttCombo#$'attCombo'||*{SYM#tag-Z_DiagTerm#}$SYM#tag-Z_DiagTerm#$'term'||*{SYM#tag-Z_Proximity#}$SYM#tag-Z_Proximity#$'proximity'||*{SYM#tag-Z_Scan#}$SYM#tag-Z_Scan#$'scan'||*{SYM#tag-Z_Sort#}$SYM#tag-Z_Sort#$'sort'||*{SYM#tag-Z_Segmentation#}$SYM#tag-Z_Segmentation#$'segmentation'||*{SYM#tag-Z_ExtServices#}$SYM#tag-Z_ExtServices#$'extServices'||*{SYM#tag-Z_AccessCtrl#}$SYM#tag-Z_AccessCtrl#$'accessCtrl'||*{SYM#tag-Z_RecordSyntax#}$SYM#tag-Z_RecordSyntax#$'recordSyntax'|]
// file /usr/include/yaz/z-diag1.h line 318
union anonymous$14;

// tag-#anon#UN[*{SYM#tag-Z_UniverseReportHits#}$SYM#tag-Z_UniverseReportHits#$'databaseHits'||*{SYM#tag-Z_UniverseReportDuplicate#}$SYM#tag-Z_UniverseReportDuplicate#$'duplicate'|]
// file /usr/include/yaz/z-univ.h line 42
union anonymous$30;

// tag-#anon#UN[*{SYM#tag-Z_ValueRange#}$SYM#tag-Z_ValueRange#$'range'||*{SYM#tag-Z_ValueSetEnumerated#}$SYM#tag-Z_ValueSetEnumerated#$'enumerated'|]
// file /usr/include/yaz/z-exp.h line 703
union anonymous$73;

// tag-#anon#UN[*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'general'||*{S64}$S64$'numeric'||*{S8}$S8$'characterString'||*{S16}$S16$'oid'||*{S8}$S8$'dateTime'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'external'||*{SYM#tag-Z_IntUnit#}$SYM#tag-Z_IntUnit#$'integerAndUnit'||*{V}$V$'null'|]
// file /usr/include/yaz/z-core.h line 538
union anonymous$1;

// tag-#anon#UN[*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'octets'||*{S64}$S64$'numeric'||*{S8}$S8$'date'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'ext'||*{S8}$S8$'string'||*{S32}$S32$'trueOrFalse'||*{S16}$S16$'oid'||*{SYM#tag-Z_IntUnit#}$SYM#tag-Z_IntUnit#$'intUnit'||*{V}$V$'elementNotThere'||*{V}$V$'elementEmpty'||*{V}$V$'noDataRequested'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'diagnostic'||*{SYM#tag-Z_GenericRecord#}$SYM#tag-Z_GenericRecord#$'subtree'|]
// file /usr/include/yaz/z-grs.h line 70
union anonymous$28;

// tag-#anon#UN[*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'single_ASN1_type'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'octet_aligned'||*{SYM#tag-odr_bitmask#}$SYM#tag-odr_bitmask#$'arbitrary'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'sutrs'||*{SYM#tag-Z_ExplainRecord#}$SYM#tag-Z_ExplainRecord#$'explainRecord'||*{SYM#tag-Z_ResourceReport1#}$SYM#tag-Z_ResourceReport1#$'resourceReport1'||*{SYM#tag-Z_ResourceReport2#}$SYM#tag-Z_ResourceReport2#$'resourceReport2'||*{SYM#tag-Z_PromptObject1#}$SYM#tag-Z_PromptObject1#$'promptObject1'||*{SYM#tag-Z_GenericRecord#}$SYM#tag-Z_GenericRecord#$'grs1'||*{SYM#tag-Z_TaskPackage#}$SYM#tag-Z_TaskPackage#$'extendedService'||*{SYM#tag-Z_IOItemOrder#}$SYM#tag-Z_IOItemOrder#$'itemOrder'||*{SYM#tag-Z_DiagnosticFormat#}$SYM#tag-Z_DiagnosticFormat#$'diag1'||*{SYM#tag-Z_Espec1#}$SYM#tag-Z_Espec1#$'espec1'||*{SYM#tag-Z_BriefBib#}$SYM#tag-Z_BriefBib#$'summary'||*{SYM#tag-Z_OPACRecord#}$SYM#tag-Z_OPACRecord#$'opac'||*{SYM#tag-Z_SearchInfoReport#}$SYM#tag-Z_SearchInfoReport#$'searchResult1'||*{SYM#tag-Z_IUUpdate#}$SYM#tag-Z_IUUpdate#$'update'||*{SYM#tag-Z_DateTime#}$SYM#tag-Z_DateTime#$'dateTime'||*{SYM#tag-Z_UniverseReport#}$SYM#tag-Z_UniverseReport#$'universeReport'||*{SYM#tag-Z_Admin#}$SYM#tag-Z_Admin#$'adminService'||*{SYM#tag-Z_IU0Update#}$SYM#tag-Z_IU0Update#$'update0'||*{SYM#tag-Z_OtherInformation#}$SYM#tag-Z_OtherInformation#$'userInfo1'||*{SYM#tag-Z_CharSetandLanguageNegotiation#}$SYM#tag-Z_CharSetandLanguageNegotiation#$'charNeg3'||*{SYM#tag-Z_PromptObject1#}$SYM#tag-Z_PromptObject1#$'acfPrompt1'||*{SYM#tag-Z_DES_RN_Object#}$SYM#tag-Z_DES_RN_Object#$'acfDes1'||*{SYM#tag-Z_KRBObject#}$SYM#tag-Z_KRBObject#$'acfKrb1'||*{SYM#tag-Z_MultipleSearchTerms_2#}$SYM#tag-Z_MultipleSearchTerms_2#$'multipleSearchTerms_2'||*{S8}$S8$'cql'||*{SYM#tag-Z_OCLC_UserInformation#}$SYM#tag-Z_OCLC_UserInformation#$'oclc'||*{SYM#tag-Z_PRPersistentResultSet#}$SYM#tag-Z_PRPersistentResultSet#$'persistentResultSet'||*{SYM#tag-Z_PQueryPersistentQuery#}$SYM#tag-Z_PQueryPersistentQuery#$'persistentQuery'||*{SYM#tag-Z_PQSPeriodicQuerySchedule#}$SYM#tag-Z_PQSPeriodicQuerySchedule#$'periodicQuerySchedule'||*{SYM#tag-Z_ESExportSpecification#}$SYM#tag-Z_ESExportSpecification#$'exportSpecification'||*{SYM#tag-Z_EIExportInvocation#}$SYM#tag-Z_EIExportInvocation#$'exportInvocation'||*{SYM#tag-Z_FacetList#}$SYM#tag-Z_FacetList#$'facetList'|]
// file /usr/include/yaz/prt-ext.h line 101
union anonymous$3;

// tag-#anon#UN[*{V}$V$'all'||*{SYM#tag-Z_EIOriginPartNotToKeepRanges#}$SYM#tag-Z_EIOriginPartNotToKeepRanges#$'ranges'|]
// file /usr/include/yaz/zes-expi.h line 90
union anonymous$88;

// tag-#anon#UN[*{V}$V$'all'||*{SYM#tag-Z_ResultsByDB_sList#}$SYM#tag-Z_ResultsByDB_sList#$'list'|]
// file /usr/include/yaz/z-uifr1.h line 65
union anonymous$80;

// tag-#anon#UN[*{V}$V$'all'||*{V}$V$'last'||*{SYM#tag-Z_OccurValues#}$SYM#tag-Z_OccurValues#$'values'|]
// file /usr/include/yaz/z-espec1.h line 132
union anonymous$31;

// tag-#anon#UN[*{V}$V$'any_or_none'||*{SYM#tag-Z_AttributeValueList#}$SYM#tag-Z_AttributeValueList#$'specific'|]
// file /usr/include/yaz/z-exp.h line 1004
union anonymous$9;

// tag-#anon#UN[*{V}$V$'billInvoice'||*{V}$V$'prepay'||*{V}$V$'depositAccount'||*{SYM#tag-Z_IOCreditCardInfo#}$SYM#tag-Z_IOCreditCardInfo#$'creditCard'||*{V}$V$'cardInfoPreviouslySupplied'||*{V}$V$'privateKnown'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'privateNotKnown'|]
// file /usr/include/yaz/zes-order.h line 79
union anonymous$91;

// tag-#anon#UN[*{V}$V$'character'||*{V}$V$'numeric'||*{SYM#tag-Z_HumanString#}$SYM#tag-Z_HumanString#$'structured'|]
// file /usr/include/yaz/z-exp.h line 638
union anonymous$71;

// tag-#anon#UN[*{V}$V$'decade'||*{V}$V$'century'||*{V}$V$'millennium'|]
// file /usr/include/yaz/z-date.h line 85
union anonymous$61;

// tag-#anon#UN[*{V}$V$'first'||*{V}$V$'second'||*{V}$V$'third'||*{V}$V$'fourth'|]
// file /usr/include/yaz/z-date.h line 57
union anonymous$58;

// tag-#anon#UN[*{V}$V$'local'||*{V}$V$'utc'||*{S64}$S64$'utcOffset'|]
// file /usr/include/yaz/z-date.h line 124
union anonymous$42;

// tag-#anon#UN[*{V}$V$'noUser'||*{V}$V$'refused'||*{V}$V$'simple'||*{SYM#tag-Z_OidList#}$SYM#tag-Z_OidList#$'oid'||*{SYM#tag-Z_AltOidList#}$SYM#tag-Z_AltOidList#$'alternative'||*{V}$V$'pwdInv'||*{V}$V$'pwdExp'|]
// file /usr/include/yaz/z-diag1.h line 292
union anonymous$11;

// tag-#anon#UN[*{V}$V$'nonZeroStepSize'||*{V}$V$'specifiedStepSize'||*{V}$V$'termList1'||*{SYM#tag-Z_AttrListList#}$SYM#tag-Z_AttrListList#$'termList2'||*{S64}$S64$'posInResponse'||*{V}$V$'resources'||*{V}$V$'endOfList'|]
// file /usr/include/yaz/z-diag1.h line 186
union anonymous$23;

// tag-#anon#UN[*{V}$V$'op_and'||*{V}$V$'op_or'||*{V}$V$'and_not'||*{SYM#tag-Z_ProximityOperator#}$SYM#tag-Z_ProximityOperator#$'prox'|]
// file /usr/include/yaz/z-core.h line 560
union anonymous$12;

// tag-#anon#UN[*{V}$V$'reIndex'||*{V}$V$'truncate'||*{V}$V$'drop'||*{V}$V$'create'||*{SYM#tag-Z_ImportParameters#}$SYM#tag-Z_ImportParameters#$'import'||*{V}$V$'refresh'||*{V}$V$'commit'||*{V}$V$'shutdown'||*{V}$V$'start'|]
// file /usr/include/yaz/zes-admin.h line 64
union anonymous$16;

// tag-#anon#UN[*{V}$V$'resultSets'||*{S8}$S8$'badSet'||*{S64}$S64$'relation'||*{S64}$S64$'unit'||*{S64}$S64$'distance'||*{SYM#tag-Z_AttributeList#}$SYM#tag-Z_AttributeList#$'attributes'||*{V}$V$'ordered'||*{V}$V$'exclusion'|]
// file /usr/include/yaz/z-diag1.h line 159
union anonymous$21;

// tag-#anon#UN[*{V}$V$'segmentCount'||*{S64}$S64$'segmentSize'|]
// file /usr/include/yaz/z-diag1.h line 251
union anonymous$101;

// tag-#anon#UN[*{V}$V$'sequence'||*{V}$V$'noRsName'||*{S64}$S64$'tooMany'||*{V}$V$'incompatible'||*{V}$V$'generic'||*{V}$V$'dbSpecific'||*{SYM#tag-Z_SortElement#}$SYM#tag-Z_SortElement#$'sortElement'||*{S64}$S64$'key'||*{V}$V$'action'||*{S64}$S64$'illegal'||*{SYM#tag-Z_StringList#}$SYM#tag-Z_StringList#$'inputTooLarge'||*{V}$V$'aggregateTooLarge'|]
// file /usr/include/yaz/z-diag1.h line 215
union anonymous$25;

// tag-#anon#UN[*{V}$V$'sevenBit'||*{V}$V$'eightBit'|]
// file /usr/include/yaz/z-charneg.h line 152
union anonymous$78;

// tag-#anon#UN[*{V}$V$'type_0'||*{SYM#tag-Z_RPNQuery#}$SYM#tag-Z_RPNQuery#$'type_1'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'type_2'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'type_100'||*{SYM#tag-Z_RPNQuery#}$SYM#tag-Z_RPNQuery#$'type_101'||*{SYM#tag-odr_oct#}$SYM#tag-odr_oct#$'type_102'||*{SYM#tag-Z_External#}$SYM#tag-Z_External#$'type_104'|]
// file /usr/include/yaz/z-core.h line 470
union anonymous$82;

// tag-#anon#UN[*{V}$V$'winter'||*{V}$V$'spring'||*{V}$V$'summer'||*{V}$V$'autumn'|]
// file /usr/include/yaz/z-date.h line 71
union anonymous$60;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$53;

// tag-#anon#UN[SYM#tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'op'||*{S8}$S8$'value'|]#'relation'||SYM#tag-#anon#ST[*{cS8}$cS8$'op'||*{SYM#tag-xpath_predicate#}$SYM#tag-xpath_predicate#$'left'||*{SYM#tag-xpath_predicate#}$SYM#tag-xpath_predicate#$'right'|]#'boolean'|]
// file ../include/zebra_xpath.h line 28
union anonymous$66;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$48;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'entry_size'|]#'sort'|]
// file zebramap.c line 51
union anonymous$97;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$47;

// tag-UErrorCode
// file /usr/include/x86_64-linux-gnu/unicode/utypes.h line 476
enum UErrorCode { U_USING_FALLBACK_WARNING=-128, U_ERROR_WARNING_START=-128, U_USING_DEFAULT_WARNING=-127, U_SAFECLONE_ALLOCATED_WARNING=-126, U_STATE_OLD_WARNING=-125, U_STRING_NOT_TERMINATED_WARNING=-124, U_SORT_KEY_TOO_SHORT_WARNING=-123, U_AMBIGUOUS_ALIAS_WARNING=-122, U_DIFFERENT_UCA_VERSION=-121, U_PLUGIN_CHANGED_LEVEL_WARNING=-120, U_ERROR_WARNING_LIMIT=-119, U_ZERO_ERROR=0, U_ILLEGAL_ARGUMENT_ERROR=1, U_MISSING_RESOURCE_ERROR=2, U_INVALID_FORMAT_ERROR=3, U_FILE_ACCESS_ERROR=4, U_INTERNAL_PROGRAM_ERROR=5, U_MESSAGE_PARSE_ERROR=6, U_MEMORY_ALLOCATION_ERROR=7, U_INDEX_OUTOFBOUNDS_ERROR=8, U_PARSE_ERROR=9, U_INVALID_CHAR_FOUND=10, U_TRUNCATED_CHAR_FOUND=11, U_ILLEGAL_CHAR_FOUND=12, U_INVALID_TABLE_FORMAT=13, U_INVALID_TABLE_FILE=14, U_BUFFER_OVERFLOW_ERROR=15, U_UNSUPPORTED_ERROR=16, U_RESOURCE_TYPE_MISMATCH=17, U_ILLEGAL_ESCAPE_SEQUENCE=18, U_UNSUPPORTED_ESCAPE_SEQUENCE=19, U_NO_SPACE_AVAILABLE=20, U_CE_NOT_FOUND_ERROR=21, U_PRIMARY_TOO_LONG_ERROR=22, U_STATE_TOO_OLD_ERROR=23, U_TOO_MANY_ALIASES_ERROR=24, U_ENUM_OUT_OF_SYNC_ERROR=25, U_INVARIANT_CONVERSION_ERROR=26, U_INVALID_STATE_ERROR=27, U_COLLATOR_VERSION_MISMATCH=28, U_USELESS_COLLATOR_ERROR=29, U_NO_WRITE_PERMISSION=30, U_STANDARD_ERROR_LIMIT=31, U_BAD_VARIABLE_DEFINITION=65536, U_PARSE_ERROR_START=65536, U_MALFORMED_RULE=65537, U_MALFORMED_SET=65538, U_MALFORMED_SYMBOL_REFERENCE=65539, U_MALFORMED_UNICODE_ESCAPE=65540, U_MALFORMED_VARIABLE_DEFINITION=65541, U_MALFORMED_VARIABLE_REFERENCE=65542, U_MISMATCHED_SEGMENT_DELIMITERS=65543, U_MISPLACED_ANCHOR_START=65544, U_MISPLACED_CURSOR_OFFSET=65545, U_MISPLACED_QUANTIFIER=65546, U_MISSING_OPERATOR=65547, U_MISSING_SEGMENT_CLOSE=65548, U_MULTIPLE_ANTE_CONTEXTS=65549, U_MULTIPLE_CURSORS=65550, U_MULTIPLE_POST_CONTEXTS=65551, U_TRAILING_BACKSLASH=65552, U_UNDEFINED_SEGMENT_REFERENCE=65553, U_UNDEFINED_VARIABLE=65554, U_UNQUOTED_SPECIAL=65555, U_UNTERMINATED_QUOTE=65556, U_RULE_MASK_ERROR=65557, U_MISPLACED_COMPOUND_FILTER=65558, U_MULTIPLE_COMPOUND_FILTERS=65559, U_INVALID_RBT_SYNTAX=65560, U_INVALID_PROPERTY_PATTERN=65561, U_MALFORMED_PRAGMA=65562, U_UNCLOSED_SEGMENT=65563, U_ILLEGAL_CHAR_IN_SEGMENT=65564, U_VARIABLE_RANGE_EXHAUSTED=65565, U_VARIABLE_RANGE_OVERLAP=65566, U_ILLEGAL_CHARACTER=65567, U_INTERNAL_TRANSLITERATOR_ERROR=65568, U_INVALID_ID=65569, U_INVALID_FUNCTION=65570, U_PARSE_ERROR_LIMIT=65571, U_UNEXPECTED_TOKEN=65792, U_FMT_PARSE_ERROR_START=65792, U_MULTIPLE_DECIMAL_SEPARATORS=65793, U_MULTIPLE_DECIMAL_SEPERATORS=65793, U_MULTIPLE_EXPONENTIAL_SYMBOLS=65794, U_MALFORMED_EXPONENTIAL_PATTERN=65795, U_MULTIPLE_PERCENT_SYMBOLS=65796, U_MULTIPLE_PERMILL_SYMBOLS=65797, U_MULTIPLE_PAD_SPECIFIERS=65798, U_PATTERN_SYNTAX_ERROR=65799, U_ILLEGAL_PAD_POSITION=65800, U_UNMATCHED_BRACES=65801, U_UNSUPPORTED_PROPERTY=65802, U_UNSUPPORTED_ATTRIBUTE=65803, U_ARGUMENT_TYPE_MISMATCH=65804, U_DUPLICATE_KEYWORD=65805, U_UNDEFINED_KEYWORD=65806, U_DEFAULT_KEYWORD_MISSING=65807, U_DECIMAL_NUMBER_SYNTAX_ERROR=65808, U_FORMAT_INEXACT_ERROR=65809, U_FMT_PARSE_ERROR_LIMIT=65810, U_BRK_INTERNAL_ERROR=66048, U_BRK_ERROR_START=66048, U_BRK_HEX_DIGITS_EXPECTED=66049, U_BRK_SEMICOLON_EXPECTED=66050, U_BRK_RULE_SYNTAX=66051, U_BRK_UNCLOSED_SET=66052, U_BRK_ASSIGN_ERROR=66053, U_BRK_VARIABLE_REDFINITION=66054, U_BRK_MISMATCHED_PAREN=66055, U_BRK_NEW_LINE_IN_QUOTED_STRING=66056, U_BRK_UNDEFINED_VARIABLE=66057, U_BRK_INIT_ERROR=66058, U_BRK_RULE_EMPTY_SET=66059, U_BRK_UNRECOGNIZED_OPTION=66060, U_BRK_MALFORMED_RULE_TAG=66061, U_BRK_ERROR_LIMIT=66062, U_REGEX_INTERNAL_ERROR=66304, U_REGEX_ERROR_START=66304, U_REGEX_RULE_SYNTAX=66305, U_REGEX_INVALID_STATE=66306, U_REGEX_BAD_ESCAPE_SEQUENCE=66307, U_REGEX_PROPERTY_SYNTAX=66308, U_REGEX_UNIMPLEMENTED=66309, U_REGEX_MISMATCHED_PAREN=66310, U_REGEX_NUMBER_TOO_BIG=66311, U_REGEX_BAD_INTERVAL=66312, U_REGEX_MAX_LT_MIN=66313, U_REGEX_INVALID_BACK_REF=66314, U_REGEX_INVALID_FLAG=66315, U_REGEX_LOOK_BEHIND_LIMIT=66316, U_REGEX_SET_CONTAINS_STRING=66317, U_REGEX_OCTAL_TOO_BIG=66318, U_REGEX_MISSING_CLOSE_BRACKET=66319, U_REGEX_INVALID_RANGE=66320, U_REGEX_STACK_OVERFLOW=66321, U_REGEX_TIME_OUT=66322, U_REGEX_STOPPED_BY_CALLER=66323, U_REGEX_PATTERN_TOO_BIG=66324, U_REGEX_INVALID_CAPTURE_GROUP_NAME=66325, U_REGEX_ERROR_LIMIT=66326, U_IDNA_PROHIBITED_ERROR=66560, U_IDNA_ERROR_START=66560, U_IDNA_UNASSIGNED_ERROR=66561, U_IDNA_CHECK_BIDI_ERROR=66562, U_IDNA_STD3_ASCII_RULES_ERROR=66563, U_IDNA_ACE_PREFIX_ERROR=66564, U_IDNA_VERIFICATION_ERROR=66565, U_IDNA_LABEL_TOO_LONG_ERROR=66566, U_IDNA_ZERO_LENGTH_LABEL_ERROR=66567, U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR=66568, U_IDNA_ERROR_LIMIT=66569, U_STRINGPREP_PROHIBITED_ERROR=66560, U_STRINGPREP_UNASSIGNED_ERROR=66561, U_STRINGPREP_CHECK_BIDI_ERROR=66562, U_PLUGIN_ERROR_START=66816, U_PLUGIN_TOO_HIGH=66816, U_PLUGIN_DIDNT_SET_LEVEL=66817, U_PLUGIN_ERROR_LIMIT=66818, U_ERROR_LIMIT=66818 };

// tag-Z_AccessCtrl
// file /usr/include/yaz/z-diag1.h line 70
struct Z_AccessCtrl;

// tag-Z_AccessInfo
// file /usr/include/yaz/z-exp.h line 190
struct Z_AccessInfo;

// tag-Z_AccessRestrictions
// file /usr/include/yaz/z-exp.h line 223
struct Z_AccessRestrictions;

// tag-Z_AccessRestrictionsUnit
// file /usr/include/yaz/z-exp.h line 220
struct Z_AccessRestrictionsUnit;

// tag-Z_Admin
// file /usr/include/yaz/zes-admin.h line 22
struct Z_Admin;

// tag-Z_AdminEsRequest
// file /usr/include/yaz/zes-admin.h line 16
struct Z_AdminEsRequest;

// tag-Z_AdminTaskPackage
// file /usr/include/yaz/zes-admin.h line 19
struct Z_AdminTaskPackage;

// tag-Z_AltOidList
// file /usr/include/yaz/z-diag1.h line 67
struct Z_AltOidList;

// tag-Z_AttCombo
// file /usr/include/yaz/z-diag1.h line 37
struct Z_AttCombo;

// tag-Z_AttrListList
// file /usr/include/yaz/z-diag1.h line 46
struct Z_AttrListList;

// tag-Z_Attribute
// file /usr/include/yaz/z-diag1.h line 34
struct Z_Attribute;

// tag-Z_AttributeCombination
// file /usr/include/yaz/z-exp.h line 241
struct Z_AttributeCombination;

// tag-Z_AttributeCombinations
// file /usr/include/yaz/z-exp.h line 238
struct Z_AttributeCombinations;

// tag-Z_AttributeDescription
// file /usr/include/yaz/z-exp.h line 64
struct Z_AttributeDescription;

// tag-Z_AttributeDetails
// file /usr/include/yaz/z-exp.h line 76
struct Z_AttributeDetails;

// tag-Z_AttributeElement
// file /usr/include/yaz/z-core.h line 76
struct Z_AttributeElement;

// tag-Z_AttributeList
// file /usr/include/yaz/z-core.h line 64
struct Z_AttributeList;

// tag-Z_AttributeOccurrence
// file /usr/include/yaz/z-exp.h line 247
struct Z_AttributeOccurrence;

// tag-Z_AttributeSetDetails
// file /usr/include/yaz/z-exp.h line 79
struct Z_AttributeSetDetails;

// tag-Z_AttributeSetInfo
// file /usr/include/yaz/z-exp.h line 58
struct Z_AttributeSetInfo;

// tag-Z_AttributeType
// file /usr/include/yaz/z-exp.h line 61
struct Z_AttributeType;

// tag-Z_AttributeTypeDetails
// file /usr/include/yaz/z-exp.h line 82
struct Z_AttributeTypeDetails;

// tag-Z_AttributeValue
// file /usr/include/yaz/z-exp.h line 88
struct Z_AttributeValue;

// tag-Z_AttributeValueList
// file /usr/include/yaz/z-exp.h line 244
struct Z_AttributeValueList;

// tag-Z_AttributesPlusTerm
// file /usr/include/yaz/z-core.h line 58
struct Z_AttributesPlusTerm;

// tag-Z_BadSpec
// file /usr/include/yaz/z-diag1.h line 25
struct Z_BadSpec;

// tag-Z_BriefBib
// file /usr/include/yaz/z-sum.h line 16
struct Z_BriefBib;

// tag-Z_CategoryInfo
// file /usr/include/yaz/z-exp.h line 154
struct Z_CategoryInfo;

// tag-Z_CategoryList
// file /usr/include/yaz/z-exp.h line 151
struct Z_CategoryList;

// tag-Z_Challenge1
// file /usr/include/yaz/z-accform1.h line 22
struct Z_Challenge1;

// tag-Z_ChallengeUnit1
// file /usr/include/yaz/z-accform1.h line 19
struct Z_ChallengeUnit1;

// tag-Z_CharSetandLanguageNegotiation
// file /usr/include/yaz/z-charneg.h line 16
struct Z_CharSetandLanguageNegotiation;

// tag-Z_Charge
// file /usr/include/yaz/z-exp.h line 232
struct Z_Charge;

// tag-Z_CircRecord
// file /usr/include/yaz/z-opac.h line 28
struct Z_CircRecord;

// tag-Z_CommonInfo
// file /usr/include/yaz/z-exp.h line 157
struct Z_CommonInfo;

// tag-Z_CompSpec
// file /usr/include/yaz/z-core.h line 139
struct Z_CompSpec;

// tag-Z_Complex
// file /usr/include/yaz/z-core.h line 49
struct Z_Complex;

// tag-Z_ComplexAttribute
// file /usr/include/yaz/z-core.h line 73
struct Z_ComplexAttribute;

// tag-Z_ContactInfo
// file /usr/include/yaz/z-exp.h line 175
struct Z_ContactInfo;

// tag-Z_Costs
// file /usr/include/yaz/z-exp.h line 229
struct Z_Costs;

// tag-Z_CostsOtherCharge
// file /usr/include/yaz/z-exp.h line 226
struct Z_CostsOtherCharge;

// tag-Z_DES_RN_Object
// file /usr/include/yaz/z-accdes1.h line 15
struct Z_DES_RN_Object;

// tag-Z_DRNType
// file /usr/include/yaz/z-accdes1.h line 18
struct Z_DRNType;

// tag-Z_DatabaseInfo
// file /usr/include/yaz/z-exp.h line 22
struct Z_DatabaseInfo;

// tag-Z_DatabaseList
// file /usr/include/yaz/z-exp.h line 235
struct Z_DatabaseList;

// tag-Z_Date
// file /usr/include/yaz/z-date.h line 34
struct Z_Date;

// tag-Z_DateFlags
// file /usr/include/yaz/z-date.h line 31
struct Z_DateFlags;

// tag-Z_DateMonthAndDay
// file /usr/include/yaz/z-date.h line 19
struct Z_DateMonthAndDay;

// tag-Z_DateQuarter
// file /usr/include/yaz/z-date.h line 22
struct Z_DateQuarter;

// tag-Z_DateSeason
// file /usr/include/yaz/z-date.h line 25
struct Z_DateSeason;

// tag-Z_DateTime
// file /usr/include/yaz/z-date.h line 16
struct Z_DateTime;

// tag-Z_DbSpecific
// file /usr/include/yaz/z-core.h line 136
struct Z_DbSpecific;

// tag-Z_DbUnavail
// file /usr/include/yaz/z-diag1.h line 31
struct Z_DbUnavail;

// tag-Z_DbUnavail_0
// file /usr/include/yaz/z-diag1.h line 28
struct Z_DbUnavail_0;

// tag-Z_DefaultDiagFormat
// file /usr/include/yaz/z-core.h line 118
struct Z_DefaultDiagFormat;

// tag-Z_DiagFormat
// file /usr/include/yaz/z-diag1.h line 76
struct Z_DiagFormat;

// tag-Z_DiagRec
// file /usr/include/yaz/z-core.h line 115
struct Z_DiagRec;

// tag-Z_DiagTerm
// file /usr/include/yaz/z-diag1.h line 40
struct Z_DiagTerm;

// tag-Z_DiagnosticFormat
// file /usr/include/yaz/z-diag1.h line 19
struct Z_DiagnosticFormat;

// tag-Z_DiagnosticFormat_s
// file /usr/include/yaz/z-diag1.h line 16
struct Z_DiagnosticFormat_s;

// tag-Z_EIExportInvocation
// file /usr/include/yaz/zes-expi.h line 23
struct Z_EIExportInvocation;

// tag-Z_EIExportInvocationEsRequest
// file /usr/include/yaz/zes-expi.h line 17
struct Z_EIExportInvocationEsRequest;

// tag-Z_EIExportInvocationTaskPackage
// file /usr/include/yaz/zes-expi.h line 20
struct Z_EIExportInvocationTaskPackage;

// tag-Z_EIOriginPartNotToKeep
// file /usr/include/yaz/zes-expi.h line 35
struct Z_EIOriginPartNotToKeep;

// tag-Z_EIOriginPartNotToKeepRanges
// file /usr/include/yaz/zes-expi.h line 32
struct Z_EIOriginPartNotToKeepRanges;

// tag-Z_EIOriginPartNotToKeepRanges_s
// file /usr/include/yaz/zes-expi.h line 29
struct Z_EIOriginPartNotToKeepRanges_s;

// tag-Z_EIOriginPartToKeep
// file /usr/include/yaz/zes-expi.h line 26
struct Z_EIOriginPartToKeep;

// tag-Z_EITargetPart
// file /usr/include/yaz/zes-expi.h line 38
struct Z_EITargetPart;

// tag-Z_ESAdminOriginPartNotToKeep
// file /usr/include/yaz/zes-admin.h line 28
struct Z_ESAdminOriginPartNotToKeep;

// tag-Z_ESAdminOriginPartToKeep
// file /usr/include/yaz/zes-admin.h line 25
struct Z_ESAdminOriginPartToKeep;

// tag-Z_ESAdminTargetPart
// file /usr/include/yaz/zes-admin.h line 31
struct Z_ESAdminTargetPart;

// tag-Z_ESDestination
// file /usr/include/yaz/zes-exps.h line 31
struct Z_ESDestination;

// tag-Z_ESDestinationOther
// file /usr/include/yaz/zes-exps.h line 28
struct Z_ESDestinationOther;

// tag-Z_ESExportSpecification
// file /usr/include/yaz/zes-exps.h line 22
struct Z_ESExportSpecification;

// tag-Z_ESExportSpecificationEsRequest
// file /usr/include/yaz/zes-exps.h line 16
struct Z_ESExportSpecificationEsRequest;

// tag-Z_ESExportSpecificationTaskPackage
// file /usr/include/yaz/zes-exps.h line 19
struct Z_ESExportSpecificationTaskPackage;

// tag-Z_ESOriginPartToKeep
// file /usr/include/yaz/zes-exps.h line 25
struct Z_ESOriginPartToKeep;

// tag-Z_EScanInfo
// file /usr/include/yaz/z-exp.h line 91
struct Z_EScanInfo;

// tag-Z_ETagPath
// file /usr/include/yaz/z-espec1.h line 41
struct Z_ETagPath;

// tag-Z_ETagUnit
// file /usr/include/yaz/z-espec1.h line 38
struct Z_ETagUnit;

// tag-Z_ElementData
// file /usr/include/yaz/z-grs.h line 22
struct Z_ElementData;

// tag-Z_ElementDataType
// file /usr/include/yaz/z-exp.h line 43
struct Z_ElementDataType;

// tag-Z_ElementInfo
// file /usr/include/yaz/z-exp.h line 31
struct Z_ElementInfo;

// tag-Z_ElementInfoList
// file /usr/include/yaz/z-exp.h line 40
struct Z_ElementInfoList;

// tag-Z_ElementMetaData
// file /usr/include/yaz/z-grs.h line 25
struct Z_ElementMetaData;

// tag-Z_ElementRequest
// file /usr/include/yaz/z-espec1.h line 29
struct Z_ElementRequest;

// tag-Z_ElementRequestCompositeElement
// file /usr/include/yaz/z-espec1.h line 26
struct Z_ElementRequestCompositeElement;

// tag-Z_ElementRequestCompositeElementPrimitives
// file /usr/include/yaz/z-espec1.h line 20
struct Z_ElementRequestCompositeElementPrimitives;

// tag-Z_ElementRequestCompositeElementSpecs
// file /usr/include/yaz/z-espec1.h line 23
struct Z_ElementRequestCompositeElementSpecs;

// tag-Z_ElementSetDetails
// file /usr/include/yaz/z-exp.h line 97
struct Z_ElementSetDetails;

// tag-Z_ElementSpec
// file /usr/include/yaz/z-core.h line 142
struct Z_ElementSpec;

// tag-Z_Encryption
// file /usr/include/yaz/z-accform1.h line 37
struct Z_Encryption;

// tag-Z_Environment
// file /usr/include/yaz/z-charneg.h line 43
struct Z_Environment;

// tag-Z_Era
// file /usr/include/yaz/z-date.h line 28
struct Z_Era;

// tag-Z_Espec1
// file /usr/include/yaz/z-espec1.h line 17
struct Z_Espec1;

// tag-Z_Estimate1
// file /usr/include/yaz/z-rrf1.h line 19
struct Z_Estimate1;

// tag-Z_Estimate2
// file /usr/include/yaz/z-rrf2.h line 19
struct Z_Estimate2;

// tag-Z_ExplainRecord
// file /usr/include/yaz/z-exp.h line 16
struct Z_ExplainRecord;

// tag-Z_ExtServices
// file /usr/include/yaz/z-diag1.h line 61
struct Z_ExtServices;

// tag-Z_ExtendedServicesInfo
// file /usr/include/yaz/z-exp.h line 73
struct Z_ExtendedServicesInfo;

// tag-Z_External
// file /usr/include/yaz/z-core.h line 15
struct Z_External;

// tag-Z_FacetField
// file /usr/include/yaz/z-facet-1.h line 19
struct Z_FacetField;

// tag-Z_FacetList
// file /usr/include/yaz/z-facet-1.h line 16
struct Z_FacetList;

// tag-Z_FacetTerm
// file /usr/include/yaz/z-facet-1.h line 22
struct Z_FacetTerm;

// tag-Z_FormatSpec
// file /usr/include/yaz/z-sum.h line 19
struct Z_FormatSpec;

// tag-Z_FragmentSyntax
// file /usr/include/yaz/z-core.h line 112
struct Z_FragmentSyntax;

// tag-Z_GenericRecord
// file /usr/include/yaz/z-grs.h line 16
struct Z_GenericRecord;

// tag-Z_HitVector
// file /usr/include/yaz/z-grs.h line 40
struct Z_HitVector;

// tag-Z_HoldingsAndCircData
// file /usr/include/yaz/z-opac.h line 22
struct Z_HoldingsAndCircData;

// tag-Z_HoldingsRecord
// file /usr/include/yaz/z-opac.h line 19
struct Z_HoldingsRecord;

// tag-Z_HumanString
// file /usr/include/yaz/z-exp.h line 163
struct Z_HumanString;

// tag-Z_HumanStringUnit
// file /usr/include/yaz/z-exp.h line 160
struct Z_HumanStringUnit;

// tag-Z_IOBilling
// file /usr/include/yaz/zes-order.h line 28
struct Z_IOBilling;

// tag-Z_IOContact
// file /usr/include/yaz/zes-order.h line 25
struct Z_IOContact;

// tag-Z_IOCreditCardInfo
// file /usr/include/yaz/zes-order.h line 34
struct Z_IOCreditCardInfo;

// tag-Z_IOItemOrder
// file /usr/include/yaz/zes-order.h line 22
struct Z_IOItemOrder;

// tag-Z_IOOriginPartNotToKeep
// file /usr/include/yaz/zes-order.h line 40
struct Z_IOOriginPartNotToKeep;

// tag-Z_IOOriginPartToKeep
// file /usr/include/yaz/zes-order.h line 31
struct Z_IOOriginPartToKeep;

// tag-Z_IORequest
// file /usr/include/yaz/zes-order.h line 16
struct Z_IORequest;

// tag-Z_IOResultSetItem
// file /usr/include/yaz/zes-order.h line 37
struct Z_IOResultSetItem;

// tag-Z_IOTargetPart
// file /usr/include/yaz/zes-order.h line 43
struct Z_IOTargetPart;

// tag-Z_IOTaskPackage
// file /usr/include/yaz/zes-order.h line 19
struct Z_IOTaskPackage;

// tag-Z_IU0CorrelationInfo
// file /usr/include/yaz/zes-update0.h line 43
struct Z_IU0CorrelationInfo;

// tag-Z_IU0OriginPartToKeep
// file /usr/include/yaz/zes-update0.h line 25
struct Z_IU0OriginPartToKeep;

// tag-Z_IU0SuppliedRecords
// file /usr/include/yaz/zes-update0.h line 37
struct Z_IU0SuppliedRecords;

// tag-Z_IU0SuppliedRecordsId
// file /usr/include/yaz/zes-update0.h line 31
struct Z_IU0SuppliedRecordsId;

// tag-Z_IU0SuppliedRecords_elem
// file /usr/include/yaz/zes-update0.h line 34
struct Z_IU0SuppliedRecords_elem;

// tag-Z_IU0TargetPart
// file /usr/include/yaz/zes-update0.h line 28
struct Z_IU0TargetPart;

// tag-Z_IU0TaskPackageRecordStructure
// file /usr/include/yaz/zes-update0.h line 46
struct Z_IU0TaskPackageRecordStructure;

// tag-Z_IU0Update
// file /usr/include/yaz/zes-update0.h line 22
struct Z_IU0Update;

// tag-Z_IU0UpdateEsRequest
// file /usr/include/yaz/zes-update0.h line 16
struct Z_IU0UpdateEsRequest;

// tag-Z_IU0UpdateTaskPackage
// file /usr/include/yaz/zes-update0.h line 19
struct Z_IU0UpdateTaskPackage;

// tag-Z_IUCorrelationInfo
// file /usr/include/yaz/zes-update.h line 43
struct Z_IUCorrelationInfo;

// tag-Z_IUOriginPartToKeep
// file /usr/include/yaz/zes-update.h line 25
struct Z_IUOriginPartToKeep;

// tag-Z_IUSuppliedRecords
// file /usr/include/yaz/zes-update.h line 37
struct Z_IUSuppliedRecords;

// tag-Z_IUSuppliedRecordsId
// file /usr/include/yaz/zes-update.h line 31
struct Z_IUSuppliedRecordsId;

// tag-Z_IUSuppliedRecords_elem
// file /usr/include/yaz/zes-update.h line 34
struct Z_IUSuppliedRecords_elem;

// tag-Z_IUTargetPart
// file /usr/include/yaz/zes-update.h line 28
struct Z_IUTargetPart;

// tag-Z_IUTaskPackageRecordStructure
// file /usr/include/yaz/zes-update.h line 49
struct Z_IUTaskPackageRecordStructure;

// tag-Z_IUTaskPackageRecordStructureSurrogateDiagnostics
// file /usr/include/yaz/zes-update.h line 46
struct Z_IUTaskPackageRecordStructureSurrogateDiagnostics;

// tag-Z_IUUpdate
// file /usr/include/yaz/zes-update.h line 22
struct Z_IUUpdate;

// tag-Z_IUUpdateEsRequest
// file /usr/include/yaz/zes-update.h line 16
struct Z_IUUpdateEsRequest;

// tag-Z_IUUpdateTaskPackage
// file /usr/include/yaz/zes-update.h line 19
struct Z_IUUpdateTaskPackage;

// tag-Z_IconObject
// file /usr/include/yaz/z-exp.h line 169
struct Z_IconObject;

// tag-Z_IconObjectUnit
// file /usr/include/yaz/z-exp.h line 166
struct Z_IconObjectUnit;

// tag-Z_ImportParameters
// file /usr/include/yaz/zes-admin.h line 34
struct Z_ImportParameters;

// tag-Z_InfoCategory
// file /usr/include/yaz/z-core.h line 292
struct Z_InfoCategory;

// tag-Z_InitialSet
// file /usr/include/yaz/z-charneg.h line 46
struct Z_InitialSet;

// tag-Z_IntUnit
// file /usr/include/yaz/z-core.h line 295
struct Z_IntUnit;

// tag-Z_Iso10646
// file /usr/include/yaz/z-charneg.h line 52
struct Z_Iso10646;

// tag-Z_Iso2022
// file /usr/include/yaz/z-charneg.h line 40
struct Z_Iso2022;

// tag-Z_Iso2022OriginProposal
// file /usr/include/yaz/z-charneg.h line 34
struct Z_Iso2022OriginProposal;

// tag-Z_Iso2022TargetResponse
// file /usr/include/yaz/z-charneg.h line 37
struct Z_Iso2022TargetResponse;

// tag-Z_Iso8777Capabilities
// file /usr/include/yaz/z-exp.h line 205
struct Z_Iso8777Capabilities;

// tag-Z_KRBObject
// file /usr/include/yaz/z-acckrb1.h line 16
struct Z_KRBObject;

// tag-Z_KRBRequest
// file /usr/include/yaz/z-acckrb1.h line 19
struct Z_KRBRequest;

// tag-Z_KRBResponse
// file /usr/include/yaz/z-acckrb1.h line 22
struct Z_KRBResponse;

// tag-Z_LeftAndRight
// file /usr/include/yaz/z-charneg.h line 49
struct Z_LeftAndRight;

// tag-Z_MultipleSearchTerms_2
// file /usr/include/yaz/z-mterm2.h line 19
struct Z_MultipleSearchTerms_2;

// tag-Z_MultipleSearchTerms_2_s
// file /usr/include/yaz/z-mterm2.h line 16
struct Z_MultipleSearchTerms_2_s;

// tag-Z_NamePlusRecord
// file /usr/include/yaz/z-core.h line 109
struct Z_NamePlusRecord;

// tag-Z_NetworkAddress
// file /usr/include/yaz/z-exp.h line 187
struct Z_NetworkAddress;

// tag-Z_NetworkAddressIA
// file /usr/include/yaz/z-exp.h line 178
struct Z_NetworkAddressIA;

// tag-Z_NetworkAddressOPA
// file /usr/include/yaz/z-exp.h line 181
struct Z_NetworkAddressOPA;

// tag-Z_NetworkAddressOther
// file /usr/include/yaz/z-exp.h line 184
struct Z_NetworkAddressOther;

// tag-Z_OCLC_UserInformation
// file /usr/include/yaz/z-oclcui.h line 15
struct Z_OCLC_UserInformation;

// tag-Z_OPACRecord
// file /usr/include/yaz/z-opac.h line 16
struct Z_OPACRecord;

// tag-Z_OccurValues
// file /usr/include/yaz/z-espec1.h line 44
struct Z_OccurValues;

// tag-Z_Occurrences
// file /usr/include/yaz/z-espec1.h line 47
struct Z_Occurrences;

// tag-Z_OidList
// file /usr/include/yaz/z-diag1.h line 64
struct Z_OidList;

// tag-Z_OmittedAttributeInterpretation
// file /usr/include/yaz/z-exp.h line 85
struct Z_OmittedAttributeInterpretation;

// tag-Z_Operand
// file /usr/include/yaz/z-core.h line 55
struct Z_Operand;

// tag-Z_Operator
// file /usr/include/yaz/z-core.h line 70
struct Z_Operator;

// tag-Z_Order
// file /usr/include/yaz/z-grs.h line 34
struct Z_Order;

// tag-Z_OriginProposal
// file /usr/include/yaz/z-charneg.h line 22
struct Z_OriginProposal;

// tag-Z_OriginProposal_0
// file /usr/include/yaz/z-charneg.h line 19
struct Z_OriginProposal_0;

// tag-Z_OtherInformation
// file /usr/include/yaz/z-core.h line 289
struct Z_OtherInformation;

// tag-Z_OtherInformationUnit
// file /usr/include/yaz/z-core.h line 286
struct Z_OtherInformationUnit;

// tag-Z_PQSOriginPartNotToKeep
// file /usr/include/yaz/zes-psched.h line 29
struct Z_PQSOriginPartNotToKeep;

// tag-Z_PQSOriginPartToKeep
// file /usr/include/yaz/zes-psched.h line 26
struct Z_PQSOriginPartToKeep;

// tag-Z_PQSPeriod
// file /usr/include/yaz/zes-psched.h line 35
struct Z_PQSPeriod;

// tag-Z_PQSPeriodicQuerySchedule
// file /usr/include/yaz/zes-psched.h line 23
struct Z_PQSPeriodicQuerySchedule;

// tag-Z_PQSPeriodicQueryScheduleEsRequest
// file /usr/include/yaz/zes-psched.h line 17
struct Z_PQSPeriodicQueryScheduleEsRequest;

// tag-Z_PQSPeriodicQueryScheduleTaskPackage
// file /usr/include/yaz/zes-psched.h line 20
struct Z_PQSPeriodicQueryScheduleTaskPackage;

// tag-Z_PQSTargetPart
// file /usr/include/yaz/zes-psched.h line 32
struct Z_PQSTargetPart;

// tag-Z_PQueryOriginPartNotToKeep
// file /usr/include/yaz/zes-pquery.h line 28
struct Z_PQueryOriginPartNotToKeep;

// tag-Z_PQueryOriginPartToKeep
// file /usr/include/yaz/zes-pquery.h line 25
struct Z_PQueryOriginPartToKeep;

// tag-Z_PQueryPersistentQuery
// file /usr/include/yaz/zes-pquery.h line 22
struct Z_PQueryPersistentQuery;

// tag-Z_PQueryPersistentQueryEsRequest
// file /usr/include/yaz/zes-pquery.h line 16
struct Z_PQueryPersistentQueryEsRequest;

// tag-Z_PQueryPersistentQueryTaskPackage
// file /usr/include/yaz/zes-pquery.h line 19
struct Z_PQueryPersistentQueryTaskPackage;

// tag-Z_PROriginPartNotToKeep
// file /usr/include/yaz/zes-pset.h line 25
struct Z_PROriginPartNotToKeep;

// tag-Z_PRPersistentResultSet
// file /usr/include/yaz/zes-pset.h line 22
struct Z_PRPersistentResultSet;

// tag-Z_PRPersistentResultSetEsRequest
// file /usr/include/yaz/zes-pset.h line 16
struct Z_PRPersistentResultSetEsRequest;

// tag-Z_PRPersistentResultSetTaskPackage
// file /usr/include/yaz/zes-pset.h line 19
struct Z_PRPersistentResultSetTaskPackage;

// tag-Z_PRTargetPart
// file /usr/include/yaz/zes-pset.h line 28
struct Z_PRTargetPart;

// tag-Z_Path
// file /usr/include/yaz/z-exp.h line 37
struct Z_Path;

// tag-Z_PathUnit
// file /usr/include/yaz/z-exp.h line 34
struct Z_PathUnit;

// tag-Z_PerElementDetails
// file /usr/include/yaz/z-exp.h line 103
struct Z_PerElementDetails;

// tag-Z_Permissions
// file /usr/include/yaz/z-core.h line 253
struct Z_Permissions;

// tag-Z_Permissions_s
// file /usr/include/yaz/z-core.h line 250
struct Z_Permissions_s;

// tag-Z_PrivateCapOperator
// file /usr/include/yaz/z-exp.h line 196
struct Z_PrivateCapOperator;

// tag-Z_PrivateCapabilities
// file /usr/include/yaz/z-exp.h line 199
struct Z_PrivateCapabilities;

// tag-Z_PrivateCharacterSet
// file /usr/include/yaz/z-charneg.h line 31
struct Z_PrivateCharacterSet;

// tag-Z_PrivateCharacterSetViaOid
// file /usr/include/yaz/z-charneg.h line 28
struct Z_PrivateCharacterSetViaOid;

// tag-Z_ProcessingInformation
// file /usr/include/yaz/z-exp.h line 115
struct Z_ProcessingInformation;

// tag-Z_PromptId
// file /usr/include/yaz/z-accform1.h line 34
struct Z_PromptId;

// tag-Z_PromptIdEnumeratedPrompt
// file /usr/include/yaz/z-accform1.h line 31
struct Z_PromptIdEnumeratedPrompt;

// tag-Z_PromptObject1
// file /usr/include/yaz/z-accform1.h line 16
struct Z_PromptObject1;

// tag-Z_ProxSupportPrivate
// file /usr/include/yaz/z-exp.h line 208
struct Z_ProxSupportPrivate;

// tag-Z_ProxSupportUnit
// file /usr/include/yaz/z-exp.h line 211
struct Z_ProxSupportUnit;

// tag-Z_Proximity
// file /usr/include/yaz/z-diag1.h line 43
struct Z_Proximity;

// tag-Z_ProximityOperator
// file /usr/include/yaz/z-core.h line 79
struct Z_ProximityOperator;

// tag-Z_ProximitySupport
// file /usr/include/yaz/z-exp.h line 214
struct Z_ProximitySupport;

// tag-Z_Query
// file /usr/include/yaz/z-core.h line 43
struct Z_Query;

// tag-Z_QueryExpression
// file /usr/include/yaz/z-uifr1.h line 34
struct Z_QueryExpression;

// tag-Z_QueryExpressionTerm
// file /usr/include/yaz/z-uifr1.h line 31
struct Z_QueryExpressionTerm;

// tag-Z_QueryTypeDetails
// file /usr/include/yaz/z-exp.h line 193
struct Z_QueryTypeDetails;

// tag-Z_RPNQuery
// file /usr/include/yaz/z-core.h line 46
struct Z_RPNQuery;

// tag-Z_RPNStructure
// file /usr/include/yaz/z-core.h line 52
struct Z_RPNStructure;

// tag-Z_RecordSyntax
// file /usr/include/yaz/z-diag1.h line 73
struct Z_RecordSyntax;

// tag-Z_RecordSyntaxInfo
// file /usr/include/yaz/z-exp.h line 55
struct Z_RecordSyntaxInfo;

// tag-Z_RecordTag
// file /usr/include/yaz/z-exp.h line 106
struct Z_RecordTag;

// tag-Z_ResourceReport1
// file /usr/include/yaz/z-rrf1.h line 16
struct Z_ResourceReport1;

// tag-Z_ResourceReport2
// file /usr/include/yaz/z-rrf2.h line 16
struct Z_ResourceReport2;

// tag-Z_Response1
// file /usr/include/yaz/z-accform1.h line 28
struct Z_Response1;

// tag-Z_ResponseUnit1
// file /usr/include/yaz/z-accform1.h line 25
struct Z_ResponseUnit1;

// tag-Z_ResultSetPlusAttributes
// file /usr/include/yaz/z-core.h line 61
struct Z_ResultSetPlusAttributes;

// tag-Z_ResultsByDB
// file /usr/include/yaz/z-uifr1.h line 28
struct Z_ResultsByDB;

// tag-Z_ResultsByDB_s
// file /usr/include/yaz/z-uifr1.h line 25
struct Z_ResultsByDB_s;

// tag-Z_ResultsByDB_sList
// file /usr/include/yaz/z-uifr1.h line 22
struct Z_ResultsByDB_sList;

// tag-Z_RetrievalRecordDetails
// file /usr/include/yaz/z-exp.h line 100
struct Z_RetrievalRecordDetails;

// tag-Z_RpnCapabilities
// file /usr/include/yaz/z-exp.h line 202
struct Z_RpnCapabilities;

// tag-Z_Scan
// file /usr/include/yaz/z-diag1.h line 49
struct Z_Scan;

// tag-Z_SchemaInfo
// file /usr/include/yaz/z-exp.h line 28
struct Z_SchemaInfo;

// tag-Z_SearchInfoReport
// file /usr/include/yaz/z-uifr1.h line 19
struct Z_SearchInfoReport;

// tag-Z_SearchInfoReport_s
// file /usr/include/yaz/z-uifr1.h line 16
struct Z_SearchInfoReport_s;

// tag-Z_SearchKey
// file /usr/include/yaz/z-exp.h line 217
struct Z_SearchKey;

// tag-Z_Segment
// file /usr/include/yaz/z-core.h line 94
struct Z_Segment;

// tag-Z_Segmentation
// file /usr/include/yaz/z-diag1.h line 58
struct Z_Segmentation;

// tag-Z_SimpleElement
// file /usr/include/yaz/z-espec1.h line 32
struct Z_SimpleElement;

// tag-Z_Sort
// file /usr/include/yaz/z-diag1.h line 55
struct Z_Sort;

// tag-Z_SortAttributes
// file /usr/include/yaz/z-core.h line 238
struct Z_SortAttributes;

// tag-Z_SortDbSpecificList
// file /usr/include/yaz/z-core.h line 232
struct Z_SortDbSpecificList;

// tag-Z_SortDbSpecificList_s
// file /usr/include/yaz/z-core.h line 229
struct Z_SortDbSpecificList_s;

// tag-Z_SortDetails
// file /usr/include/yaz/z-exp.h line 109
struct Z_SortDetails;

// tag-Z_SortElement
// file /usr/include/yaz/z-core.h line 235
struct Z_SortElement;

// tag-Z_SortKey
// file /usr/include/yaz/z-core.h line 241
struct Z_SortKey;

// tag-Z_SortKeyDetails
// file /usr/include/yaz/z-exp.h line 112
struct Z_SortKeyDetails;

// tag-Z_SpecificTag
// file /usr/include/yaz/z-espec1.h line 35
struct Z_SpecificTag;

// tag-Z_Specification
// file /usr/include/yaz/z-core.h line 145
struct Z_Specification;

// tag-Z_StringList
// file /usr/include/yaz/z-diag1.h line 52
struct Z_StringList;

// tag-Z_StringOrNumeric
// file /usr/include/yaz/z-core.h line 313
struct Z_StringOrNumeric;

// tag-Z_TagPath
// file /usr/include/yaz/z-grs.h line 31
struct Z_TagPath;

// tag-Z_TagPath_s
// file /usr/include/yaz/z-grs.h line 28
struct Z_TagPath_s;

// tag-Z_TagSetElements
// file /usr/include/yaz/z-exp.h line 49
struct Z_TagSetElements;

// tag-Z_TagSetInfo
// file /usr/include/yaz/z-exp.h line 52
struct Z_TagSetInfo;

// tag-Z_TagTypeMapping
// file /usr/include/yaz/z-exp.h line 25
struct Z_TagTypeMapping;

// tag-Z_TaggedElement
// file /usr/include/yaz/z-grs.h line 19
struct Z_TaggedElement;

// tag-Z_TargetInfo
// file /usr/include/yaz/z-exp.h line 19
struct Z_TargetInfo;

// tag-Z_TargetResponse
// file /usr/include/yaz/z-charneg.h line 25
struct Z_TargetResponse;

// tag-Z_TaskPackage
// file /usr/include/yaz/z-estask.h line 16
struct Z_TaskPackage;

// tag-Z_Term
// file /usr/include/yaz/z-core.h line 67
struct Z_Term;

// tag-Z_TermListDetails
// file /usr/include/yaz/z-exp.h line 94
struct Z_TermListDetails;

// tag-Z_TermListElement
// file /usr/include/yaz/z-exp.h line 67
struct Z_TermListElement;

// tag-Z_TermListInfo
// file /usr/include/yaz/z-exp.h line 70
struct Z_TermListInfo;

// tag-Z_Time
// file /usr/include/yaz/z-date.h line 37
struct Z_Time;

// tag-Z_TooMany
// file /usr/include/yaz/z-diag1.h line 22
struct Z_TooMany;

// tag-Z_Triple
// file /usr/include/yaz/z-grs.h line 43
struct Z_Triple;

// tag-Z_Unit
// file /usr/include/yaz/z-core.h line 298
struct Z_Unit;

// tag-Z_UnitInfo
// file /usr/include/yaz/z-exp.h line 142
struct Z_UnitInfo;

// tag-Z_UnitType
// file /usr/include/yaz/z-exp.h line 145
struct Z_UnitType;

// tag-Z_Units
// file /usr/include/yaz/z-exp.h line 148
struct Z_Units;

// tag-Z_UniverseReport
// file /usr/include/yaz/z-univ.h line 22
struct Z_UniverseReport;

// tag-Z_UniverseReportDuplicate
// file /usr/include/yaz/z-univ.h line 19
struct Z_UniverseReportDuplicate;

// tag-Z_UniverseReportHits
// file /usr/include/yaz/z-univ.h line 16
struct Z_UniverseReportHits;

// tag-Z_Usage
// file /usr/include/yaz/z-grs.h line 37
struct Z_Usage;

// tag-Z_ValueDescription
// file /usr/include/yaz/z-exp.h line 139
struct Z_ValueDescription;

// tag-Z_ValueRange
// file /usr/include/yaz/z-exp.h line 136
struct Z_ValueRange;

// tag-Z_ValueSet
// file /usr/include/yaz/z-exp.h line 133
struct Z_ValueSet;

// tag-Z_ValueSetEnumerated
// file /usr/include/yaz/z-exp.h line 130
struct Z_ValueSetEnumerated;

// tag-Z_Variant
// file /usr/include/yaz/z-grs.h line 46
struct Z_Variant;

// tag-Z_VariantClass
// file /usr/include/yaz/z-exp.h line 121
struct Z_VariantClass;

// tag-Z_VariantSetInfo
// file /usr/include/yaz/z-exp.h line 118
struct Z_VariantSetInfo;

// tag-Z_VariantType
// file /usr/include/yaz/z-exp.h line 124
struct Z_VariantType;

// tag-Z_VariantValue
// file /usr/include/yaz/z-exp.h line 127
struct Z_VariantValue;

// tag-Z_Volume
// file /usr/include/yaz/z-opac.h line 25
struct Z_Volume;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_xmlAttr
// file /usr/include/libxml2/libxml/tree.h line 432
struct _xmlAttr;

// tag-_xmlDict
// file /usr/include/libxml2/libxml/dict.h line 25
struct _xmlDict;

// tag-_xmlDoc
// file /usr/include/libxml2/libxml/tree.h line 262
struct _xmlDoc;

// tag-_xmlDtd
// file /usr/include/libxml2/libxml/tree.h line 259
struct _xmlDtd;

// tag-_xmlNode
// file /usr/include/libxml2/libxml/tree.h line 257
struct _xmlNode;

// tag-_xmlNs
// file /usr/include/libxml2/libxml/tree.h line 387
struct _xmlNs;

// tag-chr_t_entry
// file ../include/charmap.h line 35
struct chr_t_entry;

// tag-chrmaptab_info
// file ../include/charmap.h line 38
struct chrmaptab_info;

// tag-chrwork
// file charmap.c line 74
struct chrwork;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-icu_chain
// file /usr/include/yaz/icu.h line 45
struct icu_chain;

// tag-iscz1_code_info
// file it_key.c line 125
struct iscz1_code_info;

// tag-it_key
// file ../include/it_key.h line 30
struct it_key;

// tag-nmem_control
// file /usr/include/yaz/nmem.h line 44
struct nmem_control;

// tag-odr_bitmask
// file /usr/include/yaz/odr.h line 111
struct odr_bitmask;

// tag-odr_oct
// file /usr/include/yaz/odr.h line 99
struct odr_oct;

// tag-passwd_db
// file ../include/passwddb.h line 27
struct passwd_db;

// tag-passwd_entry
// file passwddb.c line 41
struct passwd_entry;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-res_entry
// file res.c line 40
struct res_entry;

// tag-res_struct
// file ../include/idzebra/res.h line 27
struct res_struct;

// tag-strmap_entry
// file strmap.c line 29
struct strmap_entry;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-wrbuf
// file /usr/include/yaz/wrbuf.h line 42
struct wrbuf;

// tag-xpath_location_step
// file ../include/zebra_xpath.h line 44
struct xpath_location_step;

// tag-xpath_predicate
// file ../include/zebra_xpath.h line 26
struct xpath_predicate;

// tag-yaz_iconv_struct
// file /usr/include/yaz/yaz-iconv.h line 42
struct yaz_iconv_struct;

// tag-yaz_tok_cfg
// file /usr/include/yaz/tokenizer.h line 43
struct yaz_tok_cfg;

// tag-yaz_tok_parse
// file /usr/include/yaz/tokenizer.h line 44
struct yaz_tok_parse;

// tag-zebra_lock_handle
// file ../include/idzebra/flock.h line 27
struct zebra_lock_handle;

// tag-zebra_lock_info
// file flock.c line 53
struct zebra_lock_info;

// tag-zebra_map
// file ../include/zebramap.h line 29
struct zebra_map;

// tag-zebra_maps_s
// file ../include/zebramap.h line 28
struct zebra_maps_s;

// tag-zebra_snippet_word
// file ../include/idzebra/snippet.h line 27
struct zebra_snippet_word;

// tag-zebra_snippets
// file ../include/idzebra/snippet.h line 38
struct zebra_snippets;

// tag-zebra_strmap
// file ../include/zebra_strmap.h line 27
struct zebra_strmap;

// tag-zebra_strmap_it_s
// file ../include/zebra_strmap.h line 28
struct zebra_strmap_it_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_entry
// file res.c line 60
static struct res_entry * add_entry(struct res_struct *r);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atoi_zn
// file atoi_zn.c line 27
signed long long int atoi_zn(const char *buf, signed long long int len);
// atoll
// file /usr/include/stdlib.h line 157
extern signed long long int atoll(const char *);
// atozint
// file zint.c line 55
signed long long int atozint(const char *src);
// attr_find
// file ../include/attrfind.h line 42
signed int attr_find(struct anonymous$89 *src, const signed short int **attribute_set_id);
// attr_find_ex
// file ../include/attrfind.h line 40
signed int attr_find_ex(struct anonymous$89 *src, const signed short int **attribute_set_oid, const char **string_value);
// attr_init_APT
// file ../include/attrfind.h line 36
void attr_init_APT(struct anonymous$89 *src, struct Z_AttributesPlusTerm *zapt, signed int type);
// attr_init_AttrList
// file ../include/attrfind.h line 38
void attr_init_AttrList(struct anonymous$89 *src, struct Z_AttributeList *list, signed int type);
// check_for_linuxthreads
// file flock.c line 371
static signed int check_for_linuxthreads(void);
// chr_map_input
// file charmap.c line 194
const char ** chr_map_input(struct chrmaptab_info *maptab, const char **from, signed int len, signed int first);
// chr_map_input_x
// file charmap.c line 184
const char ** chr_map_input_x(struct chrmaptab_info *maptab, const char **from, signed int *len, signed int first);
// chr_map_output
// file charmap.c line 221
const char * chr_map_output(struct chrmaptab_info *maptab, const char **from, signed int len);
// chr_map_q_input
// file charmap.c line 207
const char ** chr_map_q_input(struct chrmaptab_info *maptab, const char **from, signed int len, signed int first);
// chrmaptab_create
// file charmap.c line 513
struct chrmaptab_info * chrmaptab_create(const char *tabpath, const char *name, const char *tabroot);
// chrmaptab_destroy
// file charmap.c line 748
void chrmaptab_destroy(struct chrmaptab_info *tab);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// confstr
// file /usr/include/unistd.h line 623
extern unsigned long int confstr(signed int, char *, unsigned long int);
// crypt
// file /usr/include/crypt.h line 32
extern char * crypt(const char *, const char *);
// dump_xp_predicate
// file xpath.c line 216
void dump_xp_predicate(struct xpath_predicate *p);
// dump_xp_steps
// file xpath.c line 235
void dump_xp_steps(struct xpath_location_step *xpath, signed int no);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_entry_x
// file charmap.c line 141
static struct chr_t_entry * find_entry_x(struct chr_t_entry *t, const char **from, signed int *len, signed int first);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fork_tst
// file tstflock.c line 216
void fork_tst(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fun_add_equivalent_string
// file charmap.c line 369
static void fun_add_equivalent_string(const char *s, void *data, signed int num);
// fun_add_map
// file charmap.c line 381
static void fun_add_map(const char *s, void *data, signed int num);
// fun_addcut
// file charmap.c line 344
static void fun_addcut(const char *s, void *data, signed int num);
// fun_addentry
// file charmap.c line 318
static void fun_addentry(const char *s, void *data, signed int num);
// fun_addspace
// file charmap.c line 333
static void fun_addspace(const char *s, void *data, signed int num);
// fun_mkstring
// file charmap.c line 354
static void fun_mkstring(const char *s, void *data, signed int num);
// get_entry
// file passwddb.c line 59
static signed int get_entry(const char **p, char *dst, signed int max);
// get_xp_part
// file xpath.c line 31
static char * get_xp_part(char **strs, struct nmem_control *mem, signed int *literal);
// get_xpath_boolean
// file xpath.c line 121
static struct xpath_predicate * get_xpath_boolean(char **pr, struct nmem_control *mem, char **look, signed int *literal);
// get_xpath_predicate
// file xpath.c line 151
static struct xpath_predicate * get_xpath_predicate(char *predicate, struct nmem_control *mem);
// get_xpath_relation
// file xpath.c line 82
static struct xpath_predicate * get_xpath_relation(char **pr, struct nmem_control *mem, char **look, signed int *literal);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hash
// file strmap.c line 70
static struct strmap_entry ** hash(struct zebra_strmap *st, const char *name);
// icu_chain_assign_cstr
// file /usr/include/yaz/icu.h line 66
signed int icu_chain_assign_cstr(struct icu_chain *, const char *, enum UErrorCode *);
// icu_chain_destroy
// file /usr/include/yaz/icu.h line 48
void icu_chain_destroy(struct icu_chain *);
// icu_chain_next_token
// file /usr/include/yaz/icu.h line 79
signed int icu_chain_next_token(struct icu_chain *, enum UErrorCode *);
// icu_chain_token_display
// file /usr/include/yaz/icu.h line 94
const char * icu_chain_token_display(struct icu_chain *);
// icu_chain_token_sortkey
// file /usr/include/yaz/icu.h line 110
const char * icu_chain_token_sortkey(struct icu_chain *);
// icu_chain_xml_config
// file /usr/include/yaz/icu.h line 56
struct icu_chain * icu_chain_xml_config(const struct _xmlNode *, signed int, enum UErrorCode *);
// iscz1_decode
// file it_key.c line 237
void iscz1_decode(void *vp, char **dst, const char **src);
// iscz1_decode_int
// file it_key.c line 174
static inline signed long long int iscz1_decode_int(unsigned char **src);
// iscz1_encode
// file it_key.c line 189
void iscz1_encode(void *vp, char **dst, const char **src);
// iscz1_encode_int
// file it_key.c line 160
static inline void iscz1_encode_int(signed long long int d, char **dst);
// iscz1_reset
// file it_key.c line 145
void iscz1_reset(void *vp);
// iscz1_start
// file it_key.c line 129
void * iscz1_start(void);
// iscz1_stop
// file it_key.c line 154
void iscz1_stop(void *p);
// key_SU_decode
// file su_codec.c line 64
signed int key_SU_decode(signed int *ch, const unsigned char *out);
// key_SU_encode
// file su_codec.c line 31
signed int key_SU_encode(signed int ch, char *out);
// key_compare
// file it_key.c line 73
signed int key_compare(const void *p1, const void *p2);
// key_get_segment
// file it_key.c line 103
signed long long int key_get_segment(const void *p);
// key_get_seq
// file it_key.c line 96
signed long long int key_get_seq(const void *p);
// key_init
// file it_key.c line 137
void key_init(struct it_key *key);
// key_logdump
// file it_key.c line 62
void key_logdump(signed int logmask, const void *p);
// key_logdump_txt
// file it_key.c line 37
void key_logdump_txt(signed int logmask, const void *p, const char *txt);
// key_print_it
// file it_key.c line 67
char * key_print_it(const void *p, char *buf);
// key_qsort_compare
// file it_key.c line 110
signed int key_qsort_compare(const void *p1, const void *p2);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// nmem_create
// file /usr/include/yaz/nmem.h line 190
struct nmem_control * nmem_create(void);
// nmem_destroy
// file /usr/include/yaz/nmem.h line 195
void nmem_destroy(struct nmem_control *);
// nmem_malloc
// file /usr/include/yaz/nmem.h line 202
void * nmem_malloc(struct nmem_control *, unsigned long int);
// nmem_strdup
// file /usr/include/yaz/nmem.h line 88
char * nmem_strdup(struct nmem_control *, const char *);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse_command
// file zebramap.c line 140
static signed int parse_command(struct zebra_maps_s *zms, signed int argc, char **argv, const char *fname, signed int lineno);
// passwd_db_auth
// file passwddb.c line 128
signed int passwd_db_auth(struct passwd_db *db, const char *user, const char *pass);
// passwd_db_close
// file passwddb.c line 106
void passwd_db_close(struct passwd_db *db);
// passwd_db_file_crypt
// file passwddb.c line 172
signed int passwd_db_file_crypt(struct passwd_db *db, const char *fname);
// passwd_db_file_int
// file passwddb.c line 75
static signed int passwd_db_file_int(struct passwd_db *db, const char *fname, signed int encrypt_flag);
// passwd_db_file_plain
// file passwddb.c line 181
signed int passwd_db_file_plain(struct passwd_db *db, const char *fname);
// passwd_db_open
// file passwddb.c line 52
struct passwd_db * passwd_db_open(void);
// passwd_db_show
// file passwddb.c line 121
void passwd_db_show(struct passwd_db *db);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$48 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$48 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$48 *, const union anonymous$53 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$48 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$48 *, union anonymous$47 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$48 *, union anonymous$47 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$47 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$47 *, const union anonymous$53 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$47 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$47 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// readconf_line
// file /usr/include/yaz/readconf.h line 45
signed int readconf_line(struct _IO_FILE *, signed int *, char *, signed int, char **, signed int);
// res_add
// file res.c line 445
void res_add(struct res_struct *r, const char *name, const char *value);
// res_check
// file res.c line 479
signed int res_check(struct res_struct *r_i, struct res_struct *r_v);
// res_clear
// file res.c line 246
void res_clear(struct res_struct *r);
// res_close
// file res.c line 261
void res_close(struct res_struct *r);
// res_dump
// file res.c line 457
void res_dump(struct res_struct *r, signed int level);
// res_get
// file res.c line 294
const char * res_get(struct res_struct *r, const char *name);
// res_get_def
// file res.c line 313
const char * res_get_def(struct res_struct *r, const char *name, const char *def);
// res_get_int
// file res.c line 432
signed short int res_get_int(struct res_struct *r, const char *name, signed int *val);
// res_get_match
// file res.c line 327
signed int res_get_match(struct res_struct *r, const char *name, const char *value, const char *s);
// res_get_prefix
// file res.c line 272
const char * res_get_prefix(struct res_struct *r, const char *name, const char *prefix, const char *def);
// res_incref
// file res.c line 53
static struct res_struct * res_incref(struct res_struct *r);
// res_open
// file res.c line 234
struct res_struct * res_open(struct res_struct *def_res, struct res_struct *over_res);
// res_read_file
// file res.c line 146
signed short int res_read_file(struct res_struct *r, const char *fname);
// res_set
// file res.c line 338
void res_set(struct res_struct *r, const char *name, const char *value);
// res_trav
// file res.c line 357
signed int res_trav(struct res_struct *r, const char *prefix, void *p, void (*f)(void *, const char *, const char *));
// res_trav::f$object
// 
void f$object(void *, const char *, const char *);
// res_write_file
// file res.c line 384
signed short int res_write_file(struct res_struct *r, const char *fname);
// run_func
// file tstflock.c line 98
void * run_func(void *arg);
// scan_string
// file charmap.c line 421
static signed int scan_string(char *s_native, struct yaz_iconv_struct *t_unicode, struct yaz_iconv_struct *t_utf8, void (*fun)(const char *, void *, signed int), void *data, signed int *num);
// scan_string::fun$object
// 
void fun$object(const char *, void *, signed int);
// scan_to_utf8
// file charmap.c line 393
static signed int scan_to_utf8(struct yaz_iconv_struct *t, unsigned int *from, unsigned long int inlen, char *outbuf, unsigned long int outbytesleft);
// set_map_string
// file charmap.c line 92
static struct chr_t_entry * set_map_string(struct chr_t_entry *root, struct nmem_control *nmem, const char *from, signed int len, char *to, const char *from_0);
// small_sleep
// file tstflock.c line 74
static void small_sleep(void);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// tokenize_simple
// file zebramap.c line 628
static signed int tokenize_simple(struct zebra_map *zm, const char **result_buf, unsigned long int *result_len);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// tst
// file tstflock.c line 197
static void tst(void);
// tst_thread
// file tstflock.c line 149
static void tst_thread(signed int num, signed int write_flag);
// unixLock
// file flock.c line 232
static signed int unixLock(signed int fd, signed int type, signed int cmd);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// wrbuf_alloc
// file /usr/include/yaz/wrbuf.h line 52
struct wrbuf * wrbuf_alloc(void);
// wrbuf_cstr
// file /usr/include/yaz/wrbuf.h line 229
const char * wrbuf_cstr(struct wrbuf *);
// wrbuf_destroy
// file /usr/include/yaz/wrbuf.h line 59
void wrbuf_destroy(struct wrbuf *);
// wrbuf_grow
// file /usr/include/yaz/wrbuf.h line 220
signed int wrbuf_grow(struct wrbuf *, unsigned long int);
// wrbuf_puts
// file /usr/include/yaz/wrbuf.h line 85
void wrbuf_puts(struct wrbuf *, const char *);
// wrbuf_puts_escaped
// file /usr/include/yaz/wrbuf.h line 121
void wrbuf_puts_escaped(struct wrbuf *, const char *);
// wrbuf_rewind
// file /usr/include/yaz/wrbuf.h line 64
void wrbuf_rewind(struct wrbuf *);
// wrbuf_write
// file /usr/include/yaz/wrbuf.h line 71
void wrbuf_write(struct wrbuf *, const char *, unsigned long int);
// wrbuf_write_escaped
// file /usr/include/yaz/wrbuf.h line 130
void wrbuf_write_escaped(struct wrbuf *, const char *, unsigned long int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xfree_f
// file /usr/include/yaz/xmalloc.h line 128
void xfree_f(void *, const char *, signed int);
// xmalloc_f
// file /usr/include/yaz/xmalloc.h line 82
void * xmalloc_f(unsigned long int, const char *, signed int);
// xmlDocGetRootElement
// file /usr/include/libxml2/libxml/tree.h line 920
struct _xmlNode * xmlDocGetRootElement(const struct _xmlDoc *);
// xmlFreeDoc
// file /usr/include/libxml2/libxml/tree.h line 782
void xmlFreeDoc(struct _xmlDoc *);
// xmlParseFile
// file /usr/include/libxml2/libxml/parser.h line 844
struct _xmlDoc * xmlParseFile(const char *);
// xstrdup_env
// file res.c line 77
static char * xstrdup_env(const char *src);
// xstrdup_f
// file /usr/include/yaz/xmalloc.h line 105
char * xstrdup_f(const char *, const char *, signed int);
// yaz_check_eq1
// file /usr/include/yaz/test.h line 107
void yaz_check_eq1(signed int, const char *, signed int, const char *, const char *, signed int, signed int);
// yaz_check_init1
// file /usr/include/yaz/test.h line 95
void yaz_check_init1(signed int *, char ***);
// yaz_check_init_log
// file /usr/include/yaz/test.h line 101
void yaz_check_init_log(const char *);
// yaz_check_print1
// file /usr/include/yaz/test.h line 104
void yaz_check_print1(signed int, const char *, signed int, const char *);
// yaz_check_term1
// file /usr/include/yaz/test.h line 98
void yaz_check_term1(void);
// yaz_fclose
// file /usr/include/yaz/tpath.h line 100
signed int yaz_fclose(struct _IO_FILE *);
// yaz_filepath_resolve
// file /usr/include/yaz/tpath.h line 71
char * yaz_filepath_resolve(const char *, const char *, const char *, char *);
// yaz_fopen
// file /usr/include/yaz/tpath.h line 82
struct _IO_FILE * yaz_fopen(const char *, const char *, const char *, const char *);
// yaz_iconv
// file /usr/include/yaz/yaz-iconv.h line 57
unsigned long int yaz_iconv(struct yaz_iconv_struct *, char **, unsigned long int *, char **, unsigned long int *);
// yaz_iconv_close
// file /usr/include/yaz/yaz-iconv.h line 63
signed int yaz_iconv_close(struct yaz_iconv_struct *);
// yaz_iconv_open
// file /usr/include/yaz/yaz-iconv.h line 54
struct yaz_iconv_struct * yaz_iconv_open(const char *, const char *);
// yaz_log
// file /usr/include/yaz/log.h line 140
void yaz_log(signed int, const char *, ...);
// yaz_log_init_level
// file /usr/include/yaz/log.h line 102
void yaz_log_init_level(signed int);
// yaz_log_mask_str
// file /usr/include/yaz/log.h line 156
signed int yaz_log_mask_str(const char *);
// yaz_log_module_level
// file /usr/include/yaz/log.h line 178
signed int yaz_log_module_level(const char *);
// yaz_matchstr
// file /usr/include/yaz/matchstr.h line 47
signed int yaz_matchstr(const char *, const char *);
// yaz_tok_cfg_create
// file /usr/include/yaz/tokenizer.h line 49
struct yaz_tok_cfg * yaz_tok_cfg_create(void);
// yaz_tok_cfg_destroy
// file /usr/include/yaz/tokenizer.h line 52
void yaz_tok_cfg_destroy(struct yaz_tok_cfg *);
// yaz_tok_move
// file /usr/include/yaz/tokenizer.h line 68
signed int yaz_tok_move(struct yaz_tok_parse *);
// yaz_tok_parse_buf
// file /usr/include/yaz/tokenizer.h line 58
struct yaz_tok_parse * yaz_tok_parse_buf(struct yaz_tok_cfg *, const char *);
// yaz_tok_parse_destroy
// file /usr/include/yaz/tokenizer.h line 65
void yaz_tok_parse_destroy(struct yaz_tok_parse *);
// yaz_tok_parse_string
// file /usr/include/yaz/tokenizer.h line 71
const char * yaz_tok_parse_string(struct yaz_tok_parse *);
// zebra_add_map
// file zebramap.c line 106
struct zebra_map * zebra_add_map(struct zebra_maps_s *zms, const char *index_type, signed int map_type);
// zebra_charmap_get
// file zebramap.c line 381
struct chrmaptab_info * zebra_charmap_get(struct zebra_map *zm);
// zebra_exit
// file exit.c line 26
void zebra_exit(const char *msg);
// zebra_flock_init
// file ../include/idzebra/flock.h line 46
void zebra_flock_init(void);
// zebra_get_version
// file version.c line 33
void zebra_get_version(char *version_str, char *sha1_str);
// zebra_lock_create
// file ../include/idzebra/flock.h line 30
struct zebra_lock_handle * zebra_lock_create(const char *dir, const char *name);
// zebra_lock_destroy
// file ../include/idzebra/flock.h line 33
void zebra_lock_destroy(struct zebra_lock_handle *h);
// zebra_lock_r
// file ../include/idzebra/flock.h line 43
signed int zebra_lock_r(struct zebra_lock_handle *h);
// zebra_lock_rdwr_destroy
// file zebra-lock.c line 100
signed int zebra_lock_rdwr_destroy(struct anonymous$56 *p);
// zebra_lock_rdwr_init
// file zebra-lock.c line 89
signed int zebra_lock_rdwr_init(struct anonymous$56 *p);
// zebra_lock_rdwr_rlock
// file zebra-lock.c line 111
signed int zebra_lock_rdwr_rlock(struct anonymous$56 *p);
// zebra_lock_rdwr_runlock
// file zebra-lock.c line 135
signed int zebra_lock_rdwr_runlock(struct anonymous$56 *p);
// zebra_lock_rdwr_wlock
// file zebra-lock.c line 123
signed int zebra_lock_rdwr_wlock(struct anonymous$56 *p);
// zebra_lock_rdwr_wunlock
// file zebra-lock.c line 155
signed int zebra_lock_rdwr_wunlock(struct anonymous$56 *p);
// zebra_lock_w
// file ../include/idzebra/flock.h line 41
signed int zebra_lock_w(struct zebra_lock_handle *h);
// zebra_map_get
// file zebramap.c line 354
struct zebra_map * zebra_map_get(struct zebra_maps_s *zms, const char *id);
// zebra_map_get_or_add
// file zebramap.c line 363
struct zebra_map * zebra_map_get_or_add(struct zebra_maps_s *zms, const char *id);
// zebra_map_tokenize_next
// file zebramap.c line 657
signed int zebra_map_tokenize_next(struct zebra_map *zm, const char **result_buf, unsigned long int *result_len, const char **display_buf, unsigned long int *display_len);
// zebra_map_tokenize_start
// file zebramap.c line 701
signed int zebra_map_tokenize_start(struct zebra_map *zm, const char *buf, unsigned long int len);
// zebra_maps_attr
// file zebramap.c line 514
signed int zebra_maps_attr(struct zebra_maps_s *zms, struct Z_AttributesPlusTerm *zapt, const char **index_type, char **search_type, char *rank_type, signed int *complete_flag, signed int *sort_flag);
// zebra_maps_close
// file zebramap.c line 83
void zebra_maps_close(struct zebra_maps_s *zms);
// zebra_maps_define_default_sort
// file zebramap.c line 348
void zebra_maps_define_default_sort(struct zebra_maps_s *zms);
// zebra_maps_input
// file zebramap.c line 398
const char ** zebra_maps_input(struct zebra_map *zm, const char **from, signed int len, signed int first);
// zebra_maps_is_alwaysmatches
// file zebramap.c line 484
signed int zebra_maps_is_alwaysmatches(struct zebra_map *zm);
// zebra_maps_is_complete
// file zebramap.c line 449
signed int zebra_maps_is_complete(struct zebra_map *zm);
// zebra_maps_is_first_in_field
// file zebramap.c line 491
signed int zebra_maps_is_first_in_field(struct zebra_map *zm);
// zebra_maps_is_icu
// file zebramap.c line 740
signed int zebra_maps_is_icu(struct zebra_map *zm);
// zebra_maps_is_index
// file zebramap.c line 463
signed int zebra_maps_is_index(struct zebra_map *zm);
// zebra_maps_is_positioned
// file zebramap.c line 456
signed int zebra_maps_is_positioned(struct zebra_map *zm);
// zebra_maps_is_sort
// file zebramap.c line 477
signed int zebra_maps_is_sort(struct zebra_map *zm);
// zebra_maps_is_staticrank
// file zebramap.c line 470
signed int zebra_maps_is_staticrank(struct zebra_map *zm);
// zebra_maps_open
// file zebramap.c line 323
struct zebra_maps_s * zebra_maps_open(struct res_struct *res, const char *base_path, const char *profile_path);
// zebra_maps_output
// file zebramap.c line 437
const char * zebra_maps_output(struct zebra_map *zm, const char **from);
// zebra_maps_read_file
// file zebramap.c line 294
signed short int zebra_maps_read_file(struct zebra_maps_s *zms, const char *fname);
// zebra_maps_search
// file zebramap.c line 411
const char ** zebra_maps_search(struct zebra_map *zm, const char **from, signed int len, signed int *q_map_match);
// zebra_maps_sort
// file zebramap.c line 498
signed int zebra_maps_sort(struct zebra_maps_s *zms, struct Z_SortAttributes *sortAttributes, signed int *numerical);
// zebra_mk_fname
// file flock.c line 84
char * zebra_mk_fname(const char *dir, const char *name);
// zebra_mutex_cond_destroy
// file zebra-lock.c line 183
signed int zebra_mutex_cond_destroy(struct anonymous$49 *p);
// zebra_mutex_cond_init
// file zebra-lock.c line 174
signed int zebra_mutex_cond_init(struct anonymous$49 *p);
// zebra_mutex_cond_lock
// file zebra-lock.c line 192
signed int zebra_mutex_cond_lock(struct anonymous$49 *p);
// zebra_mutex_cond_signal
// file zebra-lock.c line 219
signed int zebra_mutex_cond_signal(struct anonymous$49 *p);
// zebra_mutex_cond_unlock
// file zebra-lock.c line 201
signed int zebra_mutex_cond_unlock(struct anonymous$49 *p);
// zebra_mutex_cond_wait
// file zebra-lock.c line 210
signed int zebra_mutex_cond_wait(struct anonymous$49 *p);
// zebra_mutex_destroy
// file zebra-lock.c line 43
signed int zebra_mutex_destroy(struct anonymous$54 *p);
// zebra_mutex_init
// file zebra-lock.c line 31
signed int zebra_mutex_init(struct anonymous$54 *p);
// zebra_mutex_lock
// file zebra-lock.c line 59
signed int zebra_mutex_lock(struct anonymous$54 *p);
// zebra_mutex_unlock
// file zebra-lock.c line 74
signed int zebra_mutex_unlock(struct anonymous$54 *p);
// zebra_parse_xpath_str
// file xpath.c line 162
signed int zebra_parse_xpath_str(const char *xpath_string, struct xpath_location_step *xpath, signed int max, struct nmem_control *mem);
// zebra_prim_w
// file charmap.c line 239
unsigned int zebra_prim_w(unsigned int **s);
// zebra_replace
// file zebramap.c line 618
struct wrbuf * zebra_replace(struct zebra_map *zm, const char *ex_list, const char *input_str, signed int input_len);
// zebra_snippets_append
// file snippet.c line 51
void zebra_snippets_append(struct zebra_snippets *l, signed long long int seqno, signed int ws, signed int ord, const char *term);
// zebra_snippets_append_match
// file snippet.c line 65
void zebra_snippets_append_match(struct zebra_snippets *l, signed long long int seqno, signed int ws, signed int ord, const char *term, unsigned long int term_len, signed int match);
// zebra_snippets_appendn
// file snippet.c line 57
void zebra_snippets_appendn(struct zebra_snippets *l, signed long long int seqno, signed int ws, signed int ord, const char *term, unsigned long int term_len);
// zebra_snippets_clear
// file snippet.c line 207
static void zebra_snippets_clear(struct zebra_snippets *sn);
// zebra_snippets_constlist
// file snippet.c line 99
const struct zebra_snippet_word * zebra_snippets_constlist(const struct zebra_snippets *l);
// zebra_snippets_create
// file snippet.c line 36
struct zebra_snippets * zebra_snippets_create(void);
// zebra_snippets_destroy
// file snippet.c line 45
void zebra_snippets_destroy(struct zebra_snippets *l);
// zebra_snippets_list
// file snippet.c line 94
struct zebra_snippet_word * zebra_snippets_list(struct zebra_snippets *l);
// zebra_snippets_log
// file snippet.c line 104
void zebra_snippets_log(const struct zebra_snippets *l, signed int log_level, signed int all);
// zebra_snippets_lookup
// file snippet.c line 218
struct zebra_snippet_word * zebra_snippets_lookup(const struct zebra_snippets *doc, const struct zebra_snippets *hit);
// zebra_snippets_ring
// file snippet.c line 237
void zebra_snippets_ring(struct zebra_snippets *doc, const struct zebra_snippets *hit, signed int before, signed int after);
// zebra_snippets_window
// file snippet.c line 121
struct zebra_snippets * zebra_snippets_window(const struct zebra_snippets *doc, const struct zebra_snippets *hit, signed int window_size);
// zebra_strmap_add
// file strmap.c line 80
void zebra_strmap_add(struct zebra_strmap *st, const char *name, void *data_buf, unsigned long int data_len);
// zebra_strmap_create
// file strmap.c line 45
struct zebra_strmap * zebra_strmap_create(void);
// zebra_strmap_destroy
// file strmap.c line 61
void zebra_strmap_destroy(struct zebra_strmap *st);
// zebra_strmap_get_size
// file strmap.c line 136
signed int zebra_strmap_get_size(struct zebra_strmap *st);
// zebra_strmap_it_create
// file strmap.c line 148
struct zebra_strmap_it_s * zebra_strmap_it_create(struct zebra_strmap *st);
// zebra_strmap_it_destroy
// file strmap.c line 157
void zebra_strmap_it_destroy(struct zebra_strmap_it_s *it);
// zebra_strmap_it_next
// file strmap.c line 162
const char * zebra_strmap_it_next(struct zebra_strmap_it_s *it, void **data_buf, unsigned long int *data_len);
// zebra_strmap_lookup
// file strmap.c line 99
void * zebra_strmap_lookup(struct zebra_strmap *st, const char *name, signed int no, unsigned long int *data_len);
// zebra_strmap_remove
// file strmap.c line 118
signed int zebra_strmap_remove(struct zebra_strmap *st, const char *name);
// zebra_ucs4_strlen
// file charmap.c line 231
static signed int zebra_ucs4_strlen(unsigned int *s);
// zebra_unlock
// file ../include/idzebra/flock.h line 36
signed int zebra_unlock(struct zebra_lock_handle *h);
// zebra_zint_decode
// file zint.c line 39
void zebra_zint_decode(const char **src, signed long long int *pos);
// zebra_zint_encode
// file zint.c line 26
void zebra_zint_encode(char **dst, signed long long int pos);

struct anonymous$65
{
  // name
  char *name;
  // op
  char *op;
  // value
  char *value;
};

struct anonymous$35
{
  // nmem
  struct nmem_control *nmem;
  // no_eq
  signed int no_eq;
  // eq
  char *eq[32l];
};

struct anonymous$68
{
  // op
  const char *op;
  // left
  struct xpath_predicate *left;
  // right
  struct xpath_predicate *right;
};

struct anonymous$92
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$46
{
  // entry_size
  signed int entry_size;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$47
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$48
{
  // __data
  struct anonymous$92 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous$56
{
  // readers_reading
  signed int readers_reading;
  // writers_writing
  signed int writers_writing;
  // mutex
  union anonymous$47 mutex;
  // lock_free
  union anonymous$48 lock_free;
};

struct anonymous$89
{
  // type
  signed int type;
  // major
  signed int major;
  // minor
  signed int minor;
  // attributeList
  struct Z_AttributeElement **attributeList;
  // num_attributes
  signed int num_attributes;
};

struct anonymous$54
{
  // mutex
  union anonymous$47 mutex;
  // state
  signed int state;
};

struct anonymous$49
{
  // mutex
  union anonymous$47 mutex;
  // cond
  union anonymous$48 cond;
};

union anonymous$62
{
  // oid
  signed short int *oid;
  // uri
  char *uri;
};

union anonymous$64
{
  // actualNumber
  signed long long int *actualNumber;
  // approxNumber
  signed long long int *approxNumber;
};

union anonymous$59
{
  // integer
  signed long long int *integer;
  // internationalString
  char *internationalString;
  // octetString
  struct odr_oct *octetString;
  // objectIdentifier
  signed short int *objectIdentifier;
  // boolean
  signed int *boolean;
  // null
  void *null;
  // unit
  struct Z_Unit *unit;
  // valueAndUnit
  struct Z_IntUnit *valueAndUnit;
};

union anonymous$74
{
  // integer
  signed long long int *integer;
  // string
  char *string;
  // octets
  struct odr_oct *octets;
  // oid
  signed short int *oid;
  // unit
  struct Z_Unit *unit;
  // valueAndUnit
  struct Z_IntUnit *valueAndUnit;
};

union anonymous$15
{
  // known
  signed long long int *known;
  // zprivate
  signed long long int *zprivate;
};

union anonymous$22
{
  // known
  signed long long int *known;
  // zprivate
  struct Z_ProxSupportPrivate *zprivate;
};

union anonymous$45
{
  // number
  signed long long int *number;
  // string
  char *string;
  // opaque
  struct odr_oct *opaque;
};

union anonymous$8
{
  // numeric
  signed long long int *numeric;
  // complex
  struct Z_ComplexAttribute *complex;
};

union anonymous$70
{
  // primitive
  signed long long int *primitive;
  // structured
  struct Z_ElementInfoList *structured;
};

union anonymous$2
{
  // req
  signed long long int *req;
  // permission
  signed long long int *permission;
  // immediate
  signed long long int *immediate;
};

union anonymous$52
{
  // character
  char *character;
  // encrypted
  struct Z_Encryption *encrypted;
};

union anonymous$4
{
  // characterInfo
  char *characterInfo;
  // binaryInfo
  struct odr_oct *binaryInfo;
  // externallyDefinedInfo
  struct Z_External *externallyDefinedInfo;
  // oid
  signed short int *oid;
};

union anonymous$67
{
  // elementSetName
  char *elementSetName;
  // externalSpec
  struct Z_External *externalSpec;
};

union anonymous$75
{
  // ianaType
  char *ianaType;
  // z3950type
  char *z3950type;
  // otherType
  char *otherType;
};

union anonymous$94
{
  // package
  char *package;
  // query
  struct Z_Query *query;
};

union anonymous$96
{
  // packageName
  char *packageName;
  // exportPackage
  struct Z_ESExportSpecification *exportPackage;
};

union anonymous$87
{
  // packageName
  char *packageName;
  // packageSpec
  struct Z_ESExportSpecification *packageSpec;
};

union anonymous$85
{
  // phoneNumber
  char *phoneNumber;
  // faxNumber
  char *faxNumber;
  // x400address
  char *x400address;
  // emailAddress
  char *emailAddress;
  // pagerNumber
  char *pagerNumber;
  // ftpAddress
  char *ftpAddress;
  // ftamAddress
  char *ftamAddress;
  // printerAddress
  char *printerAddress;
  // other
  struct Z_ESDestinationOther *other;
};

union anonymous$83
{
  // sortField
  char *sortField;
  // elementSpec
  struct Z_Specification *elementSpec;
  // sortAttributes
  struct Z_SortAttributes *sortAttributes;
};

union anonymous$55
{
  // string
  char *string;
  // accept
  signed int *accept;
  // acknowledge
  void *acknowledge;
  // diagnostic
  struct Z_DiagRec *diagnostic;
  // encrypted
  struct Z_Encryption *encrypted;
};

union anonymous$7
{
  // string
  char *string;
  // numeric
  signed long long int *numeric;
};

union anonymous$38
{
  // timeStamp
  char *timeStamp;
  // versionNumber
  char *versionNumber;
  // previousVersion
  struct Z_External *previousVersion;
};

union anonymous$40
{
  // v2Addinfo
  char *v2Addinfo;
  // v3Addinfo
  char *v3Addinfo;
};

union anonymous$19
{
  // esRequest
  struct Z_AdminEsRequest *esRequest;
  // taskPackage
  struct Z_AdminTaskPackage *taskPackage;
};

union anonymous$100
{
  // attributesPlusTerm
  struct Z_AttributesPlusTerm *attributesPlusTerm;
  // resultSetId
  char *resultSetId;
  // resultAttr
  struct Z_ResultSetPlusAttributes *resultAttr;
};

union anonymous$39
{
  // challenge
  struct Z_Challenge1 *challenge;
  // response
  struct Z_Response1 *response;
};

union anonymous$43
{
  // challenge
  struct Z_DRNType *challenge;
  // response
  struct Z_DRNType *response;
};

union anonymous$41
{
  // monthAndDay
  struct Z_DateMonthAndDay *monthAndDay;
  // julianDay
  signed long long int *julianDay;
  // weekNumber
  signed long long int *weekNumber;
  // quarter
  struct Z_DateQuarter *quarter;
  // season
  struct Z_DateSeason *season;
};

union anonymous$20
{
  // defaultDiagRec
  struct Z_DefaultDiagFormat *defaultDiagRec;
  // explicitDiagnostic
  struct Z_DiagFormat *explicitDiagnostic;
};

union anonymous$5
{
  // defaultFormat
  struct Z_DefaultDiagFormat *defaultFormat;
  // externallyDefined
  struct Z_External *externallyDefined;
};

union anonymous$86
{
  // esRequest
  struct Z_EIExportInvocationEsRequest *esRequest;
  // taskPackage
  struct Z_EIExportInvocationTaskPackage *taskPackage;
};

union anonymous$84
{
  // esRequest
  struct Z_ESExportSpecificationEsRequest *esRequest;
  // taskPackage
  struct Z_ESExportSpecificationTaskPackage *taskPackage;
};

union anonymous$26
{
  // primitives
  struct Z_ElementRequestCompositeElementPrimitives *primitives;
  // specs
  struct Z_ElementRequestCompositeElementSpecs *specs;
};

union anonymous$18
{
  // databaseRecord
  struct Z_External *databaseRecord;
  // surrogateDiagnostic
  struct Z_DiagRec *surrogateDiagnostic;
  // startingFragment
  struct Z_FragmentSyntax *startingFragment;
  // intermediateFragment
  struct Z_FragmentSyntax *intermediateFragment;
  // finalFragment
  struct Z_FragmentSyntax *finalFragment;
};

union anonymous$36
{
  // externallyTagged
  struct Z_External *externallyTagged;
  // notExternallyTagged
  struct odr_oct *notExternallyTagged;
};

union anonymous$34
{
  // marcHoldingsRecord
  struct Z_External *marcHoldingsRecord;
  // holdingsAndCirc
  struct Z_HoldingsAndCircData *holdingsAndCirc;
};

union anonymous$37
{
  // record
  struct Z_External *record;
  // diagnostic
  struct Z_DiagRec *diagnostic;
};

union anonymous$6
{
  // record
  struct Z_External *record;
  // surrogateDiagnostics
  struct Z_IUTaskPackageRecordStructureSurrogateDiagnostics *surrogateDiagnostics;
};

union anonymous$90
{
  // esRequest
  struct Z_IORequest *esRequest;
  // taskPackage
  struct Z_IOTaskPackage *taskPackage;
};

union anonymous$33
{
  // esRequest
  struct Z_IU0UpdateEsRequest *esRequest;
  // taskPackage
  struct Z_IU0UpdateTaskPackage *taskPackage;
};

union anonymous
{
  // esRequest
  struct Z_IUUpdateEsRequest *esRequest;
  // taskPackage
  struct Z_IUUpdateTaskPackage *taskPackage;
};

union anonymous$99
{
  // unit
  struct Z_IntUnit *unit;
  // businessDaily
  void *businessDaily;
  // continuous
  void *continuous;
  // other
  char *other;
};

union anonymous$69
{
  // iso2022
  struct Z_Iso2022 *iso2022;
  // iso10646
  struct Z_Iso10646 *iso10646;
  // zprivate
  struct Z_PrivateCharacterSet *zprivate;
};

union anonymous$72
{
  // iso2022
  struct Z_Iso2022 *iso2022;
  // iso10646
  struct Z_Iso10646 *iso10646;
  // zprivate
  struct Z_PrivateCharacterSet *zprivate;
  // none
  void *none;
};

union anonymous$81
{
  // originProposal
  struct Z_Iso2022OriginProposal *originProposal;
  // targetResponse
  struct Z_Iso2022TargetResponse *targetResponse;
};

union anonymous$44
{
  // challenge
  struct Z_KRBRequest *challenge;
  // response
  struct Z_KRBResponse *response;
};

union anonymous$57
{
  // internetAddress
  struct Z_NetworkAddressIA *internetAddress;
  // osiPresentationAddress
  struct Z_NetworkAddressOPA *osiPresentationAddress;
  // other
  struct Z_NetworkAddressOther *other;
};

union anonymous$27
{
  // simple
  struct Z_Operand *simple;
  // complex
  struct Z_Complex *complex;
};

union anonymous$63
{
  // proposal
  struct Z_OriginProposal *proposal;
  // response
  struct Z_TargetResponse *response;
};

union anonymous$95
{
  // esRequest
  struct Z_PQSPeriodicQueryScheduleEsRequest *esRequest;
  // taskPackage
  struct Z_PQSPeriodicQueryScheduleTaskPackage *taskPackage;
};

union anonymous$93
{
  // esRequest
  struct Z_PQueryPersistentQueryEsRequest *esRequest;
  // taskPackage
  struct Z_PQueryPersistentQueryTaskPackage *taskPackage;
};

union anonymous$0
{
  // esRequest
  struct Z_PRPersistentResultSetEsRequest *esRequest;
  // taskPackage
  struct Z_PRPersistentResultSetTaskPackage *taskPackage;
};

union anonymous$76
{
  // zprivate
  struct Z_PrivateCapabilities *zprivate;
  // rpn
  struct Z_RpnCapabilities *rpn;
  // iso8777
  struct Z_Iso8777Capabilities *iso8777;
  // z39_58
  struct Z_HumanString *z39_58;
  // erpn
  struct Z_RpnCapabilities *erpn;
  // rankedList
  struct Z_HumanString *rankedList;
};

union anonymous$77
{
  // viaOid
  struct Z_PrivateCharacterSetViaOid *viaOid;
  // externallySpecified
  struct Z_External *externallySpecified;
  // previouslyAgreedUpon
  void *previouslyAgreedUpon;
};

union anonymous$50
{
  // enumeratedPrompt
  struct Z_PromptIdEnumeratedPrompt *enumeratedPrompt;
  // nonEnumeratedPrompt
  char *nonEnumeratedPrompt;
};

union anonymous$98
{
  // actualQuery
  struct Z_Query *actualQuery;
  // packageName
  char *packageName;
};

union anonymous$79
{
  // term
  struct Z_QueryExpressionTerm *term;
  // query
  struct Z_Query *query;
};

union anonymous$17
{
  // records
  struct Z_Segment *records;
  // recordsWillFollow
  void *recordsWillFollow;
};

union anonymous$29
{
  // simpleElement
  struct Z_SimpleElement *simpleElement;
  // compositeElement
  struct Z_ElementRequestCompositeElement *compositeElement;
};

union anonymous$24
{
  // generic
  struct Z_SortKey *generic;
  // databaseSpecific
  struct Z_SortDbSpecificList *databaseSpecific;
};

union anonymous$32
{
  // specificTag
  struct Z_SpecificTag *specificTag;
  // wildThing
  struct Z_Occurrences *wildThing;
  // wildPath
  void *wildPath;
};

union anonymous$51
{
  // targetInfo
  struct Z_TargetInfo *targetInfo;
  // databaseInfo
  struct Z_DatabaseInfo *databaseInfo;
  // schemaInfo
  struct Z_SchemaInfo *schemaInfo;
  // tagSetInfo
  struct Z_TagSetInfo *tagSetInfo;
  // recordSyntaxInfo
  struct Z_RecordSyntaxInfo *recordSyntaxInfo;
  // attributeSetInfo
  struct Z_AttributeSetInfo *attributeSetInfo;
  // termListInfo
  struct Z_TermListInfo *termListInfo;
  // extendedServicesInfo
  struct Z_ExtendedServicesInfo *extendedServicesInfo;
  // attributeDetails
  struct Z_AttributeDetails *attributeDetails;
  // termListDetails
  struct Z_TermListDetails *termListDetails;
  // elementSetDetails
  struct Z_ElementSetDetails *elementSetDetails;
  // retrievalRecordDetails
  struct Z_RetrievalRecordDetails *retrievalRecordDetails;
  // sortDetails
  struct Z_SortDetails *sortDetails;
  // processing
  struct Z_ProcessingInformation *processing;
  // variants
  struct Z_VariantSetInfo *variants;
  // units
  struct Z_UnitInfo *units;
  // categoryList
  struct Z_CategoryList *categoryList;
};

union anonymous$14
{
  // tooMany
  struct Z_TooMany *tooMany;
  // badSpec
  struct Z_BadSpec *badSpec;
  // dbUnavail
  struct Z_DbUnavail *dbUnavail;
  // unSupOp
  signed long long int *unSupOp;
  // attribute
  struct Z_Attribute *attribute;
  // attCombo
  struct Z_AttCombo *attCombo;
  // term
  struct Z_DiagTerm *term;
  // proximity
  struct Z_Proximity *proximity;
  // scan
  struct Z_Scan *scan;
  // sort
  struct Z_Sort *sort;
  // segmentation
  struct Z_Segmentation *segmentation;
  // extServices
  struct Z_ExtServices *extServices;
  // accessCtrl
  struct Z_AccessCtrl *accessCtrl;
  // recordSyntax
  struct Z_RecordSyntax *recordSyntax;
};

union anonymous$30
{
  // databaseHits
  struct Z_UniverseReportHits *databaseHits;
  // duplicate
  struct Z_UniverseReportDuplicate *duplicate;
};

union anonymous$73
{
  // range
  struct Z_ValueRange *range;
  // enumerated
  struct Z_ValueSetEnumerated *enumerated;
};

union anonymous$1
{
  // general
  struct odr_oct *general;
  // numeric
  signed long long int *numeric;
  // characterString
  char *characterString;
  // oid
  signed short int *oid;
  // dateTime
  char *dateTime;
  // external
  struct Z_External *external;
  // integerAndUnit
  struct Z_IntUnit *integerAndUnit;
  // null
  void *null;
};

union anonymous$28
{
  // octets
  struct odr_oct *octets;
  // numeric
  signed long long int *numeric;
  // date
  char *date;
  // ext
  struct Z_External *ext;
  // string
  char *string;
  // trueOrFalse
  signed int *trueOrFalse;
  // oid
  signed short int *oid;
  // intUnit
  struct Z_IntUnit *intUnit;
  // elementNotThere
  void *elementNotThere;
  // elementEmpty
  void *elementEmpty;
  // noDataRequested
  void *noDataRequested;
  // diagnostic
  struct Z_External *diagnostic;
  // subtree
  struct Z_GenericRecord *subtree;
};

union anonymous$3
{
  // single_ASN1_type
  struct odr_oct *single_ASN1_type;
  // octet_aligned
  struct odr_oct *octet_aligned;
  // arbitrary
  struct odr_bitmask *arbitrary;
  // sutrs
  struct odr_oct *sutrs;
  // explainRecord
  struct Z_ExplainRecord *explainRecord;
  // resourceReport1
  struct Z_ResourceReport1 *resourceReport1;
  // resourceReport2
  struct Z_ResourceReport2 *resourceReport2;
  // promptObject1
  struct Z_PromptObject1 *promptObject1;
  // grs1
  struct Z_GenericRecord *grs1;
  // extendedService
  struct Z_TaskPackage *extendedService;
  // itemOrder
  struct Z_IOItemOrder *itemOrder;
  // diag1
  struct Z_DiagnosticFormat *diag1;
  // espec1
  struct Z_Espec1 *espec1;
  // summary
  struct Z_BriefBib *summary;
  // opac
  struct Z_OPACRecord *opac;
  // searchResult1
  struct Z_SearchInfoReport *searchResult1;
  // update
  struct Z_IUUpdate *update;
  // dateTime
  struct Z_DateTime *dateTime;
  // universeReport
  struct Z_UniverseReport *universeReport;
  // adminService
  struct Z_Admin *adminService;
  // update0
  struct Z_IU0Update *update0;
  // userInfo1
  struct Z_OtherInformation *userInfo1;
  // charNeg3
  struct Z_CharSetandLanguageNegotiation *charNeg3;
  // acfPrompt1
  struct Z_PromptObject1 *acfPrompt1;
  // acfDes1
  struct Z_DES_RN_Object *acfDes1;
  // acfKrb1
  struct Z_KRBObject *acfKrb1;
  // multipleSearchTerms_2
  struct Z_MultipleSearchTerms_2 *multipleSearchTerms_2;
  // cql
  char *cql;
  // oclc
  struct Z_OCLC_UserInformation *oclc;
  // persistentResultSet
  struct Z_PRPersistentResultSet *persistentResultSet;
  // persistentQuery
  struct Z_PQueryPersistentQuery *persistentQuery;
  // periodicQuerySchedule
  struct Z_PQSPeriodicQuerySchedule *periodicQuerySchedule;
  // exportSpecification
  struct Z_ESExportSpecification *exportSpecification;
  // exportInvocation
  struct Z_EIExportInvocation *exportInvocation;
  // facetList
  struct Z_FacetList *facetList;
};

union anonymous$88
{
  // all
  void *all;
  // ranges
  struct Z_EIOriginPartNotToKeepRanges *ranges;
};

union anonymous$80
{
  // all
  void *all;
  // list
  struct Z_ResultsByDB_sList *list;
};

union anonymous$31
{
  // all
  void *all;
  // last
  void *last;
  // values
  struct Z_OccurValues *values;
};

union anonymous$9
{
  // any_or_none
  void *any_or_none;
  // specific
  struct Z_AttributeValueList *specific;
};

union anonymous$91
{
  // billInvoice
  void *billInvoice;
  // prepay
  void *prepay;
  // depositAccount
  void *depositAccount;
  // creditCard
  struct Z_IOCreditCardInfo *creditCard;
  // cardInfoPreviouslySupplied
  void *cardInfoPreviouslySupplied;
  // privateKnown
  void *privateKnown;
  // privateNotKnown
  struct Z_External *privateNotKnown;
};

union anonymous$71
{
  // character
  void *character;
  // numeric
  void *numeric;
  // structured
  struct Z_HumanString *structured;
};

union anonymous$61
{
  // decade
  void *decade;
  // century
  void *century;
  // millennium
  void *millennium;
};

union anonymous$58
{
  // first
  void *first;
  // second
  void *second;
  // third
  void *third;
  // fourth
  void *fourth;
};

union anonymous$42
{
  // local
  void *local;
  // utc
  void *utc;
  // utcOffset
  signed long long int *utcOffset;
};

union anonymous$11
{
  // noUser
  void *noUser;
  // refused
  void *refused;
  // simple
  void *simple;
  // oid
  struct Z_OidList *oid;
  // alternative
  struct Z_AltOidList *alternative;
  // pwdInv
  void *pwdInv;
  // pwdExp
  void *pwdExp;
};

union anonymous$23
{
  // nonZeroStepSize
  void *nonZeroStepSize;
  // specifiedStepSize
  void *specifiedStepSize;
  // termList1
  void *termList1;
  // termList2
  struct Z_AttrListList *termList2;
  // posInResponse
  signed long long int *posInResponse;
  // resources
  void *resources;
  // endOfList
  void *endOfList;
};

union anonymous$12
{
  // op_and
  void *op_and;
  // op_or
  void *op_or;
  // and_not
  void *and_not;
  // prox
  struct Z_ProximityOperator *prox;
};

union anonymous$16
{
  // reIndex
  void *reIndex;
  // truncate
  void *truncate;
  // drop
  void *drop;
  // create
  void *create;
  // import
  struct Z_ImportParameters *import;
  // refresh
  void *refresh;
  // commit
  void *commit;
  // shutdown
  void *shutdown;
  // start
  void *start;
};

union anonymous$21
{
  // resultSets
  void *resultSets;
  // badSet
  char *badSet;
  // relation
  signed long long int *relation;
  // unit
  signed long long int *unit;
  // distance
  signed long long int *distance;
  // attributes
  struct Z_AttributeList *attributes;
  // ordered
  void *ordered;
  // exclusion
  void *exclusion;
};

union anonymous$101
{
  // segmentCount
  void *segmentCount;
  // segmentSize
  signed long long int *segmentSize;
};

union anonymous$25
{
  // sequence
  void *sequence;
  // noRsName
  void *noRsName;
  // tooMany
  signed long long int *tooMany;
  // incompatible
  void *incompatible;
  // generic
  void *generic;
  // dbSpecific
  void *dbSpecific;
  // sortElement
  struct Z_SortElement *sortElement;
  // key
  signed long long int *key;
  // action
  void *action;
  // illegal
  signed long long int *illegal;
  // inputTooLarge
  struct Z_StringList *inputTooLarge;
  // aggregateTooLarge
  void *aggregateTooLarge;
};

union anonymous$78
{
  // sevenBit
  void *sevenBit;
  // eightBit
  void *eightBit;
};

union anonymous$82
{
  // type_0
  void *type_0;
  // type_1
  struct Z_RPNQuery *type_1;
  // type_2
  struct odr_oct *type_2;
  // type_100
  struct odr_oct *type_100;
  // type_101
  struct Z_RPNQuery *type_101;
  // type_102
  struct odr_oct *type_102;
  // type_104
  struct Z_External *type_104;
};

union anonymous$60
{
  // winter
  void *winter;
  // spring
  void *spring;
  // summer
  void *summer;
  // autumn
  void *autumn;
};

union anonymous$53
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$66
{
  // relation
  struct anonymous$65 relation;
  // boolean
  struct anonymous$68 boolean;
};

union anonymous$97
{
  // sort
  struct anonymous$46 sort;
};

struct Z_AccessCtrl
{
  // which
  signed int which;
  // u
  union anonymous$11 u;
};

struct Z_AccessInfo
{
  // num_queryTypesSupported
  signed int num_queryTypesSupported;
  // queryTypesSupported
  struct Z_QueryTypeDetails **queryTypesSupported;
  // num_diagnosticsSets
  signed int num_diagnosticsSets;
  // diagnosticsSets
  signed short int **diagnosticsSets;
  // num_attributeSetIds
  signed int num_attributeSetIds;
  // attributeSetIds
  signed short int **attributeSetIds;
  // num_schemas
  signed int num_schemas;
  // schemas
  signed short int **schemas;
  // num_recordSyntaxes
  signed int num_recordSyntaxes;
  // recordSyntaxes
  signed short int **recordSyntaxes;
  // num_resourceChallenges
  signed int num_resourceChallenges;
  // resourceChallenges
  signed short int **resourceChallenges;
  // restrictedAccess
  struct Z_AccessRestrictions *restrictedAccess;
  // costInfo
  struct Z_Costs *costInfo;
  // num_variantSets
  signed int num_variantSets;
  // variantSets
  signed short int **variantSets;
  // num_elementSetNames
  signed int num_elementSetNames;
  // elementSetNames
  char **elementSetNames;
  // num_unitSystems
  signed int num_unitSystems;
  // unitSystems
  char **unitSystems;
};

struct Z_AccessRestrictions
{
  // num
  signed int num;
  // elements
  struct Z_AccessRestrictionsUnit **elements;
};

struct Z_AccessRestrictionsUnit
{
  // accessType
  signed long long int *accessType;
  // accessText
  struct Z_HumanString *accessText;
  // num_accessChallenges
  signed int num_accessChallenges;
  // accessChallenges
  signed short int **accessChallenges;
};

struct Z_Admin
{
  // which
  signed int which;
  // u
  union anonymous$19 u;
};

struct Z_AdminEsRequest
{
  // toKeep
  struct Z_ESAdminOriginPartToKeep *toKeep;
  // notToKeep
  struct Z_ESAdminOriginPartNotToKeep *notToKeep;
};

struct Z_AdminTaskPackage
{
  // originPart
  struct Z_ESAdminOriginPartToKeep *originPart;
  // targetPart
  struct Z_ESAdminTargetPart *targetPart;
};

struct Z_AltOidList
{
  // num
  signed int num;
  // elements
  signed short int **elements;
};

struct Z_AttCombo
{
  // unsupportedCombination
  struct Z_AttributeList *unsupportedCombination;
  // num_recommendedAlternatives
  signed int num_recommendedAlternatives;
  // recommendedAlternatives
  struct Z_AttributeList **recommendedAlternatives;
};

struct Z_AttrListList
{
  // num
  signed int num;
  // elements
  struct Z_AttributeList **elements;
};

struct Z_Attribute
{
  // id
  signed short int *id;
  // type
  signed long long int *type;
  // value
  signed long long int *value;
  // term
  struct Z_Term *term;
};

struct Z_AttributeCombination
{
  // num_occurrences
  signed int num_occurrences;
  // occurrences
  struct Z_AttributeOccurrence **occurrences;
};

struct Z_AttributeCombinations
{
  // defaultAttributeSet
  signed short int *defaultAttributeSet;
  // num_legalCombinations
  signed int num_legalCombinations;
  // legalCombinations
  struct Z_AttributeCombination **legalCombinations;
};

struct Z_AttributeDescription
{
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // attributeValue
  struct Z_StringOrNumeric *attributeValue;
  // num_equivalentAttributes
  signed int num_equivalentAttributes;
  // equivalentAttributes
  struct Z_StringOrNumeric **equivalentAttributes;
};

struct Z_AttributeDetails
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // databaseName
  char *databaseName;
  // num_attributesBySet
  signed int num_attributesBySet;
  // attributesBySet
  struct Z_AttributeSetDetails **attributesBySet;
  // attributeCombinations
  struct Z_AttributeCombinations *attributeCombinations;
};

struct Z_AttributeElement
{
  // attributeSet
  signed short int *attributeSet;
  // attributeType
  signed long long int *attributeType;
  // which
  signed int which;
  // value
  union anonymous$8 value;
};

struct Z_AttributeList
{
  // num_attributes
  signed int num_attributes;
  // attributes
  struct Z_AttributeElement **attributes;
};

struct Z_AttributeOccurrence
{
  // attributeSet
  signed short int *attributeSet;
  // attributeType
  signed long long int *attributeType;
  // mustBeSupplied
  void *mustBeSupplied;
  // which
  signed int which;
  // attributeValues
  union anonymous$9 attributeValues;
};

struct Z_AttributeSetDetails
{
  // attributeSet
  signed short int *attributeSet;
  // num_attributesByType
  signed int num_attributesByType;
  // attributesByType
  struct Z_AttributeTypeDetails **attributesByType;
};

struct Z_AttributeSetInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // attributeSet
  signed short int *attributeSet;
  // name
  char *name;
  // num_attributes
  signed int num_attributes;
  // attributes
  struct Z_AttributeType **attributes;
  // description
  struct Z_HumanString *description;
};

struct Z_AttributeType
{
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // attributeType
  signed long long int *attributeType;
  // num_attributeValues
  signed int num_attributeValues;
  // attributeValues
  struct Z_AttributeDescription **attributeValues;
};

struct Z_AttributeTypeDetails
{
  // attributeType
  signed long long int *attributeType;
  // defaultIfOmitted
  struct Z_OmittedAttributeInterpretation *defaultIfOmitted;
  // num_attributeValues
  signed int num_attributeValues;
  // attributeValues
  struct Z_AttributeValue **attributeValues;
};

struct Z_AttributeValue
{
  // value
  struct Z_StringOrNumeric *value;
  // description
  struct Z_HumanString *description;
  // num_subAttributes
  signed int num_subAttributes;
  // subAttributes
  struct Z_StringOrNumeric **subAttributes;
  // num_superAttributes
  signed int num_superAttributes;
  // superAttributes
  struct Z_StringOrNumeric **superAttributes;
  // partialSupport
  void *partialSupport;
};

struct Z_AttributeValueList
{
  // num_attributes
  signed int num_attributes;
  // attributes
  struct Z_StringOrNumeric **attributes;
};

struct Z_AttributesPlusTerm
{
  // attributes
  struct Z_AttributeList *attributes;
  // term
  struct Z_Term *term;
};

struct Z_BadSpec
{
  // spec
  struct Z_Specification *spec;
  // db
  char *db;
  // num_goodOnes
  signed int num_goodOnes;
  // goodOnes
  struct Z_Specification **goodOnes;
};

struct Z_BriefBib
{
  // title
  char *title;
  // author
  char *author;
  // callNumber
  char *callNumber;
  // recordType
  char *recordType;
  // bibliographicLevel
  char *bibliographicLevel;
  // num_format
  signed int num_format;
  // format
  struct Z_FormatSpec **format;
  // publicationPlace
  char *publicationPlace;
  // publicationDate
  char *publicationDate;
  // targetSystemKey
  char *targetSystemKey;
  // satisfyingElement
  char *satisfyingElement;
  // rank
  signed long long int *rank;
  // documentId
  char *documentId;
  // abstract
  char *abstract;
  // otherInfo
  struct Z_OtherInformation *otherInfo;
};

struct Z_CategoryInfo
{
  // category
  char *category;
  // originalCategory
  char *originalCategory;
  // description
  struct Z_HumanString *description;
  // asn1Module
  char *asn1Module;
};

struct Z_CategoryList
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // num_categories
  signed int num_categories;
  // categories
  struct Z_CategoryInfo **categories;
};

struct Z_Challenge1
{
  // num
  signed int num;
  // elements
  struct Z_ChallengeUnit1 **elements;
};

struct Z_ChallengeUnit1
{
  // promptId
  struct Z_PromptId *promptId;
  // defaultResponse
  char *defaultResponse;
  // which
  signed int which;
  // u
  union anonymous$52 u;
  // regExpr
  char *regExpr;
  // responseRequired
  void *responseRequired;
  // num_allowedValues
  signed int num_allowedValues;
  // allowedValues
  char **allowedValues;
  // shouldSave
  void *shouldSave;
  // dataType
  signed long long int *dataType;
  // diagnostic
  struct Z_External *diagnostic;
};

struct Z_CharSetandLanguageNegotiation
{
  // which
  signed int which;
  // u
  union anonymous$63 u;
};

struct Z_Charge
{
  // cost
  struct Z_IntUnit *cost;
  // perWhat
  struct Z_Unit *perWhat;
  // text
  struct Z_HumanString *text;
};

struct Z_CircRecord
{
  // availableNow
  signed int *availableNow;
  // availablityDate
  char *availablityDate;
  // availableThru
  char *availableThru;
  // restrictions
  char *restrictions;
  // itemId
  char *itemId;
  // renewable
  signed int *renewable;
  // onHold
  signed int *onHold;
  // enumAndChron
  char *enumAndChron;
  // midspine
  char *midspine;
  // temporaryLocation
  char *temporaryLocation;
};

struct Z_CommonInfo
{
  // dateAdded
  char *dateAdded;
  // dateChanged
  char *dateChanged;
  // expiry
  char *expiry;
  // humanStringLanguage
  char *humanStringLanguage;
  // otherInfo
  struct Z_OtherInformation *otherInfo;
};

struct Z_CompSpec
{
  // selectAlternativeSyntax
  signed int *selectAlternativeSyntax;
  // generic
  struct Z_Specification *generic;
  // num_dbSpecific
  signed int num_dbSpecific;
  // dbSpecific
  struct Z_DbSpecific **dbSpecific;
  // num_recordSyntax
  signed int num_recordSyntax;
  // recordSyntax
  signed short int **recordSyntax;
};

struct Z_Complex
{
  // s1
  struct Z_RPNStructure *s1;
  // s2
  struct Z_RPNStructure *s2;
  // roperator
  struct Z_Operator *roperator;
};

struct Z_ComplexAttribute
{
  // num_list
  signed int num_list;
  // list
  struct Z_StringOrNumeric **list;
  // num_semanticAction
  signed int num_semanticAction;
  // semanticAction
  signed long long int **semanticAction;
};

struct Z_ContactInfo
{
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // address
  struct Z_HumanString *address;
  // email
  char *email;
  // phone
  char *phone;
};

struct Z_Costs
{
  // connectCharge
  struct Z_Charge *connectCharge;
  // connectTime
  struct Z_Charge *connectTime;
  // displayCharge
  struct Z_Charge *displayCharge;
  // searchCharge
  struct Z_Charge *searchCharge;
  // subscriptCharge
  struct Z_Charge *subscriptCharge;
  // num_otherCharges
  signed int num_otherCharges;
  // otherCharges
  struct Z_CostsOtherCharge **otherCharges;
};

struct Z_CostsOtherCharge
{
  // forWhat
  struct Z_HumanString *forWhat;
  // charge
  struct Z_Charge *charge;
};

struct Z_DES_RN_Object
{
  // which
  signed int which;
  // u
  union anonymous$43 u;
};

struct Z_DRNType
{
  // userId
  struct odr_oct *userId;
  // salt
  struct odr_oct *salt;
  // randomNumber
  struct odr_oct *randomNumber;
};

struct Z_DatabaseInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // name
  char *name;
  // explainDatabase
  void *explainDatabase;
  // num_nicknames
  signed int num_nicknames;
  // nicknames
  char **nicknames;
  // icon
  struct Z_IconObject *icon;
  // userFee
  signed int *userFee;
  // available
  signed int *available;
  // titleString
  struct Z_HumanString *titleString;
  // num_keywords
  signed int num_keywords;
  // keywords
  struct Z_HumanString **keywords;
  // description
  struct Z_HumanString *description;
  // associatedDbs
  struct Z_DatabaseList *associatedDbs;
  // subDbs
  struct Z_DatabaseList *subDbs;
  // disclaimers
  struct Z_HumanString *disclaimers;
  // news
  struct Z_HumanString *news;
  // which
  signed int which;
  // u
  union anonymous$64 u;
  // defaultOrder
  struct Z_HumanString *defaultOrder;
  // avRecordSize
  signed long long int *avRecordSize;
  // maxRecordSize
  signed long long int *maxRecordSize;
  // hours
  struct Z_HumanString *hours;
  // bestTime
  struct Z_HumanString *bestTime;
  // lastUpdate
  char *lastUpdate;
  // updateInterval
  struct Z_IntUnit *updateInterval;
  // coverage
  struct Z_HumanString *coverage;
  // proprietary
  signed int *proprietary;
  // copyrightText
  struct Z_HumanString *copyrightText;
  // copyrightNotice
  struct Z_HumanString *copyrightNotice;
  // producerContactInfo
  struct Z_ContactInfo *producerContactInfo;
  // supplierContactInfo
  struct Z_ContactInfo *supplierContactInfo;
  // submissionContactInfo
  struct Z_ContactInfo *submissionContactInfo;
  // accessInfo
  struct Z_AccessInfo *accessInfo;
};

struct Z_DatabaseList
{
  // num_databases
  signed int num_databases;
  // databases
  char **databases;
};

struct Z_Date
{
  // year
  signed long long int *year;
  // which
  signed int which;
  // u
  union anonymous$41 u;
  // flags
  struct Z_DateFlags *flags;
};

struct Z_DateFlags
{
  // circa
  void *circa;
  // era
  struct Z_Era *era;
};

struct Z_DateMonthAndDay
{
  // month
  signed long long int *month;
  // day
  signed long long int *day;
};

struct Z_DateQuarter
{
  // which
  signed int which;
  // u
  union anonymous$58 u;
};

struct Z_DateSeason
{
  // which
  signed int which;
  // u
  union anonymous$60 u;
};

struct Z_DateTime
{
  // date
  struct Z_Date *date;
  // time
  struct Z_Time *time;
};

struct Z_DbSpecific
{
  // db
  char *db;
  // spec
  struct Z_Specification *spec;
};

struct Z_DbUnavail
{
  // db
  char *db;
  // why
  struct Z_DbUnavail_0 *why;
};

struct Z_DbUnavail_0
{
  // reasonCode
  signed long long int *reasonCode;
  // message
  char *message;
};

struct Z_DefaultDiagFormat
{
  // diagnosticSetId
  signed short int *diagnosticSetId;
  // condition
  signed long long int *condition;
  // which
  signed int which;
  // u
  union anonymous$40 u;
};

struct Z_DiagFormat
{
  // which
  signed int which;
  // u
  union anonymous$14 u;
};

struct Z_DiagRec
{
  // which
  signed int which;
  // u
  union anonymous$5 u;
};

struct Z_DiagTerm
{
  // problem
  signed long long int *problem;
  // term
  struct Z_Term *term;
};

struct Z_DiagnosticFormat
{
  // num
  signed int num;
  // elements
  struct Z_DiagnosticFormat_s **elements;
};

struct Z_DiagnosticFormat_s
{
  // which
  signed int which;
  // u
  union anonymous$20 u;
  // message
  char *message;
};

struct Z_EIExportInvocation
{
  // which
  signed int which;
  // u
  union anonymous$86 u;
};

struct Z_EIExportInvocationEsRequest
{
  // toKeep
  struct Z_EIOriginPartToKeep *toKeep;
  // notToKeep
  struct Z_EIOriginPartNotToKeep *notToKeep;
};

struct Z_EIExportInvocationTaskPackage
{
  // originPart
  struct Z_EIOriginPartToKeep *originPart;
  // targetPart
  struct Z_EITargetPart *targetPart;
};

struct Z_EIOriginPartNotToKeep
{
  // resultSetId
  char *resultSetId;
  // which
  signed int which;
  // u
  union anonymous$88 u;
};

struct Z_EIOriginPartNotToKeepRanges
{
  // num
  signed int num;
  // elements
  struct Z_EIOriginPartNotToKeepRanges_s **elements;
};

struct Z_EIOriginPartNotToKeepRanges_s
{
  // start
  signed long long int *start;
  // count
  signed long long int *count;
};

struct Z_EIOriginPartToKeep
{
  // which
  signed int which;
  // u
  union anonymous$87 u;
  // numberOfCopies
  signed long long int *numberOfCopies;
};

struct Z_EITargetPart
{
  // estimatedQuantity
  struct Z_IntUnit *estimatedQuantity;
  // quantitySoFar
  struct Z_IntUnit *quantitySoFar;
  // estimatedCost
  struct Z_IntUnit *estimatedCost;
  // costSoFar
  struct Z_IntUnit *costSoFar;
};

struct Z_ESAdminOriginPartNotToKeep
{
  // which
  signed int which;
  // u
  union anonymous$17 u;
};

struct Z_ESAdminOriginPartToKeep
{
  // which
  signed int which;
  // u
  union anonymous$16 u;
  // databaseName
  char *databaseName;
};

struct Z_ESAdminTargetPart
{
  // updateStatus
  signed long long int *updateStatus;
  // num_globalDiagnostics
  signed int num_globalDiagnostics;
  // globalDiagnostics
  struct Z_DiagRec **globalDiagnostics;
};

struct Z_ESDestination
{
  // which
  signed int which;
  // u
  union anonymous$85 u;
};

struct Z_ESDestinationOther
{
  // vehicle
  char *vehicle;
  // destination
  char *destination;
};

struct Z_ESExportSpecification
{
  // which
  signed int which;
  // u
  union anonymous$84 u;
};

struct Z_ESExportSpecificationEsRequest
{
  // toKeep
  struct Z_ESOriginPartToKeep *toKeep;
  // notToKeep
  void *notToKeep;
};

struct Z_ESExportSpecificationTaskPackage
{
  // originPart
  struct Z_ESOriginPartToKeep *originPart;
  // targetPart
  void *targetPart;
};

struct Z_ESOriginPartToKeep
{
  // composition
  struct Z_CompSpec *composition;
  // exportDestination
  struct Z_ESDestination *exportDestination;
};

struct Z_EScanInfo
{
  // maxStepSize
  signed long long int *maxStepSize;
  // collatingSequence
  struct Z_HumanString *collatingSequence;
  // increasing
  signed int *increasing;
};

struct Z_ETagPath
{
  // num_tags
  signed int num_tags;
  // tags
  struct Z_ETagUnit **tags;
};

struct Z_ETagUnit
{
  // which
  signed int which;
  // u
  union anonymous$32 u;
};

struct Z_ElementData
{
  // which
  signed int which;
  // u
  union anonymous$28 u;
};

struct Z_ElementDataType
{
  // which
  signed int which;
  // u
  union anonymous$70 u;
};

struct Z_ElementInfo
{
  // elementName
  char *elementName;
  // elementTagPath
  struct Z_Path *elementTagPath;
  // dataType
  struct Z_ElementDataType *dataType;
  // required
  signed int *required;
  // repeatable
  signed int *repeatable;
  // description
  struct Z_HumanString *description;
};

struct Z_ElementInfoList
{
  // num
  signed int num;
  // elements
  struct Z_ElementInfo **elements;
};

struct Z_ElementMetaData
{
  // seriesOrder
  struct Z_Order *seriesOrder;
  // usageRight
  struct Z_Usage *usageRight;
  // num_hits
  signed int num_hits;
  // hits
  struct Z_HitVector **hits;
  // displayName
  char *displayName;
  // num_supportedVariants
  signed int num_supportedVariants;
  // supportedVariants
  struct Z_Variant **supportedVariants;
  // message
  char *message;
  // elementDescriptor
  struct odr_oct *elementDescriptor;
  // surrogateFor
  struct Z_TagPath *surrogateFor;
  // surrogateElement
  struct Z_TagPath *surrogateElement;
  // other
  struct Z_External *other;
};

struct Z_ElementRequest
{
  // which
  signed int which;
  // u
  union anonymous$29 u;
};

struct Z_ElementRequestCompositeElement
{
  // which
  signed int which;
  // u
  union anonymous$26 u;
  // deliveryTag
  struct Z_ETagPath *deliveryTag;
  // variantRequest
  struct Z_Variant *variantRequest;
};

struct Z_ElementRequestCompositeElementPrimitives
{
  // num
  signed int num;
  // elements
  char **elements;
};

struct Z_ElementRequestCompositeElementSpecs
{
  // num
  signed int num;
  // elements
  struct Z_SimpleElement **elements;
};

struct Z_ElementSetDetails
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // databaseName
  char *databaseName;
  // elementSetName
  char *elementSetName;
  // recordSyntax
  signed short int *recordSyntax;
  // schema
  signed short int *schema;
  // description
  struct Z_HumanString *description;
  // num_detailsPerElement
  signed int num_detailsPerElement;
  // detailsPerElement
  struct Z_PerElementDetails **detailsPerElement;
};

struct Z_ElementSpec
{
  // which
  signed int which;
  // u
  union anonymous$67 u;
};

struct Z_Encryption
{
  // cryptType
  struct odr_oct *cryptType;
  // credential
  struct odr_oct *credential;
  // data
  struct odr_oct *data;
};

struct Z_Environment
{
  // which
  signed int which;
  // u
  union anonymous$78 u;
};

struct Z_Era
{
  // which
  signed int which;
  // u
  union anonymous$61 u;
};

struct Z_Espec1
{
  // num_elementSetNames
  signed int num_elementSetNames;
  // elementSetNames
  char **elementSetNames;
  // defaultVariantSetId
  signed short int *defaultVariantSetId;
  // defaultVariantRequest
  struct Z_Variant *defaultVariantRequest;
  // defaultTagType
  signed long long int *defaultTagType;
  // num_elements
  signed int num_elements;
  // elements
  struct Z_ElementRequest **elements;
};

struct Z_Estimate1
{
  // type
  signed long long int *type;
  // value
  signed long long int *value;
  // currency_code
  signed long long int *currency_code;
};

struct Z_Estimate2
{
  // type
  struct Z_StringOrNumeric *type;
  // value
  struct Z_IntUnit *value;
};

struct Z_ExplainRecord
{
  // which
  signed int which;
  // u
  union anonymous$51 u;
};

struct Z_ExtServices
{
  // which
  signed int which;
  // u
  union anonymous$2 u;
};

struct Z_ExtendedServicesInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // type
  signed short int *type;
  // name
  char *name;
  // privateType
  signed int *privateType;
  // restrictionsApply
  signed int *restrictionsApply;
  // feeApply
  signed int *feeApply;
  // available
  signed int *available;
  // retentionSupported
  signed int *retentionSupported;
  // waitAction
  signed long long int *waitAction;
  // description
  struct Z_HumanString *description;
  // specificExplain
  struct Z_External *specificExplain;
  // esASN
  char *esASN;
};

struct Z_External
{
  // direct_reference
  signed short int *direct_reference;
  // indirect_reference
  signed long long int *indirect_reference;
  // descriptor
  char *descriptor;
  // which
  signed int which;
  // u
  union anonymous$3 u;
};

struct Z_FacetField
{
  // attributes
  struct Z_AttributeList *attributes;
  // num_terms
  signed int num_terms;
  // terms
  struct Z_FacetTerm **terms;
};

struct Z_FacetList
{
  // num
  signed int num;
  // elements
  struct Z_FacetField **elements;
};

struct Z_FacetTerm
{
  // term
  struct Z_Term *term;
  // count
  signed long long int *count;
};

struct Z_FormatSpec
{
  // type
  char *type;
  // size
  signed long long int *size;
  // bestPosn
  signed long long int *bestPosn;
};

struct Z_FragmentSyntax
{
  // which
  signed int which;
  // u
  union anonymous$36 u;
};

struct Z_GenericRecord
{
  // num_elements
  signed int num_elements;
  // elements
  struct Z_TaggedElement **elements;
};

struct Z_HitVector
{
  // satisfier
  struct Z_Term *satisfier;
  // offsetIntoElement
  struct Z_IntUnit *offsetIntoElement;
  // length
  struct Z_IntUnit *length;
  // hitRank
  signed long long int *hitRank;
  // targetToken
  struct odr_oct *targetToken;
};

struct Z_HoldingsAndCircData
{
  // typeOfRecord
  char *typeOfRecord;
  // encodingLevel
  char *encodingLevel;
  // format
  char *format;
  // receiptAcqStatus
  char *receiptAcqStatus;
  // generalRetention
  char *generalRetention;
  // completeness
  char *completeness;
  // dateOfReport
  char *dateOfReport;
  // nucCode
  char *nucCode;
  // localLocation
  char *localLocation;
  // shelvingLocation
  char *shelvingLocation;
  // callNumber
  char *callNumber;
  // shelvingData
  char *shelvingData;
  // copyNumber
  char *copyNumber;
  // publicNote
  char *publicNote;
  // reproductionNote
  char *reproductionNote;
  // termsUseRepro
  char *termsUseRepro;
  // enumAndChron
  char *enumAndChron;
  // num_volumes
  signed int num_volumes;
  // volumes
  struct Z_Volume **volumes;
  // num_circulationData
  signed int num_circulationData;
  // circulationData
  struct Z_CircRecord **circulationData;
};

struct Z_HoldingsRecord
{
  // which
  signed int which;
  // u
  union anonymous$34 u;
};

struct Z_HumanString
{
  // num_strings
  signed int num_strings;
  // strings
  struct Z_HumanStringUnit **strings;
};

struct Z_HumanStringUnit
{
  // language
  char *language;
  // text
  char *text;
};

struct Z_IOBilling
{
  // which
  signed int which;
  // u
  union anonymous$91 u;
  // customerReference
  char *customerReference;
  // customerPONumber
  char *customerPONumber;
};

struct Z_IOContact
{
  // name
  char *name;
  // phone
  char *phone;
  // email
  char *email;
};

struct Z_IOCreditCardInfo
{
  // nameOnCard
  char *nameOnCard;
  // expirationDate
  char *expirationDate;
  // cardNumber
  char *cardNumber;
};

struct Z_IOItemOrder
{
  // which
  signed int which;
  // u
  union anonymous$90 u;
};

struct Z_IOOriginPartNotToKeep
{
  // resultSetItem
  struct Z_IOResultSetItem *resultSetItem;
  // itemRequest
  struct Z_External *itemRequest;
};

struct Z_IOOriginPartToKeep
{
  // supplDescription
  struct Z_External *supplDescription;
  // contact
  struct Z_IOContact *contact;
  // addlBilling
  struct Z_IOBilling *addlBilling;
};

struct Z_IORequest
{
  // toKeep
  struct Z_IOOriginPartToKeep *toKeep;
  // notToKeep
  struct Z_IOOriginPartNotToKeep *notToKeep;
};

struct Z_IOResultSetItem
{
  // resultSetId
  char *resultSetId;
  // item
  signed long long int *item;
};

struct Z_IOTargetPart
{
  // itemRequest
  struct Z_External *itemRequest;
  // statusOrErrorReport
  struct Z_External *statusOrErrorReport;
  // auxiliaryStatus
  signed long long int *auxiliaryStatus;
};

struct Z_IOTaskPackage
{
  // originPart
  struct Z_IOOriginPartToKeep *originPart;
  // targetPart
  struct Z_IOTargetPart *targetPart;
};

struct Z_IU0CorrelationInfo
{
  // note
  char *note;
  // id
  signed long long int *id;
};

struct Z_IU0OriginPartToKeep
{
  // action
  signed long long int *action;
  // databaseName
  char *databaseName;
  // schema
  signed short int *schema;
  // elementSetName
  char *elementSetName;
};

struct Z_IU0SuppliedRecords
{
  // num
  signed int num;
  // elements
  struct Z_IU0SuppliedRecords_elem **elements;
};

struct Z_IU0SuppliedRecordsId
{
  // which
  signed int which;
  // u
  union anonymous$38 u;
};

struct Z_IU0SuppliedRecords_elem
{
  // which
  signed int which;
  // u
  union anonymous$45 u;
  // supplementalId
  struct Z_IU0SuppliedRecordsId *supplementalId;
  // correlationInfo
  struct Z_IU0CorrelationInfo *correlationInfo;
  // record
  struct Z_External *record;
};

struct Z_IU0TargetPart
{
  // updateStatus
  signed long long int *updateStatus;
  // num_globalDiagnostics
  signed int num_globalDiagnostics;
  // globalDiagnostics
  struct Z_DiagRec **globalDiagnostics;
  // num_taskPackageRecords
  signed int num_taskPackageRecords;
  // taskPackageRecords
  struct Z_IU0TaskPackageRecordStructure **taskPackageRecords;
};

struct Z_IU0TaskPackageRecordStructure
{
  // which
  signed int which;
  // u
  union anonymous$37 u;
  // correlationInfo
  struct Z_IU0CorrelationInfo *correlationInfo;
  // recordStatus
  signed long long int *recordStatus;
};

struct Z_IU0Update
{
  // which
  signed int which;
  // u
  union anonymous$33 u;
};

struct Z_IU0UpdateEsRequest
{
  // toKeep
  struct Z_IU0OriginPartToKeep *toKeep;
  // notToKeep
  struct Z_IU0SuppliedRecords *notToKeep;
};

struct Z_IU0UpdateTaskPackage
{
  // originPart
  struct Z_IU0OriginPartToKeep *originPart;
  // targetPart
  struct Z_IU0TargetPart *targetPart;
};

struct Z_IUCorrelationInfo
{
  // note
  char *note;
  // id
  signed long long int *id;
};

struct Z_IUOriginPartToKeep
{
  // action
  signed long long int *action;
  // databaseName
  char *databaseName;
  // schema
  signed short int *schema;
  // elementSetName
  char *elementSetName;
  // actionQualifier
  struct Z_External *actionQualifier;
};

struct Z_IUSuppliedRecords
{
  // num
  signed int num;
  // elements
  struct Z_IUSuppliedRecords_elem **elements;
};

struct Z_IUSuppliedRecordsId
{
  // which
  signed int which;
  // u
  union anonymous$38 u;
};

struct Z_IUSuppliedRecords_elem
{
  // which
  signed int which;
  // u
  union anonymous$45 u;
  // supplementalId
  struct Z_IUSuppliedRecordsId *supplementalId;
  // correlationInfo
  struct Z_IUCorrelationInfo *correlationInfo;
  // record
  struct Z_External *record;
};

struct Z_IUTargetPart
{
  // updateStatus
  signed long long int *updateStatus;
  // num_globalDiagnostics
  signed int num_globalDiagnostics;
  // globalDiagnostics
  struct Z_DiagRec **globalDiagnostics;
  // num_taskPackageRecords
  signed int num_taskPackageRecords;
  // taskPackageRecords
  struct Z_IUTaskPackageRecordStructure **taskPackageRecords;
};

struct Z_IUTaskPackageRecordStructure
{
  // which
  signed int which;
  // u
  union anonymous$6 u;
  // correlationInfo
  struct Z_IUCorrelationInfo *correlationInfo;
  // recordStatus
  signed long long int *recordStatus;
  // num_supplementalDiagnostics
  signed int num_supplementalDiagnostics;
  // supplementalDiagnostics
  struct Z_DiagRec **supplementalDiagnostics;
};

struct Z_IUTaskPackageRecordStructureSurrogateDiagnostics
{
  // num
  signed int num;
  // elements
  struct Z_DiagRec **elements;
};

struct Z_IUUpdate
{
  // which
  signed int which;
  // u
  union anonymous u;
};

struct Z_IUUpdateEsRequest
{
  // toKeep
  struct Z_IUOriginPartToKeep *toKeep;
  // notToKeep
  struct Z_IUSuppliedRecords *notToKeep;
};

struct Z_IUUpdateTaskPackage
{
  // originPart
  struct Z_IUOriginPartToKeep *originPart;
  // targetPart
  struct Z_IUTargetPart *targetPart;
};

struct Z_IconObject
{
  // num
  signed int num;
  // elements
  struct Z_IconObjectUnit **elements;
};

struct Z_IconObjectUnit
{
  // which
  signed int which;
  // u
  union anonymous$75 u;
  // content
  struct odr_oct *content;
};

struct Z_ImportParameters
{
  // recordType
  char *recordType;
};

struct Z_InfoCategory
{
  // categoryTypeId
  signed short int *categoryTypeId;
  // categoryValue
  signed long long int *categoryValue;
};

struct Z_InitialSet
{
  // g0
  signed long long int *g0;
  // g1
  signed long long int *g1;
  // g2
  signed long long int *g2;
  // g3
  signed long long int *g3;
  // c0
  signed long long int *c0;
  // c1
  signed long long int *c1;
};

struct Z_IntUnit
{
  // value
  signed long long int *value;
  // unitUsed
  struct Z_Unit *unitUsed;
};

struct Z_Iso10646
{
  // collections
  signed short int *collections;
  // encodingLevel
  signed short int *encodingLevel;
};

struct Z_Iso2022
{
  // which
  signed int which;
  // u
  union anonymous$81 u;
};

struct Z_Iso2022OriginProposal
{
  // proposedEnvironment
  struct Z_Environment *proposedEnvironment;
  // num_proposedSets
  signed int num_proposedSets;
  // proposedSets
  signed long long int **proposedSets;
  // num_proposedInitialSets
  signed int num_proposedInitialSets;
  // proposedInitialSets
  struct Z_InitialSet **proposedInitialSets;
  // proposedLeftAndRight
  struct Z_LeftAndRight *proposedLeftAndRight;
};

struct Z_Iso2022TargetResponse
{
  // selectedEnvironment
  struct Z_Environment *selectedEnvironment;
  // num_selectedSets
  signed int num_selectedSets;
  // selectedSets
  signed long long int **selectedSets;
  // selectedinitialSet
  struct Z_InitialSet *selectedinitialSet;
  // selectedLeftAndRight
  struct Z_LeftAndRight *selectedLeftAndRight;
};

struct Z_Iso8777Capabilities
{
  // num_searchKeys
  signed int num_searchKeys;
  // searchKeys
  struct Z_SearchKey **searchKeys;
  // restrictions
  struct Z_HumanString *restrictions;
};

struct Z_KRBObject
{
  // which
  signed int which;
  // u
  union anonymous$44 u;
};

struct Z_KRBRequest
{
  // service
  char *service;
  // instance
  char *instance;
  // realm
  char *realm;
};

struct Z_KRBResponse
{
  // userid
  char *userid;
  // ticket
  struct odr_oct *ticket;
};

struct Z_LeftAndRight
{
  // gLeft
  signed long long int *gLeft;
  // gRight
  signed long long int *gRight;
};

struct Z_MultipleSearchTerms_2
{
  // num
  signed int num;
  // elements
  struct Z_MultipleSearchTerms_2_s **elements;
};

struct Z_MultipleSearchTerms_2_s
{
  // term
  struct Z_Term *term;
  // flag
  signed int *flag;
};

struct Z_NamePlusRecord
{
  // databaseName
  char *databaseName;
  // which
  signed int which;
  // u
  union anonymous$18 u;
};

struct Z_NetworkAddress
{
  // which
  signed int which;
  // u
  union anonymous$57 u;
};

struct Z_NetworkAddressIA
{
  // hostAddress
  char *hostAddress;
  // port
  signed long long int *port;
};

struct Z_NetworkAddressOPA
{
  // pSel
  char *pSel;
  // sSel
  char *sSel;
  // tSel
  char *tSel;
  // nSap
  char *nSap;
};

struct Z_NetworkAddressOther
{
  // type
  char *type;
  // address
  char *address;
};

struct Z_OCLC_UserInformation
{
  // motd
  char *motd;
  // num_dblist
  signed int num_dblist;
  // dblist
  char **dblist;
  // failReason
  signed int *failReason;
  // code
  signed long long int *code;
  // text
  char *text;
};

struct Z_OPACRecord
{
  // bibliographicRecord
  struct Z_External *bibliographicRecord;
  // num_holdingsData
  signed int num_holdingsData;
  // holdingsData
  struct Z_HoldingsRecord **holdingsData;
};

struct Z_OccurValues
{
  // start
  signed long long int *start;
  // howMany
  signed long long int *howMany;
};

struct Z_Occurrences
{
  // which
  signed int which;
  // u
  union anonymous$31 u;
};

struct Z_OidList
{
  // num
  signed int num;
  // elements
  signed short int **elements;
};

struct Z_OmittedAttributeInterpretation
{
  // defaultValue
  struct Z_StringOrNumeric *defaultValue;
  // defaultDescription
  struct Z_HumanString *defaultDescription;
};

struct Z_Operand
{
  // which
  signed int which;
  // u
  union anonymous$100 u;
};

struct Z_Operator
{
  // which
  signed int which;
  // u
  union anonymous$12 u;
};

struct Z_Order
{
  // ascending
  signed int *ascending;
  // order
  signed long long int *order;
};

struct Z_OriginProposal
{
  // num_proposedCharSets
  signed int num_proposedCharSets;
  // proposedCharSets
  struct Z_OriginProposal_0 **proposedCharSets;
  // num_proposedlanguages
  signed int num_proposedlanguages;
  // proposedlanguages
  char **proposedlanguages;
  // recordsInSelectedCharSets
  signed int *recordsInSelectedCharSets;
};

struct Z_OriginProposal_0
{
  // which
  signed int which;
  // u
  union anonymous$69 u;
};

struct Z_OtherInformation
{
  // num_elements
  signed int num_elements;
  // list
  struct Z_OtherInformationUnit **list;
};

struct Z_OtherInformationUnit
{
  // category
  struct Z_InfoCategory *category;
  // which
  signed int which;
  // information
  union anonymous$4 information;
};

struct Z_PQSOriginPartNotToKeep
{
  // which
  signed int which;
  // u
  union anonymous$98 u;
  // originSuggestedPeriod
  struct Z_PQSPeriod *originSuggestedPeriod;
  // expiration
  char *expiration;
  // resultSetPackage
  char *resultSetPackage;
};

struct Z_PQSOriginPartToKeep
{
  // activeFlag
  signed int *activeFlag;
  // num_databaseNames
  signed int num_databaseNames;
  // databaseNames
  char **databaseNames;
  // resultSetDisposition
  signed long long int *resultSetDisposition;
  // alertDestination
  struct Z_ESDestination *alertDestination;
  // which
  signed int which;
  // u
  union anonymous$96 u;
};

struct Z_PQSPeriod
{
  // which
  signed int which;
  // u
  union anonymous$99 u;
};

struct Z_PQSPeriodicQuerySchedule
{
  // which
  signed int which;
  // u
  union anonymous$95 u;
};

struct Z_PQSPeriodicQueryScheduleEsRequest
{
  // toKeep
  struct Z_PQSOriginPartToKeep *toKeep;
  // notToKeep
  struct Z_PQSOriginPartNotToKeep *notToKeep;
};

struct Z_PQSPeriodicQueryScheduleTaskPackage
{
  // originPart
  struct Z_PQSOriginPartToKeep *originPart;
  // targetPart
  struct Z_PQSTargetPart *targetPart;
};

struct Z_PQSTargetPart
{
  // actualQuery
  struct Z_Query *actualQuery;
  // targetStatedPeriod
  struct Z_PQSPeriod *targetStatedPeriod;
  // expiration
  char *expiration;
  // resultSetPackage
  char *resultSetPackage;
  // lastQueryTime
  char *lastQueryTime;
  // lastResultNumber
  signed long long int *lastResultNumber;
  // numberSinceModify
  signed long long int *numberSinceModify;
};

struct Z_PQueryOriginPartNotToKeep
{
  // which
  signed int which;
  // u
  union anonymous$94 u;
};

struct Z_PQueryOriginPartToKeep
{
  // num_dbNames
  signed int num_dbNames;
  // dbNames
  char **dbNames;
  // additionalSearchInfo
  struct Z_OtherInformation *additionalSearchInfo;
};

struct Z_PQueryPersistentQuery
{
  // which
  signed int which;
  // u
  union anonymous$93 u;
};

struct Z_PQueryPersistentQueryEsRequest
{
  // toKeep
  struct Z_PQueryOriginPartToKeep *toKeep;
  // notToKeep
  struct Z_PQueryOriginPartNotToKeep *notToKeep;
};

struct Z_PQueryPersistentQueryTaskPackage
{
  // originPart
  struct Z_PQueryOriginPartToKeep *originPart;
  // targetPart
  struct Z_Query *targetPart;
};

struct Z_PROriginPartNotToKeep
{
  // originSuppliedResultSet
  char *originSuppliedResultSet;
  // replaceOrAppend
  signed long long int *replaceOrAppend;
};

struct Z_PRPersistentResultSet
{
  // which
  signed int which;
  // u
  union anonymous$0 u;
};

struct Z_PRPersistentResultSetEsRequest
{
  // toKeep
  void *toKeep;
  // notToKeep
  struct Z_PROriginPartNotToKeep *notToKeep;
};

struct Z_PRPersistentResultSetTaskPackage
{
  // originPart
  void *originPart;
  // targetPart
  struct Z_PRTargetPart *targetPart;
};

struct Z_PRTargetPart
{
  // targetSuppliedResultSet
  char *targetSuppliedResultSet;
  // numberOfRecords
  signed long long int *numberOfRecords;
};

struct Z_Path
{
  // num
  signed int num;
  // elements
  struct Z_PathUnit **elements;
};

struct Z_PathUnit
{
  // tagType
  signed long long int *tagType;
  // tagValue
  struct Z_StringOrNumeric *tagValue;
};

struct Z_PerElementDetails
{
  // name
  char *name;
  // recordTag
  struct Z_RecordTag *recordTag;
  // num_schemaTags
  signed int num_schemaTags;
  // schemaTags
  struct Z_Path **schemaTags;
  // maxSize
  signed long long int *maxSize;
  // minSize
  signed long long int *minSize;
  // avgSize
  signed long long int *avgSize;
  // fixedSize
  signed long long int *fixedSize;
  // repeatable
  signed int *repeatable;
  // required
  signed int *required;
  // description
  struct Z_HumanString *description;
  // contents
  struct Z_HumanString *contents;
  // billingInfo
  struct Z_HumanString *billingInfo;
  // restrictions
  struct Z_HumanString *restrictions;
  // num_alternateNames
  signed int num_alternateNames;
  // alternateNames
  char **alternateNames;
  // num_genericNames
  signed int num_genericNames;
  // genericNames
  char **genericNames;
  // searchAccess
  struct Z_AttributeCombinations *searchAccess;
};

struct Z_Permissions
{
  // num
  signed int num;
  // elements
  struct Z_Permissions_s **elements;
};

struct Z_Permissions_s
{
  // userId
  char *userId;
  // num_allowableFunctions
  signed int num_allowableFunctions;
  // allowableFunctions
  signed long long int **allowableFunctions;
};

struct Z_PrivateCapOperator
{
  // roperator
  char *roperator;
  // description
  struct Z_HumanString *description;
};

struct Z_PrivateCapabilities
{
  // num_operators
  signed int num_operators;
  // operators
  struct Z_PrivateCapOperator **operators;
  // num_searchKeys
  signed int num_searchKeys;
  // searchKeys
  struct Z_SearchKey **searchKeys;
  // num_description
  signed int num_description;
  // description
  struct Z_HumanString **description;
};

struct Z_PrivateCharacterSet
{
  // which
  signed int which;
  // u
  union anonymous$77 u;
};

struct Z_PrivateCharacterSetViaOid
{
  // num
  signed int num;
  // elements
  signed short int **elements;
};

struct Z_ProcessingInformation
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // databaseName
  char *databaseName;
  // processingContext
  signed long long int *processingContext;
  // name
  char *name;
  // oid
  signed short int *oid;
  // description
  struct Z_HumanString *description;
  // instructions
  struct Z_External *instructions;
};

struct Z_PromptId
{
  // which
  signed int which;
  // u
  union anonymous$50 u;
};

struct Z_PromptIdEnumeratedPrompt
{
  // type
  signed long long int *type;
  // suggestedString
  char *suggestedString;
};

struct Z_PromptObject1
{
  // which
  signed int which;
  // u
  union anonymous$39 u;
};

struct Z_ProxSupportPrivate
{
  // unit
  signed long long int *unit;
  // description
  struct Z_HumanString *description;
};

struct Z_ProxSupportUnit
{
  // which
  signed int which;
  // u
  union anonymous$22 u;
};

struct Z_Proximity
{
  // which
  signed int which;
  // u
  union anonymous$21 u;
};

struct Z_ProximityOperator
{
  // exclusion
  signed int *exclusion;
  // distance
  signed long long int *distance;
  // ordered
  signed int *ordered;
  // relationType
  signed long long int *relationType;
  // which
  signed int which;
  // u
  union anonymous$15 u;
};

struct Z_ProximitySupport
{
  // anySupport
  signed int *anySupport;
  // num_unitsSupported
  signed int num_unitsSupported;
  // unitsSupported
  struct Z_ProxSupportUnit **unitsSupported;
};

struct Z_Query
{
  // which
  signed int which;
  // u
  union anonymous$82 u;
};

struct Z_QueryExpression
{
  // which
  signed int which;
  // u
  union anonymous$79 u;
};

struct Z_QueryExpressionTerm
{
  // queryTerm
  struct Z_Term *queryTerm;
  // termComment
  char *termComment;
};

struct Z_QueryTypeDetails
{
  // which
  signed int which;
  // u
  union anonymous$76 u;
};

struct Z_RPNQuery
{
  // attributeSetId
  signed short int *attributeSetId;
  // RPNStructure
  struct Z_RPNStructure *RPNStructure;
};

struct Z_RPNStructure
{
  // which
  signed int which;
  // u
  union anonymous$27 u;
};

struct Z_RecordSyntax
{
  // unsupportedSyntax
  signed short int *unsupportedSyntax;
  // num_suggestedAlternatives
  signed int num_suggestedAlternatives;
  // suggestedAlternatives
  signed short int **suggestedAlternatives;
};

struct Z_RecordSyntaxInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // recordSyntax
  signed short int *recordSyntax;
  // name
  char *name;
  // num_transferSyntaxes
  signed int num_transferSyntaxes;
  // transferSyntaxes
  signed short int **transferSyntaxes;
  // description
  struct Z_HumanString *description;
  // asn1Module
  char *asn1Module;
  // num_abstractStructure
  signed int num_abstractStructure;
  // abstractStructure
  struct Z_ElementInfo **abstractStructure;
};

struct Z_RecordTag
{
  // qualifier
  struct Z_StringOrNumeric *qualifier;
  // tagValue
  struct Z_StringOrNumeric *tagValue;
};

struct Z_ResourceReport1
{
  // num_estimates
  signed int num_estimates;
  // estimates
  struct Z_Estimate1 **estimates;
  // message
  char *message;
};

struct Z_ResourceReport2
{
  // num_estimates
  signed int num_estimates;
  // estimates
  struct Z_Estimate2 **estimates;
  // message
  char *message;
};

struct Z_Response1
{
  // num
  signed int num;
  // elements
  struct Z_ResponseUnit1 **elements;
};

struct Z_ResponseUnit1
{
  // promptId
  struct Z_PromptId *promptId;
  // which
  signed int which;
  // u
  union anonymous$55 u;
};

struct Z_ResultSetPlusAttributes
{
  // resultSet
  char *resultSet;
  // attributes
  struct Z_AttributeList *attributes;
};

struct Z_ResultsByDB
{
  // num
  signed int num;
  // elements
  struct Z_ResultsByDB_s **elements;
};

struct Z_ResultsByDB_s
{
  // which
  signed int which;
  // u
  union anonymous$80 u;
  // count
  signed long long int *count;
  // resultSetName
  char *resultSetName;
};

struct Z_ResultsByDB_sList
{
  // num
  signed int num;
  // elements
  char **elements;
};

struct Z_RetrievalRecordDetails
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // databaseName
  char *databaseName;
  // schema
  signed short int *schema;
  // recordSyntax
  signed short int *recordSyntax;
  // description
  struct Z_HumanString *description;
  // num_detailsPerElement
  signed int num_detailsPerElement;
  // detailsPerElement
  struct Z_PerElementDetails **detailsPerElement;
};

struct Z_RpnCapabilities
{
  // num_operators
  signed int num_operators;
  // operators
  signed long long int **operators;
  // resultSetAsOperandSupported
  signed int *resultSetAsOperandSupported;
  // restrictionOperandSupported
  signed int *restrictionOperandSupported;
  // proximity
  struct Z_ProximitySupport *proximity;
};

struct Z_Scan
{
  // which
  signed int which;
  // u
  union anonymous$23 u;
};

struct Z_SchemaInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // schema
  signed short int *schema;
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // num_tagTypeMapping
  signed int num_tagTypeMapping;
  // tagTypeMapping
  struct Z_TagTypeMapping **tagTypeMapping;
  // num_recordStructure
  signed int num_recordStructure;
  // recordStructure
  struct Z_ElementInfo **recordStructure;
};

struct Z_SearchInfoReport
{
  // num
  signed int num;
  // elements
  struct Z_SearchInfoReport_s **elements;
};

struct Z_SearchInfoReport_s
{
  // subqueryId
  char *subqueryId;
  // fullQuery
  signed int *fullQuery;
  // subqueryExpression
  struct Z_QueryExpression *subqueryExpression;
  // subqueryInterpretation
  struct Z_QueryExpression *subqueryInterpretation;
  // subqueryRecommendation
  struct Z_QueryExpression *subqueryRecommendation;
  // subqueryCount
  signed long long int *subqueryCount;
  // subqueryWeight
  struct Z_IntUnit *subqueryWeight;
  // resultsByDB
  struct Z_ResultsByDB *resultsByDB;
};

struct Z_SearchKey
{
  // searchKey
  char *searchKey;
  // description
  struct Z_HumanString *description;
};

struct Z_Segment
{
  // referenceId
  struct odr_oct *referenceId;
  // numberOfRecordsReturned
  signed long long int *numberOfRecordsReturned;
  // num_segmentRecords
  signed int num_segmentRecords;
  // segmentRecords
  struct Z_NamePlusRecord **segmentRecords;
  // otherInfo
  struct Z_OtherInformation *otherInfo;
};

struct Z_Segmentation
{
  // which
  signed int which;
  // u
  union anonymous$101 u;
};

struct Z_SimpleElement
{
  // path
  struct Z_ETagPath *path;
  // variantRequest
  struct Z_Variant *variantRequest;
};

struct Z_Sort
{
  // which
  signed int which;
  // u
  union anonymous$25 u;
};

struct Z_SortAttributes
{
  // id
  signed short int *id;
  // list
  struct Z_AttributeList *list;
};

struct Z_SortDbSpecificList
{
  // num
  signed int num;
  // elements
  struct Z_SortDbSpecificList_s **elements;
};

struct Z_SortDbSpecificList_s
{
  // databaseName
  char *databaseName;
  // dbSort
  struct Z_SortKey *dbSort;
};

struct Z_SortDetails
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // databaseName
  char *databaseName;
  // num_sortKeys
  signed int num_sortKeys;
  // sortKeys
  struct Z_SortKeyDetails **sortKeys;
};

struct Z_SortElement
{
  // which
  signed int which;
  // u
  union anonymous$24 u;
};

struct Z_SortKey
{
  // which
  signed int which;
  // u
  union anonymous$83 u;
};

struct Z_SortKeyDetails
{
  // description
  struct Z_HumanString *description;
  // num_elementSpecifications
  signed int num_elementSpecifications;
  // elementSpecifications
  struct Z_Specification **elementSpecifications;
  // attributeSpecifications
  struct Z_AttributeCombinations *attributeSpecifications;
  // which
  signed int which;
  // u
  union anonymous$71 u;
  // caseSensitivity
  signed long long int *caseSensitivity;
};

struct Z_SpecificTag
{
  // tagType
  signed long long int *tagType;
  // tagValue
  struct Z_StringOrNumeric *tagValue;
  // occurrences
  struct Z_Occurrences *occurrences;
};

struct Z_Specification
{
  // which
  signed int which;
  // schema
  union anonymous$62 schema;
  // elementSpec
  struct Z_ElementSpec *elementSpec;
};

struct Z_StringList
{
  // num
  signed int num;
  // elements
  char **elements;
};

struct Z_StringOrNumeric
{
  // which
  signed int which;
  // u
  union anonymous$7 u;
};

struct Z_TagPath
{
  // num
  signed int num;
  // elements
  struct Z_TagPath_s **elements;
};

struct Z_TagPath_s
{
  // tagType
  signed long long int *tagType;
  // tagValue
  struct Z_StringOrNumeric *tagValue;
  // tagOccurrence
  signed long long int *tagOccurrence;
};

struct Z_TagSetElements
{
  // elementname
  char *elementname;
  // num_nicknames
  signed int num_nicknames;
  // nicknames
  char **nicknames;
  // elementTag
  struct Z_StringOrNumeric *elementTag;
  // description
  struct Z_HumanString *description;
  // dataType
  signed long long int *dataType;
  // otherTagInfo
  struct Z_OtherInformation *otherTagInfo;
};

struct Z_TagSetInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // tagSet
  signed short int *tagSet;
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // num_elements
  signed int num_elements;
  // elements
  struct Z_TagSetElements **elements;
};

struct Z_TagTypeMapping
{
  // tagType
  signed long long int *tagType;
  // tagSet
  signed short int *tagSet;
  // defaultTagType
  void *defaultTagType;
};

struct Z_TaggedElement
{
  // tagType
  signed long long int *tagType;
  // tagValue
  struct Z_StringOrNumeric *tagValue;
  // tagOccurrence
  signed long long int *tagOccurrence;
  // content
  struct Z_ElementData *content;
  // metaData
  struct Z_ElementMetaData *metaData;
  // appliedVariant
  struct Z_Variant *appliedVariant;
};

struct Z_TargetInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // name
  char *name;
  // recentNews
  struct Z_HumanString *recentNews;
  // icon
  struct Z_IconObject *icon;
  // namedResultSets
  signed int *namedResultSets;
  // multipleDBsearch
  signed int *multipleDBsearch;
  // maxResultSets
  signed long long int *maxResultSets;
  // maxResultSize
  signed long long int *maxResultSize;
  // maxTerms
  signed long long int *maxTerms;
  // timeoutInterval
  struct Z_IntUnit *timeoutInterval;
  // welcomeMessage
  struct Z_HumanString *welcomeMessage;
  // contactInfo
  struct Z_ContactInfo *contactInfo;
  // description
  struct Z_HumanString *description;
  // num_nicknames
  signed int num_nicknames;
  // nicknames
  char **nicknames;
  // usageRest
  struct Z_HumanString *usageRest;
  // paymentAddr
  struct Z_HumanString *paymentAddr;
  // hours
  struct Z_HumanString *hours;
  // num_dbCombinations
  signed int num_dbCombinations;
  // dbCombinations
  struct Z_DatabaseList **dbCombinations;
  // num_addresses
  signed int num_addresses;
  // addresses
  struct Z_NetworkAddress **addresses;
  // num_languages
  signed int num_languages;
  // languages
  char **languages;
  // commonAccessInfo
  struct Z_AccessInfo *commonAccessInfo;
};

struct Z_TargetResponse
{
  // which
  signed int which;
  // u
  union anonymous$72 u;
  // selectedLanguage
  char *selectedLanguage;
  // recordsInSelectedCharSets
  signed int *recordsInSelectedCharSets;
};

struct Z_TaskPackage
{
  // packageType
  signed short int *packageType;
  // packageName
  char *packageName;
  // userId
  char *userId;
  // retentionTime
  struct Z_IntUnit *retentionTime;
  // permissions
  struct Z_Permissions *permissions;
  // description
  char *description;
  // targetReference
  struct odr_oct *targetReference;
  // creationDateTime
  char *creationDateTime;
  // taskStatus
  signed long long int *taskStatus;
  // num_packageDiagnostics
  signed int num_packageDiagnostics;
  // packageDiagnostics
  struct Z_DiagRec **packageDiagnostics;
  // taskSpecificParameters
  struct Z_External *taskSpecificParameters;
};

struct Z_Term
{
  // which
  signed int which;
  // u
  union anonymous$1 u;
};

struct Z_TermListDetails
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // termListName
  char *termListName;
  // description
  struct Z_HumanString *description;
  // attributes
  struct Z_AttributeCombinations *attributes;
  // scanInfo
  struct Z_EScanInfo *scanInfo;
  // estNumberTerms
  signed long long int *estNumberTerms;
  // num_sampleTerms
  signed int num_sampleTerms;
  // sampleTerms
  struct Z_Term **sampleTerms;
};

struct Z_TermListElement
{
  // name
  char *name;
  // title
  struct Z_HumanString *title;
  // searchCost
  signed long long int *searchCost;
  // scanable
  signed int *scanable;
  // num_broader
  signed int num_broader;
  // broader
  char **broader;
  // num_narrower
  signed int num_narrower;
  // narrower
  char **narrower;
};

struct Z_TermListInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // databaseName
  char *databaseName;
  // num_termLists
  signed int num_termLists;
  // termLists
  struct Z_TermListElement **termLists;
};

struct Z_Time
{
  // hour
  signed long long int *hour;
  // minute
  signed long long int *minute;
  // second
  signed long long int *second;
  // partOfSecond
  struct Z_IntUnit *partOfSecond;
  // which
  signed int which;
  // u
  union anonymous$42 u;
};

struct Z_TooMany
{
  // tooManyWhat
  signed long long int *tooManyWhat;
  // max
  signed long long int *max;
};

struct Z_Triple
{
  // variantSetId
  signed short int *variantSetId;
  // zclass
  signed long long int *zclass;
  // type
  signed long long int *type;
  // which
  signed int which;
  // value
  union anonymous$59 value;
};

struct Z_Unit
{
  // unitSystem
  char *unitSystem;
  // unitType
  struct Z_StringOrNumeric *unitType;
  // unit
  struct Z_StringOrNumeric *unit;
  // scaleFactor
  signed long long int *scaleFactor;
};

struct Z_UnitInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // unitSystem
  char *unitSystem;
  // description
  struct Z_HumanString *description;
  // num_units
  signed int num_units;
  // units
  struct Z_UnitType **units;
};

struct Z_UnitType
{
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // unitType
  struct Z_StringOrNumeric *unitType;
  // num_units
  signed int num_units;
  // units
  struct Z_Units **units;
};

struct Z_Units
{
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // unit
  struct Z_StringOrNumeric *unit;
};

struct Z_UniverseReport
{
  // totalHits
  signed long long int *totalHits;
  // which
  signed int which;
  // u
  union anonymous$30 u;
};

struct Z_UniverseReportDuplicate
{
  // hitno
  struct Z_StringOrNumeric *hitno;
};

struct Z_UniverseReportHits
{
  // database
  struct Z_StringOrNumeric *database;
  // hits
  struct Z_StringOrNumeric *hits;
};

struct Z_Usage
{
  // type
  signed long long int *type;
  // restriction
  char *restriction;
};

struct Z_ValueDescription
{
  // which
  signed int which;
  // u
  union anonymous$74 u;
};

struct Z_ValueRange
{
  // lower
  struct Z_ValueDescription *lower;
  // upper
  struct Z_ValueDescription *upper;
};

struct Z_ValueSet
{
  // which
  signed int which;
  // u
  union anonymous$73 u;
};

struct Z_ValueSetEnumerated
{
  // num
  signed int num;
  // elements
  struct Z_ValueDescription **elements;
};

struct Z_Variant
{
  // globalVariantSetId
  signed short int *globalVariantSetId;
  // num_triples
  signed int num_triples;
  // triples
  struct Z_Triple **triples;
};

struct Z_VariantClass
{
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // variantClass
  signed long long int *variantClass;
  // num_variantTypes
  signed int num_variantTypes;
  // variantTypes
  struct Z_VariantType **variantTypes;
};

struct Z_VariantSetInfo
{
  // commonInfo
  struct Z_CommonInfo *commonInfo;
  // variantSet
  signed short int *variantSet;
  // name
  char *name;
  // num_variants
  signed int num_variants;
  // variants
  struct Z_VariantClass **variants;
};

struct Z_VariantType
{
  // name
  char *name;
  // description
  struct Z_HumanString *description;
  // variantType
  signed long long int *variantType;
  // variantValue
  struct Z_VariantValue *variantValue;
};

struct Z_VariantValue
{
  // dataType
  signed long long int *dataType;
  // values
  struct Z_ValueSet *values;
};

struct Z_Volume
{
  // enumeration
  char *enumeration;
  // chronology
  char *chronology;
  // enumAndChron
  char *enumAndChron;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _xmlAttr
{
  // _private
  void *_private;
  // type
  enum anonymous$10 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlAttr *next;
  // prev
  struct _xmlAttr *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // atype
  enum anonymous$13 atype;
  // psvi
  void *psvi;
};

struct _xmlDoc
{
  // _private
  void *_private;
  // type
  enum anonymous$10 type;
  // name
  char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // compression
  signed int compression;
  // standalone
  signed int standalone;
  // intSubset
  struct _xmlDtd *intSubset;
  // extSubset
  struct _xmlDtd *extSubset;
  // oldNs
  struct _xmlNs *oldNs;
  // version
  const unsigned char *version;
  // encoding
  const unsigned char *encoding;
  // ids
  void *ids;
  // refs
  void *refs;
  // URL
  const unsigned char *URL;
  // charset
  signed int charset;
  // dict
  struct _xmlDict *dict;
  // psvi
  void *psvi;
  // parseFlags
  signed int parseFlags;
  // properties
  signed int properties;
};

struct _xmlDtd
{
  // _private
  void *_private;
  // type
  enum anonymous$10 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlDoc *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // notations
  void *notations;
  // elements
  void *elements;
  // attributes
  void *attributes;
  // entities
  void *entities;
  // ExternalID
  const unsigned char *ExternalID;
  // SystemID
  const unsigned char *SystemID;
  // pentities
  void *pentities;
};

struct _xmlNode
{
  // _private
  void *_private;
  // type
  enum anonymous$10 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // content
  unsigned char *content;
  // properties
  struct _xmlAttr *properties;
  // nsDef
  struct _xmlNs *nsDef;
  // psvi
  void *psvi;
  // line
  unsigned short int line;
  // extra
  unsigned short int extra;
};

struct _xmlNs
{
  // next
  struct _xmlNs *next;
  // type
  enum anonymous$10 type;
  // href
  const unsigned char *href;
  // prefix
  const unsigned char *prefix;
  // _private
  void *_private;
  // context
  struct _xmlDoc *context;
};

struct chr_t_entry
{
  // children
  struct chr_t_entry **children;
  // target
  unsigned char **target;
};

struct chrmaptab_info
{
  // input
  struct chr_t_entry *input;
  // q_input
  struct chr_t_entry *q_input;
  // output
  unsigned char *output[256l];
  // base_uppercase
  signed int base_uppercase;
  // nmem
  struct nmem_control *nmem;
};

struct chrwork
{
  // map
  struct chrmaptab_info *map;
  // string
  char string[1025l];
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct it_key
{
  // len
  signed int len;
  // mem
  signed long long int mem[5l];
};

struct iscz1_code_info
{
  // key
  struct it_key key;
};

struct odr_bitmask
{
  // bits
  unsigned char bits[256l];
  // top
  signed int top;
};

struct odr_oct
{
  // buf
  unsigned char *buf;
  // len
  signed int len;
  // size
  signed int size;
};

struct passwd_db
{
  // entries
  struct passwd_entry *entries;
};

struct passwd_entry
{
  // encrypt_flag
  signed int encrypt_flag;
  // name
  char *name;
  // des
  char *des;
  // next
  struct passwd_entry *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct res_entry
{
  // name
  char *name;
  // value
  char *value;
  // next
  struct res_entry *next;
};

struct res_struct
{
  // ref_count
  signed int ref_count;
  // first
  struct res_entry *first;
  // last
  struct res_entry *last;
  // def_res
  struct res_struct *def_res;
  // over_res
  struct res_struct *over_res;
};

struct strmap_entry
{
  // name
  char *name;
  // data_len
  unsigned long int data_len;
  // data_buf
  void *data_buf;
  // next
  struct strmap_entry *next;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct wrbuf
{
  // buf
  char *buf;
  // pos
  unsigned long int pos;
  // size
  unsigned long int size;
};

struct xpath_location_step
{
  // part
  char *part;
  // predicate
  struct xpath_predicate *predicate;
};

struct xpath_predicate
{
  // which
  signed int which;
  // u
  union anonymous$66 u;
};

struct zebra_lock_handle
{
  // write_flag
  signed int write_flag;
  // p
  struct zebra_lock_info *p;
};

struct zebra_lock_info
{
  // fd
  signed int fd;
  // fname
  char *fname;
  // ref_count
  signed int ref_count;
  // no_file_write_lock
  signed int no_file_write_lock;
  // no_file_read_lock
  signed int no_file_read_lock;
  // rdwr_lock
  struct anonymous$56 rdwr_lock;
  // file_mutex
  struct anonymous$54 file_mutex;
  // next
  struct zebra_lock_info *next;
};

struct zebra_map
{
  // id
  const char *id;
  // completeness
  signed int completeness;
  // positioned
  signed int positioned;
  // alwaysmatches
  signed int alwaysmatches;
  // first_in_field
  signed int first_in_field;
  // type
  signed int type;
  // use_chain
  signed int use_chain;
  // debug
  signed int debug;
  // u
  union anonymous$97 u;
  // maptab
  struct chrmaptab_info *maptab;
  // maptab_name
  const char *maptab_name;
  // zebra_maps
  struct zebra_maps_s *zebra_maps;
  // doc
  struct _xmlDoc *doc;
  // icu_chain
  struct icu_chain *icu_chain;
  // input_str
  struct wrbuf *input_str;
  // print_str
  struct wrbuf *print_str;
  // simple_off
  unsigned long int simple_off;
  // next
  struct zebra_map *next;
};

struct zebra_maps_s
{
  // tabpath
  char *tabpath;
  // tabroot
  char *tabroot;
  // nmem
  struct nmem_control *nmem;
  // temp_map_str
  char temp_map_str[2l];
  // temp_map_ptr
  const char *temp_map_ptr[2l];
  // wrbuf_1
  struct wrbuf *wrbuf_1;
  // no_files_read
  signed int no_files_read;
  // map_list
  struct zebra_map *map_list;
  // last_map
  struct zebra_map *last_map;
};

struct zebra_snippet_word
{
  // seqno
  signed long long int seqno;
  // ord
  signed int ord;
  // term
  char *term;
  // match
  signed int match;
  // mark
  signed int mark;
  // ws
  signed int ws;
  // next
  struct zebra_snippet_word *next;
  // prev
  struct zebra_snippet_word *prev;
};

struct zebra_snippets
{
  // nmem
  struct nmem_control *nmem;
  // front
  struct zebra_snippet_word *front;
  // tail
  struct zebra_snippet_word *tail;
};

struct zebra_strmap
{
  // nmem_str
  struct nmem_control *nmem_str;
  // nmem_ent
  struct nmem_control *nmem_ent;
  // hsize
  signed int hsize;
  // size
  signed int size;
  // entries
  struct strmap_entry **entries;
  // free_entries
  struct strmap_entry *free_entries;
};

struct zebra_strmap_it_s
{
  // hno
  signed int hno;
  // ent
  struct strmap_entry *ent;
  // st
  struct zebra_strmap *st;
};


// CHR_BASE
// file charmap.c line 51
const char *CHR_BASE = "\005";
// CHR_CUT
// file charmap.c line 50
const char *CHR_CUT = "\003";
// CHR_FIELD_BEGIN
// file charmap.c line 46
const unsigned char CHR_FIELD_BEGIN = (const unsigned char)94;
// CHR_SPACE
// file charmap.c line 49
const char *CHR_SPACE = "\002";
// CHR_UNKNOWN
// file charmap.c line 48
const char *CHR_UNKNOWN = "\001";
// initialized
// file flock.c line 44
static signed int initialized = 0;
// lock_list
// file flock.c line 53
static struct zebra_lock_info *lock_list = ((struct zebra_lock_info *)NULL);
// lock_list_mutex
// file flock.c line 50
struct anonymous$54 lock_list_mutex;
// log_level
// file flock.c line 82
static signed int log_level = 0;
// posix_locks
// file flock.c line 47
static signed int posix_locks = 1;
// seq
// file tstflock.c line 62
static char seq[1000l];
// seqp
// file tstflock.c line 63
static char *seqp = ((char *)NULL);
// sleep_cond
// file tstflock.c line 68
union anonymous$48 sleep_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// sleep_mutex
// file tstflock.c line 69
union anonymous$47 sleep_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// test_fd
// file tstflock.c line 72
signed int test_fd = 0;

// add_entry
// file res.c line 60
static struct res_entry * add_entry(struct res_struct *r)
{
  struct res_entry *resp;
  void *return_value_xmalloc_f$1;
  if(r->first == ((struct res_entry *)NULL))
  {
    return_value_xmalloc_f$1=xmalloc_f(sizeof(struct res_entry) /*24ul*/ , "res.c", 66);
    r->first = (struct res_entry *)return_value_xmalloc_f$1;
    r->last = r->first;
    resp = r->last;
  }

  else
  {
    void *return_value_xmalloc_f$2;
    return_value_xmalloc_f$2=xmalloc_f(sizeof(struct res_entry) /*24ul*/ , "res.c", 69);
    resp = (struct res_entry *)return_value_xmalloc_f$2;
    r->last->next = resp;
    r->last = resp;
  }
  resp->next = (struct res_entry *)(void *)0;
  return resp;
}

// atoi_zn
// file atoi_zn.c line 27
signed long long int atoi_zn(const char *buf, signed long long int len)
{
  signed long long int val = (signed long long int)0;
  do
  {
    len = len - 1ll;
    if(!(len >= 0l))
      break;

    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*buf]) == 0))
      val = val * (signed long int)10 + (signed long int)((signed int)*buf - 48);

    buf = buf + 1l;
  }
  while((_Bool)1);
  return val;
}

// atozint
// file zint.c line 55
signed long long int atozint(const char *src)
{
  signed long long int return_value_atoll$1;
  return_value_atoll$1=atoll(src);
  return return_value_atoll$1;
}

// attr_find
// file ../include/attrfind.h line 42
signed int attr_find(struct anonymous$89 *src, const signed short int **attribute_set_id)
{
  signed int return_value_attr_find_ex$1;
  return_value_attr_find_ex$1=attr_find_ex(src, attribute_set_id, ((const char **)NULL));
  return return_value_attr_find_ex$1;
}

// attr_find_ex
// file ../include/attrfind.h line 40
signed int attr_find_ex(struct anonymous$89 *src, const signed short int **attribute_set_oid, const char **string_value)
{
  signed int num_attributes = src->num_attributes;
  while(!(src->major >= num_attributes))
  {
    struct Z_AttributeElement *element = src->attributeList[(signed long int)src->major];
    if((signed long int)src->type == *element->attributeType)
      switch(element->which)
      {
        case 1:
        {
          src->major = src->major + 1;
          if(!(element->attributeSet == ((signed short int *)NULL)))
          {
            if(!(attribute_set_oid == ((const signed short int **)NULL)))
              *attribute_set_oid = element->attributeSet;

          }

          return (signed int)*element->value.numeric;
        }
        case 2:
        {
          if(src->minor >= element->value.complex->num_list)
            break;

          if(!(element->attributeSet == ((signed short int *)NULL)))
          {
            if(!(attribute_set_oid == ((const signed short int **)NULL)))
              *attribute_set_oid = element->attributeSet;

          }

          if(element->value.complex->list[(signed long int)src->minor]->which == 2)
          {
            src->minor = src->minor + 1;
            return (signed int)*element->value.complex->list[(signed long int)(src->minor - 1)]->u.numeric;
          }

          else
            if(element->value.complex->list[(signed long int)src->minor]->which == 1)
            {
              if(string_value == ((const char **)NULL))
                break;

              src->minor = src->minor + 1;
              *string_value = element->value.complex->list[(signed long int)(src->minor - 1)]->u.string;
              return -2;
            }

            else
              break;
        }
        default:
          /* assertion 0 */
          assert(0 != 0);
      }

    src->major = src->major + 1;
  }
  return -1;
}

// attr_init_APT
// file ../include/attrfind.h line 36
void attr_init_APT(struct anonymous$89 *src, struct Z_AttributesPlusTerm *zapt, signed int type)
{
  src->attributeList = zapt->attributes->attributes;
  src->num_attributes = zapt->attributes->num_attributes;
  src->type = type;
  src->major = 0;
  src->minor = 0;
}

// attr_init_AttrList
// file ../include/attrfind.h line 38
void attr_init_AttrList(struct anonymous$89 *src, struct Z_AttributeList *list, signed int type)
{
  src->attributeList = list->attributes;
  src->num_attributes = list->num_attributes;
  src->type = type;
  src->major = 0;
  src->minor = 0;
}

// check_for_linuxthreads
// file flock.c line 371
static signed int check_for_linuxthreads(void)
{
  char conf_buf[512l];
  unsigned long int r;
  r=confstr(3, conf_buf, sizeof(char [512l]) /*512ul*/ );
  if(r == 0ul)
  {
    yaz_log(0x00000004 | 0x00000010, "confstr failed");
    return -1;
  }

  else
  {
    signed int return_value_strncmp$1;
    return_value_strncmp$1=strncmp(conf_buf, "linuxthreads", (unsigned long int)12);
    if(return_value_strncmp$1 == 0)
      posix_locks = 0;

    return 0;
  }
}

// chr_map_input
// file charmap.c line 194
const char ** chr_map_input(struct chrmaptab_info *maptab, const char **from, signed int len, signed int first)
{
  struct chr_t_entry *t = maptab->input;
  struct chr_t_entry *res;
  signed int len_tmp[2l];
  len_tmp[(signed long int)0] = len;
  len_tmp[(signed long int)1] = -1;
  res=find_entry_x(t, from, len_tmp, first);
  if(res == ((struct chr_t_entry *)NULL))
    abort();

  return (const char **)res->target;
}

// chr_map_input_x
// file charmap.c line 184
const char ** chr_map_input_x(struct chrmaptab_info *maptab, const char **from, signed int *len, signed int first)
{
  struct chr_t_entry *t = maptab->input;
  struct chr_t_entry *res;
  res=find_entry_x(t, from, len, first);
  if(res == ((struct chr_t_entry *)NULL))
    abort();

  return (const char **)res->target;
}

// chr_map_output
// file charmap.c line 221
const char * chr_map_output(struct chrmaptab_info *maptab, const char **from, signed int len)
{
  unsigned char c = *(*((unsigned char **)from));
  const char *out = (const char *)maptab->output[(signed long int)c];
  if(!(out == ((const char *)NULL)))
    *from = *from + 1l;

  return out;
}

// chr_map_q_input
// file charmap.c line 207
const char ** chr_map_q_input(struct chrmaptab_info *maptab, const char **from, signed int len, signed int first)
{
  struct chr_t_entry *t = maptab->q_input;
  struct chr_t_entry *res;
  signed int len_tmp[2l];
  len_tmp[(signed long int)0] = len;
  len_tmp[(signed long int)1] = -1;
  res=find_entry_x(t, from, len_tmp, first);
  if(res == ((struct chr_t_entry *)NULL))
    return ((const char **)NULL);

  else
    return (const char **)res->target;
}

// chrmaptab_create
// file charmap.c line 513
struct chrmaptab_info * chrmaptab_create(const char *tabpath, const char *name, const char *tabroot)
{
  struct _IO_FILE *f;
  char line[512l];
  char *argv[50l];
  struct chrmaptab_info *res;
  signed int lineno = 0;
  signed int no_directives = 0;
  signed int errors = 0;
  signed int argc;
  signed int num = (signed int)*CHR_BASE;
  signed int chrmaptab_create$$1$$i;
  struct nmem_control *nmem;
  struct yaz_iconv_struct *t_unicode = ((struct yaz_iconv_struct *)NULL);
  struct yaz_iconv_struct *t_utf8 = ((struct yaz_iconv_struct *)NULL);
  unsigned int endian = (unsigned int)31;
  const char *ucs4_native = "UCS-4";
  yaz_log(0x00000002, "maptab %s open", name);
  f=yaz_fopen(tabpath, name, "r", tabroot);
  signed int return_value_yaz_matchstr$26;
  signed int return_value_yaz_matchstr$25;
  signed int return_value_yaz_matchstr$24;
  signed int return_value_yaz_matchstr$23;
  signed int return_value_yaz_matchstr$22;
  unsigned long int return_value_strlen$14;
  signed int tmp_post$16;
  signed int tmp_post$18;
  signed int return_value_yaz_matchstr$21;
  if(f == ((struct _IO_FILE *)NULL))
  {
    yaz_log(0x00000004 | 0x00000010, "%s", name);
    return ((struct chrmaptab_info *)NULL);
  }

  else
  {
    if((signed int)*((char *)&endian) == 31)
      ucs4_native = "UCS-4LE";

    t_utf8=yaz_iconv_open("UTF-8", ucs4_native);
    nmem=nmem_create();
    void *return_value_nmem_malloc$1;
    return_value_nmem_malloc$1=nmem_malloc(nmem, sizeof(struct chrmaptab_info) /*2080ul*/ );
    res = (struct chrmaptab_info *)return_value_nmem_malloc$1;
    res->nmem = nmem;
    void *return_value_nmem_malloc$2;
    return_value_nmem_malloc$2=nmem_malloc(res->nmem, sizeof(struct chr_t_entry) /*16ul*/ );
    res->input = (struct chr_t_entry *)return_value_nmem_malloc$2;
    void *return_value_nmem_malloc$3;
    return_value_nmem_malloc$3=nmem_malloc(res->nmem, sizeof(unsigned char *) /*8ul*/  * (unsigned long int)2);
    res->input->target = (unsigned char **)return_value_nmem_malloc$3;
    res->input->target[(signed long int)0] = (unsigned char *)CHR_UNKNOWN;
    res->input->target[(signed long int)1] = ((unsigned char *)NULL);
    void *return_value_nmem_malloc$4;
    return_value_nmem_malloc$4=nmem_malloc(res->nmem, sizeof(struct chr_t_entry *) /*8ul*/  * (unsigned long int)256);
    res->input->children = (struct chr_t_entry **)return_value_nmem_malloc$4;
    chrmaptab_create$$1$$i = 0;
    for( ; !(chrmaptab_create$$1$$i >= 256); chrmaptab_create$$1$$i = chrmaptab_create$$1$$i + 1)
    {
      void *return_value_nmem_malloc$5;
      return_value_nmem_malloc$5=nmem_malloc(res->nmem, sizeof(struct chr_t_entry) /*16ul*/ );
      res->input->children[(signed long int)chrmaptab_create$$1$$i] = (struct chr_t_entry *)return_value_nmem_malloc$5;
      res->input->children[(signed long int)chrmaptab_create$$1$$i]->children = ((struct chr_t_entry **)NULL);
      void *return_value_nmem_malloc$6;
      return_value_nmem_malloc$6=nmem_malloc(res->nmem, (unsigned long int)2 * sizeof(unsigned char *) /*8ul*/ );
      res->input->children[(signed long int)chrmaptab_create$$1$$i]->target = (unsigned char **)return_value_nmem_malloc$6;
      res->input->children[(signed long int)chrmaptab_create$$1$$i]->target[(signed long int)1] = ((unsigned char *)NULL);
      res->input->children[(signed long int)chrmaptab_create$$1$$i]->target[(signed long int)0] = (unsigned char *)CHR_UNKNOWN;
    }
    void *return_value_nmem_malloc$7;
    return_value_nmem_malloc$7=nmem_malloc(res->nmem, sizeof(struct chr_t_entry) /*16ul*/ );
    res->q_input = (struct chr_t_entry *)return_value_nmem_malloc$7;
    res->q_input->target = ((unsigned char **)NULL);
    res->q_input->children = ((struct chr_t_entry **)NULL);
    chrmaptab_create$$1$$i = (signed int)*CHR_BASE;
    for( ; !(chrmaptab_create$$1$$i >= 256); chrmaptab_create$$1$$i = chrmaptab_create$$1$$i + 1)
      res->output[(signed long int)chrmaptab_create$$1$$i] = ((unsigned char *)NULL);
    res->output[(signed long int)(signed int)*CHR_SPACE] = (unsigned char *)" ";
    res->output[(signed long int)(signed int)*CHR_UNKNOWN] = (unsigned char *)"@";
    res->base_uppercase = 0;
    while(errors == 0)
    {
      argc=readconf_line(f, &lineno, line, 512, argv, 50);
      if(argc == 0)
        break;

      no_directives = no_directives + 1;
      signed int return_value_yaz_matchstr$27;
      return_value_yaz_matchstr$27=yaz_matchstr(argv[(signed long int)0], "lowercase");
      if(return_value_yaz_matchstr$27 == 0)
      {
        if(!(argc == 2))
        {
          yaz_log(0x00000001, "Syntax error in charmap");
          errors = errors + 1;
        }

        signed int return_value_scan_string$8;
        return_value_scan_string$8=scan_string(argv[(signed long int)1], t_unicode, t_utf8, fun_addentry, (void *)res, &num);
        if(!(return_value_scan_string$8 >= 0))
        {
          yaz_log(0x00000001, "Bad value-set specification");
          errors = errors + 1;
        }

        res->base_uppercase = num;
        res->output[(signed long int)((signed int)*CHR_SPACE + num)] = (unsigned char *)" ";
        res->output[(signed long int)((signed int)*CHR_UNKNOWN + num)] = (unsigned char *)"@";
        num = (signed int)*CHR_BASE;
      }

      else
      {
        return_value_yaz_matchstr$26=yaz_matchstr(argv[(signed long int)0], "uppercase");
        if(return_value_yaz_matchstr$26 == 0)
        {
          if(res->base_uppercase == 0)
          {
            yaz_log(0x00000001, "Uppercase directive with no lowercase set");
            errors = errors + 1;
          }

          if(!(argc == 2))
          {
            yaz_log(0x00000001, "Missing arg for uppercase directive");
            errors = errors + 1;
          }

          signed int return_value_scan_string$9;
          return_value_scan_string$9=scan_string(argv[(signed long int)1], t_unicode, t_utf8, fun_addentry, (void *)res, &num);
          if(!(return_value_scan_string$9 >= 0))
          {
            yaz_log(0x00000001, "Bad value-set specification");
            errors = errors + 1;
          }

        }

        else
        {
          return_value_yaz_matchstr$25=yaz_matchstr(argv[(signed long int)0], "space");
          if(return_value_yaz_matchstr$25 == 0)
          {
            if(!(argc == 2))
            {
              yaz_log(0x00000001, "Syntax error in charmap for space");
              errors = errors + 1;
            }

            signed int return_value_scan_string$10;
            return_value_scan_string$10=scan_string(argv[(signed long int)1], t_unicode, t_utf8, fun_addspace, (void *)res, ((signed int *)NULL));
            if(!(return_value_scan_string$10 >= 0))
            {
              yaz_log(0x00000001, "Bad space specification");
              errors = errors + 1;
            }

          }

          else
          {
            return_value_yaz_matchstr$24=yaz_matchstr(argv[(signed long int)0], "cut");
            if(return_value_yaz_matchstr$24 == 0)
            {
              if(!(argc == 2))
              {
                yaz_log(0x00000001, "Syntax error in charmap for cut");
                errors = errors + 1;
              }

              signed int return_value_scan_string$11;
              return_value_scan_string$11=scan_string(argv[(signed long int)1], t_unicode, t_utf8, fun_addcut, (void *)res, ((signed int *)NULL));
              if(!(return_value_scan_string$11 >= 0))
              {
                yaz_log(0x00000001, "Bad cut specification");
                errors = errors + 1;
              }

            }

            else
            {
              return_value_yaz_matchstr$23=yaz_matchstr(argv[(signed long int)0], "map");
              if(return_value_yaz_matchstr$23 == 0)
              {
                struct chrwork buf;
                if(!(argc == 3))
                {
                  yaz_log(0x00000001, "charmap directive map requires 2 args");
                  errors = errors + 1;
                }

                buf.map = res;
                buf.string[(signed long int)0] = (char)0;
                signed int return_value_scan_string$12;
                return_value_scan_string$12=scan_string(argv[(signed long int)2], t_unicode, t_utf8, fun_mkstring, (void *)&buf, ((signed int *)NULL));
                if(!(return_value_scan_string$12 >= 0))
                {
                  yaz_log(0x00000001, "Bad map target");
                  errors = errors + 1;
                }

                signed int return_value_scan_string$13;
                return_value_scan_string$13=scan_string(argv[(signed long int)1], t_unicode, t_utf8, fun_add_map, (void *)&buf, ((signed int *)NULL));
                if(!(return_value_scan_string$13 >= 0))
                {
                  yaz_log(0x00000001, "Bad map source");
                  errors = errors + 1;
                }

              }

              else
              {
                return_value_yaz_matchstr$22=yaz_matchstr(argv[(signed long int)0], "equivalent");
                if(return_value_yaz_matchstr$22 == 0)
                {
                  struct anonymous$35 w;
                  if(!(argc == 2))
                  {
                    yaz_log(0x00000001, "equivalent requires 1 argument");
                    errors = errors + 1;
                  }

                  w.nmem = res->nmem;
                  w.no_eq = 0;
                  signed int return_value_scan_string$20;
                  return_value_scan_string$20=scan_string(argv[(signed long int)1], t_unicode, t_utf8, fun_add_equivalent_string, (void *)&w, ((signed int *)NULL));
                  if(!(return_value_scan_string$20 >= 0))
                  {
                    yaz_log(0x00000001, "equivalent: invalid string");
                    errors = errors + 1;
                  }

                  else
                    if(w.no_eq == 0)
                    {
                      yaz_log(0x00000001, "equivalent: no strings");
                      errors = errors + 1;
                    }

                    else
                    {
                      char *result_str;
                      signed int i;
                      signed int slen = 5;
                      i = 0;
                      for( ; !(i >= w.no_eq); i = i + 1)
                      {
                        return_value_strlen$14=strlen(w.eq[(signed long int)i]);
                        slen = slen + (signed int)(return_value_strlen$14 + (unsigned long int)1);
                      }
                      void *return_value_nmem_malloc$15;
                      return_value_nmem_malloc$15=nmem_malloc(res->nmem, (unsigned long int)(slen + 5));
                      result_str = (char *)return_value_nmem_malloc$15;
                      *result_str = (char)0;
                      slen = 0;
                      i = 0;
                      for( ; !(i >= w.no_eq); i = i + 1)
                      {
                        tmp_post$16 = slen;
                        slen = slen + 1;
                        result_str[(signed long int)tmp_post$16] = (char)(i != 0 ? 124 : 40);
                        strcpy(result_str + (signed long int)slen, w.eq[(signed long int)i]);
                        unsigned long int return_value_strlen$17;
                        return_value_strlen$17=strlen(w.eq[(signed long int)i]);
                        slen = slen + (signed int)return_value_strlen$17;
                      }
                      tmp_post$18 = slen;
                      slen = slen + 1;
                      result_str[(signed long int)tmp_post$18] = (char)41;
                      result_str[(signed long int)slen] = (char)0;
                      i = 0;
                      for( ; !(i >= w.no_eq); i = i + 1)
                      {
                        unsigned long int return_value_strlen$19;
                        return_value_strlen$19=strlen(w.eq[(signed long int)i]);
                        set_map_string(res->q_input, res->nmem, w.eq[(signed long int)i], (signed int)return_value_strlen$19, result_str, ((const char *)NULL));
                      }
                    }
                }

                else
                {
                  return_value_yaz_matchstr$21=yaz_matchstr(argv[(signed long int)0], "encoding");
                  if(return_value_yaz_matchstr$21 == 0)
                  {
                    if(!(t_unicode == ((struct yaz_iconv_struct *)NULL)))
                      yaz_iconv_close(t_unicode);

                    t_unicode=yaz_iconv_open(ucs4_native, argv[(signed long int)1]);
                  }

                  else
                  {
                    yaz_log(0x00000004, "Syntax error at '%s' in %s", (const void *)line, name);
                    errors = errors + 1;
                  }
                }
              }
            }
          }
        }
      }
    }
    yaz_fclose(f);
    if(no_directives == 0)
    {
      yaz_log(0x00000004, "No directives in '%s'", name);
      errors = errors + 1;
    }

    if(!(errors == 0))
    {
      chrmaptab_destroy(res);
      res = ((struct chrmaptab_info *)NULL);
    }

    yaz_log(0x00000002, "maptab %s num=%d close %d errors", name, num, errors);
    if(!(t_utf8 == ((struct yaz_iconv_struct *)NULL)))
      yaz_iconv_close(t_utf8);

    if(!(t_unicode == ((struct yaz_iconv_struct *)NULL)))
      yaz_iconv_close(t_unicode);

    return res;
  }
}

// chrmaptab_destroy
// file charmap.c line 748
void chrmaptab_destroy(struct chrmaptab_info *tab)
{
  if(!(tab == ((struct chrmaptab_info *)NULL)))
    nmem_destroy(tab->nmem);

}

// dump_xp_predicate
// file xpath.c line 216
void dump_xp_predicate(struct xpath_predicate *p)
{
  _Bool tmp_if_expr$1;
  if(!(p == ((struct xpath_predicate *)NULL)))
  {
    if(p->which == 1)
      tmp_if_expr$1 = p->u.relation.name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      fprintf(stderr, "%s,%s,%s", p->u.relation.name, p->u.relation.op, p->u.relation.value);

    else
    {
      fprintf(stderr, "(");
      dump_xp_predicate(p->u.boolean.left);
      fprintf(stderr, ") %s (", p->u.boolean.op);
      dump_xp_predicate(p->u.boolean.right);
      fprintf(stderr, ")");
    }
  }

}

// dump_xp_steps
// file xpath.c line 235
void dump_xp_steps(struct xpath_location_step *xpath, signed int no)
{
  signed int i = 0;
  for( ; !(i >= no); i = i + 1)
  {
    fprintf(stderr, "Step %d: %s   ", i, (xpath + (signed long int)i)->part);
    dump_xp_predicate((xpath + (signed long int)i)->predicate);
    fprintf(stderr, "\n");
  }
}

// find_entry_x
// file charmap.c line 141
static struct chr_t_entry * find_entry_x(struct chr_t_entry *t, const char **from, signed int *len, signed int first)
{
  struct chr_t_entry *res;
  for( ; !(*len >= 1); len = len + 1l)
  {
    if(!(*len >= 0))
      break;

    from = from + 1l;
  }
  _Bool tmp_if_expr$1;
  if(*len >= 1)
  {
    if(!(t->children == ((struct chr_t_entry **)NULL)))
    {
      const char *old_from = *from;
      signed int old_len = *len;
      res = ((struct chr_t_entry *)NULL);
      if(!(first == 0))
      {
        if(!(t->children[(signed long int)CHR_FIELD_BEGIN] == ((struct chr_t_entry *)NULL)))
        {
          res=find_entry_x(t->children[(signed long int)CHR_FIELD_BEGIN], from, len, 0);
          if(!(res == ((struct chr_t_entry *)NULL)))
            tmp_if_expr$1 = res != t->children[(signed long int)CHR_FIELD_BEGIN] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(tmp_if_expr$1)
            return res;

          else
            res = ((struct chr_t_entry *)NULL);
        }

      }

      if(res == ((struct chr_t_entry *)NULL))
      {
        if(!(t->children[(signed long int)(unsigned char)*(*from)] == ((struct chr_t_entry *)NULL)))
        {
          *len = *len - 1;
          *from = *from + 1l;
          res=find_entry_x(t->children[(signed long int)(unsigned char)*old_from], from, len, 0);
          if(!(res == ((struct chr_t_entry *)NULL)))
            return res;

          *len = old_len;
          *from = old_from;
        }

      }

    }

  }

  return t->target != ((unsigned char **)NULL) ? t : ((struct chr_t_entry *)NULL);
}

// fork_tst
// file tstflock.c line 216
void fork_tst(void)
{
  signed int pid[2l];
  signed int i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    pid[(signed long int)i]=fork();
    if(pid[(signed long int)i] == 0)
    {
      tst();
      exit(0);
    }

  }
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    signed int status;
    waitpid(pid[(signed long int)i], &status, 0);
    if(status == 0)
      yaz_check_print1(1, "tstflock.c", 235, "status == 0");

    else
      yaz_check_print1(2, "tstflock.c", 235, "status == 0");
  }
}

// fun_add_equivalent_string
// file charmap.c line 369
static void fun_add_equivalent_string(const char *s, void *data, signed int num)
{
  struct anonymous$35 *arg = (struct anonymous$35 *)data;
  signed int tmp_post$1;
  if(!(arg->no_eq == 32))
  {
    tmp_post$1 = arg->no_eq;
    arg->no_eq = arg->no_eq + 1;
    arg->eq[(signed long int)tmp_post$1]=nmem_strdup(arg->nmem, s);
  }

}

// fun_add_map
// file charmap.c line 381
static void fun_add_map(const char *s, void *data, signed int num)
{
  struct chrwork *arg = (struct chrwork *)data;
  /* assertion arg->map->input */
  assert(arg->map->input != ((struct chr_t_entry *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  yaz_log(0x00000002, "set map %.*s", (signed int)return_value_strlen$1, s);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(s);
  set_map_string(arg->map->input, arg->map->nmem, s, (signed int)return_value_strlen$2, arg->string, ((const char *)NULL));
  s = arg->string;
  for( ; !(*s == 0); s = s + 1l)
    yaz_log(0x00000002, " %3d", (unsigned char)*s);
}

// fun_addcut
// file charmap.c line 344
static void fun_addcut(const char *s, void *data, signed int num)
{
  struct chrmaptab_info *tab = (struct chrmaptab_info *)data;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  tab->input=set_map_string(tab->input, tab->nmem, s, (signed int)return_value_strlen$1, (char *)CHR_CUT, ((const char *)NULL));
}

// fun_addentry
// file charmap.c line 318
static void fun_addentry(const char *s, void *data, signed int num)
{
  struct chrmaptab_info *tab = (struct chrmaptab_info *)data;
  char tmp[2l];
  tmp[(signed long int)0] = (char)num;
  tmp[(signed long int)1] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  tab->input=set_map_string(tab->input, tab->nmem, s, (signed int)return_value_strlen$1, tmp, ((const char *)NULL));
  char *return_value_nmem_strdup$2;
  return_value_nmem_strdup$2=nmem_strdup(tab->nmem, s);
  tab->output[(signed long int)(num + tab->base_uppercase)] = (unsigned char *)return_value_nmem_strdup$2;
}

// fun_addspace
// file charmap.c line 333
static void fun_addspace(const char *s, void *data, signed int num)
{
  struct chrmaptab_info *tab = (struct chrmaptab_info *)data;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  tab->input=set_map_string(tab->input, tab->nmem, s, (signed int)return_value_strlen$1, (char *)CHR_SPACE, ((const char *)NULL));
}

// fun_mkstring
// file charmap.c line 354
static void fun_mkstring(const char *s, void *data, signed int num)
{
  struct chrwork *arg = (struct chrwork *)data;
  const char **res;
  const char *p = s;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  res=chr_map_input(arg->map, &s, (signed int)return_value_strlen$1, 0);
  if(*res == CHR_UNKNOWN)
    yaz_log(0x00000004, "Map: '%s' has no mapping", p);

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(arg->string);
  strncat(arg->string, *res, (unsigned long int)1024 - return_value_strlen$2);
  arg->string[(signed long int)1024] = (char)0;
}

// get_entry
// file passwddb.c line 59
static signed int get_entry(const char **p, char *dst, signed int max)
{
  signed int i = 0;
  for( ; !((signed int)(*p)[(signed long int)i] == 58); i = i + 1)
    if((*p)[(signed long int)i] == 0)
      break;

  if(i >= max)
    i = max - 1;

  if(!(i == 0))
    memcpy((void *)dst, (const void *)*p, (unsigned long int)i);

  dst[(signed long int)i] = (char)0;
  *p = *p + (signed long int)i;
  if(!(*p == ((const char *)NULL)))
    *p = *p + 1l;

  return i;
}

// get_xp_part
// file xpath.c line 31
static char * get_xp_part(char **strs, struct nmem_control *mem, signed int *literal)
{
  char *cp = *strs;
  char *str = ((char *)NULL);
  char *res = ((char *)NULL);
  *literal = 0;
  for( ; (signed int)*cp == 32; cp = cp + 1l)
    ;
  str = cp;
  char *return_value_strchr$6;
  return_value_strchr$6=strchr("()", (signed int)*cp);
  char *return_value_strchr$5;
  char *return_value_strchr$1;
  _Bool tmp_if_expr$4;
  char *return_value_strchr$3;
  if(!(return_value_strchr$6 == ((char *)NULL)))
    cp = cp + 1l;

  else
  {
    return_value_strchr$5=strchr("><=", (signed int)*cp);
    if(!(return_value_strchr$5 == ((char *)NULL)))
      do
      {
        return_value_strchr$1=strchr("><=", (signed int)*cp);
        if(return_value_strchr$1 == ((char *)NULL))
          break;

        cp = cp + 1l;
      }
      while((_Bool)1);

    else
    {
      if((signed int)*cp == 34)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)*cp == 39 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        signed int sep = (signed int)*cp;
        str = str + 1l;
        cp = cp + 1l;
        for( ; !(*cp == 0); cp = cp + 1l)
          if((signed int)*cp == sep)
            break;

        void *return_value_nmem_malloc$2;
        return_value_nmem_malloc$2=nmem_malloc(mem, (unsigned long int)((cp - str) + (signed long int)1));
        res = (char *)return_value_nmem_malloc$2;
        if(!(cp - str == 0l))
          memcpy((void *)res, (const void *)str, (unsigned long int)(cp - str));

        res[cp - str] = (char)0;
        if(!(*cp == 0))
          cp = cp + 1l;

        *literal = 1;
      }

      else
        for( ; !(*cp == 0); cp = cp + 1l)
        {
          return_value_strchr$3=strchr("><=()]\" ", (signed int)*cp);
          if(!(return_value_strchr$3 == ((char *)NULL)))
            break;

        }
    }
  }
  if(res == ((char *)NULL))
  {
    void *return_value_nmem_malloc$7;
    return_value_nmem_malloc$7=nmem_malloc(mem, (unsigned long int)((cp - str) + (signed long int)1));
    res = (char *)return_value_nmem_malloc$7;
    if(!(cp - str == 0l))
      memcpy((void *)res, (const void *)str, (unsigned long int)(cp - str));

    res[cp - str] = (char)0;
  }

  *strs = cp;
  return res;
}

// get_xpath_boolean
// file xpath.c line 121
static struct xpath_predicate * get_xpath_boolean(char **pr, struct nmem_control *mem, char **look, signed int *literal)
{
  struct xpath_predicate *left = ((struct xpath_predicate *)NULL);
  left=get_xpath_relation(pr, mem, look, literal);
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$3;
  if(left == ((struct xpath_predicate *)NULL))
    return ((struct xpath_predicate *)NULL);

  else
  {
    while(!(*look == ((char *)NULL)))
    {
      if(!(*literal == 0))
        break;

      return_value_strcmp$1=strcmp(*look, "and");
      if(!(return_value_strcmp$1 == 0))
      {
        return_value_strcmp$2=strcmp(*look, "or");
        if(!(return_value_strcmp$2 == 0))
        {
          return_value_strcmp$3=strcmp(*look, "not");
          if(!(return_value_strcmp$3 == 0))
            break;

        }

      }

      struct xpath_predicate *res;
      struct xpath_predicate *right;
      void *return_value_nmem_malloc$4;
      return_value_nmem_malloc$4=nmem_malloc(mem, sizeof(struct xpath_predicate) /*32ul*/ );
      res = (struct xpath_predicate *)return_value_nmem_malloc$4;
      res->which = 2;
      res->u.boolean.op = *look;
      res->u.boolean.left = left;
      *look=get_xp_part(pr, mem, literal);
      right=get_xpath_relation(pr, mem, look, literal);
      res->u.boolean.right = right;
      left = res;
    }
    return left;
  }
}

// get_xpath_predicate
// file xpath.c line 151
static struct xpath_predicate * get_xpath_predicate(char *predicate, struct nmem_control *mem)
{
  signed int literal;
  char **pr = &predicate;
  char *look;
  look=get_xp_part(pr, mem, &literal);
  if(look == ((char *)NULL))
    return ((struct xpath_predicate *)NULL);

  else
  {
    struct xpath_predicate *return_value_get_xpath_boolean$1;
    return_value_get_xpath_boolean$1=get_xpath_boolean(pr, mem, &look, &literal);
    return return_value_get_xpath_boolean$1;
  }
}

// get_xpath_relation
// file xpath.c line 82
static struct xpath_predicate * get_xpath_relation(char **pr, struct nmem_control *mem, char **look, signed int *literal)
{
  struct xpath_predicate *res = ((struct xpath_predicate *)NULL);
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$6;
  if(*literal == 0)
  {
    return_value_strcmp$6=strcmp(*look, "(");
    tmp_if_expr$7 = !(return_value_strcmp$6 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  char *return_value_strchr$4;
  if(tmp_if_expr$7)
  {
    *look=get_xp_part(pr, mem, literal);
    res=get_xpath_boolean(pr, mem, look, literal);
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(*look, ")");
    if(return_value_strcmp$1 == 0)
      *look=get_xp_part(pr, mem, literal);

    else
      res = ((struct xpath_predicate *)NULL);
  }

  else
  {
    void *return_value_nmem_malloc$2;
    return_value_nmem_malloc$2=nmem_malloc(mem, sizeof(struct xpath_predicate) /*32ul*/ );
    res = (struct xpath_predicate *)return_value_nmem_malloc$2;
    res->which = 1;
    res->u.relation.name = *look;
    *look=get_xp_part(pr, mem, literal);
    if(!(*look == ((char *)NULL)))
      tmp_if_expr$3 = !(*literal != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_strchr$4=strchr("><=", (signed int)*(*look));
      tmp_if_expr$5 = return_value_strchr$4 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
    {
      res->u.relation.op = *look;
      *look=get_xp_part(pr, mem, literal);
      if(*look == ((char *)NULL))
        return ((struct xpath_predicate *)NULL);

      res->u.relation.value = *look;
      *look=get_xp_part(pr, mem, literal);
    }

    else
    {
      res->u.relation.op = "";
      res->u.relation.value = "";
    }
  }
  return res;
}

// hash
// file strmap.c line 70
static struct strmap_entry ** hash(struct zebra_strmap *st, const char *name)
{
  unsigned int hash$$1$$hash = (unsigned int)0;
  signed int i = 0;
  for( ; !(name[(signed long int)i] == 0); i = i + 1)
    hash$$1$$hash = hash$$1$$hash + hash$$1$$hash * (unsigned int)65519 + (unsigned int)name[(signed long int)i];
  hash$$1$$hash = hash$$1$$hash % (unsigned int)st->hsize;
  return st->entries + (signed long int)hash$$1$$hash;
}

// iscz1_decode
// file it_key.c line 237
void iscz1_decode(void *vp, char **dst, const char **src)
{
  struct iscz1_code_info *p = (struct iscz1_code_info *)vp;
  signed int i;
  signed int leader;
  signed long long int return_value_iscz1_decode_int$1;
  return_value_iscz1_decode_int$1=iscz1_decode_int((unsigned char **)src);
  leader = (signed int)return_value_iscz1_decode_int$1;
  i = leader & 7;
  signed long long int return_value_iscz1_decode_int$2;
  if(!((64 & leader) == 0))
  {
    return_value_iscz1_decode_int$2=iscz1_decode_int((unsigned char **)src);
    p->key.mem[(signed long int)i] = p->key.mem[(signed long int)i] + return_value_iscz1_decode_int$2;
  }

  else
    p->key.mem[(signed long int)i]=iscz1_decode_int((unsigned char **)src);
  p->key.len = leader >> 3 & 7;
  do
  {
    i = i + 1;
    if(i >= p->key.len)
      break;

    p->key.mem[(signed long int)i]=iscz1_decode_int((unsigned char **)src);
  }
  while((_Bool)1);
  memcpy((void *)*dst, (const void *)&p->key, sizeof(struct it_key) /*48ul*/ );
  *dst = *dst + (signed long int)sizeof(struct it_key) /*48ul*/ ;
}

// iscz1_decode_int
// file it_key.c line 174
static inline signed long long int iscz1_decode_int(unsigned char **src)
{
  signed long long int d = (signed long long int)0;
  unsigned char c;
  unsigned int r = (unsigned int)0;
  unsigned char *tmp_post$1;
  do
  {
    tmp_post$1 = *src;
    *src = *src + 1l;
    c = *tmp_post$1;
    if((128 & (signed int)c) == 0)
      break;

    d = d + ((signed long long int)((signed int)c & 127) << r);
    r = r + (unsigned int)7;
  }
  while((_Bool)1);
  d = d + ((signed long long int)c << r);
  return d;
}

// iscz1_encode
// file it_key.c line 189
void iscz1_encode(void *vp, char **dst, const char **src)
{
  struct iscz1_code_info *p = (struct iscz1_code_info *)vp;
  struct it_key tkey;
  signed long long int d;
  signed int i;
  memcpy((void *)&tkey, (const void *)*src, sizeof(struct it_key) /*48ul*/ );
  d = (signed long long int)0;
  /* assertion tkey.len > 0 && tkey.len <= 5 */
  assert(tkey.len > 0 && tkey.len <= 5);
  i = 0;
  for( ; !(i >= tkey.len); i = i + 1)
  {
    d = tkey.mem[(signed long int)i] - p->key.mem[(signed long int)i];
    if(i == tkey.len + -1 || !(d == 0ll))
    {
      p->key.mem[(signed long int)i] = tkey.mem[(signed long int)i];
      if(d >= 1l)
      {
        iscz1_encode_int((signed long long int)(i + (tkey.len << 3) + 64), dst);
        i = i + 1;
        iscz1_encode_int(d, dst);
      }

      else
        iscz1_encode_int((signed long long int)(i + (tkey.len << 3)), dst);
      break;
    }

  }
  for( ; !(i >= tkey.len); i = i + 1)
  {
    iscz1_encode_int(tkey.mem[(signed long int)i], dst);
    p->key.mem[(signed long int)i] = tkey.mem[(signed long int)i];
  }
  *src = *src + (signed long int)sizeof(struct it_key) /*48ul*/ ;
}

// iscz1_encode_int
// file it_key.c line 160
static inline void iscz1_encode_int(signed long long int d, char **dst)
{
  unsigned char *bp = (unsigned char *)*dst;
  unsigned char *tmp_post$1;
  for( ; d >= 128l; d = d >> 7)
  {
    tmp_post$1 = bp;
    bp = bp + 1l;
    *tmp_post$1 = (unsigned char)(unsigned int)((signed long int)128 | d & (signed long int)127);
  }
  unsigned char *tmp_post$2 = bp;
  bp = bp + 1l;
  *tmp_post$2 = (unsigned char)(unsigned int)d;
  *dst = (char *)bp;
}

// iscz1_reset
// file it_key.c line 145
void iscz1_reset(void *vp)
{
  struct iscz1_code_info *p = (struct iscz1_code_info *)vp;
  signed int i;
  p->key.len = 0;
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    p->key.mem[(signed long int)i] = (signed long long int)0;
}

// iscz1_start
// file it_key.c line 129
void * iscz1_start(void)
{
  struct iscz1_code_info *p;
  void *return_value_xmalloc_f$1;
  return_value_xmalloc_f$1=xmalloc_f(sizeof(struct iscz1_code_info) /*48ul*/ , "it_key.c", 132);
  p = (struct iscz1_code_info *)return_value_xmalloc_f$1;
  iscz1_reset((void *)p);
  return (void *)p;
}

// iscz1_stop
// file it_key.c line 154
void iscz1_stop(void *p)
{
  xfree_f(p, "it_key.c", 156);
}

// key_SU_decode
// file su_codec.c line 64
signed int key_SU_decode(signed int *ch, const unsigned char *out)
{
  signed int len = 1;
  signed int fact = 1;
  *ch = 0;
  len = 1;
  for( ; (signed int)*out >= 65; out = out + 1l)
  {
    *ch = *ch + ((signed int)*out - 65) * fact;
    fact = fact << 6;
    len = len + 1;
  }
  *ch = *ch + ((signed int)*out - 1) * fact;
  return len;
}

// key_SU_encode
// file su_codec.c line 31
signed int key_SU_encode(signed int ch, char *out)
{
  signed int i;
  if(ch == -1)
  {
    out[(signed long int)0] = (char)129;
    return 1;
  }

  else
  {
    i = 0;
    for( ; !(ch == 0); i = i + 1)
    {
      if(ch >= 64)
        out[(signed long int)i] = (char)(65 + (ch & 63));

      else
        out[(signed long int)i] = (char)(1 + ch);
      ch = ch >> 6;
    }
    return i;
  }
}

// key_compare
// file it_key.c line 73
signed int key_compare(const void *p1, const void *p2)
{
  struct it_key i1;
  struct it_key i2;
  signed int i;
  signed int l;
  memcpy((void *)&i1, p1, sizeof(struct it_key) /*48ul*/ );
  memcpy((void *)&i2, p2, sizeof(struct it_key) /*48ul*/ );
  l = i1.len;
  if(!(l >= i2.len))
    l = i2.len;

  /* assertion l <= 5 && l > 0 */
  assert(l <= 5 && l > 0);
  i = 0;
  for( ; !(i >= l); i = i + 1)
    if(!(i1.mem[(signed long int)i] == i2.mem[(signed long int)i]))
    {
      if(!(i2.mem[(signed long int)i] >= i1.mem[(signed long int)i]))
        return l - i;

      else
        return i - l;
    }

  return 0;
}

// key_get_segment
// file it_key.c line 103
signed long long int key_get_segment(const void *p)
{
  struct it_key k;
  memcpy((void *)&k, p, sizeof(struct it_key) /*48ul*/ );
  return k.mem[(signed long int)(k.len - 2)];
}

// key_get_seq
// file it_key.c line 96
signed long long int key_get_seq(const void *p)
{
  struct it_key k;
  memcpy((void *)&k, p, sizeof(struct it_key) /*48ul*/ );
  return k.mem[(signed long int)(k.len - 1)];
}

// key_init
// file it_key.c line 137
void key_init(struct it_key *key)
{
  signed int i;
  key->len = 0;
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    key->mem[(signed long int)i] = (signed long long int)0;
}

// key_logdump
// file it_key.c line 62
void key_logdump(signed int logmask, const void *p)
{
  key_logdump_txt(logmask, p, "");
}

// key_logdump_txt
// file it_key.c line 37
void key_logdump_txt(signed int logmask, const void *p, const char *txt)
{
  struct it_key key;
  if(txt == ((const char *)NULL))
    txt = "(none)";

  if(!(p == NULL))
  {
    char formstr[128l];
    signed int i;
    memcpy((void *)&key, p, sizeof(struct it_key) /*48ul*/ );
    /* assertion key.len > 0 && key.len <= 5 */
    assert(key.len > 0 && key.len <= 5);
    formstr[0l] = (char)0;
    i = 0;
    for( ; !(i >= key.len); i = i + 1)
    {
      if(!(i == 0))
        strcat(formstr, ".");

      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(formstr);
      sprintf(formstr + (signed long int)return_value_strlen$1, "%lld", key.mem[(signed long int)i]);
    }
    yaz_log(logmask, "%s %s", (const void *)formstr, txt);
  }

  else
    yaz_log(logmask, " (no key) %s", txt);
}

// key_print_it
// file it_key.c line 67
char * key_print_it(const void *p, char *buf)
{
  strcpy(buf, "");
  return buf;
}

// key_qsort_compare
// file it_key.c line 110
signed int key_qsort_compare(const void *p1, const void *p2)
{
  signed int r;
  unsigned long int l;
  char *cp1 = *((char **)p1);
  char *cp2 = *((char **)p2);
  r=strcmp(cp1, cp2);
  if(!(r == 0))
    return r;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(cp1);
    l = return_value_strlen$1 + (unsigned long int)1;
    r=key_compare((const void *)(cp1 + (signed long int)l + (signed long int)1), (const void *)(cp2 + (signed long int)l + (signed long int)1));
    if(!(r == 0))
      return r;

    else
      return (signed int)cp1[(signed long int)l] - (signed int)cp2[(signed long int)l];
  }
}

// main
// file tstflock.c line 242
signed int main(signed int argc, char **argv)
{
  yaz_check_init1(&argc, &argv);
  yaz_check_init_log(argv[(signed long int)0]);
  signed int return_value_yaz_log_mask_str$1;
  return_value_yaz_log_mask_str$1=yaz_log_mask_str("flock");
  yaz_log_init_level(return_value_yaz_log_mask_str$1);
  zebra_flock_init();
  test_fd=open("tstflock.out", 0 | 0100 | 02, 0666);
  if(!(test_fd == -1))
    yaz_check_print1(1, "tstflock.c", 253, "test_fd != -1");

  else
    yaz_check_print1(2, "tstflock.c", 253, "test_fd != -1");
  if(!(test_fd == -1))
    fork_tst();

  yaz_check_term1();
  return 0;
}

// parse_command
// file zebramap.c line 140
static signed int parse_command(struct zebra_maps_s *zms, signed int argc, char **argv, const char *fname, signed int lineno)
{
  struct zebra_map *zm = zms->last_map;
  signed int return_value_yaz_matchstr$12;
  signed int return_value_yaz_matchstr$11;
  signed int return_value_yaz_matchstr$10;
  signed int return_value_yaz_matchstr$9;
  signed int return_value_yaz_matchstr$8;
  signed int return_value_yaz_matchstr$7;
  signed int return_value_yaz_matchstr$6;
  signed int return_value_yaz_matchstr$5;
  signed int return_value_yaz_matchstr$4;
  signed int return_value_yaz_matchstr$3;
  signed int return_value_yaz_matchstr$2;
  if(argc == 1)
  {
    yaz_log(0x00000004, "%s:%d: Missing arguments for '%s'", fname, lineno, argv[(signed long int)0]);
    return -1;
  }

  else
    if(argc >= 3)
    {
      yaz_log(0x00000004, "%s:%d: Too many arguments for '%s'", fname, lineno, argv[(signed long int)0]);
      return -1;
    }

    else
    {
      signed int return_value_yaz_matchstr$13;
      return_value_yaz_matchstr$13=yaz_matchstr(argv[(signed long int)0], "index");
      if(return_value_yaz_matchstr$13 == 0)
      {
        zm=zebra_add_map(zms, argv[(signed long int)1], 2);
        zm->positioned = 1;
      }

      else
      {
        return_value_yaz_matchstr$12=yaz_matchstr(argv[(signed long int)0], "sort");
        if(return_value_yaz_matchstr$12 == 0)
        {
          zm=zebra_add_map(zms, argv[(signed long int)1], 1);
          zm->u.sort.entry_size = 80;
        }

        else
        {
          return_value_yaz_matchstr$11=yaz_matchstr(argv[(signed long int)0], "staticrank");
          if(return_value_yaz_matchstr$11 == 0)
          {
            zm=zebra_add_map(zms, argv[(signed long int)1], 3);
            zm->completeness = 1;
          }

          else
            if(zm == ((struct zebra_map *)NULL))
            {
              yaz_log(0x00000004, "%s:%d: Missing sort/index before '%s'", fname, lineno, argv[(signed long int)0]);
              return -1;
            }

            else
            {
              return_value_yaz_matchstr$10=yaz_matchstr(argv[(signed long int)0], "charmap");
              if(return_value_yaz_matchstr$10 == 0 && argc == 2)
              {
                if(!(zm->type == 3))
                  zm->maptab_name=nmem_strdup(zms->nmem, argv[(signed long int)1]);

                else
                {
                  yaz_log(0x00000004 | 0x00000001, "%s:%d: charmap for staticrank is invalid", fname, lineno);
                  yaz_log(0x00000008, "Type is %d", zm->type);
                  return -1;
                }
              }

              else
              {
                return_value_yaz_matchstr$9=yaz_matchstr(argv[(signed long int)0], "completeness");
                if(return_value_yaz_matchstr$9 == 0 && argc == 2)
                  zm->completeness=atoi(argv[(signed long int)1]);

                else
                {
                  return_value_yaz_matchstr$8=yaz_matchstr(argv[(signed long int)0], "position");
                  if(return_value_yaz_matchstr$8 == 0 && argc == 2)
                    zm->positioned=atoi(argv[(signed long int)1]);

                  else
                  {
                    return_value_yaz_matchstr$7=yaz_matchstr(argv[(signed long int)0], "alwaysmatches");
                    if(return_value_yaz_matchstr$7 == 0 && argc == 2)
                    {
                      if(!(zm->type == 3))
                        zm->alwaysmatches=atoi(argv[(signed long int)1]);

                      else
                      {
                        yaz_log(0x00000004 | 0x00000001, "%s:%d: alwaysmatches for staticrank is invalid", fname, lineno);
                        return -1;
                      }
                    }

                    else
                    {
                      return_value_yaz_matchstr$6=yaz_matchstr(argv[(signed long int)0], "firstinfield");
                      if(return_value_yaz_matchstr$6 == 0 && argc == 2)
                        zm->first_in_field=atoi(argv[(signed long int)1]);

                      else
                      {
                        return_value_yaz_matchstr$5=yaz_matchstr(argv[(signed long int)0], "entrysize");
                        if(return_value_yaz_matchstr$5 == 0 && argc == 2)
                        {
                          if(zm->type == 1)
                            zm->u.sort.entry_size=atoi(argv[(signed long int)1]);

                          else
                          {
                            yaz_log(0x00000004, "%s:%d: entrysize only valid in sort section", fname, lineno);
                            return -1;
                          }
                        }

                        else
                        {
                          return_value_yaz_matchstr$4=yaz_matchstr(argv[(signed long int)0], "simplechain");
                          if(return_value_yaz_matchstr$4 == 0)
                          {
                            zm->use_chain = 1;
                            zm->icu_chain = ((struct icu_chain *)NULL);
                          }

                          else
                          {
                            return_value_yaz_matchstr$3=yaz_matchstr(argv[(signed long int)0], "icuchain");
                            if(return_value_yaz_matchstr$3 == 0)
                            {
                              char full_path[1024l];
                              char *return_value_yaz_filepath_resolve$1;
                              return_value_yaz_filepath_resolve$1=yaz_filepath_resolve(argv[(signed long int)1], zms->tabpath, zms->tabroot, full_path);
                              if(return_value_yaz_filepath_resolve$1 == ((char *)NULL))
                              {
                                yaz_log(0x00000004, "%s:%d: Could not locate icuchain config '%s'", fname, lineno, argv[(signed long int)1]);
                                return -1;
                              }

                              zm->doc=xmlParseFile(full_path);
                              if(zm->doc == ((struct _xmlDoc *)NULL))
                              {
                                yaz_log(0x00000004, "%s:%d: Could not load icuchain config '%s'", fname, lineno, argv[(signed long int)1]);
                                return -1;
                              }

                              else
                              {
                                enum UErrorCode status;
                                struct _xmlNode *xml_node;
                                xml_node=xmlDocGetRootElement(zm->doc);
                                zm->icu_chain=icu_chain_xml_config(xml_node, 1, &status);
                                if(zm->icu_chain == ((struct icu_chain *)NULL))
                                  yaz_log(0x00000004, "%s:%d: Failed to load ICU chain %s", fname, lineno, argv[(signed long int)1]);

                                zm->use_chain = 1;
                              }
                            }

                            else
                            {
                              return_value_yaz_matchstr$2=yaz_matchstr(argv[(signed long int)0], "debug");
                              if(return_value_yaz_matchstr$2 == 0 && argc == 2)
                                zm->debug=atoi(argv[(signed long int)1]);

                              else
                              {
                                yaz_log(0x00000004, "%s:%d: Unrecognized directive '%s'", fname, lineno, argv[(signed long int)0]);
                                return -1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
        }
      }
      return 0;
    }
}

// passwd_db_auth
// file passwddb.c line 128
signed int passwd_db_auth(struct passwd_db *db, const char *user, const char *pass)
{
  struct passwd_entry *pe;
  /* assertion db */
  assert(db != ((struct passwd_db *)NULL));
  pe = db->entries;
  signed int return_value_strcmp$1;
  for( ; !(pe == ((struct passwd_entry *)NULL)); pe = pe->next)
    if(!(user == ((const char *)NULL)))
    {
      return_value_strcmp$1=strcmp(user, pe->name);
      if(return_value_strcmp$1 == 0)
        break;

    }

  if(pe == ((struct passwd_entry *)NULL))
    return -1;

  else
    if(pass == ((const char *)NULL))
      return -2;

    else
    {
      if(!(pe->encrypt_flag == 0))
      {
        const char *des_try;
        /* assertion pe->des */
        assert(pe->des != ((char *)NULL));
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(pe->des);
        if(!(return_value_strlen$2 >= 3ul))
          return -3;

        if(!((signed int)*pe->des == 36))
        {
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(pass);
          if(return_value_strlen$3 >= 9ul)
            return -2;

        }

        des_try=crypt(pass, pe->des);
        /* assertion des_try */
        assert(des_try != ((const char *)NULL));
        signed int return_value_strcmp$4;
        return_value_strcmp$4=strcmp(des_try, pe->des);
        if(!(return_value_strcmp$4 == 0))
          return -2;

      }

      else
      {
        /* assertion pass */
        assert(pass != ((const char *)NULL));
        /* assertion pe->des */
        assert(pe->des != ((char *)NULL));
        signed int return_value_strcmp$5;
        return_value_strcmp$5=strcmp(pe->des, pass);
        if(!(return_value_strcmp$5 == 0))
          return -2;

      }
      return 0;
    }
}

// passwd_db_close
// file passwddb.c line 106
void passwd_db_close(struct passwd_db *db)
{
  struct passwd_entry *pe = db->entries;
  while(!(pe == ((struct passwd_entry *)NULL)))
  {
    struct passwd_entry *pe_next = pe->next;
    xfree_f((void *)pe->name, "passwddb.c", 113);
    xfree_f((void *)pe->des, "passwddb.c", 114);
    xfree_f((void *)pe, "passwddb.c", 115);
    pe = pe_next;
  }
  xfree_f((void *)db, "passwddb.c", 118);
}

// passwd_db_file_crypt
// file passwddb.c line 172
signed int passwd_db_file_crypt(struct passwd_db *db, const char *fname)
{
  signed int return_value_passwd_db_file_int$1;
  return_value_passwd_db_file_int$1=passwd_db_file_int(db, fname, 1);
  return return_value_passwd_db_file_int$1;
}

// passwd_db_file_int
// file passwddb.c line 75
static signed int passwd_db_file_int(struct passwd_db *db, const char *fname, signed int encrypt_flag)
{
  struct _IO_FILE *f;
  char buf[1024l];
  f=fopen(fname, "r");
  char *return_value_fgets$1;
  if(f == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    do
    {
      return_value_fgets$1=fgets(buf, (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1), f);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      struct passwd_entry *pe;
      char name[128l];
      char des[128l];
      char *p;
      const char *cp = buf;
      p=strchr(buf, 10);
      if(!(p == ((char *)NULL)))
        *p = (char)0;

      get_entry(&cp, name, 128);
      get_entry(&cp, des, 128);
      void *return_value_xmalloc_f$2;
      return_value_xmalloc_f$2=xmalloc_f(sizeof(struct passwd_entry) /*32ul*/ , "passwddb.c", 95);
      pe = (struct passwd_entry *)return_value_xmalloc_f$2;
      pe->name=xstrdup_f(name, "passwddb.c", 96);
      pe->des=xstrdup_f(des, "passwddb.c", 97);
      pe->encrypt_flag = encrypt_flag;
      pe->next = db->entries;
      db->entries = pe;
    }
    while((_Bool)1);
    fclose(f);
    return 0;
  }
}

// passwd_db_file_plain
// file passwddb.c line 181
signed int passwd_db_file_plain(struct passwd_db *db, const char *fname)
{
  signed int return_value_passwd_db_file_int$1;
  return_value_passwd_db_file_int$1=passwd_db_file_int(db, fname, 0);
  return return_value_passwd_db_file_int$1;
}

// passwd_db_open
// file passwddb.c line 52
struct passwd_db * passwd_db_open(void)
{
  struct passwd_db *p;
  void *return_value_xmalloc_f$1;
  return_value_xmalloc_f$1=xmalloc_f(sizeof(struct passwd_db) /*8ul*/ , "passwddb.c", 54);
  p = (struct passwd_db *)return_value_xmalloc_f$1;
  p->entries = ((struct passwd_entry *)NULL);
  return p;
}

// passwd_db_show
// file passwddb.c line 121
void passwd_db_show(struct passwd_db *db)
{
  struct passwd_entry *pe = db->entries;
  for( ; !(pe == ((struct passwd_entry *)NULL)); pe = pe->next)
    yaz_log(0x00000008, "%s:%s", pe->name, pe->des);
}

// res_add
// file res.c line 445
void res_add(struct res_struct *r, const char *name, const char *value)
{
  struct res_entry *re;
  /* assertion r */
  assert(r != ((struct res_struct *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion value */
  assert(value != ((const char *)NULL));
  yaz_log(0, "res_add res=%p, name=%s, value=%s", r, name, value);
  re=add_entry(r);
  re->name=xstrdup_f(name, "res.c", 453);
  re->value=xstrdup_env(value);
}

// res_check
// file res.c line 479
signed int res_check(struct res_struct *r_i, struct res_struct *r_v)
{
  struct res_entry *e_i;
  signed int errors = 0;
  e_i = r_i->first;
  for( ; !(e_i == ((struct res_entry *)NULL)); e_i = e_i->next)
  {
    struct res_entry *e_v = r_v->first;
    for( ; !(e_v == ((struct res_entry *)NULL)); e_v = e_v->next)
    {
      signed int prefix_allowed = 0;
      signed int suffix_allowed = 0;
      const char *name = e_i->name;
      unsigned long int name_len;
      name_len=strlen(e_i->name);
      char namez[32l];
      const char *first_dot = ((const char *)NULL);
      const char *second_dot = ((const char *)NULL);
      char *return_value_strchr$1;
      return_value_strchr$1=strchr(e_v->value, 112);
      if(!(return_value_strchr$1 == ((char *)NULL)))
        prefix_allowed = 1;

      char *return_value_strchr$2;
      return_value_strchr$2=strchr(e_v->value, 115);
      if(!(return_value_strchr$2 == ((char *)NULL)))
        suffix_allowed = 1;

      first_dot=strchr(name, 46);
      if(!(first_dot == ((const char *)NULL)) && !(prefix_allowed == 0))
      {
        name = first_dot + (signed long int)1;
        name_len=strlen(name);
      }

      second_dot=strchr(name, 46);
      if(!(second_dot == ((const char *)NULL)) && !(suffix_allowed == 0))
        name_len = (unsigned long int)(second_dot - name);

      if(!(name_len >= 31ul))
      {
        memcpy((void *)namez, (const void *)name, name_len);
        namez[(signed long int)name_len] = (char)0;
        signed int return_value_yaz_matchstr$3;
        return_value_yaz_matchstr$3=yaz_matchstr(namez, e_v->name);
        if(return_value_yaz_matchstr$3 == 0)
          break;

      }

      if(second_dot == ((const char *)NULL) && !(first_dot == ((const char *)NULL)) && !(prefix_allowed == 0) && !(suffix_allowed == 0))
      {
        name = e_i->name;
        name_len = (unsigned long int)(first_dot - name);
        if(!(name_len >= 31ul))
        {
          memcpy((void *)namez, (const void *)name, name_len);
          namez[(signed long int)name_len] = (char)0;
          signed int return_value_yaz_matchstr$4;
          return_value_yaz_matchstr$4=yaz_matchstr(namez, e_v->name);
          if(return_value_yaz_matchstr$4 == 0)
            break;

        }

      }

    }
    if(e_v == ((struct res_entry *)NULL))
    {
      yaz_log(0x00000004, "The following setting is unrecognized: %s", e_i->name);
      errors = errors + 1;
    }

  }
  return errors;
}

// res_clear
// file res.c line 246
void res_clear(struct res_struct *r)
{
  struct res_entry *re;
  struct res_entry *re1;
  re = r->first;
  for( ; !(re == ((struct res_entry *)NULL)); re = re1)
  {
    if(!(re->name == ((char *)NULL)))
      xfree_f((void *)re->name, "res.c", 252);

    if(!(re->value == ((char *)NULL)))
      xfree_f((void *)re->value, "res.c", 254);

    re1 = re->next;
    xfree_f((void *)re, "res.c", 256);
  }
  r->last = (struct res_entry *)(void *)0;
  r->first = r->last;
}

// res_close
// file res.c line 261
void res_close(struct res_struct *r)
{
  if(!(r == ((struct res_struct *)NULL)))
  {
    r->ref_count = r->ref_count - 1;
    if(r->ref_count == 0)
    {
      res_clear(r);
      res_close(r->def_res);
      res_close(r->over_res);
      xfree_f((void *)r, "res.c", 268);
    }

  }

}

// res_dump
// file res.c line 457
void res_dump(struct res_struct *r, signed int level)
{
  struct res_entry *re;
  if(!(r == ((struct res_struct *)NULL)))
  {
    re = r->first;
    for( ; !(re == ((struct res_entry *)NULL)); re = re->next)
      printf("%*s - %s:='%s'\n", level * 4, (const void *)"", re->name, re->value);
    if(!(r->def_res == ((struct res_struct *)NULL)))
    {
      printf("%*s DEF ", level * 4, (const void *)"");
      res_dump(r->def_res, level + 1);
    }

    if(!(r->over_res == ((struct res_struct *)NULL)))
    {
      printf("%*s OVER ", level * 4, (const void *)"");
      res_dump(r->over_res, level + 1);
    }

  }

}

// res_get
// file res.c line 294
const char * res_get(struct res_struct *r, const char *name)
{
  struct res_entry *re;
  const char *v;
  signed int return_value_yaz_matchstr$1;
  if(r == ((struct res_struct *)NULL))
    return ((const char *)NULL);

  else
  {
    v=res_get(r->over_res, name);
    if(!(v == ((const char *)NULL)))
      return v;

    else
    {
      re = r->first;
      for( ; !(re == ((struct res_entry *)NULL)); re = re->next)
        if(!(re->value == ((char *)NULL)))
        {
          return_value_yaz_matchstr$1=yaz_matchstr(re->name, name);
          if(return_value_yaz_matchstr$1 == 0)
            return re->value;

        }

      const char *return_value_res_get$2;
      return_value_res_get$2=res_get(r->def_res, name);
      return return_value_res_get$2;
    }
  }
}

// res_get_def
// file res.c line 313
const char * res_get_def(struct res_struct *r, const char *name, const char *def)
{
  const char *t;
  t=res_get(r, name);
  if(t == ((const char *)NULL))
  {
    if(!(def == ((const char *)NULL)))
      yaz_log(0x00000002, "Using default resource %s:%s", name, def);

    return def;
  }

  else
    return t;
}

// res_get_int
// file res.c line 432
signed short int res_get_int(struct res_struct *r, const char *name, signed int *val)
{
  const char *cp;
  cp=res_get(r, name);
  if(!(cp == ((const char *)NULL)))
  {
    signed int return_value_sscanf$1;
    return_value_sscanf$1=sscanf(cp, "%d", val);
    if(return_value_sscanf$1 == 1)
      return (signed short int)0;

    yaz_log(0x00000004, "Expected integer for resource %s", name);
  }

  return (signed short int)-1;
}

// res_get_match
// file res.c line 327
signed int res_get_match(struct res_struct *r, const char *name, const char *value, const char *s)
{
  const char *cn;
  cn=res_get(r, name);
  if(cn == ((const char *)NULL))
    cn = s;

  signed int return_value_yaz_matchstr$1;
  if(!(cn == ((const char *)NULL)))
  {
    return_value_yaz_matchstr$1=yaz_matchstr(cn, value);
    if(!(return_value_yaz_matchstr$1 == 0))
      goto __CPROVER_DUMP_L2;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return 0;
  }
}

// res_get_prefix
// file res.c line 272
const char * res_get_prefix(struct res_struct *r, const char *name, const char *prefix, const char *def)
{
  const char *v = ((const char *)NULL);
  if(!(prefix == ((const char *)NULL)))
  {
    char rname[128l];
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(name);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(prefix);
    if(return_value_strlen$1 + return_value_strlen$2 >= 126ul)
      return ((const char *)NULL);

    strcpy(rname, prefix);
    strcat(rname, ".");
    strcat(rname, name);
    v=res_get(r, rname);
  }

  if(v == ((const char *)NULL))
    v=res_get(r, name);

  if(v == ((const char *)NULL))
    v = def;

  return v;
}

// res_incref
// file res.c line 53
static struct res_struct * res_incref(struct res_struct *r)
{
  if(!(r == ((struct res_struct *)NULL)))
    r->ref_count = r->ref_count + 1;

  return r;
}

// res_open
// file res.c line 234
struct res_struct * res_open(struct res_struct *def_res, struct res_struct *over_res)
{
  struct res_struct *r;
  void *return_value_xmalloc_f$1;
  return_value_xmalloc_f$1=xmalloc_f(sizeof(struct res_struct) /*40ul*/ , "res.c", 237);
  r = (struct res_struct *)return_value_xmalloc_f$1;
  r->ref_count = 1;
  r->last = (struct res_entry *)(void *)0;
  r->first = r->last;
  r->def_res=res_incref(def_res);
  r->over_res=res_incref(over_res);
  return r;
}

// res_read_file
// file res.c line 146
signed short int res_read_file(struct res_struct *r, const char *fname)
{
  struct _IO_FILE *fr;
  signed int errors = 0;
  /* assertion r */
  assert(r != ((struct res_struct *)NULL));
  fr=fopen(fname, "r");
  unsigned long int tmp_post$3;
  if(fr == ((struct _IO_FILE *)NULL))
  {
    yaz_log(0x00000004 | 0x00000010, "Cannot open `%s'", fname);
    errors = errors + 1;
  }

  else
  {
    char fr_buf[1024l];
    char *line;
    signed int lineno = 1;
    struct wrbuf *wrbuf_val;
    wrbuf_val=wrbuf_alloc();
    struct yaz_tok_cfg *yt;
    yt=yaz_tok_cfg_create();
    do
    {
      line=fgets(fr_buf, (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1), fr);
      if(line == ((char *)NULL))
        break;

      struct yaz_tok_parse *tp;
      tp=yaz_tok_parse_buf(yt, line);
      signed int t;
      t=yaz_tok_move(tp);
      if(t == -2)
      {
        unsigned long int sz;
        struct res_entry *resp;
        const char *cp;
        cp=yaz_tok_parse_string(tp);
        const char *cp1;
        cp1=strchr(cp, 58);
        if(cp1 == ((const char *)NULL))
        {
          yaz_log(0x00000001, "%s:%d missing colon after '%s'", fname, lineno, cp);
          errors = errors + 1;
          break;
        }

        resp=add_entry(r);
        sz = (unsigned long int)(cp1 - cp);
        void *return_value_xmalloc_f$1;
        return_value_xmalloc_f$1=xmalloc_f(sz + (unsigned long int)1, "res.c", 188);
        resp->name = (char *)return_value_xmalloc_f$1;
        memcpy((void *)resp->name, (const void *)cp, sz);
        resp->name[(signed long int)sz] = (char)0;
        wrbuf_rewind(wrbuf_val);
        if(!(cp1[1l] == 0))
          wrbuf_puts(wrbuf_val, cp1 + (signed long int)1);

        else
        {
          t=yaz_tok_move(tp);
          if(!(t == -2))
          {
            resp->value=xstrdup_f("", "res.c", 206);
            yaz_log(0x00000001, "%s:%d missing value after '%s'", fname, lineno, resp->name);
            errors = errors + 1;
            break;
          }

          const char *return_value_yaz_tok_parse_string$2;
          return_value_yaz_tok_parse_string$2=yaz_tok_parse_string(tp);
          wrbuf_puts(wrbuf_val, return_value_yaz_tok_parse_string$2);
        }
        do
        {
          t=yaz_tok_move(tp);
          if(!(t == -2))
            break;

          if(wrbuf_val->pos >= wrbuf_val->size)
            wrbuf_grow(wrbuf_val, (unsigned long int)1);

          else
            0;
          tmp_post$3 = wrbuf_val->pos;
          wrbuf_val->pos = wrbuf_val->pos + 1ul;
          wrbuf_val->buf[(signed long int)tmp_post$3] = (char)32;
          0;
          const char *return_value_yaz_tok_parse_string$4;
          return_value_yaz_tok_parse_string$4=yaz_tok_parse_string(tp);
          wrbuf_puts(wrbuf_val, return_value_yaz_tok_parse_string$4);
        }
        while((_Bool)1);
        const char *return_value_wrbuf_cstr$5;
        return_value_wrbuf_cstr$5=wrbuf_cstr(wrbuf_val);
        resp->value=xstrdup_env(return_value_wrbuf_cstr$5);
      }

      lineno = lineno + 1;
      yaz_tok_parse_destroy(tp);
    }
    while((_Bool)1);
    fclose(fr);
    yaz_tok_cfg_destroy(yt);
    wrbuf_destroy(wrbuf_val);
  }
  if(!(errors == 0))
    return (signed short int)-1;

  else
    return (signed short int)0;
}

// res_set
// file res.c line 338
void res_set(struct res_struct *r, const char *name, const char *value)
{
  struct res_entry *re;
  /* assertion r */
  assert(r != ((struct res_struct *)NULL));
  signed int return_value_yaz_matchstr$1;
  if(!(value == ((const char *)NULL)))
  {
    re = r->first;
    for( ; !(re == ((struct res_entry *)NULL)); re = re->next)
      if(!(re->value == ((char *)NULL)))
      {
        return_value_yaz_matchstr$1=yaz_matchstr(re->name, name);
        if(return_value_yaz_matchstr$1 == 0)
        {
          xfree_f((void *)re->value, "res.c", 348);
          re->value=xstrdup_env(value);
          goto __CPROVER_DUMP_L5;
        }

      }

    re=add_entry(r);
    re->name=xstrdup_f(name, "res.c", 353);
    re->value=xstrdup_env(value);
  }


__CPROVER_DUMP_L5:
  ;
}

// res_trav
// file res.c line 357
signed int res_trav(struct res_struct *r, const char *prefix, void *p, void (*f)(void *, const char *, const char *))
{
  struct res_entry *re;
  signed int l = 0;
  signed int no = 0;
  unsigned long int return_value_strlen$1;
  _Bool tmp_if_expr$3;
  signed int return_value_memcmp$2;
  signed int return_value_res_trav$4;
  if(r == ((struct res_struct *)NULL))
    return 0;

  else
  {
    no=res_trav(r->over_res, prefix, p, f);
    if(!(no == 0))
      return no;

    else
    {
      if(!(prefix == ((const char *)NULL)))
      {
        return_value_strlen$1=strlen(prefix);
        l = (signed int)return_value_strlen$1;
      }

      re = r->first;
      for( ; !(re == ((struct res_entry *)NULL)); re = re->next)
        if(!(re->value == ((char *)NULL)))
        {
          if(l == 0)
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value_memcmp$2=memcmp((const void *)re->name, (const void *)prefix, (unsigned long int)l);
            tmp_if_expr$3 = !(return_value_memcmp$2 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
          {
            f(p, re->name, re->value);
            no = no + 1;
          }

        }

      if(no == 0)
      {
        return_value_res_trav$4=res_trav(r->def_res, prefix, p, f);
        return return_value_res_trav$4;
      }

      else
        return no;
    }
  }
}

// res_write_file
// file res.c line 384
signed short int res_write_file(struct res_struct *r, const char *fname)
{
  struct res_entry *re;
  struct _IO_FILE *fr;
  /* assertion r */
  assert(r != ((struct res_struct *)NULL));
  fr=fopen(fname, "w");
  unsigned long int return_value_strlen$2;
  if(fr == ((struct _IO_FILE *)NULL))
  {
    yaz_log(0x00000001 | 0x00000010, "Cannot create `%s'", fname);
    return (signed short int)-1;
  }

  else
  {
    re = r->first;
    for( ; !(re == ((struct res_entry *)NULL)); re = re->next)
    {
      signed int no = 0;
      signed int lefts;
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(re->name);
      lefts = (signed int)(return_value_strlen$1 + (unsigned long int)2);
      if(re->value == ((char *)NULL))
        fprintf(fr, "%s\n", re->name);

      else
      {
        fprintf(fr, "%s: ", re->name);
        do
        {
          return_value_strlen$2=strlen(re->value + (signed long int)no);
          if(!(return_value_strlen$2 + (unsigned long int)lefts >= 79ul))
            break;

          signed int i = 20;
          signed int ind = (no + 78) - lefts;
          do
          {
            i = i - 1;
            if(!(i >= 0))
              break;

            if((signed int)re->value[(signed long int)ind] == 32)
              break;

            ind = ind - 1;
          }
          while((_Bool)1);
          if(!(i >= 0))
            ind = (no + 78) - lefts;

          i = no;
          for( ; !(i == ind); i = i + 1)
            _IO_putc((signed int)re->value[(signed long int)i], fr);
          fprintf(fr, "\\\n");
          no = ind;
          lefts = 0;
        }
        while((_Bool)1);
        fprintf(fr, "%s\n", re->value + (signed long int)no);
      }
    }
    fclose(fr);
    return (signed short int)0;
  }
}

// run_func
// file tstflock.c line 98
void * run_func(void *arg)
{
  signed int i;
  signed int *pdata = (signed int *)arg;
  signed int use_write_lock = *pdata;
  struct zebra_lock_handle *lh;
  lh=zebra_lock_create(((const char *)NULL), "my.LCK");
  i = 0;
  signed int return_value_rand$1;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  for( ; !(i >= 2); i = i + 1)
  {
    signed int write_lock = use_write_lock;
    if(use_write_lock == 2)
    {
      return_value_rand$1=rand();
      write_lock = (return_value_rand$1 & 3) == 3 ? 1 : 0;
    }

    if(!(write_lock == 0))
    {
      zebra_lock_w(lh);
      write(test_fd, (const void *)"L", (unsigned long int)1);
      tmp_post$2 = seqp;
      seqp = seqp + 1l;
      *tmp_post$2 = (char)76;
      small_sleep();
      tmp_post$3 = seqp;
      seqp = seqp + 1l;
      *tmp_post$3 = (char)85;
      write(test_fd, (const void *)"U", (unsigned long int)1);
      zebra_unlock(lh);
    }

    else
    {
      zebra_lock_r(lh);
      write(test_fd, (const void *)"l", (unsigned long int)1);
      tmp_post$4 = seqp;
      seqp = seqp + 1l;
      *tmp_post$4 = (char)108;
      small_sleep();
      tmp_post$5 = seqp;
      seqp = seqp + 1l;
      *tmp_post$5 = (char)117;
      write(test_fd, (const void *)"u", (unsigned long int)1);
      zebra_unlock(lh);
    }
  }
  zebra_lock_destroy(lh);
  *pdata = 123;
  return NULL;
}

// scan_string
// file charmap.c line 421
static signed int scan_string(char *s_native, struct yaz_iconv_struct *t_unicode, struct yaz_iconv_struct *t_utf8, void (*fun)(const char *, void *, signed int), void *data, signed int *num)
{
  char str[1024l];
  unsigned int arg[512l];
  unsigned int arg_prim[512l];
  unsigned int *s = arg;
  unsigned int c;
  unsigned int begin;
  unsigned int end;
  unsigned long int i;
  if(!(t_unicode == ((struct yaz_iconv_struct *)NULL)))
  {
    char *outbuf = (char *)arg;
    char *inbuf = s_native;
    unsigned long int outbytesleft = sizeof(unsigned int [512l]) /*2048ul*/  - (unsigned long int)4;
    unsigned long int inbytesleft;
    inbytesleft=strlen(s_native);
    unsigned long int ret;
    ret=yaz_iconv(t_unicode, &inbuf, &inbytesleft, &outbuf, &outbytesleft);
    if(!(ret == 18446744073709551615ul))
      ret=yaz_iconv(t_unicode, ((char **)NULL), ((unsigned long int *)NULL), &outbuf, &outbytesleft);

    if(ret == 18446744073709551615ul)
      return -1;

    i = (unsigned long int)(outbuf - (char *)arg) / sizeof(unsigned int) /*4ul*/ ;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(s_native[(signed long int)i] == 0); i = i + 1ul)
      arg[(signed long int)i] = (unsigned int)((signed int)s_native[(signed long int)i] & 255);
  }
  arg[(signed long int)i] = (unsigned int)0;
  _Bool tmp_if_expr$1;
  if(*s == 65279u)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = s[(signed long int)0] == (unsigned int)0xfeff ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    s = s + 1l;

  signed int tmp_if_expr$4;
  signed int tmp_post$3;
  unsigned long int tmp_post$5;
  signed int return_value_zebra_ucs4_strlen$6;
  signed int return_value_scan_to_utf8$7;
  signed int tmp_if_expr$9;
  signed int tmp_post$8;
  signed int return_value_scan_to_utf8$10;
  signed int tmp_if_expr$12;
  signed int tmp_post$11;
  while(!(*s == 0u))
    switch(*s)
    {
      case (unsigned int)123:
      {
        s = s + 1l;
        begin=zebra_prim_w(&s);
        if(!(*s == 45u))
        {
          yaz_log(0x00000001, "Bad range in char-map");
          return -1;
        }

        s = s + 1l;
        end=zebra_prim_w(&s);
        if(begin >= end)
        {
          yaz_log(0x00000001, "Bad range in char-map");
          return -1;
        }

        s = s + 1l;
        c = begin;
        if(end >= c)
        {
          signed int return_value_scan_to_utf8$2;
          return_value_scan_to_utf8$2=scan_to_utf8(t_utf8, &c, (unsigned long int)1, str, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
          if(!(return_value_scan_to_utf8$2 == 0))
            return -1;

          if(!(num == ((signed int *)NULL)))
          {
            tmp_post$3 = *num;
            *num = *num + 1;
            tmp_if_expr$4 = tmp_post$3;
          }

          else
            tmp_if_expr$4 = 0;
          fun(str, data, tmp_if_expr$4);
          c = c + 1u;
        }

        break;
      }
      case (unsigned int)40:
      {
        s = s + 1l;
        i = (unsigned long int)0;
        while((_Bool)1)
        {
          if(*s == 41u)
          {
            if(!(s[-1l] == 92u))
              goto __CPROVER_DUMP_L21;

          }

          if(*s == 0u)
          {
            yaz_log(0x00000001, "Missing ) in charmap");
            return -1;
          }

          tmp_post$5 = i;
          i = i + 1ul;
          arg_prim[(signed long int)tmp_post$5]=zebra_prim_w(&s);
        }

      __CPROVER_DUMP_L21:
        ;
        arg_prim[(signed long int)i] = (unsigned int)0;
        return_value_zebra_ucs4_strlen$6=zebra_ucs4_strlen(arg_prim);
        return_value_scan_to_utf8$7=scan_to_utf8(t_utf8, arg_prim, (unsigned long int)return_value_zebra_ucs4_strlen$6, str, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
        if(!(return_value_scan_to_utf8$7 == 0))
          return -1;

        if(!(num == ((signed int *)NULL)))
        {
          tmp_post$8 = *num;
          *num = *num + 1;
          tmp_if_expr$9 = tmp_post$8;
        }

        else
          tmp_if_expr$9 = 0;
        fun(str, data, tmp_if_expr$9);
      }
      default:
      {
        c=zebra_prim_w(&s);
        return_value_scan_to_utf8$10=scan_to_utf8(t_utf8, &c, (unsigned long int)1, str, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
        if(!(return_value_scan_to_utf8$10 == 0))
          return -1;

        if(!(num == ((signed int *)NULL)))
        {
          tmp_post$11 = *num;
          *num = *num + 1;
          tmp_if_expr$12 = tmp_post$11;
        }

        else
          tmp_if_expr$12 = 0;
        fun(str, data, tmp_if_expr$12);
      }
    }
  return 0;
}

// scan_to_utf8
// file charmap.c line 393
static signed int scan_to_utf8(struct yaz_iconv_struct *t, unsigned int *from, unsigned long int inlen, char *outbuf, unsigned long int outbytesleft)
{
  unsigned long int inbytesleft = inlen * sizeof(unsigned int) /*4ul*/ ;
  char *inbuf = (char *)from;
  unsigned long int ret;
  char *tmp_post$1;
  if(t == ((struct yaz_iconv_struct *)NULL))
  {
    tmp_post$1 = outbuf;
    outbuf = outbuf + 1l;
    *tmp_post$1 = (char)*from;
  }

  else
  {
    ret=yaz_iconv(t, &inbuf, &inbytesleft, &outbuf, &outbytesleft);
    if(!(ret == 18446744073709551615ul))
      ret=yaz_iconv(t, ((char **)NULL), ((unsigned long int *)NULL), &outbuf, &outbytesleft);

    if(ret == 18446744073709551615ul)
    {
      yaz_log(0x00000008, "from: %2X %2X %2X %2X", from[(signed long int)0], from[(signed long int)1], from[(signed long int)2], from[(signed long int)3]);
      yaz_log(0x00000004 | 0x00000010, "bad unicode sequence");
      return -1;
    }

  }
  *outbuf = (char)0;
  return 0;
}

// set_map_string
// file charmap.c line 92
static struct chr_t_entry * set_map_string(struct chr_t_entry *root, struct nmem_control *nmem, const char *from, signed int len, char *to, const char *from_0)
{
  if(from_0 == ((const char *)NULL))
    from_0 = from;

  if(root == ((struct chr_t_entry *)NULL))
  {
    void *return_value_nmem_malloc$1;
    return_value_nmem_malloc$1=nmem_malloc(nmem, sizeof(struct chr_t_entry) /*16ul*/ );
    root = (struct chr_t_entry *)return_value_nmem_malloc$1;
    root->children = ((struct chr_t_entry **)NULL);
    root->target = ((unsigned char **)NULL);
  }

  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$2;
  if(len == 0)
  {
    if(root->target == ((unsigned char **)NULL))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(root->target[(signed long int)0] != ((unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strcmp$6=strcmp((const char *)root->target[(signed long int)0], to);
      tmp_if_expr$7 = return_value_strcmp$6 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
    {
      if(!(from_0 == ((const char *)NULL)))
      {
        if(!(root->target == ((unsigned char **)NULL)))
        {
          if(!(*root->target == ((unsigned char *)NULL)))
          {
            if(!(*(*root->target) == 0))
            {
              return_value_strcmp$2=strcmp((const char *)root->target[(signed long int)0], CHR_UNKNOWN);
              if(!(return_value_strcmp$2 == 0))
                yaz_log(0x00000004, "duplicate entry for charmap from '%s'", from_0);

            }

          }

        }

      }

      void *return_value_nmem_malloc$3;
      return_value_nmem_malloc$3=nmem_malloc(nmem, sizeof(unsigned char *) /*8ul*/  * (unsigned long int)2);
      root->target = (unsigned char **)return_value_nmem_malloc$3;
      char *return_value_nmem_strdup$4;
      return_value_nmem_strdup$4=nmem_strdup(nmem, to);
      root->target[(signed long int)0] = (unsigned char *)return_value_nmem_strdup$4;
      root->target[(signed long int)1] = ((unsigned char *)NULL);
    }

  }

  else
  {
    if(root->children == ((struct chr_t_entry **)NULL))
    {
      signed int i;
      void *return_value_nmem_malloc$8;
      return_value_nmem_malloc$8=nmem_malloc(nmem, sizeof(struct chr_t_entry *) /*8ul*/  * (unsigned long int)256);
      root->children = (struct chr_t_entry **)return_value_nmem_malloc$8;
      i = 0;
      for( ; !(i >= 256); i = i + 1)
        root->children[(signed long int)i] = ((struct chr_t_entry *)NULL);
    }

    root->children[(signed long int)(unsigned char)*from]=set_map_string(root->children[(signed long int)(unsigned char)*from], nmem, from + (signed long int)1, len - 1, to, from_0);
    if(root->children[(signed long int)(unsigned char)*from] == ((struct chr_t_entry *)NULL))
      return ((struct chr_t_entry *)NULL);

  }
  return root;
}

// small_sleep
// file tstflock.c line 74
static void small_sleep(void)
{
  struct timespec abstime;
  struct timeval now;
  gettimeofday(&now, ((struct timezone *)NULL));
  abstime.tv_sec = now.tv_sec;
  abstime.tv_nsec = (signed long int)1000000 + now.tv_usec * (signed long int)1000;
  if(abstime.tv_nsec >= 1000000001l)
  {
    abstime.tv_nsec = abstime.tv_nsec - (signed long int)1000000000;
    abstime.tv_sec = abstime.tv_sec + 1l;
  }

  pthread_mutex_lock(&sleep_mutex);
  pthread_cond_timedwait(&sleep_cond, &sleep_mutex, &abstime);
  pthread_mutex_unlock(&sleep_mutex);
}

// tokenize_simple
// file zebramap.c line 628
static signed int tokenize_simple(struct zebra_map *zm, const char **result_buf, unsigned long int *result_len)
{
  char *buf = zm->input_str->buf;
  unsigned long int len = zm->input_str->pos;
  unsigned long int i = zm->simple_off;
  unsigned long int start;
  char *return_value_strchr$1;
  for( ; !(i >= len); i = i + 1ul)
  {
    return_value_strchr$1=strchr(";,.()-/?<> \r\n\t", (signed int)buf[(signed long int)i]);
    if(return_value_strchr$1 == ((char *)NULL))
      break;

  }
  start = i;
  char *return_value_strchr$2;
  signed int return_value_tolower$3;
  while(!(i >= len))
  {
    return_value_strchr$2=strchr(";,.()-/?<> \r\n\t", (signed int)buf[(signed long int)i]);
    if(!(return_value_strchr$2 == ((char *)NULL)))
      break;

    if((signed int)buf[(signed long int)i] >= 33)
    {
      if(!((signed int)buf[(signed long int)i] >= 127))
      {
        return_value_tolower$3=tolower((signed int)buf[(signed long int)i]);
        buf[(signed long int)i] = (char)return_value_tolower$3;
      }

    }

    i = i + 1ul;
  }
  zm->simple_off = i;
  if(!(start == i))
  {
    *result_buf = buf + (signed long int)start;
    *result_len = i - start;
    return 1;
  }

  else
    return 0;
}

// tst
// file tstflock.c line 197
static void tst(void)
{
  tst_thread(4, 1);
  {
    signed int i = 0;
    for( ; !(seq[(signed long int)i] == 0); i = i + 2)
    {
      signed int tst$$1$$1$$1$$1$$lval = (signed int)seq[(signed long int)i];
      signed int rval = 76;
      if(tst$$1$$1$$1$$1$$lval == rval)
        yaz_check_eq1(1, "tstflock.c", 205, "seq[i]", "'L'", tst$$1$$1$$1$$1$$lval, rval);

      else
        yaz_check_eq1(2, "tstflock.c", 205, "seq[i]", "'L'", tst$$1$$1$$1$$1$$lval, rval);
      signed int lval = (signed int)seq[(signed long int)(i + 1)];
      signed int tst$$1$$1$$1$$2$$rval = 85;
      if(lval == tst$$1$$1$$1$$2$$rval)
        yaz_check_eq1(1, "tstflock.c", 206, "seq[i+1]", "'U'", lval, tst$$1$$1$$1$$2$$rval);

      else
        yaz_check_eq1(2, "tstflock.c", 206, "seq[i+1]", "'U'", lval, tst$$1$$1$$1$$2$$rval);
    }
  }
  tst_thread(6, 0);
  tst_thread(20, 2);
}

// tst_thread
// file tstflock.c line 149
static void tst_thread(signed int num, signed int write_flag)
{
  unsigned long int child_thread[100l];
  signed int i;
  signed int id[100l];
  seqp = seq;
  /* assertion num <= 100 */
  assert(num <= 100);
  i = 0;
  for( ; !(i >= num); i = i + 1)
  {
    id[(signed long int)i] = write_flag;
    pthread_create(&child_thread[(signed long int)i], ((const union pthread_attr_t *)NULL), run_func, (void *)&id[(signed long int)i]);
  }
  i = 0;
  for( ; !(i >= num); i = i + 1)
    pthread_join(child_thread[(signed long int)i], ((void **)NULL));
  i = 0;
  for( ; !(i >= num); i = i + 1)
    if(id[(signed long int)i] == 123)
      yaz_check_print1(1, "tstflock.c", 191, "id[i] == 123");

    else
      yaz_check_print1(2, "tstflock.c", 191, "id[i] == 123");
  char *tmp_post$1 = seqp;
  seqp = seqp + 1l;
  *tmp_post$1 = (char)0;
  yaz_log(0x00000008, "tst_thread(%d,%d) returns seq=%s", num, write_flag, (const void *)seq);
}

// unixLock
// file flock.c line 232
static signed int unixLock(signed int fd, signed int type, signed int cmd)
{
  struct flock area;
  signed int r;
  area.l_type = (signed short int)type;
  area.l_whence = (signed short int)0;
  area.l_start = 0L;
  area.l_len = area.l_start;
  yaz_log(log_level, "fcntl begin type=%d fd=%d", type, fd);
  r=fcntl(fd, cmd, &area);
  if(r == -1)
    yaz_log(0x00000004 | 0x00000010, "fcntl FAIL type=%d fd=%d", type, fd);

  else
    yaz_log(log_level, "fcntl type=%d OK fd=%d", type, fd);
  return r;
}

// xstrdup_env
// file res.c line 77
static char * xstrdup_env(const char *src)
{
  signed int i = 0;
  signed int j = 0;
  char *dst;
  signed int env_strlen = 0;
  _Bool tmp_if_expr$6;
  char *return_value_strchr$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  unsigned long int return_value_strlen$4;
  char *return_value_strchr$5;
  while(!(src[(signed long int)i] == 0))
  {
    if((signed int)src[(signed long int)i] == 36)
      tmp_if_expr$6 = (signed int)src[(signed long int)(i + 1)] == 123 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      char envname[128l];
      char *env_val;
      signed int k = 0;
      i = i + 2;
      for( ; !(k >= 127); envname[(signed long int)tmp_post$2] = src[(signed long int)tmp_post$3])
      {
        if(src[(signed long int)i] == 0)
          break;

        return_value_strchr$1=strchr(":}\n\r\f", (signed int)src[(signed long int)i]);
        if(!(return_value_strchr$1 == ((char *)NULL)))
          break;

        tmp_post$2 = k;
        k = k + 1;
        tmp_post$3 = i;
        i = i + 1;
      }
      envname[(signed long int)k] = (char)0;
      env_val=getenv(envname);
      if(!(env_val == ((char *)NULL)))
      {
        return_value_strlen$4=strlen(env_val);
        env_strlen = env_strlen + (signed int)((unsigned long int)1 + return_value_strlen$4);
      }

      else
        env_strlen = env_strlen + 1;
      for( ; !(src[(signed long int)i] == 0); i = i + 1)
      {
        return_value_strchr$5=strchr("}\n\r\f", (signed int)src[(signed long int)i]);
        if(!(return_value_strchr$5 == ((char *)NULL)))
          break;

      }
      if((signed int)src[(signed long int)i] == 125)
        i = i + 1;

    }

    else
      i = i + 1;
  }
  void *return_value_xmalloc_f$7;
  return_value_xmalloc_f$7=xmalloc_f((unsigned long int)(1 + env_strlen + i), "res.c", 109);
  dst = (char *)return_value_xmalloc_f$7;
  i = 0;
  _Bool tmp_if_expr$18;
  char *return_value_strchr$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  char *return_value_strchr$12;
  signed int tmp_post$13;
  signed int tmp_post$14;
  char *return_value_strchr$15;
  signed int tmp_post$16;
  signed int tmp_post$17;
  while(!(src[(signed long int)i] == 0))
  {
    if((signed int)src[(signed long int)i] == 36)
      tmp_if_expr$18 = (signed int)src[(signed long int)(i + 1)] == 123 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$18 = (_Bool)0;
    if(tmp_if_expr$18)
    {
      char xstrdup_env$$1$$2$$1$$envname[128l];
      char *xstrdup_env$$1$$2$$1$$env_val;
      signed int xstrdup_env$$1$$2$$1$$k = 0;
      i = i + 2;
      for( ; !(xstrdup_env$$1$$2$$1$$k >= 127); xstrdup_env$$1$$2$$1$$envname[(signed long int)tmp_post$9] = src[(signed long int)tmp_post$10])
      {
        if(src[(signed long int)i] == 0)
          break;

        return_value_strchr$8=strchr(":}\n\r\f", (signed int)src[(signed long int)i]);
        if(!(return_value_strchr$8 == ((char *)NULL)))
          break;

        tmp_post$9 = xstrdup_env$$1$$2$$1$$k;
        xstrdup_env$$1$$2$$1$$k = xstrdup_env$$1$$2$$1$$k + 1;
        tmp_post$10 = i;
        i = i + 1;
      }
      xstrdup_env$$1$$2$$1$$envname[(signed long int)xstrdup_env$$1$$2$$1$$k] = (char)0;
      xstrdup_env$$1$$2$$1$$env_val=getenv(xstrdup_env$$1$$2$$1$$envname);
      if(!(xstrdup_env$$1$$2$$1$$env_val == ((char *)NULL)))
      {
        strcpy(dst + (signed long int)j, xstrdup_env$$1$$2$$1$$env_val);
        unsigned long int return_value_strlen$11;
        return_value_strlen$11=strlen(xstrdup_env$$1$$2$$1$$env_val);
        j = j + (signed int)return_value_strlen$11;
      }

      else
        if((signed int)src[(signed long int)i] == 58)
        {
          if((signed int)src[(signed long int)(1 + i)] == 45)
          {
            i = i + 2;
            for( ; !(src[(signed long int)i] == 0); dst[(signed long int)tmp_post$13] = src[(signed long int)tmp_post$14])
            {
              return_value_strchr$12=strchr("}\n\r\f", (signed int)src[(signed long int)i]);
              if(!(return_value_strchr$12 == ((char *)NULL)))
                break;

              tmp_post$13 = j;
              j = j + 1;
              tmp_post$14 = i;
              i = i + 1;
            }
          }

        }

      for( ; !(src[(signed long int)i] == 0); i = i + 1)
      {
        return_value_strchr$15=strchr("}\n\r\f", (signed int)src[(signed long int)i]);
        if(!(return_value_strchr$15 == ((char *)NULL)))
          break;

      }
      if((signed int)src[(signed long int)i] == 125)
        i = i + 1;

    }

    else
    {
      tmp_post$16 = j;
      j = j + 1;
      tmp_post$17 = i;
      i = i + 1;
      dst[(signed long int)tmp_post$16] = src[(signed long int)tmp_post$17];
    }
  }
  dst[(signed long int)j] = (char)0;
  return dst;
}

// zebra_add_map
// file zebramap.c line 106
struct zebra_map * zebra_add_map(struct zebra_maps_s *zms, const char *index_type, signed int map_type)
{
  struct zebra_map *zm;
  void *return_value_nmem_malloc$1;
  return_value_nmem_malloc$1=nmem_malloc(zms->nmem, sizeof(struct zebra_map) /*112ul*/ );
  zm = (struct zebra_map *)return_value_nmem_malloc$1;
  zm->zebra_maps = zms;
  zm->id=nmem_strdup(zms->nmem, index_type);
  zm->maptab_name = ((const char *)NULL);
  zm->use_chain = 0;
  zm->debug = 0;
  zm->maptab = ((struct chrmaptab_info *)NULL);
  zm->type = map_type;
  zm->completeness = 0;
  zm->positioned = 0;
  zm->alwaysmatches = 0;
  zm->first_in_field = 0;
  if(!(zms->last_map == ((struct zebra_map *)NULL)))
    zms->last_map->next = zm;

  else
    zms->map_list = zm;
  zms->last_map = zm;
  zm->next = ((struct zebra_map *)NULL);
  zm->icu_chain = ((struct icu_chain *)NULL);
  zm->doc = ((struct _xmlDoc *)NULL);
  zm->input_str=wrbuf_alloc();
  zm->print_str=wrbuf_alloc();
  return zm;
}

// zebra_charmap_get
// file zebramap.c line 381
struct chrmaptab_info * zebra_charmap_get(struct zebra_map *zm)
{
  _Bool tmp_if_expr$2;
  signed int return_value_yaz_matchstr$1;
  if(zm->maptab == ((struct chrmaptab_info *)NULL))
  {
    if(zm->maptab_name == ((const char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_yaz_matchstr$1=yaz_matchstr(zm->maptab_name, "@");
      tmp_if_expr$2 = !(return_value_yaz_matchstr$1 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      return (struct chrmaptab_info *)(void *)0;

    zm->maptab=chrmaptab_create(zm->zebra_maps->tabpath, zm->maptab_name, zm->zebra_maps->tabroot);
    if(zm->maptab == ((struct chrmaptab_info *)NULL))
      yaz_log(0x00000004, "Failed to read character table %s", zm->maptab_name);

    else
      yaz_log(0x00000002, "Read character table %s", zm->maptab_name);
  }

  return zm->maptab;
}

// zebra_exit
// file exit.c line 26
void zebra_exit(const char *msg)
{
  yaz_log(0x00000008, "%s: exit", msg);
  exit(1);
}

// zebra_flock_init
// file ../include/idzebra/flock.h line 46
void zebra_flock_init(void)
{
  if(initialized == 0)
  {
    initialized = 1;
    log_level=yaz_log_module_level("flock");
    yaz_log(log_level, "zebra_flock_init");
    check_for_linuxthreads();
    zebra_mutex_init(&lock_list_mutex);
    yaz_log(log_level, "posix_locks: %d", posix_locks);
  }

}

// zebra_get_version
// file version.c line 33
void zebra_get_version(char *version_str, char *sha1_str)
{
  if(!(version_str == ((char *)NULL)))
    strcpy(version_str, "2.0.59");

  if(!(sha1_str == ((char *)NULL)))
    strcpy(sha1_str, "c00bfddbf0f3608340d61298acc61dafb167f9b2");

}

// zebra_lock_create
// file ../include/idzebra/flock.h line 30
struct zebra_lock_handle * zebra_lock_create(const char *dir, const char *name)
{
  char *fname;
  fname=zebra_mk_fname(dir, name);
  struct zebra_lock_info *p = ((struct zebra_lock_info *)NULL);
  struct zebra_lock_handle *h = ((struct zebra_lock_handle *)NULL);
  /* assertion initialized */
  assert(initialized != 0);
  zebra_mutex_lock(&lock_list_mutex);
  signed int return_value_strcmp$1;
  if(!(posix_locks == 0))
  {
    p = lock_list;
    for( ; !(p == ((struct zebra_lock_info *)NULL)); p = p->next)
    {
      return_value_strcmp$1=strcmp(p->fname, fname);
      if(return_value_strcmp$1 == 0)
        break;

    }
  }

  if(p == ((struct zebra_lock_info *)NULL))
  {
    void *return_value_xmalloc_f$2;
    return_value_xmalloc_f$2=xmalloc_f(sizeof(struct zebra_lock_info) /*184ul*/ , "flock.c", 137);
    p = (struct zebra_lock_info *)return_value_xmalloc_f$2;
    p->ref_count = 0;
    p->fd=open(fname, 0 | 0100 | 02, 0666);
    if(p->fd == -1)
    {
      xfree_f((void *)p, "flock.c", 149);
      yaz_log(0x00000004 | 0x00000010, "zebra_lock_create fail fname=%s", fname);
      p = ((struct zebra_lock_info *)NULL);
    }

    else
    {
      p->fname = fname;
      fname = ((char *)NULL);
      if(!(posix_locks == 0))
        zebra_lock_rdwr_init(&p->rdwr_lock);

      zebra_mutex_init(&p->file_mutex);
      p->no_file_write_lock = 0;
      p->no_file_read_lock = 0;
      p->next = lock_list;
      lock_list = p;
    }
  }

  if(!(p == ((struct zebra_lock_info *)NULL)))
  {
    p->ref_count = p->ref_count + 1;
    void *return_value_xmalloc_f$3;
    return_value_xmalloc_f$3=xmalloc_f(sizeof(struct zebra_lock_handle) /*16ul*/ , "flock.c", 174);
    h = (struct zebra_lock_handle *)return_value_xmalloc_f$3;
    h->p = p;
    h->write_flag = 0;
    yaz_log(log_level, "zebra_lock_create fd=%d p=%p fname=%s", h->p->fd, h, p->fname);
  }

  zebra_mutex_unlock(&lock_list_mutex);
  xfree_f((void *)fname, "flock.c", 183);
  return h;
}

// zebra_lock_destroy
// file ../include/idzebra/flock.h line 33
void zebra_lock_destroy(struct zebra_lock_handle *h)
{
  if(!(h == ((struct zebra_lock_handle *)NULL)))
  {
    yaz_log(log_level, "zebra_lock_destroy fd=%d p=%p fname=%s", h->p->fd, h, h->p->fname);
    zebra_mutex_lock(&lock_list_mutex);
    yaz_log(log_level, "zebra_lock_destroy fd=%d p=%p fname=%s refcount=%d", h->p->fd, h, h->p->fname, h->p->ref_count);
    /* assertion h->p->ref_count > 0 */
    assert(h->p->ref_count > 0);
    h->p->ref_count = h->p->ref_count - 1;
    if(h->p->ref_count == 0)
    {
      struct zebra_lock_info **hp = &lock_list;
      while(!(*hp == ((struct zebra_lock_info *)NULL)))
        if(*hp == h->p)
        {
          *hp = h->p->next;
          break;
        }

        else
          hp = &(*hp)->next;
      yaz_log(log_level, "zebra_lock_destroy fd=%d p=%p fname=%s remove", h->p->fd, h, h->p->fname);
      if(!(posix_locks == 0))
        zebra_lock_rdwr_destroy(&h->p->rdwr_lock);

      zebra_mutex_destroy(&h->p->file_mutex);
      if(!(h->p->fd == -1))
        close(h->p->fd);

      xfree_f((void *)h->p->fname, "flock.c", 224);
      xfree_f((void *)h->p, "flock.c", 225);
    }

    xfree_f((void *)h, "flock.c", 227);
    zebra_mutex_unlock(&lock_list_mutex);
  }

}

// zebra_lock_r
// file ../include/idzebra/flock.h line 43
signed int zebra_lock_r(struct zebra_lock_handle *h)
{
  signed int r = 0;
  signed int do_lock = 0;
  yaz_log(log_level, "zebra_lock_r fd=%d p=%p fname=%s begin", h->p->fd, h, h->p->fname);
  if(!(posix_locks == 0))
    zebra_lock_rdwr_rlock(&h->p->rdwr_lock);

  zebra_mutex_lock(&h->p->file_mutex);
  if(h->p->no_file_read_lock == 0)
  {
    if(h->p->no_file_write_lock == 0)
      do_lock = 1;

  }

  h->p->no_file_read_lock = h->p->no_file_read_lock + 1;
  if(!(do_lock == 0))
    r=unixLock(h->p->fd, 0, 7);

  else
    /* assertion posix_locks */
    assert(posix_locks != 0);
  zebra_mutex_unlock(&h->p->file_mutex);
  h->write_flag = 0;
  yaz_log(log_level, "zebra_lock_r fd=%d p=%p fname=%s end", h->p->fd, h, h->p->fname);
  return r;
}

// zebra_lock_rdwr_destroy
// file zebra-lock.c line 100
signed int zebra_lock_rdwr_destroy(struct anonymous$56 *p)
{
  /* assertion p->readers_reading == 0 */
  assert(p->readers_reading == 0);
  /* assertion p->writers_writing == 0 */
  assert(p->writers_writing == 0);
  pthread_mutex_destroy(&p->mutex);
  pthread_cond_destroy(&p->lock_free);
  return 0;
}

// zebra_lock_rdwr_init
// file zebra-lock.c line 89
signed int zebra_lock_rdwr_init(struct anonymous$56 *p)
{
  p->readers_reading = 0;
  p->writers_writing = 0;
  pthread_mutex_init(&p->mutex, ((const union anonymous$53 *)NULL));
  pthread_cond_init(&p->lock_free, ((const union anonymous$53 *)NULL));
  return 0;
}

// zebra_lock_rdwr_rlock
// file zebra-lock.c line 111
signed int zebra_lock_rdwr_rlock(struct anonymous$56 *p)
{
  pthread_mutex_lock(&p->mutex);
  while(!(p->writers_writing == 0))
    pthread_cond_wait(&p->lock_free, &p->mutex);
  p->readers_reading = p->readers_reading + 1;
  pthread_mutex_unlock(&p->mutex);
  return 0;
}

// zebra_lock_rdwr_runlock
// file zebra-lock.c line 135
signed int zebra_lock_rdwr_runlock(struct anonymous$56 *p)
{
  pthread_mutex_lock(&p->mutex);
  if(p->readers_reading == 0)
  {
    pthread_mutex_unlock(&p->mutex);
    return -1;
  }

  else
  {
    p->readers_reading = p->readers_reading - 1;
    if(p->readers_reading == 0)
      pthread_cond_signal(&p->lock_free);

    pthread_mutex_unlock(&p->mutex);
  }
  return 0;
}

// zebra_lock_rdwr_wlock
// file zebra-lock.c line 123
signed int zebra_lock_rdwr_wlock(struct anonymous$56 *p)
{
  pthread_mutex_lock(&p->mutex);
  while((_Bool)1)
  {
    if(p->writers_writing == 0)
    {
      if(p->readers_reading == 0)
        goto __CPROVER_DUMP_L3;

    }

    pthread_cond_wait(&p->lock_free, &p->mutex);
  }

__CPROVER_DUMP_L3:
  ;
  p->writers_writing = p->writers_writing + 1;
  pthread_mutex_unlock(&p->mutex);
  return 0;
}

// zebra_lock_rdwr_wunlock
// file zebra-lock.c line 155
signed int zebra_lock_rdwr_wunlock(struct anonymous$56 *p)
{
  pthread_mutex_lock(&p->mutex);
  if(p->writers_writing == 0)
  {
    pthread_mutex_unlock(&p->mutex);
    return -1;
  }

  else
  {
    p->writers_writing = p->writers_writing - 1;
    pthread_cond_broadcast(&p->lock_free);
    pthread_mutex_unlock(&p->mutex);
  }
  return 0;
}

// zebra_lock_w
// file ../include/idzebra/flock.h line 41
signed int zebra_lock_w(struct zebra_lock_handle *h)
{
  signed int r = 0;
  signed int do_lock = 0;
  yaz_log(log_level, "zebra_lock_w fd=%d p=%p fname=%s begin", h->p->fd, h, h->p->fname);
  if(!(posix_locks == 0))
    zebra_lock_rdwr_wlock(&h->p->rdwr_lock);

  zebra_mutex_lock(&h->p->file_mutex);
  if(h->p->no_file_write_lock == 0)
    do_lock = 1;

  h->p->no_file_write_lock = h->p->no_file_write_lock + 1;
  if(!(do_lock == 0))
    r=unixLock(h->p->fd, 1, 7);

  else
    /* assertion posix_locks */
    assert(posix_locks != 0);
  zebra_mutex_unlock(&h->p->file_mutex);
  h->write_flag = 1;
  yaz_log(log_level, "zebra_lock_w fd=%d p=%p fname=%s end", h->p->fd, h, h->p->fname);
  return r;
}

// zebra_map_get
// file zebramap.c line 354
struct zebra_map * zebra_map_get(struct zebra_maps_s *zms, const char *id)
{
  struct zebra_map *zm = zms->map_list;
  signed int return_value_strcmp$1;
  for( ; !(zm == ((struct zebra_map *)NULL)); zm = zm->next)
  {
    return_value_strcmp$1=strcmp(zm->id, id);
    if(return_value_strcmp$1 == 0)
      break;

  }
  return zm;
}

// zebra_map_get_or_add
// file zebramap.c line 363
struct zebra_map * zebra_map_get_or_add(struct zebra_maps_s *zms, const char *id)
{
  struct zebra_map *zm;
  zm=zebra_map_get(zms, id);
  if(zm == ((struct zebra_map *)NULL))
  {
    zm=zebra_add_map(zms, id, 2);
    if(!(zms->no_files_read == 0))
      yaz_log(0x00000004, "Unknown register type: %s", id);

    zm->maptab_name=nmem_strdup(zms->nmem, "@");
    zm->completeness = 0;
    zm->positioned = 1;
  }

  return zm;
}

// zebra_map_tokenize_next
// file zebramap.c line 657
signed int zebra_map_tokenize_next(struct zebra_map *zm, const char **result_buf, unsigned long int *result_len, const char **display_buf, unsigned long int *display_len)
{
  /* assertion zm->use_chain */
  assert(zm->use_chain != 0);
  signed int return_value_tokenize_simple$1;
  signed int return_value_icu_chain_next_token$2;
  if(zm->icu_chain == ((struct icu_chain *)NULL))
  {
    return_value_tokenize_simple$1=tokenize_simple(zm, result_buf, result_len);
    return return_value_tokenize_simple$1;
  }

  else
  {
    enum UErrorCode status;
    do
    {
      return_value_icu_chain_next_token$2=icu_chain_next_token(zm->icu_chain, &status);
      if(return_value_icu_chain_next_token$2 == 0)
        break;

      if((signed int)status >= 1)
        return 0;

      *result_buf=icu_chain_token_sortkey(zm->icu_chain);
      /* assertion *result_buf */
      assert(*result_buf != ((const char *)NULL));
      *result_len=strlen(*result_buf);
      if(!(display_buf == ((const char **)NULL)))
      {
        *display_buf=icu_chain_token_display(zm->icu_chain);
        if(!(display_len == ((unsigned long int *)NULL)))
          *display_len=strlen(*display_buf);

      }

      if(!(zm->debug == 0))
      {
        wrbuf_rewind(zm->print_str);
        wrbuf_write_escaped(zm->print_str, *result_buf, *result_len);
        const char *return_value_wrbuf_cstr$3;
        return_value_wrbuf_cstr$3=wrbuf_cstr(zm->print_str);
        yaz_log(0x00000008, "output %s", return_value_wrbuf_cstr$3);
      }

      if(!((signed int)*(*result_buf) == 0))
        return 1;

    }
    while((_Bool)1);
  }
  return 0;
}

// zebra_map_tokenize_start
// file zebramap.c line 701
signed int zebra_map_tokenize_start(struct zebra_map *zm, const char *buf, unsigned long int len)
{
  signed int ret;
  /* assertion zm->use_chain */
  assert(zm->use_chain != 0);
  wrbuf_rewind(zm->input_str);
  wrbuf_write(zm->input_str, buf, len);
  zm->simple_off = (unsigned long int)0;
  if(!(zm->icu_chain == ((struct icu_chain *)NULL)))
  {
    enum UErrorCode status;
    if(!(zm->debug == 0))
    {
      wrbuf_rewind(zm->print_str);
      wrbuf_write_escaped(zm->print_str, zm->input_str->buf, zm->input_str->pos);
      const char *return_value_wrbuf_cstr$1;
      return_value_wrbuf_cstr$1=wrbuf_cstr(zm->print_str);
      yaz_log(0x00000008, "input %s", return_value_wrbuf_cstr$1);
    }

    const char *return_value_wrbuf_cstr$2;
    return_value_wrbuf_cstr$2=wrbuf_cstr(zm->input_str);
    ret=icu_chain_assign_cstr(zm->icu_chain, return_value_wrbuf_cstr$2, &status);
    if(ret == 0 && (signed int)status >= 1)
    {
      if(!(zm->debug == 0))
        yaz_log(0x00000004, "bad encoding for input");

      return -1;
    }

  }

  return 0;
}

// zebra_maps_attr
// file zebramap.c line 514
signed int zebra_maps_attr(struct zebra_maps_s *zms, struct Z_AttributesPlusTerm *zapt, const char **index_type, char **search_type, char *rank_type, signed int *complete_flag, signed int *sort_flag)
{
  struct anonymous$89 completeness;
  struct anonymous$89 structure;
  struct anonymous$89 relation;
  struct anonymous$89 sort_relation;
  struct anonymous$89 weight;
  struct anonymous$89 use;
  signed int completeness_value;
  signed int structure_value;
  const char *structure_str = ((const char *)NULL);
  signed int relation_value;
  signed int sort_relation_value;
  signed int weight_value;
  signed int use_value;
  attr_init_APT(&structure, zapt, 4);
  attr_init_APT(&completeness, zapt, 6);
  attr_init_APT(&relation, zapt, 2);
  attr_init_APT(&sort_relation, zapt, 7);
  attr_init_APT(&weight, zapt, 9);
  attr_init_APT(&use, zapt, 1);
  completeness_value=attr_find(&completeness, (const signed short int **)(void *)0);
  structure_value=attr_find_ex(&structure, (const signed short int **)(void *)0, &structure_str);
  relation_value=attr_find(&relation, (const signed short int **)(void *)0);
  sort_relation_value=attr_find(&sort_relation, (const signed short int **)(void *)0);
  weight_value=attr_find(&weight, (const signed short int **)(void *)0);
  use_value=attr_find(&use, (const signed short int **)(void *)0);
  if(completeness_value == 2 || completeness_value == 3)
    *complete_flag = 1;

  else
    *complete_flag = 0;
  *index_type = ((const char *)NULL);
  *sort_flag = sort_relation_value > 0 ? 1 : 0;
  *search_type = "phrase";
  strcpy(rank_type, "void");
  if(relation_value == 102)
  {
    if(weight_value == -1)
      weight_value = 34;

    sprintf(rank_type, "rank,w=%d,u=%d", weight_value, use_value);
  }

  if(!(*complete_flag == 0))
    *index_type = "p";

  else
    *index_type = "w";
  _Bool tmp_if_expr$1;
  if(!(structure_value == 6))
  {
    if(structure_value == 105)
      goto __CPROVER_DUMP_L8;

    if(structure_value == 106)
      goto __CPROVER_DUMP_L9;

    if(structure_value == 1 || structure_value == 2 || structure_value == 108 || structure_value == -1)
      goto __CPROVER_DUMP_L10;

    if(structure_value == 107)
      goto __CPROVER_DUMP_L11;

    if(structure_value == 109)
      goto __CPROVER_DUMP_L12;

    if(structure_value == 104)
      goto __CPROVER_DUMP_L13;

    if(structure_value == 3)
      goto __CPROVER_DUMP_L14;

    if(structure_value == 4)
      goto __CPROVER_DUMP_L15;

    if(structure_value == 5)
      goto __CPROVER_DUMP_L16;

    if(structure_value == -2)
      goto __CPROVER_DUMP_L17;

  }

  else
  {
    *search_type = "and-list";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L8:
    ;
    *search_type = "or-list";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L9:
    ;
    *search_type = "or-list";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L10:
    ;
    *search_type = "phrase";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L11:
    ;
    *search_type = "local";
    *index_type = ((const char *)NULL);
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L12:
    ;
    *index_type = "n";
    *search_type = "numeric";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L13:
    ;
    *index_type = "u";
    *search_type = "phrase";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L14:
    ;
    *index_type = "0";
    *search_type = "phrase";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L15:
    ;
    *index_type = "y";
    *search_type = "phrase";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L16:
    ;
    *index_type = "d";
    *search_type = "phrase";
    goto __CPROVER_DUMP_L23;

  __CPROVER_DUMP_L17:
    ;
    if(!(structure_str == ((const char *)NULL)))
      tmp_if_expr$1 = *structure_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      *index_type = structure_str;

    else
      return -1;
    goto __CPROVER_DUMP_L23;
  }
  return -1;

__CPROVER_DUMP_L23:
  ;
  return 0;
}

// zebra_maps_close
// file zebramap.c line 83
void zebra_maps_close(struct zebra_maps_s *zms)
{
  struct zebra_map *zm = zms->map_list;
  for( ; !(zm == ((struct zebra_map *)NULL)); zm = zm->next)
  {
    if(!(zm->maptab == ((struct chrmaptab_info *)NULL)))
      chrmaptab_destroy(zm->maptab);

    if(!(zm->icu_chain == ((struct icu_chain *)NULL)))
      icu_chain_destroy(zm->icu_chain);

    xmlFreeDoc(zm->doc);
    wrbuf_destroy(zm->input_str);
    wrbuf_destroy(zm->print_str);
  }
  wrbuf_destroy(zms->wrbuf_1);
  nmem_destroy(zms->nmem);
  xfree_f((void *)zms, "zebramap.c", 103);
}

// zebra_maps_define_default_sort
// file zebramap.c line 348
void zebra_maps_define_default_sort(struct zebra_maps_s *zms)
{
  struct zebra_map *zm;
  zm=zebra_add_map(zms, "s", 1);
  zm->u.sort.entry_size = 80;
}

// zebra_maps_input
// file zebramap.c line 398
const char ** zebra_maps_input(struct zebra_map *zm, const char **from, signed int len, signed int first)
{
  struct chrmaptab_info *maptab;
  maptab=zebra_charmap_get(zm);
  const char **return_value_chr_map_input$1;
  if(!(maptab == ((struct chrmaptab_info *)NULL)))
  {
    return_value_chr_map_input$1=chr_map_input(maptab, from, len, first);
    return return_value_chr_map_input$1;
  }

  else
  {
    zm->zebra_maps->temp_map_str[(signed long int)0] = *(*from);
    *from = *from + 1l;
    return zm->zebra_maps->temp_map_ptr;
  }
}

// zebra_maps_is_alwaysmatches
// file zebramap.c line 484
signed int zebra_maps_is_alwaysmatches(struct zebra_map *zm)
{
  if(!(zm == ((struct zebra_map *)NULL)))
    return zm->alwaysmatches;

  else
    return 0;
}

// zebra_maps_is_complete
// file zebramap.c line 449
signed int zebra_maps_is_complete(struct zebra_map *zm)
{
  if(!(zm == ((struct zebra_map *)NULL)))
    return zm->completeness;

  else
    return 0;
}

// zebra_maps_is_first_in_field
// file zebramap.c line 491
signed int zebra_maps_is_first_in_field(struct zebra_map *zm)
{
  if(!(zm == ((struct zebra_map *)NULL)))
    return zm->first_in_field;

  else
    return 0;
}

// zebra_maps_is_icu
// file zebramap.c line 740
signed int zebra_maps_is_icu(struct zebra_map *zm)
{
  /* assertion zm */
  assert(zm != ((struct zebra_map *)NULL));
  return zm->use_chain;
}

// zebra_maps_is_index
// file zebramap.c line 463
signed int zebra_maps_is_index(struct zebra_map *zm)
{
  if(!(zm == ((struct zebra_map *)NULL)))
    return (signed int)(zm->type == 2);

  else
    return 0;
}

// zebra_maps_is_positioned
// file zebramap.c line 456
signed int zebra_maps_is_positioned(struct zebra_map *zm)
{
  if(!(zm == ((struct zebra_map *)NULL)))
    return zm->positioned;

  else
    return 0;
}

// zebra_maps_is_sort
// file zebramap.c line 477
signed int zebra_maps_is_sort(struct zebra_map *zm)
{
  if(!(zm == ((struct zebra_map *)NULL)))
    return (signed int)(zm->type == 1);

  else
    return 0;
}

// zebra_maps_is_staticrank
// file zebramap.c line 470
signed int zebra_maps_is_staticrank(struct zebra_map *zm)
{
  if(!(zm == ((struct zebra_map *)NULL)))
    return (signed int)(zm->type == 3);

  else
    return 0;
}

// zebra_maps_open
// file zebramap.c line 323
struct zebra_maps_s * zebra_maps_open(struct res_struct *res, const char *base_path, const char *profile_path)
{
  struct zebra_maps_s *zms;
  void *return_value_xmalloc_f$1;
  return_value_xmalloc_f$1=xmalloc_f(sizeof(struct zebra_maps_s) /*80ul*/ , "zebramap.c", 326);
  zms = (struct zebra_maps_s *)return_value_xmalloc_f$1;
  zms->nmem=nmem_create();
  char *tmp_if_expr$3;
  char *return_value_nmem_strdup$2;
  if(!(profile_path == ((const char *)NULL)))
  {
    return_value_nmem_strdup$2=nmem_strdup(zms->nmem, profile_path);
    tmp_if_expr$3 = return_value_nmem_strdup$2;
  }

  else
    tmp_if_expr$3 = ((char *)NULL);
  zms->tabpath = tmp_if_expr$3;
  zms->tabroot = ((char *)NULL);
  if(!(base_path == ((const char *)NULL)))
    zms->tabroot=nmem_strdup(zms->nmem, base_path);

  zms->map_list = ((struct zebra_map *)NULL);
  zms->last_map = ((struct zebra_map *)NULL);
  zms->temp_map_str[(signed long int)0] = (char)0;
  zms->temp_map_str[(signed long int)1] = (char)0;
  zms->temp_map_ptr[(signed long int)0] = zms->temp_map_str;
  zms->temp_map_ptr[(signed long int)1] = (const char *)(void *)0;
  zms->wrbuf_1=wrbuf_alloc();
  zms->no_files_read = 0;
  return zms;
}

// zebra_maps_output
// file zebramap.c line 437
const char * zebra_maps_output(struct zebra_map *zm, const char **from)
{
  struct chrmaptab_info *maptab;
  maptab=zebra_charmap_get(zm);
  if(maptab == ((struct chrmaptab_info *)NULL))
    return ((const char *)NULL);

  else
  {
    const char *return_value_chr_map_output$1;
    return_value_chr_map_output$1=chr_map_output(maptab, from, 1);
    return return_value_chr_map_output$1;
  }
}

// zebra_maps_read_file
// file zebramap.c line 294
signed short int zebra_maps_read_file(struct zebra_maps_s *zms, const char *fname)
{
  struct _IO_FILE *f;
  char line[512l];
  char *argv[10l];
  signed int argc;
  signed int lineno = 0;
  signed int failures = 0;
  f=yaz_fopen(zms->tabpath, fname, "r", zms->tabroot);
  if(f == ((struct _IO_FILE *)NULL))
  {
    yaz_log(0x00000010 | 0x00000001, "%s", fname);
    return (signed short int)-1;
  }

  else
  {
    do
    {
      argc=readconf_line(f, &lineno, line, 512, argv, 10);
      if(argc == 0)
        break;

      signed int r;
      r=parse_command(zms, argc, argv, fname, lineno);
      if(!(r == 0))
        failures = failures + 1;

    }
    while((_Bool)1);
    yaz_fclose(f);
    if(!(failures == 0))
      return (signed short int)-1;

    else
    {
      zms->no_files_read = zms->no_files_read + 1;
      return (signed short int)0;
    }
  }
}

// zebra_maps_search
// file zebramap.c line 411
const char ** zebra_maps_search(struct zebra_map *zm, const char **from, signed int len, signed int *q_map_match)
{
  struct chrmaptab_info *maptab;
  *q_map_match = 0;
  maptab=zebra_charmap_get(zm);
  if(!(maptab == ((struct chrmaptab_info *)NULL)))
  {
    const char **map;
    map=chr_map_q_input(maptab, from, len, 0);
    if(!(map == ((const char **)NULL)))
    {
      if(!(*map == ((const char *)NULL)))
      {
        *q_map_match = 1;
        return map;
      }

    }

    map=chr_map_input(maptab, from, len, 0);
    if(!(map == ((const char **)NULL)))
      return map;

  }

  zm->zebra_maps->temp_map_str[(signed long int)0] = *(*from);
  *from = *from + 1l;
  return zm->zebra_maps->temp_map_ptr;
}

// zebra_maps_sort
// file zebramap.c line 498
signed int zebra_maps_sort(struct zebra_maps_s *zms, struct Z_SortAttributes *sortAttributes, signed int *numerical)
{
  struct anonymous$89 use;
  struct anonymous$89 structure;
  signed int structure_value;
  attr_init_AttrList(&use, sortAttributes->list, 1);
  attr_init_AttrList(&structure, sortAttributes->list, 4);
  *numerical = 0;
  structure_value=attr_find(&structure, ((const signed short int **)NULL));
  if(structure_value == 109)
    *numerical = 1;

  signed int return_value_attr_find$1;
  return_value_attr_find$1=attr_find(&use, (const signed short int **)(void *)0);
  return return_value_attr_find$1;
}

// zebra_mk_fname
// file flock.c line 84
char * zebra_mk_fname(const char *dir, const char *name)
{
  signed int dlen;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(dir == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(dir);
    tmp_if_expr$2 = return_value_strlen$1;
  }

  else
    tmp_if_expr$2 = (unsigned long int)0;
  dlen = (signed int)tmp_if_expr$2;
  char *fname;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(name);
  void *return_value_xmalloc_f$4;
  return_value_xmalloc_f$4=xmalloc_f((unsigned long int)dlen + return_value_strlen$3 + (unsigned long int)3, "flock.c", 87);
  fname = (char *)return_value_xmalloc_f$4;
  if(!(dlen == 0))
  {
    signed int last_one = (signed int)dir[(signed long int)(dlen - 1)];
    char *return_value_strchr$5;
    return_value_strchr$5=strchr("/", last_one);
    if(return_value_strchr$5 == ((char *)NULL))
      sprintf(fname, "%s/%s", dir, name);

    else
      sprintf(fname, "%s%s", dir, name);
  }

  else
    sprintf(fname, "%s", name);
  return fname;
}

// zebra_mutex_cond_destroy
// file zebra-lock.c line 183
signed int zebra_mutex_cond_destroy(struct anonymous$49 *p)
{
  pthread_cond_destroy(&p->cond);
  pthread_mutex_destroy(&p->mutex);
  return 0;
}

// zebra_mutex_cond_init
// file zebra-lock.c line 174
signed int zebra_mutex_cond_init(struct anonymous$49 *p)
{
  pthread_cond_init(&p->cond, ((const union anonymous$53 *)NULL));
  pthread_mutex_init(&p->mutex, ((const union anonymous$53 *)NULL));
  return 0;
}

// zebra_mutex_cond_lock
// file zebra-lock.c line 192
signed int zebra_mutex_cond_lock(struct anonymous$49 *p)
{
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&p->mutex);
  return return_value_pthread_mutex_lock$1;
}

// zebra_mutex_cond_signal
// file zebra-lock.c line 219
signed int zebra_mutex_cond_signal(struct anonymous$49 *p)
{
  signed int return_value_pthread_cond_signal$1;
  return_value_pthread_cond_signal$1=pthread_cond_signal(&p->cond);
  return return_value_pthread_cond_signal$1;
}

// zebra_mutex_cond_unlock
// file zebra-lock.c line 201
signed int zebra_mutex_cond_unlock(struct anonymous$49 *p)
{
  signed int return_value_pthread_mutex_unlock$1;
  return_value_pthread_mutex_unlock$1=pthread_mutex_unlock(&p->mutex);
  return return_value_pthread_mutex_unlock$1;
}

// zebra_mutex_cond_wait
// file zebra-lock.c line 210
signed int zebra_mutex_cond_wait(struct anonymous$49 *p)
{
  signed int return_value_pthread_cond_wait$1;
  return_value_pthread_cond_wait$1=pthread_cond_wait(&p->cond, &p->mutex);
  return return_value_pthread_cond_wait$1;
}

// zebra_mutex_destroy
// file zebra-lock.c line 43
signed int zebra_mutex_destroy(struct anonymous$54 *p)
{
  p->state = p->state - 1;
  if(!(p->state == 0))
    fprintf(stderr, "zebra_mutex_destroy. state = %d\n", p->state);

  pthread_mutex_destroy(&p->mutex);
  return 0;
}

// zebra_mutex_init
// file zebra-lock.c line 31
signed int zebra_mutex_init(struct anonymous$54 *p)
{
  p->state = 1;
  pthread_mutex_init(&p->mutex, ((const union anonymous$53 *)NULL));
  return 0;
}

// zebra_mutex_lock
// file zebra-lock.c line 59
signed int zebra_mutex_lock(struct anonymous$54 *p)
{
  if(!(p->state == 1))
    fprintf(stderr, "zebra_mutex_lock. state = %d\n", p->state);

  pthread_mutex_lock(&p->mutex);
  return 0;
}

// zebra_mutex_unlock
// file zebra-lock.c line 74
signed int zebra_mutex_unlock(struct anonymous$54 *p)
{
  if(!(p->state == 1))
    fprintf(stderr, "zebra_mutex_unlock. state = %d\n", p->state);

  pthread_mutex_unlock(&p->mutex);
  return 0;
}

// zebra_parse_xpath_str
// file xpath.c line 162
signed int zebra_parse_xpath_str(const char *xpath_string, struct xpath_location_step *xpath, signed int max, struct nmem_control *mem)
{
  const char *cp;
  char *a;
  signed int no = 0;
  _Bool tmp_if_expr$1;
  if(xpath_string == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*xpath_string != 47 ? (_Bool)1 : (_Bool)0;
  char *return_value_strchr$2;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    cp = xpath_string;
    while(!(*cp == 0))
    {
      if(no >= max)
        break;

      signed int i = 0;
      for( ; !(*cp == 0); cp = cp + 1l)
      {
        return_value_strchr$2=strchr("/[", (signed int)*cp);
        if(!(return_value_strchr$2 == ((char *)NULL)))
          break;

        i = i + 1;
      }
      (xpath + (signed long int)no)->predicate = ((struct xpath_predicate *)NULL);
      void *return_value_nmem_malloc$3;
      return_value_nmem_malloc$3=nmem_malloc(mem, (unsigned long int)(i + 1));
      (xpath + (signed long int)no)->part = (char *)return_value_nmem_malloc$3;
      if(!(i == 0))
        memcpy((void *)(xpath + (signed long int)no)->part, (const void *)(cp - (signed long int)i), (unsigned long int)i);

      (xpath + (signed long int)no)->part[(signed long int)i] = (char)0;
      if((signed int)*cp == 91)
      {
        cp = cp + 1l;
        for( ; (signed int)*cp == 32; cp = cp + 1l)
          ;
        a = (char *)cp;
        (xpath + (signed long int)no)->predicate=get_xpath_predicate(a, mem);
        for( ; !(*cp == 0); cp = cp + 1l)
          if((signed int)*cp == 93)
            break;

        if((signed int)*cp == 93)
          cp = cp + 1l;

      }

      no = no + 1;
      if(!((signed int)*cp == 47))
        break;

      cp = cp + 1l;
    }
    return no;
  }
}

// zebra_prim_w
// file charmap.c line 239
unsigned int zebra_prim_w(unsigned int **s)
{
  unsigned int c;
  unsigned int i = (unsigned int)0;
  char fmtstr[8l];
  _Bool tmp_if_expr$4;
  if(*(*s) == 92u)
    tmp_if_expr$4 = (*s)[(signed long int)1] != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  signed int return_value_zebra_ucs4_strlen$1;
  signed int return_value_zebra_ucs4_strlen$2;
  signed int return_value_zebra_ucs4_strlen$3;
  if(tmp_if_expr$4)
  {
    *s = *s + 1l;
    c = *(*s);
    switch(c)
    {
      case (unsigned int)92:
      {
        c = (unsigned int)92;
        *s = *s + 1l;
        break;
      }
      case (unsigned int)114:
      {
        c = (unsigned int)13;
        *s = *s + 1l;
        break;
      }
      case (unsigned int)110:
      {
        c = (unsigned int)10;
        *s = *s + 1l;
        break;
      }
      case (unsigned int)116:
      {
        c = (unsigned int)9;
        *s = *s + 1l;
        break;
      }
      case (unsigned int)115:
      {
        c = (unsigned int)32;
        *s = *s + 1l;
        break;
      }
      case (unsigned int)120:
      {
        return_value_zebra_ucs4_strlen$1=zebra_ucs4_strlen(*s);
        if(return_value_zebra_ucs4_strlen$1 >= 3)
        {
          fmtstr[(signed long int)0] = (char)(*s)[(signed long int)1];
          fmtstr[(signed long int)1] = (char)(*s)[(signed long int)2];
          fmtstr[(signed long int)2] = (char)0;
          sscanf(fmtstr, "%x", &i);
          c = i;
          *s = *s + (signed long int)3;
        }

        break;
      }
      case (unsigned int)48:

      case (unsigned int)49:

      case (unsigned int)50:

      case (unsigned int)51:

      case (unsigned int)52:

      case (unsigned int)53:

      case (unsigned int)54:

      case (unsigned int)55:

      case (unsigned int)56:

      case (unsigned int)57:
      {
        return_value_zebra_ucs4_strlen$2=zebra_ucs4_strlen(*s);
        if(return_value_zebra_ucs4_strlen$2 >= 3)
        {
          fmtstr[(signed long int)0] = (char)(*s)[(signed long int)0];
          fmtstr[(signed long int)1] = (char)(*s)[(signed long int)1];
          fmtstr[(signed long int)2] = (char)(*s)[(signed long int)2];
          fmtstr[(signed long int)3] = (char)0;
          sscanf(fmtstr, "%o", &i);
          c = i;
          *s = *s + (signed long int)3;
        }

        break;
      }
      case (unsigned int)76:
      {
        return_value_zebra_ucs4_strlen$3=zebra_ucs4_strlen(*s);
        if(return_value_zebra_ucs4_strlen$3 >= 5)
        {
          fmtstr[(signed long int)0] = (char)(*s)[(signed long int)1];
          fmtstr[(signed long int)1] = (char)(*s)[(signed long int)2];
          fmtstr[(signed long int)2] = (char)(*s)[(signed long int)3];
          fmtstr[(signed long int)3] = (char)(*s)[(signed long int)4];
          fmtstr[(signed long int)4] = (char)0;
          sscanf(fmtstr, "%x", &i);
          c = i;
          *s = *s + (signed long int)5;
        }

        break;
      }
      default:
        *s = *s + 1l;
    }
  }

  else
  {
    c = *(*s);
    *s = *s + 1l;
  }
  yaz_log(0x00000002, "out %d", c);
  return c;
}

// zebra_replace
// file zebramap.c line 618
struct wrbuf * zebra_replace(struct zebra_map *zm, const char *ex_list, const char *input_str, signed int input_len)
{
  wrbuf_rewind(zm->zebra_maps->wrbuf_1);
  wrbuf_write(zm->zebra_maps->wrbuf_1, input_str, (unsigned long int)input_len);
  return zm->zebra_maps->wrbuf_1;
}

// zebra_snippets_append
// file snippet.c line 51
void zebra_snippets_append(struct zebra_snippets *l, signed long long int seqno, signed int ws, signed int ord, const char *term)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(term);
  zebra_snippets_append_match(l, seqno, ws, ord, term, return_value_strlen$1, 0);
}

// zebra_snippets_append_match
// file snippet.c line 65
void zebra_snippets_append_match(struct zebra_snippets *l, signed long long int seqno, signed int ws, signed int ord, const char *term, unsigned long int term_len, signed int match)
{
  struct zebra_snippet_word *w;
  void *return_value_nmem_malloc$1;
  return_value_nmem_malloc$1=nmem_malloc(l->nmem, sizeof(struct zebra_snippet_word) /*56ul*/ );
  w = (struct zebra_snippet_word *)return_value_nmem_malloc$1;
  w->next = ((struct zebra_snippet_word *)NULL);
  w->prev = l->tail;
  if(!(l->tail == ((struct zebra_snippet_word *)NULL)))
    l->tail->next = w;

  else
    l->front = w;
  l->tail = w;
  w->seqno = seqno;
  w->ws = ws;
  w->ord = ord;
  void *return_value_nmem_malloc$2;
  return_value_nmem_malloc$2=nmem_malloc(l->nmem, term_len + (unsigned long int)1);
  w->term = (char *)return_value_nmem_malloc$2;
  memcpy((void *)w->term, (const void *)term, term_len);
  w->term[(signed long int)term_len] = (char)0;
  w->match = match;
  w->mark = 0;
}

// zebra_snippets_appendn
// file snippet.c line 57
void zebra_snippets_appendn(struct zebra_snippets *l, signed long long int seqno, signed int ws, signed int ord, const char *term, unsigned long int term_len)
{
  zebra_snippets_append_match(l, seqno, ws, ord, term, term_len, 0);
}

// zebra_snippets_clear
// file snippet.c line 207
static void zebra_snippets_clear(struct zebra_snippets *sn)
{
  struct zebra_snippet_word *w;
  w=zebra_snippets_list(sn);
  for( ; !(w == ((struct zebra_snippet_word *)NULL)); w = w->next)
  {
    w->mark = 0;
    w->match = 0;
  }
}

// zebra_snippets_constlist
// file snippet.c line 99
const struct zebra_snippet_word * zebra_snippets_constlist(const struct zebra_snippets *l)
{
  return l->front;
}

// zebra_snippets_create
// file snippet.c line 36
struct zebra_snippets * zebra_snippets_create(void)
{
  struct nmem_control *nmem;
  nmem=nmem_create();
  struct zebra_snippets *l;
  void *return_value_nmem_malloc$1;
  return_value_nmem_malloc$1=nmem_malloc(nmem, sizeof(struct zebra_snippets) /*24ul*/ );
  l = (struct zebra_snippets *)return_value_nmem_malloc$1;
  l->nmem = nmem;
  l->tail = ((struct zebra_snippet_word *)NULL);
  l->front = l->tail;
  return l;
}

// zebra_snippets_destroy
// file snippet.c line 45
void zebra_snippets_destroy(struct zebra_snippets *l)
{
  if(!(l == ((struct zebra_snippets *)NULL)))
    nmem_destroy(l->nmem);

}

// zebra_snippets_list
// file snippet.c line 94
struct zebra_snippet_word * zebra_snippets_list(struct zebra_snippets *l)
{
  return l->front;
}

// zebra_snippets_log
// file snippet.c line 104
void zebra_snippets_log(const struct zebra_snippets *l, signed int log_level, signed int all)
{
  struct zebra_snippet_word *w = l->front;
  _Bool tmp_if_expr$3;
  const char *return_value_wrbuf_cstr$1;
  _Bool tmp_if_expr$2;
  for( ; !(w == ((struct zebra_snippet_word *)NULL)); w = w->next)
  {
    struct wrbuf *wr_term;
    wr_term=wrbuf_alloc();
    wrbuf_puts_escaped(wr_term, w->term);
    if(!(all == 0))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = w->mark != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_wrbuf_cstr$1=wrbuf_cstr(wr_term);
      if(!(w->match == 0))
        tmp_if_expr$2 = !(w->ws != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      yaz_log(log_level, "term='%s'%s mark=%d seqno=%lld ord=%d", return_value_wrbuf_cstr$1, tmp_if_expr$2 ? "*" : "", w->mark, w->seqno, w->ord);
    }

    wrbuf_destroy(wr_term);
  }
}

// zebra_snippets_lookup
// file snippet.c line 218
struct zebra_snippet_word * zebra_snippets_lookup(const struct zebra_snippets *doc, const struct zebra_snippets *hit)
{
  const struct zebra_snippet_word *hit_w;
  hit_w=zebra_snippets_constlist(hit);
  for( ; !(hit_w == ((const struct zebra_snippet_word *)NULL)); hit_w = hit_w->next)
  {
    const struct zebra_snippet_word *doc_w;
    doc_w=zebra_snippets_constlist(doc);
    for( ; !(doc_w == ((const struct zebra_snippet_word *)NULL)); doc_w = doc_w->next)
      if(doc_w->ord == hit_w->ord)
      {
        if(doc_w->seqno == hit_w->seqno)
        {
          if(doc_w->ws == 0)
            return doc_w;

        }

      }

  }
  return ((struct zebra_snippet_word *)NULL);
}

// zebra_snippets_ring
// file snippet.c line 237
void zebra_snippets_ring(struct zebra_snippets *doc, const struct zebra_snippets *hit, signed int before, signed int after)
{
  signed int ord = -1;
  zebra_snippets_clear(doc);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  while((_Bool)1)
  {
    const struct zebra_snippet_word *hit_w;
    struct zebra_snippet_word *doc_w;
    signed int min_ord = 0;
    hit_w=zebra_snippets_constlist(hit);
    for( ; !(hit_w == ((const struct zebra_snippet_word *)NULL)); hit_w = hit_w->next)
      if(!(ord >= hit_w->ord))
      {
        if(min_ord == 0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = hit_w->ord < min_ord ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          min_ord = hit_w->ord;

      }

    if(min_ord == 0)
      break;

    ord = min_ord;
    hit_w=zebra_snippets_constlist(hit);
    for( ; !(hit_w == ((const struct zebra_snippet_word *)NULL)); hit_w = hit_w->next)
      if(hit_w->ord == ord)
      {
        doc_w=zebra_snippets_list(doc);
        for( ; !(doc_w == ((struct zebra_snippet_word *)NULL)); doc_w = doc_w->next)
          if(doc_w->ord == ord)
          {
            if(doc_w->seqno == hit_w->seqno)
            {
              if(doc_w->ws == 0)
              {
                doc_w->match = 1;
                doc_w->mark = 1;
                break;
              }

            }

          }

        if(!(doc_w == ((struct zebra_snippet_word *)NULL)))
        {
          struct zebra_snippet_word *w = doc_w->next;
          while(!(w == ((struct zebra_snippet_word *)NULL)))
          {
            if(w->ord == ord)
              tmp_if_expr$2 = hit_w->seqno - (signed long int)before < w->seqno ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(tmp_if_expr$2)
              tmp_if_expr$3 = hit_w->seqno + (signed long int)after > w->seqno ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(tmp_if_expr$3)
            {
              w->mark = 1;
              w = w->next;
            }

            else
              break;
          }
        }

        if(!(doc_w == ((struct zebra_snippet_word *)NULL)))
        {
          struct zebra_snippet_word *zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w = doc_w->prev;
          while(!(zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w == ((struct zebra_snippet_word *)NULL)))
          {
            if(zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w->ord == ord)
              tmp_if_expr$4 = hit_w->seqno - (signed long int)before < zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w->seqno ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(tmp_if_expr$4)
              tmp_if_expr$5 = hit_w->seqno + (signed long int)after > zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w->seqno ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
            {
              zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w->mark = 1;
              zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w = zebra_snippets_ring$$1$$1$$2$$1$$1$$3$$w->prev;
            }

            else
              break;
          }
        }

      }

  }
}

// zebra_snippets_window
// file snippet.c line 121
struct zebra_snippets * zebra_snippets_window(const struct zebra_snippets *doc, const struct zebra_snippets *hit, signed int window_size)
{
  signed int ord = -1;
  struct zebra_snippets *result;
  result=zebra_snippets_create();
  if(window_size == 0)
    window_size = 1000000;

  _Bool tmp_if_expr$1;
  while((_Bool)1)
  {
    signed long long int window_start;
    signed long long int first_seq_no_best_window = (signed long long int)0;
    signed long long int last_seq_no_best_window = (signed long long int)0;
    signed int number_best_window = 0;
    const struct zebra_snippet_word *hit_w;
    const struct zebra_snippet_word *doc_w;
    signed int min_ord = 0;
    hit_w=zebra_snippets_constlist(hit);
    for( ; !(hit_w == ((const struct zebra_snippet_word *)NULL)); hit_w = hit_w->next)
      if(!(ord >= hit_w->ord))
      {
        if(min_ord == 0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = hit_w->ord < min_ord ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          min_ord = hit_w->ord;

      }

    if(min_ord == 0)
      break;

    ord = min_ord;
    hit_w=zebra_snippets_constlist(hit);
    for( ; !(hit_w == ((const struct zebra_snippet_word *)NULL)); hit_w = hit_w->next)
      if(hit_w->ord == ord)
      {
        const struct zebra_snippet_word *look_w = hit_w;
        signed int number_this = 0;
        signed long long int seq_no_last = (signed long long int)0;
        for( ; !(look_w == ((const struct zebra_snippet_word *)NULL)); look_w = look_w->next)
        {
          if(look_w->seqno >= hit_w->seqno + (signed long int)window_size)
            break;

          if(look_w->ord == ord)
          {
            seq_no_last = look_w->seqno;
            number_this = number_this + 1;
          }

        }
        if(!(number_best_window >= number_this))
        {
          number_best_window = number_this;
          first_seq_no_best_window = hit_w->seqno;
          last_seq_no_best_window = seq_no_last;
        }

      }

    yaz_log(0x00000002, "ord=%d", ord);
    yaz_log(0x00000002, "first_seq_no_best_window=%lld", first_seq_no_best_window);
    yaz_log(0x00000002, "last_seq_no_best_window=%lld", last_seq_no_best_window);
    yaz_log(0x00000002, "number_best_window=%d", number_best_window);
    window_start = ((first_seq_no_best_window + last_seq_no_best_window) - (signed long int)window_size) / (signed long int)2;
    doc_w=zebra_snippets_constlist(doc);
    for( ; !(doc_w == ((const struct zebra_snippet_word *)NULL)); doc_w = doc_w->next)
      if(doc_w->ord == ord)
      {
        if(doc_w->seqno >= window_start)
        {
          if(!(doc_w->seqno >= window_start + (signed long int)window_size))
          {
            signed int match = 0;
            hit_w=zebra_snippets_constlist(hit);
            for( ; !(hit_w == ((const struct zebra_snippet_word *)NULL)); hit_w = hit_w->next)
              if(hit_w->ord == ord)
              {
                if(hit_w->seqno == doc_w->seqno)
                {
                  match = 1;
                  break;
                }

              }

            unsigned long int return_value_strlen$2;
            return_value_strlen$2=strlen(doc_w->term);
            zebra_snippets_append_match(result, doc_w->seqno, doc_w->ws, ord, doc_w->term, return_value_strlen$2, match);
          }

        }

      }

  }
  return result;
}

// zebra_strmap_add
// file strmap.c line 80
void zebra_strmap_add(struct zebra_strmap *st, const char *name, void *data_buf, unsigned long int data_len)
{
  struct strmap_entry **e;
  e=hash(st, name);
  struct strmap_entry *ne = st->free_entries;
  void *return_value_nmem_malloc$1;
  if(!(ne == ((struct strmap_entry *)NULL)))
    st->free_entries = ne->next;

  else
  {
    return_value_nmem_malloc$1=nmem_malloc(st->nmem_ent, sizeof(struct strmap_entry) /*32ul*/ );
    ne = (struct strmap_entry *)return_value_nmem_malloc$1;
  }
  ne->next = *e;
  *e = ne;
  ne->name=nmem_strdup(st->nmem_str, name);
  ne->data_buf=nmem_malloc(st->nmem_str, data_len);
  memcpy(ne->data_buf, data_buf, data_len);
  ne->data_len = data_len;
  st->size = st->size + 1;
}

// zebra_strmap_create
// file strmap.c line 45
struct zebra_strmap * zebra_strmap_create(void)
{
  signed int i;
  struct nmem_control *nmem_ent;
  nmem_ent=nmem_create();
  struct zebra_strmap *st;
  void *return_value_nmem_malloc$1;
  return_value_nmem_malloc$1=nmem_malloc(nmem_ent, sizeof(struct zebra_strmap) /*40ul*/ );
  st = (struct zebra_strmap *)return_value_nmem_malloc$1;
  st->nmem_ent = nmem_ent;
  st->nmem_str=nmem_create();
  st->hsize = 1001;
  st->size = 0;
  st->free_entries = ((struct strmap_entry *)NULL);
  void *return_value_nmem_malloc$2;
  return_value_nmem_malloc$2=nmem_malloc(nmem_ent, (unsigned long int)st->hsize * sizeof(struct strmap_entry *) /*8ul*/ );
  st->entries = (struct strmap_entry **)return_value_nmem_malloc$2;
  i = 0;
  for( ; !(i >= st->hsize); i = i + 1)
    st->entries[(signed long int)i] = ((struct strmap_entry *)NULL);
  return st;
}

// zebra_strmap_destroy
// file strmap.c line 61
void zebra_strmap_destroy(struct zebra_strmap *st)
{
  if(!(st == ((struct zebra_strmap *)NULL)))
  {
    nmem_destroy(st->nmem_str);
    nmem_destroy(st->nmem_ent);
  }

}

// zebra_strmap_get_size
// file strmap.c line 136
signed int zebra_strmap_get_size(struct zebra_strmap *st)
{
  return st->size;
}

// zebra_strmap_it_create
// file strmap.c line 148
struct zebra_strmap_it_s * zebra_strmap_it_create(struct zebra_strmap *st)
{
  struct zebra_strmap_it_s *it;
  void *return_value_xmalloc_f$1;
  return_value_xmalloc_f$1=xmalloc_f(sizeof(struct zebra_strmap_it_s) /*24ul*/ , "strmap.c", 150);
  it = (struct zebra_strmap_it_s *)return_value_xmalloc_f$1;
  it->hno = 0;
  it->ent = ((struct strmap_entry *)NULL);
  it->st = st;
  return it;
}

// zebra_strmap_it_destroy
// file strmap.c line 157
void zebra_strmap_it_destroy(struct zebra_strmap_it_s *it)
{
  xfree_f((void *)it, "strmap.c", 159);
}

// zebra_strmap_it_next
// file strmap.c line 162
const char * zebra_strmap_it_next(struct zebra_strmap_it_s *it, void **data_buf, unsigned long int *data_len)
{
  struct strmap_entry *ent = ((struct strmap_entry *)NULL);
  for( ; it->ent == ((struct strmap_entry *)NULL); it->hno = it->hno + 1)
  {
    if(it->hno >= it->st->hsize)
      break;

    it->ent = it->st->entries[(signed long int)it->hno];
  }
  if(!(it->ent == ((struct strmap_entry *)NULL)))
  {
    ent = it->ent;
    it->ent = ent->next;
  }

  if(!(ent == ((struct strmap_entry *)NULL)))
  {
    if(!(data_buf == ((void **)NULL)))
      *data_buf = ent->data_buf;

    if(!(data_len == ((unsigned long int *)NULL)))
      *data_len = ent->data_len;

    return ent->name;
  }

  else
    return ((const char *)NULL);
}

// zebra_strmap_lookup
// file strmap.c line 99
void * zebra_strmap_lookup(struct zebra_strmap *st, const char *name, signed int no, unsigned long int *data_len)
{
  struct strmap_entry *e;
  struct strmap_entry **return_value_hash$1;
  return_value_hash$1=hash(st, name);
  e = *return_value_hash$1;
  signed int i = 0;
  signed int return_value_strcmp$2;
  for( ; !(e == ((struct strmap_entry *)NULL)); e = e->next)
  {
    return_value_strcmp$2=strcmp(name, e->name);
    if(return_value_strcmp$2 == 0)
    {
      if(i == no)
      {
        if(!(data_len == ((unsigned long int *)NULL)))
          *data_len = e->data_len;

        return e->data_buf;
      }

      i = i + 1;
    }

  }
  return NULL;
}

// zebra_strmap_remove
// file strmap.c line 118
signed int zebra_strmap_remove(struct zebra_strmap *st, const char *name)
{
  struct strmap_entry **e;
  e=hash(st, name);
  signed int return_value_strcmp$1;
  for( ; !(*e == ((struct strmap_entry *)NULL)); e = &(*e)->next)
  {
    return_value_strcmp$1=strcmp(name, (*e)->name);
    if(return_value_strcmp$1 == 0)
    {
      struct strmap_entry *tmp = *e;
      *e = (*e)->next;
      tmp->next = st->free_entries;
      st->free_entries = tmp;
      st->size = st->size - 1;
      return 1;
    }

  }
  return 0;
}

// zebra_ucs4_strlen
// file charmap.c line 231
static signed int zebra_ucs4_strlen(unsigned int *s)
{
  signed int i = 0;
  unsigned int *tmp_post$1;
  do
  {
    tmp_post$1 = s;
    s = s + 1l;
    if(*tmp_post$1 == 0u)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  return i;
}

// zebra_unlock
// file ../include/idzebra/flock.h line 36
signed int zebra_unlock(struct zebra_lock_handle *h)
{
  signed int r = 0;
  yaz_log(log_level, "zebra_unlock fd=%d p=%p fname=%s begin", h->p->fd, h, h->p->fname);
  zebra_mutex_lock(&h->p->file_mutex);
  if(!(h->write_flag == 0))
  {
    if(h->p->no_file_write_lock >= 1)
      h->p->no_file_write_lock = h->p->no_file_write_lock - 1;

  }

  else
    if(h->p->no_file_read_lock >= 1)
      h->p->no_file_read_lock = h->p->no_file_read_lock - 1;

  _Bool tmp_if_expr$1;
  if(h->p->no_file_read_lock == 0)
    tmp_if_expr$1 = h->p->no_file_write_lock == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    r=unixLock(h->p->fd, 2, 7);

  else
  {
    r = 0;
    /* assertion posix_locks */
    assert(posix_locks != 0);
  }
  zebra_mutex_unlock(&h->p->file_mutex);
  if(!(posix_locks == 0))
  {
    if(!(h->write_flag == 0))
      zebra_lock_rdwr_wunlock(&h->p->rdwr_lock);

    else
      zebra_lock_rdwr_runlock(&h->p->rdwr_lock);
  }

  yaz_log(log_level, "zebra_unlock fd=%d p=%p fname=%s end", h->p->fd, h, h->p->fname);
  return r;
}

// zebra_zint_decode
// file zint.c line 39
void zebra_zint_decode(const char **src, signed long long int *pos)
{
  const unsigned char **bp = (const unsigned char **)src;
  signed long long int d = (signed long long int)0;
  unsigned char c;
  unsigned int r = (unsigned int)0;
  const unsigned char *tmp_post$1;
  do
  {
    tmp_post$1 = *bp;
    *bp = *bp + 1l;
    c = *tmp_post$1;
    if((128 & (signed int)c) == 0)
      break;

    d = d + ((signed long long int)((signed int)c & 127) << r);
    r = r + (unsigned int)7;
  }
  while((_Bool)1);
  d = d + ((signed long long int)c << r);
  *pos = d;
}

// zebra_zint_encode
// file zint.c line 26
void zebra_zint_encode(char **dst, signed long long int pos)
{
  unsigned char *bp = (unsigned char *)*dst;
  unsigned char *tmp_post$1;
  for( ; pos >= 128l; pos = pos >> 7)
  {
    tmp_post$1 = bp;
    bp = bp + 1l;
    *tmp_post$1 = (unsigned char)((signed long int)128 | pos & (signed long int)127);
  }
  unsigned char *tmp_post$2 = bp;
  bp = bp + 1l;
  *tmp_post$2 = (unsigned char)pos;
  *dst = (char *)bp;
}

