// #anon_enum$ATK_LAYER_INVALID=0$ATK_LAYER_BACKGROUND=1$ATK_LAYER_CANVAS=2$ATK_LAYER_WIDGET=3$ATK_LAYER_MDI=4$ATK_LAYER_POPUP=5$ATK_LAYER_OVERLAY=6$ATK_LAYER_WINDOW=7
// file /usr/include/atk-1.0/atk/atkobject.h line 376
enum anonymous$7 { ATK_LAYER_INVALID=0, ATK_LAYER_BACKGROUND=1, ATK_LAYER_CANVAS=2, ATK_LAYER_WIDGET=3, ATK_LAYER_MDI=4, ATK_LAYER_POPUP=5, ATK_LAYER_OVERLAY=6, ATK_LAYER_WINDOW=7 };

// #anon_enum$ATK_ROLE_INVALID=0$ATK_ROLE_ACCEL_LABEL=1$ATK_ROLE_ALERT=2$ATK_ROLE_ANIMATION=3$ATK_ROLE_ARROW=4$ATK_ROLE_CALENDAR=5$ATK_ROLE_CANVAS=6$ATK_ROLE_CHECK_BOX=7$ATK_ROLE_CHECK_MENU_ITEM=8$ATK_ROLE_COLOR_CHOOSER=9$ATK_ROLE_COLUMN_HEADER=10$ATK_ROLE_COMBO_BOX=11$ATK_ROLE_DATE_EDITOR=12$ATK_ROLE_DESKTOP_ICON=13$ATK_ROLE_DESKTOP_FRAME=14$ATK_ROLE_DIAL=15$ATK_ROLE_DIALOG=16$ATK_ROLE_DIRECTORY_PANE=17$ATK_ROLE_DRAWING_AREA=18$ATK_ROLE_FILE_CHOOSER=19$ATK_ROLE_FILLER=20$ATK_ROLE_FONT_CHOOSER=21$ATK_ROLE_FRAME=22$ATK_ROLE_GLASS_PANE=23$ATK_ROLE_HTML_CONTAINER=24$ATK_ROLE_ICON=25$ATK_ROLE_IMAGE=26$ATK_ROLE_INTERNAL_FRAME=27$ATK_ROLE_LABEL=28$ATK_ROLE_LAYERED_PANE=29$ATK_ROLE_LIST=30$ATK_ROLE_LIST_ITEM=31$ATK_ROLE_MENU=32$ATK_ROLE_MENU_BAR=33$ATK_ROLE_MENU_ITEM=34$ATK_ROLE_OPTION_PANE=35$ATK_ROLE_PAGE_TAB=36$ATK_ROLE_PAGE_TAB_LIST=37$ATK_ROLE_PANEL=38$ATK_ROLE_PASSWORD_TEXT=39$ATK_ROLE_POPUP_MENU=40$ATK_ROLE_PROGRESS_BAR=41$ATK_ROLE_PUSH_BUTTON=42$ATK_ROLE_RADIO_BUTTON=43$ATK_ROLE_RADIO_MENU_ITEM=44$ATK_ROLE_ROOT_PANE=45$ATK_ROLE_ROW_HEADER=46$ATK_ROLE_SCROLL_BAR=47$ATK_ROLE_SCROLL_PANE=48$ATK_ROLE_SEPARATOR=49$ATK_ROLE_SLIDER=50$ATK_ROLE_SPLIT_PANE=51$ATK_ROLE_SPIN_BUTTON=52$ATK_ROLE_STATUSBAR=53$ATK_ROLE_TABLE=54$ATK_ROLE_TABLE_CELL=55$ATK_ROLE_TABLE_COLUMN_HEADER=56$ATK_ROLE_TABLE_ROW_HEADER=57$ATK_ROLE_TEAR_OFF_MENU_ITEM=58$ATK_ROLE_TERMINAL=59$ATK_ROLE_TEXT=60$ATK_ROLE_TOGGLE_BUTTON=61$ATK_ROLE_TOOL_BAR=62$ATK_ROLE_TOOL_TIP=63$ATK_ROLE_TREE=64$ATK_ROLE_TREE_TABLE=65$ATK_ROLE_UNKNOWN=66$ATK_ROLE_VIEWPORT=67$ATK_ROLE_WINDOW=68$ATK_ROLE_HEADER=69$ATK_ROLE_FOOTER=70$ATK_ROLE_PARAGRAPH=71$ATK_ROLE_RULER=72$ATK_ROLE_APPLICATION=73$ATK_ROLE_AUTOCOMPLETE=74$ATK_ROLE_EDITBAR=75$ATK_ROLE_EMBEDDED=76$ATK_ROLE_ENTRY=77$ATK_ROLE_CHART=78$ATK_ROLE_CAPTION=79$ATK_ROLE_DOCUMENT_FRAME=80$ATK_ROLE_HEADING=81$ATK_ROLE_PAGE=82$ATK_ROLE_SECTION=83$ATK_ROLE_REDUNDANT_OBJECT=84$ATK_ROLE_FORM=85$ATK_ROLE_LINK=86$ATK_ROLE_INPUT_METHOD_WINDOW=87$ATK_ROLE_TABLE_ROW=88$ATK_ROLE_TREE_ITEM=89$ATK_ROLE_DOCUMENT_SPREADSHEET=90$ATK_ROLE_DOCUMENT_PRESENTATION=91$ATK_ROLE_DOCUMENT_TEXT=92$ATK_ROLE_DOCUMENT_WEB=93$ATK_ROLE_DOCUMENT_EMAIL=94$ATK_ROLE_COMMENT=95$ATK_ROLE_LIST_BOX=96$ATK_ROLE_GROUPING=97$ATK_ROLE_IMAGE_MAP=98$ATK_ROLE_NOTIFICATION=99$ATK_ROLE_INFO_BAR=100$ATK_ROLE_LEVEL_BAR=101$ATK_ROLE_TITLE_BAR=102$ATK_ROLE_BLOCK_QUOTE=103$ATK_ROLE_AUDIO=104$ATK_ROLE_VIDEO=105$ATK_ROLE_DEFINITION=106$ATK_ROLE_ARTICLE=107$ATK_ROLE_LANDMARK=108$ATK_ROLE_LOG=109$ATK_ROLE_MARQUEE=110$ATK_ROLE_MATH=111$ATK_ROLE_RATING=112$ATK_ROLE_TIMER=113$ATK_ROLE_DESCRIPTION_LIST=114$ATK_ROLE_DESCRIPTION_TERM=115$ATK_ROLE_DESCRIPTION_VALUE=116$ATK_ROLE_STATIC=117$ATK_ROLE_MATH_FRACTION=118$ATK_ROLE_MATH_ROOT=119$ATK_ROLE_SUBSCRIPT=120$ATK_ROLE_SUPERSCRIPT=121$ATK_ROLE_LAST_DEFINED=122
// file /usr/include/atk-1.0/atk/atkobject.h line 232
enum anonymous$6 { ATK_ROLE_INVALID=0, ATK_ROLE_ACCEL_LABEL=1, ATK_ROLE_ALERT=2, ATK_ROLE_ANIMATION=3, ATK_ROLE_ARROW=4, ATK_ROLE_CALENDAR=5, ATK_ROLE_CANVAS=6, ATK_ROLE_CHECK_BOX=7, ATK_ROLE_CHECK_MENU_ITEM=8, ATK_ROLE_COLOR_CHOOSER=9, ATK_ROLE_COLUMN_HEADER=10, ATK_ROLE_COMBO_BOX=11, ATK_ROLE_DATE_EDITOR=12, ATK_ROLE_DESKTOP_ICON=13, ATK_ROLE_DESKTOP_FRAME=14, ATK_ROLE_DIAL=15, ATK_ROLE_DIALOG=16, ATK_ROLE_DIRECTORY_PANE=17, ATK_ROLE_DRAWING_AREA=18, ATK_ROLE_FILE_CHOOSER=19, ATK_ROLE_FILLER=20, ATK_ROLE_FONT_CHOOSER=21, ATK_ROLE_FRAME=22, ATK_ROLE_GLASS_PANE=23, ATK_ROLE_HTML_CONTAINER=24, ATK_ROLE_ICON=25, ATK_ROLE_IMAGE=26, ATK_ROLE_INTERNAL_FRAME=27, ATK_ROLE_LABEL=28, ATK_ROLE_LAYERED_PANE=29, ATK_ROLE_LIST=30, ATK_ROLE_LIST_ITEM=31, ATK_ROLE_MENU=32, ATK_ROLE_MENU_BAR=33, ATK_ROLE_MENU_ITEM=34, ATK_ROLE_OPTION_PANE=35, ATK_ROLE_PAGE_TAB=36, ATK_ROLE_PAGE_TAB_LIST=37, ATK_ROLE_PANEL=38, ATK_ROLE_PASSWORD_TEXT=39, ATK_ROLE_POPUP_MENU=40, ATK_ROLE_PROGRESS_BAR=41, ATK_ROLE_PUSH_BUTTON=42, ATK_ROLE_RADIO_BUTTON=43, ATK_ROLE_RADIO_MENU_ITEM=44, ATK_ROLE_ROOT_PANE=45, ATK_ROLE_ROW_HEADER=46, ATK_ROLE_SCROLL_BAR=47, ATK_ROLE_SCROLL_PANE=48, ATK_ROLE_SEPARATOR=49, ATK_ROLE_SLIDER=50, ATK_ROLE_SPLIT_PANE=51, ATK_ROLE_SPIN_BUTTON=52, ATK_ROLE_STATUSBAR=53, ATK_ROLE_TABLE=54, ATK_ROLE_TABLE_CELL=55, ATK_ROLE_TABLE_COLUMN_HEADER=56, ATK_ROLE_TABLE_ROW_HEADER=57, ATK_ROLE_TEAR_OFF_MENU_ITEM=58, ATK_ROLE_TERMINAL=59, ATK_ROLE_TEXT=60, ATK_ROLE_TOGGLE_BUTTON=61, ATK_ROLE_TOOL_BAR=62, ATK_ROLE_TOOL_TIP=63, ATK_ROLE_TREE=64, ATK_ROLE_TREE_TABLE=65, ATK_ROLE_UNKNOWN=66, ATK_ROLE_VIEWPORT=67, ATK_ROLE_WINDOW=68, ATK_ROLE_HEADER=69, ATK_ROLE_FOOTER=70, ATK_ROLE_PARAGRAPH=71, ATK_ROLE_RULER=72, ATK_ROLE_APPLICATION=73, ATK_ROLE_AUTOCOMPLETE=74, ATK_ROLE_EDITBAR=75, ATK_ROLE_EMBEDDED=76, ATK_ROLE_ENTRY=77, ATK_ROLE_CHART=78, ATK_ROLE_CAPTION=79, ATK_ROLE_DOCUMENT_FRAME=80, ATK_ROLE_HEADING=81, ATK_ROLE_PAGE=82, ATK_ROLE_SECTION=83, ATK_ROLE_REDUNDANT_OBJECT=84, ATK_ROLE_FORM=85, ATK_ROLE_LINK=86, ATK_ROLE_INPUT_METHOD_WINDOW=87, ATK_ROLE_TABLE_ROW=88, ATK_ROLE_TREE_ITEM=89, ATK_ROLE_DOCUMENT_SPREADSHEET=90, ATK_ROLE_DOCUMENT_PRESENTATION=91, ATK_ROLE_DOCUMENT_TEXT=92, ATK_ROLE_DOCUMENT_WEB=93, ATK_ROLE_DOCUMENT_EMAIL=94, ATK_ROLE_COMMENT=95, ATK_ROLE_LIST_BOX=96, ATK_ROLE_GROUPING=97, ATK_ROLE_IMAGE_MAP=98, ATK_ROLE_NOTIFICATION=99, ATK_ROLE_INFO_BAR=100, ATK_ROLE_LEVEL_BAR=101, ATK_ROLE_TITLE_BAR=102, ATK_ROLE_BLOCK_QUOTE=103, ATK_ROLE_AUDIO=104, ATK_ROLE_VIDEO=105, ATK_ROLE_DEFINITION=106, ATK_ROLE_ARTICLE=107, ATK_ROLE_LANDMARK=108, ATK_ROLE_LOG=109, ATK_ROLE_MARQUEE=110, ATK_ROLE_MATH=111, ATK_ROLE_RATING=112, ATK_ROLE_TIMER=113, ATK_ROLE_DESCRIPTION_LIST=114, ATK_ROLE_DESCRIPTION_TERM=115, ATK_ROLE_DESCRIPTION_VALUE=116, ATK_ROLE_STATIC=117, ATK_ROLE_MATH_FRACTION=118, ATK_ROLE_MATH_ROOT=119, ATK_ROLE_SUBSCRIPT=120, ATK_ROLE_SUPERSCRIPT=121, ATK_ROLE_LAST_DEFINED=122 };

// #anon_enum$GCONF_CLIENT_HANDLE_NONE=0$GCONF_CLIENT_HANDLE_UNRETURNED=1$GCONF_CLIENT_HANDLE_ALL=2
// file /usr/include/gconf/2/gconf/gconf-client.h line 63
enum anonymous$105 { GCONF_CLIENT_HANDLE_NONE=0, GCONF_CLIENT_HANDLE_UNRETURNED=1, GCONF_CLIENT_HANDLE_ALL=2 };

// #anon_enum$GCONF_CLIENT_PRELOAD_NONE=0$GCONF_CLIENT_PRELOAD_ONELEVEL=1$GCONF_CLIENT_PRELOAD_RECURSIVE=2
// file /usr/include/gconf/2/gconf/gconf-client.h line 57
enum anonymous$63 { GCONF_CLIENT_PRELOAD_NONE=0, GCONF_CLIENT_PRELOAD_ONELEVEL=1, GCONF_CLIENT_PRELOAD_RECURSIVE=2 };

// #anon_enum$GCONF_VALUE_INVALID=0$GCONF_VALUE_STRING=1$GCONF_VALUE_INT=2$GCONF_VALUE_FLOAT=3$GCONF_VALUE_BOOL=4$GCONF_VALUE_SCHEMA=5$GCONF_VALUE_LIST=6$GCONF_VALUE_PAIR=7
// file /usr/include/gconf/2/gconf/gconf-value.h line 34
enum anonymous$62 { GCONF_VALUE_INVALID=0, GCONF_VALUE_STRING=1, GCONF_VALUE_INT=2, GCONF_VALUE_FLOAT=3, GCONF_VALUE_BOOL=4, GCONF_VALUE_SCHEMA=5, GCONF_VALUE_LIST=6, GCONF_VALUE_PAIR=7 };

// #anon_enum$GDK_ACTION_DEFAULT=1$GDK_ACTION_COPY=2$GDK_ACTION_MOVE=4$GDK_ACTION_LINK=8$GDK_ACTION_PRIVATE=16$GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous$43 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum$GDK_AXIS_IGNORE=0$GDK_AXIS_X=1$GDK_AXIS_Y=2$GDK_AXIS_PRESSURE=3$GDK_AXIS_XTILT=4$GDK_AXIS_YTILT=5$GDK_AXIS_WHEEL=6$GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous$45 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum$GDK_COLORSPACE_RGB=0
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 140
enum anonymous$84 { GDK_COLORSPACE_RGB=0 };

// #anon_enum$GDK_CROSSING_NORMAL=0$GDK_CROSSING_GRAB=1$GDK_CROSSING_UNGRAB=2$GDK_CROSSING_GTK_GRAB=3$GDK_CROSSING_GTK_UNGRAB=4$GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous$51 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum$GDK_DRAG_PROTO_MOTIF=0$GDK_DRAG_PROTO_XDND=1$GDK_DRAG_PROTO_ROOTWIN=2$GDK_DRAG_PROTO_NONE=3$GDK_DRAG_PROTO_WIN32_DROPFILES=4$GDK_DRAG_PROTO_OLE2=5$GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous$44 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum$GDK_EVEN_ODD_RULE=0$GDK_WINDING_RULE=1
// file /usr/include/gtk-2.0/gdk/gdkregion.h line 43
enum anonymous$148 { GDK_EVEN_ODD_RULE=0, GDK_WINDING_RULE=1 };

// #anon_enum$GDK_EXPOSURE_MASK=2$GDK_POINTER_MOTION_MASK=4$GDK_POINTER_MOTION_HINT_MASK=8$GDK_BUTTON_MOTION_MASK=16$GDK_BUTTON1_MOTION_MASK=32$GDK_BUTTON2_MOTION_MASK=64$GDK_BUTTON3_MOTION_MASK=128$GDK_BUTTON_PRESS_MASK=256$GDK_BUTTON_RELEASE_MASK=512$GDK_KEY_PRESS_MASK=1024$GDK_KEY_RELEASE_MASK=2048$GDK_ENTER_NOTIFY_MASK=4096$GDK_LEAVE_NOTIFY_MASK=8192$GDK_FOCUS_CHANGE_MASK=16384$GDK_STRUCTURE_MASK=32768$GDK_PROPERTY_CHANGE_MASK=65536$GDK_VISIBILITY_NOTIFY_MASK=131072$GDK_PROXIMITY_IN_MASK=262144$GDK_PROXIMITY_OUT_MASK=524288$GDK_SUBSTRUCTURE_MASK=1048576$GDK_SCROLL_MASK=2097152$GDK_ALL_EVENTS_MASK=4194302
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 161
enum anonymous$47 { GDK_EXPOSURE_MASK=2, GDK_POINTER_MOTION_MASK=4, GDK_POINTER_MOTION_HINT_MASK=8, GDK_BUTTON_MOTION_MASK=16, GDK_BUTTON1_MOTION_MASK=32, GDK_BUTTON2_MOTION_MASK=64, GDK_BUTTON3_MOTION_MASK=128, GDK_BUTTON_PRESS_MASK=256, GDK_BUTTON_RELEASE_MASK=512, GDK_KEY_PRESS_MASK=1024, GDK_KEY_RELEASE_MASK=2048, GDK_ENTER_NOTIFY_MASK=4096, GDK_LEAVE_NOTIFY_MASK=8192, GDK_FOCUS_CHANGE_MASK=16384, GDK_STRUCTURE_MASK=32768, GDK_PROPERTY_CHANGE_MASK=65536, GDK_VISIBILITY_NOTIFY_MASK=131072, GDK_PROXIMITY_IN_MASK=262144, GDK_PROXIMITY_OUT_MASK=524288, GDK_SUBSTRUCTURE_MASK=1048576, GDK_SCROLL_MASK=2097152, GDK_ALL_EVENTS_MASK=4194302 };

// #anon_enum$GDK_FILTER_CONTINUE=0$GDK_FILTER_TRANSLATE=1$GDK_FILTER_REMOVE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 79
enum anonymous$112 { GDK_FILTER_CONTINUE=0, GDK_FILTER_TRANSLATE=1, GDK_FILTER_REMOVE=2 };

// #anon_enum$GDK_FONT_FONT=0$GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous$18 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum$GDK_GRAB_SUCCESS=0$GDK_GRAB_ALREADY_GRABBED=1$GDK_GRAB_INVALID_TIME=2$GDK_GRAB_NOT_VIEWABLE=3$GDK_GRAB_FROZEN=4
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 175
enum anonymous$42 { GDK_GRAB_SUCCESS=0, GDK_GRAB_ALREADY_GRABBED=1, GDK_GRAB_INVALID_TIME=2, GDK_GRAB_NOT_VIEWABLE=3, GDK_GRAB_FROZEN=4 };

// #anon_enum$GDK_IMAGE_NORMAL=0$GDK_IMAGE_SHARED=1$GDK_IMAGE_FASTEST=2
// file /usr/include/gtk-2.0/gdk/gdkimage.h line 49
enum anonymous$97 { GDK_IMAGE_NORMAL=0, GDK_IMAGE_SHARED=1, GDK_IMAGE_FASTEST=2 };

// #anon_enum$GDK_INTERP_NEAREST=0$GDK_INTERP_TILES=1$GDK_INTERP_BILINEAR=2$GDK_INTERP_HYPER=3
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h line 71
enum anonymous$87 { GDK_INTERP_NEAREST=0, GDK_INTERP_TILES=1, GDK_INTERP_BILINEAR=2, GDK_INTERP_HYPER=3 };

// #anon_enum$GDK_LSB_FIRST=0$GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous$36 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum$GDK_MODE_DISABLED=0$GDK_MODE_SCREEN=1$GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous$39 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum$GDK_NOTHING=-1$GDK_DELETE=0$GDK_DESTROY=1$GDK_EXPOSE=2$GDK_MOTION_NOTIFY=3$GDK_BUTTON_PRESS=4$GDK_2BUTTON_PRESS=5$GDK_3BUTTON_PRESS=6$GDK_BUTTON_RELEASE=7$GDK_KEY_PRESS=8$GDK_KEY_RELEASE=9$GDK_ENTER_NOTIFY=10$GDK_LEAVE_NOTIFY=11$GDK_FOCUS_CHANGE=12$GDK_CONFIGURE=13$GDK_MAP=14$GDK_UNMAP=15$GDK_PROPERTY_NOTIFY=16$GDK_SELECTION_CLEAR=17$GDK_SELECTION_REQUEST=18$GDK_SELECTION_NOTIFY=19$GDK_PROXIMITY_IN=20$GDK_PROXIMITY_OUT=21$GDK_DRAG_ENTER=22$GDK_DRAG_LEAVE=23$GDK_DRAG_MOTION=24$GDK_DRAG_STATUS=25$GDK_DROP_START=26$GDK_DROP_FINISHED=27$GDK_CLIENT_EVENT=28$GDK_VISIBILITY_NOTIFY=29$GDK_NO_EXPOSE=30$GDK_SCROLL=31$GDK_WINDOW_STATE=32$GDK_SETTING=33$GDK_OWNER_CHANGE=34$GDK_GRAB_BROKEN=35$GDK_DAMAGE=36$GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous$12 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum$GDK_NOTIFY_ANCESTOR=0$GDK_NOTIFY_VIRTUAL=1$GDK_NOTIFY_INFERIOR=2$GDK_NOTIFY_NONLINEAR=3$GDK_NOTIFY_NONLINEAR_VIRTUAL=4$GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous$50 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum$GDK_OWNER_CHANGE_NEW_OWNER=0$GDK_OWNER_CHANGE_DESTROY=1$GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous$54 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum$GDK_SCROLL_UP=0$GDK_SCROLL_DOWN=1$GDK_SCROLL_LEFT=2$GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous$49 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum$GDK_SETTING_ACTION_NEW=0$GDK_SETTING_ACTION_CHANGED=1$GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous$52 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum$GDK_SHIFT_MASK=1$GDK_LOCK_MASK=2$GDK_CONTROL_MASK=4$GDK_MOD1_MASK=8$GDK_MOD2_MASK=16$GDK_MOD3_MASK=32$GDK_MOD4_MASK=64$GDK_MOD5_MASK=128$GDK_BUTTON1_MASK=256$GDK_BUTTON2_MASK=512$GDK_BUTTON3_MASK=1024$GDK_BUTTON4_MASK=2048$GDK_BUTTON5_MASK=4096$GDK_SUPER_MASK=67108864$GDK_HYPER_MASK=134217728$GDK_META_MASK=268435456$GDK_RELEASE_MASK=1073741824$GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous$0 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum$GDK_SOURCE_MOUSE=0$GDK_SOURCE_PEN=1$GDK_SOURCE_ERASER=2$GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous$38 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum$GDK_VISIBILITY_UNOBSCURED=0$GDK_VISIBILITY_PARTIAL=1$GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous$48 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum$GDK_VISUAL_STATIC_GRAY=0$GDK_VISUAL_GRAYSCALE=1$GDK_VISUAL_STATIC_COLOR=2$GDK_VISUAL_PSEUDO_COLOR=3$GDK_VISUAL_TRUE_COLOR=4$GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous$35 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum$GDK_WINDOW_STATE_WITHDRAWN=1$GDK_WINDOW_STATE_ICONIFIED=2$GDK_WINDOW_STATE_MAXIMIZED=4$GDK_WINDOW_STATE_STICKY=8$GDK_WINDOW_STATE_FULLSCREEN=16$GDK_WINDOW_STATE_ABOVE=32$GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous$22 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum$GDK_X_CURSOR=0$GDK_ARROW=2$GDK_BASED_ARROW_DOWN=4$GDK_BASED_ARROW_UP=6$GDK_BOAT=8$GDK_BOGOSITY=10$GDK_BOTTOM_LEFT_CORNER=12$GDK_BOTTOM_RIGHT_CORNER=14$GDK_BOTTOM_SIDE=16$GDK_BOTTOM_TEE=18$GDK_BOX_SPIRAL=20$GDK_CENTER_PTR=22$GDK_CIRCLE=24$GDK_CLOCK=26$GDK_COFFEE_MUG=28$GDK_CROSS=30$GDK_CROSS_REVERSE=32$GDK_CROSSHAIR=34$GDK_DIAMOND_CROSS=36$GDK_DOT=38$GDK_DOTBOX=40$GDK_DOUBLE_ARROW=42$GDK_DRAFT_LARGE=44$GDK_DRAFT_SMALL=46$GDK_DRAPED_BOX=48$GDK_EXCHANGE=50$GDK_FLEUR=52$GDK_GOBBLER=54$GDK_GUMBY=56$GDK_HAND1=58$GDK_HAND2=60$GDK_HEART=62$GDK_ICON=64$GDK_IRON_CROSS=66$GDK_LEFT_PTR=68$GDK_LEFT_SIDE=70$GDK_LEFT_TEE=72$GDK_LEFTBUTTON=74$GDK_LL_ANGLE=76$GDK_LR_ANGLE=78$GDK_MAN=80$GDK_MIDDLEBUTTON=82$GDK_MOUSE=84$GDK_PENCIL=86$GDK_PIRATE=88$GDK_PLUS=90$GDK_QUESTION_ARROW=92$GDK_RIGHT_PTR=94$GDK_RIGHT_SIDE=96$GDK_RIGHT_TEE=98$GDK_RIGHTBUTTON=100$GDK_RTL_LOGO=102$GDK_SAILBOAT=104$GDK_SB_DOWN_ARROW=106$GDK_SB_H_DOUBLE_ARROW=108$GDK_SB_LEFT_ARROW=110$GDK_SB_RIGHT_ARROW=112$GDK_SB_UP_ARROW=114$GDK_SB_V_DOUBLE_ARROW=116$GDK_SHUTTLE=118$GDK_SIZING=120$GDK_SPIDER=122$GDK_SPRAYCAN=124$GDK_STAR=126$GDK_TARGET=128$GDK_TCROSS=130$GDK_TOP_LEFT_ARROW=132$GDK_TOP_LEFT_CORNER=134$GDK_TOP_RIGHT_CORNER=136$GDK_TOP_SIDE=138$GDK_TOP_TEE=140$GDK_TREK=142$GDK_UL_ANGLE=144$GDK_UMBRELLA=146$GDK_UR_ANGLE=148$GDK_WATCH=150$GDK_XTERM=152$GDK_LAST_CURSOR=153$GDK_BLANK_CURSOR=-2$GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 43
enum anonymous$37 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum$GNOME_INTERACT_NONE=0$GNOME_INTERACT_ERRORS=1$GNOME_INTERACT_ANY=2
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 50
enum anonymous$53 { GNOME_INTERACT_NONE=0, GNOME_INTERACT_ERRORS=1, GNOME_INTERACT_ANY=2 };

// #anon_enum$GNOME_RESTART_IF_RUNNING=0$GNOME_RESTART_ANYWAY=1$GNOME_RESTART_IMMEDIATELY=2$GNOME_RESTART_NEVER=3
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 71
enum anonymous$56 { GNOME_RESTART_IF_RUNNING=0, GNOME_RESTART_ANYWAY=1, GNOME_RESTART_IMMEDIATELY=2, GNOME_RESTART_NEVER=3 };

// #anon_enum$GNOME_SAVE_GLOBAL=0$GNOME_SAVE_LOCAL=1$GNOME_SAVE_BOTH=2
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 63
enum anonymous$55 { GNOME_SAVE_GLOBAL=0, GNOME_SAVE_LOCAL=1, GNOME_SAVE_BOTH=2 };

// #anon_enum$GNOME_VFS_FILE_FLAGS_NONE=0$GNOME_VFS_FILE_FLAGS_SYMLINK=1$GNOME_VFS_FILE_FLAGS_LOCAL=2
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 79
enum anonymous$30 { GNOME_VFS_FILE_FLAGS_NONE=0, GNOME_VFS_FILE_FLAGS_SYMLINK=1, GNOME_VFS_FILE_FLAGS_LOCAL=2 };

// #anon_enum$GNOME_VFS_FILE_INFO_DEFAULT=0$GNOME_VFS_FILE_INFO_GET_MIME_TYPE=1$GNOME_VFS_FILE_INFO_FORCE_FAST_MIME_TYPE=2$GNOME_VFS_FILE_INFO_FORCE_SLOW_MIME_TYPE=4$GNOME_VFS_FILE_INFO_FOLLOW_LINKS=8$GNOME_VFS_FILE_INFO_GET_ACCESS_RIGHTS=16$GNOME_VFS_FILE_INFO_NAME_ONLY=32$GNOME_VFS_FILE_INFO_GET_ACL=64$GNOME_VFS_FILE_INFO_GET_SELINUX_CONTEXT=128
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 360
enum anonymous$33 { GNOME_VFS_FILE_INFO_DEFAULT=0, GNOME_VFS_FILE_INFO_GET_MIME_TYPE=1, GNOME_VFS_FILE_INFO_FORCE_FAST_MIME_TYPE=2, GNOME_VFS_FILE_INFO_FORCE_SLOW_MIME_TYPE=4, GNOME_VFS_FILE_INFO_FOLLOW_LINKS=8, GNOME_VFS_FILE_INFO_GET_ACCESS_RIGHTS=16, GNOME_VFS_FILE_INFO_NAME_ONLY=32, GNOME_VFS_FILE_INFO_GET_ACL=64, GNOME_VFS_FILE_INFO_GET_SELINUX_CONTEXT=128 };

// #anon_enum$GNOME_VFS_FILE_INFO_FIELDS_NONE=0$GNOME_VFS_FILE_INFO_FIELDS_TYPE=1$GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS=2$GNOME_VFS_FILE_INFO_FIELDS_FLAGS=4$GNOME_VFS_FILE_INFO_FIELDS_DEVICE=8$GNOME_VFS_FILE_INFO_FIELDS_INODE=16$GNOME_VFS_FILE_INFO_FIELDS_LINK_COUNT=32$GNOME_VFS_FILE_INFO_FIELDS_SIZE=64$GNOME_VFS_FILE_INFO_FIELDS_BLOCK_COUNT=128$GNOME_VFS_FILE_INFO_FIELDS_IO_BLOCK_SIZE=256$GNOME_VFS_FILE_INFO_FIELDS_ATIME=512$GNOME_VFS_FILE_INFO_FIELDS_MTIME=1024$GNOME_VFS_FILE_INFO_FIELDS_CTIME=2048$GNOME_VFS_FILE_INFO_FIELDS_SYMLINK_NAME=4096$GNOME_VFS_FILE_INFO_FIELDS_MIME_TYPE=8192$GNOME_VFS_FILE_INFO_FIELDS_ACCESS=16384$GNOME_VFS_FILE_INFO_FIELDS_IDS=32768$GNOME_VFS_FILE_INFO_FIELDS_ACL=65536$GNOME_VFS_FILE_INFO_FIELDS_SELINUX_CONTEXT=131072
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 139
enum anonymous$27 { GNOME_VFS_FILE_INFO_FIELDS_NONE=0, GNOME_VFS_FILE_INFO_FIELDS_TYPE=1, GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS=2, GNOME_VFS_FILE_INFO_FIELDS_FLAGS=4, GNOME_VFS_FILE_INFO_FIELDS_DEVICE=8, GNOME_VFS_FILE_INFO_FIELDS_INODE=16, GNOME_VFS_FILE_INFO_FIELDS_LINK_COUNT=32, GNOME_VFS_FILE_INFO_FIELDS_SIZE=64, GNOME_VFS_FILE_INFO_FIELDS_BLOCK_COUNT=128, GNOME_VFS_FILE_INFO_FIELDS_IO_BLOCK_SIZE=256, GNOME_VFS_FILE_INFO_FIELDS_ATIME=512, GNOME_VFS_FILE_INFO_FIELDS_MTIME=1024, GNOME_VFS_FILE_INFO_FIELDS_CTIME=2048, GNOME_VFS_FILE_INFO_FIELDS_SYMLINK_NAME=4096, GNOME_VFS_FILE_INFO_FIELDS_MIME_TYPE=8192, GNOME_VFS_FILE_INFO_FIELDS_ACCESS=16384, GNOME_VFS_FILE_INFO_FIELDS_IDS=32768, GNOME_VFS_FILE_INFO_FIELDS_ACL=65536, GNOME_VFS_FILE_INFO_FIELDS_SELINUX_CONTEXT=131072 };

// #anon_enum$GNOME_VFS_FILE_TYPE_UNKNOWN=0$GNOME_VFS_FILE_TYPE_REGULAR=1$GNOME_VFS_FILE_TYPE_DIRECTORY=2$GNOME_VFS_FILE_TYPE_FIFO=3$GNOME_VFS_FILE_TYPE_SOCKET=4$GNOME_VFS_FILE_TYPE_CHARACTER_DEVICE=5$GNOME_VFS_FILE_TYPE_BLOCK_DEVICE=6$GNOME_VFS_FILE_TYPE_SYMBOLIC_LINK=7
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 100
enum anonymous$28 { GNOME_VFS_FILE_TYPE_UNKNOWN=0, GNOME_VFS_FILE_TYPE_REGULAR=1, GNOME_VFS_FILE_TYPE_DIRECTORY=2, GNOME_VFS_FILE_TYPE_FIFO=3, GNOME_VFS_FILE_TYPE_SOCKET=4, GNOME_VFS_FILE_TYPE_CHARACTER_DEVICE=5, GNOME_VFS_FILE_TYPE_BLOCK_DEVICE=6, GNOME_VFS_FILE_TYPE_SYMBOLIC_LINK=7 };

// #anon_enum$GNOME_VFS_MONITOR_EVENT_CHANGED=0$GNOME_VFS_MONITOR_EVENT_DELETED=1$GNOME_VFS_MONITOR_EVENT_STARTEXECUTING=2$GNOME_VFS_MONITOR_EVENT_STOPEXECUTING=3$GNOME_VFS_MONITOR_EVENT_CREATED=4$GNOME_VFS_MONITOR_EVENT_METADATA_CHANGED=5
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-monitor.h line 55
enum anonymous$102 { GNOME_VFS_MONITOR_EVENT_CHANGED=0, GNOME_VFS_MONITOR_EVENT_DELETED=1, GNOME_VFS_MONITOR_EVENT_STARTEXECUTING=2, GNOME_VFS_MONITOR_EVENT_STOPEXECUTING=3, GNOME_VFS_MONITOR_EVENT_CREATED=4, GNOME_VFS_MONITOR_EVENT_METADATA_CHANGED=5 };

// #anon_enum$GNOME_VFS_MONITOR_FILE=0$GNOME_VFS_MONITOR_DIRECTORY=1
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-monitor.h line 38
enum anonymous$101 { GNOME_VFS_MONITOR_FILE=0, GNOME_VFS_MONITOR_DIRECTORY=1 };

// #anon_enum$GNOME_VFS_OK=0$GNOME_VFS_ERROR_NOT_FOUND=1$GNOME_VFS_ERROR_GENERIC=2$GNOME_VFS_ERROR_INTERNAL=3$GNOME_VFS_ERROR_BAD_PARAMETERS=4$GNOME_VFS_ERROR_NOT_SUPPORTED=5$GNOME_VFS_ERROR_IO=6$GNOME_VFS_ERROR_CORRUPTED_DATA=7$GNOME_VFS_ERROR_WRONG_FORMAT=8$GNOME_VFS_ERROR_BAD_FILE=9$GNOME_VFS_ERROR_TOO_BIG=10$GNOME_VFS_ERROR_NO_SPACE=11$GNOME_VFS_ERROR_READ_ONLY=12$GNOME_VFS_ERROR_INVALID_URI=13$GNOME_VFS_ERROR_NOT_OPEN=14$GNOME_VFS_ERROR_INVALID_OPEN_MODE=15$GNOME_VFS_ERROR_ACCESS_DENIED=16$GNOME_VFS_ERROR_TOO_MANY_OPEN_FILES=17$GNOME_VFS_ERROR_EOF=18$GNOME_VFS_ERROR_NOT_A_DIRECTORY=19$GNOME_VFS_ERROR_IN_PROGRESS=20$GNOME_VFS_ERROR_INTERRUPTED=21$GNOME_VFS_ERROR_FILE_EXISTS=22$GNOME_VFS_ERROR_LOOP=23$GNOME_VFS_ERROR_NOT_PERMITTED=24$GNOME_VFS_ERROR_IS_DIRECTORY=25$GNOME_VFS_ERROR_NO_MEMORY=26$GNOME_VFS_ERROR_HOST_NOT_FOUND=27$GNOME_VFS_ERROR_INVALID_HOST_NAME=28$GNOME_VFS_ERROR_HOST_HAS_NO_ADDRESS=29$GNOME_VFS_ERROR_LOGIN_FAILED=30$GNOME_VFS_ERROR_CANCELLED=31$GNOME_VFS_ERROR_DIRECTORY_BUSY=32$GNOME_VFS_ERROR_DIRECTORY_NOT_EMPTY=33$GNOME_VFS_ERROR_TOO_MANY_LINKS=34$GNOME_VFS_ERROR_READ_ONLY_FILE_SYSTEM=35$GNOME_VFS_ERROR_NOT_SAME_FILE_SYSTEM=36$GNOME_VFS_ERROR_NAME_TOO_LONG=37$GNOME_VFS_ERROR_SERVICE_NOT_AVAILABLE=38$GNOME_VFS_ERROR_SERVICE_OBSOLETE=39$GNOME_VFS_ERROR_PROTOCOL_ERROR=40$GNOME_VFS_ERROR_NO_MASTER_BROWSER=41$GNOME_VFS_ERROR_NO_DEFAULT=42$GNOME_VFS_ERROR_NO_HANDLER=43$GNOME_VFS_ERROR_PARSE=44$GNOME_VFS_ERROR_LAUNCH=45$GNOME_VFS_ERROR_TIMEOUT=46$GNOME_VFS_ERROR_NAMESERVER=47$GNOME_VFS_ERROR_LOCKED=48$GNOME_VFS_ERROR_DEPRECATED_FUNCTION=49$GNOME_VFS_ERROR_INVALID_FILENAME=50$GNOME_VFS_ERROR_NOT_A_SYMBOLIC_LINK=51$GNOME_VFS_NUM_ERRORS=52
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-result.h line 98
enum anonymous$32 { GNOME_VFS_OK=0, GNOME_VFS_ERROR_NOT_FOUND=1, GNOME_VFS_ERROR_GENERIC=2, GNOME_VFS_ERROR_INTERNAL=3, GNOME_VFS_ERROR_BAD_PARAMETERS=4, GNOME_VFS_ERROR_NOT_SUPPORTED=5, GNOME_VFS_ERROR_IO=6, GNOME_VFS_ERROR_CORRUPTED_DATA=7, GNOME_VFS_ERROR_WRONG_FORMAT=8, GNOME_VFS_ERROR_BAD_FILE=9, GNOME_VFS_ERROR_TOO_BIG=10, GNOME_VFS_ERROR_NO_SPACE=11, GNOME_VFS_ERROR_READ_ONLY=12, GNOME_VFS_ERROR_INVALID_URI=13, GNOME_VFS_ERROR_NOT_OPEN=14, GNOME_VFS_ERROR_INVALID_OPEN_MODE=15, GNOME_VFS_ERROR_ACCESS_DENIED=16, GNOME_VFS_ERROR_TOO_MANY_OPEN_FILES=17, GNOME_VFS_ERROR_EOF=18, GNOME_VFS_ERROR_NOT_A_DIRECTORY=19, GNOME_VFS_ERROR_IN_PROGRESS=20, GNOME_VFS_ERROR_INTERRUPTED=21, GNOME_VFS_ERROR_FILE_EXISTS=22, GNOME_VFS_ERROR_LOOP=23, GNOME_VFS_ERROR_NOT_PERMITTED=24, GNOME_VFS_ERROR_IS_DIRECTORY=25, GNOME_VFS_ERROR_NO_MEMORY=26, GNOME_VFS_ERROR_HOST_NOT_FOUND=27, GNOME_VFS_ERROR_INVALID_HOST_NAME=28, GNOME_VFS_ERROR_HOST_HAS_NO_ADDRESS=29, GNOME_VFS_ERROR_LOGIN_FAILED=30, GNOME_VFS_ERROR_CANCELLED=31, GNOME_VFS_ERROR_DIRECTORY_BUSY=32, GNOME_VFS_ERROR_DIRECTORY_NOT_EMPTY=33, GNOME_VFS_ERROR_TOO_MANY_LINKS=34, GNOME_VFS_ERROR_READ_ONLY_FILE_SYSTEM=35, GNOME_VFS_ERROR_NOT_SAME_FILE_SYSTEM=36, GNOME_VFS_ERROR_NAME_TOO_LONG=37, GNOME_VFS_ERROR_SERVICE_NOT_AVAILABLE=38, GNOME_VFS_ERROR_SERVICE_OBSOLETE=39, GNOME_VFS_ERROR_PROTOCOL_ERROR=40, GNOME_VFS_ERROR_NO_MASTER_BROWSER=41, GNOME_VFS_ERROR_NO_DEFAULT=42, GNOME_VFS_ERROR_NO_HANDLER=43, GNOME_VFS_ERROR_PARSE=44, GNOME_VFS_ERROR_LAUNCH=45, GNOME_VFS_ERROR_TIMEOUT=46, GNOME_VFS_ERROR_NAMESERVER=47, GNOME_VFS_ERROR_LOCKED=48, GNOME_VFS_ERROR_DEPRECATED_FUNCTION=49, GNOME_VFS_ERROR_INVALID_FILENAME=50, GNOME_VFS_ERROR_NOT_A_SYMBOLIC_LINK=51, GNOME_VFS_NUM_ERRORS=52 };

// #anon_enum$GNOME_VFS_PERM_SUID=2048$GNOME_VFS_PERM_SGID=1024$GNOME_VFS_PERM_STICKY=512$GNOME_VFS_PERM_USER_READ=256$GNOME_VFS_PERM_USER_WRITE=128$GNOME_VFS_PERM_USER_EXEC=64$GNOME_VFS_PERM_USER_ALL=448$GNOME_VFS_PERM_GROUP_READ=32$GNOME_VFS_PERM_GROUP_WRITE=16$GNOME_VFS_PERM_GROUP_EXEC=8$GNOME_VFS_PERM_GROUP_ALL=56$GNOME_VFS_PERM_OTHER_READ=4$GNOME_VFS_PERM_OTHER_WRITE=2$GNOME_VFS_PERM_OTHER_EXEC=1$GNOME_VFS_PERM_OTHER_ALL=7$GNOME_VFS_PERM_ACCESS_READABLE=65536$GNOME_VFS_PERM_ACCESS_WRITABLE=131072$GNOME_VFS_PERM_ACCESS_EXECUTABLE=262144
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 203
enum anonymous$29 { GNOME_VFS_PERM_SUID=2048, GNOME_VFS_PERM_SGID=1024, GNOME_VFS_PERM_STICKY=512, GNOME_VFS_PERM_USER_READ=256, GNOME_VFS_PERM_USER_WRITE=128, GNOME_VFS_PERM_USER_EXEC=64, GNOME_VFS_PERM_USER_ALL=448, GNOME_VFS_PERM_GROUP_READ=32, GNOME_VFS_PERM_GROUP_WRITE=16, GNOME_VFS_PERM_GROUP_EXEC=8, GNOME_VFS_PERM_GROUP_ALL=56, GNOME_VFS_PERM_OTHER_READ=4, GNOME_VFS_PERM_OTHER_WRITE=2, GNOME_VFS_PERM_OTHER_EXEC=1, GNOME_VFS_PERM_OTHER_ALL=7, GNOME_VFS_PERM_ACCESS_READABLE=65536, GNOME_VFS_PERM_ACCESS_WRITABLE=131072, GNOME_VFS_PERM_ACCESS_EXECUTABLE=262144 };

// #anon_enum$GNOME_VFS_XFER_DEFAULT=0$GNOME_VFS_XFER_UNUSED_1=1$GNOME_VFS_XFER_FOLLOW_LINKS=2$GNOME_VFS_XFER_UNUSED_2=4$GNOME_VFS_XFER_RECURSIVE=8$GNOME_VFS_XFER_SAMEFS=16$GNOME_VFS_XFER_DELETE_ITEMS=32$GNOME_VFS_XFER_EMPTY_DIRECTORIES=64$GNOME_VFS_XFER_NEW_UNIQUE_DIRECTORY=128$GNOME_VFS_XFER_REMOVESOURCE=256$GNOME_VFS_XFER_USE_UNIQUE_NAMES=512$GNOME_VFS_XFER_LINK_ITEMS=1024$GNOME_VFS_XFER_FOLLOW_LINKS_RECURSIVE=2048$GNOME_VFS_XFER_TARGET_DEFAULT_PERMS=4096
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-xfer.h line 161
enum anonymous$81 { GNOME_VFS_XFER_DEFAULT=0, GNOME_VFS_XFER_UNUSED_1=1, GNOME_VFS_XFER_FOLLOW_LINKS=2, GNOME_VFS_XFER_UNUSED_2=4, GNOME_VFS_XFER_RECURSIVE=8, GNOME_VFS_XFER_SAMEFS=16, GNOME_VFS_XFER_DELETE_ITEMS=32, GNOME_VFS_XFER_EMPTY_DIRECTORIES=64, GNOME_VFS_XFER_NEW_UNIQUE_DIRECTORY=128, GNOME_VFS_XFER_REMOVESOURCE=256, GNOME_VFS_XFER_USE_UNIQUE_NAMES=512, GNOME_VFS_XFER_LINK_ITEMS=1024, GNOME_VFS_XFER_FOLLOW_LINKS_RECURSIVE=2048, GNOME_VFS_XFER_TARGET_DEFAULT_PERMS=4096 };

// #anon_enum$GNOME_VFS_XFER_ERROR_MODE_ABORT=0$GNOME_VFS_XFER_ERROR_MODE_QUERY=1
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-xfer.h line 260
enum anonymous$83 { GNOME_VFS_XFER_ERROR_MODE_ABORT=0, GNOME_VFS_XFER_ERROR_MODE_QUERY=1 };

// #anon_enum$GNOME_VFS_XFER_OVERWRITE_MODE_ABORT=0$GNOME_VFS_XFER_OVERWRITE_MODE_QUERY=1$GNOME_VFS_XFER_OVERWRITE_MODE_REPLACE=2$GNOME_VFS_XFER_OVERWRITE_MODE_SKIP=3
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-xfer.h line 218
enum anonymous$82 { GNOME_VFS_XFER_OVERWRITE_MODE_ABORT=0, GNOME_VFS_XFER_OVERWRITE_MODE_QUERY=1, GNOME_VFS_XFER_OVERWRITE_MODE_REPLACE=2, GNOME_VFS_XFER_OVERWRITE_MODE_SKIP=3 };

// #anon_enum$GNOME_VFS_XFER_PHASE_INITIAL=0$GNOME_VFS_XFER_CHECKING_DESTINATION=1$GNOME_VFS_XFER_PHASE_COLLECTING=2$GNOME_VFS_XFER_PHASE_READYTOGO=3$GNOME_VFS_XFER_PHASE_OPENSOURCE=4$GNOME_VFS_XFER_PHASE_OPENTARGET=5$GNOME_VFS_XFER_PHASE_COPYING=6$GNOME_VFS_XFER_PHASE_MOVING=7$GNOME_VFS_XFER_PHASE_READSOURCE=8$GNOME_VFS_XFER_PHASE_WRITETARGET=9$GNOME_VFS_XFER_PHASE_CLOSESOURCE=10$GNOME_VFS_XFER_PHASE_CLOSETARGET=11$GNOME_VFS_XFER_PHASE_DELETESOURCE=12$GNOME_VFS_XFER_PHASE_SETATTRIBUTES=13$GNOME_VFS_XFER_PHASE_FILECOMPLETED=14$GNOME_VFS_XFER_PHASE_CLEANUP=15$GNOME_VFS_XFER_PHASE_COMPLETED=16$GNOME_VFS_XFER_NUM_PHASES=17
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-xfer.h line 315
enum anonymous$14 { GNOME_VFS_XFER_PHASE_INITIAL=0, GNOME_VFS_XFER_CHECKING_DESTINATION=1, GNOME_VFS_XFER_PHASE_COLLECTING=2, GNOME_VFS_XFER_PHASE_READYTOGO=3, GNOME_VFS_XFER_PHASE_OPENSOURCE=4, GNOME_VFS_XFER_PHASE_OPENTARGET=5, GNOME_VFS_XFER_PHASE_COPYING=6, GNOME_VFS_XFER_PHASE_MOVING=7, GNOME_VFS_XFER_PHASE_READSOURCE=8, GNOME_VFS_XFER_PHASE_WRITETARGET=9, GNOME_VFS_XFER_PHASE_CLOSESOURCE=10, GNOME_VFS_XFER_PHASE_CLOSETARGET=11, GNOME_VFS_XFER_PHASE_DELETESOURCE=12, GNOME_VFS_XFER_PHASE_SETATTRIBUTES=13, GNOME_VFS_XFER_PHASE_FILECOMPLETED=14, GNOME_VFS_XFER_PHASE_CLEANUP=15, GNOME_VFS_XFER_PHASE_COMPLETED=16, GNOME_VFS_XFER_NUM_PHASES=17 };

// #anon_enum$GNOME_VFS_XFER_PROGRESS_STATUS_OK=0$GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR=1$GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE=2$GNOME_VFS_XFER_PROGRESS_STATUS_DUPLICATE=3
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-xfer.h line 195
enum anonymous$15 { GNOME_VFS_XFER_PROGRESS_STATUS_OK=0, GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR=1, GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE=2, GNOME_VFS_XFER_PROGRESS_STATUS_DUPLICATE=3 };

// #anon_enum$GTK_ACCEL_VISIBLE=1$GTK_ACCEL_LOCKED=2$GTK_ACCEL_MASK=7
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 51
enum anonymous$59 { GTK_ACCEL_VISIBLE=1, GTK_ACCEL_LOCKED=2, GTK_ACCEL_MASK=7 };

// #anon_enum$GTK_BUTTONS_NONE=0$GTK_BUTTONS_OK=1$GTK_BUTTONS_CLOSE=2$GTK_BUTTONS_CANCEL=3$GTK_BUTTONS_YES_NO=4$GTK_BUTTONS_OK_CANCEL=5
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 89
enum anonymous$152 { GTK_BUTTONS_NONE=0, GTK_BUTTONS_OK=1, GTK_BUTTONS_CLOSE=2, GTK_BUTTONS_CANCEL=3, GTK_BUTTONS_YES_NO=4, GTK_BUTTONS_OK_CANCEL=5 };

// #anon_enum$GTK_CELL_RENDERER_SELECTED=1$GTK_CELL_RENDERER_PRELIT=2$GTK_CELL_RENDERER_INSENSITIVE=4$GTK_CELL_RENDERER_SORTED=8$GTK_CELL_RENDERER_FOCUSED=16
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 31
enum anonymous$1 { GTK_CELL_RENDERER_SELECTED=1, GTK_CELL_RENDERER_PRELIT=2, GTK_CELL_RENDERER_INSENSITIVE=4, GTK_CELL_RENDERER_SORTED=8, GTK_CELL_RENDERER_FOCUSED=16 };

// #anon_enum$GTK_DELETE_CHARS=0$GTK_DELETE_WORD_ENDS=1$GTK_DELETE_WORDS=2$GTK_DELETE_DISPLAY_LINES=3$GTK_DELETE_DISPLAY_LINE_ENDS=4$GTK_DELETE_PARAGRAPH_ENDS=5$GTK_DELETE_PARAGRAPHS=6$GTK_DELETE_WHITESPACE=7
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 107
enum anonymous$93 { GTK_DELETE_CHARS=0, GTK_DELETE_WORD_ENDS=1, GTK_DELETE_WORDS=2, GTK_DELETE_DISPLAY_LINES=3, GTK_DELETE_DISPLAY_LINE_ENDS=4, GTK_DELETE_PARAGRAPH_ENDS=5, GTK_DELETE_PARAGRAPHS=6, GTK_DELETE_WHITESPACE=7 };

// #anon_enum$GTK_DIALOG_MODAL=1$GTK_DIALOG_DESTROY_WITH_PARENT=2$GTK_DIALOG_NO_SEPARATOR=4
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 41
enum anonymous$154 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_NO_SEPARATOR=4 };

// #anon_enum$GTK_DIR_TAB_FORWARD=0$GTK_DIR_TAB_BACKWARD=1$GTK_DIR_UP=2$GTK_DIR_DOWN=3$GTK_DIR_LEFT=4$GTK_DIR_RIGHT=5
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 122
enum anonymous$25 { GTK_DIR_TAB_FORWARD=0, GTK_DIR_TAB_BACKWARD=1, GTK_DIR_UP=2, GTK_DIR_DOWN=3, GTK_DIR_LEFT=4, GTK_DIR_RIGHT=5 };

// #anon_enum$GTK_EXPAND=1$GTK_SHRINK=2$GTK_FILL=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 79
enum anonymous$58 { GTK_EXPAND=1, GTK_SHRINK=2, GTK_FILL=4 };

// #anon_enum$GTK_FILE_CHOOSER_ACTION_OPEN=0$GTK_FILE_CHOOSER_ACTION_SAVE=1$GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2$GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 56
enum anonymous$155 { GTK_FILE_CHOOSER_ACTION_OPEN=0, GTK_FILE_CHOOSER_ACTION_SAVE=1, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2, GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3 };

// #anon_enum$GTK_ICON_LOOKUP_NO_SVG=1$GTK_ICON_LOOKUP_FORCE_SVG=2$GTK_ICON_LOOKUP_USE_BUILTIN=4$GTK_ICON_LOOKUP_GENERIC_FALLBACK=8$GTK_ICON_LOOKUP_FORCE_SIZE=16
// file /usr/include/gtk-2.0/gtk/gtkicontheme.h line 80
enum anonymous$86 { GTK_ICON_LOOKUP_NO_SVG=1, GTK_ICON_LOOKUP_FORCE_SVG=2, GTK_ICON_LOOKUP_USE_BUILTIN=4, GTK_ICON_LOOKUP_GENERIC_FALLBACK=8, GTK_ICON_LOOKUP_FORCE_SIZE=16 };

// #anon_enum$GTK_ICON_SIZE_INVALID=0$GTK_ICON_SIZE_MENU=1$GTK_ICON_SIZE_SMALL_TOOLBAR=2$GTK_ICON_SIZE_LARGE_TOOLBAR=3$GTK_ICON_SIZE_BUTTON=4$GTK_ICON_SIZE_DND=5$GTK_ICON_SIZE_DIALOG=6
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 142
enum anonymous$21 { GTK_ICON_SIZE_INVALID=0, GTK_ICON_SIZE_MENU=1, GTK_ICON_SIZE_SMALL_TOOLBAR=2, GTK_ICON_SIZE_LARGE_TOOLBAR=3, GTK_ICON_SIZE_BUTTON=4, GTK_ICON_SIZE_DND=5, GTK_ICON_SIZE_DIALOG=6 };

// #anon_enum$GTK_IMAGE_EMPTY=0$GTK_IMAGE_PIXMAP=1$GTK_IMAGE_IMAGE=2$GTK_IMAGE_PIXBUF=3$GTK_IMAGE_STOCK=4$GTK_IMAGE_ICON_SET=5$GTK_IMAGE_ANIMATION=6$GTK_IMAGE_ICON_NAME=7$GTK_IMAGE_GICON=8
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 129
enum anonymous$95 { GTK_IMAGE_EMPTY=0, GTK_IMAGE_PIXMAP=1, GTK_IMAGE_IMAGE=2, GTK_IMAGE_PIXBUF=3, GTK_IMAGE_STOCK=4, GTK_IMAGE_ICON_SET=5, GTK_IMAGE_ANIMATION=6, GTK_IMAGE_ICON_NAME=7, GTK_IMAGE_GICON=8 };

// #anon_enum$GTK_JUSTIFY_LEFT=0$GTK_JUSTIFY_RIGHT=1$GTK_JUSTIFY_CENTER=2$GTK_JUSTIFY_FILL=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 181
enum anonymous$76 { GTK_JUSTIFY_LEFT=0, GTK_JUSTIFY_RIGHT=1, GTK_JUSTIFY_CENTER=2, GTK_JUSTIFY_FILL=3 };

// #anon_enum$GTK_MESSAGE_INFO=0$GTK_MESSAGE_WARNING=1$GTK_MESSAGE_QUESTION=2$GTK_MESSAGE_ERROR=3$GTK_MESSAGE_OTHER=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 221
enum anonymous$79 { GTK_MESSAGE_INFO=0, GTK_MESSAGE_WARNING=1, GTK_MESSAGE_QUESTION=2, GTK_MESSAGE_ERROR=3, GTK_MESSAGE_OTHER=4 };

// #anon_enum$GTK_MOVEMENT_LOGICAL_POSITIONS=0$GTK_MOVEMENT_VISUAL_POSITIONS=1$GTK_MOVEMENT_WORDS=2$GTK_MOVEMENT_DISPLAY_LINES=3$GTK_MOVEMENT_DISPLAY_LINE_ENDS=4$GTK_MOVEMENT_PARAGRAPHS=5$GTK_MOVEMENT_PARAGRAPH_ENDS=6$GTK_MOVEMENT_PAGES=7$GTK_MOVEMENT_BUFFER_ENDS=8$GTK_MOVEMENT_HORIZONTAL_PAGES=9
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 237
enum anonymous$92 { GTK_MOVEMENT_LOGICAL_POSITIONS=0, GTK_MOVEMENT_VISUAL_POSITIONS=1, GTK_MOVEMENT_WORDS=2, GTK_MOVEMENT_DISPLAY_LINES=3, GTK_MOVEMENT_DISPLAY_LINE_ENDS=4, GTK_MOVEMENT_PARAGRAPHS=5, GTK_MOVEMENT_PARAGRAPH_ENDS=6, GTK_MOVEMENT_PAGES=7, GTK_MOVEMENT_BUFFER_ENDS=8, GTK_MOVEMENT_HORIZONTAL_PAGES=9 };

// #anon_enum$GTK_NOTEBOOK_TAB_FIRST=0$GTK_NOTEBOOK_TAB_LAST=1
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 49
enum anonymous$85 { GTK_NOTEBOOK_TAB_FIRST=0, GTK_NOTEBOOK_TAB_LAST=1 };

// #anon_enum$GTK_ORIENTATION_HORIZONTAL=0$GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 262
enum anonymous$9 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum$GTK_POLICY_ALWAYS=0$GTK_POLICY_AUTOMATIC=1$GTK_POLICY_NEVER=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 305
enum anonymous$88 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2 };

// #anon_enum$GTK_POS_LEFT=0$GTK_POS_RIGHT=1$GTK_POS_TOP=2$GTK_POS_BOTTOM=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 312
enum anonymous$46 { GTK_POS_LEFT=0, GTK_POS_RIGHT=1, GTK_POS_TOP=2, GTK_POS_BOTTOM=3 };

// #anon_enum$GTK_RC_FG=1$GTK_RC_BG=2$GTK_RC_TEXT=4$GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous$19 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum$GTK_RELIEF_NORMAL=0$GTK_RELIEF_HALF=1$GTK_RELIEF_NONE=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 329
enum anonymous$94 { GTK_RELIEF_NORMAL=0, GTK_RELIEF_HALF=1, GTK_RELIEF_NONE=2 };

// #anon_enum$GTK_SELECTION_NONE=0$GTK_SELECTION_SINGLE=1$GTK_SELECTION_BROWSE=2$GTK_SELECTION_MULTIPLE=3$GTK_SELECTION_EXTENDED=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 379
enum anonymous$78 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3, GTK_SELECTION_EXTENDED=3 };

// #anon_enum$GTK_SHADOW_NONE=0$GTK_SHADOW_IN=1$GTK_SHADOW_OUT=2$GTK_SHADOW_ETCHED_IN=3$GTK_SHADOW_ETCHED_OUT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 389
enum anonymous$89 { GTK_SHADOW_NONE=0, GTK_SHADOW_IN=1, GTK_SHADOW_OUT=2, GTK_SHADOW_ETCHED_IN=3, GTK_SHADOW_ETCHED_OUT=4 };

// #anon_enum$GTK_SORT_ASCENDING=0$GTK_SORT_DESCENDING=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 476
enum anonymous$151 { GTK_SORT_ASCENDING=0, GTK_SORT_DESCENDING=1 };

// #anon_enum$GTK_STATE_NORMAL=0$GTK_STATE_ACTIVE=1$GTK_STATE_PRELIGHT=2$GTK_STATE_SELECTED=3$GTK_STATE_INSENSITIVE=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 399
enum anonymous$23 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4 };

// #anon_enum$GTK_TEXT_DIR_NONE=0$GTK_TEXT_DIR_LTR=1$GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 173
enum anonymous$24 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum$GTK_TEXT_SEARCH_VISIBLE_ONLY=1$GTK_TEXT_SEARCH_TEXT_ONLY=2
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 39
enum anonymous$100 { GTK_TEXT_SEARCH_VISIBLE_ONLY=1, GTK_TEXT_SEARCH_TEXT_ONLY=2 };

// #anon_enum$GTK_TEXT_WINDOW_PRIVATE=0$GTK_TEXT_WINDOW_WIDGET=1$GTK_TEXT_WINDOW_TEXT=2$GTK_TEXT_WINDOW_LEFT=3$GTK_TEXT_WINDOW_RIGHT=4$GTK_TEXT_WINDOW_TOP=5$GTK_TEXT_WINDOW_BOTTOM=6
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 48
enum anonymous$91 { GTK_TEXT_WINDOW_PRIVATE=0, GTK_TEXT_WINDOW_WIDGET=1, GTK_TEXT_WINDOW_TEXT=2, GTK_TEXT_WINDOW_LEFT=3, GTK_TEXT_WINDOW_RIGHT=4, GTK_TEXT_WINDOW_TOP=5, GTK_TEXT_WINDOW_BOTTOM=6 };

// #anon_enum$GTK_TOOLBAR_ICONS=0$GTK_TOOLBAR_TEXT=1$GTK_TOOLBAR_BOTH=2$GTK_TOOLBAR_BOTH_HORIZ=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 425
enum anonymous$20 { GTK_TOOLBAR_ICONS=0, GTK_TOOLBAR_TEXT=1, GTK_TOOLBAR_BOTH=2, GTK_TOOLBAR_BOTH_HORIZ=3 };

// #anon_enum$GTK_TREE_VIEW_COLUMN_GROW_ONLY=0$GTK_TREE_VIEW_COLUMN_AUTOSIZE=1$GTK_TREE_VIEW_COLUMN_FIXED=2
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 45
enum anonymous$150 { GTK_TREE_VIEW_COLUMN_GROW_ONLY=0, GTK_TREE_VIEW_COLUMN_AUTOSIZE=1, GTK_TREE_VIEW_COLUMN_FIXED=2 };

// #anon_enum$GTK_UI_MANAGER_AUTO=0$GTK_UI_MANAGER_MENUBAR=1$GTK_UI_MANAGER_MENU=2$GTK_UI_MANAGER_TOOLBAR=4$GTK_UI_MANAGER_PLACEHOLDER=8$GTK_UI_MANAGER_POPUP=16$GTK_UI_MANAGER_MENUITEM=32$GTK_UI_MANAGER_TOOLITEM=64$GTK_UI_MANAGER_SEPARATOR=128$GTK_UI_MANAGER_ACCELERATOR=256$GTK_UI_MANAGER_POPUP_WITH_ACCELS=512
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 94
enum anonymous$16 { GTK_UI_MANAGER_AUTO=0, GTK_UI_MANAGER_MENUBAR=1, GTK_UI_MANAGER_MENU=2, GTK_UI_MANAGER_TOOLBAR=4, GTK_UI_MANAGER_PLACEHOLDER=8, GTK_UI_MANAGER_POPUP=16, GTK_UI_MANAGER_MENUITEM=32, GTK_UI_MANAGER_TOOLITEM=64, GTK_UI_MANAGER_SEPARATOR=128, GTK_UI_MANAGER_ACCELERATOR=256, GTK_UI_MANAGER_POPUP_WITH_ACCELS=512 };

// #anon_enum$GTK_UPDATE_ALWAYS=0$GTK_UPDATE_IF_VALID=1
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 53
enum anonymous$153 { GTK_UPDATE_ALWAYS=0, GTK_UPDATE_IF_VALID=1 };

// #anon_enum$GTK_WIDGET_HELP_TOOLTIP=0$GTK_WIDGET_HELP_WHATS_THIS=1
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 127
enum anonymous$26 { GTK_WIDGET_HELP_TOOLTIP=0, GTK_WIDGET_HELP_WHATS_THIS=1 };

// #anon_enum$GTK_WINDOW_TOPLEVEL=0$GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous$149 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum$GTK_WRAP_NONE=0$GTK_WRAP_CHAR=1$GTK_WRAP_WORD=2$GTK_WRAP_WORD_CHAR=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 467
enum anonymous$77 { GTK_WRAP_NONE=0, GTK_WRAP_CHAR=1, GTK_WRAP_WORD=2, GTK_WRAP_WORD_CHAR=3 };

// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$73 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$G_FILE_TEST_IS_REGULAR=1$G_FILE_TEST_IS_SYMLINK=2$G_FILE_TEST_IS_DIR=4$G_FILE_TEST_IS_EXECUTABLE=8$G_FILE_TEST_EXISTS=16
// file /usr/include/glib-2.0/glib/gfileutils.h line 66
enum anonymous$106 { G_FILE_TEST_IS_REGULAR=1, G_FILE_TEST_IS_SYMLINK=2, G_FILE_TEST_IS_DIR=4, G_FILE_TEST_IS_EXECUTABLE=8, G_FILE_TEST_EXISTS=16 };

// #anon_enum$G_IO_FLAG_APPEND=1$G_IO_FLAG_NONBLOCK=2$G_IO_FLAG_IS_READABLE=4$G_IO_FLAG_IS_WRITABLE=8$G_IO_FLAG_IS_WRITEABLE=8$G_IO_FLAG_IS_SEEKABLE=16$G_IO_FLAG_MASK=31$G_IO_FLAG_GET_MASK=31$G_IO_FLAG_SET_MASK=3
// file /usr/include/glib-2.0/glib/giochannel.h line 84
enum anonymous$72 { G_IO_FLAG_APPEND=1, G_IO_FLAG_NONBLOCK=2, G_IO_FLAG_IS_READABLE=4, G_IO_FLAG_IS_WRITABLE=8, G_IO_FLAG_IS_WRITEABLE=8, G_IO_FLAG_IS_SEEKABLE=16, G_IO_FLAG_MASK=31, G_IO_FLAG_GET_MASK=31, G_IO_FLAG_SET_MASK=3 };

// #anon_enum$G_IO_IN=1$G_IO_OUT=4$G_IO_PRI=2$G_IO_ERR=8$G_IO_HUP=16$G_IO_NVAL=32
// file /usr/include/glib-2.0/glib/gmain.h line 31
enum anonymous$69 { G_IO_IN=1, G_IO_OUT=4, G_IO_PRI=2, G_IO_ERR=8, G_IO_HUP=16, G_IO_NVAL=32 };

// #anon_enum$G_IO_STATUS_ERROR=0$G_IO_STATUS_NORMAL=1$G_IO_STATUS_EOF=2$G_IO_STATUS_AGAIN=3
// file /usr/include/glib-2.0/glib/giochannel.h line 69
enum anonymous$70 { G_IO_STATUS_ERROR=0, G_IO_STATUS_NORMAL=1, G_IO_STATUS_EOF=2, G_IO_STATUS_AGAIN=3 };

// #anon_enum$G_LOG_FLAG_RECURSION=1$G_LOG_FLAG_FATAL=2$G_LOG_LEVEL_ERROR=4$G_LOG_LEVEL_CRITICAL=8$G_LOG_LEVEL_WARNING=16$G_LOG_LEVEL_MESSAGE=32$G_LOG_LEVEL_INFO=64$G_LOG_LEVEL_DEBUG=128$G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous$99 { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// #anon_enum$G_NORMALIZE_DEFAULT=0$G_NORMALIZE_NFD=0$G_NORMALIZE_DEFAULT_COMPOSE=1$G_NORMALIZE_NFC=1$G_NORMALIZE_ALL=2$G_NORMALIZE_NFKD=2$G_NORMALIZE_ALL_COMPOSE=3$G_NORMALIZE_NFKC=3
// file /usr/include/glib-2.0/glib/gunicode.h line 828
enum anonymous$98 { G_NORMALIZE_DEFAULT=0, G_NORMALIZE_NFD=0, G_NORMALIZE_DEFAULT_COMPOSE=1, G_NORMALIZE_NFC=1, G_NORMALIZE_ALL=2, G_NORMALIZE_NFKD=2, G_NORMALIZE_ALL_COMPOSE=3, G_NORMALIZE_NFKC=3 };

// #anon_enum$G_PARAM_READABLE=1$G_PARAM_WRITABLE=2$G_PARAM_READWRITE=3$G_PARAM_CONSTRUCT=4$G_PARAM_CONSTRUCT_ONLY=8$G_PARAM_LAX_VALIDATION=16$G_PARAM_STATIC_NAME=32$G_PARAM_PRIVATE=32$G_PARAM_STATIC_NICK=64$G_PARAM_STATIC_BLURB=128$G_PARAM_EXPLICIT_NOTIFY=1073741824$G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous$5 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum$G_SEEK_CUR=0$G_SEEK_SET=1$G_SEEK_END=2
// file /usr/include/glib-2.0/glib/giochannel.h line 77
enum anonymous$71 { G_SEEK_CUR=0, G_SEEK_SET=1, G_SEEK_END=2 };

// #anon_enum$G_SIGNAL_MATCH_ID=1$G_SIGNAL_MATCH_DETAIL=2$G_SIGNAL_MATCH_CLOSURE=4$G_SIGNAL_MATCH_FUNC=8$G_SIGNAL_MATCH_DATA=16$G_SIGNAL_MATCH_UNBLOCKED=32
// file /usr/include/glib-2.0/gobject/gsignal.h line 173
enum anonymous$74 { G_SIGNAL_MATCH_ID=1, G_SIGNAL_MATCH_DETAIL=2, G_SIGNAL_MATCH_CLOSURE=4, G_SIGNAL_MATCH_FUNC=8, G_SIGNAL_MATCH_DATA=16, G_SIGNAL_MATCH_UNBLOCKED=32 };

// #anon_enum$G_SIGNAL_RUN_FIRST=1$G_SIGNAL_RUN_LAST=2$G_SIGNAL_RUN_CLEANUP=4$G_SIGNAL_NO_RECURSE=8$G_SIGNAL_DETAILED=16$G_SIGNAL_ACTION=32$G_SIGNAL_NO_HOOKS=64$G_SIGNAL_MUST_COLLECT=128$G_SIGNAL_DEPRECATED=256
// file /usr/include/glib-2.0/gobject/gsignal.h line 127
enum anonymous$68 { G_SIGNAL_RUN_FIRST=1, G_SIGNAL_RUN_LAST=2, G_SIGNAL_RUN_CLEANUP=4, G_SIGNAL_NO_RECURSE=8, G_SIGNAL_DETAILED=16, G_SIGNAL_ACTION=32, G_SIGNAL_NO_HOOKS=64, G_SIGNAL_MUST_COLLECT=128, G_SIGNAL_DEPRECATED=256 };

// #anon_enum$G_SPAWN_DEFAULT=0$G_SPAWN_LEAVE_DESCRIPTORS_OPEN=1$G_SPAWN_DO_NOT_REAP_CHILD=2$G_SPAWN_SEARCH_PATH=4$G_SPAWN_STDOUT_TO_DEV_NULL=8$G_SPAWN_STDERR_TO_DEV_NULL=16$G_SPAWN_CHILD_INHERITS_STDIN=32$G_SPAWN_FILE_AND_ARGV_ZERO=64$G_SPAWN_SEARCH_PATH_FROM_ENVP=128$G_SPAWN_CLOEXEC_PIPES=256
// file /usr/include/glib-2.0/glib/gspawn.h line 172
enum anonymous$104 { G_SPAWN_DEFAULT=0, G_SPAWN_LEAVE_DESCRIPTORS_OPEN=1, G_SPAWN_DO_NOT_REAP_CHILD=2, G_SPAWN_SEARCH_PATH=4, G_SPAWN_STDOUT_TO_DEV_NULL=8, G_SPAWN_STDERR_TO_DEV_NULL=16, G_SPAWN_CHILD_INHERITS_STDIN=32, G_SPAWN_FILE_AND_ARGV_ZERO=64, G_SPAWN_SEARCH_PATH_FROM_ENVP=128, G_SPAWN_CLOEXEC_PIPES=256 };

// #anon_enum$G_TYPE_FLAG_ABSTRACT=16$G_TYPE_FLAG_VALUE_ABSTRACT=32
// file /usr/include/glib-2.0/gobject/gtype.h line 993
enum anonymous { G_TYPE_FLAG_ABSTRACT=16, G_TYPE_FLAG_VALUE_ABSTRACT=32 };

// #anon_enum$PANGO_ATTR_INVALID=0$PANGO_ATTR_LANGUAGE=1$PANGO_ATTR_FAMILY=2$PANGO_ATTR_STYLE=3$PANGO_ATTR_WEIGHT=4$PANGO_ATTR_VARIANT=5$PANGO_ATTR_STRETCH=6$PANGO_ATTR_SIZE=7$PANGO_ATTR_FONT_DESC=8$PANGO_ATTR_FOREGROUND=9$PANGO_ATTR_BACKGROUND=10$PANGO_ATTR_UNDERLINE=11$PANGO_ATTR_STRIKETHROUGH=12$PANGO_ATTR_RISE=13$PANGO_ATTR_SHAPE=14$PANGO_ATTR_SCALE=15$PANGO_ATTR_FALLBACK=16$PANGO_ATTR_LETTER_SPACING=17$PANGO_ATTR_UNDERLINE_COLOR=18$PANGO_ATTR_STRIKETHROUGH_COLOR=19$PANGO_ATTR_ABSOLUTE_SIZE=20$PANGO_ATTR_GRAVITY=21$PANGO_ATTR_GRAVITY_HINT=22$PANGO_ATTR_FONT_FEATURES=23$PANGO_ATTR_FOREGROUND_ALPHA=24$PANGO_ATTR_BACKGROUND_ALPHA=25
// file /usr/include/pango-1.0/pango/pango-attributes.h line 150
enum anonymous$2 { PANGO_ATTR_INVALID=0, PANGO_ATTR_LANGUAGE=1, PANGO_ATTR_FAMILY=2, PANGO_ATTR_STYLE=3, PANGO_ATTR_WEIGHT=4, PANGO_ATTR_VARIANT=5, PANGO_ATTR_STRETCH=6, PANGO_ATTR_SIZE=7, PANGO_ATTR_FONT_DESC=8, PANGO_ATTR_FOREGROUND=9, PANGO_ATTR_BACKGROUND=10, PANGO_ATTR_UNDERLINE=11, PANGO_ATTR_STRIKETHROUGH=12, PANGO_ATTR_RISE=13, PANGO_ATTR_SHAPE=14, PANGO_ATTR_SCALE=15, PANGO_ATTR_FALLBACK=16, PANGO_ATTR_LETTER_SPACING=17, PANGO_ATTR_UNDERLINE_COLOR=18, PANGO_ATTR_STRIKETHROUGH_COLOR=19, PANGO_ATTR_ABSOLUTE_SIZE=20, PANGO_ATTR_GRAVITY=21, PANGO_ATTR_GRAVITY_HINT=22, PANGO_ATTR_FONT_FEATURES=23, PANGO_ATTR_FOREGROUND_ALPHA=24, PANGO_ATTR_BACKGROUND_ALPHA=25 };

// #anon_enum$PANGO_STYLE_NORMAL=0$PANGO_STYLE_OBLIQUE=1$PANGO_STYLE_ITALIC=2
// file /usr/include/pango-1.0/pango/pango-font.h line 60
enum anonymous$4 { PANGO_STYLE_NORMAL=0, PANGO_STYLE_OBLIQUE=1, PANGO_STYLE_ITALIC=2 };

// #anon_enum$PANGO_UNDERLINE_NONE=0$PANGO_UNDERLINE_SINGLE=1$PANGO_UNDERLINE_DOUBLE=2$PANGO_UNDERLINE_LOW=3$PANGO_UNDERLINE_ERROR=4
// file /usr/include/pango-1.0/pango/pango-attributes.h line 201
enum anonymous$3 { PANGO_UNDERLINE_NONE=0, PANGO_UNDERLINE_SINGLE=1, PANGO_UNDERLINE_DOUBLE=2, PANGO_UNDERLINE_LOW=3, PANGO_UNDERLINE_ERROR=4 };

// #anon_enum$STRING=0$INT=1$OBJECT=2$FLOAT=3$LIST=4$ERROR=5
// file ./list.h line 23
enum anonymous$34 { STRING=0, INT=1, OBJECT=2, FLOAT=3, LIST=4, ERROR=5 };

// #anon_enum$XML_ATTRIBUTE_CDATA=1$XML_ATTRIBUTE_ID=2$XML_ATTRIBUTE_IDREF=3$XML_ATTRIBUTE_IDREFS=4$XML_ATTRIBUTE_ENTITY=5$XML_ATTRIBUTE_ENTITIES=6$XML_ATTRIBUTE_NMTOKEN=7$XML_ATTRIBUTE_NMTOKENS=8$XML_ATTRIBUTE_ENUMERATION=9$XML_ATTRIBUTE_NOTATION=10
// file /usr/include/libxml2/libxml/tree.h line 206
enum anonymous$61 { XML_ATTRIBUTE_CDATA=1, XML_ATTRIBUTE_ID=2, XML_ATTRIBUTE_IDREF=3, XML_ATTRIBUTE_IDREFS=4, XML_ATTRIBUTE_ENTITY=5, XML_ATTRIBUTE_ENTITIES=6, XML_ATTRIBUTE_NMTOKEN=7, XML_ATTRIBUTE_NMTOKENS=8, XML_ATTRIBUTE_ENUMERATION=9, XML_ATTRIBUTE_NOTATION=10 };

// #anon_enum$XML_ELEMENT_NODE=1$XML_ATTRIBUTE_NODE=2$XML_TEXT_NODE=3$XML_CDATA_SECTION_NODE=4$XML_ENTITY_REF_NODE=5$XML_ENTITY_NODE=6$XML_PI_NODE=7$XML_COMMENT_NODE=8$XML_DOCUMENT_NODE=9$XML_DOCUMENT_TYPE_NODE=10$XML_DOCUMENT_FRAG_NODE=11$XML_NOTATION_NODE=12$XML_HTML_DOCUMENT_NODE=13$XML_DTD_NODE=14$XML_ELEMENT_DECL=15$XML_ATTRIBUTE_DECL=16$XML_ENTITY_DECL=17$XML_NAMESPACE_DECL=18$XML_XINCLUDE_START=19$XML_XINCLUDE_END=20$XML_DOCB_DOCUMENT_NODE=21
// file /usr/include/libxml2/libxml/tree.h line 159
enum anonymous$60 { XML_ELEMENT_NODE=1, XML_ATTRIBUTE_NODE=2, XML_TEXT_NODE=3, XML_CDATA_SECTION_NODE=4, XML_ENTITY_REF_NODE=5, XML_ENTITY_NODE=6, XML_PI_NODE=7, XML_COMMENT_NODE=8, XML_DOCUMENT_NODE=9, XML_DOCUMENT_TYPE_NODE=10, XML_DOCUMENT_FRAG_NODE=11, XML_NOTATION_NODE=12, XML_HTML_DOCUMENT_NODE=13, XML_DTD_NODE=14, XML_ELEMENT_DECL=15, XML_ATTRIBUTE_DECL=16, XML_ENTITY_DECL=17, XML_NAMESPACE_DECL=18, XML_XINCLUDE_START=19, XML_XINCLUDE_END=20, XML_DOCB_DOCUMENT_NODE=21 };

// tag-#anon#ST[*{S8}$S8$'buf'||S32'pos'||S32'len'|]
// file list.h line 51
struct anonymous$90;

// tag-#anon#ST[*{S8}$S8$'name'||EN#anon_enum$GNOME_VFS_FILE_INFO_FIELDS_NONE=0$GNOME_VFS_FILE_INFO_FIELDS_TYPE=1$GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS=2$GNOME_VFS_FILE_INFO_FIELDS_FLAGS=4$GNOME_VFS_FILE_INFO_FIELDS_DEVICE=8$GNOME_VFS_FILE_INFO_FIELDS_INODE=16$GNOME_VFS_FILE_INFO_FIELDS_LINK_COUNT=32$GNOME_VFS_FILE_INFO_FIELDS_SIZE=64$GNOME_VFS_FILE_INFO_FIELDS_BLOCK_COUNT=128$GNOME_VFS_FILE_INFO_FIELDS_IO_BLOCK_SIZE=256$GNOME_VFS_FILE_INFO_FIELDS_ATIME=512$GNOME_VFS_FILE_INFO_FIELDS_MTIME=1024$GNOME_VFS_FILE_INFO_FIELDS_CTIME=2048$GNOME_VFS_FILE_INFO_FIELDS_SYMLINK_NAME=4096$GNOME_VFS_FILE_INFO_FIELDS_MIME_TYPE=8192$GNOME_VFS_FILE_INFO_FIELDS_ACCESS=16384$GNOME_VFS_FILE_INFO_FIELDS_IDS=32768$GNOME_VFS_FILE_INFO_FIELDS_ACL=65536$GNOME_VFS_FILE_INFO_FIELDS_SELINUX_CONTEXT=131072#{U32}$U32$'valid_fields'||EN#anon_enum$GNOME_VFS_FILE_TYPE_UNKNOWN=0$GNOME_VFS_FILE_TYPE_REGULAR=1$GNOME_VFS_FILE_TYPE_DIRECTORY=2$GNOME_VFS_FILE_TYPE_FIFO=3$GNOME_VFS_FILE_TYPE_SOCKET=4$GNOME_VFS_FILE_TYPE_CHARACTER_DEVICE=5$GNOME_VFS_FILE_TYPE_BLOCK_DEVICE=6$GNOME_VFS_FILE_TYPE_SYMBOLIC_LINK=7#{U32}$U32$'type'||EN#anon_enum$GNOME_VFS_PERM_SUID=2048$GNOME_VFS_PERM_SGID=1024$GNOME_VFS_PERM_STICKY=512$GNOME_VFS_PERM_USER_READ=256$GNOME_VFS_PERM_USER_WRITE=128$GNOME_VFS_PERM_USER_EXEC=64$GNOME_VFS_PERM_USER_ALL=448$GNOME_VFS_PERM_GROUP_READ=32$GNOME_VFS_PERM_GROUP_WRITE=16$GNOME_VFS_PERM_GROUP_EXEC=8$GNOME_VFS_PERM_GROUP_ALL=56$GNOME_VFS_PERM_OTHER_READ=4$GNOME_VFS_PERM_OTHER_WRITE=2$GNOME_VFS_PERM_OTHER_EXEC=1$GNOME_VFS_PERM_OTHER_ALL=7$GNOME_VFS_PERM_ACCESS_READABLE=65536$GNOME_VFS_PERM_ACCESS_WRITABLE=131072$GNOME_VFS_PERM_ACCESS_EXECUTABLE=262144#{U32}$U32$'permissions'||EN#anon_enum$GNOME_VFS_FILE_FLAGS_NONE=0$GNOME_VFS_FILE_FLAGS_SYMLINK=1$GNOME_VFS_FILE_FLAGS_LOCAL=2#{U32}$U32$'flags'||U64'device'||U64'inode'||U32'link_count'||U32'uid'||U32'gid'||U32'$pad0'||U64'size'||U64'block_count'||U32'io_block_size'||U32'$pad1'||S64'atime'||S64'mtime'||S64'ctime'||*{S8}$S8$'symlink_name'||*{S8}$S8$'mime_type'||U32'refcount'||U32'$pad2'||*{SYM#tag-_GnomeVFSACL#}$SYM#tag-_GnomeVFSACL#$'acl'||*{S8}$S8$'selinux_context'||*{V}$V$'reserved1'||*{V}$V$'reserved2'||*{V}$V$'reserved3'|]
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 287
struct anonymous$31;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'toplevel_under_pointer'||*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'window_under_pointer'||F64'toplevel_x'||F64'toplevel_y'||U32'state'||U32'button'||U64'motion_hint_serial'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 63
struct anonymous$41;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'window'||*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'native_window'||U64'serial'||S32'owner_events'||U32'time'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 47
struct anonymous$40;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$109;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$111;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$110;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$107;

// tag-#anon#ST[*{V()->V}$V()->V$'f'||*{V}$V$'d'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 165
struct anonymous$10;

// tag-#anon#ST[*{cS8}$cS8$'terminal'||*{cS8}$cS8$'arguments'|]
// file widgets/gm-external-view.c line 70
struct anonymous$103;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$75;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous$65;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous$64;

// tag-#anon#ST[EN#anon_enum$GNOME_VFS_XFER_PROGRESS_STATUS_OK=0$GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR=1$GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE=2$GNOME_VFS_XFER_PROGRESS_STATUS_DUPLICATE=3#{U32}$U32$'status'||EN#anon_enum$GNOME_VFS_OK=0$GNOME_VFS_ERROR_NOT_FOUND=1$GNOME_VFS_ERROR_GENERIC=2$GNOME_VFS_ERROR_INTERNAL=3$GNOME_VFS_ERROR_BAD_PARAMETERS=4$GNOME_VFS_ERROR_NOT_SUPPORTED=5$GNOME_VFS_ERROR_IO=6$GNOME_VFS_ERROR_CORRUPTED_DATA=7$GNOME_VFS_ERROR_WRONG_FORMAT=8$GNOME_VFS_ERROR_BAD_FILE=9$GNOME_VFS_ERROR_TOO_BIG=10$GNOME_VFS_ERROR_NO_SPACE=11$GNOME_VFS_ERROR_READ_ONLY=12$GNOME_VFS_ERROR_INVALID_URI=13$GNOME_VFS_ERROR_NOT_OPEN=14$GNOME_VFS_ERROR_INVALID_OPEN_MODE=15$GNOME_VFS_ERROR_ACCESS_DENIED=16$GNOME_VFS_ERROR_TOO_MANY_OPEN_FILES=17$GNOME_VFS_ERROR_EOF=18$GNOME_VFS_ERROR_NOT_A_DIRECTORY=19$GNOME_VFS_ERROR_IN_PROGRESS=20$GNOME_VFS_ERROR_INTERRUPTED=21$GNOME_VFS_ERROR_FILE_EXISTS=22$GNOME_VFS_ERROR_LOOP=23$GNOME_VFS_ERROR_NOT_PERMITTED=24$GNOME_VFS_ERROR_IS_DIRECTORY=25$GNOME_VFS_ERROR_NO_MEMORY=26$GNOME_VFS_ERROR_HOST_NOT_FOUND=27$GNOME_VFS_ERROR_INVALID_HOST_NAME=28$GNOME_VFS_ERROR_HOST_HAS_NO_ADDRESS=29$GNOME_VFS_ERROR_LOGIN_FAILED=30$GNOME_VFS_ERROR_CANCELLED=31$GNOME_VFS_ERROR_DIRECTORY_BUSY=32$GNOME_VFS_ERROR_DIRECTORY_NOT_EMPTY=33$GNOME_VFS_ERROR_TOO_MANY_LINKS=34$GNOME_VFS_ERROR_READ_ONLY_FILE_SYSTEM=35$GNOME_VFS_ERROR_NOT_SAME_FILE_SYSTEM=36$GNOME_VFS_ERROR_NAME_TOO_LONG=37$GNOME_VFS_ERROR_SERVICE_NOT_AVAILABLE=38$GNOME_VFS_ERROR_SERVICE_OBSOLETE=39$GNOME_VFS_ERROR_PROTOCOL_ERROR=40$GNOME_VFS_ERROR_NO_MASTER_BROWSER=41$GNOME_VFS_ERROR_NO_DEFAULT=42$GNOME_VFS_ERROR_NO_HANDLER=43$GNOME_VFS_ERROR_PARSE=44$GNOME_VFS_ERROR_LAUNCH=45$GNOME_VFS_ERROR_TIMEOUT=46$GNOME_VFS_ERROR_NAMESERVER=47$GNOME_VFS_ERROR_LOCKED=48$GNOME_VFS_ERROR_DEPRECATED_FUNCTION=49$GNOME_VFS_ERROR_INVALID_FILENAME=50$GNOME_VFS_ERROR_NOT_A_SYMBOLIC_LINK=51$GNOME_VFS_NUM_ERRORS=52#{U32}$U32$'vfs_status'||EN#anon_enum$GNOME_VFS_XFER_PHASE_INITIAL=0$GNOME_VFS_XFER_CHECKING_DESTINATION=1$GNOME_VFS_XFER_PHASE_COLLECTING=2$GNOME_VFS_XFER_PHASE_READYTOGO=3$GNOME_VFS_XFER_PHASE_OPENSOURCE=4$GNOME_VFS_XFER_PHASE_OPENTARGET=5$GNOME_VFS_XFER_PHASE_COPYING=6$GNOME_VFS_XFER_PHASE_MOVING=7$GNOME_VFS_XFER_PHASE_READSOURCE=8$GNOME_VFS_XFER_PHASE_WRITETARGET=9$GNOME_VFS_XFER_PHASE_CLOSESOURCE=10$GNOME_VFS_XFER_PHASE_CLOSETARGET=11$GNOME_VFS_XFER_PHASE_DELETESOURCE=12$GNOME_VFS_XFER_PHASE_SETATTRIBUTES=13$GNOME_VFS_XFER_PHASE_FILECOMPLETED=14$GNOME_VFS_XFER_PHASE_CLEANUP=15$GNOME_VFS_XFER_PHASE_COMPLETED=16$GNOME_VFS_XFER_NUM_PHASES=17#{U32}$U32$'phase'||U32'$pad0'||*{S8}$S8$'source_name'||*{S8}$S8$'target_name'||U64'file_index'||U64'files_total'||U64'bytes_total'||U64'file_size'||U64'bytes_copied'||U64'total_bytes_copied'||*{S8}$S8$'duplicate_name'||S32'duplicate_count'||S32'top_level_item'||*{V}$V$'reserved1'||*{V}$V$'reserved2'|]
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-xfer.h line 375
struct anonymous$80;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$108;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous$17;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$143;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$145;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$146;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$122;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$121;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$125;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$126;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$127;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$134;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$131;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$130;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$129;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$138;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$128;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous$135;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$124;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$133;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$139;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$114;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$144;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$119;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$142;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$123;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$132;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$120;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$136;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$140;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$141;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$118;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$117;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$116;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$115;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous$137;

// tag-#anon#ST[U64'gl_pathc'||*{*{S8}$S8$}$*{S8}$S8$$'gl_pathv'||U64'gl_offs'||S32'gl_flags'||U32'$pad0'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'gl_closedir'||*{*{V}$V$(*{V}$V$)->*{V}$V$}$*{V}$V$(*{V}$V$)->*{V}$V$$'gl_readdir'||*{*{V}$V$(*{cS8}$cS8$)->*{V}$V$}$*{V}$V$(*{cS8}$cS8$)->*{V}$V$$'gl_opendir'||*{S32(r*{cS8}$cS8$|r*{V}$V$)->S32}$S32(r*{cS8}$cS8$|r*{V}$V$)->S32$'gl_lstat'||*{S32(r*{cS8}$cS8$|r*{V}$V$)->S32}$S32(r*{cS8}$cS8$|r*{V}$V$)->S32$'gl_stat'|]
// file /usr/include/glob.h line 82
struct anonymous$13;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous$57;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$67;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$8;

// tag-#anon#UN[S8'char_data'||U8'uchar_data'||S32'bool_data'||S32'int_data'||U32'uint_data'||S64'long_data'||U64'ulong_data'||F32'float_data'||F64'double_data'||*{S8}$S8$'string_data'||*{SYM#tag-_GtkObject#}$SYM#tag-_GtkObject#$'object_data'||*{V}$V$'pointer_data'||SYM#tag-#anon#ST[*{V()->V}$V()->V$'f'||*{V}$V$'d'|]#'signal_data'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 149
union anonymous$11;

// tag-#anon#UN[SYM#tag-_GtkImagePixmapData#'pixmap'||SYM#tag-_GtkImageImageData#'image'||SYM#tag-_GtkImagePixbufData#'pixbuf'||SYM#tag-_GtkImageStockData#'stock'||SYM#tag-_GtkImageIconSetData#'icon_set'||SYM#tag-_GtkImageAnimationData#'anim'||SYM#tag-_GtkImageIconNameData#'name'||SYM#tag-_GtkImageGIconData#'gicon'|]
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 154
union anonymous$96;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$66;

// tag-GnomeVFSAsyncHandle
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-async-ops.h line 57
struct GnomeVFSAsyncHandle;

// tag-GnomeVFSMethod
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-uri.h line 54
struct GnomeVFSMethod;

// tag-GnomeVFSMonitorHandle
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-monitor.h line 71
struct GnomeVFSMonitorHandle;

// tag-GnomeVFSURI
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-uri.h line 46
struct GnomeVFSURI;

// tag-_AccelInfo
// file widgets/gm-app-view.c line 76
struct _AccelInfo;

// tag-_AtkObject
// file /usr/include/atk-1.0/atk/atkobject.h line 440
struct _AtkObject;

// tag-_AtkRelationSet
// file /usr/include/atk-1.0/atk/atkobject.h line 442
struct _AtkRelationSet;

// tag-_BlinkInfo
// file widgets/gm-world-text-view.c line 61
struct _BlinkInfo;

// tag-_ComboBoxTypeData
// file dialogs/gm-triggers-dialog.c line 98
struct _ComboBoxTypeData;

// tag-_CustomArgType
// file dialogs/gm-triggers-dialog.c line 55
enum _CustomArgType { CUSTOM_ARG_CREATE=0, CUSTOM_ARG_GET_DATA=1 };

// tag-_EggNotificationBubble
// file widgets/eggnotificationbubble.h line 36
struct _EggNotificationBubble;

// tag-_EggNotificationBubbleClass
// file widgets/eggnotificationbubble.h line 37
struct _EggNotificationBubbleClass;

// tag-_EggTrayIcon
// file widgets/eggtrayicon.h line 43
struct _EggTrayIcon;

// tag-_EggTrayIconClass
// file widgets/eggtrayicon.h line 44
struct _EggTrayIconClass;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GCClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 156
struct _GCClosure;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GConfClient
// file /usr/include/gconf/2/gconf/gconf-client.h line 70
struct _GConfClient;

// tag-_GConfEngine
// file /usr/include/gconf/2/gconf/gconf-engine.h line 38
struct _GConfEngine;

// tag-_GConfEntry
// file /usr/include/gconf/2/gconf/gconf-value.h line 166
struct _GConfEntry;

// tag-_GConfListeners
// file /usr/include/gconf/2/gconf/gconf-listeners.h line 46
struct _GConfListeners;

// tag-_GConfValue
// file /usr/include/gconf/2/gconf/gconf-value.h line 57
struct _GConfValue;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GDir
// file /usr/include/glib-2.0/glib/gdir.h line 37
struct _GDir;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GIConv
// file /usr/include/glib-2.0/glib/gconvert.h line 77
struct _GIConv;

// tag-_GIOChannel
// file /usr/include/glib-2.0/glib/giochannel.h line 41
struct _GIOChannel;

// tag-_GIOFuncs
// file /usr/include/glib-2.0/glib/giochannel.h line 42
struct _GIOFuncs;

// tag-_GIcon
// file /usr/include/glib-2.0/gio/giotypes.h line 102
struct _GIcon;

// tag-_GInterfaceInfo
// file /usr/include/glib-2.0/gobject/gtype.h line 394
struct _GInterfaceInfo;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMainContext
// file /usr/include/glib-2.0/glib/gmain.h line 48
struct _GMainContext;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GOptionGroup
// file /usr/include/glib-2.0/glib/goption.h line 51
struct _GOptionGroup;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GParameter
// file /usr/include/glib-2.0/gobject/gparam.h line 195
struct _GParameter;

// tag-_GPtrArray
// file /usr/include/glib-2.0/glib/garray.h line 39
struct _GPtrArray;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GSignalInvocationHint
// file /usr/include/glib-2.0/gobject/gsignal.h line 33
struct _GSignalInvocationHint;

// tag-_GSource
// file /usr/include/glib-2.0/glib/gmain.h line 64
struct _GSource;

// tag-_GSourceCallbackFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 77
struct _GSourceCallbackFuncs;

// tag-_GSourceFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 130
struct _GSourceFuncs;

// tag-_GSourcePrivate
// file /usr/include/glib-2.0/glib/gmain.h line 65
struct _GSourcePrivate;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_GTimeVal
// file /usr/include/glib-2.0/glib/gtypes.h line 449
struct _GTimeVal;

// tag-_GTypeCValue
// file /usr/include/glib-2.0/gobject/gtype.h line 387
union _GTypeCValue;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInfo
// file /usr/include/glib-2.0/gobject/gtype.h line 392
struct _GTypeInfo;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GTypeInterface
// file /usr/include/glib-2.0/gobject/gtype.h line 390
struct _GTypeInterface;

// tag-_GTypeValueTable
// file /usr/include/glib-2.0/gobject/gtype.h line 395
struct _GTypeValueTable;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkCursor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 104
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDisplay
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 115
struct _GdkDisplay;

// tag-_GdkDisplayPointerHooks
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 37
struct _GdkDisplayPointerHooks;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkImage
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 107
struct _GdkImage;

// tag-_GdkPixbuf
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 155
struct _GdkPixbuf;

// tag-_GdkPixbufAnimation
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h line 44
struct _GdkPixbufAnimation;

// tag-_GdkPixbufAnimationIter
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h line 53
struct _GdkPixbufAnimationIter;

// tag-_GdkPoint
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 68
struct _GdkPoint;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GladeXML
// file /usr/include/libglade-2.0/glade/glade-xml.h line 37
struct _GladeXML;

// tag-_GladeXMLPrivate
// file /usr/include/libglade-2.0/glade/glade-xml.h line 39
struct _GladeXMLPrivate;

// tag-_GmApp
// file ./gm-app.h line 37
struct _GmApp;

// tag-_GmAppClass
// file ./gm-app.h line 49
struct _GmAppClass;

// tag-_GmAppPrivate
// file ./gm-app.h line 32
struct _GmAppPrivate;

// tag-_GmAppView
// file widgets/gm-app-view.h line 31
struct _GmAppView;

// tag-_GmAppViewClass
// file widgets/gm-app-view.h line 43
struct _GmAppViewClass;

// tag-_GmAppViewPrivate
// file widgets/gm-app-view.h line 26
struct _GmAppViewPrivate;

// tag-_GmAppViewWorldMenuItem
// file widgets/gm-app-view.c line 111
struct _GmAppViewWorldMenuItem;

// tag-_GmCellRendererText
// file mcp/gm-cell-renderer-text.h line 22
struct _GmCellRendererText;

// tag-_GmCellRendererTextClass
// file mcp/gm-cell-renderer-text.h line 34
struct _GmCellRendererTextClass;

// tag-_GmCellRendererTextPrivate
// file mcp/gm-cell-renderer-text.h line 17
struct _GmCellRendererTextPrivate;

// tag-_GmColorScheme
// file gm-color-table.c line 201
struct _GmColorScheme;

// tag-_GmColorTable
// file ./gm-color-table.h line 32
struct _GmColorTable;

// tag-_GmColorTableClass
// file gm-color-table.h line 44
struct _GmColorTableClass;

// tag-_GmColorTableItem
// file gm-color-table.c line 12
struct _GmColorTableItem;

// tag-_GmColorTablePrivate
// file gm-color-table.h line 27
struct _GmColorTablePrivate;

// tag-_GmColorTableScheme
// file ./gm-color-table.h line 54
enum _GmColorTableScheme { SCHEME_NONE=0, SCHEME_DEFAULT=1, SCHEME_WHITE_ON_BLACK=2, SCHEME_RXVT=3, SCHEME_XTERM=4, SCHEME_LINUX=5, SCHEME_USER=6 };

// tag-_GmColorTableSchemeItem
// file gm-color-table.c line 19
struct _GmColorTableSchemeItem;

// tag-_GmDebugLevel
// file gm-debug.h line 4
enum _GmDebugLevel { DEBUG_ALWAYS=2, DEBUG_DEFAULT=4, DEBUG_MCP=8, DEBUG_ALL=65535 };

// tag-_GmEditType
// file gm-editor.h line 49
enum _GmEditType { E_LEGACY=0, E_MCP=1 };

// tag-_GmEditingInfo
// file gm-world.h line 38
struct _GmEditingInfo;

// tag-_GmEditor
// file ./gm-editor.h line 26
struct _GmEditor;

// tag-_GmEditorClass
// file gm-editor.h line 38
struct _GmEditorClass;

// tag-_GmEditorPrivate
// file gm-editor.h line 21
struct _GmEditorPrivate;

// tag-_GmEditorView
// file widgets/gm-editor-view.h line 34
struct _GmEditorView;

// tag-_GmEditorViewClass
// file widgets/gm-editor-view.h line 46
struct _GmEditorViewClass;

// tag-_GmEditorViewPrivate
// file widgets/gm-editor-view.h line 29
struct _GmEditorViewPrivate;

// tag-_GmEmbeddedView
// file widgets/gm-embedded-view.h line 34
struct _GmEmbeddedView;

// tag-_GmEmbeddedViewClass
// file widgets/gm-embedded-view.h line 46
struct _GmEmbeddedViewClass;

// tag-_GmEmbeddedViewPrivate
// file widgets/gm-embedded-view.h line 29
struct _GmEmbeddedViewPrivate;

// tag-_GmExternalView
// file widgets/gm-external-view.h line 8
struct _GmExternalView;

// tag-_GmFetchHandle
// file ./gm-support.h line 86
struct _GmFetchHandle;

// tag-_GmIUserlist
// file mcp/gm-iuserlist.h line 17
struct _GmIUserlist;

// tag-_GmIUserlistInterface
// file mcp/gm-iuserlist.h line 18
struct _GmIUserlistInterface;

// tag-_GmKeyValuePair
// file ./gm-support.h line 81
struct _GmKeyValuePair;

// tag-_GmLabelInfo
// file ./gm-support.h line 48
struct _GmLabelInfo;

// tag-_GmLogType
// file ./gm-world.h line 50
enum _GmLogType { LOG_NONE=0, LOG_IN=1, LOG_OUT=2, LOG_STATUS=3, LOG_MCP_IN=4, LOG_MCP_OUT=5, LOG_MCP_STATUS=6 };

// tag-_GmLogView
// file widgets/gm-log-view.h line 32
struct _GmLogView;

// tag-_GmLogViewClass
// file widgets/gm-log-view.h line 44
struct _GmLogViewClass;

// tag-_GmLogViewPrivate
// file widgets/gm-log-view.h line 27
struct _GmLogViewPrivate;

// tag-_GmMcpAwnsPing
// file mcp/gm-mcp-awns-ping.h line 33
struct _GmMcpAwnsPing;

// tag-_GmMcpAwnsPingClass
// file mcp/gm-mcp-awns-ping.h line 45
struct _GmMcpAwnsPingClass;

// tag-_GmMcpAwnsPingPrivate
// file mcp/gm-mcp-awns-ping.h line 28
struct _GmMcpAwnsPingPrivate;

// tag-_GmMcpAwnsStatus
// file mcp/gm-mcp-awns-status.h line 32
struct _GmMcpAwnsStatus;

// tag-_GmMcpAwnsStatusClass
// file mcp/gm-mcp-awns-status.h line 44
struct _GmMcpAwnsStatusClass;

// tag-_GmMcpAwnsStatusPrivate
// file mcp/gm-mcp-awns-status.h line 27
struct _GmMcpAwnsStatusPrivate;

// tag-_GmMcpAwnsStatusView
// file mcp/gm-mcp-awns-status.c line 17
struct _GmMcpAwnsStatusView;

// tag-_GmMcpIcecrewMcpreset
// file mcp/gm-mcp-icecrew-mcpreset.h line 33
struct _GmMcpIcecrewMcpreset;

// tag-_GmMcpIcecrewMcpresetClass
// file mcp/gm-mcp-icecrew-mcpreset.h line 45
struct _GmMcpIcecrewMcpresetClass;

// tag-_GmMcpIcecrewMcpresetPrivate
// file mcp/gm-mcp-icecrew-mcpreset.h line 28
struct _GmMcpIcecrewMcpresetPrivate;

// tag-_GmMcpIcecrewPlayerdb
// file mcp/gm-mcp-icecrew-playerdb.h line 33
struct _GmMcpIcecrewPlayerdb;

// tag-_GmMcpIcecrewPlayerdbClass
// file mcp/gm-mcp-icecrew-playerdb.h line 45
struct _GmMcpIcecrewPlayerdbClass;

// tag-_GmMcpIcecrewPlayerdbPrivate
// file mcp/gm-mcp-icecrew-playerdb.h line 28
struct _GmMcpIcecrewPlayerdbPrivate;

// tag-_GmMcpIcecrewServerinfo
// file mcp/gm-mcp-icecrew-serverinfo.h line 33
struct _GmMcpIcecrewServerinfo;

// tag-_GmMcpIcecrewServerinfoClass
// file mcp/gm-mcp-icecrew-serverinfo.h line 45
struct _GmMcpIcecrewServerinfoClass;

// tag-_GmMcpIcecrewServerinfoPrivate
// file mcp/gm-mcp-icecrew-serverinfo.h line 28
struct _GmMcpIcecrewServerinfoPrivate;

// tag-_GmMcpIcecrewServerinfoView
// file mcp/gm-mcp-icecrew-serverinfo.c line 16
struct _GmMcpIcecrewServerinfoView;

// tag-_GmMcpIcecrewUserlist
// file mcp/gm-mcp-icecrew-userlist.h line 38
struct _GmMcpIcecrewUserlist;

// tag-_GmMcpIcecrewUserlistClass
// file mcp/gm-mcp-icecrew-userlist.h line 50
struct _GmMcpIcecrewUserlistClass;

// tag-_GmMcpIcecrewUserlistPrivate
// file mcp/gm-mcp-icecrew-userlist.h line 33
struct _GmMcpIcecrewUserlistPrivate;

// tag-_GmMcpMudMooSimpleedit
// file mcp/gm-mcp-mud-moo-simpleedit.h line 33
struct _GmMcpMudMooSimpleedit;

// tag-_GmMcpMudMooSimpleeditClass
// file mcp/gm-mcp-mud-moo-simpleedit.h line 45
struct _GmMcpMudMooSimpleeditClass;

// tag-_GmMcpMudMooSimpleeditPrivate
// file mcp/gm-mcp-mud-moo-simpleedit.h line 28
struct _GmMcpMudMooSimpleeditPrivate;

// tag-_GmMcpNegotiate
// file mcp/gm-mcp-negotiate.h line 32
struct _GmMcpNegotiate;

// tag-_GmMcpNegotiateClass
// file mcp/gm-mcp-negotiate.h line 44
struct _GmMcpNegotiateClass;

// tag-_GmMcpNegotiatePrivate
// file mcp/gm-mcp-negotiate.h line 27
struct _GmMcpNegotiatePrivate;

// tag-_GmMcpPackage
// file ./mcp/gm-mcp-package.h line 33
struct _GmMcpPackage;

// tag-_GmMcpPackageClass
// file mcp/gm-mcp-package.h line 45
struct _GmMcpPackageClass;

// tag-_GmMcpPackagePrivate
// file mcp/gm-mcp-package.h line 28
struct _GmMcpPackagePrivate;

// tag-_GmMcpSession
// file ./mcp/gm-mcp-session.h line 43
struct _GmMcpSession;

// tag-_GmMcpSessionClass
// file mcp/gm-mcp-session.h line 55
struct _GmMcpSessionClass;

// tag-_GmMcpSessionPrivate
// file mcp/gm-mcp-session.h line 38
struct _GmMcpSessionPrivate;

// tag-_GmMcpUserlistView
// file mcp/gm-mcp-userlist-view.c line 15
struct _GmMcpUserlistView;

// tag-_GmMcpVmooClient
// file mcp/gm-mcp-vmoo-client.h line 33
struct _GmMcpVmooClient;

// tag-_GmMcpVmooClientClass
// file mcp/gm-mcp-vmoo-client.h line 45
struct _GmMcpVmooClientClass;

// tag-_GmMcpVmooClientView
// file mcp/gm-mcp-vmoo-client.c line 17
struct _GmMcpVmooClientView;

// tag-_GmMcpVmooUserlist
// file mcp/gm-mcp-vmoo-userlist.h line 33
struct _GmMcpVmooUserlist;

// tag-_GmMcpVmooUserlistClass
// file mcp/gm-mcp-vmoo-userlist.h line 45
struct _GmMcpVmooUserlistClass;

// tag-_GmMcpVmooUserlistPrivate
// file mcp/gm-mcp-vmoo-userlist.h line 28
struct _GmMcpVmooUserlistPrivate;

// tag-_GmNet
// file gm-net.h line 47
struct _GmNet;

// tag-_GmNetClass
// file gm-net.h line 59
struct _GmNetClass;

// tag-_GmNetPrivate
// file gm-net.h line 42
struct _GmNetPrivate;

// tag-_GmNetState
// file ./gm-net.h line 26
enum _GmNetState { GM_NET_STATE_CONNECTED=0, GM_NET_STATE_DISCONNECTED=1, GM_NET_STATE_CONNECTING=2, GM_NET_STATE_TRY_ADDRESS=3, GM_NET_STATE_DISCONNECTING=4, GM_NET_STATE_END=5 };

// tag-_GmOpenWorldDialog
// file dialogs/gm-open-world-dialog.c line 16
struct _GmOpenWorldDialog;

// tag-_GmOptions
// file ./gm-options.h line 32
struct _GmOptions;

// tag-_GmOptionsClass
// file gm-options.h line 44
struct _GmOptionsClass;

// tag-_GmOptionsPrivate
// file gm-options.h line 27
struct _GmOptionsPrivate;

// tag-_GmPixbufInfo
// file gm-pixbuf.h line 7
struct _GmPixbufInfo;

// tag-_GmPlayerdbPlayerInfo
// file mcp/gm-mcp-icecrew-playerdb.h line 57
struct _GmPlayerdbPlayerInfo;

// tag-_GmPreferencesDialog
// file dialogs/gm-preferences-dialog.c line 76
struct _GmPreferencesDialog;

// tag-_GmSchemedFlags
// file ./gm-support.h line 160
enum _GmSchemedFlags { GM_SCHEMED_COLORS=1, GM_SCHEMED_FONT=2 };

// tag-_GmSearchable
// file widgets/gm-searchable.h line 17
struct _GmSearchable;

// tag-_GmSearchableInterface
// file widgets/gm-searchable.h line 18
struct _GmSearchableInterface;

// tag-_GmSearchableSearchFlags
// file widgets/gm-searchable.h line 20
enum _GmSearchableSearchFlags { GM_SEARCHABLE_SEARCH_NONE=0, GM_SEARCHABLE_SEARCH_FORWARDS=1, GM_SEARCHABLE_SEARCH_BACKWARDS=2, GM_SEARCHABLE_SEARCH_CASE_INSENSITIVE=4 };

// tag-_GmSourceStyleEntry
// file widgets/gm-source-style-scheme.c line 134
struct _GmSourceStyleEntry;

// tag-_GmSourceStyleScheme
// file widgets/gm-source-style-scheme.c line 21
struct _GmSourceStyleScheme;

// tag-_GmSourceStyleSchemeClass
// file widgets/gm-source-style-scheme.c line 22
struct _GmSourceStyleSchemeClass;

// tag-_GmTextScroller
// file widgets/gm-text-scroller.h line 25
struct _GmTextScroller;

// tag-_GmTextScrollerClass
// file widgets/gm-text-scroller.h line 37
struct _GmTextScrollerClass;

// tag-_GmTextScrollerPrivate
// file widgets/gm-text-scroller.h line 20
struct _GmTextScrollerPrivate;

// tag-_GmTray
// file widgets/gm-tray.h line 40
struct _GmTray;

// tag-_GmTrayClass
// file widgets/gm-tray.h line 52
struct _GmTrayClass;

// tag-_GmTrayPrivate
// file widgets/gm-tray.h line 27
struct _GmTrayPrivate;

// tag-_GmTrayState
// file widgets/gm-tray.h line 29
enum _GmTrayState { TRAY_STATE_NORMAL=0, TRAY_STATE_ACTIVE=1, TRAY_STATE_ACTIVITY=2, TRAY_STATE_NOTIFY=3, NUM_TRAY_STATES=4 };

// tag-_GmTrigger
// file ./gm-triggers.h line 91
struct _GmTrigger;

// tag-_GmTriggerConditionType
// file ./gm-triggers.h line 58
enum _GmTriggerConditionType { TCT_CONTAINS=0, TCT_NOT_CONTAINS=1, TCT_BEGINS=2, TCT_NOT_BEGINS=3, TCT_ENDS=4, TCT_NOT_ENDS=5, TCT_MATCHES=6, TCT_NOT_MATCHES=7, TCT_USER_ONLINE=8, TCT_USER_OFFLINE=9, TCT_USER_IDLE=10, TCT_USER_IDLE_OFF=11, TCT_USER_AWAY=12, TCT_USER_AWAY_OFF=13 };

// tag-_GmTriggerData
// file ./gm-triggers.h line 85
struct _GmTriggerData;

// tag-_GmTriggerType
// file ./gm-triggers.h line 53
enum _GmTriggerType { TT_OUTPUT=0, TT_USERS=1 };

// tag-_GmTriggers
// file ./gm-triggers.h line 33
struct _GmTriggers;

// tag-_GmTriggersClass
// file gm-triggers.h line 45
struct _GmTriggersClass;

// tag-_GmTriggersDialog
// file dialogs/gm-triggers-dialog.c line 24
struct _GmTriggersDialog;

// tag-_GmTriggersPrivate
// file gm-triggers.h line 28
struct _GmTriggersPrivate;

// tag-_GmUserlistSortType
// file mcp/gm-mcp-userlist-view.h line 21
enum _GmUserlistSortType { GM_USERLIST_SORT_TYPE_STATE_RANK_NAME=0, GM_USERLIST_SORT_TYPE_RANK_NAME=1, GM_USERLIST_SORT_TYPE_STATE_NAME=2, GM_USERLIST_SORT_TYPE_NAME=3, GM_USERLIST_SORT_TYPE_NUM=4 };

// tag-_GmWorld
// file ./gm-world.h line 67
struct _GmWorld;

// tag-_GmWorldClass
// file gm-world.h line 79
struct _GmWorldClass;

// tag-_GmWorldInfo
// file dialogs/gm-world-info-dialog.h line 4
struct _GmWorldInfo;

// tag-_GmWorldInputView
// file widgets/gm-world-input-view.h line 26
struct _GmWorldInputView;

// tag-_GmWorldInputViewClass
// file widgets/gm-world-input-view.h line 38
struct _GmWorldInputViewClass;

// tag-_GmWorldInputViewPrivate
// file widgets/gm-world-input-view.h line 21
struct _GmWorldInputViewPrivate;

// tag-_GmWorldPasteDialog
// file dialogs/gm-world-paste-dialog.c line 16
struct _GmWorldPasteDialog;

// tag-_GmWorldPrivate
// file gm-world.h line 62
struct _GmWorldPrivate;

// tag-_GmWorldPropertiesDialog
// file dialogs/gm-world-properties-dialog.c line 25
struct _GmWorldPropertiesDialog;

// tag-_GmWorldTab
// file widgets/gm-world-tab.h line 25
struct _GmWorldTab;

// tag-_GmWorldTabClass
// file widgets/gm-world-tab.h line 37
struct _GmWorldTabClass;

// tag-_GmWorldTabPrivate
// file widgets/gm-world-tab.h line 20
struct _GmWorldTabPrivate;

// tag-_GmWorldTextView
// file widgets/gm-world-text-view.h line 26
struct _GmWorldTextView;

// tag-_GmWorldTextViewClass
// file widgets/gm-world-text-view.h line 38
struct _GmWorldTextViewClass;

// tag-_GmWorldTextViewInsertInfo
// file widgets/gm-world-text-view.c line 59
struct _GmWorldTextViewInsertInfo;

// tag-_GmWorldTextViewPrivate
// file widgets/gm-world-text-view.h line 21
struct _GmWorldTextViewPrivate;

// tag-_GmWorldView
// file widgets/gm-world-view.h line 36
struct _GmWorldView;

// tag-_GmWorldViewClass
// file widgets/gm-world-view.h line 48
struct _GmWorldViewClass;

// tag-_GmWorldViewPrivate
// file widgets/gm-world-view.h line 31
struct _GmWorldViewPrivate;

// tag-_GmWorldsListDialog
// file dialogs/gm-worlds-list-dialog.c line 24
struct _GmWorldsListDialog;

// tag-_GmWorldsView
// file widgets/gm-worlds-view.h line 39
struct _GmWorldsView;

// tag-_GmWorldsViewClass
// file widgets/gm-worlds-view.h line 51
struct _GmWorldsViewClass;

// tag-_GmWorldsViewPrivate
// file widgets/gm-worlds-view.h line 34
struct _GmWorldsViewPrivate;

// tag-_GnomeClient
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 46
struct _GnomeClient;

// tag-_GnomeModuleInfo
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 144
struct _GnomeModuleInfo;

// tag-_GnomeModuleRequirement
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 145
struct _GnomeModuleRequirement;

// tag-_GnomeProgram
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 52
struct _GnomeProgram;

// tag-_GnomeProgramClass
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 54
struct _GnomeProgramClass;

// tag-_GnomeProgramPrivate
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 53
struct _GnomeProgramPrivate;

// tag-_GnomeVFSACL
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-acl.h line 72
struct _GnomeVFSACL;

// tag-_GnomeVFSACLPrivate
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-acl.h line 75
struct _GnomeVFSACLPrivate;

// tag-_GtkAccelGroup
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 60
struct _GtkAccelGroup;

// tag-_GtkAccelGroupEntry
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 63
struct _GtkAccelGroupEntry;

// tag-_GtkAccelKey
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 62
struct _GtkAccelKey;

// tag-_GtkAction
// file /usr/include/gtk-2.0/gtk/gtkaction.h line 49
struct _GtkAction;

// tag-_GtkActionEntry
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 53
struct _GtkActionEntry;

// tag-_GtkActionGroup
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 50
struct _GtkActionGroup;

// tag-_GtkActionGroupPrivate
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 51
struct _GtkActionGroupPrivate;

// tag-_GtkActionPrivate
// file /usr/include/gtk-2.0/gtk/gtkaction.h line 51
struct _GtkActionPrivate;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkArg
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 48
struct _GtkArg;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBinClass
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 49
struct _GtkBinClass;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkBoxClass
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 50
struct _GtkBoxClass;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkCellEditable
// file /usr/include/gtk-2.0/gtk/gtkcelleditable.h line 37
struct _GtkCellEditable;

// tag-_GtkCellLayout
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 39
struct _GtkCellLayout;

// tag-_GtkCellRenderer
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 55
struct _GtkCellRenderer;

// tag-_GtkCellRendererClass
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 56
struct _GtkCellRendererClass;

// tag-_GtkCellRendererText
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 41
struct _GtkCellRendererText;

// tag-_GtkCellRendererTextClass
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 42
struct _GtkCellRendererTextClass;

// tag-_GtkCheckButton
// file /usr/include/gtk-2.0/gtk/gtkcheckbutton.h line 48
struct _GtkCheckButton;

// tag-_GtkClipboard
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 483
struct _GtkClipboard;

// tag-_GtkColorButton
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 58
struct _GtkColorButton;

// tag-_GtkColorButtonPrivate
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 60
struct _GtkColorButtonPrivate;

// tag-_GtkComboBox
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 40
struct _GtkComboBox;

// tag-_GtkComboBoxEntry
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 41
struct _GtkComboBoxEntry;

// tag-_GtkComboBoxEntryPrivate
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 43
struct _GtkComboBoxEntryPrivate;

// tag-_GtkComboBoxPrivate
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 42
struct _GtkComboBoxPrivate;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkContainerClass
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 52
struct _GtkContainerClass;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkEditable
// file /usr/include/gtk-2.0/gtk/gtkeditable.h line 47
struct _GtkEditable;

// tag-_GtkEntry
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 63
struct _GtkEntry;

// tag-_GtkExpander
// file /usr/include/gtk-2.0/gtk/gtkexpander.h line 42
struct _GtkExpander;

// tag-_GtkExpanderPrivate
// file /usr/include/gtk-2.0/gtk/gtkexpander.h line 44
struct _GtkExpanderPrivate;

// tag-_GtkFileChooser
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 37
struct _GtkFileChooser;

// tag-_GtkFontButton
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 49
struct _GtkFontButton;

// tag-_GtkFontButtonPrivate
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 51
struct _GtkFontButtonPrivate;

// tag-_GtkHBox
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 48
struct _GtkHBox;

// tag-_GtkHBoxClass
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 49
struct _GtkHBoxClass;

// tag-_GtkHPaned
// file /usr/include/gtk-2.0/gtk/gtkhpaned.h line 46
struct _GtkHPaned;

// tag-_GtkIMContext
// file /usr/include/gtk-2.0/gtk/gtkimcontext.h line 42
struct _GtkIMContext;

// tag-_GtkIconFactory
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 40
struct _GtkIconFactory;

// tag-_GtkIconSet
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 58
struct _GtkIconSet;

// tag-_GtkIconSource
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 59
struct _GtkIconSource;

// tag-_GtkIconTheme
// file /usr/include/gtk-2.0/gtk/gtkicontheme.h line 42
struct _GtkIconTheme;

// tag-_GtkIconThemePrivate
// file /usr/include/gtk-2.0/gtk/gtkicontheme.h line 44
struct _GtkIconThemePrivate;

// tag-_GtkImage
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 49
struct _GtkImage;

// tag-_GtkImageAnimationData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 57
struct _GtkImageAnimationData;

// tag-_GtkImageGIconData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 59
struct _GtkImageGIconData;

// tag-_GtkImageIconNameData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 58
struct _GtkImageIconNameData;

// tag-_GtkImageIconSetData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 56
struct _GtkImageIconSetData;

// tag-_GtkImageImageData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 53
struct _GtkImageImageData;

// tag-_GtkImagePixbufData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 54
struct _GtkImagePixbufData;

// tag-_GtkImagePixmapData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 52
struct _GtkImagePixmapData;

// tag-_GtkImageStockData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 55
struct _GtkImageStockData;

// tag-_GtkItem
// file /usr/include/gtk-2.0/gtk/gtkitem.h line 48
struct _GtkItem;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkListStore
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 42
struct _GtkListStore;

// tag-_GtkMenu
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 49
struct _GtkMenu;

// tag-_GtkMenuBar
// file /usr/include/gtk-2.0/gtk/gtkmenubar.h line 48
struct _GtkMenuBar;

// tag-_GtkMenuItem
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 48
struct _GtkMenuItem;

// tag-_GtkMenuShell
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 48
struct _GtkMenuShell;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkNotebook
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 55
struct _GtkNotebook;

// tag-_GtkNotebookClass
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 56
struct _GtkNotebookClass;

// tag-_GtkNotebookPage
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 58
struct _GtkNotebookPage;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkObjectClass
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 104
struct _GtkObjectClass;

// tag-_GtkPaned
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 46
struct _GtkPaned;

// tag-_GtkPanedPrivate
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 48
struct _GtkPanedPrivate;

// tag-_GtkPlug
// file /usr/include/gtk-2.0/gtk/gtkplug.h line 48
struct _GtkPlug;

// tag-_GtkPlugClass
// file /usr/include/gtk-2.0/gtk/gtkplug.h line 49
struct _GtkPlugClass;

// tag-_GtkRcContext
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 41
struct _GtkRcContext;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSelectionData
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 479
struct _GtkSelectionData;

// tag-_GtkSettings
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 61
struct _GtkSettings;

// tag-_GtkSettingsPropertyValue
// file /usr/include/gtk-2.0/gtk/gtksettings.h line 43
struct _GtkSettingsPropertyValue;

// tag-_GtkSourceBuffer
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 44
struct _GtkSourceBuffer;

// tag-_GtkSourceBufferPrivate
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 46
struct _GtkSourceBufferPrivate;

// tag-_GtkSourceLanguage
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcelanguage.h line 38
struct _GtkSourceLanguage;

// tag-_GtkSourceLanguageManager
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcelanguagemanager.h line 36
struct _GtkSourceLanguageManager;

// tag-_GtkSourceLanguageManagerPrivate
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcelanguagemanager.h line 38
struct _GtkSourceLanguageManagerPrivate;

// tag-_GtkSourceLanguagePrivate
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcelanguage.h line 40
struct _GtkSourceLanguagePrivate;

// tag-_GtkSourceStyleScheme
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcestylescheme.h line 36
struct _GtkSourceStyleScheme;

// tag-_GtkSourceStyleSchemeClass
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcestylescheme.h line 38
struct _GtkSourceStyleSchemeClass;

// tag-_GtkSourceStyleSchemePrivate
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcestylescheme.h line 37
struct _GtkSourceStyleSchemePrivate;

// tag-_GtkSourceView
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcecompletion.h line 56
struct _GtkSourceView;

// tag-_GtkSourceViewPrivate
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h line 58
struct _GtkSourceViewPrivate;

// tag-_GtkSpinButton
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 71
struct _GtkSpinButton;

// tag-_GtkStatusbar
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 47
struct _GtkStatusbar;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkTable
// file /usr/include/gtk-2.0/gtk/gtktable.h line 48
struct _GtkTable;

// tag-_GtkTableRowCol
// file /usr/include/gtk-2.0/gtk/gtktable.h line 51
struct _GtkTableRowCol;

// tag-_GtkTargetEntry
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 42
struct _GtkTargetEntry;

// tag-_GtkTargetList
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 41
struct _GtkTargetList;

// tag-_GtkTextAppearance
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 170
struct _GtkTextAppearance;

// tag-_GtkTextAttributes
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 70
struct _GtkTextAttributes;

// tag-_GtkTextBTree
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 61
struct _GtkTextBTree;

// tag-_GtkTextBuffer
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 51
struct _GtkTextBuffer;

// tag-_GtkTextIter
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 67
struct _GtkTextIter;

// tag-_GtkTextLayout
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 72
struct _GtkTextLayout;

// tag-_GtkTextLogAttrCache
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 63
struct _GtkTextLogAttrCache;

// tag-_GtkTextMark
// file /usr/include/gtk-2.0/gtk/gtktextmark.h line 61
struct _GtkTextMark;

// tag-_GtkTextPendingScroll
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 66
struct _GtkTextPendingScroll;

// tag-_GtkTextTag
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 81
struct _GtkTextTag;

// tag-_GtkTextTagTable
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 68
struct _GtkTextTagTable;

// tag-_GtkTextView
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 61
struct _GtkTextView;

// tag-_GtkTextViewClass
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 62
struct _GtkTextViewClass;

// tag-_GtkTextWindow
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 65
struct _GtkTextWindow;

// tag-_GtkToggleAction
// file /usr/include/gtk-2.0/gtk/gtktoggleaction.h line 49
struct _GtkToggleAction;

// tag-_GtkToggleActionEntry
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 54
struct _GtkToggleActionEntry;

// tag-_GtkToggleActionPrivate
// file /usr/include/gtk-2.0/gtk/gtktoggleaction.h line 50
struct _GtkToggleActionPrivate;

// tag-_GtkToggleButton
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 48
struct _GtkToggleButton;

// tag-_GtkToolbar
// file /usr/include/gtk-2.0/gtk/gtktoolbar.h line 89
struct _GtkToolbar;

// tag-_GtkTooltip
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 484
struct _GtkTooltip;

// tag-_GtkTooltips
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 46
struct _GtkTooltips;

// tag-_GtkTooltipsData
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 48
struct _GtkTooltipsData;

// tag-_GtkTreeIter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 43
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 46
struct _GtkTreeModel;

// tag-_GtkTreeModelSort
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 40
struct _GtkTreeModelSort;

// tag-_GtkTreePath
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 44
struct _GtkTreePath;

// tag-_GtkTreeRowReference
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 45
struct _GtkTreeRowReference;

// tag-_GtkTreeSelection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 58
struct _GtkTreeSelection;

// tag-_GtkTreeSortable
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 45
struct _GtkTreeSortable;

// tag-_GtkTreeView
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 55
struct _GtkTreeView;

// tag-_GtkTreeViewClass
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 56
struct _GtkTreeViewClass;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 52
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 57
struct _GtkTreeViewPrivate;

// tag-_GtkUIManager
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 52
struct _GtkUIManager;

// tag-_GtkUIManagerPrivate
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 54
struct _GtkUIManagerPrivate;

// tag-_GtkVBox
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 48
struct _GtkVBox;

// tag-_GtkVBoxClass
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 49
struct _GtkVBoxClass;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWidgetClass
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 480
struct _GtkWidgetClass;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowClass
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 49
struct _GtkWindowClass;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_LevelMap
// file gm-debug.c line 11
struct _LevelMap;

// tag-_MOOVar
// file ./list.h line 27
struct _MOOVar;

// tag-_McpMessageInfo
// file mcp/gm-mcp.h line 10
struct _McpMessageInfo;

// tag-_McpMultilineInfo
// file mcp/gm-mcp-session.h line 27
struct _McpMultilineInfo;

// tag-_ModelData
// file dialogs/gm-triggers-dialog.c line 86
struct _ModelData;

// tag-_Notify
// file widgets/eggtrayicon.h line 46
struct _Notify;

// tag-_NotifyNotification
// file /usr/include/libnotify/notification.h line 54
struct _NotifyNotification;

// tag-_NotifyNotificationPrivate
// file /usr/include/libnotify/notification.h line 56
struct _NotifyNotificationPrivate;

// tag-_PackageInfo
// file mcp/gm-mcp-negotiate.c line 15
struct _PackageInfo;

// tag-_PangoAttrClass
// file /usr/include/pango-1.0/pango/pango-attributes.h line 68
struct _PangoAttrClass;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoAttribute
// file /usr/include/pango-1.0/pango/pango-attributes.h line 67
struct _PangoAttribute;

// tag-_PangoColor
// file /usr/include/pango-1.0/pango/pango-attributes.h line 32
struct _PangoColor;

// tag-_PangoContext
// file /usr/include/pango-1.0/pango/pango-fontmap.h line 51
struct _PangoContext;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLanguage
// file /usr/include/pango-1.0/pango/pango-language.h line 30
struct _PangoLanguage;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-_PangoTabArray
// file /usr/include/pango-1.0/pango/pango-tabs.h line 29
struct _PangoTabArray;

// tag-_SortInfo
// file mcp/gm-mcp-userlist-view.c line 61
struct _SortInfo;

// tag-_TagPair
// file dialogs/gm-triggers-dialog.c line 93
struct _TagPair;

// tag-_UserInfo
// file mcp/gm-mcp-vmoo-userlist.c line 36
struct _UserInfo;

// tag-_UserState
// file mcp/gm-mcp-vmoo-userlist.c line 29
enum _UserState { U_NORMAL=0, U_AWAY=1, U_IDLE=2, U_IDLEAWAY=3 };

// tag-_VteTerminal
// file /usr/include/vte-0.0/vte/vte.h line 56
struct _VteTerminal;

// tag-_VteTerminalPrivate
// file /usr/include/vte-0.0/vte/vte.h line 57
struct _VteTerminalPrivate;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_ansi_code
// file ./gm-ansi.h line 12
enum _ansi_code { A_DEFAULT=0, A_BOLD=1, A_FAINT=2, A_ITALIC=3, A_UNDERLINE=4, A_BLINK=5, A_BLINK_FAST=6, A_INVERSE=7, A_INVISIBLE=8, A_CROSSOUT=9, A_DOUBLE_UNDERLINE=21, A_BOLD_OFF=22, A_ITALIC_OFF=23, A_UNDERLINE_OFF=24, A_BLINK_OFF=25, A_BLINK_FAST_OFF=26, A_INVERSE_OFF=27, A_INVISIBLE_OFF=28, A_CROSSOUT_OFF=29, A_FG_BLACK=30, A_FG_RED=31, A_FG_GREEN=32, A_FG_YELLOW=33, A_FG_BLUE=34, A_FG_PURPLE=35, A_FG_CYAN=36, A_FG_WHITE=37, A_FG_DEFAULT=39, A_BG_BLACK=40, A_BG_RED=41, A_BG_GREEN=42, A_BG_YELLOW=43, A_BG_BLUE=44, A_BG_PURPLE=45, A_BG_CYAN=46, A_BG_WHITE=47, A_BG_DEFAULT=49, A_NOWRAP=50, A_FG_BLACK_H=51, A_FG_RED_H=52, A_FG_GREEN_H=53, A_FG_YELLOW_H=54, A_FG_BLUE_H=55, A_FG_PURPLE_H=56, A_FG_CYAN_H=57, A_FG_WHITE_H=58, A_FG_DEFAULT_H=59 };

// tag-_ansinamepair
// file ./gm-ansi.h line 71
struct _ansinamepair;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-_encoding
// file dialogs/gm-world-properties-dialog.h line 7
struct _encoding;

// tag-_threadinfo
// file gm-net.c line 25
struct _threadinfo;

// tag-_trigger_trans
// file gm-triggers.c line 10
struct _trigger_trans;

// tag-_xmlAttr
// file /usr/include/libxml2/libxml/tree.h line 432
struct _xmlAttr;

// tag-_xmlDict
// file /usr/include/libxml2/libxml/dict.h line 25
struct _xmlDict;

// tag-_xmlDoc
// file /usr/include/libxml2/libxml/tree.h line 262
struct _xmlDoc;

// tag-_xmlDtd
// file /usr/include/libxml2/libxml/tree.h line 259
struct _xmlDtd;

// tag-_xmlNode
// file /usr/include/libxml2/libxml/tree.h line 257
struct _xmlNode;

// tag-_xmlNs
// file /usr/include/libxml2/libxml/tree.h line 387
struct _xmlNs;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-lconv
// file /usr/include/locale.h line 53
struct lconv;

// tag-poptOption
// file /usr/include/popt.h line 125
struct poptOption;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// MOOVar_free
// file ./list.h line 43
void MOOVar_free(struct _MOOVar *var);
// MOOVar_listappend
// file list.c line 404
void MOOVar_listappend(struct _MOOVar *var, struct _MOOVar *item);
// MOOVar_listindex
// file list.c line 472
struct _MOOVar * MOOVar_listindex(struct _MOOVar *list, signed int index);
// MOOVar_new_error
// file list.c line 339
struct _MOOVar * MOOVar_new_error(const char *try_error);
// MOOVar_new_float
// file list.c line 356
struct _MOOVar * MOOVar_new_float(const char *d);
// MOOVar_new_int
// file list.c line 376
struct _MOOVar * MOOVar_new_int(const char *i);
// MOOVar_new_list
// file list.c line 209
struct _MOOVar * MOOVar_new_list();
// MOOVar_new_object
// file list.c line 222
struct _MOOVar * MOOVar_new_object(signed int obj);
// MOOVar_new_string
// file list.c line 235
struct _MOOVar * MOOVar_new_string(const char *string);
// MOOVar_parse
// file ./list.h line 45
struct _MOOVar * MOOVar_parse(const char *s);
// MOOVar_tostr
// file list.c line 460
char * MOOVar_tostr(struct _MOOVar *v);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XGetSelectionOwner
// file /usr/include/X11/Xlib.h line 1632
extern unsigned long int XGetSelectionOwner(struct _XDisplay *, unsigned long int);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XGrabServer
// file /usr/include/X11/Xlib.h line 2741
extern signed int XGrabServer(struct _XDisplay *);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XScreenNumberOfScreen
// file /usr/include/X11/Xlib.h line 1839
extern signed int XScreenNumberOfScreen(struct anonymous$109 *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSendEvent
// file /usr/include/X11/Xlib.h line 3135
extern signed int XSendEvent(struct _XDisplay *, unsigned long int, signed int, signed long int, union _XEvent *);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XUngrabServer
// file /usr/include/X11/Xlib.h line 3486
extern signed int XUngrabServer(struct _XDisplay *);
// __atomic_load_8
// file widgets/gm-app-view.c line 167 function gm_app_view_get_type
//signed int __atomic_load_8(void);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$65 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$65 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$65 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _gm_options_check_old_options
// file ./gm-options.h line 67
void _gm_options_check_old_options(const char *xmlname);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// add_bevels_to_rectangle
// file widgets/eggnotificationbubble.c line 277
static struct _GdkRegion * add_bevels_to_rectangle(struct _GdkRectangle *rectangle);
// addrinfo_thread
// file gm-net.c line 510
static void * addrinfo_thread(void *ptr);
// addrinfo_thread::1::1::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// backward_lines_match
// file widgets/gm-searchable.c line 326
static signed int backward_lines_match(const struct _GtkTextIter *start, const char **lines, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end);
// bind_textdomain_codeset
// file /usr/include/libintl.h line 91
extern char * bind_textdomain_codeset(const char *, const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// blink_info_free
// file widgets/gm-world-text-view.c line 239
static void blink_info_free(struct _BlinkInfo *info);
// bubble_window_display_closed
// file widgets/eggnotificationbubble.c line 123
static void bubble_window_display_closed(struct _GdkDisplay *display, signed int was_error, struct _EggNotificationBubble *bubble);
// build_terminal_command
// file widgets/gm-external-view.c line 140
static char ** build_terminal_command(const char *editor_command);
// cell_renderer_text_finalize
// file mcp/gm-cell-renderer-text.c line 83
static void cell_renderer_text_finalize(struct _GObject *object);
// cell_renderer_text_get_property
// file mcp/gm-cell-renderer-text.c line 95
static void cell_renderer_text_get_property(struct _GObject *object, unsigned int param_id, struct _GValue *value, struct _GParamSpec *pspec);
// cell_renderer_text_get_size
// file mcp/gm-cell-renderer-text.c line 148
static void cell_renderer_text_get_size(struct _GtkCellRenderer *cell, struct _GtkWidget *widget, struct _GdkRectangle *cell_area, signed int *x_offset, signed int *y_offset, signed int *width, signed int *height);
// cell_renderer_text_render
// file mcp/gm-cell-renderer-text.c line 162
static void cell_renderer_text_render(struct _GtkCellRenderer *cell, struct _GdkDrawable *window, struct _GtkWidget *widget, struct _GdkRectangle *background_area, struct _GdkRectangle *cell_area, struct _GdkRectangle *expose_area, enum anonymous$1 flags);
// cell_renderer_text_set_property
// file mcp/gm-cell-renderer-text.c line 115
static void cell_renderer_text_set_property(struct _GObject *object, unsigned int param_id, const struct _GValue *value, struct _GParamSpec *pspec);
// cell_renderer_text_update_text
// file mcp/gm-cell-renderer-text.c line 178
static void cell_renderer_text_update_text(struct _GmCellRendererText *cell, struct _GtkWidget *widget, signed int new_width, signed int selected);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// create_button
// file widgets/gm-app-view.c line 429
struct _GtkWidget * create_button(char *label, char *stock);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// difftime
// file /usr/include/time.h line 195
extern double difftime(signed long int, signed long int);
// disconnect_bubble_window_display_closed
// file widgets/eggnotificationbubble.c line 131
static void disconnect_bubble_window_display_closed(struct _EggNotificationBubble *bubble);
// do_MOOVar_parse
// file list.c line 79
struct _MOOVar * do_MOOVar_parse(const char **s);
// do_MOOVar_tostr
// file list.c line 417
void do_MOOVar_tostr(struct _MOOVar *v, struct anonymous$90 *stream);
// draw_bubble
// file widgets/eggnotificationbubble.c line 385
static void draw_bubble(struct _EggNotificationBubble *bubble, unsigned int timeout);
// egg_notification_bubble_attach
// file widgets/eggnotificationbubble.c line 219
void egg_notification_bubble_attach(struct _EggNotificationBubble *bubble, struct _GtkWidget *widget);
// egg_notification_bubble_class_init
// file widgets/eggnotificationbubble.c line 87
static void egg_notification_bubble_class_init(struct _EggNotificationBubbleClass *class);
// egg_notification_bubble_destroy
// file widgets/eggnotificationbubble.c line 151
static void egg_notification_bubble_destroy(struct _GtkObject *object);
// egg_notification_bubble_detach
// file widgets/eggnotificationbubble.c line 554
static void egg_notification_bubble_detach(struct _EggNotificationBubble *bubble);
// egg_notification_bubble_event_handler
// file widgets/eggnotificationbubble.c line 535
static void egg_notification_bubble_event_handler(struct _GtkWidget *widget, union _GdkEvent *event, void *user_data);
// egg_notification_bubble_get_type
// file widgets/eggnotificationbubble.c line 60
unsigned long int egg_notification_bubble_get_type(void);
// egg_notification_bubble_hide
// file widgets/eggnotificationbubble.c line 517
void egg_notification_bubble_hide(struct _EggNotificationBubble *bubble);
// egg_notification_bubble_init
// file widgets/eggnotificationbubble.c line 117
static void egg_notification_bubble_init(struct _EggNotificationBubble *bubble);
// egg_notification_bubble_new
// file widgets/eggnotificationbubble.c line 529
struct _EggNotificationBubble * egg_notification_bubble_new(void);
// egg_notification_bubble_paint_window
// file widgets/eggnotificationbubble.c line 254
static signed int egg_notification_bubble_paint_window(struct _EggNotificationBubble *bubble);
// egg_notification_bubble_set
// file widgets/eggnotificationbubble.c line 230
void egg_notification_bubble_set(struct _EggNotificationBubble *bubble, const char *bubble_header_text, struct _GtkWidget *icon, const char *bubble_body_text);
// egg_notification_bubble_show
// file widgets/eggnotificationbubble.c line 511
void egg_notification_bubble_show(struct _EggNotificationBubble *bubble, unsigned int timeout);
// egg_notification_bubble_unset_bubble_window
// file widgets/eggnotificationbubble.c line 139
static void egg_notification_bubble_unset_bubble_window(struct _EggNotificationBubble *bubble);
// egg_tray_icon_cancel_message
// file widgets/eggtrayicon.c line 479
void egg_tray_icon_cancel_message(struct _EggTrayIcon *icon, unsigned int id);
// egg_tray_icon_class_init
// file widgets/eggtrayicon.c line 130
static void egg_tray_icon_class_init(struct _EggTrayIconClass *klass);
// egg_tray_icon_get_orientation
// file widgets/eggtrayicon.c line 495
enum anonymous$9 egg_tray_icon_get_orientation(struct _EggTrayIcon *icon);
// egg_tray_icon_get_orientation_property
// file widgets/eggtrayicon.c line 182
static void egg_tray_icon_get_orientation_property(struct _EggTrayIcon *icon);
// egg_tray_icon_get_property
// file widgets/eggtrayicon.c line 163
static void egg_tray_icon_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec);
// egg_tray_icon_get_type
// file widgets/eggtrayicon.h line 76
unsigned long int egg_tray_icon_get_type(void);
// egg_tray_icon_have_manager
// file widgets/eggtrayicon.c line 389
signed int egg_tray_icon_have_manager(struct _EggTrayIcon *icon);
// egg_tray_icon_init
// file widgets/eggtrayicon.c line 119
static void egg_tray_icon_init(struct _EggTrayIcon *icon);
// egg_tray_icon_manager_filter
// file widgets/eggtrayicon.c line 234
static enum anonymous$112 egg_tray_icon_manager_filter(void *xevent, union _GdkEvent *event, void *user_data);
// egg_tray_icon_manager_window_destroyed
// file widgets/eggtrayicon.c line 372
static void egg_tray_icon_manager_window_destroyed(struct _EggTrayIcon *icon);
// egg_tray_icon_new
// file widgets/eggtrayicon.c line 452
struct _EggTrayIcon * egg_tray_icon_new(const char *name);
// egg_tray_icon_new_for_screen
// file widgets/eggtrayicon.c line 444
struct _EggTrayIcon * egg_tray_icon_new_for_screen(struct _GdkScreen *screen, const char *name);
// egg_tray_icon_notify
// file widgets/eggtrayicon.c line 519
void egg_tray_icon_notify(struct _EggTrayIcon *icon, unsigned int timeout, const char *primary, struct _GtkWidget *msgicon, const char *secondary);
// egg_tray_icon_notify_default_cb
// file widgets/eggtrayicon.c line 508
static void egg_tray_icon_notify_default_cb(struct _NotifyNotification *notify, char *action, void *userdata);
// egg_tray_icon_realize
// file widgets/eggtrayicon.c line 400
static void egg_tray_icon_realize(struct _GtkWidget *widget);
// egg_tray_icon_send_dock_request
// file widgets/eggtrayicon.c line 323
static void egg_tray_icon_send_dock_request(struct _EggTrayIcon *icon);
// egg_tray_icon_send_manager_message
// file widgets/eggtrayicon.c line 293
static void egg_tray_icon_send_manager_message(struct _EggTrayIcon *icon, signed long int message, unsigned long int window, signed long int data1, signed long int data2, signed long int data3);
// egg_tray_icon_send_message
// file widgets/eggtrayicon.h line 83
unsigned int egg_tray_icon_send_message(struct _EggTrayIcon *icon, signed int timeout, const char *message, signed int len);
// egg_tray_icon_unrealize
// file widgets/eggtrayicon.c line 261
static void egg_tray_icon_unrealize(struct _GtkWidget *widget);
// egg_tray_icon_update_manager_window
// file widgets/eggtrayicon.c line 333
static void egg_tray_icon_update_manager_window(struct _EggTrayIcon *icon, signed int dock_if_realized);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_terminal
// file widgets/gm-external-view.c line 114
static struct anonymous$103 * find_terminal(const char *term);
// flush_history_cb
// file gm-world.c line 449
static signed int flush_history_cb(void *data);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// force_window
// file widgets/eggnotificationbubble.c line 171
static void force_window(struct _EggNotificationBubble *bubble);
// forward_chars_with_skipping
// file widgets/gm-searchable.c line 201
static void forward_chars_with_skipping(struct _GtkTextIter *iter, signed int count, signed int skip_decomp);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// g_array_append_vals
// file /usr/include/glib-2.0/glib/garray.h line 88
extern struct _GArray * g_array_append_vals(struct _GArray *, const void *, unsigned int);
// g_array_free
// file /usr/include/glib-2.0/glib/garray.h line 79
extern char * g_array_free(struct _GArray *, signed int);
// g_array_new
// file /usr/include/glib-2.0/glib/garray.h line 70
extern struct _GArray * g_array_new(signed int, signed int, unsigned int);
// g_ascii_formatd
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 168
extern char * g_ascii_formatd(char *, signed int, const char *, double);
// g_ascii_strtod
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 149
extern double g_ascii_strtod(const char *, char **);
// g_assertion_message_expr
// file /usr/include/glib-2.0/glib/gtestutils.h line 302
extern void g_assertion_message_expr(const char *, const char *, signed int, const char *, const char *);
// g_build_filename
// file /usr/include/glib-2.0/glib/gfileutils.h line 131
extern char * g_build_filename(const char *, ...);
// g_cclosure_marshal_VOID__BOOLEAN
// file /usr/include/glib-2.0/gobject/gmarshal.h line 26
extern void g_cclosure_marshal_VOID__BOOLEAN(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
// g_cclosure_marshal_VOID__INT
// file /usr/include/glib-2.0/gobject/gmarshal.h line 77
extern void g_cclosure_marshal_VOID__INT(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
// g_cclosure_marshal_VOID__OBJECT
// file /usr/include/glib-2.0/gobject/gmarshal.h line 281
extern void g_cclosure_marshal_VOID__OBJECT(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
// g_cclosure_marshal_VOID__POINTER
// file /usr/include/glib-2.0/gobject/gmarshal.h line 264
extern void g_cclosure_marshal_VOID__POINTER(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
// g_cclosure_marshal_VOID__STRING
// file /usr/include/glib-2.0/gobject/gmarshal.h line 213
extern void g_cclosure_marshal_VOID__STRING(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
// g_cclosure_marshal_VOID__UINT
// file /usr/include/glib-2.0/gobject/gmarshal.h line 94
extern void g_cclosure_marshal_VOID__UINT(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
// g_cclosure_marshal_VOID__VOID
// file /usr/include/glib-2.0/gobject/gmarshal.h line 9
extern void g_cclosure_marshal_VOID__VOID(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
// g_cclosure_new
// file /usr/include/glib-2.0/gobject/gclosure.h line 224
extern struct _GClosure * g_cclosure_new(void (*)(void), void *, void (*)(void *, struct _GClosure *));
// g_child_watch_add
// file /usr/include/glib-2.0/glib/gmain.h line 580
extern unsigned int g_child_watch_add(signed int, void (*)(signed int, signed int, void *), void *);
// g_closure_unref
// file /usr/include/glib-2.0/gobject/gclosure.h line 242
extern void g_closure_unref(struct _GClosure *);
// g_convert
// file /usr/include/glib-2.0/glib/gconvert.h line 93
extern char * g_convert(const char *, signed long int, const char *, const char *, unsigned long int *, unsigned long int *, struct _GError **);
// g_dir_close
// file /usr/include/glib-2.0/glib/gdir.h line 48
extern void g_dir_close(struct _GDir *);
// g_dir_open
// file /usr/include/glib-2.0/glib/gdir.h line 40
extern struct _GDir * g_dir_open(const char *, unsigned int, struct _GError **);
// g_dir_read_name
// file /usr/include/glib-2.0/glib/gdir.h line 44
extern const char * g_dir_read_name(struct _GDir *);
// g_direct_equal
// file /usr/include/glib-2.0/glib/ghash.h line 180
extern signed int g_direct_equal(const void *, const void *);
// g_direct_hash
// file /usr/include/glib-2.0/glib/ghash.h line 178
extern unsigned int g_direct_hash(const void *);
// g_error_free
// file /usr/include/glib-2.0/glib/gerror.h line 68
extern void g_error_free(struct _GError *);
// g_file_read_link
// file /usr/include/glib-2.0/glib/gfileutils.h line 95
extern char * g_file_read_link(const char *, struct _GError **);
// g_file_test
// file /usr/include/glib-2.0/glib/gfileutils.h line 82
extern signed int g_file_test(const char *, enum anonymous$106);
// g_find_program_in_path
// file /usr/include/glib-2.0/glib/gutils.h line 262
extern char * g_find_program_in_path(const char *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_get_charset
// file /usr/include/glib-2.0/glib/gcharset.h line 32
extern signed int g_get_charset(const char **);
// g_get_home_dir
// file /usr/include/glib-2.0/glib/gutils.h line 90
extern const char * g_get_home_dir(void);
// g_get_tmp_dir
// file /usr/include/glib-2.0/glib/gutils.h line 92
extern const char * g_get_tmp_dir(void);
// g_hash_table_destroy
// file /usr/include/glib-2.0/glib/ghash.h line 65
extern void g_hash_table_destroy(struct _GHashTable *);
// g_hash_table_foreach
// file /usr/include/glib-2.0/glib/ghash.h line 99
extern void g_hash_table_foreach(struct _GHashTable *, void (*)(void *, void *, void *), void *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_hash_table_remove
// file /usr/include/glib-2.0/glib/ghash.h line 78
extern signed int g_hash_table_remove(struct _GHashTable *, const void *);
// g_idle_add
// file /usr/include/glib-2.0/glib/gmain.h line 584
extern unsigned int g_idle_add(signed int (*)(void *), void *);
// g_intern_static_string
// file /usr/include/glib-2.0/glib/gquark.h line 64
extern const char * g_intern_static_string(const char *);
// g_io_add_watch
// file /usr/include/glib-2.0/glib/giochannel.h line 200
extern unsigned int g_io_add_watch(struct _GIOChannel *, enum anonymous$69, signed int (*)(struct _GIOChannel *, enum anonymous$69, void *), void *);
// g_io_channel_set_close_on_unref
// file /usr/include/glib-2.0/glib/giochannel.h line 240
extern void g_io_channel_set_close_on_unref(struct _GIOChannel *, signed int);
// g_io_channel_shutdown
// file /usr/include/glib-2.0/glib/giochannel.h line 186
extern enum anonymous$70 g_io_channel_shutdown(struct _GIOChannel *, signed int, struct _GError **);
// g_io_channel_unix_new
// file /usr/include/glib-2.0/glib/giochannel.h line 321
extern struct _GIOChannel * g_io_channel_unix_new(signed int);
// g_io_channel_unref
// file /usr/include/glib-2.0/glib/giochannel.h line 163
extern void g_io_channel_unref(struct _GIOChannel *);
// g_list_append
// file /usr/include/glib-2.0/glib/glist.h line 59
extern struct _GList * g_list_append(struct _GList *, void *);
// g_list_copy
// file /usr/include/glib-2.0/glib/glist.h line 99
extern struct _GList * g_list_copy(struct _GList *);
// g_list_find
// file /usr/include/glib-2.0/glib/glist.h line 113
extern struct _GList * g_list_find(struct _GList *, const void *);
// g_list_free
// file /usr/include/glib-2.0/glib/glist.h line 51
extern void g_list_free(struct _GList *);
// g_list_free_1
// file /usr/include/glib-2.0/glib/glist.h line 53
extern void g_list_free_1(struct _GList *);
// g_list_insert_before
// file /usr/include/glib-2.0/glib/glist.h line 78
extern struct _GList * g_list_insert_before(struct _GList *, struct _GList *, void *);
// g_list_insert_sorted
// file /usr/include/glib-2.0/glib/glist.h line 69
extern struct _GList * g_list_insert_sorted(struct _GList *, void *, signed int (*)(const void *, const void *));
// g_list_last
// file /usr/include/glib-2.0/glib/glist.h line 126
extern struct _GList * g_list_last(struct _GList *);
// g_list_length
// file /usr/include/glib-2.0/glib/glist.h line 130
extern unsigned int g_list_length(struct _GList *);
// g_list_nth_data
// file /usr/include/glib-2.0/glib/glist.h line 143
extern void * g_list_nth_data(struct _GList *, unsigned int);
// g_list_prepend
// file /usr/include/glib-2.0/glib/glist.h line 62
extern struct _GList * g_list_prepend(struct _GList *, void *);
// g_list_remove
// file /usr/include/glib-2.0/glib/glist.h line 85
extern struct _GList * g_list_remove(struct _GList *, const void *);
// g_list_remove_link
// file /usr/include/glib-2.0/glib/glist.h line 91
extern struct _GList * g_list_remove_link(struct _GList *, struct _GList *);
// g_locale_to_utf8
// file /usr/include/glib-2.0/glib/gconvert.h line 121
extern char * g_locale_to_utf8(const char *, signed long int, unsigned long int *, unsigned long int *, struct _GError **);
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous$99, const char *, ...);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0_n
// file /usr/include/glib-2.0/glib/gmem.h line 96
extern void * g_malloc0_n(unsigned long int, unsigned long int);
// g_malloc_n
// file /usr/include/glib-2.0/glib/gmem.h line 93
extern void * g_malloc_n(unsigned long int, unsigned long int);
// g_markup_escape_text
// file /usr/include/glib-2.0/glib/gmarkup.h line 228
extern char * g_markup_escape_text(const char *, signed long int);
// g_object_add_toggle_ref
// file /usr/include/glib-2.0/gobject/gobject.h line 513
extern void g_object_add_toggle_ref(struct _GObject *, void (*)(void *, struct _GObject *, signed int), void *);
// g_object_class_install_property
// file /usr/include/glib-2.0/gobject/gobject.h line 389
extern void g_object_class_install_property(struct _GObjectClass *, unsigned int, struct _GParamSpec *);
// g_object_get
// file /usr/include/glib-2.0/gobject/gobject.h line 436
extern void g_object_get(void *, const char *, ...);
// g_object_get_data
// file /usr/include/glib-2.0/gobject/gobject.h line 551
extern void * g_object_get_data(struct _GObject *, const char *);
// g_object_new
// file /usr/include/glib-2.0/gobject/gobject.h line 420
extern void * g_object_new(unsigned long int, const char *, ...);
// g_object_newv
// file /usr/include/glib-2.0/gobject/gobject.h line 424
extern void * g_object_newv(unsigned long int, unsigned int, struct _GParameter *);
// g_object_notify
// file /usr/include/glib-2.0/gobject/gobject.h line 466
extern void g_object_notify(struct _GObject *, const char *);
// g_object_ref
// file /usr/include/glib-2.0/gobject/gobject.h line 478
extern void * g_object_ref(void *);
// g_object_remove_toggle_ref
// file /usr/include/glib-2.0/gobject/gobject.h line 517
extern void g_object_remove_toggle_ref(struct _GObject *, void (*)(void *, struct _GObject *, signed int), void *);
// g_object_set
// file /usr/include/glib-2.0/gobject/gobject.h line 432
extern void g_object_set(void *, const char *, ...);
// g_object_set_data
// file /usr/include/glib-2.0/gobject/gobject.h line 554
extern void g_object_set_data(struct _GObject *, const char *, void *);
// g_object_set_data_full
// file /usr/include/glib-2.0/gobject/gobject.h line 558
extern void g_object_set_data_full(struct _GObject *, const char *, void *, void (*)(void *));
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// g_object_weak_ref
// file /usr/include/glib-2.0/gobject/gobject.h line 482
extern void g_object_weak_ref(struct _GObject *, void (*)(void *, struct _GObject *), void *);
// g_object_weak_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 486
extern void g_object_weak_unref(struct _GObject *, void (*)(void *, struct _GObject *), void *);
// g_once_init_enter
// file /usr/include/glib-2.0/glib/gthread.h line 232
extern signed int g_once_init_enter(volatile void *);
// g_once_init_leave
// file /usr/include/glib-2.0/glib/gthread.h line 234
extern void g_once_init_leave(volatile void *, unsigned long int);
// g_param_spec_boolean
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 995
extern struct _GParamSpec * g_param_spec_boolean(const char *, const char *, const char *, signed int, enum anonymous$5);
// g_param_spec_enum
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1055
extern struct _GParamSpec * g_param_spec_enum(const char *, const char *, const char *, unsigned long int, signed int, enum anonymous$5);
// g_param_spec_int
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1001
extern struct _GParamSpec * g_param_spec_int(const char *, const char *, const char *, signed int, signed int, signed int, enum anonymous$5);
// g_param_spec_object
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1114
extern struct _GParamSpec * g_param_spec_object(const char *, const char *, const char *, unsigned long int, enum anonymous$5);
// g_param_spec_pointer
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1103
extern struct _GParamSpec * g_param_spec_pointer(const char *, const char *, const char *, enum anonymous$5);
// g_param_spec_string
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1085
extern struct _GParamSpec * g_param_spec_string(const char *, const char *, const char *, const char *, enum anonymous$5);
// g_path_get_basename
// file /usr/include/glib-2.0/glib/gfileutils.h line 176
extern char * g_path_get_basename(const char *);
// g_realloc
// file /usr/include/glib-2.0/glib/gmem.h line 82
extern void * g_realloc(void *, unsigned long int);
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_shell_parse_argv
// file /usr/include/glib-2.0/glib/gshell.h line 52
extern signed int g_shell_parse_argv(const char *, signed int *, char ***, struct _GError **);
// g_shell_quote
// file /usr/include/glib-2.0/glib/gshell.h line 47
extern char * g_shell_quote(const char *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$73);
// g_signal_connect_object
// file /usr/include/glib-2.0/gobject/gobject.h line 600
extern unsigned long int g_signal_connect_object(void *, const char *, void (*)(void), void *, enum anonymous$73);
// g_signal_emit
// file /usr/include/glib-2.0/gobject/gsignal.h line 322
extern void g_signal_emit(void *, unsigned int, unsigned int, ...);
// g_signal_emit_by_name
// file /usr/include/glib-2.0/gobject/gsignal.h line 327
extern void g_signal_emit_by_name(void *, const char *, ...);
// g_signal_handler_disconnect
// file /usr/include/glib-2.0/gobject/gsignal.h line 401
extern void g_signal_handler_disconnect(void *, unsigned long int);
// g_signal_handlers_block_matched
// file /usr/include/glib-2.0/gobject/gsignal.h line 415
extern unsigned int g_signal_handlers_block_matched(void *, enum anonymous$74, unsigned int, unsigned int, struct _GClosure *, void *, void *);
// g_signal_handlers_disconnect_matched
// file /usr/include/glib-2.0/gobject/gsignal.h line 431
extern unsigned int g_signal_handlers_disconnect_matched(void *, enum anonymous$74, unsigned int, unsigned int, struct _GClosure *, void *, void *);
// g_signal_handlers_unblock_matched
// file /usr/include/glib-2.0/gobject/gsignal.h line 423
extern unsigned int g_signal_handlers_unblock_matched(void *, enum anonymous$74, unsigned int, unsigned int, struct _GClosure *, void *, void *);
// g_signal_new
// file /usr/include/glib-2.0/gobject/gsignal.h line 285
extern unsigned int g_signal_new(const char *, unsigned long int, enum anonymous$68, unsigned int, signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *), void *, void (*)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *), unsigned long int, unsigned int, ...);
// g_slist_append
// file /usr/include/glib-2.0/glib/gslist.h line 58
extern struct _GSList * g_slist_append(struct _GSList *, void *);
// g_slist_copy
// file /usr/include/glib-2.0/glib/gslist.h line 98
extern struct _GSList * g_slist_copy(struct _GSList *);
// g_slist_find
// file /usr/include/glib-2.0/glib/gslist.h line 108
extern struct _GSList * g_slist_find(struct _GSList *, const void *);
// g_slist_find_custom
// file /usr/include/glib-2.0/glib/gslist.h line 111
extern struct _GSList * g_slist_find_custom(struct _GSList *, const void *, signed int (*)(const void *, const void *));
// g_slist_free
// file /usr/include/glib-2.0/glib/gslist.h line 50
extern void g_slist_free(struct _GSList *);
// g_slist_prepend
// file /usr/include/glib-2.0/glib/gslist.h line 61
extern struct _GSList * g_slist_prepend(struct _GSList *, void *);
// g_slist_remove
// file /usr/include/glib-2.0/glib/gslist.h line 84
extern struct _GSList * g_slist_remove(struct _GSList *, const void *);
// g_snprintf
// file /usr/include/glib-2.0/glib/gutils.h line 201
extern signed int g_snprintf(char *, unsigned long int, const char *, ...);
// g_source_remove
// file /usr/include/glib-2.0/glib/gmain.h line 545
extern signed int g_source_remove(unsigned int);
// g_spawn_async
// file /usr/include/glib-2.0/glib/gspawn.h line 194
extern signed int g_spawn_async(const char *, char **, char **, enum anonymous$104, void (*)(void *), void *, signed int *, struct _GError **);
// g_spawn_close_pid
// file /usr/include/glib-2.0/glib/gspawn.h line 252
extern void g_spawn_close_pid(signed int);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_strcasecmp
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 200
extern signed int g_strcasecmp(const char *, const char *);
// g_strchomp
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 178
extern char * g_strchomp(char *);
// g_strchug
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 175
extern char * g_strchug(char *);
// g_strconcat
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 230
extern char * g_strconcat(const char *, ...);
// g_strdelimit
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 103
extern char * g_strdelimit(char *, const char *, char);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strfreev
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 281
extern void g_strfreev(char **);
// g_string_append
// file /usr/include/glib-2.0/glib/gstring.h line 80
extern struct _GString * g_string_append(struct _GString *, const char *);
// g_string_append_c_inline
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline(struct _GString *gstring, char c);
// g_string_append_c_inline$link1
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link1(struct _GString *gstring$link1, char c$link1);
// g_string_append_c_inline$link2
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link2(struct _GString *gstring$link2, char c$link2);
// g_string_append_c_inline$link3
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link3(struct _GString *gstring$link3, char c$link3);
// g_string_append_c_inline$link4
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link4(struct _GString *gstring$link4, char c$link4);
// g_string_append_c_inline$link5
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link5(struct _GString *gstring$link5, char c$link5);
// g_string_append_len
// file /usr/include/glib-2.0/glib/gstring.h line 83
extern struct _GString * g_string_append_len(struct _GString *, const char *, signed long int);
// g_string_append_unichar
// file /usr/include/glib-2.0/glib/gstring.h line 90
extern struct _GString * g_string_append_unichar(struct _GString *, unsigned int);
// g_string_erase
// file /usr/include/glib-2.0/glib/gstring.h line 127
extern struct _GString * g_string_erase(struct _GString *, signed long int, signed long int);
// g_string_free
// file /usr/include/glib-2.0/glib/gstring.h line 56
extern char * g_string_free(struct _GString *, signed int);
// g_string_insert_c
// file /usr/include/glib-2.0/glib/gstring.h line 110
extern struct _GString * g_string_insert_c(struct _GString *, signed long int, char);
// g_string_new
// file /usr/include/glib-2.0/glib/gstring.h line 49
extern struct _GString * g_string_new(const char *);
// g_string_sized_new
// file /usr/include/glib-2.0/glib/gstring.h line 54
extern struct _GString * g_string_sized_new(unsigned long int);
// g_strndup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 224
extern char * g_strndup(const char *, unsigned long int);
// g_strnfill
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 227
extern char * g_strnfill(unsigned long int, char);
// g_strsplit
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 270
extern char ** g_strsplit(const char *, const char *, signed int);
// g_thread_init
// file /usr/include/glib-2.0/glib/deprecated/gthread.h line 265
extern void g_thread_init(void *);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_type_add_interface_static
// file /usr/include/glib-2.0/gobject/gtype.h line 1279
extern void g_type_add_interface_static(unsigned long int, unsigned long int, const struct _GInterfaceInfo *);
// g_type_check_class_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2177
extern struct _GTypeClass * g_type_check_class_cast(struct _GTypeClass *, unsigned long int);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_type_check_instance_is_a
// file /usr/include/glib-2.0/gobject/gtype.h line 2171
extern signed int g_type_check_instance_is_a(struct _GTypeInstance *, unsigned long int);
// g_type_class_add_private
// file /usr/include/glib-2.0/gobject/gtype.h line 1293
extern void g_type_class_add_private(void *, unsigned long int);
// g_type_class_adjust_private_offset
// file /usr/include/glib-2.0/gobject/gtype.h line 1302
extern void g_type_class_adjust_private_offset(void *, signed int *);
// g_type_class_peek
// file /usr/include/glib-2.0/gobject/gtype.h line 703
extern void * g_type_class_peek(unsigned long int);
// g_type_class_peek_parent
// file /usr/include/glib-2.0/gobject/gtype.h line 709
extern void * g_type_class_peek_parent(void *);
// g_type_class_ref
// file /usr/include/glib-2.0/gobject/gtype.h line 701
extern void * g_type_class_ref(unsigned long int);
// g_type_init
// file /usr/include/glib-2.0/gobject/gtype.h line 681
extern void g_type_init(void);
// g_type_instance_get_private
// file /usr/include/glib-2.0/gobject/gtype.h line 1299
extern void * g_type_instance_get_private(struct _GTypeInstance *, unsigned long int);
// g_type_interface_peek
// file /usr/include/glib-2.0/gobject/gtype.h line 711
extern void * g_type_interface_peek(void *, unsigned long int);
// g_type_name
// file /usr/include/glib-2.0/gobject/gtype.h line 685
extern const char * g_type_name(unsigned long int);
// g_type_register_static
// file /usr/include/glib-2.0/gobject/gtype.h line 1254
extern unsigned long int g_type_register_static(unsigned long int, const char *, const struct _GTypeInfo *, enum anonymous);
// g_type_register_static_simple
// file /usr/include/glib-2.0/gobject/gtype.h line 1259
extern unsigned long int g_type_register_static_simple(unsigned long int, const char *, unsigned int, void (*)(void *, void *), unsigned int, void (*)(struct _GTypeInstance *, void *), enum anonymous);
// g_unichar_digit_value
// file /usr/include/glib-2.0/glib/gunicode.h line 610
extern signed int g_unichar_digit_value(unsigned int);
// g_unichar_isalnum
// file /usr/include/glib-2.0/glib/gunicode.h line 564
extern signed int g_unichar_isalnum(unsigned int);
// g_unichar_isalpha
// file /usr/include/glib-2.0/glib/gunicode.h line 566
extern signed int g_unichar_isalpha(unsigned int);
// g_unichar_isdigit
// file /usr/include/glib-2.0/glib/gunicode.h line 570
extern signed int g_unichar_isdigit(unsigned int);
// g_unichar_isspace
// file /usr/include/glib-2.0/glib/gunicode.h line 580
extern signed int g_unichar_isspace(unsigned int);
// g_unichar_to_utf8
// file /usr/include/glib-2.0/glib/gunicode.h line 786
extern signed int g_unichar_to_utf8(unsigned int, char *);
// g_utf8_casefold
// file /usr/include/glib-2.0/glib/gunicode.h line 801
extern char * g_utf8_casefold(const char *, signed long int);
// g_utf8_caselessnmatch
// file widgets/gm-searchable.c line 162
static signed int g_utf8_caselessnmatch(const char *s1, const char *s2, signed long int n1, signed long int n2);
// g_utf8_collate
// file /usr/include/glib-2.0/glib/gunicode.h line 845
extern signed int g_utf8_collate(const char *, const char *);
// g_utf8_get_char
// file /usr/include/glib-2.0/glib/gunicode.h line 696
extern unsigned int g_utf8_get_char(const char *);
// g_utf8_normalize
// file /usr/include/glib-2.0/glib/gunicode.h line 840
extern char * g_utf8_normalize(const char *, signed long int, enum anonymous$98);
// g_utf8_offset_to_pointer
// file /usr/include/glib-2.0/glib/gunicode.h line 702
extern char * g_utf8_offset_to_pointer(const char *, signed long int);
// g_utf8_pointer_to_offset
// file /usr/include/glib-2.0/glib/gunicode.h line 705
extern signed long int g_utf8_pointer_to_offset(const char *, const char *);
// g_utf8_prev_char
// file /usr/include/glib-2.0/glib/gunicode.h line 708
extern char * g_utf8_prev_char(const char *);
// g_utf8_strcasestr
// file widgets/gm-searchable.c line 52
static const char * g_utf8_strcasestr(const char *haystack, const char *needle);
// g_utf8_strchr
// file /usr/include/glib-2.0/glib/gunicode.h line 733
extern char * g_utf8_strchr(const char *, signed long int, unsigned int);
// g_utf8_strlen
// file /usr/include/glib-2.0/glib/gunicode.h line 717
extern signed long int g_utf8_strlen(const char *, signed long int);
// g_utf8_strrcasestr
// file widgets/gm-searchable.c line 107
static const char * g_utf8_strrcasestr(const char *haystack, const char *needle);
// g_utf8_toint
// file widgets/gm-world-text-view.c line 701
static signed int g_utf8_toint(char *str, unsigned int *result);
// g_utf8_validate
// file /usr/include/glib-2.0/glib/gunicode.h line 790
extern signed int g_utf8_validate(const char *, signed long int, const char **);
// g_value_get_boolean
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 197
extern signed int g_value_get_boolean(const struct _GValue *);
// g_value_get_int
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 202
extern signed int g_value_get_int(const struct _GValue *);
// g_value_get_string
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 245
extern const char * g_value_get_string(const struct _GValue *);
// g_value_peek_pointer
// file /usr/include/glib-2.0/gobject/gvalue.h line 149
extern void * g_value_peek_pointer(const struct _GValue *);
// g_value_set_boolean
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 194
extern void g_value_set_boolean(struct _GValue *, signed int);
// g_value_set_enum
// file /usr/include/glib-2.0/gobject/genums.h line 237
extern void g_value_set_enum(struct _GValue *, signed int);
// g_value_set_int
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 199
extern void g_value_set_int(struct _GValue *, signed int);
// g_value_set_object
// file /usr/include/glib-2.0/gobject/gobject.h line 593
extern void g_value_set_object(struct _GValue *, void *);
// g_value_set_pointer
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 249
extern void g_value_set_pointer(struct _GValue *, void *);
// g_value_set_string
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 239
extern void g_value_set_string(struct _GValue *, const char *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// gconf_client_add_dir
// file /usr/include/gconf/2/gconf/gconf-client.h line 160
void gconf_client_add_dir(struct _GConfClient *, const char *, enum anonymous$63, struct _GError **);
// gconf_client_get_default
// file /usr/include/gconf/2/gconf/gconf-client.h line 149
struct _GConfClient * gconf_client_get_default(void);
// gconf_client_get_string
// file /usr/include/gconf/2/gconf/gconf-client.h line 290
char * gconf_client_get_string(struct _GConfClient *, const char *, struct _GError **);
// gconf_client_notify_add
// file /usr/include/gconf/2/gconf/gconf-client.h line 181
unsigned int gconf_client_notify_add(struct _GConfClient *, const char *, void (*)(struct _GConfClient *, unsigned int, struct _GConfEntry *, void *), void *, void (*)(void *), struct _GError **);
// gconf_client_notify_remove
// file /usr/include/gconf/2/gconf/gconf-client.h line 188
void gconf_client_notify_remove(struct _GConfClient *, unsigned int);
// gconf_client_remove_dir
// file /usr/include/gconf/2/gconf/gconf-client.h line 167
void gconf_client_remove_dir(struct _GConfClient *, const char *, struct _GError **);
// gdk_atom_intern
// file /usr/include/gtk-2.0/gdk/gdkproperty.h line 45
struct _GdkAtom * gdk_atom_intern(const char *, signed int);
// gdk_beep
// file /usr/include/gtk-2.0/gdk/gdk.h line 140
void gdk_beep(void);
// gdk_color_parse
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 136
signed int gdk_color_parse(const char *, struct _GdkColor *);
// gdk_cursor_new
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 142
struct _GdkCursor * gdk_cursor_new(enum anonymous$37);
// gdk_cursor_unref
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 156
void gdk_cursor_unref(struct _GdkCursor *);
// gdk_error_trap_pop
// file /usr/include/gtk-2.0/gdk/gdk.h line 89
signed int gdk_error_trap_pop(void);
// gdk_error_trap_push
// file /usr/include/gtk-2.0/gdk/gdk.h line 88
void gdk_error_trap_push(void);
// gdk_keyval_from_name
// file /usr/include/gtk-2.0/gdk/gdkkeys.h line 119
unsigned int gdk_keyval_from_name(const char *);
// gdk_pixbuf_add_alpha
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 451
struct _GdkPixbuf * gdk_pixbuf_add_alpha(const struct _GdkPixbuf *, signed int, unsigned char, unsigned char, unsigned char);
// gdk_pixbuf_composite
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h line 106
void gdk_pixbuf_composite(const struct _GdkPixbuf *, struct _GdkPixbuf *, signed int, signed int, signed int, signed int, double, double, double, double, enum anonymous$87, signed int);
// gdk_pixbuf_copy
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 255
struct _GdkPixbuf * gdk_pixbuf_copy(const struct _GdkPixbuf *);
// gdk_pixbuf_copy_area
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 455
void gdk_pixbuf_copy_area(const struct _GdkPixbuf *, signed int, signed int, signed int, signed int, struct _GdkPixbuf *, signed int, signed int);
// gdk_pixbuf_fill
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 321
void gdk_pixbuf_fill(struct _GdkPixbuf *, unsigned int);
// gdk_pixbuf_get_bits_per_sample
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 234
signed int gdk_pixbuf_get_bits_per_sample(const struct _GdkPixbuf *);
// gdk_pixbuf_get_colorspace
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 231
enum anonymous$84 gdk_pixbuf_get_colorspace(const struct _GdkPixbuf *);
// gdk_pixbuf_get_has_alpha
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 233
signed int gdk_pixbuf_get_has_alpha(const struct _GdkPixbuf *);
// gdk_pixbuf_get_height
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 237
signed int gdk_pixbuf_get_height(const struct _GdkPixbuf *);
// gdk_pixbuf_get_n_channels
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 232
signed int gdk_pixbuf_get_n_channels(const struct _GdkPixbuf *);
// gdk_pixbuf_get_pixels
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 235
unsigned char * gdk_pixbuf_get_pixels(const struct _GdkPixbuf *);
// gdk_pixbuf_get_rowstride
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 238
signed int gdk_pixbuf_get_rowstride(const struct _GdkPixbuf *);
// gdk_pixbuf_get_type
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 218
unsigned long int gdk_pixbuf_get_type(void);
// gdk_pixbuf_get_width
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 236
signed int gdk_pixbuf_get_width(const struct _GdkPixbuf *);
// gdk_pixbuf_new
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 250
struct _GdkPixbuf * gdk_pixbuf_new(enum anonymous$84, signed int, signed int, signed int, signed int);
// gdk_pixbuf_new_from_file
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 275
struct _GdkPixbuf * gdk_pixbuf_new_from_file(const char *, struct _GError **);
// gdk_pixbuf_new_from_file_at_size
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 277
struct _GdkPixbuf * gdk_pixbuf_new_from_file_at_size(const char *, signed int, signed int, struct _GError **);
// gdk_pixbuf_unref
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 226
void gdk_pixbuf_unref(struct _GdkPixbuf *);
// gdk_pointer_grab
// file /usr/include/gtk-2.0/gdk/gdk.h line 112
enum anonymous$42 gdk_pointer_grab(struct _GdkDrawable *, signed int, enum anonymous$47, struct _GdkDrawable *, struct _GdkCursor *, unsigned int);
// gdk_pointer_is_grabbed
// file /usr/include/gtk-2.0/gdk/gdk.h line 132
signed int gdk_pointer_is_grabbed(void);
// gdk_pointer_ungrab
// file /usr/include/gtk-2.0/gdk/gdk.h line 130
void gdk_pointer_ungrab(unsigned int);
// gdk_region_destroy
// file /usr/include/gtk-2.0/gdk/gdkregion.h line 75
void gdk_region_destroy(struct _GdkRegion *);
// gdk_region_polygon
// file /usr/include/gtk-2.0/gdk/gdkregion.h line 69
struct _GdkRegion * gdk_region_polygon(const struct _GdkPoint *, signed int, enum anonymous$148);
// gdk_region_rectangle
// file /usr/include/gtk-2.0/gdk/gdkregion.h line 74
struct _GdkRegion * gdk_region_rectangle(const struct _GdkRectangle *);
// gdk_region_subtract
// file /usr/include/gtk-2.0/gdk/gdkregion.h line 110
void gdk_region_subtract(struct _GdkRegion *, const struct _GdkRegion *);
// gdk_region_union
// file /usr/include/gtk-2.0/gdk/gdkregion.h line 108
void gdk_region_union(struct _GdkRegion *, const struct _GdkRegion *);
// gdk_screen_get_display
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 82
struct _GdkDisplay * gdk_screen_get_display(struct _GdkScreen *);
// gdk_screen_get_height
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 85
signed int gdk_screen_get_height(struct _GdkScreen *);
// gdk_screen_get_monitor_at_window
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 101
signed int gdk_screen_get_monitor_at_window(struct _GdkScreen *, struct _GdkDrawable *);
// gdk_screen_get_monitor_geometry
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 95
void gdk_screen_get_monitor_geometry(struct _GdkScreen *, signed int, struct _GdkRectangle *);
// gdk_screen_get_number
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 83
signed int gdk_screen_get_number(struct _GdkScreen *);
// gdk_screen_get_root_window
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 81
struct _GdkDrawable * gdk_screen_get_root_window(struct _GdkScreen *);
// gdk_screen_get_type
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 69
unsigned long int gdk_screen_get_type(void);
// gdk_threads_enter
// file /usr/include/gtk-2.0/gdk/gdk.h line 195
void gdk_threads_enter(void);
// gdk_threads_leave
// file /usr/include/gtk-2.0/gdk/gdk.h line 196
void gdk_threads_leave(void);
// gdk_threads_lock$object
// 
void gdk_threads_lock$object(void);
// gdk_threads_unlock$object
// 
void gdk_threads_unlock$object(void);
// gdk_window_add_filter
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 394
void gdk_window_add_filter(struct _GdkDrawable *, enum anonymous$112 (*)(void *, union _GdkEvent *, void *), void *);
// gdk_window_focus
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 382
void gdk_window_focus(struct _GdkDrawable *, unsigned int);
// gdk_window_get_origin
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 561
signed int gdk_window_get_origin(struct _GdkDrawable *, signed int *, signed int *);
// gdk_window_get_pointer
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 592
struct _GdkDrawable * gdk_window_get_pointer(struct _GdkDrawable *, signed int *, signed int *, enum anonymous$0 *);
// gdk_window_get_state
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 469
enum anonymous$22 gdk_window_get_state(struct _GdkDrawable *);
// gdk_window_lookup_for_display
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 485
struct _GdkDrawable * gdk_window_lookup_for_display(struct _GdkDisplay *, unsigned int);
// gdk_window_object_get_type
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 331
unsigned long int gdk_window_object_get_type(void);
// gdk_window_remove_filter
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 397
void gdk_window_remove_filter(struct _GdkDrawable *, enum anonymous$112 (*)(void *, union _GdkEvent *, void *), void *);
// gdk_window_set_cursor
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 547
void gdk_window_set_cursor(struct _GdkDrawable *, struct _GdkCursor *);
// gdk_window_shape_combine_region
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 419
void gdk_window_shape_combine_region(struct _GdkDrawable *, const struct _GdkRegion *, signed int, signed int);
// gdk_x11_display_get_xdisplay
// file /usr/include/gtk-2.0/gdk/gdkx.h line 51
struct _XDisplay * gdk_x11_display_get_xdisplay(struct _GdkDisplay *);
// gdk_x11_get_server_time
// file /usr/include/gtk-2.0/gdk/gdkx.h line 148
unsigned int gdk_x11_get_server_time(struct _GdkDrawable *);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glade_init
// file /usr/include/libglade-2.0/glade/glade-init.h line 31
void glade_init(void);
// glade_xml_get_widget
// file /usr/include/libglade-2.0/glade/glade-xml.h line 112
struct _GtkWidget * glade_xml_get_widget(struct _GladeXML *, const char *);
// glade_xml_new
// file /usr/include/libglade-2.0/glade/glade-xml.h line 59
struct _GladeXML * glade_xml_new(const char *, const char *, const char *);
// glade_xml_signal_connect
// file /usr/include/libglade-2.0/glade/glade-xml.h line 72
void glade_xml_signal_connect(struct _GladeXML *, const char *, void (*)(void));
// glade_xml_signal_connect_data
// file /usr/include/libglade-2.0/glade/glade-xml.h line 75
void glade_xml_signal_connect_data(struct _GladeXML *, const char *, void (*)(void), void *);
// glob
// file /usr/include/glob.h line 146
extern signed int glob(const char *, signed int, signed int (*)(const char *, signed int), struct anonymous$13 *);
// globfree
// file /usr/include/glob.h line 151
extern void globfree(struct anonymous$13 *);
// gm_ansi_strip
// file gm-support.h line 117
char * gm_ansi_strip(char *s);
// gm_app_add_world
// file ./gm-app.h line 63
void gm_app_add_world(struct _GmApp *app, struct _GmWorld *world);
// gm_app_class_init
// file gm-app.c line 144
static void gm_app_class_init(struct _GmAppClass *klass);
// gm_app_class_intern_init
// file gm-app.c line 88
static void gm_app_class_intern_init(void *klass);
// gm_app_color_table
// file ./gm-app.h line 70
struct _GmColorTable * gm_app_color_table(struct _GmApp *app);
// gm_app_compare_worlds
// file gm-app.c line 548
signed int gm_app_compare_worlds(struct _GmWorld *world1, struct _GmWorld *world2);
// gm_app_convert_old_color_configuration
// file gm-app.c line 354
static void gm_app_convert_old_color_configuration(struct _GmApp *app, const char *colors_path);
// gm_app_create_settings
// file gm-app.c line 271
static void gm_app_create_settings(struct _GmApp *app);
// gm_app_destroy_worlds
// file gm-app.c line 209
static void gm_app_destroy_worlds(struct _GmApp *app);
// gm_app_finalize
// file gm-app.c line 115
static void gm_app_finalize(struct _GObject *object);
// gm_app_get_property
// file gm-app.c line 91
static void gm_app_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec);
// gm_app_get_type
// file gm-app.c line 88
unsigned long int gm_app_get_type(void);
// gm_app_init
// file gm-app.c line 196
static void gm_app_init(struct _GmApp *app);
// gm_app_initialize
// file gm-app.c line 409
static void gm_app_initialize(struct _GmApp *app);
// gm_app_instance
// file ./gm-app.h line 59
struct _GmApp * gm_app_instance();
// gm_app_load_worlds
// file gm-app.c line 318
static void gm_app_load_worlds(struct _GmApp *app, signed int autoload);
// gm_app_new
// file gm-app.c line 502
struct _GmApp * gm_app_new(signed int argc, char **argv);
// gm_app_options
// file ./gm-app.h line 68
struct _GmOptions * gm_app_options(struct _GmApp *app);
// gm_app_path
// file gm-app.c line 611
const char * gm_app_path(struct _GmApp *app);
// gm_app_remove_world
// file ./gm-app.h line 64
void gm_app_remove_world(struct _GmApp *app, struct _GmWorld *world);
// gm_app_run
// file gm-app.c line 450
static void gm_app_run(struct _GmApp *app);
// gm_app_view_action
// file widgets/gm-app-view.c line 865
struct _GtkAction * gm_app_view_action(struct _GmAppView *view, const char *path);
// gm_app_view_active_editor_view
// file widgets/gm-app-view.c line 1652
struct _GmEditorView * gm_app_view_active_editor_view(struct _GmAppView *view);
// gm_app_view_active_world
// file widgets/gm-app-view.c line 833
struct _GmWorld * gm_app_view_active_world(struct _GmAppView *view);
// gm_app_view_active_world_view
// file widgets/gm-app-view.c line 820
struct _GmWorldView * gm_app_view_active_world_view(struct _GmAppView *view);
// gm_app_view_application
// file widgets/gm-app-view.c line 778
const struct _GmApp * gm_app_view_application(struct _GmAppView *view);
// gm_app_view_class_init
// file widgets/gm-app-view.c line 297
static void gm_app_view_class_init(struct _GmAppViewClass *klass);
// gm_app_view_class_intern_init
// file widgets/gm-app-view.c line 167
static void gm_app_view_class_intern_init(void *klass);
// gm_app_view_create_keybindings
// file widgets/gm-app-view.c line 560
void gm_app_view_create_keybindings(struct _GmAppView *view);
// gm_app_view_create_search_box
// file widgets/gm-app-view.c line 445
struct _GtkWidget * gm_app_view_create_search_box(struct _GmAppView *view);
// gm_app_view_create_tray
// file widgets/gm-app-view.c line 615
static void gm_app_view_create_tray(struct _GmAppView *view);
// gm_app_view_create_ui
// file widgets/gm-app-view.c line 324
void gm_app_view_create_ui(struct _GmAppView *view);
// gm_app_view_delete_event
// file widgets/gm-app-view.c line 198
static signed int gm_app_view_delete_event(struct _GtkWidget *widget, struct _GdkEventAny *event);
// gm_app_view_destroy_world_menu_item
// file widgets/gm-app-view.c line 788
void gm_app_view_destroy_world_menu_item(struct _GmAppViewWorldMenuItem *item);
// gm_app_view_drag_start
// file widgets/gm-app-view.c line 1443
void gm_app_view_drag_start(struct _GmAppView *view, unsigned int time);
// gm_app_view_drag_stop
// file widgets/gm-app-view.c line 1431
void gm_app_view_drag_stop(struct _GmAppView *view);
// gm_app_view_finalize
// file widgets/gm-app-view.c line 170
static void gm_app_view_finalize(struct _GObject *object);
// gm_app_view_find_first
// file widgets/gm-app-view.c line 1209
signed int gm_app_view_find_first(struct _GmAppView *view);
// gm_app_view_find_tab_num_at_pos
// file widgets/gm-app-view.c line 1380
signed int gm_app_view_find_tab_num_at_pos(struct _GmAppView *view, signed int abs_x, signed int abs_y);
// gm_app_view_focus_in_event
// file widgets/gm-app-view.c line 212
static signed int gm_app_view_focus_in_event(struct _GtkWidget *widget, struct _GdkEventFocus *event);
// gm_app_view_focus_out_event
// file widgets/gm-app-view.c line 237
static signed int gm_app_view_focus_out_event(struct _GtkWidget *widget, struct _GdkEventFocus *event);
// gm_app_view_get_type
// file widgets/gm-app-view.c line 167
unsigned long int gm_app_view_get_type(void);
// gm_app_view_init
// file widgets/gm-app-view.c line 638
static void gm_app_view_init(struct _GmAppView *view);
// gm_app_view_menu_item
// file widgets/gm-app-view.c line 858
struct _GtkMenuItem * gm_app_view_menu_item(struct _GmAppView *view, const char *path);
// gm_app_view_move_current_tab
// file widgets/gm-app-view.c line 1463
void gm_app_view_move_current_tab(struct _GmAppView *view, signed int dest_position);
// gm_app_view_new
// file widgets/gm-app-view.c line 747
struct _GmAppView * gm_app_view_new(struct _GmApp *application);
// gm_app_view_notebook
// file widgets/gm-app-view.c line 783
struct _GtkNotebook * gm_app_view_notebook(struct _GmAppView *view);
// gm_app_view_restore_position
// file widgets/gm-app-view.c line 720
static void gm_app_view_restore_position(struct _GmAppView *view);
// gm_app_view_restore_size
// file widgets/gm-app-view.c line 726
static void gm_app_view_restore_size(struct _GmAppView *view);
// gm_app_view_search_flags
// file widgets/gm-app-view.c line 1188
enum _GmSearchableSearchFlags gm_app_view_search_flags(struct _GmAppView *view);
// gm_app_view_set_sensitivity
// file widgets/gm-app-view.c line 806
void gm_app_view_set_sensitivity(struct _GmAppView *view, signed int sens);
// gm_app_view_show_find_box
// file widgets/gm-app-view.c line 1249
void gm_app_view_show_find_box(struct _GmAppView *view);
// gm_app_view_show_replace_box
// file widgets/gm-app-view.c line 1241
void gm_app_view_show_replace_box(struct _GmAppView *view);
// gm_app_view_size_allocate
// file widgets/gm-app-view.c line 258
static void gm_app_view_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation);
// gm_app_view_store_position
// file widgets/gm-app-view.c line 714
static void gm_app_view_store_position(struct _GmAppView *view);
// gm_app_view_toggle_visibility
// file widgets/gm-app-view.c line 957
void gm_app_view_toggle_visibility(struct _GmAppView *view);
// gm_app_view_update_connect_button
// file widgets/gm-app-view.c line 871
void gm_app_view_update_connect_button(struct _GmAppView *view, signed int connected);
// gm_app_view_update_title
// file widgets/gm-app-view.c line 844
void gm_app_view_update_title(struct _GmAppView *view);
// gm_app_view_update_tray
// file widgets/gm-app-view.c line 901
void gm_app_view_update_tray(struct _GmAppView *view);
// gm_app_view_window_state_event
// file widgets/gm-app-view.c line 279
static signed int gm_app_view_window_state_event(struct _GtkWidget *widget, struct _GdkEventWindowState *event);
// gm_app_view_world_view_from_world
// file widgets/gm-app-view.c line 981
struct _GmWorldView * gm_app_view_world_view_from_world(struct _GmAppView *view, struct _GmWorld *world);
// gm_app_view_worlds_loaded
// file widgets/gm-app-view.c line 894
void gm_app_view_worlds_loaded(struct _GmAppView *view);
// gm_app_view_worlds_unloaded
// file widgets/gm-app-view.c line 887
void gm_app_view_worlds_unloaded(struct _GmAppView *view);
// gm_app_world_by_name
// file ./gm-app.h line 71
struct _GmWorld * gm_app_world_by_name(struct _GmApp *app, char *name);
// gm_app_worlds
// file ./gm-app.h line 69
struct _GList * gm_app_worlds(struct _GmApp *app);
// gm_app_worlds_path
// file gm-app.c line 606
const char * gm_app_worlds_path(struct _GmApp *app);
// gm_cell_renderer_text_class_init
// file mcp/gm-cell-renderer-text.c line 46
static void gm_cell_renderer_text_class_init(struct _GmCellRendererTextClass *klass);
// gm_cell_renderer_text_class_intern_init
// file mcp/gm-cell-renderer-text.c line 41
static void gm_cell_renderer_text_class_intern_init(void *klass);
// gm_cell_renderer_text_get_type
// file mcp/gm-cell-renderer-text.c line 41
unsigned long int gm_cell_renderer_text_get_type(void);
// gm_cell_renderer_text_init
// file mcp/gm-cell-renderer-text.c line 74
static void gm_cell_renderer_text_init(struct _GmCellRendererText *cell);
// gm_cell_renderer_text_new
// file mcp/gm-cell-renderer-text.h line 41
struct _GtkCellRenderer * gm_cell_renderer_text_new(void);
// gm_color_table_class_init
// file gm-color-table.c line 256
static void gm_color_table_class_init(struct _GmColorTableClass *klass);
// gm_color_table_class_intern_init
// file gm-color-table.c line 245
static void gm_color_table_class_intern_init(void *klass);
// gm_color_table_connect_font_changed
// file gm-color-table.c line 381
static void gm_color_table_connect_font_changed(struct _GmColorTable *table);
// gm_color_table_default_font
// file gm-color-table.c line 324
static char * gm_color_table_default_font(struct _GmColorTable *table);
// gm_color_table_disconnect_font_changed
// file gm-color-table.c line 368
static void gm_color_table_disconnect_font_changed(struct _GmColorTable *table);
// gm_color_table_fill_from_options
// file gm-color-table.c line 338
static void gm_color_table_fill_from_options(struct _GmColorTable *table);
// gm_color_table_finalize
// file gm-color-table.c line 248
static void gm_color_table_finalize(struct _GObject *object);
// gm_color_table_font_description
// file ./gm-color-table.h line 78
const char * gm_color_table_font_description(struct _GmColorTable *table);
// gm_color_table_get
// file ./gm-color-table.h line 72
signed int gm_color_table_get(struct _GmColorTable *table, const char *name, struct _GdkColor *color);
// gm_color_table_get_hex
// file ./gm-color-table.h line 74
const char * gm_color_table_get_hex(struct _GmColorTable *table, const char *name);
// gm_color_table_get_scheme_name
// file ./gm-color-table.h line 88
const char * gm_color_table_get_scheme_name(struct _GmColorTable *table);
// gm_color_table_get_type
// file ./gm-color-table.h line 64
unsigned long int gm_color_table_get_type(void);
// gm_color_table_get_use_system_font
// file ./gm-color-table.h line 82
signed int gm_color_table_get_use_system_font(struct _GmColorTable *table);
// gm_color_table_init
// file gm-color-table.c line 287
static void gm_color_table_init(struct _GmColorTable *table);
// gm_color_table_item_free
// file gm-color-table.c line 296
static void gm_color_table_item_free(void *item);
// gm_color_table_load_scheme
// file ./gm-color-table.h line 84
void gm_color_table_load_scheme(struct _GmColorTable *table, enum _GmColorTableScheme scheme);
// gm_color_table_new
// file ./gm-color-table.h line 66
struct _GmColorTable * gm_color_table_new(void);
// gm_color_table_new_from_options
// file ./gm-color-table.h line 67
struct _GmColorTable * gm_color_table_new_from_options(char *filename);
// gm_color_table_save
// file ./gm-color-table.h line 68
void gm_color_table_save(struct _GmColorTable *table);
// gm_color_table_set
// file ./gm-color-table.h line 70
void gm_color_table_set(struct _GmColorTable *table, const char *name, const char *hex);
// gm_color_table_set_font_description
// file ./gm-color-table.h line 76
void gm_color_table_set_font_description(struct _GmColorTable *table, const char *font_description);
// gm_color_table_set_from_scheme_name
// file ./gm-color-table.h line 86
void gm_color_table_set_from_scheme_name(struct _GmColorTable *table, const char *scheme);
// gm_color_table_set_use_system_font
// file ./gm-color-table.h line 80
void gm_color_table_set_use_system_font(struct _GmColorTable *table, signed int use_system_font);
// gm_color_table_set_value
// file gm-color-table.c line 304
static void gm_color_table_set_value(struct _GmColorTable *table, const char *name, const char *hex);
// gm_container_item
// file ./gm-support.h line 158
struct _GtkWidget * gm_container_item(struct _GtkContainer *cnt, unsigned long int type);
// gm_convert_with_fallback
// file gm-support.c line 627
char * gm_convert_with_fallback(const char *text, signed long int len, const char *from, const char *to, const char *fallback);
// gm_create_tab_label
// file ./gm-support.h line 144
struct _GtkWidget * gm_create_tab_label(const char *icon, const char *caption, signed int has_exit, struct _GmLabelInfo *info);
// gm_debug_msg
// file ./gm-debug.h line 13
void gm_debug_msg(signed int level, char *line, ...);
// gm_debug_msg_real
// file gm-debug.c line 27
static void gm_debug_msg_real(struct _IO_FILE *f, struct tm *timet, char *line, void **args);
// gm_debug_set_level
// file gm-debug.h line 14
void gm_debug_set_level(char *level);
// gm_default_charset
// file gm-support.h line 147
const char * gm_default_charset();
// gm_dialog
// file gm-support.c line 124
signed int gm_dialog(char *message, enum anonymous$79 messagebox_type, signed int buttons_type, struct _GtkWindow *parent);
// gm_directory_remove_all
// file ./gm-support.h line 129
void gm_directory_remove_all(const char *path, signed int remove_self);
// gm_do_events
// file ./gm-support.h line 127
void gm_do_events();
// gm_editor_class_init
// file gm-editor.c line 52
static void gm_editor_class_init(struct _GmEditorClass *klass);
// gm_editor_class_intern_init
// file gm-editor.c line 37
static void gm_editor_class_intern_init(void *klass);
// gm_editor_close
// file ./gm-editor.h line 66
void gm_editor_close(struct _GmEditor *editor);
// gm_editor_finalize
// file gm-editor.c line 40
static void gm_editor_finalize(struct _GObject *object);
// gm_editor_generate_filename
// file gm-editor.c line 191
char * gm_editor_generate_filename(struct _GmEditor *editor);
// gm_editor_get_type
// file ./gm-editor.h line 55
unsigned long int gm_editor_get_type(void);
// gm_editor_init
// file gm-editor.c line 89
static void gm_editor_init(struct _GmEditor *view);
// gm_editor_is_code
// file ./gm-editor.h line 68
signed int gm_editor_is_code(struct _GmEditor *editor);
// gm_editor_lines
// file ./gm-editor.h line 72
struct _GList * gm_editor_lines(struct _GmEditor *editor);
// gm_editor_lines_free
// file gm-editor.c line 122
void gm_editor_lines_free(struct _GmEditor *editor);
// gm_editor_mcp_type
// file ./gm-editor.h line 71
char * gm_editor_mcp_type(struct _GmEditor *editor);
// gm_editor_name
// file ./gm-editor.h line 69
char * gm_editor_name(struct _GmEditor *editor);
// gm_editor_new
// file gm-editor.h line 56
struct _GmEditor * gm_editor_new(char *name, char *uploadcmd, struct _GList *text);
// gm_editor_new_mcp
// file ./gm-editor.h line 57
struct _GmEditor * gm_editor_new_mcp(char *name, char *reference, char *type, struct _GList *text);
// gm_editor_save
// file ./gm-editor.h line 64
void gm_editor_save(struct _GmEditor *editor);
// gm_editor_saved
// file ./gm-editor.h line 65
void gm_editor_saved(struct _GmEditor *editor);
// gm_editor_set_lines_from_file
// file ./gm-editor.h line 61
void gm_editor_set_lines_from_file(struct _GmEditor *editor, const char *filename);
// gm_editor_set_lines_from_string
// file ./gm-editor.h line 60
void gm_editor_set_lines_from_string(struct _GmEditor *editor, const char *text);
// gm_editor_type
// file gm-editor.c line 171
enum _GmEditType gm_editor_type(struct _GmEditor *editor);
// gm_editor_upload_cmd
// file ./gm-editor.h line 70
char * gm_editor_upload_cmd(struct _GmEditor *editor);
// gm_editor_view_class_init
// file widgets/gm-editor-view.c line 144
static void gm_editor_view_class_init(struct _GmEditorViewClass *klass);
// gm_editor_view_class_intern_init
// file widgets/gm-editor-view.c line 91
static void gm_editor_view_class_intern_init(void *klass);
// gm_editor_view_create_source_view
// file widgets/gm-editor-view.c line 166
struct _GtkSourceView * gm_editor_view_create_source_view(struct _GmEditorView *view);
// gm_editor_view_editor
// file widgets/gm-editor-view.h line 57
struct _GmEditor * gm_editor_view_editor(struct _GmEditorView *view);
// gm_editor_view_finalize
// file widgets/gm-editor-view.c line 110
static void gm_editor_view_finalize(struct _GObject *object);
// gm_editor_view_get_type
// file widgets/gm-editor-view.h line 55
unsigned long int gm_editor_view_get_type(void);
// gm_editor_view_init
// file widgets/gm-editor-view.c line 365
static void gm_editor_view_init(struct _GmEditorView *obj);
// gm_editor_view_init_language
// file widgets/gm-editor-view.c line 127
void gm_editor_view_init_language();
// gm_editor_view_new
// file widgets/gm-editor-view.h line 56
struct _GmEditorView * gm_editor_view_new(struct _GmWorld *world, struct _GmEditor *editor);
// gm_editor_view_save
// file widgets/gm-editor-view.h line 58
void gm_editor_view_save(struct _GmEditorView *view);
// gm_editor_view_searchable_get_text_view
// file widgets/gm-editor-view.c line 101
static struct _GtkTextView * gm_editor_view_searchable_get_text_view(struct _GmSearchable *sea);
// gm_editor_view_searchable_iface_init
// file widgets/gm-editor-view.c line 96
static void gm_editor_view_searchable_iface_init(struct _GmSearchableInterface *iface);
// gm_editor_view_text_view
// file widgets/gm-editor-view.c line 407
struct _GtkTextView * gm_editor_view_text_view(struct _GmEditorView *view);
// gm_editor_write_lines
// file ./gm-editor.h line 62
char * gm_editor_write_lines(struct _GmEditor *editor);
// gm_embedded_view_class_init
// file widgets/gm-embedded-view.c line 71
static void gm_embedded_view_class_init(struct _GmEmbeddedViewClass *klass);
// gm_embedded_view_class_intern_init
// file widgets/gm-embedded-view.c line 43
static void gm_embedded_view_class_intern_init(void *klass);
// gm_embedded_view_editor
// file widgets/gm-embedded-view.h line 57
struct _GmEditor * gm_embedded_view_editor(struct _GmEmbeddedView *view);
// gm_embedded_view_finalize
// file widgets/gm-embedded-view.c line 46
static void gm_embedded_view_finalize(struct _GObject *object);
// gm_embedded_view_get_type
// file widgets/gm-embedded-view.h line 55
unsigned long int gm_embedded_view_get_type(void);
// gm_embedded_view_init
// file widgets/gm-embedded-view.c line 90
static void gm_embedded_view_init(struct _GmEmbeddedView *obj);
// gm_embedded_view_new
// file widgets/gm-embedded-view.h line 56
struct _GmEmbeddedView * gm_embedded_view_new(struct _GmWorld *world, struct _GmEditor *editor);
// gm_embedded_view_update_last_modified
// file widgets/gm-embedded-view.c line 123
void gm_embedded_view_update_last_modified(struct _GmEmbeddedView *embedded);
// gm_error_dialog
// file ./gm-support.h line 122
signed int gm_error_dialog(char *message, struct _GtkWindow *parent);
// gm_external_view_destroy
// file widgets/gm-external-view.h line 20
void gm_external_view_destroy(struct _GmExternalView *view);
// gm_external_view_new
// file widgets/gm-external-view.h line 19
struct _GmExternalView * gm_external_view_new(struct _GmWorld *world, struct _GmEditor *editor);
// gm_external_view_spawn
// file widgets/gm-external-view.c line 54
signed int gm_external_view_spawn(struct _GmExternalView *view, char **argv);
// gm_external_view_update_last_modified
// file widgets/gm-external-view.c line 45
void gm_external_view_update_last_modified(struct _GmExternalView *view);
// gm_fetch
// file ./gm-support.h line 134
struct _GmFetchHandle * gm_fetch(const struct _GList *source, const struct _GList *dest, void (*cb)(void *, void *), void *user_data);
// gm_fetch::cb$object
// 
void cb$object(void *, void *);
// gm_fetch_handle_create
// file gm-support.c line 273
struct _GmFetchHandle * gm_fetch_handle_create(void (*cb)(void *, void *), void *user_data);
// gm_fetch_handle_create::cb$object
// 
void cb$object(void *, void *);
// gm_fetch_handle_free
// file gm-support.c line 252
void gm_fetch_handle_free(struct _GmFetchHandle *g);
// gm_fetch_interact
// file gm-support.c line 370
signed int gm_fetch_interact(struct anonymous$80 *info, void *user_data);
// gm_fetch_progress
// file gm-support.c line 288
signed int gm_fetch_progress(struct GnomeVFSAsyncHandle *handle, struct anonymous$80 *info, struct _GmFetchHandle *g);
// gm_find_child
// file ./gm-support.h line 151
struct _GtkWidget * gm_find_child(struct _GtkWidget *widget, unsigned long int parent_type);
// gm_find_parent
// file gm-support.c line 582
struct _GtkWidget * gm_find_parent(struct _GtkWidget *widget, unsigned long int parent_type);
// gm_fix_decimal_point
// file gm-support.c line 31
char * gm_fix_decimal_point(char *line, signed int len);
// gm_fix_decimal_point_rev
// file gm-support.c line 49
char * gm_fix_decimal_point_rev(char *line, signed int len);
// gm_from_utf8_with_fallback
// file gm-support.h line 153
char * gm_from_utf8_with_fallback(const char *text, signed long int len, const char *to, const char *fallback);
// gm_g_list_find_simple
// file gm-support.c line 111
char * gm_g_list_find_simple(struct _GList *s, char *f);
// gm_g_list_free_simple
// file ./gm-support.h line 119
void gm_g_list_free_simple(struct _GList *s);
// gm_garray_length
// file gm-support.c line 91
signed int gm_garray_length(char **s);
// gm_info_dialog
// file ./gm-support.h line 124
signed int gm_info_dialog(char *message, struct _GtkWindow *parent);
// gm_is_end_scrolled
// file gm-support.c line 403
signed int gm_is_end_scrolled(struct _GtkScrolledWindow *wnd, unsigned int charHeight);
// gm_iuserlist_base_init
// file mcp/gm-iuserlist.c line 31
static void gm_iuserlist_base_init(void *object_class);
// gm_iuserlist_get_icon
// file mcp/gm-iuserlist.c line 142
const char * gm_iuserlist_get_icon(struct _GmIUserlist *self, signed int id, signed int use_state);
// gm_iuserlist_get_menu
// file mcp/gm-iuserlist.c line 86
struct _GList * gm_iuserlist_get_menu(struct _GmIUserlist *self, signed int id);
// gm_iuserlist_get_name
// file mcp/gm-iuserlist.c line 127
const char * gm_iuserlist_get_name(struct _GmIUserlist *self, signed int id);
// gm_iuserlist_get_rank_priority
// file mcp/gm-iuserlist.c line 157
signed int gm_iuserlist_get_rank_priority(struct _GmIUserlist *self, signed int id);
// gm_iuserlist_get_state_priority
// file mcp/gm-iuserlist.c line 172
signed int gm_iuserlist_get_state_priority(struct _GmIUserlist *self, signed int id);
// gm_iuserlist_get_status
// file mcp/gm-iuserlist.c line 112
char * gm_iuserlist_get_status(struct _GmIUserlist *self, signed int id);
// gm_iuserlist_get_type
// file mcp/gm-iuserlist.c line 7
unsigned long int gm_iuserlist_get_type();
// gm_iuserlist_supports_status
// file mcp/gm-iuserlist.c line 101
signed int gm_iuserlist_supports_status(struct _GmIUserlist *self);
// gm_log_view_class_init
// file widgets/gm-log-view.c line 56
static void gm_log_view_class_init(struct _GmLogViewClass *klass);
// gm_log_view_class_intern_init
// file widgets/gm-log-view.c line 31
static void gm_log_view_class_intern_init(void *klass);
// gm_log_view_create_filter
// file widgets/gm-log-view.c line 107
struct _GtkWidget * gm_log_view_create_filter(struct _GmLogView *obj);
// gm_log_view_create_tags
// file widgets/gm-log-view.c line 78
static void gm_log_view_create_tags(struct _GmLogView *obj);
// gm_log_view_create_text_view
// file widgets/gm-log-view.c line 89
static void gm_log_view_create_text_view(struct _GmLogView *obj);
// gm_log_view_finalize
// file widgets/gm-log-view.c line 50
static void gm_log_view_finalize(struct _GObject *object);
// gm_log_view_get_tag
// file widgets/gm-log-view.c line 208
const char * gm_log_view_get_tag(const char *last);
// gm_log_view_get_type
// file widgets/gm-log-view.h line 53
unsigned long int gm_log_view_get_type(void);
// gm_log_view_init
// file widgets/gm-log-view.c line 174
static void gm_log_view_init(struct _GmLogView *obj);
// gm_log_view_new
// file widgets/gm-log-view.h line 54
struct _GmLogView * gm_log_view_new(void);
// gm_log_view_searchable_get_text_view
// file widgets/gm-log-view.c line 41
static struct _GtkTextView * gm_log_view_searchable_get_text_view(struct _GmSearchable *sea);
// gm_log_view_searchable_iface_init
// file widgets/gm-log-view.c line 36
static void gm_log_view_searchable_iface_init(struct _GmSearchableInterface *iface);
// gm_log_view_set_text
// file widgets/gm-log-view.h line 55
void gm_log_view_set_text(struct _GmLogView *view, const char *text);
// gm_marshal_VOID__INT_INT_STRING
// file gm-marshal.c line 324
extern void gm_marshal_VOID__INT_INT_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__INT_INT_STRING::1::callback$object
// 
//void callback$object(void *, signed int, signed int, void *, void *);
// gm_marshal_VOID__INT_STRING
// file gm-marshal.c line 166
extern void gm_marshal_VOID__INT_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__INT_STRING::1::callback$object
// 
//void callback$object(void *, signed int, void *, void *);
// gm_marshal_VOID__INT_STRING_STRING
// file gm-marshal.c line 203
extern void gm_marshal_VOID__INT_STRING_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__INT_STRING_STRING::1::callback$object
// 
//void callback$object(void *, signed int, void *, void *, void *);
// gm_marshal_VOID__INT_STRING_STRING_STRING
// file gm-marshal.c line 242
extern void gm_marshal_VOID__INT_STRING_STRING_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__INT_STRING_STRING_STRING::1::callback$object
// 
//void callback$object(void *, signed int, void *, void *, void *, void *);
// gm_marshal_VOID__POINTER_STRING_STRING_STRING
// file ./gm-marshal.h line 58
extern void gm_marshal_VOID__POINTER_STRING_STRING_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__POINTER_STRING_STRING_STRING::1::callback$object
// 
//void callback$object(void *, void *, void *, void *, void *, void *);
// gm_marshal_VOID__STRING_INT
// file gm-marshal.c line 92
extern void gm_marshal_VOID__STRING_INT(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__STRING_INT::1::callback$object
// 
//void callback$object(void *, void *, signed int, void *);
// gm_marshal_VOID__STRING_UINT
// file gm-marshal.c line 55
extern void gm_marshal_VOID__STRING_UINT(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__STRING_UINT::1::callback$object
// 
//void callback$object(void *, void *, unsigned int, void *);
// gm_marshal_VOID__UINT_UINT
// file ./gm-marshal.h line 26
extern void gm_marshal_VOID__UINT_UINT(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data);
// gm_marshal_VOID__UINT_UINT::1::callback$object
// 
//void callback$object(void *, unsigned int, unsigned int, void *);
// gm_mcp_awns_ping_class_init
// file mcp/gm-mcp-awns-ping.c line 35
static void gm_mcp_awns_ping_class_init(struct _GmMcpAwnsPingClass *klass);
// gm_mcp_awns_ping_class_intern_init
// file mcp/gm-mcp-awns-ping.c line 22
static void gm_mcp_awns_ping_class_intern_init(void *klass);
// gm_mcp_awns_ping_finalize
// file mcp/gm-mcp-awns-ping.c line 28
static void gm_mcp_awns_ping_finalize(struct _GObject *object);
// gm_mcp_awns_ping_get_type
// file mcp/gm-mcp-awns-ping.h line 54
unsigned long int gm_mcp_awns_ping_get_type(void);
// gm_mcp_awns_ping_handle_simple
// file mcp/gm-mcp-awns-ping.c line 70
void gm_mcp_awns_ping_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_awns_ping_init
// file mcp/gm-mcp-awns-ping.c line 58
static void gm_mcp_awns_ping_init(struct _GmMcpAwnsPing *obj);
// gm_mcp_awns_ping_new
// file mcp/gm-mcp-awns-ping.c line 63
struct _GmMcpAwnsPing * gm_mcp_awns_ping_new(void);
// gm_mcp_awns_status_class_init
// file mcp/gm-mcp-awns-status.c line 44
static void gm_mcp_awns_status_class_init(struct _GmMcpAwnsStatusClass *klass);
// gm_mcp_awns_status_class_intern_init
// file mcp/gm-mcp-awns-status.c line 34
static void gm_mcp_awns_status_class_intern_init(void *klass);
// gm_mcp_awns_status_create_view
// file mcp/gm-mcp-awns-status.c line 107
void gm_mcp_awns_status_create_view(struct _GmMcpPackage *package, struct _GObject *parent);
// gm_mcp_awns_status_finalize
// file mcp/gm-mcp-awns-status.c line 37
static void gm_mcp_awns_status_finalize(struct _GObject *object);
// gm_mcp_awns_status_get_type
// file mcp/gm-mcp-awns-status.h line 53
unsigned long int gm_mcp_awns_status_get_type(void);
// gm_mcp_awns_status_handle_simple
// file mcp/gm-mcp-awns-status.c line 84
void gm_mcp_awns_status_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_awns_status_init
// file mcp/gm-mcp-awns-status.c line 69
static void gm_mcp_awns_status_init(struct _GmMcpAwnsStatus *obj);
// gm_mcp_awns_status_new
// file mcp/gm-mcp-awns-status.c line 75
struct _GmMcpAwnsStatus * gm_mcp_awns_status_new(void);
// gm_mcp_classes_initialize
// file mcp/gm-mcp-classes.c line 14
struct _GList * gm_mcp_classes_initialize();
// gm_mcp_destroy_fields
// file mcp/gm-mcp.c line 248
void gm_mcp_destroy_fields(struct _GList *fields);
// gm_mcp_escape_if_needed
// file mcp/gm-mcp.c line 42
char * gm_mcp_escape_if_needed(const char *line);
// gm_mcp_find_multiline_tag
// file mcp/gm-mcp.c line 229
const char * gm_mcp_find_multiline_tag(const struct _GList *fields);
// gm_mcp_find_value
// file mcp/gm-mcp.c line 25
const char * gm_mcp_find_value(const struct _GList *fields, const char *key);
// gm_mcp_generate_auth_key
// file mcp/gm-mcp.c line 224
char * gm_mcp_generate_auth_key();
// gm_mcp_generate_data_tag
// file mcp/gm-mcp.c line 219
char * gm_mcp_generate_data_tag();
// gm_mcp_generate_key
// file mcp/gm-mcp.c line 201
char * gm_mcp_generate_key(signed int len);
// gm_mcp_get_version
// file mcp/gm-mcp.c line 11
double gm_mcp_get_version(double client_min, double client_max, double server_min, double server_max);
// gm_mcp_icecrew_mcpreset_class_init
// file mcp/gm-mcp-icecrew-mcpreset.c line 34
static void gm_mcp_icecrew_mcpreset_class_init(struct _GmMcpIcecrewMcpresetClass *klass);
// gm_mcp_icecrew_mcpreset_class_intern_init
// file mcp/gm-mcp-icecrew-mcpreset.c line 21
static void gm_mcp_icecrew_mcpreset_class_intern_init(void *klass);
// gm_mcp_icecrew_mcpreset_finalize
// file mcp/gm-mcp-icecrew-mcpreset.c line 27
static void gm_mcp_icecrew_mcpreset_finalize(struct _GObject *object);
// gm_mcp_icecrew_mcpreset_get_type
// file mcp/gm-mcp-icecrew-mcpreset.h line 54
unsigned long int gm_mcp_icecrew_mcpreset_get_type(void);
// gm_mcp_icecrew_mcpreset_handle_simple
// file mcp/gm-mcp-icecrew-mcpreset.c line 69
void gm_mcp_icecrew_mcpreset_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_icecrew_mcpreset_init
// file mcp/gm-mcp-icecrew-mcpreset.c line 57
static void gm_mcp_icecrew_mcpreset_init(struct _GmMcpIcecrewMcpreset *obj);
// gm_mcp_icecrew_mcpreset_new
// file mcp/gm-mcp-icecrew-mcpreset.c line 62
struct _GmMcpIcecrewMcpreset * gm_mcp_icecrew_mcpreset_new(void);
// gm_mcp_icecrew_playerdb_add_player
// file mcp/gm-mcp-icecrew-playerdb.c line 244
struct _GmPlayerdbPlayerInfo * gm_mcp_icecrew_playerdb_add_player(struct _GmMcpIcecrewPlayerdb *package, signed int id);
// gm_mcp_icecrew_playerdb_class_init
// file mcp/gm-mcp-icecrew-playerdb.c line 60
static void gm_mcp_icecrew_playerdb_class_init(struct _GmMcpIcecrewPlayerdbClass *klass);
// gm_mcp_icecrew_playerdb_class_intern_init
// file mcp/gm-mcp-icecrew-playerdb.c line 32
static void gm_mcp_icecrew_playerdb_class_intern_init(void *klass);
// gm_mcp_icecrew_playerdb_finalize
// file mcp/gm-mcp-icecrew-playerdb.c line 42
static void gm_mcp_icecrew_playerdb_finalize(struct _GObject *object);
// gm_mcp_icecrew_playerdb_find
// file mcp/gm-mcp-icecrew-playerdb.c line 126
struct _GmPlayerdbPlayerInfo * gm_mcp_icecrew_playerdb_find(struct _GmMcpIcecrewPlayerdb *package, signed int id);
// gm_mcp_icecrew_playerdb_find_players_with
// file mcp/gm-mcp-icecrew-playerdb.c line 152
void gm_mcp_icecrew_playerdb_find_players_with(struct _GmMcpIcecrewPlayerdb *package, const char *key, const char *value, void (*func)(struct _GmPlayerdbPlayerInfo *, void *), void *user_data);
// gm_mcp_icecrew_playerdb_find_players_with::func$object
// 
void func$object(struct _GmPlayerdbPlayerInfo *, void *);
// gm_mcp_icecrew_playerdb_get_type
// file mcp/gm-mcp-icecrew-playerdb.h line 64
unsigned long int gm_mcp_icecrew_playerdb_get_type(void);
// gm_mcp_icecrew_playerdb_handle_multi
// file mcp/gm-mcp-icecrew-playerdb.c line 304
signed int gm_mcp_icecrew_playerdb_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values);
// gm_mcp_icecrew_playerdb_handle_simple
// file mcp/gm-mcp-icecrew-playerdb.c line 258
void gm_mcp_icecrew_playerdb_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_icecrew_playerdb_init
// file mcp/gm-mcp-icecrew-playerdb.c line 109
static void gm_mcp_icecrew_playerdb_init(struct _GmMcpIcecrewPlayerdb *obj);
// gm_mcp_icecrew_playerdb_initializing
// file mcp/gm-mcp-icecrew-playerdb.c line 147
signed int gm_mcp_icecrew_playerdb_initializing(struct _GmMcpIcecrewPlayerdb *package);
// gm_mcp_icecrew_playerdb_modify_prop
// file mcp/gm-mcp-icecrew-playerdb.c line 208
void gm_mcp_icecrew_playerdb_modify_prop(struct _GmMcpIcecrewPlayerdb *package, struct _GmPlayerdbPlayerInfo *ppi, const char *key, const char *value, signed int add);
// gm_mcp_icecrew_playerdb_modify_prop_list
// file mcp/gm-mcp-icecrew-playerdb.c line 217
void gm_mcp_icecrew_playerdb_modify_prop_list(struct _GmMcpIcecrewPlayerdb *package, struct _GmPlayerdbPlayerInfo *ppi, struct _GList *fields, signed int add);
// gm_mcp_icecrew_playerdb_new
// file mcp/gm-mcp-icecrew-playerdb.c line 118
struct _GmMcpIcecrewPlayerdb * gm_mcp_icecrew_playerdb_new(void);
// gm_mcp_icecrew_playerdb_players
// file mcp/gm-mcp-icecrew-playerdb.c line 171
struct _GList * gm_mcp_icecrew_playerdb_players(struct _GmMcpIcecrewPlayerdb *db);
// gm_mcp_icecrew_playerdb_remove_player
// file mcp/gm-mcp-icecrew-playerdb.c line 231
void gm_mcp_icecrew_playerdb_remove_player(struct _GmMcpIcecrewPlayerdb *package, signed int id);
// gm_mcp_icecrew_playerdb_set_prop
// file mcp/gm-mcp-icecrew-playerdb.c line 176
void gm_mcp_icecrew_playerdb_set_prop(struct _GmMcpIcecrewPlayerdb *package, struct _GmPlayerdbPlayerInfo *ppi, const char *key, const char *value, signed int add);
// gm_mcp_icecrew_serverinfo_class_init
// file mcp/gm-mcp-icecrew-serverinfo.c line 73
static void gm_mcp_icecrew_serverinfo_class_init(struct _GmMcpIcecrewServerinfoClass *klass);
// gm_mcp_icecrew_serverinfo_class_intern_init
// file mcp/gm-mcp-icecrew-serverinfo.c line 36
static void gm_mcp_icecrew_serverinfo_class_intern_init(void *klass);
// gm_mcp_icecrew_serverinfo_create_view
// file mcp/gm-mcp-icecrew-serverinfo.c line 375
void gm_mcp_icecrew_serverinfo_create_view(struct _GmMcpPackage *package, struct _GObject *parent);
// gm_mcp_icecrew_serverinfo_fetch_progress
// file mcp/gm-mcp-icecrew-serverinfo.c line 115
void gm_mcp_icecrew_serverinfo_fetch_progress(struct _GmFetchHandle *g, struct _GmMcpIcecrewServerinfo *package);
// gm_mcp_icecrew_serverinfo_finalize
// file mcp/gm-mcp-icecrew-serverinfo.c line 64
static void gm_mcp_icecrew_serverinfo_finalize(struct _GObject *object);
// gm_mcp_icecrew_serverinfo_free_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 46
void gm_mcp_icecrew_serverinfo_free_info(struct _GmMcpIcecrewServerinfo *obj);
// gm_mcp_icecrew_serverinfo_get_type
// file mcp/gm-mcp-icecrew-serverinfo.h line 54
unsigned long int gm_mcp_icecrew_serverinfo_get_type(void);
// gm_mcp_icecrew_serverinfo_handle_simple
// file mcp/gm-mcp-icecrew-serverinfo.c line 168
void gm_mcp_icecrew_serverinfo_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_icecrew_serverinfo_has_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 293
signed int gm_mcp_icecrew_serverinfo_has_info(struct _GmMcpIcecrewServerinfo *package);
// gm_mcp_icecrew_serverinfo_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 298
const struct _GmWorldInfo * gm_mcp_icecrew_serverinfo_info(struct _GmMcpIcecrewServerinfo *package);
// gm_mcp_icecrew_serverinfo_init
// file mcp/gm-mcp-icecrew-serverinfo.c line 100
static void gm_mcp_icecrew_serverinfo_init(struct _GmMcpIcecrewServerinfo *obj);
// gm_mcp_icecrew_serverinfo_new
// file mcp/gm-mcp-icecrew-serverinfo.c line 107
struct _GmMcpIcecrewServerinfo * gm_mcp_icecrew_serverinfo_new(void);
// gm_mcp_icecrew_serverinfo_set_session
// file mcp/gm-mcp-icecrew-serverinfo.c line 271
void gm_mcp_icecrew_serverinfo_set_session(struct _GmMcpPackage *package, struct _GObject *session);
// gm_mcp_icecrew_serverinfo_view_set_visible
// file mcp/gm-mcp-icecrew-serverinfo.c line 310
void gm_mcp_icecrew_serverinfo_view_set_visible(struct _GmMcpIcecrewServerinfoView *view, signed int visible);
// gm_mcp_icecrew_userlist_class_init
// file mcp/gm-mcp-icecrew-userlist.c line 207
static void gm_mcp_icecrew_userlist_class_init(struct _GmMcpIcecrewUserlistClass *klass);
// gm_mcp_icecrew_userlist_class_intern_init
// file mcp/gm-mcp-icecrew-userlist.c line 97
static void gm_mcp_icecrew_userlist_class_intern_init(void *klass);
// gm_mcp_icecrew_userlist_create_view
// file mcp/gm-mcp-icecrew-userlist.c line 1175
void gm_mcp_icecrew_userlist_create_view(struct _GmMcpPackage *package, struct _GObject *parent);
// gm_mcp_icecrew_userlist_fetch_next_alternatives
// file mcp/gm-mcp-icecrew-userlist.c line 573
void gm_mcp_icecrew_userlist_fetch_next_alternatives(struct _GmMcpIcecrewUserlist *package, signed int rank);
// gm_mcp_icecrew_userlist_fetch_progress
// file mcp/gm-mcp-icecrew-userlist.c line 650
void gm_mcp_icecrew_userlist_fetch_progress(struct _GmFetchHandle *g, struct _GmMcpIcecrewUserlist *package);
// gm_mcp_icecrew_userlist_finalize
// file mcp/gm-mcp-icecrew-userlist.c line 171
static void gm_mcp_icecrew_userlist_finalize(struct _GObject *object);
// gm_mcp_icecrew_userlist_find_icon_names
// file mcp/gm-mcp-icecrew-userlist.c line 236
struct _GList * gm_mcp_icecrew_userlist_find_icon_names(struct _GList *icons, const char *path);
// gm_mcp_icecrew_userlist_find_key
// file mcp/gm-mcp-icecrew-userlist.c line 316
const char * gm_mcp_icecrew_userlist_find_key(struct _GmMcpIcecrewUserlist *package, const char *datatag);
// gm_mcp_icecrew_userlist_find_name
// file mcp/gm-mcp-icecrew-userlist.c line 337
const char * gm_mcp_icecrew_userlist_find_name(const char *name, struct _GmKeyValuePair *def);
// gm_mcp_icecrew_userlist_find_path
// file mcp/gm-mcp-icecrew-userlist.c line 256
unsigned int gm_mcp_icecrew_userlist_find_path(struct _GList *icons, const char *name, const char **path);
// gm_mcp_icecrew_userlist_free_list
// file mcp/gm-mcp-icecrew-userlist.c line 154
void gm_mcp_icecrew_userlist_free_list(struct _GList *rs);
// gm_mcp_icecrew_userlist_free_menu
// file mcp/gm-mcp-icecrew-userlist.c line 165
static void gm_mcp_icecrew_userlist_free_menu(struct _GmMcpIcecrewUserlist *obj);
// gm_mcp_icecrew_userlist_get_icon
// file mcp/gm-mcp-icecrew-userlist.c line 878
const char * gm_mcp_icecrew_userlist_get_icon(struct _GmIUserlist *userlist, signed int id, signed int use_state);
// gm_mcp_icecrew_userlist_get_menu
// file mcp/gm-mcp-icecrew-userlist.c line 849
struct _GList * gm_mcp_icecrew_userlist_get_menu(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_icecrew_userlist_get_menu_item
// file mcp/gm-mcp-icecrew-userlist.c line 831
struct _GmKeyValuePair * gm_mcp_icecrew_userlist_get_menu_item(struct _GmMcpIcecrewUserlist *package, struct _GmKeyValuePair *menuitem, struct _GmPlayerdbPlayerInfo *info);
// gm_mcp_icecrew_userlist_get_name
// file mcp/gm-mcp-icecrew-userlist.c line 866
const char * gm_mcp_icecrew_userlist_get_name(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_icecrew_userlist_get_rank_priority
// file mcp/gm-mcp-icecrew-userlist.c line 890
signed int gm_mcp_icecrew_userlist_get_rank_priority(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_icecrew_userlist_get_state_priority
// file mcp/gm-mcp-icecrew-userlist.c line 905
signed int gm_mcp_icecrew_userlist_get_state_priority(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_icecrew_userlist_get_status
// file mcp/gm-mcp-icecrew-userlist.c line 920
char * gm_mcp_icecrew_userlist_get_status(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_icecrew_userlist_get_type
// file mcp/gm-mcp-icecrew-userlist.h line 56
unsigned long int gm_mcp_icecrew_userlist_get_type(void);
// gm_mcp_icecrew_userlist_handle_menu
// file mcp/gm-mcp-icecrew-userlist.c line 955
void gm_mcp_icecrew_userlist_handle_menu(struct _GmMcpIcecrewUserlist *package, struct _GList *values);
// gm_mcp_icecrew_userlist_handle_multi
// file mcp/gm-mcp-icecrew-userlist.c line 1079
signed int gm_mcp_icecrew_userlist_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values);
// gm_mcp_icecrew_userlist_handle_ranks_states
// file mcp/gm-mcp-icecrew-userlist.c line 977
void gm_mcp_icecrew_userlist_handle_ranks_states(struct _GmMcpIcecrewUserlist *package, struct _GList *values, signed int rank);
// gm_mcp_icecrew_userlist_icon_path
// file mcp/gm-mcp-icecrew-userlist.c line 467
const char * gm_mcp_icecrew_userlist_icon_path(struct _GmMcpIcecrewUserlist *package, struct _GmPlayerdbPlayerInfo *ppi, signed int use_state);
// gm_mcp_icecrew_userlist_iface_init
// file mcp/gm-mcp-icecrew-userlist.c line 135
static void gm_mcp_icecrew_userlist_iface_init(struct _GmIUserlistInterface *iface);
// gm_mcp_icecrew_userlist_init
// file mcp/gm-mcp-icecrew-userlist.c line 383
static void gm_mcp_icecrew_userlist_init(struct _GmMcpIcecrewUserlist *obj);
// gm_mcp_icecrew_userlist_init_ranks
// file mcp/gm-mcp-icecrew-userlist.c line 370
void gm_mcp_icecrew_userlist_init_ranks(struct _GmMcpIcecrewUserlist *package);
// gm_mcp_icecrew_userlist_init_states
// file mcp/gm-mcp-icecrew-userlist.c line 357
void gm_mcp_icecrew_userlist_init_states(struct _GmMcpIcecrewUserlist *package);
// gm_mcp_icecrew_userlist_menu_item_subst
// file mcp/gm-mcp-icecrew-userlist.c line 756
char * gm_mcp_icecrew_userlist_menu_item_subst(struct _GmMcpIcecrewUserlist *package, char *str, struct _GmPlayerdbPlayerInfo *info);
// gm_mcp_icecrew_userlist_new
// file mcp/gm-mcp-icecrew-userlist.c line 399
struct _GmMcpIcecrewUserlist * gm_mcp_icecrew_userlist_new(void);
// gm_mcp_icecrew_userlist_new_rank_state_icon
// file mcp/gm-mcp-icecrew-userlist.c line 501
void gm_mcp_icecrew_userlist_new_rank_state_icon(struct _GmMcpIcecrewUserlist *package, char *path, signed int rank);
// gm_mcp_icecrew_userlist_pair_free
// file mcp/gm-mcp-icecrew-userlist.c line 147
void gm_mcp_icecrew_userlist_pair_free(struct _GmKeyValuePair *pair);
// gm_mcp_icecrew_userlist_process_state_changed
// file mcp/gm-mcp-icecrew-userlist.c line 1180
void gm_mcp_icecrew_userlist_process_state_changed(struct _GmMcpIcecrewUserlist *userlist, struct _GmPlayerdbPlayerInfo *ppi, const char *value, const char *old);
// gm_mcp_icecrew_userlist_process_triggers
// file mcp/gm-mcp-icecrew-userlist.c line 723
void gm_mcp_icecrew_userlist_process_triggers(struct _GmMcpIcecrewUserlist *package, const char *username, enum _GmTriggerConditionType condition);
// gm_mcp_icecrew_userlist_remote_to_local_path
// file mcp/gm-mcp-icecrew-userlist.c line 407
char * gm_mcp_icecrew_userlist_remote_to_local_path(const char *url, const char *dirname);
// gm_mcp_icecrew_userlist_remove_alternatives
// file mcp/gm-mcp-icecrew-userlist.c line 419
void gm_mcp_icecrew_userlist_remove_alternatives(struct _GmMcpIcecrewUserlist *package, const char *path, signed int n, signed int rank);
// gm_mcp_icecrew_userlist_remove_datatag
// file mcp/gm-mcp-icecrew-userlist.c line 291
void gm_mcp_icecrew_userlist_remove_datatag(struct _GmMcpIcecrewUserlist *package, const char *datatag);
// gm_mcp_icecrew_userlist_remove_not_used_icons
// file mcp/gm-mcp-icecrew-userlist.c line 544
void gm_mcp_icecrew_userlist_remove_not_used_icons(struct _GList *icons, char *dir);
// gm_mcp_icecrew_userlist_set_session
// file mcp/gm-mcp-icecrew-userlist.c line 1124
void gm_mcp_icecrew_userlist_set_session(struct _GmMcpPackage *package, struct _GObject *session);
// gm_mcp_icecrew_userlist_update_rank_icon
// file mcp/gm-mcp-icecrew-userlist.c line 489
void gm_mcp_icecrew_userlist_update_rank_icon(struct _GmPlayerdbPlayerInfo *ppi, void *user_data);
// gm_mcp_icecrew_userlist_update_state_icon
// file mcp/gm-mcp-icecrew-userlist.c line 495
void gm_mcp_icecrew_userlist_update_state_icon(struct _GmPlayerdbPlayerInfo *ppi, void *user_data);
// gm_mcp_icecrew_userlist_url_map_new
// file mcp/gm-mcp-icecrew-userlist.c line 226
struct _GmKeyValuePair * gm_mcp_icecrew_userlist_url_map_new(const char *name, const char *filename);
// gm_mcp_list_free
// file mcp/gm-mcp.c line 268
void gm_mcp_list_free(struct _GList *list);
// gm_mcp_mud_moo_simpleedit_add_editor
// file mcp/gm-mcp-mud-moo-simpleedit.c line 137
static void gm_mcp_mud_moo_simpleedit_add_editor(struct _GmMcpMudMooSimpleedit *package, struct _GmEditor *editor);
// gm_mcp_mud_moo_simpleedit_class_init
// file mcp/gm-mcp-mud-moo-simpleedit.c line 70
static void gm_mcp_mud_moo_simpleedit_class_init(struct _GmMcpMudMooSimpleeditClass *klass);
// gm_mcp_mud_moo_simpleedit_class_intern_init
// file mcp/gm-mcp-mud-moo-simpleedit.c line 29
static void gm_mcp_mud_moo_simpleedit_class_intern_init(void *klass);
// gm_mcp_mud_moo_simpleedit_finalize
// file mcp/gm-mcp-mud-moo-simpleedit.c line 51
static void gm_mcp_mud_moo_simpleedit_finalize(struct _GObject *object);
// gm_mcp_mud_moo_simpleedit_get_type
// file mcp/gm-mcp-mud-moo-simpleedit.h line 54
unsigned long int gm_mcp_mud_moo_simpleedit_get_type(void);
// gm_mcp_mud_moo_simpleedit_handle_multi
// file mcp/gm-mcp-mud-moo-simpleedit.c line 148
signed int gm_mcp_mud_moo_simpleedit_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values);
// gm_mcp_mud_moo_simpleedit_handle_simple
// file mcp/gm-mcp-mud-moo-simpleedit.c line 107
void gm_mcp_mud_moo_simpleedit_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_mud_moo_simpleedit_init
// file mcp/gm-mcp-mud-moo-simpleedit.c line 95
static void gm_mcp_mud_moo_simpleedit_init(struct _GmMcpMudMooSimpleedit *obj);
// gm_mcp_mud_moo_simpleedit_new
// file mcp/gm-mcp-mud-moo-simpleedit.c line 100
struct _GmMcpMudMooSimpleedit * gm_mcp_mud_moo_simpleedit_new(void);
// gm_mcp_mud_moo_simpleedit_remove_editor
// file mcp/gm-mcp-mud-moo-simpleedit.c line 41
static void gm_mcp_mud_moo_simpleedit_remove_editor(struct _GmMcpMudMooSimpleedit *simpleedit, struct _GmEditor *editor);
// gm_mcp_mud_moo_simpleedit_set_session
// file mcp/gm-mcp-mud-moo-simpleedit.c line 170
void gm_mcp_mud_moo_simpleedit_set_session(struct _GmMcpPackage *package, struct _GObject *session);
// gm_mcp_negotiate_class_init
// file mcp/gm-mcp-negotiate.c line 46
static void gm_mcp_negotiate_class_init(struct _GmMcpNegotiateClass *klass);
// gm_mcp_negotiate_class_intern_init
// file mcp/gm-mcp-negotiate.c line 36
static void gm_mcp_negotiate_class_intern_init(void *klass);
// gm_mcp_negotiate_finalize
// file mcp/gm-mcp-negotiate.c line 39
static void gm_mcp_negotiate_finalize(struct _GObject *object);
// gm_mcp_negotiate_find_package
// file mcp/gm-mcp-negotiate.c line 75
struct _PackageInfo * gm_mcp_negotiate_find_package(struct _GmMcpNegotiate *package, char *name);
// gm_mcp_negotiate_fix_depends
// file mcp/gm-mcp-negotiate.c line 123
void gm_mcp_negotiate_fix_depends(struct _GmMcpNegotiate *package);
// gm_mcp_negotiate_fix_overrides
// file mcp/gm-mcp-negotiate.c line 92
void gm_mcp_negotiate_fix_overrides(struct _GmMcpNegotiate *package);
// gm_mcp_negotiate_get_type
// file mcp/gm-mcp-negotiate.h line 53
unsigned long int gm_mcp_negotiate_get_type(void);
// gm_mcp_negotiate_handle_simple
// file mcp/gm-mcp-negotiate.c line 191
void gm_mcp_negotiate_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_negotiate_init
// file mcp/gm-mcp-negotiate.c line 69
static void gm_mcp_negotiate_init(struct _GmMcpNegotiate *obj);
// gm_mcp_negotiate_new
// file mcp/gm-mcp-negotiate.c line 167
struct _GmMcpNegotiate * gm_mcp_negotiate_new(void);
// gm_mcp_negotiate_send_can
// file mcp/gm-mcp-negotiate.c line 176
signed int gm_mcp_negotiate_send_can(struct _GmMcpPackageClass *klass, void *user_data);
// gm_mcp_package_can_create_view
// file mcp/gm-mcp-package.c line 115
signed int gm_mcp_package_can_create_view(struct _GmMcpPackage *package);
// gm_mcp_package_can_handle_multi
// file mcp/gm-mcp-package.h line 77
signed int gm_mcp_package_can_handle_multi(struct _GmMcpPackage *package);
// gm_mcp_package_can_handle_simple
// file mcp/gm-mcp-package.h line 73
signed int gm_mcp_package_can_handle_simple(struct _GmMcpPackage *package);
// gm_mcp_package_class_init
// file mcp/gm-mcp-package.c line 34
static void gm_mcp_package_class_init(struct _GmMcpPackageClass *klass);
// gm_mcp_package_class_intern_init
// file mcp/gm-mcp-package.c line 24
static void gm_mcp_package_class_intern_init(void *klass);
// gm_mcp_package_create_view
// file ./mcp/gm-mcp-package.h line 79
void gm_mcp_package_create_view(struct _GmMcpPackage *package, struct _GObject *parent);
// gm_mcp_package_finalize
// file mcp/gm-mcp-package.c line 28
static void gm_mcp_package_finalize(struct _GObject *object);
// gm_mcp_package_get_depends
// file mcp/gm-mcp-package.c line 145
char ** gm_mcp_package_get_depends(struct _GmMcpPackage *package);
// gm_mcp_package_get_max_version
// file mcp/gm-mcp-package.c line 160
double gm_mcp_package_get_max_version(struct _GmMcpPackage *package);
// gm_mcp_package_get_min_version
// file mcp/gm-mcp-package.c line 155
double gm_mcp_package_get_min_version(struct _GmMcpPackage *package);
// gm_mcp_package_get_name
// file mcp/gm-mcp-package.h line 87
const char * gm_mcp_package_get_name(struct _GmMcpPackage *package);
// gm_mcp_package_get_overrides
// file mcp/gm-mcp-package.c line 150
char ** gm_mcp_package_get_overrides(struct _GmMcpPackage *package);
// gm_mcp_package_get_session
// file mcp/gm-mcp-package.c line 125
struct _GObject * gm_mcp_package_get_session(struct _GmMcpPackage *package);
// gm_mcp_package_get_type
// file mcp/gm-mcp-package.h line 67
unsigned long int gm_mcp_package_get_type(void);
// gm_mcp_package_get_version
// file mcp/gm-mcp-package.c line 135
double gm_mcp_package_get_version(struct _GmMcpPackage *package);
// gm_mcp_package_handle_multi
// file mcp/gm-mcp-package.h line 75
signed int gm_mcp_package_handle_multi(struct _GmMcpPackage *package, char *data_tag, char *key, char *value, struct _GList *allValues);
// gm_mcp_package_handle_simple
// file mcp/gm-mcp-package.h line 71
void gm_mcp_package_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_package_init
// file mcp/gm-mcp-package.c line 64
static void gm_mcp_package_init(struct _GmMcpPackage *obj);
// gm_mcp_package_new
// file mcp/gm-mcp-package.c line 77
struct _GmMcpPackage * gm_mcp_package_new();
// gm_mcp_package_set_session
// file mcp/gm-mcp-package.h line 69
void gm_mcp_package_set_session(struct _GmMcpPackage *package, struct _GObject *session);
// gm_mcp_package_set_session_real
// file mcp/gm-mcp-package.c line 71
void gm_mcp_package_set_session_real(struct _GmMcpPackage *package, struct _GObject *session);
// gm_mcp_package_set_version
// file mcp/gm-mcp-package.h line 82
void gm_mcp_package_set_version(struct _GmMcpPackage *package, double version);
// gm_mcp_parse_line
// file mcp/gm-mcp.c line 175
signed int gm_mcp_parse_line(char *line, struct _McpMessageInfo *info);
// gm_mcp_parse_list
// file mcp/gm-mcp.c line 273
struct _GList * gm_mcp_parse_list(const char *s);
// gm_mcp_process_key_values
// file mcp/gm-mcp.c line 164
struct _GList * gm_mcp_process_key_values(const char *line);
// gm_mcp_process_keyval
// file mcp/gm-mcp.c line 98
const char * gm_mcp_process_keyval(struct _GList **info, const char *line);
// gm_mcp_session_class_init
// file mcp/gm-mcp-session.c line 46
static void gm_mcp_session_class_init(struct _GmMcpSessionClass *klass);
// gm_mcp_session_class_intern_init
// file mcp/gm-mcp-session.c line 35
static void gm_mcp_session_class_intern_init(void *klass);
// gm_mcp_session_create_package
// file mcp/gm-mcp-session.c line 400
struct _GmMcpPackage * gm_mcp_session_create_package(struct _GmMcpSession *session, struct _GmMcpPackageClass *klass, double version);
// gm_mcp_session_finalize
// file mcp/gm-mcp-session.c line 38
static void gm_mcp_session_finalize(struct _GObject *object);
// gm_mcp_session_find_package
// file mcp/gm-mcp-session.c line 379
struct _GmMcpPackage * gm_mcp_session_find_package(struct _GmMcpSession *session, const char *pname);
// gm_mcp_session_find_package_class
// file mcp/gm-mcp-session.c line 436
struct _GmMcpPackageClass * gm_mcp_session_find_package_class(const char *name);
// gm_mcp_session_find_package_class_real
// file mcp/gm-mcp-session.c line 429
signed int gm_mcp_session_find_package_class_real(struct _GmMcpPackageClass *klass, void *user_data);
// gm_mcp_session_get_packages
// file mcp/gm-mcp-session.c line 271
const struct _GList * gm_mcp_session_get_packages(struct _GmMcpSession *session);
// gm_mcp_session_get_type
// file mcp/gm-mcp-session.c line 35
unsigned long int gm_mcp_session_get_type(void);
// gm_mcp_session_handle_multiline
// file mcp/gm-mcp-session.c line 173
void gm_mcp_session_handle_multiline(struct _GmMcpSession *session, const char *line);
// gm_mcp_session_handle_multiline_end
// file mcp/gm-mcp-session.c line 205
void gm_mcp_session_handle_multiline_end(struct _GmMcpSession *session, char *line);
// gm_mcp_session_handle_oob
// file mcp/gm-mcp-session.c line 442
void gm_mcp_session_handle_oob(struct _GmMcpSession *session, char *line);
// gm_mcp_session_handle_open
// file mcp/gm-mcp-session.c line 76
void gm_mcp_session_handle_open(struct _GmMcpSession *session, char *line);
// gm_mcp_session_has_package_of_class
// file mcp/gm-mcp-session.c line 360
struct _GmMcpPackage * gm_mcp_session_has_package_of_class(struct _GmMcpSession *session, struct _GmMcpPackageClass *klass);
// gm_mcp_session_init
// file mcp/gm-mcp-session.c line 67
static void gm_mcp_session_init(struct _GmMcpSession *obj);
// gm_mcp_session_initialized
// file mcp/gm-mcp-session.c line 266
signed int gm_mcp_session_initialized(struct _GmMcpSession *session);
// gm_mcp_session_invoke_multiline_handle
// file mcp/gm-mcp-session.c line 122
void gm_mcp_session_invoke_multiline_handle(struct _GmMcpSession *session, char *data_tag, char *key, char *value);
// gm_mcp_session_new
// file mcp/gm-mcp-session.c line 218
struct _GmMcpSession * gm_mcp_session_new(struct _GObject *world);
// gm_mcp_session_package_class_for_each
// file mcp/gm-mcp-session.c line 276
struct _GmMcpPackageClass * gm_mcp_session_package_class_for_each(signed int (*func)(struct _GmMcpPackageClass *, void *), void *user_data);
// gm_mcp_session_package_class_for_each::func$object
// 
//signed int func$object(struct _GmMcpPackageClass *, void *);
// gm_mcp_session_reset
// file mcp/gm-mcp-session.c line 226
void gm_mcp_session_reset(struct _GmMcpSession *session);
// gm_mcp_session_send_multiline
// file mcp/gm-mcp-session.c line 294
void gm_mcp_session_send_multiline(struct _GmMcpSession *session, const char *data_tag, const char *key, const struct _GList *lines);
// gm_mcp_session_send_simple
// file mcp/gm-mcp-session.c line 315
void gm_mcp_session_send_simple(struct _GmMcpSession *session, const char *pname, const char *first_key, ...);
// gm_mcp_session_world
// file mcp/gm-mcp-session.c line 545
struct _GObject * gm_mcp_session_world(struct _GmMcpSession *session);
// gm_mcp_un_escape
// file mcp/gm-mcp.c line 75
char * gm_mcp_un_escape(char *line);
// gm_mcp_userlist_view_create_label
// file mcp/gm-mcp-userlist-view.c line 262
struct _GtkWidget * gm_mcp_userlist_view_create_label(struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_create_userlist
// file mcp/gm-mcp-userlist-view.c line 279
struct _GtkWidget * gm_mcp_userlist_view_create_userlist(struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_do_popup
// file mcp/gm-mcp-userlist-view.c line 775
static signed int gm_mcp_userlist_view_do_popup(struct _GmMcpUserlistView *view, struct _GdkEventButton *event);
// gm_mcp_userlist_view_find
// file mcp/gm-mcp-userlist-view.c line 585
static signed int gm_mcp_userlist_view_find(struct _GmMcpUserlistView *view, signed int id, struct _GtkTreeIter *iter);
// gm_mcp_userlist_view_get_name
// file mcp/gm-mcp-userlist-view.c line 412
static char * gm_mcp_userlist_view_get_name(struct _GmMcpUserlistView *view, signed int id);
// gm_mcp_userlist_view_get_status
// file mcp/gm-mcp-userlist-view.c line 402
static char * gm_mcp_userlist_view_get_status(struct _GmMcpUserlistView *view, signed int id);
// gm_mcp_userlist_view_idle_scroll
// file mcp/gm-mcp-userlist-view.c line 86
static signed int gm_mcp_userlist_view_idle_scroll(struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_model_create
// file mcp/gm-mcp-userlist-view.c line 128
struct _GtkTreeModel * gm_mcp_userlist_view_model_create(struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_new
// file mcp/gm-mcp-userlist-view.c line 332
void gm_mcp_userlist_view_new(struct _GmMcpPackage *package, struct _GObject *parent);
// gm_mcp_userlist_view_player_active
// file mcp/gm-mcp-userlist-view.c line 518
static signed int gm_mcp_userlist_view_player_active(struct _GmMcpUserlistView *view, struct _GtkTreeIter *iter);
// gm_mcp_userlist_view_prepare_scroll
// file mcp/gm-mcp-userlist-view.c line 97
static void gm_mcp_userlist_view_prepare_scroll(struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_sort_func
// file mcp/gm-mcp-userlist-view.c line 225
signed int gm_mcp_userlist_view_sort_func(struct _GtkTreeModel *model, struct _GtkTreeIter *a, struct _GtkTreeIter *b, struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_sort_name
// file mcp/gm-mcp-userlist-view.c line 219
static signed int gm_mcp_userlist_view_sort_name(struct _SortInfo *info1, struct _SortInfo *info2);
// gm_mcp_userlist_view_sort_rank_name
// file mcp/gm-mcp-userlist-view.c line 199
static signed int gm_mcp_userlist_view_sort_rank_name(struct _SortInfo *info1, struct _SortInfo *info2);
// gm_mcp_userlist_view_sort_state_name
// file mcp/gm-mcp-userlist-view.c line 209
static signed int gm_mcp_userlist_view_sort_state_name(struct _SortInfo *info1, struct _SortInfo *info2);
// gm_mcp_userlist_view_sort_state_rank_name
// file mcp/gm-mcp-userlist-view.c line 178
static signed int gm_mcp_userlist_view_sort_state_rank_name(struct _SortInfo *info1, struct _SortInfo *info2);
// gm_mcp_userlist_view_update_label
// file mcp/gm-mcp-userlist-view.c line 251
static void gm_mcp_userlist_view_update_label(struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_update_names
// file mcp/gm-mcp-userlist-view.c line 444
static void gm_mcp_userlist_view_update_names(struct _GmMcpUserlistView *view);
// gm_mcp_userlist_view_update_show_object_number
// file mcp/gm-mcp-userlist-view.c line 467
static void gm_mcp_userlist_view_update_show_object_number(struct _GmMcpUserlistView *view, signed int show_object);
// gm_mcp_userlist_view_update_show_status
// file mcp/gm-mcp-userlist-view.c line 479
static void gm_mcp_userlist_view_update_show_status(struct _GmMcpUserlistView *view, signed int show_status);
// gm_mcp_userlist_view_update_sort_type
// file mcp/gm-mcp-userlist-view.c line 425
static void gm_mcp_userlist_view_update_sort_type(struct _GmMcpUserlistView *view, enum _GmUserlistSortType sort_type);
// gm_mcp_userlist_view_update_use_state_icon
// file mcp/gm-mcp-userlist-view.c line 490
static void gm_mcp_userlist_view_update_use_state_icon(struct _GmMcpUserlistView *view, signed int use_state_icon);
// gm_mcp_vmoo_client_class_init
// file mcp/gm-mcp-vmoo-client.c line 53
static void gm_mcp_vmoo_client_class_init(struct _GmMcpVmooClientClass *klass);
// gm_mcp_vmoo_client_class_intern_init
// file mcp/gm-mcp-vmoo-client.c line 38
static void gm_mcp_vmoo_client_class_intern_init(void *klass);
// gm_mcp_vmoo_client_create_view
// file mcp/gm-mcp-vmoo-client.c line 196
void gm_mcp_vmoo_client_create_view(struct _GmMcpPackage *package, struct _GObject *parent);
// gm_mcp_vmoo_client_finalize
// file mcp/gm-mcp-vmoo-client.c line 46
static void gm_mcp_vmoo_client_finalize(struct _GObject *object);
// gm_mcp_vmoo_client_get_type
// file mcp/gm-mcp-vmoo-client.h line 54
unsigned long int gm_mcp_vmoo_client_get_type(void);
// gm_mcp_vmoo_client_handle_simple
// file mcp/gm-mcp-vmoo-client.c line 90
void gm_mcp_vmoo_client_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_vmoo_client_init
// file mcp/gm-mcp-vmoo-client.c line 78
static void gm_mcp_vmoo_client_init(struct _GmMcpVmooClient *obj);
// gm_mcp_vmoo_client_install_timeout
// file mcp/gm-mcp-vmoo-client.c line 162
void gm_mcp_vmoo_client_install_timeout(struct _GmMcpVmooClientView *view);
// gm_mcp_vmoo_client_new
// file mcp/gm-mcp-vmoo-client.c line 83
struct _GmMcpVmooClient * gm_mcp_vmoo_client_new(void);
// gm_mcp_vmoo_client_set_session
// file mcp/gm-mcp-vmoo-client.c line 99
void gm_mcp_vmoo_client_set_session(struct _GmMcpPackage *package, struct _GObject *session);
// gm_mcp_vmoo_client_timeout_update
// file mcp/gm-mcp-vmoo-client.c line 154
signed int gm_mcp_vmoo_client_timeout_update(struct _GmMcpVmooClientView *view);
// gm_mcp_vmoo_client_view_update_metrics
// file mcp/gm-mcp-vmoo-client.c line 117
void gm_mcp_vmoo_client_view_update_metrics(struct _GmMcpVmooClientView *view);
// gm_mcp_vmoo_userlist_class_init
// file mcp/gm-mcp-vmoo-userlist.c line 151
static void gm_mcp_vmoo_userlist_class_init(struct _GmMcpVmooUserlistClass *klass);
// gm_mcp_vmoo_userlist_class_intern_init
// file mcp/gm-mcp-vmoo-userlist.c line 61
static void gm_mcp_vmoo_userlist_class_intern_init(void *klass);
// gm_mcp_vmoo_userlist_create_view
// file mcp/gm-mcp-vmoo-userlist.c line 800
void gm_mcp_vmoo_userlist_create_view(struct _GmMcpPackage *package, struct _GObject *parent);
// gm_mcp_vmoo_userlist_finalize
// file mcp/gm-mcp-vmoo-userlist.c line 126
static void gm_mcp_vmoo_userlist_finalize(struct _GObject *object);
// gm_mcp_vmoo_userlist_find_user
// file mcp/gm-mcp-vmoo-userlist.c line 344
struct _UserInfo * gm_mcp_vmoo_userlist_find_user(struct _GmMcpVmooUserlist *package, signed int nr);
// gm_mcp_vmoo_userlist_free_menu
// file mcp/gm-mcp-vmoo-userlist.c line 110
static void gm_mcp_vmoo_userlist_free_menu(struct _GmMcpVmooUserlist *obj);
// gm_mcp_vmoo_userlist_get_icon
// file mcp/gm-mcp-vmoo-userlist.c line 480
const char * gm_mcp_vmoo_userlist_get_icon(struct _GmIUserlist *userlist, signed int id, signed int use_state);
// gm_mcp_vmoo_userlist_get_int
// file mcp/gm-mcp-vmoo-userlist.c line 324
signed int gm_mcp_vmoo_userlist_get_int(struct _GmMcpVmooUserlist *package, struct _MOOVar *v, enum anonymous$34 type, char *cmp);
// gm_mcp_vmoo_userlist_get_menu
// file mcp/gm-mcp-vmoo-userlist.c line 452
struct _GList * gm_mcp_vmoo_userlist_get_menu(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_vmoo_userlist_get_menu_item
// file mcp/gm-mcp-vmoo-userlist.c line 435
struct _GmKeyValuePair * gm_mcp_vmoo_userlist_get_menu_item(struct _GmMcpVmooUserlist *package, struct _GmKeyValuePair *menuitem, struct _UserInfo *info);
// gm_mcp_vmoo_userlist_get_name
// file mcp/gm-mcp-vmoo-userlist.c line 472
const char * gm_mcp_vmoo_userlist_get_name(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_vmoo_userlist_get_rank_priority
// file mcp/gm-mcp-vmoo-userlist.c line 489
signed int gm_mcp_vmoo_userlist_get_rank_priority(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_vmoo_userlist_get_state_priority
// file mcp/gm-mcp-vmoo-userlist.c line 497
signed int gm_mcp_vmoo_userlist_get_state_priority(struct _GmIUserlist *userlist, signed int id);
// gm_mcp_vmoo_userlist_get_string
// file mcp/gm-mcp-vmoo-userlist.c line 304
char * gm_mcp_vmoo_userlist_get_string(struct _GmMcpVmooUserlist *package, struct _MOOVar *v, enum anonymous$34 type, char *cmp);
// gm_mcp_vmoo_userlist_get_type
// file mcp/gm-mcp-vmoo-userlist.h line 51
unsigned long int gm_mcp_vmoo_userlist_get_type(void);
// gm_mcp_vmoo_userlist_handle_add
// file mcp/gm-mcp-vmoo-userlist.c line 585
void gm_mcp_vmoo_userlist_handle_add(struct _GmMcpVmooUserlist *package, struct _MOOVar *v);
// gm_mcp_vmoo_userlist_handle_fields
// file mcp/gm-mcp-vmoo-userlist.c line 216
void gm_mcp_vmoo_userlist_handle_fields(struct _GmMcpVmooUserlist *package, struct _MOOVar *list);
// gm_mcp_vmoo_userlist_handle_icons
// file mcp/gm-mcp-vmoo-userlist.c line 271
void gm_mcp_vmoo_userlist_handle_icons(struct _GmMcpVmooUserlist *package, struct _MOOVar *list);
// gm_mcp_vmoo_userlist_handle_menu
// file mcp/gm-mcp-vmoo-userlist.c line 283
void gm_mcp_vmoo_userlist_handle_menu(struct _GmMcpVmooUserlist *package, struct _MOOVar *list);
// gm_mcp_vmoo_userlist_handle_multi
// file mcp/gm-mcp-vmoo-userlist.c line 722
signed int gm_mcp_vmoo_userlist_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values);
// gm_mcp_vmoo_userlist_handle_remove
// file mcp/gm-mcp-vmoo-userlist.c line 594
void gm_mcp_vmoo_userlist_handle_remove(struct _GmMcpVmooUserlist *package, struct _MOOVar *v);
// gm_mcp_vmoo_userlist_handle_set
// file mcp/gm-mcp-vmoo-userlist.c line 563
void gm_mcp_vmoo_userlist_handle_set(struct _GmMcpVmooUserlist *package, struct _MOOVar *v);
// gm_mcp_vmoo_userlist_handle_simple
// file mcp/gm-mcp-vmoo-userlist.c line 686
void gm_mcp_vmoo_userlist_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields);
// gm_mcp_vmoo_userlist_handle_state
// file mcp/gm-mcp-vmoo-userlist.c line 618
void gm_mcp_vmoo_userlist_handle_state(struct _GmMcpVmooUserlist *package, struct _MOOVar *v, enum _UserState state, signed int onOff);
// gm_mcp_vmoo_userlist_handle_update
// file mcp/gm-mcp-vmoo-userlist.c line 609
void gm_mcp_vmoo_userlist_handle_update(struct _GmMcpVmooUserlist *package, struct _MOOVar *v);
// gm_mcp_vmoo_userlist_handle_user_update
// file mcp/gm-mcp-vmoo-userlist.c line 525
void gm_mcp_vmoo_userlist_handle_user_update(struct _GmMcpVmooUserlist *package, struct _MOOVar *v);
// gm_mcp_vmoo_userlist_icon_path
// file mcp/gm-mcp-vmoo-userlist.c line 228
const char * gm_mcp_vmoo_userlist_icon_path(struct _GmMcpVmooUserlist *package, struct _UserInfo *ui, signed int use_state);
// gm_mcp_vmoo_userlist_iface_init
// file mcp/gm-mcp-vmoo-userlist.c line 83
static void gm_mcp_vmoo_userlist_iface_init(struct _GmIUserlistInterface *iface);
// gm_mcp_vmoo_userlist_init
// file mcp/gm-mcp-vmoo-userlist.c line 166
static void gm_mcp_vmoo_userlist_init(struct _GmMcpVmooUserlist *obj);
// gm_mcp_vmoo_userlist_menu_item_subst
// file mcp/gm-mcp-vmoo-userlist.c line 360
char * gm_mcp_vmoo_userlist_menu_item_subst(struct _GmMcpVmooUserlist *package, char *str, struct _UserInfo *info);
// gm_mcp_vmoo_userlist_new
// file mcp/gm-mcp-vmoo-userlist.c line 176
struct _GmMcpVmooUserlist * gm_mcp_vmoo_userlist_new(void);
// gm_mcp_vmoo_userlist_process_triggers
// file mcp/gm-mcp-vmoo-userlist.c line 186
void gm_mcp_vmoo_userlist_process_triggers(struct _GmMcpVmooUserlist *package, const char *username, enum _GmTriggerConditionType condition);
// gm_mcp_vmoo_userlist_remove_user
// file mcp/gm-mcp-vmoo-userlist.c line 505
void gm_mcp_vmoo_userlist_remove_user(struct _GmMcpVmooUserlist *package, signed int nr);
// gm_mcp_vmoo_userlist_remove_users
// file mcp/gm-mcp-vmoo-userlist.c line 93
void gm_mcp_vmoo_userlist_remove_users(struct _GmMcpVmooUserlist *package);
// gm_net_class_init
// file gm-net.c line 128
static void gm_net_class_init(struct _GmNetClass *klass);
// gm_net_class_intern_init
// file gm-net.c line 73
static void gm_net_class_intern_init(void *klass);
// gm_net_clean_disconnection
// file gm-net.c line 217
void gm_net_clean_disconnection(struct _GmNet *net);
// gm_net_close_thread
// file gm-net.c line 103
static void gm_net_close_thread(struct _GmNet *net);
// gm_net_connect
// file gm-net.c line 547
void gm_net_connect(struct _GmNet *net, const char *host, const char *port);
// gm_net_connect_failed
// file gm-net.c line 295
void gm_net_connect_failed(struct _GmNet *net, char *err, signed int code);
// gm_net_connect_next
// file gm-net.c line 461
void gm_net_connect_next(struct _GmNet *net);
// gm_net_connect_succeed
// file gm-net.c line 272
void gm_net_connect_succeed(struct _GmNet *net);
// gm_net_current_host
// file gm-net.c line 630
const char * gm_net_current_host(struct _GmNet *net);
// gm_net_current_port
// file gm-net.c line 635
const char * gm_net_current_port(struct _GmNet *net);
// gm_net_dirty_disconnection
// file gm-net.c line 256
void gm_net_dirty_disconnection(struct _GmNet *net, signed int err);
// gm_net_disconnect
// file gm-net.c line 574
void gm_net_disconnect(struct _GmNet *net);
// gm_net_finalize
// file gm-net.c line 116
static void gm_net_finalize(struct _GObject *object);
// gm_net_free_thread_info
// file gm-net.c line 93
static void gm_net_free_thread_info(struct _GmNet *net);
// gm_net_get_type
// file gm-net.c line 73
unsigned long int gm_net_get_type(void);
// gm_net_handle_telnet
// file gm-net.c line 324
void gm_net_handle_telnet(struct _GmNet *net, unsigned char *buf, signed int *len);
// gm_net_init
// file gm-net.c line 183
static void gm_net_init(struct _GmNet *net);
// gm_net_new
// file gm-net.c line 535
struct _GmNet * gm_net_new(void);
// gm_net_send
// file gm-net.c line 604
void gm_net_send(struct _GmNet *net, char *text);
// gm_net_send_line
// file gm-net.c line 595
void gm_net_send_line(struct _GmNet *net, char *line);
// gm_net_set_host
// file gm-net.c line 198
static void gm_net_set_host(struct _GmNet *net, const char *host);
// gm_net_set_port
// file gm-net.c line 204
static void gm_net_set_port(struct _GmNet *net, const char *port);
// gm_net_set_state
// file gm-net.c line 210
void gm_net_set_state(struct _GmNet *net, enum _GmNetState state);
// gm_net_state
// file gm-net.c line 542
enum _GmNetState gm_net_state(struct _GmNet *net);
// gm_notebook_focus_from_label
// file gm-support.c line 566
void gm_notebook_focus_from_label(struct _GtkNotebook *note, char *caption);
// gm_open_url
// file ./gm-support.h line 132
void gm_open_url(const char *url);
// gm_open_world_dialog_create_tree_view
// file dialogs/gm-open-world-dialog.c line 39
struct _GtkWidget * gm_open_world_dialog_create_tree_view(char *widget_name, char *string1, char *string2, signed int int1, signed int int2);
// gm_open_world_dialog_open_selected_worlds
// file dialogs/gm-open-world-dialog.c line 85
static void gm_open_world_dialog_open_selected_worlds();
// gm_open_world_dialog_run
// file ./dialogs/gm-open-world-dialog.h line 4
void gm_open_world_dialog_run();
// gm_open_world_dialog_widget
// file dialogs/gm-open-world-dialog.c line 31
struct _GtkWidget * gm_open_world_dialog_widget(char *name);
// gm_options_class_init
// file gm-options.c line 48
static void gm_options_class_init(struct _GmOptionsClass *klass);
// gm_options_class_intern_init
// file gm-options.c line 35
static void gm_options_class_intern_init(void *klass);
// gm_options_dup
// file gm-options.c line 125
struct _GmOptions * gm_options_dup(struct _GmOptions *source);
// gm_options_dup_option
// file gm-options.c line 111
static void gm_options_dup_option(char *key, char *value, struct _GmOptions *copy);
// gm_options_finalize
// file gm-options.c line 38
static void gm_options_finalize(struct _GObject *object);
// gm_options_get
// file ./gm-options.h line 58
const char * gm_options_get(struct _GmOptions *options, const char *key);
// gm_options_get_int
// file ./gm-options.h line 60
signed int gm_options_get_int(struct _GmOptions *options, const char *key);
// gm_options_get_type
// file ./gm-options.h line 53
unsigned long int gm_options_get_type(void);
// gm_options_init
// file gm-options.c line 68
static void gm_options_init(struct _GmOptions *options);
// gm_options_load
// file ./gm-options.h line 65
signed int gm_options_load(struct _GmOptions *options, const char *filename);
// gm_options_load_option
// file gm-options.c line 76
static void gm_options_load_option(struct _GmOptions *options, struct _xmlDoc *doc, struct _xmlNode *ptr);
// gm_options_new
// file ./gm-options.h line 54
struct _GmOptions * gm_options_new(void);
// gm_options_remove
// file ./gm-options.h line 61
void gm_options_remove(struct _GmOptions *options, const char *key);
// gm_options_save
// file ./gm-options.h line 63
void gm_options_save(struct _GmOptions *options);
// gm_options_save_as
// file gm-options.c line 210
void gm_options_save_as(struct _GmOptions *options, const char *filename);
// gm_options_save_option
// file gm-options.c line 99
static void gm_options_save_option(char *key, char *value, struct _xmlNode *root);
// gm_options_set
// file ./gm-options.h line 57
void gm_options_set(struct _GmOptions *options, const char *key, const char *value);
// gm_options_set_int
// file ./gm-options.h line 59
void gm_options_set_int(struct _GmOptions *options, const char *key, signed int value);
// gm_pixbuf_add_directory
// file gm-pixbuf.c line 72
void gm_pixbuf_add_directory(const char *directory);
// gm_pixbuf_create
// file gm-pixbuf.c line 191
struct _GdkPixbuf * gm_pixbuf_create(const char *filename, signed int width, signed int height);
// gm_pixbuf_create_save_close
// file gm-pixbuf.c line 21
static struct _GdkPixbuf * gm_pixbuf_create_save_close();
// gm_pixbuf_create_stock24
// file gm-pixbuf.c line 78
static struct _GtkIconSource * gm_pixbuf_create_stock24(struct _GdkPixbuf *pixbuf);
// gm_pixbuf_find
// file gm-pixbuf.c line 164
char * gm_pixbuf_find(const char *filename);
// gm_pixbuf_fini
// file gm-pixbuf.h line 18
void gm_pixbuf_fini();
// gm_pixbuf_get
// file ./gm-pixbuf.h line 22
struct _GdkPixbuf * gm_pixbuf_get(const char *filename);
// gm_pixbuf_get_at_size
// file ./gm-pixbuf.h line 23
struct _GdkPixbuf * gm_pixbuf_get_at_size(const char *filename, signed int width, signed int height);
// gm_pixbuf_init
// file gm-pixbuf.h line 17
void gm_pixbuf_init();
// gm_pixbuf_populate_factory
// file gm-pixbuf.c line 104
void gm_pixbuf_populate_factory();
// gm_pixbuf_set_alpha
// file gm-pixbuf.c line 267
void gm_pixbuf_set_alpha(struct _GdkPixbuf **pixs, unsigned char alpha);
// gm_playerdb_player_info_get_prop
// file mcp/gm-mcp-icecrew-playerdb.c line 142
const char * gm_playerdb_player_info_get_prop(struct _GmPlayerdbPlayerInfo *ppi, const char *key);
// gm_preferences_dialog_init_combo_box_scheme
// file dialogs/gm-preferences-dialog.c line 140
void gm_preferences_dialog_init_combo_box_scheme();
// gm_preferences_dialog_init_logging
// file dialogs/gm-preferences-dialog.c line 210
void gm_preferences_dialog_init_logging();
// gm_preferences_dialog_init_sort_buttons
// file dialogs/gm-preferences-dialog.c line 255
static void gm_preferences_dialog_init_sort_buttons();
// gm_preferences_dialog_run
// file ./dialogs/gm-preferences-dialog.h line 4
void gm_preferences_dialog_run();
// gm_preferences_dialog_run_dialog
// file dialogs/gm-preferences-dialog.c line 413
void gm_preferences_dialog_run_dialog();
// gm_preferences_dialog_update_color_buttons
// file dialogs/gm-preferences-dialog.c line 177
void gm_preferences_dialog_update_color_buttons(signed int signals);
// gm_preferences_dialog_widget
// file dialogs/gm-preferences-dialog.c line 135
struct _GtkWidget * gm_preferences_dialog_widget(const char *name);
// gm_question_dialog
// file ./gm-support.h line 125
signed int gm_question_dialog(char *message, struct _GtkWindow *parent);
// gm_read_file
// file ./gm-support.h line 143
char * gm_read_file(const char *fname);
// gm_register_schemed
// file ./gm-support.h line 165
void gm_register_schemed(struct _GtkWidget *widget, struct _GmColorTable *table, enum _GmSchemedFlags flags);
// gm_scroll_end
// file gm-support.c line 410
void gm_scroll_end(struct _GtkTextView *view, signed int needs);
// gm_searchable_can_find
// file widgets/gm-searchable.h line 44
signed int gm_searchable_can_find(struct _GmSearchable *self);
// gm_searchable_can_replace
// file widgets/gm-searchable.h line 50
signed int gm_searchable_can_replace(struct _GmSearchable *self);
// gm_searchable_find_first
// file widgets/gm-searchable.h line 45
signed int gm_searchable_find_first(struct _GmSearchable *self, const char *str, enum _GmSearchableSearchFlags flags);
// gm_searchable_find_next
// file widgets/gm-searchable.h line 47
signed int gm_searchable_find_next(struct _GmSearchable *self, const char *str, enum _GmSearchableSearchFlags flags);
// gm_searchable_get_text_view
// file widgets/gm-searchable.c line 663
struct _GtkTextView * gm_searchable_get_text_view(struct _GmSearchable *self);
// gm_searchable_get_type
// file widgets/gm-searchable.h line 41
unsigned long int gm_searchable_get_type();
// gm_searchable_interface_get_text_view
// file widgets/gm-searchable.c line 651
struct _GtkTextView * gm_searchable_interface_get_text_view(struct _GmSearchable *self, struct _GmSearchableInterface *iface);
// gm_searchable_replace
// file widgets/gm-searchable.h line 51
signed int gm_searchable_replace(struct _GmSearchable *self, const char *replace);
// gm_searchable_replace_all
// file widgets/gm-searchable.h line 52
signed int gm_searchable_replace_all(struct _GmSearchable *self, const char *str, const char *replace, enum _GmSearchableSearchFlags flags);
// gm_searchable_text_view_find_first
// file widgets/gm-searchable.c line 580
signed int gm_searchable_text_view_find_first(struct _GtkTextView *text_view, const char *str, enum _GmSearchableSearchFlags flags);
// gm_searchable_text_view_find_next
// file widgets/gm-searchable.c line 519
signed int gm_searchable_text_view_find_next(struct _GtkTextView *text_view, const char *str, enum _GmSearchableSearchFlags flags);
// gm_searchable_text_view_replace
// file widgets/gm-searchable.c line 611
signed int gm_searchable_text_view_replace(struct _GtkTextView *text_view, const char *replace);
// gm_searchable_text_view_replace_all
// file widgets/gm-searchable.c line 634
signed int gm_searchable_text_view_replace_all(struct _GtkTextView *text_view, const char *str, const char *replace, enum _GmSearchableSearchFlags flags);
// gm_searchable_text_view_search_case_insensitive
// file widgets/gm-searchable.c line 466
signed int gm_searchable_text_view_search_case_insensitive(struct _GtkTextView *text_view, const char *str, enum _GmSearchableSearchFlags flags, struct _GtkTextIter *start, struct _GtkTextIter *end);
// gm_source_style_scheme_IFace_init
// file widgets/gm-source-style-scheme.c line 92
static void gm_source_style_scheme_IFace_init(struct _GtkSourceStyleSchemeClass *iface);
// gm_source_style_scheme_class_init
// file widgets/gm-source-style-scheme.c line 84
static void gm_source_style_scheme_class_init(struct _GmSourceStyleSchemeClass *klass);
// gm_source_style_scheme_finalize
// file widgets/gm-source-style-scheme.c line 197
static void gm_source_style_scheme_finalize(struct _GObject *object);
// gm_source_style_scheme_get_default
// file widgets/gm-source-style-scheme.c line 254
struct _GtkSourceStyleScheme * gm_source_style_scheme_get_default(void);
// gm_source_style_scheme_get_type
// file widgets/gm-source-style-scheme.c line 44
static unsigned long int gm_source_style_scheme_get_type(void);
// gm_source_style_scheme_init
// file widgets/gm-source-style-scheme.c line 177
static void gm_source_style_scheme_init(struct _GmSourceStyleScheme *scheme);
// gm_source_style_scheme_init_mapping
// file widgets/gm-source-style-scheme.c line 164
static void gm_source_style_scheme_init_mapping(struct _GmSourceStyleScheme *scheme);
// gm_source_style_weak_destroy
// file widgets/gm-source-style-scheme.c line 247
void gm_source_style_weak_destroy(void *data, struct _GObject *object);
// gm_string_cat
// file gm-string.c line 44
char * gm_string_cat(char *str, char *add);
// gm_string_catn
// file gm-string.c line 20
char * gm_string_catn(char *str, char *add, unsigned int n);
// gm_string_escape
// file gm-string.c line 152
char * gm_string_escape(const char *line);
// gm_string_remove_char
// file ./gm-string.h line 12
char * gm_string_remove_char(char *str, char rem);
// gm_string_skip_nonspace
// file ./gm-string.h line 15
void gm_string_skip_nonspace(const char **ptr);
// gm_string_skip_space
// file ./gm-string.h line 14
void gm_string_skip_space(const char **ptr);
// gm_string_skip_till
// file ./gm-string.h line 16
void gm_string_skip_till(const char **ptr, const char *find);
// gm_string_split
// file gm-string.c line 199
struct _GList * gm_string_split(const char *text);
// gm_string_split_add_line
// file gm-string.c line 186
struct _GList * gm_string_split_add_line(char *line, struct _GList *lines, struct _GList **lastptr);
// gm_string_to_int
// file gm-string.h line 8
signed int gm_string_to_int(const char *str, signed int *result);
// gm_string_trim
// file gm-string.h line 11
char * gm_string_trim(const char *str);
// gm_text_scroller_class_init
// file widgets/gm-text-scroller.c line 71
static void gm_text_scroller_class_init(struct _GmTextScrollerClass *klass);
// gm_text_scroller_class_intern_init
// file widgets/gm-text-scroller.c line 42
static void gm_text_scroller_class_intern_init(void *klass);
// gm_text_scroller_finalize
// file widgets/gm-text-scroller.c line 45
static void gm_text_scroller_finalize(struct _GObject *object);
// gm_text_scroller_get_type
// file widgets/gm-text-scroller.c line 42
unsigned long int gm_text_scroller_get_type(void);
// gm_text_scroller_init
// file widgets/gm-text-scroller.c line 90
static void gm_text_scroller_init(struct _GmTextScroller *obj);
// gm_text_scroller_is_end_scrolled
// file widgets/gm-text-scroller.c line 181
signed int gm_text_scroller_is_end_scrolled(struct _GmTextScroller *scroller);
// gm_text_scroller_is_end_scrolled_margin
// file widgets/gm-text-scroller.c line 170
signed int gm_text_scroller_is_end_scrolled_margin(struct _GmTextScroller *scroller, signed int margin);
// gm_text_scroller_new
// file widgets/gm-text-scroller.h line 47
struct _GmTextScroller * gm_text_scroller_new(struct _GtkTextView *text_view);
// gm_text_scroller_prepare
// file widgets/gm-text-scroller.c line 186
void gm_text_scroller_prepare(struct _GmTextScroller *scroller);
// gm_text_scroller_scroll_begin
// file widgets/gm-text-scroller.h line 49
void gm_text_scroller_scroll_begin(struct _GmTextScroller *scroller);
// gm_text_scroller_scroll_end
// file widgets/gm-text-scroller.h line 48
void gm_text_scroller_scroll_end(struct _GmTextScroller *scroller);
// gm_text_scroller_scroll_end_idle
// file widgets/gm-text-scroller.c line 160
signed int gm_text_scroller_scroll_end_idle(struct _GmTextScroller *scroller);
// gm_text_scroller_scroll_page
// file widgets/gm-text-scroller.h line 50
void gm_text_scroller_scroll_page(struct _GmTextScroller *scroller, signed int direction);
// gm_text_scroller_update_character_height
// file widgets/gm-text-scroller.c line 199
void gm_text_scroller_update_character_height(struct _GmTextScroller *scroller);
// gm_text_scroller_update_text_buffer
// file widgets/gm-text-scroller.c line 98
void gm_text_scroller_update_text_buffer(struct _GmTextScroller *scroller);
// gm_to_utf8_with_fallback
// file gm-support.h line 155
char * gm_to_utf8_with_fallback(const char *text, signed long int len, const char *from, const char *fallback);
// gm_tray_activate
// file widgets/gm-tray.h line 64
void gm_tray_activate(struct _GmTray *tray);
// gm_tray_active
// file widgets/gm-tray.c line 144
void gm_tray_active(struct _GmTray *tray);
// gm_tray_class_init
// file widgets/gm-tray.c line 46
static void gm_tray_class_init(struct _GmTrayClass *klass);
// gm_tray_class_intern_init
// file widgets/gm-tray.c line 27
static void gm_tray_class_intern_init(void *klass);
// gm_tray_finalize
// file widgets/gm-tray.c line 30
static void gm_tray_finalize(struct _GObject *object);
// gm_tray_get_state
// file widgets/gm-tray.h line 71
enum _GmTrayState gm_tray_get_state(struct _GmTray *tray);
// gm_tray_get_type
// file widgets/gm-tray.c line 27
unsigned long int gm_tray_get_type(void);
// gm_tray_has_manager
// file widgets/gm-tray.h line 73
signed int gm_tray_has_manager();
// gm_tray_init
// file widgets/gm-tray.c line 54
static void gm_tray_init(struct _GmTray *tray);
// gm_tray_message
// file widgets/gm-tray.c line 170
void gm_tray_message(struct _GmTray *tray, const char *message);
// gm_tray_new
// file widgets/gm-tray.h line 61
struct _GmTray * gm_tray_new(const char *title);
// gm_tray_normal
// file widgets/gm-tray.h line 65
void gm_tray_normal(struct _GmTray *tray);
// gm_tray_notify
// file widgets/gm-tray.h line 67
void gm_tray_notify(struct _GmTray *tray, const char *message);
// gm_tray_restore_from_activity
// file widgets/gm-tray.c line 105
static signed int gm_tray_restore_from_activity(void *user_data);
// gm_tray_set_icon
// file widgets/gm-tray.h line 62
void gm_tray_set_icon(struct _GmTray *tray, enum _GmTrayState state, struct _GdkPixbuf *icon);
// gm_tray_set_state
// file widgets/gm-tray.c line 88
static void gm_tray_set_state(struct _GmTray *tray, enum _GmTrayState state);
// gm_tray_set_tip
// file widgets/gm-tray.h line 70
void gm_tray_set_tip(struct _GmTray *tray, const char *message);
// gm_tray_update_icon
// file widgets/gm-tray.c line 82
static void gm_tray_update_icon(struct _GmTray *tray);
// gm_trigger_add_action
// file gm-triggers.c line 186
void gm_trigger_add_action(struct _GmTrigger *trigger, struct _GmTriggerData *action);
// gm_trigger_add_condition
// file gm-triggers.c line 181
void gm_trigger_add_condition(struct _GmTrigger *trigger, struct _GmTriggerData *condition);
// gm_trigger_data_free
// file gm-triggers.c line 175
void gm_trigger_data_free(struct _GmTriggerData *tdata);
// gm_trigger_data_new
// file ./gm-triggers.h line 125
struct _GmTriggerData * gm_trigger_data_new(signed int type, char *data);
// gm_trigger_dup
// file ./gm-triggers.h line 112
struct _GmTrigger * gm_trigger_dup(struct _GmTrigger *source);
// gm_trigger_free
// file ./gm-triggers.h line 111
void gm_trigger_free(struct _GmTrigger *trigger);
// gm_trigger_free_list
// file ./gm-triggers.h line 114
void gm_trigger_free_list(struct _GList *list);
// gm_trigger_list_dup
// file gm-triggers.c line 99
struct _GList * gm_trigger_list_dup(struct _GList *list);
// gm_trigger_match
// file gm-triggers.c line 244
signed int gm_trigger_match(struct _GmTrigger *trigger, char *text, struct anonymous$17 *matches, signed int nmatch);
// gm_trigger_match_user
// file ./gm-triggers.h line 120
signed int gm_trigger_match_user(struct _GmTrigger *trigger, const char *username, enum _GmTriggerConditionType condition, struct anonymous$17 *matches, signed int nmatch);
// gm_trigger_name_from_type
// file gm-triggers.c line 380
const char * gm_trigger_name_from_type(signed int type, const struct _trigger_trans *trans_table);
// gm_trigger_new
// file ./gm-triggers.h line 110
struct _GmTrigger * gm_trigger_new();
// gm_trigger_rules_xml
// file gm-triggers.c line 519
void gm_trigger_rules_xml(struct _GmTrigger *t, struct _xmlNode *trig);
// gm_trigger_set_actions
// file ./gm-triggers.h line 118
void gm_trigger_set_actions(struct _GmTrigger *trigger, struct _GList *actions);
// gm_trigger_set_conditions
// file ./gm-triggers.h line 117
void gm_trigger_set_conditions(struct _GmTrigger *trigger, struct _GList *conditions);
// gm_trigger_set_name
// file ./gm-triggers.h line 113
void gm_trigger_set_name(struct _GmTrigger *trigger, const char *name);
// gm_trigger_type_from_name
// file gm-triggers.c line 366
signed int gm_trigger_type_from_name(const char *name, const struct _trigger_trans *trans_table);
// gm_triggers_add
// file ./gm-triggers.h line 107
void gm_triggers_add(struct _GmTriggers *trg, struct _GmTrigger *t);
// gm_triggers_class_init
// file gm-triggers.c line 78
static void gm_triggers_class_init(struct _GmTriggersClass *klass);
// gm_triggers_class_intern_init
// file gm-triggers.c line 60
static void gm_triggers_class_intern_init(void *klass);
// gm_triggers_clear
// file ./gm-triggers.h line 108
void gm_triggers_clear(struct _GmTriggers *trg);
// gm_triggers_dialog_collect_rules
// file dialogs/gm-triggers-dialog.c line 259
struct _GList * gm_triggers_dialog_collect_rules(struct _GmTriggersDialog *triggers, struct _GtkWidget *vbox);
// gm_triggers_dialog_combo_get_selected_data
// file dialogs/gm-triggers-dialog.c line 246
struct _ModelData * gm_triggers_dialog_combo_get_selected_data(struct _GmTriggersDialog *triggers, struct _GtkComboBox *combo);
// gm_triggers_dialog_create_item
// file dialogs/gm-triggers-dialog.c line 545
struct _GtkWidget * gm_triggers_dialog_create_item(struct _GmTriggersDialog *triggers, struct _GtkTreeModel *model, struct _GmTriggerData *t);
// gm_triggers_dialog_create_models
// file dialogs/gm-triggers-dialog.c line 185
void gm_triggers_dialog_create_models(struct _GmTriggersDialog *triggers, const struct _ModelData *conditionData, const struct _ModelData *actionData);
// gm_triggers_dialog_custom_arg_browse
// file dialogs/gm-triggers-dialog.c line 849
void * gm_triggers_dialog_custom_arg_browse(struct _GmTriggersDialog *triggers, enum _CustomArgType type, void *data, void *user_data);
// gm_triggers_dialog_custom_arg_highlight
// file dialogs/gm-triggers-dialog.c line 773
void * gm_triggers_dialog_custom_arg_highlight(struct _GmTriggersDialog *triggers, enum _CustomArgType type, void *data, void *user_data);
// gm_triggers_dialog_fill_trigger
// file dialogs/gm-triggers-dialog.c line 322
signed int gm_triggers_dialog_fill_trigger(struct _GmTriggersDialog *triggers);
// gm_triggers_dialog_idle_remove_item
// file dialogs/gm-triggers-dialog.c line 980
signed int gm_triggers_dialog_idle_remove_item(struct _GtkWidget *parent);
// gm_triggers_dialog_initialize_event_types
// file dialogs/gm-triggers-dialog.c line 360
void gm_triggers_dialog_initialize_event_types(struct _GmTriggersDialog *triggers);
// gm_triggers_dialog_new_action
// file dialogs/gm-triggers-dialog.c line 627
void gm_triggers_dialog_new_action(struct _GmTriggersDialog *triggers);
// gm_triggers_dialog_new_condition
// file dialogs/gm-triggers-dialog.c line 579
void gm_triggers_dialog_new_condition(struct _GmTriggersDialog *triggers);
// gm_triggers_dialog_populate_actions
// file dialogs/gm-triggers-dialog.c line 648
void gm_triggers_dialog_populate_actions(struct _GmTriggersDialog *triggers);
// gm_triggers_dialog_populate_conditions
// file dialogs/gm-triggers-dialog.c line 601
void gm_triggers_dialog_populate_conditions(struct _GmTriggersDialog *triggers);
// gm_triggers_dialog_run
// file dialogs/gm-triggers-dialog.h line 7
struct _GmTrigger * gm_triggers_dialog_run(struct _GmWorld *world, struct _GmTrigger *trigger);
// gm_triggers_dialog_run_dialog
// file dialogs/gm-triggers-dialog.c line 404
struct _GmTrigger * gm_triggers_dialog_run_dialog(struct _GmTriggersDialog *triggers);
// gm_triggers_dialog_run_new
// file dialogs/gm-triggers-dialog.h line 8
struct _GmTrigger * gm_triggers_dialog_run_new(struct _GmWorld *world, struct _GmTrigger *trigger);
// gm_triggers_dialog_run_priv
// file dialogs/gm-triggers-dialog.c line 450
struct _GmTrigger * gm_triggers_dialog_run_priv(struct _GmWorld *world, struct _GmTrigger *trigger, signed int is_new);
// gm_triggers_dialog_select_combo_by_type
// file dialogs/gm-triggers-dialog.c line 526
void gm_triggers_dialog_select_combo_by_type(struct _GmTriggersDialog *triggers, struct _GtkComboBox *combo, signed int type);
// gm_triggers_dup
// file gm-triggers.c line 589
struct _GmTriggers * gm_triggers_dup(struct _GmTriggers *source);
// gm_triggers_finalize
// file gm-triggers.c line 63
static void gm_triggers_finalize(struct _GObject *object);
// gm_triggers_get_type
// file gm-triggers.c line 60
unsigned long int gm_triggers_get_type(void);
// gm_triggers_init
// file gm-triggers.c line 87
static void gm_triggers_init(struct _GmTriggers *trg);
// gm_triggers_list
// file ./gm-triggers.h line 106
const struct _GList * gm_triggers_list(struct _GmTriggers *trg);
// gm_triggers_new
// file gm-triggers.c line 445
struct _GmTriggers * gm_triggers_new(void);
// gm_triggers_new_from_file
// file gm-triggers.c line 469
struct _GmTriggers * gm_triggers_new_from_file(char *filename);
// gm_triggers_parse_trigger
// file gm-triggers.c line 393
void gm_triggers_parse_trigger(struct _GmTriggers *trg, struct _xmlDoc *doc, struct _xmlNode *node);
// gm_triggers_save
// file ./gm-triggers.h line 102
void gm_triggers_save(struct _GmTriggers *trg);
// gm_triggers_save_as
// file gm-triggers.c line 582
void gm_triggers_save_as(struct _GmTriggers *trg, const char *path);
// gm_triggers_set_path
// file gm-triggers.c line 513
void gm_triggers_set_path(struct _GmTriggers *trg, char *path);
// gm_url_regex_match
// file ./gm-support.h line 131
signed int gm_url_regex_match(const char *msg, signed int len, struct _GArray *start, struct _GArray *end);
// gm_userlist_view_strcmp_safe
// file mcp/gm-mcp-userlist-view.c line 152
signed int gm_userlist_view_strcmp_safe(const char *str1, const char *str2);
// gm_warning_dialog
// file gm-support.c line 145
signed int gm_warning_dialog(char *message, struct _GtkWindow *parent);
// gm_widget_destroy_data
// file ./gm-support.h line 146
void gm_widget_destroy_data(struct _GtkWidget *caller, struct _GtkWidget *destroyer);
// gm_world_active
// file ./gm-world.h line 110
signed int gm_world_active(struct _GmWorld *world);
// gm_world_activity
// file ./gm-world.h line 109
signed int gm_world_activity(struct _GmWorld *world);
// gm_world_add_editor
// file ./gm-world.h line 131
void gm_world_add_editor(struct _GmWorld *world, struct _GmEditor *editor);
// gm_world_apply_trigger
// file ./gm-world.h line 140
void gm_world_apply_trigger(struct _GmWorld *world, struct _GmTrigger *trigger, const char *text, struct anonymous$17 *matches, signed int nummatches);
// gm_world_auto_login
// file gm-world.c line 1277
void gm_world_auto_login(struct _GmWorld *world);
// gm_world_check_dirs
// file gm-world.c line 502
void gm_world_check_dirs(struct _GmWorld *world);
// gm_world_class_init
// file gm-world.c line 182
static void gm_world_class_init(struct _GmWorldClass *klass);
// gm_world_class_intern_init
// file gm-world.c line 94
static void gm_world_class_intern_init(void *klass);
// gm_world_connect
// file ./gm-world.h line 127
void gm_world_connect(struct _GmWorld *world);
// gm_world_connect_to
// file gm-world.c line 667
void gm_world_connect_to(struct _GmWorld *world, const char *host, const char *port);
// gm_world_connected
// file ./gm-world.h line 124
signed int gm_world_connected(struct _GmWorld *world);
// gm_world_create_default_settings
// file gm-world.c line 331
static void gm_world_create_default_settings(struct _GmWorld *world);
// gm_world_current_host
// file ./gm-world.h line 113
const char * gm_world_current_host(struct _GmWorld *world);
// gm_world_current_port
// file ./gm-world.h line 114
const char * gm_world_current_port(struct _GmWorld *world);
// gm_world_disconnect
// file ./gm-world.h line 129
void gm_world_disconnect(struct _GmWorld *world);
// gm_world_disconnected
// file ./gm-world.h line 125
signed int gm_world_disconnected(struct _GmWorld *world);
// gm_world_dup
// file ./gm-world.h line 101
struct _GmWorld * gm_world_dup(struct _GmWorld *source);
// gm_world_editors
// file ./gm-world.h line 133
const struct _GSList * gm_world_editors(struct _GmWorld *world);
// gm_world_finalize
// file gm-world.c line 97
static void gm_world_finalize(struct _GObject *object);
// gm_world_get_mcp_session
// file ./gm-world.h line 120
struct _GmMcpSession * gm_world_get_mcp_session(struct _GmWorld *world);
// gm_world_get_property
// file gm-world.c line 135
static void gm_world_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec);
// gm_world_get_type
// file ./gm-world.h line 98
unsigned long int gm_world_get_type(void);
// gm_world_history
// file ./gm-world.h line 108
struct _GList ** gm_world_history(struct _GmWorld *world);
// gm_world_info_dialog_event_box_cursor
// file dialogs/gm-world-info-dialog.c line 31
void gm_world_info_dialog_event_box_cursor(struct _GtkWidget *widget);
// gm_world_info_dialog_new
// file dialogs/gm-world-info-dialog.c line 40
struct _GtkDialog * gm_world_info_dialog_new(const struct _GmWorldInfo *world_info);
// gm_world_info_dialog_set_label
// file dialogs/gm-world-info-dialog.c line 22
void gm_world_info_dialog_set_label(struct _GtkLabel *label, char *text);
// gm_world_init
// file gm-world.c line 351
static void gm_world_init(struct _GmWorld *world);
// gm_world_input_view_class_init
// file widgets/gm-world-input-view.c line 243
static void gm_world_input_view_class_init(struct _GmWorldInputViewClass *klass);
// gm_world_input_view_class_intern_init
// file widgets/gm-world-input-view.c line 38
static void gm_world_input_view_class_intern_init(void *klass);
// gm_world_input_view_color_table
// file widgets/gm-world-input-view.c line 341
struct _GmColorTable * gm_world_input_view_color_table(struct _GmWorldInputView *view);
// gm_world_input_view_finalize
// file widgets/gm-world-input-view.c line 42
static void gm_world_input_view_finalize(struct _GObject *object);
// gm_world_input_view_get_type
// file widgets/gm-world-input-view.h line 47
unsigned long int gm_world_input_view_get_type(void);
// gm_world_input_view_history
// file widgets/gm-world-input-view.c line 317
struct _GList ** gm_world_input_view_history(struct _GmWorldInputView *view);
// gm_world_input_view_init
// file widgets/gm-world-input-view.c line 267
static void gm_world_input_view_init(struct _GmWorldInputView *view);
// gm_world_input_view_key_press_event
// file widgets/gm-world-input-view.c line 89
signed int gm_world_input_view_key_press_event(struct _GtkWidget *widget, struct _GdkEventKey *event);
// gm_world_input_view_new
// file widgets/gm-world-input-view.c line 288
struct _GtkWidget * gm_world_input_view_new();
// gm_world_input_view_new_with_color_table
// file widgets/gm-world-input-view.h line 49
struct _GtkWidget * gm_world_input_view_new_with_color_table(struct _GmColorTable *color_table);
// gm_world_input_view_reset_prefix
// file widgets/gm-world-input-view.c line 82
static void gm_world_input_view_reset_prefix(struct _GmWorldInputView *view);
// gm_world_input_view_set_color_table
// file widgets/gm-world-input-view.c line 322
void gm_world_input_view_set_color_table(struct _GmWorldInputView *view, struct _GmColorTable *color_table);
// gm_world_input_view_set_history
// file widgets/gm-world-input-view.h line 53
void gm_world_input_view_set_history(struct _GmWorldInputView *view, struct _GList **history);
// gm_world_input_view_set_text
// file widgets/gm-world-input-view.c line 66
void gm_world_input_view_set_text(struct _GmWorldInputView *view, char *text, signed int len);
// gm_world_input_view_str_new_value
// file widgets/gm-world-input-view.c line 55
static char * gm_world_input_view_str_new_value(char *old, char *new);
// gm_world_load
// file ./gm-world.h line 102
void gm_world_load(struct _GmWorld *world);
// gm_world_load_input_history
// file gm-world.c line 379
static void gm_world_load_input_history(struct _GmWorld *world);
// gm_world_load_triggers
// file gm-world.c line 459
static void gm_world_load_triggers(struct _GmWorld *world);
// gm_world_loaded
// file ./gm-world.h line 122
signed int gm_world_loaded(struct _GmWorld *world);
// gm_world_log
// file gm-world.c line 733
void gm_world_log(struct _GmWorld *world, enum _GmLogType type, const char *text);
// gm_world_log_allowed
// file gm-world.c line 696
signed int gm_world_log_allowed(struct _GmWorld *world, enum _GmLogType type);
// gm_world_logs_dialog_build_tree_view
// file dialogs/gm-world-logs-dialog.c line 20
void gm_world_logs_dialog_build_tree_view(struct _GtkTreeView *tree_view);
// gm_world_logs_dialog_fill
// file dialogs/gm-world-logs-dialog.c line 45
signed int gm_world_logs_dialog_fill(struct _GmWorld *world, struct _GtkTreeView *view, struct _GtkTreeModel *model, struct _GError **err);
// gm_world_logs_dialog_new
// file ./dialogs/gm-world-logs-dialog.h line 7
struct _GtkDialog * gm_world_logs_dialog_new(struct _GmWorld *world, struct _GtkTreeView **view);
// gm_world_name
// file ./gm-world.h line 105
const char * gm_world_name(struct _GmWorld *world);
// gm_world_name_changed
// file gm-world.c line 1232
void gm_world_name_changed(struct _GmWorld *world);
// gm_world_new
// file ./gm-world.h line 99
struct _GmWorld * gm_world_new(char *path);
// gm_world_options
// file ./gm-world.h line 106
struct _GmOptions * gm_world_options(struct _GmWorld *world);
// gm_world_parse_legacy_editing_start
// file gm-world.c line 830
void gm_world_parse_legacy_editing_start(struct _GmWorld *world, char *line);
// gm_world_paste_dialog_do_paste
// file dialogs/gm-world-paste-dialog.c line 258
static void gm_world_paste_dialog_do_paste();
// gm_world_paste_dialog_fill_to
// file dialogs/gm-world-paste-dialog.c line 70
static void gm_world_paste_dialog_fill_to();
// gm_world_paste_dialog_init_command
// file dialogs/gm-world-paste-dialog.c line 45
static void gm_world_paste_dialog_init_command();
// gm_world_paste_dialog_init_end_with
// file dialogs/gm-world-paste-dialog.c line 147
static void gm_world_paste_dialog_init_end_with();
// gm_world_paste_dialog_init_text
// file dialogs/gm-world-paste-dialog.c line 133
static void gm_world_paste_dialog_init_text();
// gm_world_paste_dialog_init_to
// file dialogs/gm-world-paste-dialog.c line 118
static void gm_world_paste_dialog_init_to();
// gm_world_paste_dialog_remove_model
// file dialogs/gm-world-paste-dialog.c line 58
static void gm_world_paste_dialog_remove_model(void *data, struct _GObject *model, signed int is_last_ref);
// gm_world_paste_dialog_run
// file ./dialogs/gm-world-paste-dialog.h line 5
void gm_world_paste_dialog_run(struct _GmAppView *view);
// gm_world_paste_dialog_send_text
// file dialogs/gm-world-paste-dialog.c line 206
static void gm_world_paste_dialog_send_text(struct _GmWorld *world, const char *end_with);
// gm_world_paste_dialog_widget
// file dialogs/gm-world-paste-dialog.c line 31
static struct _GtkWidget * gm_world_paste_dialog_widget(char *name);
// gm_world_paste_get_to
// file dialogs/gm-world-paste-dialog.c line 238
static char * gm_world_paste_get_to();
// gm_world_path
// file ./gm-world.h line 107
const char * gm_world_path(struct _GmWorld *world);
// gm_world_prepare_disconnect
// file ./gm-world.h line 130
void gm_world_prepare_disconnect(struct _GmWorld *world);
// gm_world_process_input
// file ./gm-world.h line 138
void gm_world_process_input(struct _GmWorld *world, const char *text);
// gm_world_process_line
// file gm-world.c line 995
void gm_world_process_line(struct _GmWorld *world, char *line, signed int len);
// gm_world_process_triggers
// file gm-world.c line 976
void gm_world_process_triggers(struct _GmWorld *world, char *text);
// gm_world_properties_dialog_add_trigger
// file dialogs/gm-world-properties-dialog.c line 202
void gm_world_properties_dialog_add_trigger(struct _GmWorldPropertiesDialog *properties, struct _GmTrigger *t);
// gm_world_properties_dialog_check_values
// file dialogs/gm-world-properties-dialog.c line 538
signed int gm_world_properties_dialog_check_values(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_find
// file dialogs/gm-world-properties-dialog.c line 262
struct _GmWorldPropertiesDialog * gm_world_properties_dialog_find(struct _GmWorld *world);
// gm_world_properties_dialog_free_triggers
// file dialogs/gm-world-properties-dialog.c line 483
void gm_world_properties_dialog_free_triggers(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_get_charset
// file dialogs/gm-world-properties-dialog.c line 463
char * gm_world_properties_dialog_get_charset(char *charset);
// gm_world_properties_dialog_init_logging
// file dialogs/gm-world-properties-dialog.c line 290
void gm_world_properties_dialog_init_logging(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_initialize
// file dialogs/gm-world-properties-dialog.c line 317
void gm_world_properties_dialog_initialize(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_populate_charsets
// file dialogs/gm-world-properties-dialog.c line 133
void gm_world_properties_dialog_populate_charsets(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_populate_tree_view_triggers
// file dialogs/gm-world-properties-dialog.c line 221
void gm_world_properties_dialog_populate_tree_view_triggers(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_remove_trigger
// file dialogs/gm-world-properties-dialog.c line 158
void gm_world_properties_dialog_remove_trigger(struct _GmWorldPropertiesDialog *properties, struct _GtkTreeIter *iter);
// gm_world_properties_dialog_run
// file ./dialogs/gm-world-properties-dialog.h line 12
void gm_world_properties_dialog_run(struct _GmWorld *world);
// gm_world_properties_dialog_run_dialog
// file dialogs/gm-world-properties-dialog.c line 652
void gm_world_properties_dialog_run_dialog(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_run_new
// file ./dialogs/gm-world-properties-dialog.h line 13
void gm_world_properties_dialog_run_new(struct _GmWorld *world);
// gm_world_properties_dialog_run_priv
// file dialogs/gm-world-properties-dialog.c line 376
void gm_world_properties_dialog_run_priv(struct _GmWorld *world, signed int is_new);
// gm_world_properties_dialog_run_triggers
// file ./dialogs/gm-world-properties-dialog.h line 14
void gm_world_properties_dialog_run_triggers(struct _GmWorld *world);
// gm_world_properties_dialog_selected_trigger
// file dialogs/gm-world-properties-dialog.c line 711
struct _GmTrigger * gm_world_properties_dialog_selected_trigger(struct _GmWorldPropertiesDialog *properties, struct _GtkTreeIter *iter);
// gm_world_properties_dialog_set_logging
// file dialogs/gm-world-properties-dialog.c line 516
void gm_world_properties_dialog_set_logging(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_set_triggers
// file dialogs/gm-world-properties-dialog.c line 498
void gm_world_properties_dialog_set_triggers(struct _GmWorldPropertiesDialog *properties);
// gm_world_properties_dialog_update_trigger
// file dialogs/gm-world-properties-dialog.c line 174
void gm_world_properties_dialog_update_trigger(struct _GmWorldPropertiesDialog *properties, struct _GtkTreeIter *iter, struct _GmTrigger *t);
// gm_world_properties_dialog_widget
// file dialogs/gm-world-properties-dialog.c line 127
struct _GtkWidget * gm_world_properties_dialog_widget(struct _GmWorldPropertiesDialog *properties, char *name);
// gm_world_reconnect
// file gm-world.c line 483
static signed int gm_world_reconnect(struct _GmWorld *world);
// gm_world_remove_editor
// file gm-world.c line 1146
void gm_world_remove_editor(struct _GmWorld *world, struct _GmEditor *editor);
// gm_world_save_input_history
// file gm-world.c line 416
static void gm_world_save_input_history(struct _GmWorld *world);
// gm_world_sendln
// file ./gm-world.h line 135
void gm_world_sendln(struct _GmWorld *world, const char *text);
// gm_world_sendln_log
// file ./gm-world.h line 134
void gm_world_sendln_log(struct _GmWorld *world, const char *text, enum _GmLogType logtype);
// gm_world_set_active
// file ./gm-world.h line 118
void gm_world_set_active(struct _GmWorld *world, signed int active);
// gm_world_set_activity
// file gm-world.c line 1220
void gm_world_set_activity(struct _GmWorld *world, signed int activity);
// gm_world_set_property
// file gm-world.c line 168
static void gm_world_set_property(struct _GObject *object, unsigned int prop_id, const struct _GValue *value, struct _GParamSpec *pspec);
// gm_world_state
// file ./gm-world.h line 123
enum _GmNetState gm_world_state(struct _GmWorld *world);
// gm_world_status
// file ./gm-world.h line 137
void gm_world_status(struct _GmWorld *world, const char *text);
// gm_world_tab_class_init
// file widgets/gm-world-tab.c line 63
static void gm_world_tab_class_init(struct _GmWorldTabClass *klass);
// gm_world_tab_class_intern_init
// file widgets/gm-world-tab.c line 35
static void gm_world_tab_class_intern_init(void *klass);
// gm_world_tab_create_interface
// file widgets/gm-world-tab.c line 82
static void gm_world_tab_create_interface(struct _GmWorldTab *obj);
// gm_world_tab_finalize
// file widgets/gm-world-tab.c line 46
static void gm_world_tab_finalize(struct _GObject *object);
// gm_world_tab_get_type
// file widgets/gm-world-tab.c line 35
unsigned long int gm_world_tab_get_type(void);
// gm_world_tab_init
// file widgets/gm-world-tab.c line 121
static void gm_world_tab_init(struct _GmWorldTab *obj);
// gm_world_tab_new
// file widgets/gm-world-tab.h line 47
struct _GmWorldTab * gm_world_tab_new(struct _GmWorld *world);
// gm_world_tab_stop_recolor
// file widgets/gm-world-tab.c line 38
static void gm_world_tab_stop_recolor(struct _GmWorldTab *tab);
// gm_world_tab_update
// file widgets/gm-world-tab.c line 152
static void gm_world_tab_update(struct _GmWorldTab *tab);
// gm_world_tab_update_color
// file widgets/gm-world-tab.c line 136
signed int gm_world_tab_update_color(struct _GmWorldTab *tab);
// gm_world_text_view_blink_timeout
// file widgets/gm-world-text-view.c line 782
static signed int gm_world_text_view_blink_timeout(struct _GmWorldTextView *view);
// gm_world_text_view_blinker_iters
// file widgets/gm-world-text-view.c line 718
static void gm_world_text_view_blinker_iters(struct _BlinkInfo *info, struct _GtkTextIter *start, struct _GtkTextIter *end, struct _GtkTextTag **tag_blink);
// gm_world_text_view_blinker_set_visible
// file widgets/gm-world-text-view.c line 742
static void gm_world_text_view_blinker_set_visible(struct _BlinkInfo *info, signed int visible);
// gm_world_text_view_blinker_timeout
// file widgets/gm-world-text-view.c line 762
static signed int gm_world_text_view_blinker_timeout(struct _BlinkInfo *info);
// gm_world_text_view_button_press_event
// file widgets/gm-world-text-view.c line 250
static signed int gm_world_text_view_button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event);
// gm_world_text_view_button_release_event
// file widgets/gm-world-text-view.c line 309
static signed int gm_world_text_view_button_release_event(struct _GtkWidget *widget, struct _GdkEventButton *event);
// gm_world_text_view_check_buffer_size
// file widgets/gm-world-text-view.c line 544
static void gm_world_text_view_check_buffer_size(struct _GmWorldTextView *view);
// gm_world_text_view_class_init
// file widgets/gm-world-text-view.c line 144
static void gm_world_text_view_class_init(struct _GmWorldTextViewClass *klass);
// gm_world_text_view_class_intern_init
// file widgets/gm-world-text-view.c line 113
static void gm_world_text_view_class_intern_init(void *klass);
// gm_world_text_view_color_table
// file widgets/gm-world-text-view.c line 1174
struct _GmColorTable * gm_world_text_view_color_table(struct _GmWorldTextView *view);
// gm_world_text_view_create_tags
// file widgets/gm-world-text-view.c line 562
static void gm_world_text_view_create_tags(struct _GmWorldTextView *view);
// gm_world_text_view_drag_data_get
// file widgets/gm-world-text-view.c line 342
static void gm_world_text_view_drag_data_get(struct _GtkWidget *widget, struct _GdkDragContext *context, struct _GtkSelectionData *data, unsigned int info, unsigned int time);
// gm_world_text_view_drag_end
// file widgets/gm-world-text-view.c line 371
static void gm_world_text_view_drag_end(struct _GtkWidget *widget, struct _GdkDragContext *context);
// gm_world_text_view_finalize
// file widgets/gm-world-text-view.c line 117
static void gm_world_text_view_finalize(struct _GObject *object);
// gm_world_text_view_get_metrics
// file widgets/gm-world-text-view.c line 1354
void gm_world_text_view_get_metrics(struct _GmWorldTextView *view, unsigned int *width, unsigned int *height);
// gm_world_text_view_get_type
// file widgets/gm-world-text-view.h line 49
unsigned long int gm_world_text_view_get_type(void);
// gm_world_text_view_init
// file widgets/gm-world-text-view.c line 205
static void gm_world_text_view_init(struct _GmWorldTextView *view);
// gm_world_text_view_init_tags
// file widgets/gm-world-text-view.c line 677
static void gm_world_text_view_init_tags(struct _GmWorldTextView *view);
// gm_world_text_view_insert
// file widgets/gm-world-text-view.h line 52
char * gm_world_text_view_insert(struct _GmWorldTextView *view, const char *text);
// gm_world_text_view_insert_text
// file widgets/gm-world-text-view.c line 1018
static void gm_world_text_view_insert_text(struct _GmWorldTextView *view, const char *text, struct _GmWorldTextViewInsertInfo *insert_info);
// gm_world_text_view_leave_event
// file widgets/gm-world-text-view.c line 329
static signed int gm_world_text_view_leave_event(struct _GtkWidget *widget, struct _GdkEventCrossing *event);
// gm_world_text_view_new
// file widgets/gm-world-text-view.c line 1126
struct _GtkWidget * gm_world_text_view_new(void);
// gm_world_text_view_new_with_color_table
// file widgets/gm-world-text-view.h line 51
struct _GtkWidget * gm_world_text_view_new_with_color_table(struct _GmColorTable *color_table);
// gm_world_text_view_no_selection
// file widgets/gm-world-text-view.c line 298
static void gm_world_text_view_no_selection(struct _GmWorldTextView *view);
// gm_world_text_view_populate_popup
// file widgets/gm-world-text-view.c line 423
static void gm_world_text_view_populate_popup(struct _GtkTextView *text_view, struct _GtkMenu *menu);
// gm_world_text_view_remove_blinkers
// file widgets/gm-world-text-view.c line 521
static void gm_world_text_view_remove_blinkers(struct _GmWorldTextView *view, struct _GtkTextIter *start, struct _GtkTextIter *end);
// gm_world_text_view_set_color_table
// file widgets/gm-world-text-view.c line 1147
void gm_world_text_view_set_color_table(struct _GmWorldTextView *view, struct _GmColorTable *color_table);
// gm_world_text_view_style_set
// file widgets/gm-world-text-view.c line 383
static void gm_world_text_view_style_set(struct _GtkWidget *widget, struct _GtkStyle *previous_style);
// gm_world_text_view_tag_urls
// file widgets/gm-world-text-view.c line 1090
static void gm_world_text_view_tag_urls(struct _GmWorldTextView *view, char *text, struct _GtkTextIter *started, struct _GtkTextIter *ended);
// gm_world_text_view_tagname_from_code
// file widgets/gm-world-text-view.c line 814
static const char * gm_world_text_view_tagname_from_code(unsigned int code);
// gm_world_text_view_tags_add
// file widgets/gm-world-text-view.c line 1083
static struct _GList * gm_world_text_view_tags_add(struct _GmWorldTextView *view, struct _GList *tags, struct _GtkTextTag *tag);
// gm_world_text_view_tags_apply_bold
// file widgets/gm-world-text-view.c line 836
static struct _GList * gm_world_text_view_tags_apply_bold(struct _GmWorldTextView *view, struct _GList *tags);
// gm_world_text_view_tags_fix_for_inverse
// file widgets/gm-world-text-view.c line 881
static struct _GList * gm_world_text_view_tags_fix_for_inverse(struct _GmWorldTextView *view, struct _GList *tags);
// gm_world_text_view_tags_overlap
// file widgets/gm-world-text-view.c line 963
static signed int gm_world_text_view_tags_overlap(struct _GtkTextTag *t1, struct _GtkTextTag *t2);
// gm_world_text_view_tags_remove_bold
// file widgets/gm-world-text-view.c line 1000
static struct _GList * gm_world_text_view_tags_remove_bold(struct _GmWorldTextView *view, struct _GList *tags);
// gm_world_text_view_tags_remove_obsolete
// file widgets/gm-world-text-view.c line 982
static struct _GList * gm_world_text_view_tags_remove_obsolete(struct _GmWorldTextView *view, struct _GList *tags, struct _GtkTextTag *tag);
// gm_world_text_view_update_color_tag
// file widgets/gm-world-text-view.c line 478
static void gm_world_text_view_update_color_tag(struct _GmWorldTextView *view, const char *name, struct _GtkTextTag *tag);
// gm_world_text_view_update_font
// file widgets/gm-world-text-view.c line 690
static void gm_world_text_view_update_font(struct _GmWorldTextView *view);
// gm_world_text_view_update_tags
// file widgets/gm-world-text-view.c line 658
static void gm_world_text_view_update_tags(struct _GmWorldTextView *view);
// gm_world_triggers
// file ./gm-world.h line 111
struct _GmTriggers * gm_world_triggers(struct _GmWorld *world);
// gm_world_triggers_subst
// file gm-world.c line 856
char * gm_world_triggers_subst(const char *data, const char *text, struct anonymous$17 *matches, signed int nummatches);
// gm_world_unload
// file ./gm-world.h line 103
void gm_world_unload(struct _GmWorld *world);
// gm_world_view_buffer
// file widgets/gm-world-view.h line 77
struct _GtkTextBuffer * gm_world_view_buffer(struct _GmWorldView *view);
// gm_world_view_can_find
// file widgets/gm-world-view.c line 552
signed int gm_world_view_can_find(struct _GmWorldView *view);
// gm_world_view_can_replace
// file widgets/gm-world-view.c line 653
signed int gm_world_view_can_replace(struct _GmWorldView *view);
// gm_world_view_change_font_size
// file widgets/gm-world-view.c line 721
void gm_world_view_change_font_size(struct _GmWorldView *view, signed int size_change);
// gm_world_view_class_init
// file widgets/gm-world-view.c line 201
static void gm_world_view_class_init(struct _GmWorldViewClass *klass);
// gm_world_view_class_intern_init
// file widgets/gm-world-view.c line 89
static void gm_world_view_class_intern_init(void *klass);
// gm_world_view_create_input_text_view
// file widgets/gm-world-view.c line 257
struct _GtkWidget * gm_world_view_create_input_text_view(struct _GmWorldView *view);
// gm_world_view_create_world_text_view
// file widgets/gm-world-view.c line 276
struct _GtkWidget * gm_world_view_create_world_text_view(struct _GmWorldView *view);
// gm_world_view_destroy
// file widgets/gm-world-view.c line 149
static void gm_world_view_destroy(struct _GtkObject *object);
// gm_world_view_editor_create_view
// file widgets/gm-world-view.c line 358
struct _GtkWidget * gm_world_view_editor_create_view(struct _GmWorldView *view, struct _GmEditor *editor);
// gm_world_view_editor_page_new
// file widgets/gm-world-view.c line 384
struct _GtkWidget * gm_world_view_editor_page_new(struct _GmWorldView *view, struct _GmEditor *editor);
// gm_world_view_ensure_show_tabs
// file widgets/gm-world-view.c line 215
static void gm_world_view_ensure_show_tabs(struct _GmWorldView *view);
// gm_world_view_finalize
// file widgets/gm-world-view.c line 108
static void gm_world_view_finalize(struct _GObject *object);
// gm_world_view_find_first
// file widgets/gm-world-view.h line 59
signed int gm_world_view_find_first(struct _GmWorldView *view, const char *str, enum _GmSearchableSearchFlags flags);
// gm_world_view_find_next
// file widgets/gm-world-view.h line 61
signed int gm_world_view_find_next(struct _GmWorldView *view, const char *str, enum _GmSearchableSearchFlags flags);
// gm_world_view_flash_status
// file widgets/gm-world-view.c line 316
void gm_world_view_flash_status(struct _GmWorldView *view, const char *status, unsigned int seconds);
// gm_world_view_get_type
// file widgets/gm-world-view.h line 56
unsigned long int gm_world_view_get_type(void);
// gm_world_view_hpaned
// file widgets/gm-world-view.c line 700
struct _GtkHPaned * gm_world_view_hpaned(struct _GmWorldView *view);
// gm_world_view_init
// file widgets/gm-world-view.c line 471
static void gm_world_view_init(struct _GmWorldView *view);
// gm_world_view_input
// file widgets/gm-world-view.h line 73
struct _GmWorldInputView * gm_world_view_input(struct _GmWorldView *view);
// gm_world_view_input_grab_focus
// file widgets/gm-world-view.c line 169
static signed int gm_world_view_input_grab_focus(struct _GmWorldView *view);
// gm_world_view_log_page_new
// file widgets/gm-world-view.c line 322
struct _GtkWidget * gm_world_view_log_page_new(struct _GmWorldView *view, const char *filename);
// gm_world_view_new
// file widgets/gm-world-view.h line 57
struct _GtkWidget * gm_world_view_new(struct _GmWorld *world);
// gm_world_view_open_log
// file widgets/gm-world-view.h line 80
void gm_world_view_open_log(struct _GmWorldView *view, const char *filename);
// gm_world_view_page_can_find
// file widgets/gm-world-view.h line 64
signed int gm_world_view_page_can_find(struct _GmWorldView *view, signed int page_num);
// gm_world_view_page_can_replace
// file widgets/gm-world-view.h line 70
signed int gm_world_view_page_can_replace(struct _GmWorldView *view, signed int page_num);
// gm_world_view_remove_page
// file widgets/gm-world-view.c line 188
static void gm_world_view_remove_page(struct _GtkContainer *container, struct _GtkWidget *page);
// gm_world_view_replace
// file widgets/gm-world-view.h line 66
signed int gm_world_view_replace(struct _GmWorldView *view, const char *replace);
// gm_world_view_replace_all
// file widgets/gm-world-view.h line 67
signed int gm_world_view_replace_all(struct _GmWorldView *view, const char *str, const char *replace, enum _GmSearchableSearchFlags flags);
// gm_world_view_restore_paned_size
// file widgets/gm-world-view.c line 460
static void gm_world_view_restore_paned_size(struct _GtkWidget *widget, struct _GmWorldView *view);
// gm_world_view_searchable_get_text_view
// file widgets/gm-world-view.c line 99
static struct _GtkTextView * gm_world_view_searchable_get_text_view(struct _GmSearchable *sea);
// gm_world_view_searchable_iface_init
// file widgets/gm-world-view.c line 94
static void gm_world_view_searchable_iface_init(struct _GmSearchableInterface *iface);
// gm_world_view_set_focus
// file widgets/gm-world-view.h line 82
void gm_world_view_set_focus(struct _GmWorldView *view);
// gm_world_view_set_userlist_width
// file widgets/gm-world-view.c line 710
void gm_world_view_set_userlist_width(struct _GmWorldView *view, signed int width);
// gm_world_view_switch_page
// file widgets/gm-world-view.c line 175
static void gm_world_view_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num);
// gm_world_view_text_active
// file widgets/gm-world-view.c line 525
signed int gm_world_view_text_active(struct _GmWorldView *view);
// gm_world_view_text_view
// file widgets/gm-world-view.c line 690
struct _GmWorldTextView * gm_world_view_text_view(struct _GmWorldView *view);
// gm_world_view_update_status
// file widgets/gm-world-view.c line 303
void gm_world_view_update_status(struct _GmWorldView *view, const char *status);
// gm_world_view_world
// file widgets/gm-world-view.h line 72
struct _GmWorld * gm_world_view_world(struct _GmWorldView *view);
// gm_world_view_world_page_new
// file widgets/gm-world-view.c line 420
struct _GtkWidget * gm_world_view_world_page_new(struct _GmWorldView *view);
// gm_world_writeln
// file gm-world.c line 1138
void gm_world_writeln(struct _GmWorld *world, const char *text);
// gm_worlds_list_dialog_connect_world
// file dialogs/gm-worlds-list-dialog.c line 237
void gm_worlds_list_dialog_connect_world();
// gm_worlds_list_dialog_create_tree_view
// file dialogs/gm-worlds-list-dialog.c line 60
struct _GtkWidget * gm_worlds_list_dialog_create_tree_view(char *widget_name, char *string1, char *string2, signed int int1, signed int int2);
// gm_worlds_list_dialog_delete_selected_worlds
// file dialogs/gm-worlds-list-dialog.c line 122
static void gm_worlds_list_dialog_delete_selected_worlds();
// gm_worlds_list_dialog_modify_world
// file dialogs/gm-worlds-list-dialog.c line 183
void gm_worlds_list_dialog_modify_world();
// gm_worlds_list_dialog_run
// file ./dialogs/gm-worlds-list-dialog.h line 4
void gm_worlds_list_dialog_run();
// gm_worlds_list_dialog_selected_path
// file dialogs/gm-worlds-list-dialog.c line 207
struct _GList * gm_worlds_list_dialog_selected_path();
// gm_worlds_list_dialog_selected_world
// file dialogs/gm-worlds-list-dialog.c line 217
struct _GmWorld * gm_worlds_list_dialog_selected_world();
// gm_worlds_list_dialog_widget
// file dialogs/gm-worlds-list-dialog.c line 52
struct _GtkWidget * gm_worlds_list_dialog_widget(char *name);
// gm_worlds_view_add_world
// file widgets/gm-worlds-view.c line 198
void gm_worlds_view_add_world(struct _GmWorldsView *view, struct _GmWorld *world);
// gm_worlds_view_build
// file widgets/gm-worlds-view.c line 121
static void gm_worlds_view_build(struct _GmWorldsView *view);
// gm_worlds_view_class_init
// file widgets/gm-worlds-view.c line 62
static void gm_worlds_view_class_init(struct _GmWorldsViewClass *klass);
// gm_worlds_view_class_intern_init
// file widgets/gm-worlds-view.c line 34
static void gm_worlds_view_class_intern_init(void *klass);
// gm_worlds_view_finalize
// file widgets/gm-worlds-view.c line 37
static void gm_worlds_view_finalize(struct _GObject *object);
// gm_worlds_view_find
// file widgets/gm-worlds-view.c line 176
static signed int gm_worlds_view_find(struct _GmWorldsView *view, struct _GmWorld *world, struct _GtkTreeIter *iter);
// gm_worlds_view_find_by_options
// file widgets/gm-worlds-view.c line 152
static signed int gm_worlds_view_find_by_options(struct _GmWorldsView *view, struct _GmOptions *options, struct _GtkTreeIter *iter, struct _GmWorld **world);
// gm_worlds_view_get_type
// file widgets/gm-worlds-view.c line 34
unsigned long int gm_worlds_view_get_type(void);
// gm_worlds_view_init
// file widgets/gm-worlds-view.c line 81
static void gm_worlds_view_init(struct _GmWorldsView *obj);
// gm_worlds_view_model
// file widgets/gm-worlds-view.c line 228
struct _GtkTreeModel * gm_worlds_view_model(struct _GmWorldsView *view);
// gm_worlds_view_new
// file widgets/gm-worlds-view.c line 183
struct _GtkWidget * gm_worlds_view_new();
// gm_worlds_view_populate_worlds
// file widgets/gm-worlds-view.c line 106
static void gm_worlds_view_populate_worlds(struct _GmWorldsView *view);
// gm_worlds_view_world_text
// file widgets/gm-worlds-view.c line 86
static char * gm_worlds_view_world_text(struct _GmWorldsView *view, struct _GmWorld *world);
// gnome_client_set_clone_command
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 335
void gnome_client_set_clone_command(struct _GnomeClient *, signed int, char **);
// gnome_client_set_restart_command
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 292
void gnome_client_set_restart_command(struct _GnomeClient *, signed int, char **);
// gnome_master_client
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 208
struct _GnomeClient * gnome_master_client(void);
// gnome_program_init
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 230
struct _GnomeProgram * gnome_program_init(const char *, const char *, const struct _GnomeModuleInfo *, signed int, char **, const char *, ...);
// gnome_url_show
// file /usr/include/libgnome-2.0/libgnome/gnome-url.h line 52
signed int gnome_url_show(const char *, struct _GError **);
// gnome_util_user_shell
// file /usr/include/libgnome-2.0/libgnome/gnome-util.h line 55
char * gnome_util_user_shell(void);
// gnome_vfs_async_xfer
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-async-ops.h line 487
enum anonymous$32 gnome_vfs_async_xfer(struct GnomeVFSAsyncHandle **, struct _GList *, struct _GList *, enum anonymous$81, enum anonymous$83, enum anonymous$82, signed int, signed int (*)(struct GnomeVFSAsyncHandle *, struct anonymous$80 *, void *), void *, signed int (*)(struct anonymous$80 *, void *), void *);
// gnome_vfs_file_info_new
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 529
struct anonymous$31 * gnome_vfs_file_info_new(void);
// gnome_vfs_file_info_unref
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-file-info.h line 530
void gnome_vfs_file_info_unref(struct anonymous$31 *);
// gnome_vfs_format_file_size_for_display
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-utils.h line 58
char * gnome_vfs_format_file_size_for_display(unsigned long int);
// gnome_vfs_get_file_info
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-ops.h line 75
enum anonymous$32 gnome_vfs_get_file_info(const char *, struct anonymous$31 *, enum anonymous$33);
// gnome_vfs_get_local_path_from_uri
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-utils.h line 118
char * gnome_vfs_get_local_path_from_uri(const char *);
// gnome_vfs_init
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-init.h line 31
signed int gnome_vfs_init(void);
// gnome_vfs_monitor_add
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-ops.h line 132
enum anonymous$32 gnome_vfs_monitor_add(struct GnomeVFSMonitorHandle **, const char *, enum anonymous$101, void (*)(struct GnomeVFSMonitorHandle *, const char *, const char *, enum anonymous$102, void *), void *);
// gnome_vfs_monitor_cancel
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-ops.h line 138
enum anonymous$32 gnome_vfs_monitor_cancel(struct GnomeVFSMonitorHandle *);
// gnome_vfs_result_to_string
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-result.h line 154
const char * gnome_vfs_result_to_string(enum anonymous$32);
// gnome_vfs_shutdown
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-init.h line 33
void gnome_vfs_shutdown(void);
// gnome_vfs_uri_get_path
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-uri.h line 200
const char * gnome_vfs_uri_get_path(const struct GnomeVFSURI *);
// gnome_vfs_uri_new
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-uri.h line 155
struct GnomeVFSURI * gnome_vfs_uri_new(const char *);
// gnome_vfs_uri_unref
// file /usr/include/gnome-vfs-2.0/libgnomevfs/gnome-vfs-uri.h line 161
void gnome_vfs_uri_unref(struct GnomeVFSURI *);
// gtk_accel_group_connect
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 129
void gtk_accel_group_connect(struct _GtkAccelGroup *, unsigned int, enum anonymous$0, enum anonymous$59, struct _GClosure *);
// gtk_accel_group_new
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 123
struct _GtkAccelGroup * gtk_accel_group_new(void);
// gtk_action_get_visible
// file /usr/include/gtk-2.0/gtk/gtkaction.h line 99
signed int gtk_action_get_visible(struct _GtkAction *);
// gtk_action_group_add_action
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 123
void gtk_action_group_add_action(struct _GtkActionGroup *, struct _GtkAction *);
// gtk_action_group_add_actions
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 130
void gtk_action_group_add_actions(struct _GtkActionGroup *, const struct _GtkActionEntry *, unsigned int, void *);
// gtk_action_group_add_toggle_actions
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 134
void gtk_action_group_add_toggle_actions(struct _GtkActionGroup *, const struct _GtkToggleActionEntry *, unsigned int, void *);
// gtk_action_group_get_action
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 120
struct _GtkAction * gtk_action_group_get_action(struct _GtkActionGroup *, const char *);
// gtk_action_group_new
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 112
struct _GtkActionGroup * gtk_action_group_new(const char *);
// gtk_action_group_remove_action
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 128
void gtk_action_group_remove_action(struct _GtkActionGroup *, struct _GtkAction *);
// gtk_action_group_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 115
void gtk_action_group_set_sensitive(struct _GtkActionGroup *, signed int);
// gtk_action_group_set_translation_domain
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 165
void gtk_action_group_set_translation_domain(struct _GtkActionGroup *, const char *);
// gtk_action_group_set_visible
// file /usr/include/gtk-2.0/gtk/gtkactiongroup.h line 118
void gtk_action_group_set_visible(struct _GtkActionGroup *, signed int);
// gtk_action_new
// file /usr/include/gtk-2.0/gtk/gtkaction.h line 89
struct _GtkAction * gtk_action_new(const char *, const char *, const char *, const char *);
// gtk_action_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkaction.h line 96
void gtk_action_set_sensitive(struct _GtkAction *, signed int);
// gtk_action_set_visible
// file /usr/include/gtk-2.0/gtk/gtkaction.h line 100
void gtk_action_set_visible(struct _GtkAction *, signed int);
// gtk_adjustment_get_value
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 92
double gtk_adjustment_get_value(struct _GtkAdjustment *);
// gtk_adjustment_set_value
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 93
void gtk_adjustment_set_value(struct _GtkAdjustment *, double);
// gtk_alignment_new
// file /usr/include/gtk-2.0/gtk/gtkalignment.h line 69
struct _GtkWidget * gtk_alignment_new(float, float, float, float);
// gtk_bin_get_type
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 64
unsigned long int gtk_bin_get_type(void);
// gtk_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 104
unsigned long int gtk_box_get_type(void);
// gtk_box_pack_end
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 114
void gtk_box_pack_end(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 109
void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start_defaults
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 121
void gtk_box_pack_start_defaults(struct _GtkBox *, struct _GtkWidget *);
// gtk_box_reorder_child
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 134
void gtk_box_reorder_child(struct _GtkBox *, struct _GtkWidget *, signed int);
// gtk_box_set_homogeneous
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 127
void gtk_box_set_homogeneous(struct _GtkBox *, signed int);
// gtk_box_set_spacing
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 130
void gtk_box_set_spacing(struct _GtkBox *, signed int);
// gtk_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 91
unsigned long int gtk_button_get_type(void);
// gtk_button_new
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 92
struct _GtkWidget * gtk_button_new(void);
// gtk_button_new_from_stock
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 94
struct _GtkWidget * gtk_button_new_from_stock(const char *);
// gtk_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 93
struct _GtkWidget * gtk_button_new_with_label(const char *);
// gtk_button_set_focus_on_click
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 118
void gtk_button_set_focus_on_click(struct _GtkButton *, signed int);
// gtk_button_set_relief
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 106
void gtk_button_set_relief(struct _GtkButton *, enum anonymous$94);
// gtk_cell_layout_add_attribute
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 90
void gtk_cell_layout_add_attribute(struct _GtkCellLayout *, struct _GtkCellRenderer *, const char *, signed int);
// gtk_cell_layout_clear
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 86
void gtk_cell_layout_clear(struct _GtkCellLayout *);
// gtk_cell_layout_get_type
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 78
unsigned long int gtk_cell_layout_get_type(void);
// gtk_cell_layout_pack_start
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 79
void gtk_cell_layout_pack_start(struct _GtkCellLayout *, struct _GtkCellRenderer *, signed int);
// gtk_cell_layout_reorder
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 101
void gtk_cell_layout_reorder(struct _GtkCellLayout *, struct _GtkCellRenderer *, signed int);
// gtk_cell_layout_set_attributes
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 87
void gtk_cell_layout_set_attributes(struct _GtkCellLayout *, struct _GtkCellRenderer *, ...);
// gtk_cell_renderer_get_type
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 125
unsigned long int gtk_cell_renderer_get_type(void);
// gtk_cell_renderer_pixbuf_new
// file /usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h line 65
struct _GtkCellRenderer * gtk_cell_renderer_pixbuf_new(void);
// gtk_cell_renderer_text_get_type
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 96
unsigned long int gtk_cell_renderer_text_get_type(void);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 97
struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_check_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkcheckbutton.h line 71
unsigned long int gtk_check_button_get_type(void);
// gtk_check_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkcheckbutton.h line 73
struct _GtkWidget * gtk_check_button_new_with_label(const char *);
// gtk_clipboard_get
// file /usr/include/gtk-2.0/gtk/gtkclipboard.h line 75
struct _GtkClipboard * gtk_clipboard_get(struct _GdkAtom *);
// gtk_clipboard_set_text
// file /usr/include/gtk-2.0/gtk/gtkclipboard.h line 95
void gtk_clipboard_set_text(struct _GtkClipboard *, const char *, signed int);
// gtk_clipboard_wait_for_text
// file /usr/include/gtk-2.0/gtk/gtkclipboard.h line 124
char * gtk_clipboard_wait_for_text(struct _GtkClipboard *);
// gtk_color_button_get_color
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 90
void gtk_color_button_get_color(struct _GtkColorButton *, struct _GdkColor *);
// gtk_color_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 83
unsigned long int gtk_color_button_get_type(void);
// gtk_color_button_set_color
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 86
void gtk_color_button_set_color(struct _GtkColorButton *, const struct _GdkColor *);
// gtk_combo_box_append_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 132
void gtk_combo_box_append_text(struct _GtkComboBox *, const char *);
// gtk_combo_box_entry_get_text_column
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 72
signed int gtk_combo_box_entry_get_text_column(struct _GtkComboBoxEntry *);
// gtk_combo_box_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 65
unsigned long int gtk_combo_box_entry_get_type(void);
// gtk_combo_box_entry_set_text_column
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 70
void gtk_combo_box_entry_set_text_column(struct _GtkComboBoxEntry *, signed int);
// gtk_combo_box_get_active
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 100
signed int gtk_combo_box_get_active(struct _GtkComboBox *);
// gtk_combo_box_get_active_iter
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 103
signed int gtk_combo_box_get_active_iter(struct _GtkComboBox *, struct _GtkTreeIter *);
// gtk_combo_box_get_active_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 141
char * gtk_combo_box_get_active_text(struct _GtkComboBox *);
// gtk_combo_box_get_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 111
struct _GtkTreeModel * gtk_combo_box_get_model(struct _GtkComboBox *);
// gtk_combo_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 70
unsigned long int gtk_combo_box_get_type(void);
// gtk_combo_box_new_with_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 73
struct _GtkWidget * gtk_combo_box_new_with_model(struct _GtkTreeModel *);
// gtk_combo_box_set_active
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 101
void gtk_combo_box_set_active(struct _GtkComboBox *, signed int);
// gtk_combo_box_set_active_iter
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 105
void gtk_combo_box_set_active_iter(struct _GtkComboBox *, struct _GtkTreeIter *);
// gtk_combo_box_set_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 109
void gtk_combo_box_set_model(struct _GtkComboBox *, struct _GtkTreeModel *);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_border_width
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 110
unsigned int gtk_container_get_border_width(struct _GtkContainer *);
// gtk_container_get_children
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 132
struct _GList * gtk_container_get_children(struct _GtkContainer *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_container_remove
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 113
void gtk_container_remove(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_set_border_width
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 108
void gtk_container_set_border_width(struct _GtkContainer *, unsigned int);
// gtk_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 127
unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_response
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 171
void gtk_dialog_response(struct _GtkDialog *, signed int);
// gtk_dialog_run
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 175
signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_drag_begin
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 133
struct _GdkDragContext * gtk_drag_begin(struct _GtkWidget *, struct _GtkTargetList *, enum anonymous$43, signed int, union _GdkEvent *);
// gtk_drag_check_threshold
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 166
signed int gtk_drag_check_threshold(struct _GtkWidget *, signed int, signed int, signed int, signed int);
// gtk_entry_get_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 216
const char * gtk_entry_get_text(struct _GtkEntry *);
// gtk_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 166
unsigned long int gtk_entry_get_type(void);
// gtk_entry_new
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 167
struct _GtkWidget * gtk_entry_new(void);
// gtk_entry_set_invisible_char
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 180
void gtk_entry_set_invisible_char(struct _GtkEntry *, unsigned int);
// gtk_entry_set_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 213
void gtk_entry_set_text(struct _GtkEntry *, const char *);
// gtk_event_box_new
// file /usr/include/gtk-2.0/gtk/gtkeventbox.h line 61
struct _GtkWidget * gtk_event_box_new(void);
// gtk_events_pending
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 137
signed int gtk_events_pending(void);
// gtk_expander_get_expanded
// file /usr/include/gtk-2.0/gtk/gtkexpander.h line 70
signed int gtk_expander_get_expanded(struct _GtkExpander *);
// gtk_expander_get_type
// file /usr/include/gtk-2.0/gtk/gtkexpander.h line 63
unsigned long int gtk_expander_get_type(void);
// gtk_expander_new
// file /usr/include/gtk-2.0/gtk/gtkexpander.h line 65
struct _GtkWidget * gtk_expander_new(const char *);
// gtk_expander_set_expanded
// file /usr/include/gtk-2.0/gtk/gtkexpander.h line 68
void gtk_expander_set_expanded(struct _GtkExpander *, signed int);
// gtk_file_chooser_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h line 57
struct _GtkWidget * gtk_file_chooser_dialog_new(const char *, struct _GtkWindow *, enum anonymous$155, const char *, ...);
// gtk_file_chooser_get_filename
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 163
char * gtk_file_chooser_get_filename(struct _GtkFileChooser *);
// gtk_file_chooser_get_type
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 88
unsigned long int gtk_file_chooser_get_type(void);
// gtk_font_button_get_font_name
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 87
const char * gtk_font_button_get_font_name(struct _GtkFontButton *);
// gtk_font_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 74
unsigned long int gtk_font_button_get_type(void);
// gtk_font_button_set_font_name
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 88
signed int gtk_font_button_set_font_name(struct _GtkFontButton *, const char *);
// gtk_get_current_event_time
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 210
unsigned int gtk_get_current_event_time(void);
// gtk_grab_add
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 155
void gtk_grab_add(struct _GtkWidget *);
// gtk_grab_remove
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 157
void gtk_grab_remove(struct _GtkWidget *);
// gtk_hbox_get_type
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 62
unsigned long int gtk_hbox_get_type(void);
// gtk_hbox_new
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 63
struct _GtkWidget * gtk_hbox_new(signed int, signed int);
// gtk_hpaned_get_type
// file /usr/include/gtk-2.0/gtk/gtkhpaned.h line 60
unsigned long int gtk_hpaned_get_type(void);
// gtk_hpaned_new
// file /usr/include/gtk-2.0/gtk/gtkhpaned.h line 61
struct _GtkWidget * gtk_hpaned_new(void);
// gtk_hseparator_new
// file /usr/include/gtk-2.0/gtk/gtkhseparator.h line 63
struct _GtkWidget * gtk_hseparator_new(void);
// gtk_icon_factory_add
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 76
void gtk_icon_factory_add(struct _GtkIconFactory *, const char *, struct _GtkIconSet *);
// gtk_icon_factory_add_default
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 84
void gtk_icon_factory_add_default(struct _GtkIconFactory *);
// gtk_icon_factory_new
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 75
struct _GtkIconFactory * gtk_icon_factory_new(void);
// gtk_icon_factory_remove_default
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 85
void gtk_icon_factory_remove_default(struct _GtkIconFactory *);
// gtk_icon_set_add_source
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 139
void gtk_icon_set_add_source(struct _GtkIconSet *, const struct _GtkIconSource *);
// gtk_icon_set_new_from_pixbuf
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 121
struct _GtkIconSet * gtk_icon_set_new_from_pixbuf(struct _GdkPixbuf *);
// gtk_icon_size_lookup
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 100
signed int gtk_icon_size_lookup(enum anonymous$21, signed int *, signed int *);
// gtk_icon_size_lookup_for_settings
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 104
signed int gtk_icon_size_lookup_for_settings(struct _GtkSettings *, enum anonymous$21, signed int *, signed int *);
// gtk_icon_source_free
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 149
void gtk_icon_source_free(struct _GtkIconSource *);
// gtk_icon_source_new
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 147
struct _GtkIconSource * gtk_icon_source_new(void);
// gtk_icon_source_set_pixbuf
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 155
void gtk_icon_source_set_pixbuf(struct _GtkIconSource *, struct _GdkPixbuf *);
// gtk_icon_source_set_size
// file /usr/include/gtk-2.0/gtk/gtkiconfactory.h line 175
void gtk_icon_source_set_size(struct _GtkIconSource *, enum anonymous$21);
// gtk_icon_theme_get_default
// file /usr/include/gtk-2.0/gtk/gtkicontheme.h line 117
struct _GtkIconTheme * gtk_icon_theme_get_default(void);
// gtk_icon_theme_load_icon
// file /usr/include/gtk-2.0/gtk/gtkicontheme.h line 148
struct _GdkPixbuf * gtk_icon_theme_load_icon(struct _GtkIconTheme *, const char *, signed int, enum anonymous$86, struct _GError **);
// gtk_image_get_pixbuf
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 245
struct _GdkPixbuf * gtk_image_get_pixbuf(struct _GtkImage *);
// gtk_image_get_type
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 190
unsigned long int gtk_image_get_type(void);
// gtk_image_new
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 192
struct _GtkWidget * gtk_image_new(void);
// gtk_image_new_from_pixbuf
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 198
struct _GtkWidget * gtk_image_new_from_pixbuf(struct _GdkPixbuf *);
// gtk_image_new_from_stock
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 199
struct _GtkWidget * gtk_image_new_from_stock(const char *, enum anonymous$21);
// gtk_image_set_from_pixbuf
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 218
void gtk_image_set_from_pixbuf(struct _GtkImage *, struct _GdkPixbuf *);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_label_get_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 114
const char * gtk_label_get_text(struct _GtkLabel *);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_set_label
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 118
void gtk_label_set_label(struct _GtkLabel *, const char *);
// gtk_label_set_line_wrap
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 152
void gtk_label_set_line_wrap(struct _GtkLabel *, signed int);
// gtk_label_set_markup
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 121
void gtk_label_set_markup(struct _GtkLabel *, const char *);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_list_store_append
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 126
void gtk_list_store_append(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_get_type
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 77
unsigned long int gtk_list_store_get_type(void);
// gtk_list_store_insert_with_values
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 114
void gtk_list_store_insert_with_values(struct _GtkListStore *, struct _GtkTreeIter *, signed int, ...);
// gtk_list_store_new
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 78
struct _GtkListStore * gtk_list_store_new(signed int, ...);
// gtk_list_store_prepend
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 124
void gtk_list_store_prepend(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_remove
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 103
signed int gtk_list_store_remove(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_set
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 92
void gtk_list_store_set(struct _GtkListStore *, struct _GtkTreeIter *, ...);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_iteration
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 148
signed int gtk_main_iteration(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_menu_attach_to_widget
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 165
void gtk_menu_attach_to_widget(struct _GtkMenu *, struct _GtkWidget *, void (*)(struct _GtkWidget *, struct _GtkMenu *));
// gtk_menu_bar_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenubar.h line 68
unsigned long int gtk_menu_bar_get_type(void);
// gtk_menu_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 125
unsigned long int gtk_menu_get_type(void);
// gtk_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 99
unsigned long int gtk_menu_item_get_type(void);
// gtk_menu_item_new
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 100
struct _GtkWidget * gtk_menu_item_new(void);
// gtk_menu_item_new_with_mnemonic
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 102
struct _GtkWidget * gtk_menu_item_new_with_mnemonic(const char *);
// gtk_menu_new
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 126
struct _GtkWidget * gtk_menu_new(void);
// gtk_menu_popup
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 129
void gtk_menu_popup(struct _GtkMenu *, struct _GtkWidget *, struct _GtkWidget *, void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *), void *, unsigned int, unsigned int);
// gtk_menu_shell_append
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 101
void gtk_menu_shell_append(struct _GtkMenuShell *, struct _GtkWidget *);
// gtk_menu_shell_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 100
unsigned long int gtk_menu_shell_get_type(void);
// gtk_message_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 101
struct _GtkWidget * gtk_message_dialog_new(struct _GtkWindow *, enum anonymous$154, enum anonymous$79, enum anonymous$152, const char *, ...);
// gtk_misc_get_type
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 68
unsigned long int gtk_misc_get_type(void);
// gtk_misc_set_alignment
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 69
void gtk_misc_set_alignment(struct _GtkMisc *, float, float);
// gtk_notebook_append_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 153
signed int gtk_notebook_append_page(struct _GtkNotebook *, struct _GtkWidget *, struct _GtkWidget *);
// gtk_notebook_get_current_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 205
signed int gtk_notebook_get_current_page(struct _GtkNotebook *);
// gtk_notebook_get_n_pages
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 208
signed int gtk_notebook_get_n_pages(struct _GtkNotebook *);
// gtk_notebook_get_nth_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 206
struct _GtkWidget * gtk_notebook_get_nth_page(struct _GtkNotebook *, signed int);
// gtk_notebook_get_show_tabs
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 225
signed int gtk_notebook_get_show_tabs(struct _GtkNotebook *);
// gtk_notebook_get_tab_label
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 258
struct _GtkWidget * gtk_notebook_get_tab_label(struct _GtkNotebook *, struct _GtkWidget *);
// gtk_notebook_get_tab_label_text
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 266
const char * gtk_notebook_get_tab_label_text(struct _GtkNotebook *, struct _GtkWidget *);
// gtk_notebook_get_tab_pos
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 228
enum anonymous$46 gtk_notebook_get_tab_pos(struct _GtkNotebook *);
// gtk_notebook_get_type
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 151
unsigned long int gtk_notebook_get_type(void);
// gtk_notebook_new
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 152
struct _GtkWidget * gtk_notebook_new(void);
// gtk_notebook_page_num
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 209
signed int gtk_notebook_page_num(struct _GtkNotebook *, struct _GtkWidget *);
// gtk_notebook_remove_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 176
void gtk_notebook_remove_page(struct _GtkNotebook *, signed int);
// gtk_notebook_reorder_child
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 290
void gtk_notebook_reorder_child(struct _GtkNotebook *, struct _GtkWidget *, signed int);
// gtk_notebook_set_current_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 211
void gtk_notebook_set_current_page(struct _GtkNotebook *, signed int);
// gtk_notebook_set_scrollable
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 241
void gtk_notebook_set_scrollable(struct _GtkNotebook *, signed int);
// gtk_notebook_set_show_border
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 220
void gtk_notebook_set_show_border(struct _GtkNotebook *, signed int);
// gtk_notebook_set_show_tabs
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 223
void gtk_notebook_set_show_tabs(struct _GtkNotebook *, signed int);
// gtk_notebook_set_tab_pos
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 226
void gtk_notebook_set_tab_pos(struct _GtkNotebook *, enum anonymous$46);
// gtk_object_get_type
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 146
unsigned long int gtk_object_get_type(void);
// gtk_orientation_get_type
// file /usr/include/gtk-2.0/gtk/gtktypebuiltins.h line 102
unsigned long int gtk_orientation_get_type(void);
// gtk_paint_flat_box
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 721
void gtk_paint_flat_box(struct _GtkStyle *, struct _GdkDrawable *, enum anonymous$23, enum anonymous$89, const struct _GdkRectangle *, struct _GtkWidget *, const char *, signed int, signed int, signed int, signed int);
// gtk_paned_get_child2
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 128
struct _GtkWidget * gtk_paned_get_child2(struct _GtkPaned *);
// gtk_paned_get_position
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 123
signed int gtk_paned_get_position(struct _GtkPaned *);
// gtk_paned_get_type
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 109
unsigned long int gtk_paned_get_type(void);
// gtk_paned_pack1
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 114
void gtk_paned_pack1(struct _GtkPaned *, struct _GtkWidget *, signed int, signed int);
// gtk_paned_pack2
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 118
void gtk_paned_pack2(struct _GtkPaned *, struct _GtkWidget *, signed int, signed int);
// gtk_paned_set_position
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 124
void gtk_paned_set_position(struct _GtkPaned *, signed int);
// gtk_plug_get_id
// file /usr/include/gtk-2.0/gtk/gtkplug.h line 92
unsigned int gtk_plug_get_id(struct _GtkPlug *);
// gtk_plug_get_type
// file /usr/include/gtk-2.0/gtk/gtkplug.h line 78
unsigned long int gtk_plug_get_type(void);
// gtk_rc_parse_string
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 159
void gtk_rc_parse_string(const char *);
// gtk_rc_style_new
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 173
struct _GtkRcStyle * gtk_rc_style_new(void);
// gtk_rc_style_unref
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 178
void gtk_rc_style_unref(struct _GtkRcStyle *);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_get_vadjustment
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 110
struct _GtkAdjustment * gtk_scrolled_window_get_vadjustment(struct _GtkScrolledWindow *);
// gtk_scrolled_window_new
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 103
struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 113
void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous$88, enum anonymous$88);
// gtk_scrolled_window_set_shadow_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 124
void gtk_scrolled_window_set_shadow_type(struct _GtkScrolledWindow *, enum anonymous$89);
// gtk_selection_data_set
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 159
void gtk_selection_data_set(struct _GtkSelectionData *, struct _GdkAtom *, signed int, const unsigned char *, signed int);
// gtk_separator_menu_item_new
// file /usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h line 63
struct _GtkWidget * gtk_separator_menu_item_new(void);
// gtk_set_locale
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 132
char * gtk_set_locale(void);
// gtk_show_about_dialog
// file /usr/include/gtk-2.0/gtk/gtkaboutdialog.h line 75
void gtk_show_about_dialog(struct _GtkWindow *, const char *, ...);
// gtk_signal_connect_full
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 121
unsigned long int gtk_signal_connect_full(struct _GtkObject *, const char *, void (*)(void), void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *), void *, void (*)(void *), signed int, signed int);
// gtk_source_buffer_begin_not_undoable_action
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 112
void gtk_source_buffer_begin_not_undoable_action(struct _GtkSourceBuffer *);
// gtk_source_buffer_end_not_undoable_action
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 113
void gtk_source_buffer_end_not_undoable_action(struct _GtkSourceBuffer *);
// gtk_source_buffer_get_type
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 70
unsigned long int gtk_source_buffer_get_type(void);
// gtk_source_buffer_set_highlight_matching_brackets
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 84
void gtk_source_buffer_set_highlight_matching_brackets(struct _GtkSourceBuffer *, signed int);
// gtk_source_buffer_set_highlight_syntax
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 79
void gtk_source_buffer_set_highlight_syntax(struct _GtkSourceBuffer *, signed int);
// gtk_source_buffer_set_language
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 93
void gtk_source_buffer_set_language(struct _GtkSourceBuffer *, struct _GtkSourceLanguage *);
// gtk_source_buffer_set_style_scheme
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcebuffer.h line 100
void gtk_source_buffer_set_style_scheme(struct _GtkSourceBuffer *, struct _GtkSourceStyleScheme *);
// gtk_source_language_manager_get_language
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcelanguagemanager.h line 74
struct _GtkSourceLanguage * gtk_source_language_manager_get_language(struct _GtkSourceLanguageManager *, const char *);
// gtk_source_language_manager_new
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcelanguagemanager.h line 61
struct _GtkSourceLanguageManager * gtk_source_language_manager_new(void);
// gtk_source_style_scheme_get_type
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourcestylescheme.h line 55
unsigned long int gtk_source_style_scheme_get_type(void);
// gtk_source_view_get_type
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h line 140
unsigned long int gtk_source_view_get_type(void);
// gtk_source_view_new
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h line 143
struct _GtkWidget * gtk_source_view_new(void);
// gtk_source_view_set_auto_indent
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h line 159
void gtk_source_view_set_auto_indent(struct _GtkSourceView *, signed int);
// gtk_source_view_set_indent_width
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h line 155
void gtk_source_view_set_indent_width(struct _GtkSourceView *, signed int);
// gtk_source_view_set_insert_spaces_instead_of_tabs
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h line 163
void gtk_source_view_set_insert_spaces_instead_of_tabs(struct _GtkSourceView *, signed int);
// gtk_source_view_set_show_line_numbers
// file /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h line 147
void gtk_source_view_set_show_line_numbers(struct _GtkSourceView *, signed int);
// gtk_spin_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 123
unsigned long int gtk_spin_button_get_type(void);
// gtk_spin_button_get_value_as_int
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 163
signed int gtk_spin_button_get_value_as_int(struct _GtkSpinButton *);
// gtk_spin_button_set_value
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 165
void gtk_spin_button_set_value(struct _GtkSpinButton *, double);
// gtk_statusbar_get_type
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 89
unsigned long int gtk_statusbar_get_type(void);
// gtk_statusbar_new
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 90
struct _GtkWidget * gtk_statusbar_new(void);
// gtk_statusbar_pop
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 100
void gtk_statusbar_pop(struct _GtkStatusbar *, unsigned int);
// gtk_statusbar_push
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 97
unsigned int gtk_statusbar_push(struct _GtkStatusbar *, unsigned int, const char *);
// gtk_statusbar_set_has_resize_grip
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 109
void gtk_statusbar_set_has_resize_grip(struct _GtkStatusbar *, signed int);
// gtk_table_attach
// file /usr/include/gtk-2.0/gtk/gtktable.h line 109
void gtk_table_attach(struct _GtkTable *, struct _GtkWidget *, unsigned int, unsigned int, unsigned int, unsigned int, enum anonymous$58, enum anonymous$58, unsigned int, unsigned int);
// gtk_table_get_type
// file /usr/include/gtk-2.0/gtk/gtktable.h line 102
unsigned long int gtk_table_get_type(void);
// gtk_table_new
// file /usr/include/gtk-2.0/gtk/gtktable.h line 103
struct _GtkWidget * gtk_table_new(unsigned int, unsigned int, signed int);
// gtk_target_list_new
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 93
struct _GtkTargetList * gtk_target_list_new(const struct _GtkTargetEntry *, unsigned int);
// gtk_target_list_unref
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 96
void gtk_target_list_unref(struct _GtkTargetList *);
// gtk_text_buffer_apply_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 290
void gtk_text_buffer_apply_tag(struct _GtkTextBuffer *, struct _GtkTextTag *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_apply_tag_by_name
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 298
void gtk_text_buffer_apply_tag_by_name(struct _GtkTextBuffer *, const char *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_begin_user_action
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 389
void gtk_text_buffer_begin_user_action(struct _GtkTextBuffer *);
// gtk_text_buffer_copy_clipboard
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 374
void gtk_text_buffer_copy_clipboard(struct _GtkTextBuffer *, struct _GtkClipboard *);
// gtk_text_buffer_create_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 259
struct _GtkTextMark * gtk_text_buffer_create_mark(struct _GtkTextBuffer *, const char *, const struct _GtkTextIter *, signed int);
// gtk_text_buffer_create_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 314
struct _GtkTextTag * gtk_text_buffer_create_tag(struct _GtkTextBuffer *, const char *, const char *, ...);
// gtk_text_buffer_cut_clipboard
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 371
void gtk_text_buffer_cut_clipboard(struct _GtkTextBuffer *, struct _GtkClipboard *, signed int);
// gtk_text_buffer_delete
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 218
void gtk_text_buffer_delete(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_delete_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 266
void gtk_text_buffer_delete_mark(struct _GtkTextBuffer *, struct _GtkTextMark *);
// gtk_text_buffer_end_user_action
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 390
void gtk_text_buffer_end_user_action(struct _GtkTextBuffer *);
// gtk_text_buffer_get_bounds
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 340
void gtk_text_buffer_get_bounds(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_get_end_iter
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 338
void gtk_text_buffer_get_end_iter(struct _GtkTextBuffer *, struct _GtkTextIter *);
// gtk_text_buffer_get_insert
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 277
struct _GtkTextMark * gtk_text_buffer_get_insert(struct _GtkTextBuffer *);
// gtk_text_buffer_get_iter_at_line
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 333
void gtk_text_buffer_get_iter_at_line(struct _GtkTextBuffer *, struct _GtkTextIter *, signed int);
// gtk_text_buffer_get_iter_at_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 343
void gtk_text_buffer_get_iter_at_mark(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextMark *);
// gtk_text_buffer_get_iter_at_offset
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 330
void gtk_text_buffer_get_iter_at_offset(struct _GtkTextBuffer *, struct _GtkTextIter *, signed int);
// gtk_text_buffer_get_line_count
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 163
signed int gtk_text_buffer_get_line_count(struct _GtkTextBuffer *);
// gtk_text_buffer_get_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 268
struct _GtkTextMark * gtk_text_buffer_get_mark(struct _GtkTextBuffer *, const char *);
// gtk_text_buffer_get_modified
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 360
signed int gtk_text_buffer_get_modified(struct _GtkTextBuffer *);
// gtk_text_buffer_get_selection_bound
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 278
struct _GtkTextMark * gtk_text_buffer_get_selection_bound(struct _GtkTextBuffer *);
// gtk_text_buffer_get_selection_bounds
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 381
signed int gtk_text_buffer_get_selection_bounds(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_get_start_iter
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 336
void gtk_text_buffer_get_start_iter(struct _GtkTextBuffer *, struct _GtkTextIter *);
// gtk_text_buffer_get_tag_table
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 167
struct _GtkTextTagTable * gtk_text_buffer_get_tag_table(struct _GtkTextBuffer *);
// gtk_text_buffer_get_text
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 231
char * gtk_text_buffer_get_text(struct _GtkTextBuffer *, const struct _GtkTextIter *, const struct _GtkTextIter *, signed int);
// gtk_text_buffer_get_type
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 157
unsigned long int gtk_text_buffer_get_type(void);
// gtk_text_buffer_insert
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 175
void gtk_text_buffer_insert(struct _GtkTextBuffer *, struct _GtkTextIter *, const char *, signed int);
// gtk_text_buffer_insert_range
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 193
void gtk_text_buffer_insert_range(struct _GtkTextBuffer *, struct _GtkTextIter *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_insert_with_tags
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 203
void gtk_text_buffer_insert_with_tags(struct _GtkTextBuffer *, struct _GtkTextIter *, const char *, signed int, struct _GtkTextTag *, ...);
// gtk_text_buffer_insert_with_tags_by_name
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 210
void gtk_text_buffer_insert_with_tags_by_name(struct _GtkTextBuffer *, struct _GtkTextIter *, const char *, signed int, const char *, ...);
// gtk_text_buffer_move_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 263
void gtk_text_buffer_move_mark(struct _GtkTextBuffer *, struct _GtkTextMark *, const struct _GtkTextIter *);
// gtk_text_buffer_move_mark_by_name
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 271
void gtk_text_buffer_move_mark_by_name(struct _GtkTextBuffer *, const char *, const struct _GtkTextIter *);
// gtk_text_buffer_new
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 162
struct _GtkTextBuffer * gtk_text_buffer_new(struct _GtkTextTagTable *);
// gtk_text_buffer_paste_clipboard
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 376
void gtk_text_buffer_paste_clipboard(struct _GtkTextBuffer *, struct _GtkClipboard *, struct _GtkTextIter *, signed int);
// gtk_text_buffer_place_cursor
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 281
void gtk_text_buffer_place_cursor(struct _GtkTextBuffer *, const struct _GtkTextIter *);
// gtk_text_buffer_remove_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 294
void gtk_text_buffer_remove_tag(struct _GtkTextBuffer *, struct _GtkTextTag *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_set_modified
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 361
void gtk_text_buffer_set_modified(struct _GtkTextBuffer *, signed int);
// gtk_text_buffer_set_text
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 170
void gtk_text_buffer_set_text(struct _GtkTextBuffer *, const char *, signed int);
// gtk_text_iter_backward_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 184
signed int gtk_text_iter_backward_line(struct _GtkTextIter *);
// gtk_text_iter_backward_search
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 280
signed int gtk_text_iter_backward_search(const struct _GtkTextIter *, const char *, enum anonymous$100, struct _GtkTextIter *, struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_backward_to_tag_toggle
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 259
signed int gtk_text_iter_backward_to_tag_toggle(struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_begins_tag
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 136
signed int gtk_text_iter_begins_tag(const struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_ends_tag
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 139
signed int gtk_text_iter_ends_tag(const struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_equal
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 291
signed int gtk_text_iter_equal(const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_forward_char
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 177
signed int gtk_text_iter_forward_char(struct _GtkTextIter *);
// gtk_text_iter_forward_chars
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 179
signed int gtk_text_iter_forward_chars(struct _GtkTextIter *, signed int);
// gtk_text_iter_forward_cursor_positions
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 223
signed int gtk_text_iter_forward_cursor_positions(struct _GtkTextIter *, signed int);
// gtk_text_iter_forward_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 183
signed int gtk_text_iter_forward_line(struct _GtkTextIter *);
// gtk_text_iter_forward_search
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 273
signed int gtk_text_iter_forward_search(const struct _GtkTextIter *, const char *, enum anonymous$100, struct _GtkTextIter *, struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_forward_to_tag_toggle
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 256
signed int gtk_text_iter_forward_to_tag_toggle(struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_get_char
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 108
unsigned int gtk_text_iter_get_char(const struct _GtkTextIter *);
// gtk_text_iter_get_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 97
signed int gtk_text_iter_get_line(const struct _GtkTextIter *);
// gtk_text_iter_get_line_offset
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 98
signed int gtk_text_iter_get_line_offset(const struct _GtkTextIter *);
// gtk_text_iter_get_offset
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 96
signed int gtk_text_iter_get_offset(const struct _GtkTextIter *);
// gtk_text_iter_get_visible_text
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 122
char * gtk_text_iter_get_visible_text(const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_has_tag
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 145
signed int gtk_text_iter_has_tag(const struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_in_range
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 295
signed int gtk_text_iter_in_range(const struct _GtkTextIter *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_is_end
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 170
signed int gtk_text_iter_is_end(const struct _GtkTextIter *);
// gtk_text_iter_set_line_offset
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 240
void gtk_text_iter_set_line_offset(struct _GtkTextIter *, signed int);
// gtk_text_mark_get_deleted
// file /usr/include/gtk-2.0/gtk/gtktextmark.h line 98
signed int gtk_text_mark_get_deleted(struct _GtkTextMark *);
// gtk_text_tag_get_type
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 156
unsigned long int gtk_text_tag_get_type(void);
// gtk_text_tag_new
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 157
struct _GtkTextTag * gtk_text_tag_new(const char *);
// gtk_text_tag_table_lookup
// file /usr/include/gtk-2.0/gtk/gtktexttagtable.h line 82
struct _GtkTextTag * gtk_text_tag_table_lookup(struct _GtkTextTagTable *, const char *);
// gtk_text_tag_table_remove
// file /usr/include/gtk-2.0/gtk/gtktexttagtable.h line 80
void gtk_text_tag_table_remove(struct _GtkTextTagTable *, struct _GtkTextTag *);
// gtk_text_view_get_buffer
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 222
struct _GtkTextBuffer * gtk_text_view_get_buffer(struct _GtkTextView *);
// gtk_text_view_get_cursor_visible
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 245
signed int gtk_text_view_get_cursor_visible(struct _GtkTextView *);
// gtk_text_view_get_editable
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 339
signed int gtk_text_view_get_editable(struct _GtkTextView *);
// gtk_text_view_get_iter_at_location
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 250
void gtk_text_view_get_iter_at_location(struct _GtkTextView *, struct _GtkTextIter *, signed int, signed int);
// gtk_text_view_get_left_margin
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 360
signed int gtk_text_view_get_left_margin(struct _GtkTextView *);
// gtk_text_view_get_line_yrange
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 259
void gtk_text_view_get_line_yrange(struct _GtkTextView *, const struct _GtkTextIter *, signed int *, signed int *);
// gtk_text_view_get_pixels_above_lines
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 348
signed int gtk_text_view_get_pixels_above_lines(struct _GtkTextView *);
// gtk_text_view_get_pixels_below_lines
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 351
signed int gtk_text_view_get_pixels_below_lines(struct _GtkTextView *);
// gtk_text_view_get_right_margin
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 363
signed int gtk_text_view_get_right_margin(struct _GtkTextView *);
// gtk_text_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 217
unsigned long int gtk_text_view_get_type(void);
// gtk_text_view_get_window
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 285
struct _GdkDrawable * gtk_text_view_get_window(struct _GtkTextView *, enum anonymous$91);
// gtk_text_view_get_window_type
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 287
enum anonymous$91 gtk_text_view_get_window_type(struct _GtkTextView *, struct _GdkDrawable *);
// gtk_text_view_new
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 218
struct _GtkWidget * gtk_text_view_new(void);
// gtk_text_view_scroll_to_iter
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 223
signed int gtk_text_view_scroll_to_iter(struct _GtkTextView *, struct _GtkTextIter *, double, signed int, double, double);
// gtk_text_view_scroll_to_mark
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 229
void gtk_text_view_scroll_to_mark(struct _GtkTextView *, struct _GtkTextMark *, double, signed int, double, double);
// gtk_text_view_set_accepts_tab
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 343
void gtk_text_view_set_accepts_tab(struct _GtkTextView *, signed int);
// gtk_text_view_set_editable
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 337
void gtk_text_view_set_editable(struct _GtkTextView *, signed int);
// gtk_text_view_set_left_margin
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 358
void gtk_text_view_set_left_margin(struct _GtkTextView *, signed int);
// gtk_text_view_set_pixels_above_lines
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 346
void gtk_text_view_set_pixels_above_lines(struct _GtkTextView *, signed int);
// gtk_text_view_set_pixels_below_lines
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 349
void gtk_text_view_set_pixels_below_lines(struct _GtkTextView *, signed int);
// gtk_text_view_set_right_margin
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 361
void gtk_text_view_set_right_margin(struct _GtkTextView *, signed int);
// gtk_text_view_set_wrap_mode
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 334
void gtk_text_view_set_wrap_mode(struct _GtkTextView *, enum anonymous$77);
// gtk_text_view_window_to_buffer_coords
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 275
void gtk_text_view_window_to_buffer_coords(struct _GtkTextView *, enum anonymous$91, signed int, signed int, signed int *, signed int *);
// gtk_toggle_action_get_active
// file /usr/include/gtk-2.0/gtk/gtktoggleaction.h line 83
signed int gtk_toggle_action_get_active(struct _GtkToggleAction *);
// gtk_toggle_action_get_type
// file /usr/include/gtk-2.0/gtk/gtktoggleaction.h line 75
unsigned long int gtk_toggle_action_get_type(void);
// gtk_toggle_action_set_active
// file /usr/include/gtk-2.0/gtk/gtktoggleaction.h line 81
void gtk_toggle_action_set_active(struct _GtkToggleAction *, signed int);
// gtk_toggle_button_get_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 84
signed int gtk_toggle_button_get_active(struct _GtkToggleButton *);
// gtk_toggle_button_get_type
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 74
unsigned long int gtk_toggle_button_get_type(void);
// gtk_toggle_button_set_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 82
void gtk_toggle_button_set_active(struct _GtkToggleButton *, signed int);
// gtk_toggle_button_toggled
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 85
void gtk_toggle_button_toggled(struct _GtkToggleButton *);
// gtk_toolbar_get_type
// file /usr/include/gtk-2.0/gtk/gtktoolbar.h line 141
unsigned long int gtk_toolbar_get_type(void);
// gtk_tooltips_new
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 88
struct _GtkTooltips * gtk_tooltips_new(void);
// gtk_tooltips_set_tip
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 94
void gtk_tooltips_set_tip(struct _GtkTooltips *, struct _GtkWidget *, const char *, const char *);
// gtk_tree_model_get
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 234
void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 198
signed int gtk_tree_model_get_iter(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreePath *);
// gtk_tree_model_get_iter_first
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 206
signed int gtk_tree_model_get_iter_first(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 190
unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_model_iter_n_children
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 221
signed int gtk_tree_model_iter_n_children(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_iter_next
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 214
signed int gtk_tree_model_iter_next(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_sort_get_model
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 87
struct _GtkTreeModel * gtk_tree_model_sort_get_model(struct _GtkTreeModelSort *);
// gtk_tree_model_sort_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 84
unsigned long int gtk_tree_model_sort_get_type(void);
// gtk_tree_model_sort_new_with_model
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 85
struct _GtkTreeModel * gtk_tree_model_sort_new_with_model(struct _GtkTreeModel *);
// gtk_tree_model_sort_reset_default_sort_func
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 98
void gtk_tree_model_sort_reset_default_sort_func(struct _GtkTreeModelSort *);
// gtk_tree_path_free
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 139
void gtk_tree_path_free(struct _GtkTreePath *);
// gtk_tree_row_reference_deleted
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 178
void gtk_tree_row_reference_deleted(struct _GObject *, struct _GtkTreePath *);
// gtk_tree_row_reference_free
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 173
void gtk_tree_row_reference_free(struct _GtkTreeRowReference *);
// gtk_tree_row_reference_get_path
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 169
struct _GtkTreePath * gtk_tree_row_reference_get_path(struct _GtkTreeRowReference *);
// gtk_tree_row_reference_new_proxy
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 166
struct _GtkTreeRowReference * gtk_tree_row_reference_new_proxy(struct _GObject *, struct _GtkTreeModel *, struct _GtkTreePath *);
// gtk_tree_selection_get_selected
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 92
signed int gtk_tree_selection_get_selected(struct _GtkTreeSelection *, struct _GtkTreeModel **, struct _GtkTreeIter *);
// gtk_tree_selection_get_selected_rows
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 95
struct _GList * gtk_tree_selection_get_selected_rows(struct _GtkTreeSelection *, struct _GtkTreeModel **);
// gtk_tree_selection_select_iter
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 105
void gtk_tree_selection_select_iter(struct _GtkTreeSelection *, struct _GtkTreeIter *);
// gtk_tree_selection_set_mode
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 78
void gtk_tree_selection_set_mode(struct _GtkTreeSelection *, enum anonymous$78);
// gtk_tree_sortable_get_type
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 81
unsigned long int gtk_tree_sortable_get_type(void);
// gtk_tree_sortable_set_default_sort_func
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 95
void gtk_tree_sortable_set_default_sort_func(struct _GtkTreeSortable *, signed int (*)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *), void *, void (*)(void *));
// gtk_tree_sortable_set_sort_column_id
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 87
void gtk_tree_sortable_set_sort_column_id(struct _GtkTreeSortable *, signed int, enum anonymous$151);
// gtk_tree_view_append_column
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 167
signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_new_with_attributes
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 128
struct _GtkTreeViewColumn * gtk_tree_view_column_new_with_attributes(const char *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_column_set_min_width
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 171
void gtk_tree_view_column_set_min_width(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_column_set_sort_column_id
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 207
void gtk_tree_view_column_set_sort_column_id(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_columns_autosize
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 158
void gtk_tree_view_columns_autosize(struct _GtkTreeView *);
// gtk_tree_view_get_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 145
struct _GtkTreeModel * gtk_tree_view_get_model(struct _GtkTreeView *);
// gtk_tree_view_get_path_at_pos
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 246
signed int gtk_tree_view_get_path_at_pos(struct _GtkTreeView *, signed int, signed int, struct _GtkTreePath **, struct _GtkTreeViewColumn **, signed int *, signed int *);
// gtk_tree_view_get_selection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 148
struct _GtkTreeSelection * gtk_tree_view_get_selection(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 140
unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_new_with_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 142
struct _GtkWidget * gtk_tree_view_new_with_model(struct _GtkTreeModel *);
// gtk_tree_view_set_headers_visible
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 156
void gtk_tree_view_set_headers_visible(struct _GtkTreeView *, signed int);
// gtk_tree_view_set_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 146
void gtk_tree_view_set_model(struct _GtkTreeView *, struct _GtkTreeModel *);
// gtk_ui_manager_add_ui
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 138
void gtk_ui_manager_add_ui(struct _GtkUIManager *, unsigned int, const char *, const char *, const char *, enum anonymous$16, signed int);
// gtk_ui_manager_add_ui_from_file
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 135
unsigned int gtk_ui_manager_add_ui_from_file(struct _GtkUIManager *, const char *, struct _GError **);
// gtk_ui_manager_ensure_update
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 148
void gtk_ui_manager_ensure_update(struct _GtkUIManager *);
// gtk_ui_manager_get_accel_group
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 124
struct _GtkAccelGroup * gtk_ui_manager_get_accel_group(struct _GtkUIManager *);
// gtk_ui_manager_get_action
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 129
struct _GtkAction * gtk_ui_manager_get_action(struct _GtkUIManager *, const char *);
// gtk_ui_manager_get_widget
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 125
struct _GtkWidget * gtk_ui_manager_get_widget(struct _GtkUIManager *, const char *);
// gtk_ui_manager_insert_action_group
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 118
void gtk_ui_manager_insert_action_group(struct _GtkUIManager *, struct _GtkActionGroup *, signed int);
// gtk_ui_manager_new
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 114
struct _GtkUIManager * gtk_ui_manager_new(void);
// gtk_ui_manager_new_merge_id
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 149
unsigned int gtk_ui_manager_new_merge_id(struct _GtkUIManager *);
// gtk_ui_manager_remove_ui
// file /usr/include/gtk-2.0/gtk/gtkuimanager.h line 145
void gtk_ui_manager_remove_ui(struct _GtkUIManager *, unsigned int);
// gtk_vbox_get_type
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 62
unsigned long int gtk_vbox_get_type(void);
// gtk_vbox_new
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 63
struct _GtkWidget * gtk_vbox_new(signed int, signed int);
// gtk_vscrollbar_new
// file /usr/include/gtk-2.0/gtk/gtkvscrollbar.h line 70
struct _GtkWidget * gtk_vscrollbar_new(struct _GtkAdjustment *);
// gtk_widget_add_events
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1044
void gtk_widget_add_events(struct _GtkWidget *, signed int);
// gtk_widget_create_pango_context
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1187
struct _PangoContext * gtk_widget_create_pango_context(struct _GtkWidget *);
// gtk_widget_destroy
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 837
void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_destroyed
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 838
void gtk_widget_destroyed(struct _GtkWidget *, struct _GtkWidget **);
// gtk_widget_ensure_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1140
void gtk_widget_ensure_style(struct _GtkWidget *);
// gtk_widget_get_display
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1058
struct _GdkDisplay * gtk_widget_get_display(struct _GtkWidget *);
// gtk_widget_get_modifier_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1145
struct _GtkRcStyle * gtk_widget_get_modifier_style(struct _GtkWidget *);
// gtk_widget_get_name
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 958
const char * gtk_widget_get_name(struct _GtkWidget *);
// gtk_widget_get_parent
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 999
struct _GtkWidget * gtk_widget_get_parent(struct _GtkWidget *);
// gtk_widget_get_pointer
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1115
void gtk_widget_get_pointer(struct _GtkWidget *, signed int *, signed int *);
// gtk_widget_get_screen
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1056
struct _GdkScreen * gtk_widget_get_screen(struct _GtkWidget *);
// gtk_widget_get_settings
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1060
struct _GtkSettings * gtk_widget_get_settings(struct _GtkWidget *);
// gtk_widget_get_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1141
struct _GtkStyle * gtk_widget_get_style(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_grab_focus
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 942
void gtk_widget_grab_focus(struct _GtkWidget *);
// gtk_widget_hide
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 853
void gtk_widget_hide(struct _GtkWidget *);
// gtk_widget_modify_base
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1155
void gtk_widget_modify_base(struct _GtkWidget *, enum anonymous$23, const struct _GdkColor *);
// gtk_widget_modify_font
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1161
void gtk_widget_modify_font(struct _GtkWidget *, struct _PangoFontDescription *);
// gtk_widget_modify_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1143
void gtk_widget_modify_style(struct _GtkWidget *, struct _GtkRcStyle *);
// gtk_widget_modify_text
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1152
void gtk_widget_modify_text(struct _GtkWidget *, enum anonymous$23, const struct _GdkColor *);
// gtk_widget_reset_rc_styles
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1205
void gtk_widget_reset_rc_styles(struct _GtkWidget *);
// gtk_widget_set_app_paintable
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 986
void gtk_widget_set_app_paintable(struct _GtkWidget *, signed int);
// gtk_widget_set_name
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 956
void gtk_widget_set_name(struct _GtkWidget *, const char *);
// gtk_widget_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 964
void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_set_size_request
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1027
void gtk_widget_set_size_request(struct _GtkWidget *, signed int, signed int);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_show_all
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 854
void gtk_widget_show_all(struct _GtkWidget *);
// gtk_widget_size_request
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 886
void gtk_widget_size_request(struct _GtkWidget *, struct _GtkRequisition *);
// gtk_window_add_accel_group
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 191
void gtk_window_add_accel_group(struct _GtkWindow *, struct _GtkAccelGroup *);
// gtk_window_get_focus
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 200
struct _GtkWidget * gtk_window_get_focus(struct _GtkWindow *);
// gtk_window_get_position
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 382
void gtk_window_get_position(struct _GtkWindow *, signed int *, signed int *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_is_active
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 255
signed int gtk_window_is_active(struct _GtkWindow *);
// gtk_window_maximize
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 337
void gtk_window_maximize(struct _GtkWindow *);
// gtk_window_move
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 379
void gtk_window_move(struct _GtkWindow *, signed int, signed int);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous$149);
// gtk_window_present
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 330
void gtk_window_present(struct _GtkWindow *);
// gtk_window_set_default_size
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 367
void gtk_window_set_default_size(struct _GtkWindow *, signed int, signed int);
// gtk_window_set_icon
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 285
void gtk_window_set_icon(struct _GtkWindow *, struct _GdkPixbuf *);
// gtk_window_set_resizable
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 237
void gtk_window_set_resizable(struct _GtkWindow *, signed int);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// gtk_window_set_transient_for
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 206
void gtk_window_set_transient_for(struct _GtkWindow *, struct _GtkWindow *);
// gtk_window_set_urgency_hint
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 221
void gtk_window_set_urgency_hint(struct _GtkWindow *, signed int);
// idle_create_tray
// file widgets/gm-app-view.c line 1738
signed int idle_create_tray(void *user_data);
// idle_notification_expired
// file widgets/eggnotificationbubble.c line 371
static signed int idle_notification_expired(void *data);
// idle_proceed_addrinfo
// file gm-net.c line 478
static signed int idle_proceed_addrinfo(void *user_data);
// idle_proceed_connect_next
// file gm-net.c line 377
static signed int idle_proceed_connect_next(void *user_data);
// idle_scroll
// file widgets/gm-world-input-view.c line 348
signed int idle_scroll(void *user_data);
// libgnomeui_module_info_get
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-ui-init.h line 38
const struct _GnomeModuleInfo * libgnomeui_module_info_get(void);
// lines_match
// file widgets/gm-searchable.c line 252
static signed int lines_match(const struct _GtkTextIter *start, const char **lines, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end);
// localeconv
// file /usr/include/locale.h line 127
extern struct lconv * localeconv(void);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// modify_cursor_color
// file gm-support.c line 690
static void modify_cursor_color(struct _GtkWidget *textview, struct _GdkColor *color);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// mutex_unlock
// file gm-net.c line 434
void mutex_unlock(void *ptr);
// nameinfo_thread
// file gm-net.c line 439
void * nameinfo_thread(void *ptr);
// nameinfo_thread::1::2::__cancel_routine$object
// 
void __cancel_routine$object(void *);
// new_tag_style
// file widgets/gm-source-style-scheme.c line 103
static struct _GtkTextTag * new_tag_style(const char *foreground, const char *background, signed int bold, signed int italic);
// notify_init
// file /usr/include/libnotify/notify.h line 33
signed int notify_init(const char *);
// notify_is_initted
// file /usr/include/libnotify/notify.h line 35
signed int notify_is_initted(void);
// notify_notification_add_action
// file /usr/include/libnotify/notification.h line 176
void notify_notification_add_action(struct _NotifyNotification *, const char *, const char *, void (*)(struct _NotifyNotification *, char *, void *), void *, void (*)(void *));
// notify_notification_close
// file /usr/include/libnotify/notification.h line 184
signed int notify_notification_close(struct _NotifyNotification *, struct _GError **);
// notify_notification_new
// file /usr/include/libnotify/notification.h line 114
struct _NotifyNotification * notify_notification_new(const char *, const char *, const char *);
// notify_notification_set_hint_int32
// file /usr/include/libnotify/notification.h line 142
void notify_notification_set_hint_int32(struct _NotifyNotification *, const char *, signed int);
// notify_notification_set_icon_from_pixbuf
// file /usr/include/libnotify/notification.h line 139
void notify_notification_set_icon_from_pixbuf(struct _NotifyNotification *, struct _GdkPixbuf *);
// notify_notification_set_timeout
// file /usr/include/libnotify/notification.h line 126
void notify_notification_set_timeout(struct _NotifyNotification *, signed int);
// notify_notification_show
// file /usr/include/libnotify/notification.h line 123
signed int notify_notification_show(struct _NotifyNotification *, struct _GError **);
// on_action_edit_copy
// file ./widgets/gm-commands.h line 13
void on_action_edit_copy(struct _GtkAction *action, struct _GmAppView *view);
// on_action_edit_cut
// file ./widgets/gm-commands.h line 12
void on_action_edit_cut(struct _GtkAction *action, struct _GmAppView *view);
// on_action_edit_paste
// file ./widgets/gm-commands.h line 14
void on_action_edit_paste(struct _GtkAction *action, struct _GmAppView *view);
// on_action_edit_preferences
// file ./widgets/gm-commands.h line 17
void on_action_edit_preferences(struct _GtkAction *action, struct _GmAppView *view);
// on_action_edit_scripts
// file ./widgets/gm-commands.h line 18
void on_action_edit_scripts(struct _GtkAction *action, struct _GmAppView *view);
// on_action_edit_triggers
// file ./widgets/gm-commands.h line 28
void on_action_edit_triggers(struct _GtkAction *action, struct _GmAppView *view);
// on_action_edit_world
// file ./widgets/gm-commands.h line 16
void on_action_edit_world(struct _GtkAction *action, struct _GmAppView *view);
// on_action_edit_worlds
// file ./widgets/gm-commands.h line 15
void on_action_edit_worlds(struct _GtkAction *action, struct _GmAppView *view);
// on_action_editor_close
// file ./widgets/gm-commands.h line 26
void on_action_editor_close(struct _GtkAction *action, struct _GmAppView *view);
// on_action_editor_save
// file ./widgets/gm-commands.h line 23
void on_action_editor_save(struct _GtkAction *action, struct _GmAppView *view);
// on_action_editor_save_close
// file ./widgets/gm-commands.h line 24
void on_action_editor_save_close(struct _GtkAction *action, struct _GmAppView *view);
// on_action_help_about
// file ./widgets/gm-commands.h line 30
void on_action_help_about(struct _GtkAction *action, struct _GmAppView *view);
// on_action_view_toolbar
// file ./widgets/gm-commands.h line 20
void on_action_view_toolbar(struct _GtkAction *action, struct _GmAppView *view);
// on_action_view_userlist
// file ./widgets/gm-commands.h line 21
void on_action_view_userlist(struct _GtkAction *action, struct _GmAppView *view);
// on_action_world_close
// file ./widgets/gm-commands.h line 9
void on_action_world_close(struct _GtkAction *action, struct _GmAppView *view);
// on_action_world_connect
// file ./widgets/gm-commands.h line 6
void on_action_world_connect(struct _GtkAction *action, struct _GmAppView *view);
// on_action_world_logs
// file ./widgets/gm-commands.h line 8
void on_action_world_logs(struct _GtkAction *action, struct _GmAppView *view);
// on_action_world_new
// file ./widgets/gm-commands.h line 4
void on_action_world_new(struct _GtkAction *action, struct _GmAppView *view);
// on_action_world_open
// file ./widgets/gm-commands.h line 5
void on_action_world_open(struct _GtkAction *action, struct _GmAppView *view);
// on_action_world_paste
// file ./widgets/gm-commands.h line 7
void on_action_world_paste(struct _GtkAction *action, struct _GmAppView *view);
// on_action_world_quit
// file ./widgets/gm-commands.h line 10
void on_action_world_quit(struct _GtkAction *action, struct _GmAppView *view);
// on_adj_changed
// file mcp/gm-mcp-userlist-view.c line 270
static void on_adj_changed(struct _GtkAdjustment *adj, struct _GmMcpUserlistView *view);
// on_button_add_action_clicked
// file dialogs/gm-triggers-dialog.c line 997
void on_button_add_action_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers);
// on_button_add_condition_clicked
// file dialogs/gm-triggers-dialog.c line 992
void on_button_add_condition_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers);
// on_button_add_trigger_clicked
// file dialogs/gm-world-properties-dialog.c line 701
void on_button_add_trigger_clicked(struct _GtkButton *button, struct _GmWorldPropertiesDialog *properties);
// on_button_browse_clicked
// file dialogs/gm-triggers-dialog.c line 831
void on_button_browse_clicked(struct _GtkButton *widget, struct _GtkEntry *entry);
// on_button_delete_trigger_clicked
// file dialogs/gm-world-properties-dialog.c line 747
void on_button_delete_trigger_clicked(struct _GtkButton *button, struct _GmWorldPropertiesDialog *properties);
// on_button_edit_trigger_clicked
// file dialogs/gm-world-properties-dialog.c line 726
void on_button_edit_trigger_clicked(struct _GtkButton *button, struct _GmWorldPropertiesDialog *properties);
// on_button_next_clicked
// file dialogs/gm-triggers-dialog.c line 675
void on_button_next_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers);
// on_button_remove_clicked
// file dialogs/gm-triggers-dialog.c line 986
void on_button_remove_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers);
// on_color_changed
// file gm-support.c line 729
void on_color_changed(struct _GmColorTable *table, const char *color, struct _GtkWidget *widget);
// on_combo_box_type_changed
// file dialogs/gm-triggers-dialog.c line 892
void on_combo_box_type_changed(struct _GtkComboBox *widget, struct _ComboBoxTypeData *tdata);
// on_combo_box_type_destroy
// file dialogs/gm-triggers-dialog.c line 938
void on_combo_box_type_destroy(struct _GtkObject *object, struct _ComboBoxTypeData *tdata);
// on_font_changed
// file gm-support.c line 753
void on_font_changed(struct _GmColorTable *table, const char *font, struct _GtkWidget *widget);
// on_gm_app_save_session
// file gm-app.c line 226
static signed int on_gm_app_save_session(struct _GnomeClient *client, signed int phase, enum anonymous$55 save_style, signed int is_shutdown, enum anonymous$53 interact_style, signed int is_fast, char **client_data);
// on_gm_app_session_die
// file gm-app.c line 221
static void on_gm_app_session_die(struct _GnomeClient *client, void *client_data);
// on_gm_app_view_accel_cycle_page
// file widgets/gm-app-view.c line 1168
void on_gm_app_view_accel_cycle_page(struct _GtkAccelGroup *accelgroup, struct _GObject *arg1, unsigned int arg2, enum anonymous$0 arg3, struct _AccelInfo *info);
// on_gm_app_view_accel_switch_edit
// file widgets/gm-app-view.c line 1158
void on_gm_app_view_accel_switch_edit(struct _GtkAccelGroup *accelgroup, struct _GObject *arg1, unsigned int arg2, enum anonymous$0 arg3, struct _AccelInfo *info);
// on_gm_app_view_accel_switch_page
// file widgets/gm-app-view.c line 1151
void on_gm_app_view_accel_switch_page(struct _GtkAccelGroup *accelgroup, struct _GObject *arg1, unsigned int arg2, enum anonymous$0 arg3, struct _AccelInfo *info);
// on_gm_app_view_button_find_clicked
// file widgets/gm-app-view.c line 1283
void on_gm_app_view_button_find_clicked(struct _GtkButton *button, void *user_data);
// on_gm_app_view_button_find_close_clicked
// file widgets/gm-app-view.c line 1331
void on_gm_app_view_button_find_close_clicked(struct _GtkButton *button, struct _GmAppView *view);
// on_gm_app_view_button_replace_all_clicked
// file widgets/gm-app-view.c line 1298
void on_gm_app_view_button_replace_all_clicked(struct _GtkButton *button, struct _GmAppView *view);
// on_gm_app_view_button_replace_clicked
// file widgets/gm-app-view.c line 1288
void on_gm_app_view_button_replace_clicked(struct _GtkButton *button, struct _GmAppView *view);
// on_gm_app_view_check_button_search_direction_toggled
// file widgets/gm-app-view.c line 1352
void on_gm_app_view_check_button_search_direction_toggled(struct _GtkToggleButton *button, struct _GmAppView *view);
// on_gm_app_view_check_button_search_sensitive_toggled
// file widgets/gm-app-view.c line 1343
void on_gm_app_view_check_button_search_sensitive_toggled(struct _GtkToggleButton *button, struct _GmAppView *view);
// on_gm_app_view_edit_find
// file widgets/gm-app-view.c line 1256
void on_gm_app_view_edit_find(struct _GtkMenuItem *menuitem, struct _GmAppView *view);
// on_gm_app_view_edit_find_next
// file widgets/gm-app-view.c line 1265
void on_gm_app_view_edit_find_next(struct _GtkMenuItem *menuitem, struct _GmAppView *view);
// on_gm_app_view_edit_replace
// file widgets/gm-app-view.c line 1274
void on_gm_app_view_edit_replace(struct _GtkMenuItem *menuitem, struct _GmAppView *view);
// on_gm_app_view_entry_find_activate
// file widgets/gm-app-view.c line 1236
void on_gm_app_view_entry_find_activate(struct _GtkEntry *entry, struct _GmAppView *view);
// on_gm_app_view_entry_find_changed
// file widgets/gm-app-view.c line 1231
void on_gm_app_view_entry_find_changed(struct _GtkEditable *editable, struct _GmAppView *view);
// on_gm_app_view_entry_find_key_press
// file widgets/gm-app-view.c line 1319
signed int on_gm_app_view_entry_find_key_press(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GmAppView *view);
// on_gm_app_view_expander_replace
// file widgets/gm-app-view.c line 1306
void on_gm_app_view_expander_replace(struct _GObject *object, struct _GParamSpec *param_spec, struct _GmAppView *view);
// on_gm_app_view_motion_notify
// file widgets/gm-app-view.c line 1477
signed int on_gm_app_view_motion_notify(struct _GtkWidget *widget, struct _GdkEventMotion *event, struct _GmAppView *view);
// on_gm_app_view_notebook_button_press
// file widgets/gm-app-view.c line 1505
signed int on_gm_app_view_notebook_button_press(struct _GtkNotebook *notebook, struct _GdkEventButton *event, struct _GmAppView *view);
// on_gm_app_view_notebook_button_release
// file widgets/gm-app-view.c line 1537
signed int on_gm_app_view_notebook_button_release(struct _GtkNotebook *notebook, struct _GdkEventButton *event, struct _GmAppView *view);
// on_gm_app_view_notebook_switch_page
// file widgets/gm-app-view.c line 1626
void on_gm_app_view_notebook_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num, struct _GmAppView *view);
// on_gm_app_view_option_changed
// file widgets/gm-app-view.c line 1763
void on_gm_app_view_option_changed(struct _GmOptions *options, const char *key, struct _GmAppView *view);
// on_gm_app_view_tray_button_press
// file widgets/gm-app-view.c line 1714
signed int on_gm_app_view_tray_button_press(struct _GmTray *tray, struct _GdkEventButton *event, struct _GmAppView *view);
// on_gm_app_view_tray_destroy
// file widgets/gm-app-view.c line 1754
void on_gm_app_view_tray_destroy(struct _GtkWidget *caller, struct _GmAppView *view);
// on_gm_app_view_tray_message_clicked
// file widgets/gm-app-view.c line 1728
void on_gm_app_view_tray_message_clicked(struct _GmTray *tray, struct _GmAppView *view);
// on_gm_app_view_world_activate
// file widgets/gm-app-view.c line 1183
void on_gm_app_view_world_activate(struct _GtkAction *action, struct _GmWorld *world);
// on_gm_app_view_world_activate_request
// file widgets/gm-app-view.c line 1134
void on_gm_app_view_world_activate_request(struct _GmWorld *world, struct _GmAppView *view);
// on_gm_app_view_world_active_changed
// file widgets/gm-app-view.c line 1661
void on_gm_app_view_world_active_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmAppView *view);
// on_gm_app_view_world_activity_changed
// file widgets/gm-app-view.c line 1686
void on_gm_app_view_world_activity_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmAppView *view);
// on_gm_app_view_world_added
// file widgets/gm-app-view.c line 1016
void on_gm_app_view_world_added(struct _GmApp *app, struct _GmWorld *world, struct _GmAppView *view);
// on_gm_app_view_world_close_from_tab
// file widgets/gm-app-view.c line 999
void on_gm_app_view_world_close_from_tab(struct _GmWorldTab *tab, struct _GmWorld *world);
// on_gm_app_view_world_load
// file widgets/gm-app-view.c line 1091
void on_gm_app_view_world_load(struct _GmWorld *world, struct _GmAppView *view);
// on_gm_app_view_world_mcp_package_created
// file widgets/gm-app-view.c line 1692
void on_gm_app_view_world_mcp_package_created(struct _GmMcpSession *session, struct _GmMcpPackage *package, struct _GmAppView *view);
// on_gm_app_view_world_name_changed
// file widgets/gm-app-view.c line 1004
void on_gm_app_view_world_name_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmAppView *view);
// on_gm_app_view_world_notify_message
// file widgets/gm-app-view.c line 1139
void on_gm_app_view_world_notify_message(struct _GmWorld *world, const char *message, struct _GmAppView *view);
// on_gm_app_view_world_removed
// file widgets/gm-app-view.c line 794
void on_gm_app_view_world_removed(struct _GmApp *app, struct _GmWorld *world, struct _GmAppView *view);
// on_gm_app_view_world_state_changing
// file widgets/gm-app-view.c line 1074
void on_gm_app_view_world_state_changing(struct _GmWorld *world, enum _GmNetState state, struct _GmAppView *view);
// on_gm_app_view_world_unload
// file widgets/gm-app-view.c line 1116
void on_gm_app_view_world_unload(struct _GmWorld *world, struct _GmAppView *view);
// on_gm_app_view_world_view_destroy
// file widgets/gm-app-view.c line 1698
void on_gm_app_view_world_view_destroy(struct _GmWorldView *world_view, struct _GmAppView *view);
// on_gm_app_view_world_view_notebook_switch_page
// file widgets/gm-app-view.c line 1561
void on_gm_app_view_world_view_notebook_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *p, unsigned int page_num, struct _GmAppView *view);
// on_gm_color_table_monospace_font_change_notify
// file gm-color-table.c line 643
static void on_gm_color_table_monospace_font_change_notify(struct _GConfClient *client, unsigned int cnxn_id, struct _GConfEntry *entry, void *user_data);
// on_gm_editor_view_editor_saved
// file widgets/gm-editor-view.c line 649
void on_gm_editor_view_editor_saved(struct _GmEditor *editor, struct _GmEditorView *view);
// on_gm_editor_view_font_changed
// file widgets/gm-editor-view.c line 635
void on_gm_editor_view_font_changed(struct _GmColorTable *color_table, const char *desc, struct _GmEditorView *view);
// on_gm_editor_view_modified_changed
// file widgets/gm-editor-view.c line 655
void on_gm_editor_view_modified_changed(struct _GtkTextBuffer *buffer, struct _GmEditorView *view);
// on_gm_embedded_view_exited
// file widgets/gm-embedded-view.c line 197
void on_gm_embedded_view_exited(struct _VteTerminal *vte, struct _GmEmbeddedView *embedded);
// on_gm_embedded_view_file_changed
// file widgets/gm-embedded-view.c line 177
void on_gm_embedded_view_file_changed(struct GnomeVFSMonitorHandle *handle, const char *monitor_uri, const char *info_uri, enum anonymous$102 event_type, struct _GmEmbeddedView *embedded);
// on_gm_embedded_view_font_changed
// file widgets/gm-embedded-view.c line 202
void on_gm_embedded_view_font_changed(struct _GmColorTable *color_table, const char *desc, struct _GmEmbeddedView *view);
// on_gm_external_view_exited
// file widgets/gm-external-view.c line 243
void on_gm_external_view_exited(signed int pid, signed int status, struct _GmExternalView *view);
// on_gm_external_view_file_changed
// file widgets/gm-external-view.c line 248
void on_gm_external_view_file_changed(struct GnomeVFSMonitorHandle *handle, const char *monitor_uri, const char *info_uri, enum anonymous$102 event_type, struct _GmExternalView *view);
// on_gm_log_view_filter_toggled
// file widgets/gm-log-view.c line 268
void on_gm_log_view_filter_toggled(struct _GtkToggleButton *button, struct _GmLogView *view);
// on_gm_mcp_awns_status_view_status_changed
// file mcp/gm-mcp-awns-status.c line 96
void on_gm_mcp_awns_status_view_status_changed(struct _GmMcpAwnsStatus *package, const char *status, struct _GmMcpAwnsStatusView *view);
// on_gm_mcp_awns_status_view_weak_notify
// file mcp/gm-mcp-awns-status.c line 102
void on_gm_mcp_awns_status_view_weak_notify(void *data, struct _GObject *obj);
// on_gm_mcp_icecrew_serverinfo_view_activate
// file mcp/gm-mcp-icecrew-serverinfo.c line 304
void on_gm_mcp_icecrew_serverinfo_view_activate(struct _GtkMenuItem *item, struct _GmMcpIcecrewServerinfoView *view);
// on_gm_mcp_icecrew_serverinfo_view_active_changed
// file mcp/gm-mcp-icecrew-serverinfo.c line 331
void on_gm_mcp_icecrew_serverinfo_view_active_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmMcpIcecrewServerinfoView *view);
// on_gm_mcp_icecrew_serverinfo_view_got_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 358
void on_gm_mcp_icecrew_serverinfo_view_got_info(struct _GmMcpIcecrewServerinfo *package, struct _GmMcpIcecrewServerinfoView *view);
// on_gm_mcp_icecrew_serverinfo_view_weak_notify
// file mcp/gm-mcp-icecrew-serverinfo.c line 343
void on_gm_mcp_icecrew_serverinfo_view_weak_notify(void *data, struct _GObject *obj);
// on_gm_mcp_icecrew_userlist_add
// file mcp/gm-mcp-icecrew-userlist.c line 1212
void on_gm_mcp_icecrew_userlist_add(struct _GmMcpIcecrewPlayerdb *playerdb, struct _GmPlayerdbPlayerInfo *ppi, struct _GmMcpIcecrewUserlist *userlist);
// on_gm_mcp_icecrew_userlist_delete
// file mcp/gm-mcp-icecrew-userlist.c line 1240
void on_gm_mcp_icecrew_userlist_delete(struct _GmMcpIcecrewPlayerdb *playerdb, struct _GmPlayerdbPlayerInfo *ppi, struct _GmMcpIcecrewUserlist *userlist);
// on_gm_mcp_icecrew_userlist_set
// file mcp/gm-mcp-icecrew-userlist.c line 1222
void on_gm_mcp_icecrew_userlist_set(struct _GmMcpIcecrewPlayerdb *playerdb, struct _GmPlayerdbPlayerInfo *ppi, const char *key, const char *value, const char *old, struct _GmMcpIcecrewUserlist *userlist);
// on_gm_mcp_mud_moo_simpleedit_editor_save
// file mcp/gm-mcp-mud-moo-simpleedit.c line 187
void on_gm_mcp_mud_moo_simpleedit_editor_save(struct _GmEditor *editor, struct _GmMcpMudMooSimpleedit *package);
// on_gm_mcp_userlist_view_button_press
// file mcp/gm-mcp-userlist-view.c line 863
static signed int on_gm_mcp_userlist_view_button_press(struct _GtkWidget *widget, struct _GdkEventButton *event, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_menuitem_activate
// file mcp/gm-mcp-userlist-view.c line 763
static void on_gm_mcp_userlist_view_menuitem_activate(struct _GtkMenuItem *item, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_name_changed
// file mcp/gm-mcp-userlist-view.c line 666
static void on_gm_mcp_userlist_view_name_changed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_option_changed
// file mcp/gm-mcp-userlist-view.c line 562
static void on_gm_mcp_userlist_view_option_changed(struct _GmOptions *options, const char *key, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_player_added
// file mcp/gm-mcp-userlist-view.c line 603
static void on_gm_mcp_userlist_view_player_added(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_player_removed
// file mcp/gm-mcp-userlist-view.c line 645
static void on_gm_mcp_userlist_view_player_removed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_popup_menu
// file mcp/gm-mcp-userlist-view.c line 857
static signed int on_gm_mcp_userlist_view_popup_menu(struct _GtkWidget *widget, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_rank_changed
// file mcp/gm-mcp-userlist-view.c line 686
static void on_gm_mcp_userlist_view_rank_changed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_state_changed
// file mcp/gm-mcp-userlist-view.c line 709
static void on_gm_mcp_userlist_view_state_changed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view);
// on_gm_mcp_userlist_view_weak_notify
// file mcp/gm-mcp-userlist-view.c line 529
static void on_gm_mcp_userlist_view_weak_notify(void *data, struct _GObject *obj);
// on_gm_mcp_vmoo_client_character_size_changed
// file mcp/gm-mcp-vmoo-client.c line 178
void on_gm_mcp_vmoo_client_character_size_changed(struct _GmWorldTextView *v, unsigned int width, unsigned int height, struct _GmMcpVmooClientView *view);
// on_gm_mcp_vmoo_client_text_view_size_allocate
// file mcp/gm-mcp-vmoo-client.c line 172
void on_gm_mcp_vmoo_client_text_view_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation, struct _GmMcpVmooClientView *view);
// on_gm_mcp_vmoo_client_view_weak_notify
// file mcp/gm-mcp-vmoo-client.c line 184
void on_gm_mcp_vmoo_client_view_weak_notify(void *data, struct _GObject *obj);
// on_gm_net_connect_check
// file gm-net.c line 690
signed int on_gm_net_connect_check(struct _GIOChannel *source, enum anonymous$69 condition, struct _GmNet *net);
// on_gm_net_connect_timeout
// file gm-net.c line 711
signed int on_gm_net_connect_timeout(struct _GmNet *net);
// on_gm_net_input_recv
// file gm-net.c line 644
signed int on_gm_net_input_recv(struct _GIOChannel *source, enum anonymous$69 condition, struct _GmNet *net);
// on_gm_open_world_dialog_response
// file dialogs/gm-open-world-dialog.c line 118
void on_gm_open_world_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data);
// on_gm_open_world_dialog_tree_view_worlds_row_activated
// file dialogs/gm-open-world-dialog.c line 132
void on_gm_open_world_dialog_tree_view_worlds_row_activated(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// on_gm_pixbuf_theme_changed
// file gm-pixbuf.c line 306
static void on_gm_pixbuf_theme_changed(struct _GtkIconTheme *theme, void *user_data);
// on_gm_preferences_dialog_check_button_alt_editor_clicked
// file dialogs/gm-preferences-dialog.c line 481
void on_gm_preferences_dialog_check_button_alt_editor_clicked(struct _GtkButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_embed_editor_clicked
// file dialogs/gm-preferences-dialog.c line 458
void on_gm_preferences_dialog_check_button_embed_editor_clicked(struct _GtkButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_logging_disable_all_toggled
// file dialogs/gm-preferences-dialog.c line 599
void on_gm_preferences_dialog_check_button_logging_disable_all_toggled(struct _GtkToggleButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_logging_toggled
// file dialogs/gm-preferences-dialog.c line 589
void on_gm_preferences_dialog_check_button_logging_toggled(struct _GtkToggleButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_needs_terminal_clicked
// file dialogs/gm-preferences-dialog.c line 508
void on_gm_preferences_dialog_check_button_needs_terminal_clicked(struct _GtkButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_show_object_number_toggled
// file dialogs/gm-preferences-dialog.c line 613
void on_gm_preferences_dialog_check_button_show_object_number_toggled(struct _GtkToggleButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_show_player_status_toggled
// file dialogs/gm-preferences-dialog.c line 621
void on_gm_preferences_dialog_check_button_show_player_status_toggled(struct _GtkToggleButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_system_font_clicked
// file dialogs/gm-preferences-dialog.c line 436
void on_gm_preferences_dialog_check_button_system_font_clicked(struct _GtkButton *button, void *user_data);
// on_gm_preferences_dialog_check_button_use_state_icon_toggled
// file dialogs/gm-preferences-dialog.c line 630
void on_gm_preferences_dialog_check_button_use_state_icon_toggled(struct _GtkToggleButton *button, void *user_data);
// on_gm_preferences_dialog_color_set
// file dialogs/gm-preferences-dialog.c line 543
void on_gm_preferences_dialog_color_set(struct _GtkColorButton *button, char *option);
// on_gm_preferences_dialog_combo_box_scheme_changed
// file dialogs/gm-preferences-dialog.c line 572
void on_gm_preferences_dialog_combo_box_scheme_changed(struct _GtkComboBox *box, void *user_data);
// on_gm_preferences_dialog_entry_alt_editor_focus_out
// file dialogs/gm-preferences-dialog.c line 528
signed int on_gm_preferences_dialog_entry_alt_editor_focus_out(struct _GtkEntry *entry, struct _GdkEventFocus *event, void *user_data);
// on_gm_preferences_dialog_font_set
// file dialogs/gm-preferences-dialog.c line 450
void on_gm_preferences_dialog_font_set(struct _GtkFontButton *button, void *user_data);
// on_gm_preferences_dialog_radio_button_sort_toggled
// file dialogs/gm-preferences-dialog.c line 640
void on_gm_preferences_dialog_radio_button_sort_toggled(struct _GtkToggleButton *button, void *user_data);
// on_gm_preferences_dialog_response
// file dialogs/gm-preferences-dialog.c line 423
void on_gm_preferences_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data);
// on_gm_source_style_scheme_color_changed
// file widgets/gm-source-style-scheme.c line 212
static void on_gm_source_style_scheme_color_changed(struct _GmColorTable *table, const char *color);
// on_gm_text_scroller_text_buffer_changed
// file widgets/gm-text-scroller.c line 312
void on_gm_text_scroller_text_buffer_changed(struct _GtkTextBuffer *text_buffer, struct _GmTextScroller *scroller);
// on_gm_text_scroller_text_view_destroy
// file widgets/gm-text-scroller.c line 321
void on_gm_text_scroller_text_view_destroy(struct _GtkTextView *text_view, struct _GmTextScroller *scroller);
// on_gm_text_scroller_text_view_notify
// file widgets/gm-text-scroller.c line 296
void on_gm_text_scroller_text_view_notify(struct _GtkTextView *text_view, struct _GParamSpec *arg1, struct _GmTextScroller *scroller);
// on_gm_text_scroller_text_view_size_allocate
// file widgets/gm-text-scroller.c line 226
void on_gm_text_scroller_text_view_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation, struct _GmTextScroller *scroller);
// on_gm_text_scroller_text_view_style_set
// file widgets/gm-text-scroller.c line 303
void on_gm_text_scroller_text_view_style_set(struct _GtkTextView *view, struct _GtkStyle *previous_style, struct _GmTextScroller *scroller);
// on_gm_world_editor_save
// file gm-world.c line 1293
static void on_gm_world_editor_save(struct _GmEditor *editor, struct _GmWorld *world);
// on_gm_world_info_dialog_url_button_release
// file dialogs/gm-world-info-dialog.c line 127
signed int on_gm_world_info_dialog_url_button_release(struct _GtkWidget *label, struct _GdkEventButton *event, char *prefix);
// on_gm_world_input_view_changed
// file widgets/gm-world-input-view.c line 360
void on_gm_world_input_view_changed(struct _GtkTextBuffer *buffer, struct _GmWorldInputView *view);
// on_gm_world_input_view_world_text_activate
// file widgets/gm-world-view.c line 740
void on_gm_world_input_view_world_text_activate(struct _GmWorldInputView *iview, char *text, struct _GmWorldView *view);
// on_gm_world_logs_dialog_row_activated
// file dialogs/gm-world-logs-dialog.c line 150
void on_gm_world_logs_dialog_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *arg1, struct _GtkTreeViewColumn *arg2, struct _GtkDialog *dlg);
// on_gm_world_net_bytes_recv
// file gm-world.c line 1369
static void on_gm_world_net_bytes_recv(struct _GmNet *net, char *text, signed int len, struct _GmWorld *world);
// on_gm_world_net_net_error
// file gm-world.c line 1362
static void on_gm_world_net_net_error(struct _GmNet *net, char *error, signed int code, struct _GmWorld *world);
// on_gm_world_net_state_changed
// file gm-world.c line 1349
static void on_gm_world_net_state_changed(struct _GmNet *net, enum _GmNetState state, struct _GmWorld *world);
// on_gm_world_net_state_changing
// file gm-world.c line 1312
static void on_gm_world_net_state_changing(struct _GmNet *net, enum _GmNetState state, struct _GmWorld *world);
// on_gm_world_options_option_changed
// file gm-world.c line 1420
static void on_gm_world_options_option_changed(struct _GmOptions *options, char *key, struct _GmWorld *world);
// on_gm_world_paste_dialog_active_world_changed
// file dialogs/gm-world-paste-dialog.c line 324
static void on_gm_world_paste_dialog_active_world_changed(struct _GmAppView *view, struct _GmWorldView *world_view);
// on_gm_world_paste_dialog_response
// file dialogs/gm-world-paste-dialog.c line 300
static void on_gm_world_paste_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data);
// on_gm_world_properties_dialog_app_world_removed
// file dialogs/gm-world-properties-dialog.c line 770
void on_gm_world_properties_dialog_app_world_removed(struct _GmApp *app, struct _GmWorld *world, struct _GmWorldPropertiesDialog *properties);
// on_gm_world_properties_dialog_check_button_logging_override_toggled
// file dialogs/gm-world-properties-dialog.c line 778
void on_gm_world_properties_dialog_check_button_logging_override_toggled(struct _GtkToggleButton *button, struct _GmWorldPropertiesDialog *properties);
// on_gm_world_properties_dialog_response
// file dialogs/gm-world-properties-dialog.c line 662
void on_gm_world_properties_dialog_response(struct _GtkDialog *dialog, signed int response, struct _GmWorldPropertiesDialog *properties);
// on_gm_world_tab_button_clicked
// file widgets/gm-world-tab.c line 196
void on_gm_world_tab_button_clicked(struct _GtkButton *button, struct _GmWorldTab *tab);
// on_gm_world_tab_world_activity_changed
// file widgets/gm-world-tab.c line 201
void on_gm_world_tab_world_activity_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmWorldTab *tab);
// on_gm_world_tab_world_name_changed
// file widgets/gm-world-tab.c line 207
void on_gm_world_tab_world_name_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmWorldTab *tab);
// on_gm_world_text_view_color_table_color_changed
// file widgets/gm-world-text-view.c line 1521
static void on_gm_world_text_view_color_table_color_changed(struct _GmColorTable *table, char *name, struct _GmWorldTextView *view);
// on_gm_world_text_view_color_table_font_changed
// file widgets/gm-world-text-view.c line 1537
static void on_gm_world_text_view_color_table_font_changed(struct _GmColorTable *table, char *font_description, struct _GmWorldTextView *view);
// on_gm_world_text_view_copy_address
// file widgets/gm-world-text-view.c line 1457
static void on_gm_world_text_view_copy_address(struct _GtkMenuItem *item, struct _GmWorldTextView *view);
// on_gm_world_text_view_event
// file widgets/gm-world-text-view.c line 1399
static signed int on_gm_world_text_view_event(struct _GmWorldTextView *view, struct _GdkEventMotion *event, struct _GtkTextTag *tag);
// on_gm_world_text_view_open_address
// file widgets/gm-world-text-view.c line 1467
static void on_gm_world_text_view_open_address(struct _GtkMenuItem *item, struct _GmWorldTextView *view);
// on_gm_world_text_view_url_event
// file widgets/gm-world-text-view.c line 1362
static signed int on_gm_world_text_view_url_event(struct _GtkTextTag *tag, struct _GObject *object, union _GdkEvent *event, struct _GtkTextIter *iter, struct _GmWorldTextView *view);
// on_gm_world_view_editor_save
// file widgets/gm-world-view.c line 756
void on_gm_world_view_editor_save(struct _GmEditor *editor, struct _GmWorldView *view);
// on_gm_world_view_editor_view_close_clicked
// file widgets/gm-world-view.c line 762
void on_gm_world_view_editor_view_close_clicked(struct _GtkButton *button, struct _GtkWidget *view);
// on_gm_world_view_editor_view_modified_changed
// file widgets/gm-world-view.c line 780
void on_gm_world_view_editor_view_modified_changed(struct _GmEditorView *editor_view, signed int modified, struct _GmWorldView *view);
// on_gm_world_view_log_view_close_clicked
// file widgets/gm-world-view.c line 773
void on_gm_world_view_log_view_close_clicked(struct _GtkButton *button, struct _GtkWidget *view);
// on_gm_world_view_world_active_changed
// file widgets/gm-world-view.c line 922
void on_gm_world_view_world_active_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmWorldView *view);
// on_gm_world_view_world_editor_added
// file widgets/gm-world-view.c line 811
void on_gm_world_view_world_editor_added(struct _GmWorld *world, struct _GmEditor *editor, struct _GmWorldView *view);
// on_gm_world_view_world_editor_removed
// file widgets/gm-world-view.c line 820
void on_gm_world_view_world_editor_removed(struct _GmWorld *world, struct _GmEditor *editor, struct _GmWorldView *view);
// on_gm_world_view_world_error
// file widgets/gm-world-view.c line 863
void on_gm_world_view_world_error(struct _GmWorld *world, char *text, signed int code, struct _GmWorldView *view);
// on_gm_world_view_world_highlight
// file widgets/gm-world-view.c line 930
void on_gm_world_view_world_highlight(struct _GmWorld *world, signed int start, signed int end, char *color, struct _GmWorldView *view);
// on_gm_world_view_world_input_view_key_pressed
// file widgets/gm-world-view.c line 974
signed int on_gm_world_view_world_input_view_key_pressed(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GmWorldView *view);
// on_gm_world_view_world_mcp_package_created
// file widgets/gm-world-view.c line 1011
void on_gm_world_view_world_mcp_package_created(struct _GmMcpSession *session, struct _GmMcpPackage *package, struct _GmWorldView *view);
// on_gm_world_view_world_state_changing
// file widgets/gm-world-view.c line 884
void on_gm_world_view_world_state_changing(struct _GmWorld *world, unsigned int state, struct _GmWorldView *view);
// on_gm_world_view_world_text_received
// file widgets/gm-world-view.c line 747
void on_gm_world_view_world_text_received(struct _GmWorld *world, char *text, struct _GmWorldView *view);
// on_gm_world_view_world_text_view_scroll_event
// file widgets/gm-world-view.c line 950
signed int on_gm_world_view_world_text_view_scroll_event(struct _GmWorldView *view, struct _GdkEventScroll *event, struct _GmWorldTextView *text);
// on_gm_world_view_world_text_view_url_activate
// file widgets/gm-world-view.c line 1017
void on_gm_world_view_world_text_view_url_activate(struct _GmWorldView *view, const char *url);
// on_gm_worlds_list_dialog_button_connect_clicked
// file dialogs/gm-worlds-list-dialog.c line 336
void on_gm_worlds_list_dialog_button_connect_clicked(struct _GtkButton *button, void *user_data);
// on_gm_worlds_list_dialog_button_delete_clicked
// file dialogs/gm-worlds-list-dialog.c line 274
void on_gm_worlds_list_dialog_button_delete_clicked(struct _GtkButton *button, void *user_data);
// on_gm_worlds_list_dialog_button_duplicate_clicked
// file dialogs/gm-worlds-list-dialog.c line 317
void on_gm_worlds_list_dialog_button_duplicate_clicked(struct _GtkButton *button, void *user_data);
// on_gm_worlds_list_dialog_button_modify_clicked
// file dialogs/gm-worlds-list-dialog.c line 311
void on_gm_worlds_list_dialog_button_modify_clicked(struct _GtkButton *button, void *user_data);
// on_gm_worlds_list_dialog_button_new_clicked
// file dialogs/gm-worlds-list-dialog.c line 305
void on_gm_worlds_list_dialog_button_new_clicked(struct _GtkButton *button, void *user_data);
// on_gm_worlds_list_dialog_response
// file dialogs/gm-worlds-list-dialog.c line 265
void on_gm_worlds_list_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data);
// on_gm_worlds_list_dialog_tree_view_worlds_key_press
// file dialogs/gm-worlds-list-dialog.c line 280
void on_gm_worlds_list_dialog_tree_view_worlds_key_press(struct _GtkWidget *widget, struct _GdkEventKey *event, void *user_data);
// on_gm_worlds_list_dialog_tree_view_worlds_row_activated
// file dialogs/gm-worlds-list-dialog.c line 298
void on_gm_worlds_list_dialog_tree_view_worlds_row_activated(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// on_gm_worlds_view_app_world_added
// file widgets/gm-worlds-view.c line 269
static void on_gm_worlds_view_app_world_added(struct _GmApp *app, struct _GmWorld *world, struct _GmWorldsView *view);
// on_gm_worlds_view_app_world_removed
// file widgets/gm-worlds-view.c line 275
static void on_gm_worlds_view_app_world_removed(struct _GmApp *app, struct _GmWorld *world, struct _GmWorldsView *view);
// on_gm_worlds_view_world_option_changed
// file widgets/gm-worlds-view.c line 235
static void on_gm_worlds_view_world_option_changed(struct _GmOptions *options, const char *key, struct _GmWorldsView *view);
// on_notebook_triggers_switch_page
// file dialogs/gm-triggers-dialog.c line 732
void on_notebook_triggers_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num, struct _GmTriggersDialog *triggers);
// on_row_deleted
// file mcp/gm-mcp-userlist-view.c line 122
static void on_row_deleted(struct _GtkTreeModel *model, struct _GtkTreePath *path, struct _GmMcpUserlistView *view);
// on_row_inserted
// file mcp/gm-mcp-userlist-view.c line 116
static void on_row_inserted(struct _GtkTreeModel *model, struct _GtkTreePath *path, struct _GtkTreeIter *iter, struct _GmMcpUserlistView *view);
// on_rows_reordered
// file mcp/gm-mcp-userlist-view.c line 110
static void on_rows_reordered(struct _GtkTreeModel *model, struct _GtkTreePath *path, struct _GtkTreeIter *iter, void *arg3, struct _GmMcpUserlistView *view);
// on_signal_quit
// file gm-app.c line 649
static void on_signal_quit(signed int signum);
// on_style_set
// file gm-support.c line 763
void on_style_set(struct _GtkWidget *widget, struct _GtkStyle *prev, void *user_data);
// on_tree_view_event_types_changed
// file dialogs/gm-triggers-dialog.c line 699
void on_tree_view_event_types_changed(struct _GtkTreeSelection *treeselection, struct _GmTriggersDialog *triggers);
// on_tree_view_triggers_row_activated
// file dialogs/gm-world-properties-dialog.c line 764
void on_tree_view_triggers_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *arg1, struct _GtkTreeViewColumn *arg2, struct _GmWorldPropertiesDialog *properties);
// on_widget_destroy
// file gm-support.c line 784
void on_widget_destroy(struct _GtkWidget *widget, void *data);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// paned_restore_size
// file widgets/gm-world-view.c line 448
static signed int paned_restore_size(struct _GmWorldView *view);
// pango_attr_foreground_new
// file /usr/include/pango-1.0/pango/pango-attributes.h line 444
struct _PangoAttribute * pango_attr_foreground_new(unsigned short int, unsigned short int, unsigned short int);
// pango_attr_list_insert
// file /usr/include/pango-1.0/pango/pango-attributes.h line 491
void pango_attr_list_insert(struct _PangoAttrList *, struct _PangoAttribute *);
// pango_attr_list_new
// file /usr/include/pango-1.0/pango/pango-attributes.h line 487
struct _PangoAttrList * pango_attr_list_new(void);
// pango_attr_list_unref
// file /usr/include/pango-1.0/pango/pango-attributes.h line 489
void pango_attr_list_unref(struct _PangoAttrList *);
// pango_attr_size_new
// file /usr/include/pango-1.0/pango/pango-attributes.h line 450
struct _PangoAttribute * pango_attr_size_new(signed int);
// pango_attr_style_new
// file /usr/include/pango-1.0/pango/pango-attributes.h line 452
struct _PangoAttribute * pango_attr_style_new(enum anonymous$4);
// pango_context_set_font_description
// file /usr/include/pango-1.0/pango/pango-context.h line 71
void pango_context_set_font_description(struct _PangoContext *, const struct _PangoFontDescription *);
// pango_font_description_copy
// file /usr/include/pango-1.0/pango/pango-font.h line 219
struct _PangoFontDescription * pango_font_description_copy(const struct _PangoFontDescription *);
// pango_font_description_free
// file /usr/include/pango-1.0/pango/pango-font.h line 224
void pango_font_description_free(struct _PangoFontDescription *);
// pango_font_description_from_string
// file /usr/include/pango-1.0/pango/pango-font.h line 270
struct _PangoFontDescription * pango_font_description_from_string(const char *);
// pango_font_description_get_size
// file /usr/include/pango-1.0/pango/pango-font.h line 247
signed int pango_font_description_get_size(const struct _PangoFontDescription *);
// pango_font_description_set_size
// file /usr/include/pango-1.0/pango/pango-font.h line 245
void pango_font_description_set_size(struct _PangoFontDescription *, signed int);
// pango_font_description_to_string
// file /usr/include/pango-1.0/pango/pango-font.h line 271
char * pango_font_description_to_string(const struct _PangoFontDescription *);
// pango_layout_get_pixel_size
// file /usr/include/pango-1.0/pango/pango-layout.h line 254
void pango_layout_get_pixel_size(struct _PangoLayout *, signed int *, signed int *);
// pango_layout_new
// file /usr/include/pango-1.0/pango/pango-layout.h line 138
struct _PangoLayout * pango_layout_new(struct _PangoContext *);
// pango_layout_set_text
// file /usr/include/pango-1.0/pango/pango-layout.h line 147
void pango_layout_set_text(struct _PangoLayout *, const char *, signed int);
// parse_error
// file list.c line 248
signed int parse_error(const char *e, signed int *i, char **s);
// pointer_from_offset_skipping_decomp
// file widgets/gm-searchable.c line 32
static const char * pointer_from_offset_skipping_decomp(const char *str, signed int offset);
// popup_menu_detach
// file mcp/gm-mcp-userlist-view.c line 755
static void popup_menu_detach(struct _GtkWidget *attach_widget, struct _GtkMenu *menu);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$66 *, const union anonymous$67 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$66 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$66 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$17 *, signed int);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// resolve_file
// file widgets/gm-external-view.c line 82
static char * resolve_file(const char *file);
// rindex
// file /usr/include/string.h line 516
extern char * rindex(const char *, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$75 *, struct anonymous$75 *, struct anonymous$75 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strbreakup
// file widgets/gm-searchable.c line 407
static char ** strbreakup(const char *string, const char *delimiter, signed int max_tokens);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// stream_append
// file list.c line 39
void stream_append(struct anonymous$90 *s, char c);
// stream_append_string
// file list.c line 49
void stream_append_string(struct anonymous$90 *s, const char *string);
// stream_append_string_quoted
// file list.c line 59
void stream_append_string_quoted(struct anonymous$90 *s, const char *string);
// stream_free
// file list.c line 72
void stream_free(struct anonymous$90 *s);
// stream_new
// file list.c line 28
struct anonymous$90 * stream_new(signed int len);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// subtract_rectangle
// file widgets/eggnotificationbubble.c line 267
static void subtract_rectangle(struct _GdkRegion *region, struct _GdkRectangle *rectangle);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// to_error
// file list.c line 304
char * to_error(signed int e);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vte_terminal_fork_command
// file /usr/include/vte-0.0/vte/vtedeprecated.h line 82
signed int vte_terminal_fork_command(struct _VteTerminal *, const char *, char **, char **, const char *, signed int, signed int, signed int);
// vte_terminal_get_type
// file /usr/include/vte-0.0/vte/vte.h line 261
unsigned long int vte_terminal_get_type(void);
// vte_terminal_new
// file /usr/include/vte-0.0/vte/vte.h line 263
struct _GtkWidget * vte_terminal_new(void);
// vte_terminal_set_allow_bold
// file /usr/include/vte-0.0/vte/vte.h line 389
void vte_terminal_set_allow_bold(struct _VteTerminal *, signed int);
// vte_terminal_set_audible_bell
// file /usr/include/vte-0.0/vte/vte.h line 305
void vte_terminal_set_audible_bell(struct _VteTerminal *, signed int);
// vte_terminal_set_font_from_string
// file /usr/include/vte-0.0/vte/vte.h line 387
void vte_terminal_set_font_from_string(struct _VteTerminal *, const char *);
// vte_terminal_set_scroll_on_keystroke
// file /usr/include/vte-0.0/vte/vte.h line 311
void vte_terminal_set_scroll_on_keystroke(struct _VteTerminal *, signed int);
// vte_terminal_set_scroll_on_output
// file /usr/include/vte-0.0/vte/vte.h line 310
void vte_terminal_set_scroll_on_output(struct _VteTerminal *, signed int);
// vte_terminal_set_scrollback_lines
// file /usr/include/vte-0.0/vte/vte.h line 378
void vte_terminal_set_scrollback_lines(struct _VteTerminal *, signed long int);
// vte_terminal_set_word_chars
// file /usr/include/vte-0.0/vte/vte.h line 398
void vte_terminal_set_word_chars(struct _VteTerminal *, const char *);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xmlDocGetRootElement
// file /usr/include/libxml2/libxml/tree.h line 920
struct _xmlNode * xmlDocGetRootElement(const struct _xmlDoc *);
// xmlDocSetRootElement
// file /usr/include/libxml2/libxml/tree.h line 933
struct _xmlNode * xmlDocSetRootElement(struct _xmlDoc *, struct _xmlNode *);
// xmlFree$object
// 
void xmlFree$object(void *);
// xmlFreeDoc
// file /usr/include/libxml2/libxml/tree.h line 782
void xmlFreeDoc(struct _xmlDoc *);
// xmlGetProp
// file /usr/include/libxml2/libxml/tree.h line 1029
unsigned char * xmlGetProp(const struct _xmlNode *, const unsigned char *);
// xmlNewChild
// file /usr/include/libxml2/libxml/tree.h line 844
struct _xmlNode * xmlNewChild(struct _xmlNode *, struct _xmlNs *, const unsigned char *, const unsigned char *);
// xmlNewDoc
// file /usr/include/libxml2/libxml/tree.h line 780
struct _xmlDoc * xmlNewDoc(const unsigned char *);
// xmlNewNode
// file /usr/include/libxml2/libxml/tree.h line 837
struct _xmlNode * xmlNewNode(struct _xmlNs *, const unsigned char *);
// xmlNewProp
// file /usr/include/libxml2/libxml/tree.h line 790
struct _xmlAttr * xmlNewProp(struct _xmlNode *, const unsigned char *, const unsigned char *);
// xmlParseFile
// file /usr/include/libxml2/libxml/parser.h line 844
struct _xmlDoc * xmlParseFile(const char *);
// xmlSaveFormatFileEnc
// file /usr/include/libxml2/libxml/tree.h line 1223
signed int xmlSaveFormatFileEnc(const char *, struct _xmlDoc *, const char *, signed int);
// xmlStrcmp
// file /usr/include/libxml2/libxml/xmlstring.h line 64
signed int xmlStrcmp(const unsigned char *, const unsigned char *);

struct anonymous$90
{
  // buf
  char *buf;
  // pos
  signed int pos;
  // len
  signed int len;
};

struct anonymous$31
{
  // name
  char *name;
  // valid_fields
  enum anonymous$27 valid_fields;
  // type
  enum anonymous$28 type;
  // permissions
  enum anonymous$29 permissions;
  // flags
  enum anonymous$30 flags;
  // device
  unsigned long int device;
  // inode
  unsigned long int inode;
  // link_count
  unsigned int link_count;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // size
  unsigned long int size;
  // block_count
  unsigned long int block_count;
  // io_block_size
  unsigned int io_block_size;
  // atime
  signed long int atime;
  // mtime
  signed long int mtime;
  // ctime
  signed long int ctime;
  // symlink_name
  char *symlink_name;
  // mime_type
  char *mime_type;
  // refcount
  unsigned int refcount;
  // acl
  struct _GnomeVFSACL *acl;
  // selinux_context
  char *selinux_context;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
  // reserved3
  void *reserved3;
};

struct anonymous$41
{
  // toplevel_under_pointer
  struct _GdkDrawable *toplevel_under_pointer;
  // window_under_pointer
  struct _GdkDrawable *window_under_pointer;
  // toplevel_x
  double toplevel_x;
  // toplevel_y
  double toplevel_y;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // motion_hint_serial
  unsigned long int motion_hint_serial;
};

struct anonymous$40
{
  // window
  struct _GdkDrawable *window;
  // native_window
  struct _GdkDrawable *native_window;
  // serial
  unsigned long int serial;
  // owner_events
  signed int owner_events;
  // time
  unsigned int time;
};

struct anonymous$109
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$108 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$107 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$111
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$110 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$109 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$110
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$107
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$10
{
  // f
  void (*f)(void);
  // d
  void *d;
};

struct anonymous$103
{
  // terminal
  const char *terminal;
  // arguments
  const char *arguments;
};

struct anonymous$75
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$64
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$65
{
  // __cancel_jmp_buf
  struct anonymous$64 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$80
{
  // status
  enum anonymous$15 status;
  // vfs_status
  enum anonymous$32 vfs_status;
  // phase
  enum anonymous$14 phase;
  // source_name
  char *source_name;
  // target_name
  char *target_name;
  // file_index
  unsigned long int file_index;
  // files_total
  unsigned long int files_total;
  // bytes_total
  unsigned long int bytes_total;
  // file_size
  unsigned long int file_size;
  // bytes_copied
  unsigned long int bytes_copied;
  // total_bytes_copied
  unsigned long int total_bytes_copied;
  // duplicate_name
  char *duplicate_name;
  // duplicate_count
  signed int duplicate_count;
  // top_level_item
  signed int top_level_item;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
};

struct anonymous$108
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$107 *visuals;
};

struct anonymous$17
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$143
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$145
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$146
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$122
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$121
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$125
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$126
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$127
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$134
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$131
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$130
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$129
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$138
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$128
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$135
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$124
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$133
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$139
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$114
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$144
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$119
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$142
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$123
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$132
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$120
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$136
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$140
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$57
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$141
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$57 data;
};

struct anonymous$118
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$117
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$116
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$115
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$137
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$13
{
  // gl_pathc
  unsigned long int gl_pathc;
  // gl_pathv
  char **gl_pathv;
  // gl_offs
  unsigned long int gl_offs;
  // gl_flags
  signed int gl_flags;
  // gl_closedir
  void (*gl_closedir)(void *);
  // gl_readdir
  void * (*gl_readdir)(void *);
  // gl_opendir
  void * (*gl_opendir)(const char *);
  // gl_lstat
  signed int (*gl_lstat)(const char *, void *);
  // gl_stat
  signed int (*gl_stat)(const char *, void *);
};

union anonymous$67
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$8
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

union anonymous$11
{
  // char_data
  char char_data;
  // uchar_data
  unsigned char uchar_data;
  // bool_data
  signed int bool_data;
  // int_data
  signed int int_data;
  // uint_data
  unsigned int uint_data;
  // long_data
  signed long int long_data;
  // ulong_data
  unsigned long int ulong_data;
  // float_data
  float float_data;
  // double_data
  double double_data;
  // string_data
  char *string_data;
  // object_data
  struct _GtkObject *object_data;
  // pointer_data
  void *pointer_data;
  // signal_data
  struct anonymous$10 signal_data;
};

struct _GtkImagePixmapData
{
  // pixmap
  struct _GdkDrawable *pixmap;
};

struct _GtkImageImageData
{
  // image
  struct _GdkImage *image;
};

struct _GtkImagePixbufData
{
  // pixbuf
  struct _GdkPixbuf *pixbuf;
};

struct _GtkImageStockData
{
  // stock_id
  char *stock_id;
};

struct _GtkImageIconSetData
{
  // icon_set
  struct _GtkIconSet *icon_set;
};

struct _GtkImageAnimationData
{
  // anim
  struct _GdkPixbufAnimation *anim;
  // iter
  struct _GdkPixbufAnimationIter *iter;
  // frame_timeout
  unsigned int frame_timeout;
};

struct _GtkImageIconNameData
{
  // icon_name
  char *icon_name;
  // pixbuf
  struct _GdkPixbuf *pixbuf;
  // theme_change_id
  unsigned int theme_change_id;
};

struct _GtkImageGIconData
{
  // icon
  struct _GIcon *icon;
  // pixbuf
  struct _GdkPixbuf *pixbuf;
  // theme_change_id
  unsigned int theme_change_id;
};

union anonymous$96
{
  // pixmap
  struct _GtkImagePixmapData pixmap;
  // image
  struct _GtkImageImageData image;
  // pixbuf
  struct _GtkImagePixbufData pixbuf;
  // stock
  struct _GtkImageStockData stock;
  // icon_set
  struct _GtkImageIconSetData icon_set;
  // anim
  struct _GtkImageAnimationData anim;
  // name
  struct _GtkImageIconNameData name;
  // gicon
  struct _GtkImageGIconData gicon;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$66
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct GnomeVFSURI
{
  // ref_count
  unsigned int ref_count;
  // text
  char *text;
  // fragment_id
  char *fragment_id;
  // method_string
  char *method_string;
  // method
  struct GnomeVFSMethod *method;
  // parent
  struct GnomeVFSURI *parent;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
};

struct _AccelInfo
{
  // num
  signed int num;
  // view
  struct _GmAppView *view;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _AtkObject
{
  // parent
  struct _GObject parent;
  // description
  char *description;
  // name
  char *name;
  // accessible_parent
  struct _AtkObject *accessible_parent;
  // role
  enum anonymous$6 role;
  // relation_set
  struct _AtkRelationSet *relation_set;
  // layer
  enum anonymous$7 layer;
};

struct _AtkRelationSet
{
  // parent
  struct _GObject parent;
  // relations
  struct _GPtrArray *relations;
};

struct _BlinkInfo
{
  // blink
  unsigned int blink;
  // text
  struct _GtkTextBuffer *text;
  // fill
  char *fill;
  // timeout
  unsigned int timeout;
  // view
  struct _GmWorldTextView *view;
  // begin
  struct _GtkTextMark *begin;
};

struct _ComboBoxTypeData
{
  // triggers
  struct _GmTriggersDialog *triggers;
  // data
  struct _GmTriggerData *data;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _EggNotificationBubble
{
  // parent_instance
  struct _GtkObject parent_instance;
  // widget
  struct _GtkWidget *widget;
  // timeout_id
  unsigned int timeout_id;
  // bubble_header_text
  char *bubble_header_text;
  // bubble_body_text
  char *bubble_body_text;
  // icon
  struct _GtkWidget *icon;
  // active
  signed int active;
  // bubble_window
  struct _GtkWidget *bubble_window;
  // main_hbox
  struct _GtkWidget *main_hbox;
  // bubble_header_label
  struct _GtkWidget *bubble_header_label;
  // bubble_body_label
  struct _GtkWidget *bubble_body_label;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GtkObjectClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // set_arg
  void (*set_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // get_arg
  void (*get_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // destroy
  void (*destroy)(struct _GtkObject *);
};

struct _EggNotificationBubbleClass
{
  // parent_class
  struct _GtkObjectClass parent_class;
  // clicked
  void (*clicked)(void);
  // timeout
  void (*timeout)(void);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous$0 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkPlug
{
  // window
  struct _GtkWindow window;
  // socket_window
  struct _GdkDrawable *socket_window;
  // modality_window
  struct _GtkWidget *modality_window;
  // modality_group
  struct _GtkWindowGroup *modality_group;
  // grabbed_keys
  struct _GHashTable *grabbed_keys;
  // same_app
  unsigned int same_app : 1;
};

struct _EggTrayIcon
{
  // parent_instance
  struct _GtkPlug parent_instance;
  // stamp
  unsigned int stamp;
  // selection_atom
  unsigned long int selection_atom;
  // manager_atom
  unsigned long int manager_atom;
  // system_tray_opcode_atom
  unsigned long int system_tray_opcode_atom;
  // orientation_atom
  unsigned long int orientation_atom;
  // manager_window
  unsigned long int manager_window;
  // orientation
  enum anonymous$9 orientation;
  // notify
  struct _Notify *notify;
};

struct _GtkWidgetClass
{
  // parent_class
  struct _GtkObjectClass parent_class;
  // activate_signal
  unsigned int activate_signal;
  // set_scroll_adjustments_signal
  unsigned int set_scroll_adjustments_signal;
  // dispatch_child_properties_changed
  void (*dispatch_child_properties_changed)(struct _GtkWidget *, unsigned int, struct _GParamSpec **);
  // show
  void (*show)(struct _GtkWidget *);
  // show_all
  void (*show_all)(struct _GtkWidget *);
  // hide
  void (*hide)(struct _GtkWidget *);
  // hide_all
  void (*hide_all)(struct _GtkWidget *);
  // map
  void (*map)(struct _GtkWidget *);
  // unmap
  void (*unmap)(struct _GtkWidget *);
  // realize
  void (*realize)(struct _GtkWidget *);
  // unrealize
  void (*unrealize)(struct _GtkWidget *);
  // size_request
  void (*size_request)(struct _GtkWidget *, struct _GtkRequisition *);
  // size_allocate
  void (*size_allocate)(struct _GtkWidget *, struct _GdkRectangle *);
  // state_changed
  void (*state_changed)(struct _GtkWidget *, enum anonymous$23);
  // parent_set
  void (*parent_set)(struct _GtkWidget *, struct _GtkWidget *);
  // hierarchy_changed
  void (*hierarchy_changed)(struct _GtkWidget *, struct _GtkWidget *);
  // style_set
  void (*style_set)(struct _GtkWidget *, struct _GtkStyle *);
  // direction_changed
  void (*direction_changed)(struct _GtkWidget *, enum anonymous$24);
  // grab_notify
  void (*grab_notify)(struct _GtkWidget *, signed int);
  // child_notify
  void (*child_notify)(struct _GtkWidget *, struct _GParamSpec *);
  // mnemonic_activate
  signed int (*mnemonic_activate)(struct _GtkWidget *, signed int);
  // grab_focus
  void (*grab_focus)(struct _GtkWidget *);
  // focus
  signed int (*focus)(struct _GtkWidget *, enum anonymous$25);
  // event
  signed int (*event)(struct _GtkWidget *, union _GdkEvent *);
  // button_press_event
  signed int (*button_press_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // button_release_event
  signed int (*button_release_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // scroll_event
  signed int (*scroll_event)(struct _GtkWidget *, struct _GdkEventScroll *);
  // motion_notify_event
  signed int (*motion_notify_event)(struct _GtkWidget *, struct _GdkEventMotion *);
  // delete_event
  signed int (*delete_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // destroy_event
  signed int (*destroy_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // expose_event
  signed int (*expose_event)(struct _GtkWidget *, struct _GdkEventExpose *);
  // key_press_event
  signed int (*key_press_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // key_release_event
  signed int (*key_release_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // enter_notify_event
  signed int (*enter_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // leave_notify_event
  signed int (*leave_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // configure_event
  signed int (*configure_event)(struct _GtkWidget *, struct _GdkEventConfigure *);
  // focus_in_event
  signed int (*focus_in_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // focus_out_event
  signed int (*focus_out_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // map_event
  signed int (*map_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // unmap_event
  signed int (*unmap_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // property_notify_event
  signed int (*property_notify_event)(struct _GtkWidget *, struct _GdkEventProperty *);
  // selection_clear_event
  signed int (*selection_clear_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_request_event
  signed int (*selection_request_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_notify_event
  signed int (*selection_notify_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // proximity_in_event
  signed int (*proximity_in_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // proximity_out_event
  signed int (*proximity_out_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // visibility_notify_event
  signed int (*visibility_notify_event)(struct _GtkWidget *, struct _GdkEventVisibility *);
  // client_event
  signed int (*client_event)(struct _GtkWidget *, struct _GdkEventClient *);
  // no_expose_event
  signed int (*no_expose_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // window_state_event
  signed int (*window_state_event)(struct _GtkWidget *, struct _GdkEventWindowState *);
  // selection_get
  void (*selection_get)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // selection_received
  void (*selection_received)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int);
  // drag_begin
  void (*drag_begin)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_end
  void (*drag_end)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_data_get
  void (*drag_data_get)(struct _GtkWidget *, struct _GdkDragContext *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_data_delete
  void (*drag_data_delete)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_leave
  void (*drag_leave)(struct _GtkWidget *, struct _GdkDragContext *, unsigned int);
  // drag_motion
  signed int (*drag_motion)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_drop
  signed int (*drag_drop)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_data_received
  void (*drag_data_received)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, struct _GtkSelectionData *, unsigned int, unsigned int);
  // popup_menu
  signed int (*popup_menu)(struct _GtkWidget *);
  // show_help
  signed int (*show_help)(struct _GtkWidget *, enum anonymous$26);
  // get_accessible
  struct _AtkObject * (*get_accessible)(struct _GtkWidget *);
  // screen_changed
  void (*screen_changed)(struct _GtkWidget *, struct _GdkScreen *);
  // can_activate_accel
  signed int (*can_activate_accel)(struct _GtkWidget *, unsigned int);
  // grab_broken_event
  signed int (*grab_broken_event)(struct _GtkWidget *, struct _GdkEventGrabBroken *);
  // composited_changed
  void (*composited_changed)(struct _GtkWidget *);
  // query_tooltip
  signed int (*query_tooltip)(struct _GtkWidget *, signed int, signed int, signed int, struct _GtkTooltip *);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _GtkContainerClass
{
  // parent_class
  struct _GtkWidgetClass parent_class;
  // add
  void (*add)(struct _GtkContainer *, struct _GtkWidget *);
  // remove
  void (*remove)(struct _GtkContainer *, struct _GtkWidget *);
  // check_resize
  void (*check_resize)(struct _GtkContainer *);
  // forall
  void (*forall)(struct _GtkContainer *, signed int, void (*)(struct _GtkWidget *, void *), void *);
  // set_focus_child
  void (*set_focus_child)(struct _GtkContainer *, struct _GtkWidget *);
  // child_type
  unsigned long int (*child_type)(struct _GtkContainer *);
  // composite_name
  char * (*composite_name)(struct _GtkContainer *, struct _GtkWidget *);
  // set_child_property
  void (*set_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_child_property
  void (*get_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GtkBinClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
};

struct _GtkWindowClass
{
  // parent_class
  struct _GtkBinClass parent_class;
  // set_focus
  void (*set_focus)(struct _GtkWindow *, struct _GtkWidget *);
  // frame_event
  signed int (*frame_event)(struct _GtkWindow *, union _GdkEvent *);
  // activate_focus
  void (*activate_focus)(struct _GtkWindow *);
  // activate_default
  void (*activate_default)(struct _GtkWindow *);
  // move_focus
  void (*move_focus)(struct _GtkWindow *, enum anonymous$25);
  // keys_changed
  void (*keys_changed)(struct _GtkWindow *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GtkPlugClass
{
  // parent_class
  struct _GtkWindowClass parent_class;
  // embedded
  void (*embedded)(struct _GtkPlug *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _EggTrayIconClass
{
  // parent_class
  struct _GtkPlugClass parent_class;
  // message_clicked
  void (*message_clicked)(struct _EggTrayIcon *);
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GCClosure
{
  // closure
  struct _GClosure closure;
  // callback
  void *callback;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GConfClient
{
  // object
  struct _GObject object;
  // engine
  struct _GConfEngine *engine;
  // error_mode
  enum anonymous$105 error_mode;
  // dir_hash
  struct _GHashTable *dir_hash;
  // cache_hash
  struct _GHashTable *cache_hash;
  // listeners
  struct _GConfListeners *listeners;
  // notify_list
  struct _GSList *notify_list;
  // notify_handler
  unsigned int notify_handler;
  // pending_notify_count
  signed int pending_notify_count;
  // cache_dirs
  struct _GHashTable *cache_dirs;
  // cache_recursive_dirs
  struct _GHashTable *cache_recursive_dirs;
};

struct _GConfEntry
{
  // key
  char *key;
  // value
  struct _GConfValue *value;
};

struct _GConfValue
{
  // type
  enum anonymous$62 type;
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GIOChannel
{
  // ref_count
  signed int ref_count;
  // funcs
  struct _GIOFuncs *funcs;
  // encoding
  char *encoding;
  // read_cd
  struct _GIConv *read_cd;
  // write_cd
  struct _GIConv *write_cd;
  // line_term
  char *line_term;
  // line_term_len
  unsigned int line_term_len;
  // buf_size
  unsigned long int buf_size;
  // read_buf
  struct _GString *read_buf;
  // encoded_read_buf
  struct _GString *encoded_read_buf;
  // write_buf
  struct _GString *write_buf;
  // partial_write_buf
  char partial_write_buf[6l];
  // use_buffer
  unsigned int use_buffer : 1;
  // do_encode
  unsigned int do_encode : 1;
  // close_on_unref
  unsigned int close_on_unref : 1;
  // is_readable
  unsigned int is_readable : 1;
  // is_writeable
  unsigned int is_writeable : 1;
  // is_seekable
  unsigned int is_seekable : 1;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
};

struct _GIOFuncs
{
  // io_read
  enum anonymous$70 (*io_read)(struct _GIOChannel *, char *, unsigned long int, unsigned long int *, struct _GError **);
  // io_write
  enum anonymous$70 (*io_write)(struct _GIOChannel *, const char *, unsigned long int, unsigned long int *, struct _GError **);
  // io_seek
  enum anonymous$70 (*io_seek)(struct _GIOChannel *, signed long int, enum anonymous$71, struct _GError **);
  // io_close
  enum anonymous$70 (*io_close)(struct _GIOChannel *, struct _GError **);
  // io_create_watch
  struct _GSource * (*io_create_watch)(struct _GIOChannel *, enum anonymous$69);
  // io_free
  void (*io_free)(struct _GIOChannel *);
  // io_set_flags
  enum anonymous$70 (*io_set_flags)(struct _GIOChannel *, enum anonymous$72, struct _GError **);
  // io_get_flags
  enum anonymous$72 (*io_get_flags)(struct _GIOChannel *);
};

struct _GInterfaceInfo
{
  // interface_init
  void (*interface_init)(void *, void *);
  // interface_finalize
  void (*interface_finalize)(void *, void *);
  // interface_data
  void *interface_data;
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous$5 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$8 data[2l];
};

struct _GParameter
{
  // name
  const char *name;
  // value
  struct _GValue value;
};

struct _GPtrArray
{
  // pdata
  void **pdata;
  // len
  unsigned int len;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GSignalInvocationHint
{
  // signal_id
  unsigned int signal_id;
  // detail
  unsigned int detail;
  // run_type
  enum anonymous$68 run_type;
};

struct _GSource
{
  // callback_data
  void *callback_data;
  // callback_funcs
  struct _GSourceCallbackFuncs *callback_funcs;
  // source_funcs
  const struct _GSourceFuncs *source_funcs;
  // ref_count
  unsigned int ref_count;
  // context
  struct _GMainContext *context;
  // priority
  signed int priority;
  // flags
  unsigned int flags;
  // source_id
  unsigned int source_id;
  // poll_fds
  struct _GSList *poll_fds;
  // prev
  struct _GSource *prev;
  // next
  struct _GSource *next;
  // name
  char *name;
  // priv
  struct _GSourcePrivate *priv;
};

struct _GSourceCallbackFuncs
{
  // ref
  void (*ref)(void *);
  // unref
  void (*unref)(void *);
  // get
  void (*get)(void *, struct _GSource *, signed int (**)(void *), void **);
};

struct _GSourceFuncs
{
  // prepare
  signed int (*prepare)(struct _GSource *, signed int *);
  // check
  signed int (*check)(struct _GSource *);
  // dispatch
  signed int (*dispatch)(struct _GSource *, signed int (*)(void *), void *);
  // finalize
  void (*finalize)(struct _GSource *);
  // closure_callback
  signed int (*closure_callback)(void *);
  // closure_marshal
  void (*closure_marshal)(void);
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _GTimeVal
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _GTypeInfo
{
  // class_size
  unsigned short int class_size;
  // base_init
  void (*base_init)(void *);
  // base_finalize
  void (*base_finalize)(void *);
  // class_init
  void (*class_init)(void *, void *);
  // class_finalize
  void (*class_finalize)(void *, void *);
  // class_data
  const void *class_data;
  // instance_size
  unsigned short int instance_size;
  // n_preallocs
  unsigned short int n_preallocs;
  // instance_init
  void (*instance_init)(struct _GTypeInstance *, void *);
  // value_table
  const struct _GTypeValueTable *value_table;
};

struct _GTypeInterface
{
  // g_type
  unsigned long int g_type;
  // g_instance_type
  unsigned long int g_instance_type;
};

struct _GTypeValueTable
{
  // value_init
  void (*value_init)(struct _GValue *);
  // value_free
  void (*value_free)(struct _GValue *);
  // value_copy
  void (*value_copy)(const struct _GValue *, struct _GValue *);
  // value_peek_pointer
  void * (*value_peek_pointer)(const struct _GValue *);
  // collect_format
  const char *collect_format;
  // collect_value
  char * (*collect_value)(struct _GValue *, unsigned int, union _GTypeCValue *, unsigned int);
  // lcopy_format
  const char *lcopy_format;
  // lcopy_value
  char * (*lcopy_value)(const struct _GValue *, unsigned int, union _GTypeCValue *, unsigned int);
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkCursor
{
  // type
  enum anonymous$37 type;
  // ref_count
  unsigned int ref_count;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous$38 source;
  // mode
  enum anonymous$39 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous$45 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous$0 modifiers;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkDisplay
{
  // parent_instance
  struct _GObject parent_instance;
  // queued_events
  struct _GList *queued_events;
  // queued_tail
  struct _GList *queued_tail;
  // button_click_time
  unsigned int button_click_time[2l];
  // button_window
  struct _GdkDrawable *button_window[2l];
  // button_number
  signed int button_number[2l];
  // double_click_time
  unsigned int double_click_time;
  // core_pointer
  struct _GdkDevice *core_pointer;
  // pointer_hooks
  const struct _GdkDisplayPointerHooks *pointer_hooks;
  // closed
  unsigned int closed : 1;
  // ignore_core_events
  unsigned int ignore_core_events : 1;
  // double_click_distance
  unsigned int double_click_distance;
  // button_x
  signed int button_x[2l];
  // button_y
  signed int button_y[2l];
  // pointer_grabs
  struct _GList *pointer_grabs;
  // keyboard_grab
  struct anonymous$40 keyboard_grab;
  // pointer_info
  struct anonymous$41 pointer_info;
  // last_event_time
  unsigned int last_event_time;
};

struct _GdkDisplayPointerHooks
{
  // get_pointer
  void (*get_pointer)(struct _GdkDisplay *, struct _GdkScreen **, signed int *, signed int *, enum anonymous$0 *);
  // window_get_pointer
  struct _GdkDrawable * (*window_get_pointer)(struct _GdkDisplay *, struct _GdkDrawable *, signed int *, signed int *, enum anonymous$0 *);
  // window_at_pointer
  struct _GdkDrawable * (*window_at_pointer)(struct _GdkDisplay *, signed int *, signed int *);
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous$44 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous$43 actions;
  // suggested_action
  enum anonymous$43 suggested_action;
  // action
  enum anonymous$43 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkEventAny
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventExpose
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous$48 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous$49 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous$51 mode;
  // detail
  enum anonymous$50 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous$54 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous$57 data;
};

struct _GdkEventDND
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous$22 changed_mask;
  // new_window_state
  enum anonymous$22 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous$52 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous$12 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous$12 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous$18 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkImage
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$97 type;
  // visual
  struct _GdkVisual *visual;
  // byte_order
  enum anonymous$36 byte_order;
  // width
  signed int width;
  // height
  signed int height;
  // depth
  unsigned short int depth;
  // bpp
  unsigned short int bpp;
  // bpl
  unsigned short int bpl;
  // bits_per_pixel
  unsigned short int bits_per_pixel;
  // mem
  void *mem;
  // colormap
  struct _GdkColormap *colormap;
  // windowing_data
  void *windowing_data;
};

struct _GdkPoint
{
  // x
  signed int x;
  // y
  signed int y;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$35 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous$36 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GladeXML
{
  // parent
  struct _GObject parent;
  // filename
  char *filename;
  // priv
  struct _GladeXMLPrivate *priv;
};

struct _GmApp
{
  // object
  struct _GObject object;
  // priv
  struct _GmAppPrivate *priv;
};

struct _GmAppClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // world_added
  void (*world_added)(struct _GmApp *, struct _GmWorld *);
  // world_removed
  void (*world_removed)(struct _GmApp *, struct _GmWorld *);
};

struct _GmAppPrivate
{
  // path
  char *path;
  // worlds_path
  char *worlds_path;
  // options_path
  char *options_path;
  // view
  struct _GmAppView *view;
  // options
  struct _GmOptions *options;
  // color_table
  struct _GmColorTable *color_table;
  // client
  struct _GnomeClient *client;
  // worlds
  struct _GList *worlds;
};

struct _GmAppView
{
  // window
  struct _GtkWindow window;
  // priv
  struct _GmAppViewPrivate *priv;
};

struct _GmAppViewClass
{
  // parent_class
  struct _GtkWindowClass parent_class;
  // active_world_changed
  void (*active_world_changed)(struct _GmAppView *, struct _GmWorldView *);
};

struct _GmAppViewPrivate
{
  // application
  struct _GmApp *application;
  // manager
  struct _GtkUIManager *manager;
  // sensitive_action_group
  struct _GtkActionGroup *sensitive_action_group;
  // action_group
  struct _GtkActionGroup *action_group;
  // worlds_action_group
  struct _GtkActionGroup *worlds_action_group;
  // editor_action_group
  struct _GtkActionGroup *editor_action_group;
  // world_menu_items
  struct _GHashTable *world_menu_items;
  // tray
  struct _GmTray *tray;
  // notebook
  struct _GtkNotebook *notebook;
  // active_world
  struct _GmWorld *active_world;
  // menu
  struct _GtkMenuBar *menu;
  // toolbar
  struct _GtkToolbar *toolbar;
  // label_replace
  struct _GtkLabel *label_replace;
  // expander_replace
  struct _GtkExpander *expander_replace;
  // entry_find
  struct _GtkEntry *entry_find;
  // entry_replace
  struct _GtkEntry *entry_replace;
  // vbox_find
  struct _GtkVBox *vbox_find;
  // hbox_control_find
  struct _GtkHBox *hbox_control_find;
  // hbox_replace
  struct _GtkHBox *hbox_replace;
  // check_button_search_direction
  struct _GtkCheckButton *check_button_search_direction;
  // check_button_search_sensitive
  struct _GtkCheckButton *check_button_search_sensitive;
  // ignore_toggling
  signed int ignore_toggling;
  // drag_in_progress
  signed int drag_in_progress;
  // motion_notify_handler_id
  signed int motion_notify_handler_id;
  // x_start
  signed int x_start;
  // y_start
  signed int y_start;
  // tab
  signed int tab;
  // cursor
  struct _GdkCursor *cursor;
  // tray_idle_create
  unsigned int tray_idle_create;
  // position_left
  signed int position_left;
  // position_top
  signed int position_top;
};

struct _GmAppViewWorldMenuItem
{
  // merge_id
  unsigned int merge_id;
  // action
  struct _GtkAction *action;
};

struct _GtkCellRenderer
{
  // parent
  struct _GtkObject parent;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // width
  signed int width;
  // height
  signed int height;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
  // mode
  unsigned int mode : 2;
  // visible
  unsigned int visible : 1;
  // is_expander
  unsigned int is_expander : 1;
  // is_expanded
  unsigned int is_expanded : 1;
  // cell_background_set
  unsigned int cell_background_set : 1;
  // sensitive
  unsigned int sensitive : 1;
  // editing
  unsigned int editing : 1;
};

struct _PangoColor
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GtkCellRendererText
{
  // parent
  struct _GtkCellRenderer parent;
  // text
  char *text;
  // font
  struct _PangoFontDescription *font;
  // font_scale
  double font_scale;
  // foreground
  struct _PangoColor foreground;
  // background
  struct _PangoColor background;
  // extra_attrs
  struct _PangoAttrList *extra_attrs;
  // underline_style
  enum anonymous$3 underline_style;
  // rise
  signed int rise;
  // fixed_height_rows
  signed int fixed_height_rows;
  // strikethrough
  unsigned int strikethrough : 1;
  // editable
  unsigned int editable : 1;
  // scale_set
  unsigned int scale_set : 1;
  // foreground_set
  unsigned int foreground_set : 1;
  // background_set
  unsigned int background_set : 1;
  // underline_set
  unsigned int underline_set : 1;
  // rise_set
  unsigned int rise_set : 1;
  // strikethrough_set
  unsigned int strikethrough_set : 1;
  // editable_set
  unsigned int editable_set : 1;
  // calc_fixed_height
  unsigned int calc_fixed_height : 1;
};

struct _GmCellRendererText
{
  // parent
  struct _GtkCellRendererText parent;
  // priv
  struct _GmCellRendererTextPrivate *priv;
};

struct _GtkCellRendererClass
{
  // parent_class
  struct _GtkObjectClass parent_class;
  // get_size
  void (*get_size)(struct _GtkCellRenderer *, struct _GtkWidget *, struct _GdkRectangle *, signed int *, signed int *, signed int *, signed int *);
  // render
  void (*render)(struct _GtkCellRenderer *, struct _GdkDrawable *, struct _GtkWidget *, struct _GdkRectangle *, struct _GdkRectangle *, struct _GdkRectangle *, enum anonymous$1);
  // activate
  signed int (*activate)(struct _GtkCellRenderer *, union _GdkEvent *, struct _GtkWidget *, const char *, struct _GdkRectangle *, struct _GdkRectangle *, enum anonymous$1);
  // start_editing
  struct _GtkCellEditable * (*start_editing)(struct _GtkCellRenderer *, union _GdkEvent *, struct _GtkWidget *, const char *, struct _GdkRectangle *, struct _GdkRectangle *, enum anonymous$1);
  // editing_canceled
  void (*editing_canceled)(struct _GtkCellRenderer *);
  // editing_started
  void (*editing_started)(struct _GtkCellRenderer *, struct _GtkCellEditable *, const char *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
};

struct _GtkCellRendererTextClass
{
  // parent_class
  struct _GtkCellRendererClass parent_class;
  // edited
  void (*edited)(struct _GtkCellRendererText *, const char *, const char *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GmCellRendererTextClass
{
  // parent_class
  struct _GtkCellRendererTextClass parent_class;
};

struct _GmCellRendererTextPrivate
{
  // name
  char *name;
  // status
  char *status;
  // width
  signed int width;
};

struct _GmColorScheme
{
  // scheme
  enum _GmColorTableScheme scheme;
  // name
  const char *name;
  // values
  const struct _GmColorTableSchemeItem *values;
};

struct _GmColorTable
{
  // object
  struct _GObject object;
  // priv
  struct _GmColorTablePrivate *priv;
};

struct _GmColorTableClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // color_changed
  void (*color_changed)(struct _GmColorTable *, const char *);
  // font_changed
  void (*font_changed)(struct _GmColorTable *, const char *);
};

struct _GmColorTableItem
{
  // hex
  char *hex;
  // color
  struct _GdkColor color;
};

struct _GmColorTablePrivate
{
  // colors
  struct _GHashTable *colors;
  // font_description
  char *font_description;
  // use_system_font
  signed int use_system_font;
  // options
  struct _GmOptions *options;
  // scheme
  enum _GmColorTableScheme scheme;
  // gconf_connection_id
  unsigned int gconf_connection_id;
};

struct _GmColorTableSchemeItem
{
  // name
  const char *name;
  // hex
  const char *hex;
};

struct _GmEditingInfo
{
  // is_editing
  signed int is_editing;
  // lines
  struct _GList *lines;
  // name
  char *name;
  // upload
  char *upload;
};

struct _GmEditor
{
  // object
  struct _GObject object;
  // priv
  struct _GmEditorPrivate *priv;
};

struct _GmEditorClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // save
  void (*save)(struct _GmEditor *);
  // saved
  void (*saved)(struct _GmEditor *);
  // close
  void (*close)(struct _GmEditor *);
};

struct _GmEditorPrivate
{
  // name
  char *name;
  // upload_cmd
  char *upload_cmd;
  // mcp_type
  char *mcp_type;
  // type
  enum _GmEditType type;
  // is_code
  signed int is_code;
  // lines
  struct _GList *lines;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkVBox
{
  // box
  struct _GtkBox box;
};

struct _GmEditorView
{
  // parent
  struct _GtkVBox parent;
  // priv
  struct _GmEditorViewPrivate *priv;
};

struct _GtkBoxClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
};

struct _GtkVBoxClass
{
  // parent_class
  struct _GtkBoxClass parent_class;
};

struct _GmEditorViewClass
{
  // parent_class
  struct _GtkVBoxClass parent_class;
  // modified_changed
  void (*modified_changed)(struct _GmEditorView *, signed int);
};

struct _GmEditorViewPrivate
{
  // world
  struct _GmWorld *world;
  // editor
  struct _GmEditor *editor;
  // source_view
  struct _GtkSourceView *source_view;
};

struct _GtkHBox
{
  // box
  struct _GtkBox box;
};

struct _GmEmbeddedView
{
  // parent
  struct _GtkHBox parent;
  // priv
  struct _GmEmbeddedViewPrivate *priv;
};

struct _GtkHBoxClass
{
  // parent_class
  struct _GtkBoxClass parent_class;
};

struct _GmEmbeddedViewClass
{
  // parent_class
  struct _GtkHBoxClass parent_class;
};

struct _GmEmbeddedViewPrivate
{
  // world
  struct _GmWorld *world;
  // editor
  struct _GmEditor *editor;
  // vte
  struct _VteTerminal *vte;
  // filename
  char *filename;
  // monitor
  struct GnomeVFSMonitorHandle *monitor;
  // last_modified
  signed long int last_modified;
};

struct _GmExternalView
{
  // world
  struct _GmWorld *world;
  // editor
  struct _GmEditor *editor;
  // filename
  char *filename;
  // monitor
  struct GnomeVFSMonitorHandle *monitor;
  // last_modified
  signed long int last_modified;
  // pid
  signed int pid;
  // child_watch
  unsigned int child_watch;
};

struct _GmFetchHandle
{
  // handle
  struct GnomeVFSAsyncHandle *handle;
  // cb
  void (*cb)(void *, void *);
  // user_data
  void *user_data;
  // source_uri
  struct _GList *source_uri;
  // dest_uri
  struct _GList *dest_uri;
  // cur_phase
  enum anonymous$14 cur_phase;
  // prev_phase
  enum anonymous$14 prev_phase;
  // prev_status
  enum anonymous$15 prev_status;
  // status
  enum anonymous$15 status;
  // bytes_total
  unsigned long int bytes_total;
  // file_size
  unsigned long int file_size;
  // bytes_copied
  unsigned long int bytes_copied;
  // total_bytes_copied
  unsigned long int total_bytes_copied;
  // files_total
  unsigned long int files_total;
  // cur_file
  unsigned long int cur_file;
  // prev_file
  unsigned long int prev_file;
  // cur_file_name
  char *cur_file_name;
  // aborted
  signed int aborted;
  // done
  signed int done;
};

struct _GmIUserlistInterface
{
  // parent
  struct _GTypeInterface parent;
  // get_menu
  struct _GList * (*get_menu)(struct _GmIUserlist *, signed int);
  // get_status
  char * (*get_status)(struct _GmIUserlist *, signed int);
  // get_name
  const char * (*get_name)(struct _GmIUserlist *, signed int);
  // get_icon
  const char * (*get_icon)(struct _GmIUserlist *, signed int, signed int);
  // get_rank_priority
  signed int (*get_rank_priority)(struct _GmIUserlist *, signed int);
  // get_state_priority
  signed int (*get_state_priority)(struct _GmIUserlist *, signed int);
  // player_added
  void (*player_added)(struct _GmIUserlist *, signed int);
  // player_removed
  void (*player_removed)(struct _GmIUserlist *, signed int);
  // name_changed
  void (*name_changed)(struct _GmIUserlist *, signed int);
  // state_changed
  void (*state_changed)(struct _GmIUserlist *, signed int);
  // rank_changed
  void (*rank_changed)(struct _GmIUserlist *, signed int);
};

struct _GmKeyValuePair
{
  // key
  char *key;
  // value
  char *value;
};

struct _GmLabelInfo
{
  // button_exit
  struct _GtkWidget *button_exit;
  // image_exit
  struct _GtkWidget *image_exit;
  // label_name
  struct _GtkWidget *label_name;
  // image_icon
  struct _GtkWidget *image_icon;
};

struct _GmLogView
{
  // parent
  struct _GtkVBox parent;
  // priv
  struct _GmLogViewPrivate *priv;
};

struct _GmLogViewClass
{
  // parent_class
  struct _GtkVBoxClass parent_class;
};

struct _GmLogViewPrivate
{
  // text_view
  struct _GtkTextView *text_view;
};

struct _GmMcpPackage
{
  // parent
  struct _GObject parent;
  // priv
  struct _GmMcpPackagePrivate *priv;
};

struct _GmMcpAwnsPing
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpAwnsPingPrivate *priv;
};

struct _GmMcpPackageClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // name
  char *name;
  // min_version
  double min_version;
  // max_version
  double max_version;
  // depends
  char **depends;
  // overrides
  char **overrides;
  // handle_simple
  void (*handle_simple)(struct _GmMcpPackage *, char *, struct _GList *);
  // handle_multi
  signed int (*handle_multi)(struct _GmMcpPackage *, const char *, const char *, const char *, struct _GList *);
  // create_view
  void (*create_view)(struct _GmMcpPackage *, struct _GObject *);
  // set_session
  void (*set_session)(struct _GmMcpPackage *, struct _GObject *);
};

struct _GmMcpAwnsPingClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
};

struct _GmMcpAwnsStatus
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpAwnsStatusPrivate *priv;
};

struct _GmMcpAwnsStatusClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
  // status_changed
  void (*status_changed)(struct _GmMcpAwnsStatus *, const char *);
};

struct _GmMcpAwnsStatusPrivate
{
  // status
  char *status;
};

struct _GmMcpAwnsStatusView
{
  // package
  struct _GmMcpAwnsStatus *package;
  // view
  struct _GmWorldView *view;
};

struct _GmMcpIcecrewMcpreset
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpIcecrewMcpresetPrivate *priv;
};

struct _GmMcpIcecrewMcpresetClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
};

struct _GmMcpIcecrewPlayerdb
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpIcecrewPlayerdbPrivate *priv;
};

struct _GmMcpIcecrewPlayerdbClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
  // add
  void (*add)(struct _GmMcpIcecrewPlayerdb *, void *);
  // set
  void (*set)(struct _GmMcpIcecrewPlayerdb *, void *, const char *, const char *, const char *);
  // delete
  void (*delete)(struct _GmMcpIcecrewPlayerdb *, void *);
};

struct _GmMcpIcecrewPlayerdbPrivate
{
  // self
  signed int self;
  // db
  struct _GList *db;
  // last_init_keys
  struct _GList *last_init_keys;
};

struct _GmMcpIcecrewServerinfo
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpIcecrewServerinfoPrivate *priv;
};

struct _GmMcpIcecrewServerinfoClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
  // got_info
  void (*got_info)(struct _GmMcpIcecrewServerinfo *);
};

struct _GmWorldInfo
{
  // name
  char *name;
  // homepage
  char *homepage;
  // location
  char *location;
  // admin
  char *admin;
  // contact
  char *contact;
  // charset
  char *charset;
  // language
  char *language;
  // system
  char *system;
  // logo
  char *logo;
};

struct _GmMcpIcecrewServerinfoPrivate
{
  // has_info
  signed int has_info;
  // info
  struct _GmWorldInfo info;
  // handle
  struct _GmFetchHandle *handle;
};

struct _GmMcpIcecrewServerinfoView
{
  // view
  struct _GmAppView *view;
  // package
  struct _GmMcpIcecrewServerinfo *package;
};

struct _GmMcpIcecrewUserlist
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpIcecrewUserlistPrivate *priv;
};

struct _GmMcpIcecrewUserlistClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
};

struct _GmMcpIcecrewUserlistPrivate
{
  // state_icons
  struct _GList *state_icons;
  // rank_icons
  struct _GList *rank_icons;
  // state_alternatives
  struct _GList *state_alternatives;
  // rank_alternatives
  struct _GList *rank_alternatives;
  // key_datatags
  struct _GList *key_datatags;
  // rank_fetch
  struct _GmFetchHandle *rank_fetch;
  // state_fetch
  struct _GmFetchHandle *state_fetch;
  // rank_dir
  char *rank_dir;
  // state_dir
  char *state_dir;
  // property_names
  char **property_names;
  // menu
  struct _GList *menu;
  // initializing
  signed int initializing;
};

struct _GmMcpMudMooSimpleedit
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpMudMooSimpleeditPrivate *priv;
};

struct _GmMcpMudMooSimpleeditClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
};

struct _GmMcpMudMooSimpleeditPrivate
{
  // ref
  char *ref;
  // name
  char *name;
  // type
  char *type;
  // editors
  struct _GSList *editors;
};

struct _GmMcpNegotiate
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpNegotiatePrivate *priv;
};

struct _GmMcpNegotiateClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
};

struct _GmMcpNegotiatePrivate
{
  // packages
  struct _GList *packages;
};

struct _GmMcpPackagePrivate
{
  // session
  struct _GmMcpSession *session;
  // version
  double version;
};

struct _GmMcpSession
{
  // parent
  struct _GObject parent;
  // priv
  struct _GmMcpSessionPrivate *priv;
};

struct _GmMcpSessionClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // available_packages
  struct _GList *available_packages;
  // package_created
  void (*package_created)(struct _GmMcpSession *, struct _GObject *);
};

struct _GmMcpSessionPrivate
{
  // world
  struct _GmWorld *world;
  // authkey
  char *authkey;
  // version
  double version;
  // packages
  struct _GList *packages;
  // multiline
  struct _GList *multiline;
};

struct _GmMcpUserlistView
{
  // view
  struct _GmWorldView *view;
  // package
  struct _GmMcpPackage *package;
  // model
  struct _GtkTreeModel *model;
  // store
  struct _GtkListStore *store;
  // tree_view
  struct _GtkTreeView *tree_view;
  // label
  struct _GtkWidget *label;
  // scrolled_window
  struct _GtkScrolledWindow *scrolled_window;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // vbox
  struct _GtkWidget *vbox;
  // initializing
  signed int initializing;
  // sort_type
  enum _GmUserlistSortType sort_type;
  // show_object
  signed int show_object;
  // show_status
  signed int show_status;
  // use_state_icon
  signed int use_state_icon;
  // num_players
  signed int num_players;
  // num_active
  signed int num_active;
  // status_color
  struct _GdkColor status_color;
  // scroll_position
  double scroll_position;
  // idle_scroll
  unsigned long int idle_scroll;
};

struct _GmMcpVmooClient
{
  // parent
  struct _GmMcpPackage parent;
};

struct _GmMcpVmooClientClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
};

struct _GmMcpVmooClientView
{
  // package
  struct _GmMcpVmooClient *package;
  // view
  struct _GmWorldTextView *view;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // margin_width
  unsigned int margin_width;
  // margin_height
  unsigned int margin_height;
  // timeout
  unsigned int timeout;
};

struct _GmMcpVmooUserlist
{
  // parent
  struct _GmMcpPackage parent;
  // priv
  struct _GmMcpVmooUserlistPrivate *priv;
};

struct _GmMcpVmooUserlistClass
{
  // parent_class
  struct _GmMcpPackageClass parent_class;
};

struct _GmMcpVmooUserlistPrivate
{
  // you
  signed int you;
  // fields
  struct _GList *fields;
  // icons
  struct _GList *icons;
  // users
  struct _GList *users;
  // menu
  struct _GList *menu;
  // initializing
  signed int initializing;
};

struct _GmNet
{
  // object
  struct _GObject object;
  // priv
  struct _GmNetPrivate *priv;
};

struct _GmNetClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // state_changing
  void (*state_changing)(struct _GmNet *, unsigned int);
  // state_changed
  void (*state_changed)(struct _GmNet *, unsigned int);
  // net_error
  void (*net_error)(struct _GmNet *, char *, signed int);
  // bytes_recv
  void (*bytes_recv)(struct _GmNet *, char *);
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _GmNetPrivate
{
  // socket
  signed int socket;
  // channel
  struct _GIOChannel *channel;
  // source
  unsigned int source;
  // connect_timeout_id
  unsigned int connect_timeout_id;
  // connect_check_id
  unsigned int connect_check_id;
  // last_connected
  struct timeval last_connected;
  // tn_last
  signed int tn_last;
  // tn_subneg
  signed int tn_subneg;
  // thread
  unsigned long int thread;
  // thread_info
  struct _threadinfo *thread_info;
  // mutex_idle
  union anonymous$66 mutex_idle;
  // addr
  struct addrinfo *addr;
  // current
  struct addrinfo *current;
  // state
  enum _GmNetState state;
  // current_host
  char *current_host;
  // current_port
  char *current_port;
};

struct _GmOpenWorldDialog
{
  // xml
  struct _GladeXML *xml;
  // dialog
  struct _GtkWidget *dialog;
};

struct _GmOptions
{
  // object
  struct _GObject object;
  // priv
  struct _GmOptionsPrivate *priv;
};

struct _GmOptionsClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // option_changed
  void (*option_changed)(struct _GmOptions *, const char *);
};

struct _GmOptionsPrivate
{
  // options
  struct _GHashTable *options;
  // filepath
  char *filepath;
};

struct _GmPixbufInfo
{
  // name
  char *name;
  // width
  signed int width;
  // height
  signed int height;
  // pixbuf
  struct _GdkPixbuf *pixbuf;
};

struct _GmPlayerdbPlayerInfo
{
  // id
  signed int id;
  // values
  struct _GHashTable *values;
};

struct _GmPreferencesDialog
{
  // xml
  struct _GladeXML *xml;
  // dialog
  struct _GtkWidget *dialog;
  // user_scheme_index
  signed int user_scheme_index;
};

struct _GmSearchableInterface
{
  // parent
  struct _GTypeInterface parent;
  // get_text_view
  struct _GtkTextView * (*get_text_view)(struct _GmSearchable *);
  // find_first
  signed int (*find_first)(struct _GmSearchable *, const char *, enum _GmSearchableSearchFlags);
  // find_next
  signed int (*find_next)(struct _GmSearchable *, const char *, enum _GmSearchableSearchFlags);
  // replace
  signed int (*replace)(struct _GmSearchable *, const char *);
  // replace_all
  signed int (*replace_all)(struct _GmSearchable *, const char *, const char *, enum _GmSearchableSearchFlags);
};

struct _GmSourceStyleEntry
{
  // name
  const char *name;
  // color_name
  const char *color_name;
  // bold
  signed int bold;
  // italic
  signed int italic;
};

struct _GmSourceStyleScheme
{
  // parent_instance
  struct _GObject parent_instance;
  // mapping
  struct _GHashTable *mapping;
  // styles
  struct _GHashTable *styles;
};

struct _GmSourceStyleSchemeClass
{
  // parent_class
  struct _GObjectClass parent_class;
};

struct _GmTextScroller
{
  // parent
  struct _GObject parent;
  // priv
  struct _GmTextScrollerPrivate *priv;
};

struct _GmTextScrollerClass
{
  // parent_class
  struct _GObjectClass parent_class;
};

struct _GmTextScrollerPrivate
{
  // text_view
  struct _GtkTextView *text_view;
  // text_buffer
  struct _GtkTextBuffer *text_buffer;
  // scrolled_window
  struct _GtkScrolledWindow *scrolled_window;
  // character_height
  signed int character_height;
  // end_scrolled
  signed int end_scrolled;
  // idle_handler
  signed int idle_handler;
  // allocation
  struct _GdkRectangle allocation;
};

struct _GmTray
{
  // trayicon
  struct _EggTrayIcon trayicon;
  // priv
  struct _GmTrayPrivate *priv;
};

struct _GmTrayClass
{
  // parent_class
  struct _EggTrayIconClass parent_class;
};

struct _GmTrayPrivate
{
  // event_box
  struct _GtkWidget *event_box;
  // image
  struct _GtkImage *image;
  // tooltips
  struct _GtkTooltips *tooltips;
  // flash_timeout
  unsigned int flash_timeout;
  // current_state
  enum _GmTrayState current_state;
  // prev_state
  enum _GmTrayState prev_state;
  // icons
  struct _GdkPixbuf *icons[4l];
};

struct _GmTrigger
{
  // name
  char *name;
  // event
  enum _GmTriggerType event;
  // conditions
  struct _GList *conditions;
  // actions
  struct _GList *actions;
};

struct re_pattern_buffer
{
  // __buffer
  unsigned char *__buffer;
  // __allocated
  unsigned long int __allocated;
  // __used
  unsigned long int __used;
  // __syntax
  unsigned long int __syntax;
  // __fastmap
  char *__fastmap;
  // __translate
  unsigned char *__translate;
  // re_nsub
  unsigned long int re_nsub;
  // __can_be_null
  unsigned int __can_be_null : 1;
  // __regs_allocated
  unsigned int __regs_allocated : 2;
  // __fastmap_accurate
  unsigned int __fastmap_accurate : 1;
  // __no_sub
  unsigned int __no_sub : 1;
  // __not_bol
  unsigned int __not_bol : 1;
  // __not_eol
  unsigned int __not_eol : 1;
  // __newline_anchor
  unsigned int __newline_anchor : 1;
};

struct _GmTriggerData
{
  // type
  unsigned int type;
  // data
  char *data;
  // expr
  struct re_pattern_buffer expr;
};

struct _GmTriggers
{
  // object
  struct _GObject object;
  // priv
  struct _GmTriggersPrivate *priv;
};

struct _GmTriggersClass
{
  // parent_class
  struct _GObjectClass parent_class;
};

struct _GmTriggersDialog
{
  // dialog
  struct _GtkWidget *dialog;
  // xml
  struct _GladeXML *xml;
  // world
  struct _GmWorld *world;
  // trigger
  struct _GmTrigger *trigger;
  // is_new
  signed int is_new;
  // entry_name
  struct _GtkWidget *entry_name;
  // button_ok
  struct _GtkWidget *button_ok;
  // button_next
  struct _GtkWidget *button_next;
  // vbox_conditions
  struct _GtkWidget *vbox_conditions;
  // vbox_actions
  struct _GtkWidget *vbox_actions;
  // notebook_triggers
  struct _GtkWidget *notebook_triggers;
  // tree_view_event_types
  struct _GtkWidget *tree_view_event_types;
  // hbox_add_condition
  struct _GtkWidget *hbox_add_condition;
  // hbox_add_action
  struct _GtkWidget *hbox_add_action;
  // action_model
  struct _GtkTreeModel *action_model;
  // condition_model
  struct _GtkTreeModel *condition_model;
  // highlight_model
  struct _GtkTreeModel *highlight_model;
};

struct _GmTriggersPrivate
{
  // triggers
  struct _GList *triggers;
  // path
  char *path;
};

struct _GmWorld
{
  // object
  struct _GObject object;
  // priv
  struct _GmWorldPrivate *priv;
};

struct _GmWorldClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // activate_request
  void (*activate_request)(struct _GmWorld *);
  // load
  void (*load)(struct _GmWorld *);
  // unload
  void (*unload)(struct _GmWorld *);
  // state_changing
  void (*state_changing)(struct _GmWorld *, unsigned int);
  // world_error
  void (*world_error)(struct _GmWorld *, const char *, signed int);
  // text_received
  void (*text_received)(struct _GmWorld *, const char *);
  // editor_added
  void (*editor_added)(struct _GmWorld *, struct _GObject *);
  // editor_removed
  void (*editor_removed)(struct _GmWorld *, struct _GObject *);
  // highlight
  void (*highlight)(struct _GmWorld *, signed int, signed int, const char *);
  // notify_message
  void (*notify_message)(struct _GmWorld *, const char *);
};

struct _GtkTextView
{
  // parent_instance
  struct _GtkContainer parent_instance;
  // layout
  struct _GtkTextLayout *layout;
  // buffer
  struct _GtkTextBuffer *buffer;
  // selection_drag_handler
  unsigned int selection_drag_handler;
  // scroll_timeout
  unsigned int scroll_timeout;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // wrap_mode
  enum anonymous$77 wrap_mode;
  // justify
  enum anonymous$76 justify;
  // left_margin
  signed int left_margin;
  // right_margin
  signed int right_margin;
  // indent
  signed int indent;
  // tabs
  struct _PangoTabArray *tabs;
  // editable
  unsigned int editable : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // accepts_tab
  unsigned int accepts_tab : 1;
  // width_changed
  unsigned int width_changed : 1;
  // onscreen_validated
  unsigned int onscreen_validated : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // text_window
  struct _GtkTextWindow *text_window;
  // left_window
  struct _GtkTextWindow *left_window;
  // right_window
  struct _GtkTextWindow *right_window;
  // top_window
  struct _GtkTextWindow *top_window;
  // bottom_window
  struct _GtkTextWindow *bottom_window;
  // hadjustment
  struct _GtkAdjustment *hadjustment;
  // vadjustment
  struct _GtkAdjustment *vadjustment;
  // xoffset
  signed int xoffset;
  // yoffset
  signed int yoffset;
  // width
  signed int width;
  // height
  signed int height;
  // virtual_cursor_x
  signed int virtual_cursor_x;
  // virtual_cursor_y
  signed int virtual_cursor_y;
  // first_para_mark
  struct _GtkTextMark *first_para_mark;
  // first_para_pixels
  signed int first_para_pixels;
  // dnd_mark
  struct _GtkTextMark *dnd_mark;
  // blink_timeout
  unsigned int blink_timeout;
  // first_validate_idle
  unsigned int first_validate_idle;
  // incremental_validate_idle
  unsigned int incremental_validate_idle;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // children
  struct _GSList *children;
  // pending_scroll
  struct _GtkTextPendingScroll *pending_scroll;
  // pending_place_cursor_button
  signed int pending_place_cursor_button;
};

struct _GmWorldInputView
{
  // textview
  struct _GtkTextView textview;
  // priv
  struct _GmWorldInputViewPrivate *priv;
};

struct _GtkTextViewClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
  // set_scroll_adjustments
  void (*set_scroll_adjustments)(struct _GtkTextView *, struct _GtkAdjustment *, struct _GtkAdjustment *);
  // populate_popup
  void (*populate_popup)(struct _GtkTextView *, struct _GtkMenu *);
  // move_cursor
  void (*move_cursor)(struct _GtkTextView *, enum anonymous$92, signed int, signed int);
  // page_horizontally
  void (*page_horizontally)(struct _GtkTextView *, signed int, signed int);
  // set_anchor
  void (*set_anchor)(struct _GtkTextView *);
  // insert_at_cursor
  void (*insert_at_cursor)(struct _GtkTextView *, const char *);
  // delete_from_cursor
  void (*delete_from_cursor)(struct _GtkTextView *, enum anonymous$93, signed int);
  // backspace
  void (*backspace)(struct _GtkTextView *);
  // cut_clipboard
  void (*cut_clipboard)(struct _GtkTextView *);
  // copy_clipboard
  void (*copy_clipboard)(struct _GtkTextView *);
  // paste_clipboard
  void (*paste_clipboard)(struct _GtkTextView *);
  // toggle_overwrite
  void (*toggle_overwrite)(struct _GtkTextView *);
  // move_focus
  void (*move_focus)(struct _GtkTextView *, enum anonymous$25);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _GmWorldInputViewClass
{
  // parent_class
  struct _GtkTextViewClass parent_class;
  // text_activate
  void (*text_activate)(struct _GmWorldInputView *, const char *);
};

struct _GmWorldInputViewPrivate
{
  // color_table
  struct _GmColorTable *color_table;
  // history
  struct _GList **history;
  // position
  struct _GList *position;
  // prefix
  char *prefix;
  // changed_id
  unsigned long int changed_id;
  // idle_scroll
  unsigned int idle_scroll;
  // is_scrolled
  signed int is_scrolled;
};

struct _GmWorldPasteDialog
{
  // xml
  struct _GladeXML *xml;
  // dialog
  struct _GtkWidget *dialog;
  // view
  struct _GmAppView *view;
  // model
  struct _GtkTreeModel *model;
};

struct _GmWorldPrivate
{
  // path
  char *path;
  // loaded
  signed int loaded;
  // active
  signed int active;
  // activity
  unsigned int activity;
  // buffer
  char *buffer;
  // manual_disconnect
  signed int manual_disconnect;
  // manual_disconnect_timeout
  signed long int manual_disconnect_timeout;
  // reconnect_id
  unsigned int reconnect_id;
  // flush_history_id
  unsigned int flush_history_id;
  // last_command
  signed long int last_command;
  // options
  struct _GmOptions *options;
  // triggers
  struct _GmTriggers *triggers;
  // net
  struct _GmNet *net;
  // mcp
  struct _GmMcpSession *mcp;
  // history
  struct _GList *history;
  // editors
  struct _GSList *editors;
  // editing_info
  struct _GmEditingInfo editing_info;
  // last_day
  signed int last_day;
  // fd_log
  signed int fd_log;
};

struct _GmWorldPropertiesDialog
{
  // dialog
  struct _GtkWidget *dialog;
  // combo_box_charset
  struct _GtkWidget *combo_box_charset;
  // tree_view_triggers
  struct _GtkWidget *tree_view_triggers;
  // xml
  struct _GladeXML *xml;
  // world
  struct _GmWorld *world;
  // is_new
  signed int is_new;
  // handler_id
  unsigned long int handler_id;
};

struct _GmWorldTab
{
  // parent
  struct _GtkHBox parent;
  // priv
  struct _GmWorldTabPrivate *priv;
};

struct _GmWorldTabClass
{
  // parent_class
  struct _GtkHBoxClass parent_class;
  // close
  void (*close)(struct _GmWorldTab *);
};

struct _GmWorldTabPrivate
{
  // world
  struct _GmWorld *world;
  // image
  struct _GtkImage *image;
  // label
  struct _GtkLabel *label;
  // button
  struct _GtkButton *button;
  // source_id
  unsigned int source_id;
};

struct _GmWorldTextView
{
  // textview
  struct _GtkTextView textview;
  // priv
  struct _GmWorldTextViewPrivate *priv;
};

struct _GmWorldTextViewClass
{
  // parent_class
  struct _GtkTextViewClass parent_class;
  // url_activate
  void (*url_activate)(struct _GmWorldTextView *, const char *);
  // character_size_changed
  void (*character_size_changed)(struct _GmWorldTextView *, unsigned int, unsigned int);
};

struct _GmWorldTextViewInsertInfo
{
  // tags
  struct _GList *tags;
  // bold
  signed int bold;
  // inverse
  signed int inverse;
  // blink
  unsigned int blink;
  // text
  char *text;
};

struct _GmWorldTextViewPrivate
{
  // blinkers
  struct _GSList *blinkers;
  // blink_state
  unsigned int blink_state;
  // tag_blink
  struct _GtkTextTag *tag_blink;
  // tag_blink_fast
  struct _GtkTextTag *tag_blink_fast;
  // blink_timeout_id
  unsigned int blink_timeout_id;
  // character_width
  unsigned int character_width;
  // character_height
  unsigned int character_height;
  // max_lines
  signed int max_lines;
  // last_info
  struct _GmWorldTextViewInsertInfo last_info;
  // color_table
  struct _GmColorTable *color_table;
  // drag_url
  signed int drag_url;
  // drag_url_text
  char *drag_url_text;
  // drag_x
  unsigned int drag_x;
  // drag_y
  unsigned int drag_y;
  // source_target_list
  struct _GtkTargetList *source_target_list;
  // is_hand
  signed int is_hand;
};

struct _GtkNotebook
{
  // container
  struct _GtkContainer container;
  // cur_page
  struct _GtkNotebookPage *cur_page;
  // children
  struct _GList *children;
  // first_tab
  struct _GList *first_tab;
  // focus_tab
  struct _GList *focus_tab;
  // menu
  struct _GtkWidget *menu;
  // event_window
  struct _GdkDrawable *event_window;
  // timer
  unsigned int timer;
  // tab_hborder
  unsigned short int tab_hborder;
  // tab_vborder
  unsigned short int tab_vborder;
  // show_tabs
  unsigned int show_tabs : 1;
  // homogeneous
  unsigned int homogeneous : 1;
  // show_border
  unsigned int show_border : 1;
  // tab_pos
  unsigned int tab_pos : 2;
  // scrollable
  unsigned int scrollable : 1;
  // in_child
  unsigned int in_child : 3;
  // click_child
  unsigned int click_child : 3;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // child_has_focus
  unsigned int child_has_focus : 1;
  // have_visible_child
  unsigned int have_visible_child : 1;
  // focus_out
  unsigned int focus_out : 1;
  // has_before_previous
  unsigned int has_before_previous : 1;
  // has_before_next
  unsigned int has_before_next : 1;
  // has_after_previous
  unsigned int has_after_previous : 1;
  // has_after_next
  unsigned int has_after_next : 1;
};

struct _GmWorldView
{
  // notebook
  struct _GtkNotebook notebook;
  // priv
  struct _GmWorldViewPrivate *priv;
};

struct _GtkNotebookClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
  // switch_page
  void (*switch_page)(struct _GtkNotebook *, struct _GtkNotebookPage *, unsigned int);
  // select_page
  signed int (*select_page)(struct _GtkNotebook *, signed int);
  // focus_tab
  signed int (*focus_tab)(struct _GtkNotebook *, enum anonymous$85);
  // change_current_page
  signed int (*change_current_page)(struct _GtkNotebook *, signed int);
  // move_focus_out
  void (*move_focus_out)(struct _GtkNotebook *, enum anonymous$25);
  // reorder_tab
  signed int (*reorder_tab)(struct _GtkNotebook *, enum anonymous$25, signed int);
  // insert_page
  signed int (*insert_page)(struct _GtkNotebook *, struct _GtkWidget *, struct _GtkWidget *, struct _GtkWidget *, signed int);
  // create_window
  struct _GtkNotebook * (*create_window)(struct _GtkNotebook *, struct _GtkWidget *, signed int, signed int);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
};

struct _GmWorldViewClass
{
  // parent_class
  struct _GtkNotebookClass parent_class;
};

struct _GmWorldViewPrivate
{
  // world
  struct _GmWorld *world;
  // statusbar
  struct _GtkStatusbar *statusbar;
  // status_msg
  char *status_msg;
  // status_timeout
  unsigned int status_timeout;
  // hpaned
  struct _GtkHPaned *hpaned;
  // text_view_world
  struct _GmWorldTextView *text_view_world;
  // text_view_input
  struct _GmWorldInputView *text_view_input;
  // text_scroller_world
  struct _GmTextScroller *text_scroller_world;
  // external_editors
  struct _GList *external_editors;
};

struct _GmWorldsListDialog
{
  // xml
  struct _GladeXML *xml;
  // dialog
  struct _GtkWidget *dialog;
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GmWorldsView
{
  // parent
  struct _GtkTreeView parent;
  // priv
  struct _GmWorldsViewPrivate *priv;
};

struct _GtkTreeViewClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
  // set_scroll_adjustments
  void (*set_scroll_adjustments)(struct _GtkTreeView *, struct _GtkAdjustment *, struct _GtkAdjustment *);
  // row_activated
  void (*row_activated)(struct _GtkTreeView *, struct _GtkTreePath *, struct _GtkTreeViewColumn *);
  // test_expand_row
  signed int (*test_expand_row)(struct _GtkTreeView *, struct _GtkTreeIter *, struct _GtkTreePath *);
  // test_collapse_row
  signed int (*test_collapse_row)(struct _GtkTreeView *, struct _GtkTreeIter *, struct _GtkTreePath *);
  // row_expanded
  void (*row_expanded)(struct _GtkTreeView *, struct _GtkTreeIter *, struct _GtkTreePath *);
  // row_collapsed
  void (*row_collapsed)(struct _GtkTreeView *, struct _GtkTreeIter *, struct _GtkTreePath *);
  // columns_changed
  void (*columns_changed)(struct _GtkTreeView *);
  // cursor_changed
  void (*cursor_changed)(struct _GtkTreeView *);
  // move_cursor
  signed int (*move_cursor)(struct _GtkTreeView *, enum anonymous$92, signed int);
  // select_all
  signed int (*select_all)(struct _GtkTreeView *);
  // unselect_all
  signed int (*unselect_all)(struct _GtkTreeView *);
  // select_cursor_row
  signed int (*select_cursor_row)(struct _GtkTreeView *, signed int);
  // toggle_cursor_row
  signed int (*toggle_cursor_row)(struct _GtkTreeView *);
  // expand_collapse_cursor_row
  signed int (*expand_collapse_cursor_row)(struct _GtkTreeView *, signed int, signed int, signed int);
  // select_cursor_parent
  signed int (*select_cursor_parent)(struct _GtkTreeView *);
  // start_interactive_search
  signed int (*start_interactive_search)(struct _GtkTreeView *);
  // _gtk_reserved0
  void (*_gtk_reserved0)(void);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GmWorldsViewClass
{
  // parent_class
  struct _GtkTreeViewClass parent_class;
};

struct _GmWorldsViewPrivate
{
  // model
  struct _GtkTreeModel *model;
};

struct _GnomeClient
{
  // object
  struct _GtkObject object;
  // smc_conn
  void *smc_conn;
  // client_id
  char *client_id;
  // previous_id
  char *previous_id;
  // config_prefix
  char *config_prefix;
  // global_config_prefix
  char *global_config_prefix;
  // static_args
  struct _GList *static_args;
  // clone_command
  char **clone_command;
  // current_directory
  char *current_directory;
  // discard_command
  char **discard_command;
  // environment
  struct _GHashTable *environment;
  // process_id
  signed int process_id;
  // program
  char *program;
  // resign_command
  char **resign_command;
  // restart_command
  char **restart_command;
  // restart_style
  enum anonymous$56 restart_style;
  // shutdown_command
  char **shutdown_command;
  // user_id
  char *user_id;
  // interaction_keys
  struct _GSList *interaction_keys;
  // input_id
  signed int input_id;
  // save_style
  unsigned int save_style : 2;
  // interact_style
  unsigned int interact_style : 2;
  // state
  unsigned int state : 3;
  // shutdown
  unsigned int shutdown : 1;
  // fast
  unsigned int fast : 1;
  // save_phase_2_requested
  unsigned int save_phase_2_requested : 1;
  // save_successfull
  unsigned int save_successfull : 1;
  // save_yourself_emitted
  unsigned int save_yourself_emitted : 1;
  // reserved
  void *reserved;
};

struct _GnomeModuleInfo
{
  // name
  const char *name;
  // version
  const char *version;
  // description
  const char *description;
  // requirements
  struct _GnomeModuleRequirement *requirements;
  // instance_init
  void (*instance_init)(struct _GnomeProgram *, struct _GnomeModuleInfo *);
  // pre_args_parse
  void (*pre_args_parse)(struct _GnomeProgram *, struct _GnomeModuleInfo *);
  // post_args_parse
  void (*post_args_parse)(struct _GnomeProgram *, struct _GnomeModuleInfo *);
  // options
  struct poptOption *options;
  // init_pass
  void (*init_pass)(const struct _GnomeModuleInfo *);
  // class_init
  void (*class_init)(struct _GnomeProgramClass *, const struct _GnomeModuleInfo *);
  // opt_prefix
  const char *opt_prefix;
  // get_goption_group_func
  struct _GOptionGroup * (*get_goption_group_func)(void);
};

struct _GnomeModuleRequirement
{
  // required_version
  const char *required_version;
  // module_info
  const struct _GnomeModuleInfo *module_info;
};

struct _GnomeProgram
{
  // object
  struct _GObject object;
  // _priv
  struct _GnomeProgramPrivate *_priv;
};

struct _GnomeProgramClass
{
  // object_class
  struct _GObjectClass object_class;
  // padding1
  void *padding1;
  // padding2
  void *padding2;
};

struct _GnomeVFSACL
{
  // parent
  struct _GObject parent;
  // priv
  struct _GnomeVFSACLPrivate *priv;
};

struct _GtkAccelGroup
{
  // parent
  struct _GObject parent;
  // lock_count
  unsigned int lock_count;
  // modifier_mask
  enum anonymous$0 modifier_mask;
  // acceleratables
  struct _GSList *acceleratables;
  // n_accels
  unsigned int n_accels;
  // priv_accels
  struct _GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelKey
{
  // accel_key
  unsigned int accel_key;
  // accel_mods
  enum anonymous$0 accel_mods;
  // accel_flags
  unsigned int accel_flags : 16;
};

struct _GtkAccelGroupEntry
{
  // key
  struct _GtkAccelKey key;
  // closure
  struct _GClosure *closure;
  // accel_path_quark
  unsigned int accel_path_quark;
};

struct _GtkAction
{
  // object
  struct _GObject object;
  // private_data
  struct _GtkActionPrivate *private_data;
};

struct _GtkActionEntry
{
  // name
  const char *name;
  // stock_id
  const char *stock_id;
  // label
  const char *label;
  // accelerator
  const char *accelerator;
  // tooltip
  const char *tooltip;
  // callback
  void (*callback)(void);
};

struct _GtkActionGroup
{
  // parent
  struct _GObject parent;
  // private_data
  struct _GtkActionGroupPrivate *private_data;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkArg
{
  // type
  unsigned long int type;
  // name
  char *name;
  // d
  union anonymous$11 d;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkToggleButton
{
  // button
  struct _GtkButton button;
  // active
  unsigned int active : 1;
  // draw_indicator
  unsigned int draw_indicator : 1;
  // inconsistent
  unsigned int inconsistent : 1;
};

struct _GtkCheckButton
{
  // toggle_button
  struct _GtkToggleButton toggle_button;
};

struct _GtkColorButton
{
  // button
  struct _GtkButton button;
  // priv
  struct _GtkColorButtonPrivate *priv;
};

struct _GtkComboBox
{
  // parent_instance
  struct _GtkBin parent_instance;
  // priv
  struct _GtkComboBoxPrivate *priv;
};

struct _GtkComboBoxEntry
{
  // parent_instance
  struct _GtkComboBox parent_instance;
  // priv
  struct _GtkComboBoxEntryPrivate *priv;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkEntry
{
  // widget
  struct _GtkWidget widget;
  // text
  char *text;
  // editable
  unsigned int editable : 1;
  // visible
  unsigned int visible : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // in_drag
  unsigned int in_drag : 1;
  // text_length
  unsigned short int text_length;
  // text_max_length
  unsigned short int text_max_length;
  // text_area
  struct _GdkDrawable *text_area;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // current_pos
  signed int current_pos;
  // selection_bound
  signed int selection_bound;
  // cached_layout
  struct _PangoLayout *cached_layout;
  // cache_includes_preedit
  unsigned int cache_includes_preedit : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // has_frame
  unsigned int has_frame : 1;
  // activates_default
  unsigned int activates_default : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // in_click
  unsigned int in_click : 1;
  // is_cell_renderer
  unsigned int is_cell_renderer : 1;
  // editing_canceled
  unsigned int editing_canceled : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // select_words
  unsigned int select_words : 1;
  // select_lines
  unsigned int select_lines : 1;
  // resolved_dir
  unsigned int resolved_dir : 4;
  // truncate_multiline
  unsigned int truncate_multiline : 1;
  // button
  unsigned int button;
  // blink_timeout
  unsigned int blink_timeout;
  // recompute_idle
  unsigned int recompute_idle;
  // scroll_offset
  signed int scroll_offset;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // x_text_size
  unsigned short int x_text_size;
  // x_n_bytes
  unsigned short int x_n_bytes;
  // preedit_length
  unsigned short int preedit_length;
  // preedit_cursor
  unsigned short int preedit_cursor;
  // dnd_position
  signed int dnd_position;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // invisible_char
  unsigned int invisible_char;
  // width_chars
  signed int width_chars;
};

struct _GtkExpander
{
  // bin
  struct _GtkBin bin;
  // priv
  struct _GtkExpanderPrivate *priv;
};

struct _GtkFontButton
{
  // button
  struct _GtkButton button;
  // priv
  struct _GtkFontButtonPrivate *priv;
};

struct _GtkPaned
{
  // container
  struct _GtkContainer container;
  // child1
  struct _GtkWidget *child1;
  // child2
  struct _GtkWidget *child2;
  // handle
  struct _GdkDrawable *handle;
  // xor_gc
  struct _GdkGC *xor_gc;
  // cursor_type
  enum anonymous$37 cursor_type;
  // handle_pos
  struct _GdkRectangle handle_pos;
  // child1_size
  signed int child1_size;
  // last_allocation
  signed int last_allocation;
  // min_position
  signed int min_position;
  // max_position
  signed int max_position;
  // position_set
  unsigned int position_set : 1;
  // in_drag
  unsigned int in_drag : 1;
  // child1_shrink
  unsigned int child1_shrink : 1;
  // child1_resize
  unsigned int child1_resize : 1;
  // child2_shrink
  unsigned int child2_shrink : 1;
  // child2_resize
  unsigned int child2_resize : 1;
  // orientation
  unsigned int orientation : 1;
  // in_recursion
  unsigned int in_recursion : 1;
  // handle_prelit
  unsigned int handle_prelit : 1;
  // last_child1_focus
  struct _GtkWidget *last_child1_focus;
  // last_child2_focus
  struct _GtkWidget *last_child2_focus;
  // priv
  struct _GtkPanedPrivate *priv;
  // drag_pos
  signed int drag_pos;
  // original_position
  signed int original_position;
};

struct _GtkHPaned
{
  // paned
  struct _GtkPaned paned;
};

struct _GtkIMContext
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GtkIconFactory
{
  // parent_instance
  struct _GObject parent_instance;
  // icons
  struct _GHashTable *icons;
};

struct _GtkIconTheme
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkIconThemePrivate *priv;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkImage
{
  // misc
  struct _GtkMisc misc;
  // storage_type
  enum anonymous$95 storage_type;
  // data
  union anonymous$96 data;
  // mask
  struct _GdkDrawable *mask;
  // icon_size
  enum anonymous$21 icon_size;
};

struct _GtkItem
{
  // bin
  struct _GtkBin bin;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // seq
  void *seq;
  // _gtk_reserved1
  void *_gtk_reserved1;
  // sort_list
  struct _GList *sort_list;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous$151 order;
  // column_headers
  unsigned long int *column_headers;
  // length
  signed int length;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkMenuShell
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // active_menu_item
  struct _GtkWidget *active_menu_item;
  // parent_menu_shell
  struct _GtkWidget *parent_menu_shell;
  // button
  unsigned int button;
  // activate_time
  unsigned int activate_time;
  // active
  unsigned int active : 1;
  // have_grab
  unsigned int have_grab : 1;
  // have_xgrab
  unsigned int have_xgrab : 1;
  // ignore_leave
  unsigned int ignore_leave : 1;
  // menu_flag
  unsigned int menu_flag : 1;
  // ignore_enter
  unsigned int ignore_enter : 1;
  // keyboard_mode
  unsigned int keyboard_mode : 1;
};

struct _GtkMenu
{
  // menu_shell
  struct _GtkMenuShell menu_shell;
  // parent_menu_item
  struct _GtkWidget *parent_menu_item;
  // old_active_menu_item
  struct _GtkWidget *old_active_menu_item;
  // accel_group
  struct _GtkAccelGroup *accel_group;
  // accel_path
  char *accel_path;
  // position_func
  void (*position_func)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *);
  // position_func_data
  void *position_func_data;
  // toggle_size
  unsigned int toggle_size;
  // toplevel
  struct _GtkWidget *toplevel;
  // tearoff_window
  struct _GtkWidget *tearoff_window;
  // tearoff_hbox
  struct _GtkWidget *tearoff_hbox;
  // tearoff_scrollbar
  struct _GtkWidget *tearoff_scrollbar;
  // tearoff_adjustment
  struct _GtkAdjustment *tearoff_adjustment;
  // view_window
  struct _GdkDrawable *view_window;
  // bin_window
  struct _GdkDrawable *bin_window;
  // scroll_offset
  signed int scroll_offset;
  // saved_scroll_offset
  signed int saved_scroll_offset;
  // scroll_step
  signed int scroll_step;
  // timeout_id
  unsigned int timeout_id;
  // navigation_region
  struct _GdkRegion *navigation_region;
  // navigation_timeout
  unsigned int navigation_timeout;
  // needs_destruction_ref_count
  unsigned int needs_destruction_ref_count : 1;
  // torn_off
  unsigned int torn_off : 1;
  // tearoff_active
  unsigned int tearoff_active : 1;
  // scroll_fast
  unsigned int scroll_fast : 1;
  // upper_arrow_visible
  unsigned int upper_arrow_visible : 1;
  // lower_arrow_visible
  unsigned int lower_arrow_visible : 1;
  // upper_arrow_prelight
  unsigned int upper_arrow_prelight : 1;
  // lower_arrow_prelight
  unsigned int lower_arrow_prelight : 1;
};

struct _GtkMenuBar
{
  // menu_shell
  struct _GtkMenuShell menu_shell;
};

struct _GtkMenuItem
{
  // item
  struct _GtkItem item;
  // submenu
  struct _GtkWidget *submenu;
  // event_window
  struct _GdkDrawable *event_window;
  // toggle_size
  unsigned short int toggle_size;
  // accelerator_width
  unsigned short int accelerator_width;
  // accel_path
  char *accel_path;
  // show_submenu_indicator
  unsigned int show_submenu_indicator : 1;
  // submenu_placement
  unsigned int submenu_placement : 1;
  // submenu_direction
  unsigned int submenu_direction : 1;
  // right_justify
  unsigned int right_justify : 1;
  // timer_from_keypress
  unsigned int timer_from_keypress : 1;
  // from_menubar
  unsigned int from_menubar : 1;
  // timer
  unsigned int timer;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous$19 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSelectionData
{
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // type
  struct _GdkAtom *type;
  // format
  signed int format;
  // data
  unsigned char *data;
  // length
  signed int length;
  // display
  struct _GdkDisplay *display;
};

struct _GtkSettings
{
  // parent_instance
  struct _GObject parent_instance;
  // queued_settings
  struct _GData *queued_settings;
  // property_values
  struct _GtkSettingsPropertyValue *property_values;
  // rc_context
  struct _GtkRcContext *rc_context;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkTextBuffer
{
  // parent_instance
  struct _GObject parent_instance;
  // tag_table
  struct _GtkTextTagTable *tag_table;
  // btree
  struct _GtkTextBTree *btree;
  // clipboard_contents_buffers
  struct _GSList *clipboard_contents_buffers;
  // selection_clipboards
  struct _GSList *selection_clipboards;
  // log_attr_cache
  struct _GtkTextLogAttrCache *log_attr_cache;
  // user_action_count
  unsigned int user_action_count;
  // modified
  unsigned int modified : 1;
  // has_selection
  unsigned int has_selection : 1;
};

struct _GtkSourceBuffer
{
  // parent_instance
  struct _GtkTextBuffer parent_instance;
  // priv
  struct _GtkSourceBufferPrivate *priv;
};

struct _GtkSourceLanguage
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkSourceLanguagePrivate *priv;
};

struct _GtkSourceLanguageManager
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkSourceLanguageManagerPrivate *priv;
};

struct _GtkSourceStyleScheme
{
  // base
  struct _GObject base;
  // priv
  struct _GtkSourceStyleSchemePrivate *priv;
};

struct _GtkSourceStyleSchemeClass
{
  // base_class
  struct _GObjectClass base_class;
  // _gtk_source_reserved1
  void (*_gtk_source_reserved1)(void);
  // _gtk_source_reserved2
  void (*_gtk_source_reserved2)(void);
};

struct _GtkSourceView
{
  // parent
  struct _GtkTextView parent;
  // priv
  struct _GtkSourceViewPrivate *priv;
};

struct _GtkSpinButton
{
  // entry
  struct _GtkEntry entry;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // panel
  struct _GdkDrawable *panel;
  // timer
  unsigned int timer;
  // climb_rate
  double climb_rate;
  // timer_step
  double timer_step;
  // update_policy
  enum anonymous$153 update_policy;
  // in_child
  unsigned int in_child : 2;
  // click_child
  unsigned int click_child : 2;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // timer_calls
  unsigned int timer_calls : 3;
  // digits
  unsigned int digits : 10;
  // numeric
  unsigned int numeric : 1;
  // wrap
  unsigned int wrap : 1;
  // snap_to_ticks
  unsigned int snap_to_ticks : 1;
};

struct _GtkStatusbar
{
  // parent_widget
  struct _GtkHBox parent_widget;
  // frame
  struct _GtkWidget *frame;
  // label
  struct _GtkWidget *label;
  // messages
  struct _GSList *messages;
  // keys
  struct _GSList *keys;
  // seq_context_id
  unsigned int seq_context_id;
  // seq_message_id
  unsigned int seq_message_id;
  // grip_window
  struct _GdkDrawable *grip_window;
  // has_resize_grip
  unsigned int has_resize_grip : 1;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTable
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // rows
  struct _GtkTableRowCol *rows;
  // cols
  struct _GtkTableRowCol *cols;
  // nrows
  unsigned short int nrows;
  // ncols
  unsigned short int ncols;
  // column_spacing
  unsigned short int column_spacing;
  // row_spacing
  unsigned short int row_spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkTableRowCol
{
  // requisition
  unsigned short int requisition;
  // allocation
  unsigned short int allocation;
  // spacing
  unsigned short int spacing;
  // need_expand
  unsigned int need_expand : 1;
  // need_shrink
  unsigned int need_shrink : 1;
  // expand
  unsigned int expand : 1;
  // shrink
  unsigned int shrink : 1;
  // empty
  unsigned int empty : 1;
};

struct _GtkTargetEntry
{
  // target
  char *target;
  // flags
  unsigned int flags;
  // info
  unsigned int info;
};

struct _GtkTargetList
{
  // list
  struct _GList *list;
  // ref_count
  unsigned int ref_count;
};

struct _GtkTextAppearance
{
  // bg_color
  struct _GdkColor bg_color;
  // fg_color
  struct _GdkColor fg_color;
  // bg_stipple
  struct _GdkDrawable *bg_stipple;
  // fg_stipple
  struct _GdkDrawable *fg_stipple;
  // rise
  signed int rise;
  // padding1
  void *padding1;
  // underline
  unsigned int underline : 4;
  // strikethrough
  unsigned int strikethrough : 1;
  // draw_bg
  unsigned int draw_bg : 1;
  // inside_selection
  unsigned int inside_selection : 1;
  // is_text
  unsigned int is_text : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextAttributes
{
  // refcount
  unsigned int refcount;
  // appearance
  struct _GtkTextAppearance appearance;
  // justification
  enum anonymous$76 justification;
  // direction
  enum anonymous$24 direction;
  // font
  struct _PangoFontDescription *font;
  // font_scale
  double font_scale;
  // left_margin
  signed int left_margin;
  // indent
  signed int indent;
  // right_margin
  signed int right_margin;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // tabs
  struct _PangoTabArray *tabs;
  // wrap_mode
  enum anonymous$77 wrap_mode;
  // language
  struct _PangoLanguage *language;
  // pg_bg_color
  struct _GdkColor *pg_bg_color;
  // invisible
  unsigned int invisible : 1;
  // bg_full_height
  unsigned int bg_full_height : 1;
  // editable
  unsigned int editable : 1;
  // realized
  unsigned int realized : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  signed int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  void *dummy9;
  // dummy10
  void *dummy10;
  // dummy11
  signed int dummy11;
  // dummy12
  signed int dummy12;
  // dummy13
  signed int dummy13;
  // dummy14
  void *dummy14;
};

struct _GtkTextMark
{
  // parent_instance
  struct _GObject parent_instance;
  // segment
  void *segment;
};

struct _GtkTextTag
{
  // parent_instance
  struct _GObject parent_instance;
  // table
  struct _GtkTextTagTable *table;
  // name
  char *name;
  // priority
  signed int priority;
  // values
  struct _GtkTextAttributes *values;
  // bg_color_set
  unsigned int bg_color_set : 1;
  // bg_stipple_set
  unsigned int bg_stipple_set : 1;
  // fg_color_set
  unsigned int fg_color_set : 1;
  // scale_set
  unsigned int scale_set : 1;
  // fg_stipple_set
  unsigned int fg_stipple_set : 1;
  // justification_set
  unsigned int justification_set : 1;
  // left_margin_set
  unsigned int left_margin_set : 1;
  // indent_set
  unsigned int indent_set : 1;
  // rise_set
  unsigned int rise_set : 1;
  // strikethrough_set
  unsigned int strikethrough_set : 1;
  // right_margin_set
  unsigned int right_margin_set : 1;
  // pixels_above_lines_set
  unsigned int pixels_above_lines_set : 1;
  // pixels_below_lines_set
  unsigned int pixels_below_lines_set : 1;
  // pixels_inside_wrap_set
  unsigned int pixels_inside_wrap_set : 1;
  // tabs_set
  unsigned int tabs_set : 1;
  // underline_set
  unsigned int underline_set : 1;
  // wrap_mode_set
  unsigned int wrap_mode_set : 1;
  // bg_full_height_set
  unsigned int bg_full_height_set : 1;
  // invisible_set
  unsigned int invisible_set : 1;
  // editable_set
  unsigned int editable_set : 1;
  // language_set
  unsigned int language_set : 1;
  // pg_bg_color_set
  unsigned int pg_bg_color_set : 1;
  // accumulative_margin
  unsigned int accumulative_margin : 1;
  // pad1
  unsigned int pad1 : 1;
};

struct _GtkTextTagTable
{
  // parent_instance
  struct _GObject parent_instance;
  // hash
  struct _GHashTable *hash;
  // anonymous
  struct _GSList *anonymous;
  // anon_count
  signed int anon_count;
  // buffers
  struct _GSList *buffers;
};

struct _GtkToggleAction
{
  // parent
  struct _GtkAction parent;
  // private_data
  struct _GtkToggleActionPrivate *private_data;
};

struct _GtkToggleActionEntry
{
  // name
  const char *name;
  // stock_id
  const char *stock_id;
  // label
  const char *label;
  // accelerator
  const char *accelerator;
  // tooltip
  const char *tooltip;
  // callback
  void (*callback)(void);
  // is_active
  signed int is_active;
};

struct _GtkToolbar
{
  // container
  struct _GtkContainer container;
  // num_children
  signed int num_children;
  // children
  struct _GList *children;
  // orientation
  enum anonymous$9 orientation;
  // style
  enum anonymous$20 style;
  // icon_size
  enum anonymous$21 icon_size;
  // tooltips
  struct _GtkTooltips *tooltips;
  // button_maxw
  signed int button_maxw;
  // button_maxh
  signed int button_maxh;
  // _gtk_reserved1
  unsigned int _gtk_reserved1;
  // _gtk_reserved2
  unsigned int _gtk_reserved2;
  // style_set
  unsigned int style_set : 1;
  // icon_size_set
  unsigned int icon_size_set : 1;
};

struct _GtkTooltips
{
  // parent_instance
  struct _GtkObject parent_instance;
  // tip_window
  struct _GtkWidget *tip_window;
  // tip_label
  struct _GtkWidget *tip_label;
  // active_tips_data
  struct _GtkTooltipsData *active_tips_data;
  // tips_data_list
  struct _GList *tips_data_list;
  // delay
  unsigned int delay : 30;
  // enabled
  unsigned int enabled : 1;
  // have_grab
  unsigned int have_grab : 1;
  // use_sticky_delay
  unsigned int use_sticky_delay : 1;
  // timer_tag
  signed int timer_tag;
  // last_popdown
  struct _GTimeVal last_popdown;
};

struct _GtkTooltipsData
{
  // tooltips
  struct _GtkTooltips *tooltips;
  // widget
  struct _GtkWidget *widget;
  // tip_text
  char *tip_text;
  // tip_private
  char *tip_private;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct _GtkTreeModelSort
{
  // parent
  struct _GObject parent;
  // root
  void *root;
  // stamp
  signed int stamp;
  // child_flags
  unsigned int child_flags;
  // child_model
  struct _GtkTreeModel *child_model;
  // zero_ref_count
  signed int zero_ref_count;
  // sort_list
  struct _GList *sort_list;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous$151 order;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // changed_id
  unsigned int changed_id;
  // inserted_id
  unsigned int inserted_id;
  // has_child_toggled_id
  unsigned int has_child_toggled_id;
  // deleted_id
  unsigned int deleted_id;
  // reordered_id
  unsigned int reordered_id;
};

struct _GtkTreeSelection
{
  // parent
  struct _GObject parent;
  // tree_view
  struct _GtkTreeView *tree_view;
  // type
  enum anonymous$78 type;
  // user_func
  signed int (*user_func)(struct _GtkTreeSelection *, struct _GtkTreeModel *, struct _GtkTreePath *, signed int, void *);
  // user_data
  void *user_data;
  // destroy
  void (*destroy)(void *);
};

struct _GtkTreeViewColumn
{
  // parent
  struct _GtkObject parent;
  // tree_view
  struct _GtkWidget *tree_view;
  // button
  struct _GtkWidget *button;
  // child
  struct _GtkWidget *child;
  // arrow
  struct _GtkWidget *arrow;
  // alignment
  struct _GtkWidget *alignment;
  // window
  struct _GdkDrawable *window;
  // editable_widget
  struct _GtkCellEditable *editable_widget;
  // xalign
  float xalign;
  // property_changed_signal
  unsigned int property_changed_signal;
  // spacing
  signed int spacing;
  // column_type
  enum anonymous$150 column_type;
  // requested_width
  signed int requested_width;
  // button_request
  signed int button_request;
  // resized_width
  signed int resized_width;
  // width
  signed int width;
  // fixed_width
  signed int fixed_width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // drag_x
  signed int drag_x;
  // drag_y
  signed int drag_y;
  // title
  char *title;
  // cell_list
  struct _GList *cell_list;
  // sort_clicked_signal
  unsigned int sort_clicked_signal;
  // sort_column_changed_signal
  unsigned int sort_column_changed_signal;
  // sort_column_id
  signed int sort_column_id;
  // sort_order
  enum anonymous$151 sort_order;
  // visible
  unsigned int visible : 1;
  // resizable
  unsigned int resizable : 1;
  // clickable
  unsigned int clickable : 1;
  // dirty
  unsigned int dirty : 1;
  // show_sort_indicator
  unsigned int show_sort_indicator : 1;
  // maybe_reordered
  unsigned int maybe_reordered : 1;
  // reorderable
  unsigned int reorderable : 1;
  // use_resized_width
  unsigned int use_resized_width : 1;
  // expand
  unsigned int expand : 1;
};

struct _GtkUIManager
{
  // parent
  struct _GObject parent;
  // private_data
  struct _GtkUIManagerPrivate *private_data;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _LevelMap
{
  // name
  const char *name;
  // level
  enum _GmDebugLevel level;
};

struct _MOOVar
{
  // type
  enum anonymous$34 type;
  // s
  char *s;
  // i
  signed int i;
  // d
  double d;
  // list
  struct _MOOVar *list;
  // next
  struct _MOOVar *next;
};

struct _McpMessageInfo
{
  // name
  char *name;
  // authkey
  char *authkey;
  // fields
  struct _GList *fields;
};

struct _McpMultilineInfo
{
  // key
  char *key;
  // data_tag
  char *data_tag;
  // data
  struct _GList *data;
  // package
  struct _GmMcpPackage *package;
};

struct _ModelData
{
  // type
  signed int type;
  // title
  char *title;
  // args
  signed int args;
  // func
  void * (*func)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *);
};

struct _Notify
{
  // handle
  struct _NotifyNotification *handle;
};

struct _NotifyNotification
{
  // parent_object
  struct _GObject parent_object;
  // priv
  struct _NotifyNotificationPrivate *priv;
};

struct _PackageInfo
{
  // klass
  struct _GmMcpPackageClass *klass;
  // version
  double version;
};

struct _PangoAttrClass
{
  // type
  enum anonymous$2 type;
  // copy
  struct _PangoAttribute * (*copy)(const struct _PangoAttribute *);
  // destroy
  void (*destroy)(struct _PangoAttribute *);
  // equal
  signed int (*equal)(const struct _PangoAttribute *, const struct _PangoAttribute *);
};

struct _PangoAttribute
{
  // klass
  const struct _PangoAttrClass *klass;
  // start_index
  unsigned int start_index;
  // end_index
  unsigned int end_index;
};

struct _SortInfo
{
  // name
  char *name;
  // rank_priority
  signed int rank_priority;
  // state_priority
  signed int state_priority;
};

struct _TagPair
{
  // name
  const char *name;
  // tag
  const char *tag;
};

struct _UserInfo
{
  // nr
  signed int nr;
  // icon
  unsigned int icon;
  // name
  char *name;
  // state
  enum _UserState state;
};

struct _VteTerminal
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // char_width
  signed long int char_width;
  // char_height
  signed long int char_height;
  // char_ascent
  signed long int char_ascent;
  // char_descent
  signed long int char_descent;
  // row_count
  signed long int row_count;
  // column_count
  signed long int column_count;
  // window_title
  char *window_title;
  // icon_title
  char *icon_title;
  // pvt
  struct _VteTerminalPrivate *pvt;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$114 xany;
  // xkey
  struct anonymous$115 xkey;
  // xbutton
  struct anonymous$116 xbutton;
  // xmotion
  struct anonymous$117 xmotion;
  // xcrossing
  struct anonymous$118 xcrossing;
  // xfocus
  struct anonymous$119 xfocus;
  // xexpose
  struct anonymous$120 xexpose;
  // xgraphicsexpose
  struct anonymous$121 xgraphicsexpose;
  // xnoexpose
  struct anonymous$122 xnoexpose;
  // xvisibility
  struct anonymous$123 xvisibility;
  // xcreatewindow
  struct anonymous$124 xcreatewindow;
  // xdestroywindow
  struct anonymous$125 xdestroywindow;
  // xunmap
  struct anonymous$126 xunmap;
  // xmap
  struct anonymous$127 xmap;
  // xmaprequest
  struct anonymous$128 xmaprequest;
  // xreparent
  struct anonymous$129 xreparent;
  // xconfigure
  struct anonymous$130 xconfigure;
  // xgravity
  struct anonymous$131 xgravity;
  // xresizerequest
  struct anonymous$132 xresizerequest;
  // xconfigurerequest
  struct anonymous$133 xconfigurerequest;
  // xcirculate
  struct anonymous$134 xcirculate;
  // xcirculaterequest
  struct anonymous$135 xcirculaterequest;
  // xproperty
  struct anonymous$136 xproperty;
  // xselectionclear
  struct anonymous$137 xselectionclear;
  // xselectionrequest
  struct anonymous$138 xselectionrequest;
  // xselection
  struct anonymous$139 xselection;
  // xcolormap
  struct anonymous$140 xcolormap;
  // xclient
  struct anonymous$141 xclient;
  // xmapping
  struct anonymous$142 xmapping;
  // xerror
  struct anonymous$143 xerror;
  // xkeymap
  struct anonymous$144 xkeymap;
  // xgeneric
  struct anonymous$145 xgeneric;
  // xcookie
  struct anonymous$146 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct _ansinamepair
{
  // code
  const enum _ansi_code code;
  // name
  const char *name;
};

struct _encoding
{
  // charset
  const char *charset;
  // name
  const char *name;
};

struct _threadinfo
{
  // host
  char *host;
  // port
  char *port;
  // addr
  struct addrinfo *addr;
  // current
  struct addrinfo *current;
  // tmp
  struct addrinfo *tmp;
  // mutex_idle
  union anonymous$66 *mutex_idle;
  // idle_id
  unsigned int idle_id;
  // ret
  signed int ret;
  // message
  char *message;
  // net
  struct _GmNet *net;
};

struct _trigger_trans
{
  // type
  signed int type;
  // name
  const char *name;
};

struct _xmlAttr
{
  // _private
  void *_private;
  // type
  enum anonymous$60 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlAttr *next;
  // prev
  struct _xmlAttr *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // atype
  enum anonymous$61 atype;
  // psvi
  void *psvi;
};

struct _xmlDoc
{
  // _private
  void *_private;
  // type
  enum anonymous$60 type;
  // name
  char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // compression
  signed int compression;
  // standalone
  signed int standalone;
  // intSubset
  struct _xmlDtd *intSubset;
  // extSubset
  struct _xmlDtd *extSubset;
  // oldNs
  struct _xmlNs *oldNs;
  // version
  const unsigned char *version;
  // encoding
  const unsigned char *encoding;
  // ids
  void *ids;
  // refs
  void *refs;
  // URL
  const unsigned char *URL;
  // charset
  signed int charset;
  // dict
  struct _xmlDict *dict;
  // psvi
  void *psvi;
  // parseFlags
  signed int parseFlags;
  // properties
  signed int properties;
};

struct _xmlDtd
{
  // _private
  void *_private;
  // type
  enum anonymous$60 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlDoc *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // notations
  void *notations;
  // elements
  void *elements;
  // attributes
  void *attributes;
  // entities
  void *entities;
  // ExternalID
  const unsigned char *ExternalID;
  // SystemID
  const unsigned char *SystemID;
  // pentities
  void *pentities;
};

struct _xmlNode
{
  // _private
  void *_private;
  // type
  enum anonymous$60 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // content
  unsigned char *content;
  // properties
  struct _xmlAttr *properties;
  // nsDef
  struct _xmlNs *nsDef;
  // psvi
  void *psvi;
  // line
  unsigned short int line;
  // extra
  unsigned short int extra;
};

struct _xmlNs
{
  // next
  struct _xmlNs *next;
  // type
  enum anonymous$60 type;
  // href
  const unsigned char *href;
  // prefix
  const unsigned char *prefix;
  // _private
  void *_private;
  // context
  struct _xmlDoc *context;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct lconv
{
  // decimal_point
  char *decimal_point;
  // thousands_sep
  char *thousands_sep;
  // grouping
  char *grouping;
  // int_curr_symbol
  char *int_curr_symbol;
  // currency_symbol
  char *currency_symbol;
  // mon_decimal_point
  char *mon_decimal_point;
  // mon_thousands_sep
  char *mon_thousands_sep;
  // mon_grouping
  char *mon_grouping;
  // positive_sign
  char *positive_sign;
  // negative_sign
  char *negative_sign;
  // int_frac_digits
  char int_frac_digits;
  // frac_digits
  char frac_digits;
  // p_cs_precedes
  char p_cs_precedes;
  // p_sep_by_space
  char p_sep_by_space;
  // n_cs_precedes
  char n_cs_precedes;
  // n_sep_by_space
  char n_sep_by_space;
  // p_sign_posn
  char p_sign_posn;
  // n_sign_posn
  char n_sign_posn;
  // int_p_cs_precedes
  char int_p_cs_precedes;
  // int_p_sep_by_space
  char int_p_sep_by_space;
  // int_n_cs_precedes
  char int_n_cs_precedes;
  // int_n_sep_by_space
  char int_n_sep_by_space;
  // int_p_sign_posn
  char int_p_sign_posn;
  // int_n_sign_posn
  char int_n_sign_posn;
};

struct poptOption
{
  // longName
  const char *longName;
  // shortName
  char shortName;
  // argInfo
  unsigned int argInfo;
  // arg
  void *arg;
  // val
  signed int val;
  // descrip
  const char *descrip;
  // argDescrip
  const char *argDescrip;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// GmAppView_private_offset
// file widgets/gm-app-view.c line 167
static signed int GmAppView_private_offset;
// GmApp_private_offset
// file gm-app.c line 88
static signed int GmApp_private_offset;
// GmCellRendererText_private_offset
// file mcp/gm-cell-renderer-text.c line 41
static signed int GmCellRendererText_private_offset;
// GmColorTable_private_offset
// file gm-color-table.c line 245
static signed int GmColorTable_private_offset;
// GmEditorView_private_offset
// file widgets/gm-editor-view.c line 91
static signed int GmEditorView_private_offset;
// GmEditor_private_offset
// file gm-editor.c line 37
static signed int GmEditor_private_offset;
// GmEmbeddedView_private_offset
// file widgets/gm-embedded-view.c line 43
static signed int GmEmbeddedView_private_offset;
// GmLogView_private_offset
// file widgets/gm-log-view.c line 31
static signed int GmLogView_private_offset;
// GmMcpAwnsPing_private_offset
// file mcp/gm-mcp-awns-ping.c line 22
static signed int GmMcpAwnsPing_private_offset;
// GmMcpAwnsStatus_private_offset
// file mcp/gm-mcp-awns-status.c line 34
static signed int GmMcpAwnsStatus_private_offset;
// GmMcpIcecrewMcpreset_private_offset
// file mcp/gm-mcp-icecrew-mcpreset.c line 21
static signed int GmMcpIcecrewMcpreset_private_offset;
// GmMcpIcecrewPlayerdb_private_offset
// file mcp/gm-mcp-icecrew-playerdb.c line 32
static signed int GmMcpIcecrewPlayerdb_private_offset;
// GmMcpIcecrewServerinfo_private_offset
// file mcp/gm-mcp-icecrew-serverinfo.c line 36
static signed int GmMcpIcecrewServerinfo_private_offset;
// GmMcpIcecrewUserlist_private_offset
// file mcp/gm-mcp-icecrew-userlist.c line 97
static signed int GmMcpIcecrewUserlist_private_offset;
// GmMcpMudMooSimpleedit_private_offset
// file mcp/gm-mcp-mud-moo-simpleedit.c line 29
static signed int GmMcpMudMooSimpleedit_private_offset;
// GmMcpNegotiate_private_offset
// file mcp/gm-mcp-negotiate.c line 36
static signed int GmMcpNegotiate_private_offset;
// GmMcpPackage_private_offset
// file mcp/gm-mcp-package.c line 24
static signed int GmMcpPackage_private_offset;
// GmMcpSession_private_offset
// file mcp/gm-mcp-session.c line 35
static signed int GmMcpSession_private_offset;
// GmMcpVmooClient_private_offset
// file mcp/gm-mcp-vmoo-client.c line 38
static signed int GmMcpVmooClient_private_offset;
// GmMcpVmooUserlist_private_offset
// file mcp/gm-mcp-vmoo-userlist.c line 61
static signed int GmMcpVmooUserlist_private_offset;
// GmNet_private_offset
// file gm-net.c line 73
static signed int GmNet_private_offset;
// GmOptions_private_offset
// file gm-options.c line 35
static signed int GmOptions_private_offset;
// GmTextScroller_private_offset
// file widgets/gm-text-scroller.c line 42
static signed int GmTextScroller_private_offset;
// GmTray_private_offset
// file widgets/gm-tray.c line 27
static signed int GmTray_private_offset;
// GmTriggers_private_offset
// file gm-triggers.c line 60
static signed int GmTriggers_private_offset;
// GmWorldInputView_private_offset
// file widgets/gm-world-input-view.c line 38
static signed int GmWorldInputView_private_offset;
// GmWorldTab_private_offset
// file widgets/gm-world-tab.c line 35
static signed int GmWorldTab_private_offset;
// GmWorldTextView_private_offset
// file widgets/gm-world-text-view.c line 113
static signed int GmWorldTextView_private_offset;
// GmWorldView_private_offset
// file widgets/gm-world-view.c line 89
static signed int GmWorldView_private_offset;
// GmWorld_private_offset
// file gm-world.c line 94
static signed int GmWorld_private_offset;
// GmWorldsView_private_offset
// file widgets/gm-worlds-view.c line 34
static signed int GmWorldsView_private_offset;
// action
// file mcp/gm-mcp-icecrew-serverinfo.c line 25
struct _GmMcpIcecrewServerinfoPrivate action;
// ansi_colors
// file ./gm-ansi.h line 80
static const struct _ansinamepair ansi_colors[27l] = { { .code=(const enum _ansi_code)30, .name="fg_black" }, 
    { .code=(const enum _ansi_code)31, .name="fg_red" }, 
    { .code=(const enum _ansi_code)32, .name="fg_green" }, 
    { .code=(const enum _ansi_code)33, .name="fg_yellow" }, 
    { .code=(const enum _ansi_code)34, .name="fg_blue" }, 
    { .code=(const enum _ansi_code)35, .name="fg_purple" }, 
    { .code=(const enum _ansi_code)36, .name="fg_cyan" }, 
    { .code=(const enum _ansi_code)37, .name="fg_white" }, 
    { .code=(const enum _ansi_code)39, .name="fg_default" }, 
    { .code=(const enum _ansi_code)51, .name="fg_black_h" }, 
    { .code=(const enum _ansi_code)52, .name="fg_red_h" }, 
    { .code=(const enum _ansi_code)53, .name="fg_green_h" }, 
    { .code=(const enum _ansi_code)54, .name="fg_yellow_h" }, 
    { .code=(const enum _ansi_code)55, .name="fg_blue_h" }, 
    { .code=(const enum _ansi_code)56, .name="fg_purple_h" }, 
    { .code=(const enum _ansi_code)57, .name="fg_cyan_h" }, 
    { .code=(const enum _ansi_code)58, .name="fg_white_h" }, 
    { .code=(const enum _ansi_code)59, .name="fg_default_h" }, 
    { .code=(const enum _ansi_code)40, .name="bg_black" }, 
    { .code=(const enum _ansi_code)41, .name="bg_red" }, 
    { .code=(const enum _ansi_code)42, .name="bg_green" }, 
    { .code=(const enum _ansi_code)43, .name="bg_yellow" }, 
    { .code=(const enum _ansi_code)44, .name="bg_blue" }, 
    { .code=(const enum _ansi_code)45, .name="bg_purple" }, 
    { .code=(const enum _ansi_code)46, .name="bg_cyan" }, 
    { .code=(const enum _ansi_code)47, .name="bg_white" }, 
    { .code=(const enum _ansi_code)49, .name="bg_default" } };
// ansi_colors$link1
// file gm-ansi.h line 80
static const struct _ansinamepair ansi_colors$link1[27l] = { { .code=(const enum _ansi_code)30, .name="fg_black" }, 
    { .code=(const enum _ansi_code)31, .name="fg_red" }, 
    { .code=(const enum _ansi_code)32, .name="fg_green" }, 
    { .code=(const enum _ansi_code)33, .name="fg_yellow" }, 
    { .code=(const enum _ansi_code)34, .name="fg_blue" }, 
    { .code=(const enum _ansi_code)35, .name="fg_purple" }, 
    { .code=(const enum _ansi_code)36, .name="fg_cyan" }, 
    { .code=(const enum _ansi_code)37, .name="fg_white" }, 
    { .code=(const enum _ansi_code)39, .name="fg_default" }, 
    { .code=(const enum _ansi_code)51, .name="fg_black_h" }, 
    { .code=(const enum _ansi_code)52, .name="fg_red_h" }, 
    { .code=(const enum _ansi_code)53, .name="fg_green_h" }, 
    { .code=(const enum _ansi_code)54, .name="fg_yellow_h" }, 
    { .code=(const enum _ansi_code)55, .name="fg_blue_h" }, 
    { .code=(const enum _ansi_code)56, .name="fg_purple_h" }, 
    { .code=(const enum _ansi_code)57, .name="fg_cyan_h" }, 
    { .code=(const enum _ansi_code)58, .name="fg_white_h" }, 
    { .code=(const enum _ansi_code)59, .name="fg_default_h" }, 
    { .code=(const enum _ansi_code)40, .name="bg_black" }, 
    { .code=(const enum _ansi_code)41, .name="bg_red" }, 
    { .code=(const enum _ansi_code)42, .name="bg_green" }, 
    { .code=(const enum _ansi_code)43, .name="bg_yellow" }, 
    { .code=(const enum _ansi_code)44, .name="bg_blue" }, 
    { .code=(const enum _ansi_code)45, .name="bg_purple" }, 
    { .code=(const enum _ansi_code)46, .name="bg_cyan" }, 
    { .code=(const enum _ansi_code)47, .name="bg_white" }, 
    { .code=(const enum _ansi_code)49, .name="bg_default" } };
// ansi_styles
// file ./gm-ansi.h line 114
static const struct _ansinamepair ansi_styles[12l] = { { .code=(const enum _ansi_code)1, .name="bold" }, 
    { .code=(const enum _ansi_code)2, .name="faint" }, 
    { .code=(const enum _ansi_code)22, .name="bold-off" }, 
    { .code=(const enum _ansi_code)4, .name="underline" }, 
    { .code=(const enum _ansi_code)21, .name="dblunderline" }, 
    { .code=(const enum _ansi_code)24, .name="underline-off" }, 
    { .code=(const enum _ansi_code)9, .name="crossout" }, 
    { .code=(const enum _ansi_code)29, .name="crossout-off" }, 
    { .code=(const enum _ansi_code)3, .name="italic" }, 
    { .code=(const enum _ansi_code)23, .name="italic-off" }, 
    { .code=(const enum _ansi_code)8, .name="invisible" }, 
    { .code=(const enum _ansi_code)28, .name="invisible-off" } };
// app_signals
// file gm-app.c line 86
static unsigned int app_signals[2l] = { (unsigned int)0, 0u };
// application
// file gm-app.c line 27
static struct _GmApp *application;
// artists
// file widgets/gm-commands.c line 242
static const char *artists[2l] = { "Simon Gijsen", (const char *)(void *)0 };
// authors
// file widgets/gm-commands.c line 236
static const char *authors[3l] = { "Jesse van den Kieboom", "Sjoerd Simons (debian package)", (const char *)(void *)0 };
// color_mapping
// file dialogs/gm-preferences-dialog.c line 83
static const struct _GmKeyValuePair color_mapping[28l] = { { .key="color_button_fg_default", .value="fg_default" }, 
    { .key="color_button_fg_default_h", .value="fg_default_h" }, 
    { .key="color_button_bg_default", .value="bg_default" }, 
    { .key="color_button_fg_black", .value="fg_black" }, 
    { .key="color_button_fg_black_h", .value="fg_black_h" }, 
    { .key="color_button_fg_red", .value="fg_red" }, 
    { .key="color_button_fg_red_h", .value="fg_red_h" }, 
    { .key="color_button_fg_green", .value="fg_green" }, 
    { .key="color_button_fg_green_h", .value="fg_green_h" }, 
    { .key="color_button_fg_yellow", .value="fg_yellow" }, 
    { .key="color_button_fg_yellow_h", .value="fg_yellow_h" }, 
    { .key="color_button_fg_blue", .value="fg_blue" }, 
    { .key="color_button_fg_blue_h", .value="fg_blue_h" }, 
    { .key="color_button_fg_purple", .value="fg_purple" }, 
    { .key="color_button_fg_purple_h", .value="fg_purple_h" }, 
    { .key="color_button_fg_cyan", .value="fg_cyan" }, 
    { .key="color_button_fg_cyan_h", .value="fg_cyan_h" }, 
    { .key="color_button_fg_white", .value="fg_white" }, 
    { .key="color_button_fg_white_h", .value="fg_white_h" }, 
    { .key="color_button_bg_black", .value="bg_black" }, 
    { .key="color_button_bg_red", .value="bg_red" }, 
    { .key="color_button_bg_green", .value="bg_green" }, 
    { .key="color_button_bg_yellow", .value="bg_yellow" }, 
    { .key="color_button_bg_blue", .value="bg_blue" }, 
    { .key="color_button_bg_purple", .value="bg_purple" }, 
    { .key="color_button_bg_cyan", .value="bg_cyan" }, 
    { .key="color_button_bg_white", .value="bg_white" }, 
    { .key=(char *)(void *)0, .value=(char *)(void *)0 } };
// color_schemes
// file dialogs/gm-preferences-dialog.c line 116
static const struct _GmKeyValuePair color_schemes[7l] = { { .key="Default", .value="default" }, { .key="White on black", .value="white_on_black" }, 
    { .key="Rxvt", .value="rxvt" }, { .key="XTerm", .value="xterm" }, { .key="Linux", .value="linux" }, { .key="User defined", .value="user" }, { .key=(char *)(void *)0, .value=(char *)(void *)0 } };
// color_table_signals
// file gm-color-table.c line 243
static unsigned int color_table_signals[2l] = { (unsigned int)0, 0u };
// commands
// file dialogs/gm-world-paste-dialog.c line 38
static const char *commands[3l] = { "@paste", "@chanpaste", (const char *)(void *)0 };
// compare_functions
// file mcp/gm-mcp-userlist-view.c line 78
static signed int (*compare_functions[4l])(struct _SortInfo *, struct _SortInfo *);
// compare_functions
// file mcp/gm-mcp-userlist-view.c line 78
static signed int (*compare_functions[4l])(struct _SortInfo *, struct _SortInfo *) = { gm_mcp_userlist_view_sort_state_rank_name, 
    gm_mcp_userlist_view_sort_rank_name, gm_mcp_userlist_view_sort_state_name, gm_mcp_userlist_view_sort_name };
// dataActionOutput
// file dialogs/gm-triggers-dialog.c line 137
static const struct _ModelData dataActionOutput[7l];
// dataActionOutput
// file dialogs/gm-triggers-dialog.c line 137
static const struct _ModelData dataActionOutput[7l] = { { .type=0, .title="Highlight line", .args=2, .func=gm_triggers_dialog_custom_arg_highlight }, 
    { .type=1, .title="Highlight match", .args=2, .func=gm_triggers_dialog_custom_arg_highlight }, 
    { .type=2, .title="Beep", .args=0, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=3, .title="Play sound", .args=2, .func=gm_triggers_dialog_custom_arg_browse }, 
    { .type=4, .title="Notify", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=6, .title="Run", .args=2, .func=gm_triggers_dialog_custom_arg_browse }, 
    { .type=-1, .title=(char *)(void *)0, .args=0, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 } };
// dataActionUsers
// file dialogs/gm-triggers-dialog.c line 155
static const struct _ModelData dataActionUsers[5l];
// dataActionUsers
// file dialogs/gm-triggers-dialog.c line 155
static const struct _ModelData dataActionUsers[5l] = { { .type=2, .title="Beep", .args=0, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=3, .title="Play sound", .args=2, .func=gm_triggers_dialog_custom_arg_browse }, 
    { .type=4, .title="Notify", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=6, .title="Run", .args=2, .func=gm_triggers_dialog_custom_arg_browse }, 
    { .type=-1, .title=(char *)(void *)0, .args=0, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 } };
// dataConditionOutput
// file dialogs/gm-triggers-dialog.c line 115
static const struct _ModelData dataConditionOutput[9l] = { { .type=0, .title="Contains", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=1, .title="Not contains", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=2, .title="Begins with", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=3, .title="Not begins with", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=4, .title="Ends with", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=5, .title="Not ends with", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=6, .title="Matches", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=7, .title="Not matches", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=-1, .title=(char *)(void *)0, .args=0, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 } };
// dataConditionUsers
// file dialogs/gm-triggers-dialog.c line 127
static const struct _ModelData dataConditionUsers[7l] = { { .type=8, .title="Online", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=9, .title="Offline", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=10, .title="Idle", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=11, .title="No longer idle", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=12, .title="Away", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=13, .title="No longer away", .args=1, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 }, 
    { .type=-1, .title=(char *)(void *)0, .args=0, .func=(void * (*)(struct _GmTriggersDialog *, enum _CustomArgType, void *, void *))(void *)0 } };
// debug_level
// file gm-app.c line 23
static char *debug_level = (char *)(void *)0;
// debug_level$link1
// file gm-debug.c line 23
static signed int debug_level$link1 = 2;
// default_ranks
// file mcp/gm-mcp-icecrew-userlist.c line 34
static struct _GmKeyValuePair default_ranks[4l] = { { .key="inhabitant", .value="ice-userlist/inhabitant.svg" }, 
    { .key="programmer", .value="ice-userlist/programmer.svg" }, 
    { .key="wizard", .value="ice-userlist/wizard.svg" }, 
    { .key=(char *)(void *)0, .value=(char *)(void *)0 } };
// default_states
// file mcp/gm-mcp-icecrew-userlist.c line 25
static struct _GmKeyValuePair default_states[6l] = { { .key="away+idle", .value="ice-userlist/away+idle.svg" }, 
    { .key="busy+idle", .value="ice-userlist/busy+idle.svg" }, 
    { .key="avail+idle", .value="ice-userlist/avail+idle.svg" }, 
    { .key="away", .value="ice-userlist/away.svg" }, 
    { .key="busy", .value="ice-userlist/busy.svg" }, 
    { .key=(char *)(void *)0, .value=(char *)(void *)0 } };
// drag_targets
// file widgets/gm-world-text-view.c line 198
static const struct _GtkTargetEntry drag_targets[3l] = { { .target="_NETSCAPE_URL", .flags=(unsigned int)0, .info=(unsigned int)0 }, 
    { .target="text/uri-list", .flags=(unsigned int)0, .info=(unsigned int)1 }, 
    { .target="text/plain", .flags=(unsigned int)0, .info=(unsigned int)2 } };
// editor_signals
// file gm-editor.c line 35
static unsigned int editor_signals[3l] = { (unsigned int)0, 0u, 0u };
// egg_notification_bubble_signals
// file widgets/eggnotificationbubble.c line 57
static unsigned int egg_notification_bubble_signals[2l] = { (unsigned int)0, 0u };
// egg_tray_icon_signals
// file widgets/eggtrayicon.c line 74
static unsigned int egg_tray_icon_signals[1l] = { (unsigned int)0 };
// encodings
// file dialogs/gm-world-properties-dialog.c line 37
static const struct _encoding encodings[59l] = { { .charset="ISO-8859-1", .name="Western" }, 
    { .charset="ISO-8859-2", .name="Central European" }, 
    { .charset="ISO-8859-3", .name="South European" }, 
    { .charset="ISO-8859-4", .name="Baltic" }, 
    { .charset="ISO-8859-5", .name="Cyrillic" }, 
    { .charset="ISO-8859-6", .name="Arabic" }, 
    { .charset="ISO-8859-7", .name="Greek" }, 
    { .charset="ISO-8859-8", .name="Hebrew Visual" }, 
    { .charset="ISO-8859-8-I", .name="Hebrew" }, 
    { .charset="ISO-8859-9", .name="Turkish" }, 
    { .charset="ISO-8859-10", .name="Nordic" }, 
    { .charset="ISO-8859-13", .name="Baltic" }, 
    { .charset="ISO-8859-14", .name="Celtic" }, 
    { .charset="ISO-8859-15", .name="Western" }, 
    { .charset="ISO-8859-16", .name="Romanian" }, 
    { .charset="UTF-7", .name="Unicode" }, { .charset="UTF-8", .name="Unicode" }, { .charset="UTF-16", .name="Unicode" }, { .charset="UCS-2", .name="Unicode" }, { .charset="UCS-4", .name="Unicode" }, { .charset="ARMSCII-8", .name="Armenian" }, 
    { .charset="BIG5", .name="Chinese Traditional" }, 
    { .charset="BIG5-HKSCS", .name="Chinese Traditional" }, 
    { .charset="CP866", .name="Cyrillic/Russian" }, 
    { .charset="EUC-JP", .name="Japanese" }, 
    { .charset="EUC-KR", .name="Korean" }, { .charset="EUC-TW", .name="Chinese Traditional" }, 
    { .charset="GB18030", .name="Chinese Simplified" }, 
    { .charset="GB2312", .name="Chinese Simplified" }, 
    { .charset="GBK", .name="Chinese Simplified" }, 
    { .charset="GEORGIAN-ACADEMY", .name="Georgian" }, 
    { .charset="HZ", .name="Chinese Simplified" }, 
    { .charset="IBM850", .name="Western" }, { .charset="IBM852", .name="Central European" }, 
    { .charset="IBM855", .name="Cyrillic" }, 
    { .charset="IBM857", .name="Turkish" }, { .charset="IBM862", .name="Hebrew" }, { .charset="IBM864", .name="Arabic" }, { .charset="ISO-2022-JP", .name="Japanese" }, 
    { .charset="ISO-2022-KR", .name="Korean" }, 
    { .charset="ISO-IR-111", .name="Cyrillic" }, 
    { .charset="JOHAB", .name="Korean" }, { .charset="KOI8R", .name="Cyrillic" }, { .charset="KOI8-R", .name="Cyrillic" }, 
    { .charset="KOI8U", .name="Cyrillic/Ukrainian" }, 
    { .charset="SHIFT_JIS", .name="Japanese" }, 
    { .charset="TCVN", .name="Vietnamese" }, 
    { .charset="TIS-620", .name="Thai" }, { .charset="UHC", .name="Korean" }, { .charset="VISCII", .name="Vietnamese" }, 
    { .charset="WINDOWS-1250", .name="Central European" }, 
    { .charset="WINDOWS-1251", .name="Cyrillic" }, 
    { .charset="WINDOWS-1252", .name="Western" }, 
    { .charset="WINDOWS-1253", .name="Greek" }, 
    { .charset="WINDOWS-1254", .name="Turkish" }, 
    { .charset="WINDOWS-1255", .name="Hebrew" }, 
    { .charset="WINDOWS-1256", .name="Arabic" }, 
    { .charset="WINDOWS-1257", .name="Baltic" }, 
    { .charset="WINDOWS-1258", .name="Vietnamese" } };
// entries
// file widgets/gm-source-style-scheme.c line 141
static struct _GmSourceStyleEntry entries[10l] = { { .name="Base-N Integer", .color_name="fg_purple_h", .bold=0,
    .italic=0 }, 
    { .name="Character", .color_name="fg_purple_h", .bold=0,
    .italic=0 }, 
    { .name="Comment", .color_name="fg_blue_h", .bold=0,
    .italic=0 }, 
    { .name="Data Type", .color_name="fg_cyan", .bold=(signed int)!(0 != 0),
    .italic=0 }, 
    { .name="Function", .color_name="fg_green", .bold=0,
    .italic=0 }, 
    { .name="Decimal", .color_name="fg_purple_h", .bold=0,
    .italic=0 }, 
    { .name="Floating Point", .color_name="fg_purple_h", .bold=0,
    .italic=0 }, 
    { .name="Keyword", .color_name="fg_red", .bold=(signed int)!(0 != 0),
    .italic=0 }, 
    { .name="String", .color_name="fg_purple_h", .bold=0,
    .italic=0 }, 
    { .name=(const char *)(void *)0, .color_name=(const char *)(void *)0, .bold=0,
    .italic=0 } };
// factory
// file gm-pixbuf.c line 15
static struct _GtkIconFactory *factory = (struct _GtkIconFactory *)(void *)0;
// g_utf8_skip
// file /usr/include/glib-2.0/glib/gunicode.h line 680
extern const char * const g_utf8_skip;
// gdk_display
// file /usr/include/gtk-2.0/gdk/gdkx.h line 38
extern struct _XDisplay *gdk_display;
// gdk_threads_lock
// file /usr/include/gtk-2.0/gdk/gdk.h line 192
extern void (*gdk_threads_lock)(void);
// gdk_threads_unlock
// file /usr/include/gtk-2.0/gdk/gdk.h line 193
extern void (*gdk_threads_unlock)(void);
// gm_app_parent_class
// file gm-app.c line 88
static void *gm_app_parent_class = (void *)0;
// gm_app_view_parent_class
// file widgets/gm-app-view.c line 167
static void *gm_app_view_parent_class = (void *)0;
// gm_app_view_signals
// file widgets/gm-app-view.c line 165
static unsigned int gm_app_view_signals[1l] = { (unsigned int)0 };
// gm_cell_renderer_text_parent_class
// file mcp/gm-cell-renderer-text.c line 41
static void *gm_cell_renderer_text_parent_class = (void *)0;
// gm_color_table_parent_class
// file gm-color-table.c line 245
static void *gm_color_table_parent_class = (void *)0;
// gm_editor_entries
// file ./gm-ui.h line 56
static const struct _GtkActionEntry gm_editor_entries[4l];
// gm_editor_entries
// file ./gm-ui.h line 56
static const struct _GtkActionEntry gm_editor_entries[4l] = { { .name="Editor", .stock_id=(const char *)(void *)0, .label="E_ditor",
    .accelerator=((const char *)NULL), .tooltip=((const char *)NULL),
    .callback=((void (*)(void))NULL) }, 
    { .name="EditorSave", .stock_id="gtk-save", .label="Save",
    .accelerator="<control>S", .tooltip="Save editor contents",
    .callback=(void (*)(void))on_action_editor_save }, 
    { .name="EditorSaveClose", .stock_id="gm-stock-save-close", .label="Save and close",
    .accelerator=(const char *)(void *)0, .tooltip="Save editor contents and close editor",
    .callback=(void (*)(void))on_action_editor_save_close }, 
    { .name="EditorClose", .stock_id="gtk-close", .label="Close",
    .accelerator=(const char *)(void *)0, .tooltip="Close current editor",
    .callback=(void (*)(void))on_action_editor_close } };
// gm_editor_parent_class
// file gm-editor.c line 37
static void *gm_editor_parent_class = (void *)0;
// gm_editor_view_parent_class
// file widgets/gm-editor-view.c line 91
static void *gm_editor_view_parent_class = (void *)0;
// gm_editor_view_signals
// file widgets/gm-editor-view.c line 62
static unsigned int gm_editor_view_signals[1l] = { (unsigned int)0 };
// gm_embedded_view_parent_class
// file widgets/gm-embedded-view.c line 43
static void *gm_embedded_view_parent_class = (void *)0;
// gm_log_view_parent_class
// file widgets/gm-log-view.c line 31
static void *gm_log_view_parent_class = (void *)0;
// gm_mcp_awns_ping_parent_class
// file mcp/gm-mcp-awns-ping.c line 22
static void *gm_mcp_awns_ping_parent_class = (void *)0;
// gm_mcp_awns_status_parent_class
// file mcp/gm-mcp-awns-status.c line 34
static void *gm_mcp_awns_status_parent_class = (void *)0;
// gm_mcp_awns_status_signals
// file mcp/gm-mcp-awns-status.c line 29
static unsigned int gm_mcp_awns_status_signals[1l] = { (unsigned int)0 };
// gm_mcp_icecrew_mcpreset_parent_class
// file mcp/gm-mcp-icecrew-mcpreset.c line 21
static void *gm_mcp_icecrew_mcpreset_parent_class = (void *)0;
// gm_mcp_icecrew_playerdb_parent_class
// file mcp/gm-mcp-icecrew-playerdb.c line 32
static void *gm_mcp_icecrew_playerdb_parent_class = (void *)0;
// gm_mcp_icecrew_playerdb_signals
// file mcp/gm-mcp-icecrew-playerdb.c line 30
static unsigned int gm_mcp_icecrew_playerdb_signals[3l] = { (unsigned int)0, 0u, 0u };
// gm_mcp_icecrew_serverinfo_parent_class
// file mcp/gm-mcp-icecrew-serverinfo.c line 36
static void *gm_mcp_icecrew_serverinfo_parent_class = (void *)0;
// gm_mcp_icecrew_serverinfo_signals
// file mcp/gm-mcp-icecrew-serverinfo.c line 34
static unsigned int gm_mcp_icecrew_serverinfo_signals[1l] = { (unsigned int)0 };
// gm_mcp_icecrew_userlist_depends
// file mcp/gm-mcp-icecrew-userlist.c line 59
static char *gm_mcp_icecrew_userlist_depends[2l] = { "dns-nl-icecrew-playerdb", (char *)(void *)0 };
// gm_mcp_icecrew_userlist_overrides
// file mcp/gm-mcp-icecrew-userlist.c line 63
static char *gm_mcp_icecrew_userlist_overrides[2l] = { "dns-com-vmoo-userlist", (char *)(void *)0 };
// gm_mcp_icecrew_userlist_parent_class
// file mcp/gm-mcp-icecrew-userlist.c line 97
static void *gm_mcp_icecrew_userlist_parent_class = (void *)0;
// gm_mcp_icecrew_userlist_property_names0
// file mcp/gm-mcp-icecrew-userlist.c line 75
static char *gm_mcp_icecrew_userlist_property_names0[4l] = { "P_NAME", "P_RANK", "P_STATE", "P_STATE_MSG" };
// gm_mcp_icecrew_userlist_property_names1
// file mcp/gm-mcp-icecrew-userlist.c line 81
static char *gm_mcp_icecrew_userlist_property_names1[4l] = { "name", "rank", "state", "state_msg" };
// gm_mcp_mud_moo_simpleedit_parent_class
// file mcp/gm-mcp-mud-moo-simpleedit.c line 29
static void *gm_mcp_mud_moo_simpleedit_parent_class = (void *)0;
// gm_mcp_negotiate_parent_class
// file mcp/gm-mcp-negotiate.c line 36
static void *gm_mcp_negotiate_parent_class = (void *)0;
// gm_mcp_package_parent_class
// file mcp/gm-mcp-package.c line 24
static void *gm_mcp_package_parent_class = (void *)0;
// gm_mcp_session_parent_class
// file mcp/gm-mcp-session.c line 35
static void *gm_mcp_session_parent_class = (void *)0;
// gm_mcp_session_signals
// file mcp/gm-mcp-session.c line 33
static unsigned int gm_mcp_session_signals[1l] = { (unsigned int)0 };
// gm_mcp_vmoo_client_parent_class
// file mcp/gm-mcp-vmoo-client.c line 38
static void *gm_mcp_vmoo_client_parent_class = (void *)0;
// gm_mcp_vmoo_userlist_parent_class
// file mcp/gm-mcp-vmoo-userlist.c line 61
static void *gm_mcp_vmoo_userlist_parent_class = (void *)0;
// gm_menu_entries
// file ./gm-ui.h line 76
static const struct _GtkActionEntry gm_menu_entries[14l];
// gm_menu_entries
// file ./gm-ui.h line 76
static const struct _GtkActionEntry gm_menu_entries[14l] = { { .name="WorldConnect", .stock_id="gtk-connect", .label="Connect",
    .accelerator="<control><shift>C", .tooltip="Connect the current world",
    .callback=(void (*)(void))on_action_world_connect }, 
    { .name="WorldClose", .stock_id="gtk-close", .label=(const char *)(void *)0,
    .accelerator=(const char *)(void *)0, .tooltip="Close current world",
    .callback=(void (*)(void))on_action_world_close }, 
    { .name="WorldPaste", .stock_id="gtk-paste", .label="Paste",
    .accelerator="<control>P", .tooltip="Paste text to the current world",
    .callback=(void (*)(void))on_action_world_paste }, 
    { .name="WorldLogs", .stock_id="gtk-justify-left", .label="Logs",
    .accelerator=(const char *)(void *)0, .tooltip="View current world logs",
    .callback=(void (*)(void))on_action_world_logs }, 
    { .name="WorldInfo", .stock_id="gtk-info", .label="In_fo",
    .accelerator=(const char *)(void *)0, .tooltip="View current world info",
    .callback=(void (*)(void))(void *)0 }, 
    { .name="EditCut", .stock_id="gtk-cut", .label=(const char *)(void *)0, .accelerator="<control>X",
    .tooltip="Cut the selection", .callback=(void (*)(void))on_action_edit_cut }, 
    { .name="EditCopy", .stock_id="gtk-copy", .label=(const char *)(void *)0,
    .accelerator="<control>C", .tooltip="Copy the selection",
    .callback=(void (*)(void))on_action_edit_copy }, 
    { .name="EditPaste", .stock_id="gtk-paste", .label=(const char *)(void *)0,
    .accelerator="<control>V", .tooltip="Paste the clipboard",
    .callback=(void (*)(void))on_action_edit_paste }, 
    { .name="EditWorld", .stock_id=(const char *)(void *)0, .label="Current world...",
    .accelerator=(const char *)(void *)0, .tooltip="Edit the current world",
    .callback=(void (*)(void))on_action_edit_world }, 
    { .name="EditFind", .stock_id="gtk-find", .label=(const char *)(void *)0,
    .accelerator="<control>F", .tooltip="Search for text",
    .callback=(void (*)(void))on_gm_app_view_edit_find }, 
    { .name="EditFindNext", .stock_id="gtk-find", .label="Find Ne_xt",
    .accelerator="<control>G", .tooltip="Search forwards for the same text",
    .callback=(void (*)(void))on_gm_app_view_edit_find_next }, 
    { .name="EditReplace", .stock_id="gtk-find-and-replace", .label="_Replace...",
    .accelerator="<control>R", .tooltip="Search for and replace text",
    .callback=(void (*)(void))on_gm_app_view_edit_replace }, 
    { .name="WorldTriggers", .stock_id="gtk-index", .label="Triggers",
    .accelerator=(const char *)(void *)0, .tooltip="Edit the current world triggers",
    .callback=(void (*)(void))on_action_edit_triggers }, 
    { .name="WorldProperties", .stock_id="gtk-properties", .label="Properties",
    .accelerator=(const char *)(void *)0, .tooltip="Edit the current world",
    .callback=(void (*)(void))on_action_edit_world } };
// gm_net_parent_class
// file gm-net.c line 73
static void *gm_net_parent_class = (void *)0;
// gm_open_world_dialog_instance
// file dialogs/gm-open-world-dialog.c line 28
static struct _GmOpenWorldDialog *gm_open_world_dialog_instance;
// gm_options_parent_class
// file gm-options.c line 35
static void *gm_options_parent_class = (void *)0;
// gm_pixbuf_directories
// file gm-pixbuf.c line 13
static struct _GList *gm_pixbuf_directories = (struct _GList *)(void *)0;
// gm_pixbufs
// file gm-pixbuf.c line 14
static struct _GList *gm_pixbufs = (struct _GList *)(void *)0;
// gm_sensitive_menu_entries
// file ./gm-ui.h line 16
static const struct _GtkActionEntry gm_sensitive_menu_entries[11l];
// gm_sensitive_menu_entries
// file ./gm-ui.h line 16
static const struct _GtkActionEntry gm_sensitive_menu_entries[11l] = { { .name="World", .stock_id=(const char *)(void *)0, .label="_World",
    .accelerator=((const char *)NULL), .tooltip=((const char *)NULL),
    .callback=((void (*)(void))NULL) }, 
    { .name="Edit", .stock_id=(const char *)(void *)0, .label="_Edit",
    .accelerator=((const char *)NULL), .tooltip=((const char *)NULL),
    .callback=((void (*)(void))NULL) }, 
    { .name="View", .stock_id=(const char *)(void *)0, .label="_View",
    .accelerator=((const char *)NULL), .tooltip=((const char *)NULL),
    .callback=((void (*)(void))NULL) }, 
    { .name="Help", .stock_id=(const char *)(void *)0, .label="_Help",
    .accelerator=((const char *)NULL), .tooltip=((const char *)NULL),
    .callback=((void (*)(void))NULL) }, 
    { .name="WorldNew", .stock_id="gtk-new", .label="New World...",
    .accelerator="<control>N", .tooltip="Create a new world",
    .callback=(void (*)(void))on_action_world_new }, 
    { .name="WorldOpen", .stock_id="gtk-open", .label="Open World...",
    .accelerator="<control>O", .tooltip="Open an existing world",
    .callback=(void (*)(void))on_action_world_open }, 
    { .name="WorldQuit", .stock_id="gtk-quit", .label=(const char *)(void *)0,
    .accelerator=(const char *)(void *)0, .tooltip="Quit the program",
    .callback=(void (*)(void))on_action_world_quit }, 
    { .name="EditWorlds", .stock_id=(const char *)(void *)0, .label="Worlds...",
    .accelerator=(const char *)(void *)0, .tooltip="Edit worlds",
    .callback=(void (*)(void))on_action_edit_worlds }, 
    { .name="EditPreferences", .stock_id="gtk-preferences", .label=(const char *)(void *)0,
    .accelerator=(const char *)(void *)0, .tooltip="Configure the application",
    .callback=(void (*)(void))on_action_edit_preferences }, 
    { .name="EditScripts", .stock_id=(const char *)(void *)0, .label="Scripts",
    .accelerator=(const char *)(void *)0, .tooltip="Edit scripts",
    .callback=(void (*)(void))on_action_edit_scripts }, 
    { .name="HelpAbout", .stock_id="gtk-about", .label=(const char *)(void *)0,
    .accelerator=(const char *)(void *)0, .tooltip="About this application",
    .callback=(void (*)(void))on_action_help_about } };
// gm_style_scheme
// file widgets/gm-source-style-scheme.c line 209
static struct _GtkSourceStyleScheme *gm_style_scheme = (struct _GtkSourceStyleScheme *)(void *)0;
// gm_text_scroller_parent_class
// file widgets/gm-text-scroller.c line 42
static void *gm_text_scroller_parent_class = (void *)0;
// gm_toggle_menu_entries
// file ./gm-ui.h line 47
static const struct _GtkToggleActionEntry gm_toggle_menu_entries[2l];
// gm_toggle_menu_entries
// file ./gm-ui.h line 47
static const struct _GtkToggleActionEntry gm_toggle_menu_entries[2l] = { { .name="ViewToolbar", .stock_id=(const char *)(void *)0, .label="_Toolbar",
    .accelerator=(const char *)(void *)0, .tooltip="Show or hide the toolbar",
    .callback=(void (*)(void))on_action_view_toolbar,
    .is_active=(signed int)!(0 != 0) }, 
    { .name="ViewUserlist", .stock_id=(const char *)(void *)0, .label="_Userlist",
    .accelerator="F9", .tooltip="Show or hide the world userlist",
    .callback=(void (*)(void))on_action_view_userlist,
    .is_active=(signed int)!(0 != 0) } };
// gm_tray_parent_class
// file widgets/gm-tray.c line 27
static void *gm_tray_parent_class = (void *)0;
// gm_triggers_parent_class
// file gm-triggers.c line 60
static void *gm_triggers_parent_class = (void *)0;
// gm_world_input_view_parent_class
// file widgets/gm-world-input-view.c line 38
static void *gm_world_input_view_parent_class = (void *)0;
// gm_world_parent_class
// file gm-world.c line 94
static void *gm_world_parent_class = (void *)0;
// gm_world_paste_dialog_instance
// file dialogs/gm-world-paste-dialog.c line 28
static struct _GmWorldPasteDialog *gm_world_paste_dialog_instance;
// gm_world_properties_dialog_open
// file dialogs/gm-world-properties-dialog.c line 104
static struct _GList *gm_world_properties_dialog_open = (struct _GList *)(void *)0;
// gm_world_tab_parent_class
// file widgets/gm-world-tab.c line 35
static void *gm_world_tab_parent_class = (void *)0;
// gm_world_tab_signals
// file widgets/gm-world-tab.c line 33
static unsigned int gm_world_tab_signals[1l] = { (unsigned int)0 };
// gm_world_text_view_parent_class
// file widgets/gm-world-text-view.c line 113
static void *gm_world_text_view_parent_class = (void *)0;
// gm_world_view_parent_class
// file widgets/gm-world-view.c line 89
static void *gm_world_view_parent_class = (void *)0;
// gm_worlds_list_dialog_instance
// file dialogs/gm-worlds-list-dialog.c line 49
static struct _GmWorldsListDialog *gm_worlds_list_dialog_instance;
// gm_worlds_view_parent_class
// file widgets/gm-worlds-view.c line 34
static void *gm_worlds_view_parent_class = (void *)0;
// highlightTags
// file dialogs/gm-triggers-dialog.c line 103
static const struct _TagPair highlightTags[9l] = { { .name="Black", .tag="bg_black" }, { .name="Red", .tag="bg_red" }, { .name="Green", .tag="bg_green" }, { .name="Yellow", .tag="bg_yellow" }, { .name="Blue", .tag="bg_blue" }, { .name="Purple", .tag="bg_purple" }, { .name="Cyan", .tag="bg_cyan" }, { .name="White", .tag="bg_white" }, { .name=(const char *)(void *)0, .tag=(const char *)(void *)0 } };
// icon_mapping
// file mcp/gm-mcp-vmoo-userlist.c line 18
static const struct _GmKeyValuePair icon_mapping[8l] = { { .key="newbie", .value="userlist/newbie.svg" }, 
    { .key="inhabitant", .value="userlist/inhabitant.svg" }, 
    { .key="inhabitant+", .value="userlist/inhabitantplus.svg" }, 
    { .key="schooled", .value="userlist/schooled.svg" }, 
    { .key="key", .value="userlist/key.svg" }, 
    { .key="star", .value="userlist/star.svg" }, 
    { .key="wizard", .value="userlist/wizard.svg" }, 
    { .key=(char *)(void *)0, .value=(char *)(void *)0 } };
// language
// file widgets/gm-editor-view.c line 53
static struct _GtkSourceLanguage *language = (struct _GtkSourceLanguage *)(void *)0;
// level_mapping
// file gm-debug.c line 16
static struct _LevelMap level_mapping[4l] = { { .name="default", .level=(enum _GmDebugLevel)4 }, 
    { .name="mcp", .level=(enum _GmDebugLevel)8 }, 
    { .name="all", .level=(enum _GmDebugLevel)65535 }, 
    { .name=(const char *)(void *)0, .level=(enum _GmDebugLevel)0 } };
// load_worlds
// file gm-app.c line 26
static char *load_worlds = (char *)(void *)0;
// logging_button_names
// file dialogs/gm-world-properties-dialog.c line 277
static const char *logging_button_names[9l] = { "logging_in", "logging_out", "logging_status", "logging_mcp_in", "logging_mcp_out", "logging_mcp_status", "logging_add_timestamp", "logging_add_log_type", (const char *)(void *)0 };
// logging_button_names$link1
// file dialogs/gm-preferences-dialog.c line 197
static const char *logging_button_names$link1[9l] = { "logging_in", "logging_out", "logging_status", "logging_mcp_in", "logging_mcp_out", "logging_mcp_status", "logging_add_timestamp", "logging_add_log_type", (const char *)(void *)0 };
// mapping
// file widgets/gm-source-style-scheme.c line 154
static struct _GmKeyValuePair mapping[6l] = { { .key="fg_purple_h", .value="Object@32@Number String" }, 
    { .key="fg_cyan", .value="Builtin@32@Variables Types S-Ref Error" }, 
    { .key="fg_green", .value="Builtin@32@Functions" }, 
    { .key="fg_blue_h", .value="Line@32@Comment" }, 
    { .key="fg_red", .value="Keywords" }, { .key=(char *)(void *)0, .value=(char *)(void *)0 } };
// mutex_debug
// file gm-debug.c line 24
static union anonymous$66 mutex_debug = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// net_signals
// file gm-net.c line 71
static unsigned int net_signals[4l] = { (unsigned int)0, 0u, 0u, 0u };
// options_signals
// file gm-options.c line 33
static unsigned int options_signals[1l] = { (unsigned int)0 };
// parent_class
// file widgets/gm-world-text-view.c line 111
static struct _GtkTextViewClass *parent_class = (struct _GtkTextViewClass *)(void *)0;
// parent_class$link1
// file widgets/eggtrayicon.c line 75
static struct _GtkPlugClass *parent_class$link1 = (struct _GtkPlugClass *)(void *)0;
// parent_class$link2
// file widgets/eggnotificationbubble.c line 48
static struct _GtkObjectClass *parent_class$link2;
// parent_class$link3
// file widgets/gm-source-style-scheme.c line 35
static struct _GObjectClass *parent_class$link3 = (struct _GObjectClass *)(void *)0;
// parent_class$link4
// file mcp/gm-cell-renderer-text.c line 43
static void *parent_class$link4;
// poptions
// file gm-app.c line 29
struct poptOption poptions[5l];
// recover
// file gm-app.c line 25
static signed int recover = 0;
// show_version
// file gm-app.c line 24
static signed int show_version = 0;
// poptions
// file gm-app.c line 29
struct poptOption poptions[5l] = { { .longName="debug", .shortName=(char)100, .argInfo=1U,
    .arg=(void *)&debug_level, .val=0,
    .descrip="Enable debugging. Specify multiple debug levels with a comma seperated list. Available levels: default, mcp, all", .argDescrip="DBGGLEVEL" }, 
    { .longName="version", .shortName=(char)118, .argInfo=0U,
    .arg=(void *)&show_version, .val=0,
    .descrip="Show application version", .argDescrip=(const char *)(void *)0 }, 
    { .longName="load", .shortName=(char)108, .argInfo=1U,
    .arg=(void *)&load_worlds, .val=0,
    .descrip="Load specified worlds. Specify multiple worlds with a comma separated list", .argDescrip="WORLDS" }, 
    { .longName="recover", .shortName=(char)114, .argInfo=0U,
    .arg=(void *)&recover, .val=0, .descrip="Recover from previous session (used with gnome session)",
    .argDescrip=(const char *)(void *)0 }, 
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
// preferences
// file dialogs/gm-preferences-dialog.c line 126
static struct _GmPreferencesDialog *preferences = (struct _GmPreferencesDialog *)(void *)0;
// scheme_default
// file gm-color-table.c line 24
static const struct _GmColorTableSchemeItem scheme_default[28l] = { { .name="fg_default", .hex="#000000" }, { .name="fg_black", .hex="#000000" }, { .name="fg_red", .hex="#aa0000" }, { .name="fg_green", .hex="#00aa00" }, { .name="fg_yellow", .hex="#aa5500" }, { .name="fg_blue", .hex="#0000aa" }, { .name="fg_purple", .hex="#aa00aa" }, { .name="fg_cyan", .hex="#00aaaa" }, { .name="fg_white", .hex="#aaaaaa" }, { .name="fg_default_h", .hex="#555555" }, 
    { .name="fg_black_h", .hex="#555555" }, { .name="fg_red_h", .hex="#ff5555" }, { .name="fg_green_h", .hex="#55ff55" }, { .name="fg_yellow_h", .hex="#ffff55" }, 
    { .name="fg_blue_h", .hex="#5555ff" }, { .name="fg_purple_h", .hex="#ff55ff" }, 
    { .name="fg_cyan_h", .hex="#55ffff" }, { .name="fg_white_h", .hex="#ffffff" }, { .name="bg_default", .hex="#ffffff" }, { .name="bg_black", .hex="#222222" }, { .name="bg_red", .hex="#770000" }, { .name="bg_green", .hex="#007700" }, { .name="bg_yellow", .hex="#ddaa33" }, { .name="bg_blue", .hex="#000077" }, { .name="bg_purple", .hex="#770077" }, { .name="bg_cyan", .hex="#007777" }, { .name="bg_white", .hex="#777777" }, { .name=(const char *)(void *)0, .hex=(const char *)(void *)0 } };
// scheme_linux
// file gm-color-table.c line 164
static const struct _GmColorTableSchemeItem scheme_linux[28l] = { { .name="fg_default", .hex="#AAAAAAAAAAAA" }, 
    { .name="fg_black", .hex="#000000000000" }, 
    { .name="fg_red", .hex="#AAAA00000000" }, 
    { .name="fg_green", .hex="#0000AAAA0000" }, 
    { .name="fg_yellow", .hex="#AAAA55550000" }, 
    { .name="fg_blue", .hex="#00000000AAAA" }, 
    { .name="fg_purple", .hex="#AAAA0000AAAA" }, 
    { .name="fg_cyan", .hex="#0000AAAAAAAA" }, 
    { .name="fg_white", .hex="#AAAAAAAAAAAA" }, 
    { .name="fg_default_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="fg_black_h", .hex="#555555555555" }, 
    { .name="fg_red_h", .hex="#FFFF55555555" }, 
    { .name="fg_green_h", .hex="#5555FFFF5555" }, 
    { .name="fg_yellow_h", .hex="#FFFFFFFF5555" }, 
    { .name="fg_blue_h", .hex="#55555555FFFF" }, 
    { .name="fg_purple_h", .hex="#FFFF5555FFFF" }, 
    { .name="fg_cyan_h", .hex="#5555FFFFFFFF" }, 
    { .name="fg_white_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="bg_default", .hex="#000000000000" }, 
    { .name="bg_black", .hex="#000000000000" }, 
    { .name="bg_red", .hex="#AAAA00000000" }, 
    { .name="bg_green", .hex="#0000AAAA0000" }, 
    { .name="bg_yellow", .hex="#AAAA55550000" }, 
    { .name="bg_blue", .hex="#00000000AAAA" }, 
    { .name="bg_purple", .hex="#AAAA0000AAAA" }, 
    { .name="bg_cyan", .hex="#0000AAAAAAAA" }, 
    { .name="bg_white", .hex="#AAAAAAAAAAAA" }, 
    { .name=(const char *)(void *)0, .hex=(const char *)(void *)0 } };
// scheme_names
// file gm-color-table.c line 207
static const struct _GmColorScheme scheme_names[8l];
// scheme_rxvt
// file gm-color-table.c line 127
static const struct _GmColorTableSchemeItem scheme_rxvt[28l] = { { .name="fg_default", .hex="#FAFAEBEBD7D7" }, 
    { .name="fg_black", .hex="#000000000000" }, 
    { .name="fg_red", .hex="#CDCD00000000" }, 
    { .name="fg_green", .hex="#0000CDCD0000" }, 
    { .name="fg_yellow", .hex="#CDCDCDCD0000" }, 
    { .name="fg_blue", .hex="#00000000CDCD" }, 
    { .name="fg_purple", .hex="#CDCD0000CDCD" }, 
    { .name="fg_cyan", .hex="#0000CDCDCDCD" }, 
    { .name="fg_white", .hex="#FAFAEBEBD7D7" }, 
    { .name="fg_default_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="fg_black_h", .hex="#404040404040" }, 
    { .name="fg_red_h", .hex="#FFFF00000000" }, 
    { .name="fg_green_h", .hex="#0000FFFF0000" }, 
    { .name="fg_yellow_h", .hex="#FFFFFFFF0000" }, 
    { .name="fg_blue_h", .hex="#00000000FFFF" }, 
    { .name="fg_purple_h", .hex="#FFFF0000FFFF" }, 
    { .name="fg_cyan_h", .hex="#0000FFFFFFFF" }, 
    { .name="fg_white_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="bg_default", .hex="#000000000000" }, 
    { .name="bg_black", .hex="#000000000000" }, 
    { .name="bg_red", .hex="#CDCD00000000" }, 
    { .name="bg_green", .hex="#0000CDCD0000" }, 
    { .name="bg_yellow", .hex="#CDCDCDCD0000" }, 
    { .name="bg_blue", .hex="#00000000CDCD" }, 
    { .name="bg_purple", .hex="#CDCD0000CDCD" }, 
    { .name="bg_cyan", .hex="#0000CDCDCDCD" }, 
    { .name="bg_white", .hex="#FAFAEBEBD7D7" }, 
    { .name=(const char *)(void *)0, .hex=(const char *)(void *)0 } };
// scheme_white_on_black
// file gm-color-table.c line 57
static const struct _GmColorTableSchemeItem scheme_white_on_black[28l] = { { .name="fg_default", .hex="#D6B5D6B5D6B5" }, 
    { .name="fg_black", .hex="#2D6B2D6B2D6B" }, 
    { .name="fg_red", .hex="#FFFF00000000" }, 
    { .name="fg_green", .hex="#0000FFFF0000" }, 
    { .name="fg_yellow", .hex="#FFFFD0450000" }, 
    { .name="fg_blue", .hex="#3EF73EF7BFFF" }, 
    { .name="fg_purple", .hex="#A0A02020F0F0" }, 
    { .name="fg_cyan", .hex="#0000FFFFFFFF" }, 
    { .name="fg_white", .hex="#D8C5D8C5D8C5" }, 
    { .name="fg_default_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="fg_black_h", .hex="#529452945294" }, 
    { .name="fg_red_h", .hex="#FFFF785F785F" }, 
    { .name="fg_green_h", .hex="#66ADFFFF66AD" }, 
    { .name="fg_yellow_h", .hex="#FFFFFFFF58C6" }, 
    { .name="fg_blue_h", .hex="#86318631FFFF" }, 
    { .name="fg_purple_h", .hex="#C6576A18FFFF" }, 
    { .name="fg_cyan_h", .hex="#86EEFFFFFFFF" }, 
    { .name="fg_white_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="bg_default", .hex="#000000000000" }, 
    { .name="bg_black", .hex="#2B5B2B5B2B5B" }, 
    { .name="bg_red", .hex="#FFFF00000000" }, 
    { .name="bg_green", .hex="#000080000000" }, 
    { .name="bg_yellow", .hex="#C047C0470000" }, 
    { .name="bg_blue", .hex="#00000000FFFF" }, 
    { .name="bg_purple", .hex="#A0A02020F0F0" }, 
    { .name="bg_cyan", .hex="#0000B74CB74C" }, 
    { .name="bg_white", .hex="#FFFFFFFFFFFF" }, 
    { .name=(const char *)(void *)0, .hex=(const char *)(void *)0 } };
// scheme_xterm
// file gm-color-table.c line 90
static const struct _GmColorTableSchemeItem scheme_xterm[28l] = { { .name="fg_default", .hex="#E5E2E5E2E5E2" }, 
    { .name="fg_black", .hex="#000000000000" }, 
    { .name="fg_red", .hex="#CDCB00000000" }, 
    { .name="fg_green", .hex="#0000CDCB0000" }, 
    { .name="fg_yellow", .hex="#CDCBCDCB0000" }, 
    { .name="fg_blue", .hex="#1E1A908FFFFF" }, 
    { .name="fg_purple", .hex="#CDCB0000CDCB" }, 
    { .name="fg_cyan", .hex="#0000CDCBCDCB" }, 
    { .name="fg_white", .hex="#E5E2E5E2E5E2" }, 
    { .name="fg_default_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="fg_black_h", .hex="#4CCCC4CCCC4CCCC" }, 
    { .name="fg_red_h", .hex="#FFFF00000000" }, 
    { .name="fg_green_h", .hex="#0000FFFF0000" }, 
    { .name="fg_yellow_h", .hex="#FFFFFFFF0000" }, 
    { .name="fg_blue_h", .hex="#46458281B4AE" }, 
    { .name="fg_purple_h", .hex="#FFFF0000FFFF" }, 
    { .name="fg_cyan_h", .hex="#0000FFFFFFFF" }, 
    { .name="fg_white_h", .hex="#FFFFFFFFFFFF" }, 
    { .name="bg_default", .hex="#000000000000" }, 
    { .name="bg_black", .hex="#000000000000" }, 
    { .name="bg_red", .hex="#CDCB00000000" }, 
    { .name="bg_green", .hex="#0000CDCB0000" }, 
    { .name="bg_yellow", .hex="#CDCBCDCB0000" }, 
    { .name="bg_blue", .hex="#1E1A908FFFFF" }, 
    { .name="bg_purple", .hex="#CDCB0000CDCB" }, 
    { .name="bg_cyan", .hex="#0000CDCBCDCB" }, 
    { .name="bg_white", .hex="#E5E2E5E2E5E2" }, 
    { .name=(const char *)(void *)0, .hex=(const char *)(void *)0 } };
// scheme_names
// file gm-color-table.c line 207
static const struct _GmColorScheme scheme_names[8l] = { { .scheme=(enum _GmColorTableScheme)0, .name="none", .values=(const struct _GmColorTableSchemeItem *)(void *)0 }, 
    { .scheme=(enum _GmColorTableScheme)1, .name="default", .values=scheme_default }, 
    { .scheme=(enum _GmColorTableScheme)2, .name="white_on_black", .values=scheme_white_on_black }, 
    { .scheme=(enum _GmColorTableScheme)3, .name="rxvt", .values=scheme_rxvt }, 
    { .scheme=(enum _GmColorTableScheme)4, .name="xterm", .values=scheme_xterm }, 
    { .scheme=(enum _GmColorTableScheme)5, .name="linux", .values=scheme_linux }, 
    { .scheme=(enum _GmColorTableScheme)6, .name="user", .values=(const struct _GmColorTableSchemeItem *)(void *)0 }, 
    { .scheme=(enum _GmColorTableScheme)0, .name=(const char *)(void *)0, .values=(const struct _GmColorTableSchemeItem *)(void *)0 } };
// sort_button_names
// file dialogs/gm-preferences-dialog.c line 246
static const char *sort_button_names[5l] = { "radio_button_state_rank_name", "radio_button_rank_name", "radio_button_state_name", "radio_button_name", (const char *)(void *)0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// table_actions
// file gm-triggers.c line 33
static const struct _trigger_trans table_actions[7l] = { { .type=0, .name="highlight-line" }, { .type=1, .name="highlight-match" }, { .type=2, .name="beep" }, { .type=3, .name="play-sound" }, { .type=4, .name="notify" }, { .type=6, .name="run" }, { .type=-1, .name=(const char *)(void *)0 } };
// table_conditions
// file gm-triggers.c line 15
static const struct _trigger_trans table_conditions[15l] = { { .type=0, .name="contains" }, { .type=1, .name="not-contains" }, { .type=2, .name="begins" }, { .type=3, .name="not-begins" }, { .type=4, .name="ends" }, { .type=5, .name="not-ends" }, { .type=6, .name="matches" }, { .type=7, .name="not-matches" }, { .type=8, .name="online" }, { .type=9, .name="offline" }, { .type=10, .name="idle" }, { .type=11, .name="idle-off" }, { .type=12, .name="away" }, { .type=13, .name="away-off" }, { .type=-1, .name=(const char *)(void *)0 } };
// tag_checks
// file widgets/gm-world-text-view.c line 951
static const char *tag_checks[8l] = { "foreground-set", "background-set", "weight-set", "underline-set", "style-set", "wrap-mode-set", "invisible-set", (const char *)(void *)0 };
// terminals
// file widgets/gm-external-view.c line 75
static struct anonymous$103 terminals[3l] = { { .terminal="gnome-terminal", .arguments="--disable-factory" }, 
    { .terminal="gnome-terminal.wrapper", .arguments="--disable-factory" }, 
    { .terminal=(const char *)(void *)0, .arguments=(const char *)(void *)0 } };
// url_regexp
// file gm-support.c line 28
static struct re_pattern_buffer url_regexp;
// widget_parent_class
// file widgets/gm-world-input-view.c line 36
static struct _GtkWidgetClass *widget_parent_class;
// world_input_view_signals
// file widgets/gm-world-input-view.c line 35
static unsigned int world_input_view_signals[1l] = { (unsigned int)0 };
// world_signals
// file gm-world.c line 92
static unsigned int world_signals[10l] = { (unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
// world_text_view_signals
// file widgets/gm-world-text-view.c line 110
static unsigned int world_text_view_signals[2l] = { (unsigned int)0, 0u };
// xmlFree
// file /usr/include/libxml2/libxml/globals.h line 251
extern void (*xmlFree)(void *);

// MOOVar_free
// file ./list.h line 43
void MOOVar_free(struct _MOOVar *var)
{
  if(!(var == ((struct _MOOVar *)NULL)))
  {
    g_free((void *)var->s);
    MOOVar_free(var->list);
    MOOVar_free(var->next);
    g_free((void *)var);
  }

}

// MOOVar_listappend
// file list.c line 404
void MOOVar_listappend(struct _MOOVar *var, struct _MOOVar *item)
{
  if((signed int)var->type == LIST)
  {
    var->i = var->i + 1;
    if(var->i >= 2)
    {
      var = var->list;
      for( ; !(var->next == ((struct _MOOVar *)NULL)); var = var->next)
        ;
      var->next = item;
    }

    else
      var->list = item;
  }

}

// MOOVar_listindex
// file list.c line 472
struct _MOOVar * MOOVar_listindex(struct _MOOVar *list, signed int index)
{
  struct _MOOVar *v;
  signed int i;
  _Bool tmp_if_expr$1;
  if(!((signed int)list->type == LIST) || !(index >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = index > list->i ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (struct _MOOVar *)(void *)0;

  else
  {
    v = list->list;
    i = 1;
    for( ; !(i >= index); i = i + 1)
      v = v->next;
    return v;
  }
}

// MOOVar_new_error
// file list.c line 339
struct _MOOVar * MOOVar_new_error(const char *try_error)
{
  struct _MOOVar *var;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct _MOOVar) /*48ul*/ );
  var = (struct _MOOVar *)return_value_g_malloc$1;
  var->type = (enum anonymous$34)ERROR;
  var->s = (char *)(void *)0;
  var->i = 0;
  var->d = 0.0;
  var->list = (struct _MOOVar *)(void *)0;
  var->next = (struct _MOOVar *)(void *)0;
  signed int return_value_parse_error$2;
  return_value_parse_error$2=parse_error(try_error, &var->i, &var->s);
  if(!(return_value_parse_error$2 == 0))
    return var;

  else
  {
    g_free((void *)var);
    return (struct _MOOVar *)(void *)0;
  }
}

// MOOVar_new_float
// file list.c line 356
struct _MOOVar * MOOVar_new_float(const char *d)
{
  char *s = (char *)(void *)0;
  double f;
  f=strtod(d, &s);
  struct _MOOVar *var;
  _Bool tmp_if_expr$1;
  if(!(s == ((char *)NULL)))
    tmp_if_expr$1 = !(*s != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _MOOVar *)(void *)0;

  else
  {
    void *return_value_g_malloc$2;
    return_value_g_malloc$2=g_malloc(sizeof(struct _MOOVar) /*48ul*/ );
    var = (struct _MOOVar *)return_value_g_malloc$2;
    var->type = (enum anonymous$34)FLOAT;
    var->s = (char *)(void *)0;
    var->i = 0;
    var->d = f;
    var->list = (struct _MOOVar *)(void *)0;
    var->next = (struct _MOOVar *)(void *)0;
    return var;
  }
}

// MOOVar_new_int
// file list.c line 376
struct _MOOVar * MOOVar_new_int(const char *i)
{
  char *s = (char *)(void *)0;
  signed int in;
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(i, &s, 10);
  in = (signed int)return_value_strtol$1;
  struct _MOOVar *var;
  _Bool tmp_if_expr$2;
  if(!(s == ((char *)NULL)))
    tmp_if_expr$2 = !(*s != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(!tmp_if_expr$2)
    return (struct _MOOVar *)(void *)0;

  else
  {
    void *return_value_g_malloc$3;
    return_value_g_malloc$3=g_malloc(sizeof(struct _MOOVar) /*48ul*/ );
    var = (struct _MOOVar *)return_value_g_malloc$3;
    var->type = (enum anonymous$34)INT;
    var->s = (char *)(void *)0;
    var->i = in;
    var->d = 0.0;
    var->list = (struct _MOOVar *)(void *)0;
    var->next = (struct _MOOVar *)(void *)0;
    return var;
  }
}

// MOOVar_new_list
// file list.c line 209
struct _MOOVar * MOOVar_new_list()
{
  struct _MOOVar *var;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct _MOOVar) /*48ul*/ );
  var = (struct _MOOVar *)return_value_g_malloc$1;
  var->type = (enum anonymous$34)LIST;
  var->s = (char *)(void *)0;
  var->i = 0;
  var->d = 0.0;
  var->list = (struct _MOOVar *)(void *)0;
  var->next = (struct _MOOVar *)(void *)0;
  return var;
}

// MOOVar_new_object
// file list.c line 222
struct _MOOVar * MOOVar_new_object(signed int obj)
{
  struct _MOOVar *var;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct _MOOVar) /*48ul*/ );
  var = (struct _MOOVar *)return_value_g_malloc$1;
  var->type = (enum anonymous$34)OBJECT;
  var->s = (char *)(void *)0;
  var->i = obj;
  var->d = 0.0;
  var->list = (struct _MOOVar *)(void *)0;
  var->next = (struct _MOOVar *)(void *)0;
  return var;
}

// MOOVar_new_string
// file list.c line 235
struct _MOOVar * MOOVar_new_string(const char *string)
{
  struct _MOOVar *var;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct _MOOVar) /*48ul*/ );
  var = (struct _MOOVar *)return_value_g_malloc$1;
  var->type = (enum anonymous$34)STRING;
  var->s=g_strdup(string);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(string);
  var->i = (signed int)return_value_strlen$2;
  var->d = 0.0;
  var->list = (struct _MOOVar *)(void *)0;
  var->next = (struct _MOOVar *)(void *)0;
  return var;
}

// MOOVar_parse
// file ./list.h line 45
struct _MOOVar * MOOVar_parse(const char *s)
{
  struct _MOOVar *v;
  v=do_MOOVar_parse(&s);
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
      break;

    s = s + 1l;
  }
  while((_Bool)1);
  if(!(*s == 0))
  {
    MOOVar_free(v);
    return (struct _MOOVar *)(void *)0;
  }

  else
    return v;
}

// MOOVar_tostr
// file list.c line 460
char * MOOVar_tostr(struct _MOOVar *v)
{
  struct anonymous$90 *stream;
  char *s;
  stream=stream_new(100);
  do_MOOVar_tostr(v, stream);
  s = stream->buf;
  g_free((void *)stream);
  return s;
}

// _gm_options_check_old_options
// file ./gm-options.h line 67
void _gm_options_check_old_options(const char *xmlname)
{
  char *filename;
  struct _xmlDoc *doc;
  struct _xmlNode *root;
  struct _IO_FILE *f;
  char **keyvalue;
  char line[1024l];
  signed int i;
  filename=g_strdup(xmlname);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(xmlname);
  filename[(signed long int)(return_value_strlen$1 - (unsigned long int)4)] = (char)0;
  signed int return_value_g_file_test$2;
  return_value_g_file_test$2=g_file_test(xmlname, (enum anonymous$106)G_FILE_TEST_EXISTS);
  _Bool tmp_if_expr$4;
  signed int return_value_g_file_test$3;
  if(!(return_value_g_file_test$2 == 0))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_g_file_test$3=g_file_test(filename, (enum anonymous$106)G_FILE_TEST_EXISTS);
    tmp_if_expr$4 = !(return_value_g_file_test$3 != 0) ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_fgets$5;
  if(tmp_if_expr$4)
    g_free((void *)filename);

  else
  {
    doc=xmlNewDoc((const unsigned char *)"1.0");
    root=xmlNewNode((struct _xmlNs *)(void *)0, (const unsigned char *)"options");
    xmlDocSetRootElement(doc, root);
    f=fopen(filename, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
    {
      i = 0;
      do
      {
        return_value_fgets$5=fgets((char *)&line, 1024 - 1, f);
        if(return_value_fgets$5 == ((char *)NULL))
          break;

        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen((char *)&line);
        line[(signed long int)(return_value_strlen$6 - (unsigned long int)1)] = (char)0;
        i = i + 1;
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(line);
        if(!(return_value_strlen$8 == 0ul))
        {
          keyvalue=g_strsplit(line, "=", 2);
          signed int return_value_strncmp$7;
          return_value_strncmp$7=strncmp(keyvalue[(signed long int)0], "#", (unsigned long int)1);
          if(!(return_value_strncmp$7 == 0))
          {
            if(!(keyvalue[1l] == ((char *)NULL)))
            {
              gm_debug_msg(DEBUG_DEFAULT, "GmOptions.check_old_options: converting %s, %s", keyvalue[(signed long int)0], keyvalue[(signed long int)1]);
              gm_options_save_option(keyvalue[(signed long int)0], keyvalue[(signed long int)1], root);
            }

            else
              gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load: wrong syntax of options line in %s line %d", filename, i);
          }

          g_strfreev(keyvalue);
        }

      }
      while((_Bool)1);
      fclose(f);
    }

    else
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      char *return_value_strerror$10;
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      gm_debug_msg(DEBUG_DEFAULT, "GmOptions.check_old_options: could not retrieve contents of file %s (%s)", filename, return_value_strerror$10);
    }
    xmlSaveFormatFileEnc(xmlname, doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    signed int return_value_g_file_test$11;
    return_value_g_file_test$11=g_file_test(xmlname, (enum anonymous$106)G_FILE_TEST_EXISTS);
    if(!(return_value_g_file_test$11 == 0))
    {
      chmod(xmlname, (unsigned int)0660);
      unlink(filename);
    }

    g_free((void *)filename);
  }
}

// add_bevels_to_rectangle
// file widgets/eggnotificationbubble.c line 277
static struct _GdkRegion * add_bevels_to_rectangle(struct _GdkRectangle *rectangle)
{
  struct _GdkRectangle temp_rect;
  struct _GdkRegion *region;
  region=gdk_region_rectangle(rectangle);
  temp_rect.width = 5;
  temp_rect.height = 1;
  temp_rect.x = rectangle->x;
  temp_rect.y = rectangle->y;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y + 1;
  temp_rect.width = temp_rect.width - 2;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y + 1;
  temp_rect.width = temp_rect.width - 1;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y + 1;
  temp_rect.width = temp_rect.width - 1;
  temp_rect.height = 2;
  subtract_rectangle(region, &temp_rect);
  temp_rect.width = 5;
  temp_rect.height = 1;
  temp_rect.x = (rectangle->x + rectangle->width) - temp_rect.width;
  temp_rect.y = rectangle->y;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y + 1;
  temp_rect.x = temp_rect.x + 2;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y + 1;
  temp_rect.x = temp_rect.x + 1;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y + 1;
  temp_rect.x = temp_rect.x + 1;
  temp_rect.height = 2;
  subtract_rectangle(region, &temp_rect);
  temp_rect.width = 5;
  temp_rect.height = 1;
  temp_rect.x = (rectangle->x + rectangle->width) - temp_rect.width;
  temp_rect.y = (rectangle->y + rectangle->height) - temp_rect.height;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y - 1;
  temp_rect.x = temp_rect.x + 2;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y - 1;
  temp_rect.x = temp_rect.x + 1;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y - 1;
  temp_rect.x = temp_rect.x + 1;
  temp_rect.height = 2;
  subtract_rectangle(region, &temp_rect);
  temp_rect.width = 5;
  temp_rect.height = 1;
  temp_rect.x = rectangle->x;
  temp_rect.y = rectangle->y + rectangle->height;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y - 1;
  temp_rect.width = temp_rect.width - 2;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y - 1;
  temp_rect.width = temp_rect.width - 1;
  subtract_rectangle(region, &temp_rect);
  temp_rect.y = temp_rect.y - 1;
  temp_rect.width = temp_rect.width - 1;
  temp_rect.height = 2;
  subtract_rectangle(region, &temp_rect);
  return region;
}

// addrinfo_thread
// file gm-net.c line 510
static void * addrinfo_thread(void *ptr)
{
  struct _threadinfo *info = (struct _threadinfo *)ptr;
  struct addrinfo hint;
  memset((void *)&hint, 0, sizeof(struct addrinfo) /*48ul*/ );
  hint.ai_flags = 0;
  hint.ai_family = 0;
  hint.ai_socktype = 1;
  hint.ai_protocol = 6;
  gm_debug_msg(DEBUG_DEFAULT, "GmNet.Connect: getaddrinfo: %s : %s", info->host, info->port);
  info->ret=getaddrinfo(info->host, info->port, &hint, &info->addr);
  pthread_mutex_lock(info->mutex_idle);
  do
  {
    struct anonymous$65 __cancel_buf;
    void (*__cancel_routine)(void *) = mutex_unlock;
    void *__cancel_arg = (void *)info->mutex_idle;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      info->idle_id=g_idle_add(idle_proceed_addrinfo, (void *)info);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// backward_lines_match
// file widgets/gm-searchable.c line 326
static signed int backward_lines_match(const struct _GtkTextIter *start, const char **lines, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end)
{
  struct _GtkTextIter line;
  struct _GtkTextIter next;
  char *line_text;
  const char *found;
  signed int offset;
  _Bool tmp_if_expr$1;
  if(*lines == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*(*lines) == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(!(match_start == ((struct _GtkTextIter *)NULL)))
      *match_start = *start;

    if(!(match_end == ((struct _GtkTextIter *)NULL)))
      *match_end = *start;

    return (signed int)!(0 != 0);
  }

  else
  {
    next = *start;
    line = next;
    signed int return_value_gtk_text_iter_get_line_offset$3;
    return_value_gtk_text_iter_get_line_offset$3=gtk_text_iter_get_line_offset(&next);
    if(return_value_gtk_text_iter_get_line_offset$3 == 0)
    {
      signed int return_value_gtk_text_iter_backward_line$2;
      return_value_gtk_text_iter_backward_line$2=gtk_text_iter_backward_line(&next);
      if(return_value_gtk_text_iter_backward_line$2 == 0)
        return 0;

    }

    else
      gtk_text_iter_set_line_offset(&next, 0);
    line_text=gtk_text_iter_get_visible_text(&next, &line);
    if(!(match_start == ((struct _GtkTextIter *)NULL)))
      found=g_utf8_strrcasestr(line_text, *lines);

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(line_text);
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(*lines);
      signed int return_value_g_utf8_caselessnmatch$6;
      return_value_g_utf8_caselessnmatch$6=g_utf8_caselessnmatch(line_text, *lines, (signed long int)return_value_strlen$4, (signed long int)return_value_strlen$5);
      if(!(return_value_g_utf8_caselessnmatch$6 == 0))
        found = line_text;

      else
        found = (const char *)(void *)0;
    }
    if(found == ((const char *)NULL))
    {
      g_free((void *)line_text);
      return 0;
    }

    else
    {
      signed long int return_value_g_utf8_strlen$7;
      return_value_g_utf8_strlen$7=g_utf8_strlen(line_text, found - line_text);
      offset = (signed int)return_value_g_utf8_strlen$7;
      forward_chars_with_skipping(&next, offset, 0);
      if(!(match_start == ((struct _GtkTextIter *)NULL)))
        *match_start = next;

      signed long int return_value_g_utf8_strlen$8;
      return_value_g_utf8_strlen$8=g_utf8_strlen(*lines, (signed long int)-1);
      forward_chars_with_skipping(&next, (signed int)return_value_g_utf8_strlen$8, (signed int)!(0 != 0));
      g_free((void *)line_text);
      lines = lines + 1l;
      if(!(match_end == ((struct _GtkTextIter *)NULL)))
        *match_end = next;

      signed int return_value_lines_match$9;
      return_value_lines_match$9=lines_match(&next, lines, (struct _GtkTextIter *)(void *)0, match_end);
      return return_value_lines_match$9;
    }
  }
}

// blink_info_free
// file widgets/gm-world-text-view.c line 239
static void blink_info_free(struct _BlinkInfo *info)
{
  signed int return_value_gtk_text_mark_get_deleted$4;
  return_value_gtk_text_mark_get_deleted$4=gtk_text_mark_get_deleted(info->begin);
  unsigned long int return_value_gtk_text_view_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$3;
  if(return_value_gtk_text_mark_get_deleted$4 == 0)
  {
    return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)info->view, return_value_gtk_text_view_get_type$1);
    return_value_gtk_text_view_get_buffer$3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
    gtk_text_buffer_delete_mark(return_value_gtk_text_view_get_buffer$3, info->begin);
  }

  g_object_unref((void *)info->begin);
  g_object_unref((void *)info->text);
  g_free((void *)info->fill);
  g_free((void *)info);
}

// bubble_window_display_closed
// file widgets/eggnotificationbubble.c line 123
static void bubble_window_display_closed(struct _GdkDisplay *display, signed int was_error, struct _EggNotificationBubble *bubble)
{
  egg_notification_bubble_unset_bubble_window(bubble);
}

// build_terminal_command
// file widgets/gm-external-view.c line 140
static char ** build_terminal_command(const char *editor_command)
{
  struct _GConfClient *client;
  char *term;
  char *term_extra_args = (char *)(void *)0;
  char *term_args = (char *)(void *)0;
  char **spawn_command = (char **)(void *)0;
  struct anonymous$103 *terminal;
  char **argv;
  signed int argc;
  signed int i;
  client=gconf_client_get_default();
  term=gconf_client_get_string(client, "/desktop/gnome/applications/terminal/exec", (struct _GError **)(void *)0);
  if(!(term == ((char *)NULL)))
    term_extra_args=gconf_client_get_string(client, "/desktop/gnome/applications/terminal/exec_arg", (struct _GError **)(void *)0);

  else
  {
    char *return_value_getenv$1;
    return_value_getenv$1=getenv("TERM");
    term=g_strdup(return_value_getenv$1);
    if(term == ((char *)NULL))
      term=g_strdup("xterm");

    term_extra_args=g_strdup("-e");
  }
  terminal=find_terminal(term);
  if(!(terminal == ((struct anonymous$103 *)NULL)))
    term_args = (char *)terminal->arguments;

  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(!(term_args == ((char *)NULL)))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(!(term_extra_args == ((char *)NULL)))
      tmp_if_expr$4 = (signed int)*term_extra_args != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    term_args=g_strdup_printf("%s %s %s", term_args != ((char *)NULL) ? term_args : "", term_extra_args != ((char *)NULL) ? term_extra_args : "", editor_command);
    signed int return_value_g_shell_parse_argv$3;
    return_value_g_shell_parse_argv$3=g_shell_parse_argv(term_args, &argc, &argv, (struct _GError **)(void *)0);
    if(!(return_value_g_shell_parse_argv$3 == 0))
    {
      void *return_value_g_malloc0_n$2;
      return_value_g_malloc0_n$2=g_malloc0_n((unsigned long int)(argc + 2), sizeof(char *) /*8ul*/ );
      spawn_command = (char **)return_value_g_malloc0_n$2;
      spawn_command[(signed long int)0] = term;
      i = 0;
      for( ; !(i >= argc); i = i + 1)
        spawn_command[(signed long int)(i + 1)] = argv[(signed long int)i];
      g_free((void *)argv);
    }

    g_free((void *)term_args);
  }

  g_free((void *)term_extra_args);
  g_object_unref((void *)client);
  i = 0;
  for( ; !(spawn_command[(signed long int)i] == ((char *)NULL)); i = i + 1)
    printf("'%s' ", spawn_command[(signed long int)i]);
  printf("\n");
  return spawn_command;
}

// cell_renderer_text_finalize
// file mcp/gm-cell-renderer-text.c line 83
static void cell_renderer_text_finalize(struct _GObject *object)
{
  struct _GmCellRendererText *cell;
  unsigned long int return_value_gm_cell_renderer_text_get_type$1;
  return_value_gm_cell_renderer_text_get_type$1=gm_cell_renderer_text_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_cell_renderer_text_get_type$1);
  cell = (struct _GmCellRendererText *)return_value_g_type_check_instance_cast$2;
  g_free((void *)cell->priv->name);
  g_free((void *)cell->priv->status);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)parent_class$link4, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// cell_renderer_text_get_property
// file mcp/gm-cell-renderer-text.c line 95
static void cell_renderer_text_get_property(struct _GObject *object, unsigned int param_id, struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _GmCellRendererText *cell;
  unsigned long int return_value_gm_cell_renderer_text_get_type$1;
  return_value_gm_cell_renderer_text_get_type$1=gm_cell_renderer_text_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_cell_renderer_text_get_type$1);
  cell = (struct _GmCellRendererText *)return_value_g_type_check_instance_cast$2;
  switch(param_id)
  {
    case (unsigned int)1:
    {
      g_value_set_string(value, cell->priv->name);
      break;
    }
    case (unsigned int)2:
    {
      g_value_set_string(value, cell->priv->status);
      break;
    }
    default:
      do
      {
        struct _GObject *_glib__object = (struct _GObject *)object;
        struct _GParamSpec *_glib__pspec = (struct _GParamSpec *)pspec;
        unsigned int _glib__property_id = param_id;
        const char *return_value_g_type_name$3;
        return_value_g_type_name$3=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__pspec)->g_class)->g_type);
        const char *return_value_g_type_name$4;
        return_value_g_type_name$4=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__object)->g_class)->g_type);
        g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_WARNING, "%s:%d: invalid %s id %u for \"%s\" of type '%s' in '%s'", (const void *)"mcp/gm-cell-renderer-text.c", 109, (const void *)"property", _glib__property_id, _glib__pspec->name, return_value_g_type_name$3, return_value_g_type_name$4);
      }
      while((_Bool)0);
  }
}

// cell_renderer_text_get_size
// file mcp/gm-cell-renderer-text.c line 148
static void cell_renderer_text_get_size(struct _GtkCellRenderer *cell, struct _GtkWidget *widget, struct _GdkRectangle *cell_area, signed int *x_offset, signed int *y_offset, signed int *width, signed int *height)
{
  struct _GmCellRendererText *celltext;
  unsigned long int return_value_gm_cell_renderer_text_get_type$1;
  return_value_gm_cell_renderer_text_get_type$1=gm_cell_renderer_text_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)cell, return_value_gm_cell_renderer_text_get_type$1);
  celltext = (struct _GmCellRendererText *)return_value_g_type_check_instance_cast$2;
  cell_renderer_text_update_text(celltext, widget, 0, 0);
  unsigned long int return_value_gtk_cell_renderer_get_type$3;
  return_value_gtk_cell_renderer_get_type$3=gtk_cell_renderer_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$4;
  return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class$link4, return_value_gtk_cell_renderer_get_type$3);
  ((struct _GtkCellRendererClass *)return_value_g_type_check_class_cast$4)->get_size(cell, widget, cell_area, x_offset, y_offset, width, height);
}

// cell_renderer_text_render
// file mcp/gm-cell-renderer-text.c line 162
static void cell_renderer_text_render(struct _GtkCellRenderer *cell, struct _GdkDrawable *window, struct _GtkWidget *widget, struct _GdkRectangle *background_area, struct _GdkRectangle *cell_area, struct _GdkRectangle *expose_area, enum anonymous$1 flags)
{
  struct _GmCellRendererText *celltext;
  unsigned long int return_value_gm_cell_renderer_text_get_type$1;
  return_value_gm_cell_renderer_text_get_type$1=gm_cell_renderer_text_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)cell, return_value_gm_cell_renderer_text_get_type$1);
  celltext = (struct _GmCellRendererText *)return_value_g_type_check_instance_cast$2;
  cell_renderer_text_update_text(celltext, widget, cell_area->width, (signed int)flags & GTK_CELL_RENDERER_SELECTED);
  unsigned long int return_value_gtk_cell_renderer_get_type$3;
  return_value_gtk_cell_renderer_get_type$3=gtk_cell_renderer_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$4;
  return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class$link4, return_value_gtk_cell_renderer_get_type$3);
  ((struct _GtkCellRendererClass *)return_value_g_type_check_class_cast$4)->render(cell, window, widget, background_area, cell_area, expose_area, flags);
}

// cell_renderer_text_set_property
// file mcp/gm-cell-renderer-text.c line 115
static void cell_renderer_text_set_property(struct _GObject *object, unsigned int param_id, const struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _GmCellRendererText *cell;
  const char *str;
  unsigned long int return_value_gm_cell_renderer_text_get_type$1;
  return_value_gm_cell_renderer_text_get_type$1=gm_cell_renderer_text_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_cell_renderer_text_get_type$1);
  cell = (struct _GmCellRendererText *)return_value_g_type_check_instance_cast$2;
  switch(param_id)
  {
    case (unsigned int)1:
    {
      g_free((void *)cell->priv->name);
      str=g_value_get_string(value);
      cell->priv->name=g_strdup(str);
      if(!(cell->priv->name == ((char *)NULL)))
        g_strdelimit(cell->priv->name, "\n\r\t", (char)32);

      break;
    }
    case (unsigned int)2:
    {
      g_free((void *)cell->priv->status);
      str=g_value_get_string(value);
      cell->priv->status=g_strdup(str);
      if(!(cell->priv->status == ((char *)NULL)))
        g_strdelimit(cell->priv->status, "\n\r\t", (char)32);

      break;
    }
    default:
      do
      {
        struct _GObject *_glib__object = (struct _GObject *)object;
        struct _GParamSpec *_glib__pspec = (struct _GParamSpec *)pspec;
        unsigned int _glib__property_id = param_id;
        const char *return_value_g_type_name$3;
        return_value_g_type_name$3=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__pspec)->g_class)->g_type);
        const char *return_value_g_type_name$4;
        return_value_g_type_name$4=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__object)->g_class)->g_type);
        g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_WARNING, "%s:%d: invalid %s id %u for \"%s\" of type '%s' in '%s'", (const void *)"mcp/gm-cell-renderer-text.c", 142, (const void *)"property", _glib__property_id, _glib__pspec->name, return_value_g_type_name$3, return_value_g_type_name$4);
      }
      while((_Bool)0);
  }
}

// cell_renderer_text_update_text
// file mcp/gm-cell-renderer-text.c line 178
static void cell_renderer_text_update_text(struct _GmCellRendererText *cell, struct _GtkWidget *widget, signed int new_width, signed int selected)
{
  struct _PangoAttrList *attr_list;
  struct _PangoAttribute *attr_color;
  struct _PangoAttribute *attr_style;
  struct _PangoAttribute *attr_size;
  struct _GtkStyle *style;
  struct _GdkColor color;
  char *str;
  signed int show_status = 0;
  signed int font_size;
  cell->priv->width = new_width;
  attr_color = (struct _PangoAttribute *)(void *)0;
  if(!(cell->priv->status == ((char *)NULL)))
  {
    if(!((signed int)*cell->priv->status == 0))
      show_status = (signed int)!(0 != 0);

  }

  char *tmp_if_expr$1;
  if(!(cell->priv->name == ((char *)NULL)))
  {
    if(show_status == 0)
      tmp_if_expr$1 = "";

    else
      tmp_if_expr$1 = cell->priv->status;
    str=g_strdup_printf("%s%s%s", cell->priv->name, !(show_status != 0) ? "" : "\n", tmp_if_expr$1);
  }

  else
  {
    g_object_set((void *)cell, "visible", !(0 != 0), (const void *)"weight", 400, (const void *)"text", (const void *)"", (void *)0);
    goto __CPROVER_DUMP_L7;
  }
  style=gtk_widget_get_style(widget);
  color = style->text_aa[(signed long int)GTK_STATE_NORMAL];
  signed int return_value_pango_font_description_get_size$2;
  return_value_pango_font_description_get_size$2=pango_font_description_get_size(style->font_desc);
  font_size = return_value_pango_font_description_get_size$2 / 1024;
  attr_list=pango_attr_list_new();
  signed int return_value_pango_font_description_get_size$3;
  return_value_pango_font_description_get_size$3=pango_font_description_get_size(style->font_desc);
  attr_size=pango_attr_size_new((signed int)((double)return_value_pango_font_description_get_size$3 / (font_size >= 10 ? 1.2 : 1.0)));
  attr_size->start_index = (unsigned int)0;
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(cell->priv->name);
  attr_size->end_index = (unsigned int)return_value_strlen$4;
  pango_attr_list_insert(attr_list, attr_size);
  attr_style=pango_attr_style_new((enum anonymous$4)PANGO_STYLE_ITALIC);
  attr_style->start_index = attr_size->end_index + (unsigned int)1;
  attr_style->end_index = (unsigned int)-1;
  pango_attr_list_insert(attr_list, attr_style);
  if(selected == 0)
  {
    attr_color=pango_attr_foreground_new(color.red, color.green, color.blue);
    attr_color->start_index = attr_style->start_index;
    attr_color->end_index = (unsigned int)-1;
    pango_attr_list_insert(attr_list, attr_color);
  }

  signed int return_value_pango_font_description_get_size$5;
  return_value_pango_font_description_get_size$5=pango_font_description_get_size(style->font_desc);
  attr_size=pango_attr_size_new((signed int)((double)return_value_pango_font_description_get_size$5 / (font_size >= 10 ? 1.5 : 1.2)));
  attr_size->start_index = attr_style->start_index;
  attr_size->end_index = (unsigned int)-1;
  pango_attr_list_insert(attr_list, attr_size);
  g_object_set((void *)cell, "visible", !(0 != 0), (const void *)"weight", 400, (const void *)"text", str, (const void *)"attributes", attr_list, (void *)0);
  pango_attr_list_unref(attr_list);
  g_free((void *)str);

__CPROVER_DUMP_L7:
  ;
}

// create_button
// file widgets/gm-app-view.c line 429
struct _GtkWidget * create_button(char *label, char *stock)
{
  struct _GtkWidget *align;
  align=gtk_alignment_new((float)0.5, (float)0.5, (float)0.0, (float)0.0);
  struct _GtkWidget *button;
  button=gtk_button_new();
  struct _GtkWidget *hbox;
  hbox=gtk_hbox_new(0, 2);
  unsigned long int return_value_gtk_container_get_type$1;
  return_value_gtk_container_get_type$1=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_container_get_type$1);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$2, align);
  unsigned long int return_value_gtk_container_get_type$3;
  return_value_gtk_container_get_type$3=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)align, return_value_gtk_container_get_type$3);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$4, hbox);
  unsigned long int return_value_gtk_box_get_type$5;
  return_value_gtk_box_get_type$5=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$5);
  struct _GtkWidget *return_value_gtk_image_new_from_stock$7;
  return_value_gtk_image_new_from_stock$7=gtk_image_new_from_stock(stock, (enum anonymous$21)GTK_ICON_SIZE_BUTTON);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$6, return_value_gtk_image_new_from_stock$7, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$8;
  return_value_gtk_box_get_type$8=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$8);
  struct _GtkWidget *return_value_gtk_label_new$10;
  return_value_gtk_label_new$10=gtk_label_new(label);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$9, return_value_gtk_label_new$10, 0, 0, (unsigned int)0);
  return button;
}

// disconnect_bubble_window_display_closed
// file widgets/eggnotificationbubble.c line 131
static void disconnect_bubble_window_display_closed(struct _EggNotificationBubble *bubble)
{
  struct _GdkDisplay *return_value_gtk_widget_get_display$1;
  return_value_gtk_widget_get_display$1=gtk_widget_get_display(bubble->bubble_window);
  g_signal_handlers_disconnect_matched((void *)return_value_gtk_widget_get_display$1, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)bubble_window_display_closed, (void *)bubble);
}

// do_MOOVar_parse
// file list.c line 79
struct _MOOVar * do_MOOVar_parse(const char **s)
{
  struct _MOOVar *var = (struct _MOOVar *)(void *)0;
  struct _MOOVar *item;
  struct anonymous$90 *stream;
  signed int i;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*(*s)]) == 0)
      break;

    *s = *s + 1l;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  const unsigned short int **return_value___ctype_b_loc$6;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  const unsigned short int **return_value___ctype_b_loc$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  if((signed int)*(*s) == 123)
  {
    *s = *s + 1l;
    var=MOOVar_new_list();
    while(!(*(*s) == 0))
    {
      if((signed int)*(*s) == 125)
        break;

      item=do_MOOVar_parse(s);
      if(!(item == ((struct _MOOVar *)NULL)))
        MOOVar_listappend(var, item);

      else
        goto error;
      do
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*(*s)]) == 0)
          break;

        *s = *s + 1l;
      }
      while((_Bool)1);
      if((signed int)*(*s) == 44)
        *s = *s + 1l;

      else
        break;
    }
    if((signed int)*(*s) == 125)
    {
      *s = *s + 1l;
      return var;
    }


  error:
    ;
    MOOVar_free(var);
    return (struct _MOOVar *)(void *)0;
  }

  else
  {
    stream=stream_new(80);
    if((signed int)*(*s) == 34)
    {
      *s = *s + 1l;
      i = 0;
      for( ; !(*(*s) == 0); *s = *s + 1l)
        switch((signed int)*(*s))
        {
          case 34:
            if(i == 0)
            {
              var=MOOVar_new_string(stream->buf);
              stream_free(stream);
              *s = *s + 1l;
              return var;
            }

            else
            {
              stream_append(stream, *(*s));
              break;
            }
          case 92:
            if(i == 0)
            {
              i = 1;
              break;
            }

          default:
          {
            stream_append(stream, *(*s));
            i = 0;
          }
        }
      stream_free(stream);
      return (struct _MOOVar *)(void *)0;
    }

    else
    {
      if((signed int)*(*s) == 35)
      {
        *s = *s + 1l;
        if((signed int)*(*s) == 45)
        {
          stream_append(stream, *(*s));
          *s = *s + 1l;
        }

        do
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*(*s)]) == 0)
            break;

          stream_append(stream, *(*s));
          *s = *s + 1l;
        }
        while((_Bool)1);
        if(stream->pos == 0)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)stream->buf[(signed long int)(stream->pos - 1)] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
        {
          stream_free(stream);
          return (struct _MOOVar *)(void *)0;
        }

        signed int return_value_atoi$5;
        return_value_atoi$5=atoi(stream->buf);
        var=MOOVar_new_object(return_value_atoi$5);
        stream_free(stream);
        return var;
      }

      if((signed int)*(*s) == 69)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)*(*s) == 101 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        if((signed int)(*s)[1l] == 95)
        {
          stream_append(stream, (char)101);
          stream_append(stream, (char)95);
          *s = *s + (signed long int)2;
          do
          {
            return_value___ctype_b_loc$6=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*(*s)]) == 0)
              break;

            stream_append(stream, *(*s));
            *s = *s + 1l;
          }
          while((_Bool)1);
          var=MOOVar_new_error(stream->buf);
          stream_free(stream);
          return var;
        }

      }

      if((signed int)*(*s) == 45)
      {
        stream_append(stream, *(*s));
        *s = *s + 1l;
      }

      const unsigned short int **return_value___ctype_b_loc$11;
      return_value___ctype_b_loc$11=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)*(*s)]) == 0))
        tmp_if_expr$12 = (_Bool)1;

      else
        tmp_if_expr$12 = (signed int)*(*s) == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$12)
        tmp_if_expr$13 = (_Bool)1;

      else
        tmp_if_expr$13 = (signed int)*(*s) == 101 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$13)
        tmp_if_expr$14 = (_Bool)1;

      else
        tmp_if_expr$14 = (signed int)*(*s) == 69 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$14)
      {
        i = 0;
        do
        {
          return_value___ctype_b_loc$8=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*(*s)]) == 0)
          {
            if(!((signed int)*(*s) == 46))
            {
              if(!((signed int)*(*s) == 101))
              {
                if(!((signed int)*(*s) == 69))
                  break;

              }

            }

          }

          if((signed int)*(*s) == 46)
            tmp_if_expr$9 = (_Bool)1;

          else
            tmp_if_expr$9 = (signed int)*(*s) == 101 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$9)
            tmp_if_expr$10 = (_Bool)1;

          else
            tmp_if_expr$10 = (signed int)*(*s) == 69 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$10)
            i = (signed int)!(0 != 0);

          stream_append(stream, *(*s));
          *s = *s + 1l;
        }
        while((_Bool)1);
        if(!(i == 0))
          var=MOOVar_new_float(stream->buf);

        else
          var=MOOVar_new_int(stream->buf);
        stream_free(stream);
        return var;
      }

      stream_free(stream);
      return (struct _MOOVar *)(void *)0;
    }
  }
}

// do_MOOVar_tostr
// file list.c line 417
void do_MOOVar_tostr(struct _MOOVar *v, struct anonymous$90 *stream)
{
  signed int i;
  struct _MOOVar *v2 = (struct _MOOVar *)(void *)0;
  char *s;
  struct _MOOVar *tmp_if_expr$1;
  char *return_value_to_error$2;
  if(!(v == ((struct _MOOVar *)NULL)))
  {
    switch((signed int)v->type)
    {
      case LIST:
      {
        stream_append(stream, (char)123);
        i = 0;
        for( ; !(i >= v->i); i = i + 1)
        {
          if(i == 0)
            tmp_if_expr$1 = v->list;

          else
            tmp_if_expr$1 = v2->next;
          v2 = tmp_if_expr$1;
          do_MOOVar_tostr(v2, stream);
          if(!(i == v->i + -1))
            stream_append(stream, (char)44);

        }
        stream_append(stream, (char)125);
        goto __CPROVER_DUMP_L15;
      }
      case ERROR:
      {
        return_value_to_error$2=to_error(v->i);
        stream_append_string(stream, return_value_to_error$2);
        goto __CPROVER_DUMP_L15;
      }
      case STRING:
      {
        stream_append_string_quoted(stream, v->s);
        goto __CPROVER_DUMP_L15;
      }
      case INT:
      {
        s=g_strdup_printf("%d", v->i);
        break;
      }
      case FLOAT:
      {
        s=g_strdup_printf("%f", v->d);
        break;
      }
      case OBJECT:
      {
        s=g_strdup_printf("#%d", v->i);
        break;
      }
      default:
        goto __CPROVER_DUMP_L15;
    }
    stream_append_string(stream, s);
    g_free((void *)s);
  }


__CPROVER_DUMP_L15:
  ;
}

// draw_bubble
// file widgets/eggnotificationbubble.c line 385
static void draw_bubble(struct _EggNotificationBubble *bubble, unsigned int timeout)
{
  struct _GtkRequisition requisition;
  struct _GtkWidget *widget;
  struct _GtkStyle *style;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  struct _GdkScreen *screen;
  signed int monitor_num;
  struct _GdkRectangle monitor;
  struct _GdkPoint triangle_points[3l];
  char *markuptext;
  char *markupquoted;
  struct _GdkRectangle rectangle;
  struct _GdkRegion *region;
  struct _GdkRegion *triangle_region;
  /* #anon_enum$ORIENT_TOP=0$ORIENT_BOTTOM=1 */
enum anonymous$147 { ORIENT_TOP=0, ORIENT_BOTTOM=1 };

/* */
  ;
  enum anonymous$147 orient;
  unsigned int rectangle_border;
  unsigned int triangle_offset;
  if(bubble->bubble_window == ((struct _GtkWidget *)NULL))
    force_window(bubble);

  gtk_widget_ensure_style(bubble->bubble_window);
  style = bubble->bubble_window->style;
  widget = bubble->widget;
  screen=gtk_widget_get_screen(widget);
  if(!(bubble->icon == ((struct _GtkWidget *)NULL)))
  {
    unsigned long int return_value_gtk_box_get_type$1;
    return_value_gtk_box_get_type$1=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)bubble->main_hbox, return_value_gtk_box_get_type$1);
    gtk_box_pack_start_defaults((struct _GtkBox *)return_value_g_type_check_instance_cast$2, bubble->icon);
    unsigned long int return_value_gtk_box_get_type$3;
    return_value_gtk_box_get_type$3=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)bubble->main_hbox, return_value_gtk_box_get_type$3);
    gtk_box_reorder_child((struct _GtkBox *)return_value_g_type_check_instance_cast$4, bubble->icon, 0);
  }

  markupquoted=g_markup_escape_text(bubble->bubble_header_text, (signed long int)-1);
  markuptext=g_strdup_printf("<b>%s</b>", markupquoted);
  unsigned long int return_value_gtk_label_get_type$5;
  return_value_gtk_label_get_type$5=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_header_label, return_value_gtk_label_get_type$5);
  gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$6, markuptext);
  g_free((void *)markuptext);
  g_free((void *)markupquoted);
  unsigned long int return_value_gtk_label_get_type$7;
  return_value_gtk_label_get_type$7=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_body_label, return_value_gtk_label_get_type$7);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$8, bubble->bubble_body_text);
  unsigned long int return_value_gtk_window_get_type$9;
  return_value_gtk_window_get_type$9=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_window, return_value_gtk_window_get_type$9);
  signed int return_value_gdk_screen_get_height$11;
  return_value_gdk_screen_get_height$11=gdk_screen_get_height(screen);
  gtk_window_move((struct _GtkWindow *)return_value_g_type_check_instance_cast$10, 0, 2 * return_value_gdk_screen_get_height$11);
  gtk_widget_show_all(bubble->bubble_window);
  gtk_widget_size_request(bubble->bubble_window, &requisition);
  w = requisition.width;
  h = requisition.height;
  gdk_window_get_origin(widget->window, &x, &y);
  unsigned long int return_value_gtk_object_get_type$12;
  return_value_gtk_object_get_type$12=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_object_get_type$12);
  if(!((32u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$13)->flags) == 0u))
  {
    x = x + widget->allocation.x;
    y = y + widget->allocation.y;
  }

  orient = (enum anonymous$147)ORIENT_BOTTOM;
  triangle_offset = (unsigned int)20;
  x = x - (signed int)triangle_offset;
  monitor_num=gdk_screen_get_monitor_at_window(screen, widget->window);
  gdk_screen_get_monitor_geometry(screen, monitor_num, &monitor);
  if(!(monitor.width + monitor.x >= w + x))
  {
    signed int offset = (x + w) - (monitor.x + monitor.width);
    triangle_offset = triangle_offset + (unsigned int)offset;
    x = x - offset;
  }

  else
    if(!(x >= monitor.x))
    {
      signed int draw_bubble$$1$$4$$offset = monitor.x - x;
      triangle_offset = triangle_offset - (unsigned int)draw_bubble$$1$$4$$offset;
      x = x + draw_bubble$$1$$4$$offset;
    }

  if(!(monitor.height + monitor.y >= 4 + widget->allocation.height + h + y))
  {
    y = y - (h - 4);
    orient = (enum anonymous$147)ORIENT_TOP;
  }

  else
    y = y + widget->allocation.height + 4;
  if((signed int)orient == ORIENT_BOTTOM)
    y = y - 5;

  else
    y = y + 5;
  rectangle_border = (unsigned int)(15 - 2);
  rectangle.x = (signed int)rectangle_border;
  rectangle.y = (signed int)rectangle_border;
  rectangle.width = (signed int)((unsigned int)w - rectangle_border * (unsigned int)2);
  rectangle.height = (signed int)((unsigned int)h - rectangle_border * (unsigned int)2);
  region=add_bevels_to_rectangle(&rectangle);
  triangle_points[(signed long int)0].x = (signed int)triangle_offset;
  triangle_points[(signed long int)0].y = (signed int)orient == ORIENT_BOTTOM ? 15 : h - 15;
  triangle_points[(signed long int)1].x = triangle_points[(signed long int)0].x + 20;
  triangle_points[(signed long int)1].y = triangle_points[(signed long int)0].y;
  triangle_points[(signed long int)2].x = (triangle_points[(signed long int)1].x + triangle_points[(signed long int)0].x) / 2;
  triangle_points[(signed long int)2].y = (signed int)orient == ORIENT_BOTTOM ? 0 : h;
  triangle_region=gdk_region_polygon(triangle_points, 3, (enum anonymous$148)GDK_WINDING_RULE);
  gdk_region_union(region, triangle_region);
  gdk_region_destroy(triangle_region);
  gdk_window_shape_combine_region(bubble->bubble_window->window, region, 0, 0);
  unsigned long int return_value_gtk_window_get_type$14;
  return_value_gtk_window_get_type$14=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_window, return_value_gtk_window_get_type$14);
  gtk_window_move((struct _GtkWindow *)return_value_g_type_check_instance_cast$15, x, y);
  bubble->active = (signed int)!(0 != 0);
  if(!(bubble->timeout_id == 0u))
  {
    g_source_remove(bubble->timeout_id);
    bubble->timeout_id = (unsigned int)0;
  }

  if(timeout >= 1u)
    bubble->timeout_id=g_timeout_add(timeout, idle_notification_expired, (void *)bubble);

}

// egg_notification_bubble_attach
// file widgets/eggnotificationbubble.c line 219
void egg_notification_bubble_attach(struct _EggNotificationBubble *bubble, struct _GtkWidget *widget)
{
  bubble->widget = widget;
  g_signal_connect_object((void *)widget, "destroy", (void (*)(void))g_object_unref, (void *)bubble, (enum anonymous$73)G_CONNECT_SWAPPED);
}

// egg_notification_bubble_class_init
// file widgets/eggnotificationbubble.c line 87
static void egg_notification_bubble_class_init(struct _EggNotificationBubbleClass *class)
{
  struct _GtkObjectClass *object_class = (struct _GtkObjectClass *)class;
  void *return_value_g_type_class_peek_parent$1;
  return_value_g_type_class_peek_parent$1=g_type_class_peek_parent((void *)class);
  parent_class$link2 = (struct _GtkObjectClass *)return_value_g_type_class_peek_parent$1;
  object_class->destroy = egg_notification_bubble_destroy;
  unsigned long int return_value_egg_notification_bubble_get_type$2;
  return_value_egg_notification_bubble_get_type$2=egg_notification_bubble_get_type();
  egg_notification_bubble_signals[(signed long int)0]=g_signal_new("clicked", return_value_egg_notification_bubble_get_type$2, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)160ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  unsigned long int return_value_egg_notification_bubble_get_type$3;
  return_value_egg_notification_bubble_get_type$3=egg_notification_bubble_get_type();
  egg_notification_bubble_signals[(signed long int)1]=g_signal_new("timeout", return_value_egg_notification_bubble_get_type$3, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)168ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
}

// egg_notification_bubble_destroy
// file widgets/eggnotificationbubble.c line 151
static void egg_notification_bubble_destroy(struct _GtkObject *object)
{
  struct _EggNotificationBubble *bubble;
  unsigned long int return_value_egg_notification_bubble_get_type$1;
  return_value_egg_notification_bubble_get_type$1=egg_notification_bubble_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_egg_notification_bubble_get_type$1);
  bubble = (struct _EggNotificationBubble *)return_value_g_type_check_instance_cast$2;
  do
    if(bubble == ((struct _EggNotificationBubble *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_notification_bubble_destroy", "bubble != NULL");
      goto __CPROVER_DUMP_L4;
    }

  while((_Bool)0);
  if(!(bubble->timeout_id == 0u))
  {
    g_source_remove(bubble->timeout_id);
    bubble->timeout_id = (unsigned int)0;
  }

  egg_notification_bubble_detach(bubble);
  egg_notification_bubble_unset_bubble_window(bubble);
  unsigned long int return_value_gtk_object_get_type$3;
  return_value_gtk_object_get_type$3=gtk_object_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$4;
  return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class$link2, return_value_gtk_object_get_type$3);
  ((struct _GtkObjectClass *)return_value_g_type_check_class_cast$4)->destroy(object);

__CPROVER_DUMP_L4:
  ;
}

// egg_notification_bubble_detach
// file widgets/eggnotificationbubble.c line 554
static void egg_notification_bubble_detach(struct _EggNotificationBubble *bubble)
{
  do
    if(bubble->widget == ((struct _GtkWidget *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_notification_bubble_detach", "bubble->widget");
      goto __CPROVER_DUMP_L3;
    }

  while((_Bool)0);
  g_object_unref((void *)bubble->widget);

__CPROVER_DUMP_L3:
  ;
}

// egg_notification_bubble_event_handler
// file widgets/eggnotificationbubble.c line 535
static void egg_notification_bubble_event_handler(struct _GtkWidget *widget, union _GdkEvent *event, void *user_data)
{
  struct _EggNotificationBubble *bubble;
  unsigned long int return_value_egg_notification_bubble_get_type$1;
  return_value_egg_notification_bubble_get_type$1=egg_notification_bubble_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_egg_notification_bubble_get_type$1);
  bubble = (struct _EggNotificationBubble *)return_value_g_type_check_instance_cast$2;
  if((signed int)event->type == GDK_BUTTON_PRESS)
    g_signal_emit((void *)bubble, egg_notification_bubble_signals[(signed long int)0], (unsigned int)0);

}

// egg_notification_bubble_get_type
// file widgets/eggnotificationbubble.c line 60
unsigned long int egg_notification_bubble_get_type(void)
{
  static unsigned long int bubble_type = (unsigned long int)0;
  if(bubble_type == 0ul)
  {
    unsigned long int return_value_gtk_object_get_type$1;
    return_value_gtk_object_get_type$1=gtk_object_get_type();
    static const struct _GTypeInfo bubble_info = { .class_size=(unsigned short int)sizeof(struct _EggNotificationBubbleClass) /*208ul*/ , .base_init=(void (*)(void *))(void *)0,
    .base_finalize=(void (*)(void *))(void *)0,
    .class_init=(void (*)(void *, void *))egg_notification_bubble_class_init,
    .class_finalize=(void (*)(void *, void *))(void *)0,
    .class_data=(void *)0,
    .instance_size=(unsigned short int)sizeof(struct _EggNotificationBubble) /*112ul*/ , .n_preallocs=(unsigned short int)0,
    .instance_init=(void (*)(struct _GTypeInstance *, void *))egg_notification_bubble_init, .value_table=((const struct _GTypeValueTable *)NULL) };
    bubble_type=g_type_register_static(return_value_gtk_object_get_type$1, "EggNotificationBubble", &bubble_info, (enum anonymous)0);
  }

  return bubble_type;
}

// egg_notification_bubble_hide
// file widgets/eggnotificationbubble.c line 517
void egg_notification_bubble_hide(struct _EggNotificationBubble *bubble)
{
  if(!(bubble->bubble_window == ((struct _GtkWidget *)NULL)))
    gtk_widget_hide(bubble->bubble_window);

  if(!(bubble->timeout_id == 0u))
  {
    g_source_remove(bubble->timeout_id);
    bubble->timeout_id = (unsigned int)0;
  }

}

// egg_notification_bubble_init
// file widgets/eggnotificationbubble.c line 117
static void egg_notification_bubble_init(struct _EggNotificationBubble *bubble)
{
  bubble->bubble_window = (struct _GtkWidget *)(void *)0;
}

// egg_notification_bubble_new
// file widgets/eggnotificationbubble.c line 529
struct _EggNotificationBubble * egg_notification_bubble_new(void)
{
  unsigned long int return_value_egg_notification_bubble_get_type$1;
  return_value_egg_notification_bubble_get_type$1=egg_notification_bubble_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_egg_notification_bubble_get_type$1, (const char *)(void *)0);
  return (struct _EggNotificationBubble *)return_value_g_object_new$2;
}

// egg_notification_bubble_paint_window
// file widgets/eggnotificationbubble.c line 254
static signed int egg_notification_bubble_paint_window(struct _EggNotificationBubble *bubble)
{
  struct _GtkRequisition req;
  gtk_widget_size_request(bubble->bubble_window, &req);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_window, return_value_gtk_widget_get_type$1);
  gtk_paint_flat_box(bubble->bubble_window->style, bubble->bubble_window->window, (enum anonymous$23)GTK_STATE_NORMAL, (enum anonymous$89)GTK_SHADOW_OUT, (const struct _GdkRectangle *)(void *)0, (struct _GtkWidget *)return_value_g_type_check_instance_cast$2, "notification", 0, 0, req.width, req.height);
  return 0;
}

// egg_notification_bubble_set
// file widgets/eggnotificationbubble.c line 230
void egg_notification_bubble_set(struct _EggNotificationBubble *bubble, const char *bubble_header_text, struct _GtkWidget *icon, const char *bubble_body_text)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)bubble;
    unsigned long int __t;
    __t=egg_notification_bubble_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_notification_bubble_set", "EGG_IS_NOTIFICATION_BUBBLE (bubble)");
      goto __CPROVER_DUMP_L11;
    }

  }
  while((_Bool)0);
  g_free((void *)bubble->bubble_header_text);
  g_free((void *)bubble->bubble_body_text);
  unsigned long int return_value_gtk_container_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  if(!(bubble->icon == ((struct _GtkWidget *)NULL)))
  {
    if(!(bubble->active == 0))
    {
      return_value_gtk_container_get_type$3=gtk_container_get_type();
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)bubble->main_hbox, return_value_gtk_container_get_type$3);
      gtk_container_remove((struct _GtkContainer *)return_value_g_type_check_instance_cast$4, bubble->icon);
    }

    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)bubble->icon, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$5);
    bubble->icon = (struct _GtkWidget *)(void *)0;
  }

  bubble->bubble_header_text=g_strdup(bubble_header_text);
  bubble->bubble_body_text=g_strdup(bubble_body_text);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  void *return_value_g_object_ref$7;
  if(!(icon == ((struct _GtkWidget *)NULL)))
  {
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)icon, (unsigned long int)(20 << 2));
    return_value_g_object_ref$7=g_object_ref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6);
    bubble->icon = (struct _GtkWidget *)return_value_g_object_ref$7;
  }


__CPROVER_DUMP_L11:
  ;
}

// egg_notification_bubble_show
// file widgets/eggnotificationbubble.c line 511
void egg_notification_bubble_show(struct _EggNotificationBubble *bubble, unsigned int timeout)
{
  draw_bubble(bubble, timeout);
}

// egg_notification_bubble_unset_bubble_window
// file widgets/eggnotificationbubble.c line 139
static void egg_notification_bubble_unset_bubble_window(struct _EggNotificationBubble *bubble)
{
  if(!(bubble->bubble_window == ((struct _GtkWidget *)NULL)))
  {
    disconnect_bubble_window_display_closed(bubble);
    gtk_widget_destroy(bubble->bubble_window);
    bubble->bubble_window = (struct _GtkWidget *)(void *)0;
  }

}

// egg_tray_icon_cancel_message
// file widgets/eggtrayicon.c line 479
void egg_tray_icon_cancel_message(struct _EggTrayIcon *icon, unsigned int id)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)icon;
    unsigned long int __t;
    __t=egg_tray_icon_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_cancel_message", "EGG_IS_TRAY_ICON(icon)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  if(!(icon->notify->handle == ((struct _NotifyNotification *)NULL)))
    notify_notification_close(icon->notify->handle, (struct _GError **)(void *)0);


__CPROVER_DUMP_L8:
  ;
}

// egg_tray_icon_class_init
// file widgets/eggtrayicon.c line 130
static void egg_tray_icon_class_init(struct _EggTrayIconClass *klass)
{
  struct _GObjectClass *gobject_class = (struct _GObjectClass *)klass;
  struct _GtkWidgetClass *widget_class = (struct _GtkWidgetClass *)klass;
  void *return_value_g_type_class_peek_parent$1;
  return_value_g_type_class_peek_parent$1=g_type_class_peek_parent((void *)klass);
  parent_class$link1 = (struct _GtkPlugClass *)return_value_g_type_class_peek_parent$1;
  gobject_class->get_property = egg_tray_icon_get_property;
  widget_class->realize = egg_tray_icon_realize;
  widget_class->unrealize = egg_tray_icon_unrealize;
  char *return_value_dgettext$2;
  return_value_dgettext$2=dgettext("gnoemoe", "Orientation");
  char *return_value_dgettext$3;
  return_value_dgettext$3=dgettext("gnoemoe", "The orientation of the tray.");
  unsigned long int return_value_gtk_orientation_get_type$4;
  return_value_gtk_orientation_get_type$4=gtk_orientation_get_type();
  struct _GParamSpec *return_value_g_param_spec_enum$5;
  return_value_g_param_spec_enum$5=g_param_spec_enum("orientation", return_value_dgettext$2, return_value_dgettext$3, return_value_gtk_orientation_get_type$4, GTK_ORIENTATION_HORIZONTAL, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(gobject_class, (unsigned int)1, return_value_g_param_spec_enum$5);
  egg_tray_icon_signals[(signed long int)0]=g_signal_new("message-clicked", ((struct _GTypeClass *)gobject_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)944ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
}

// egg_tray_icon_get_orientation
// file widgets/eggtrayicon.c line 495
enum anonymous$9 egg_tray_icon_get_orientation(struct _EggTrayIcon *icon)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)icon;
    unsigned long int __t;
    __t=egg_tray_icon_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_get_orientation", "EGG_IS_TRAY_ICON(icon)");
      return (enum anonymous$9)GTK_ORIENTATION_HORIZONTAL;
    }

  }
  while((_Bool)0);
  return icon->orientation;
}

// egg_tray_icon_get_orientation_property
// file widgets/eggtrayicon.c line 182
static void egg_tray_icon_get_orientation_property(struct _EggTrayIcon *icon)
{
  struct _XDisplay *xdisplay;
  unsigned long int type;
  signed int format;
  /* tag-#anon#lUN[l*{U64}$U64$'prop'||l*{U8}$U8$'prop_ch'|] */
union anonymous$113
{
  // prop
  unsigned long int *prop;
  // prop_ch
  unsigned char *prop_ch;
};

/* */
  ;
  union anonymous$113 prop = { .prop=(unsigned long int *)(void *)0 };
  unsigned long int nitems;
  unsigned long int bytes_after;
  signed int error;
  signed int result;
  do
    if(icon->manager_window == 0ul)
      g_assertion_message_expr((char *)0, "widgets/eggtrayicon.c", 195, (const char *)"egg_tray_icon_get_orientation_property", "icon->manager_window != None");

  while((_Bool)0);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$1);
  struct _GdkDisplay *return_value_gtk_widget_get_display$3;
  return_value_gtk_widget_get_display$3=gtk_widget_get_display((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  xdisplay=gdk_x11_display_get_xdisplay(return_value_gtk_widget_get_display$3);
  gdk_error_trap_push();
  type = (unsigned long int)0L;
  result=XGetWindowProperty(xdisplay, icon->manager_window, icon->orientation_atom, (signed long int)0, 0x7fffffffffffffffL, 0, (unsigned long int)6, &type, &format, &nitems, &bytes_after, &prop.prop_ch);
  error=gdk_error_trap_pop();
  if(error == 0 && result == 0)
  {
    if(type == 6ul)
    {
      enum anonymous$9 orientation = (enum anonymous$9)(prop.prop[(signed long int)0] == (unsigned long int)0 ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
      if(!(icon->orientation == orientation))
      {
        icon->orientation = orientation;
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)icon, (unsigned long int)(20 << 2));
        g_object_notify((struct _GObject *)return_value_g_type_check_instance_cast$4, "orientation");
      }

    }

    if(!(prop.prop == ((unsigned long int *)NULL)))
      XFree((void *)prop.prop);

  }

}

// egg_tray_icon_get_property
// file widgets/eggtrayicon.c line 163
static void egg_tray_icon_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _EggTrayIcon *icon;
  unsigned long int return_value_egg_tray_icon_get_type$1;
  return_value_egg_tray_icon_get_type$1=egg_tray_icon_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_egg_tray_icon_get_type$1);
  icon = (struct _EggTrayIcon *)return_value_g_type_check_instance_cast$2;
  if(prop_id == 1u)
  {
    g_value_set_enum(value, (signed int)icon->orientation);
    goto __CPROVER_DUMP_L3;
  }

  do
  {
    struct _GObject *_glib__object = (struct _GObject *)object;
    struct _GParamSpec *_glib__pspec = (struct _GParamSpec *)pspec;
    unsigned int _glib__property_id = prop_id;
    const char *return_value_g_type_name$3;
    return_value_g_type_name$3=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__pspec)->g_class)->g_type);
    const char *return_value_g_type_name$4;
    return_value_g_type_name$4=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__object)->g_class)->g_type);
    g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_WARNING, "%s:%d: invalid %s id %u for \"%s\" of type '%s' in '%s'", (const void *)"widgets/eggtrayicon.c", 176, (const void *)"property", _glib__property_id, _glib__pspec->name, return_value_g_type_name$3, return_value_g_type_name$4);
  }
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
}

// egg_tray_icon_get_type
// file widgets/eggtrayicon.h line 76
unsigned long int egg_tray_icon_get_type(void)
{
  static unsigned long int our_type = (unsigned long int)0;
  if(our_type == 0ul)
  {
    unsigned long int return_value_gtk_plug_get_type$1;
    return_value_gtk_plug_get_type$1=gtk_plug_get_type();
    static const struct _GTypeInfo our_info = { .class_size=(unsigned short int)sizeof(struct _EggTrayIconClass) /*952ul*/ , .base_init=(void (*)(void *))(void *)0,
    .base_finalize=(void (*)(void *))(void *)0,
    .class_init=(void (*)(void *, void *))egg_tray_icon_class_init,
    .class_finalize=(void (*)(void *, void *))(void *)0,
    .class_data=(void *)0,
    .instance_size=(unsigned short int)sizeof(struct _EggTrayIcon) /*344ul*/ , .n_preallocs=(unsigned short int)0,
    .instance_init=(void (*)(struct _GTypeInstance *, void *))egg_tray_icon_init, .value_table=((const struct _GTypeValueTable *)NULL) };
    our_type=g_type_register_static(return_value_gtk_plug_get_type$1, "EggTrayIcon", &our_info, (enum anonymous)0);
  }

  return our_type;
}

// egg_tray_icon_have_manager
// file widgets/eggtrayicon.c line 389
signed int egg_tray_icon_have_manager(struct _EggTrayIcon *icon)
{
  struct _GtkPlug *plug;
  unsigned long int return_value_gtk_plug_get_type$1;
  return_value_gtk_plug_get_type$1=gtk_plug_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_plug_get_type$1);
  plug = (struct _GtkPlug *)return_value_g_type_check_instance_cast$2;
  if(!(plug->socket_window == ((struct _GdkDrawable *)NULL)))
    return (signed int)!(0 != 0);

  else
    return 0;
}

// egg_tray_icon_init
// file widgets/eggtrayicon.c line 119
static void egg_tray_icon_init(struct _EggTrayIcon *icon)
{
  icon->stamp = (unsigned int)1;
  icon->orientation = (enum anonymous$9)GTK_ORIENTATION_HORIZONTAL;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _Notify) /*8ul*/ );
  icon->notify = (struct _Notify *)return_value_g_malloc0_n$1;
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$2);
  gtk_widget_add_events((struct _GtkWidget *)return_value_g_type_check_instance_cast$3, GDK_PROPERTY_CHANGE_MASK);
}

// egg_tray_icon_manager_filter
// file widgets/eggtrayicon.c line 234
static enum anonymous$112 egg_tray_icon_manager_filter(void *xevent, union _GdkEvent *event, void *user_data)
{
  struct _EggTrayIcon *icon = (struct _EggTrayIcon *)user_data;
  union _XEvent *xev = (union _XEvent *)xevent;
  _Bool tmp_if_expr$1;
  if(xev->xany.type == 33)
    tmp_if_expr$1 = xev->xclient.message_type == icon->manager_atom ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (unsigned long int)(unsigned int)xev->xclient.data.l[(signed long int)1] == icon->selection_atom ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    egg_tray_icon_update_manager_window(icon, (signed int)!(0 != 0));

  else
    if(xev->xany.window == icon->manager_window)
    {
      if(xev->xany.type == 28)
      {
        if(xev->xproperty.atom == icon->orientation_atom)
          egg_tray_icon_get_orientation_property(icon);

      }

      if(xev->xany.type == 17)
        egg_tray_icon_manager_window_destroyed(icon);

    }

  return (enum anonymous$112)GDK_FILTER_CONTINUE;
}

// egg_tray_icon_manager_window_destroyed
// file widgets/eggtrayicon.c line 372
static void egg_tray_icon_manager_window_destroyed(struct _EggTrayIcon *icon)
{
  struct _GdkDrawable *gdkwin;
  do
    if(icon->manager_window == 0ul)
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_manager_window_destroyed", "icon->manager_window != None");
      goto __CPROVER_DUMP_L3;
    }

  while((_Bool)0);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$1);
  struct _GdkDisplay *return_value_gtk_widget_get_display$3;
  return_value_gtk_widget_get_display$3=gtk_widget_get_display((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  gdkwin=gdk_window_lookup_for_display(return_value_gtk_widget_get_display$3, (unsigned int)icon->manager_window);
  gdk_window_remove_filter(gdkwin, egg_tray_icon_manager_filter, (void *)icon);
  icon->manager_window = (unsigned long int)0L;
  egg_tray_icon_update_manager_window(icon, (signed int)!(0 != 0));

__CPROVER_DUMP_L3:
  ;
}

// egg_tray_icon_new
// file widgets/eggtrayicon.c line 452
struct _EggTrayIcon * egg_tray_icon_new(const char *name)
{
  unsigned long int return_value_egg_tray_icon_get_type$1;
  return_value_egg_tray_icon_get_type$1=egg_tray_icon_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_egg_tray_icon_get_type$1, "title", name, (void *)0);
  return (struct _EggTrayIcon *)return_value_g_object_new$2;
}

// egg_tray_icon_new_for_screen
// file widgets/eggtrayicon.c line 444
struct _EggTrayIcon * egg_tray_icon_new_for_screen(struct _GdkScreen *screen, const char *name)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)screen;
    unsigned long int __t;
    __t=gdk_screen_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_new_for_screen", "GDK_IS_SCREEN(screen)");
      return (struct _EggTrayIcon *)(void *)0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_egg_tray_icon_get_type$3;
  return_value_egg_tray_icon_get_type$3=egg_tray_icon_get_type();
  void *return_value_g_object_new$4;
  return_value_g_object_new$4=g_object_new(return_value_egg_tray_icon_get_type$3, "screen", screen, (const void *)"title", name, (void *)0);
  return (struct _EggTrayIcon *)return_value_g_object_new$4;
}

// egg_tray_icon_notify
// file widgets/eggtrayicon.c line 519
void egg_tray_icon_notify(struct _EggTrayIcon *icon, unsigned int timeout, const char *primary, struct _GtkWidget *msgicon, const char *secondary)
{
  struct _GtkRequisition size;
  struct _GdkPixbuf *pixbuf;
  signed int x;
  signed int y;
  signed int return_value_notify_is_initted$2;
  return_value_notify_is_initted$2=notify_is_initted();
  signed int return_value_notify_init$1;
  if(return_value_notify_is_initted$2 == 0)
  {
    return_value_notify_init$1=notify_init("gnoemoe");
    if(!(return_value_notify_init$1 == 0))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(icon->notify->handle == ((struct _NotifyNotification *)NULL)))
      notify_notification_close(icon->notify->handle, (struct _GError **)(void *)0);

    icon->notify->handle=notify_notification_new(primary, secondary, (const char *)(void *)0);
    notify_notification_set_timeout(icon->notify->handle, (signed int)timeout);
    if(!(msgicon == ((struct _GtkWidget *)NULL)))
    {
      unsigned long int return_value_gtk_image_get_type$3;
      return_value_gtk_image_get_type$3=gtk_image_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)msgicon, return_value_gtk_image_get_type$3);
      pixbuf=gtk_image_get_pixbuf((struct _GtkImage *)return_value_g_type_check_instance_cast$4);
    }

    else
    {
      struct _GtkIconTheme *theme;
      signed int width;
      signed int height;
      theme=gtk_icon_theme_get_default();
      gtk_icon_size_lookup((enum anonymous$21)GTK_ICON_SIZE_LARGE_TOOLBAR, &width, &height);
      pixbuf=gm_pixbuf_get_at_size("gnoemoe_logo.svg", width, height);
    }
    if(!(pixbuf == ((struct _GdkPixbuf *)NULL)))
      notify_notification_set_icon_from_pixbuf(icon->notify->handle, pixbuf);

    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$5);
    gdk_window_get_origin(((struct _GtkWidget *)return_value_g_type_check_instance_cast$6)->window, &x, &y);
    unsigned long int return_value_gtk_widget_get_type$7;
    return_value_gtk_widget_get_type$7=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$7);
    gtk_widget_size_request((struct _GtkWidget *)return_value_g_type_check_instance_cast$8, &size);
    x = x + size.width / 2;
    y = y + size.height;
    notify_notification_set_hint_int32(icon->notify->handle, "x", x);
    notify_notification_set_hint_int32(icon->notify->handle, "y", y);
    notify_notification_add_action(icon->notify->handle, "default", "default", egg_tray_icon_notify_default_cb, (void *)icon, (void (*)(void *))(void *)0);
    signed int return_value_notify_notification_show$9;
    return_value_notify_notification_show$9=notify_notification_show(icon->notify->handle, (struct _GError **)(void *)0);
    if(return_value_notify_notification_show$9 == 0)
      g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_WARNING, "failed to send notification (%s)", primary);

  }
}

// egg_tray_icon_notify_default_cb
// file widgets/eggtrayicon.c line 508
static void egg_tray_icon_notify_default_cb(struct _NotifyNotification *notify, char *action, void *userdata)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)userdata;
    unsigned long int __t;
    __t=egg_tray_icon_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_notify_default_cb", "EGG_IS_TRAY_ICON(userdata)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_egg_tray_icon_get_type$3;
  return_value_egg_tray_icon_get_type$3=egg_tray_icon_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_egg_tray_icon_get_type$3);
  g_signal_emit((void *)(struct _EggTrayIcon *)return_value_g_type_check_instance_cast$4, egg_tray_icon_signals[(signed long int)0], (unsigned int)0);

__CPROVER_DUMP_L8:
  ;
}

// egg_tray_icon_realize
// file widgets/eggtrayicon.c line 400
static void egg_tray_icon_realize(struct _GtkWidget *widget)
{
  struct _EggTrayIcon *icon;
  unsigned long int return_value_egg_tray_icon_get_type$1;
  return_value_egg_tray_icon_get_type$1=egg_tray_icon_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_egg_tray_icon_get_type$1);
  icon = (struct _EggTrayIcon *)return_value_g_type_check_instance_cast$2;
  struct _GdkScreen *screen;
  struct _GdkDisplay *display;
  struct _XDisplay *xdisplay;
  char buffer[256l];
  struct _GdkDrawable *root_window;
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)parent_class$link1, return_value_gtk_widget_get_type$5);
  unsigned long int return_value_gtk_widget_get_type$3;
  struct _GTypeClass *return_value_g_type_check_class_cast$4;
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->realize == ((void (*)(struct _GtkWidget *))NULL)))
  {
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class$link1, return_value_gtk_widget_get_type$3);
    ((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$4)->realize(widget);
  }

  screen=gtk_widget_get_screen(widget);
  display=gdk_screen_get_display(screen);
  xdisplay=gdk_x11_display_get_xdisplay(display);
  signed int return_value_gdk_screen_get_number$7;
  return_value_gdk_screen_get_number$7=gdk_screen_get_number(screen);
  g_snprintf(buffer, sizeof(char [256l]) /*256ul*/ , "_NET_SYSTEM_TRAY_S%d", return_value_gdk_screen_get_number$7);
  icon->selection_atom=XInternAtom(xdisplay, buffer, 0);
  icon->manager_atom=XInternAtom(xdisplay, "MANAGER", 0);
  icon->system_tray_opcode_atom=XInternAtom(xdisplay, "_NET_SYSTEM_TRAY_OPCODE", 0);
  icon->orientation_atom=XInternAtom(xdisplay, "_NET_SYSTEM_TRAY_ORIENTATION", 0);
  egg_tray_icon_update_manager_window(icon, 0);
  egg_tray_icon_send_dock_request(icon);
  root_window=gdk_screen_get_root_window(screen);
  gdk_window_add_filter(root_window, egg_tray_icon_manager_filter, (void *)icon);
}

// egg_tray_icon_send_dock_request
// file widgets/eggtrayicon.c line 323
static void egg_tray_icon_send_dock_request(struct _EggTrayIcon *icon)
{
  unsigned long int return_value_gtk_plug_get_type$1;
  return_value_gtk_plug_get_type$1=gtk_plug_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_plug_get_type$1);
  unsigned int return_value_gtk_plug_get_id$3;
  return_value_gtk_plug_get_id$3=gtk_plug_get_id((struct _GtkPlug *)return_value_g_type_check_instance_cast$2);
  egg_tray_icon_send_manager_message(icon, (signed long int)0, icon->manager_window, (signed long int)return_value_gtk_plug_get_id$3, (signed long int)0, (signed long int)0);
}

// egg_tray_icon_send_manager_message
// file widgets/eggtrayicon.c line 293
static void egg_tray_icon_send_manager_message(struct _EggTrayIcon *icon, signed long int message, unsigned long int window, signed long int data1, signed long int data2, signed long int data3)
{
  struct anonymous$141 ev;
  struct _XDisplay *display;
  ev.type = 33;
  ev.window = window;
  ev.message_type = icon->system_tray_opcode_atom;
  ev.format = 32;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$1);
  unsigned int return_value_gdk_x11_get_server_time$3;
  return_value_gdk_x11_get_server_time$3=gdk_x11_get_server_time(((struct _GtkWidget *)return_value_g_type_check_instance_cast$2)->window);
  ev.data.l[(signed long int)0] = (signed long int)return_value_gdk_x11_get_server_time$3;
  ev.data.l[(signed long int)1] = message;
  ev.data.l[(signed long int)2] = data1;
  ev.data.l[(signed long int)3] = data2;
  ev.data.l[(signed long int)4] = data3;
  unsigned long int return_value_gtk_widget_get_type$4;
  return_value_gtk_widget_get_type$4=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$4);
  struct _GdkDisplay *return_value_gtk_widget_get_display$6;
  return_value_gtk_widget_get_display$6=gtk_widget_get_display((struct _GtkWidget *)return_value_g_type_check_instance_cast$5);
  display=gdk_x11_display_get_xdisplay(return_value_gtk_widget_get_display$6);
  gdk_error_trap_push();
  XSendEvent(display, icon->manager_window, 0, 0L, (union _XEvent *)&ev);
  XSync(display, 0);
  gdk_error_trap_pop();
}

// egg_tray_icon_send_message
// file widgets/eggtrayicon.h line 83
unsigned int egg_tray_icon_send_message(struct _EggTrayIcon *icon, signed int timeout, const char *message, signed int len)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)icon;
    unsigned long int __t;
    __t=egg_tray_icon_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_send_message", "EGG_IS_TRAY_ICON(icon)");
      return (unsigned int)0;
    }

  }
  while((_Bool)0);
  do
    if(!(timeout >= 0))
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_send_message", "timeout >= 0");
      return (unsigned int)0;
    }

  while((_Bool)0);
  do
    if(message == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"egg_tray_icon_send_message", "message != NULL");
      return (unsigned int)0;
    }

  while((_Bool)0);
  char *return_value_dgettext$3;
  return_value_dgettext$3=dgettext("gnoemoe", "Notification");
  egg_tray_icon_notify(icon, (unsigned int)timeout, return_value_dgettext$3, (struct _GtkWidget *)(void *)0, message);
  return (unsigned int)1;
}

// egg_tray_icon_unrealize
// file widgets/eggtrayicon.c line 261
static void egg_tray_icon_unrealize(struct _GtkWidget *widget)
{
  struct _EggTrayIcon *icon;
  unsigned long int return_value_egg_tray_icon_get_type$1;
  return_value_egg_tray_icon_get_type$1=egg_tray_icon_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_egg_tray_icon_get_type$1);
  icon = (struct _EggTrayIcon *)return_value_g_type_check_instance_cast$2;
  struct _GdkDrawable *root_window;
  if(!(icon->manager_window == 0ul))
  {
    struct _GdkDrawable *gdkwin;
    struct _GdkDisplay *return_value_gtk_widget_get_display$3;
    return_value_gtk_widget_get_display$3=gtk_widget_get_display(widget);
    gdkwin=gdk_window_lookup_for_display(return_value_gtk_widget_get_display$3, (unsigned int)icon->manager_window);
    gdk_window_remove_filter(gdkwin, egg_tray_icon_manager_filter, (void *)icon);
  }

  struct _GdkScreen *return_value_gtk_widget_get_screen$4;
  return_value_gtk_widget_get_screen$4=gtk_widget_get_screen(widget);
  root_window=gdk_screen_get_root_window(return_value_gtk_widget_get_screen$4);
  gdk_window_remove_filter(root_window, egg_tray_icon_manager_filter, (void *)icon);
  unsigned long int return_value_gtk_widget_get_type$7;
  return_value_gtk_widget_get_type$7=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$8;
  return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)parent_class$link1, return_value_gtk_widget_get_type$7);
  unsigned long int return_value_gtk_widget_get_type$5;
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$8)->unrealize == ((void (*)(struct _GtkWidget *))NULL)))
  {
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)parent_class$link1, return_value_gtk_widget_get_type$5);
    ((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->unrealize(widget);
  }

  unsigned long int return_value_egg_tray_icon_get_type$11;
  return_value_egg_tray_icon_get_type$11=egg_tray_icon_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_egg_tray_icon_get_type$11);
  if(!(((struct _EggTrayIcon *)return_value_g_type_check_instance_cast$12)->notify->handle == ((struct _NotifyNotification *)NULL)))
  {
    unsigned long int return_value_egg_tray_icon_get_type$9;
    return_value_egg_tray_icon_get_type$9=egg_tray_icon_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_egg_tray_icon_get_type$9);
    notify_notification_close(((struct _EggTrayIcon *)return_value_g_type_check_instance_cast$10)->notify->handle, (struct _GError **)(void *)0);
  }

  unsigned long int return_value_egg_tray_icon_get_type$13;
  return_value_egg_tray_icon_get_type$13=egg_tray_icon_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_egg_tray_icon_get_type$13);
  g_free((void *)((struct _EggTrayIcon *)return_value_g_type_check_instance_cast$14)->notify);
}

// egg_tray_icon_update_manager_window
// file widgets/eggtrayicon.c line 333
static void egg_tray_icon_update_manager_window(struct _EggTrayIcon *icon, signed int dock_if_realized)
{
  struct _XDisplay *xdisplay;
  unsigned long int return_value_gtk_object_get_type$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  if(icon->manager_window == 0ul)
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$1);
    struct _GdkDisplay *return_value_gtk_widget_get_display$3;
    return_value_gtk_widget_get_display$3=gtk_widget_get_display((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    xdisplay=gdk_x11_display_get_xdisplay(return_value_gtk_widget_get_display$3);
    XGrabServer(xdisplay);
    icon->manager_window=XGetSelectionOwner(xdisplay, icon->selection_atom);
    if(!(icon->manager_window == 0ul))
      XSelectInput(xdisplay, icon->manager_window, 1L << 17 | 1L << 22);

    XUngrabServer(xdisplay);
    XFlush(xdisplay);
    if(!(icon->manager_window == 0ul))
    {
      struct _GdkDrawable *gdkwin;
      unsigned long int return_value_gtk_widget_get_type$4;
      return_value_gtk_widget_get_type$4=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_widget_get_type$4);
      struct _GdkDisplay *return_value_gtk_widget_get_display$6;
      return_value_gtk_widget_get_display$6=gtk_widget_get_display((struct _GtkWidget *)return_value_g_type_check_instance_cast$5);
      gdkwin=gdk_window_lookup_for_display(return_value_gtk_widget_get_display$6, (unsigned int)icon->manager_window);
      gdk_window_add_filter(gdkwin, egg_tray_icon_manager_filter, (void *)icon);
      if(!(dock_if_realized == 0))
      {
        return_value_gtk_object_get_type$7=gtk_object_get_type();
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)icon, return_value_gtk_object_get_type$7);
        if(!((64u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$8)->flags) == 0u))
          egg_tray_icon_send_dock_request(icon);

      }

      egg_tray_icon_get_orientation_property(icon);
    }

  }

}

// find_terminal
// file widgets/gm-external-view.c line 114
static struct anonymous$103 * find_terminal(const char *term)
{
  char *prog;
  char *basename;
  struct anonymous$103 *terminal;
  prog=resolve_file(term);
  signed int return_value_strcmp$1;
  if(!(prog == ((char *)NULL)))
  {
    basename=g_path_get_basename(prog);
    g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_MESSAGE, "%s", basename);
    terminal = terminals;
    for( ; !(terminal->terminal == ((const char *)NULL)); terminal = terminal + 1l)
    {
      return_value_strcmp$1=strcmp(terminal->terminal, basename);
      if(return_value_strcmp$1 == 0)
        break;

    }
    g_free((void *)basename);
    g_free((void *)prog);
    if(terminal->terminal == ((const char *)NULL))
      goto __CPROVER_DUMP_L3;

    return terminal;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    return (struct anonymous$103 *)(void *)0;
  }
}

// flush_history_cb
// file gm-world.c line 449
static signed int flush_history_cb(void *data)
{
  struct _GmWorld *world;
  unsigned long int return_value_gm_world_get_type$1;
  return_value_gm_world_get_type$1=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_gm_world_get_type$1);
  world = (struct _GmWorld *)return_value_g_type_check_instance_cast$2;
  gm_world_save_input_history(world);
  world->priv->flush_history_id = (unsigned int)0;
  return 0;
}

// force_window
// file widgets/eggnotificationbubble.c line 171
static void force_window(struct _EggNotificationBubble *bubble)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)bubble;
    unsigned long int __t;
    __t=egg_notification_bubble_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"force_window", "EGG_IS_NOTIFICATION_BUBBLE (bubble)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  if(bubble->bubble_window == ((struct _GtkWidget *)NULL))
  {
    struct _GtkWidget *vbox;
    bubble->bubble_window=gtk_window_new((enum anonymous$149)GTK_WINDOW_POPUP);
    gtk_widget_add_events(bubble->bubble_window, GDK_BUTTON_PRESS_MASK);
    gtk_widget_set_app_paintable(bubble->bubble_window, (signed int)!(0 != 0));
    unsigned long int return_value_gtk_window_get_type$3;
    return_value_gtk_window_get_type$3=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_window, return_value_gtk_window_get_type$3);
    gtk_window_set_resizable((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, 0);
    gtk_widget_set_name(bubble->bubble_window, "gtk-tooltips");
    unsigned long int return_value_gtk_container_get_type$5;
    return_value_gtk_container_get_type$5=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_window, return_value_gtk_container_get_type$5);
    gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$6, (unsigned int)(15 + 5));
    g_signal_connect_data((void *)bubble->bubble_window, "expose_event", (void (*)(void))egg_notification_bubble_paint_window, (void *)bubble, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)G_CONNECT_SWAPPED);
    bubble->bubble_header_label=gtk_label_new((const char *)(void *)0);
    bubble->bubble_body_label=gtk_label_new((const char *)(void *)0);
    unsigned long int return_value_gtk_label_get_type$7;
    return_value_gtk_label_get_type$7=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_header_label, return_value_gtk_label_get_type$7);
    gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast$8, (signed int)!(0 != 0));
    unsigned long int return_value_gtk_label_get_type$9;
    return_value_gtk_label_get_type$9=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_body_label, return_value_gtk_label_get_type$9);
    gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast$10, (signed int)!(0 != 0));
    unsigned long int return_value_gtk_misc_get_type$11;
    return_value_gtk_misc_get_type$11=gtk_misc_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_header_label, return_value_gtk_misc_get_type$11);
    gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$12, (float)0.5, (float)0.5);
    unsigned long int return_value_gtk_misc_get_type$13;
    return_value_gtk_misc_get_type$13=gtk_misc_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_body_label, return_value_gtk_misc_get_type$13);
    gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$14, (float)0.5, (float)0.5);
    gtk_widget_show(bubble->bubble_header_label);
    gtk_widget_show(bubble->bubble_body_label);
    bubble->main_hbox=gtk_hbox_new(0, 10);
    unsigned long int return_value_gtk_container_get_type$15;
    return_value_gtk_container_get_type$15=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)bubble->main_hbox, return_value_gtk_container_get_type$15);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$16, bubble->bubble_body_label);
    vbox=gtk_vbox_new(0, 5);
    unsigned long int return_value_gtk_container_get_type$17;
    return_value_gtk_container_get_type$17=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type$17);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$18, bubble->bubble_header_label);
    unsigned long int return_value_gtk_container_get_type$19;
    return_value_gtk_container_get_type$19=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type$19);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$20, bubble->main_hbox);
    unsigned long int return_value_gtk_container_get_type$21;
    return_value_gtk_container_get_type$21=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
    return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)bubble->bubble_window, return_value_gtk_container_get_type$21);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$22, vbox);
    g_signal_connect_data((void *)bubble->bubble_window, "destroy", (void (*)(void))gtk_widget_destroyed, (void *)&bubble->bubble_window, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)bubble->bubble_window, "event-after", (void (*)(void))egg_notification_bubble_event_handler, (void *)bubble, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)G_CONNECT_AFTER);
  }


__CPROVER_DUMP_L8:
  ;
}

// forward_chars_with_skipping
// file widgets/gm-searchable.c line 201
static void forward_chars_with_skipping(struct _GtkTextIter *iter, signed int count, signed int skip_decomp)
{
  signed int i;
  do
    if(!(count >= 0))
    {
      g_return_if_fail_warning((char *)0, (const char *)"forward_chars_with_skipping", "count >= 0");
      goto __CPROVER_DUMP_L10;
    }

  while((_Bool)0);
  i = count;
  while(i >= 1)
  {
    signed int ignored = 0;
    signed int return_value_gtk_text_iter_is_end$1;
    return_value_gtk_text_iter_is_end$1=gtk_text_iter_is_end(iter);
    if(!(return_value_gtk_text_iter_is_end$1 == 0))
      goto __CPROVER_DUMP_L10;

    unsigned int return_value_gtk_text_iter_get_char$2;
    return_value_gtk_text_iter_get_char$2=gtk_text_iter_get_char(iter);
    if(return_value_gtk_text_iter_get_char$2 == 65532u)
      ignored = (signed int)!(0 != 0);

    if(ignored == 0 && !(skip_decomp == 0))
    {
      char *normal;
      char buffer[6l];
      signed int buffer_len;
      unsigned int return_value_gtk_text_iter_get_char$3;
      return_value_gtk_text_iter_get_char$3=gtk_text_iter_get_char(iter);
      buffer_len=g_unichar_to_utf8(return_value_gtk_text_iter_get_char$3, buffer);
      normal=g_utf8_normalize(buffer, (signed long int)buffer_len, (enum anonymous$98)G_NORMALIZE_NFD);
      signed long int return_value_g_utf8_strlen$4;
      return_value_g_utf8_strlen$4=g_utf8_strlen(normal, (signed long int)-1);
      i = i - (signed int)(return_value_g_utf8_strlen$4 - (signed long int)1);
      g_free((void *)normal);
    }

    gtk_text_iter_forward_char(iter);
    if(ignored == 0)
      i = i - 1;

  }

__CPROVER_DUMP_L10:
  ;
}

// g_string_append_c_inline
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline(struct _GString *gstring, char c)
{
  unsigned long int tmp_post$1;
  if(!(1ul + gstring->len >= gstring->allocated_len))
  {
    tmp_post$1 = gstring->len;
    gstring->len = gstring->len + 1ul;
    gstring->str[(signed long int)tmp_post$1] = c;
    gstring->str[(signed long int)gstring->len] = (char)0;
  }

  else
    g_string_insert_c(gstring, (signed long int)-1, c);
  return gstring;
}

// g_string_append_c_inline$link1
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link1(struct _GString *gstring$link1, char c$link1)
{
  unsigned long int tmp_post$1$link1;
  if(!(1ul + gstring$link1->len >= gstring$link1->allocated_len))
  {
    tmp_post$1$link1 = gstring$link1->len;
    gstring$link1->len = gstring$link1->len + 1ul;
    gstring$link1->str[(signed long int)tmp_post$1$link1] = c$link1;
    gstring$link1->str[(signed long int)gstring$link1->len] = (char)0;
  }

  else
    g_string_insert_c(gstring$link1, (signed long int)-1, c$link1);
  return gstring$link1;
}

// g_string_append_c_inline$link2
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link2(struct _GString *gstring$link2, char c$link2)
{
  unsigned long int tmp_post$1$link2;
  if(!(1ul + gstring$link2->len >= gstring$link2->allocated_len))
  {
    tmp_post$1$link2 = gstring$link2->len;
    gstring$link2->len = gstring$link2->len + 1ul;
    gstring$link2->str[(signed long int)tmp_post$1$link2] = c$link2;
    gstring$link2->str[(signed long int)gstring$link2->len] = (char)0;
  }

  else
    g_string_insert_c(gstring$link2, (signed long int)-1, c$link2);
  return gstring$link2;
}

// g_string_append_c_inline$link3
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link3(struct _GString *gstring$link3, char c$link3)
{
  unsigned long int tmp_post$1$link3;
  if(!(1ul + gstring$link3->len >= gstring$link3->allocated_len))
  {
    tmp_post$1$link3 = gstring$link3->len;
    gstring$link3->len = gstring$link3->len + 1ul;
    gstring$link3->str[(signed long int)tmp_post$1$link3] = c$link3;
    gstring$link3->str[(signed long int)gstring$link3->len] = (char)0;
  }

  else
    g_string_insert_c(gstring$link3, (signed long int)-1, c$link3);
  return gstring$link3;
}

// g_string_append_c_inline$link4
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link4(struct _GString *gstring$link4, char c$link4)
{
  unsigned long int tmp_post$1$link4;
  if(!(1ul + gstring$link4->len >= gstring$link4->allocated_len))
  {
    tmp_post$1$link4 = gstring$link4->len;
    gstring$link4->len = gstring$link4->len + 1ul;
    gstring$link4->str[(signed long int)tmp_post$1$link4] = c$link4;
    gstring$link4->str[(signed long int)gstring$link4->len] = (char)0;
  }

  else
    g_string_insert_c(gstring$link4, (signed long int)-1, c$link4);
  return gstring$link4;
}

// g_string_append_c_inline$link5
// file /usr/include/glib-2.0/glib/gstring.h line 161
static inline struct _GString * g_string_append_c_inline$link5(struct _GString *gstring$link5, char c$link5)
{
  unsigned long int tmp_post$1$link5;
  if(!(1ul + gstring$link5->len >= gstring$link5->allocated_len))
  {
    tmp_post$1$link5 = gstring$link5->len;
    gstring$link5->len = gstring$link5->len + 1ul;
    gstring$link5->str[(signed long int)tmp_post$1$link5] = c$link5;
    gstring$link5->str[(signed long int)gstring$link5->len] = (char)0;
  }

  else
    g_string_insert_c(gstring$link5, (signed long int)-1, c$link5);
  return gstring$link5;
}

// g_utf8_caselessnmatch
// file widgets/gm-searchable.c line 162
static signed int g_utf8_caselessnmatch(const char *s1, const char *s2, signed long int n1, signed long int n2)
{
  char *casefold;
  char *normalized_s1;
  char *normalized_s2;
  signed int len_s1;
  signed int len_s2;
  signed int ret = 0;
  do
    if(s1 == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_caselessnmatch", "s1 != NULL");
      return 0;
    }

  while((_Bool)0);
  do
    if(s2 == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_caselessnmatch", "s2 != NULL");
      return 0;
    }

  while((_Bool)0);
  do
    if(!(n1 >= 1l))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_caselessnmatch", "n1 > 0");
      return 0;
    }

  while((_Bool)0);
  do
    if(!(n2 >= 1l))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_caselessnmatch", "n2 > 0");
      return 0;
    }

  while((_Bool)0);
  casefold=g_utf8_casefold(s1, n1);
  normalized_s1=g_utf8_normalize(casefold, (signed long int)-1, (enum anonymous$98)G_NORMALIZE_NFD);
  g_free((void *)casefold);
  casefold=g_utf8_casefold(s2, n2);
  normalized_s2=g_utf8_normalize(casefold, (signed long int)-1, (enum anonymous$98)G_NORMALIZE_NFD);
  g_free((void *)casefold);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(normalized_s1);
  len_s1 = (signed int)return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(normalized_s2);
  len_s2 = (signed int)return_value_strlen$2;
  signed int return_value_strncmp$3;
  if(len_s1 >= len_s2)
  {
    return_value_strncmp$3=strncmp(normalized_s1, normalized_s2, (unsigned long int)len_s2);
    ret = (signed int)(return_value_strncmp$3 == 0);
  }


finally_2:
  ;
  g_free((void *)normalized_s1);
  g_free((void *)normalized_s2);
  return ret;
}

// g_utf8_strcasestr
// file widgets/gm-searchable.c line 52
static const char * g_utf8_strcasestr(const char *haystack, const char *needle)
{
  unsigned long int needle_len;
  unsigned long int haystack_len;
  const char *ret = (const char *)(void *)0;
  char *p;
  char *casefold;
  char *caseless_haystack;
  signed int i;
  do
    if(haystack == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_strcasestr", "haystack != NULL");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  do
    if(needle == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_strcasestr", "needle != NULL");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  casefold=g_utf8_casefold(haystack, (signed long int)-1);
  caseless_haystack=g_utf8_normalize(casefold, (signed long int)-1, (enum anonymous$98)G_NORMALIZE_NFD);
  g_free((void *)casefold);
  signed long int return_value_g_utf8_strlen$1;
  return_value_g_utf8_strlen$1=g_utf8_strlen(needle, (signed long int)-1);
  needle_len = (unsigned long int)return_value_g_utf8_strlen$1;
  signed long int return_value_g_utf8_strlen$2;
  return_value_g_utf8_strlen$2=g_utf8_strlen(caseless_haystack, (signed long int)-1);
  haystack_len = (unsigned long int)return_value_g_utf8_strlen$2;
  if(needle_len == 0ul)
    ret = (char *)haystack;

  else
    if(!(haystack_len >= needle_len))
      ret = (const char *)(void *)0;

    else
    {
      p = (char *)caseless_haystack;
      needle_len=strlen(needle);
      i = 0;
      while(!(*p == 0))
      {
        signed int return_value_strncmp$3;
        return_value_strncmp$3=strncmp(p, needle, needle_len);
        if(return_value_strncmp$3 == 0)
        {
          ret=pointer_from_offset_skipping_decomp(haystack, i);
          break;
        }

        p = (char *)(p + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)p)]);
        i = i + 1;
      }
    }

finally_1:
  ;
  g_free((void *)caseless_haystack);
  return ret;
}

// g_utf8_strrcasestr
// file widgets/gm-searchable.c line 107
static const char * g_utf8_strrcasestr(const char *haystack, const char *needle)
{
  unsigned long int needle_len;
  unsigned long int haystack_len;
  const char *ret = (const char *)(void *)0;
  char *p;
  char *casefold;
  char *caseless_haystack;
  signed int i;
  do
    if(haystack == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_strrcasestr", "haystack != NULL");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  do
    if(needle == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"g_utf8_strrcasestr", "needle != NULL");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  casefold=g_utf8_casefold(haystack, (signed long int)-1);
  caseless_haystack=g_utf8_normalize(casefold, (signed long int)-1, (enum anonymous$98)G_NORMALIZE_NFD);
  g_free((void *)casefold);
  signed long int return_value_g_utf8_strlen$1;
  return_value_g_utf8_strlen$1=g_utf8_strlen(needle, (signed long int)-1);
  needle_len = (unsigned long int)return_value_g_utf8_strlen$1;
  signed long int return_value_g_utf8_strlen$2;
  return_value_g_utf8_strlen$2=g_utf8_strlen(caseless_haystack, (signed long int)-1);
  haystack_len = (unsigned long int)return_value_g_utf8_strlen$2;
  if(needle_len == 0ul)
    ret = (char *)haystack;

  else
    if(!(haystack_len >= needle_len))
      ret = (const char *)(void *)0;

    else
    {
      i = (signed int)(haystack_len - needle_len);
      p=g_utf8_offset_to_pointer(caseless_haystack, (signed long int)i);
      needle_len=strlen(needle);
      while(p >= caseless_haystack)
      {
        signed int return_value_strncmp$3;
        return_value_strncmp$3=strncmp(p, needle, needle_len);
        if(return_value_strncmp$3 == 0)
        {
          ret=pointer_from_offset_skipping_decomp(haystack, i);
          break;
        }

        p=g_utf8_prev_char(p);
        i = i - 1;
      }
    }

finally_1:
  ;
  g_free((void *)caseless_haystack);
  return ret;
}

// g_utf8_toint
// file widgets/gm-world-text-view.c line 701
static signed int g_utf8_toint(char *str, unsigned int *result)
{
  unsigned int c;
  *result = (unsigned int)0;
  do
  {
    c=g_utf8_get_char(str);
    if(c == 0u)
      break;

    signed int return_value_g_unichar_isdigit$2;
    return_value_g_unichar_isdigit$2=g_unichar_isdigit(c);
    if(!(return_value_g_unichar_isdigit$2 == 0))
    {
      signed int return_value_g_unichar_digit_value$1;
      return_value_g_unichar_digit_value$1=g_unichar_digit_value(c);
      *result = *result * (unsigned int)10 + (unsigned int)return_value_g_unichar_digit_value$1;
    }

    else
      return 0;
    str = (char *)(str + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)str)]);
  }
  while((_Bool)1);
  return (signed int)!(0 != 0);
}

// gm_ansi_strip
// file gm-support.h line 117
char * gm_ansi_strip(char *s)
{
  char *ptr;
  char *fptr;
  unsigned int c;
  ptr = s;
  fptr = s;
  while(!((signed int)*ptr == 0))
  {
    c=g_utf8_get_char(ptr);
    if(c == 27u)
      gm_string_skip_till((const char **)&ptr, "m");

    else
      if(!(c == 7u))
      {
        signed int return_value_g_unichar_to_utf8$1;
        return_value_g_unichar_to_utf8$1=g_unichar_to_utf8(c, fptr);
        fptr = fptr + (signed long int)return_value_g_unichar_to_utf8$1;
      }

    if(!((signed int)*ptr == 0))
      ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);

  }
  *fptr = (char)0;
  return s;
}

// gm_app_add_world
// file ./gm-app.h line 63
void gm_app_add_world(struct _GmApp *app, struct _GmWorld *world)
{
  app->priv->worlds=g_list_insert_sorted(app->priv->worlds, (void *)world, (signed int (*)(const void *, const void *))gm_app_compare_worlds);
  g_signal_emit((void *)app, app_signals[(signed long int)0], (unsigned int)0, world);
}

// gm_app_class_init
// file gm-app.c line 144
static void gm_app_class_init(struct _GmAppClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_app_finalize;
  object_class->get_property = gm_app_get_property;
  struct _GParamSpec *return_value_g_param_spec_string$2;
  return_value_g_param_spec_string$2=g_param_spec_string("path", "PATH", "The app path", (const char *)(void *)0, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)2, return_value_g_param_spec_string$2);
  struct _GParamSpec *return_value_g_param_spec_string$3;
  return_value_g_param_spec_string$3=g_param_spec_string("worlds_path", "WORLDS_PATH", "The worlds path", (const char *)(void *)0, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)1, return_value_g_param_spec_string$3);
  unsigned long int return_value_gm_options_get_type$4;
  return_value_gm_options_get_type$4=gm_options_get_type();
  struct _GParamSpec *return_value_g_param_spec_object$5;
  return_value_g_param_spec_object$5=g_param_spec_object("options", "OPTIONS", "Options object", return_value_gm_options_get_type$4, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)3, return_value_g_param_spec_object$5);
  unsigned long int return_value_gm_color_table_get_type$6;
  return_value_gm_color_table_get_type$6=gm_color_table_get_type();
  struct _GParamSpec *return_value_g_param_spec_object$7;
  return_value_g_param_spec_object$7=g_param_spec_object("color_table", "COLOR_TABLE", "ColorTable object", return_value_gm_color_table_get_type$6, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)5, return_value_g_param_spec_object$7);
  struct _GParamSpec *return_value_g_param_spec_pointer$8;
  return_value_g_param_spec_pointer$8=g_param_spec_pointer("worlds", "WORLDS", "Worlds list", (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)4, return_value_g_param_spec_pointer$8);
  app_signals[(signed long int)0]=g_signal_new("world_added", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)136ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__POINTER, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(17 << 2));
  app_signals[(signed long int)1]=g_signal_new("world_removed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)144ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__POINTER, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(17 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmAppPrivate) /*64ul*/ );
}

// gm_app_class_intern_init
// file gm-app.c line 88
static void gm_app_class_intern_init(void *klass)
{
  gm_app_parent_class=g_type_class_peek_parent(klass);
  if(!(GmApp_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmApp_private_offset);

  gm_app_class_init((struct _GmAppClass *)klass);
}

// gm_app_color_table
// file ./gm-app.h line 70
struct _GmColorTable * gm_app_color_table(struct _GmApp *app)
{
  return app->priv->color_table;
}

// gm_app_compare_worlds
// file gm-app.c line 548
signed int gm_app_compare_worlds(struct _GmWorld *world1, struct _GmWorld *world2)
{
  const char *return_value_gm_world_name$1;
  return_value_gm_world_name$1=gm_world_name(world1);
  const char *return_value_gm_world_name$2;
  return_value_gm_world_name$2=gm_world_name(world2);
  signed int return_value_strcasecmp$3;
  return_value_strcasecmp$3=strcasecmp(return_value_gm_world_name$1, return_value_gm_world_name$2);
  return return_value_strcasecmp$3;
}

// gm_app_convert_old_color_configuration
// file gm-app.c line 354
static void gm_app_convert_old_color_configuration(struct _GmApp *app, const char *colors_path)
{
  unsigned int i;
  const char *color;
  const char *value;
  struct _IO_FILE *f;
  struct _GmColorTable *table;
  signed int is_scheme = (signed int)!(0 != 0);
  f=fopen(colors_path, "w");
  _Bool tmp_if_expr$3;
  const char *return_value_gm_color_table_get_hex$1;
  signed int return_value_strcmp$2;
  if(f == ((struct _IO_FILE *)NULL))
    gm_debug_msg(DEBUG_DEFAULT, "Can't open colors file (%s) for writing!", colors_path);

  else
  {
    table=gm_color_table_new();
    gm_color_table_load_scheme(table, (enum _GmColorTableScheme)SCHEME_WHITE_ON_BLACK);
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 27ul); i = i + 1u)
    {
      color = ansi_colors$link1[(signed long int)i].name;
      value=gm_options_get(app->priv->options, color);
      if(!(value == ((const char *)NULL)))
      {
        if(!(is_scheme == 0))
        {
          return_value_gm_color_table_get_hex$1=gm_color_table_get_hex(table, color);
          return_value_strcmp$2=strcmp(value, return_value_gm_color_table_get_hex$1);
          tmp_if_expr$3 = return_value_strcmp$2 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        is_scheme = (signed int)tmp_if_expr$3;
        fprintf(f, "%s=%s\n", color, value);
        gm_options_remove(app->priv->options, color);
      }

    }
    value=gm_options_get(app->priv->options, "font-family");
    if(!(value == ((const char *)NULL)))
      fprintf(f, "font_family=%s\n", value);

    gm_options_remove(app->priv->options, "font-family");
    gm_options_remove(app->priv->options, "bold-colors");
    gm_options_remove(app->priv->options, "background_transparancy");
    gm_options_remove(app->priv->options, "background_transparent");
    if(!(is_scheme == 0))
      fputs("color_scheme=default\n", f);

    else
      fputs("color_scheme=user\n", f);
    fclose(f);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)table, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$4);
  }
}

// gm_app_create_settings
// file gm-app.c line 271
static void gm_app_create_settings(struct _GmApp *app)
{
  app->priv->options=gm_options_new();
  gm_options_set(app->priv->options, "editor_alternative", "0");
  gm_options_set(app->priv->options, "editor_embed", "0");
  gm_options_set(app->priv->options, "editor_needs_terminal", "0");
  gm_options_set(app->priv->options, "worlds_saved_state", "");
  gm_options_set(app->priv->options, "search_direction_world", "1");
  gm_options_set(app->priv->options, "search_direction", "0");
  gm_options_set(app->priv->options, "search_sensitive", "0");
  gm_options_set(app->priv->options, "logging_enable", "1");
  gm_options_set(app->priv->options, "logging_in", "1");
  gm_options_set(app->priv->options, "logging_out", "1");
  gm_options_set(app->priv->options, "logging_status", "1");
  gm_options_set(app->priv->options, "logging_mcp_in", "0");
  gm_options_set(app->priv->options, "logging_mcp_out", "0");
  gm_options_set(app->priv->options, "logging_mcp_status", "0");
  gm_options_set(app->priv->options, "logging_add_timestamp", "1");
  gm_options_set(app->priv->options, "logging_add_log_type", "1");
  gm_options_set(app->priv->options, "logging_filter_in", "1");
  gm_options_set(app->priv->options, "logging_filter_out", "1");
  gm_options_set(app->priv->options, "logging_filter_status", "1");
  gm_options_set(app->priv->options, "logging_filter_mcp_in", "0");
  gm_options_set(app->priv->options, "logging_filter_mcp_out", "0");
  gm_options_set(app->priv->options, "logging_filter_mcp_status", "0");
  gm_options_set(app->priv->options, "userlist_sort_type", "0");
  gm_options_set(app->priv->options, "userlist_show_object_number", "0");
  gm_options_set(app->priv->options, "userlist_show_status", "1");
  gm_options_set(app->priv->options, "userlist_use_state_icon", "1");
  gm_options_set(app->priv->options, "show_toolbar", "1");
  gm_options_set(app->priv->options, "show_userlist", "1");
}

// gm_app_destroy_worlds
// file gm-app.c line 209
static void gm_app_destroy_worlds(struct _GmApp *app)
{
  struct _GList *item = app->priv->worlds;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    unsigned long int return_value_gm_world_get_type$1;
    return_value_gm_world_get_type$1=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gm_world_get_type$1);
    g_object_unref((void *)(struct _GmWorld *)return_value_g_type_check_instance_cast$2);
  }
  g_list_free(app->priv->worlds);
  app->priv->worlds = (struct _GList *)(void *)0;
}

// gm_app_finalize
// file gm-app.c line 115
static void gm_app_finalize(struct _GObject *object)
{
  struct _GmApp *app;
  unsigned long int return_value_gm_app_get_type$1;
  return_value_gm_app_get_type$1=gm_app_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_app_get_type$1);
  app = (struct _GmApp *)return_value_g_type_check_instance_cast$2;
  signed int tmp_statement_expression$5;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)app->priv->view;
  unsigned long int __t;
  __t=gtk_widget_get_type();
  signed int __r;
  _Bool tmp_if_expr$6;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$6 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$5 = __r;
  unsigned long int return_value_gtk_widget_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  if(!(tmp_statement_expression$5 == 0))
  {
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)app->priv->view, return_value_gtk_widget_get_type$3);
    gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
  }

  gnome_vfs_shutdown();
  gm_app_destroy_worlds(app);
  gm_pixbuf_fini();
  gm_options_save(app->priv->options);
  g_object_unref((void *)app->priv->options);
  gm_color_table_save(app->priv->color_table);
  g_object_unref((void *)app->priv->color_table);
  g_free((void *)app->priv->path);
  g_free((void *)app->priv->worlds_path);
  g_free((void *)app->priv->options_path);
  struct _GTypeClass *return_value_g_type_check_class_cast$7;
  return_value_g_type_check_class_cast$7=g_type_check_class_cast((struct _GTypeClass *)gm_app_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$7)->finalize(object);
}

// gm_app_get_property
// file gm-app.c line 91
static void gm_app_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _GmApp *app;
  unsigned long int return_value_gm_app_get_type$1;
  return_value_gm_app_get_type$1=gm_app_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_app_get_type$1);
  app = (struct _GmApp *)return_value_g_type_check_instance_cast$2;
  const char *return_value_gm_app_worlds_path$3;
  const char *return_value_gm_app_path$4;
  struct _GmOptions *return_value_gm_app_options$5;
  struct _GmColorTable *return_value_gm_app_color_table$6;
  struct _GList *return_value_gm_app_worlds$7;
  switch(prop_id)
  {
    case (unsigned int)1:
    {
      return_value_gm_app_worlds_path$3=gm_app_worlds_path(app);
      g_value_set_string(value, return_value_gm_app_worlds_path$3);
      break;
    }
    case (unsigned int)2:
    {
      return_value_gm_app_path$4=gm_app_path(app);
      g_value_set_string(value, return_value_gm_app_path$4);
      break;
    }
    case (unsigned int)3:
    {
      return_value_gm_app_options$5=gm_app_options(app);
      g_value_set_object(value, (void *)return_value_gm_app_options$5);
      break;
    }
    case (unsigned int)5:
    {
      return_value_gm_app_color_table$6=gm_app_color_table(app);
      g_value_set_object(value, (void *)return_value_gm_app_color_table$6);
      break;
    }
    case (unsigned int)4:
    {
      return_value_gm_app_worlds$7=gm_app_worlds(app);
      g_value_set_pointer(value, (void *)return_value_gm_app_worlds$7);
    }
  }
}

// gm_app_get_type
// file gm-app.c line 88
unsigned long int gm_app_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmApp");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmAppClass) /*152ul*/ , (void (*)(void *, void *))gm_app_class_intern_init, (unsigned int)sizeof(struct _GmApp) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_app_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_app_init
// file gm-app.c line 196
static void gm_app_init(struct _GmApp *app)
{
  unsigned long int return_value_gm_app_get_type$1;
  return_value_gm_app_get_type$1=gm_app_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)app, return_value_gm_app_get_type$1);
  app->priv = (struct _GmAppPrivate *)return_value_g_type_instance_get_private$2;
  app->priv->path = (char *)(void *)0;
  app->priv->worlds_path = (char *)(void *)0;
  app->priv->options_path = (char *)(void *)0;
  app->priv->options = (struct _GmOptions *)(void *)0;
  app->priv->client = (struct _GnomeClient *)(void *)0;
  app->priv->worlds = (struct _GList *)(void *)0;
}

// gm_app_initialize
// file gm-app.c line 409
static void gm_app_initialize(struct _GmApp *app)
{
  char *colors_path;
  gm_debug_set_level(debug_level);
  app->priv->worlds_path=g_strconcat(app->priv->path, (const void *)"/", (const void *)"worlds", (void *)0);
  app->priv->options_path=g_strconcat(app->priv->path, (const void *)"/", (const void *)"settings.xml", (void *)0);
  signed int return_value_g_file_test$1;
  return_value_g_file_test$1=g_file_test(app->priv->path, (enum anonymous$106)G_FILE_TEST_EXISTS);
  if(return_value_g_file_test$1 == 0)
  {
    mkdir(app->priv->path, (unsigned int)0755);
    mkdir(app->priv->worlds_path, (unsigned int)0755);
  }

  gm_app_create_settings(app);
  _gm_options_check_old_options(app->priv->options_path);
  gm_options_load(app->priv->options, app->priv->options_path);
  colors_path=g_strconcat(app->priv->path, (const void *)"/", (const void *)"colors", (void *)0);
  signed int return_value_g_file_test$2;
  return_value_g_file_test$2=g_file_test(colors_path, (enum anonymous$106)G_FILE_TEST_EXISTS);
  if(return_value_g_file_test$2 == 0)
    gm_app_convert_old_color_configuration(app, colors_path);

  g_free((void *)colors_path);
  colors_path=g_strconcat(app->priv->path, (const void *)"/", (const void *)"colors.xml", (void *)0);
  app->priv->color_table=gm_color_table_new_from_options(colors_path);
  g_free((void *)colors_path);
}

// gm_app_instance
// file ./gm-app.h line 59
struct _GmApp * gm_app_instance()
{
  return application;
}

// gm_app_load_worlds
// file gm-app.c line 318
static void gm_app_load_worlds(struct _GmApp *app, signed int autoload)
{
  struct _GDir *handle;
  handle=g_dir_open(app->priv->worlds_path, (unsigned int)0, (struct _GError **)(void *)0);
  char *name;
  char *path;
  struct _GmWorld *new_world;
  const char *return_value_g_dir_read_name$1;
  struct _GmOptions *return_value_gm_world_options$2;
  signed int return_value_gm_options_get_int$3;
  if(!(handle == ((struct _GDir *)NULL)))
  {
    do
    {
      return_value_g_dir_read_name$1=g_dir_read_name(handle);
      name = (char *)return_value_g_dir_read_name$1;
      if(name == ((char *)NULL))
        break;

      path=g_strconcat(app->priv->worlds_path, (const void *)"/", name, (void *)0);
      signed int return_value_g_file_test$4;
      return_value_g_file_test$4=g_file_test(path, (enum anonymous$106)G_FILE_TEST_IS_DIR);
      if(!(return_value_g_file_test$4 == 0))
      {
        new_world=gm_world_new(path);
        if(!(new_world == ((struct _GmWorld *)NULL)))
        {
          gm_app_add_world(app, new_world);
          if(!(autoload == 0))
          {
            return_value_gm_world_options$2=gm_world_options(new_world);
            return_value_gm_options_get_int$3=gm_options_get_int(return_value_gm_world_options$2, "autoload");
            if(!(return_value_gm_options_get_int$3 == 0))
              gm_world_load(new_world);

          }

        }

      }

      else
        gm_debug_msg(DEBUG_ALWAYS, "Directory can't be opened: %s", path);
      g_free((void *)path);
    }
    while((_Bool)1);
    g_dir_close(handle);
  }

  else
    gm_debug_msg(DEBUG_DEFAULT, "GmApp.load_worlds: failed to open worlds path %s", app->priv->path);
}

// gm_app_new
// file gm-app.c line 502
struct _GmApp * gm_app_new(signed int argc, char **argv)
{
  struct _GmApp *app;
  unsigned long int return_value_gm_app_get_type$1;
  return_value_gm_app_get_type$1=gm_app_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_app_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_app_get_type$3;
  return_value_gm_app_get_type$3=gm_app_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_app_get_type$3);
  app = (struct _GmApp *)return_value_g_type_check_instance_cast$4;
  const char *return_value_g_get_home_dir$5;
  return_value_g_get_home_dir$5=g_get_home_dir();
  app->priv->path=g_build_filename(return_value_g_get_home_dir$5, (const void *)".gnome2/", (const void *)"gnoemoe", (void *)0);
  if(app->priv->path == ((char *)NULL))
  {
    char *return_value_gettext$6;
    return_value_gettext$6=gettext("GnoeMoe Application: there is no application directory, this is very bad!!!\n");
    printf(return_value_gettext$6);
    return app;
  }

  bindtextdomain("gnoemoe", "/usr/share/locale");
  bind_textdomain_codeset("gnoemoe", "UTF-8");
  textdomain("gnoemoe");
  g_thread_init((void *)0);
  gtk_set_locale();
  gtk_init(&argc, &argv);
  const struct _GnomeModuleInfo *return_value_libgnomeui_module_info_get$7;
  return_value_libgnomeui_module_info_get$7=libgnomeui_module_info_get();
  gnome_program_init("gnoemoe", "2.2.0", return_value_libgnomeui_module_info_get$7, argc, argv, "popt-table", (const void *)poptions, (const void *)"app-datadir", (const void *)"/usr/share", (void *)0);
  app->priv->client=gnome_master_client();
  unsigned long int return_value_gtk_object_get_type$8;
  return_value_gtk_object_get_type$8=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)app->priv->client, return_value_gtk_object_get_type$8);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$9, "save_yourself", (void (*)(void))on_gm_app_save_session, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)argv, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$10;
  return_value_gtk_object_get_type$10=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)app->priv->client, return_value_gtk_object_get_type$10);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$11, "die", (void (*)(void))on_gm_app_session_die, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  gnome_vfs_init();
  glade_init();
  gm_pixbuf_init();
  gm_app_initialize(app);
  if(!(show_version == 0))
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)app, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$12);
    char *return_value_gettext$13;
    return_value_gettext$13=gettext("Current version of GnoeMoe is %s\n");
    printf(return_value_gettext$13, (const void *)"2.2.0");
    return (struct _GmApp *)(void *)0;
  }

  return app;
}

// gm_app_options
// file ./gm-app.h line 68
struct _GmOptions * gm_app_options(struct _GmApp *app)
{
  return app->priv->options;
}

// gm_app_path
// file gm-app.c line 611
const char * gm_app_path(struct _GmApp *app)
{
  return app->priv->path;
}

// gm_app_remove_world
// file ./gm-app.h line 64
void gm_app_remove_world(struct _GmApp *app, struct _GmWorld *world)
{
  char *path;
  signed int return_value_gm_world_loaded$2;
  return_value_gm_world_loaded$2=gm_world_loaded(world);
  if(return_value_gm_world_loaded$2 == 0)
  {
    const char *return_value_gm_world_path$1;
    return_value_gm_world_path$1=gm_world_path(world);
    path=g_strdup(return_value_gm_world_path$1);
    app->priv->worlds=g_list_remove(app->priv->worlds, (const void *)world);
    g_signal_emit((void *)app, app_signals[(signed long int)1], (unsigned int)0, world);
    g_object_unref((void *)world);
    gm_directory_remove_all(path, (signed int)!(0 != 0));
    g_free((void *)path);
  }

}

// gm_app_run
// file gm-app.c line 450
static void gm_app_run(struct _GmApp *app)
{
  char **wrlds;
  const char *savedState;
  signed int i = 0;
  struct _GmWorld *world;
  app->priv->view=gm_app_view_new(app);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)app->priv->view, return_value_gtk_widget_get_type$1);
  gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  gm_app_load_worlds(app, (signed int)!(recover != 0 || load_worlds != ((char *)NULL)));
  if(!(recover == 0))
  {
    savedState=gm_options_get(app->priv->options, "worlds_saved_state");
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(savedState);
    if(!(return_value_strlen$4 == 0ul))
    {
      wrlds=g_strsplit(savedState, ";", -1);
      i = 0;
      for( ; !(wrlds[(signed long int)i] == ((char *)NULL)); i = i + 1)
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(wrlds[(signed long int)i]);
        if(!(return_value_strlen$3 == 0ul))
        {
          world=gm_app_world_by_name(app, wrlds[(signed long int)i]);
          if(!(world == ((struct _GmWorld *)NULL)))
            gm_world_load(world);

        }

      }
      g_strfreev(wrlds);
    }

  }

  else
    if(!(load_worlds == ((char *)NULL)))
    {
      wrlds=g_strsplit(load_worlds, ",", -1);
      i = 0;
      for( ; !(wrlds[(signed long int)i] == ((char *)NULL)); i = i + 1)
      {
        world=gm_app_world_by_name(app, wrlds[(signed long int)i]);
        if(!(world == ((struct _GmWorld *)NULL)))
          gm_world_load(world);

      }
      g_strfreev(wrlds);
    }

  gtk_main();
}

// gm_app_view_action
// file widgets/gm-app-view.c line 865
struct _GtkAction * gm_app_view_action(struct _GmAppView *view, const char *path)
{
  struct _GtkAction *gm_app_view_action$$1$$action;
  gm_app_view_action$$1$$action=gtk_ui_manager_get_action(view->priv->manager, path);
  return gm_app_view_action$$1$$action;
}

// gm_app_view_active_editor_view
// file widgets/gm-app-view.c line 1652
struct _GmEditorView * gm_app_view_active_editor_view(struct _GmAppView *view)
{
  struct _GmWorldView *world_view;
  world_view=gm_app_view_active_world_view(view);
  signed int page;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)world_view, return_value_gtk_notebook_get_type$1);
  page=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_notebook_get_type$3;
  return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)world_view, return_value_gtk_notebook_get_type$3);
  struct _GtkWidget *return_value_gtk_notebook_get_nth_page$5;
  return_value_gtk_notebook_get_nth_page$5=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, page);
  unsigned long int return_value_gm_editor_view_get_type$6;
  return_value_gm_editor_view_get_type$6=gm_editor_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_notebook_get_nth_page$5, return_value_gm_editor_view_get_type$6);
  return (struct _GmEditorView *)return_value_g_type_check_instance_cast$7;
}

// gm_app_view_active_world
// file widgets/gm-app-view.c line 833
struct _GmWorld * gm_app_view_active_world(struct _GmAppView *view)
{
  struct _GmWorldView *world_view;
  world_view=gm_app_view_active_world_view(view);
  if(!(world_view == ((struct _GmWorldView *)NULL)))
  {
    struct _GmWorld *return_value_gm_world_view_world$1;
    return_value_gm_world_view_world$1=gm_world_view_world(world_view);
    return return_value_gm_world_view_world$1;
  }

  else
    return (struct _GmWorld *)(void *)0;
}

// gm_app_view_active_world_view
// file widgets/gm-app-view.c line 820
struct _GmWorldView * gm_app_view_active_world_view(struct _GmAppView *view)
{
  signed int n;
  n=gtk_notebook_get_current_page(view->priv->notebook);
  if(n == -1)
    return (struct _GmWorldView *)(void *)0;

  else
  {
    struct _GtkWidget *return_value_gtk_notebook_get_nth_page$1;
    return_value_gtk_notebook_get_nth_page$1=gtk_notebook_get_nth_page(view->priv->notebook, n);
    unsigned long int return_value_gm_world_view_get_type$2;
    return_value_gm_world_view_get_type$2=gm_world_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_notebook_get_nth_page$1, return_value_gm_world_view_get_type$2);
    return (struct _GmWorldView *)return_value_g_type_check_instance_cast$3;
  }
}

// gm_app_view_application
// file widgets/gm-app-view.c line 778
const struct _GmApp * gm_app_view_application(struct _GmAppView *view)
{
  return view->priv->application;
}

// gm_app_view_class_init
// file widgets/gm-app-view.c line 297
static void gm_app_view_class_init(struct _GmAppViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GtkWidgetClass *widget_class;
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_widget_get_type$2);
  widget_class = (struct _GtkWidgetClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_app_view_finalize;
  widget_class->delete_event = gm_app_view_delete_event;
  widget_class->focus_in_event = gm_app_view_focus_in_event;
  widget_class->focus_out_event = gm_app_view_focus_out_event;
  widget_class->size_allocate = gm_app_view_size_allocate;
  widget_class->window_state_event = gm_app_view_window_state_event;
  gm_app_view_signals[(signed long int)0]=g_signal_new("active_world_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)904ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__OBJECT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(20 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmAppViewPrivate) /*216ul*/ );
}

// gm_app_view_class_intern_init
// file widgets/gm-app-view.c line 167
static void gm_app_view_class_intern_init(void *klass)
{
  gm_app_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmAppView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmAppView_private_offset);

  gm_app_view_class_init((struct _GmAppViewClass *)klass);
}

// gm_app_view_create_keybindings
// file widgets/gm-app-view.c line 560
void gm_app_view_create_keybindings(struct _GmAppView *view)
{
  struct _GtkAccelGroup *grp;
  struct _GClosure *closure;
  signed int i;
  char num[2l] = { (char)0, (char)0 };
  struct _AccelInfo *info;
  grp=gtk_accel_group_new();
  i = 0;
  for( ; !(i >= 9); i = i + 1)
  {
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _AccelInfo) /*16ul*/ );
    info = (struct _AccelInfo *)return_value_g_malloc0_n$1;
    info->num = i;
    info->view = view;
    num[(signed long int)0] = (char)(49 + i);
    closure=g_cclosure_new((void (*)(void))on_gm_app_view_accel_switch_page, (void *)info, (void (*)(void *, struct _GClosure *))(void *)0);
    unsigned int return_value_gdk_keyval_from_name$2;
    return_value_gdk_keyval_from_name$2=gdk_keyval_from_name(num);
    gtk_accel_group_connect(grp, return_value_gdk_keyval_from_name$2, (enum anonymous$0)GDK_MOD1_MASK, (enum anonymous$59)GTK_ACCEL_VISIBLE, closure);
    g_closure_unref(closure);
    closure=g_cclosure_new((void (*)(void))on_gm_app_view_accel_switch_edit, (void *)info, (void (*)(void *, struct _GClosure *))(void *)0);
    unsigned int return_value_gdk_keyval_from_name$3;
    return_value_gdk_keyval_from_name$3=gdk_keyval_from_name(num);
    gtk_accel_group_connect(grp, return_value_gdk_keyval_from_name$3, (enum anonymous$0)GDK_CONTROL_MASK, (enum anonymous$59)GTK_ACCEL_VISIBLE, closure);
    g_closure_unref(closure);
  }
  void *return_value_g_malloc0_n$4;
  return_value_g_malloc0_n$4=g_malloc0_n((unsigned long int)1, sizeof(struct _AccelInfo) /*16ul*/ );
  info = (struct _AccelInfo *)return_value_g_malloc0_n$4;
  info->num = 1;
  info->view = view;
  closure=g_cclosure_new((void (*)(void))on_gm_app_view_accel_cycle_page, (void *)info, (void (*)(void *, struct _GClosure *))(void *)0);
  gtk_accel_group_connect(grp, (unsigned int)0xff55, (enum anonymous$0)GDK_CONTROL_MASK, (enum anonymous$59)GTK_ACCEL_VISIBLE, closure);
  g_closure_unref(closure);
  void *return_value_g_malloc0_n$5;
  return_value_g_malloc0_n$5=g_malloc0_n((unsigned long int)1, sizeof(struct _AccelInfo) /*16ul*/ );
  info = (struct _AccelInfo *)return_value_g_malloc0_n$5;
  info->num = -1;
  info->view = view;
  closure=g_cclosure_new((void (*)(void))on_gm_app_view_accel_cycle_page, (void *)info, (void (*)(void *, struct _GClosure *))(void *)0);
  gtk_accel_group_connect(grp, (unsigned int)0xff56, (enum anonymous$0)GDK_CONTROL_MASK, (enum anonymous$59)GTK_ACCEL_VISIBLE, closure);
  g_closure_unref(closure);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$6);
  gtk_window_add_accel_group((struct _GtkWindow *)return_value_g_type_check_instance_cast$7, grp);
}

// gm_app_view_create_search_box
// file widgets/gm-app-view.c line 445
struct _GtkWidget * gm_app_view_create_search_box(struct _GmAppView *view)
{
  struct _GtkWidget *vbox;
  vbox=gtk_vbox_new(0, 3);
  struct _GtkWidget *table;
  table=gtk_table_new((unsigned int)2, (unsigned int)2, 0);
  struct _GtkWidget *hbox;
  struct _GtkWidget *hbox_control;
  hbox_control=gtk_hbox_new(0, 6);
  struct _GtkWidget *lbl;
  struct _GtkWidget *entry;
  struct _GtkWidget *button;
  struct _GtkWidget *align;
  struct _GtkWidget *check_button;
  struct _GtkWidget *button_close;
  button_close=gtk_button_new_from_stock("gtk-close");
  struct _GtkWidget *separator;
  separator=gtk_hseparator_new();
  struct _GtkWidget *expander;
  expander=gtk_expander_new((const char *)(void *)0);
  unsigned long int return_value_gtk_container_get_type$1;
  return_value_gtk_container_get_type$1=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_container_get_type$1);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$2, (unsigned int)3);
  hbox=gtk_hbox_new(0, 6);
  char *return_value_gettext$3;
  return_value_gettext$3=gettext("Find:");
  lbl=gtk_label_new(return_value_gettext$3);
  unsigned long int return_value_gtk_misc_get_type$4;
  return_value_gtk_misc_get_type$4=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)lbl, return_value_gtk_misc_get_type$4);
  gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$5, (float)1.0, (float)0.5);
  gtk_widget_set_sensitive(expander, 0);
  align=gtk_alignment_new((float)0.0, (float)0.5, (float)0.0, (float)0.0);
  unsigned long int return_value_gtk_container_get_type$6;
  return_value_gtk_container_get_type$6=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)align, return_value_gtk_container_get_type$6);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$7, expander);
  g_signal_connect_data((void *)expander, "notify::expanded", (void (*)(void))on_gm_app_view_expander_replace, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_box_get_type$8;
  return_value_gtk_box_get_type$8=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$8);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$9, align, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$10;
  return_value_gtk_box_get_type$10=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$10);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$11, lbl, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_table_get_type$12;
  return_value_gtk_table_get_type$12=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type$12);
  gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast$13, hbox, (unsigned int)0, (unsigned int)1, (unsigned int)0, (unsigned int)1, (enum anonymous$58)(GTK_SHRINK | GTK_FILL), (enum anonymous$58)(GTK_SHRINK | GTK_FILL), (unsigned int)0.0, (unsigned int)0.0);
  char *return_value_gettext$14;
  return_value_gettext$14=gettext("Replace:");
  lbl=gtk_label_new(return_value_gettext$14);
  unsigned long int return_value_gtk_label_get_type$15;
  return_value_gtk_label_get_type$15=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)lbl, return_value_gtk_label_get_type$15);
  view->priv->label_replace = (struct _GtkLabel *)return_value_g_type_check_instance_cast$16;
  unsigned long int return_value_gtk_misc_get_type$17;
  return_value_gtk_misc_get_type$17=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)lbl, return_value_gtk_misc_get_type$17);
  gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$18, (float)1.0, (float)0.5);
  unsigned long int return_value_gtk_table_get_type$19;
  return_value_gtk_table_get_type$19=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type$19);
  gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast$20, lbl, (unsigned int)0, (unsigned int)1, (unsigned int)1, (unsigned int)2, (enum anonymous$58)(GTK_SHRINK | GTK_FILL), (enum anonymous$58)(GTK_SHRINK | GTK_FILL), (unsigned int)0.0, (unsigned int)0.0);
  hbox=gtk_hbox_new(0, 6);
  unsigned long int return_value_gtk_container_get_type$21;
  return_value_gtk_container_get_type$21=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_container_get_type$21);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$22, (unsigned int)3);
  unsigned long int return_value_gtk_table_get_type$23;
  return_value_gtk_table_get_type$23=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type$23);
  gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast$24, hbox, (unsigned int)1, (unsigned int)2, (unsigned int)0, (unsigned int)1, (enum anonymous$58)(GTK_EXPAND | GTK_FILL), (enum anonymous$58)(GTK_SHRINK | GTK_FILL), (unsigned int)0.0, (unsigned int)0.0);
  unsigned long int return_value_gtk_box_get_type$25;
  return_value_gtk_box_get_type$25=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$25);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$26, table, 0, (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$27;
  return_value_gtk_box_get_type$27=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$27);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$28, separator, 0, (signed int)!(0 != 0), (unsigned int)0);
  entry=gtk_entry_new();
  unsigned long int return_value_gtk_entry_get_type$29;
  return_value_gtk_entry_get_type$29=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$29);
  view->priv->entry_find = (struct _GtkEntry *)return_value_g_type_check_instance_cast$30;
  char *return_value_gettext$31;
  return_value_gettext$31=gettext("Find next");
  button=create_button(return_value_gettext$31, "gtk-find");
  g_signal_connect_data((void *)button, "clicked", (void (*)(void))on_gm_app_view_entry_find_activate, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)entry, "key_press_event", (void (*)(void))on_gm_app_view_entry_find_key_press, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)entry, "activate", (void (*)(void))on_gm_app_view_entry_find_activate, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)entry, "changed", (void (*)(void))on_gm_app_view_entry_find_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_box_get_type$32;
  return_value_gtk_box_get_type$32=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)hbox_control, return_value_gtk_box_get_type$32);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$33, entry, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$34;
  return_value_gtk_box_get_type$34=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
  return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)hbox_control, return_value_gtk_box_get_type$34);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$35, button, 0, 0, (unsigned int)0);
  char *return_value_gettext$36;
  return_value_gettext$36=gettext("Search backwards");
  check_button=gtk_check_button_new_with_label(return_value_gettext$36);
  g_signal_connect_data((void *)check_button, "toggled", (void (*)(void))on_gm_app_view_check_button_search_direction_toggled, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_check_button_get_type$37;
  return_value_gtk_check_button_get_type$37=gtk_check_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)check_button, return_value_gtk_check_button_get_type$37);
  view->priv->check_button_search_direction = (struct _GtkCheckButton *)return_value_g_type_check_instance_cast$38;
  unsigned long int return_value_gtk_box_get_type$39;
  return_value_gtk_box_get_type$39=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
  return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)hbox_control, return_value_gtk_box_get_type$39);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$40, check_button, 0, 0, (unsigned int)0);
  char *return_value_gettext$41;
  return_value_gettext$41=gettext("Match case");
  check_button=gtk_check_button_new_with_label(return_value_gettext$41);
  g_signal_connect_data((void *)check_button, "toggled", (void (*)(void))on_gm_app_view_check_button_search_sensitive_toggled, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_check_button_get_type$42;
  return_value_gtk_check_button_get_type$42=gtk_check_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$43;
  return_value_g_type_check_instance_cast$43=g_type_check_instance_cast((struct _GTypeInstance *)check_button, return_value_gtk_check_button_get_type$42);
  view->priv->check_button_search_sensitive = (struct _GtkCheckButton *)return_value_g_type_check_instance_cast$43;
  unsigned long int return_value_gtk_box_get_type$44;
  return_value_gtk_box_get_type$44=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)hbox_control, return_value_gtk_box_get_type$44);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$45, check_button, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$46;
  return_value_gtk_box_get_type$46=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$47;
  return_value_g_type_check_instance_cast$47=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$46);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$47, hbox_control, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$48;
  return_value_gtk_box_get_type$48=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
  return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$48);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$49, button_close, 0, 0, (unsigned int)0);
  hbox=gtk_hbox_new(0, 6);
  unsigned long int return_value_gtk_container_get_type$50;
  return_value_gtk_container_get_type$50=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
  return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_container_get_type$50);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$51, (unsigned int)3);
  entry=gtk_entry_new();
  g_signal_connect_data((void *)entry, "key_press_event", (void (*)(void))on_gm_app_view_entry_find_key_press, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_entry_get_type$52;
  return_value_gtk_entry_get_type$52=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$53;
  return_value_g_type_check_instance_cast$53=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$52);
  view->priv->entry_replace = (struct _GtkEntry *)return_value_g_type_check_instance_cast$53;
  unsigned long int return_value_gtk_box_get_type$54;
  return_value_gtk_box_get_type$54=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$55;
  return_value_g_type_check_instance_cast$55=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$54);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$55, entry, 0, 0, (unsigned int)0);
  char *return_value_gettext$56;
  return_value_gettext$56=gettext("Replace");
  button=create_button(return_value_gettext$56, "gtk-find-and-replace");
  g_signal_connect_data((void *)button, "clicked", (void (*)(void))on_gm_app_view_button_replace_clicked, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_box_get_type$57;
  return_value_gtk_box_get_type$57=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$58;
  return_value_g_type_check_instance_cast$58=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$57);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$58, button, 0, 0, (unsigned int)0);
  char *return_value_gettext$59;
  return_value_gettext$59=gettext("Replace all");
  button=gtk_button_new_with_label(return_value_gettext$59);
  g_signal_connect_data((void *)button, "clicked", (void (*)(void))on_gm_app_view_button_replace_all_clicked, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_box_get_type$60;
  return_value_gtk_box_get_type$60=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$61;
  return_value_g_type_check_instance_cast$61=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$60);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$61, button, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_table_get_type$62;
  return_value_gtk_table_get_type$62=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
  return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type$62);
  gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast$63, hbox, (unsigned int)1, (unsigned int)2, (unsigned int)1, (unsigned int)2, (enum anonymous$58)(GTK_EXPAND | GTK_FILL), (enum anonymous$58)(GTK_SHRINK | GTK_FILL), (unsigned int)0.0, (unsigned int)0.0);
  unsigned long int return_value_gtk_expander_get_type$64;
  return_value_gtk_expander_get_type$64=gtk_expander_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$65;
  return_value_g_type_check_instance_cast$65=g_type_check_instance_cast((struct _GTypeInstance *)expander, return_value_gtk_expander_get_type$64);
  view->priv->expander_replace = (struct _GtkExpander *)return_value_g_type_check_instance_cast$65;
  unsigned long int return_value_gtk_hbox_get_type$66;
  return_value_gtk_hbox_get_type$66=gtk_hbox_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$67;
  return_value_g_type_check_instance_cast$67=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_hbox_get_type$66);
  view->priv->hbox_replace = (struct _GtkHBox *)return_value_g_type_check_instance_cast$67;
  unsigned long int return_value_gtk_vbox_get_type$68;
  return_value_gtk_vbox_get_type$68=gtk_vbox_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$69;
  return_value_g_type_check_instance_cast$69=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_vbox_get_type$68);
  view->priv->vbox_find = (struct _GtkVBox *)return_value_g_type_check_instance_cast$69;
  unsigned long int return_value_gtk_hbox_get_type$70;
  return_value_gtk_hbox_get_type$70=gtk_hbox_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$71;
  return_value_g_type_check_instance_cast$71=g_type_check_instance_cast((struct _GTypeInstance *)hbox_control, return_value_gtk_hbox_get_type$70);
  view->priv->hbox_control_find = (struct _GtkHBox *)return_value_g_type_check_instance_cast$71;
  view->priv->ignore_toggling = 0;
  gtk_widget_show_all(vbox);
  unsigned long int return_value_gtk_widget_get_type$72;
  return_value_gtk_widget_get_type$72=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$73;
  return_value_g_type_check_instance_cast$73=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->label_replace, return_value_gtk_widget_get_type$72);
  gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$73);
  unsigned long int return_value_gtk_widget_get_type$74;
  return_value_gtk_widget_get_type$74=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$75;
  return_value_g_type_check_instance_cast$75=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hbox_replace, return_value_gtk_widget_get_type$74);
  gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$75);
  gtk_widget_hide(vbox);
  g_signal_connect_data((void *)button_close, "clicked", (void (*)(void))on_gm_app_view_button_find_close_clicked, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  return vbox;
}

// gm_app_view_create_tray
// file widgets/gm-app-view.c line 615
static void gm_app_view_create_tray(struct _GmAppView *view)
{
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("GnoeMoe Gnome MOO Client");
  struct _GmTray *return_value_gm_tray_new$2;
  return_value_gm_tray_new$2=gm_tray_new(return_value_gettext$1);
  void *return_value_g_object_ref$3;
  return_value_g_object_ref$3=g_object_ref((void *)return_value_gm_tray_new$2);
  view->priv->tray = (struct _GmTray *)return_value_g_object_ref$3;
  struct _GdkPixbuf *return_value_gm_pixbuf_get$4;
  return_value_gm_pixbuf_get$4=gm_pixbuf_get("tray/default.svg");
  gm_tray_set_icon(view->priv->tray, (enum _GmTrayState)TRAY_STATE_NORMAL, return_value_gm_pixbuf_get$4);
  struct _GdkPixbuf *return_value_gm_pixbuf_get$5;
  return_value_gm_pixbuf_get$5=gm_pixbuf_get("tray/active.svg");
  gm_tray_set_icon(view->priv->tray, (enum _GmTrayState)TRAY_STATE_ACTIVE, return_value_gm_pixbuf_get$5);
  struct _GdkPixbuf *return_value_gm_pixbuf_get$6;
  return_value_gm_pixbuf_get$6=gm_pixbuf_get("tray/notify.svg");
  gm_tray_set_icon(view->priv->tray, (enum _GmTrayState)TRAY_STATE_NOTIFY, return_value_gm_pixbuf_get$6);
  struct _GdkPixbuf *return_value_gm_pixbuf_get$7;
  return_value_gm_pixbuf_get$7=gm_pixbuf_get("tray/activity.svg");
  gm_tray_set_icon(view->priv->tray, (enum _GmTrayState)TRAY_STATE_ACTIVITY, return_value_gm_pixbuf_get$7);
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->tray, return_value_gtk_widget_get_type$8);
  gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$9);
  g_signal_connect_data((void *)view->priv->tray, "message-clicked", (void (*)(void))on_gm_app_view_tray_message_clicked, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)view->priv->tray, "button-press-event", (void (*)(void))on_gm_app_view_tray_button_press, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)view->priv->tray, "destroy", (void (*)(void))on_gm_app_view_tray_destroy, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
}

// gm_app_view_create_ui
// file widgets/gm-app-view.c line 324
void gm_app_view_create_ui(struct _GmAppView *view)
{
  struct _GError *error = (struct _GError *)(void *)0;
  struct _GtkActionGroup *action_group;
  struct _GtkAction *gm_app_view_create_ui$$1$$action;
  view->priv->manager=gtk_ui_manager_new();
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  struct _GtkAccelGroup *return_value_gtk_ui_manager_get_accel_group$3;
  return_value_gtk_ui_manager_get_accel_group$3=gtk_ui_manager_get_accel_group(view->priv->manager);
  gtk_window_add_accel_group((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, return_value_gtk_ui_manager_get_accel_group$3);
  gtk_ui_manager_add_ui_from_file(view->priv->manager, "/usr/share/gnoemoe/ui/gm-ui.xml", &error);
  if(!(error == ((struct _GError *)NULL)))
  {
    gm_debug_msg(DEBUG_ALWAYS, "Could not merge UI file");
    g_error_free(error);
    g_object_unref((void *)view->priv->manager);
    view->priv->manager = (struct _GtkUIManager *)(void *)0;
  }

  else
  {
    action_group=gtk_action_group_new("GmAppViewSensitiveActions");
    gtk_action_group_set_translation_domain(action_group, "gnoemoe");
    gtk_action_group_add_actions(action_group, gm_sensitive_menu_entries, (unsigned int)(sizeof(const struct _GtkActionEntry [11l]) /*528ul*/  / sizeof(const struct _GtkActionEntry) /*48ul*/ ), (void *)view);
    gtk_action_group_add_toggle_actions(action_group, gm_toggle_menu_entries, (unsigned int)(sizeof(const struct _GtkToggleActionEntry [2l]) /*112ul*/  / sizeof(const struct _GtkToggleActionEntry) /*56ul*/ ), (void *)view);
    gtk_ui_manager_insert_action_group(view->priv->manager, action_group, 0);
    view->priv->sensitive_action_group = action_group;
    gtk_action_group_set_sensitive(action_group, (signed int)!(0 != 0));
    action_group=gtk_action_group_new("GmAppViewActions");
    gtk_action_group_set_translation_domain(action_group, "gnoemoe");
    gtk_action_group_add_actions(action_group, gm_menu_entries, (unsigned int)(sizeof(const struct _GtkActionEntry [14l]) /*672ul*/  / sizeof(const struct _GtkActionEntry) /*48ul*/ ), (void *)view);
    gtk_ui_manager_insert_action_group(view->priv->manager, action_group, 0);
    view->priv->action_group = action_group;
    gtk_action_group_set_sensitive(action_group, 0);
    view->priv->worlds_action_group=gtk_action_group_new("GmAppViewWorldsActions");
    gtk_action_group_set_translation_domain(view->priv->worlds_action_group, "gnoemoe");
    gtk_ui_manager_insert_action_group(view->priv->manager, view->priv->worlds_action_group, 0);
    view->priv->editor_action_group=gtk_action_group_new("GmAppViewEditorActions");
    gtk_action_group_set_translation_domain(view->priv->editor_action_group, "gnoemoe");
    gtk_action_group_add_actions(view->priv->editor_action_group, gm_editor_entries, (unsigned int)(sizeof(const struct _GtkActionEntry [4l]) /*192ul*/  / sizeof(const struct _GtkActionEntry) /*48ul*/ ), (void *)view);
    gtk_ui_manager_insert_action_group(view->priv->manager, view->priv->editor_action_group, 0);
    gtk_action_group_set_visible(view->priv->editor_action_group, 0);
    gtk_action_group_set_sensitive(view->priv->editor_action_group, 0);
    struct _GtkAction *return_value_gm_app_view_action$4;
    return_value_gm_app_view_action$4=gm_app_view_action(view, "/MenuBar/EditMenu/EditScriptsMenu");
    gtk_action_set_sensitive(return_value_gm_app_view_action$4, 0);
    gm_app_view_create_ui$$1$$action=gm_app_view_action(view, "/MenuBar/WorldMenu/WorldOpenMenu");
    char *return_value_gettext$5;
    return_value_gettext$5=gettext("Open");
    g_object_set((void *)gm_app_view_create_ui$$1$$action, "short-label", return_value_gettext$5, (void *)0);
    gm_app_view_create_ui$$1$$action=gm_app_view_action(view, "/MenuBar/ViewMenu/ViewToolbarMenu");
    unsigned long int return_value_gtk_toggle_action_get_type$6;
    return_value_gtk_toggle_action_get_type$6=gtk_toggle_action_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)gm_app_view_create_ui$$1$$action, return_value_gtk_toggle_action_get_type$6);
    struct _GmApp *return_value_gm_app_instance$8;
    return_value_gm_app_instance$8=gm_app_instance();
    struct _GmOptions *return_value_gm_app_options$9;
    return_value_gm_app_options$9=gm_app_options(return_value_gm_app_instance$8);
    signed int return_value_gm_options_get_int$10;
    return_value_gm_options_get_int$10=gm_options_get_int(return_value_gm_app_options$9, "show_toolbar");
    gtk_toggle_action_set_active((struct _GtkToggleAction *)return_value_g_type_check_instance_cast$7, return_value_gm_options_get_int$10);
    gm_app_view_create_ui$$1$$action=gm_app_view_action(view, "/MenuBar/ViewMenu/ViewUserlistMenu");
    unsigned long int return_value_gtk_toggle_action_get_type$11;
    return_value_gtk_toggle_action_get_type$11=gtk_toggle_action_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)gm_app_view_create_ui$$1$$action, return_value_gtk_toggle_action_get_type$11);
    struct _GmApp *return_value_gm_app_instance$13;
    return_value_gm_app_instance$13=gm_app_instance();
    struct _GmOptions *return_value_gm_app_options$14;
    return_value_gm_app_options$14=gm_app_options(return_value_gm_app_instance$13);
    signed int return_value_gm_options_get_int$15;
    return_value_gm_options_get_int$15=gm_options_get_int(return_value_gm_app_options$14, "show_userlist");
    gtk_toggle_action_set_active((struct _GtkToggleAction *)return_value_g_type_check_instance_cast$12, return_value_gm_options_get_int$15);
  }
}

// gm_app_view_delete_event
// file widgets/gm-app-view.c line 198
static signed int gm_app_view_delete_event(struct _GtkWidget *widget, struct _GdkEventAny *event)
{
  signed int ret = 0;
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$4;
  return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$3);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$4)->delete_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventAny *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$2;
    return_value_g_type_check_class_cast$2=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$1);
    ret=((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$2)->delete_event(widget, event);
  }

  gtk_main_quit();
  return ret;
}

// gm_app_view_destroy_world_menu_item
// file widgets/gm-app-view.c line 788
void gm_app_view_destroy_world_menu_item(struct _GmAppViewWorldMenuItem *item)
{
  g_object_unref((void *)item->action);
  g_free((void *)item);
}

// gm_app_view_drag_start
// file widgets/gm-app-view.c line 1443
void gm_app_view_drag_start(struct _GmAppView *view, unsigned int time)
{
  view->priv->drag_in_progress = (signed int)!(0 != 0);
  if(view->priv->cursor == ((struct _GdkCursor *)NULL))
    view->priv->cursor=gdk_cursor_new((enum anonymous$37)GDK_FLEUR);

  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->notebook, return_value_gtk_widget_get_type$1);
  gtk_grab_add((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gdk_pointer_is_grabbed$5;
  return_value_gdk_pointer_is_grabbed$5=gdk_pointer_is_grabbed();
  if(return_value_gdk_pointer_is_grabbed$5 == 0)
  {
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->notebook, return_value_gtk_widget_get_type$3);
    gdk_pointer_grab(((struct _GtkWidget *)return_value_g_type_check_instance_cast$4)->window, 0, (enum anonymous$47)(GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_RELEASE_MASK), (struct _GdkDrawable *)(void *)0, view->priv->cursor, time);
  }

}

// gm_app_view_drag_stop
// file widgets/gm-app-view.c line 1431
void gm_app_view_drag_stop(struct _GmAppView *view)
{
  view->priv->drag_in_progress = 0;
  if(!(view->priv->motion_notify_handler_id == 0))
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->notebook, (unsigned long int)(20 << 2));
    g_signal_handler_disconnect((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, (unsigned long int)view->priv->motion_notify_handler_id);
    view->priv->motion_notify_handler_id = 0;
  }

}

// gm_app_view_finalize
// file widgets/gm-app-view.c line 170
static void gm_app_view_finalize(struct _GObject *object)
{
  struct _GmAppView *view;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_app_view_get_type$1);
  view = (struct _GmAppView *)return_value_g_type_check_instance_cast$2;
  if(!(view->priv->cursor == ((struct _GdkCursor *)NULL)))
    gdk_cursor_unref(view->priv->cursor);

  if(!(view->priv->tray_idle_create == 0u))
    g_source_remove(view->priv->tray_idle_create);

  if(!(view->priv->tray == ((struct _GmTray *)NULL)))
  {
    g_signal_handlers_disconnect_matched((void *)view->priv->tray, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_app_view_tray_destroy, (void *)view);
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->tray, return_value_gtk_widget_get_type$3);
    gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
    g_object_unref((void *)view->priv->tray);
  }

  g_hash_table_destroy(view->priv->world_menu_items);
  struct _GTypeClass *return_value_g_type_check_class_cast$5;
  return_value_g_type_check_class_cast$5=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$5)->finalize(object);
}

// gm_app_view_find_first
// file widgets/gm-app-view.c line 1209
signed int gm_app_view_find_first(struct _GmAppView *view)
{
  struct _GmWorldView *world_view;
  world_view=gm_app_view_active_world_view(view);
  struct _GdkColor red;
  struct _GtkEntry *entry = view->priv->entry_find;
  const char *text;
  _Bool tmp_if_expr$7;
  if(!(world_view == ((struct _GmWorldView *)NULL)))
  {
    gdk_color_parse("#ff6666", &red);
    text=gtk_entry_get_text(entry);
    enum _GmSearchableSearchFlags return_value_gm_app_view_search_flags$5;
    return_value_gm_app_view_search_flags$5=gm_app_view_search_flags(view);
    signed int return_value_gm_world_view_find_first$6;
    return_value_gm_world_view_find_first$6=gm_world_view_find_first(world_view, text, return_value_gm_app_view_search_flags$5);
    if(!(return_value_gm_world_view_find_first$6 == 0))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)*text == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
    {
      unsigned long int return_value_gtk_widget_get_type$1;
      return_value_gtk_widget_get_type$1=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_widget_get_type$1);
      gtk_widget_modify_base((struct _GtkWidget *)return_value_g_type_check_instance_cast$2, (enum anonymous$23)GTK_STATE_NORMAL, (const struct _GdkColor *)(void *)0);
    }

    else
    {
      unsigned long int return_value_gtk_widget_get_type$3;
      return_value_gtk_widget_get_type$3=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_widget_get_type$3);
      gtk_widget_modify_base((struct _GtkWidget *)return_value_g_type_check_instance_cast$4, (enum anonymous$23)GTK_STATE_NORMAL, &red);
    }
  }

  return 0;
}

// gm_app_view_find_tab_num_at_pos
// file widgets/gm-app-view.c line 1380
signed int gm_app_view_find_tab_num_at_pos(struct _GmAppView *view, signed int abs_x, signed int abs_y)
{
  struct _GtkNotebook *notebook = view->priv->notebook;
  enum anonymous$46 tab_pos;
  signed int page_num = 0;
  struct _GtkWidget *page;
  tab_pos=gtk_notebook_get_tab_pos(notebook);
  if(notebook->first_tab == ((struct _GList *)NULL))
    return -1;

  else
  {
    do
    {
      page=gtk_notebook_get_nth_page(notebook, page_num);
      if(page == ((struct _GtkWidget *)NULL))
        break;

      struct _GtkWidget *tab;
      signed int max_x;
      signed int max_y;
      signed int x_root;
      signed int y_root;
      tab=gtk_notebook_get_tab_label(notebook, page);
      do
        if(tab == ((struct _GtkWidget *)NULL))
        {
          g_return_if_fail_warning((char *)0, (const char *)"gm_app_view_find_tab_num_at_pos", "tab != NULL");
          return -1;
        }

      while((_Bool)0);
      unsigned long int return_value_gtk_widget_get_type$1;
      return_value_gtk_widget_get_type$1=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)tab, return_value_gtk_widget_get_type$1);
      unsigned long int return_value_gtk_object_get_type$3;
      return_value_gtk_object_get_type$3=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkWidget *)return_value_g_type_check_instance_cast$2, return_value_gtk_object_get_type$3);
      if((128u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$4)->flags) == 0u)
        page_num = page_num + 1;

      else
      {
        unsigned long int return_value_gdk_window_object_get_type$5;
        return_value_gdk_window_object_get_type$5=gdk_window_object_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)tab->window, return_value_gdk_window_object_get_type$5);
        gdk_window_get_origin((struct _GdkDrawable *)return_value_g_type_check_instance_cast$6, &x_root, &y_root);
        max_x = x_root + tab->allocation.x + tab->allocation.width;
        max_y = y_root + tab->allocation.y + tab->allocation.height;
        if(max_x >= abs_x && ((signed int)tab_pos == GTK_POS_TOP || (signed int)tab_pos == GTK_POS_BOTTOM))
          return page_num;

        else
          if(max_y >= abs_y && ((signed int)tab_pos == GTK_POS_LEFT || (signed int)tab_pos == GTK_POS_RIGHT))
            return page_num;

        page_num = page_num + 1;
      }
    }
    while((_Bool)1);
    return -1;
  }
}

// gm_app_view_focus_in_event
// file widgets/gm-app-view.c line 212
static signed int gm_app_view_focus_in_event(struct _GtkWidget *widget, struct _GdkEventFocus *event)
{
  struct _GmAppView *view;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_app_view_get_type$1);
  view = (struct _GmAppView *)return_value_g_type_check_instance_cast$2;
  struct _GmWorld *world;
  world=gm_app_view_active_world(view);
  if(!(world == ((struct _GmWorld *)NULL)))
    gm_world_set_active(world, (signed int)!(0 != 0));

  if(!(view->priv->tray == ((struct _GmTray *)NULL)))
    gm_tray_normal(view->priv->tray);

  unsigned long int return_value_gtk_window_get_type$3;
  return_value_gtk_window_get_type$3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$3);
  gtk_window_set_urgency_hint((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, 0);
  unsigned long int return_value_gtk_widget_get_type$7;
  return_value_gtk_widget_get_type$7=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$8;
  return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$7);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$8)->focus_in_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventFocus *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$6;
    return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$5);
    signed int return_value;
    return_value=((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->focus_in_event(widget, event);
    return return_value;
  }

  return 0;
}

// gm_app_view_focus_out_event
// file widgets/gm-app-view.c line 237
static signed int gm_app_view_focus_out_event(struct _GtkWidget *widget, struct _GdkEventFocus *event)
{
  struct _GmAppView *view;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_app_view_get_type$1);
  view = (struct _GmAppView *)return_value_g_type_check_instance_cast$2;
  struct _GmWorld *world;
  world=gm_app_view_active_world(view);
  if(!(world == ((struct _GmWorld *)NULL)))
    gm_world_set_active(world, 0);

  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$5);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->focus_out_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventFocus *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$4;
    return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$3);
    signed int return_value;
    return_value=((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$4)->focus_out_event(widget, event);
    return return_value;
  }

  return 0;
}

// gm_app_view_get_type
// file widgets/gm-app-view.c line 167
unsigned long int gm_app_view_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_window_get_type$1;
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmAppView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_window_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmAppViewClass) /*912ul*/ , (void (*)(void *, void *))gm_app_view_class_intern_init, (unsigned int)sizeof(struct _GmAppView) /*248ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_app_view_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_app_view_init
// file widgets/gm-app-view.c line 638
static void gm_app_view_init(struct _GmAppView *view)
{
  struct _GtkWidget *menu = (struct _GtkWidget *)(void *)0;
  struct _GtkWidget *toolbar = (struct _GtkWidget *)(void *)0;
  struct _GtkWidget *search;
  struct _GtkWidget *vbox;
  struct _GtkWidget *note;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)view, return_value_gm_app_view_get_type$1);
  view->priv = (struct _GmAppViewPrivate *)return_value_g_type_instance_get_private$2;
  vbox=gtk_vbox_new(0, 3);
  gtk_widget_show(vbox);
  unsigned long int return_value_gtk_container_get_type$3;
  return_value_gtk_container_get_type$3=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_container_get_type$3);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$4, vbox);
  gm_app_view_create_ui(view);
  if(!(view->priv->manager == ((struct _GtkUIManager *)NULL)))
  {
    menu=gtk_ui_manager_get_widget(view->priv->manager, "/MenuBar");
    if(!(menu == ((struct _GtkWidget *)NULL)))
    {
      gtk_widget_show(menu);
      unsigned long int return_value_gtk_box_get_type$5;
      return_value_gtk_box_get_type$5=gtk_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$5);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$6, menu, 0, (signed int)!(0 != 0), (unsigned int)0);
    }

    toolbar=gtk_ui_manager_get_widget(view->priv->manager, "/ToolBar");
    if(!(toolbar == ((struct _GtkWidget *)NULL)))
    {
      gtk_widget_show(toolbar);
      unsigned long int return_value_gtk_box_get_type$7;
      return_value_gtk_box_get_type$7=gtk_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$7);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$8, toolbar, 0, (signed int)!(0 != 0), (unsigned int)0);
    }

  }

  search=gm_app_view_create_search_box(view);
  unsigned long int return_value_gtk_box_get_type$9;
  return_value_gtk_box_get_type$9=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$10, search, 0, (signed int)!(0 != 0), (unsigned int)0);
  note=gtk_notebook_new();
  gtk_widget_show(note);
  unsigned long int return_value_gtk_container_get_type$11;
  return_value_gtk_container_get_type$11=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)note, return_value_gtk_container_get_type$11);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$12, (unsigned int)3);
  unsigned long int return_value_gtk_notebook_get_type$13;
  return_value_gtk_notebook_get_type$13=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)note, return_value_gtk_notebook_get_type$13);
  gtk_notebook_set_show_border((struct _GtkNotebook *)return_value_g_type_check_instance_cast$14, 0);
  do
  {
    unsigned long int return_value_gtk_object_get_type$15;
    return_value_gtk_object_get_type$15=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)note, return_value_gtk_object_get_type$15);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast$16)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast$16)->flags & (unsigned int)~2048;
  }
  while((_Bool)0);
  unsigned long int return_value_gtk_widget_get_type$17;
  return_value_gtk_widget_get_type$17=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)note, return_value_gtk_widget_get_type$17);
  gtk_widget_add_events((struct _GtkWidget *)return_value_g_type_check_instance_cast$18, GDK_BUTTON1_MOTION_MASK);
  unsigned long int return_value_gtk_box_get_type$19;
  return_value_gtk_box_get_type$19=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$19);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$20, note, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  gm_app_view_create_keybindings(view);
  unsigned long int return_value_gtk_menu_bar_get_type$21;
  return_value_gtk_menu_bar_get_type$21=gtk_menu_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)menu, return_value_gtk_menu_bar_get_type$21);
  view->priv->menu = (struct _GtkMenuBar *)return_value_g_type_check_instance_cast$22;
  unsigned long int return_value_gtk_toolbar_get_type$23;
  return_value_gtk_toolbar_get_type$23=gtk_toolbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)toolbar, return_value_gtk_toolbar_get_type$23);
  view->priv->toolbar = (struct _GtkToolbar *)return_value_g_type_check_instance_cast$24;
  unsigned long int return_value_gtk_notebook_get_type$25;
  return_value_gtk_notebook_get_type$25=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)note, return_value_gtk_notebook_get_type$25);
  view->priv->notebook = (struct _GtkNotebook *)return_value_g_type_check_instance_cast$26;
  unsigned long int return_value_gtk_window_get_type$27;
  return_value_gtk_window_get_type$27=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$27);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$28, "GnoeMoe");
  unsigned long int return_value_gtk_window_get_type$29;
  return_value_gtk_window_get_type$29=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$29);
  struct _GdkPixbuf *return_value_gm_pixbuf_get$31;
  return_value_gm_pixbuf_get$31=gm_pixbuf_get("gnoemoe_logo.svg");
  gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$30, return_value_gm_pixbuf_get$31);
  g_signal_connect_data((void *)note, "switch-page", (void (*)(void))on_gm_app_view_notebook_switch_page, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)G_CONNECT_AFTER);
  g_signal_connect_data((void *)note, "button-press-event", (void (*)(void))on_gm_app_view_notebook_button_press, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)note, "button-release-event", (void (*)(void))on_gm_app_view_notebook_button_release, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  view->priv->world_menu_items=g_hash_table_new_full(g_direct_hash, g_direct_equal, (void (*)(void *))(void *)0, (void (*)(void *))gm_app_view_destroy_world_menu_item);
  view->priv->drag_in_progress = 0;
  view->priv->motion_notify_handler_id = 0;
  view->priv->x_start = 0;
  view->priv->y_start = 0;
  view->priv->cursor = (struct _GdkCursor *)(void *)0;
  gm_app_view_create_tray(view);
}

// gm_app_view_menu_item
// file widgets/gm-app-view.c line 858
struct _GtkMenuItem * gm_app_view_menu_item(struct _GmAppView *view, const char *path)
{
  struct _GtkMenuItem *img;
  struct _GtkWidget *return_value_gtk_ui_manager_get_widget$1;
  return_value_gtk_ui_manager_get_widget$1=gtk_ui_manager_get_widget(view->priv->manager, path);
  unsigned long int return_value_gtk_menu_item_get_type$2;
  return_value_gtk_menu_item_get_type$2=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_ui_manager_get_widget$1, return_value_gtk_menu_item_get_type$2);
  img = (struct _GtkMenuItem *)return_value_g_type_check_instance_cast$3;
  return img;
}

// gm_app_view_move_current_tab
// file widgets/gm-app-view.c line 1463
void gm_app_view_move_current_tab(struct _GmAppView *view, signed int dest_position)
{
  signed int cur_page_num;
  cur_page_num=gtk_notebook_get_current_page(view->priv->notebook);
  if(!(dest_position == cur_page_num))
  {
    struct _GtkWidget *cur_tab;
    cur_tab=gtk_notebook_get_nth_page(view->priv->notebook, cur_page_num);
    gtk_notebook_reorder_child(view->priv->notebook, cur_tab, dest_position);
  }

}

// gm_app_view_new
// file widgets/gm-app-view.c line 747
struct _GmAppView * gm_app_view_new(struct _GmApp *application)
{
  struct _GmAppView *view;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_app_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_app_view_get_type$3;
  return_value_gm_app_view_get_type$3=gm_app_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_app_view_get_type$3);
  view = (struct _GmAppView *)return_value_g_type_check_instance_cast$4;
  view->priv->application = application;
  view->priv->active_world = (struct _GmWorld *)(void *)0;
  gm_app_view_restore_size(view);
  unsigned long int return_value_gtk_toggle_button_get_type$5;
  return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->check_button_search_direction, return_value_gtk_toggle_button_get_type$5);
  struct _GmOptions *return_value_gm_app_options$7;
  return_value_gm_app_options$7=gm_app_options(application);
  signed int return_value_gm_options_get_int$8;
  return_value_gm_options_get_int$8=gm_options_get_int(return_value_gm_app_options$7, "search_direction_world");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6, return_value_gm_options_get_int$8);
  unsigned long int return_value_gtk_toggle_button_get_type$9;
  return_value_gtk_toggle_button_get_type$9=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->check_button_search_sensitive, return_value_gtk_toggle_button_get_type$9);
  struct _GmOptions *return_value_gm_app_options$11;
  return_value_gm_app_options$11=gm_app_options(application);
  signed int return_value_gm_options_get_int$12;
  return_value_gm_options_get_int$12=gm_options_get_int(return_value_gm_app_options$11, "search_sensitive");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$10, return_value_gm_options_get_int$12);
  g_signal_connect_data((void *)application, "world_added", (void (*)(void))on_gm_app_view_world_added, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)application, "world_removed", (void (*)(void))on_gm_app_view_world_removed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  struct _GmOptions *return_value_gm_app_options$13;
  return_value_gm_app_options$13=gm_app_options(application);
  g_signal_connect_data((void *)return_value_gm_app_options$13, "option-changed", (void (*)(void))on_gm_app_view_option_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  return view;
}

// gm_app_view_notebook
// file widgets/gm-app-view.c line 783
struct _GtkNotebook * gm_app_view_notebook(struct _GmAppView *view)
{
  return view->priv->notebook;
}

// gm_app_view_restore_position
// file widgets/gm-app-view.c line 720
static void gm_app_view_restore_position(struct _GmAppView *view)
{
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  gtk_window_move((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, view->priv->position_left, view->priv->position_top);
}

// gm_app_view_restore_size
// file widgets/gm-app-view.c line 726
static void gm_app_view_restore_size(struct _GmAppView *view)
{
  signed int width;
  signed int height;
  struct _GmOptions *return_value_gm_app_options$1;
  return_value_gm_app_options$1=gm_app_options(view->priv->application);
  width=gm_options_get_int(return_value_gm_app_options$1, "width");
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(view->priv->application);
  height=gm_options_get_int(return_value_gm_app_options$2, "height");
  unsigned long int return_value_gtk_window_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  unsigned long int return_value_gtk_window_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  if(height >= 11 && width >= 11)
  {
    return_value_gtk_window_get_type$3=gtk_window_get_type();
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$3);
    gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, width, height);
  }

  else
  {
    return_value_gtk_window_get_type$5=gtk_window_get_type();
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$5);
    gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast$6, 400, 300);
  }
  struct _GmOptions *return_value_gm_app_options$9;
  return_value_gm_app_options$9=gm_app_options(view->priv->application);
  signed int return_value_gm_options_get_int$10;
  return_value_gm_options_get_int$10=gm_options_get_int(return_value_gm_app_options$9, "maximized");
  if(!(return_value_gm_options_get_int$10 == 0))
  {
    unsigned long int return_value_gtk_window_get_type$7;
    return_value_gtk_window_get_type$7=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$7);
    gtk_window_maximize((struct _GtkWindow *)return_value_g_type_check_instance_cast$8);
  }

}

// gm_app_view_search_flags
// file widgets/gm-app-view.c line 1188
enum _GmSearchableSearchFlags gm_app_view_search_flags(struct _GmAppView *view)
{
  enum _GmSearchableSearchFlags flags = (enum _GmSearchableSearchFlags)0;
  signed int active;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->check_button_search_direction, return_value_gtk_toggle_button_get_type$1);
  active=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  signed int sensitive;
  unsigned long int return_value_gtk_toggle_button_get_type$3;
  return_value_gtk_toggle_button_get_type$3=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->check_button_search_sensitive, return_value_gtk_toggle_button_get_type$3);
  sensitive=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$4);
  if(!(active == 0))
    flags = (enum _GmSearchableSearchFlags)GM_SEARCHABLE_SEARCH_BACKWARDS;

  else
    flags = (enum _GmSearchableSearchFlags)GM_SEARCHABLE_SEARCH_FORWARDS;
  if(sensitive == 0)
    flags = flags | (enum _GmSearchableSearchFlags)GM_SEARCHABLE_SEARCH_CASE_INSENSITIVE;

  return flags;
}

// gm_app_view_set_sensitivity
// file widgets/gm-app-view.c line 806
void gm_app_view_set_sensitivity(struct _GmAppView *view, signed int sens)
{
  gtk_action_group_set_sensitive(view->priv->action_group, sens);
  if(sens == 1)
  {
    struct _GtkAction *return_value_gtk_action_group_get_action$1;
    return_value_gtk_action_group_get_action$1=gtk_action_group_get_action(view->priv->action_group, "WorldInfo");
    gtk_action_set_visible(return_value_gtk_action_group_get_action$1, 0);
  }

  if(sens == 0)
  {
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->vbox_find, return_value_gtk_widget_get_type$2);
    gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$3);
  }

}

// gm_app_view_show_find_box
// file widgets/gm-app-view.c line 1249
void gm_app_view_show_find_box(struct _GmAppView *view)
{
  unsigned long int return_value_gtk_object_get_type$3;
  return_value_gtk_object_get_type$3=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->vbox_find, return_value_gtk_object_get_type$3);
  if((256u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$4)->flags) == 0u)
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->vbox_find, return_value_gtk_widget_get_type$1);
    gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  }

}

// gm_app_view_show_replace_box
// file widgets/gm-app-view.c line 1241
void gm_app_view_show_replace_box(struct _GmAppView *view)
{
  unsigned long int return_value_gtk_object_get_type$5;
  return_value_gtk_object_get_type$5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hbox_replace, return_value_gtk_object_get_type$5);
  if((256u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$6)->flags) == 0u)
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->label_replace, return_value_gtk_widget_get_type$1);
    gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hbox_replace, return_value_gtk_widget_get_type$3);
    gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
  }

}

// gm_app_view_size_allocate
// file widgets/gm-app-view.c line 258
static void gm_app_view_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation)
{
  struct _GmAppView *view;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_app_view_get_type$1);
  view = (struct _GmAppView *)return_value_g_type_check_instance_cast$2;
  enum anonymous$22 state = (enum anonymous$22)0;
  signed int tmp_statement_expression$3;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget->window;
  unsigned long int __t;
  __t=gdk_window_object_get_type();
  signed int __r;
  _Bool tmp_if_expr$4;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$3 = __r;
  if(!(tmp_statement_expression$3 == 0))
    state=gdk_window_get_state(widget->window);

  if((6 & (signed int)state) == 0)
  {
    struct _GmOptions *return_value_gm_app_options$5;
    return_value_gm_app_options$5=gm_app_options(view->priv->application);
    gm_options_set_int(return_value_gm_app_options$5, "width", allocation->width);
    struct _GmOptions *return_value_gm_app_options$6;
    return_value_gm_app_options$6=gm_app_options(view->priv->application);
    gm_options_set_int(return_value_gm_app_options$6, "height", allocation->height);
  }

  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$10;
  return_value_g_type_check_class_cast$10=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$9);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$10)->size_allocate == ((void (*)(struct _GtkWidget *, struct _GdkRectangle *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$7;
    return_value_gtk_widget_get_type$7=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$8;
    return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$7);
    ((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$8)->size_allocate(widget, allocation);
  }

}

// gm_app_view_store_position
// file widgets/gm-app-view.c line 714
static void gm_app_view_store_position(struct _GmAppView *view)
{
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  gtk_window_get_position((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, &view->priv->position_left, &view->priv->position_top);
}

// gm_app_view_toggle_visibility
// file widgets/gm-app-view.c line 957
void gm_app_view_toggle_visibility(struct _GmAppView *view)
{
  signed int visible;
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_object_get_type$1);
  visible = (signed int)((((struct _GtkObject *)return_value_g_type_check_instance_cast$2)->flags & (unsigned int)256) != (unsigned int)0);
  _Bool tmp_if_expr$14;
  unsigned long int return_value_gtk_window_get_type$11;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  signed int return_value_gtk_window_is_active$13;
  if(visible == 0)
    tmp_if_expr$14 = (_Bool)1;

  else
  {
    return_value_gtk_window_get_type$11=gtk_window_get_type();
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$11);
    return_value_gtk_window_is_active$13=gtk_window_is_active((struct _GtkWindow *)return_value_g_type_check_instance_cast$12);
    tmp_if_expr$14 = !(return_value_gtk_window_is_active$13 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$14)
  {
    if(visible == 0)
    {
      gm_app_view_restore_size(view);
      gm_app_view_restore_position(view);
    }

    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$3);
    gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
    unsigned long int return_value_gtk_window_get_type$5;
    return_value_gtk_window_get_type$5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$5);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$6);
    unsigned long int return_value_gtk_widget_get_type$7;
    return_value_gtk_widget_get_type$7=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$7);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$8);
    if(!(view->priv->tray == ((struct _GmTray *)NULL)))
      gm_tray_normal(view->priv->tray);

  }

  else
    if(!(view->priv->tray == ((struct _GmTray *)NULL)))
    {
      gm_app_view_store_position(view);
      unsigned long int return_value_gtk_widget_get_type$9;
      return_value_gtk_widget_get_type$9=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$9);
      gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$10);
    }

}

// gm_app_view_update_connect_button
// file widgets/gm-app-view.c line 871
void gm_app_view_update_connect_button(struct _GmAppView *view, signed int connected)
{
  struct _GtkAction *gm_app_view_update_connect_button$$1$$action;
  gm_app_view_update_connect_button$$1$$action=gm_app_view_action(view, "/MenuBar/WorldMenu/WorldConnectMenu");
  if(connected == 0)
  {
    g_object_set((void *)gm_app_view_update_connect_button$$1$$action, "stock-id", (const void *)"gtk-connect", (void *)0);
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Connect");
    g_object_set((void *)gm_app_view_update_connect_button$$1$$action, "label", return_value_gettext$1, (void *)0);
    char *return_value_gettext$2;
    return_value_gettext$2=gettext("Connect the current world");
    g_object_set((void *)gm_app_view_update_connect_button$$1$$action, "tooltip", return_value_gettext$2, (void *)0);
  }

  else
  {
    g_object_set((void *)gm_app_view_update_connect_button$$1$$action, "stock-id", (const void *)"gtk-disconnect", (void *)0);
    char *return_value_gettext$3;
    return_value_gettext$3=gettext("Disconnect");
    g_object_set((void *)gm_app_view_update_connect_button$$1$$action, "label", return_value_gettext$3, (void *)0);
    char *return_value_gettext$4;
    return_value_gettext$4=gettext("Disconnect the current world");
    g_object_set((void *)gm_app_view_update_connect_button$$1$$action, "tooltip", return_value_gettext$4, (void *)0);
  }
}

// gm_app_view_update_title
// file widgets/gm-app-view.c line 844
void gm_app_view_update_title(struct _GmAppView *view)
{
  char *title;
  struct _GmWorld *world;
  world=gm_app_view_active_world(view);
  if(world == ((struct _GmWorld *)NULL))
  {
    unsigned long int return_value_gtk_window_get_type$1;
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, "GnoeMoe");
  }

  else
  {
    const char *return_value_gm_world_name$3;
    return_value_gm_world_name$3=gm_world_name(world);
    title=g_strconcat(return_value_gm_world_name$3, (const void *)" - GnoeMoe", (void *)0);
    unsigned long int return_value_gtk_window_get_type$4;
    return_value_gtk_window_get_type$4=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$4);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, title);
    g_free((void *)title);
  }
}

// gm_app_view_update_tray
// file widgets/gm-app-view.c line 901
void gm_app_view_update_tray(struct _GmAppView *view)
{
  struct _GList *worlds;
  struct _GmWorld *world;
  char *tmp;
  signed int active;
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  active=gtk_window_is_active((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
  signed int activity;
  struct _GString *str = (struct _GString *)(void *)0;
  enum _GmTrayState return_value_gm_tray_get_state$9;
  if(!(view->priv->tray == ((struct _GmTray *)NULL)))
  {
    if(active == 0)
    {
      worlds=gm_app_worlds(view->priv->application);
      for( ; !(worlds == ((struct _GList *)NULL)); worlds = worlds->next)
      {
        unsigned long int return_value_gm_world_get_type$3;
        return_value_gm_world_get_type$3=gm_world_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)worlds->data, return_value_gm_world_get_type$3);
        world = (struct _GmWorld *)return_value_g_type_check_instance_cast$4;
        activity=gm_world_activity(world);
        signed int return_value_gm_world_loaded$8;
        return_value_gm_world_loaded$8=gm_world_loaded(world);
        if(!(return_value_gm_world_loaded$8 == 0))
        {
          if(!(activity == 0))
          {
            if(str == ((struct _GString *)NULL))
            {
              char *return_value_gettext$5;
              return_value_gettext$5=gettext("Activity in:\n%s (%d)");
              const char *return_value_gm_world_name$6;
              return_value_gm_world_name$6=gm_world_name(world);
              tmp=g_strdup_printf(return_value_gettext$5, return_value_gm_world_name$6, activity);
              str=g_string_new((const char *)(void *)0);
            }

            else
            {
              const char *return_value_gm_world_name$7;
              return_value_gm_world_name$7=gm_world_name(world);
              tmp=g_strdup_printf(", %s (%d)", return_value_gm_world_name$7, activity);
            }
            str=g_string_append(str, tmp);
            g_free((void *)tmp);
          }

        }

      }
      if(!(str == ((struct _GString *)NULL)))
        gm_tray_activate(view->priv->tray);

      else
      {
        return_value_gm_tray_get_state$9=gm_tray_get_state(view->priv->tray);
        if(!((signed int)return_value_gm_tray_get_state$9 == TRAY_STATE_NOTIFY))
          gm_tray_normal(view->priv->tray);

      }
      enum _GmTrayState return_value_gm_tray_get_state$10;
      return_value_gm_tray_get_state$10=gm_tray_get_state(view->priv->tray);
      if(!((signed int)return_value_gm_tray_get_state$10 == TRAY_STATE_NOTIFY))
      {
        if(!(str == ((struct _GString *)NULL)))
          gm_tray_set_tip(view->priv->tray, str->str);

        else
          gm_tray_set_tip(view->priv->tray, (const char *)(void *)0);
      }

      if(!(str == ((struct _GString *)NULL)))
        g_string_free(str, (signed int)!(0 != 0));

    }

    else
      gm_tray_normal(view->priv->tray);
  }

}

// gm_app_view_window_state_event
// file widgets/gm-app-view.c line 279
static signed int gm_app_view_window_state_event(struct _GtkWidget *widget, struct _GdkEventWindowState *event)
{
  struct _GmAppView *view;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_app_view_get_type$1);
  view = (struct _GmAppView *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_object_get_type$4;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  if(!((GDK_WINDOW_STATE_MAXIMIZED & (signed int)event->changed_mask) == 0))
  {
    return_value_gtk_object_get_type$4=gtk_object_get_type();
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_object_get_type$4);
    if(!((256u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$5)->flags) == 0u))
    {
      struct _GmOptions *return_value_gm_app_options$3;
      return_value_gm_app_options$3=gm_app_options(view->priv->application);
      gm_options_set_int(return_value_gm_app_options$3, "maximized", (signed int)(((signed int)event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) != 0));
    }

  }

  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$9;
  return_value_g_type_check_class_cast$9=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$8);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$9)->window_state_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventWindowState *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$6;
    return_value_gtk_widget_get_type$6=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$7;
    return_value_g_type_check_class_cast$7=g_type_check_class_cast((struct _GTypeClass *)gm_app_view_parent_class, return_value_gtk_widget_get_type$6);
    signed int return_value;
    return_value=((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$7)->window_state_event(widget, event);
    return return_value;
  }

  return 0;
}

// gm_app_view_world_view_from_world
// file widgets/gm-app-view.c line 981
struct _GmWorldView * gm_app_view_world_view_from_world(struct _GmAppView *view, struct _GmWorld *world)
{
  struct _GtkNotebook *book = view->priv->notebook;
  struct _GmWorldView *current_view;
  signed int i = 0;
  signed int return_value_gtk_notebook_get_n_pages$1;
  do
  {
    return_value_gtk_notebook_get_n_pages$1=gtk_notebook_get_n_pages(book);
    if(i >= return_value_gtk_notebook_get_n_pages$1)
      break;

    struct _GtkWidget *return_value_gtk_notebook_get_nth_page$2;
    return_value_gtk_notebook_get_nth_page$2=gtk_notebook_get_nth_page(book, i);
    unsigned long int return_value_gm_world_view_get_type$3;
    return_value_gm_world_view_get_type$3=gm_world_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_notebook_get_nth_page$2, return_value_gm_world_view_get_type$3);
    current_view = (struct _GmWorldView *)return_value_g_type_check_instance_cast$4;
    struct _GmWorld *return_value_gm_world_view_world$5;
    return_value_gm_world_view_world$5=gm_world_view_world(current_view);
    if(return_value_gm_world_view_world$5 == world)
      return current_view;

    i = i + 1;
  }
  while((_Bool)1);
  return (struct _GmWorldView *)(void *)0;
}

// gm_app_view_worlds_loaded
// file widgets/gm-app-view.c line 894
void gm_app_view_worlds_loaded(struct _GmAppView *view)
{
  gm_app_view_set_sensitivity(view, (signed int)!(0 != 0));
  struct _GtkAction *return_value_gm_app_view_action$1;
  return_value_gm_app_view_action$1=gm_app_view_action(view, "/MenuBar/EditMenu/EditReplaceMenu");
  gtk_action_set_sensitive(return_value_gm_app_view_action$1, 0);
}

// gm_app_view_worlds_unloaded
// file widgets/gm-app-view.c line 887
void gm_app_view_worlds_unloaded(struct _GmAppView *view)
{
  gm_app_view_set_sensitivity(view, 0);
  gm_app_view_update_connect_button(view, 0);
  gm_app_view_update_title(view);
}

// gm_app_world_by_name
// file ./gm-app.h line 71
struct _GmWorld * gm_app_world_by_name(struct _GmApp *app, char *name)
{
  struct _GList *elem;
  const char *world_name;
  elem = app->priv->worlds;
  for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
  {
    unsigned long int return_value_gm_world_get_type$1;
    return_value_gm_world_get_type$1=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)elem->data, return_value_gm_world_get_type$1);
    world_name=gm_world_name((struct _GmWorld *)return_value_g_type_check_instance_cast$2);
    signed int return_value_g_strcasecmp$5;
    return_value_g_strcasecmp$5=g_strcasecmp(name, world_name);
    if(return_value_g_strcasecmp$5 == 0)
    {
      unsigned long int return_value_gm_world_get_type$3;
      return_value_gm_world_get_type$3=gm_world_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)elem->data, return_value_gm_world_get_type$3);
      return (struct _GmWorld *)return_value_g_type_check_instance_cast$4;
    }

  }
  return (struct _GmWorld *)(void *)0;
}

// gm_app_worlds
// file ./gm-app.h line 69
struct _GList * gm_app_worlds(struct _GmApp *app)
{
  struct _GList *return_value_g_list_copy$1;
  return_value_g_list_copy$1=g_list_copy(app->priv->worlds);
  return return_value_g_list_copy$1;
}

// gm_app_worlds_path
// file gm-app.c line 606
const char * gm_app_worlds_path(struct _GmApp *app)
{
  return app->priv->worlds_path;
}

// gm_cell_renderer_text_class_init
// file mcp/gm-cell-renderer-text.c line 46
static void gm_cell_renderer_text_class_init(struct _GmCellRendererTextClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GtkCellRendererClass *cell_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  unsigned long int return_value_gtk_cell_renderer_get_type$2;
  return_value_gtk_cell_renderer_get_type$2=gtk_cell_renderer_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_cell_renderer_get_type$2);
  cell_class = (struct _GtkCellRendererClass *)return_value_g_type_check_class_cast$3;
  parent_class$link4=g_type_class_peek_parent((void *)klass);
  object_class->finalize = cell_renderer_text_finalize;
  object_class->get_property = cell_renderer_text_get_property;
  object_class->set_property = cell_renderer_text_set_property;
  cell_class->get_size = cell_renderer_text_get_size;
  cell_class->render = cell_renderer_text_render;
  struct _GParamSpec *return_value_g_param_spec_string$4;
  return_value_g_param_spec_string$4=g_param_spec_string("name", "Name", "Player name", (const char *)(void *)0, (enum anonymous$5)G_PARAM_READWRITE);
  g_object_class_install_property(object_class, (unsigned int)1, return_value_g_param_spec_string$4);
  struct _GParamSpec *return_value_g_param_spec_string$5;
  return_value_g_param_spec_string$5=g_param_spec_string("status", "Status", "Contact status string", (const char *)(void *)0, (enum anonymous$5)G_PARAM_READWRITE);
  g_object_class_install_property(object_class, (unsigned int)2, return_value_g_param_spec_string$5);
  g_type_class_add_private((void *)object_class, sizeof(struct _GmCellRendererTextPrivate) /*24ul*/ );
}

// gm_cell_renderer_text_class_intern_init
// file mcp/gm-cell-renderer-text.c line 41
static void gm_cell_renderer_text_class_intern_init(void *klass)
{
  gm_cell_renderer_text_parent_class=g_type_class_peek_parent(klass);
  if(!(GmCellRendererText_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmCellRendererText_private_offset);

  gm_cell_renderer_text_class_init((struct _GmCellRendererTextClass *)klass);
}

// gm_cell_renderer_text_get_type
// file mcp/gm-cell-renderer-text.c line 41
unsigned long int gm_cell_renderer_text_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_cell_renderer_text_get_type$1;
    return_value_gtk_cell_renderer_text_get_type$1=gtk_cell_renderer_text_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmCellRendererText");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_cell_renderer_text_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmCellRendererTextClass) /*264ul*/ , (void (*)(void *, void *))gm_cell_renderer_text_class_intern_init, (unsigned int)sizeof(struct _GmCellRendererText) /*128ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_cell_renderer_text_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_cell_renderer_text_init
// file mcp/gm-cell-renderer-text.c line 74
static void gm_cell_renderer_text_init(struct _GmCellRendererText *cell)
{
  unsigned long int return_value_gm_cell_renderer_text_get_type$1;
  return_value_gm_cell_renderer_text_get_type$1=gm_cell_renderer_text_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)cell, return_value_gm_cell_renderer_text_get_type$1);
  cell->priv = (struct _GmCellRendererTextPrivate *)return_value_g_type_instance_get_private$2;
  cell->priv->name=g_strdup("");
  cell->priv->status=g_strdup("");
}

// gm_cell_renderer_text_new
// file mcp/gm-cell-renderer-text.h line 41
struct _GtkCellRenderer * gm_cell_renderer_text_new(void)
{
  unsigned long int return_value_gm_cell_renderer_text_get_type$1;
  return_value_gm_cell_renderer_text_get_type$1=gm_cell_renderer_text_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_cell_renderer_text_get_type$1, (const char *)(void *)0);
  return (struct _GtkCellRenderer *)return_value_g_object_new$2;
}

// gm_color_table_class_init
// file gm-color-table.c line 256
static void gm_color_table_class_init(struct _GmColorTableClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_color_table_finalize;
  color_table_signals[(signed long int)0]=g_signal_new("color_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)136ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  color_table_signals[(signed long int)1]=g_signal_new("font_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)144ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmColorTablePrivate) /*40ul*/ );
}

// gm_color_table_class_intern_init
// file gm-color-table.c line 245
static void gm_color_table_class_intern_init(void *klass)
{
  gm_color_table_parent_class=g_type_class_peek_parent(klass);
  if(!(GmColorTable_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmColorTable_private_offset);

  gm_color_table_class_init((struct _GmColorTableClass *)klass);
}

// gm_color_table_connect_font_changed
// file gm-color-table.c line 381
static void gm_color_table_connect_font_changed(struct _GmColorTable *table)
{
  struct _GError *err;
  struct _GConfClient *conf;
  unsigned int connection_id;
  conf=gconf_client_get_default();
  err = (struct _GError *)(void *)0;
  gconf_client_add_dir(conf, "/desktop/gnome/interface", (enum anonymous$63)GCONF_CLIENT_PRELOAD_ONELEVEL, &err);
  if(!(err == ((struct _GError *)NULL)))
  {
    gm_debug_msg(DEBUG_DEFAULT, "There was an error loading config from %s. (%s)\n", (const void *)"/desktop/gnome/interface", err->message);
    g_error_free(err);
  }

  err = (struct _GError *)(void *)0;
  connection_id=gconf_client_notify_add(conf, "/desktop/gnome/interface", on_gm_color_table_monospace_font_change_notify, (void *)table, (void (*)(void *))(void *)0, &err);
  g_object_unref((void *)conf);
  if(!(err == ((struct _GError *)NULL)))
  {
    gm_debug_msg(DEBUG_DEFAULT, "There was an error subscribing to notification of monospace font changes. (%s)\n", err->message);
    g_error_free(err);
  }

  else
    table->priv->gconf_connection_id = connection_id;
}

// gm_color_table_default_font
// file gm-color-table.c line 324
static char * gm_color_table_default_font(struct _GmColorTable *table)
{
  struct _GConfClient *conf;
  conf=gconf_client_get_default();
  char *name;
  name=gconf_client_get_string(conf, "/desktop/gnome/interface/monospace_font_name", (struct _GError **)(void *)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)conf, (unsigned long int)(20 << 2));
  g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1);
  if(!(name == ((char *)NULL)))
    return name;

  else
  {
    char *return_value_g_strdup$2;
    return_value_g_strdup$2=g_strdup("Monospace 10");
    return return_value_g_strdup$2;
  }
}

// gm_color_table_disconnect_font_changed
// file gm-color-table.c line 368
static void gm_color_table_disconnect_font_changed(struct _GmColorTable *table)
{
  struct _GConfClient *conf;
  if(!(table->priv->gconf_connection_id == 0u))
  {
    conf=gconf_client_get_default();
    gconf_client_notify_remove(conf, table->priv->gconf_connection_id);
    gconf_client_remove_dir(conf, "/desktop/gnome/interface", (struct _GError **)(void *)0);
    table->priv->gconf_connection_id = (unsigned int)0;
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)conf, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1);
  }

}

// gm_color_table_fill_from_options
// file gm-color-table.c line 338
static void gm_color_table_fill_from_options(struct _GmColorTable *table)
{
  const char *value;
  signed int vint;
  char *font;
  struct _GmOptions *options = table->priv->options;
  value=gm_options_get(options, "color_scheme");
  gm_color_table_set_from_scheme_name(table, value);
  value=gm_options_get(options, "use_system_font");
  vint=gm_options_get_int(options, "use_system_font");
  _Bool tmp_if_expr$1;
  if(value == ((const char *)NULL) || !(vint == 0))
    gm_color_table_set_use_system_font(table, (signed int)!(0 != 0));

  else
  {
    value=gm_options_get(options, "font_family");
    if(value == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      font=gm_color_table_default_font(table);
      gm_options_set(options, "font_family", font);
      g_free((void *)font);
      value=gm_options_get(options, "font_family");
    }

    gm_color_table_set_font_description(table, value);
  }
}

// gm_color_table_finalize
// file gm-color-table.c line 248
static void gm_color_table_finalize(struct _GObject *object)
{
  struct _GmColorTable *table;
  unsigned long int return_value_gm_color_table_get_type$1;
  return_value_gm_color_table_get_type$1=gm_color_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_color_table_get_type$1);
  table = (struct _GmColorTable *)return_value_g_type_check_instance_cast$2;
  gm_color_table_disconnect_font_changed(table);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_color_table_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_color_table_font_description
// file ./gm-color-table.h line 78
const char * gm_color_table_font_description(struct _GmColorTable *table)
{
  return table->priv->font_description;
}

// gm_color_table_get
// file ./gm-color-table.h line 72
signed int gm_color_table_get(struct _GmColorTable *table, const char *name, struct _GdkColor *color)
{
  struct _GmColorTableItem *item;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(table->priv->colors, (const void *)name);
  item = (struct _GmColorTableItem *)return_value_g_hash_table_lookup$1;
  if(!(item == ((struct _GmColorTableItem *)NULL)))
  {
    *color = item->color;
    return (signed int)!(0 != 0);
  }

  else
    return 0;
}

// gm_color_table_get_hex
// file ./gm-color-table.h line 74
const char * gm_color_table_get_hex(struct _GmColorTable *table, const char *name)
{
  struct _GmColorTableItem *item;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(table->priv->colors, (const void *)name);
  item = (struct _GmColorTableItem *)return_value_g_hash_table_lookup$1;
  if(!(item == ((struct _GmColorTableItem *)NULL)))
    return item->hex;

  else
    return ((const char *)NULL);
}

// gm_color_table_get_scheme_name
// file ./gm-color-table.h line 88
const char * gm_color_table_get_scheme_name(struct _GmColorTable *table)
{
  signed int i = 0;
  for( ; !(scheme_names[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    if(scheme_names[(signed long int)i].scheme == table->priv->scheme)
      return scheme_names[(signed long int)i].name;

  return (const char *)(void *)0;
}

// gm_color_table_get_type
// file ./gm-color-table.h line 64
unsigned long int gm_color_table_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmColorTable");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmColorTableClass) /*152ul*/ , (void (*)(void *, void *))gm_color_table_class_intern_init, (unsigned int)sizeof(struct _GmColorTable) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_color_table_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_color_table_get_use_system_font
// file ./gm-color-table.h line 82
signed int gm_color_table_get_use_system_font(struct _GmColorTable *table)
{
  return table->priv->use_system_font;
}

// gm_color_table_init
// file gm-color-table.c line 287
static void gm_color_table_init(struct _GmColorTable *table)
{
  unsigned long int return_value_gm_color_table_get_type$1;
  return_value_gm_color_table_get_type$1=gm_color_table_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)table, return_value_gm_color_table_get_type$1);
  table->priv = (struct _GmColorTablePrivate *)return_value_g_type_instance_get_private$2;
  table->priv->colors=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, gm_color_table_item_free);
  table->priv->scheme = (enum _GmColorTableScheme)SCHEME_NONE;
}

// gm_color_table_item_free
// file gm-color-table.c line 296
static void gm_color_table_item_free(void *item)
{
  struct _GmColorTableItem *i = (struct _GmColorTableItem *)item;
  g_free((void *)i->hex);
  g_free((void *)i);
}

// gm_color_table_load_scheme
// file ./gm-color-table.h line 84
void gm_color_table_load_scheme(struct _GmColorTable *table, enum _GmColorTableScheme scheme)
{
  unsigned int i = (unsigned int)0;
  const struct _GmColorTableSchemeItem *values;
  struct _GmOptions *options = table->priv->options;
  const char *value;
  if((signed int)scheme == SCHEME_USER && !(options == ((struct _GmOptions *)NULL)))
  {
    values = scheme_names[(signed long int)SCHEME_DEFAULT].values;
    for( ; !((values + (signed long int)i)->name == ((const char *)NULL)); i = i + 1u)
    {
      value=gm_options_get(options, (values + (signed long int)i)->name);
      if(!(value == ((const char *)NULL)))
        gm_color_table_set_value(table, (values + (signed long int)i)->name, value);

      else
      {
        gm_options_set(options, (values + (signed long int)i)->name, (values + (signed long int)i)->hex);
        gm_color_table_set_value(table, (values + (signed long int)i)->name, (values + (signed long int)i)->hex);
      }
    }
  }

  else
    if(!((signed int)scheme == SCHEME_USER))
    {
      values = scheme_names[(signed long int)scheme].values;
      for( ; !((values + (signed long int)i)->name == ((const char *)NULL)); i = i + 1u)
        gm_color_table_set_value(table, (values + (signed long int)i)->name, (values + (signed long int)i)->hex);
    }

  table->priv->scheme = scheme;
}

// gm_color_table_new
// file ./gm-color-table.h line 66
struct _GmColorTable * gm_color_table_new(void)
{
  struct _GmColorTable *table;
  unsigned long int return_value_gm_color_table_get_type$1;
  return_value_gm_color_table_get_type$1=gm_color_table_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_color_table_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_color_table_get_type$3;
  return_value_gm_color_table_get_type$3=gm_color_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_color_table_get_type$3);
  table = (struct _GmColorTable *)return_value_g_type_check_instance_cast$4;
  gm_color_table_load_scheme(table, (enum _GmColorTableScheme)SCHEME_DEFAULT);
  gm_color_table_set_use_system_font(table, (signed int)!(0 != 0));
  return table;
}

// gm_color_table_new_from_options
// file ./gm-color-table.h line 67
struct _GmColorTable * gm_color_table_new_from_options(char *filename)
{
  struct _GmColorTable *table;
  unsigned long int return_value_gm_color_table_get_type$1;
  return_value_gm_color_table_get_type$1=gm_color_table_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_color_table_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_color_table_get_type$3;
  return_value_gm_color_table_get_type$3=gm_color_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_color_table_get_type$3);
  table = (struct _GmColorTable *)return_value_g_type_check_instance_cast$4;
  table->priv->options=gm_options_new();
  gm_options_set(table->priv->options, "color_scheme", "default");
  _gm_options_check_old_options(filename);
  gm_options_load(table->priv->options, filename);
  gm_color_table_fill_from_options(table);
  return table;
}

// gm_color_table_save
// file ./gm-color-table.h line 68
void gm_color_table_save(struct _GmColorTable *table)
{
  if(!(table->priv->options == ((struct _GmOptions *)NULL)))
    gm_options_save(table->priv->options);

}

// gm_color_table_set
// file ./gm-color-table.h line 70
void gm_color_table_set(struct _GmColorTable *table, const char *name, const char *hex)
{
  const struct _GmColorTableSchemeItem *item;
  struct _GmColorTableItem *it;
  if(!((signed int)table->priv->scheme == SCHEME_USER))
  {
    table->priv->scheme = (enum _GmColorTableScheme)SCHEME_USER;
    if(!(table->priv->options == ((struct _GmOptions *)NULL)))
    {
      gm_options_set(table->priv->options, "color_scheme", scheme_names[(signed long int)SCHEME_USER].name);
      item = scheme_default;
      for( ; !(item->name == ((const char *)NULL)); item = item + 1l)
      {
        void *return_value_g_hash_table_lookup$1;
        return_value_g_hash_table_lookup$1=g_hash_table_lookup(table->priv->colors, (const void *)item->name);
        it = (struct _GmColorTableItem *)return_value_g_hash_table_lookup$1;
        gm_options_set(table->priv->options, item->name, it->hex);
      }
    }

  }

  if(!(table->priv->options == ((struct _GmOptions *)NULL)))
    gm_options_set(table->priv->options, name, hex);

  gm_color_table_set_value(table, name, hex);
}

// gm_color_table_set_font_description
// file ./gm-color-table.h line 76
void gm_color_table_set_font_description(struct _GmColorTable *table, const char *font_description)
{
  char *fd;
  if(font_description == ((const char *)NULL))
    fd=gm_color_table_default_font(table);

  else
    if(!(table->priv->use_system_font == 0))
      goto __CPROVER_DUMP_L8;

    else
      fd=g_strdup(font_description);
  if(!(table->priv->options == ((struct _GmOptions *)NULL)))
    gm_options_set(table->priv->options, "font_family", fd);

  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(table->priv->font_description == ((char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strcmp$1=strcmp(table->priv->font_description, fd);
    tmp_if_expr$2 = return_value_strcmp$1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    g_free((void *)table->priv->font_description);
    table->priv->font_description=g_strdup(fd);
    g_signal_emit((void *)table, color_table_signals[(signed long int)1], (unsigned int)0, table->priv->font_description);
  }

  g_free((void *)fd);

__CPROVER_DUMP_L8:
  ;
}

// gm_color_table_set_from_scheme_name
// file ./gm-color-table.h line 86
void gm_color_table_set_from_scheme_name(struct _GmColorTable *table, const char *scheme)
{
  signed int i = 0;
  while(!(scheme_names[(signed long int)i].name == ((const char *)NULL)))
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(scheme_names[(signed long int)i].name, scheme);
    if(return_value_strcasecmp$1 == 0)
    {
      gm_color_table_load_scheme(table, scheme_names[(signed long int)i].scheme);
      break;
    }

    i = i + 1;
  }
  if(scheme_names[(signed long int)i].name == ((const char *)NULL))
  {
    gm_color_table_load_scheme(table, (enum _GmColorTableScheme)SCHEME_DEFAULT);
    if(!(table->priv->options == ((struct _GmOptions *)NULL)))
      gm_options_set(table->priv->options, "color_scheme", "default");

  }

  else
    if(!(table->priv->options == ((struct _GmOptions *)NULL)))
      gm_options_set(table->priv->options, "color_scheme", scheme_names[(signed long int)i].name);

}

// gm_color_table_set_use_system_font
// file ./gm-color-table.h line 80
void gm_color_table_set_use_system_font(struct _GmColorTable *table, signed int use_system_font)
{
  if(!(table->priv->use_system_font == use_system_font))
  {
    table->priv->use_system_font = use_system_font;
    if(!(use_system_font == 0))
    {
      gm_color_table_connect_font_changed(table);
      gm_color_table_set_font_description(table, (const char *)(void *)0);
      if(!(table->priv->options == ((struct _GmOptions *)NULL)))
        gm_options_set(table->priv->options, "use_system_font", "1");

    }

    else
    {
      gm_color_table_disconnect_font_changed(table);
      if(!(table->priv->options == ((struct _GmOptions *)NULL)))
        gm_options_set(table->priv->options, "use_system_font", "0");

    }
  }

}

// gm_color_table_set_value
// file gm-color-table.c line 304
static void gm_color_table_set_value(struct _GmColorTable *table, const char *name, const char *hex)
{
  struct _GmColorTableItem *item;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(table->priv->colors, (const void *)name);
  item = (struct _GmColorTableItem *)return_value_g_hash_table_lookup$1;
  if(item == ((struct _GmColorTableItem *)NULL))
  {
    void *return_value_g_malloc0_n$2;
    return_value_g_malloc0_n$2=g_malloc0_n((unsigned long int)1, sizeof(struct _GmColorTableItem) /*24ul*/ );
    item = (struct _GmColorTableItem *)return_value_g_malloc0_n$2;
    char *return_value_g_strdup$3;
    return_value_g_strdup$3=g_strdup(name);
    g_hash_table_insert(table->priv->colors, (void *)return_value_g_strdup$3, (void *)item);
  }

  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  if(item->hex == ((char *)NULL))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strcmp$4=strcmp(hex, item->hex);
    tmp_if_expr$5 = return_value_strcmp$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    g_free((void *)item->hex);
    item->hex=g_strdup(hex);
    gdk_color_parse(item->hex, &item->color);
    g_signal_emit((void *)table, color_table_signals[(signed long int)0], (unsigned int)0, name);
  }

}

// gm_container_item
// file ./gm-support.h line 158
struct _GtkWidget * gm_container_item(struct _GtkContainer *cnt, unsigned long int type)
{
  struct _GList *child_first;
  child_first=gtk_container_get_children(cnt);
  struct _GList *child;
  struct _GtkWidget *result = (struct _GtkWidget *)(void *)0;
  child = child_first;
  signed int tmp_statement_expression$7;
  _Bool tmp_if_expr$8;
  signed int tmp_statement_expression$5;
  _Bool tmp_if_expr$6;
  for( ; !(child == ((struct _GList *)NULL)); child = child->next)
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)child->data;
    unsigned long int gm_container_item$$1$$1$$1$$1$$__t = type;
    signed int gm_container_item$$1$$1$$1$$1$$__r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      gm_container_item$$1$$1$$1$$1$$__r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$8 = __inst->g_class->g_type == gm_container_item$$1$$1$$1$$1$$__t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
        gm_container_item$$1$$1$$1$$1$$__r = (signed int)!(0 != 0);

      else
        gm_container_item$$1$$1$$1$$1$$__r=g_type_check_instance_is_a(__inst, gm_container_item$$1$$1$$1$$1$$__t);
    }
    tmp_statement_expression$7 = gm_container_item$$1$$1$$1$$1$$__r;
    if(!(tmp_statement_expression$7 == 0))
    {
      unsigned long int return_value_gtk_widget_get_type$1;
      return_value_gtk_widget_get_type$1=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)child->data, return_value_gtk_widget_get_type$1);
      result = (struct _GtkWidget *)return_value_g_type_check_instance_cast$2;
      break;
    }

    else
    {
      struct _GTypeInstance *gm_container_item$$1$$1$$1$$3$$__inst = (struct _GTypeInstance *)child->data;
      unsigned long int __t;
      __t=gtk_container_get_type();
      signed int __r;
      if(gm_container_item$$1$$1$$1$$3$$__inst == ((struct _GTypeInstance *)NULL))
        __r = 0;

      else
      {
        if(!(gm_container_item$$1$$1$$1$$3$$__inst->g_class == ((struct _GTypeClass *)NULL)))
          tmp_if_expr$6 = gm_container_item$$1$$1$$1$$3$$__inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
          __r = (signed int)!(0 != 0);

        else
          __r=g_type_check_instance_is_a(gm_container_item$$1$$1$$1$$3$$__inst, __t);
      }
      tmp_statement_expression$5 = __r;
      if(!(tmp_statement_expression$5 == 0))
      {
        unsigned long int return_value_gtk_container_get_type$3;
        return_value_gtk_container_get_type$3=gtk_container_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)child->data, return_value_gtk_container_get_type$3);
        result=gm_container_item((struct _GtkContainer *)return_value_g_type_check_instance_cast$4, type);
        if(!(result == ((struct _GtkWidget *)NULL)))
          break;

      }

    }
  }
  g_list_free(child_first);
  return result;
}

// gm_convert_with_fallback
// file gm-support.c line 627
char * gm_convert_with_fallback(const char *text, signed long int len, const char *from, const char *to, const char *fallback)
{
  char *res;
  unsigned long int read;
  unsigned long int written;
  struct _GString *str;
  str=g_string_new("");
  do
  {
    res=g_convert(text, len, to, from, &read, &written, (struct _GError **)(void *)0);
    if(!(res == ((char *)NULL)))
      break;

    res=g_convert(text, (signed long int)read, to, from, (unsigned long int *)(void *)0, (unsigned long int *)(void *)0, (struct _GError **)(void *)0);
    str=g_string_append(str, res);
    str=g_string_append(str, fallback);
    text = text + (signed long int)read + (signed long int)1;
    if(!(len == -1l))
      len = (signed long int)(((unsigned long int)len - read) - (unsigned long int)1);

  }
  while((_Bool)1);
  str=g_string_append(str, res);
  g_free((void *)res);
  res = str->str;
  g_string_free(str, 0);
  return res;
}

// gm_create_tab_label
// file ./gm-support.h line 144
struct _GtkWidget * gm_create_tab_label(const char *icon, const char *caption, signed int has_exit, struct _GmLabelInfo *info)
{
  struct _GtkWidget *hboxTabLabel;
  signed int h;
  signed int w;
  struct _GtkRcStyle *rcstyle;
  hboxTabLabel=gtk_hbox_new(0, 4);
  gtk_widget_show(hboxTabLabel);
  gtk_icon_size_lookup((enum anonymous$21)GTK_ICON_SIZE_MENU, &w, &h);
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$1;
  return_value_gm_pixbuf_get_at_size$1=gm_pixbuf_get_at_size(icon, w, h);
  info->image_icon=gtk_image_new_from_pixbuf(return_value_gm_pixbuf_get_at_size$1);
  gtk_widget_set_size_request(info->image_icon, w, h);
  gtk_widget_show(info->image_icon);
  unsigned long int return_value_gtk_box_get_type$2;
  return_value_gtk_box_get_type$2=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)hboxTabLabel, return_value_gtk_box_get_type$2);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$3, info->image_icon, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  info->label_name=gtk_label_new(caption);
  gtk_widget_show(info->label_name);
  unsigned long int return_value_gtk_box_get_type$4;
  return_value_gtk_box_get_type$4=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)hboxTabLabel, return_value_gtk_box_get_type$4);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$5, info->label_name, 0, 0, (unsigned int)0);
  if(!(has_exit == 0))
  {
    info->button_exit=gtk_button_new();
    gtk_widget_show(info->button_exit);
    unsigned long int return_value_gtk_box_get_type$6;
    return_value_gtk_box_get_type$6=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)hboxTabLabel, return_value_gtk_box_get_type$6);
    gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$7, info->button_exit, 0, 0, (unsigned int)0);
    unsigned long int return_value_gtk_button_get_type$8;
    return_value_gtk_button_get_type$8=gtk_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)info->button_exit, return_value_gtk_button_get_type$8);
    gtk_button_set_relief((struct _GtkButton *)return_value_g_type_check_instance_cast$9, (enum anonymous$94)GTK_RELIEF_NONE);
    unsigned long int return_value_gtk_button_get_type$10;
    return_value_gtk_button_get_type$10=gtk_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)info->button_exit, return_value_gtk_button_get_type$10);
    gtk_button_set_focus_on_click((struct _GtkButton *)return_value_g_type_check_instance_cast$11, 0);
    gtk_widget_set_size_request(info->button_exit, w + 2, h + 2);
    rcstyle=gtk_rc_style_new();
    rcstyle->ythickness = 0;
    rcstyle->xthickness = rcstyle->ythickness;
    gtk_widget_modify_style(info->button_exit, rcstyle);
    gtk_rc_style_unref(rcstyle);
    info->image_exit=gtk_image_new_from_stock("gtk-close", (enum anonymous$21)GTK_ICON_SIZE_MENU);
    gtk_widget_show(info->image_exit);
    unsigned long int return_value_gtk_container_get_type$12;
    return_value_gtk_container_get_type$12=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)info->button_exit, return_value_gtk_container_get_type$12);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$13, info->image_exit);
  }

  return hboxTabLabel;
}

// gm_debug_msg
// file ./gm-debug.h line 13
void gm_debug_msg(signed int level, char *line, ...)
{
  struct tm *timet;
  signed long int timer;
  void **args;
  pthread_mutex_lock(&mutex_debug);
  if((debug_level$link1 | level) == debug_level$link1)
  {
    args = (void **)&line;
    timer=time(((signed long int *)NULL));
    timet=localtime(&timer);
    if(!((DEBUG_ALWAYS & level) == 0))
      gm_debug_msg_real(stdout, timet, line, args);

    if(!((DEBUG_ALWAYS & level) == level))
      gm_debug_msg_real(stderr, timet, line, args);

    args = ((void **)NULL);
  }

  pthread_mutex_unlock(&mutex_debug);
}

// gm_debug_msg_real
// file gm-debug.c line 27
static void gm_debug_msg_real(struct _IO_FILE *f, struct tm *timet, char *line, void **args)
{
  fprintf(f, "[%02d:%02d:%02d] # ", timet->tm_hour, timet->tm_min, timet->tm_sec);
  vfprintf(f, line, args);
  fprintf(f, "\n");
}

// gm_debug_set_level
// file gm-debug.h line 14
void gm_debug_set_level(char *level)
{
  char **levels;
  char **iter;
  debug_level$link1 = DEBUG_ALWAYS;
  struct _LevelMap *map;
  if(!(level == ((char *)NULL)))
  {
    levels=g_strsplit(level, ",", -1);
    pthread_mutex_lock(&mutex_debug);
    iter = levels;
    for( ; !(*iter == ((char *)NULL)); iter = iter + 1l)
    {
      map = level_mapping;
      for( ; !(map->name == ((const char *)NULL)); map = map + 1l)
      {
        signed int return_value_strcasecmp$1;
        return_value_strcasecmp$1=strcasecmp(map->name, *iter);
        if(return_value_strcasecmp$1 == 0)
        {
          debug_level$link1 = debug_level$link1 | (signed int)map->level;
          break;
        }

      }
    }
    pthread_mutex_unlock(&mutex_debug);
    g_strfreev(levels);
  }

}

// gm_default_charset
// file gm-support.h line 147
const char * gm_default_charset()
{
  static const char *loc = (const char *)(void *)0;
  if(loc == ((const char *)NULL))
    g_get_charset(&loc);

  _Bool tmp_if_expr$1;
  if(loc == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*loc == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    loc = "ISO-8859-15";

  return loc;
}

// gm_dialog
// file gm-support.c line 124
signed int gm_dialog(char *message, enum anonymous$79 messagebox_type, signed int buttons_type, struct _GtkWindow *parent)
{
  struct _GtkWidget *dlg;
  signed int result;
  dlg=gtk_message_dialog_new(parent, (enum anonymous$154)(GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT), messagebox_type, (enum anonymous$152)buttons_type, message, (void *)0);
  unsigned long int return_value_gtk_dialog_get_type$1;
  return_value_gtk_dialog_get_type$1=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_dialog_get_type$1);
  result=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$2);
  gtk_widget_destroy(dlg);
  return result;
}

// gm_directory_remove_all
// file ./gm-support.h line 129
void gm_directory_remove_all(const char *path, signed int remove_self)
{
  struct _GDir *cDir;
  char *name;
  char *newPath;
  signed int return_value_g_file_test$2;
  return_value_g_file_test$2=g_file_test(path, (enum anonymous$106)G_FILE_TEST_IS_DIR);
  const char *return_value_g_dir_read_name$1;
  if(!(return_value_g_file_test$2 == 0))
  {
    cDir=g_dir_open(path, (unsigned int)0, (struct _GError **)(void *)0);
    if(!(cDir == ((struct _GDir *)NULL)))
    {
      do
      {
        return_value_g_dir_read_name$1=g_dir_read_name(cDir);
        name = (char *)return_value_g_dir_read_name$1;
        if(name == ((char *)NULL))
          break;

        newPath=g_strconcat(path, (const void *)"/", name, (void *)0);
        gm_directory_remove_all(newPath, (signed int)!(0 != 0));
        g_free((void *)newPath);
      }
      while((_Bool)1);
      g_dir_close(cDir);
    }

  }

  if(!(remove_self == 0))
    remove(path);

}

// gm_do_events
// file ./gm-support.h line 127
void gm_do_events()
{
  signed int return_value_gtk_events_pending$1;
  do
  {
    return_value_gtk_events_pending$1=gtk_events_pending();
    if(return_value_gtk_events_pending$1 == 0)
      break;

    gtk_main_iteration();
  }
  while((_Bool)1);
}

// gm_editor_class_init
// file gm-editor.c line 52
static void gm_editor_class_init(struct _GmEditorClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_editor_finalize;
  editor_signals[(signed long int)0]=g_signal_new("save", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)136ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  editor_signals[(signed long int)1]=g_signal_new("saved", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)144ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  editor_signals[(signed long int)2]=g_signal_new("close", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)152ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  g_type_class_add_private((void *)object_class, sizeof(struct _GmEditorPrivate) /*40ul*/ );
}

// gm_editor_class_intern_init
// file gm-editor.c line 37
static void gm_editor_class_intern_init(void *klass)
{
  gm_editor_parent_class=g_type_class_peek_parent(klass);
  if(!(GmEditor_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmEditor_private_offset);

  gm_editor_class_init((struct _GmEditorClass *)klass);
}

// gm_editor_close
// file ./gm-editor.h line 66
void gm_editor_close(struct _GmEditor *editor)
{
  g_signal_emit((void *)editor, editor_signals[(signed long int)2], (unsigned int)0);
}

// gm_editor_finalize
// file gm-editor.c line 40
static void gm_editor_finalize(struct _GObject *object)
{
  struct _GmEditor *editor;
  unsigned long int return_value_gm_editor_get_type$1;
  return_value_gm_editor_get_type$1=gm_editor_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_editor_get_type$1);
  editor = (struct _GmEditor *)return_value_g_type_check_instance_cast$2;
  g_free((void *)editor->priv->name);
  g_free((void *)editor->priv->upload_cmd);
  g_free((void *)editor->priv->mcp_type);
  gm_g_list_free_simple(editor->priv->lines);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_editor_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_editor_generate_filename
// file gm-editor.c line 191
char * gm_editor_generate_filename(struct _GmEditor *editor)
{
  char *filename;
  char *ptr;
  char *fptr;
  unsigned int c;
  unsigned int counter;
  filename=g_strdup(editor->priv->name);
  ptr = filename;
  fptr = filename;
  char *tmp_post$1;
  _Bool tmp_if_expr$4;
  signed int return_value_g_unichar_isalnum$3;
  while(!((signed int)*ptr == 0))
  {
    c=g_utf8_get_char(ptr);
    if(c == 32u)
    {
      tmp_post$1 = fptr;
      fptr = fptr + 1l;
      *tmp_post$1 = (char)95;
    }

    else
    {
      if(c == 46u || c == 58u || c == 95u)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_g_unichar_isalnum$3=g_unichar_isalnum(c);
        tmp_if_expr$4 = return_value_g_unichar_isalnum$3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
      {
        signed int return_value_g_unichar_to_utf8$2;
        return_value_g_unichar_to_utf8$2=g_unichar_to_utf8(c, fptr);
        fptr = fptr + (signed long int)return_value_g_unichar_to_utf8$2;
      }

    }
    ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
  }
  *fptr = (char)0;
  ptr = (char *)(void *)0;
  counter = (unsigned int)0;
  signed int return_value_g_file_test$5;
  for( ; (_Bool)1; counter = counter + 1u)
  {
    if(!(ptr == ((char *)NULL)))
    {
      return_value_g_file_test$5=g_file_test(ptr, (enum anonymous$106)G_FILE_TEST_EXISTS);
      if(return_value_g_file_test$5 == 0)
        goto __CPROVER_DUMP_L11;

    }

    g_free((void *)ptr);
    if(!(editor->priv->is_code == 0))
    {
      const char *return_value_g_get_tmp_dir$6;
      return_value_g_get_tmp_dir$6=g_get_tmp_dir();
      ptr=g_strdup_printf("%s/gnoemoe-edit.%s.%d.%s", return_value_g_get_tmp_dir$6, filename, counter, (const void *)"moo");
    }

    else
    {
      const char *return_value_g_get_tmp_dir$7;
      return_value_g_get_tmp_dir$7=g_get_tmp_dir();
      ptr=g_strdup_printf("%s/gnoemoe-edit.%s.%d.%s", return_value_g_get_tmp_dir$7, filename, counter, (const void *)"txt");
    }
  }

__CPROVER_DUMP_L11:
  ;
  g_free((void *)filename);
  return ptr;
}

// gm_editor_get_type
// file ./gm-editor.h line 55
unsigned long int gm_editor_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmEditor");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmEditorClass) /*160ul*/ , (void (*)(void *, void *))gm_editor_class_intern_init, (unsigned int)sizeof(struct _GmEditor) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_editor_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_editor_init
// file gm-editor.c line 89
static void gm_editor_init(struct _GmEditor *view)
{
  unsigned long int return_value_gm_editor_get_type$1;
  return_value_gm_editor_get_type$1=gm_editor_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)view, return_value_gm_editor_get_type$1);
  view->priv = (struct _GmEditorPrivate *)return_value_g_type_instance_get_private$2;
}

// gm_editor_is_code
// file ./gm-editor.h line 68
signed int gm_editor_is_code(struct _GmEditor *editor)
{
  return editor->priv->is_code;
}

// gm_editor_lines
// file ./gm-editor.h line 72
struct _GList * gm_editor_lines(struct _GmEditor *editor)
{
  return editor->priv->lines;
}

// gm_editor_lines_free
// file gm-editor.c line 122
void gm_editor_lines_free(struct _GmEditor *editor)
{
  gm_g_list_free_simple(editor->priv->lines);
  editor->priv->lines = (struct _GList *)(void *)0;
}

// gm_editor_mcp_type
// file ./gm-editor.h line 71
char * gm_editor_mcp_type(struct _GmEditor *editor)
{
  return editor->priv->mcp_type;
}

// gm_editor_name
// file ./gm-editor.h line 69
char * gm_editor_name(struct _GmEditor *editor)
{
  return editor->priv->name;
}

// gm_editor_new
// file gm-editor.h line 56
struct _GmEditor * gm_editor_new(char *name, char *uploadcmd, struct _GList *text)
{
  struct _GmEditor *editor;
  unsigned long int return_value_gm_editor_get_type$1;
  return_value_gm_editor_get_type$1=gm_editor_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_editor_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_editor_get_type$3;
  return_value_gm_editor_get_type$3=gm_editor_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_editor_get_type$3);
  editor = (struct _GmEditor *)return_value_g_type_check_instance_cast$4;
  editor->priv->name=g_strdup(name);
  editor->priv->upload_cmd=g_strdup(uploadcmd);
  editor->priv->mcp_type = (char *)(void *)0;
  editor->priv->lines=g_list_copy(text);
  editor->priv->type = (enum _GmEditType)E_LEGACY;
  signed int return_value_strncmp$5;
  return_value_strncmp$5=strncmp(uploadcmd, "@program", (unsigned long int)7);
  editor->priv->is_code = (signed int)(return_value_strncmp$5 == 0);
  return editor;
}

// gm_editor_new_mcp
// file ./gm-editor.h line 57
struct _GmEditor * gm_editor_new_mcp(char *name, char *reference, char *type, struct _GList *text)
{
  struct _GmEditor *editor;
  unsigned long int return_value_gm_editor_get_type$1;
  return_value_gm_editor_get_type$1=gm_editor_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_editor_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_editor_get_type$3;
  return_value_gm_editor_get_type$3=gm_editor_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_editor_get_type$3);
  editor = (struct _GmEditor *)return_value_g_type_check_instance_cast$4;
  editor->priv->name=g_strdup(name);
  editor->priv->upload_cmd=g_strdup(reference);
  editor->priv->mcp_type=g_strdup(type);
  editor->priv->lines=g_list_copy(text);
  editor->priv->type = (enum _GmEditType)E_LEGACY;
  signed int return_value_strcmp$5;
  return_value_strcmp$5=strcmp(type, "moo-code");
  editor->priv->is_code = (signed int)(return_value_strcmp$5 == 0);
  return editor;
}

// gm_editor_save
// file ./gm-editor.h line 64
void gm_editor_save(struct _GmEditor *editor)
{
  g_signal_emit((void *)editor, editor_signals[(signed long int)0], (unsigned int)0);
}

// gm_editor_saved
// file ./gm-editor.h line 65
void gm_editor_saved(struct _GmEditor *editor)
{
  g_signal_emit((void *)editor, editor_signals[(signed long int)1], (unsigned int)0);
}

// gm_editor_set_lines_from_file
// file ./gm-editor.h line 61
void gm_editor_set_lines_from_file(struct _GmEditor *editor, const char *filename)
{
  char *text;
  text=gm_read_file(filename);
  if(!(text == ((char *)NULL)))
  {
    gm_editor_set_lines_from_string(editor, text);
    g_free((void *)text);
  }

}

// gm_editor_set_lines_from_string
// file ./gm-editor.h line 60
void gm_editor_set_lines_from_string(struct _GmEditor *editor, const char *text)
{
  editor->priv->lines=gm_string_split(text);
}

// gm_editor_type
// file gm-editor.c line 171
enum _GmEditType gm_editor_type(struct _GmEditor *editor)
{
  return editor->priv->type;
}

// gm_editor_upload_cmd
// file ./gm-editor.h line 70
char * gm_editor_upload_cmd(struct _GmEditor *editor)
{
  return editor->priv->upload_cmd;
}

// gm_editor_view_class_init
// file widgets/gm-editor-view.c line 144
static void gm_editor_view_class_init(struct _GmEditorViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_editor_view_finalize;
  gm_editor_view_signals[(signed long int)0]=g_signal_new("modified_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)824ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__BOOLEAN, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(5 << 2));
  gm_editor_view_init_language();
  g_type_class_add_private((void *)object_class, sizeof(struct _GmEditorViewPrivate) /*24ul*/ );
}

// gm_editor_view_class_intern_init
// file widgets/gm-editor-view.c line 91
static void gm_editor_view_class_intern_init(void *klass)
{
  gm_editor_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmEditorView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmEditorView_private_offset);

  gm_editor_view_class_init((struct _GmEditorViewClass *)klass);
}

// gm_editor_view_create_source_view
// file widgets/gm-editor-view.c line 166
struct _GtkSourceView * gm_editor_view_create_source_view(struct _GmEditorView *view)
{
  struct _GtkTextBuffer *buffer;
  struct _GtkWidget *source_view;
  struct _GtkTextIter iter;
  char *line;
  struct _GList *lines;
  struct _PangoFontDescription *f;
  struct _GtkTextTag *st;
  source_view=gtk_source_view_new();
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)source_view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  if(!(language == ((struct _GtkSourceLanguage *)NULL)))
  {
    unsigned long int return_value_gtk_source_buffer_get_type$3;
    return_value_gtk_source_buffer_get_type$3=gtk_source_buffer_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)buffer, return_value_gtk_source_buffer_get_type$3);
    gtk_source_buffer_set_language((struct _GtkSourceBuffer *)return_value_g_type_check_instance_cast$4, language);
  }

  unsigned long int return_value_gtk_source_buffer_get_type$5;
  return_value_gtk_source_buffer_get_type$5=gtk_source_buffer_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)buffer, return_value_gtk_source_buffer_get_type$5);
  gtk_source_buffer_begin_not_undoable_action((struct _GtkSourceBuffer *)return_value_g_type_check_instance_cast$6);
  gtk_text_buffer_get_end_iter(buffer, &iter);
  struct _GmApp *return_value_gm_app_instance$7;
  return_value_gm_app_instance$7=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$8;
  return_value_gm_app_color_table$8=gm_app_color_table(return_value_gm_app_instance$7);
  gm_register_schemed(source_view, return_value_gm_app_color_table$8, (enum _GmSchemedFlags)(GM_SCHEMED_COLORS | GM_SCHEMED_FONT));
  lines=gm_editor_lines(view->priv->editor);
  for( ; !(lines == ((struct _GList *)NULL)); lines = lines->next)
  {
    line = (char *)lines->data;
    gtk_text_buffer_insert(buffer, &iter, line, -1);
    if(!(lines->next == ((struct _GList *)NULL)))
      gtk_text_buffer_insert(buffer, &iter, "\r\n", 2);

  }
  unsigned long int return_value_gtk_source_buffer_get_type$9;
  return_value_gtk_source_buffer_get_type$9=gtk_source_buffer_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)buffer, return_value_gtk_source_buffer_get_type$9);
  gtk_source_buffer_end_not_undoable_action((struct _GtkSourceBuffer *)return_value_g_type_check_instance_cast$10);
  gtk_text_buffer_set_modified(buffer, 0);
  st=gtk_text_tag_new((const char *)(void *)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)st, (unsigned long int)(20 << 2));
  g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$11, "background-set", !(0 != 0), (const void *)"background", (const void *)"#0000FF", (void *)0);
  unsigned long int return_value_gtk_source_buffer_get_type$12;
  return_value_gtk_source_buffer_get_type$12=gtk_source_buffer_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)buffer, return_value_gtk_source_buffer_get_type$12);
  unsigned long int return_value_gtk_source_style_scheme_get_type$14;
  return_value_gtk_source_style_scheme_get_type$14=gtk_source_style_scheme_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)st, return_value_gtk_source_style_scheme_get_type$14);
  gtk_source_buffer_set_style_scheme((struct _GtkSourceBuffer *)return_value_g_type_check_instance_cast$13, (struct _GtkSourceStyleScheme *)return_value_g_type_check_instance_cast$15);
  struct _GmApp *return_value_gm_app_instance$16;
  return_value_gm_app_instance$16=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$17;
  return_value_gm_app_color_table$17=gm_app_color_table(return_value_gm_app_instance$16);
  const char *return_value_gm_color_table_font_description$18;
  return_value_gm_color_table_font_description$18=gm_color_table_font_description(return_value_gm_app_color_table$17);
  f=pango_font_description_from_string(return_value_gm_color_table_font_description$18);
  if(!(f == ((struct _PangoFontDescription *)NULL)))
  {
    gtk_widget_modify_font(source_view, f);
    pango_font_description_free(f);
  }

  unsigned long int return_value_gtk_source_view_get_type$19;
  return_value_gtk_source_view_get_type$19=gtk_source_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)source_view, return_value_gtk_source_view_get_type$19);
  gtk_source_view_set_insert_spaces_instead_of_tabs((struct _GtkSourceView *)return_value_g_type_check_instance_cast$20, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_source_view_get_type$21;
  return_value_gtk_source_view_get_type$21=gtk_source_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)source_view, return_value_gtk_source_view_get_type$21);
  gtk_source_view_set_auto_indent((struct _GtkSourceView *)return_value_g_type_check_instance_cast$22, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_source_view_get_type$23;
  return_value_gtk_source_view_get_type$23=gtk_source_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)source_view, return_value_gtk_source_view_get_type$23);
  gtk_source_view_set_show_line_numbers((struct _GtkSourceView *)return_value_g_type_check_instance_cast$24, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_source_view_get_type$25;
  return_value_gtk_source_view_get_type$25=gtk_source_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)source_view, return_value_gtk_source_view_get_type$25);
  gtk_source_view_set_indent_width((struct _GtkSourceView *)return_value_g_type_check_instance_cast$26, 2);
  unsigned long int return_value_gtk_text_view_get_type$27;
  return_value_gtk_text_view_get_type$27=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)source_view, return_value_gtk_text_view_get_type$27);
  gtk_text_view_set_wrap_mode((struct _GtkTextView *)return_value_g_type_check_instance_cast$28, (enum anonymous$77)GTK_WRAP_WORD_CHAR);
  signed int return_value_gm_editor_is_code$35;
  return_value_gm_editor_is_code$35=gm_editor_is_code(view->priv->editor);
  if(!(return_value_gm_editor_is_code$35 == 0))
  {
    unsigned long int return_value_gtk_source_buffer_get_type$29;
    return_value_gtk_source_buffer_get_type$29=gtk_source_buffer_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
    return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)buffer, return_value_gtk_source_buffer_get_type$29);
    gtk_source_buffer_set_highlight_syntax((struct _GtkSourceBuffer *)return_value_g_type_check_instance_cast$30, (signed int)!(0 != 0));
  }

  else
  {
    unsigned long int return_value_gtk_source_buffer_get_type$31;
    return_value_gtk_source_buffer_get_type$31=gtk_source_buffer_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
    return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)buffer, return_value_gtk_source_buffer_get_type$31);
    gtk_source_buffer_set_highlight_syntax((struct _GtkSourceBuffer *)return_value_g_type_check_instance_cast$32, 0);
    unsigned long int return_value_gtk_source_buffer_get_type$33;
    return_value_gtk_source_buffer_get_type$33=gtk_source_buffer_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
    return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)buffer, return_value_gtk_source_buffer_get_type$33);
    gtk_source_buffer_set_highlight_matching_brackets((struct _GtkSourceBuffer *)return_value_g_type_check_instance_cast$34, 0);
  }
  g_signal_connect_data((void *)buffer, "modified_changed", (void (*)(void))on_gm_editor_view_modified_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  gtk_widget_show(source_view);
  unsigned long int return_value_gtk_source_view_get_type$36;
  return_value_gtk_source_view_get_type$36=gtk_source_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
  return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)source_view, return_value_gtk_source_view_get_type$36);
  return (struct _GtkSourceView *)return_value_g_type_check_instance_cast$37;
}

// gm_editor_view_editor
// file widgets/gm-editor-view.h line 57
struct _GmEditor * gm_editor_view_editor(struct _GmEditorView *view)
{
  return view->priv->editor;
}

// gm_editor_view_finalize
// file widgets/gm-editor-view.c line 110
static void gm_editor_view_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_editor_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_editor_view_get_type
// file widgets/gm-editor-view.h line 55
unsigned long int gm_editor_view_get_type(void)
{
  _Bool tmp_statement_expression$4;
  void *tmp_statement_expression$5;
  signed int return_value___atomic_load_8$6;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$6=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$5 = (void *)return_value___atomic_load_8$6;
  _Bool tmp_if_expr$8;
  signed int return_value_g_once_init_enter$7;
  if(tmp_statement_expression$5 == NULL)
  {
    return_value_g_once_init_enter$7=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$8 = return_value_g_once_init_enter$7 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  tmp_statement_expression$4 = tmp_if_expr$8;
  if(tmp_statement_expression$4)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_vbox_get_type$1;
    return_value_gtk_vbox_get_type$1=gtk_vbox_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmEditorView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_vbox_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmEditorViewClass) /*832ul*/ , (void (*)(void *, void *))gm_editor_view_class_intern_init, (unsigned int)sizeof(struct _GmEditorView) /*136ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_editor_view_init, (enum anonymous)0);
    const struct _GInterfaceInfo g_implement_interface_info = { .interface_init=(void (*)(void *, void *))gm_editor_view_searchable_iface_init, .interface_finalize=(void (*)(void *, void *))(void *)0,
    .interface_data=(void *)0 };
    unsigned long int return_value_gm_searchable_get_type$3;
    return_value_gm_searchable_get_type$3=gm_searchable_get_type();
    g_type_add_interface_static(g_define_type_id, return_value_gm_searchable_get_type$3, &g_implement_interface_info);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_editor_view_init
// file widgets/gm-editor-view.c line 365
static void gm_editor_view_init(struct _GmEditorView *obj)
{
  unsigned long int return_value_gm_editor_view_get_type$1;
  return_value_gm_editor_view_get_type$1=gm_editor_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_editor_view_get_type$1);
  obj->priv = (struct _GmEditorViewPrivate *)return_value_g_type_instance_get_private$2;
  unsigned long int return_value_gtk_box_get_type$3;
  return_value_gtk_box_get_type$3=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$3);
  gtk_box_set_spacing((struct _GtkBox *)return_value_g_type_check_instance_cast$4, 0);
  unsigned long int return_value_gtk_box_get_type$5;
  return_value_gtk_box_get_type$5=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$5);
  gtk_box_set_homogeneous((struct _GtkBox *)return_value_g_type_check_instance_cast$6, 0);
}

// gm_editor_view_init_language
// file widgets/gm-editor-view.c line 127
void gm_editor_view_init_language()
{
  struct _GtkSourceLanguageManager *manager;
  if(language == ((struct _GtkSourceLanguage *)NULL))
  {
    manager=gtk_source_language_manager_new();
    struct _GtkSourceLanguage *return_value_gtk_source_language_manager_get_language$1;
    return_value_gtk_source_language_manager_get_language$1=gtk_source_language_manager_get_language(manager, "moo");
    void *return_value_g_object_ref$2;
    return_value_g_object_ref$2=g_object_ref((void *)return_value_gtk_source_language_manager_get_language$1);
    language = (struct _GtkSourceLanguage *)return_value_g_object_ref$2;
    g_object_unref((void *)manager);
  }

}

// gm_editor_view_new
// file widgets/gm-editor-view.h line 56
struct _GmEditorView * gm_editor_view_new(struct _GmWorld *world, struct _GmEditor *editor)
{
  struct _GmEditorView *obj;
  unsigned long int return_value_gm_editor_view_get_type$1;
  return_value_gm_editor_view_get_type$1=gm_editor_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_editor_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_editor_view_get_type$3;
  return_value_gm_editor_view_get_type$3=gm_editor_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_editor_view_get_type$3);
  obj = (struct _GmEditorView *)return_value_g_type_check_instance_cast$4;
  struct _GtkWidget *srl;
  obj->priv->editor = editor;
  obj->priv->world = world;
  obj->priv->source_view=gm_editor_view_create_source_view(obj);
  srl=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  gtk_widget_show(srl);
  unsigned long int return_value_gtk_scrolled_window_get_type$5;
  return_value_gtk_scrolled_window_get_type$5=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)srl, return_value_gtk_scrolled_window_get_type$5);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$6, (enum anonymous$88)GTK_POLICY_AUTOMATIC, (enum anonymous$88)GTK_POLICY_AUTOMATIC);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)srl, return_value_gtk_container_get_type$7);
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)obj->priv->source_view, return_value_gtk_widget_get_type$9);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, (struct _GtkWidget *)return_value_g_type_check_instance_cast$10);
  unsigned long int return_value_gtk_box_get_type$11;
  return_value_gtk_box_get_type$11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$11);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$12, srl, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  struct _GmApp *return_value_gm_app_instance$13;
  return_value_gm_app_instance$13=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$14;
  return_value_gm_app_color_table$14=gm_app_color_table(return_value_gm_app_instance$13);
  g_signal_connect_data((void *)return_value_gm_app_color_table$14, "font_changed", (void (*)(void))on_gm_editor_view_font_changed, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)editor, "saved", (void (*)(void))on_gm_editor_view_editor_saved, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  return obj;
}

// gm_editor_view_save
// file widgets/gm-editor-view.h line 58
void gm_editor_view_save(struct _GmEditorView *view)
{
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->source_view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  char *text;
  gtk_text_buffer_get_bounds(buffer, &start, &end);
  text=gtk_text_buffer_get_text(buffer, &start, &end, 0);
  gm_editor_set_lines_from_string(view->priv->editor, text);
  g_free((void *)text);
  gm_editor_save(view->priv->editor);
}

// gm_editor_view_searchable_get_text_view
// file widgets/gm-editor-view.c line 101
static struct _GtkTextView * gm_editor_view_searchable_get_text_view(struct _GmSearchable *sea)
{
  struct _GmEditorView *view = (struct _GmEditorView *)sea;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)sea;
    unsigned long int __t;
    __t=gm_editor_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_editor_view_searchable_get_text_view", "GM_IS_EDITOR_VIEW(sea)");
      return (struct _GtkTextView *)(void *)0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gtk_text_view_get_type$3;
  return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->source_view, return_value_gtk_text_view_get_type$3);
  return (struct _GtkTextView *)return_value_g_type_check_instance_cast$4;
}

// gm_editor_view_searchable_iface_init
// file widgets/gm-editor-view.c line 96
static void gm_editor_view_searchable_iface_init(struct _GmSearchableInterface *iface)
{
  iface->get_text_view = gm_editor_view_searchable_get_text_view;
}

// gm_editor_view_text_view
// file widgets/gm-editor-view.c line 407
struct _GtkTextView * gm_editor_view_text_view(struct _GmEditorView *view)
{
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->source_view, return_value_gtk_text_view_get_type$1);
  return (struct _GtkTextView *)return_value_g_type_check_instance_cast$2;
}

// gm_editor_write_lines
// file ./gm-editor.h line 62
char * gm_editor_write_lines(struct _GmEditor *editor)
{
  char *tmp;
  tmp=gm_editor_generate_filename(editor);
  signed int fd;
  fd=open(tmp, 0100 | 02, 0400 | 0200 | 0400 >> 3);
  struct _GList *line;
  if(fd == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't open file: %s, %s", tmp, return_value_strerror$2);
    g_free((void *)tmp);
    return (char *)(void *)0;
  }

  line = editor->priv->lines;
  for( ; !(line == ((struct _GList *)NULL)); line = line->next)
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen((const char *)line->data);
    signed long int return_value_write$4;
    return_value_write$4=write(fd, line->data, return_value_strlen$3);
    if(return_value_write$4 == -1l)
    {
      gm_debug_msg(DEBUG_ALWAYS, "Writing failed");
      break;
    }

    signed long int return_value_write$5;
    return_value_write$5=write(fd, (const void *)"\n", (unsigned long int)1);
    if(return_value_write$5 == -1l)
    {
      gm_debug_msg(DEBUG_ALWAYS, "Writing failed");
      break;
    }

  }
  close(fd);
  return tmp;
}

// gm_embedded_view_class_init
// file widgets/gm-embedded-view.c line 71
static void gm_embedded_view_class_init(struct _GmEmbeddedViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_embedded_view_finalize;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmEmbeddedViewPrivate) /*48ul*/ );
}

// gm_embedded_view_class_intern_init
// file widgets/gm-embedded-view.c line 43
static void gm_embedded_view_class_intern_init(void *klass)
{
  gm_embedded_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmEmbeddedView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmEmbeddedView_private_offset);

  gm_embedded_view_class_init((struct _GmEmbeddedViewClass *)klass);
}

// gm_embedded_view_editor
// file widgets/gm-embedded-view.h line 57
struct _GmEditor * gm_embedded_view_editor(struct _GmEmbeddedView *view)
{
  return view->priv->editor;
}

// gm_embedded_view_finalize
// file widgets/gm-embedded-view.c line 46
static void gm_embedded_view_finalize(struct _GObject *object)
{
  struct _GmEmbeddedView *obj;
  unsigned long int return_value_gm_embedded_view_get_type$1;
  return_value_gm_embedded_view_get_type$1=gm_embedded_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_embedded_view_get_type$1);
  obj = (struct _GmEmbeddedView *)return_value_g_type_check_instance_cast$2;
  struct stat buf;
  if(!(obj->priv->monitor == ((struct GnomeVFSMonitorHandle *)NULL)))
    gnome_vfs_monitor_cancel(obj->priv->monitor);

  signed int tmp_statement_expression$4;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)obj->priv->editor;
  unsigned long int __t;
  __t=gm_editor_get_type();
  signed int __r;
  _Bool tmp_if_expr$5;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$5 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$4 = __r;
  if(!(tmp_statement_expression$4 == 0))
  {
    signed int return_value_stat$3;
    return_value_stat$3=stat(obj->priv->filename, &buf);
    if(!(return_value_stat$3 == -1))
    {
      if(!(obj->priv->last_modified >= buf.st_mtim.tv_sec))
        gm_editor_save(obj->priv->editor);

    }

  }

  if(!(obj->priv->filename == ((char *)NULL)))
  {
    unlink(obj->priv->filename);
    g_free((void *)obj->priv->filename);
  }

  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)gm_embedded_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$6)->finalize(object);
}

// gm_embedded_view_get_type
// file widgets/gm-embedded-view.h line 55
unsigned long int gm_embedded_view_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_hbox_get_type$1;
    return_value_gtk_hbox_get_type$1=gtk_hbox_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmEmbeddedView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_hbox_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmEmbeddedViewClass) /*824ul*/ , (void (*)(void *, void *))gm_embedded_view_class_intern_init, (unsigned int)sizeof(struct _GmEmbeddedView) /*136ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_embedded_view_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_embedded_view_init
// file widgets/gm-embedded-view.c line 90
static void gm_embedded_view_init(struct _GmEmbeddedView *obj)
{
  struct _GtkWidget *vte;
  struct _GtkWidget *vscroll;
  unsigned long int return_value_gm_embedded_view_get_type$1;
  return_value_gm_embedded_view_get_type$1=gm_embedded_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_embedded_view_get_type$1);
  obj->priv = (struct _GmEmbeddedViewPrivate *)return_value_g_type_instance_get_private$2;
  unsigned long int return_value_gtk_box_get_type$3;
  return_value_gtk_box_get_type$3=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$3);
  gtk_box_set_homogeneous((struct _GtkBox *)return_value_g_type_check_instance_cast$4, 0);
  unsigned long int return_value_gtk_box_get_type$5;
  return_value_gtk_box_get_type$5=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$5);
  gtk_box_set_spacing((struct _GtkBox *)return_value_g_type_check_instance_cast$6, 6);
  vte=vte_terminal_new();
  unsigned long int return_value_vte_terminal_get_type$7;
  return_value_vte_terminal_get_type$7=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$7);
  struct _GmApp *return_value_gm_app_instance$9;
  return_value_gm_app_instance$9=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$10;
  return_value_gm_app_color_table$10=gm_app_color_table(return_value_gm_app_instance$9);
  const char *return_value_gm_color_table_font_description$11;
  return_value_gm_color_table_font_description$11=gm_color_table_font_description(return_value_gm_app_color_table$10);
  vte_terminal_set_font_from_string((struct _VteTerminal *)return_value_g_type_check_instance_cast$8, return_value_gm_color_table_font_description$11);
  unsigned long int return_value_vte_terminal_get_type$12;
  return_value_vte_terminal_get_type$12=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$12);
  vte_terminal_set_scroll_on_keystroke((struct _VteTerminal *)return_value_g_type_check_instance_cast$13, (signed int)!(0 != 0));
  unsigned long int return_value_vte_terminal_get_type$14;
  return_value_vte_terminal_get_type$14=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$14);
  vte_terminal_set_scrollback_lines((struct _VteTerminal *)return_value_g_type_check_instance_cast$15, (signed long int)500);
  unsigned long int return_value_vte_terminal_get_type$16;
  return_value_vte_terminal_get_type$16=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$16);
  vte_terminal_set_scroll_on_output((struct _VteTerminal *)return_value_g_type_check_instance_cast$17, 0);
  unsigned long int return_value_vte_terminal_get_type$18;
  return_value_vte_terminal_get_type$18=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$18);
  vte_terminal_set_word_chars((struct _VteTerminal *)return_value_g_type_check_instance_cast$19, "-A-Za-z0-9,./?%&#:_");
  unsigned long int return_value_vte_terminal_get_type$20;
  return_value_vte_terminal_get_type$20=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$20);
  vte_terminal_set_allow_bold((struct _VteTerminal *)return_value_g_type_check_instance_cast$21, (signed int)!(0 != 0));
  unsigned long int return_value_vte_terminal_get_type$22;
  return_value_vte_terminal_get_type$22=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$22);
  vte_terminal_set_audible_bell((struct _VteTerminal *)return_value_g_type_check_instance_cast$23, (signed int)!(0 != 0));
  gtk_widget_show(vte);
  unsigned long int return_value_vte_terminal_get_type$24;
  return_value_vte_terminal_get_type$24=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$24);
  vscroll=gtk_vscrollbar_new(((struct _VteTerminal *)return_value_g_type_check_instance_cast$25)->adjustment);
  gtk_widget_show(vscroll);
  unsigned long int return_value_gtk_box_get_type$26;
  return_value_gtk_box_get_type$26=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$26);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$27, vte, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$28;
  return_value_gtk_box_get_type$28=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
  return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$28);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$29, vscroll, 0, 0, (unsigned int)0);
  struct _GmApp *return_value_gm_app_instance$30;
  return_value_gm_app_instance$30=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$31;
  return_value_gm_app_color_table$31=gm_app_color_table(return_value_gm_app_instance$30);
  g_signal_connect_data((void *)return_value_gm_app_color_table$31, "font_changed", (void (*)(void))on_gm_embedded_view_font_changed, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_vte_terminal_get_type$32;
  return_value_vte_terminal_get_type$32=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)vte, return_value_vte_terminal_get_type$32);
  obj->priv->vte = (struct _VteTerminal *)return_value_g_type_check_instance_cast$33;
}

// gm_embedded_view_new
// file widgets/gm-embedded-view.h line 56
struct _GmEmbeddedView * gm_embedded_view_new(struct _GmWorld *world, struct _GmEditor *editor)
{
  struct _GmEmbeddedView *obj;
  unsigned long int return_value_gm_embedded_view_get_type$1;
  return_value_gm_embedded_view_get_type$1=gm_embedded_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_embedded_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_embedded_view_get_type$3;
  return_value_gm_embedded_view_get_type$3=gm_embedded_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_embedded_view_get_type$3);
  obj = (struct _GmEmbeddedView *)return_value_g_type_check_instance_cast$4;
  char *cmd[4l] = { (char *)(void *)0, (char *)(void *)0, (char *)(void *)0, (char *)(void *)0 };
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$5;
  return_value_gm_app_instance$5=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$5);
  obj->priv->world = world;
  obj->priv->editor = editor;
  obj->priv->filename=gm_editor_write_lines(editor);
  gm_embedded_view_update_last_modified(obj);
  cmd[(signed long int)0]=gnome_util_user_shell();
  if(cmd[0l] == ((char *)NULL))
    cmd[(signed long int)0]=g_strdup("/bin/sh");

  cmd[(signed long int)1] = "-c";
  const char *return_value_gm_options_get$6;
  return_value_gm_options_get$6=gm_options_get(options, "editor_alternative");
  cmd[(signed long int)2]=g_strconcat(return_value_gm_options_get$6, (const void *)" ", obj->priv->filename, (void *)0);
  const char *return_value_g_get_home_dir$7;
  return_value_g_get_home_dir$7=g_get_home_dir();
  vte_terminal_fork_command(obj->priv->vte, cmd[(signed long int)0], cmd, (char **)(void *)0, return_value_g_get_home_dir$7, 0, (signed int)!(0 != 0), (signed int)!(0 != 0));
  g_free((void *)cmd[(signed long int)0]);
  g_free((void *)cmd[(signed long int)2]);
  gnome_vfs_monitor_add(&obj->priv->monitor, obj->priv->filename, (enum anonymous$101)GNOME_VFS_MONITOR_FILE, (void (*)(struct GnomeVFSMonitorHandle *, const char *, const char *, enum anonymous$102, void *))on_gm_embedded_view_file_changed, (void *)obj);
  g_signal_connect_data((void *)obj->priv->vte, "child-exited", (void (*)(void))on_gm_embedded_view_exited, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  return obj;
}

// gm_embedded_view_update_last_modified
// file widgets/gm-embedded-view.c line 123
void gm_embedded_view_update_last_modified(struct _GmEmbeddedView *embedded)
{
  struct stat buf;
  signed int return_value_stat$1;
  return_value_stat$1=stat(embedded->priv->filename, &buf);
  if(!(return_value_stat$1 == -1))
    embedded->priv->last_modified = buf.st_mtim.tv_sec;

}

// gm_error_dialog
// file ./gm-support.h line 122
signed int gm_error_dialog(char *message, struct _GtkWindow *parent)
{
  signed int return_value_gm_dialog$1;
  return_value_gm_dialog$1=gm_dialog(message, (enum anonymous$79)GTK_MESSAGE_ERROR, GTK_BUTTONS_OK, parent);
  return return_value_gm_dialog$1;
}

// gm_external_view_destroy
// file widgets/gm-external-view.h line 20
void gm_external_view_destroy(struct _GmExternalView *view)
{
  struct stat buf;
  if(!(view->monitor == ((struct GnomeVFSMonitorHandle *)NULL)))
    gnome_vfs_monitor_cancel(view->monitor);

  g_source_remove(view->child_watch);
  g_spawn_close_pid(view->pid);
  signed int tmp_statement_expression$2;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)view->editor;
  unsigned long int __t;
  __t=gm_editor_get_type();
  signed int __r;
  _Bool tmp_if_expr$3;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$3 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$2 = __r;
  if(!(tmp_statement_expression$2 == 0))
  {
    signed int return_value_stat$1;
    return_value_stat$1=stat(view->filename, &buf);
    if(!(return_value_stat$1 == -1))
    {
      if(!(view->last_modified >= buf.st_mtim.tv_sec))
        gm_editor_save(view->editor);

    }

  }

  if(!(view->filename == ((char *)NULL)))
  {
    unlink(view->filename);
    g_free((void *)view->filename);
  }

}

// gm_external_view_new
// file widgets/gm-external-view.h line 19
struct _GmExternalView * gm_external_view_new(struct _GmWorld *world, struct _GmEditor *editor)
{
  struct _GmExternalView *obj;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmExternalView) /*48ul*/ );
  obj = (struct _GmExternalView *)return_value_g_malloc0_n$1;
  char **spawn_command = (char **)(void *)0;
  char *filename;
  char *command;
  signed int argc;
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$2;
  return_value_gm_app_instance$2=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$2);
  obj->world = world;
  obj->editor = editor;
  obj->filename=gm_editor_write_lines(editor);
  gm_external_view_update_last_modified(obj);
  gnome_vfs_monitor_add(&obj->monitor, obj->filename, (enum anonymous$101)GNOME_VFS_MONITOR_FILE, (void (*)(struct GnomeVFSMonitorHandle *, const char *, const char *, enum anonymous$102, void *))on_gm_external_view_file_changed, (void *)obj);
  filename=g_shell_quote(obj->filename);
  const char *return_value_gm_options_get$3;
  return_value_gm_options_get$3=gm_options_get(options, "editor_alternative");
  command=g_strconcat(return_value_gm_options_get$3, (const void *)" ", filename, (void *)0);
  g_free((void *)filename);
  signed int return_value_gm_options_get_int$4;
  return_value_gm_options_get_int$4=gm_options_get_int(options, "editor_needs_terminal");
  if(!(return_value_gm_options_get_int$4 == 0))
    spawn_command=build_terminal_command(command);

  else
    g_shell_parse_argv(command, &argc, &spawn_command, (struct _GError **)(void *)0);
  gm_external_view_spawn(obj, spawn_command);
  g_strfreev(spawn_command);
  g_free((void *)command);
  obj->child_watch=g_child_watch_add(obj->pid, (void (*)(signed int, signed int, void *))on_gm_external_view_exited, (void *)obj);
  return obj;
}

// gm_external_view_spawn
// file widgets/gm-external-view.c line 54
signed int gm_external_view_spawn(struct _GmExternalView *view, char **argv)
{
  struct _GError *err = (struct _GError *)(void *)0;
  g_spawn_async((const char *)(void *)0, argv, (char **)(void *)0, (enum anonymous$104)(G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD), (void (*)(void *))(void *)0, (void *)0, &view->pid, &err);
  if(!(err == ((struct _GError *)NULL)))
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmExternalView.Spawn: couldn't spawn editor: %s", err->message);
    g_error_free(err);
    return 0;
  }

  else
    return (signed int)!(0 != 0);
}

// gm_external_view_update_last_modified
// file widgets/gm-external-view.c line 45
void gm_external_view_update_last_modified(struct _GmExternalView *view)
{
  struct stat buf;
  signed int return_value_stat$1;
  return_value_stat$1=stat(view->filename, &buf);
  if(!(return_value_stat$1 == -1))
    view->last_modified = buf.st_mtim.tv_sec;

}

// gm_fetch
// file ./gm-support.h line 134
struct _GmFetchHandle * gm_fetch(const struct _GList *source, const struct _GList *dest, void (*cb)(void *, void *), void *user_data)
{
  struct _GmFetchHandle *g;
  g=gm_fetch_handle_create(cb, user_data);
  char *uri;
  enum anonymous$32 ret;
  for( ; !(source == ((const struct _GList *)NULL)); source = source->next)
  {
    uri = (char *)source->data;
    struct GnomeVFSURI *return_value_gnome_vfs_uri_new$1;
    return_value_gnome_vfs_uri_new$1=gnome_vfs_uri_new(uri);
    g->source_uri=g_list_append(g->source_uri, (void *)return_value_gnome_vfs_uri_new$1);
  }
  for( ; !(dest == ((const struct _GList *)NULL)); dest = dest->next)
  {
    uri = (char *)dest->data;
    struct GnomeVFSURI *return_value_gnome_vfs_uri_new$2;
    return_value_gnome_vfs_uri_new$2=gnome_vfs_uri_new(uri);
    g->dest_uri=g_list_append(g->dest_uri, (void *)return_value_gnome_vfs_uri_new$2);
  }
  ret=gnome_vfs_async_xfer(&g->handle, g->source_uri, g->dest_uri, (enum anonymous$81)(GNOME_VFS_XFER_DEFAULT | GNOME_VFS_XFER_RECURSIVE), (enum anonymous$83)GNOME_VFS_XFER_ERROR_MODE_QUERY, (enum anonymous$82)GNOME_VFS_XFER_OVERWRITE_MODE_REPLACE, 0, (signed int (*)(struct GnomeVFSAsyncHandle *, struct anonymous$80 *, void *))gm_fetch_progress, (void *)g, gm_fetch_interact, (void *)g);
  return g;
}

// gm_fetch_handle_create
// file gm-support.c line 273
struct _GmFetchHandle * gm_fetch_handle_create(void (*cb)(void *, void *), void *user_data)
{
  struct _GmFetchHandle *g;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmFetchHandle) /*128ul*/ );
  g = (struct _GmFetchHandle *)return_value_g_malloc0_n$1;
  g->cb = cb;
  g->user_data = user_data;
  g->prev_status = (enum anonymous$15)GNOME_VFS_XFER_PROGRESS_STATUS_OK;
  g->cur_phase = (enum anonymous$14)-1;
  g->prev_phase = (enum anonymous$14)-1;
  g->cur_file = (unsigned long int)-1;
  g->prev_file = (unsigned long int)-1;
  return g;
}

// gm_fetch_handle_free
// file gm-support.c line 252
void gm_fetch_handle_free(struct _GmFetchHandle *g)
{
  struct _GList *tmp;
  g_free((void *)g->cur_file_name);
  tmp = g->source_uri;
  for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
    gnome_vfs_uri_unref((struct GnomeVFSURI *)tmp->data);
  g_list_free(g->source_uri);
  tmp = g->dest_uri;
  for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
    gnome_vfs_uri_unref((struct GnomeVFSURI *)tmp->data);
  g_list_free(g->dest_uri);
  g_free((void *)g);
}

// gm_fetch_interact
// file gm-support.c line 370
signed int gm_fetch_interact(struct anonymous$80 *info, void *user_data)
{
  return 1;
}

// gm_fetch_progress
// file gm-support.c line 288
signed int gm_fetch_progress(struct GnomeVFSAsyncHandle *handle, struct anonymous$80 *info, struct _GmFetchHandle *g)
{
  char *name;
  const char *err;
  g->cur_phase = info->phase;
  g->cur_file = info->file_index;
  g->files_total = info->files_total;
  g->bytes_total = info->bytes_total;
  g->file_size = info->file_size;
  g->bytes_copied = info->bytes_copied;
  g->total_bytes_copied = info->total_bytes_copied;
  g->status = info->status;
  signed int return_value_strcmp$1;
  if(!(g->aborted == 0))
  {
    g->cb((void *)g, g->user_data);
    gm_fetch_handle_free(g);
    return 0;
  }

  else
  {
    if(!(info->target_name == ((char *)NULL)))
    {
      if(!(g->cur_file_name == ((char *)NULL)))
      {
        return_value_strcmp$1=strcmp(g->cur_file_name, info->target_name);
        if(!(return_value_strcmp$1 == 0))
        {
          g->cur_phase = (enum anonymous$14)GNOME_VFS_XFER_PHASE_FILECOMPLETED;
          g->cb((void *)g, g->user_data);
          g->cur_phase = info->phase;
          g_free((void *)g->cur_file_name);
          g->cur_file_name = (char *)(void *)0;
        }

      }

      if(g->cur_file_name == ((char *)NULL))
        g->cur_file_name=g_strdup(info->target_name);

    }

    if((signed int)info->status == GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE)
    {
      name=gnome_vfs_get_local_path_from_uri(info->target_name);
      gm_debug_msg(DEBUG_DEFAULT, "GmFetchProgress: asking for overwriting %s: yes", name);
      g->prev_status = (enum anonymous$15)GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE;
      return 1;
    }

    else
      if((signed int)info->status == GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR)
      {
        name=gnome_vfs_get_local_path_from_uri(info->target_name);
        err=gnome_vfs_result_to_string(info->vfs_status);
        gdk_threads_enter();
        gm_debug_msg(DEBUG_DEFAULT, "GmFetchProgress: error for %s: %s", name, err);
        g->cb((void *)g, g->user_data);
        gdk_threads_leave();
        g_free((void *)g->cur_file_name);
        g->cur_file_name = (char *)(void *)0;
        g->prev_status = (enum anonymous$15)GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR;
        g_free((void *)name);
        return 2;
      }

    if((signed int)info->phase == GNOME_VFS_XFER_PHASE_COMPLETED)
    {
      if(!(g->cur_file_name == ((char *)NULL)))
      {
        g->cur_phase = (enum anonymous$14)GNOME_VFS_XFER_PHASE_FILECOMPLETED;
        g->cb((void *)g, g->user_data);
        g->cur_phase = info->phase;
      }

      g->done = (signed int)!(0 != 0);
      g->cb((void *)g, g->user_data);
      gm_fetch_handle_free(g);
      return (signed int)!(0 != 0);
    }

    else
    {
      g->prev_status = info->status;
      return (signed int)!(0 != 0);
    }
  }
}

// gm_find_child
// file ./gm-support.h line 151
struct _GtkWidget * gm_find_child(struct _GtkWidget *widget, unsigned long int parent_type)
{
  struct _GList *children;
  struct _GList *child;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  signed int tmp_statement_expression$7;
  _Bool tmp_if_expr$8;
  if(widget == ((struct _GtkWidget *)NULL))
    return (struct _GtkWidget *)(void *)0;

  else
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget;
    unsigned long int __t = parent_type;
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(!(tmp_statement_expression$1 == 0))
      return widget;

    else
    {
      struct _GTypeInstance *gm_find_child$$1$$4$$__inst = (struct _GTypeInstance *)widget;
      unsigned long int gm_find_child$$1$$4$$__t;
      gm_find_child$$1$$4$$__t=gtk_container_get_type();
      signed int gm_find_child$$1$$4$$__r;
      if(gm_find_child$$1$$4$$__inst == ((struct _GTypeInstance *)NULL))
        gm_find_child$$1$$4$$__r = 0;

      else
      {
        if(!(gm_find_child$$1$$4$$__inst->g_class == ((struct _GTypeClass *)NULL)))
          tmp_if_expr$8 = gm_find_child$$1$$4$$__inst->g_class->g_type == gm_find_child$$1$$4$$__t ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          gm_find_child$$1$$4$$__r = (signed int)!(0 != 0);

        else
          gm_find_child$$1$$4$$__r=g_type_check_instance_is_a(gm_find_child$$1$$4$$__inst, gm_find_child$$1$$4$$__t);
      }
      tmp_statement_expression$7 = gm_find_child$$1$$4$$__r;
      if(!(tmp_statement_expression$7 == 0))
      {
        unsigned long int return_value_gtk_container_get_type$3;
        return_value_gtk_container_get_type$3=gtk_container_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_container_get_type$3);
        children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$4);
        widget = (struct _GtkWidget *)(void *)0;
        child = children;
        for( ; !(child == ((struct _GList *)NULL)); child = child->next)
        {
          unsigned long int return_value_gtk_widget_get_type$5;
          return_value_gtk_widget_get_type$5=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
          return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)child->data, return_value_gtk_widget_get_type$5);
          widget=gm_find_child((struct _GtkWidget *)return_value_g_type_check_instance_cast$6, parent_type);
          if(!(widget == ((struct _GtkWidget *)NULL)))
            break;

        }
        g_list_free(children);
        return widget;
      }

      else
        return (struct _GtkWidget *)(void *)0;
    }
  }
}

// gm_find_parent
// file gm-support.c line 582
struct _GtkWidget * gm_find_parent(struct _GtkWidget *widget, unsigned long int parent_type)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  if(widget == ((struct _GtkWidget *)NULL))
    return (struct _GtkWidget *)(void *)0;

  else
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget;
    unsigned long int __t = parent_type;
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(!(tmp_statement_expression$1 == 0))
      return widget;

    else
    {
      struct _GtkWidget *return_value_gtk_widget_get_parent$3;
      return_value_gtk_widget_get_parent$3=gtk_widget_get_parent(widget);
      struct _GtkWidget *return_value_gm_find_parent$4;
      return_value_gm_find_parent$4=gm_find_parent(return_value_gtk_widget_get_parent$3, parent_type);
      return return_value_gm_find_parent$4;
    }
  }
}

// gm_fix_decimal_point
// file gm-support.c line 31
char * gm_fix_decimal_point(char *line, signed int len)
{
  signed int i;
  struct lconv *l;
  l=localeconv();
  if((signed int)*l->decimal_point == 46)
    return line;

  else
  {
    i = 0;
    for( ; !(i >= len); i = i + 1)
      if((signed int)line[(signed long int)i] == 46)
        line[(signed long int)i] = l->decimal_point[(signed long int)0];

    return line;
  }
}

// gm_fix_decimal_point_rev
// file gm-support.c line 49
char * gm_fix_decimal_point_rev(char *line, signed int len)
{
  signed int i;
  struct lconv *l;
  l=localeconv();
  i = 0;
  for( ; !(i >= len); i = i + 1)
    if(line[(signed long int)i] == *l->decimal_point)
      line[(signed long int)i] = (char)46;

  return line;
}

// gm_from_utf8_with_fallback
// file gm-support.h line 153
char * gm_from_utf8_with_fallback(const char *text, signed long int len, const char *to, const char *fallback)
{
  char *return_value_gm_convert_with_fallback$1;
  return_value_gm_convert_with_fallback$1=gm_convert_with_fallback(text, len, "UTF-8", to, fallback);
  return return_value_gm_convert_with_fallback$1;
}

// gm_g_list_find_simple
// file gm-support.c line 111
char * gm_g_list_find_simple(struct _GList *s, char *f)
{
  struct _GList *tmp = s;
  for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)tmp->data, f);
    if(return_value_strcmp$1 == 0)
      return (char *)tmp->data;

  }
  return (char *)(void *)0;
}

// gm_g_list_free_simple
// file ./gm-support.h line 119
void gm_g_list_free_simple(struct _GList *s)
{
  struct _GList *tmp = s;
  for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
    g_free(tmp->data);
  g_list_free(s);
}

// gm_garray_length
// file gm-support.c line 91
signed int gm_garray_length(char **s)
{
  char **iter = s;
  char **tmp_post$1;
  do
  {
    tmp_post$1 = iter;
    iter = iter + 1l;
    if(*tmp_post$1 == ((char *)NULL))
      break;

  }
  while((_Bool)1);
  return (signed int)((*iter - *s) - (signed long int)1);
}

// gm_info_dialog
// file ./gm-support.h line 124
signed int gm_info_dialog(char *message, struct _GtkWindow *parent)
{
  signed int return_value_gm_dialog$1;
  return_value_gm_dialog$1=gm_dialog(message, (enum anonymous$79)GTK_MESSAGE_INFO, GTK_BUTTONS_OK, parent);
  return return_value_gm_dialog$1;
}

// gm_is_end_scrolled
// file gm-support.c line 403
signed int gm_is_end_scrolled(struct _GtkScrolledWindow *wnd, unsigned int charHeight)
{
  struct _GtkAdjustment *ad;
  ad=gtk_scrolled_window_get_vadjustment(wnd);
  return (signed int)(ad->page_size + ad->value >= ad->upper - (double)charHeight);
}

// gm_iuserlist_base_init
// file mcp/gm-iuserlist.c line 31
static void gm_iuserlist_base_init(void *object_class)
{
  static signed int initialized = 0;
  if(initialized == 0)
  {
    g_signal_new("player_added", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)64ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__INT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(6 << 2));
    g_signal_new("player_removed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)72ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__INT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(6 << 2));
    g_signal_new("name_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)80ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__INT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(6 << 2));
    g_signal_new("state_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)88ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__INT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(6 << 2));
    g_signal_new("rank_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)96ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__INT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(6 << 2));
    initialized = (signed int)!(0 != 0);
  }

}

// gm_iuserlist_get_icon
// file mcp/gm-iuserlist.c line 142
const char * gm_iuserlist_get_icon(struct _GmIUserlist *self, signed int id, signed int use_state)
{
  struct _GmIUserlistInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_iuserlist_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_iuserlist_get_icon", "GM_IS_IUSERLIST(self)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_iuserlist_get_type$3);
  iface = (struct _GmIUserlistInterface *)return_value_g_type_interface_peek$4;
  if(!(iface->get_icon == ((const char * (*)(struct _GmIUserlist *, signed int, signed int))NULL)))
  {
    const char *return_value;
    return_value=iface->get_icon(self, id, use_state);
    return return_value;
  }

  else
    return (const char *)(void *)0;
}

// gm_iuserlist_get_menu
// file mcp/gm-iuserlist.c line 86
struct _GList * gm_iuserlist_get_menu(struct _GmIUserlist *self, signed int id)
{
  struct _GmIUserlistInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_iuserlist_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_iuserlist_get_menu", "GM_IS_IUSERLIST(self)");
      return (struct _GList *)(void *)0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_iuserlist_get_type$3);
  iface = (struct _GmIUserlistInterface *)return_value_g_type_interface_peek$4;
  if(!(iface->get_menu == ((struct _GList * (*)(struct _GmIUserlist *, signed int))NULL)))
  {
    struct _GList *return_value;
    return_value=iface->get_menu(self, id);
    return return_value;
  }

  else
    return (struct _GList *)(void *)0;
}

// gm_iuserlist_get_name
// file mcp/gm-iuserlist.c line 127
const char * gm_iuserlist_get_name(struct _GmIUserlist *self, signed int id)
{
  struct _GmIUserlistInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_iuserlist_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_iuserlist_get_name", "GM_IS_IUSERLIST(self)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_iuserlist_get_type$3);
  iface = (struct _GmIUserlistInterface *)return_value_g_type_interface_peek$4;
  if(!(iface->get_name == ((const char * (*)(struct _GmIUserlist *, signed int))NULL)))
  {
    const char *return_value;
    return_value=iface->get_name(self, id);
    return return_value;
  }

  else
    return (const char *)(void *)0;
}

// gm_iuserlist_get_rank_priority
// file mcp/gm-iuserlist.c line 157
signed int gm_iuserlist_get_rank_priority(struct _GmIUserlist *self, signed int id)
{
  struct _GmIUserlistInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_iuserlist_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_iuserlist_get_rank_priority", "GM_IS_IUSERLIST(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_iuserlist_get_type$3);
  iface = (struct _GmIUserlistInterface *)return_value_g_type_interface_peek$4;
  if(!(iface->get_rank_priority == ((signed int (*)(struct _GmIUserlist *, signed int))NULL)))
  {
    signed int return_value;
    return_value=iface->get_rank_priority(self, id);
    return return_value;
  }

  else
    return 0;
}

// gm_iuserlist_get_state_priority
// file mcp/gm-iuserlist.c line 172
signed int gm_iuserlist_get_state_priority(struct _GmIUserlist *self, signed int id)
{
  struct _GmIUserlistInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_iuserlist_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_iuserlist_get_state_priority", "GM_IS_IUSERLIST(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_iuserlist_get_type$3);
  iface = (struct _GmIUserlistInterface *)return_value_g_type_interface_peek$4;
  if(!(iface->get_state_priority == ((signed int (*)(struct _GmIUserlist *, signed int))NULL)))
  {
    signed int return_value;
    return_value=iface->get_state_priority(self, id);
    return return_value;
  }

  else
    return 0;
}

// gm_iuserlist_get_status
// file mcp/gm-iuserlist.c line 112
char * gm_iuserlist_get_status(struct _GmIUserlist *self, signed int id)
{
  struct _GmIUserlistInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_iuserlist_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_iuserlist_get_status", "GM_IS_IUSERLIST(self)");
      return (char *)(void *)0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_iuserlist_get_type$3);
  iface = (struct _GmIUserlistInterface *)return_value_g_type_interface_peek$4;
  if(!(iface->get_status == ((char * (*)(struct _GmIUserlist *, signed int))NULL)))
  {
    char *return_value;
    return_value=iface->get_status(self, id);
    return return_value;
  }

  else
    return (char *)(void *)0;
}

// gm_iuserlist_get_type
// file mcp/gm-iuserlist.c line 7
unsigned long int gm_iuserlist_get_type()
{
  static const struct _GTypeInfo iuserlist_info = { .class_size=(unsigned short int)sizeof(struct _GmIUserlistInterface) /*104ul*/ , .base_init=gm_iuserlist_base_init,
    .base_finalize=(void (*)(void *))(void *)0, .class_init=(void (*)(void *, void *))(void *)0,
    .class_finalize=(void (*)(void *, void *))(void *)0,
    .class_data=(void *)0,
    .instance_size=(unsigned short int)0, .n_preallocs=(unsigned short int)0,
    .instance_init=(void (*)(struct _GTypeInstance *, void *))(void *)0, .value_table=((const struct _GTypeValueTable *)NULL) };
  static unsigned long int iuserlist_type = (unsigned long int)0;
  if(iuserlist_type == 0ul)
    iuserlist_type=g_type_register_static((unsigned long int)(2 << 2), "GmIUserlist", &iuserlist_info, (enum anonymous)0);

  return iuserlist_type;
}

// gm_iuserlist_supports_status
// file mcp/gm-iuserlist.c line 101
signed int gm_iuserlist_supports_status(struct _GmIUserlist *self)
{
  struct _GmIUserlistInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_iuserlist_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_iuserlist_supports_status", "GM_IS_IUSERLIST(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_iuserlist_get_type$3);
  iface = (struct _GmIUserlistInterface *)return_value_g_type_interface_peek$4;
  return (signed int)(iface->get_status != (char * (*)(struct _GmIUserlist *, signed int))(void *)0);
}

// gm_log_view_class_init
// file widgets/gm-log-view.c line 56
static void gm_log_view_class_init(struct _GmLogViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmOptions *options;
  object_class->finalize = gm_log_view_finalize;
  struct _GmApp *return_value_gm_app_instance$2;
  return_value_gm_app_instance$2=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$2);
  g_type_class_add_private((void *)object_class, sizeof(struct _GmLogViewPrivate) /*8ul*/ );
}

// gm_log_view_class_intern_init
// file widgets/gm-log-view.c line 31
static void gm_log_view_class_intern_init(void *klass)
{
  gm_log_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmLogView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmLogView_private_offset);

  gm_log_view_class_init((struct _GmLogViewClass *)klass);
}

// gm_log_view_create_filter
// file widgets/gm-log-view.c line 107
struct _GtkWidget * gm_log_view_create_filter(struct _GmLogView *obj)
{
  struct _GtkWidget *box;
  box=gtk_hbox_new(0, 6);
  struct _GtkWidget *label;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Filter: ");
  label=gtk_label_new(return_value_gettext$1);
  struct _GtkWidget *check;
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$2;
  return_value_gm_app_instance$2=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$2);
  unsigned long int return_value_gtk_box_get_type$3;
  return_value_gtk_box_get_type$3=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type$3);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$4, label, 0, 0, (unsigned int)0);
  char *return_value_gettext$5;
  return_value_gettext$5=gettext("Incoming");
  check=gtk_check_button_new_with_label(return_value_gettext$5);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)check, (unsigned long int)(20 << 2));
  char *return_value_g_strdup$7;
  return_value_g_strdup$7=g_strdup("in");
  g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$6, "option", (void *)return_value_g_strdup$7, g_free);
  g_signal_connect_data((void *)check, "toggled", (void (*)(void))on_gm_log_view_filter_toggled, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_toggle_button_get_type$8;
  return_value_gtk_toggle_button_get_type$8=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$8);
  signed int return_value_gm_options_get_int$10;
  return_value_gm_options_get_int$10=gm_options_get_int(options, "logging_filter_in");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$9, return_value_gm_options_get_int$10);
  unsigned long int return_value_gtk_box_get_type$11;
  return_value_gtk_box_get_type$11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type$11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$12, check, 0, 0, (unsigned int)0);
  char *return_value_gettext$13;
  return_value_gettext$13=gettext("Outgoing");
  check=gtk_check_button_new_with_label(return_value_gettext$13);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)check, (unsigned long int)(20 << 2));
  char *return_value_g_strdup$15;
  return_value_g_strdup$15=g_strdup("out");
  g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$14, "option", (void *)return_value_g_strdup$15, g_free);
  g_signal_connect_data((void *)check, "toggled", (void (*)(void))on_gm_log_view_filter_toggled, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_toggle_button_get_type$16;
  return_value_gtk_toggle_button_get_type$16=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$16);
  signed int return_value_gm_options_get_int$18;
  return_value_gm_options_get_int$18=gm_options_get_int(options, "logging_filter_out");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$17, return_value_gm_options_get_int$18);
  unsigned long int return_value_gtk_box_get_type$19;
  return_value_gtk_box_get_type$19=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type$19);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$20, check, 0, 0, (unsigned int)0);
  char *return_value_gettext$21;
  return_value_gettext$21=gettext("Status");
  check=gtk_check_button_new_with_label(return_value_gettext$21);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)check, (unsigned long int)(20 << 2));
  char *return_value_g_strdup$23;
  return_value_g_strdup$23=g_strdup("status");
  g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$22, "option", (void *)return_value_g_strdup$23, g_free);
  g_signal_connect_data((void *)check, "toggled", (void (*)(void))on_gm_log_view_filter_toggled, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_toggle_button_get_type$24;
  return_value_gtk_toggle_button_get_type$24=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$24);
  signed int return_value_gm_options_get_int$26;
  return_value_gm_options_get_int$26=gm_options_get_int(options, "logging_filter_status");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$25, return_value_gm_options_get_int$26);
  unsigned long int return_value_gtk_box_get_type$27;
  return_value_gtk_box_get_type$27=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type$27);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$28, check, 0, 0, (unsigned int)0);
  char *return_value_gettext$29;
  return_value_gettext$29=gettext("Mcp incoming");
  check=gtk_check_button_new_with_label(return_value_gettext$29);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)check, (unsigned long int)(20 << 2));
  char *return_value_g_strdup$31;
  return_value_g_strdup$31=g_strdup("mcp_in");
  g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$30, "option", (void *)return_value_g_strdup$31, g_free);
  g_signal_connect_data((void *)check, "toggled", (void (*)(void))on_gm_log_view_filter_toggled, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_toggle_button_get_type$32;
  return_value_gtk_toggle_button_get_type$32=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$32);
  signed int return_value_gm_options_get_int$34;
  return_value_gm_options_get_int$34=gm_options_get_int(options, "logging_filter_mcp_in");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$33, return_value_gm_options_get_int$34);
  unsigned long int return_value_gtk_box_get_type$35;
  return_value_gtk_box_get_type$35=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type$35);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$36, check, 0, 0, (unsigned int)0);
  char *return_value_gettext$37;
  return_value_gettext$37=gettext("Mcp outgoing");
  check=gtk_check_button_new_with_label(return_value_gettext$37);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)check, (unsigned long int)(20 << 2));
  char *return_value_g_strdup$39;
  return_value_g_strdup$39=g_strdup("mcp_out");
  g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$38, "option", (void *)return_value_g_strdup$39, g_free);
  g_signal_connect_data((void *)check, "toggled", (void (*)(void))on_gm_log_view_filter_toggled, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_toggle_button_get_type$40;
  return_value_gtk_toggle_button_get_type$40=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
  return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$40);
  signed int return_value_gm_options_get_int$42;
  return_value_gm_options_get_int$42=gm_options_get_int(options, "logging_filter_mcp_out");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$41, return_value_gm_options_get_int$42);
  unsigned long int return_value_gtk_box_get_type$43;
  return_value_gtk_box_get_type$43=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type$43);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$44, check, 0, 0, (unsigned int)0);
  char *return_value_gettext$45;
  return_value_gettext$45=gettext("Mcp status");
  check=gtk_check_button_new_with_label(return_value_gettext$45);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
  return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)check, (unsigned long int)(20 << 2));
  char *return_value_g_strdup$47;
  return_value_g_strdup$47=g_strdup("mcp_status");
  g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$46, "option", (void *)return_value_g_strdup$47, g_free);
  g_signal_connect_data((void *)check, "toggled", (void (*)(void))on_gm_log_view_filter_toggled, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_toggle_button_get_type$48;
  return_value_gtk_toggle_button_get_type$48=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
  return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$48);
  signed int return_value_gm_options_get_int$50;
  return_value_gm_options_get_int$50=gm_options_get_int(options, "logging_filter_mcp_status");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$49, return_value_gm_options_get_int$50);
  unsigned long int return_value_gtk_box_get_type$51;
  return_value_gtk_box_get_type$51=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$52;
  return_value_g_type_check_instance_cast$52=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type$51);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$52, check, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_container_get_type$53;
  return_value_gtk_container_get_type$53=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_container_get_type$53);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$54, (unsigned int)3);
  gtk_widget_show_all(box);
  return box;
}

// gm_log_view_create_tags
// file widgets/gm-log-view.c line 78
static void gm_log_view_create_tags(struct _GmLogView *obj)
{
  struct _GtkTextBuffer *buffer;
  buffer=gtk_text_view_get_buffer(obj->priv->text_view);
  gtk_text_buffer_create_tag(buffer, "in", (const char *)(void *)0);
  gtk_text_buffer_create_tag(buffer, "out", (const char *)(void *)0);
  gtk_text_buffer_create_tag(buffer, "status", (const char *)(void *)0);
  gtk_text_buffer_create_tag(buffer, "mcp_in", (const char *)(void *)0);
  gtk_text_buffer_create_tag(buffer, "mcp_out", (const char *)(void *)0);
  gtk_text_buffer_create_tag(buffer, "mcp_status", (const char *)(void *)0);
}

// gm_log_view_create_text_view
// file widgets/gm-log-view.c line 89
static void gm_log_view_create_text_view(struct _GmLogView *obj)
{
  struct _GtkTextView *text_view;
  struct _GtkWidget *return_value_gtk_text_view_new$1;
  return_value_gtk_text_view_new$1=gtk_text_view_new();
  unsigned long int return_value_gtk_text_view_get_type$2;
  return_value_gtk_text_view_get_type$2=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_text_view_new$1, return_value_gtk_text_view_get_type$2);
  text_view = (struct _GtkTextView *)return_value_g_type_check_instance_cast$3;
  gtk_text_view_set_editable(text_view, 0);
  gtk_text_view_set_left_margin(text_view, 3);
  gtk_text_view_set_right_margin(text_view, 3);
  gtk_text_view_set_wrap_mode(text_view, (enum anonymous$77)GTK_WRAP_WORD_CHAR);
  unsigned long int return_value_gtk_widget_get_type$4;
  return_value_gtk_widget_get_type$4=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)text_view, return_value_gtk_widget_get_type$4);
  gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$5);
  obj->priv->text_view = text_view;
  gm_log_view_create_tags(obj);
}

// gm_log_view_finalize
// file widgets/gm-log-view.c line 50
static void gm_log_view_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_log_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_log_view_get_tag
// file widgets/gm-log-view.c line 208
const char * gm_log_view_get_tag(const char *last)
{
  switch((signed int)last[(signed long int)11])
  {
    case 62:
      return "out";
    case 60:
      return "in";
    case 35:
      return "status";
    case 91:
      switch((signed int)last[(signed long int)17])
      {
        case 62:
          return "mcp_out";
        case 60:
          return "mcp_in";
        case 35:
          return "mcp_status";
        default:
          ;
      }
    default:
      return (const char *)(void *)0;
  }
}

// gm_log_view_get_type
// file widgets/gm-log-view.h line 53
unsigned long int gm_log_view_get_type(void)
{
  _Bool tmp_statement_expression$4;
  void *tmp_statement_expression$5;
  signed int return_value___atomic_load_8$6;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$6=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$5 = (void *)return_value___atomic_load_8$6;
  _Bool tmp_if_expr$8;
  signed int return_value_g_once_init_enter$7;
  if(tmp_statement_expression$5 == NULL)
  {
    return_value_g_once_init_enter$7=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$8 = return_value_g_once_init_enter$7 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  tmp_statement_expression$4 = tmp_if_expr$8;
  if(tmp_statement_expression$4)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_vbox_get_type$1;
    return_value_gtk_vbox_get_type$1=gtk_vbox_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmLogView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_vbox_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmLogViewClass) /*824ul*/ , (void (*)(void *, void *))gm_log_view_class_intern_init, (unsigned int)sizeof(struct _GmLogView) /*136ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_log_view_init, (enum anonymous)0);
    const struct _GInterfaceInfo g_implement_interface_info = { .interface_init=(void (*)(void *, void *))gm_log_view_searchable_iface_init, .interface_finalize=(void (*)(void *, void *))(void *)0,
    .interface_data=(void *)0 };
    unsigned long int return_value_gm_searchable_get_type$3;
    return_value_gm_searchable_get_type$3=gm_searchable_get_type();
    g_type_add_interface_static(g_define_type_id, return_value_gm_searchable_get_type$3, &g_implement_interface_info);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_log_view_init
// file widgets/gm-log-view.c line 174
static void gm_log_view_init(struct _GmLogView *obj)
{
  struct _GtkWidget *srl;
  unsigned long int return_value_gm_log_view_get_type$1;
  return_value_gm_log_view_get_type$1=gm_log_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_log_view_get_type$1);
  obj->priv = (struct _GmLogViewPrivate *)return_value_g_type_instance_get_private$2;
  unsigned long int return_value_gtk_box_get_type$3;
  return_value_gtk_box_get_type$3=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$3);
  gtk_box_set_spacing((struct _GtkBox *)return_value_g_type_check_instance_cast$4, 6);
  unsigned long int return_value_gtk_box_get_type$5;
  return_value_gtk_box_get_type$5=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$5);
  gtk_box_set_homogeneous((struct _GtkBox *)return_value_g_type_check_instance_cast$6, 0);
  gm_log_view_create_text_view(obj);
  srl=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_scrolled_window_get_type$7;
  return_value_gtk_scrolled_window_get_type$7=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)srl, return_value_gtk_scrolled_window_get_type$7);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$8, (enum anonymous$89)GTK_SHADOW_IN);
  gtk_widget_show(srl);
  unsigned long int return_value_gtk_scrolled_window_get_type$9;
  return_value_gtk_scrolled_window_get_type$9=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)srl, return_value_gtk_scrolled_window_get_type$9);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$10, (enum anonymous$88)GTK_POLICY_AUTOMATIC, (enum anonymous$88)GTK_POLICY_AUTOMATIC);
  unsigned long int return_value_gtk_container_get_type$11;
  return_value_gtk_container_get_type$11=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)srl, return_value_gtk_container_get_type$11);
  unsigned long int return_value_gtk_widget_get_type$13;
  return_value_gtk_widget_get_type$13=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)obj->priv->text_view, return_value_gtk_widget_get_type$13);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$12, (struct _GtkWidget *)return_value_g_type_check_instance_cast$14);
  unsigned long int return_value_gtk_box_get_type$15;
  return_value_gtk_box_get_type$15=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$15);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$16, srl, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_widget_get_type$17;
  return_value_gtk_widget_get_type$17=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)obj->priv->text_view, return_value_gtk_widget_get_type$17);
  struct _GmApp *return_value_gm_app_instance$19;
  return_value_gm_app_instance$19=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$20;
  return_value_gm_app_color_table$20=gm_app_color_table(return_value_gm_app_instance$19);
  gm_register_schemed((struct _GtkWidget *)return_value_g_type_check_instance_cast$18, return_value_gm_app_color_table$20, (enum _GmSchemedFlags)(GM_SCHEMED_COLORS | GM_SCHEMED_FONT));
}

// gm_log_view_new
// file widgets/gm-log-view.h line 54
struct _GmLogView * gm_log_view_new(void)
{
  struct _GmLogView *obj;
  unsigned long int return_value_gm_log_view_get_type$1;
  return_value_gm_log_view_get_type$1=gm_log_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_log_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_log_view_get_type$3;
  return_value_gm_log_view_get_type$3=gm_log_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_log_view_get_type$3);
  obj = (struct _GmLogView *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_log_view_searchable_get_text_view
// file widgets/gm-log-view.c line 41
static struct _GtkTextView * gm_log_view_searchable_get_text_view(struct _GmSearchable *sea)
{
  struct _GmLogView *view = (struct _GmLogView *)sea;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)sea;
    unsigned long int __t;
    __t=gm_log_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_log_view_searchable_get_text_view", "GM_IS_LOG_VIEW(sea)");
      return (struct _GtkTextView *)(void *)0;
    }

  }
  while((_Bool)0);
  return view->priv->text_view;
}

// gm_log_view_searchable_iface_init
// file widgets/gm-log-view.c line 36
static void gm_log_view_searchable_iface_init(struct _GmSearchableInterface *iface)
{
  iface->get_text_view = gm_log_view_searchable_get_text_view;
}

// gm_log_view_set_text
// file widgets/gm-log-view.h line 55
void gm_log_view_set_text(struct _GmLogView *view, const char *text)
{
  struct _GtkTextBuffer *buffer;
  buffer=gtk_text_view_get_buffer(view->priv->text_view);
  char *ptr;
  const char *last = text;
  const char *tag;
  struct _GtkTextIter iter;
  gtk_text_buffer_get_end_iter(buffer, &iter);
  tag=gm_log_view_get_tag(text);
  gtk_text_buffer_insert_with_tags_by_name(buffer, &iter, text, -1, tag, (void *)0);
  goto __CPROVER_DUMP_L4;
  ptr=g_utf8_strchr(last, (signed long int)-1, (unsigned int)10);
  if(!(ptr == ((char *)NULL)))
  {
    gtk_text_buffer_get_end_iter(buffer, &iter);
    tag=gm_log_view_get_tag(last);
    gtk_text_buffer_insert_with_tags_by_name(buffer, &iter, last, (signed int)((ptr - last) + (signed long int)1), tag, (void *)0);
    last = ptr + (signed long int)1;
  }

  if(!((signed int)*last == 0))
  {
    gtk_text_buffer_get_end_iter(buffer, &iter);
    tag=gm_log_view_get_tag(last);
    gtk_text_buffer_insert_with_tags_by_name(buffer, &iter, last, (signed int)((ptr - last) + (signed long int)1), tag, (void *)0);
  }


__CPROVER_DUMP_L4:
  ;
}

// gm_marshal_VOID__INT_INT_STRING
// file gm-marshal.c line 324
extern void gm_marshal_VOID__INT_INT_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, signed int, signed int, void *, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 4u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__INT_INT_STRING", "n_param_values == 4");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, signed int, signed int, void *, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_int, (param_values + (signed long int)2)->data[(signed long int)0].v_int, (param_values + (signed long int)3)->data[(signed long int)0].v_pointer, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_marshal_VOID__INT_STRING
// file gm-marshal.c line 166
extern void gm_marshal_VOID__INT_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, signed int, void *, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 3u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__INT_STRING", "n_param_values == 3");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, signed int, void *, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_int, (param_values + (signed long int)2)->data[(signed long int)0].v_pointer, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_marshal_VOID__INT_STRING_STRING
// file gm-marshal.c line 203
extern void gm_marshal_VOID__INT_STRING_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, signed int, void *, void *, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 4u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__INT_STRING_STRING", "n_param_values == 4");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, signed int, void *, void *, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_int, (param_values + (signed long int)2)->data[(signed long int)0].v_pointer, (param_values + (signed long int)3)->data[(signed long int)0].v_pointer, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_marshal_VOID__INT_STRING_STRING_STRING
// file gm-marshal.c line 242
extern void gm_marshal_VOID__INT_STRING_STRING_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, signed int, void *, void *, void *, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 5u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__INT_STRING_STRING_STRING", "n_param_values == 5");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, signed int, void *, void *, void *, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_int, (param_values + (signed long int)2)->data[(signed long int)0].v_pointer, (param_values + (signed long int)3)->data[(signed long int)0].v_pointer, (param_values + (signed long int)4)->data[(signed long int)0].v_pointer, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_marshal_VOID__POINTER_STRING_STRING_STRING
// file ./gm-marshal.h line 58
extern void gm_marshal_VOID__POINTER_STRING_STRING_STRING(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, void *, void *, void *, void *, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 5u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__POINTER_STRING_STRING_STRING", "n_param_values == 5");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, void *, void *, void *, void *, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_pointer, (param_values + (signed long int)2)->data[(signed long int)0].v_pointer, (param_values + (signed long int)3)->data[(signed long int)0].v_pointer, (param_values + (signed long int)4)->data[(signed long int)0].v_pointer, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_marshal_VOID__STRING_INT
// file gm-marshal.c line 92
extern void gm_marshal_VOID__STRING_INT(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, void *, signed int, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 3u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__STRING_INT", "n_param_values == 3");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, void *, signed int, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_pointer, (param_values + (signed long int)2)->data[(signed long int)0].v_int, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_marshal_VOID__STRING_UINT
// file gm-marshal.c line 55
extern void gm_marshal_VOID__STRING_UINT(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, void *, unsigned int, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 3u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__STRING_UINT", "n_param_values == 3");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, void *, unsigned int, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_pointer, (param_values + (signed long int)2)->data[(signed long int)0].v_uint, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_marshal_VOID__UINT_UINT
// file ./gm-marshal.h line 26
extern void gm_marshal_VOID__UINT_UINT(struct _GClosure *closure, struct _GValue *return_value, unsigned int n_param_values, const struct _GValue *param_values, void *invocation_hint, void *marshal_data)
{
  void (*callback)(void *, unsigned int, unsigned int, void *);
  struct _GCClosure *cc = (struct _GCClosure *)closure;
  void *data1;
  void *data2;
  do
    if(!(n_param_values == 3u))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_marshal_VOID__UINT_UINT", "n_param_values == 3");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  if(!(closure->derivative_flag == 0u))
  {
    data1 = closure->data;
    data2=g_value_peek_pointer(param_values + (signed long int)0);
  }

  else
  {
    data1=g_value_peek_pointer(param_values + (signed long int)0);
    data2 = closure->data;
  }
  void *tmp_if_expr$1;
  if(!(marshal_data == NULL))
    tmp_if_expr$1 = marshal_data;

  else
    tmp_if_expr$1 = cc->callback;
  callback = (void (*)(void *, unsigned int, unsigned int, void *))tmp_if_expr$1;
  callback(data1, (param_values + (signed long int)1)->data[(signed long int)0].v_uint, (param_values + (signed long int)2)->data[(signed long int)0].v_uint, data2);

__CPROVER_DUMP_L7:
  ;
}

// gm_mcp_awns_ping_class_init
// file mcp/gm-mcp-awns-ping.c line 35
static void gm_mcp_awns_ping_class_init(struct _GmMcpAwnsPingClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_awns_ping_finalize;
  pklass->name = "dns-com-awns-ping";
  pklass->handle_simple = gm_mcp_awns_ping_handle_simple;
}

// gm_mcp_awns_ping_class_intern_init
// file mcp/gm-mcp-awns-ping.c line 22
static void gm_mcp_awns_ping_class_intern_init(void *klass)
{
  gm_mcp_awns_ping_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpAwnsPing_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpAwnsPing_private_offset);

  gm_mcp_awns_ping_class_init((struct _GmMcpAwnsPingClass *)klass);
}

// gm_mcp_awns_ping_finalize
// file mcp/gm-mcp-awns-ping.c line 28
static void gm_mcp_awns_ping_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_awns_ping_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_mcp_awns_ping_get_type
// file mcp/gm-mcp-awns-ping.h line 54
unsigned long int gm_mcp_awns_ping_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpAwnsPing");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpAwnsPingClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_awns_ping_class_intern_init, (unsigned int)sizeof(struct _GmMcpAwnsPing) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_awns_ping_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_awns_ping_handle_simple
// file mcp/gm-mcp-awns-ping.c line 70
void gm_mcp_awns_ping_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  const char *id;
  if(suffix == ((char *)NULL))
  {
    id=gm_mcp_find_value(fields, "id");
    if(!(id == ((const char *)NULL)))
    {
      unsigned long int return_value_gm_mcp_package_get_type$1;
      return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
      struct _GObject *return_value_gm_mcp_package_get_session$3;
      return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
      unsigned long int return_value_gm_mcp_session_get_type$4;
      return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
      gm_mcp_session_send_simple((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5, "dns-com-awns-ping-reply", "id", id, (void *)0);
    }

  }

}

// gm_mcp_awns_ping_init
// file mcp/gm-mcp-awns-ping.c line 58
static void gm_mcp_awns_ping_init(struct _GmMcpAwnsPing *obj)
{
  ;
}

// gm_mcp_awns_ping_new
// file mcp/gm-mcp-awns-ping.c line 63
struct _GmMcpAwnsPing * gm_mcp_awns_ping_new(void)
{
  struct _GmMcpAwnsPing *obj;
  unsigned long int return_value_gm_mcp_awns_ping_get_type$1;
  return_value_gm_mcp_awns_ping_get_type$1=gm_mcp_awns_ping_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_awns_ping_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_awns_ping_get_type$3;
  return_value_gm_mcp_awns_ping_get_type$3=gm_mcp_awns_ping_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_awns_ping_get_type$3);
  obj = (struct _GmMcpAwnsPing *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_awns_status_class_init
// file mcp/gm-mcp-awns-status.c line 44
static void gm_mcp_awns_status_class_init(struct _GmMcpAwnsStatusClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_awns_status_finalize;
  gm_mcp_awns_status_signals[(signed long int)0]=g_signal_new("status_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)208ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  pklass->name = "dns-com-awns-status";
  pklass->handle_simple = gm_mcp_awns_status_handle_simple;
  pklass->create_view = gm_mcp_awns_status_create_view;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpAwnsStatusPrivate) /*8ul*/ );
}

// gm_mcp_awns_status_class_intern_init
// file mcp/gm-mcp-awns-status.c line 34
static void gm_mcp_awns_status_class_intern_init(void *klass)
{
  gm_mcp_awns_status_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpAwnsStatus_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpAwnsStatus_private_offset);

  gm_mcp_awns_status_class_init((struct _GmMcpAwnsStatusClass *)klass);
}

// gm_mcp_awns_status_create_view
// file mcp/gm-mcp-awns-status.c line 107
void gm_mcp_awns_status_create_view(struct _GmMcpPackage *package, struct _GObject *parent)
{
  struct _GmMcpAwnsStatusView *status_view;
  signed int tmp_statement_expression$7;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)parent;
  unsigned long int __t;
  __t=gm_world_view_get_type();
  signed int __r;
  _Bool tmp_if_expr$8;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$8 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$7 = __r;
  if(!(tmp_statement_expression$7 == 0))
  {
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmMcpAwnsStatusView) /*16ul*/ );
    status_view = (struct _GmMcpAwnsStatusView *)return_value_g_malloc0_n$1;
    unsigned long int return_value_gm_mcp_awns_status_get_type$2;
    return_value_gm_mcp_awns_status_get_type$2=gm_mcp_awns_status_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_awns_status_get_type$2);
    status_view->package = (struct _GmMcpAwnsStatus *)return_value_g_type_check_instance_cast$3;
    unsigned long int return_value_gm_world_view_get_type$4;
    return_value_gm_world_view_get_type$4=gm_world_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gm_world_view_get_type$4);
    status_view->view = (struct _GmWorldView *)return_value_g_type_check_instance_cast$5;
    g_signal_connect_data((void *)package, "status_changed", (void (*)(void))on_gm_mcp_awns_status_view_status_changed, (void *)status_view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)package, (unsigned long int)(20 << 2));
    g_object_weak_ref((struct _GObject *)return_value_g_type_check_instance_cast$6, on_gm_mcp_awns_status_view_weak_notify, (void *)status_view);
  }

}

// gm_mcp_awns_status_finalize
// file mcp/gm-mcp-awns-status.c line 37
static void gm_mcp_awns_status_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_awns_status_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_mcp_awns_status_get_type
// file mcp/gm-mcp-awns-status.h line 53
unsigned long int gm_mcp_awns_status_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpAwnsStatus");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpAwnsStatusClass) /*216ul*/ , (void (*)(void *, void *))gm_mcp_awns_status_class_intern_init, (unsigned int)sizeof(struct _GmMcpAwnsStatus) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_awns_status_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_awns_status_handle_simple
// file mcp/gm-mcp-awns-status.c line 84
void gm_mcp_awns_status_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  const char *text;
  text=gm_mcp_find_value(fields, "text");
  gm_debug_msg(DEBUG_MCP, "GmMcpAwnsStatus.HandleSimple: set status %s", text);
  g_signal_emit((void *)package, gm_mcp_awns_status_signals[(signed long int)0], (unsigned int)0, text);
}

// gm_mcp_awns_status_init
// file mcp/gm-mcp-awns-status.c line 69
static void gm_mcp_awns_status_init(struct _GmMcpAwnsStatus *obj)
{
  unsigned long int return_value_gm_mcp_awns_status_get_type$1;
  return_value_gm_mcp_awns_status_get_type$1=gm_mcp_awns_status_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_awns_status_get_type$1);
  obj->priv = (struct _GmMcpAwnsStatusPrivate *)return_value_g_type_instance_get_private$2;
}

// gm_mcp_awns_status_new
// file mcp/gm-mcp-awns-status.c line 75
struct _GmMcpAwnsStatus * gm_mcp_awns_status_new(void)
{
  struct _GmMcpAwnsStatus *obj;
  unsigned long int return_value_gm_mcp_awns_status_get_type$1;
  return_value_gm_mcp_awns_status_get_type$1=gm_mcp_awns_status_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_awns_status_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_awns_status_get_type$3;
  return_value_gm_mcp_awns_status_get_type$3=gm_mcp_awns_status_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_awns_status_get_type$3);
  obj = (struct _GmMcpAwnsStatus *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_classes_initialize
// file mcp/gm-mcp-classes.c line 14
struct _GList * gm_mcp_classes_initialize()
{
  struct _GList *result = (struct _GList *)(void *)0;
  unsigned long int return_value_gm_mcp_negotiate_get_type$1;
  return_value_gm_mcp_negotiate_get_type$1=gm_mcp_negotiate_get_type();
  void *return_value_g_type_class_ref$2;
  return_value_g_type_class_ref$2=g_type_class_ref(return_value_gm_mcp_negotiate_get_type$1);
  result=g_list_append(result, return_value_g_type_class_ref$2);
  unsigned long int return_value_gm_mcp_awns_status_get_type$3;
  return_value_gm_mcp_awns_status_get_type$3=gm_mcp_awns_status_get_type();
  void *return_value_g_type_class_ref$4;
  return_value_g_type_class_ref$4=g_type_class_ref(return_value_gm_mcp_awns_status_get_type$3);
  result=g_list_append(result, return_value_g_type_class_ref$4);
  unsigned long int return_value_gm_mcp_vmoo_client_get_type$5;
  return_value_gm_mcp_vmoo_client_get_type$5=gm_mcp_vmoo_client_get_type();
  void *return_value_g_type_class_ref$6;
  return_value_g_type_class_ref$6=g_type_class_ref(return_value_gm_mcp_vmoo_client_get_type$5);
  result=g_list_append(result, return_value_g_type_class_ref$6);
  unsigned long int return_value_gm_mcp_awns_ping_get_type$7;
  return_value_gm_mcp_awns_ping_get_type$7=gm_mcp_awns_ping_get_type();
  void *return_value_g_type_class_ref$8;
  return_value_g_type_class_ref$8=g_type_class_ref(return_value_gm_mcp_awns_ping_get_type$7);
  result=g_list_append(result, return_value_g_type_class_ref$8);
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$9;
  return_value_gm_mcp_icecrew_playerdb_get_type$9=gm_mcp_icecrew_playerdb_get_type();
  void *return_value_g_type_class_ref$10;
  return_value_g_type_class_ref$10=g_type_class_ref(return_value_gm_mcp_icecrew_playerdb_get_type$9);
  result=g_list_append(result, return_value_g_type_class_ref$10);
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$11;
  return_value_gm_mcp_icecrew_userlist_get_type$11=gm_mcp_icecrew_userlist_get_type();
  void *return_value_g_type_class_ref$12;
  return_value_g_type_class_ref$12=g_type_class_ref(return_value_gm_mcp_icecrew_userlist_get_type$11);
  result=g_list_append(result, return_value_g_type_class_ref$12);
  unsigned long int return_value_gm_mcp_icecrew_mcpreset_get_type$13;
  return_value_gm_mcp_icecrew_mcpreset_get_type$13=gm_mcp_icecrew_mcpreset_get_type();
  void *return_value_g_type_class_ref$14;
  return_value_g_type_class_ref$14=g_type_class_ref(return_value_gm_mcp_icecrew_mcpreset_get_type$13);
  result=g_list_append(result, return_value_g_type_class_ref$14);
  unsigned long int return_value_gm_mcp_icecrew_serverinfo_get_type$15;
  return_value_gm_mcp_icecrew_serverinfo_get_type$15=gm_mcp_icecrew_serverinfo_get_type();
  void *return_value_g_type_class_ref$16;
  return_value_g_type_class_ref$16=g_type_class_ref(return_value_gm_mcp_icecrew_serverinfo_get_type$15);
  result=g_list_append(result, return_value_g_type_class_ref$16);
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$17;
  return_value_gm_mcp_vmoo_userlist_get_type$17=gm_mcp_vmoo_userlist_get_type();
  void *return_value_g_type_class_ref$18;
  return_value_g_type_class_ref$18=g_type_class_ref(return_value_gm_mcp_vmoo_userlist_get_type$17);
  result=g_list_append(result, return_value_g_type_class_ref$18);
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$19;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$19=gm_mcp_mud_moo_simpleedit_get_type();
  void *return_value_g_type_class_ref$20;
  return_value_g_type_class_ref$20=g_type_class_ref(return_value_gm_mcp_mud_moo_simpleedit_get_type$19);
  result=g_list_append(result, return_value_g_type_class_ref$20);
  return result;
}

// gm_mcp_destroy_fields
// file mcp/gm-mcp.c line 248
void gm_mcp_destroy_fields(struct _GList *fields)
{
  struct _GmKeyValuePair *tmp;
  struct _GList *elem = fields;
  for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
  {
    tmp = (struct _GmKeyValuePair *)elem->data;
    g_free((void *)tmp->key);
    g_free((void *)tmp->value);
    g_free(elem->data);
    elem->data = (void *)0;
  }
  g_list_free(fields);
}

// gm_mcp_escape_if_needed
// file mcp/gm-mcp.c line 42
char * gm_mcp_escape_if_needed(const char *line)
{
  struct _GString *new_line;
  const char *ptr = line;
  char *result;
  if((signed int)*line == 0)
  {
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("\"\"");
    return return_value_g_strdup$1;
  }

  char *return_value_g_utf8_strchr$4;
  return_value_g_utf8_strchr$4=g_utf8_strchr(line, (signed long int)-1, (unsigned int)32);
  _Bool tmp_if_expr$6;
  char *return_value_g_utf8_strchr$5;
  if(!(return_value_g_utf8_strchr$4 == ((char *)NULL)))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_g_utf8_strchr$5=g_utf8_strchr(line, (signed long int)-1, (unsigned int)34);
    tmp_if_expr$6 = return_value_g_utf8_strchr$5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$8;
  char *return_value_g_utf8_strchr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$8 = (_Bool)1;

  else
  {
    return_value_g_utf8_strchr$7=g_utf8_strchr(line, (signed long int)-1, (unsigned int)92);
    tmp_if_expr$8 = return_value_g_utf8_strchr$7 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$8)
  {
    new_line=g_string_new("\"");
    for( ; !((signed int)*ptr == 0); ptr = ptr + 1l)
    {
      if((signed int)*ptr == 34)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)*ptr == 92 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        new_line=g_string_append_c_inline(new_line, (char)92);

      new_line=g_string_append_c_inline(new_line, *ptr);
    }
    new_line=g_string_append_c_inline(new_line, (char)34);
    result = new_line->str;
    g_string_free(new_line, 0);
    return result;
  }

  else
  {
    char *return_value_g_strdup$3;
    return_value_g_strdup$3=g_strdup(line);
    return return_value_g_strdup$3;
  }
}

// gm_mcp_find_multiline_tag
// file mcp/gm-mcp.c line 229
const char * gm_mcp_find_multiline_tag(const struct _GList *fields)
{
  struct _GmKeyValuePair *data;
  unsigned int last;
  while(!(fields == ((const struct _GList *)NULL)))
  {
    data = (struct _GmKeyValuePair *)fields->data;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(data->key);
    char *return_value_g_utf8_prev_char$2;
    return_value_g_utf8_prev_char$2=g_utf8_prev_char(data->key + (signed long int)return_value_strlen$1);
    last=g_utf8_get_char(return_value_g_utf8_prev_char$2);
    if(last == 42u)
      return data->key;

    fields = fields->next;
  }
  return (const char *)(void *)0;
}

// gm_mcp_find_value
// file mcp/gm-mcp.c line 25
const char * gm_mcp_find_value(const struct _GList *fields, const char *key)
{
  struct _GmKeyValuePair *tmp;
  while(!(fields == ((const struct _GList *)NULL)))
  {
    tmp = (struct _GmKeyValuePair *)fields->data;
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(key, tmp->key);
    if(return_value_strcasecmp$1 == 0)
      return tmp->value;

    fields = fields->next;
  }
  return (const char *)(void *)0;
}

// gm_mcp_generate_auth_key
// file mcp/gm-mcp.c line 224
char * gm_mcp_generate_auth_key()
{
  char *return_value_gm_mcp_generate_key$1;
  return_value_gm_mcp_generate_key$1=gm_mcp_generate_key(6);
  return return_value_gm_mcp_generate_key$1;
}

// gm_mcp_generate_data_tag
// file mcp/gm-mcp.c line 219
char * gm_mcp_generate_data_tag()
{
  char *return_value_gm_mcp_generate_key$1;
  return_value_gm_mcp_generate_key$1=gm_mcp_generate_key(10);
  return return_value_gm_mcp_generate_key$1;
}

// gm_mcp_generate_key
// file mcp/gm-mcp.c line 201
char * gm_mcp_generate_key(signed int len)
{
  char *s;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc((unsigned long int)(len + 1));
  s = (char *)return_value_g_malloc$1;
  char ref[64l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 0 };
  signed int n;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(ref);
  n = (signed int)return_value_strlen$2;
  signed int i;
  signed long int return_value_time$3;
  return_value_time$3=time((signed long int *)(void *)0);
  srand((unsigned int)(signed int)return_value_time$3);
  i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    signed int return_value_rand$4;
    return_value_rand$4=rand();
    s[(signed long int)i] = ref[(signed long int)(return_value_rand$4 % n)];
  }
  s[(signed long int)i] = (char)0;
  return s;
}

// gm_mcp_get_version
// file mcp/gm-mcp.c line 11
double gm_mcp_get_version(double client_min, double client_max, double server_min, double server_max)
{
  if(client_max >= server_min && server_max >= client_min)
  {
    if(client_max < server_max)
      return client_max;

    else
      return server_max;
  }

  else
    return 0.0;
}

// gm_mcp_icecrew_mcpreset_class_init
// file mcp/gm-mcp-icecrew-mcpreset.c line 34
static void gm_mcp_icecrew_mcpreset_class_init(struct _GmMcpIcecrewMcpresetClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_icecrew_mcpreset_finalize;
  pklass->name = "dns-nl-icecrew-mcpreset";
  pklass->handle_simple = gm_mcp_icecrew_mcpreset_handle_simple;
}

// gm_mcp_icecrew_mcpreset_class_intern_init
// file mcp/gm-mcp-icecrew-mcpreset.c line 21
static void gm_mcp_icecrew_mcpreset_class_intern_init(void *klass)
{
  gm_mcp_icecrew_mcpreset_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpIcecrewMcpreset_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpIcecrewMcpreset_private_offset);

  gm_mcp_icecrew_mcpreset_class_init((struct _GmMcpIcecrewMcpresetClass *)klass);
}

// gm_mcp_icecrew_mcpreset_finalize
// file mcp/gm-mcp-icecrew-mcpreset.c line 27
static void gm_mcp_icecrew_mcpreset_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_icecrew_mcpreset_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_mcp_icecrew_mcpreset_get_type
// file mcp/gm-mcp-icecrew-mcpreset.h line 54
unsigned long int gm_mcp_icecrew_mcpreset_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpIcecrewMcpreset");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpIcecrewMcpresetClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_icecrew_mcpreset_class_intern_init, (unsigned int)sizeof(struct _GmMcpIcecrewMcpreset) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_icecrew_mcpreset_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_icecrew_mcpreset_handle_simple
// file mcp/gm-mcp-icecrew-mcpreset.c line 69
void gm_mcp_icecrew_mcpreset_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  gm_mcp_session_reset((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5);
}

// gm_mcp_icecrew_mcpreset_init
// file mcp/gm-mcp-icecrew-mcpreset.c line 57
static void gm_mcp_icecrew_mcpreset_init(struct _GmMcpIcecrewMcpreset *obj)
{
  ;
}

// gm_mcp_icecrew_mcpreset_new
// file mcp/gm-mcp-icecrew-mcpreset.c line 62
struct _GmMcpIcecrewMcpreset * gm_mcp_icecrew_mcpreset_new(void)
{
  struct _GmMcpIcecrewMcpreset *obj;
  unsigned long int return_value_gm_mcp_icecrew_mcpreset_get_type$1;
  return_value_gm_mcp_icecrew_mcpreset_get_type$1=gm_mcp_icecrew_mcpreset_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_icecrew_mcpreset_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_icecrew_mcpreset_get_type$3;
  return_value_gm_mcp_icecrew_mcpreset_get_type$3=gm_mcp_icecrew_mcpreset_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_icecrew_mcpreset_get_type$3);
  obj = (struct _GmMcpIcecrewMcpreset *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_icecrew_playerdb_add_player
// file mcp/gm-mcp-icecrew-playerdb.c line 244
struct _GmPlayerdbPlayerInfo * gm_mcp_icecrew_playerdb_add_player(struct _GmMcpIcecrewPlayerdb *package, signed int id)
{
  struct _GmPlayerdbPlayerInfo *ppi;
  void *return_value_g_malloc_n$1;
  return_value_g_malloc_n$1=g_malloc_n((unsigned long int)1, sizeof(struct _GmPlayerdbPlayerInfo) /*16ul*/ );
  ppi = (struct _GmPlayerdbPlayerInfo *)return_value_g_malloc_n$1;
  ppi->values=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
  ppi->id = id;
  package->priv->db=g_list_append(package->priv->db, (void *)ppi);
  gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewPlayerdb.AddPlayer: adding id %d", id);
  return ppi;
}

// gm_mcp_icecrew_playerdb_class_init
// file mcp/gm-mcp-icecrew-playerdb.c line 60
static void gm_mcp_icecrew_playerdb_class_init(struct _GmMcpIcecrewPlayerdbClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_icecrew_playerdb_finalize;
  gm_mcp_icecrew_playerdb_signals[(signed long int)0]=g_signal_new("add", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)208ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__POINTER, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(17 << 2));
  gm_mcp_icecrew_playerdb_signals[(signed long int)1]=g_signal_new("set", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)216ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, gm_marshal_VOID__POINTER_STRING_STRING_STRING, (unsigned long int)(1 << 2), (unsigned int)4, (unsigned long int)(17 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
  gm_mcp_icecrew_playerdb_signals[(signed long int)2]=g_signal_new("delete", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)224ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__POINTER, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(17 << 2));
  pklass->name = "dns-nl-icecrew-playerdb";
  pklass->handle_simple = gm_mcp_icecrew_playerdb_handle_simple;
  pklass->handle_multi = gm_mcp_icecrew_playerdb_handle_multi;
  pklass->min_version = 1.0;
  pklass->max_version = 1.1;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpIcecrewPlayerdbPrivate) /*24ul*/ );
}

// gm_mcp_icecrew_playerdb_class_intern_init
// file mcp/gm-mcp-icecrew-playerdb.c line 32
static void gm_mcp_icecrew_playerdb_class_intern_init(void *klass)
{
  gm_mcp_icecrew_playerdb_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpIcecrewPlayerdb_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpIcecrewPlayerdb_private_offset);

  gm_mcp_icecrew_playerdb_class_init((struct _GmMcpIcecrewPlayerdbClass *)klass);
}

// gm_mcp_icecrew_playerdb_finalize
// file mcp/gm-mcp-icecrew-playerdb.c line 42
static void gm_mcp_icecrew_playerdb_finalize(struct _GObject *object)
{
  struct _GmMcpIcecrewPlayerdb *obj;
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$1;
  return_value_gm_mcp_icecrew_playerdb_get_type$1=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_mcp_icecrew_playerdb_get_type$1);
  obj = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$2;
  struct _GmPlayerdbPlayerInfo *ppi;
  struct _GList *f = obj->priv->db;
  for( ; !(f == ((struct _GList *)NULL)); f = f->next)
  {
    ppi = (struct _GmPlayerdbPlayerInfo *)f->data;
    g_hash_table_destroy(ppi->values);
    g_free((void *)ppi);
  }
  g_list_free(obj->priv->db);
  gm_mcp_list_free(obj->priv->last_init_keys);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_icecrew_playerdb_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_mcp_icecrew_playerdb_find
// file mcp/gm-mcp-icecrew-playerdb.c line 126
struct _GmPlayerdbPlayerInfo * gm_mcp_icecrew_playerdb_find(struct _GmMcpIcecrewPlayerdb *package, signed int id)
{
  struct _GmPlayerdbPlayerInfo *ppi;
  struct _GList *item = package->priv->db;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    ppi = (struct _GmPlayerdbPlayerInfo *)item->data;
    if(ppi->id == id)
      return ppi;

  }
  return (struct _GmPlayerdbPlayerInfo *)(void *)0;
}

// gm_mcp_icecrew_playerdb_find_players_with
// file mcp/gm-mcp-icecrew-playerdb.c line 152
void gm_mcp_icecrew_playerdb_find_players_with(struct _GmMcpIcecrewPlayerdb *package, const char *key, const char *value, void (*func)(struct _GmPlayerdbPlayerInfo *, void *), void *user_data)
{
  struct _GmPlayerdbPlayerInfo *ppi;
  const char *v;
  struct _GList *db = package->priv->db;
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  for( ; !(db == ((struct _GList *)NULL)); db = db->next)
  {
    ppi = (struct _GmPlayerdbPlayerInfo *)db->data;
    v=gm_playerdb_player_info_get_prop(ppi, key);
    if(!(v == ((const char *)NULL)))
    {
      if(value == ((const char *)NULL))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_strcmp$1=strcmp(v, value);
        tmp_if_expr$2 = return_value_strcmp$1 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        func(ppi, user_data);

    }

  }
}

// gm_mcp_icecrew_playerdb_get_type
// file mcp/gm-mcp-icecrew-playerdb.h line 64
unsigned long int gm_mcp_icecrew_playerdb_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpIcecrewPlayerdb");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpIcecrewPlayerdbClass) /*232ul*/ , (void (*)(void *, void *))gm_mcp_icecrew_playerdb_class_intern_init, (unsigned int)sizeof(struct _GmMcpIcecrewPlayerdb) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_icecrew_playerdb_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_icecrew_playerdb_handle_multi
// file mcp/gm-mcp-icecrew-playerdb.c line 304
signed int gm_mcp_icecrew_playerdb_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values)
{
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$1;
  return_value_gm_mcp_icecrew_playerdb_get_type$1=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_icecrew_playerdb_get_type$1);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$2;
  signed int i;
  unsigned int counter;
  char *id;
  char *list;
  const char *ptr = value;
  struct _GList *l;
  struct _GmPlayerdbPlayerInfo *ppi;
  unsigned int uc;
  unsigned int return_value_g_utf8_get_char$3;
  unsigned int return_value_g_list_length$4;
  if(!(key == ((const char *)NULL)))
  {
    gm_string_skip_space(&value);
    ptr = value;
    gm_string_skip_nonspace(&ptr);
    if((signed int)*ptr == 0)
      return (signed int)!(0 != 0);

    id=g_strndup(value, (unsigned long int)(ptr - value));
    gm_string_skip_space(&ptr);
    value = ptr;
    unsigned int return_value_g_utf8_get_char$9;
    return_value_g_utf8_get_char$9=g_utf8_get_char(ptr);
    if(return_value_g_utf8_get_char$9 == 34u)
    {
      ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
      value = ptr;
      i = 0;
      while(!((signed int)*ptr == 0))
      {
        uc=g_utf8_get_char(ptr);
        if(uc == 34u)
          break;

        ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
        if(uc == 92u)
        {
          return_value_g_utf8_get_char$3=g_utf8_get_char(ptr);
          if(!(return_value_g_utf8_get_char$3 == 0u))
            ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);

        }

      }
      list=g_strndup(value, (unsigned long int)(ptr - value));
      l=gm_mcp_parse_list(list);
      unsigned int return_value_g_list_length$7;
      return_value_g_list_length$7=g_list_length(l);
      unsigned int return_value_g_list_length$8;
      return_value_g_list_length$8=g_list_length(playerdb->priv->last_init_keys);
      if(return_value_g_list_length$7 == return_value_g_list_length$8)
      {
        i=atoi(id);
        ppi=gm_mcp_icecrew_playerdb_find(playerdb, i);
        if(!(ppi == ((struct _GmPlayerdbPlayerInfo *)NULL)))
          gm_mcp_icecrew_playerdb_remove_player(playerdb, i);

        ppi=gm_mcp_icecrew_playerdb_add_player(playerdb, i);
        counter = (unsigned int)0;
        do
        {
          return_value_g_list_length$4=g_list_length(l);
          if(counter >= return_value_g_list_length$4)
            break;

          void *return_value_g_list_nth_data$5;
          return_value_g_list_nth_data$5=g_list_nth_data(playerdb->priv->last_init_keys, counter);
          void *return_value_g_list_nth_data$6;
          return_value_g_list_nth_data$6=g_list_nth_data(l, counter);
          gm_mcp_icecrew_playerdb_modify_prop(playerdb, ppi, (const char *)return_value_g_list_nth_data$5, (const char *)return_value_g_list_nth_data$6, (signed int)!(0 != 0));
          counter = counter + 1u;
        }
        while((_Bool)1);
        g_signal_emit((void *)playerdb, gm_mcp_icecrew_playerdb_signals[(signed long int)0], (unsigned int)0, ppi);
      }

      g_free((void *)list);
      gm_mcp_list_free(l);
    }

    g_free((void *)id);
  }

  else
  {
    gm_mcp_list_free(playerdb->priv->last_init_keys);
    playerdb->priv->last_init_keys = (struct _GList *)(void *)0;
  }
  return (signed int)!(0 != 0);
}

// gm_mcp_icecrew_playerdb_handle_simple
// file mcp/gm-mcp-icecrew-playerdb.c line 258
void gm_mcp_icecrew_playerdb_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$1;
  return_value_gm_mcp_icecrew_playerdb_get_type$1=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_icecrew_playerdb_get_type$1);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$2;
  const char *value;
  struct _GmPlayerdbPlayerInfo *ppi;
  signed int id;
  signed int add;
  signed int return_value_strcasecmp$7;
  return_value_strcasecmp$7=strcasecmp(suffix, "self");
  _Bool tmp_if_expr$6;
  signed int return_value_strcasecmp$5;
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$3;
  if(return_value_strcasecmp$7 == 0)
  {
    value=gm_mcp_find_value(fields, "id");
    if(!(value == ((const char *)NULL)))
      playerdb->priv->self=atoi(value);

  }

  else
  {
    add=strcasecmp(suffix, "add");
    if(add == 0)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_strcasecmp$5=strcasecmp(suffix, "set");
      tmp_if_expr$6 = return_value_strcasecmp$5 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      value=gm_mcp_find_value(fields, "id");
      if(!(value == ((const char *)NULL)))
      {
        id=atoi(value);
        ppi=gm_mcp_icecrew_playerdb_find(playerdb, id);
        if(ppi == ((struct _GmPlayerdbPlayerInfo *)NULL) && add == 0)
        {
          ppi=gm_mcp_icecrew_playerdb_add_player(playerdb, id);
          gm_mcp_icecrew_playerdb_modify_prop_list(playerdb, ppi, fields, (signed int)!(0 != 0));
          g_signal_emit((void *)playerdb, gm_mcp_icecrew_playerdb_signals[(signed long int)0], (unsigned int)0, ppi);
        }

        else
          if(!(ppi == ((struct _GmPlayerdbPlayerInfo *)NULL)) && !(add == 0))
            gm_mcp_icecrew_playerdb_modify_prop_list(playerdb, ppi, fields, 0);

      }

    }

    else
    {
      return_value_strcasecmp$4=strcasecmp(suffix, "del");
      if(return_value_strcasecmp$4 == 0)
      {
        value=gm_mcp_find_value(fields, "id");
        if(!(value == ((const char *)NULL)))
        {
          id=atoi(value);
          gm_mcp_icecrew_playerdb_remove_player(playerdb, id);
        }

      }

      else
      {
        return_value_strcasecmp$3=strcasecmp(suffix, "init");
        if(return_value_strcasecmp$3 == 0)
        {
          value=gm_mcp_find_value(fields, "keys");
          if(!(value == ((const char *)NULL)))
          {
            if(!(playerdb->priv->last_init_keys == ((struct _GList *)NULL)))
              gm_mcp_list_free(playerdb->priv->last_init_keys);

            playerdb->priv->last_init_keys=gm_mcp_parse_list(value);
          }

        }

      }
    }
  }
}

// gm_mcp_icecrew_playerdb_init
// file mcp/gm-mcp-icecrew-playerdb.c line 109
static void gm_mcp_icecrew_playerdb_init(struct _GmMcpIcecrewPlayerdb *obj)
{
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$1;
  return_value_gm_mcp_icecrew_playerdb_get_type$1=gm_mcp_icecrew_playerdb_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_icecrew_playerdb_get_type$1);
  obj->priv = (struct _GmMcpIcecrewPlayerdbPrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->self = 0;
  obj->priv->db = (struct _GList *)(void *)0;
  obj->priv->last_init_keys = (struct _GList *)(void *)0;
}

// gm_mcp_icecrew_playerdb_initializing
// file mcp/gm-mcp-icecrew-playerdb.c line 147
signed int gm_mcp_icecrew_playerdb_initializing(struct _GmMcpIcecrewPlayerdb *package)
{
  return (signed int)(package->priv->last_init_keys != (struct _GList *)(void *)0);
}

// gm_mcp_icecrew_playerdb_modify_prop
// file mcp/gm-mcp-icecrew-playerdb.c line 208
void gm_mcp_icecrew_playerdb_modify_prop(struct _GmMcpIcecrewPlayerdb *package, struct _GmPlayerdbPlayerInfo *ppi, const char *key, const char *value, signed int add)
{
  if(!(ppi == ((struct _GmPlayerdbPlayerInfo *)NULL)))
    gm_mcp_icecrew_playerdb_set_prop(package, ppi, key, value, add);

}

// gm_mcp_icecrew_playerdb_modify_prop_list
// file mcp/gm-mcp-icecrew-playerdb.c line 217
void gm_mcp_icecrew_playerdb_modify_prop_list(struct _GmMcpIcecrewPlayerdb *package, struct _GmPlayerdbPlayerInfo *ppi, struct _GList *fields, signed int add)
{
  struct _GmKeyValuePair *data;
  if(!(ppi == ((struct _GmPlayerdbPlayerInfo *)NULL)))
    for( ; !(fields == ((struct _GList *)NULL)); fields = fields->next)
    {
      data = (struct _GmKeyValuePair *)fields->data;
      gm_mcp_icecrew_playerdb_set_prop(package, ppi, data->key, data->value, add);
    }

}

// gm_mcp_icecrew_playerdb_new
// file mcp/gm-mcp-icecrew-playerdb.c line 118
struct _GmMcpIcecrewPlayerdb * gm_mcp_icecrew_playerdb_new(void)
{
  struct _GmMcpIcecrewPlayerdb *obj;
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$1;
  return_value_gm_mcp_icecrew_playerdb_get_type$1=gm_mcp_icecrew_playerdb_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_icecrew_playerdb_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$3;
  return_value_gm_mcp_icecrew_playerdb_get_type$3=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_icecrew_playerdb_get_type$3);
  obj = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_icecrew_playerdb_players
// file mcp/gm-mcp-icecrew-playerdb.c line 171
struct _GList * gm_mcp_icecrew_playerdb_players(struct _GmMcpIcecrewPlayerdb *db)
{
  return db->priv->db;
}

// gm_mcp_icecrew_playerdb_remove_player
// file mcp/gm-mcp-icecrew-playerdb.c line 231
void gm_mcp_icecrew_playerdb_remove_player(struct _GmMcpIcecrewPlayerdb *package, signed int id)
{
  struct _GmPlayerdbPlayerInfo *ppi;
  ppi=gm_mcp_icecrew_playerdb_find(package, id);
  if(!(ppi == ((struct _GmPlayerdbPlayerInfo *)NULL)))
  {
    g_signal_emit((void *)package, gm_mcp_icecrew_playerdb_signals[(signed long int)2], (unsigned int)0, ppi);
    package->priv->db=g_list_remove(package->priv->db, (const void *)ppi);
    g_hash_table_destroy(ppi->values);
  }

}

// gm_mcp_icecrew_playerdb_set_prop
// file mcp/gm-mcp-icecrew-playerdb.c line 176
void gm_mcp_icecrew_playerdb_set_prop(struct _GmMcpIcecrewPlayerdb *package, struct _GmPlayerdbPlayerInfo *ppi, const char *key, const char *value, signed int add)
{
  char *old;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(key, "id");
  signed int return_value_strcmp$3;
  if(!(return_value_strcmp$1 == 0))
  {
    gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewPlayerdb.SetProp: key: %s, value: %s", key, value);
    const char *return_value_gm_playerdb_player_info_get_prop$2;
    return_value_gm_playerdb_player_info_get_prop$2=gm_playerdb_player_info_get_prop(ppi, key);
    old=g_strdup(return_value_gm_playerdb_player_info_get_prop$2);
    if(!(old == ((char *)NULL)))
    {
      return_value_strcmp$3=strcmp(old, value);
      if(!(return_value_strcmp$3 == 0))
        goto __CPROVER_DUMP_L2;

      gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewPlayerdb.SetProp: new value is the same as old value, no changes made");
      g_free((void *)old);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      char *return_value_g_strdup$4;
      return_value_g_strdup$4=g_strdup(key);
      char *return_value_g_strdup$5;
      return_value_g_strdup$5=g_strdup(value);
      g_hash_table_insert(ppi->values, (void *)return_value_g_strdup$4, (void *)return_value_g_strdup$5);
      if(add == 0)
        g_signal_emit((void *)package, gm_mcp_icecrew_playerdb_signals[(signed long int)1], (unsigned int)0, ppi, key, value, old);

      g_free((void *)old);
    }
  }

}

// gm_mcp_icecrew_serverinfo_class_init
// file mcp/gm-mcp-icecrew-serverinfo.c line 73
static void gm_mcp_icecrew_serverinfo_class_init(struct _GmMcpIcecrewServerinfoClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_icecrew_serverinfo_finalize;
  gm_mcp_icecrew_serverinfo_signals[(signed long int)0]=g_signal_new("got_info", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)208ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  pklass->name = "dns-nl-icecrew-serverinfo";
  pklass->handle_simple = gm_mcp_icecrew_serverinfo_handle_simple;
  pklass->create_view = gm_mcp_icecrew_serverinfo_create_view;
  pklass->set_session = gm_mcp_icecrew_serverinfo_set_session;
  pklass->min_version = 1.0;
  pklass->max_version = 1.1;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpIcecrewServerinfoPrivate) /*88ul*/ );
}

// gm_mcp_icecrew_serverinfo_class_intern_init
// file mcp/gm-mcp-icecrew-serverinfo.c line 36
static void gm_mcp_icecrew_serverinfo_class_intern_init(void *klass)
{
  gm_mcp_icecrew_serverinfo_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpIcecrewServerinfo_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpIcecrewServerinfo_private_offset);

  gm_mcp_icecrew_serverinfo_class_init((struct _GmMcpIcecrewServerinfoClass *)klass);
}

// gm_mcp_icecrew_serverinfo_create_view
// file mcp/gm-mcp-icecrew-serverinfo.c line 375
void gm_mcp_icecrew_serverinfo_create_view(struct _GmMcpPackage *package, struct _GObject *parent)
{
  struct _GmMcpIcecrewServerinfoView *view;
  signed int tmp_statement_expression$1;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)parent;
  unsigned long int __t;
  __t=gm_app_view_get_type();
  signed int __r;
  _Bool tmp_if_expr$2;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$1 = __r;
  if(!(tmp_statement_expression$1 == 0))
  {
    void *return_value_g_malloc_n$3;
    return_value_g_malloc_n$3=g_malloc_n((unsigned long int)1, sizeof(struct _GmMcpIcecrewServerinfoView) /*16ul*/ );
    view = (struct _GmMcpIcecrewServerinfoView *)return_value_g_malloc_n$3;
    unsigned long int return_value_gm_app_view_get_type$4;
    return_value_gm_app_view_get_type$4=gm_app_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gm_app_view_get_type$4);
    view->view = (struct _GmAppView *)return_value_g_type_check_instance_cast$5;
    unsigned long int return_value_gm_mcp_icecrew_serverinfo_get_type$6;
    return_value_gm_mcp_icecrew_serverinfo_get_type$6=gm_mcp_icecrew_serverinfo_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_icecrew_serverinfo_get_type$6);
    view->package = (struct _GmMcpIcecrewServerinfo *)return_value_g_type_check_instance_cast$7;
    g_signal_connect_data((void *)package, "got_info", (void (*)(void))on_gm_mcp_icecrew_serverinfo_view_got_info, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    unsigned long int return_value_gm_mcp_package_get_type$8;
    return_value_gm_mcp_package_get_type$8=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$8);
    struct _GObject *return_value_gm_mcp_package_get_session$10;
    return_value_gm_mcp_package_get_session$10=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$9);
    unsigned long int return_value_gm_mcp_session_get_type$11;
    return_value_gm_mcp_session_get_type$11=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$10, return_value_gm_mcp_session_get_type$11);
    struct _GObject *return_value_gm_mcp_session_world$13;
    return_value_gm_mcp_session_world$13=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$12);
    unsigned long int return_value_gm_world_get_type$14;
    return_value_gm_world_get_type$14=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$13, return_value_gm_world_get_type$14);
    g_signal_connect_data((void *)(struct _GmWorld *)return_value_g_type_check_instance_cast$15, "notify::active", (void (*)(void))on_gm_mcp_icecrew_serverinfo_view_active_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)package, (unsigned long int)(20 << 2));
    g_object_weak_ref((struct _GObject *)return_value_g_type_check_instance_cast$16, on_gm_mcp_icecrew_serverinfo_view_weak_notify, (void *)view);
  }

}

// gm_mcp_icecrew_serverinfo_fetch_progress
// file mcp/gm-mcp-icecrew-serverinfo.c line 115
void gm_mcp_icecrew_serverinfo_fetch_progress(struct _GmFetchHandle *g, struct _GmMcpIcecrewServerinfo *package)
{
  char *path;
  struct _GdkPixbuf *pixtest;
  struct _GError *err = (struct _GError *)(void *)0;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  if(!(g->aborted == 0))
  {
    struct _GTypeInstance *gm_mcp_icecrew_serverinfo_fetch_progress$$1$$1$$1$$__inst = (struct _GTypeInstance *)package;
    unsigned long int __t;
    __t=gm_mcp_icecrew_serverinfo_get_type();
    signed int __r;
    if(gm_mcp_icecrew_serverinfo_fetch_progress$$1$$1$$1$$__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(gm_mcp_icecrew_serverinfo_fetch_progress$$1$$1$$1$$__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = gm_mcp_icecrew_serverinfo_fetch_progress$$1$$1$$1$$__inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(gm_mcp_icecrew_serverinfo_fetch_progress$$1$$1$$1$$__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(!(tmp_statement_expression$1 == 0))
      package->priv->handle = (struct _GmFetchHandle *)(void *)0;

    gm_debug_msg(DEBUG_MCP, "GmIcecrewServerInfo.FetchProgress: fetch aborted!");
  }

  else
    if(!(g->done == 0))
    {
      struct _GTypeInstance *__inst = (struct _GTypeInstance *)package;
      unsigned long int gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__t;
      gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__t=gm_mcp_icecrew_serverinfo_get_type();
      signed int gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__r;
      if(__inst == ((struct _GTypeInstance *)NULL))
        gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__r = 0;

      else
      {
        if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
          tmp_if_expr$4 = __inst->g_class->g_type == gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__t ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
          gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__r = (signed int)!(0 != 0);

        else
          gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__r=g_type_check_instance_is_a(__inst, gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__t);
      }
      tmp_statement_expression$3 = gm_mcp_icecrew_serverinfo_fetch_progress$$1$$2$$1$$__r;
      if(!(tmp_statement_expression$3 == 0))
        package->priv->handle = (struct _GmFetchHandle *)(void *)0;

      gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewServerinfo.FetchProgress: fetch done!");
    }

    else
      if((signed int)g->cur_phase == GNOME_VFS_XFER_PHASE_FILECOMPLETED)
      {
        path=gnome_vfs_get_local_path_from_uri(g->cur_file_name);
        pixtest=gdk_pixbuf_new_from_file(path, &err);
        gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewServerinfo.FetchProgress: %s fetched!", path);
        if(!(pixtest == ((struct _GdkPixbuf *)NULL)))
        {
          g_object_unref((void *)pixtest);
          package->priv->info.logo = path;
          unsigned long int return_value_gm_mcp_package_get_type$5;
          return_value_gm_mcp_package_get_type$5=gm_mcp_package_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
          return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$5);
          struct _GObject *return_value_gm_mcp_package_get_session$7;
          return_value_gm_mcp_package_get_session$7=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$6);
          unsigned long int return_value_gm_mcp_session_get_type$8;
          return_value_gm_mcp_session_get_type$8=gm_mcp_session_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
          return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$7, return_value_gm_mcp_session_get_type$8);
          struct _GObject *return_value_gm_mcp_session_world$10;
          return_value_gm_mcp_session_world$10=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$9);
          unsigned long int return_value_gm_world_get_type$11;
          return_value_gm_world_get_type$11=gm_world_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
          return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$10, return_value_gm_world_get_type$11);
          struct _GmOptions *return_value_gm_world_options$13;
          return_value_gm_world_options$13=gm_world_options((struct _GmWorld *)return_value_g_type_check_instance_cast$12);
          gm_options_set(return_value_gm_world_options$13, "logo", path);
          g_signal_emit((void *)package, gm_mcp_icecrew_serverinfo_signals[(signed long int)0], (unsigned int)0);
          g->aborted = (signed int)!(0 != 0);
        }

        else
        {
          gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewServerinfo.FetchProgress: Error on loading %s: %s", path, err->message);
          g_error_free(err);
          g_free((void *)path);
        }
      }

}

// gm_mcp_icecrew_serverinfo_finalize
// file mcp/gm-mcp-icecrew-serverinfo.c line 64
static void gm_mcp_icecrew_serverinfo_finalize(struct _GObject *object)
{
  struct _GmMcpIcecrewServerinfo *obj;
  unsigned long int return_value_gm_mcp_icecrew_serverinfo_get_type$1;
  return_value_gm_mcp_icecrew_serverinfo_get_type$1=gm_mcp_icecrew_serverinfo_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_mcp_icecrew_serverinfo_get_type$1);
  obj = (struct _GmMcpIcecrewServerinfo *)return_value_g_type_check_instance_cast$2;
  gm_mcp_icecrew_serverinfo_free_info(obj);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_icecrew_serverinfo_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_mcp_icecrew_serverinfo_free_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 46
void gm_mcp_icecrew_serverinfo_free_info(struct _GmMcpIcecrewServerinfo *obj)
{
  g_free((void *)obj->priv->info.homepage);
  g_free((void *)obj->priv->info.location);
  g_free((void *)obj->priv->info.admin);
  g_free((void *)obj->priv->info.contact);
  g_free((void *)obj->priv->info.charset);
  g_free((void *)obj->priv->info.language);
  g_free((void *)obj->priv->info.system);
  g_free((void *)obj->priv->info.logo);
  if(!(obj->priv->handle == ((struct _GmFetchHandle *)NULL)))
    obj->priv->handle->aborted = (signed int)!(0 != 0);

  memset((void *)&obj->priv->info, 0, sizeof(struct _GmWorldInfo) /*72ul*/ );
}

// gm_mcp_icecrew_serverinfo_get_type
// file mcp/gm-mcp-icecrew-serverinfo.h line 54
unsigned long int gm_mcp_icecrew_serverinfo_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpIcecrewServerinfo");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpIcecrewServerinfoClass) /*216ul*/ , (void (*)(void *, void *))gm_mcp_icecrew_serverinfo_class_intern_init, (unsigned int)sizeof(struct _GmMcpIcecrewServerinfo) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_icecrew_serverinfo_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_icecrew_serverinfo_handle_simple
// file mcp/gm-mcp-icecrew-serverinfo.c line 168
void gm_mcp_icecrew_serverinfo_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  struct _GmMcpIcecrewServerinfo *serverinfo;
  unsigned long int return_value_gm_mcp_icecrew_serverinfo_get_type$1;
  return_value_gm_mcp_icecrew_serverinfo_get_type$1=gm_mcp_icecrew_serverinfo_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_icecrew_serverinfo_get_type$1);
  serverinfo = (struct _GmMcpIcecrewServerinfo *)return_value_g_type_check_instance_cast$2;
  char *base;
  char *path;
  char **alternatives;
  char **ptr;
  const char *logo;
  struct _GList *source = (struct _GList *)(void *)0;
  struct _GList *dest = (struct _GList *)(void *)0;
  enum anonymous$32 result;
  struct anonymous$31 *finfo;
  signed int return_value_strcmp$32;
  return_value_strcmp$32=strcmp(suffix, "set");
  if(return_value_strcmp$32 == 0)
  {
    gm_mcp_icecrew_serverinfo_free_info(serverinfo);
    const char *return_value_gm_mcp_find_value$3;
    return_value_gm_mcp_find_value$3=gm_mcp_find_value(fields, "name");
    serverinfo->priv->info.name=g_strdup(return_value_gm_mcp_find_value$3);
    const char *return_value_gm_mcp_find_value$4;
    return_value_gm_mcp_find_value$4=gm_mcp_find_value(fields, "homepage");
    serverinfo->priv->info.homepage=g_strdup(return_value_gm_mcp_find_value$4);
    const char *return_value_gm_mcp_find_value$5;
    return_value_gm_mcp_find_value$5=gm_mcp_find_value(fields, "location");
    serverinfo->priv->info.location=g_strdup(return_value_gm_mcp_find_value$5);
    const char *return_value_gm_mcp_find_value$6;
    return_value_gm_mcp_find_value$6=gm_mcp_find_value(fields, "admin");
    serverinfo->priv->info.admin=g_strdup(return_value_gm_mcp_find_value$6);
    const char *return_value_gm_mcp_find_value$7;
    return_value_gm_mcp_find_value$7=gm_mcp_find_value(fields, "contact");
    serverinfo->priv->info.contact=g_strdup(return_value_gm_mcp_find_value$7);
    const char *return_value_gm_mcp_find_value$8;
    return_value_gm_mcp_find_value$8=gm_mcp_find_value(fields, "charset");
    serverinfo->priv->info.charset=g_strdup(return_value_gm_mcp_find_value$8);
    const char *return_value_gm_mcp_find_value$9;
    return_value_gm_mcp_find_value$9=gm_mcp_find_value(fields, "language");
    serverinfo->priv->info.language=g_strdup(return_value_gm_mcp_find_value$9);
    const char *return_value_gm_mcp_find_value$10;
    return_value_gm_mcp_find_value$10=gm_mcp_find_value(fields, "system");
    serverinfo->priv->info.system=g_strdup(return_value_gm_mcp_find_value$10);
    unsigned long int return_value_gm_mcp_package_get_type$11;
    return_value_gm_mcp_package_get_type$11=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$11);
    struct _GObject *return_value_gm_mcp_package_get_session$13;
    return_value_gm_mcp_package_get_session$13=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$12);
    unsigned long int return_value_gm_mcp_session_get_type$14;
    return_value_gm_mcp_session_get_type$14=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$13, return_value_gm_mcp_session_get_type$14);
    struct _GObject *return_value_gm_mcp_session_world$16;
    return_value_gm_mcp_session_world$16=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$15);
    unsigned long int return_value_gm_world_get_type$17;
    return_value_gm_world_get_type$17=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$16, return_value_gm_world_get_type$17);
    struct _GmOptions *return_value_gm_world_options$19;
    return_value_gm_world_options$19=gm_world_options((struct _GmWorld *)return_value_g_type_check_instance_cast$18);
    gm_options_set(return_value_gm_world_options$19, "mooname", serverinfo->priv->info.name);
    logo=gm_mcp_find_value(fields, "logo");
    if(!(logo == ((const char *)NULL)))
    {
      alternatives=g_strsplit(logo, ";", 0);
      ptr = alternatives;
      for( ; !(*ptr == ((char *)NULL)); ptr = ptr + 1l)
      {
        finfo=gnome_vfs_file_info_new();
        result=gnome_vfs_get_file_info(*ptr, finfo, (enum anonymous$33)GNOME_VFS_FILE_INFO_DEFAULT);
        gnome_vfs_file_info_unref(finfo);
        if(!((signed int)result == GNOME_VFS_OK))
        {
          const char *return_value_gnome_vfs_result_to_string$20;
          return_value_gnome_vfs_result_to_string$20=gnome_vfs_result_to_string(result);
          gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewServerinfo.HandleSimple: Ignore logo alternative %s because it's invalid: %s", *ptr, return_value_gnome_vfs_result_to_string$20);
        }

        else
        {
          base=g_path_get_basename(*ptr);
          if(!(base == ((char *)NULL)))
          {
            if(!((signed int)*base == 0))
            {
              if(!((signed int)base[1l] == 0))
              {
                unsigned long int return_value_gm_mcp_package_get_type$21;
                return_value_gm_mcp_package_get_type$21=gm_mcp_package_get_type();
                struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
                return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$21);
                struct _GObject *return_value_gm_mcp_package_get_session$23;
                return_value_gm_mcp_package_get_session$23=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$22);
                unsigned long int return_value_gm_mcp_session_get_type$24;
                return_value_gm_mcp_session_get_type$24=gm_mcp_session_get_type();
                struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
                return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$23, return_value_gm_mcp_session_get_type$24);
                struct _GObject *return_value_gm_mcp_session_world$26;
                return_value_gm_mcp_session_world$26=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$25);
                unsigned long int return_value_gm_world_get_type$27;
                return_value_gm_world_get_type$27=gm_world_get_type();
                struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
                return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$26, return_value_gm_world_get_type$27);
                const char *return_value_gm_world_path$29;
                return_value_gm_world_path$29=gm_world_path((struct _GmWorld *)return_value_g_type_check_instance_cast$28);
                path=g_strconcat(return_value_gm_world_path$29, (const void *)"/", (const void *)"pixmaps", (const void *)"/", base, (void *)0);
                char *return_value_g_strdup$30;
                return_value_g_strdup$30=g_strdup(*ptr);
                source=g_list_append(source, (void *)return_value_g_strdup$30);
                dest=g_list_append(dest, (void *)path);
              }

            }

          }

          g_free((void *)base);
        }
      }
      g_strfreev(alternatives);
      if(!(source == ((struct _GList *)NULL)))
      {
        if(!(serverinfo->priv->handle == ((struct _GmFetchHandle *)NULL)))
        {
          serverinfo->priv->handle->aborted = (signed int)!(0 != 0);
          while(!(serverinfo->priv->handle == ((struct _GmFetchHandle *)NULL)))
            gm_do_events();
        }

        if(!(serverinfo->priv->info.logo == ((char *)NULL)))
        {
          signed int return_value_g_file_test$31;
          return_value_g_file_test$31=g_file_test(serverinfo->priv->info.logo, (enum anonymous$106)G_FILE_TEST_EXISTS);
          if(!(return_value_g_file_test$31 == 0))
            unlink(serverinfo->priv->info.logo);

          g_free((void *)serverinfo->priv->info.logo);
          serverinfo->priv->info.logo = (char *)(void *)0;
        }

        gm_fetch(source, dest, (void (*)(void *, void *))gm_mcp_icecrew_serverinfo_fetch_progress, (void *)serverinfo);
        gm_g_list_free_simple(source);
        gm_g_list_free_simple(dest);
      }

    }

    serverinfo->priv->has_info = (signed int)!(0 != 0);
    g_signal_emit((void *)serverinfo, gm_mcp_icecrew_serverinfo_signals[(signed long int)0], (unsigned int)0);
  }

}

// gm_mcp_icecrew_serverinfo_has_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 293
signed int gm_mcp_icecrew_serverinfo_has_info(struct _GmMcpIcecrewServerinfo *package)
{
  return package->priv->has_info;
}

// gm_mcp_icecrew_serverinfo_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 298
const struct _GmWorldInfo * gm_mcp_icecrew_serverinfo_info(struct _GmMcpIcecrewServerinfo *package)
{
  return &package->priv->info;
}

// gm_mcp_icecrew_serverinfo_init
// file mcp/gm-mcp-icecrew-serverinfo.c line 100
static void gm_mcp_icecrew_serverinfo_init(struct _GmMcpIcecrewServerinfo *obj)
{
  unsigned long int return_value_gm_mcp_icecrew_serverinfo_get_type$1;
  return_value_gm_mcp_icecrew_serverinfo_get_type$1=gm_mcp_icecrew_serverinfo_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_icecrew_serverinfo_get_type$1);
  obj->priv = (struct _GmMcpIcecrewServerinfoPrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->has_info = 0;
}

// gm_mcp_icecrew_serverinfo_new
// file mcp/gm-mcp-icecrew-serverinfo.c line 107
struct _GmMcpIcecrewServerinfo * gm_mcp_icecrew_serverinfo_new(void)
{
  struct _GmMcpIcecrewServerinfo *obj;
  unsigned long int return_value_gm_mcp_icecrew_serverinfo_get_type$1;
  return_value_gm_mcp_icecrew_serverinfo_get_type$1=gm_mcp_icecrew_serverinfo_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_icecrew_serverinfo_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_icecrew_serverinfo_get_type$3;
  return_value_gm_mcp_icecrew_serverinfo_get_type$3=gm_mcp_icecrew_serverinfo_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_icecrew_serverinfo_get_type$3);
  obj = (struct _GmMcpIcecrewServerinfo *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_icecrew_serverinfo_set_session
// file mcp/gm-mcp-icecrew-serverinfo.c line 271
void gm_mcp_icecrew_serverinfo_set_session(struct _GmMcpPackage *package, struct _GObject *session)
{
  struct _GmMcpPackageClass *gm_mcp_icecrew_serverinfo_set_session$$1$$parent_class;
  void *return_value_g_type_class_peek_parent$1;
  return_value_g_type_class_peek_parent$1=g_type_class_peek_parent((void *)(struct _GmMcpIcecrewServerinfoClass *)((struct _GTypeInstance *)package)->g_class);
  gm_mcp_icecrew_serverinfo_set_session$$1$$parent_class = (struct _GmMcpPackageClass *)return_value_g_type_class_peek_parent$1;
  char *path;
  gm_mcp_icecrew_serverinfo_set_session$$1$$parent_class->set_session(package, session);
  unsigned long int return_value_gm_mcp_session_get_type$2;
  return_value_gm_mcp_session_get_type$2=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)session, return_value_gm_mcp_session_get_type$2);
  struct _GObject *return_value_gm_mcp_session_world$4;
  return_value_gm_mcp_session_world$4=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$3);
  unsigned long int return_value_gm_world_get_type$5;
  return_value_gm_world_get_type$5=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$4, return_value_gm_world_get_type$5);
  const char *return_value_gm_world_path$7;
  return_value_gm_world_path$7=gm_world_path((struct _GmWorld *)return_value_g_type_check_instance_cast$6);
  path=g_strconcat(return_value_gm_world_path$7, (const void *)"/", (const void *)"pixmaps", (void *)0);
  signed int return_value_g_file_test$8;
  return_value_g_file_test$8=g_file_test(path, (enum anonymous$106)G_FILE_TEST_EXISTS);
  if(return_value_g_file_test$8 == 0)
    mkdir(path, (unsigned int)0755);

  g_free((void *)path);
  double return_value_gm_mcp_package_get_version$11;
  return_value_gm_mcp_package_get_version$11=gm_mcp_package_get_version(package);
  if(IEEE_FLOAT_EQUAL(return_value_gm_mcp_package_get_version$11, 1.0))
  {
    unsigned long int return_value_gm_mcp_session_get_type$9;
    return_value_gm_mcp_session_get_type$9=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)session, return_value_gm_mcp_session_get_type$9);
    gm_mcp_session_send_simple((struct _GmMcpSession *)return_value_g_type_check_instance_cast$10, "dns-nl-icecrew-serverinfo-get", (const char *)(void *)0);
  }

}

// gm_mcp_icecrew_serverinfo_view_set_visible
// file mcp/gm-mcp-icecrew-serverinfo.c line 310
void gm_mcp_icecrew_serverinfo_view_set_visible(struct _GmMcpIcecrewServerinfoView *view, signed int visible)
{
  struct _GtkAction *gm_mcp_icecrew_serverinfo_view_set_visible$$1$$action;
  gm_mcp_icecrew_serverinfo_view_set_visible$$1$$action=gm_app_view_action(view->view, "/MenuBar/WorldMenu/WorldInfoMenu");
  signed int return_value_gtk_action_get_visible$1;
  return_value_gtk_action_get_visible$1=gtk_action_get_visible(gm_mcp_icecrew_serverinfo_view_set_visible$$1$$action);
  if(!(return_value_gtk_action_get_visible$1 == visible))
  {
    gtk_action_set_visible(gm_mcp_icecrew_serverinfo_view_set_visible$$1$$action, visible);
    if(!(visible == 0))
      g_signal_connect_data((void *)gm_mcp_icecrew_serverinfo_view_set_visible$$1$$action, "activate", (void (*)(void))on_gm_mcp_icecrew_serverinfo_view_activate, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);

    else
      g_signal_handlers_disconnect_matched((void *)gm_mcp_icecrew_serverinfo_view_set_visible$$1$$action, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_icecrew_serverinfo_view_activate, (void *)view);
  }

}

// gm_mcp_icecrew_userlist_class_init
// file mcp/gm-mcp-icecrew-userlist.c line 207
static void gm_mcp_icecrew_userlist_class_init(struct _GmMcpIcecrewUserlistClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_icecrew_userlist_finalize;
  pklass->name = "dns-nl-icecrew-userlist";
  pklass->depends = gm_mcp_icecrew_userlist_depends;
  pklass->overrides = gm_mcp_icecrew_userlist_overrides;
  pklass->min_version = 1.0;
  pklass->max_version = 1.1;
  pklass->set_session = gm_mcp_icecrew_userlist_set_session;
  pklass->handle_multi = gm_mcp_icecrew_userlist_handle_multi;
  pklass->create_view = gm_mcp_icecrew_userlist_create_view;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpIcecrewUserlistPrivate) /*96ul*/ );
}

// gm_mcp_icecrew_userlist_class_intern_init
// file mcp/gm-mcp-icecrew-userlist.c line 97
static void gm_mcp_icecrew_userlist_class_intern_init(void *klass)
{
  gm_mcp_icecrew_userlist_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpIcecrewUserlist_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpIcecrewUserlist_private_offset);

  gm_mcp_icecrew_userlist_class_init((struct _GmMcpIcecrewUserlistClass *)klass);
}

// gm_mcp_icecrew_userlist_create_view
// file mcp/gm-mcp-icecrew-userlist.c line 1175
void gm_mcp_icecrew_userlist_create_view(struct _GmMcpPackage *package, struct _GObject *parent)
{
  gm_mcp_userlist_view_new(package, parent);
}

// gm_mcp_icecrew_userlist_fetch_next_alternatives
// file mcp/gm-mcp-icecrew-userlist.c line 573
void gm_mcp_icecrew_userlist_fetch_next_alternatives(struct _GmMcpIcecrewUserlist *package, signed int rank)
{
  struct _GList *source_uri = (struct _GList *)(void *)0;
  struct _GList *dest_uri = (struct _GList *)(void *)0;
  char *prev_name = (char *)(void *)0;
  char *path;
  struct _GList *item;
  struct _GList **alter;
  struct _GList *iter;
  struct _GmKeyValuePair *map;
  struct _GmKeyValuePair *itermap;
  struct _GList **tmp_if_expr$1;
  if(!(rank == 0))
    tmp_if_expr$1 = &package->priv->rank_alternatives;

  else
    tmp_if_expr$1 = &package->priv->state_alternatives;
  alter = tmp_if_expr$1;
  item = *alter;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  signed int return_value_strcmp$5;
  char *tmp_if_expr$2;
  struct _GList *tmp_if_expr$3;
  signed int return_value_strcmp$4;
  while(!(item == ((struct _GList *)NULL)))
  {
    map = (struct _GmKeyValuePair *)item->data;
    gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.FetchNextAlternatives: checking: %s", map->value);
    if(prev_name == ((char *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      if(!(map->key == ((char *)NULL)))
      {
        return_value_strcmp$5=strcmp(map->key, prev_name);
        tmp_if_expr$6 = return_value_strcmp$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
    {
      prev_name = map->key;
      if(!(rank == 0))
        tmp_if_expr$2 = package->priv->rank_dir;

      else
        tmp_if_expr$2 = package->priv->state_dir;
      path=gm_mcp_icecrew_userlist_remote_to_local_path(map->value, tmp_if_expr$2);
      gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.FetchNextAlternatives: adding to be fetched: %s => %s", map->key, map->value);
      source_uri=g_list_append(source_uri, (void *)map->value);
      dest_uri=g_list_append(dest_uri, (void *)path);
      unlink(path);
      if(!(rank == 0))
        tmp_if_expr$3 = package->priv->rank_icons;

      else
        tmp_if_expr$3 = package->priv->state_icons;
      iter = tmp_if_expr$3;
      for( ; !(iter == ((struct _GList *)NULL)); iter = iter->next)
      {
        itermap = (struct _GmKeyValuePair *)iter->data;
        if(!(itermap->key == ((char *)NULL)))
        {
          return_value_strcmp$4=strcmp(itermap->key, map->key);
          if(return_value_strcmp$4 == 0)
          {
            g_free((void *)itermap->value);
            itermap->value=g_strdup(path);
            break;
          }

        }

      }
    }

    if(!(source_uri == ((struct _GList *)NULL)))
      break;

    item = item->next;
  }
  if(!(source_uri == ((struct _GList *)NULL)))
  {
    if(!(rank == 0))
      package->priv->rank_fetch=gm_fetch(source_uri, dest_uri, (void (*)(void *, void *))gm_mcp_icecrew_userlist_fetch_progress, (void *)package);

    else
      package->priv->state_fetch=gm_fetch(source_uri, dest_uri, (void (*)(void *, void *))gm_mcp_icecrew_userlist_fetch_progress, (void *)package);
    gm_g_list_free_simple(dest_uri);
  }

  else
    if(!(rank == 0))
      gm_mcp_icecrew_userlist_remove_not_used_icons(package->priv->rank_icons, package->priv->rank_dir);

    else
      gm_mcp_icecrew_userlist_remove_not_used_icons(package->priv->state_icons, package->priv->state_dir);
}

// gm_mcp_icecrew_userlist_fetch_progress
// file mcp/gm-mcp-icecrew-userlist.c line 650
void gm_mcp_icecrew_userlist_fetch_progress(struct _GmFetchHandle *g, struct _GmMcpIcecrewUserlist *package)
{
  char *path;
  signed int rank;
  struct _GdkPixbuf *pixtest;
  struct _GError *err = (struct _GError *)(void *)0;
  if(!(g->aborted == 0))
    gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.FetchProgress: fetch aborted!");

  else
  {
    rank = (signed int)(package->priv->rank_fetch == g);
    if(!(g->done == 0))
    {
      gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.FetchProgress: fetch done!");
      const char *return_value_gnome_vfs_uri_get_path$1;
      return_value_gnome_vfs_uri_get_path$1=gnome_vfs_uri_get_path((struct GnomeVFSURI *)g->dest_uri->data);
      gm_mcp_icecrew_userlist_remove_alternatives(package, return_value_gnome_vfs_uri_get_path$1, 1, rank);
      if(!(rank == 0))
      {
        package->priv->rank_fetch = (struct _GmFetchHandle *)(void *)0;
        gm_mcp_icecrew_userlist_fetch_next_alternatives(package, (signed int)!(0 != 0));
      }

      else
      {
        package->priv->state_fetch = (struct _GmFetchHandle *)(void *)0;
        gm_mcp_icecrew_userlist_fetch_next_alternatives(package, 0);
      }
      goto __CPROVER_DUMP_L11;
    }

    if((signed int)g->status == GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR)
      gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.FetchProgress: error");

    if((signed int)g->cur_phase == GNOME_VFS_XFER_PHASE_FILECOMPLETED)
    {
      path=gnome_vfs_get_local_path_from_uri(g->cur_file_name);
      gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.FetchProgress: %s fetched!", path);
      pixtest=gdk_pixbuf_new_from_file(path, &err);
      if(!(pixtest == ((struct _GdkPixbuf *)NULL)))
      {
        g_object_unref((void *)pixtest);
        gm_mcp_icecrew_userlist_remove_alternatives(package, path, 0, rank);
        if(!(rank == 0))
          gm_mcp_icecrew_userlist_new_rank_state_icon(package, path, (signed int)!(0 != 0));

        else
          gm_mcp_icecrew_userlist_new_rank_state_icon(package, path, 0);
      }

      else
      {
        gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.FetchProgress: error, couldn't load file: %s", err->message);
        g_error_free(err);
        gm_mcp_icecrew_userlist_remove_alternatives(package, path, 1, rank);
      }
      g_free((void *)path);
    }

  }

__CPROVER_DUMP_L11:
  ;
}

// gm_mcp_icecrew_userlist_finalize
// file mcp/gm-mcp-icecrew-userlist.c line 171
static void gm_mcp_icecrew_userlist_finalize(struct _GObject *object)
{
  struct _GmMcpIcecrewUserlist *obj;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_mcp_icecrew_userlist_get_type$1);
  obj = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$2;
  struct _GmMcpPackage *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$3;
  return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gm_mcp_package_get_type$3);
  struct _GObject *return_value_gm_mcp_package_get_session$5;
  return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gm_mcp_session_get_type$6;
  return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
  playerdb=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7, "dns-nl-icecrew-playerdb");
  if(!(playerdb == ((struct _GmMcpPackage *)NULL)))
  {
    g_signal_handlers_disconnect_matched((void *)playerdb, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_icecrew_userlist_add, (void *)obj);
    g_signal_handlers_disconnect_matched((void *)playerdb, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_icecrew_userlist_set, (void *)obj);
    g_signal_handlers_disconnect_matched((void *)playerdb, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_icecrew_userlist_delete, (void *)obj);
  }

  if(!(obj->priv->rank_fetch == ((struct _GmFetchHandle *)NULL)))
    obj->priv->rank_fetch->aborted = (signed int)!(0 != 0);

  if(!(obj->priv->state_fetch == ((struct _GmFetchHandle *)NULL)))
    obj->priv->state_fetch->aborted = (signed int)!(0 != 0);

  gm_mcp_icecrew_userlist_free_list(obj->priv->state_icons);
  gm_mcp_icecrew_userlist_free_list(obj->priv->rank_icons);
  gm_mcp_icecrew_userlist_free_list(obj->priv->key_datatags);
  gm_mcp_icecrew_userlist_free_menu(obj);
  gm_mcp_icecrew_userlist_free_list(obj->priv->rank_alternatives);
  gm_mcp_icecrew_userlist_free_list(obj->priv->state_alternatives);
  g_free((void *)obj->priv->rank_dir);
  g_free((void *)obj->priv->state_dir);
  struct _GTypeClass *return_value_g_type_check_class_cast$8;
  return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_icecrew_userlist_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$8)->finalize(object);
}

// gm_mcp_icecrew_userlist_find_icon_names
// file mcp/gm-mcp-icecrew-userlist.c line 236
struct _GList * gm_mcp_icecrew_userlist_find_icon_names(struct _GList *icons, const char *path)
{
  struct _GList *item;
  struct _GList *res = (struct _GList *)(void *)0;
  struct _GmKeyValuePair *map;
  signed int return_value_strcmp$1;
  if(path == ((const char *)NULL) || icons == ((struct _GList *)NULL))
    return (struct _GList *)(void *)0;

  else
  {
    item = icons;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      map = (struct _GmKeyValuePair *)item->data;
      if(!(map->value == ((char *)NULL)))
      {
        return_value_strcmp$1=strcmp(map->value, path);
        if(return_value_strcmp$1 == 0)
          res=g_list_append(res, (void *)map->key);

      }

    }
    return res;
  }
}

// gm_mcp_icecrew_userlist_find_key
// file mcp/gm-mcp-icecrew-userlist.c line 316
const char * gm_mcp_icecrew_userlist_find_key(struct _GmMcpIcecrewUserlist *package, const char *datatag)
{
  struct _GList *item;
  struct _GmKeyValuePair *map;
  signed int return_value_strcmp$1;
  if(datatag == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    item = package->priv->key_datatags;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      map = (struct _GmKeyValuePair *)item->data;
      if(!(map->value == ((char *)NULL)))
      {
        return_value_strcmp$1=strcmp(map->value, datatag);
        if(return_value_strcmp$1 == 0)
          return map->key;

      }

    }
    return (const char *)(void *)0;
  }
}

// gm_mcp_icecrew_userlist_find_name
// file mcp/gm-mcp-icecrew-userlist.c line 337
const char * gm_mcp_icecrew_userlist_find_name(const char *name, struct _GmKeyValuePair *def)
{
  struct _GmKeyValuePair *pair = def;
  signed int return_value_strcmp$1;
  if(name == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    while((_Bool)1)
    {
      if(pair->key == ((char *)NULL))
      {
        if(pair->value == ((char *)NULL))
          goto __CPROVER_DUMP_L4;

      }

      if(!(pair->key == ((char *)NULL)))
      {
        return_value_strcmp$1=strcmp(pair->key, name);
        if(return_value_strcmp$1 == 0)
          return pair->value;

      }

      pair = pair + 1l;
    }

  __CPROVER_DUMP_L4:
    ;
    return (const char *)(void *)0;
  }
}

// gm_mcp_icecrew_userlist_find_path
// file mcp/gm-mcp-icecrew-userlist.c line 256
unsigned int gm_mcp_icecrew_userlist_find_path(struct _GList *icons, const char *name, const char **path)
{
  struct _GList *item;
  struct _GmKeyValuePair *map;
  unsigned int position = (unsigned int)0;
  signed int return_value_strcmp$1;
  if(name == ((const char *)NULL))
  {
    if(!(path == ((const char **)NULL)))
      *path = (const char *)(void *)0;

    return (unsigned int)0;
  }

  else
  {
    item = icons;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      map = (struct _GmKeyValuePair *)item->data;
      if(!(map->key == ((char *)NULL)))
      {
        return_value_strcmp$1=strcmp(map->key, name);
        if(return_value_strcmp$1 == 0)
        {
          if(!(path == ((const char **)NULL)))
            *path = map->value;

          return position;
        }

      }

      position = position + 1u;
    }
    if(!(path == ((const char **)NULL)))
      *path = (const char *)(void *)0;

    return position + (unsigned int)1;
  }
}

// gm_mcp_icecrew_userlist_free_list
// file mcp/gm-mcp-icecrew-userlist.c line 154
void gm_mcp_icecrew_userlist_free_list(struct _GList *rs)
{
  struct _GList *item = rs;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    gm_mcp_icecrew_userlist_pair_free((struct _GmKeyValuePair *)item->data);
  g_list_free(rs);
}

// gm_mcp_icecrew_userlist_free_menu
// file mcp/gm-mcp-icecrew-userlist.c line 165
static void gm_mcp_icecrew_userlist_free_menu(struct _GmMcpIcecrewUserlist *obj)
{
  gm_mcp_icecrew_userlist_free_list(obj->priv->menu);
  obj->priv->menu = (struct _GList *)(void *)0;
}

// gm_mcp_icecrew_userlist_get_icon
// file mcp/gm-mcp-icecrew-userlist.c line 878
const char * gm_mcp_icecrew_userlist_get_icon(struct _GmIUserlist *userlist, signed int id, signed int use_state)
{
  struct _GmMcpIcecrewUserlist *package;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_icecrew_userlist_get_type$1);
  package = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$2;
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$3;
  return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$3);
  struct _GObject *return_value_gm_mcp_package_get_session$5;
  return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gm_mcp_session_get_type$6;
  return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
  struct _GmMcpPackage *return_value_gm_mcp_session_find_package$8;
  return_value_gm_mcp_session_find_package$8=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7, "dns-nl-icecrew-playerdb");
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$9;
  return_value_gm_mcp_icecrew_playerdb_get_type$9=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_find_package$8, return_value_gm_mcp_icecrew_playerdb_get_type$9);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$10;
  struct _GmPlayerdbPlayerInfo *info;
  info=gm_mcp_icecrew_playerdb_find(playerdb, id);
  const char *return_value_gm_mcp_icecrew_userlist_icon_path$11;
  return_value_gm_mcp_icecrew_userlist_icon_path$11=gm_mcp_icecrew_userlist_icon_path(package, info, use_state);
  return return_value_gm_mcp_icecrew_userlist_icon_path$11;
}

// gm_mcp_icecrew_userlist_get_menu
// file mcp/gm-mcp-icecrew-userlist.c line 849
struct _GList * gm_mcp_icecrew_userlist_get_menu(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpIcecrewUserlist *object;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_icecrew_userlist_get_type$1);
  object = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$2;
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$3;
  return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_package_get_type$3);
  struct _GObject *return_value_gm_mcp_package_get_session$5;
  return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gm_mcp_session_get_type$6;
  return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
  struct _GmMcpPackage *return_value_gm_mcp_session_find_package$8;
  return_value_gm_mcp_session_find_package$8=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7, "dns-nl-icecrew-playerdb");
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$9;
  return_value_gm_mcp_icecrew_playerdb_get_type$9=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_find_package$8, return_value_gm_mcp_icecrew_playerdb_get_type$9);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$10;
  struct _GmPlayerdbPlayerInfo *info;
  info=gm_mcp_icecrew_playerdb_find(playerdb, id);
  struct _GList *item;
  struct _GList *result = (struct _GList *)(void *)0;
  item = object->priv->menu;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    struct _GmKeyValuePair *return_value_gm_mcp_icecrew_userlist_get_menu_item$11;
    return_value_gm_mcp_icecrew_userlist_get_menu_item$11=gm_mcp_icecrew_userlist_get_menu_item(object, (struct _GmKeyValuePair *)item->data, info);
    result=g_list_append(result, (void *)return_value_gm_mcp_icecrew_userlist_get_menu_item$11);
  }
  return result;
}

// gm_mcp_icecrew_userlist_get_menu_item
// file mcp/gm-mcp-icecrew-userlist.c line 831
struct _GmKeyValuePair * gm_mcp_icecrew_userlist_get_menu_item(struct _GmMcpIcecrewUserlist *package, struct _GmKeyValuePair *menuitem, struct _GmPlayerdbPlayerInfo *info)
{
  struct _GmKeyValuePair *result;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmKeyValuePair) /*16ul*/ );
  result = (struct _GmKeyValuePair *)return_value_g_malloc0_n$1;
  if(menuitem == ((struct _GmKeyValuePair *)NULL))
    return result;

  else
  {
    result->key=gm_mcp_icecrew_userlist_menu_item_subst(package, menuitem->key, info);
    result->value=gm_mcp_icecrew_userlist_menu_item_subst(package, menuitem->value, info);
    return result;
  }
}

// gm_mcp_icecrew_userlist_get_name
// file mcp/gm-mcp-icecrew-userlist.c line 866
const char * gm_mcp_icecrew_userlist_get_name(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  struct _GmMcpPackage *return_value_gm_mcp_session_find_package$6;
  return_value_gm_mcp_session_find_package$6=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5, "dns-nl-icecrew-playerdb");
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$7;
  return_value_gm_mcp_icecrew_playerdb_get_type$7=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_find_package$6, return_value_gm_mcp_icecrew_playerdb_get_type$7);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$8;
  struct _GmPlayerdbPlayerInfo *info;
  info=gm_mcp_icecrew_playerdb_find(playerdb, id);
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$9;
  return_value_gm_mcp_icecrew_userlist_get_type$9=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_icecrew_userlist_get_type$9);
  const char *return_value_gm_playerdb_player_info_get_prop$11;
  return_value_gm_playerdb_player_info_get_prop$11=gm_playerdb_player_info_get_prop(info, ((struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$10)->priv->property_names[(signed long int)0]);
  return return_value_gm_playerdb_player_info_get_prop$11;
}

// gm_mcp_icecrew_userlist_get_rank_priority
// file mcp/gm-mcp-icecrew-userlist.c line 890
signed int gm_mcp_icecrew_userlist_get_rank_priority(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpIcecrewUserlist *package;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_icecrew_userlist_get_type$1);
  package = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$2;
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$3;
  return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_package_get_type$3);
  struct _GObject *return_value_gm_mcp_package_get_session$5;
  return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gm_mcp_session_get_type$6;
  return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
  struct _GmMcpPackage *return_value_gm_mcp_session_find_package$8;
  return_value_gm_mcp_session_find_package$8=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7, "dns-nl-icecrew-playerdb");
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$9;
  return_value_gm_mcp_icecrew_playerdb_get_type$9=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_find_package$8, return_value_gm_mcp_icecrew_playerdb_get_type$9);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$10;
  struct _GmPlayerdbPlayerInfo *info;
  info=gm_mcp_icecrew_playerdb_find(playerdb, id);
  const char *rank;
  rank=gm_playerdb_player_info_get_prop(info, package->priv->property_names[(signed long int)1]);
  unsigned int return_value_g_list_length$11;
  return_value_g_list_length$11=g_list_length(package->priv->rank_icons);
  unsigned int return_value_gm_mcp_icecrew_userlist_find_path$12;
  return_value_gm_mcp_icecrew_userlist_find_path$12=gm_mcp_icecrew_userlist_find_path(package->priv->rank_icons, rank, (const char **)(void *)0);
  return (signed int)((return_value_g_list_length$11 - return_value_gm_mcp_icecrew_userlist_find_path$12) - (unsigned int)1);
}

// gm_mcp_icecrew_userlist_get_state_priority
// file mcp/gm-mcp-icecrew-userlist.c line 905
signed int gm_mcp_icecrew_userlist_get_state_priority(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpIcecrewUserlist *package;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_icecrew_userlist_get_type$1);
  package = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$2;
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$3;
  return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_package_get_type$3);
  struct _GObject *return_value_gm_mcp_package_get_session$5;
  return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gm_mcp_session_get_type$6;
  return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
  struct _GmMcpPackage *return_value_gm_mcp_session_find_package$8;
  return_value_gm_mcp_session_find_package$8=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7, "dns-nl-icecrew-playerdb");
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$9;
  return_value_gm_mcp_icecrew_playerdb_get_type$9=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_find_package$8, return_value_gm_mcp_icecrew_playerdb_get_type$9);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$10;
  struct _GmPlayerdbPlayerInfo *info;
  info=gm_mcp_icecrew_playerdb_find(playerdb, id);
  const char *state;
  state=gm_playerdb_player_info_get_prop(info, package->priv->property_names[(signed long int)2]);
  unsigned int return_value_g_list_length$11;
  return_value_g_list_length$11=g_list_length(package->priv->state_icons);
  unsigned int return_value_gm_mcp_icecrew_userlist_find_path$12;
  return_value_gm_mcp_icecrew_userlist_find_path$12=gm_mcp_icecrew_userlist_find_path(package->priv->state_icons, state, (const char **)(void *)0);
  return (signed int)((return_value_g_list_length$11 - return_value_gm_mcp_icecrew_userlist_find_path$12) + (unsigned int)1);
}

// gm_mcp_icecrew_userlist_get_status
// file mcp/gm-mcp-icecrew-userlist.c line 920
char * gm_mcp_icecrew_userlist_get_status(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpIcecrewPlayerdb *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  struct _GmMcpPackage *return_value_gm_mcp_session_find_package$6;
  return_value_gm_mcp_session_find_package$6=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5, "dns-nl-icecrew-playerdb");
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$7;
  return_value_gm_mcp_icecrew_playerdb_get_type$7=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_find_package$6, return_value_gm_mcp_icecrew_playerdb_get_type$7);
  playerdb = (struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$8;
  struct _GmPlayerdbPlayerInfo *info;
  info=gm_mcp_icecrew_playerdb_find(playerdb, id);
  struct _GmMcpIcecrewUserlist *package;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$9;
  return_value_gm_mcp_icecrew_userlist_get_type$9=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_icecrew_userlist_get_type$9);
  package = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$10;
  const char *state;
  state=gm_playerdb_player_info_get_prop(info, package->priv->property_names[(signed long int)2]);
  const char *msg;
  msg=gm_playerdb_player_info_get_prop(info, package->priv->property_names[(signed long int)3]);
  const char *caption;
  _Bool tmp_if_expr$14;
  signed int return_value_strcmp$13;
  if(state == ((const char *)NULL))
    tmp_if_expr$14 = (_Bool)1;

  else
  {
    return_value_strcmp$13=strcmp(state, "avail");
    tmp_if_expr$14 = return_value_strcmp$13 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$14)
  {
    char *return_value_gettext$11;
    return_value_gettext$11=gettext("Available");
    char *return_value_strdup$12;
    return_value_strdup$12=strdup(return_value_gettext$11);
    return return_value_strdup$12;
  }

  char *return_value_strstr$17;
  return_value_strstr$17=strstr(state, "away");
  char *return_value_strstr$16;
  char *return_value_strstr$15;
  if(!(return_value_strstr$17 == ((char *)NULL)))
    caption=gettext("Away");

  else
  {
    return_value_strstr$16=strstr(state, "busy");
    if(!(return_value_strstr$16 == ((char *)NULL)))
      caption=gettext("Busy");

    else
    {
      return_value_strstr$15=strstr(state, "idle");
      if(!(return_value_strstr$15 == ((char *)NULL)))
        caption=gettext("Idle");

      else
        return (char *)(void *)0;
    }
  }
  _Bool tmp_if_expr$20;
  if(msg == ((const char *)NULL))
    tmp_if_expr$20 = (_Bool)1;

  else
    tmp_if_expr$20 = (signed int)*msg == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$20)
  {
    char *return_value_strdup$18;
    return_value_strdup$18=strdup(caption);
    return return_value_strdup$18;
  }

  else
  {
    char *return_value_g_strconcat$19;
    return_value_g_strconcat$19=g_strconcat(caption, (const void *)": ", msg, (void *)0);
    return return_value_g_strconcat$19;
  }
}

// gm_mcp_icecrew_userlist_get_type
// file mcp/gm-mcp-icecrew-userlist.h line 56
unsigned long int gm_mcp_icecrew_userlist_get_type(void)
{
  _Bool tmp_statement_expression$4;
  void *tmp_statement_expression$5;
  signed int return_value___atomic_load_8$6;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$6=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$5 = (void *)return_value___atomic_load_8$6;
  _Bool tmp_if_expr$8;
  signed int return_value_g_once_init_enter$7;
  if(tmp_statement_expression$5 == NULL)
  {
    return_value_g_once_init_enter$7=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$8 = return_value_g_once_init_enter$7 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  tmp_statement_expression$4 = tmp_if_expr$8;
  if(tmp_statement_expression$4)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpIcecrewUserlist");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpIcecrewUserlistClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_icecrew_userlist_class_intern_init, (unsigned int)sizeof(struct _GmMcpIcecrewUserlist) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_icecrew_userlist_init, (enum anonymous)0);
    const struct _GInterfaceInfo g_implement_interface_info = { .interface_init=(void (*)(void *, void *))gm_mcp_icecrew_userlist_iface_init, .interface_finalize=(void (*)(void *, void *))(void *)0,
    .interface_data=(void *)0 };
    unsigned long int return_value_gm_iuserlist_get_type$3;
    return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
    g_type_add_interface_static(g_define_type_id, return_value_gm_iuserlist_get_type$3, &g_implement_interface_info);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_icecrew_userlist_handle_menu
// file mcp/gm-mcp-icecrew-userlist.c line 955
void gm_mcp_icecrew_userlist_handle_menu(struct _GmMcpIcecrewUserlist *package, struct _GList *values)
{
  struct _GmKeyValuePair *pair;
  struct _GList *item;
  struct _GList *data;
  gm_mcp_icecrew_userlist_free_menu(package);
  item = values;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    data = (struct _GList *)item->data;
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmKeyValuePair) /*16ul*/ );
    pair = (struct _GmKeyValuePair *)return_value_g_malloc0_n$1;
    unsigned int return_value_g_list_length$2;
    return_value_g_list_length$2=g_list_length(data);
    if(return_value_g_list_length$2 == 2u)
    {
      pair->key=g_strdup((const char *)data->data);
      pair->value=g_strdup((const char *)data->next->data);
    }

    package->priv->menu=g_list_append(package->priv->menu, (void *)pair);
  }
}

// gm_mcp_icecrew_userlist_handle_multi
// file mcp/gm-mcp-icecrew-userlist.c line 1079
signed int gm_mcp_icecrew_userlist_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values)
{
  struct _GmMcpIcecrewUserlist *userlist;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_icecrew_userlist_get_type$1);
  userlist = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$2;
  struct _GList *tmp;
  struct _GList *l;
  struct _GList *vals = (struct _GList *)(void *)0;
  struct _GmKeyValuePair *m;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  if(!(key == ((const char *)NULL)))
  {
    const char *return_value_gm_mcp_icecrew_userlist_find_key$4;
    return_value_gm_mcp_icecrew_userlist_find_key$4=gm_mcp_icecrew_userlist_find_key(userlist, data_tag);
    if(return_value_gm_mcp_icecrew_userlist_find_key$4 == ((const char *)NULL))
    {
      void *return_value_g_malloc_n$3;
      return_value_g_malloc_n$3=g_malloc_n((unsigned long int)1, sizeof(struct _GmKeyValuePair) /*16ul*/ );
      m = (struct _GmKeyValuePair *)return_value_g_malloc_n$3;
      m->key=g_strdup(key);
      m->value=g_strdup(data_tag);
      userlist->priv->key_datatags=g_list_append(userlist->priv->key_datatags, (void *)m);
    }

  }

  else
  {
    key=gm_mcp_icecrew_userlist_find_key(userlist, data_tag);
    if(!(key == ((const char *)NULL)))
    {
      tmp = all_values;
      for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
      {
        l=gm_mcp_parse_list((char *)tmp->data);
        vals=g_list_append(vals, (void *)l);
      }
      signed int return_value_strcmp$7;
      return_value_strcmp$7=strcmp(key, "rank");
      if(return_value_strcmp$7 == 0)
        gm_mcp_icecrew_userlist_handle_ranks_states(userlist, vals, (signed int)!(0 != 0));

      else
      {
        return_value_strcmp$6=strcmp(key, "state");
        if(return_value_strcmp$6 == 0)
          gm_mcp_icecrew_userlist_handle_ranks_states(userlist, vals, 0);

        else
        {
          return_value_strcmp$5=strcmp(key, "menu");
          if(return_value_strcmp$5 == 0)
            gm_mcp_icecrew_userlist_handle_menu(userlist, vals);

        }
      }
      gm_mcp_icecrew_userlist_remove_datatag(userlist, data_tag);
    }

    else
      gm_debug_msg(DEBUG_ALWAYS, "Datatag %s not found", data_tag);
  }
  tmp = vals;
  for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
    gm_mcp_list_free((struct _GList *)tmp->data);
  g_list_free(vals);
  return 0;
}

// gm_mcp_icecrew_userlist_handle_ranks_states
// file mcp/gm-mcp-icecrew-userlist.c line 977
void gm_mcp_icecrew_userlist_handle_ranks_states(struct _GmMcpIcecrewUserlist *package, struct _GList *values, signed int rank)
{
  struct _GList *tmp;
  struct _GList *data;
  struct _GList *new_list = (struct _GList *)(void *)0;
  char *name;
  char **alternatives;
  char *path;
  char **ptr;
  const char *cpath;
  _Bool tmp_if_expr$1;
  if(!(rank == 0))
    tmp_if_expr$1 = package->priv->rank_fetch != ((struct _GmFetchHandle *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    package->priv->rank_fetch = (struct _GmFetchHandle *)(void *)0;
    gm_mcp_icecrew_userlist_free_list(package->priv->rank_alternatives);
    package->priv->rank_alternatives = (struct _GList *)(void *)0;
    package->priv->rank_fetch->aborted = (signed int)!(0 != 0);
  }

  else
    if(rank == 0)
    {
      if(!(package->priv->state_fetch == ((struct _GmFetchHandle *)NULL)))
      {
        package->priv->state_fetch = (struct _GmFetchHandle *)(void *)0;
        gm_mcp_icecrew_userlist_free_list(package->priv->state_alternatives);
        package->priv->state_alternatives = (struct _GList *)(void *)0;
        package->priv->state_fetch->aborted = (signed int)!(0 != 0);
      }

    }

  tmp = values;
  char *tmp_if_expr$4;
  for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
  {
    data = (struct _GList *)tmp->data;
    if(!(data == ((struct _GList *)NULL)))
    {
      name = (char *)data->data;
      gm_mcp_icecrew_userlist_find_path(new_list, name, &cpath);
      if(!(cpath == ((const char *)NULL)))
        gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.HandleRanksStates: duplicate %s, ignored!", name);

      else
        if(data->next == ((struct _GList *)NULL))
        {
          if(!(rank == 0))
            cpath=gm_mcp_icecrew_userlist_find_name(name, default_ranks);

          else
            cpath=gm_mcp_icecrew_userlist_find_name(name, default_states);
          if(!(cpath == ((const char *)NULL)))
          {
            struct _GmKeyValuePair *return_value_gm_mcp_icecrew_userlist_url_map_new$2;
            return_value_gm_mcp_icecrew_userlist_url_map_new$2=gm_mcp_icecrew_userlist_url_map_new(name, cpath);
            new_list=g_list_append(new_list, (void *)return_value_gm_mcp_icecrew_userlist_url_map_new$2);
          }

          else
            gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.HandleRanksStates: couldn't find %s, ignored!", name);
        }

        else
        {
          void *return_value_g_list_nth_data$3;
          return_value_g_list_nth_data$3=g_list_nth_data(data, (unsigned int)1);
          alternatives=g_strsplit((const char *)return_value_g_list_nth_data$3, ";", 0);
          ptr = alternatives;
          for( ; !(*ptr == ((char *)NULL)); ptr = ptr + 1l)
          {
            if(ptr == alternatives)
            {
              if(!(rank == 0))
                tmp_if_expr$4 = package->priv->rank_dir;

              else
                tmp_if_expr$4 = package->priv->state_dir;
              path=gm_mcp_icecrew_userlist_remote_to_local_path(*ptr, tmp_if_expr$4);
              struct _GmKeyValuePair *return_value_gm_mcp_icecrew_userlist_url_map_new$5;
              return_value_gm_mcp_icecrew_userlist_url_map_new$5=gm_mcp_icecrew_userlist_url_map_new(name, path);
              new_list=g_list_append(new_list, (void *)return_value_gm_mcp_icecrew_userlist_url_map_new$5);
              g_free((void *)path);
            }

            gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.HandleRanksStates: adding alternative: %s => %s", name, *ptr);
            if(!(rank == 0))
            {
              struct _GmKeyValuePair *return_value_gm_mcp_icecrew_userlist_url_map_new$6;
              return_value_gm_mcp_icecrew_userlist_url_map_new$6=gm_mcp_icecrew_userlist_url_map_new(name, *ptr);
              package->priv->rank_alternatives=g_list_append(package->priv->rank_alternatives, (void *)return_value_gm_mcp_icecrew_userlist_url_map_new$6);
            }

            else
            {
              struct _GmKeyValuePair *return_value_gm_mcp_icecrew_userlist_url_map_new$7;
              return_value_gm_mcp_icecrew_userlist_url_map_new$7=gm_mcp_icecrew_userlist_url_map_new(name, *ptr);
              package->priv->state_alternatives=g_list_append(package->priv->state_alternatives, (void *)return_value_gm_mcp_icecrew_userlist_url_map_new$7);
            }
          }
          g_strfreev(alternatives);
        }
    }

  }
  if(!(rank == 0))
  {
    gm_mcp_icecrew_userlist_free_list(package->priv->rank_icons);
    package->priv->rank_icons = new_list;
  }

  else
  {
    gm_mcp_icecrew_userlist_free_list(package->priv->state_icons);
    package->priv->state_icons = new_list;
  }
  _Bool tmp_if_expr$8;
  if(!(rank == 0))
    tmp_if_expr$8 = package->priv->rank_alternatives != ((struct _GList *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$8 = (_Bool)0;
  if(tmp_if_expr$8)
    gm_mcp_icecrew_userlist_fetch_next_alternatives(package, rank);

  else
    if(rank == 0)
    {
      if(!(package->priv->state_alternatives == ((struct _GList *)NULL)))
        gm_mcp_icecrew_userlist_fetch_next_alternatives(package, rank);

    }

}

// gm_mcp_icecrew_userlist_icon_path
// file mcp/gm-mcp-icecrew-userlist.c line 467
const char * gm_mcp_icecrew_userlist_icon_path(struct _GmMcpIcecrewUserlist *package, struct _GmPlayerdbPlayerInfo *ppi, signed int use_state)
{
  const char *state;
  const char *icon_path = (const char *)(void *)0;
  state=gm_playerdb_player_info_get_prop(ppi, package->priv->property_names[(signed long int)2]);
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(use_state == 0)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    if(!(state == ((const char *)NULL)))
    {
      return_value_strcmp$2=strcmp(state, "avail");
      tmp_if_expr$3 = return_value_strcmp$2 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
  {
    const char *return_value_gm_playerdb_player_info_get_prop$1;
    return_value_gm_playerdb_player_info_get_prop$1=gm_playerdb_player_info_get_prop(ppi, package->priv->property_names[(signed long int)1]);
    gm_mcp_icecrew_userlist_find_path(package->priv->rank_icons, return_value_gm_playerdb_player_info_get_prop$1, &icon_path);
  }

  else
    gm_mcp_icecrew_userlist_find_path(package->priv->state_icons, state, &icon_path);
  return icon_path;
}

// gm_mcp_icecrew_userlist_iface_init
// file mcp/gm-mcp-icecrew-userlist.c line 135
static void gm_mcp_icecrew_userlist_iface_init(struct _GmIUserlistInterface *iface)
{
  iface->get_menu = gm_mcp_icecrew_userlist_get_menu;
  iface->get_status = gm_mcp_icecrew_userlist_get_status;
  iface->get_name = gm_mcp_icecrew_userlist_get_name;
  iface->get_icon = gm_mcp_icecrew_userlist_get_icon;
  iface->get_rank_priority = gm_mcp_icecrew_userlist_get_rank_priority;
  iface->get_state_priority = gm_mcp_icecrew_userlist_get_state_priority;
}

// gm_mcp_icecrew_userlist_init
// file mcp/gm-mcp-icecrew-userlist.c line 383
static void gm_mcp_icecrew_userlist_init(struct _GmMcpIcecrewUserlist *obj)
{
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_icecrew_userlist_get_type$1);
  obj->priv = (struct _GmMcpIcecrewUserlistPrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->rank_alternatives = (struct _GList *)(void *)0;
  obj->priv->state_alternatives = (struct _GList *)(void *)0;
  obj->priv->key_datatags = (struct _GList *)(void *)0;
  obj->priv->rank_dir = (char *)(void *)0;
  obj->priv->state_dir = (char *)(void *)0;
  obj->priv->rank_fetch = (struct _GmFetchHandle *)(void *)0;
  obj->priv->state_fetch = (struct _GmFetchHandle *)(void *)0;
  gm_mcp_icecrew_userlist_init_states(obj);
  gm_mcp_icecrew_userlist_init_ranks(obj);
}

// gm_mcp_icecrew_userlist_init_ranks
// file mcp/gm-mcp-icecrew-userlist.c line 370
void gm_mcp_icecrew_userlist_init_ranks(struct _GmMcpIcecrewUserlist *package)
{
  struct _GmKeyValuePair *pair = default_ranks;
  package->priv->rank_icons = (struct _GList *)(void *)0;
  while((_Bool)1)
  {
    if(pair->key == ((char *)NULL))
    {
      if(pair->value == ((char *)NULL))
        goto __CPROVER_DUMP_L3;

    }

    struct _GmKeyValuePair *return_value_gm_mcp_icecrew_userlist_url_map_new$1;
    return_value_gm_mcp_icecrew_userlist_url_map_new$1=gm_mcp_icecrew_userlist_url_map_new(pair->key, pair->value);
    package->priv->rank_icons=g_list_append(package->priv->rank_icons, (void *)return_value_gm_mcp_icecrew_userlist_url_map_new$1);
    pair = pair + 1l;
  }

__CPROVER_DUMP_L3:
  ;
}

// gm_mcp_icecrew_userlist_init_states
// file mcp/gm-mcp-icecrew-userlist.c line 357
void gm_mcp_icecrew_userlist_init_states(struct _GmMcpIcecrewUserlist *package)
{
  struct _GmKeyValuePair *pair = default_states;
  package->priv->state_icons = (struct _GList *)(void *)0;
  while((_Bool)1)
  {
    if(pair->key == ((char *)NULL))
    {
      if(pair->value == ((char *)NULL))
        goto __CPROVER_DUMP_L3;

    }

    struct _GmKeyValuePair *return_value_gm_mcp_icecrew_userlist_url_map_new$1;
    return_value_gm_mcp_icecrew_userlist_url_map_new$1=gm_mcp_icecrew_userlist_url_map_new(pair->key, pair->value);
    package->priv->state_icons=g_list_append(package->priv->state_icons, (void *)return_value_gm_mcp_icecrew_userlist_url_map_new$1);
    pair = pair + 1l;
  }

__CPROVER_DUMP_L3:
  ;
}

// gm_mcp_icecrew_userlist_menu_item_subst
// file mcp/gm-mcp-icecrew-userlist.c line 756
char * gm_mcp_icecrew_userlist_menu_item_subst(struct _GmMcpIcecrewUserlist *package, char *str, struct _GmPlayerdbPlayerInfo *info)
{
  struct _GString *result;
  char *ptr = str;
  char *subst = (char *)(void *)0;
  char *tmp;
  char *prop;
  const char *value;
  unsigned int ch;
  unsigned int cnum;
  signed int substituted;
  signed int return_value_g_unichar_isalpha$2;
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    result=g_string_sized_new(return_value_strlen$1);
    do
    {
      ch=g_utf8_get_char(ptr);
      if(ch == 0u)
        break;

      substituted = 0;
      if(ch == 36u)
      {
        subst = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
        tmp = subst;
        do
        {
          cnum=g_utf8_get_char(subst);
          if(cnum == 0u)
            break;

          if(!(cnum == 95u))
          {
            return_value_g_unichar_isalpha$2=g_unichar_isalpha(cnum);
            if(return_value_g_unichar_isalpha$2 == 0)
              break;

          }

          subst = (char *)(subst + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)subst)]);
        }
        while((_Bool)1);
        prop=g_strndup(tmp, (unsigned long int)(subst - tmp));
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp(prop, "ID");
        if(return_value_strcmp$3 == 0)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_strcmp$4=strcmp(prop, "id");
          tmp_if_expr$5 = return_value_strcmp$4 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
        {
          tmp=g_strdup_printf("#%d", info->id);
          result=g_string_append(result, tmp);
          g_free((void *)tmp);
          substituted = (signed int)!(0 != 0);
        }

        else
        {
          value=gm_playerdb_player_info_get_prop(info, prop);
          if(!(value == ((const char *)NULL)))
          {
            for( ; !((signed int)*value == 0); value = (char *)(value + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)value)]))
            {
              ch=g_utf8_get_char(value);
              if(ch == 95u)
                result=g_string_append_c_inline$link1(result, (char)95);

              result=g_string_append_unichar(result, ch);
            }
            substituted = (signed int)!(0 != 0);
          }

        }
      }

      if(substituted == 0)
        result=g_string_append_unichar(result, ch);

      if((signed int)*ptr == 0)
        break;

      if(substituted == 0)
        ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);

      else
        ptr = subst;
    }
    while((_Bool)1);
    ptr = result->str;
    g_string_free(result, 0);
    return ptr;
  }
}

// gm_mcp_icecrew_userlist_new
// file mcp/gm-mcp-icecrew-userlist.c line 399
struct _GmMcpIcecrewUserlist * gm_mcp_icecrew_userlist_new(void)
{
  struct _GmMcpIcecrewUserlist *obj;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$1;
  return_value_gm_mcp_icecrew_userlist_get_type$1=gm_mcp_icecrew_userlist_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_icecrew_userlist_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$3;
  return_value_gm_mcp_icecrew_userlist_get_type$3=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_icecrew_userlist_get_type$3);
  obj = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_icecrew_userlist_new_rank_state_icon
// file mcp/gm-mcp-icecrew-userlist.c line 501
void gm_mcp_icecrew_userlist_new_rank_state_icon(struct _GmMcpIcecrewUserlist *package, char *path, signed int rank)
{
  struct _GList *names;
  struct _GList *tmp;
  struct _GmMcpPackage *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  playerdb=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5, "dns-nl-icecrew-playerdb");
  do
    if(playerdb == ((struct _GmMcpPackage *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_mcp_icecrew_userlist_new_rank_state_icon", "playerdb != NULL");
      goto __CPROVER_DUMP_L10;
    }

  while((_Bool)0);
  if(!(rank == 0))
    names=gm_mcp_icecrew_userlist_find_icon_names(package->priv->rank_icons, path);

  else
    names=gm_mcp_icecrew_userlist_find_icon_names(package->priv->state_icons, path);
  if(!(names == ((struct _GList *)NULL)))
  {
    tmp = names;
    for( ; !(tmp == ((struct _GList *)NULL)); tmp = tmp->next)
      if(!(rank == 0))
      {
        unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$6;
        return_value_gm_mcp_icecrew_playerdb_get_type$6=gm_mcp_icecrew_playerdb_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
        return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)playerdb, return_value_gm_mcp_icecrew_playerdb_get_type$6);
        gm_mcp_icecrew_playerdb_find_players_with((struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$7, package->priv->property_names[(signed long int)1], (char *)tmp->data, gm_mcp_icecrew_userlist_update_rank_icon, (void *)package);
      }

      else
      {
        unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$8;
        return_value_gm_mcp_icecrew_playerdb_get_type$8=gm_mcp_icecrew_playerdb_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)playerdb, return_value_gm_mcp_icecrew_playerdb_get_type$8);
        gm_mcp_icecrew_playerdb_find_players_with((struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$9, package->priv->property_names[(signed long int)2], (char *)tmp->data, gm_mcp_icecrew_userlist_update_state_icon, (void *)package);
      }
    g_list_free(names);
  }


__CPROVER_DUMP_L10:
  ;
}

// gm_mcp_icecrew_userlist_pair_free
// file mcp/gm-mcp-icecrew-userlist.c line 147
void gm_mcp_icecrew_userlist_pair_free(struct _GmKeyValuePair *pair)
{
  g_free((void *)pair->key);
  g_free((void *)pair->value);
  g_free((void *)pair);
}

// gm_mcp_icecrew_userlist_process_state_changed
// file mcp/gm-mcp-icecrew-userlist.c line 1180
void gm_mcp_icecrew_userlist_process_state_changed(struct _GmMcpIcecrewUserlist *userlist, struct _GmPlayerdbPlayerInfo *ppi, const char *value, const char *old)
{
  signed int was_away;
  signed int was_idle;
  signed int is_away;
  signed int is_idle;
  const char *name;
  name=gm_playerdb_player_info_get_prop(ppi, userlist->priv->property_names[(signed long int)0]);
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(old, "away");
  _Bool tmp_if_expr$3;
  char *return_value_strstr$2;
  if(!(return_value_strstr$1 == ((char *)NULL)))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strstr$2=strstr(old, "busy");
    tmp_if_expr$3 = return_value_strstr$2 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  was_away = (signed int)tmp_if_expr$3;
  char *return_value_strstr$4;
  return_value_strstr$4=strstr(old, "idle");
  was_idle = (signed int)(return_value_strstr$4 != (char *)(void *)0);
  char *return_value_strstr$5;
  return_value_strstr$5=strstr(value, "away");
  _Bool tmp_if_expr$7;
  char *return_value_strstr$6;
  if(!(return_value_strstr$5 == ((char *)NULL)))
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strstr$6=strstr(value, "busy");
    tmp_if_expr$7 = return_value_strstr$6 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  is_away = (signed int)tmp_if_expr$7;
  char *return_value_strstr$8;
  return_value_strstr$8=strstr(value, "idle");
  is_idle = (signed int)(return_value_strstr$8 != (char *)(void *)0);
  if(is_away == 0 && !(was_away == 0))
    gm_mcp_icecrew_userlist_process_triggers(userlist, name, (enum _GmTriggerConditionType)TCT_USER_AWAY_OFF);

  else
    if(was_away == 0 && !(is_away == 0))
      gm_mcp_icecrew_userlist_process_triggers(userlist, name, (enum _GmTriggerConditionType)TCT_USER_AWAY);

  if(is_idle == 0 && !(was_idle == 0))
    gm_mcp_icecrew_userlist_process_triggers(userlist, name, (enum _GmTriggerConditionType)TCT_USER_IDLE_OFF);

  else
    if(was_idle == 0 && !(is_idle == 0))
      gm_mcp_icecrew_userlist_process_triggers(userlist, name, (enum _GmTriggerConditionType)TCT_USER_IDLE);

}

// gm_mcp_icecrew_userlist_process_triggers
// file mcp/gm-mcp-icecrew-userlist.c line 723
void gm_mcp_icecrew_userlist_process_triggers(struct _GmMcpIcecrewUserlist *package, const char *username, enum _GmTriggerConditionType condition)
{
  struct _GmWorld *world;
  struct _GmTriggers *triggers;
  const struct _GList *item;
  struct _GmTrigger *trigger;
  struct anonymous$17 matches[10l];
  signed int num;
  struct _GmMcpPackage *playerdb;
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  playerdb=gm_mcp_session_find_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5, "dns-nl-icecrew-playerdb");
  unsigned long int return_value_gm_mcp_icecrew_playerdb_get_type$6;
  return_value_gm_mcp_icecrew_playerdb_get_type$6=gm_mcp_icecrew_playerdb_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)playerdb, return_value_gm_mcp_icecrew_playerdb_get_type$6);
  signed int return_value_gm_mcp_icecrew_playerdb_initializing$8;
  return_value_gm_mcp_icecrew_playerdb_initializing$8=gm_mcp_icecrew_playerdb_initializing((struct _GmMcpIcecrewPlayerdb *)return_value_g_type_check_instance_cast$7);
  if(return_value_gm_mcp_icecrew_playerdb_initializing$8 == 0)
  {
    unsigned long int return_value_gm_mcp_package_get_type$9;
    return_value_gm_mcp_package_get_type$9=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$9);
    struct _GObject *return_value_gm_mcp_package_get_session$11;
    return_value_gm_mcp_package_get_session$11=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$10);
    unsigned long int return_value_gm_mcp_session_get_type$12;
    return_value_gm_mcp_session_get_type$12=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$11, return_value_gm_mcp_session_get_type$12);
    struct _GObject *return_value_gm_mcp_session_world$14;
    return_value_gm_mcp_session_world$14=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$13);
    unsigned long int return_value_gm_world_get_type$15;
    return_value_gm_world_get_type$15=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$14, return_value_gm_world_get_type$15);
    world = (struct _GmWorld *)return_value_g_type_check_instance_cast$16;
    triggers=gm_world_triggers(world);
    item=gm_triggers_list(triggers);
    for( ; !(item == ((const struct _GList *)NULL)); item = item->next)
    {
      trigger = (struct _GmTrigger *)item->data;
      if((signed int)trigger->event == TT_USERS)
      {
        num=gm_trigger_match_user(trigger, username, condition, matches, 10);
        if(!(num == 0))
          gm_world_apply_trigger(world, trigger, username, matches, num);

      }

    }
  }

}

// gm_mcp_icecrew_userlist_remote_to_local_path
// file mcp/gm-mcp-icecrew-userlist.c line 407
char * gm_mcp_icecrew_userlist_remote_to_local_path(const char *url, const char *dirname)
{
  char *base;
  base=g_path_get_basename(url);
  char *result;
  result=g_strconcat(dirname, (const void *)"/", base, (void *)0);
  g_free((void *)base);
  return result;
}

// gm_mcp_icecrew_userlist_remove_alternatives
// file mcp/gm-mcp-icecrew-userlist.c line 419
void gm_mcp_icecrew_userlist_remove_alternatives(struct _GmMcpIcecrewUserlist *package, const char *path, signed int n, signed int rank)
{
  struct _GList *item;
  struct _GList **alter;
  signed int i;
  struct _GmKeyValuePair *map;
  char *name;
  char *pathd;
  char *dir;
  struct _GList **tmp_if_expr$1;
  char *tmp_if_expr$2;
  signed int return_value_strcmp$5;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  if(!(path == ((const char *)NULL)))
  {
    if(!(rank == 0))
      tmp_if_expr$1 = &package->priv->rank_alternatives;

    else
      tmp_if_expr$1 = &package->priv->state_alternatives;
    alter = tmp_if_expr$1;
    if(!(rank == 0))
      tmp_if_expr$2 = package->priv->rank_dir;

    else
      tmp_if_expr$2 = package->priv->state_dir;
    dir = tmp_if_expr$2;
    item = *alter;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      map = (struct _GmKeyValuePair *)item->data;
      pathd=gm_mcp_icecrew_userlist_remote_to_local_path(map->value, dir);
      if(!(pathd == ((char *)NULL)))
      {
        return_value_strcmp$5=strcmp(pathd, path);
        if(return_value_strcmp$5 == 0)
        {
          name=g_strdup(map->key);
          i = 0;
          if(!(name == ((char *)NULL)))
            while(!(item == ((struct _GList *)NULL)) && (n == 0 || !(i >= n)))
            {
              map = (struct _GmKeyValuePair *)item->data;
              i = i + 1;
              if(!(map->key == ((char *)NULL)))
              {
                return_value_strcmp$3=strcmp(map->key, name);
                tmp_if_expr$4 = return_value_strcmp$3 == 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$4 = (_Bool)0;
              if(tmp_if_expr$4)
              {
                item = item->next;
                *alter=g_list_remove(*alter, (const void *)map);
                gm_mcp_icecrew_userlist_pair_free(map);
              }

              else
                break;
            }

          g_free((void *)name);
          break;
        }

      }

      g_free((void *)pathd);
    }
  }

}

// gm_mcp_icecrew_userlist_remove_datatag
// file mcp/gm-mcp-icecrew-userlist.c line 291
void gm_mcp_icecrew_userlist_remove_datatag(struct _GmMcpIcecrewUserlist *package, const char *datatag)
{
  struct _GList *item;
  struct _GmKeyValuePair *map;
  if(!(datatag == ((const char *)NULL)))
  {
    item = package->priv->key_datatags;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      map = (struct _GmKeyValuePair *)item->data;
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(map->value, datatag);
      if(return_value_strcmp$1 == 0)
      {
        gm_mcp_icecrew_userlist_pair_free(map);
        package->priv->key_datatags=g_list_remove_link(package->priv->key_datatags, item);
        g_list_free_1(item);
        goto __CPROVER_DUMP_L5;
      }

    }
  }


__CPROVER_DUMP_L5:
  ;
}

// gm_mcp_icecrew_userlist_remove_not_used_icons
// file mcp/gm-mcp-icecrew-userlist.c line 544
void gm_mcp_icecrew_userlist_remove_not_used_icons(struct _GList *icons, char *dir)
{
  struct anonymous$13 gl;
  unsigned int i;
  struct _GList *names;
  char *g;
  g=g_strconcat(dir, (const void *)"/", (const void *)"*", (void *)0);
  glob(g, 0, (signed int (*)(const char *, signed int))(void *)0, &gl);
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= gl.gl_pathc); i = i + 1u)
  {
    names=gm_mcp_icecrew_userlist_find_icon_names(icons, gl.gl_pathv[(signed long int)i]);
    if(names == ((struct _GList *)NULL))
    {
      gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.RemoveNotUsedIcons: removing %s", gl.gl_pathv[(signed long int)i]);
      signed int return_value_unlink$3;
      return_value_unlink$3=unlink(gl.gl_pathv[(signed long int)i]);
      if(return_value_unlink$3 == -1)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        gm_debug_msg(DEBUG_MCP, "GmMcpIcecrewUserlist.RemoveNotUsedIcons: error %s", return_value_strerror$2);
      }

    }

    else
      g_list_free(names);
  }
  g_free((void *)g);
  globfree(&gl);
}

// gm_mcp_icecrew_userlist_set_session
// file mcp/gm-mcp-icecrew-userlist.c line 1124
void gm_mcp_icecrew_userlist_set_session(struct _GmMcpPackage *package, struct _GObject *session)
{
  struct _GmMcpPackageClass *gm_mcp_icecrew_userlist_set_session$$1$$parent_class;
  void *return_value_g_type_class_peek_parent$1;
  return_value_g_type_class_peek_parent$1=g_type_class_peek_parent((void *)(struct _GmMcpIcecrewUserlistClass *)((struct _GTypeInstance *)package)->g_class);
  gm_mcp_icecrew_userlist_set_session$$1$$parent_class = (struct _GmMcpPackageClass *)return_value_g_type_class_peek_parent$1;
  char *icons_dir;
  struct _GmMcpPackage *playerdb;
  struct _GmMcpIcecrewUserlist *userlist;
  unsigned long int return_value_gm_mcp_icecrew_userlist_get_type$2;
  return_value_gm_mcp_icecrew_userlist_get_type$2=gm_mcp_icecrew_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_icecrew_userlist_get_type$2);
  userlist = (struct _GmMcpIcecrewUserlist *)return_value_g_type_check_instance_cast$3;
  struct _GmMcpSession *ses;
  double version;
  gm_mcp_icecrew_userlist_set_session$$1$$parent_class->set_session(package, session);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)session, return_value_gm_mcp_session_get_type$4);
  ses = (struct _GmMcpSession *)return_value_g_type_check_instance_cast$5;
  playerdb=gm_mcp_session_find_package(ses, "dns-nl-icecrew-playerdb");
  if(playerdb == ((struct _GmMcpPackage *)NULL))
    g_return_if_fail_warning((char *)0, (const char *)"gm_mcp_icecrew_userlist_set_session", "playerdb != NULL");

  else
  {
    unsigned long int return_value_gm_mcp_package_get_type$6;
    return_value_gm_mcp_package_get_type$6=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)playerdb, return_value_gm_mcp_package_get_type$6);
    version=gm_mcp_package_get_version((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$7);
    if(IEEE_FLOAT_EQUAL(version, 1.1))
      userlist->priv->property_names = gm_mcp_icecrew_userlist_property_names1;

    else
      userlist->priv->property_names = gm_mcp_icecrew_userlist_property_names0;
    struct _GObject *return_value_gm_mcp_session_world$8;
    return_value_gm_mcp_session_world$8=gm_mcp_session_world(ses);
    unsigned long int return_value_gm_world_get_type$9;
    return_value_gm_world_get_type$9=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$8, return_value_gm_world_get_type$9);
    const char *return_value_gm_world_path$11;
    return_value_gm_world_path$11=gm_world_path((struct _GmWorld *)return_value_g_type_check_instance_cast$10);
    icons_dir=g_strconcat(return_value_gm_world_path$11, (const void *)"/", (const void *)"icons", (void *)0);
    userlist->priv->rank_dir=g_strconcat(icons_dir, (const void *)"/", (const void *)"ranks", (void *)0);
    userlist->priv->state_dir=g_strconcat(icons_dir, (const void *)"/", (const void *)"states", (void *)0);
    signed int return_value_g_file_test$12;
    return_value_g_file_test$12=g_file_test(icons_dir, (enum anonymous$106)G_FILE_TEST_EXISTS);
    if(return_value_g_file_test$12 == 0)
      mkdir(icons_dir, (unsigned int)0755);

    signed int return_value_g_file_test$13;
    return_value_g_file_test$13=g_file_test(userlist->priv->rank_dir, (enum anonymous$106)G_FILE_TEST_EXISTS);
    if(return_value_g_file_test$13 == 0)
      mkdir(userlist->priv->rank_dir, (unsigned int)0755);

    signed int return_value_g_file_test$14;
    return_value_g_file_test$14=g_file_test(userlist->priv->state_dir, (enum anonymous$106)G_FILE_TEST_EXISTS);
    if(return_value_g_file_test$14 == 0)
      mkdir(userlist->priv->state_dir, (unsigned int)0755);

    g_free((void *)icons_dir);
    g_signal_connect_data((void *)playerdb, "add", (void (*)(void))on_gm_mcp_icecrew_userlist_add, (void *)package, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)playerdb, "set", (void (*)(void))on_gm_mcp_icecrew_userlist_set, (void *)package, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)playerdb, "delete", (void (*)(void))on_gm_mcp_icecrew_userlist_delete, (void *)package, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  }
}

// gm_mcp_icecrew_userlist_update_rank_icon
// file mcp/gm-mcp-icecrew-userlist.c line 489
void gm_mcp_icecrew_userlist_update_rank_icon(struct _GmPlayerdbPlayerInfo *ppi, void *user_data)
{
  g_signal_emit_by_name(user_data, "rank-changed", ppi->id);
}

// gm_mcp_icecrew_userlist_update_state_icon
// file mcp/gm-mcp-icecrew-userlist.c line 495
void gm_mcp_icecrew_userlist_update_state_icon(struct _GmPlayerdbPlayerInfo *ppi, void *user_data)
{
  g_signal_emit_by_name(user_data, "state-changed", ppi->id);
}

// gm_mcp_icecrew_userlist_url_map_new
// file mcp/gm-mcp-icecrew-userlist.c line 226
struct _GmKeyValuePair * gm_mcp_icecrew_userlist_url_map_new(const char *name, const char *filename)
{
  struct _GmKeyValuePair *r;
  void *return_value_g_malloc_n$1;
  return_value_g_malloc_n$1=g_malloc_n((unsigned long int)1, sizeof(struct _GmKeyValuePair) /*16ul*/ );
  r = (struct _GmKeyValuePair *)return_value_g_malloc_n$1;
  r->key=g_strdup(name);
  r->value=g_strdup(filename);
  return r;
}

// gm_mcp_list_free
// file mcp/gm-mcp.c line 268
void gm_mcp_list_free(struct _GList *list)
{
  gm_g_list_free_simple(list);
}

// gm_mcp_mud_moo_simpleedit_add_editor
// file mcp/gm-mcp-mud-moo-simpleedit.c line 137
static void gm_mcp_mud_moo_simpleedit_add_editor(struct _GmMcpMudMooSimpleedit *package, struct _GmEditor *editor)
{
  g_signal_connect_data((void *)editor, "save", (void (*)(void))on_gm_mcp_mud_moo_simpleedit_editor_save, (void *)package, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  package->priv->editors=g_slist_prepend(package->priv->editors, (void *)editor);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)editor, (unsigned long int)(20 << 2));
  g_object_weak_ref((struct _GObject *)return_value_g_type_check_instance_cast$1, (void (*)(void *, struct _GObject *))gm_mcp_mud_moo_simpleedit_remove_editor, (void *)package);
}

// gm_mcp_mud_moo_simpleedit_class_init
// file mcp/gm-mcp-mud-moo-simpleedit.c line 70
static void gm_mcp_mud_moo_simpleedit_class_init(struct _GmMcpMudMooSimpleeditClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_mud_moo_simpleedit_finalize;
  pklass->name = "dns-org-mud-moo-simpleedit";
  pklass->set_session = gm_mcp_mud_moo_simpleedit_set_session;
  pklass->handle_simple = gm_mcp_mud_moo_simpleedit_handle_simple;
  pklass->handle_multi = gm_mcp_mud_moo_simpleedit_handle_multi;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpMudMooSimpleeditPrivate) /*32ul*/ );
}

// gm_mcp_mud_moo_simpleedit_class_intern_init
// file mcp/gm-mcp-mud-moo-simpleedit.c line 29
static void gm_mcp_mud_moo_simpleedit_class_intern_init(void *klass)
{
  gm_mcp_mud_moo_simpleedit_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpMudMooSimpleedit_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpMudMooSimpleedit_private_offset);

  gm_mcp_mud_moo_simpleedit_class_init((struct _GmMcpMudMooSimpleeditClass *)klass);
}

// gm_mcp_mud_moo_simpleedit_finalize
// file mcp/gm-mcp-mud-moo-simpleedit.c line 51
static void gm_mcp_mud_moo_simpleedit_finalize(struct _GObject *object)
{
  struct _GmMcpMudMooSimpleedit *obj;
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$1;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$1=gm_mcp_mud_moo_simpleedit_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_mcp_mud_moo_simpleedit_get_type$1);
  obj = (struct _GmMcpMudMooSimpleedit *)return_value_g_type_check_instance_cast$2;
  g_free((void *)obj->priv->ref);
  g_free((void *)obj->priv->name);
  g_free((void *)obj->priv->type);
  while(!(obj->priv->editors == ((struct _GSList *)NULL)))
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)obj->priv->editors->data, (unsigned long int)(20 << 2));
    g_object_weak_unref((struct _GObject *)return_value_g_type_check_instance_cast$3, (void (*)(void *, struct _GObject *))gm_mcp_mud_moo_simpleedit_remove_editor, (void *)obj);
    unsigned long int return_value_gm_editor_get_type$4;
    return_value_gm_editor_get_type$4=gm_editor_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)obj->priv->editors->data, return_value_gm_editor_get_type$4);
    gm_mcp_mud_moo_simpleedit_remove_editor(obj, (struct _GmEditor *)return_value_g_type_check_instance_cast$5);
  }
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_mud_moo_simpleedit_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$6)->finalize(object);
}

// gm_mcp_mud_moo_simpleedit_get_type
// file mcp/gm-mcp-mud-moo-simpleedit.h line 54
unsigned long int gm_mcp_mud_moo_simpleedit_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpMudMooSimpleedit");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpMudMooSimpleeditClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_mud_moo_simpleedit_class_intern_init, (unsigned int)sizeof(struct _GmMcpMudMooSimpleedit) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_mud_moo_simpleedit_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_mud_moo_simpleedit_handle_multi
// file mcp/gm-mcp-mud-moo-simpleedit.c line 148
signed int gm_mcp_mud_moo_simpleedit_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values)
{
  struct _GmEditor *editor;
  struct _GmMcpMudMooSimpleedit *simpleedit;
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$1;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$1=gm_mcp_mud_moo_simpleedit_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_mud_moo_simpleedit_get_type$1);
  simpleedit = (struct _GmMcpMudMooSimpleedit *)return_value_g_type_check_instance_cast$2;
  if(!(key == ((const char *)NULL)))
    return 0;

  else
  {
    editor=gm_editor_new_mcp(simpleedit->priv->name, simpleedit->priv->ref, simpleedit->priv->type, all_values);
    gm_mcp_mud_moo_simpleedit_add_editor(simpleedit, editor);
    unsigned long int return_value_gm_mcp_package_get_type$3;
    return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$3);
    struct _GObject *return_value_gm_mcp_package_get_session$5;
    return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
    unsigned long int return_value_gm_mcp_session_get_type$6;
    return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
    struct _GObject *return_value_gm_mcp_session_world$8;
    return_value_gm_mcp_session_world$8=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7);
    unsigned long int return_value_gm_world_get_type$9;
    return_value_gm_world_get_type$9=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$8, return_value_gm_world_get_type$9);
    gm_world_add_editor((struct _GmWorld *)return_value_g_type_check_instance_cast$10, editor);
  }
  return (signed int)!(0 != 0);
}

// gm_mcp_mud_moo_simpleedit_handle_simple
// file mcp/gm-mcp-mud-moo-simpleedit.c line 107
void gm_mcp_mud_moo_simpleedit_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  const char *name;
  const char *ref;
  const char *type;
  struct _GmMcpMudMooSimpleedit *simpleedit;
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$1;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$1=gm_mcp_mud_moo_simpleedit_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_mud_moo_simpleedit_get_type$1);
  simpleedit = (struct _GmMcpMudMooSimpleedit *)return_value_g_type_check_instance_cast$2;
  signed int return_value_g_strcasecmp$3;
  return_value_g_strcasecmp$3=g_strcasecmp(suffix, "content");
  if(return_value_g_strcasecmp$3 == 0)
  {
    name=gm_mcp_find_value(fields, "name");
    if(name == ((const char *)NULL))
      gm_debug_msg(DEBUG_MCP, "GmMcpMooMudSimpleedit.HandleSimple: no name found, ignoring!");

    else
    {
      ref=gm_mcp_find_value(fields, "reference");
      if(ref == ((const char *)NULL))
        gm_debug_msg(DEBUG_MCP, "GmMcpMooMudSimpleedit.HandleSimple: no reference found, ignoring!");

      else
      {
        type=gm_mcp_find_value(fields, "type");
        if(type == ((const char *)NULL))
          gm_debug_msg(DEBUG_MCP, "GmMcpMooMudSimpleedit.HandleSimple: no type found, ignoring!");

        else
        {
          gm_debug_msg(DEBUG_MCP, "GmMcpMooMudSimpleedit.HandleSimple: accept content: name = %s, reference = %s, type = %s", name, ref, type);
          simpleedit->priv->name=g_strdup(name);
          simpleedit->priv->ref=g_strdup(ref);
          simpleedit->priv->type=g_strdup(type);
        }
      }
    }
  }

  else
    gm_debug_msg(DEBUG_MCP, "GmMcpMooMudSimpleedit.HandleSimple: unknown suffix: %s", suffix);
}

// gm_mcp_mud_moo_simpleedit_init
// file mcp/gm-mcp-mud-moo-simpleedit.c line 95
static void gm_mcp_mud_moo_simpleedit_init(struct _GmMcpMudMooSimpleedit *obj)
{
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$1;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$1=gm_mcp_mud_moo_simpleedit_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_mud_moo_simpleedit_get_type$1);
  obj->priv = (struct _GmMcpMudMooSimpleeditPrivate *)return_value_g_type_instance_get_private$2;
}

// gm_mcp_mud_moo_simpleedit_new
// file mcp/gm-mcp-mud-moo-simpleedit.c line 100
struct _GmMcpMudMooSimpleedit * gm_mcp_mud_moo_simpleedit_new(void)
{
  struct _GmMcpMudMooSimpleedit *obj;
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$1;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$1=gm_mcp_mud_moo_simpleedit_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_mud_moo_simpleedit_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$3;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$3=gm_mcp_mud_moo_simpleedit_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_mud_moo_simpleedit_get_type$3);
  obj = (struct _GmMcpMudMooSimpleedit *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_mud_moo_simpleedit_remove_editor
// file mcp/gm-mcp-mud-moo-simpleedit.c line 41
static void gm_mcp_mud_moo_simpleedit_remove_editor(struct _GmMcpMudMooSimpleedit *simpleedit, struct _GmEditor *editor)
{
  g_signal_handlers_disconnect_matched((void *)editor, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_mud_moo_simpleedit_editor_save, (void *)simpleedit);
  simpleedit->priv->editors=g_slist_remove(simpleedit->priv->editors, (const void *)editor);
}

// gm_mcp_mud_moo_simpleedit_set_session
// file mcp/gm-mcp-mud-moo-simpleedit.c line 170
void gm_mcp_mud_moo_simpleedit_set_session(struct _GmMcpPackage *package, struct _GObject *session)
{
  struct _GmMcpPackageClass *gm_mcp_mud_moo_simpleedit_set_session$$1$$parent_class;
  void *return_value_g_type_class_peek_parent$1;
  return_value_g_type_class_peek_parent$1=g_type_class_peek_parent((void *)(struct _GmMcpMudMooSimpleeditClass *)((struct _GTypeInstance *)package)->g_class);
  gm_mcp_mud_moo_simpleedit_set_session$$1$$parent_class = (struct _GmMcpPackageClass *)return_value_g_type_class_peek_parent$1;
  const struct _GSList *editors;
  unsigned long int return_value_gm_mcp_session_get_type$2;
  return_value_gm_mcp_session_get_type$2=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)session, return_value_gm_mcp_session_get_type$2);
  struct _GObject *return_value_gm_mcp_session_world$4;
  return_value_gm_mcp_session_world$4=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$3);
  unsigned long int return_value_gm_world_get_type$5;
  return_value_gm_world_get_type$5=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$4, return_value_gm_world_get_type$5);
  editors=gm_world_editors((struct _GmWorld *)return_value_g_type_check_instance_cast$6);
  struct _GmMcpMudMooSimpleedit *simpleedit;
  unsigned long int return_value_gm_mcp_mud_moo_simpleedit_get_type$7;
  return_value_gm_mcp_mud_moo_simpleedit_get_type$7=gm_mcp_mud_moo_simpleedit_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_mud_moo_simpleedit_get_type$7);
  simpleedit = (struct _GmMcpMudMooSimpleedit *)return_value_g_type_check_instance_cast$8;
  gm_mcp_mud_moo_simpleedit_set_session$$1$$parent_class->set_session(package, session);
  if(!(editors == ((const struct _GSList *)NULL)))
  {
    unsigned long int return_value_gm_editor_get_type$9;
    return_value_gm_editor_get_type$9=gm_editor_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)editors->data, return_value_gm_editor_get_type$9);
    gm_mcp_mud_moo_simpleedit_add_editor(simpleedit, (struct _GmEditor *)return_value_g_type_check_instance_cast$10);
    editors = editors->next;
  }

}

// gm_mcp_negotiate_class_init
// file mcp/gm-mcp-negotiate.c line 46
static void gm_mcp_negotiate_class_init(struct _GmMcpNegotiateClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_negotiate_finalize;
  pklass->name = "mcp-negotiate";
  pklass->handle_simple = gm_mcp_negotiate_handle_simple;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpNegotiatePrivate) /*8ul*/ );
}

// gm_mcp_negotiate_class_intern_init
// file mcp/gm-mcp-negotiate.c line 36
static void gm_mcp_negotiate_class_intern_init(void *klass)
{
  gm_mcp_negotiate_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpNegotiate_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpNegotiate_private_offset);

  gm_mcp_negotiate_class_init((struct _GmMcpNegotiateClass *)klass);
}

// gm_mcp_negotiate_finalize
// file mcp/gm-mcp-negotiate.c line 39
static void gm_mcp_negotiate_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_negotiate_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_mcp_negotiate_find_package
// file mcp/gm-mcp-negotiate.c line 75
struct _PackageInfo * gm_mcp_negotiate_find_package(struct _GmMcpNegotiate *package, char *name)
{
  struct _PackageInfo *pinfo;
  struct _GList *elem = package->priv->packages;
  for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
  {
    pinfo = (struct _PackageInfo *)elem->data;
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(pinfo->klass->name, name);
    if(return_value_strcasecmp$1 == 0)
      return pinfo;

  }
  return (struct _PackageInfo *)(void *)0;
}

// gm_mcp_negotiate_fix_depends
// file mcp/gm-mcp-negotiate.c line 123
void gm_mcp_negotiate_fix_depends(struct _GmMcpNegotiate *package)
{
  struct _PackageInfo *pinfo;
  struct _PackageInfo *pdep;
  struct _GList *l;
  struct _GList *item;
  char **dep;
  l=g_list_copy(package->priv->packages);
  item = l;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    pinfo = (struct _PackageInfo *)item->data;
    dep = pinfo->klass->depends;
    if(!(dep == ((char **)NULL)))
      for( ; !(*dep == ((char *)NULL)); dep = dep + 1l)
      {
        pdep=gm_mcp_negotiate_find_package(package, *dep);
        if(pdep == ((struct _PackageInfo *)NULL))
        {
          gm_debug_msg(DEBUG_MCP, "GmMcpNegotiate.FixDepends: package %s depends on %s, but %s is not supported", pinfo->klass->name, *dep, *dep);
          package->priv->packages=g_list_remove(package->priv->packages, (const void *)pinfo);
          break;
        }

        else
        {
          package->priv->packages=g_list_remove(package->priv->packages, (const void *)pdep);
          struct _GList *return_value_g_list_find$1;
          return_value_g_list_find$1=g_list_find(package->priv->packages, (const void *)pinfo);
          package->priv->packages=g_list_insert_before(package->priv->packages, return_value_g_list_find$1, (void *)pdep);
        }
      }

  }
  g_list_free(l);
}

// gm_mcp_negotiate_fix_overrides
// file mcp/gm-mcp-negotiate.c line 92
void gm_mcp_negotiate_fix_overrides(struct _GmMcpNegotiate *package)
{
  struct _GList *l;
  struct _GList *item;
  struct _PackageInfo *pinfo;
  struct _PackageInfo *pover;
  char **over;
  l=g_list_copy(package->priv->packages);
  item = l;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    pinfo = (struct _PackageInfo *)item->data;
    over = pinfo->klass->overrides;
    if(!(over == ((char **)NULL)))
      for( ; !(*over == ((char *)NULL)); over = over + 1l)
      {
        pover=gm_mcp_negotiate_find_package(package, *over);
        if(!(pover == ((struct _PackageInfo *)NULL)))
        {
          gm_debug_msg(DEBUG_MCP, "GmMcpNegotiate.FixOverrides: package %s overrides %s", pinfo->klass->name, pover->klass->name);
          package->priv->packages=g_list_remove(package->priv->packages, (const void *)pover);
        }

      }

  }
  g_list_free(l);
}

// gm_mcp_negotiate_get_type
// file mcp/gm-mcp-negotiate.h line 53
unsigned long int gm_mcp_negotiate_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpNegotiate");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpNegotiateClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_negotiate_class_intern_init, (unsigned int)sizeof(struct _GmMcpNegotiate) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_negotiate_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_negotiate_handle_simple
// file mcp/gm-mcp-negotiate.c line 191
void gm_mcp_negotiate_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  const char *pname;
  struct _GmMcpPackageClass *pklass;
  struct _GmMcpNegotiate *negotiate;
  unsigned long int return_value_gm_mcp_negotiate_get_type$1;
  return_value_gm_mcp_negotiate_get_type$1=gm_mcp_negotiate_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_negotiate_get_type$1);
  negotiate = (struct _GmMcpNegotiate *)return_value_g_type_check_instance_cast$2;
  struct _PackageInfo *pinfo;
  double version;
  const char *min_v;
  const char *max_v;
  double cmin = 0.0;
  double cmax = 0.0;
  struct _GList *elem;
  signed int return_value_strcasecmp$15;
  return_value_strcasecmp$15=strcasecmp(suffix, "can");
  signed int return_value_strcasecmp$14;
  if(return_value_strcasecmp$15 == 0)
  {
    pname=gm_mcp_find_value(fields, "package");
    pklass=gm_mcp_session_find_package_class(pname);
    if(!(pklass == ((struct _GmMcpPackageClass *)NULL)))
    {
      min_v=gm_mcp_find_value(fields, "min-version");
      if(!(min_v == ((const char *)NULL)))
        cmin=g_ascii_strtod(min_v, (char **)(void *)0);

      max_v=gm_mcp_find_value(fields, "max-version");
      if(!(max_v == ((const char *)NULL)))
        cmax=g_ascii_strtod(max_v, (char **)(void *)0);

      version=gm_mcp_get_version(pklass->min_version, pklass->max_version, cmin, cmax);
      if(version > 0.0)
      {
        gm_debug_msg(DEBUG_MCP, "GmMcpNegotiate.HandleSimple: %s, package is supported", pname);
        void *return_value_g_malloc_n$3;
        return_value_g_malloc_n$3=g_malloc_n((unsigned long int)1, sizeof(struct _PackageInfo) /*16ul*/ );
        pinfo = (struct _PackageInfo *)return_value_g_malloc_n$3;
        pinfo->klass = pklass;
        pinfo->version = version;
        negotiate->priv->packages=g_list_append(negotiate->priv->packages, (void *)pinfo);
      }

      else
        gm_debug_msg(DEBUG_MCP, "GmMcpNegotiate.HandleSimple: %s, package supported but wrong version!", pname);
    }

    else
      gm_debug_msg(DEBUG_MCP, "GmMcpNegotiate.HandleSimple: %s, package is not supported!", pname);
  }

  else
  {
    return_value_strcasecmp$14=strcasecmp(suffix, "end");
    if(return_value_strcasecmp$14 == 0)
    {
      gm_mcp_session_package_class_for_each(gm_mcp_negotiate_send_can, (void *)negotiate);
      unsigned long int return_value_gm_mcp_package_get_type$4;
      return_value_gm_mcp_package_get_type$4=gm_mcp_package_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)negotiate, return_value_gm_mcp_package_get_type$4);
      struct _GObject *return_value_gm_mcp_package_get_session$6;
      return_value_gm_mcp_package_get_session$6=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$5);
      unsigned long int return_value_gm_mcp_session_get_type$7;
      return_value_gm_mcp_session_get_type$7=gm_mcp_session_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$6, return_value_gm_mcp_session_get_type$7);
      gm_mcp_session_send_simple((struct _GmMcpSession *)return_value_g_type_check_instance_cast$8, "mcp-negotiate-end", (const char *)(void *)0);
      gm_mcp_negotiate_fix_overrides(negotiate);
      gm_mcp_negotiate_fix_depends(negotiate);
      elem = negotiate->priv->packages;
      for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
      {
        pinfo = (struct _PackageInfo *)elem->data;
        unsigned long int return_value_gm_mcp_package_get_type$9;
        return_value_gm_mcp_package_get_type$9=gm_mcp_package_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)negotiate, return_value_gm_mcp_package_get_type$9);
        struct _GObject *return_value_gm_mcp_package_get_session$11;
        return_value_gm_mcp_package_get_session$11=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$10);
        unsigned long int return_value_gm_mcp_session_get_type$12;
        return_value_gm_mcp_session_get_type$12=gm_mcp_session_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
        return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$11, return_value_gm_mcp_session_get_type$12);
        gm_mcp_session_create_package((struct _GmMcpSession *)return_value_g_type_check_instance_cast$13, pinfo->klass, pinfo->version);
        g_free((void *)pinfo);
      }
      g_list_free(negotiate->priv->packages);
      negotiate->priv->packages = (struct _GList *)(void *)0;
    }

  }
}

// gm_mcp_negotiate_init
// file mcp/gm-mcp-negotiate.c line 69
static void gm_mcp_negotiate_init(struct _GmMcpNegotiate *obj)
{
  unsigned long int return_value_gm_mcp_negotiate_get_type$1;
  return_value_gm_mcp_negotiate_get_type$1=gm_mcp_negotiate_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_negotiate_get_type$1);
  obj->priv = (struct _GmMcpNegotiatePrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->packages = (struct _GList *)(void *)0;
}

// gm_mcp_negotiate_new
// file mcp/gm-mcp-negotiate.c line 167
struct _GmMcpNegotiate * gm_mcp_negotiate_new(void)
{
  struct _GmMcpNegotiate *obj;
  unsigned long int return_value_gm_mcp_negotiate_get_type$1;
  return_value_gm_mcp_negotiate_get_type$1=gm_mcp_negotiate_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_negotiate_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_negotiate_get_type$3;
  return_value_gm_mcp_negotiate_get_type$3=gm_mcp_negotiate_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_negotiate_get_type$3);
  obj = (struct _GmMcpNegotiate *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_negotiate_send_can
// file mcp/gm-mcp-negotiate.c line 176
signed int gm_mcp_negotiate_send_can(struct _GmMcpPackageClass *klass, void *user_data)
{
  struct _GmMcpNegotiate *package;
  unsigned long int return_value_gm_mcp_negotiate_get_type$1;
  return_value_gm_mcp_negotiate_get_type$1=gm_mcp_negotiate_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_gm_mcp_negotiate_get_type$1);
  package = (struct _GmMcpNegotiate *)return_value_g_type_check_instance_cast$2;
  char min_v[16l];
  char max_v[16l];
  g_ascii_formatd(min_v, 16, "%.1f", klass->min_version);
  g_ascii_formatd(max_v, 16, "%.1f", klass->max_version);
  unsigned long int return_value_gm_mcp_package_get_type$3;
  return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$3);
  struct _GObject *return_value_gm_mcp_package_get_session$5;
  return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gm_mcp_session_get_type$6;
  return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
  gm_mcp_session_send_simple((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7, "mcp-negotiate-can", "package", klass->name, (const void *)"min-version", (const void *)min_v, (const void *)"max-version", (const void *)max_v, (void *)0);
  return 0;
}

// gm_mcp_package_can_create_view
// file mcp/gm-mcp-package.c line 115
signed int gm_mcp_package_can_create_view(struct _GmMcpPackage *package)
{
  return (signed int)(((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->create_view != (void (*)(struct _GmMcpPackage *, struct _GObject *))(void *)0);
}

// gm_mcp_package_can_handle_multi
// file mcp/gm-mcp-package.h line 77
signed int gm_mcp_package_can_handle_multi(struct _GmMcpPackage *package)
{
  return (signed int)(((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->handle_multi != (signed int (*)(struct _GmMcpPackage *, const char *, const char *, const char *, struct _GList *))(void *)0);
}

// gm_mcp_package_can_handle_simple
// file mcp/gm-mcp-package.h line 73
signed int gm_mcp_package_can_handle_simple(struct _GmMcpPackage *package)
{
  return (signed int)(((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->handle_simple != (void (*)(struct _GmMcpPackage *, char *, struct _GList *))(void *)0);
}

// gm_mcp_package_class_init
// file mcp/gm-mcp-package.c line 34
static void gm_mcp_package_class_init(struct _GmMcpPackageClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_mcp_package_finalize;
  klass->handle_simple = (void (*)(struct _GmMcpPackage *, char *, struct _GList *))(void *)0;
  klass->handle_multi = (signed int (*)(struct _GmMcpPackage *, const char *, const char *, const char *, struct _GList *))(void *)0;
  klass->create_view = (void (*)(struct _GmMcpPackage *, struct _GObject *))(void *)0;
  klass->set_session = gm_mcp_package_set_session_real;
  klass->depends = (char **)(void *)0;
  klass->overrides = (char **)(void *)0;
  klass->name = (char *)(void *)0;
  klass->min_version = 1.0;
  klass->max_version = 1.0;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpPackagePrivate) /*16ul*/ );
}

// gm_mcp_package_class_intern_init
// file mcp/gm-mcp-package.c line 24
static void gm_mcp_package_class_intern_init(void *klass)
{
  gm_mcp_package_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpPackage_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpPackage_private_offset);

  gm_mcp_package_class_init((struct _GmMcpPackageClass *)klass);
}

// gm_mcp_package_create_view
// file ./mcp/gm-mcp-package.h line 79
void gm_mcp_package_create_view(struct _GmMcpPackage *package, struct _GObject *parent)
{
  signed int return_value_gm_mcp_package_can_create_view$1;
  return_value_gm_mcp_package_can_create_view$1=gm_mcp_package_can_create_view(package);
  if(!(return_value_gm_mcp_package_can_create_view$1 == 0))
    ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->create_view(package, parent);

}

// gm_mcp_package_finalize
// file mcp/gm-mcp-package.c line 28
static void gm_mcp_package_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_package_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_mcp_package_get_depends
// file mcp/gm-mcp-package.c line 145
char ** gm_mcp_package_get_depends(struct _GmMcpPackage *package)
{
  return ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->depends;
}

// gm_mcp_package_get_max_version
// file mcp/gm-mcp-package.c line 160
double gm_mcp_package_get_max_version(struct _GmMcpPackage *package)
{
  return ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->max_version;
}

// gm_mcp_package_get_min_version
// file mcp/gm-mcp-package.c line 155
double gm_mcp_package_get_min_version(struct _GmMcpPackage *package)
{
  return ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->min_version;
}

// gm_mcp_package_get_name
// file mcp/gm-mcp-package.h line 87
const char * gm_mcp_package_get_name(struct _GmMcpPackage *package)
{
  return ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->name;
}

// gm_mcp_package_get_overrides
// file mcp/gm-mcp-package.c line 150
char ** gm_mcp_package_get_overrides(struct _GmMcpPackage *package)
{
  return ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->overrides;
}

// gm_mcp_package_get_session
// file mcp/gm-mcp-package.c line 125
struct _GObject * gm_mcp_package_get_session(struct _GmMcpPackage *package)
{
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)package->priv->session, (unsigned long int)(20 << 2));
  return (struct _GObject *)return_value_g_type_check_instance_cast$1;
}

// gm_mcp_package_get_type
// file mcp/gm-mcp-package.h line 67
unsigned long int gm_mcp_package_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmMcpPackage");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmMcpPackageClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_package_class_intern_init, (unsigned int)sizeof(struct _GmMcpPackage) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_package_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_package_get_version
// file mcp/gm-mcp-package.c line 135
double gm_mcp_package_get_version(struct _GmMcpPackage *package)
{
  return package->priv->version;
}

// gm_mcp_package_handle_multi
// file mcp/gm-mcp-package.h line 75
signed int gm_mcp_package_handle_multi(struct _GmMcpPackage *package, char *data_tag, char *key, char *value, struct _GList *allValues)
{
  signed int return_value;
  return_value=((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->handle_multi(package, data_tag, key, value, allValues);
  return return_value;
}

// gm_mcp_package_handle_simple
// file mcp/gm-mcp-package.h line 71
void gm_mcp_package_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->handle_simple(package, suffix, fields);
}

// gm_mcp_package_init
// file mcp/gm-mcp-package.c line 64
static void gm_mcp_package_init(struct _GmMcpPackage *obj)
{
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_package_get_type$1);
  obj->priv = (struct _GmMcpPackagePrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->session = (struct _GmMcpSession *)(void *)0;
  obj->priv->version = 1.0;
}

// gm_mcp_package_new
// file mcp/gm-mcp-package.c line 77
struct _GmMcpPackage * gm_mcp_package_new()
{
  struct _GmMcpPackage *obj;
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_package_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_package_get_type$3;
  return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_package_get_type$3);
  obj = (struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_package_set_session
// file mcp/gm-mcp-package.h line 69
void gm_mcp_package_set_session(struct _GmMcpPackage *package, struct _GObject *session)
{
  ((struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class)->set_session(package, session);
}

// gm_mcp_package_set_session_real
// file mcp/gm-mcp-package.c line 71
void gm_mcp_package_set_session_real(struct _GmMcpPackage *package, struct _GObject *session)
{
  unsigned long int return_value_gm_mcp_session_get_type$1;
  return_value_gm_mcp_session_get_type$1=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)session, return_value_gm_mcp_session_get_type$1);
  package->priv->session = (struct _GmMcpSession *)return_value_g_type_check_instance_cast$2;
}

// gm_mcp_package_set_version
// file mcp/gm-mcp-package.h line 82
void gm_mcp_package_set_version(struct _GmMcpPackage *package, double version)
{
  package->priv->version = version;
}

// gm_mcp_parse_line
// file mcp/gm-mcp.c line 175
signed int gm_mcp_parse_line(char *line, struct _McpMessageInfo *info)
{
  char *p;
  p=g_utf8_strchr(line, (signed long int)-1, (unsigned int)32);
  if(p == ((char *)NULL) || p == line)
    return 0;

  else
  {
    info->name=g_strndup(line, (unsigned long int)(p - line));
    line = p + (signed long int)1;
    p=g_utf8_strchr(line, (signed long int)-1, (unsigned int)32);
    if(p == ((char *)NULL))
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(line);
      p = line + (signed long int)return_value_strlen$1;
    }

    info->authkey=g_strndup(line, (unsigned long int)(p - line));
    info->fields=gm_mcp_process_key_values(p);
    return (signed int)!(0 != 0);
  }
}

// gm_mcp_parse_list
// file mcp/gm-mcp.c line 273
struct _GList * gm_mcp_parse_list(const char *s)
{
  struct _GList *result = (struct _GList *)(void *)0;
  signed long int result$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  result$array_size0 = (signed long int)(return_value_strlen$1 + (unsigned long int)1);
  char item_mem[result$array_size0];
  char *item;
  unsigned int c;
  unsigned int cn;
  char *next_char;
  while(!((signed int)*s == 0))
  {
    gm_string_skip_space(&s);
    item = item_mem;
    *item = (char)0;
    while(!((signed int)*s == 0))
    {
      c=g_utf8_get_char(s);
      next_char = (char *)(s + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)s)]);
      cn=g_utf8_get_char(next_char);
      signed int return_value_g_unichar_isspace$2;
      return_value_g_unichar_isspace$2=g_unichar_isspace(c);
      if(!(return_value_g_unichar_isspace$2 == 0))
        break;

      if(c == 92u && !(cn == 0u))
      {
        c = cn;
        next_char = (char *)(next_char + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)next_char)]);
      }

      signed int return_value_g_unichar_to_utf8$3;
      return_value_g_unichar_to_utf8$3=g_unichar_to_utf8(c, item);
      item = item + (signed long int)return_value_g_unichar_to_utf8$3;
      s = next_char;
    }
    *item = (char)0;
    char *return_value_g_strdup$4;
    return_value_g_strdup$4=g_strdup(item_mem);
    result=g_list_append(result, (void *)return_value_g_strdup$4);
  }
  return result;
}

// gm_mcp_process_key_values
// file mcp/gm-mcp.c line 164
struct _GList * gm_mcp_process_key_values(const char *line)
{
  struct _GList *result = (struct _GList *)(void *)0;
  while(!(line == ((const char *)NULL)))
  {
    if((signed int)*line == 0)
      break;

    line=gm_mcp_process_keyval(&result, line);
  }
  return result;
}

// gm_mcp_process_keyval
// file mcp/gm-mcp.c line 98
const char * gm_mcp_process_keyval(struct _GList **info, const char *line)
{
  const char *keystart;
  const char *valuestart;
  signed int keylen;
  signed int valuelen;
  struct _GmKeyValuePair *newKeyValue;
  _Bool tmp_if_expr$1;
  if(!((signed int)*line == 32))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)line[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)line[(signed long int)1] == 32 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    return (const char *)(void *)0;

  else
  {
    line = line + 1l;
    keystart = line;
    gm_string_skip_till(&line, ": ");
    if(!((signed int)*line == 58))
      return (const char *)(void *)0;

    else
    {
      keylen = (signed int)(line - keystart);
      line = (char *)(line + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)line)]);
      if((signed int)line[1l] == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*line != 32 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        return (const char *)(void *)0;

      else
      {
        line = (char *)(line + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)line)]);
        if((signed int)*line == 32)
          return (const char *)(void *)0;

        else
        {
          valuestart = line;
          if((signed int)*line == 34)
          {
            valuestart = valuestart + 1l;
            line = line + 1l;
            for( ; !((signed int)*line == 0); line = line + 1l)
            {
              if((signed int)*line == 34)
                break;

              if((signed int)*line == 92)
                line = line + 1l;

            }
            valuelen = (signed int)(line - valuestart);
            if(!((signed int)*line == 34))
              valuelen = valuelen - 1;

            else
              line = line + 1l;
          }

          else
          {
            gm_string_skip_nonspace(&line);
            valuelen = (signed int)(line - valuestart);
          }
          void *return_value_g_malloc_n$4;
          return_value_g_malloc_n$4=g_malloc_n((unsigned long int)1, sizeof(struct _GmKeyValuePair) /*16ul*/ );
          newKeyValue = (struct _GmKeyValuePair *)return_value_g_malloc_n$4;
          newKeyValue->key=g_strndup(keystart, (unsigned long int)keylen);
          char *return_value_g_strndup$5;
          return_value_g_strndup$5=g_strndup(valuestart, (unsigned long int)valuelen);
          newKeyValue->value=gm_mcp_un_escape(return_value_g_strndup$5);
          *info=g_list_append(*info, (void *)newKeyValue);
          return line;
        }
      }
    }
  }
}

// gm_mcp_session_class_init
// file mcp/gm-mcp-session.c line 46
static void gm_mcp_session_class_init(struct _GmMcpSessionClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_mcp_session_finalize;
  klass->available_packages=gm_mcp_classes_initialize();
  gm_mcp_session_signals[(signed long int)0]=g_signal_new("package_created", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)144ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__OBJECT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(20 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpSessionPrivate) /*40ul*/ );
}

// gm_mcp_session_class_intern_init
// file mcp/gm-mcp-session.c line 35
static void gm_mcp_session_class_intern_init(void *klass)
{
  gm_mcp_session_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpSession_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpSession_private_offset);

  gm_mcp_session_class_init((struct _GmMcpSessionClass *)klass);
}

// gm_mcp_session_create_package
// file mcp/gm-mcp-session.c line 400
struct _GmMcpPackage * gm_mcp_session_create_package(struct _GmMcpSession *session, struct _GmMcpPackageClass *klass, double version)
{
  struct _GmMcpPackage *package;
  if(klass == ((struct _GmMcpPackageClass *)NULL))
    return (struct _GmMcpPackage *)(void *)0;

  else
  {
    struct _GmMcpPackage *return_value_gm_mcp_session_has_package_of_class$7;
    return_value_gm_mcp_session_has_package_of_class$7=gm_mcp_session_has_package_of_class(session, klass);
    if(return_value_gm_mcp_session_has_package_of_class$7 == ((struct _GmMcpPackage *)NULL))
    {
      struct _GTypeClass *return_value_g_type_check_class_cast$1;
      return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
      void *return_value_g_object_new$2;
      return_value_g_object_new$2=g_object_new(((struct _GTypeClass *)(struct _GObjectClass *)return_value_g_type_check_class_cast$1)->g_type, (const char *)(void *)0);
      package = (struct _GmMcpPackage *)return_value_g_object_new$2;
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)session, (unsigned long int)(20 << 2));
      gm_mcp_package_set_session(package, (struct _GObject *)return_value_g_type_check_instance_cast$3);
      gm_mcp_package_set_version(package, version);
      session->priv->packages=g_list_append(session->priv->packages, (void *)package);
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)package, (unsigned long int)(20 << 2));
      g_signal_emit((void *)session, gm_mcp_session_signals[(signed long int)0], (unsigned int)0, (struct _GObject *)return_value_g_type_check_instance_cast$4);
      return package;
    }

    else
    {
      struct _GmOptions *return_value_gm_world_options$5;
      return_value_gm_world_options$5=gm_world_options(session->priv->world);
      const char *return_value_gm_options_get$6;
      return_value_gm_options_get$6=gm_options_get(return_value_gm_world_options$5, "name");
      gm_debug_msg(DEBUG_MCP, "GmMcpSession.CreatePackage: package (%s) is already registered for %s", klass->name, return_value_gm_options_get$6);
      return (struct _GmMcpPackage *)(void *)0;
    }
  }
}

// gm_mcp_session_finalize
// file mcp/gm-mcp-session.c line 38
static void gm_mcp_session_finalize(struct _GObject *object)
{
  struct _GmMcpSession *obj;
  unsigned long int return_value_gm_mcp_session_get_type$1;
  return_value_gm_mcp_session_get_type$1=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_mcp_session_get_type$1);
  obj = (struct _GmMcpSession *)return_value_g_type_check_instance_cast$2;
  gm_mcp_session_reset(obj);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_session_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_mcp_session_find_package
// file mcp/gm-mcp-session.c line 379
struct _GmMcpPackage * gm_mcp_session_find_package(struct _GmMcpSession *session, const char *pname)
{
  struct _GList *elem;
  struct _GmMcpPackage *package;
  struct _GmMcpPackageClass *package_klass;
  elem = session->priv->packages;
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  _Bool tmp_if_expr$4;
  unsigned long int return_value_strlen$3;
  for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
  {
    package = (struct _GmMcpPackage *)elem->data;
    package_klass = (struct _GmMcpPackageClass *)((struct _GTypeInstance *)package)->g_class;
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(package_klass->name);
    signed int return_value_strncasecmp$6;
    return_value_strncasecmp$6=strncasecmp(pname, package_klass->name, return_value_strlen$5);
    if(return_value_strncasecmp$6 == 0)
    {
      return_value_strlen$1=strlen(pname);
      return_value_strlen$2=strlen(package_klass->name);
      if(return_value_strlen$1 == return_value_strlen$2)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_strlen$3=strlen(package_klass->name);
        tmp_if_expr$4 = (signed int)pname[(signed long int)return_value_strlen$3] == 45 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
        return package;

    }

  }
  return (struct _GmMcpPackage *)(void *)0;
}

// gm_mcp_session_find_package_class
// file mcp/gm-mcp-session.c line 436
struct _GmMcpPackageClass * gm_mcp_session_find_package_class(const char *name)
{
  struct _GmMcpPackageClass *return_value_gm_mcp_session_package_class_for_each$1;
  return_value_gm_mcp_session_package_class_for_each$1=gm_mcp_session_package_class_for_each(gm_mcp_session_find_package_class_real, (void *)name);
  return return_value_gm_mcp_session_package_class_for_each$1;
}

// gm_mcp_session_find_package_class_real
// file mcp/gm-mcp-session.c line 429
signed int gm_mcp_session_find_package_class_real(struct _GmMcpPackageClass *klass, void *user_data)
{
  char *name = (char *)user_data;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(name, klass->name);
  return (signed int)(return_value_strcmp$1 == 0);
}

// gm_mcp_session_get_packages
// file mcp/gm-mcp-session.c line 271
const struct _GList * gm_mcp_session_get_packages(struct _GmMcpSession *session)
{
  return session->priv->packages;
}

// gm_mcp_session_get_type
// file mcp/gm-mcp-session.c line 35
unsigned long int gm_mcp_session_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmMcpSession");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmMcpSessionClass) /*152ul*/ , (void (*)(void *, void *))gm_mcp_session_class_intern_init, (unsigned int)sizeof(struct _GmMcpSession) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_session_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_session_handle_multiline
// file mcp/gm-mcp-session.c line 173
void gm_mcp_session_handle_multiline(struct _GmMcpSession *session, const char *line)
{
  char *data_tag;
  char *key;
  char *value;
  const char *key_start;
  const char *ptr = line;
  gm_string_skip_nonspace(&ptr);
  if(!((signed int)*ptr == 0))
  {
    data_tag=g_strndup(line, (unsigned long int)(ptr - line));
    gm_string_skip_space(&ptr);
    key_start = ptr;
    gm_string_skip_nonspace(&ptr);
    if(!((signed int)*ptr == 0))
    {
      key=g_strndup(key_start, (unsigned long int)((ptr - key_start) - (signed long int)1));
      value=g_strdup(ptr + (signed long int)1);
      gm_mcp_session_invoke_multiline_handle(session, data_tag, key, value);
      g_free((void *)data_tag);
      g_free((void *)key);
      g_free((void *)value);
    }

  }

}

// gm_mcp_session_handle_multiline_end
// file mcp/gm-mcp-session.c line 205
void gm_mcp_session_handle_multiline_end(struct _GmMcpSession *session, char *line)
{
  const char *ptr = line;
  char *data_tag;
  gm_string_skip_nonspace(&ptr);
  data_tag=g_strndup(line, (unsigned long int)(ptr - line));
  gm_mcp_session_invoke_multiline_handle(session, data_tag, (char *)(void *)0, (char *)(void *)0);
  g_free((void *)data_tag);
}

// gm_mcp_session_handle_oob
// file mcp/gm-mcp-session.c line 442
void gm_mcp_session_handle_oob(struct _GmMcpSession *session, char *line)
{
  struct _McpMessageInfo info;
  struct _GmMcpPackage *package;
  struct _McpMultilineInfo *minfo;
  char *suffix;
  const char *value;
  const char *full;
  gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: %s", line);
  info.fields = (struct _GList *)(void *)0;
  info.authkey = (char *)(void *)0;
  info.name = (char *)(void *)0;
  signed int return_value_strncmp$14;
  return_value_strncmp$14=strncmp(line, "mcp ", (unsigned long int)4);
  _Bool tmp_if_expr$15;
  if(return_value_strncmp$14 == 0)
    tmp_if_expr$15 = IEEE_FLOAT_EQUAL(session->priv->version, (double)-1) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$15 = (_Bool)0;
  signed int return_value_strncmp$13;
  signed int return_value_strncmp$12;
  if(tmp_if_expr$15)
    gm_mcp_session_handle_open(session, line + (signed long int)3);

  else
    if(IEEE_FLOAT_EQUAL(session->priv->version, -1.000000))
    {
      struct _GmOptions *return_value_gm_world_options$1;
      return_value_gm_world_options$1=gm_world_options(session->priv->world);
      const char *return_value_gm_options_get$2;
      return_value_gm_options_get$2=gm_options_get(return_value_gm_world_options$1, "name");
      gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: No session found for %s, ignoring out of bound command!", return_value_gm_options_get$2);
    }

    else
    {
      return_value_strncmp$13=strncmp(line, "* ", (unsigned long int)2);
      if(return_value_strncmp$13 == 0)
        gm_mcp_session_handle_multiline(session, line + (signed long int)2);

      else
      {
        return_value_strncmp$12=strncmp(line, ": ", (unsigned long int)2);
        if(return_value_strncmp$12 == 0)
          gm_mcp_session_handle_multiline_end(session, line + (signed long int)2);

        else
        {
          signed int return_value_gm_mcp_parse_line$11;
          return_value_gm_mcp_parse_line$11=gm_mcp_parse_line(line, &info);
          if(!(return_value_gm_mcp_parse_line$11 == 0))
          {
            signed int return_value_strcmp$10;
            return_value_strcmp$10=strcmp(info.authkey, session->priv->authkey);
            if(return_value_strcmp$10 == 0)
            {
              package=gm_mcp_session_find_package(session, info.name);
              if(!(package == ((struct _GmMcpPackage *)NULL)))
              {
                value=gm_mcp_find_multiline_tag(info.fields);
                if(!(value == ((const char *)NULL)))
                {
                  const char *return_value_gm_mcp_find_value$5;
                  return_value_gm_mcp_find_value$5=gm_mcp_find_value(info.fields, "_data-tag");
                  if(!(return_value_gm_mcp_find_value$5 == ((const char *)NULL)))
                  {
                    void *return_value_g_malloc_n$3;
                    return_value_g_malloc_n$3=g_malloc_n((unsigned long int)1, sizeof(struct _McpMultilineInfo) /*32ul*/ );
                    minfo = (struct _McpMultilineInfo *)return_value_g_malloc_n$3;
                    minfo->key=g_strdup(value);
                    const char *return_value_gm_mcp_find_value$4;
                    return_value_gm_mcp_find_value$4=gm_mcp_find_value(info.fields, "_data-tag");
                    minfo->data_tag=g_strdup(return_value_gm_mcp_find_value$4);
                    minfo->data = (struct _GList *)(void *)0;
                    minfo->package = package;
                    session->priv->multiline=g_list_append(session->priv->multiline, (void *)minfo);
                    gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: multiline opening detected and stored (data_tag = %s, key = %s)", minfo->data_tag, minfo->key);
                  }

                  else
                    gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: multiline opening detected, but no _data-tag specified, ignore message");
                }

                signed int return_value_gm_mcp_package_can_handle_simple$9;
                return_value_gm_mcp_package_can_handle_simple$9=gm_mcp_package_can_handle_simple(package);
                if(!(return_value_gm_mcp_package_can_handle_simple$9 == 0))
                {
                  full=gm_mcp_package_get_name(package);
                  unsigned long int return_value_strlen$7;
                  return_value_strlen$7=strlen(full);
                  unsigned long int return_value_strlen$8;
                  return_value_strlen$8=strlen(info.name);
                  if(!(return_value_strlen$7 >= return_value_strlen$8))
                  {
                    unsigned long int return_value_strlen$6;
                    return_value_strlen$6=strlen(full);
                    suffix = info.name + (signed long int)(return_value_strlen$6 + (unsigned long int)1);
                  }

                  else
                    suffix = (char *)(void *)0;
                  gm_mcp_package_handle_simple(package, suffix, info.fields);
                }

                else
                  gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: can't handle simple message!");
              }

              else
                gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: unsupported package %s, ignore message", info.name);
            }

            else
              gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: invalid authentication key %s instead of %s, ignore message", info.authkey, session->priv->authkey);
          }

          else
            gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOob: invalid message (could not parse), ignore message");
          if(!(info.authkey == ((char *)NULL)))
            g_free((void *)info.authkey);

          if(!(info.name == ((char *)NULL)))
            g_free((void *)info.name);

          if(!(info.fields == ((struct _GList *)NULL)))
            gm_mcp_destroy_fields(info.fields);

        }
      }
    }
}

// gm_mcp_session_handle_open
// file mcp/gm-mcp-session.c line 76
void gm_mcp_session_handle_open(struct _GmMcpSession *session, char *line)
{
  struct _GList *fields;
  fields=gm_mcp_process_key_values(line);
  struct _GmMcpPackage *p;
  struct _GmMcpPackageClass *pklass;
  const char *min_version;
  min_version=gm_mcp_find_value(fields, "version");
  const char *max_version;
  max_version=gm_mcp_find_value(fields, "to");
  double min_v;
  double max_v;
  double version;
  if(max_version == ((const char *)NULL) || min_version == ((const char *)NULL))
    gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOpen: invalid opening, min version or max_version not found!");

  else
  {
    min_v=g_ascii_strtod(min_version, (char **)(void *)0);
    max_v=g_ascii_strtod(max_version, (char **)(void *)0);
    gm_debug_msg(DEBUG_MCP, "MinMaxVersion: %fd %fd", min_v, max_v);
    version=gm_mcp_get_version(2.1, 2.1, min_v, max_v);
    if(version > 0.0)
    {
      session->priv->authkey=gm_mcp_generate_auth_key();
      session->priv->version = version;
      gm_mcp_session_send_simple(session, "mcp", "authentication-key", session->priv->authkey, (const void *)"version", (const void *)"2.1", (const void *)"to", (const void *)"2.1", (void *)0);
      pklass=gm_mcp_session_find_package_class("mcp-negotiate");
      p=gm_mcp_session_create_package(session, pklass, pklass->max_version);
    }

    else
      gm_debug_msg(DEBUG_MCP, "GmMcpSession.HandleOpen: mcp server version does not match client version!");
  }
}

// gm_mcp_session_has_package_of_class
// file mcp/gm-mcp-session.c line 360
struct _GmMcpPackage * gm_mcp_session_has_package_of_class(struct _GmMcpSession *session, struct _GmMcpPackageClass *klass)
{
  struct _GList *item;
  struct _GmMcpPackage *package;
  unsigned long int klass_type = ((struct _GTypeClass *)klass)->g_type;
  item = session->priv->packages;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    package = (struct _GmMcpPackage *)item->data;
    if(((struct _GTypeInstance *)package)->g_class->g_type == klass_type)
      return package;

  }
  return (struct _GmMcpPackage *)(void *)0;
}

// gm_mcp_session_init
// file mcp/gm-mcp-session.c line 67
static void gm_mcp_session_init(struct _GmMcpSession *obj)
{
  unsigned long int return_value_gm_mcp_session_get_type$1;
  return_value_gm_mcp_session_get_type$1=gm_mcp_session_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_session_get_type$1);
  obj->priv = (struct _GmMcpSessionPrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->packages = (struct _GList *)(void *)0;
  obj->priv->version = (double)-1;
  obj->priv->authkey = (char *)(void *)0;
  obj->priv->multiline = (struct _GList *)(void *)0;
}

// gm_mcp_session_initialized
// file mcp/gm-mcp-session.c line 266
signed int gm_mcp_session_initialized(struct _GmMcpSession *session)
{
  return (signed int)(session->priv->authkey != (char *)(void *)0);
}

// gm_mcp_session_invoke_multiline_handle
// file mcp/gm-mcp-session.c line 122
void gm_mcp_session_invoke_multiline_handle(struct _GmMcpSession *session, char *data_tag, char *key, char *value)
{
  struct _GList *elem;
  struct _GmMcpPackage *p;
  struct _McpMultilineInfo *minfo;
  signed int handle_all = 0;
  elem = session->priv->multiline;
  for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
  {
    minfo = (struct _McpMultilineInfo *)elem->data;
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(minfo->data_tag, data_tag);
    if(return_value_strcmp$4 == 0)
    {
      p = minfo->package;
      signed int return_value_gm_mcp_package_can_handle_multi$3;
      return_value_gm_mcp_package_can_handle_multi$3=gm_mcp_package_can_handle_multi(p);
      if(!(return_value_gm_mcp_package_can_handle_multi$3 == 0))
      {
        if(!(key == ((char *)NULL)))
        {
          signed int return_value_gm_mcp_package_handle_multi$2;
          return_value_gm_mcp_package_handle_multi$2=gm_mcp_package_handle_multi(p, data_tag, key, value, (struct _GList *)(void *)0);
          if(return_value_gm_mcp_package_handle_multi$2 == 0)
          {
            char *return_value_g_strdup$1;
            return_value_g_strdup$1=g_strdup(value);
            minfo->data=g_list_append(minfo->data, (void *)return_value_g_strdup$1);
          }

        }

        else
          handle_all=gm_mcp_package_handle_multi(p, data_tag, (char *)(void *)0, (char *)(void *)0, minfo->data);
      }

      if(key == ((char *)NULL))
      {
        g_free((void *)minfo->data_tag);
        g_free((void *)minfo->key);
        if(handle_all == 0)
          gm_g_list_free_simple(minfo->data);

        else
          g_list_free(minfo->data);
        session->priv->multiline=g_list_remove(session->priv->multiline, (const void *)minfo);
        g_free((void *)minfo);
      }

      goto __CPROVER_DUMP_L10;
    }

  }

__CPROVER_DUMP_L10:
  ;
}

// gm_mcp_session_new
// file mcp/gm-mcp-session.c line 218
struct _GmMcpSession * gm_mcp_session_new(struct _GObject *world)
{
  struct _GmMcpSession *obj;
  unsigned long int return_value_gm_mcp_session_get_type$1;
  return_value_gm_mcp_session_get_type$1=gm_mcp_session_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_session_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_session_get_type$3;
  return_value_gm_mcp_session_get_type$3=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_session_get_type$3);
  obj = (struct _GmMcpSession *)return_value_g_type_check_instance_cast$4;
  unsigned long int return_value_gm_world_get_type$5;
  return_value_gm_world_get_type$5=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)world, return_value_gm_world_get_type$5);
  obj->priv->world = (struct _GmWorld *)return_value_g_type_check_instance_cast$6;
  return obj;
}

// gm_mcp_session_package_class_for_each
// file mcp/gm-mcp-session.c line 276
struct _GmMcpPackageClass * gm_mcp_session_package_class_for_each(signed int (*func)(struct _GmMcpPackageClass *, void *), void *user_data)
{
  struct _GmMcpSessionClass *klass;
  unsigned long int return_value_gm_mcp_session_get_type$1;
  return_value_gm_mcp_session_get_type$1=gm_mcp_session_get_type();
  void *return_value_g_type_class_peek$2;
  return_value_g_type_class_peek$2=g_type_class_peek(return_value_gm_mcp_session_get_type$1);
  klass = (struct _GmMcpSessionClass *)return_value_g_type_class_peek$2;
  struct _GList *item;
  struct _GmMcpPackageClass *package_klass;
  item = klass->available_packages;
  if(!(item == ((struct _GList *)NULL)))
  {
    unsigned long int return_value_gm_mcp_package_get_type$3;
    return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$4;
    return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)item->data, return_value_gm_mcp_package_get_type$3);
    package_klass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$4;
    signed int return_value;
    return_value=func(package_klass, user_data);
    if(!(return_value == 0))
      return package_klass;

    item = item->next;
  }

  return (struct _GmMcpPackageClass *)(void *)0;
}

// gm_mcp_session_reset
// file mcp/gm-mcp-session.c line 226
void gm_mcp_session_reset(struct _GmMcpSession *session)
{
  struct _GList *item;
  struct _GList *l;
  struct _McpMultilineInfo *minfo;
  struct _GmMcpPackage *package;
  g_free((void *)session->priv->authkey);
  session->priv->authkey = (char *)(void *)0;
  session->priv->version = (double)-1;
  l=g_list_copy(session->priv->packages);
  item = l;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gm_mcp_package_get_type$1);
    package = (struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2;
    g_object_unref((void *)package);
    session->priv->packages=g_list_remove(session->priv->packages, (const void *)package);
  }
  g_list_free(l);
  g_list_free(session->priv->packages);
  session->priv->packages = (struct _GList *)(void *)0;
  item = session->priv->multiline;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    minfo = (struct _McpMultilineInfo *)item->data;
    g_free((void *)minfo->data_tag);
    g_free((void *)minfo->key);
    gm_g_list_free_simple(minfo->data);
    g_free((void *)minfo);
  }
  g_list_free(session->priv->multiline);
  session->priv->multiline = (struct _GList *)(void *)0;
}

// gm_mcp_session_send_multiline
// file mcp/gm-mcp-session.c line 294
void gm_mcp_session_send_multiline(struct _GmMcpSession *session, const char *data_tag, const char *key, const struct _GList *lines)
{
  char *msg;
  msg=g_strconcat("#$#* ", data_tag, (const void *)" ", key, (const void *)": ", (void *)0);
  char *msg_line = (char *)(void *)0;
  for( ; !(lines == ((const struct _GList *)NULL)); lines = lines->next)
  {
    msg_line=g_strconcat(msg, (char *)lines->data, (void *)0);
    gm_world_sendln_log(session->priv->world, msg_line, (enum _GmLogType)LOG_MCP_OUT);
    g_free((void *)msg_line);
  }
  g_free((void *)msg);
  msg_line=g_strconcat("#$#: ", data_tag, (void *)0);
  gm_world_sendln_log(session->priv->world, msg_line, (enum _GmLogType)LOG_MCP_OUT);
  g_free((void *)msg_line);
}

// gm_mcp_session_send_simple
// file mcp/gm-mcp-session.c line 315
void gm_mcp_session_send_simple(struct _GmMcpSession *session, const char *pname, const char *first_key, ...)
{
  struct _GString *msg = (struct _GString *)(void *)0;
  __builtin_va_list args;
  const char *key;
  const char *value;
  char *esvalue;
  msg=g_string_new("#$#");
  msg=g_string_append(msg, pname);
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(pname, "mcp");
  if(!(return_value_strcasecmp$1 == 0))
  {
    msg=g_string_append(msg, " ");
    msg=g_string_append(msg, session->priv->authkey);
  }

  msg=g_string_append(msg, " ");
  if(!(first_key == ((const char *)NULL)))
  {
    va_start(args, first_key);
    key = first_key;
    while(!(key == ((const char *)NULL)))
    {
      value=va_arg(args, __typeof__(value));
      if(!(value == ((const char *)NULL)))
      {
        msg=g_string_append(msg, key);
        msg=g_string_append(msg, ": ");
        esvalue=gm_mcp_escape_if_needed(value);
        msg=g_string_append(msg, esvalue);
        g_free((void *)esvalue);
        msg=g_string_append(msg, " ");
        key=va_arg(args, __typeof__(key));
      }

      else
        key = (const char *)(void *)0;
    }
    va_end(args);
  }

  gm_world_sendln_log(session->priv->world, msg->str, (enum _GmLogType)LOG_MCP_OUT);
  g_string_free(msg, (signed int)!(0 != 0));
}

// gm_mcp_session_world
// file mcp/gm-mcp-session.c line 545
struct _GObject * gm_mcp_session_world(struct _GmMcpSession *session)
{
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)session->priv->world, (unsigned long int)(20 << 2));
  return (struct _GObject *)return_value_g_type_check_instance_cast$1;
}

// gm_mcp_un_escape
// file mcp/gm-mcp.c line 75
char * gm_mcp_un_escape(char *line)
{
  char *ptri = line;
  char *ptrj = line;
  signed int shifted = 0;
  for( ; !((signed int)*ptri == 0); ptri = ptri + 1l)
  {
    if((signed int)*ptri == 92)
    {
      shifted = (signed int)!(0 != 0);
      ptri = ptri + 1l;
    }

    if(!(shifted == 0))
      *ptrj = *ptri;

    ptrj = ptrj + 1l;
  }
  *ptrj = (char)0;
  return line;
}

// gm_mcp_userlist_view_create_label
// file mcp/gm-mcp-userlist-view.c line 262
struct _GtkWidget * gm_mcp_userlist_view_create_label(struct _GmMcpUserlistView *view)
{
  view->label=gtk_label_new((const char *)(void *)0);
  gm_mcp_userlist_view_update_label(view);
  return view->label;
}

// gm_mcp_userlist_view_create_userlist
// file mcp/gm-mcp-userlist-view.c line 279
struct _GtkWidget * gm_mcp_userlist_view_create_userlist(struct _GmMcpUserlistView *view)
{
  struct _GtkWidget *scrolled_window;
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  struct _GtkTreeModel *model;
  model=gm_mcp_userlist_view_model_create(view);
  struct _GtkWidget *tree_view;
  tree_view=gtk_tree_view_new_with_model(model);
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  unsigned long int return_value_gtk_scrolled_window_get_type$1;
  return_value_gtk_scrolled_window_get_type$1=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$1);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$2, (enum anonymous$88)GTK_POLICY_AUTOMATIC, (enum anonymous$88)GTK_POLICY_AUTOMATIC);
  unsigned long int return_value_gtk_scrolled_window_get_type$3;
  return_value_gtk_scrolled_window_get_type$3=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$3);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$4, (enum anonymous$89)GTK_SHADOW_IN);
  struct _GtkAdjustment *adj;
  unsigned long int return_value_gtk_scrolled_window_get_type$5;
  return_value_gtk_scrolled_window_get_type$5=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$5);
  adj=gtk_scrolled_window_get_vadjustment((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$6);
  g_signal_connect_data((void *)adj, "changed", (void (*)(void))on_adj_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  gtk_widget_set_size_request(scrolled_window, 150, -1);
  gtk_widget_set_size_request(tree_view, 150, -1);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_container_get_type$7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, tree_view);
  renderer=gtk_cell_renderer_pixbuf_new();
  char *return_value_gettext$9;
  return_value_gettext$9=gettext("I");
  column=gtk_tree_view_column_new_with_attributes(return_value_gettext$9, renderer, (const void *)"pixbuf", 0, (void *)0);
  unsigned long int return_value_gtk_tree_view_get_type$10;
  return_value_gtk_tree_view_get_type$10=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_tree_view_get_type$10);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$11, column);
  gtk_tree_view_column_set_min_width(column, 30);
  renderer=gm_cell_renderer_text_new();
  char *return_value_gettext$12;
  return_value_gettext$12=gettext("Name");
  column=gtk_tree_view_column_new_with_attributes(return_value_gettext$12, renderer, (const void *)"name", 1, (const void *)"status", 2, (void *)0);
  unsigned long int return_value_gtk_tree_view_get_type$13;
  return_value_gtk_tree_view_get_type$13=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_tree_view_get_type$13);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$14, column);
  unsigned long int return_value_gtk_tree_sortable_get_type$15;
  return_value_gtk_tree_sortable_get_type$15=gtk_tree_sortable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_tree_sortable_get_type$15);
  gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$16, -1, (enum anonymous$151)GTK_SORT_ASCENDING);
  unsigned long int return_value_gtk_tree_sortable_get_type$17;
  return_value_gtk_tree_sortable_get_type$17=gtk_tree_sortable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_tree_sortable_get_type$17);
  gtk_tree_sortable_set_default_sort_func((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$18, (signed int (*)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *))gm_mcp_userlist_view_sort_func, (void *)view, (void (*)(void *))(void *)0);
  do
  {
    unsigned long int return_value_gtk_widget_get_type$19;
    return_value_gtk_widget_get_type$19=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$19);
    unsigned long int return_value_gtk_object_get_type$21;
    return_value_gtk_object_get_type$21=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
    return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkWidget *)return_value_g_type_check_instance_cast$20, return_value_gtk_object_get_type$21);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast$22)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast$22)->flags & (unsigned int)~2048;
  }
  while((_Bool)0);
  unsigned long int return_value_gtk_widget_get_type$23;
  return_value_gtk_widget_get_type$23=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$23);
  unsigned long int return_value_gtk_widget_get_type$25;
  return_value_gtk_widget_get_type$25=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$25);
  gtk_widget_modify_base((struct _GtkWidget *)return_value_g_type_check_instance_cast$24, (enum anonymous$23)GTK_STATE_ACTIVE, &((struct _GtkWidget *)return_value_g_type_check_instance_cast$26)->style->base[(signed long int)GTK_STATE_SELECTED]);
  unsigned long int return_value_gtk_widget_get_type$27;
  return_value_gtk_widget_get_type$27=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$27);
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$29);
  gtk_widget_modify_text((struct _GtkWidget *)return_value_g_type_check_instance_cast$28, (enum anonymous$23)GTK_STATE_ACTIVE, &((struct _GtkWidget *)return_value_g_type_check_instance_cast$30)->style->text[(signed long int)GTK_STATE_SELECTED]);
  unsigned long int return_value_gtk_tree_view_get_type$31;
  return_value_gtk_tree_view_get_type$31=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_tree_view_get_type$31);
  gtk_tree_view_columns_autosize((struct _GtkTreeView *)return_value_g_type_check_instance_cast$32);
  unsigned long int return_value_gtk_tree_view_get_type$33;
  return_value_gtk_tree_view_get_type$33=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_tree_view_get_type$33);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast$34, 0);
  unsigned long int return_value_gtk_tree_view_get_type$35;
  return_value_gtk_tree_view_get_type$35=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_tree_view_get_type$35);
  view->tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$36;
  unsigned long int return_value_gtk_scrolled_window_get_type$37;
  return_value_gtk_scrolled_window_get_type$37=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$37);
  view->scrolled_window = (struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$38;
  return scrolled_window;
}

// gm_mcp_userlist_view_do_popup
// file mcp/gm-mcp-userlist-view.c line 775
static signed int gm_mcp_userlist_view_do_popup(struct _GmMcpUserlistView *view, struct _GdkEventButton *event)
{
  struct _GList *menu;
  struct _GList *item;
  struct _GmKeyValuePair *pair;
  struct _GtkWidget *menuitem;
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(view->tree_view);
  signed int id;
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  struct _GtkTreePath *path;
  if(event == ((struct _GdkEventButton *)NULL))
  {
    signed int return_value_gtk_tree_selection_get_selected$1;
    return_value_gtk_tree_selection_get_selected$1=gtk_tree_selection_get_selected(selection, &model, &iter);
    if(return_value_gtk_tree_selection_get_selected$1 == 0)
      return 0;

    gtk_tree_model_get(model, &iter, 3, &id, -1);
  }

  else
  {
    signed int return_value_gtk_tree_view_get_path_at_pos$2;
    return_value_gtk_tree_view_get_path_at_pos$2=gtk_tree_view_get_path_at_pos(view->tree_view, (signed int)event->x, (signed int)event->y, &path, (struct _GtkTreeViewColumn **)(void *)0, (signed int *)(void *)0, (signed int *)(void *)0);
    if(return_value_gtk_tree_view_get_path_at_pos$2 == 0)
      return 0;

    else
    {
      gtk_tree_model_get_iter(view->model, &iter, path);
      gtk_tree_path_free(path);
      gtk_tree_model_get(view->model, &iter, 3, &id, -1);
    }
  }
  unsigned long int return_value_gm_iuserlist_get_type$3;
  return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_iuserlist_get_type$3);
  menu=gm_iuserlist_get_menu((struct _GmIUserlist *)return_value_g_type_check_instance_cast$4, id);
  if(!(view->popup_menu == ((struct _GtkWidget *)NULL)))
    gtk_widget_destroy(view->popup_menu);

  if(menu == ((struct _GList *)NULL))
    return 0;

  else
  {
    view->popup_menu=gtk_menu_new();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view->popup_menu, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$5, "McpUserlistView", (void *)view);
    unsigned long int return_value_gtk_menu_get_type$6;
    return_value_gtk_menu_get_type$6=gtk_menu_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)view->popup_menu, return_value_gtk_menu_get_type$6);
    unsigned long int return_value_gtk_widget_get_type$8;
    return_value_gtk_widget_get_type$8=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)view->tree_view, return_value_gtk_widget_get_type$8);
    gtk_menu_attach_to_widget((struct _GtkMenu *)return_value_g_type_check_instance_cast$7, (struct _GtkWidget *)return_value_g_type_check_instance_cast$9, popup_menu_detach);
    item = menu;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      pair = (struct _GmKeyValuePair *)item->data;
      if(pair->key == ((char *)NULL))
      {
        menuitem=gtk_separator_menu_item_new();
        g_free((void *)pair->value);
      }

      else
      {
        menuitem=gtk_menu_item_new_with_mnemonic(pair->key);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, (unsigned long int)(20 << 2));
        g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$10, "UserlistAction", (void *)pair->value, g_free);
        g_signal_connect_data((void *)menuitem, "activate", (void (*)(void))on_gm_mcp_userlist_view_menuitem_activate, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
      }
      gtk_widget_show(menuitem);
      unsigned long int return_value_gtk_menu_shell_get_type$11;
      return_value_gtk_menu_shell_get_type$11=gtk_menu_shell_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)view->popup_menu, return_value_gtk_menu_shell_get_type$11);
      gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast$12, menuitem);
      g_free((void *)pair->key);
      g_free((void *)pair);
    }
    g_list_free(menu);
    if(event == ((struct _GdkEventButton *)NULL))
    {
      unsigned long int return_value_gtk_menu_get_type$13;
      return_value_gtk_menu_get_type$13=gtk_menu_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)view->popup_menu, return_value_gtk_menu_get_type$13);
      unsigned int return_value_gtk_get_current_event_time$15;
      return_value_gtk_get_current_event_time$15=gtk_get_current_event_time();
      gtk_menu_popup((struct _GtkMenu *)return_value_g_type_check_instance_cast$14, (struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0, (void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *))(void *)0, (void *)0, (unsigned int)0, return_value_gtk_get_current_event_time$15);
    }

    else
    {
      unsigned long int return_value_gtk_menu_get_type$16;
      return_value_gtk_menu_get_type$16=gtk_menu_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
      return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)view->popup_menu, return_value_gtk_menu_get_type$16);
      gtk_menu_popup((struct _GtkMenu *)return_value_g_type_check_instance_cast$17, (struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0, (void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *))(void *)0, (void *)0, event->button, event->time);
    }
    return (signed int)!(0 != 0);
  }
}

// gm_mcp_userlist_view_find
// file mcp/gm-mcp-userlist-view.c line 585
static signed int gm_mcp_userlist_view_find(struct _GmMcpUserlistView *view, signed int id, struct _GtkTreeIter *iter)
{
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_tree_model_get_type$1;
  return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->store, return_value_gtk_tree_model_get_type$1);
  model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2;
  signed int iterid;
  signed int return_value_gtk_tree_model_get_iter_first$4;
  return_value_gtk_tree_model_get_iter_first$4=gtk_tree_model_get_iter_first(model, iter);
  signed int return_value_gtk_tree_model_iter_next$3;
  if(!(return_value_gtk_tree_model_get_iter_first$4 == 0))
    do
    {
      gtk_tree_model_get(model, iter, 3, &iterid, -1);
      if(iterid == id)
        return (signed int)!(0 != 0);

      return_value_gtk_tree_model_iter_next$3=gtk_tree_model_iter_next(model, iter);
    }
    while(!(return_value_gtk_tree_model_iter_next$3 == 0));

  return 0;
}

// gm_mcp_userlist_view_get_name
// file mcp/gm-mcp-userlist-view.c line 412
static char * gm_mcp_userlist_view_get_name(struct _GmMcpUserlistView *view, signed int id)
{
  const char *name;
  unsigned long int return_value_gm_iuserlist_get_type$1;
  return_value_gm_iuserlist_get_type$1=gm_iuserlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_iuserlist_get_type$1);
  name=gm_iuserlist_get_name((struct _GmIUserlist *)return_value_g_type_check_instance_cast$2, id);
  if(!(view->show_object == 0))
  {
    char *return_value_g_strdup_printf$3;
    return_value_g_strdup_printf$3=g_strdup_printf("%s (#%d)", name, id);
    return return_value_g_strdup_printf$3;
  }

  else
  {
    char *return_value_g_strdup$4;
    return_value_g_strdup$4=g_strdup(name);
    return return_value_g_strdup$4;
  }
}

// gm_mcp_userlist_view_get_status
// file mcp/gm-mcp-userlist-view.c line 402
static char * gm_mcp_userlist_view_get_status(struct _GmMcpUserlistView *view, signed int id)
{
  _Bool tmp_if_expr$4;
  unsigned long int return_value_gm_iuserlist_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  signed int return_value_gm_iuserlist_supports_status$3;
  if(view->show_status == 0)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_gm_iuserlist_get_type$1=gm_iuserlist_get_type();
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_iuserlist_get_type$1);
    return_value_gm_iuserlist_supports_status$3=gm_iuserlist_supports_status((struct _GmIUserlist *)return_value_g_type_check_instance_cast$2);
    tmp_if_expr$4 = !(return_value_gm_iuserlist_supports_status$3 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_gm_iuserlist_get_type$5;
    return_value_gm_iuserlist_get_type$5=gm_iuserlist_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_iuserlist_get_type$5);
    char *return_value_gm_iuserlist_get_status$7;
    return_value_gm_iuserlist_get_status$7=gm_iuserlist_get_status((struct _GmIUserlist *)return_value_g_type_check_instance_cast$6, id);
    return return_value_gm_iuserlist_get_status$7;
  }
}

// gm_mcp_userlist_view_idle_scroll
// file mcp/gm-mcp-userlist-view.c line 86
static signed int gm_mcp_userlist_view_idle_scroll(struct _GmMcpUserlistView *view)
{
  struct _GtkAdjustment *adj;
  view->idle_scroll = (unsigned long int)0;
  adj=gtk_scrolled_window_get_vadjustment(view->scrolled_window);
  gtk_adjustment_set_value(adj, view->scroll_position);
  return 0;
}

// gm_mcp_userlist_view_model_create
// file mcp/gm-mcp-userlist-view.c line 128
struct _GtkTreeModel * gm_mcp_userlist_view_model_create(struct _GmMcpUserlistView *view)
{
  struct _GtkListStore *store;
  unsigned long int return_value_gdk_pixbuf_get_type$1;
  return_value_gdk_pixbuf_get_type$1=gdk_pixbuf_get_type();
  store=gtk_list_store_new(6, return_value_gdk_pixbuf_get_type$1, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(6 << 2), (unsigned long int)(6 << 2), (unsigned long int)(6 << 2));
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_tree_model_get_type$2;
  return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$2);
  model=gtk_tree_model_sort_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3);
  view->store = store;
  view->model = model;
  g_signal_connect_data((void *)model, "row-inserted", (void (*)(void))on_row_inserted, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)model, "row-deleted", (void (*)(void))on_row_deleted, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)model, "rows-reordered", (void (*)(void))on_rows_reordered, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  return model;
}

// gm_mcp_userlist_view_new
// file mcp/gm-mcp-userlist-view.c line 332
void gm_mcp_userlist_view_new(struct _GmMcpPackage *package, struct _GObject *parent)
{
  struct _GmMcpUserlistView *view;
  struct _GtkPaned *paned;
  struct _GtkWidget *vbox;
  struct _GtkWidget *child;
  struct _GmOptions *options;
  signed int tmp_statement_expression$1;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)parent;
  unsigned long int __t;
  __t=gm_world_view_get_type();
  signed int __r;
  _Bool tmp_if_expr$2;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$1 = __r;
  if(!(tmp_statement_expression$1 == 0))
  {
    void *return_value_g_malloc0_n$3;
    return_value_g_malloc0_n$3=g_malloc0_n((unsigned long int)1, sizeof(struct _GmMcpUserlistView) /*128ul*/ );
    view = (struct _GmMcpUserlistView *)return_value_g_malloc0_n$3;
    unsigned long int return_value_gm_world_view_get_type$4;
    return_value_gm_world_view_get_type$4=gm_world_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gm_world_view_get_type$4);
    view->view = (struct _GmWorldView *)return_value_g_type_check_instance_cast$5;
    view->package = package;
    struct _GtkHPaned *return_value_gm_world_view_hpaned$6;
    return_value_gm_world_view_hpaned$6=gm_world_view_hpaned(view->view);
    unsigned long int return_value_gtk_paned_get_type$7;
    return_value_gtk_paned_get_type$7=gtk_paned_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_view_hpaned$6, return_value_gtk_paned_get_type$7);
    paned = (struct _GtkPaned *)return_value_g_type_check_instance_cast$8;
    vbox=gtk_paned_get_child2(paned);
    if(vbox == ((struct _GtkWidget *)NULL))
    {
      vbox=gtk_vbox_new(0, 3);
      view->vbox = vbox;
      gtk_paned_pack2(paned, view->vbox, 0, 0);
    }

    else
      vbox = view->vbox;
    child=gm_mcp_userlist_view_create_userlist(view);
    unsigned long int return_value_gtk_box_get_type$9;
    return_value_gtk_box_get_type$9=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$9);
    gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$10, child, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
    unsigned long int return_value_gtk_box_get_type$11;
    return_value_gtk_box_get_type$11=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$11);
    struct _GtkWidget *return_value_gm_mcp_userlist_view_create_label$13;
    return_value_gm_mcp_userlist_view_create_label$13=gm_mcp_userlist_view_create_label(view);
    gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$12, return_value_gm_mcp_userlist_view_create_label$13, 0, 0, (unsigned int)0);
    gtk_widget_show_all(vbox);
    g_signal_connect_data((void *)view->tree_view, "popup-menu", (void (*)(void))on_gm_mcp_userlist_view_popup_menu, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)view->tree_view, "button-press-event", (void (*)(void))on_gm_mcp_userlist_view_button_press, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)package, "player_added", (void (*)(void))on_gm_mcp_userlist_view_player_added, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)package, "player_removed", (void (*)(void))on_gm_mcp_userlist_view_player_removed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)package, "name_changed", (void (*)(void))on_gm_mcp_userlist_view_name_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)package, "state_changed", (void (*)(void))on_gm_mcp_userlist_view_state_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)package, "rank_changed", (void (*)(void))on_gm_mcp_userlist_view_rank_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    struct _GmApp *return_value_gm_app_instance$14;
    return_value_gm_app_instance$14=gm_app_instance();
    options=gm_app_options(return_value_gm_app_instance$14);
    view->show_object=gm_options_get_int(options, "userlist_show_object_number");
    signed int return_value_gm_options_get_int$15;
    return_value_gm_options_get_int$15=gm_options_get_int(options, "userlist_sort_type");
    view->sort_type = (enum _GmUserlistSortType)return_value_gm_options_get_int$15;
    view->show_status=gm_options_get_int(options, "userlist_show_status");
    view->use_state_icon=gm_options_get_int(options, "userlist_use_state_icon");
    signed int return_value_gm_options_get_int$16;
    return_value_gm_options_get_int$16=gm_options_get_int(options, "show_userlist");
    if(return_value_gm_options_get_int$16 == 0)
      gtk_widget_hide(vbox);

    g_signal_connect_data((void *)options, "option-changed", (void (*)(void))on_gm_mcp_userlist_view_option_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)package, (unsigned long int)(20 << 2));
    g_object_weak_ref((struct _GObject *)return_value_g_type_check_instance_cast$17, on_gm_mcp_userlist_view_weak_notify, (void *)view);
  }

}

// gm_mcp_userlist_view_player_active
// file mcp/gm-mcp-userlist-view.c line 518
static signed int gm_mcp_userlist_view_player_active(struct _GmMcpUserlistView *view, struct _GtkTreeIter *iter)
{
  signed int state;
  unsigned long int return_value_gtk_tree_model_get_type$1;
  return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->store, return_value_gtk_tree_model_get_type$1);
  gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, iter, 5, &state, -1);
  return (signed int)(state == 0);
}

// gm_mcp_userlist_view_prepare_scroll
// file mcp/gm-mcp-userlist-view.c line 97
static void gm_mcp_userlist_view_prepare_scroll(struct _GmMcpUserlistView *view)
{
  struct _GtkAdjustment *adj;
  if(view->idle_scroll == 0ul)
  {
    adj=gtk_scrolled_window_get_vadjustment(view->scrolled_window);
    view->scroll_position=gtk_adjustment_get_value(adj);
    unsigned int return_value_g_idle_add$1;
    return_value_g_idle_add$1=g_idle_add((signed int (*)(void *))gm_mcp_userlist_view_idle_scroll, (void *)view);
    view->idle_scroll = (unsigned long int)return_value_g_idle_add$1;
  }

}

// gm_mcp_userlist_view_sort_func
// file mcp/gm-mcp-userlist-view.c line 225
signed int gm_mcp_userlist_view_sort_func(struct _GtkTreeModel *model, struct _GtkTreeIter *a, struct _GtkTreeIter *b, struct _GmMcpUserlistView *view)
{
  struct _SortInfo info1;
  struct _SortInfo info2;
  signed int result;
  gtk_tree_model_get(model, a, 4, &info1.rank_priority, 5, &info1.state_priority, 1, &info1.name, -1);
  gtk_tree_model_get(model, b, 4, &info2.rank_priority, 5, &info2.state_priority, 1, &info2.name, -1);
  result=compare_functions[(signed long int)view->sort_type](&info1, &info2);
  g_free((void *)info1.name);
  g_free((void *)info2.name);
  return result;
}

// gm_mcp_userlist_view_sort_name
// file mcp/gm-mcp-userlist-view.c line 219
static signed int gm_mcp_userlist_view_sort_name(struct _SortInfo *info1, struct _SortInfo *info2)
{
  signed int return_value_gm_userlist_view_strcmp_safe$1;
  return_value_gm_userlist_view_strcmp_safe$1=gm_userlist_view_strcmp_safe(info1->name, info2->name);
  return return_value_gm_userlist_view_strcmp_safe$1;
}

// gm_mcp_userlist_view_sort_rank_name
// file mcp/gm-mcp-userlist-view.c line 199
static signed int gm_mcp_userlist_view_sort_rank_name(struct _SortInfo *info1, struct _SortInfo *info2)
{
  if(info1->rank_priority == info2->rank_priority)
  {
    signed int return_value_gm_userlist_view_strcmp_safe$1;
    return_value_gm_userlist_view_strcmp_safe$1=gm_userlist_view_strcmp_safe(info1->name, info2->name);
    return return_value_gm_userlist_view_strcmp_safe$1;
  }

  else
    return info1->rank_priority - info2->rank_priority;
}

// gm_mcp_userlist_view_sort_state_name
// file mcp/gm-mcp-userlist-view.c line 209
static signed int gm_mcp_userlist_view_sort_state_name(struct _SortInfo *info1, struct _SortInfo *info2)
{
  if(info1->state_priority == info2->state_priority)
  {
    signed int return_value_gm_userlist_view_strcmp_safe$1;
    return_value_gm_userlist_view_strcmp_safe$1=gm_userlist_view_strcmp_safe(info1->name, info2->name);
    return return_value_gm_userlist_view_strcmp_safe$1;
  }

  else
    return info1->state_priority - info2->state_priority;
}

// gm_mcp_userlist_view_sort_state_rank_name
// file mcp/gm-mcp-userlist-view.c line 178
static signed int gm_mcp_userlist_view_sort_state_rank_name(struct _SortInfo *info1, struct _SortInfo *info2)
{
  if(info1->state_priority == info2->state_priority)
  {
    if(info1->state_priority == 0)
    {
      if(info1->rank_priority == info2->rank_priority)
      {
        signed int return_value_gm_userlist_view_strcmp_safe$1;
        return_value_gm_userlist_view_strcmp_safe$1=gm_userlist_view_strcmp_safe(info1->name, info2->name);
        return return_value_gm_userlist_view_strcmp_safe$1;
      }

      else
        return info1->rank_priority - info2->rank_priority;
    }

    else
    {
      signed int return_value_gm_userlist_view_strcmp_safe$2;
      return_value_gm_userlist_view_strcmp_safe$2=gm_userlist_view_strcmp_safe(info1->name, info2->name);
      return return_value_gm_userlist_view_strcmp_safe$2;
    }
  }

  else
    return info1->state_priority - info2->state_priority;
}

// gm_mcp_userlist_view_update_label
// file mcp/gm-mcp-userlist-view.c line 251
static void gm_mcp_userlist_view_update_label(struct _GmMcpUserlistView *view)
{
  char *label;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Players: %d, active: %d");
  label=g_strdup_printf(return_value_gettext$1, view->num_players, view->num_active);
  unsigned long int return_value_gtk_label_get_type$2;
  return_value_gtk_label_get_type$2=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)view->label, return_value_gtk_label_get_type$2);
  gtk_label_set_label((struct _GtkLabel *)return_value_g_type_check_instance_cast$3, label);
  g_free((void *)label);
}

// gm_mcp_userlist_view_update_names
// file mcp/gm-mcp-userlist-view.c line 444
static void gm_mcp_userlist_view_update_names(struct _GmMcpUserlistView *view)
{
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_tree_model_get_type$1;
  return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->store, return_value_gtk_tree_model_get_type$1);
  model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2;
  signed int iterid;
  struct _GtkTreeIter iter;
  char *name;
  char *status;
  signed int return_value_gtk_tree_model_get_iter_first$4;
  return_value_gtk_tree_model_get_iter_first$4=gtk_tree_model_get_iter_first(model, &iter);
  signed int return_value_gtk_tree_model_iter_next$3;
  if(!(return_value_gtk_tree_model_get_iter_first$4 == 0))
    do
    {
      gtk_tree_model_get(model, &iter, 3, &iterid, -1);
      name=gm_mcp_userlist_view_get_name(view, iterid);
      status=gm_mcp_userlist_view_get_status(view, iterid);
      gtk_list_store_set(view->store, &iter, 1, name, 2, status, -1);
      g_free((void *)name);
      g_free((void *)status);
      return_value_gtk_tree_model_iter_next$3=gtk_tree_model_iter_next(model, &iter);
    }
    while(!(return_value_gtk_tree_model_iter_next$3 == 0));

}

// gm_mcp_userlist_view_update_show_object_number
// file mcp/gm-mcp-userlist-view.c line 467
static void gm_mcp_userlist_view_update_show_object_number(struct _GmMcpUserlistView *view, signed int show_object)
{
  if(!(view->show_object == show_object))
  {
    view->show_object = show_object;
    gm_mcp_userlist_view_update_names(view);
  }

}

// gm_mcp_userlist_view_update_show_status
// file mcp/gm-mcp-userlist-view.c line 479
static void gm_mcp_userlist_view_update_show_status(struct _GmMcpUserlistView *view, signed int show_status)
{
  if(!(view->show_status == show_status))
  {
    view->show_status = show_status;
    gm_mcp_userlist_view_update_names(view);
  }

}

// gm_mcp_userlist_view_update_sort_type
// file mcp/gm-mcp-userlist-view.c line 425
static void gm_mcp_userlist_view_update_sort_type(struct _GmMcpUserlistView *view, enum _GmUserlistSortType sort_type)
{
  if(!(sort_type == view->sort_type))
  {
    if(!((signed int)sort_type >= GM_USERLIST_SORT_TYPE_NUM) && (signed int)sort_type >= 0)
    {
      view->sort_type = sort_type;
      unsigned long int return_value_gtk_tree_model_sort_get_type$1;
      return_value_gtk_tree_model_sort_get_type$1=gtk_tree_model_sort_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->model, return_value_gtk_tree_model_sort_get_type$1);
      gtk_tree_model_sort_reset_default_sort_func((struct _GtkTreeModelSort *)return_value_g_type_check_instance_cast$2);
      unsigned long int return_value_gtk_tree_sortable_get_type$3;
      return_value_gtk_tree_sortable_get_type$3=gtk_tree_sortable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->model, return_value_gtk_tree_sortable_get_type$3);
      gtk_tree_sortable_set_default_sort_func((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$4, (signed int (*)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *))gm_mcp_userlist_view_sort_func, (void *)view, (void (*)(void *))(void *)0);
    }

  }

}

// gm_mcp_userlist_view_update_use_state_icon
// file mcp/gm-mcp-userlist-view.c line 490
static void gm_mcp_userlist_view_update_use_state_icon(struct _GmMcpUserlistView *view, signed int use_state_icon)
{
  const char *icon;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_tree_model_get_type$1;
  return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->store, return_value_gtk_tree_model_get_type$1);
  model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2;
  struct _GtkTreeIter iter;
  signed int iterid;
  signed int return_value_gtk_tree_model_iter_next$3;
  if(!(view->use_state_icon == use_state_icon))
  {
    view->use_state_icon = use_state_icon;
    signed int return_value_gtk_tree_model_get_iter_first$7;
    return_value_gtk_tree_model_get_iter_first$7=gtk_tree_model_get_iter_first(model, &iter);
    if(!(return_value_gtk_tree_model_get_iter_first$7 == 0))
      do
      {
        gtk_tree_model_get(model, &iter, 3, &iterid, -1);
        unsigned long int return_value_gm_iuserlist_get_type$4;
        return_value_gm_iuserlist_get_type$4=gm_iuserlist_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
        return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_iuserlist_get_type$4);
        icon=gm_iuserlist_get_icon((struct _GmIUserlist *)return_value_g_type_check_instance_cast$5, iterid, use_state_icon);
        struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$6;
        return_value_gm_pixbuf_get_at_size$6=gm_pixbuf_get_at_size(icon, 22, 22);
        gtk_list_store_set(view->store, &iter, 0, return_value_gm_pixbuf_get_at_size$6, -1);
        return_value_gtk_tree_model_iter_next$3=gtk_tree_model_iter_next(model, &iter);
      }
      while(!(return_value_gtk_tree_model_iter_next$3 == 0));

  }

}

// gm_mcp_vmoo_client_class_init
// file mcp/gm-mcp-vmoo-client.c line 53
static void gm_mcp_vmoo_client_class_init(struct _GmMcpVmooClientClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_vmoo_client_finalize;
  pklass->name = "dns-com-vmoo-client";
  pklass->set_session = gm_mcp_vmoo_client_set_session;
  pklass->handle_simple = gm_mcp_vmoo_client_handle_simple;
  pklass->create_view = gm_mcp_vmoo_client_create_view;
}

// gm_mcp_vmoo_client_class_intern_init
// file mcp/gm-mcp-vmoo-client.c line 38
static void gm_mcp_vmoo_client_class_intern_init(void *klass)
{
  gm_mcp_vmoo_client_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpVmooClient_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpVmooClient_private_offset);

  gm_mcp_vmoo_client_class_init((struct _GmMcpVmooClientClass *)klass);
}

// gm_mcp_vmoo_client_create_view
// file mcp/gm-mcp-vmoo-client.c line 196
void gm_mcp_vmoo_client_create_view(struct _GmMcpPackage *package, struct _GObject *parent)
{
  struct _GmMcpVmooClientView *client_view;
  signed int tmp_statement_expression$1;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)parent;
  unsigned long int __t;
  __t=gm_world_view_get_type();
  signed int __r;
  _Bool tmp_if_expr$2;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$1 = __r;
  if(!(tmp_statement_expression$1 == 0))
  {
    void *return_value_g_malloc0_n$3;
    return_value_g_malloc0_n$3=g_malloc0_n((unsigned long int)1, sizeof(struct _GmMcpVmooClientView) /*40ul*/ );
    client_view = (struct _GmMcpVmooClientView *)return_value_g_malloc0_n$3;
    unsigned long int return_value_gm_mcp_vmoo_client_get_type$4;
    return_value_gm_mcp_vmoo_client_get_type$4=gm_mcp_vmoo_client_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_vmoo_client_get_type$4);
    client_view->package = (struct _GmMcpVmooClient *)return_value_g_type_check_instance_cast$5;
    unsigned long int return_value_gm_world_view_get_type$6;
    return_value_gm_world_view_get_type$6=gm_world_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gm_world_view_get_type$6);
    client_view->view=gm_world_view_text_view((struct _GmWorldView *)return_value_g_type_check_instance_cast$7);
    client_view->width = (unsigned int)0;
    client_view->height = (unsigned int)0;
    unsigned long int return_value_gtk_text_view_get_type$8;
    return_value_gtk_text_view_get_type$8=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)client_view->view, return_value_gtk_text_view_get_type$8);
    signed int return_value_gtk_text_view_get_left_margin$10;
    return_value_gtk_text_view_get_left_margin$10=gtk_text_view_get_left_margin((struct _GtkTextView *)return_value_g_type_check_instance_cast$9);
    unsigned long int return_value_gtk_text_view_get_type$11;
    return_value_gtk_text_view_get_type$11=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)client_view->view, return_value_gtk_text_view_get_type$11);
    signed int return_value_gtk_text_view_get_right_margin$13;
    return_value_gtk_text_view_get_right_margin$13=gtk_text_view_get_right_margin((struct _GtkTextView *)return_value_g_type_check_instance_cast$12);
    client_view->margin_width = (unsigned int)(return_value_gtk_text_view_get_left_margin$10 + return_value_gtk_text_view_get_right_margin$13);
    unsigned long int return_value_gtk_text_view_get_type$14;
    return_value_gtk_text_view_get_type$14=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)client_view->view, return_value_gtk_text_view_get_type$14);
    signed int return_value_gtk_text_view_get_pixels_above_lines$16;
    return_value_gtk_text_view_get_pixels_above_lines$16=gtk_text_view_get_pixels_above_lines((struct _GtkTextView *)return_value_g_type_check_instance_cast$15);
    unsigned long int return_value_gtk_text_view_get_type$17;
    return_value_gtk_text_view_get_type$17=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)client_view->view, return_value_gtk_text_view_get_type$17);
    signed int return_value_gtk_text_view_get_pixels_below_lines$19;
    return_value_gtk_text_view_get_pixels_below_lines$19=gtk_text_view_get_pixels_below_lines((struct _GtkTextView *)return_value_g_type_check_instance_cast$18);
    client_view->margin_height = (unsigned int)(return_value_gtk_text_view_get_pixels_above_lines$16 + return_value_gtk_text_view_get_pixels_below_lines$19);
    g_signal_connect_data((void *)client_view->view, "size-allocate", (void (*)(void))on_gm_mcp_vmoo_client_text_view_size_allocate, (void *)client_view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)client_view->view, "character_size_changed", (void (*)(void))on_gm_mcp_vmoo_client_character_size_changed, (void *)client_view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)package, (unsigned long int)(20 << 2));
    g_object_weak_ref((struct _GObject *)return_value_g_type_check_instance_cast$20, on_gm_mcp_vmoo_client_view_weak_notify, (void *)client_view);
  }

}

// gm_mcp_vmoo_client_finalize
// file mcp/gm-mcp-vmoo-client.c line 46
static void gm_mcp_vmoo_client_finalize(struct _GObject *object)
{
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_vmoo_client_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$1)->finalize(object);
}

// gm_mcp_vmoo_client_get_type
// file mcp/gm-mcp-vmoo-client.h line 54
unsigned long int gm_mcp_vmoo_client_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpVmooClient");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpVmooClientClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_vmoo_client_class_intern_init, (unsigned int)sizeof(struct _GmMcpVmooClient) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_vmoo_client_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_vmoo_client_handle_simple
// file mcp/gm-mcp-vmoo-client.c line 90
void gm_mcp_vmoo_client_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  signed int return_value_strcmp$9;
  return_value_strcmp$9=strcmp(suffix, "disconnect");
  if(return_value_strcmp$9 == 0)
  {
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
    struct _GObject *return_value_gm_mcp_package_get_session$3;
    return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
    unsigned long int return_value_gm_mcp_session_get_type$4;
    return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
    struct _GObject *return_value_gm_mcp_session_world$6;
    return_value_gm_mcp_session_world$6=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5);
    unsigned long int return_value_gm_world_get_type$7;
    return_value_gm_world_get_type$7=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$6, return_value_gm_world_get_type$7);
    gm_world_prepare_disconnect((struct _GmWorld *)return_value_g_type_check_instance_cast$8);
  }

}

// gm_mcp_vmoo_client_init
// file mcp/gm-mcp-vmoo-client.c line 78
static void gm_mcp_vmoo_client_init(struct _GmMcpVmooClient *obj)
{
  ;
}

// gm_mcp_vmoo_client_install_timeout
// file mcp/gm-mcp-vmoo-client.c line 162
void gm_mcp_vmoo_client_install_timeout(struct _GmMcpVmooClientView *view)
{
  if(!(view->timeout == 0u))
    g_source_remove(view->timeout);

  view->timeout=g_timeout_add((unsigned int)500, (signed int (*)(void *))gm_mcp_vmoo_client_timeout_update, (void *)view);
}

// gm_mcp_vmoo_client_new
// file mcp/gm-mcp-vmoo-client.c line 83
struct _GmMcpVmooClient * gm_mcp_vmoo_client_new(void)
{
  struct _GmMcpVmooClient *obj;
  unsigned long int return_value_gm_mcp_vmoo_client_get_type$1;
  return_value_gm_mcp_vmoo_client_get_type$1=gm_mcp_vmoo_client_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_vmoo_client_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_vmoo_client_get_type$3;
  return_value_gm_mcp_vmoo_client_get_type$3=gm_mcp_vmoo_client_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_vmoo_client_get_type$3);
  obj = (struct _GmMcpVmooClient *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_vmoo_client_set_session
// file mcp/gm-mcp-vmoo-client.c line 99
void gm_mcp_vmoo_client_set_session(struct _GmMcpPackage *package, struct _GObject *session)
{
  struct _GmMcpPackageClass *gm_mcp_vmoo_client_set_session$$1$$parent_class;
  void *return_value_g_type_class_peek_parent$1;
  return_value_g_type_class_peek_parent$1=g_type_class_peek_parent((void *)(struct _GmMcpVmooClientClass *)((struct _GTypeInstance *)package)->g_class);
  gm_mcp_vmoo_client_set_session$$1$$parent_class = (struct _GmMcpPackageClass *)return_value_g_type_class_peek_parent$1;
  char *iversion;
  gm_mcp_vmoo_client_set_session$$1$$parent_class->set_session(package, session);
  char *return_value_g_strdup$2;
  return_value_g_strdup$2=g_strdup("2.2.0");
  iversion=gm_string_remove_char(return_value_g_strdup$2, (char)46);
  unsigned long int return_value_gm_mcp_session_get_type$3;
  return_value_gm_mcp_session_get_type$3=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)session, return_value_gm_mcp_session_get_type$3);
  gm_mcp_session_send_simple((struct _GmMcpSession *)return_value_g_type_check_instance_cast$4, "dns-com-vmoo-client-info", "name", (const void *)"GnoeMoe", (const void *)"text-version", (const void *)"2.2.0", (const void *)"internal-version", iversion, (const void *)"reg-id", (const void *)"0", (const void *)"flags", (const void *)"", (void *)0);
  g_free((void *)iversion);
}

// gm_mcp_vmoo_client_timeout_update
// file mcp/gm-mcp-vmoo-client.c line 154
signed int gm_mcp_vmoo_client_timeout_update(struct _GmMcpVmooClientView *view)
{
  view->timeout = (unsigned int)0;
  gm_mcp_vmoo_client_view_update_metrics(view);
  return 0;
}

// gm_mcp_vmoo_client_view_update_metrics
// file mcp/gm-mcp-vmoo-client.c line 117
void gm_mcp_vmoo_client_view_update_metrics(struct _GmMcpVmooClientView *view)
{
  unsigned int width;
  unsigned int height;
  unsigned int cwidth;
  unsigned int cheight;
  char *w;
  char *h;
  struct _GdkRectangle *allocation;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->view, return_value_gtk_widget_get_type$1);
  allocation = &((struct _GtkWidget *)return_value_g_type_check_instance_cast$2)->allocation;
  width = (unsigned int)allocation->width - view->margin_width;
  height = (unsigned int)allocation->height - view->margin_width;
  gm_world_text_view_get_metrics(view->view, &cwidth, &cheight);
  if(!(width % cwidth == 0u))
    width = width / cwidth;

  else
    width = width / cwidth - (unsigned int)1;
  if(!(height % cheight == 0u))
    height = height / cheight;

  else
    height = height / cheight - (unsigned int)1;
  _Bool tmp_if_expr$8;
  if(!(view->width == width))
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = view->height != height ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$8)
  {
    w=g_strdup_printf("%d", width);
    h=g_strdup_printf("%d", height);
    unsigned long int return_value_gm_mcp_package_get_type$3;
    return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_mcp_package_get_type$3);
    struct _GObject *return_value_gm_mcp_package_get_session$5;
    return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
    unsigned long int return_value_gm_mcp_session_get_type$6;
    return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
    gm_mcp_session_send_simple((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7, "dns-com-vmoo-client-screensize", "cols", w, (const void *)"rows", h, (void *)0);
    g_free((void *)w);
    g_free((void *)h);
    view->width = width;
    view->height = height;
  }

}

// gm_mcp_vmoo_userlist_class_init
// file mcp/gm-mcp-vmoo-userlist.c line 151
static void gm_mcp_vmoo_userlist_class_init(struct _GmMcpVmooUserlistClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GmMcpPackageClass *pklass;
  unsigned long int return_value_gm_mcp_package_get_type$2;
  return_value_gm_mcp_package_get_type$2=gm_mcp_package_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gm_mcp_package_get_type$2);
  pklass = (struct _GmMcpPackageClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_mcp_vmoo_userlist_finalize;
  pklass->name = "dns-com-vmoo-userlist";
  pklass->handle_simple = gm_mcp_vmoo_userlist_handle_simple;
  pklass->handle_multi = gm_mcp_vmoo_userlist_handle_multi;
  pklass->create_view = gm_mcp_vmoo_userlist_create_view;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmMcpVmooUserlistPrivate) /*48ul*/ );
}

// gm_mcp_vmoo_userlist_class_intern_init
// file mcp/gm-mcp-vmoo-userlist.c line 61
static void gm_mcp_vmoo_userlist_class_intern_init(void *klass)
{
  gm_mcp_vmoo_userlist_parent_class=g_type_class_peek_parent(klass);
  if(!(GmMcpVmooUserlist_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmMcpVmooUserlist_private_offset);

  gm_mcp_vmoo_userlist_class_init((struct _GmMcpVmooUserlistClass *)klass);
}

// gm_mcp_vmoo_userlist_create_view
// file mcp/gm-mcp-vmoo-userlist.c line 800
void gm_mcp_vmoo_userlist_create_view(struct _GmMcpPackage *package, struct _GObject *parent)
{
  gm_mcp_userlist_view_new(package, parent);
}

// gm_mcp_vmoo_userlist_finalize
// file mcp/gm-mcp-vmoo-userlist.c line 126
static void gm_mcp_vmoo_userlist_finalize(struct _GObject *object)
{
  struct _GmMcpVmooUserlist *obj;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_mcp_vmoo_userlist_get_type$1);
  obj = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$2;
  struct _GList *field = obj->priv->fields;
  for( ; !(field == ((struct _GList *)NULL)); field = field->next)
    g_free(field->data);
  g_list_free(obj->priv->fields);
  field = obj->priv->icons;
  for( ; !(field == ((struct _GList *)NULL)); field = field->next)
    g_free(field->data);
  g_list_free(obj->priv->icons);
  gm_mcp_vmoo_userlist_free_menu(obj);
  gm_mcp_vmoo_userlist_remove_users(obj);
  g_list_free(obj->priv->users);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_mcp_vmoo_userlist_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_mcp_vmoo_userlist_find_user
// file mcp/gm-mcp-vmoo-userlist.c line 344
struct _UserInfo * gm_mcp_vmoo_userlist_find_user(struct _GmMcpVmooUserlist *package, signed int nr)
{
  struct _UserInfo *result;
  struct _GList *users = package->priv->users;
  for( ; !(users == ((struct _GList *)NULL)); users = users->next)
  {
    result = (struct _UserInfo *)users->data;
    if(result->nr == nr)
      return result;

  }
  return (struct _UserInfo *)(void *)0;
}

// gm_mcp_vmoo_userlist_free_menu
// file mcp/gm-mcp-vmoo-userlist.c line 110
static void gm_mcp_vmoo_userlist_free_menu(struct _GmMcpVmooUserlist *obj)
{
  struct _GList *field;
  struct _GmKeyValuePair *pair;
  field = obj->priv->menu;
  for( ; !(field == ((struct _GList *)NULL)); field = field->next)
  {
    pair = (struct _GmKeyValuePair *)field->data;
    g_free((void *)pair->key);
    g_free((void *)pair->value);
    g_free((void *)pair);
  }
  obj->priv->menu = (struct _GList *)(void *)0;
}

// gm_mcp_vmoo_userlist_get_icon
// file mcp/gm-mcp-vmoo-userlist.c line 480
const char * gm_mcp_vmoo_userlist_get_icon(struct _GmIUserlist *userlist, signed int id, signed int use_state)
{
  struct _GmMcpVmooUserlist *package;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_vmoo_userlist_get_type$1);
  package = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$2;
  struct _UserInfo *info;
  info=gm_mcp_vmoo_userlist_find_user(package, id);
  const char *return_value_gm_mcp_vmoo_userlist_icon_path$3;
  return_value_gm_mcp_vmoo_userlist_icon_path$3=gm_mcp_vmoo_userlist_icon_path(package, info, use_state);
  return return_value_gm_mcp_vmoo_userlist_icon_path$3;
}

// gm_mcp_vmoo_userlist_get_int
// file mcp/gm-mcp-vmoo-userlist.c line 324
signed int gm_mcp_vmoo_userlist_get_int(struct _GmMcpVmooUserlist *package, struct _MOOVar *v, enum anonymous$34 type, char *cmp)
{
  struct _GList *fields = package->priv->fields;
  signed int return_value_strcasecmp$1;
  while(!(fields == ((struct _GList *)NULL)))
  {
    return_value_strcasecmp$1=strcasecmp((char *)fields->data, cmp);
    if(return_value_strcasecmp$1 == 0)
      break;

    fields = fields->next;
    if(!(v == ((struct _MOOVar *)NULL)))
      v = v->next;

  }
  if(!(v == ((struct _MOOVar *)NULL)))
  {
    if(!(v->type == type))
      goto __CPROVER_DUMP_L4;

    return v->i;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    return 0;
  }
}

// gm_mcp_vmoo_userlist_get_menu
// file mcp/gm-mcp-vmoo-userlist.c line 452
struct _GList * gm_mcp_vmoo_userlist_get_menu(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpVmooUserlist *package = (struct _GmMcpVmooUserlist *)userlist;
  struct _UserInfo *info;
  info=gm_mcp_vmoo_userlist_find_user(package, id);
  struct _GList *item;
  struct _GList *menu = (struct _GList *)(void *)0;
  struct _GmKeyValuePair *pair;
  if(info == ((struct _UserInfo *)NULL))
    return (struct _GList *)(void *)0;

  else
  {
    item = package->priv->menu;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      pair = (struct _GmKeyValuePair *)item->data;
      struct _GmKeyValuePair *return_value_gm_mcp_vmoo_userlist_get_menu_item$1;
      return_value_gm_mcp_vmoo_userlist_get_menu_item$1=gm_mcp_vmoo_userlist_get_menu_item(package, pair, info);
      menu=g_list_append(menu, (void *)return_value_gm_mcp_vmoo_userlist_get_menu_item$1);
    }
    return menu;
  }
}

// gm_mcp_vmoo_userlist_get_menu_item
// file mcp/gm-mcp-vmoo-userlist.c line 435
struct _GmKeyValuePair * gm_mcp_vmoo_userlist_get_menu_item(struct _GmMcpVmooUserlist *package, struct _GmKeyValuePair *menuitem, struct _UserInfo *info)
{
  struct _GmKeyValuePair *result;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmKeyValuePair) /*16ul*/ );
  result = (struct _GmKeyValuePair *)return_value_g_malloc0_n$1;
  if(menuitem == ((struct _GmKeyValuePair *)NULL))
    return result;

  else
  {
    result->key=gm_mcp_vmoo_userlist_menu_item_subst(package, menuitem->key, info);
    result->value=gm_mcp_vmoo_userlist_menu_item_subst(package, menuitem->value, info);
    return result;
  }
}

// gm_mcp_vmoo_userlist_get_name
// file mcp/gm-mcp-vmoo-userlist.c line 472
const char * gm_mcp_vmoo_userlist_get_name(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpVmooUserlist *package;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_vmoo_userlist_get_type$1);
  package = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$2;
  struct _UserInfo *info;
  info=gm_mcp_vmoo_userlist_find_user(package, id);
  return info->name;
}

// gm_mcp_vmoo_userlist_get_rank_priority
// file mcp/gm-mcp-vmoo-userlist.c line 489
signed int gm_mcp_vmoo_userlist_get_rank_priority(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpVmooUserlist *package;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_vmoo_userlist_get_type$1);
  package = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$2;
  struct _UserInfo *info;
  info=gm_mcp_vmoo_userlist_find_user(package, id);
  unsigned int return_value_g_list_length$3;
  return_value_g_list_length$3=g_list_length(package->priv->icons);
  return (signed int)(return_value_g_list_length$3 - info->icon);
}

// gm_mcp_vmoo_userlist_get_state_priority
// file mcp/gm-mcp-vmoo-userlist.c line 497
signed int gm_mcp_vmoo_userlist_get_state_priority(struct _GmIUserlist *userlist, signed int id)
{
  struct _GmMcpVmooUserlist *package;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userlist, return_value_gm_mcp_vmoo_userlist_get_type$1);
  package = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$2;
  struct _UserInfo *info;
  info=gm_mcp_vmoo_userlist_find_user(package, id);
  return (signed int)info->state;
}

// gm_mcp_vmoo_userlist_get_string
// file mcp/gm-mcp-vmoo-userlist.c line 304
char * gm_mcp_vmoo_userlist_get_string(struct _GmMcpVmooUserlist *package, struct _MOOVar *v, enum anonymous$34 type, char *cmp)
{
  struct _GList *fields = package->priv->fields;
  signed int return_value_strcasecmp$1;
  while(!(fields == ((struct _GList *)NULL)))
  {
    return_value_strcasecmp$1=strcasecmp((char *)fields->data, cmp);
    if(return_value_strcasecmp$1 == 0)
      break;

    fields = fields->next;
    if(!(v == ((struct _MOOVar *)NULL)))
      v = v->next;

  }
  if(!(v == ((struct _MOOVar *)NULL)))
  {
    if(v->type == type)
    {
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup(v->s);
      return return_value_g_strdup$2;
    }

  }

  return (char *)(void *)0;
}

// gm_mcp_vmoo_userlist_get_type
// file mcp/gm-mcp-vmoo-userlist.h line 51
unsigned long int gm_mcp_vmoo_userlist_get_type(void)
{
  _Bool tmp_statement_expression$4;
  void *tmp_statement_expression$5;
  signed int return_value___atomic_load_8$6;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$6=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$5 = (void *)return_value___atomic_load_8$6;
  _Bool tmp_if_expr$8;
  signed int return_value_g_once_init_enter$7;
  if(tmp_statement_expression$5 == NULL)
  {
    return_value_g_once_init_enter$7=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$8 = return_value_g_once_init_enter$7 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  tmp_statement_expression$4 = tmp_if_expr$8;
  if(tmp_statement_expression$4)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmMcpVmooUserlist");
    g_define_type_id=g_type_register_static_simple(return_value_gm_mcp_package_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmMcpVmooUserlistClass) /*208ul*/ , (void (*)(void *, void *))gm_mcp_vmoo_userlist_class_intern_init, (unsigned int)sizeof(struct _GmMcpVmooUserlist) /*40ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_mcp_vmoo_userlist_init, (enum anonymous)0);
    const struct _GInterfaceInfo g_implement_interface_info = { .interface_init=(void (*)(void *, void *))gm_mcp_vmoo_userlist_iface_init, .interface_finalize=(void (*)(void *, void *))(void *)0,
    .interface_data=(void *)0 };
    unsigned long int return_value_gm_iuserlist_get_type$3;
    return_value_gm_iuserlist_get_type$3=gm_iuserlist_get_type();
    g_type_add_interface_static(g_define_type_id, return_value_gm_iuserlist_get_type$3, &g_implement_interface_info);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_mcp_vmoo_userlist_handle_add
// file mcp/gm-mcp-vmoo-userlist.c line 585
void gm_mcp_vmoo_userlist_handle_add(struct _GmMcpVmooUserlist *package, struct _MOOVar *v)
{
  if((signed int)v->type == LIST)
    gm_mcp_vmoo_userlist_handle_user_update(package, v->list);

}

// gm_mcp_vmoo_userlist_handle_fields
// file mcp/gm-mcp-vmoo-userlist.c line 216
void gm_mcp_vmoo_userlist_handle_fields(struct _GmMcpVmooUserlist *package, struct _MOOVar *list)
{
  struct _MOOVar *field = list->list;
  for( ; !(field == ((struct _MOOVar *)NULL)); field = field->next)
    if((signed int)field->type == STRING)
    {
      char *return_value_g_strdup$1;
      return_value_g_strdup$1=g_strdup(field->s);
      package->priv->fields=g_list_append(package->priv->fields, (void *)return_value_g_strdup$1);
    }

}

// gm_mcp_vmoo_userlist_handle_icons
// file mcp/gm-mcp-vmoo-userlist.c line 271
void gm_mcp_vmoo_userlist_handle_icons(struct _GmMcpVmooUserlist *package, struct _MOOVar *list)
{
  struct _MOOVar *field = list->list;
  for( ; !(field == ((struct _MOOVar *)NULL)); field = field->next)
    if((signed int)field->type == STRING)
    {
      char *return_value_g_strdup$1;
      return_value_g_strdup$1=g_strdup(field->s);
      package->priv->icons=g_list_append(package->priv->icons, (void *)return_value_g_strdup$1);
    }

}

// gm_mcp_vmoo_userlist_handle_menu
// file mcp/gm-mcp-vmoo-userlist.c line 283
void gm_mcp_vmoo_userlist_handle_menu(struct _GmMcpVmooUserlist *package, struct _MOOVar *list)
{
  struct _MOOVar *field;
  struct _GmKeyValuePair *pair;
  field = list->list;
  _Bool tmp_if_expr$2;
  for( ; !(field == ((struct _MOOVar *)NULL)); field = field->next)
  {
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmKeyValuePair) /*16ul*/ );
    pair = (struct _GmKeyValuePair *)return_value_g_malloc0_n$1;
    if((signed int)field->type == LIST)
      tmp_if_expr$2 = field->i == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      pair->key=g_strdup(field->list->s);
      pair->value=g_strdup(field->list->next->s);
      package->priv->menu=g_list_append(package->priv->menu, (void *)pair);
    }

    else
      if(!((signed int)field->type == LIST))
        package->priv->menu=g_list_append(package->priv->menu, (void *)pair);

      else
        g_free((void *)pair);
  }
}

// gm_mcp_vmoo_userlist_handle_multi
// file mcp/gm-mcp-vmoo-userlist.c line 722
signed int gm_mcp_vmoo_userlist_handle_multi(struct _GmMcpPackage *package, const char *data_tag, const char *key, const char *value, struct _GList *all_values)
{
  struct _MOOVar *v = (struct _MOOVar *)(void *)0;
  struct _GmMcpVmooUserlist *userlist;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_vmoo_userlist_get_type$1);
  userlist = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$2;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$6;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$5;
  if(!(key == ((const char *)NULL)))
  {
    signed int return_value_strcmp$7;
    return_value_strcmp$7=strcmp(key, "fields");
    if(return_value_strcmp$7 == 0)
    {
      v=MOOVar_parse(value);
      if(v == ((struct _MOOVar *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)v->type != LIST ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        gm_debug_msg(DEBUG_MCP, "GmMcpVmooUserlist.HandleMulti: invalid value: %s", value);

      else
        gm_mcp_vmoo_userlist_handle_fields(userlist, v);
    }

    else
    {
      return_value_strcmp$6=strcmp(key, "icons");
      if(return_value_strcmp$6 == 0)
      {
        v=MOOVar_parse(value);
        if(v == ((struct _MOOVar *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)v->type != LIST ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          gm_debug_msg(DEBUG_MCP, "GmMcpVmooUserlist.HandleMulti: invalid value: %s", value);

        else
          gm_mcp_vmoo_userlist_handle_icons(userlist, v);
      }

      else
      {
        return_value_strcmp$5=strcmp(key, "d");
        if(return_value_strcmp$5 == 0)
        {
          v=MOOVar_parse(value + (signed long int)1);
          if(v == ((struct _MOOVar *)NULL))
            gm_debug_msg(DEBUG_MCP, "GmMcpVmooUserlist.HandleMulti: invalid value: %s", value + (signed long int)1);

          else
            switch((signed int)*value)
            {
              case 61:
              {
                gm_mcp_vmoo_userlist_handle_set(userlist, v);
                break;
              }
              case 43:
              {
                gm_mcp_vmoo_userlist_handle_add(userlist, v);
                break;
              }
              case 45:
              {
                gm_mcp_vmoo_userlist_handle_remove(userlist, v);
                break;
              }
              case 42:
              {
                gm_mcp_vmoo_userlist_handle_update(userlist, v);
                break;
              }
              case 60:
              {
                gm_mcp_vmoo_userlist_handle_state(userlist, v, (enum _UserState)U_IDLE, (signed int)!(0 != 0));
                break;
              }
              case 62:
              {
                gm_mcp_vmoo_userlist_handle_state(userlist, v, (enum _UserState)U_IDLE, 0);
                break;
              }
              case 91:
              {
                gm_mcp_vmoo_userlist_handle_state(userlist, v, (enum _UserState)U_AWAY, (signed int)!(0 != 0));
                break;
              }
              case 93:
              {
                gm_mcp_vmoo_userlist_handle_state(userlist, v, (enum _UserState)U_AWAY, 0);
                break;
              }
              case 40:
                gm_mcp_vmoo_userlist_handle_remove(userlist, v);
            }
        }

      }
    }
  }

  if(!(v == ((struct _MOOVar *)NULL)))
    MOOVar_free(v);

  return (signed int)!(0 != 0);
}

// gm_mcp_vmoo_userlist_handle_remove
// file mcp/gm-mcp-vmoo-userlist.c line 594
void gm_mcp_vmoo_userlist_handle_remove(struct _GmMcpVmooUserlist *package, struct _MOOVar *v)
{
  struct _MOOVar *nr;
  if((signed int)v->type == LIST)
  {
    nr = v->list;
    for( ; !(nr == ((struct _MOOVar *)NULL)); nr = nr->next)
      if((signed int)nr->type == OBJECT)
        gm_mcp_vmoo_userlist_remove_user(package, nr->i);

  }

}

// gm_mcp_vmoo_userlist_handle_set
// file mcp/gm-mcp-vmoo-userlist.c line 563
void gm_mcp_vmoo_userlist_handle_set(struct _GmMcpVmooUserlist *package, struct _MOOVar *v)
{
  struct _MOOVar *ui;
  if((signed int)v->type == LIST)
  {
    package->priv->initializing = (signed int)!(0 != 0);
    gm_mcp_vmoo_userlist_remove_users(package);
    ui = v->list;
    for( ; !(ui == ((struct _MOOVar *)NULL)); ui = ui->next)
    {
      if(!((signed int)ui->type == LIST))
        goto __CPROVER_DUMP_L5;

      gm_mcp_vmoo_userlist_handle_user_update(package, ui->list);
    }
    package->priv->initializing = 0;
  }


__CPROVER_DUMP_L5:
  ;
}

// gm_mcp_vmoo_userlist_handle_simple
// file mcp/gm-mcp-vmoo-userlist.c line 686
void gm_mcp_vmoo_userlist_handle_simple(struct _GmMcpPackage *package, char *suffix, struct _GList *fields)
{
  struct _MOOVar *v = (struct _MOOVar *)(void *)0;
  struct _GmMcpVmooUserlist *userlist;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_vmoo_userlist_get_type$1);
  userlist = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$2;
  const char *value;
  signed int return_value_strcmp$5;
  _Bool tmp_if_expr$4;
  if(!(suffix == ((char *)NULL)))
  {
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(suffix, "you");
    if(return_value_strcmp$6 == 0)
    {
      const char *return_value_gm_mcp_find_value$3;
      return_value_gm_mcp_find_value$3=gm_mcp_find_value(fields, "nr");
      v=MOOVar_parse(return_value_gm_mcp_find_value$3);
      if((signed int)v->type == OBJECT)
        userlist->priv->you = v->i;

      else
        gm_debug_msg(DEBUG_MCP, "GmMcpVmooUserlist.HandleSimple: you is not an object!");
    }

    else
    {
      return_value_strcmp$5=strcmp(suffix, "menu");
      if(return_value_strcmp$5 == 0)
      {
        value=gm_mcp_find_value(fields, "menu");
        v=MOOVar_parse(value);
        if(v == ((struct _MOOVar *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)v->type != LIST ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          gm_debug_msg(DEBUG_MCP, "GmMcpVmooUserlist.HandleMulti: invalid value: %s", value);

        else
        {
          gm_mcp_vmoo_userlist_free_menu(userlist);
          gm_mcp_vmoo_userlist_handle_menu(userlist, v);
        }
      }

    }
  }

  if(!(v == ((struct _MOOVar *)NULL)))
    MOOVar_free(v);

}

// gm_mcp_vmoo_userlist_handle_state
// file mcp/gm-mcp-vmoo-userlist.c line 618
void gm_mcp_vmoo_userlist_handle_state(struct _GmMcpVmooUserlist *package, struct _MOOVar *v, enum _UserState state, signed int onOff)
{
  struct _MOOVar *nr;
  struct _UserInfo *u;
  enum _GmTriggerConditionType condition = (enum _GmTriggerConditionType)0;
  if((signed int)v->type == LIST)
  {
    nr = v->list;
    for( ; !(nr == ((struct _MOOVar *)NULL)); nr = nr->next)
      if((signed int)nr->type == OBJECT)
      {
        u=gm_mcp_vmoo_userlist_find_user(package, nr->i);
        if(!(u == ((struct _UserInfo *)NULL)))
        {
          switch((signed int)state)
          {
            case U_IDLE:
            {
              if(onOff == 0 && (signed int)u->state == U_IDLEAWAY)
                u->state = (enum _UserState)U_AWAY;

              else
                if((signed int)u->state == U_AWAY && !(onOff == 0))
                  u->state = (enum _UserState)U_IDLEAWAY;

                else
                  if(!(onOff == 0))
                    u->state = (enum _UserState)U_IDLE;

                  else
                    if((signed int)u->state == U_IDLE)
                      u->state = (enum _UserState)U_NORMAL;

              if(!(onOff == 0))
                condition = (enum _GmTriggerConditionType)TCT_USER_IDLE;

              else
                condition = (enum _GmTriggerConditionType)TCT_USER_IDLE_OFF;
              break;
            }
            case U_AWAY:
            {
              if(onOff == 0 && (signed int)u->state == U_IDLEAWAY)
                u->state = (enum _UserState)U_IDLE;

              else
                if((signed int)u->state == U_IDLE && !(onOff == 0))
                  u->state = (enum _UserState)U_IDLEAWAY;

                else
                  if(!(onOff == 0))
                    u->state = (enum _UserState)U_AWAY;

                  else
                    if((signed int)u->state == U_AWAY)
                      u->state = (enum _UserState)U_NORMAL;

              if(!(onOff == 0))
                condition = (enum _GmTriggerConditionType)TCT_USER_AWAY;

              else
                condition = (enum _GmTriggerConditionType)TCT_USER_AWAY_OFF;
            }
          }
          g_signal_emit_by_name((void *)package, "state-changed", u->nr);
          if(!((signed int)condition == 0))
            gm_mcp_vmoo_userlist_process_triggers(package, u->name, condition);

        }

        else
          gm_debug_msg(DEBUG_MCP, "User %d does not exist!", nr->i);
      }

      else
        gm_debug_msg(DEBUG_MCP, "Nr is not an object: %d", nr->type);
  }

}

// gm_mcp_vmoo_userlist_handle_update
// file mcp/gm-mcp-vmoo-userlist.c line 609
void gm_mcp_vmoo_userlist_handle_update(struct _GmMcpVmooUserlist *package, struct _MOOVar *v)
{
  if((signed int)v->type == LIST)
    gm_mcp_vmoo_userlist_handle_user_update(package, v->list);

}

// gm_mcp_vmoo_userlist_handle_user_update
// file mcp/gm-mcp-vmoo-userlist.c line 525
void gm_mcp_vmoo_userlist_handle_user_update(struct _GmMcpVmooUserlist *package, struct _MOOVar *v)
{
  signed int nr;
  nr=gm_mcp_vmoo_userlist_get_int(package, v, (enum anonymous$34)OBJECT, "object");
  char *name;
  name=gm_mcp_vmoo_userlist_get_string(package, v, (enum anonymous$34)STRING, "name");
  signed int icon;
  icon=gm_mcp_vmoo_userlist_get_int(package, v, (enum anonymous$34)INT, "icon");
  struct _UserInfo *ui;
  ui=gm_mcp_vmoo_userlist_find_user(package, nr);
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(ui == ((struct _UserInfo *)NULL))
  {
    void *return_value_g_malloc_n$1;
    return_value_g_malloc_n$1=g_malloc_n((unsigned long int)1, sizeof(struct _UserInfo) /*24ul*/ );
    ui = (struct _UserInfo *)return_value_g_malloc_n$1;
    ui->name = name;
    ui->state = (enum _UserState)U_NORMAL;
    ui->icon = (unsigned int)icon;
    ui->nr = nr;
    package->priv->users=g_list_append(package->priv->users, (void *)ui);
    g_signal_emit_by_name((void *)package, "player-added", nr);
    gm_mcp_vmoo_userlist_process_triggers(package, ui->name, (enum _GmTriggerConditionType)TCT_USER_ONLINE);
  }

  else
  {
    if(!(ui->name == ((char *)NULL)))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_strcmp$2=strcmp(ui->name, name);
      tmp_if_expr$3 = return_value_strcmp$2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      g_free((void *)ui->name);
      ui->name = name;
      g_signal_emit_by_name((void *)package, "name-changed", nr);
    }

    else
      g_free((void *)name);
    if(!(ui->icon == (unsigned int)icon))
    {
      ui->icon = (unsigned int)icon;
      g_signal_emit_by_name((void *)package, "rank-changed", nr);
    }

  }
}

// gm_mcp_vmoo_userlist_icon_path
// file mcp/gm-mcp-vmoo-userlist.c line 228
const char * gm_mcp_vmoo_userlist_icon_path(struct _GmMcpVmooUserlist *package, struct _UserInfo *ui, signed int use_state)
{
  char *field;
  unsigned int index = ui->icon;
  const struct _GmKeyValuePair *pair;
  _Bool tmp_if_expr$5;
  unsigned int return_value_g_list_length$4;
  if(!(index >= 1u))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_g_list_length$4=g_list_length(package->priv->icons);
    tmp_if_expr$5 = index > return_value_g_list_length$4 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$5)
    return (const char *)(void *)0;

  else
  {
    if(use_state == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)ui->state == U_NORMAL ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      void *return_value_g_list_nth_data$1;
      return_value_g_list_nth_data$1=g_list_nth_data(package->priv->icons, index - (unsigned int)1);
      field = (char *)return_value_g_list_nth_data$1;
      pair = icon_mapping;
      while((_Bool)1)
      {
        if(pair->key == ((char *)NULL))
        {
          if(pair->value == ((char *)NULL))
            goto __CPROVER_DUMP_L9;

        }

        signed int return_value_strcasecmp$2;
        return_value_strcasecmp$2=strcasecmp(pair->key, field);
        if(return_value_strcasecmp$2 == 0)
          return pair->value;

        pair = pair + 1l;
      }
    }

    else
      switch((signed int)ui->state)
      {
        case U_IDLE:
          return "userlist/idle.svg";
        case U_AWAY:
          return "userlist/away.svg";
        case U_IDLEAWAY:
          return "userlist/idleaway.svg";
        default:
          ;
      }
  }

__CPROVER_DUMP_L9:
  ;
  return (const char *)(void *)0;
}

// gm_mcp_vmoo_userlist_iface_init
// file mcp/gm-mcp-vmoo-userlist.c line 83
static void gm_mcp_vmoo_userlist_iface_init(struct _GmIUserlistInterface *iface)
{
  iface->get_menu = gm_mcp_vmoo_userlist_get_menu;
  iface->get_name = gm_mcp_vmoo_userlist_get_name;
  iface->get_icon = gm_mcp_vmoo_userlist_get_icon;
  iface->get_rank_priority = gm_mcp_vmoo_userlist_get_rank_priority;
  iface->get_state_priority = gm_mcp_vmoo_userlist_get_state_priority;
}

// gm_mcp_vmoo_userlist_init
// file mcp/gm-mcp-vmoo-userlist.c line 166
static void gm_mcp_vmoo_userlist_init(struct _GmMcpVmooUserlist *obj)
{
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_mcp_vmoo_userlist_get_type$1);
  obj->priv = (struct _GmMcpVmooUserlistPrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->you = 0;
  obj->priv->fields = (struct _GList *)(void *)0;
  obj->priv->icons = (struct _GList *)(void *)0;
  obj->priv->users = (struct _GList *)(void *)0;
}

// gm_mcp_vmoo_userlist_menu_item_subst
// file mcp/gm-mcp-vmoo-userlist.c line 360
char * gm_mcp_vmoo_userlist_menu_item_subst(struct _GmMcpVmooUserlist *package, char *str, struct _UserInfo *info)
{
  struct _GString *result;
  char *ptr = str;
  char *subst;
  char *tmp;
  unsigned int ch;
  unsigned int cnum;
  signed int num;
  signed int substituted;
  signed int return_value_g_unichar_isdigit$2;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    result=g_string_sized_new(return_value_strlen$1);
    do
    {
      ch=g_utf8_get_char(ptr);
      if(ch == 0u)
        break;

      substituted = 0;
      if(ch == 38u)
      {
        result=g_string_append_c_inline$link2(result, (char)95);
        substituted = (signed int)!(0 != 0);
      }

      else
        if(ch == 36u)
        {
          subst = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
          unsigned int return_value_g_utf8_get_char$5;
          return_value_g_utf8_get_char$5=g_utf8_get_char(subst);
          if(return_value_g_utf8_get_char$5 == 40u)
          {
            subst = (char *)(subst + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)subst)]);
            num = 0;
            do
            {
              cnum=g_utf8_get_char(subst);
              return_value_g_unichar_isdigit$2=g_unichar_isdigit(cnum);
              if(return_value_g_unichar_isdigit$2 == 0)
                break;

              signed int return_value_g_unichar_digit_value$3;
              return_value_g_unichar_digit_value$3=g_unichar_digit_value(cnum);
              num = num * 10 + return_value_g_unichar_digit_value$3;
              subst = (char *)(subst + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)subst)]);
            }
            while((_Bool)1);
            unsigned int return_value_g_utf8_get_char$4;
            return_value_g_utf8_get_char$4=g_utf8_get_char(subst);
            if(return_value_g_utf8_get_char$4 == 41u)
              switch(num)
              {
                case 1:
                {
                  tmp=g_strdup_printf("#%d", info->nr);
                  result=g_string_append(result, tmp);
                  g_free((void *)tmp);
                  goto __CPROVER_DUMP_L10;
                }
                case 2:
                {
                  tmp = info->name;
                  for( ; !((signed int)*tmp == 0); tmp = (char *)(tmp + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)tmp)]))
                  {
                    ch=g_utf8_get_char(tmp);
                    if(ch == 95u)
                      result=g_string_append_c_inline$link2(result, (char)95);

                    result=g_string_append_unichar(result, ch);
                  }
                }
                default:
                {

                __CPROVER_DUMP_L10:
                  ;
                  ptr = subst;
                  substituted = (signed int)!(0 != 0);
                }
              }

          }

        }

      if(substituted == 0)
        result=g_string_append_unichar(result, ch);

      ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
    }
    while((_Bool)1);
    ptr = result->str;
    g_string_free(result, 0);
    return ptr;
  }
}

// gm_mcp_vmoo_userlist_new
// file mcp/gm-mcp-vmoo-userlist.c line 176
struct _GmMcpVmooUserlist * gm_mcp_vmoo_userlist_new(void)
{
  struct _GmMcpVmooUserlist *obj;
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$1;
  return_value_gm_mcp_vmoo_userlist_get_type$1=gm_mcp_vmoo_userlist_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_mcp_vmoo_userlist_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_mcp_vmoo_userlist_get_type$3;
  return_value_gm_mcp_vmoo_userlist_get_type$3=gm_mcp_vmoo_userlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_mcp_vmoo_userlist_get_type$3);
  obj = (struct _GmMcpVmooUserlist *)return_value_g_type_check_instance_cast$4;
  return obj;
}

// gm_mcp_vmoo_userlist_process_triggers
// file mcp/gm-mcp-vmoo-userlist.c line 186
void gm_mcp_vmoo_userlist_process_triggers(struct _GmMcpVmooUserlist *package, const char *username, enum _GmTriggerConditionType condition)
{
  struct _GmWorld *world;
  struct _GmTriggers *triggers;
  const struct _GList *item;
  struct _GmTrigger *trigger;
  signed int num;
  struct anonymous$17 matches[10l];
  if(package->priv->initializing == 0)
  {
    unsigned long int return_value_gm_mcp_package_get_type$1;
    return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
    struct _GObject *return_value_gm_mcp_package_get_session$3;
    return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
    unsigned long int return_value_gm_mcp_session_get_type$4;
    return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
    struct _GObject *return_value_gm_mcp_session_world$6;
    return_value_gm_mcp_session_world$6=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5);
    unsigned long int return_value_gm_world_get_type$7;
    return_value_gm_world_get_type$7=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$6, return_value_gm_world_get_type$7);
    world = (struct _GmWorld *)return_value_g_type_check_instance_cast$8;
    triggers=gm_world_triggers(world);
    item=gm_triggers_list(triggers);
    for( ; !(item == ((const struct _GList *)NULL)); item = item->next)
    {
      trigger = (struct _GmTrigger *)item->data;
      if((signed int)trigger->event == TT_USERS)
      {
        num=gm_trigger_match_user(trigger, username, condition, matches, 10);
        if(!(num == 0))
          gm_world_apply_trigger(world, trigger, username, matches, num);

      }

    }
  }

}

// gm_mcp_vmoo_userlist_remove_user
// file mcp/gm-mcp-vmoo-userlist.c line 505
void gm_mcp_vmoo_userlist_remove_user(struct _GmMcpVmooUserlist *package, signed int nr)
{
  struct _GList *elem;
  struct _UserInfo *ui;
  elem = package->priv->users;
  for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
  {
    ui = (struct _UserInfo *)elem->data;
    if(ui->nr == nr)
    {
      gm_mcp_vmoo_userlist_process_triggers(package, ui->name, (enum _GmTriggerConditionType)TCT_USER_OFFLINE);
      package->priv->users=g_list_remove(package->priv->users, (const void *)ui);
      break;
    }

  }
  g_signal_emit_by_name((void *)package, "player-removed", nr);
}

// gm_mcp_vmoo_userlist_remove_users
// file mcp/gm-mcp-vmoo-userlist.c line 93
void gm_mcp_vmoo_userlist_remove_users(struct _GmMcpVmooUserlist *package)
{
  struct _GList *users;
  users=g_list_copy(package->priv->users);
  struct _GList *field;
  struct _UserInfo *info;
  field = users;
  for( ; !(field == ((struct _GList *)NULL)); field = field->next)
  {
    info = (struct _UserInfo *)field->data;
    package->priv->users=g_list_remove(package->priv->users, field->data);
    g_free((void *)info->name);
    g_free((void *)info);
  }
  g_list_free(users);
}

// gm_net_class_init
// file gm-net.c line 128
static void gm_net_class_init(struct _GmNetClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_net_finalize;
  net_signals[(signed long int)0]=g_signal_new("state_changing", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)136ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__UINT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(7 << 2));
  net_signals[(signed long int)1]=g_signal_new("state_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)144ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__UINT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(7 << 2));
  net_signals[(signed long int)2]=g_signal_new("net_error", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)152ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, gm_marshal_VOID__STRING_INT, (unsigned long int)(1 << 2), (unsigned int)2, (unsigned long int)(16 << 2), (unsigned long int)(6 << 2));
  net_signals[(signed long int)3]=g_signal_new("bytes_recv", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)160ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, gm_marshal_VOID__STRING_UINT, (unsigned long int)(1 << 2), (unsigned int)2, (unsigned long int)(16 << 2), (unsigned long int)(7 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmNetPrivate) /*152ul*/ );
}

// gm_net_class_intern_init
// file gm-net.c line 73
static void gm_net_class_intern_init(void *klass)
{
  gm_net_parent_class=g_type_class_peek_parent(klass);
  if(!(GmNet_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmNet_private_offset);

  gm_net_class_init((struct _GmNetClass *)klass);
}

// gm_net_clean_disconnection
// file gm-net.c line 217
void gm_net_clean_disconnection(struct _GmNet *net)
{
  struct _GError *err = (struct _GError *)(void *)0;
  if(net->priv->channel == ((struct _GIOChannel *)NULL))
    gm_debug_msg(DEBUG_DEFAULT, "GmNet.CleanDisconnection: NOT clean for %d", net->priv->socket);

  else
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmNet.CleanDisconnection: clean disconnect for %d", net->priv->socket);
    g_io_channel_shutdown(net->priv->channel, (signed int)!(0 != 0), &err);
    if(!(err == ((struct _GError *)NULL)))
    {
      gm_debug_msg(DEBUG_DEFAULT, "GmNet.CleanDisconnection: error on channel shutdown: %s", err->message);
      g_error_free(err);
      err = (struct _GError *)(void *)0;
    }

    g_io_channel_unref(net->priv->channel);
    if(!(net->priv->source == 0u))
    {
      g_source_remove(net->priv->source);
      net->priv->source = (unsigned int)0;
    }

    net->priv->channel = (struct _GIOChannel *)(void *)0;
    net->priv->socket = -1;
    net->priv->tn_last = 0;
    net->priv->tn_subneg = 0;
    gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_DISCONNECTED);
  }
}

// gm_net_close_thread
// file gm-net.c line 103
static void gm_net_close_thread(struct _GmNet *net)
{
  if(!(net->priv->thread == 0ul))
  {
    pthread_kill(net->priv->thread, 9);
    if(!(net->priv->thread_info->idle_id == 0u))
      g_source_remove(net->priv->thread_info->idle_id);

    gm_net_free_thread_info(net);
  }

}

// gm_net_connect
// file gm-net.c line 547
void gm_net_connect(struct _GmNet *net, const char *host, const char *port)
{
  char shost[1025l];
  char sport[32l];
  struct _threadinfo *info;
  if((signed int)net->priv->state == GM_NET_STATE_DISCONNECTED)
  {
    snprintf(shost, (unsigned long int)(1025 - 1), "%s", host);
    snprintf(sport, (unsigned long int)(32 - 1), "%s", port);
    gm_net_set_host(net, shost);
    gm_net_set_port(net, sport);
    gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_CONNECTING);
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _threadinfo) /*72ul*/ );
    info = (struct _threadinfo *)return_value_g_malloc0_n$1;
    info->host=g_strdup(shost);
    info->port=g_strdup(sport);
    info->net = net;
    info->mutex_idle = &net->priv->mutex_idle;
    net->priv->thread_info = info;
    pthread_create(&net->priv->thread, (const union pthread_attr_t *)(void *)0, addrinfo_thread, (void *)info);
  }

}

// gm_net_connect_failed
// file gm-net.c line 295
void gm_net_connect_failed(struct _GmNet *net, char *err, signed int code)
{
  if(!(net->priv->channel == ((struct _GIOChannel *)NULL)))
  {
    g_io_channel_shutdown(net->priv->channel, (signed int)!(0 != 0), (struct _GError **)(void *)0);
    g_io_channel_unref(net->priv->channel);
    net->priv->channel = (struct _GIOChannel *)(void *)0;
  }

  g_signal_emit((void *)net, net_signals[(signed long int)2], (unsigned int)0, err, 0);
  _Bool tmp_if_expr$2;
  if(!(net->priv->addr == ((struct addrinfo *)NULL)))
    tmp_if_expr$2 = net->priv->current->ai_next != ((struct addrinfo *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
  {
    net->priv->current = net->priv->current->ai_next;
    gm_net_connect_next(net);
  }

  else
  {
    net->priv->socket = -1;
    if(!(net->priv->addr == ((struct addrinfo *)NULL)))
    {
      freeaddrinfo(net->priv->addr);
      net->priv->addr = (struct addrinfo *)(void *)0;
      net->priv->current = (struct addrinfo *)(void *)0;
    }

    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Could not make connection...");
    g_signal_emit((void *)net, net_signals[(signed long int)2], (unsigned int)0, return_value_gettext$1, 0);
    gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_DISCONNECTED);
  }
}

// gm_net_connect_next
// file gm-net.c line 461
void gm_net_connect_next(struct _GmNet *net)
{
  struct _threadinfo *info;
  if(net->priv->current == ((struct addrinfo *)NULL))
    goto __CPROVER_DUMP_L3;

  else
  {
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _threadinfo) /*72ul*/ );
    info = (struct _threadinfo *)return_value_g_malloc0_n$1;
    info->net = net;
    info->current = net->priv->current;
    info->mutex_idle = &net->priv->mutex_idle;
    net->priv->thread_info = info;
    pthread_create(&net->priv->thread, (const union pthread_attr_t *)(void *)0, nameinfo_thread, (void *)info);
  }

__CPROVER_DUMP_L3:
  ;
}

// gm_net_connect_succeed
// file gm-net.c line 272
void gm_net_connect_succeed(struct _GmNet *net)
{
  freeaddrinfo(net->priv->addr);
  net->priv->addr = (struct addrinfo *)(void *)0;
  net->priv->current = (struct addrinfo *)(void *)0;
  net->priv->source=g_io_add_watch(net->priv->channel, (enum anonymous$69)(G_IO_IN | G_IO_HUP), (signed int (*)(struct _GIOChannel *, enum anonymous$69, void *))on_gm_net_input_recv, (void *)net);
  if(!(net->priv->connect_timeout_id == 0u))
  {
    g_source_remove(net->priv->connect_timeout_id);
    net->priv->connect_timeout_id = (unsigned int)0;
  }

  if(!(net->priv->connect_check_id == 0u))
  {
    g_source_remove(net->priv->connect_check_id);
    net->priv->connect_check_id = (unsigned int)0;
  }

  gettimeofday(&net->priv->last_connected, (struct timezone *)(void *)0);
  gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_CONNECTED);
}

// gm_net_current_host
// file gm-net.c line 630
const char * gm_net_current_host(struct _GmNet *net)
{
  return net->priv->current_host;
}

// gm_net_current_port
// file gm-net.c line 635
const char * gm_net_current_port(struct _GmNet *net)
{
  return net->priv->current_port;
}

// gm_net_dirty_disconnection
// file gm-net.c line 256
void gm_net_dirty_disconnection(struct _GmNet *net, signed int err)
{
  char *msg;
  gm_debug_msg(DEBUG_DEFAULT, "GmNet.DirtyDisconnection: dirty disconnect %d", net->priv->socket);
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Connection lost... (%s)");
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(err);
  msg=g_strdup_printf(return_value_gettext$1, return_value_strerror$2);
  g_signal_emit((void *)net, net_signals[(signed long int)2], (unsigned int)0, msg, 1);
  g_free((void *)msg);
  gm_net_clean_disconnection(net);
}

// gm_net_disconnect
// file gm-net.c line 574
void gm_net_disconnect(struct _GmNet *net)
{
  if(!((signed int)net->priv->state == GM_NET_STATE_DISCONNECTED))
  {
    gm_net_close_thread(net);
    gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_DISCONNECTING);
    if(!(net->priv->connect_timeout_id == 0u))
    {
      g_source_remove(net->priv->connect_timeout_id);
      net->priv->connect_timeout_id = (unsigned int)0;
    }

    if(!(net->priv->connect_check_id == 0u))
    {
      g_source_remove(net->priv->connect_check_id);
      net->priv->connect_check_id = (unsigned int)0;
    }

    gm_net_clean_disconnection(net);
  }

}

// gm_net_finalize
// file gm-net.c line 116
static void gm_net_finalize(struct _GObject *object)
{
  struct _GmNet *net;
  unsigned long int return_value_gm_net_get_type$1;
  return_value_gm_net_get_type$1=gm_net_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_net_get_type$1);
  net = (struct _GmNet *)return_value_g_type_check_instance_cast$2;
  gm_net_close_thread(net);
  g_free((void *)net->priv->current_host);
  g_free((void *)net->priv->current_port);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_net_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_net_free_thread_info
// file gm-net.c line 93
static void gm_net_free_thread_info(struct _GmNet *net)
{
  g_free((void *)net->priv->thread_info->message);
  g_free((void *)net->priv->thread_info->host);
  g_free((void *)net->priv->thread_info->port);
  g_free((void *)net->priv->thread_info);
  net->priv->thread_info = (struct _threadinfo *)(void *)0;
}

// gm_net_get_type
// file gm-net.c line 73
unsigned long int gm_net_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmNet");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmNetClass) /*168ul*/ , (void (*)(void *, void *))gm_net_class_intern_init, (unsigned int)sizeof(struct _GmNet) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_net_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_net_handle_telnet
// file gm-net.c line 324
void gm_net_handle_telnet(struct _GmNet *net, unsigned char *buf, signed int *len)
{
  signed int i;
  signed int j;
  unsigned char c;
  j = 0;
  i = 0;
  for( ; !(i >= *len); i = i + 1)
  {
    c = buf[(signed long int)i];
    if(!(net->priv->tn_last == 0))
      switch(net->priv->tn_last)
      {
        case 251:

        case 252:

        case 253:

        case 254:
        {
          net->priv->tn_last = 0;
          break;
        }
        case 255:
          switch((signed int)c)
          {
            case 251:

            case 252:

            case 253:

            case 254:
            {
              net->priv->tn_last = (signed int)c;
              break;
            }
            case 250:
            {
              net->priv->tn_subneg = 1;
              net->priv->tn_last = 0;
              break;
            }
            case 240:
            {
              net->priv->tn_subneg = 0;
              net->priv->tn_last = 0;
              break;
            }
            case 255:
            {
              if(net->priv->tn_subneg == 0)
              {
                buf[(signed long int)j] = c;
                j = j + 1;
              }

              net->priv->tn_last = 0;
              break;
            }
            default:
              net->priv->tn_last = 0;
          }
      }

    else
      if((signed int)c == 255)
        net->priv->tn_last = 255;

      else
        if(!(net->priv->tn_subneg == 0))
          goto __CPROVER_DUMP_L14;

        else
        {
          buf[(signed long int)j] = c;
          j = j + 1;
        }

  __CPROVER_DUMP_L14:
    ;
  }
  *len = j;
}

// gm_net_init
// file gm-net.c line 183
static void gm_net_init(struct _GmNet *net)
{
  unsigned long int return_value_gm_net_get_type$1;
  return_value_gm_net_get_type$1=gm_net_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)net, return_value_gm_net_get_type$1);
  net->priv = (struct _GmNetPrivate *)return_value_g_type_instance_get_private$2;
  net->priv->state = (enum _GmNetState)GM_NET_STATE_DISCONNECTED;
  net->priv->addr = (struct addrinfo *)(void *)0;
  net->priv->current = (struct addrinfo *)(void *)0;
  net->priv->channel = (struct _GIOChannel *)(void *)0;
  net->priv->source = (unsigned int)0;
  net->priv->connect_timeout_id = (unsigned int)0;
  net->priv->connect_check_id = (unsigned int)0;
  pthread_mutex_init(&net->priv->mutex_idle, (const union anonymous$67 *)(void *)0);
}

// gm_net_new
// file gm-net.c line 535
struct _GmNet * gm_net_new(void)
{
  struct _GmNet *net;
  unsigned long int return_value_gm_net_get_type$1;
  return_value_gm_net_get_type$1=gm_net_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_net_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_net_get_type$3;
  return_value_gm_net_get_type$3=gm_net_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_net_get_type$3);
  net = (struct _GmNet *)return_value_g_type_check_instance_cast$4;
  return net;
}

// gm_net_send
// file gm-net.c line 604
void gm_net_send(struct _GmNet *net, char *text)
{
  signed int result;
  struct anonymous$75 connect_set;
  _Bool tmp_if_expr$9;
  signed int *return_value___errno_location$6;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$7;
  if((signed int)net->priv->state == GM_NET_STATE_CONNECTED)
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmNet.Send: %s", text);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(text);
    signed long int return_value_send$5;
    return_value_send$5=send(net->priv->socket, (const void *)text, return_value_strlen$4, 0);
    result = (signed int)return_value_send$5;
    if(result == -1)
    {
      return_value___errno_location$6=__errno_location();
      if(*return_value___errno_location$6 == 11)
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value___errno_location$7=__errno_location();
        tmp_if_expr$8 = *return_value___errno_location$7 == 11 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
    {
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$75) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&connect_set)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&connect_set)->__fds_bits[(signed long int)(net->priv->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&connect_set)->__fds_bits[(signed long int)(net->priv->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << net->priv->socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      select(net->priv->socket + 1, (struct anonymous$75 *)(void *)0, &connect_set, (struct anonymous$75 *)(void *)0, (struct timeval *)(void *)0);
    }

    else
      if(result == -1)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        gm_debug_msg(DEBUG_DEFAULT, "GmNet.Send: error on sending line: %s", return_value_strerror$2);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        gm_net_dirty_disconnection(net, *return_value___errno_location$3);
      }

  }

  else
  {
    char *return_value_gettext$10;
    return_value_gettext$10=gettext("Not connected");
    g_signal_emit((void *)net, net_signals[(signed long int)2], (unsigned int)0, return_value_gettext$10, 2);
    gm_debug_msg(DEBUG_DEFAULT, "GmNet.Send: not connected!");
  }
}

// gm_net_send_line
// file gm-net.c line 595
void gm_net_send_line(struct _GmNet *net, char *line)
{
  char *send_line;
  char *return_value_g_strconcat$1;
  return_value_g_strconcat$1=g_strconcat(line, (const void *)"\r\n", (void *)0);
  send_line = (char *)return_value_g_strconcat$1;
  gm_net_send(net, send_line);
  g_free((void *)send_line);
}

// gm_net_set_host
// file gm-net.c line 198
static void gm_net_set_host(struct _GmNet *net, const char *host)
{
  g_free((void *)net->priv->current_host);
  net->priv->current_host=g_strdup(host);
}

// gm_net_set_port
// file gm-net.c line 204
static void gm_net_set_port(struct _GmNet *net, const char *port)
{
  g_free((void *)net->priv->current_port);
  net->priv->current_port=g_strdup(port);
}

// gm_net_set_state
// file gm-net.c line 210
void gm_net_set_state(struct _GmNet *net, enum _GmNetState state)
{
  g_signal_emit((void *)net, net_signals[(signed long int)0], (unsigned int)0, state);
  net->priv->state = state;
  g_signal_emit((void *)net, net_signals[(signed long int)1], (unsigned int)0, state);
}

// gm_net_state
// file gm-net.c line 542
enum _GmNetState gm_net_state(struct _GmNet *net)
{
  return net->priv->state;
}

// gm_notebook_focus_from_label
// file gm-support.c line 566
void gm_notebook_focus_from_label(struct _GtkNotebook *note, char *caption)
{
  signed int p;
  p=gtk_notebook_get_n_pages(note);
  signed int i;
  struct _GtkWidget *child;
  i = 0;
  for( ; !(i >= p); i = i + 1)
  {
    child=gtk_notebook_get_nth_page(note, i);
    const char *return_value_gtk_notebook_get_tab_label_text$1;
    return_value_gtk_notebook_get_tab_label_text$1=gtk_notebook_get_tab_label_text(note, child);
    signed int return_value_g_strcasecmp$2;
    return_value_g_strcasecmp$2=g_strcasecmp(return_value_gtk_notebook_get_tab_label_text$1, caption);
    if(return_value_g_strcasecmp$2 == 0)
    {
      gtk_notebook_set_current_page(note, i);
      break;
    }

  }
}

// gm_open_url
// file ./gm-support.h line 132
void gm_open_url(const char *url)
{
  _Bool tmp_if_expr$1;
  if(url == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*url == 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    char *return_value_strstr$2;
    return_value_strstr$2=strstr(url, "://");
    if(return_value_strstr$2 == ((char *)NULL))
    {
      char *tmp;
      tmp=g_strconcat("http://", url, (void *)0);
      gnome_url_show(tmp, (struct _GError **)(void *)0);
      g_free((void *)tmp);
      goto __CPROVER_DUMP_L4;
    }

    gnome_url_show(url, (struct _GError **)(void *)0);
  }


__CPROVER_DUMP_L4:
  ;
}

// gm_open_world_dialog_create_tree_view
// file dialogs/gm-open-world-dialog.c line 39
struct _GtkWidget * gm_open_world_dialog_create_tree_view(char *widget_name, char *string1, char *string2, signed int int1, signed int int2)
{
  struct _GtkWidget *tree_view;
  tree_view=gm_worlds_view_new();
  g_signal_connect_data((void *)tree_view, "row-activated", (void (*)(void))on_gm_open_world_dialog_tree_view_worlds_row_activated, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$1);
  gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$3);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast$4;
}

// gm_open_world_dialog_open_selected_worlds
// file dialogs/gm-open-world-dialog.c line 85
static void gm_open_world_dialog_open_selected_worlds()
{
  struct _GtkTreeView *tree_view;
  struct _GtkWidget *return_value_gm_open_world_dialog_widget$1;
  return_value_gm_open_world_dialog_widget$1=gm_open_world_dialog_widget("tree_view_worlds");
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_open_world_dialog_widget$1, return_value_gtk_tree_view_get_type$2);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gm_worlds_view_get_type$4;
  return_value_gm_worlds_view_get_type$4=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gm_worlds_view_get_type$4);
  model=gm_worlds_view_model((struct _GmWorldsView *)return_value_g_type_check_instance_cast$5);
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(tree_view);
  struct _GtkTreeIter iter;
  struct _GList *paths;
  paths=gtk_tree_selection_get_selected_rows(selection, &model);
  struct _GList *node;
  struct _GmWorld *world;
  if(!(paths == ((struct _GList *)NULL)))
  {
    node = paths;
    for( ; !(node == ((struct _GList *)NULL)); node = node->next)
    {
      gtk_tree_model_get_iter(model, &iter, (struct _GtkTreePath *)node->data);
      gtk_tree_model_get(model, &iter, 2, &world, -1);
      if(!(world == ((struct _GmWorld *)NULL)))
        gm_world_load(world);

      gtk_tree_path_free((struct _GtkTreePath *)node->data);
    }
    g_list_free(paths);
  }

  else
  {
    char *return_value_gettext$6;
    return_value_gettext$6=gettext("You first need to select a world to connect to.");
    unsigned long int return_value_gtk_window_get_type$7;
    return_value_gtk_window_get_type$7=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)gm_open_world_dialog_instance->dialog, return_value_gtk_window_get_type$7);
    gm_error_dialog(return_value_gettext$6, (struct _GtkWindow *)return_value_g_type_check_instance_cast$8);
  }
}

// gm_open_world_dialog_run
// file ./dialogs/gm-open-world-dialog.h line 4
void gm_open_world_dialog_run()
{
  struct _GladeXML *xml;
  if(!(gm_open_world_dialog_instance == ((struct _GmOpenWorldDialog *)NULL)))
  {
    gtk_widget_show(gm_open_world_dialog_instance->dialog);
    unsigned long int return_value_gtk_window_get_type$1;
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gm_open_world_dialog_instance->dialog, return_value_gtk_window_get_type$1);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
    goto __CPROVER_DUMP_L3;
  }

  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-open-world.glade", "gm_open_world_dialog", (const char *)(void *)0);
  if(xml == ((struct _GladeXML *)NULL))
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-open-world.glade");

  else
  {
    void *return_value_g_malloc0_n$3;
    return_value_g_malloc0_n$3=g_malloc0_n((unsigned long int)1, sizeof(struct _GmOpenWorldDialog) /*16ul*/ );
    gm_open_world_dialog_instance = (struct _GmOpenWorldDialog *)return_value_g_malloc0_n$3;
    gm_open_world_dialog_instance->xml = xml;
    gm_open_world_dialog_instance->dialog=gm_open_world_dialog_widget("gm_open_world_dialog");
    unsigned long int return_value_gtk_window_get_type$4;
    return_value_gtk_window_get_type$4=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)gm_open_world_dialog_instance->dialog, return_value_gtk_window_get_type$4);
    struct _GdkPixbuf *return_value_gm_pixbuf_get$6;
    return_value_gm_pixbuf_get$6=gm_pixbuf_get("world.svg");
    gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, return_value_gm_pixbuf_get$6);
    g_signal_connect_data((void *)gm_open_world_dialog_instance->dialog, "response", (void (*)(void))on_gm_open_world_dialog_response, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    gtk_widget_show(gm_open_world_dialog_instance->dialog);
  }

__CPROVER_DUMP_L3:
  ;
}

// gm_open_world_dialog_widget
// file dialogs/gm-open-world-dialog.c line 31
struct _GtkWidget * gm_open_world_dialog_widget(char *name)
{
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(gm_open_world_dialog_instance->xml, name);
  return return_value_glade_xml_get_widget$1;
}

// gm_options_class_init
// file gm-options.c line 48
static void gm_options_class_init(struct _GmOptionsClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_options_finalize;
  options_signals[(signed long int)0]=g_signal_new("option_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)136ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmOptionsPrivate) /*16ul*/ );
}

// gm_options_class_intern_init
// file gm-options.c line 35
static void gm_options_class_intern_init(void *klass)
{
  gm_options_parent_class=g_type_class_peek_parent(klass);
  if(!(GmOptions_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmOptions_private_offset);

  gm_options_class_init((struct _GmOptionsClass *)klass);
}

// gm_options_dup
// file gm-options.c line 125
struct _GmOptions * gm_options_dup(struct _GmOptions *source)
{
  struct _GmOptions *copy;
  copy=gm_options_new();
  g_hash_table_foreach(source->priv->options, (void (*)(void *, void *, void *))gm_options_dup_option, (void *)copy);
  return copy;
}

// gm_options_dup_option
// file gm-options.c line 111
static void gm_options_dup_option(char *key, char *value, struct _GmOptions *copy)
{
  gm_options_set(copy, key, value);
}

// gm_options_finalize
// file gm-options.c line 38
static void gm_options_finalize(struct _GObject *object)
{
  struct _GmOptions *options;
  unsigned long int return_value_gm_options_get_type$1;
  return_value_gm_options_get_type$1=gm_options_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_options_get_type$1);
  options = (struct _GmOptions *)return_value_g_type_check_instance_cast$2;
  g_hash_table_destroy(options->priv->options);
  g_free((void *)options->priv->filepath);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_options_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_options_get
// file ./gm-options.h line 58
const char * gm_options_get(struct _GmOptions *options, const char *key)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(options->priv->options, (const void *)key);
  return (const char *)return_value_g_hash_table_lookup$1;
}

// gm_options_get_int
// file ./gm-options.h line 60
signed int gm_options_get_int(struct _GmOptions *options, const char *key)
{
  const char *val;
  val=gm_options_get(options, key);
  signed int ret;
  _Bool tmp_if_expr$2;
  signed int return_value_gm_string_to_int$1;
  if(!(val == ((const char *)NULL)))
  {
    return_value_gm_string_to_int$1=gm_string_to_int(val, &ret);
    tmp_if_expr$2 = return_value_gm_string_to_int$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    return ret;

  else
    return 0;
}

// gm_options_get_type
// file ./gm-options.h line 53
unsigned long int gm_options_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmOptions");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmOptionsClass) /*144ul*/ , (void (*)(void *, void *))gm_options_class_intern_init, (unsigned int)sizeof(struct _GmOptions) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_options_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_options_init
// file gm-options.c line 68
static void gm_options_init(struct _GmOptions *options)
{
  unsigned long int return_value_gm_options_get_type$1;
  return_value_gm_options_get_type$1=gm_options_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)options, return_value_gm_options_get_type$1);
  options->priv = (struct _GmOptionsPrivate *)return_value_g_type_instance_get_private$2;
  options->priv->options=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
  options->priv->filepath = (char *)(void *)0;
}

// gm_options_load
// file ./gm-options.h line 65
signed int gm_options_load(struct _GmOptions *options, const char *filename)
{
  struct _xmlDoc *doc;
  struct _xmlNode *root;
  gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load: loading options (%s)!", filename);
  g_free((void *)options->priv->filepath);
  options->priv->filepath=g_strdup(filename);
  signed int return_value_g_file_test$1;
  return_value_g_file_test$1=g_file_test(filename, (enum anonymous$106)G_FILE_TEST_EXISTS);
  if(return_value_g_file_test$1 == 0)
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load: file does not exist");
    return 0;
  }

  else
  {
    doc=xmlParseFile(filename);
    if(doc == ((struct _xmlDoc *)NULL))
    {
      gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load: error on parsing options file");
      return 0;
    }

    else
    {
      root=xmlDocGetRootElement(doc);
      if(root == ((struct _xmlNode *)NULL))
      {
        xmlFreeDoc(doc);
        return 0;
      }

      else
      {
        signed int return_value_xmlStrcmp$2;
        return_value_xmlStrcmp$2=xmlStrcmp(root->name, (const unsigned char *)"options");
        if(!(return_value_xmlStrcmp$2 == 0))
        {
          gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load: invalid root node");
          xmlFreeDoc(doc);
          return 0;
        }

        else
        {
          root = root->children;
          for( ; !(root == ((struct _xmlNode *)NULL)); root = root->next)
          {
            signed int return_value_xmlStrcmp$3;
            return_value_xmlStrcmp$3=xmlStrcmp(root->name, (const unsigned char *)"option");
            if(return_value_xmlStrcmp$3 == 0)
              gm_options_load_option(options, doc, root);

          }
          xmlFreeDoc(doc);
          return (signed int)!(0 != 0);
        }
      }
    }
  }
}

// gm_options_load_option
// file gm-options.c line 76
static void gm_options_load_option(struct _GmOptions *options, struct _xmlDoc *doc, struct _xmlNode *ptr)
{
  unsigned char *key;
  unsigned char *value;
  key=xmlGetProp(ptr, (const unsigned char *)"key");
  value=xmlGetProp(ptr, (const unsigned char *)"value");
  if(key == ((unsigned char *)NULL))
    gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load_option: key not present in option");

  else
    if(value == ((unsigned char *)NULL))
      gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load_option: value not present in option");

    else
    {
      gm_debug_msg(DEBUG_DEFAULT, "GmOptions.load_option: adding option %s: %s", key, value);
      gm_options_set(options, (const char *)key, (const char *)value);
    }
  xmlFree((void *)key);
  xmlFree((void *)value);
}

// gm_options_new
// file ./gm-options.h line 54
struct _GmOptions * gm_options_new(void)
{
  struct _GmOptions *options;
  unsigned long int return_value_gm_options_get_type$1;
  return_value_gm_options_get_type$1=gm_options_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_options_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_options_get_type$3;
  return_value_gm_options_get_type$3=gm_options_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_options_get_type$3);
  options = (struct _GmOptions *)return_value_g_type_check_instance_cast$4;
  return options;
}

// gm_options_remove
// file ./gm-options.h line 61
void gm_options_remove(struct _GmOptions *options, const char *key)
{
  g_hash_table_remove(options->priv->options, (const void *)key);
}

// gm_options_save
// file ./gm-options.h line 63
void gm_options_save(struct _GmOptions *options)
{
  struct _xmlDoc *doc;
  struct _xmlNode *root;
  if(!(options->priv->filepath == ((char *)NULL)))
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmOptions.save: saving options (%s)!", options->priv->filepath);
    doc=xmlNewDoc((const unsigned char *)"1.0");
    root=xmlNewNode((struct _xmlNs *)(void *)0, (const unsigned char *)"options");
    xmlDocSetRootElement(doc, root);
    g_hash_table_foreach(options->priv->options, (void (*)(void *, void *, void *))gm_options_save_option, (void *)root);
    xmlSaveFormatFileEnc(options->priv->filepath, doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    chmod(options->priv->filepath, (unsigned int)0660);
  }

}

// gm_options_save_as
// file gm-options.c line 210
void gm_options_save_as(struct _GmOptions *options, const char *filename)
{
  g_free((void *)options->priv->filepath);
  options->priv->filepath=g_strdup(filename);
  gm_options_save(options);
}

// gm_options_save_option
// file gm-options.c line 99
static void gm_options_save_option(char *key, char *value, struct _xmlNode *root)
{
  struct _xmlNode *option;
  gm_debug_msg(DEBUG_DEFAULT, "GmOptions.SaveValue: saving %s, %s", key, value);
  option=xmlNewChild(root, (struct _xmlNs *)(void *)0, (const unsigned char *)"option", (const unsigned char *)(void *)0);
  xmlNewProp(option, (const unsigned char *)"key", (const unsigned char *)key);
  xmlNewProp(option, (const unsigned char *)"value", (const unsigned char *)value);
}

// gm_options_set
// file ./gm-options.h line 57
void gm_options_set(struct _GmOptions *options, const char *key, const char *value)
{
  char *trimmed;
  trimmed=gm_string_trim(key);
  char *lookup;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(options->priv->options, (const void *)trimmed);
  lookup = (char *)return_value_g_hash_table_lookup$1;
  signed int changed = (signed int)(lookup != (char *)(void *)0 && lookup != value);
  if(!(lookup == value))
  {
    char *return_value_g_strdup$2;
    return_value_g_strdup$2=g_strdup(trimmed);
    char *return_value_g_strdup$3;
    return_value_g_strdup$3=g_strdup(value);
    g_hash_table_insert(options->priv->options, (void *)return_value_g_strdup$2, (void *)return_value_g_strdup$3);
  }

  if(!(changed == 0))
    g_signal_emit((void *)options, options_signals[(signed long int)0], (unsigned int)0, trimmed);

  g_free((void *)trimmed);
}

// gm_options_set_int
// file ./gm-options.h line 59
void gm_options_set_int(struct _GmOptions *options, const char *key, signed int value)
{
  char val[15l];
  g_snprintf((char *)&val, (unsigned long int)15, "%d", value);
  gm_options_set(options, key, (const char *)val);
}

// gm_pixbuf_add_directory
// file gm-pixbuf.c line 72
void gm_pixbuf_add_directory(const char *directory)
{
  char *return_value_g_strdup$1;
  return_value_g_strdup$1=g_strdup(directory);
  gm_pixbuf_directories=g_list_prepend(gm_pixbuf_directories, (void *)return_value_g_strdup$1);
}

// gm_pixbuf_create
// file gm-pixbuf.c line 191
struct _GdkPixbuf * gm_pixbuf_create(const char *filename, signed int width, signed int height)
{
  char *pathname = (char *)(void *)0;
  char *ext;
  struct _GdkPixbuf *pixbuf = (struct _GdkPixbuf *)(void *)0;
  struct _GError *error = (struct _GError *)(void *)0;
  _Bool tmp_if_expr$1;
  if(filename == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*filename == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (struct _GdkPixbuf *)(void *)0;

  else
  {
    pathname=gm_pixbuf_find(filename);
    if(pathname == ((char *)NULL))
    {
      gm_debug_msg(DEBUG_DEFAULT, "gm_pixbuf_create: couldn't find pixbuf file: %s", filename);
      return (struct _GdkPixbuf *)(void *)0;
    }

    else
    {
      ext=rindex(pathname, 46);
      if(!(height >= 1) || !(width >= 1))
        pixbuf=gdk_pixbuf_new_from_file(pathname, &error);

      else
        pixbuf=gdk_pixbuf_new_from_file_at_size(pathname, width, height, &error);
      if(pixbuf == ((struct _GdkPixbuf *)NULL))
      {
        gm_debug_msg(DEBUG_DEFAULT, "gm_pixbuf_create: failed to load pixbuf from file: %s: %s\n", pathname, error->message);
        g_error_free(error);
        error = (struct _GError *)(void *)0;
      }

      g_free((void *)pathname);
      return pixbuf;
    }
  }
}

// gm_pixbuf_create_save_close
// file gm-pixbuf.c line 21
static struct _GdkPixbuf * gm_pixbuf_create_save_close()
{
  struct _GError *error = (struct _GError *)(void *)0;
  struct _GtkIconTheme *icon_theme;
  struct _GdkPixbuf *pixbuf;
  struct _GdkPixbuf *gm_pixbuf_create_save_close$$1$$close;
  struct _GdkPixbuf *save;
  signed int w1;
  signed int h1;
  signed int w2;
  signed int h2;
  icon_theme=gtk_icon_theme_get_default();
  gtk_icon_size_lookup((enum anonymous$21)GTK_ICON_SIZE_LARGE_TOOLBAR, &w1, &h1);
  save=gtk_icon_theme_load_icon(icon_theme, "gtk-save", w1, (enum anonymous$86)GTK_ICON_LOOKUP_USE_BUILTIN, &error);
  if(!(error == ((struct _GError *)NULL)))
  {
    g_error_free(error);
    error = (struct _GError *)(void *)0;
  }

  if(save == ((struct _GdkPixbuf *)NULL))
  {
    gm_debug_msg(DEBUG_DEFAULT, "Couldn't find save icon for the save and close composite icon");
    struct _GdkPixbuf *return_value_gm_pixbuf_get$1;
    return_value_gm_pixbuf_get$1=gm_pixbuf_get("saveclose.xpm");
    return return_value_gm_pixbuf_get$1;
  }

  w1=gdk_pixbuf_get_width(save);
  h1=gdk_pixbuf_get_height(save);
  pixbuf=gdk_pixbuf_copy(save);
  g_object_unref((void *)save);
  w2 = w1 / 2;
  h2 = h1 / 2;
  gm_pixbuf_create_save_close$$1$$close=gtk_icon_theme_load_icon(icon_theme, "gtk-close", w2, (enum anonymous$86)0, &error);
  if(!(error == ((struct _GError *)NULL)))
    g_error_free(error);

  if(gm_pixbuf_create_save_close$$1$$close == ((struct _GdkPixbuf *)NULL))
  {
    gm_debug_msg(DEBUG_DEFAULT, "Couldn't find close icon for the save and close composite icon");
    struct _GdkPixbuf *return_value_gm_pixbuf_get$2;
    return_value_gm_pixbuf_get$2=gm_pixbuf_get("saveclose.xpm");
    return return_value_gm_pixbuf_get$2;
  }

  gdk_pixbuf_composite(gm_pixbuf_create_save_close$$1$$close, pixbuf, w1 - w2, 0, w2, h2, (double)(w1 - w2), (double)0, (double)1, (double)1, (enum anonymous$87)GDK_INTERP_NEAREST, 255);
  g_object_unref((void *)gm_pixbuf_create_save_close$$1$$close);
  return pixbuf;
}

// gm_pixbuf_create_stock24
// file gm-pixbuf.c line 78
static struct _GtkIconSource * gm_pixbuf_create_stock24(struct _GdkPixbuf *pixbuf)
{
  struct _GtkIconSource *source;
  struct _GdkPixbuf *scaled;
  signed int w;
  signed int h;
  enum anonymous$84 return_value_gdk_pixbuf_get_colorspace$1;
  return_value_gdk_pixbuf_get_colorspace$1=gdk_pixbuf_get_colorspace(pixbuf);
  signed int return_value_gdk_pixbuf_get_has_alpha$2;
  return_value_gdk_pixbuf_get_has_alpha$2=gdk_pixbuf_get_has_alpha(pixbuf);
  signed int return_value_gdk_pixbuf_get_bits_per_sample$3;
  return_value_gdk_pixbuf_get_bits_per_sample$3=gdk_pixbuf_get_bits_per_sample(pixbuf);
  scaled=gdk_pixbuf_new(return_value_gdk_pixbuf_get_colorspace$1, return_value_gdk_pixbuf_get_has_alpha$2, return_value_gdk_pixbuf_get_bits_per_sample$3, 24, 24);
  gdk_pixbuf_fill(scaled, 0xffffff00);
  w=gdk_pixbuf_get_width(pixbuf);
  h=gdk_pixbuf_get_height(pixbuf);
  gdk_pixbuf_copy_area(pixbuf, 0, 0, w, h, scaled, (24 - w) / 2, (24 - h) / 2);
  source=gtk_icon_source_new();
  gtk_icon_source_set_pixbuf(source, scaled);
  gtk_icon_source_set_size(source, (enum anonymous$21)GTK_ICON_SIZE_LARGE_TOOLBAR);
  return source;
}

// gm_pixbuf_find
// file gm-pixbuf.c line 164
char * gm_pixbuf_find(const char *filename)
{
  struct _GList *elem;
  if(filename == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    signed int return_value_g_file_test$2;
    return_value_g_file_test$2=g_file_test(filename, (enum anonymous$106)G_FILE_TEST_EXISTS);
    if(!(return_value_g_file_test$2 == 0))
    {
      char *return_value_g_strdup$1;
      return_value_g_strdup$1=g_strdup(filename);
      return return_value_g_strdup$1;
    }

    elem = gm_pixbuf_directories;
    for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
    {
      char *pathname;
      pathname=g_strdup_printf("%s%s%s", (char *)elem->data, (const void *)"/", filename);
      signed int return_value_g_file_test$3;
      return_value_g_file_test$3=g_file_test(pathname, (enum anonymous$106)G_FILE_TEST_EXISTS);
      if(!(return_value_g_file_test$3 == 0))
        return pathname;

      g_free((void *)pathname);
    }
    return (char *)(void *)0;
  }
}

// gm_pixbuf_fini
// file gm-pixbuf.h line 18
void gm_pixbuf_fini()
{
  struct _GList *l;
  struct _GmPixbufInfo *i;
  l = gm_pixbuf_directories;
  for( ; !(l == ((struct _GList *)NULL)); l = l->next)
    g_free(l->data);
  g_list_free(gm_pixbuf_directories);
  l = gm_pixbufs;
  for( ; !(l == ((struct _GList *)NULL)); l = l->next)
  {
    i = (struct _GmPixbufInfo *)l->data;
    g_free((void *)i->name);
    g_object_unref((void *)i->pixbuf);
    g_free((void *)i);
  }
  g_list_free(gm_pixbufs);
  gtk_icon_factory_remove_default(factory);
  g_object_unref((void *)factory);
}

// gm_pixbuf_get
// file ./gm-pixbuf.h line 22
struct _GdkPixbuf * gm_pixbuf_get(const char *filename)
{
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$1;
  return_value_gm_pixbuf_get_at_size$1=gm_pixbuf_get_at_size(filename, -1, -1);
  return return_value_gm_pixbuf_get_at_size$1;
}

// gm_pixbuf_get_at_size
// file ./gm-pixbuf.h line 23
struct _GdkPixbuf * gm_pixbuf_get_at_size(const char *filename, signed int width, signed int height)
{
  struct _GdkPixbuf *pix;
  struct _GList *elem;
  struct _GmPixbufInfo *i;
  _Bool tmp_if_expr$1;
  if(filename == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*filename == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (struct _GdkPixbuf *)(void *)0;

  else
  {
    elem = gm_pixbufs;
    for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
    {
      i = (struct _GmPixbufInfo *)elem->data;
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(i->name, filename);
      if(return_value_strcmp$2 == 0)
      {
        if(i->width == width)
        {
          if(i->height == height)
            return i->pixbuf;

        }

      }

    }
    pix=gm_pixbuf_create(filename, width, height);
    if(!(pix == ((struct _GdkPixbuf *)NULL)))
    {
      void *return_value_g_malloc_n$3;
      return_value_g_malloc_n$3=g_malloc_n((unsigned long int)1, sizeof(struct _GmPixbufInfo) /*24ul*/ );
      i = (struct _GmPixbufInfo *)return_value_g_malloc_n$3;
      i->name=g_strdup(filename);
      i->width = width;
      i->height = height;
      i->pixbuf = pix;
      gm_pixbufs=g_list_append(gm_pixbufs, (void *)i);
      return pix;
    }

    else
      return (struct _GdkPixbuf *)(void *)0;
  }
}

// gm_pixbuf_init
// file gm-pixbuf.h line 17
void gm_pixbuf_init()
{
  struct _GtkIconTheme *theme;
  gm_pixbuf_add_directory("/usr/share/gnoemoe/pixmaps");
  theme=gtk_icon_theme_get_default();
  g_signal_connect_data((void *)theme, "changed", (void (*)(void))on_gm_pixbuf_theme_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  factory=gtk_icon_factory_new();
  gtk_icon_factory_add_default(factory);
  gm_pixbuf_populate_factory();
}

// gm_pixbuf_populate_factory
// file gm-pixbuf.c line 104
void gm_pixbuf_populate_factory()
{
  struct _GdkPixbuf *pixbuf;
  pixbuf=gm_pixbuf_create_save_close();
  struct _GtkIconSet *set;
  struct _GtkIconSource *source;
  set=gtk_icon_set_new_from_pixbuf(pixbuf);
  signed int return_value_gdk_pixbuf_get_width$1;
  return_value_gdk_pixbuf_get_width$1=gdk_pixbuf_get_width(pixbuf);
  if(!(return_value_gdk_pixbuf_get_width$1 >= 24))
  {
    source=gm_pixbuf_create_stock24(pixbuf);
    gtk_icon_set_add_source(set, source);
    gtk_icon_source_free(source);
  }

  gtk_icon_factory_add(factory, "gm-stock-save-close", set);
  g_object_unref((void *)pixbuf);
}

// gm_pixbuf_set_alpha
// file gm-pixbuf.c line 267
void gm_pixbuf_set_alpha(struct _GdkPixbuf **pixs, unsigned char alpha)
{
  signed int width;
  signed int height;
  signed int n_channels;
  signed int rowstride;
  signed int y;
  signed int x;
  struct _GdkPixbuf *pix;
  unsigned char *pixels;
  unsigned char *p;
  signed int return_value_gdk_pixbuf_get_has_alpha$1;
  return_value_gdk_pixbuf_get_has_alpha$1=gdk_pixbuf_get_has_alpha(*pixs);
  if(return_value_gdk_pixbuf_get_has_alpha$1 == 0)
  {
    pix=gdk_pixbuf_add_alpha(*pixs, 0, (unsigned char)0, (unsigned char)0, (unsigned char)0);
    gdk_pixbuf_unref(*pixs);
  }

  else
    pix = *pixs;
  n_channels=gdk_pixbuf_get_n_channels(pix);
  enum anonymous$84 return_value_gdk_pixbuf_get_colorspace$2;
  return_value_gdk_pixbuf_get_colorspace$2=gdk_pixbuf_get_colorspace(pix);
  _Bool tmp_if_expr$4;
  signed int return_value_gdk_pixbuf_get_bits_per_sample$3;
  if(!((signed int)return_value_gdk_pixbuf_get_colorspace$2 == GDK_COLORSPACE_RGB))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_gdk_pixbuf_get_bits_per_sample$3=gdk_pixbuf_get_bits_per_sample(pix);
    tmp_if_expr$4 = return_value_gdk_pixbuf_get_bits_per_sample$3 != 8 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$6;
  signed int return_value_gdk_pixbuf_get_has_alpha$5;
  if(tmp_if_expr$4)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_gdk_pixbuf_get_has_alpha$5=gdk_pixbuf_get_has_alpha(pix);
    tmp_if_expr$6 = !(return_value_gdk_pixbuf_get_has_alpha$5 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(!(n_channels == 4) || tmp_if_expr$6)
    *pixs = pix;

  else
  {
    width=gdk_pixbuf_get_width(pix);
    height=gdk_pixbuf_get_height(pix);
    rowstride=gdk_pixbuf_get_rowstride(pix);
    pixels=gdk_pixbuf_get_pixels(pix);
    p = pixels;
    y = 0;
    for( ; !(y >= height); y = y + 1)
    {
      x = 0;
      for( ; !(x >= width); x = x + 1)
      {
        p[(signed long int)3] = alpha;
        p = p + (signed long int)n_channels;
      }
    }
    *pixs = pix;
  }
}

// gm_playerdb_player_info_get_prop
// file mcp/gm-mcp-icecrew-playerdb.c line 142
const char * gm_playerdb_player_info_get_prop(struct _GmPlayerdbPlayerInfo *ppi, const char *key)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(ppi->values, (const void *)key);
  return (const char *)return_value_g_hash_table_lookup$1;
}

// gm_preferences_dialog_init_combo_box_scheme
// file dialogs/gm-preferences-dialog.c line 140
void gm_preferences_dialog_init_combo_box_scheme()
{
  struct _GtkComboBox *box;
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$1;
  return_value_gm_preferences_dialog_widget$1=gm_preferences_dialog_widget("combo_box_scheme");
  unsigned long int return_value_gtk_combo_box_get_type$2;
  return_value_gtk_combo_box_get_type$2=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$1, return_value_gtk_combo_box_get_type$2);
  box = (struct _GtkComboBox *)return_value_g_type_check_instance_cast$3;
  struct _GtkListStore *store;
  store=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
  struct _GtkCellRenderer *renderer;
  renderer=gtk_cell_renderer_text_new();
  struct _GtkTreeIter iter;
  signed int i;
  signed int gm_preferences_dialog_init_combo_box_scheme$$1$$select = 0;
  const char *scheme;
  struct _GmApp *return_value_gm_app_instance$4;
  return_value_gm_app_instance$4=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$5;
  return_value_gm_app_color_table$5=gm_app_color_table(return_value_gm_app_instance$4);
  scheme=gm_color_table_get_scheme_name(return_value_gm_app_color_table$5);
  unsigned long int return_value_gtk_cell_layout_get_type$6;
  return_value_gtk_cell_layout_get_type$6=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_cell_layout_get_type$6);
  gtk_cell_layout_clear((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$7);
  unsigned long int return_value_gtk_cell_layout_get_type$8;
  return_value_gtk_cell_layout_get_type$8=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_cell_layout_get_type$8);
  gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$9, renderer, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_cell_layout_get_type$10;
  return_value_gtk_cell_layout_get_type$10=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_cell_layout_get_type$10);
  gtk_cell_layout_set_attributes((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$11, renderer, (const void *)"text", 0, (void *)0);
  unsigned long int return_value_gtk_tree_model_get_type$12;
  return_value_gtk_tree_model_get_type$12=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$12);
  gtk_combo_box_set_model(box, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$13);
  i = 0;
  signed int return_value_strcasecmp$15;
  while(!(color_schemes[(signed long int)i].key == ((char *)NULL)))
  {
    gtk_list_store_append(store, &iter);
    char *return_value_gettext$14;
    return_value_gettext$14=gettext(color_schemes[(signed long int)i].key);
    gtk_list_store_set(store, &iter, 0, return_value_gettext$14, 1, color_schemes[(signed long int)i].value, -1);
    if(!(scheme == ((const char *)NULL)))
    {
      return_value_strcasecmp$15=strcasecmp(scheme, color_schemes[(signed long int)i].value);
      if(return_value_strcasecmp$15 == 0)
        gm_preferences_dialog_init_combo_box_scheme$$1$$select = i;

    }

    i = i + 1;
  }
  preferences->user_scheme_index = i - 1;
  gtk_combo_box_set_active(box, gm_preferences_dialog_init_combo_box_scheme$$1$$select);
}

// gm_preferences_dialog_init_logging
// file dialogs/gm-preferences-dialog.c line 210
void gm_preferences_dialog_init_logging()
{
  struct _GtkWidget *check;
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$1);
  const char **entry;
  char *name;
  check=gm_preferences_dialog_widget("check_button_logging_disable_all");
  glade_xml_signal_connect(preferences->xml, "on_check_button_logging_disable_all_toggled", (void (*)(void))on_gm_preferences_dialog_check_button_logging_disable_all_toggled);
  unsigned long int return_value_gtk_toggle_button_get_type$2;
  return_value_gtk_toggle_button_get_type$2=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$2);
  signed int return_value_gm_options_get_int$4;
  return_value_gm_options_get_int$4=gm_options_get_int(options, "logging_enable");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$3, (signed int)!(return_value_gm_options_get_int$4 != 0));
  unsigned long int return_value_gtk_toggle_button_get_type$5;
  return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$5);
  gtk_toggle_button_toggled((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6);
  entry = logging_button_names$link1;
  for( ; !(*entry == ((const char *)NULL)); entry = entry + 1l)
  {
    name=g_strconcat("check_button_", *entry, (void *)0);
    check=gm_preferences_dialog_widget(name);
    g_free((void *)name);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)check, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$7, "gm_logging_name", (void *)*entry);
    unsigned long int return_value_gtk_toggle_button_get_type$8;
    return_value_gtk_toggle_button_get_type$8=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$8);
    signed int return_value_gm_options_get_int$10;
    return_value_gm_options_get_int$10=gm_options_get_int(options, *entry);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$9, return_value_gm_options_get_int$10);
    name=g_strconcat("on_check_button_", *entry, (const void *)"_toggled", (void *)0);
    glade_xml_signal_connect(preferences->xml, name, (void (*)(void))on_gm_preferences_dialog_check_button_logging_toggled);
    g_free((void *)name);
  }
}

// gm_preferences_dialog_init_sort_buttons
// file dialogs/gm-preferences-dialog.c line 255
static void gm_preferences_dialog_init_sort_buttons()
{
  signed int id = 0;
  const char **name;
  struct _GtkWidget *widget;
  signed int sort_type;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  sort_type=gm_options_get_int(return_value_gm_app_options$2, "userlist_sort_type");
  name = sort_button_names;
  for( ; !(*name == ((const char *)NULL)); name = name + 1l)
  {
    widget=gm_preferences_dialog_widget(*name);
    if(id == sort_type)
    {
      unsigned long int return_value_gtk_toggle_button_get_type$3;
      return_value_gtk_toggle_button_get_type$3=gtk_toggle_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_toggle_button_get_type$3);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$4, (signed int)!(0 != 0));
    }

    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$5, "gm_userlist_sort_id", (void *)(signed long int)id);
    id = id + 1;
  }
}

// gm_preferences_dialog_run
// file ./dialogs/gm-preferences-dialog.h line 4
void gm_preferences_dialog_run()
{
  const char *alt_editor;
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$1);
  struct _GladeXML *xml;
  if(!(preferences == ((struct _GmPreferencesDialog *)NULL)))
  {
    unsigned long int return_value_gtk_window_get_type$2;
    return_value_gtk_window_get_type$2=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)preferences->dialog, return_value_gtk_window_get_type$2);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$3);
    goto __CPROVER_DUMP_L7;
  }

  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-preferences.glade", "gm_preferences_dialog", (const char *)(void *)0);
  _Bool tmp_if_expr$48;
  signed int return_value_gm_options_get_int$47;
  if(xml == ((struct _GladeXML *)NULL))
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-preferences.glade");

  else
  {
    void *return_value_g_malloc0_n$4;
    return_value_g_malloc0_n$4=g_malloc0_n((unsigned long int)1, sizeof(struct _GmPreferencesDialog) /*24ul*/ );
    preferences = (struct _GmPreferencesDialog *)return_value_g_malloc0_n$4;
    preferences->xml = xml;
    preferences->dialog=gm_preferences_dialog_widget("gm_preferences_dialog");
    gm_preferences_dialog_update_color_buttons((signed int)!(0 != 0));
    gm_preferences_dialog_init_combo_box_scheme();
    gm_preferences_dialog_init_logging();
    glade_xml_signal_connect(preferences->xml, "on_check_button_system_font_clicked", (void (*)(void))on_gm_preferences_dialog_check_button_system_font_clicked);
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$5;
    return_value_gm_preferences_dialog_widget$5=gm_preferences_dialog_widget("check_button_system_font");
    unsigned long int return_value_gtk_toggle_button_get_type$6;
    return_value_gtk_toggle_button_get_type$6=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$5, return_value_gtk_toggle_button_get_type$6);
    struct _GmApp *return_value_gm_app_instance$8;
    return_value_gm_app_instance$8=gm_app_instance();
    struct _GmColorTable *return_value_gm_app_color_table$9;
    return_value_gm_app_color_table$9=gm_app_color_table(return_value_gm_app_instance$8);
    signed int return_value_gm_color_table_get_use_system_font$10;
    return_value_gm_color_table_get_use_system_font$10=gm_color_table_get_use_system_font(return_value_gm_app_color_table$9);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$7, return_value_gm_color_table_get_use_system_font$10);
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$11;
    return_value_gm_preferences_dialog_widget$11=gm_preferences_dialog_widget("font_button_font");
    unsigned long int return_value_gtk_font_button_get_type$12;
    return_value_gtk_font_button_get_type$12=gtk_font_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$11, return_value_gtk_font_button_get_type$12);
    struct _GmApp *return_value_gm_app_instance$14;
    return_value_gm_app_instance$14=gm_app_instance();
    struct _GmColorTable *return_value_gm_app_color_table$15;
    return_value_gm_app_color_table$15=gm_app_color_table(return_value_gm_app_instance$14);
    const char *return_value_gm_color_table_font_description$16;
    return_value_gm_color_table_font_description$16=gm_color_table_font_description(return_value_gm_app_color_table$15);
    gtk_font_button_set_font_name((struct _GtkFontButton *)return_value_g_type_check_instance_cast$13, return_value_gm_color_table_font_description$16);
    alt_editor=gm_options_get(options, "editor_alternative");
    signed int return_value_strcmp$23;
    return_value_strcmp$23=strcmp(alt_editor, "0");
    if(return_value_strcmp$23 == 0)
      alt_editor = (const char *)(void *)0;

    else
    {
      struct _GtkWidget *return_value_gm_preferences_dialog_widget$17;
      return_value_gm_preferences_dialog_widget$17=gm_preferences_dialog_widget("check_button_alt_editor");
      unsigned long int return_value_gtk_toggle_button_get_type$18;
      return_value_gtk_toggle_button_get_type$18=gtk_toggle_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
      return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$17, return_value_gtk_toggle_button_get_type$18);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$19, (signed int)!(0 != 0));
      struct _GtkWidget *return_value_gm_preferences_dialog_widget$20;
      return_value_gm_preferences_dialog_widget$20=gm_preferences_dialog_widget("entry_alt_editor");
      unsigned long int return_value_gtk_entry_get_type$21;
      return_value_gtk_entry_get_type$21=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
      return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$20, return_value_gtk_entry_get_type$21);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$22, alt_editor);
    }
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$24;
    return_value_gm_preferences_dialog_widget$24=gm_preferences_dialog_widget("check_button_embed_editor");
    unsigned long int return_value_gtk_toggle_button_get_type$25;
    return_value_gtk_toggle_button_get_type$25=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
    return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$24, return_value_gtk_toggle_button_get_type$25);
    signed int return_value_gm_options_get_int$27;
    return_value_gm_options_get_int$27=gm_options_get_int(options, "editor_embed");
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$26, return_value_gm_options_get_int$27);
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$28;
    return_value_gm_preferences_dialog_widget$28=gm_preferences_dialog_widget("check_button_needs_terminal");
    unsigned long int return_value_gtk_toggle_button_get_type$29;
    return_value_gtk_toggle_button_get_type$29=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
    return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$28, return_value_gtk_toggle_button_get_type$29);
    signed int return_value_gm_options_get_int$31;
    return_value_gm_options_get_int$31=gm_options_get_int(options, "editor_needs_terminal");
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$30, return_value_gm_options_get_int$31);
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$32;
    return_value_gm_preferences_dialog_widget$32=gm_preferences_dialog_widget("check_button_show_object_number");
    unsigned long int return_value_gtk_toggle_button_get_type$33;
    return_value_gtk_toggle_button_get_type$33=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
    return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$32, return_value_gtk_toggle_button_get_type$33);
    signed int return_value_gm_options_get_int$35;
    return_value_gm_options_get_int$35=gm_options_get_int(options, "userlist_show_object_number");
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$34, return_value_gm_options_get_int$35);
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$36;
    return_value_gm_preferences_dialog_widget$36=gm_preferences_dialog_widget("check_button_show_player_status");
    unsigned long int return_value_gtk_toggle_button_get_type$37;
    return_value_gtk_toggle_button_get_type$37=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
    return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$36, return_value_gtk_toggle_button_get_type$37);
    signed int return_value_gm_options_get_int$39;
    return_value_gm_options_get_int$39=gm_options_get_int(options, "userlist_show_status");
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$38, return_value_gm_options_get_int$39);
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$40;
    return_value_gm_preferences_dialog_widget$40=gm_preferences_dialog_widget("check_button_use_state_icon");
    unsigned long int return_value_gtk_toggle_button_get_type$41;
    return_value_gtk_toggle_button_get_type$41=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
    return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$40, return_value_gtk_toggle_button_get_type$41);
    signed int return_value_gm_options_get_int$43;
    return_value_gm_options_get_int$43=gm_options_get_int(options, "userlist_use_state_icon");
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$42, return_value_gm_options_get_int$43);
    gm_preferences_dialog_init_sort_buttons();
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$44;
    return_value_gm_preferences_dialog_widget$44=gm_preferences_dialog_widget("entry_alt_editor");
    gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$44, (signed int)(alt_editor != (const char *)(void *)0));
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$45;
    return_value_gm_preferences_dialog_widget$45=gm_preferences_dialog_widget("check_button_embed_editor");
    gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$45, (signed int)(alt_editor != (const char *)(void *)0));
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$46;
    return_value_gm_preferences_dialog_widget$46=gm_preferences_dialog_widget("check_button_needs_terminal");
    if(!(alt_editor == ((const char *)NULL)))
    {
      return_value_gm_options_get_int$47=gm_options_get_int(options, "editor_embed");
      tmp_if_expr$48 = return_value_gm_options_get_int$47 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$48 = (_Bool)0;
    gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$46, (signed int)tmp_if_expr$48);
    glade_xml_signal_connect(preferences->xml, "on_font_button_font_font_set", (void (*)(void))on_gm_preferences_dialog_font_set);
    glade_xml_signal_connect(preferences->xml, "on_entry_alt_editor_focus_out", (void (*)(void))on_gm_preferences_dialog_entry_alt_editor_focus_out);
    glade_xml_signal_connect(preferences->xml, "on_check_button_alt_editor_clicked", (void (*)(void))on_gm_preferences_dialog_check_button_alt_editor_clicked);
    glade_xml_signal_connect(preferences->xml, "on_check_button_embed_editor_clicked", (void (*)(void))on_gm_preferences_dialog_check_button_embed_editor_clicked);
    glade_xml_signal_connect(preferences->xml, "on_check_button_needs_terminal_clicked", (void (*)(void))on_gm_preferences_dialog_check_button_needs_terminal_clicked);
    glade_xml_signal_connect(preferences->xml, "on_combo_box_scheme_changed", (void (*)(void))on_gm_preferences_dialog_combo_box_scheme_changed);
    glade_xml_signal_connect(preferences->xml, "on_check_button_show_object_number_toggled", (void (*)(void))on_gm_preferences_dialog_check_button_show_object_number_toggled);
    glade_xml_signal_connect(preferences->xml, "on_check_button_show_player_status_toggled", (void (*)(void))on_gm_preferences_dialog_check_button_show_player_status_toggled);
    glade_xml_signal_connect(preferences->xml, "on_check_button_use_state_icon_toggled", (void (*)(void))on_gm_preferences_dialog_check_button_use_state_icon_toggled);
    glade_xml_signal_connect(preferences->xml, "on_radio_button_sort_toggled", (void (*)(void))on_gm_preferences_dialog_radio_button_sort_toggled);
    gm_preferences_dialog_run_dialog();
  }

__CPROVER_DUMP_L7:
  ;
}

// gm_preferences_dialog_run_dialog
// file dialogs/gm-preferences-dialog.c line 413
void gm_preferences_dialog_run_dialog()
{
  g_signal_connect_data((void *)preferences->dialog, "response", (void (*)(void))on_gm_preferences_dialog_response, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)preferences->dialog, return_value_gtk_widget_get_type$1);
  gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
}

// gm_preferences_dialog_update_color_buttons
// file dialogs/gm-preferences-dialog.c line 177
void gm_preferences_dialog_update_color_buttons(signed int signals)
{
  const struct _GmKeyValuePair *pair;
  struct _GtkColorButton *but;
  struct _GdkColor col;
  struct _GmColorTable *color_table;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  color_table=gm_app_color_table(return_value_gm_app_instance$1);
  pair = color_mapping;
  for( ; !(pair->key == ((char *)NULL)); pair = pair + 1l)
  {
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$2;
    return_value_gm_preferences_dialog_widget$2=gm_preferences_dialog_widget(pair->key);
    unsigned long int return_value_gtk_color_button_get_type$3;
    return_value_gtk_color_button_get_type$3=gtk_color_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$2, return_value_gtk_color_button_get_type$3);
    but = (struct _GtkColorButton *)return_value_g_type_check_instance_cast$4;
    gm_color_table_get(color_table, pair->value, &col);
    gtk_color_button_set_color(but, &col);
    if(!(signals == 0))
      g_signal_connect_data((void *)but, "color-set", (void (*)(void))on_gm_preferences_dialog_color_set, (void *)pair->value, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);

  }
}

// gm_preferences_dialog_widget
// file dialogs/gm-preferences-dialog.c line 135
struct _GtkWidget * gm_preferences_dialog_widget(const char *name)
{
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(preferences->xml, name);
  return return_value_glade_xml_get_widget$1;
}

// gm_question_dialog
// file ./gm-support.h line 125
signed int gm_question_dialog(char *message, struct _GtkWindow *parent)
{
  signed int return_value_gm_dialog$1;
  return_value_gm_dialog$1=gm_dialog(message, (enum anonymous$79)GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, parent);
  return return_value_gm_dialog$1;
}

// gm_read_file
// file ./gm-support.h line 143
char * gm_read_file(const char *fname)
{
  signed int fd;
  char *tmp;
  char *mapped;
  signed long int bytes_total = (signed long int)0;
  if(fname == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    fd=open(fname, 00);
    if(fd == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      gm_debug_msg(DEBUG_DEFAULT, "GmReadFile: file (%s) could not be read: %s", fname, return_value_strerror$2);
      return (char *)(void *)0;
    }

    bytes_total=lseek(fd, (signed long int)0, 2);
    lseek(fd, (signed long int)0, 0);
    if(bytes_total == -1l)
    {
      close(fd);
      return (char *)(void *)0;
    }

    else
    {
      void *return_value_mmap$3;
      return_value_mmap$3=mmap(NULL, (unsigned long int)bytes_total, 0x1, 0x02, fd, (signed long int)0);
      mapped = (char *)return_value_mmap$3;
      if(mapped == (char *)-1)
      {
        close(fd);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        gm_debug_msg(DEBUG_DEFAULT, "GmReadFile: error while mapping file: %s", return_value_strerror$5);
        return (char *)(void *)0;
      }

      signed int return_value_g_utf8_validate$6;
      return_value_g_utf8_validate$6=g_utf8_validate(mapped, bytes_total, (const char **)(void *)0);
      if(!(return_value_g_utf8_validate$6 == 0))
        tmp=g_strndup(mapped, (unsigned long int)bytes_total);

      else
      {
        tmp=g_locale_to_utf8(mapped, bytes_total, (unsigned long int *)(void *)0, (unsigned long int *)(void *)0, (struct _GError **)(void *)0);
        if(tmp == ((char *)NULL))
          tmp=g_convert(mapped, bytes_total, "UTF-8", "ISO-8859-15", (unsigned long int *)(void *)0, (unsigned long int *)(void *)0, (struct _GError **)(void *)0);

        if(tmp == ((char *)NULL))
          tmp=g_convert(mapped, bytes_total, "UTF-8", "ISO-8859-1", (unsigned long int *)(void *)0, (unsigned long int *)(void *)0, (struct _GError **)(void *)0);

      }
      munmap((void *)mapped, (unsigned long int)bytes_total);
      close(fd);
      return tmp;
    }
  }
}

// gm_register_schemed
// file ./gm-support.h line 165
void gm_register_schemed(struct _GtkWidget *widget, struct _GmColorTable *table, enum _GmSchemedFlags flags)
{
  void *data;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  data=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "gm_color_table");
  if(!(data == NULL))
    on_widget_destroy(widget, (void *)(signed long int)flags);

  if(!(table == ((struct _GmColorTable *)NULL)))
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$2, "gm_color_table", (void *)table);
    if(!((GM_SCHEMED_COLORS & (signed int)flags) == 0))
    {
      g_signal_connect_data((void *)table, "color-changed", (void (*)(void))on_color_changed, (void *)widget, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
      on_color_changed(table, "fg_default", widget);
      on_color_changed(table, "bg_default", widget);
    }

    if(!((GM_SCHEMED_FONT & (signed int)flags) == 0))
    {
      g_signal_connect_data((void *)table, "font-changed", (void (*)(void))on_font_changed, (void *)widget, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
      const char *return_value_gm_color_table_font_description$3;
      return_value_gm_color_table_font_description$3=gm_color_table_font_description(table);
      on_font_changed(table, return_value_gm_color_table_font_description$3, widget);
    }

    g_signal_connect_data((void *)widget, "destroy", (void (*)(void))on_widget_destroy, (void *)(signed long int)flags, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  }

}

// gm_scroll_end
// file gm-support.c line 410
void gm_scroll_end(struct _GtkTextView *view, signed int needs)
{
  struct _GtkTextBuffer *buf;
  struct _GtkTextMark *mark;
  struct _GtkTextIter iter;
  if(!(needs == 0))
  {
    buf=gtk_text_view_get_buffer(view);
    mark=gtk_text_buffer_get_mark(buf, "end-of-buffer");
    if(mark == ((struct _GtkTextMark *)NULL))
    {
      gtk_text_buffer_get_end_iter(buf, &iter);
      mark=gtk_text_buffer_create_mark(buf, "end-of-buffer", &iter, 0);
    }

    gtk_text_view_scroll_to_mark(view, mark, 0.0, (signed int)!(0 != 0), 1.0, 1.0);
  }

}

// gm_searchable_can_find
// file widgets/gm-searchable.h line 44
signed int gm_searchable_can_find(struct _GmSearchable *self)
{
  struct _GmSearchableInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_can_find", "GM_IS_SEARCHABLE(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_searchable_get_type$3;
  return_value_gm_searchable_get_type$3=gm_searchable_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_searchable_get_type$3);
  iface = (struct _GmSearchableInterface *)return_value_g_type_interface_peek$4;
  do
    if(iface == ((struct _GmSearchableInterface *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_can_find", "iface != NULL");
      return 0;
    }

  while((_Bool)0);
  _Bool tmp_if_expr$6;
  if(iface->find_first == ((signed int (*)(struct _GmSearchable *, const char *, enum _GmSearchableSearchFlags))NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = iface->find_next == (signed int (*)(struct _GmSearchable *, const char *, enum _GmSearchableSearchFlags))(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$6)
  {
    struct _GtkTextView *return_value_gm_searchable_interface_get_text_view$5;
    return_value_gm_searchable_interface_get_text_view$5=gm_searchable_interface_get_text_view(self, iface);
    if(!(return_value_gm_searchable_interface_get_text_view$5 == ((struct _GtkTextView *)NULL)))
      return (signed int)!(0 != 0);

    else
      return 0;
  }

  else
    return (signed int)!(0 != 0);
}

// gm_searchable_can_replace
// file widgets/gm-searchable.h line 50
signed int gm_searchable_can_replace(struct _GmSearchable *self)
{
  struct _GmSearchableInterface *iface;
  struct _GtkTextView *text_view;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_can_replace", "GM_IS_SEARCHABLE(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_searchable_get_type$3;
  return_value_gm_searchable_get_type$3=gm_searchable_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_searchable_get_type$3);
  iface = (struct _GmSearchableInterface *)return_value_g_type_interface_peek$4;
  do
    if(iface == ((struct _GmSearchableInterface *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_can_replace", "iface != NULL");
      return 0;
    }

  while((_Bool)0);
  _Bool tmp_if_expr$7;
  if(iface->replace == ((signed int (*)(struct _GmSearchable *, const char *))NULL))
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = iface->replace_all == (signed int (*)(struct _GmSearchable *, const char *, const char *, enum _GmSearchableSearchFlags))(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  signed int return_value_gtk_text_view_get_editable$5;
  if(tmp_if_expr$7)
  {
    text_view=gm_searchable_interface_get_text_view(self, iface);
    if(!(text_view == ((struct _GtkTextView *)NULL)))
    {
      return_value_gtk_text_view_get_editable$5=gtk_text_view_get_editable(text_view);
      tmp_if_expr$6 = return_value_gtk_text_view_get_editable$5 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      return (signed int)!(0 != 0);

    else
      return 0;
  }

  else
    return (signed int)!(0 != 0);
}

// gm_searchable_find_first
// file widgets/gm-searchable.h line 45
signed int gm_searchable_find_first(struct _GmSearchable *self, const char *str, enum _GmSearchableSearchFlags flags)
{
  struct _GmSearchableInterface *iface;
  struct _GtkTextView *text_view;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_find_first", "GM_IS_SEARCHABLE(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_searchable_get_type$3;
  return_value_gm_searchable_get_type$3=gm_searchable_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_searchable_get_type$3);
  iface = (struct _GmSearchableInterface *)return_value_g_type_interface_peek$4;
  do
    if(iface == ((struct _GmSearchableInterface *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_find_first", "iface != NULL");
      return 0;
    }

  while((_Bool)0);
  if(iface->find_first == ((signed int (*)(struct _GmSearchable *, const char *, enum _GmSearchableSearchFlags))NULL))
  {
    text_view=gm_searchable_interface_get_text_view(self, iface);
    if(!(text_view == ((struct _GtkTextView *)NULL)))
    {
      signed int return_value_gm_searchable_text_view_find_first$5;
      return_value_gm_searchable_text_view_find_first$5=gm_searchable_text_view_find_first(text_view, str, flags);
      return return_value_gm_searchable_text_view_find_first$5;
    }

    else
    {
      g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", (const void *)"widgets/gm-searchable.c", 712, (const char *)"gm_searchable_find_first");
      return 0;
    }
  }

  signed int return_value;
  return_value=iface->find_first(self, str, flags);
  return return_value;
}

// gm_searchable_find_next
// file widgets/gm-searchable.h line 47
signed int gm_searchable_find_next(struct _GmSearchable *self, const char *str, enum _GmSearchableSearchFlags flags)
{
  struct _GmSearchableInterface *iface;
  struct _GtkTextView *text_view;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_find_next", "GM_IS_SEARCHABLE(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_searchable_get_type$3;
  return_value_gm_searchable_get_type$3=gm_searchable_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_searchable_get_type$3);
  iface = (struct _GmSearchableInterface *)return_value_g_type_interface_peek$4;
  do
    if(iface == ((struct _GmSearchableInterface *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_find_next", "iface != NULL");
      return 0;
    }

  while((_Bool)0);
  if(iface->find_next == ((signed int (*)(struct _GmSearchable *, const char *, enum _GmSearchableSearchFlags))NULL))
  {
    text_view=gm_searchable_interface_get_text_view(self, iface);
    if(!(text_view == ((struct _GtkTextView *)NULL)))
    {
      signed int return_value_gm_searchable_text_view_find_next$5;
      return_value_gm_searchable_text_view_find_next$5=gm_searchable_text_view_find_next(text_view, str, flags);
      return return_value_gm_searchable_text_view_find_next$5;
    }

    else
    {
      g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", (const void *)"widgets/gm-searchable.c", 737, (const char *)"gm_searchable_find_next");
      return 0;
    }
  }

  signed int return_value;
  return_value=iface->find_next(self, str, flags);
  return return_value;
}

// gm_searchable_get_text_view
// file widgets/gm-searchable.c line 663
struct _GtkTextView * gm_searchable_get_text_view(struct _GmSearchable *self)
{
  struct _GmSearchableInterface *iface;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_get_text_view", "GM_IS_SEARCHABLE(self)");
      return ((struct _GtkTextView *)NULL);
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_searchable_get_type$3;
  return_value_gm_searchable_get_type$3=gm_searchable_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_searchable_get_type$3);
  iface = (struct _GmSearchableInterface *)return_value_g_type_interface_peek$4;
  struct _GtkTextView *return_value_gm_searchable_interface_get_text_view$5;
  return_value_gm_searchable_interface_get_text_view$5=gm_searchable_interface_get_text_view(self, iface);
  return return_value_gm_searchable_interface_get_text_view$5;
}

// gm_searchable_get_type
// file widgets/gm-searchable.h line 41
unsigned long int gm_searchable_get_type()
{
  static const struct _GTypeInfo searchable_info = { .class_size=(unsigned short int)sizeof(struct _GmSearchableInterface) /*56ul*/ , .base_init=(void (*)(void *))(void *)0,
    .base_finalize=(void (*)(void *))(void *)0,
    .class_init=(void (*)(void *, void *))(void *)0,
    .class_finalize=(void (*)(void *, void *))(void *)0,
    .class_data=(void *)0,
    .instance_size=(unsigned short int)0, .n_preallocs=(unsigned short int)0,
    .instance_init=(void (*)(struct _GTypeInstance *, void *))(void *)0, .value_table=((const struct _GTypeValueTable *)NULL) };
  static unsigned long int searchable_type = (unsigned long int)0;
  if(searchable_type == 0ul)
    searchable_type=g_type_register_static((unsigned long int)(2 << 2), "GmSearchable", &searchable_info, (enum anonymous)0);

  return searchable_type;
}

// gm_searchable_interface_get_text_view
// file widgets/gm-searchable.c line 651
struct _GtkTextView * gm_searchable_interface_get_text_view(struct _GmSearchable *self, struct _GmSearchableInterface *iface)
{
  do
    if(iface == ((struct _GmSearchableInterface *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_interface_get_text_view", "iface != NULL");
      return ((struct _GtkTextView *)NULL);
    }

  while((_Bool)0);
  if(iface->get_text_view == ((struct _GtkTextView * (*)(struct _GmSearchable *))NULL))
    return (struct _GtkTextView *)(void *)0;

  else
  {
    struct _GtkTextView *return_value;
    return_value=iface->get_text_view(self);
    return return_value;
  }
}

// gm_searchable_replace
// file widgets/gm-searchable.h line 51
signed int gm_searchable_replace(struct _GmSearchable *self, const char *replace)
{
  struct _GmSearchableInterface *iface;
  struct _GtkTextView *text_view;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_replace", "GM_IS_SEARCHABLE(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_searchable_get_type$3;
  return_value_gm_searchable_get_type$3=gm_searchable_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_searchable_get_type$3);
  iface = (struct _GmSearchableInterface *)return_value_g_type_interface_peek$4;
  do
    if(iface == ((struct _GmSearchableInterface *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_replace", "iface != NULL");
      return 0;
    }

  while((_Bool)0);
  _Bool tmp_if_expr$7;
  signed int return_value_gtk_text_view_get_editable$6;
  if(iface->replace == ((signed int (*)(struct _GmSearchable *, const char *))NULL))
  {
    text_view=gm_searchable_interface_get_text_view(self, iface);
    if(!(text_view == ((struct _GtkTextView *)NULL)))
    {
      return_value_gtk_text_view_get_editable$6=gtk_text_view_get_editable(text_view);
      tmp_if_expr$7 = return_value_gtk_text_view_get_editable$6 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
    {
      signed int return_value_gm_searchable_text_view_replace$5;
      return_value_gm_searchable_text_view_replace$5=gm_searchable_text_view_replace(text_view, replace);
      return return_value_gm_searchable_text_view_replace$5;
    }

    else
    {
      g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", (const void *)"widgets/gm-searchable.c", 784, (const char *)"gm_searchable_replace");
      return 0;
    }
  }

  signed int return_value;
  return_value=iface->replace(self, replace);
  return return_value;
}

// gm_searchable_replace_all
// file widgets/gm-searchable.h line 52
signed int gm_searchable_replace_all(struct _GmSearchable *self, const char *str, const char *replace, enum _GmSearchableSearchFlags flags)
{
  struct _GmSearchableInterface *iface;
  struct _GtkTextView *text_view;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)self;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_replace_all", "GM_IS_SEARCHABLE(self)");
      return 0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gm_searchable_get_type$3;
  return_value_gm_searchable_get_type$3=gm_searchable_get_type();
  void *return_value_g_type_interface_peek$4;
  return_value_g_type_interface_peek$4=g_type_interface_peek((void *)((struct _GTypeInstance *)self)->g_class, return_value_gm_searchable_get_type$3);
  iface = (struct _GmSearchableInterface *)return_value_g_type_interface_peek$4;
  do
    if(iface == ((struct _GmSearchableInterface *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_replace_all", "iface != NULL");
      return 0;
    }

  while((_Bool)0);
  _Bool tmp_if_expr$7;
  signed int return_value_gtk_text_view_get_editable$6;
  if(iface->replace_all == ((signed int (*)(struct _GmSearchable *, const char *, const char *, enum _GmSearchableSearchFlags))NULL))
  {
    text_view=gm_searchable_interface_get_text_view(self, iface);
    if(!(text_view == ((struct _GtkTextView *)NULL)))
    {
      return_value_gtk_text_view_get_editable$6=gtk_text_view_get_editable(text_view);
      tmp_if_expr$7 = return_value_gtk_text_view_get_editable$6 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
    {
      signed int return_value_gm_searchable_text_view_replace_all$5;
      return_value_gm_searchable_text_view_replace_all$5=gm_searchable_text_view_replace_all(text_view, str, replace, flags);
      return return_value_gm_searchable_text_view_replace_all$5;
    }

    else
    {
      g_log((char *)0, (enum anonymous$99)G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", (const void *)"widgets/gm-searchable.c", 810, (const char *)"gm_searchable_replace_all");
      return 0;
    }
  }

  signed int return_value;
  return_value=iface->replace_all(self, str, replace, flags);
  return return_value;
}

// gm_searchable_text_view_find_first
// file widgets/gm-searchable.c line 580
signed int gm_searchable_text_view_find_first(struct _GtkTextView *text_view, const char *str, enum _GmSearchableSearchFlags flags)
{
  struct _GtkTextIter iter;
  struct _GtkTextBuffer *buffer;
  do
    if(text_view == ((struct _GtkTextView *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_text_view_find_first", "text_view != NULL");
      return 0;
    }

  while((_Bool)0);
  buffer=gtk_text_view_get_buffer(text_view);
  if(!(buffer == ((struct _GtkTextBuffer *)NULL)))
  {
    if(!((GM_SEARCHABLE_SEARCH_BACKWARDS & (signed int)flags) == 0))
      gtk_text_buffer_get_end_iter(buffer, &iter);

    else
      gtk_text_buffer_get_start_iter(buffer, &iter);
    gtk_text_buffer_place_cursor(buffer, &iter);
    if((signed int)*str == 0)
    {
      struct _GtkTextMark *return_value_gtk_text_buffer_get_selection_bound$1;
      return_value_gtk_text_buffer_get_selection_bound$1=gtk_text_buffer_get_selection_bound(buffer);
      gtk_text_buffer_move_mark(buffer, return_value_gtk_text_buffer_get_selection_bound$1, &iter);
      return 0;
    }

    else
    {
      signed int return_value_gm_searchable_text_view_find_next$2;
      return_value_gm_searchable_text_view_find_next$2=gm_searchable_text_view_find_next(text_view, str, flags);
      return return_value_gm_searchable_text_view_find_next$2;
    }
  }

  return 0;
}

// gm_searchable_text_view_find_next
// file widgets/gm-searchable.c line 519
signed int gm_searchable_text_view_find_next(struct _GtkTextView *text_view, const char *str, enum _GmSearchableSearchFlags flags)
{
  struct _GtkTextBuffer *buffer = (struct _GtkTextBuffer *)(void *)0;
  struct _GtkTextIter end;
  struct _GtkTextIter start;
  struct _GtkTextIter match_start;
  struct _GtkTextIter match_end;
  signed int found = 0;
  do
    if(text_view == ((struct _GtkTextView *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_searchable_text_view_find_next", "text_view != NULL");
      return 0;
    }

  while((_Bool)0);
  _Bool tmp_if_expr$1;
  if(str == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*str == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    buffer=gtk_text_view_get_buffer(text_view);
    if(!(buffer == ((struct _GtkTextBuffer *)NULL)))
    {
      signed int return_value_gtk_text_buffer_get_selection_bounds$4;
      return_value_gtk_text_buffer_get_selection_bounds$4=gtk_text_buffer_get_selection_bounds(buffer, &start, &end);
      if(return_value_gtk_text_buffer_get_selection_bounds$4 == 0)
      {
        signed int return_value_gtk_text_view_get_cursor_visible$3;
        return_value_gtk_text_view_get_cursor_visible$3=gtk_text_view_get_cursor_visible(text_view);
        if(!(return_value_gtk_text_view_get_cursor_visible$3 == 0))
        {
          struct _GtkTextMark *return_value_gtk_text_buffer_get_insert$2;
          return_value_gtk_text_buffer_get_insert$2=gtk_text_buffer_get_insert(buffer);
          gtk_text_buffer_get_iter_at_mark(buffer, &end, return_value_gtk_text_buffer_get_insert$2);
        }

        else
          if(!((GM_SEARCHABLE_SEARCH_FORWARDS & (signed int)flags) == 0))
            gtk_text_buffer_get_start_iter(buffer, &end);

          else
            gtk_text_buffer_get_end_iter(buffer, &end);
        start = end;
      }

      if(!((GM_SEARCHABLE_SEARCH_CASE_INSENSITIVE & (signed int)flags) == 0))
      {
        match_start = start;
        match_end = end;
        found=gm_searchable_text_view_search_case_insensitive(text_view, str, flags, &match_start, &match_end);
      }

      else
        if(!((GM_SEARCHABLE_SEARCH_FORWARDS & (signed int)flags) == 0))
          found=gtk_text_iter_forward_search(&end, str, (enum anonymous$100)(GTK_TEXT_SEARCH_VISIBLE_ONLY | GTK_TEXT_SEARCH_TEXT_ONLY), &match_start, &match_end, (const struct _GtkTextIter *)(void *)0);

        else
          found=gtk_text_iter_backward_search(&start, str, (enum anonymous$100)(GTK_TEXT_SEARCH_VISIBLE_ONLY | GTK_TEXT_SEARCH_TEXT_ONLY), &match_start, &match_end, (const struct _GtkTextIter *)(void *)0);
      if(!(found == 0))
      {
        gtk_text_buffer_place_cursor(buffer, &match_start);
        gtk_text_buffer_move_mark_by_name(buffer, "selection_bound", &match_end);
        gtk_text_view_scroll_to_iter(text_view, &match_start, 0.0, 0, 0.0, 0.0);
      }

    }

    return found;
  }
}

// gm_searchable_text_view_replace
// file widgets/gm-searchable.c line 611
signed int gm_searchable_text_view_replace(struct _GtkTextView *text_view, const char *replace)
{
  struct _GtkTextBuffer *buffer = (struct _GtkTextBuffer *)(void *)0;
  struct _GtkTextIter end;
  struct _GtkTextIter start;
  buffer=gtk_text_view_get_buffer(text_view);
  if(!(buffer == ((struct _GtkTextBuffer *)NULL)))
  {
    signed int return_value_gtk_text_buffer_get_selection_bounds$1;
    return_value_gtk_text_buffer_get_selection_bounds$1=gtk_text_buffer_get_selection_bounds(buffer, &start, &end);
    if(return_value_gtk_text_buffer_get_selection_bounds$1 == 0)
      return 0;

    else
    {
      gtk_text_buffer_begin_user_action(buffer);
      gtk_text_buffer_delete(buffer, &start, &end);
      gtk_text_buffer_insert(buffer, &start, replace, -1);
      gtk_text_buffer_end_user_action(buffer);
      return (signed int)!(0 != 0);
    }
  }

  else
    return 0;
}

// gm_searchable_text_view_replace_all
// file widgets/gm-searchable.c line 634
signed int gm_searchable_text_view_replace_all(struct _GtkTextView *text_view, const char *str, const char *replace, enum _GmSearchableSearchFlags flags)
{
  signed int found;
  found=gm_searchable_text_view_find_first(text_view, str, flags);
  if(!(found == 0))
    while(!(found == 0))
    {
      gm_searchable_text_view_replace(text_view, replace);
      found=gm_searchable_text_view_find_next(text_view, str, flags);
    }

  else
    return 0;
  return (signed int)!(0 != 0);
}

// gm_searchable_text_view_search_case_insensitive
// file widgets/gm-searchable.c line 466
signed int gm_searchable_text_view_search_case_insensitive(struct _GtkTextView *text_view, const char *str, enum _GmSearchableSearchFlags flags, struct _GtkTextIter *start, struct _GtkTextIter *end)
{
  char **lines;
  lines=strbreakup(str, "\n", -1);
  struct _GtkTextIter search;
  signed int retval = 0;
  signed int return_value_gtk_text_iter_forward_line$1;
  if(!((GM_SEARCHABLE_SEARCH_FORWARDS & (signed int)flags) == 0))
  {
    search = *end;
    do
    {
      signed int return_value_lines_match$2;
      return_value_lines_match$2=lines_match(&search, (const char **)lines, start, end);
      if(!(return_value_lines_match$2 == 0))
      {
        retval = (signed int)!(0 != 0);
        break;
      }

      return_value_gtk_text_iter_forward_line$1=gtk_text_iter_forward_line(&search);
    }
    while(!(return_value_gtk_text_iter_forward_line$1 == 0));
  }

  else
  {
    search = *start;
    while((_Bool)1)
    {
      signed int return_value_backward_lines_match$3;
      return_value_backward_lines_match$3=backward_lines_match(&search, (const char **)lines, start, end);
      if(!(return_value_backward_lines_match$3 == 0))
      {
        retval = (signed int)!(0 != 0);
        break;
      }

      signed int return_value_gtk_text_iter_get_line_offset$5;
      return_value_gtk_text_iter_get_line_offset$5=gtk_text_iter_get_line_offset(&search);
      if(return_value_gtk_text_iter_get_line_offset$5 == 0)
      {
        signed int return_value_gtk_text_iter_backward_line$4;
        return_value_gtk_text_iter_backward_line$4=gtk_text_iter_backward_line(&search);
        if(return_value_gtk_text_iter_backward_line$4 == 0)
          break;

      }

      else
        gtk_text_iter_set_line_offset(&search, 0);
    }
  }
  g_strfreev((char **)lines);
  return retval;
}

// gm_source_style_scheme_IFace_init
// file widgets/gm-source-style-scheme.c line 92
static void gm_source_style_scheme_IFace_init(struct _GtkSourceStyleSchemeClass *iface)
{
  ;
}

// gm_source_style_scheme_class_init
// file widgets/gm-source-style-scheme.c line 84
static void gm_source_style_scheme_class_init(struct _GmSourceStyleSchemeClass *klass)
{
  struct _GObjectClass *gobject_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  gobject_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  void *return_value_g_type_class_peek_parent$2;
  return_value_g_type_class_peek_parent$2=g_type_class_peek_parent((void *)klass);
  parent_class$link3 = (struct _GObjectClass *)return_value_g_type_class_peek_parent$2;
  gobject_class->finalize = gm_source_style_scheme_finalize;
}

// gm_source_style_scheme_finalize
// file widgets/gm-source-style-scheme.c line 197
static void gm_source_style_scheme_finalize(struct _GObject *object)
{
  struct _GmSourceStyleScheme *scheme;
  unsigned long int return_value_gm_source_style_scheme_get_type$1;
  return_value_gm_source_style_scheme_get_type$1=gm_source_style_scheme_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_source_style_scheme_get_type$1);
  scheme = (struct _GmSourceStyleScheme *)return_value_g_type_check_instance_cast$2;
  g_hash_table_destroy(scheme->styles);
  g_hash_table_destroy(scheme->mapping);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)parent_class$link3, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_source_style_scheme_get_default
// file widgets/gm-source-style-scheme.c line 254
struct _GtkSourceStyleScheme * gm_source_style_scheme_get_default(void)
{
  if(gm_style_scheme == ((struct _GtkSourceStyleScheme *)NULL))
  {
    unsigned long int return_value_gm_source_style_scheme_get_type$1;
    return_value_gm_source_style_scheme_get_type$1=gm_source_style_scheme_get_type();
    void *return_value_g_object_new$2;
    return_value_g_object_new$2=g_object_new(return_value_gm_source_style_scheme_get_type$1, (const char *)(void *)0);
    gm_style_scheme = (struct _GtkSourceStyleScheme *)return_value_g_object_new$2;
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)gm_style_scheme, (unsigned long int)(20 << 2));
    g_object_weak_ref((struct _GObject *)return_value_g_type_check_instance_cast$3, gm_source_style_weak_destroy, (void *)0);
    struct _GmApp *return_value_gm_app_instance$4;
    return_value_gm_app_instance$4=gm_app_instance();
    struct _GmColorTable *return_value_gm_app_color_table$5;
    return_value_gm_app_color_table$5=gm_app_color_table(return_value_gm_app_instance$4);
    g_signal_connect_data((void *)return_value_gm_app_color_table$5, "color-changed", (void (*)(void))on_gm_source_style_scheme_color_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  }

  else
    g_object_ref((void *)gm_style_scheme);
  return gm_style_scheme;
}

// gm_source_style_scheme_get_type
// file widgets/gm-source-style-scheme.c line 44
static unsigned long int gm_source_style_scheme_get_type(void)
{
  static unsigned long int type = (unsigned long int)0;
  if(type == 0ul)
  {
    static const struct _GTypeInfo info = { .class_size=(unsigned short int)sizeof(struct _GmSourceStyleSchemeClass) /*136ul*/ , .base_init=(void (*)(void *))(void *)0,
    .base_finalize=(void (*)(void *))(void *)0,
    .class_init=(void (*)(void *, void *))gm_source_style_scheme_class_init,
    .class_finalize=(void (*)(void *, void *))(void *)0,
    .class_data=(void *)0,
    .instance_size=(unsigned short int)sizeof(struct _GmSourceStyleScheme) /*40ul*/ , .n_preallocs=(unsigned short int)0,
    .instance_init=(void (*)(struct _GTypeInstance *, void *))gm_source_style_scheme_init, .value_table=((const struct _GTypeValueTable *)NULL) };
    type=g_type_register_static((unsigned long int)(20 << 2), "GmSourceStyleScheme", &info, (enum anonymous)0);
    unsigned long int return_value_gtk_source_style_scheme_get_type$1;
    return_value_gtk_source_style_scheme_get_type$1=gtk_source_style_scheme_get_type();
    static const struct _GInterfaceInfo iface_info = { .interface_init=(void (*)(void *, void *))gm_source_style_scheme_IFace_init, .interface_finalize=(void (*)(void *, void *))(void *)0,
    .interface_data=(void *)0 };
    g_type_add_interface_static(type, return_value_gtk_source_style_scheme_get_type$1, &iface_info);
  }

  return type;
}

// gm_source_style_scheme_init
// file widgets/gm-source-style-scheme.c line 177
static void gm_source_style_scheme_init(struct _GmSourceStyleScheme *scheme)
{
  struct _GtkTextTag *ts;
  struct _GmColorTable *table;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  table=gm_app_color_table(return_value_gm_app_instance$1);
  struct _GmSourceStyleEntry *entry;
  scheme->styles=g_hash_table_new_full((unsigned int (*)(const void *))g_str_hash, (signed int (*)(const void *, const void *))g_str_equal, (void (*)(void *))g_free, (void (*)(void *))(void *)0);
  entry = entries;
  for( ; !(entry->name == ((const char *)NULL)); entry = entry + 1l)
  {
    const char *return_value_gm_color_table_get_hex$2;
    return_value_gm_color_table_get_hex$2=gm_color_table_get_hex(table, entry->color_name);
    ts=new_tag_style(return_value_gm_color_table_get_hex$2, (const char *)(void *)0, entry->bold, entry->italic);
    char *return_value_g_strdup$3;
    return_value_g_strdup$3=g_strdup(entry->name);
    g_hash_table_insert(scheme->styles, (void *)return_value_g_strdup$3, (void *)ts);
  }
  gm_source_style_scheme_init_mapping(scheme);
}

// gm_source_style_scheme_init_mapping
// file widgets/gm-source-style-scheme.c line 164
static void gm_source_style_scheme_init_mapping(struct _GmSourceStyleScheme *scheme)
{
  struct _GmKeyValuePair *entry;
  scheme->mapping=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, (void (*)(void *))g_strfreev);
  entry = mapping;
  for( ; !(entry->key == ((char *)NULL)); entry = entry + 1l)
  {
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup(entry->key);
    char **return_value_g_strsplit$2;
    return_value_g_strsplit$2=g_strsplit(entry->value, " ", 0);
    g_hash_table_insert(scheme->mapping, (void *)return_value_g_strdup$1, (void *)return_value_g_strsplit$2);
  }
}

// gm_source_style_weak_destroy
// file widgets/gm-source-style-scheme.c line 247
void gm_source_style_weak_destroy(void *data, struct _GObject *object)
{
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$2;
  return_value_gm_app_color_table$2=gm_app_color_table(return_value_gm_app_instance$1);
  g_signal_handlers_disconnect_matched((void *)return_value_gm_app_color_table$2, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_source_style_scheme_color_changed, (void *)0);
  gm_style_scheme = (struct _GtkSourceStyleScheme *)(void *)0;
}

// gm_string_cat
// file gm-string.c line 44
char * gm_string_cat(char *str, char *add)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(add);
  char *return_value_gm_string_catn$2;
  return_value_gm_string_catn$2=gm_string_catn(str, add, (unsigned int)return_value_strlen$1);
  return return_value_gm_string_catn$2;
}

// gm_string_catn
// file gm-string.c line 20
char * gm_string_catn(char *str, char *add, unsigned int n)
{
  unsigned int relen;
  char *newstr;
  if(str == ((char *)NULL))
    relen = (unsigned int)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    relen = (unsigned int)return_value_strlen$1;
  }
  void *return_value_realloc$2;
  return_value_realloc$2=realloc((void *)str, (unsigned long int)(relen + n + (unsigned int)1) * sizeof(char) /*1ul*/ );
  newstr = (char *)return_value_realloc$2;
  if(newstr == ((char *)NULL))
  {
    gm_debug_msg(DEBUG_DEFAULT, "mystring_catn: REALLOC FAILED!");
    return str;
  }

  else
  {
    if(relen == 0u)
      newstr[(signed long int)0] = (char)0;

    strncat(newstr, add, (unsigned long int)n);
    return newstr;
  }
}

// gm_string_escape
// file gm-string.c line 152
char * gm_string_escape(const char *line)
{
  struct _GString *new_line;
  char *ptr;
  unsigned int c;
  if((signed int)*line == 0)
  {
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("");
    return return_value_g_strdup$1;
  }

  char *return_value_g_utf8_strchr$4;
  return_value_g_utf8_strchr$4=g_utf8_strchr(line, (signed long int)34, (unsigned int)-1);
  _Bool tmp_if_expr$6;
  char *return_value_g_utf8_strchr$5;
  if(!(return_value_g_utf8_strchr$4 == ((char *)NULL)))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_g_utf8_strchr$5=g_utf8_strchr(line, (signed long int)92, (unsigned int)-1);
    tmp_if_expr$6 = return_value_g_utf8_strchr$5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$6)
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(line);
    new_line=g_string_sized_new(return_value_strlen$2);
    for( ; !((signed int)*line == 0); line = (char *)(line + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)line)]))
    {
      c=g_utf8_get_char(line);
      if(c == 34u || c == 92u)
        g_string_append_c_inline$link5(new_line, (char)92);

      g_string_append_unichar(new_line, c);
    }
    ptr = new_line->str;
    g_string_free(new_line, 0);
    return ptr;
  }

  else
  {
    char *return_value_g_strdup$3;
    return_value_g_strdup$3=g_strdup(line);
    return return_value_g_strdup$3;
  }
}

// gm_string_remove_char
// file ./gm-string.h line 12
char * gm_string_remove_char(char *str, char rem)
{
  char *start = str;
  char *ptr = str;
  signed int changed = 0;
  unsigned int c;
  for( ; !((signed int)*str == 0); str = (char *)(str + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)str)]))
  {
    c=g_utf8_get_char(str);
    if(!(c == (unsigned int)rem))
    {
      if(!(changed == 0))
      {
        signed int return_value_g_unichar_to_utf8$1;
        return_value_g_unichar_to_utf8$1=g_unichar_to_utf8(c, ptr);
        ptr = ptr + (signed long int)return_value_g_unichar_to_utf8$1;
      }

      else
        ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
    }

    else
      changed = (signed int)!(0 != 0);
  }
  *ptr = (char)0;
  return start;
}

// gm_string_skip_nonspace
// file ./gm-string.h line 15
void gm_string_skip_nonspace(const char **ptr)
{
  unsigned int return_value_g_utf8_get_char$1;
  signed int return_value_g_unichar_isspace$2;
  for( ; !((signed int)*(*ptr) == 0); *ptr = (char *)(*ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)*ptr)]))
  {
    return_value_g_utf8_get_char$1=g_utf8_get_char(*ptr);
    return_value_g_unichar_isspace$2=g_unichar_isspace(return_value_g_utf8_get_char$1);
    if(!(return_value_g_unichar_isspace$2 == 0))
      break;

  }
}

// gm_string_skip_space
// file ./gm-string.h line 14
void gm_string_skip_space(const char **ptr)
{
  unsigned int return_value_g_utf8_get_char$1;
  signed int return_value_g_unichar_isspace$2;
  for( ; !((signed int)*(*ptr) == 0); *ptr = (char *)(*ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)*ptr)]))
  {
    return_value_g_utf8_get_char$1=g_utf8_get_char(*ptr);
    return_value_g_unichar_isspace$2=g_unichar_isspace(return_value_g_utf8_get_char$1);
    if(return_value_g_unichar_isspace$2 == 0)
      break;

  }
}

// gm_string_skip_till
// file ./gm-string.h line 16
void gm_string_skip_till(const char **ptr, const char *find)
{
  const char *fptr;
  unsigned int check;
  unsigned int c;
  for( ; !((signed int)*(*ptr) == 0); *ptr = (char *)(*ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)*ptr)]))
  {
    check=g_utf8_get_char(*ptr);
    fptr = find;
    for( ; !((signed int)*fptr == 0); fptr = (char *)(fptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)fptr)]))
    {
      c=g_utf8_get_char(fptr);
      if(check == c)
        goto __CPROVER_DUMP_L6;

    }
  }

__CPROVER_DUMP_L6:
  ;
}

// gm_string_split
// file gm-string.c line 199
struct _GList * gm_string_split(const char *text)
{
  char *fptr;
  char *line;
  struct _GList *lastptr;
  struct _GList *lines = (struct _GList *)(void *)0;
  if(text == ((const char *)NULL))
    return (struct _GList *)(void *)0;

  else
  {
    do
    {
      fptr=g_utf8_strchr(text, (signed long int)-1, (unsigned int)10);
      if(fptr == ((char *)NULL))
        break;

      line=g_strndup(text, (unsigned long int)(fptr - text));
      gm_string_remove_char(line, (char)13);
      lines=gm_string_split_add_line(line, lines, &lastptr);
      text = (char *)(fptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)fptr)]);
    }
    while((_Bool)1);
    if(!((signed int)*text == 0))
    {
      line=g_strdup(text);
      gm_string_remove_char(line, (char)13);
      lines=gm_string_split_add_line(line, lines, &lastptr);
    }

    return lines;
  }
}

// gm_string_split_add_line
// file gm-string.c line 186
struct _GList * gm_string_split_add_line(char *line, struct _GList *lines, struct _GList **lastptr)
{
  if(lines == ((struct _GList *)NULL))
  {
    lines=g_list_append((struct _GList *)(void *)0, (void *)line);
    *lastptr = lines;
  }

  else
  {
    *lastptr=g_list_append(*lastptr, (void *)line);
    *lastptr = (*lastptr)->next;
  }
  return lines;
}

// gm_string_to_int
// file gm-string.h line 8
signed int gm_string_to_int(const char *str, signed int *result)
{
  *result = 0;
  _Bool tmp_if_expr$1;
  if(str == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*str == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    *result=atoi(str);
    return (signed int)!(0 != 0);
  }
}

// gm_string_trim
// file gm-string.h line 11
char * gm_string_trim(const char *str)
{
  char *newstr = (char *)(void *)0;
  const char *r;
  const char *l;
  if(str == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    r = str + (signed long int)return_value_strlen$1;
    l = str;
    while((_Bool)1)
    {
      if(!((signed int)*l == 32))
      {
        if(!((signed int)*r == 32))
          goto __CPROVER_DUMP_L6;

      }

      if(l == r)
        break;

      if((signed int)*l == 32)
        l = l + 1l;

      if(l == r)
        break;

      if((signed int)*r == 32)
        r = r - 1l;

    }

  __CPROVER_DUMP_L6:
    ;
    if(l == r)
    {
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup("");
      return return_value_g_strdup$2;
    }

    else
    {
      newstr=g_strndup(l, (unsigned long int)(r - l));
      return newstr;
    }
  }
}

// gm_text_scroller_class_init
// file widgets/gm-text-scroller.c line 71
static void gm_text_scroller_class_init(struct _GmTextScrollerClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_text_scroller_finalize;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmTextScrollerPrivate) /*56ul*/ );
}

// gm_text_scroller_class_intern_init
// file widgets/gm-text-scroller.c line 42
static void gm_text_scroller_class_intern_init(void *klass)
{
  gm_text_scroller_parent_class=g_type_class_peek_parent(klass);
  if(!(GmTextScroller_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmTextScroller_private_offset);

  gm_text_scroller_class_init((struct _GmTextScrollerClass *)klass);
}

// gm_text_scroller_finalize
// file widgets/gm-text-scroller.c line 45
static void gm_text_scroller_finalize(struct _GObject *object)
{
  struct _GmTextScroller *obj;
  unsigned long int return_value_gm_text_scroller_get_type$1;
  return_value_gm_text_scroller_get_type$1=gm_text_scroller_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_text_scroller_get_type$1);
  obj = (struct _GmTextScroller *)return_value_g_type_check_instance_cast$2;
  if(!(obj->priv->text_buffer == ((struct _GtkTextBuffer *)NULL)))
  {
    g_signal_handlers_disconnect_matched((void *)obj->priv->text_buffer, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_text_scroller_text_buffer_changed, (void *)obj);
    g_object_unref((void *)obj->priv->text_buffer);
  }

  if(!(obj->priv->idle_handler == 0))
    g_source_remove((unsigned int)obj->priv->idle_handler);

  g_signal_handlers_disconnect_matched((void *)obj->priv->text_view, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_text_scroller_text_view_notify, (void *)obj);
  g_signal_handlers_disconnect_matched((void *)obj->priv->text_view, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_text_scroller_text_view_style_set, (void *)obj);
  g_signal_handlers_disconnect_matched((void *)obj->priv->text_view, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_text_scroller_text_view_destroy, (void *)obj);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_text_scroller_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_text_scroller_get_type
// file widgets/gm-text-scroller.c line 42
unsigned long int gm_text_scroller_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmTextScroller");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmTextScrollerClass) /*136ul*/ , (void (*)(void *, void *))gm_text_scroller_class_intern_init, (unsigned int)sizeof(struct _GmTextScroller) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_text_scroller_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_text_scroller_init
// file widgets/gm-text-scroller.c line 90
static void gm_text_scroller_init(struct _GmTextScroller *obj)
{
  unsigned long int return_value_gm_text_scroller_get_type$1;
  return_value_gm_text_scroller_get_type$1=gm_text_scroller_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_text_scroller_get_type$1);
  obj->priv = (struct _GmTextScrollerPrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->character_height = 10;
  obj->priv->end_scrolled = 0;
}

// gm_text_scroller_is_end_scrolled
// file widgets/gm-text-scroller.c line 181
signed int gm_text_scroller_is_end_scrolled(struct _GmTextScroller *scroller)
{
  signed int return_value_gm_text_scroller_is_end_scrolled_margin$1;
  return_value_gm_text_scroller_is_end_scrolled_margin$1=gm_text_scroller_is_end_scrolled_margin(scroller, 0);
  return return_value_gm_text_scroller_is_end_scrolled_margin$1;
}

// gm_text_scroller_is_end_scrolled_margin
// file widgets/gm-text-scroller.c line 170
signed int gm_text_scroller_is_end_scrolled_margin(struct _GmTextScroller *scroller, signed int margin)
{
  struct _GtkAdjustment *ad;
  ad=gtk_scrolled_window_get_vadjustment(scroller->priv->scrolled_window);
  _Bool tmp_if_expr$1;
  if(!(scroller->priv->end_scrolled == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ad->page_size + ad->value >= (ad->upper - (double)scroller->priv->character_height) - (double)margin ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// gm_text_scroller_new
// file widgets/gm-text-scroller.h line 47
struct _GmTextScroller * gm_text_scroller_new(struct _GtkTextView *text_view)
{
  struct _GmTextScroller *obj;
  struct _GtkWidget *parent;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)text_view, return_value_gtk_widget_get_type$1);
  parent=gtk_widget_get_parent((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  _Bool tmp_if_expr$5;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  if(parent == ((struct _GtkWidget *)NULL))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)parent;
    unsigned long int __t;
    __t=gtk_scrolled_window_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$3 = __r;
    tmp_if_expr$5 = !(tmp_statement_expression$3 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    return (struct _GmTextScroller *)(void *)0;

  else
  {
    unsigned long int return_value_gm_text_scroller_get_type$6;
    return_value_gm_text_scroller_get_type$6=gm_text_scroller_get_type();
    void *return_value_g_object_new$7;
    return_value_g_object_new$7=g_object_new(return_value_gm_text_scroller_get_type$6, (const char *)(void *)0);
    unsigned long int return_value_gm_text_scroller_get_type$8;
    return_value_gm_text_scroller_get_type$8=gm_text_scroller_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$7, return_value_gm_text_scroller_get_type$8);
    obj = (struct _GmTextScroller *)return_value_g_type_check_instance_cast$9;
    obj->priv->text_view = text_view;
    unsigned long int return_value_gtk_scrolled_window_get_type$10;
    return_value_gtk_scrolled_window_get_type$10=gtk_scrolled_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gtk_scrolled_window_get_type$10);
    obj->priv->scrolled_window = (struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$11;
    unsigned long int return_value_gtk_widget_get_type$12;
    return_value_gtk_widget_get_type$12=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)text_view, return_value_gtk_widget_get_type$12);
    obj->priv->allocation = ((struct _GtkWidget *)return_value_g_type_check_instance_cast$13)->allocation;
    gm_text_scroller_update_text_buffer(obj);
    gm_text_scroller_update_character_height(obj);
    g_signal_connect_data((void *)text_view, "notify::buffer", (void (*)(void))on_gm_text_scroller_text_view_notify, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)text_view, "style-set", (void (*)(void))on_gm_text_scroller_text_view_style_set, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)text_view, "destroy", (void (*)(void))on_gm_text_scroller_text_view_destroy, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)text_view, "size-allocate", (void (*)(void))on_gm_text_scroller_text_view_size_allocate, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    unsigned int return_value_g_idle_add$14;
    return_value_g_idle_add$14=g_idle_add((signed int (*)(void *))gm_text_scroller_scroll_end_idle, (void *)obj);
    obj->priv->idle_handler = (signed int)return_value_g_idle_add$14;
    return obj;
  }
}

// gm_text_scroller_prepare
// file widgets/gm-text-scroller.c line 186
void gm_text_scroller_prepare(struct _GmTextScroller *scroller)
{
  scroller->priv->end_scrolled=gm_text_scroller_is_end_scrolled(scroller);
  if(scroller->priv->idle_handler == 0)
  {
    if(!(scroller->priv->end_scrolled == 0))
    {
      gm_text_scroller_scroll_end(scroller);
      unsigned int return_value_g_idle_add$1;
      return_value_g_idle_add$1=g_idle_add((signed int (*)(void *))gm_text_scroller_scroll_end_idle, (void *)scroller);
      scroller->priv->idle_handler = (signed int)return_value_g_idle_add$1;
    }

  }

}

// gm_text_scroller_scroll_begin
// file widgets/gm-text-scroller.h line 49
void gm_text_scroller_scroll_begin(struct _GmTextScroller *scroller)
{
  struct _GtkTextMark *mark;
  struct _GtkTextIter iter;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)scroller->priv->text_buffer;
    unsigned long int __t;
    __t=gtk_text_buffer_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_text_scroller_scroll_begin", "GTK_IS_TEXT_BUFFER(scroller->priv->text_buffer)");
      goto __CPROVER_DUMP_L9;
    }

  }
  while((_Bool)0);
  mark=gtk_text_buffer_get_mark(scroller->priv->text_buffer, "begin-of-buffer");
  if(mark == ((struct _GtkTextMark *)NULL))
  {
    gtk_text_buffer_get_start_iter(scroller->priv->text_buffer, &iter);
    mark=gtk_text_buffer_create_mark(scroller->priv->text_buffer, "begin-of-buffer", &iter, (signed int)!(0 != 0));
  }

  gtk_text_view_scroll_to_mark(scroller->priv->text_view, mark, 0.0, (signed int)!(0 != 0), 0.0, 0.0);

__CPROVER_DUMP_L9:
  ;
}

// gm_text_scroller_scroll_end
// file widgets/gm-text-scroller.h line 48
void gm_text_scroller_scroll_end(struct _GmTextScroller *scroller)
{
  struct _GtkTextMark *mark;
  struct _GtkTextIter iter;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)scroller->priv->text_buffer;
    unsigned long int __t;
    __t=gtk_text_buffer_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_text_scroller_scroll_end", "GTK_IS_TEXT_BUFFER(scroller->priv->text_buffer)");
      goto __CPROVER_DUMP_L9;
    }

  }
  while((_Bool)0);
  mark=gtk_text_buffer_get_mark(scroller->priv->text_buffer, "end-of-buffer");
  if(mark == ((struct _GtkTextMark *)NULL))
  {
    gtk_text_buffer_get_end_iter(scroller->priv->text_buffer, &iter);
    mark=gtk_text_buffer_create_mark(scroller->priv->text_buffer, "end-of-buffer", &iter, 0);
  }

  gtk_text_view_scroll_to_mark(scroller->priv->text_view, mark, 0.0, (signed int)!(0 != 0), 1.0, 1.0);

__CPROVER_DUMP_L9:
  ;
}

// gm_text_scroller_scroll_end_idle
// file widgets/gm-text-scroller.c line 160
signed int gm_text_scroller_scroll_end_idle(struct _GmTextScroller *scroller)
{
  scroller->priv->idle_handler = 0;
  gm_text_scroller_scroll_end(scroller);
  scroller->priv->end_scrolled = 0;
  return 0;
}

// gm_text_scroller_scroll_page
// file widgets/gm-text-scroller.h line 50
void gm_text_scroller_scroll_page(struct _GmTextScroller *scroller, signed int direction)
{
  struct _GtkScrolledWindow *srl = scroller->priv->scrolled_window;
  struct _GtkAdjustment *adj;
  adj=gtk_scrolled_window_get_vadjustment(srl);
  double value = adj->value + adj->page_size * (double)direction;
  if(value > adj->upper + -adj->page_size)
    gtk_adjustment_set_value(adj, adj->upper - adj->page_size);

  else
    if(value < adj->lower)
      gtk_adjustment_set_value(adj, adj->lower);

    else
      gtk_adjustment_set_value(adj, value);
}

// gm_text_scroller_update_character_height
// file widgets/gm-text-scroller.c line 199
void gm_text_scroller_update_character_height(struct _GmTextScroller *scroller)
{
  struct _GtkRcStyle *style;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)scroller->priv->text_view, return_value_gtk_widget_get_type$1);
  style=gtk_widget_get_modifier_style((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  struct _PangoContext *pc;
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)scroller->priv->text_view, return_value_gtk_widget_get_type$3);
  pc=gtk_widget_create_pango_context((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
  struct _PangoLayout *pl;
  signed int cwidth;
  signed int cheight;
  if(!(style->font_desc == ((struct _PangoFontDescription *)NULL)))
  {
    pango_context_set_font_description(pc, style->font_desc);
    pl=pango_layout_new(pc);
    pango_layout_set_text(pl, "G", 1);
    pango_layout_get_pixel_size(pl, &cwidth, &cheight);
    if(!(scroller->priv->character_height == cheight))
      scroller->priv->character_height = cheight;

    g_object_unref((void *)pl);
  }

  g_object_unref((void *)pc);
}

// gm_text_scroller_update_text_buffer
// file widgets/gm-text-scroller.c line 98
void gm_text_scroller_update_text_buffer(struct _GmTextScroller *scroller)
{
  if(!(scroller->priv->text_buffer == ((struct _GtkTextBuffer *)NULL)))
  {
    g_signal_handlers_disconnect_matched((void *)scroller->priv->text_buffer, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_text_scroller_text_buffer_changed, (void *)scroller);
    g_object_unref((void *)scroller->priv->text_buffer);
  }

  scroller->priv->text_buffer=gtk_text_view_get_buffer(scroller->priv->text_view);
  if(!(scroller->priv->text_buffer == ((struct _GtkTextBuffer *)NULL)))
  {
    g_object_ref((void *)scroller->priv->text_buffer);
    g_signal_connect_data((void *)scroller->priv->text_buffer, "changed", (void (*)(void))on_gm_text_scroller_text_buffer_changed, (void *)scroller, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  }

}

// gm_to_utf8_with_fallback
// file gm-support.h line 155
char * gm_to_utf8_with_fallback(const char *text, signed long int len, const char *from, const char *fallback)
{
  char *return_value_gm_convert_with_fallback$1;
  return_value_gm_convert_with_fallback$1=gm_convert_with_fallback(text, len, from, "UTF-8", fallback);
  return return_value_gm_convert_with_fallback$1;
}

// gm_tray_activate
// file widgets/gm-tray.h line 64
void gm_tray_activate(struct _GmTray *tray)
{
  if(!(tray->priv->flash_timeout == 0u))
    g_source_remove(tray->priv->flash_timeout);

  if((signed int)tray->priv->current_state == TRAY_STATE_NORMAL)
    tray->priv->current_state = (enum _GmTrayState)TRAY_STATE_ACTIVE;

  gm_tray_set_state(tray, (enum _GmTrayState)TRAY_STATE_ACTIVITY);
  tray->priv->flash_timeout=g_timeout_add((unsigned int)1000, gm_tray_restore_from_activity, (void *)tray);
}

// gm_tray_active
// file widgets/gm-tray.c line 144
void gm_tray_active(struct _GmTray *tray)
{
  gm_tray_set_state(tray, (enum _GmTrayState)TRAY_STATE_ACTIVE);
}

// gm_tray_class_init
// file widgets/gm-tray.c line 46
static void gm_tray_class_init(struct _GmTrayClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_tray_finalize;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmTrayPrivate) /*72ul*/ );
}

// gm_tray_class_intern_init
// file widgets/gm-tray.c line 27
static void gm_tray_class_intern_init(void *klass)
{
  gm_tray_parent_class=g_type_class_peek_parent(klass);
  if(!(GmTray_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmTray_private_offset);

  gm_tray_class_init((struct _GmTrayClass *)klass);
}

// gm_tray_finalize
// file widgets/gm-tray.c line 30
static void gm_tray_finalize(struct _GObject *object)
{
  struct _GmTray *tray;
  unsigned long int return_value_gm_tray_get_type$1;
  return_value_gm_tray_get_type$1=gm_tray_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_tray_get_type$1);
  tray = (struct _GmTray *)return_value_g_type_check_instance_cast$2;
  unsigned int i;
  if(!(tray->priv->flash_timeout == 0u))
    g_source_remove(tray->priv->flash_timeout);

  i = (unsigned int)0;
  for( ; !(i >= 4u); i = i + 1u)
    g_object_unref((void *)tray->priv->icons[(signed long int)i]);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_tray_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_tray_get_state
// file widgets/gm-tray.h line 71
enum _GmTrayState gm_tray_get_state(struct _GmTray *tray)
{
  if((signed int)tray->priv->current_state == TRAY_STATE_ACTIVITY)
    return tray->priv->prev_state;

  else
    return tray->priv->current_state;
}

// gm_tray_get_type
// file widgets/gm-tray.c line 27
unsigned long int gm_tray_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_egg_tray_icon_get_type$1;
    return_value_egg_tray_icon_get_type$1=egg_tray_icon_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmTray");
    g_define_type_id=g_type_register_static_simple(return_value_egg_tray_icon_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmTrayClass) /*952ul*/ , (void (*)(void *, void *))gm_tray_class_intern_init, (unsigned int)sizeof(struct _GmTray) /*352ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_tray_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_tray_has_manager
// file widgets/gm-tray.h line 73
signed int gm_tray_has_manager()
{
  struct anonymous$109 *xscreen = &((struct anonymous$111 *)gdk_display)->screens[(signed long int)((struct anonymous$111 *)gdk_display)->default_screen];
  unsigned long int selection_atom;
  char *selection_atom_name;
  signed int return_value_XScreenNumberOfScreen$1;
  return_value_XScreenNumberOfScreen$1=XScreenNumberOfScreen(xscreen);
  selection_atom_name=g_strdup_printf("_NET_SYSTEM_TRAY_S%d", return_value_XScreenNumberOfScreen$1);
  selection_atom=XInternAtom(xscreen->display, selection_atom_name, 0);
  g_free((void *)selection_atom_name);
  unsigned long int return_value_XGetSelectionOwner$2;
  return_value_XGetSelectionOwner$2=XGetSelectionOwner(xscreen->display, selection_atom);
  if(!(return_value_XGetSelectionOwner$2 == 0ul))
    return (signed int)!(0 != 0);

  else
    return 0;
}

// gm_tray_init
// file widgets/gm-tray.c line 54
static void gm_tray_init(struct _GmTray *tray)
{
  unsigned int i;
  struct _GtkWidget *image;
  unsigned long int return_value_gm_tray_get_type$1;
  return_value_gm_tray_get_type$1=gm_tray_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)tray, return_value_gm_tray_get_type$1);
  tray->priv = (struct _GmTrayPrivate *)return_value_g_type_instance_get_private$2;
  tray->priv->event_box=gtk_event_box_new();
  tray->priv->current_state = (enum _GmTrayState)TRAY_STATE_NORMAL;
  i = (unsigned int)0;
  for( ; !(i >= 4u); i = i + 1u)
    tray->priv->icons[(signed long int)i] = (struct _GdkPixbuf *)(void *)0;
  image=gtk_image_new();
  unsigned long int return_value_gtk_container_get_type$3;
  return_value_gtk_container_get_type$3=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)tray->priv->event_box, return_value_gtk_container_get_type$3);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$4, image);
  tray->priv->tooltips=gtk_tooltips_new();
  gtk_widget_show(tray->priv->event_box);
  gtk_widget_show(image);
  unsigned long int return_value_gtk_container_get_type$5;
  return_value_gtk_container_get_type$5=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)tray, return_value_gtk_container_get_type$5);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$6, tray->priv->event_box);
  unsigned long int return_value_gtk_widget_get_type$7;
  return_value_gtk_widget_get_type$7=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)tray, return_value_gtk_widget_get_type$7);
  gtk_widget_add_events((struct _GtkWidget *)return_value_g_type_check_instance_cast$8, GDK_BUTTON_PRESS_MASK);
  unsigned long int return_value_gtk_image_get_type$9;
  return_value_gtk_image_get_type$9=gtk_image_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)image, return_value_gtk_image_get_type$9);
  tray->priv->image = (struct _GtkImage *)return_value_g_type_check_instance_cast$10;
}

// gm_tray_message
// file widgets/gm-tray.c line 170
void gm_tray_message(struct _GmTray *tray, const char *message)
{
  unsigned long int return_value_egg_tray_icon_get_type$1;
  return_value_egg_tray_icon_get_type$1=egg_tray_icon_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)tray, return_value_egg_tray_icon_get_type$1);
  signed long int return_value_g_utf8_strlen$3;
  return_value_g_utf8_strlen$3=g_utf8_strlen(message, (signed long int)-1);
  egg_tray_icon_send_message((struct _EggTrayIcon *)return_value_g_type_check_instance_cast$2, 5000, message, (signed int)return_value_g_utf8_strlen$3);
}

// gm_tray_new
// file widgets/gm-tray.h line 61
struct _GmTray * gm_tray_new(const char *title)
{
  unsigned long int return_value_gm_tray_get_type$1;
  return_value_gm_tray_get_type$1=gm_tray_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_tray_get_type$1, "title", title, (void *)0);
  return (struct _GmTray *)return_value_g_object_new$2;
}

// gm_tray_normal
// file widgets/gm-tray.h line 65
void gm_tray_normal(struct _GmTray *tray)
{
  gm_tray_set_state(tray, (enum _GmTrayState)TRAY_STATE_NORMAL);
  gm_tray_set_tip(tray, (const char *)(void *)0);
}

// gm_tray_notify
// file widgets/gm-tray.h line 67
void gm_tray_notify(struct _GmTray *tray, const char *message)
{
  gm_tray_set_state(tray, (enum _GmTrayState)TRAY_STATE_NOTIFY);
  gm_tray_message(tray, message);
  gm_tray_set_tip(tray, message);
}

// gm_tray_restore_from_activity
// file widgets/gm-tray.c line 105
static signed int gm_tray_restore_from_activity(void *user_data)
{
  struct _GmTray *tray;
  unsigned long int return_value_gm_tray_get_type$1;
  return_value_gm_tray_get_type$1=gm_tray_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_gm_tray_get_type$1);
  tray = (struct _GmTray *)return_value_g_type_check_instance_cast$2;
  tray->priv->flash_timeout = (unsigned int)0;
  gm_tray_set_state(tray, tray->priv->prev_state);
  return 0;
}

// gm_tray_set_icon
// file widgets/gm-tray.h line 62
void gm_tray_set_icon(struct _GmTray *tray, enum _GmTrayState state, struct _GdkPixbuf *icon)
{
  if(!(tray->priv->icons[(signed long int)state] == ((struct _GdkPixbuf *)NULL)))
    g_object_unref((void *)tray->priv->icons[(signed long int)state]);

  void *return_value_g_object_ref$1;
  return_value_g_object_ref$1=g_object_ref((void *)icon);
  tray->priv->icons[(signed long int)state] = (struct _GdkPixbuf *)return_value_g_object_ref$1;
  if(state == tray->priv->current_state)
    gm_tray_update_icon(tray);

}

// gm_tray_set_state
// file widgets/gm-tray.c line 88
static void gm_tray_set_state(struct _GmTray *tray, enum _GmTrayState state)
{
  if(!(tray->priv->current_state == state))
  {
    if(!(tray->priv->flash_timeout == 0u))
    {
      g_source_remove(tray->priv->flash_timeout);
      tray->priv->flash_timeout = (unsigned int)0;
    }

    tray->priv->prev_state = tray->priv->current_state;
    tray->priv->current_state = state;
    gm_tray_update_icon(tray);
  }

}

// gm_tray_set_tip
// file widgets/gm-tray.h line 70
void gm_tray_set_tip(struct _GmTray *tray, const char *message)
{
  gtk_tooltips_set_tip(tray->priv->tooltips, tray->priv->event_box, message, message);
}

// gm_tray_update_icon
// file widgets/gm-tray.c line 82
static void gm_tray_update_icon(struct _GmTray *tray)
{
  gtk_image_set_from_pixbuf(tray->priv->image, tray->priv->icons[(signed long int)tray->priv->current_state]);
}

// gm_trigger_add_action
// file gm-triggers.c line 186
void gm_trigger_add_action(struct _GmTrigger *trigger, struct _GmTriggerData *action)
{
  trigger->actions=g_list_append(trigger->actions, (void *)action);
}

// gm_trigger_add_condition
// file gm-triggers.c line 181
void gm_trigger_add_condition(struct _GmTrigger *trigger, struct _GmTriggerData *condition)
{
  trigger->conditions=g_list_append(trigger->conditions, (void *)condition);
}

// gm_trigger_data_free
// file gm-triggers.c line 175
void gm_trigger_data_free(struct _GmTriggerData *tdata)
{
  g_free((void *)tdata->data);
  g_free((void *)tdata);
}

// gm_trigger_data_new
// file ./gm-triggers.h line 125
struct _GmTriggerData * gm_trigger_data_new(signed int type, char *data)
{
  struct _GmTriggerData *tdata;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmTriggerData) /*80ul*/ );
  tdata = (struct _GmTriggerData *)return_value_g_malloc0_n$1;
  tdata->type = (unsigned int)type;
  tdata->data = data;
  memset((void *)&tdata->expr, 0, sizeof(struct re_pattern_buffer) /*64ul*/ );
  if(tdata->type == 6u || tdata->type == 7u || tdata->type == 8u || tdata->type == 9u || tdata->type == 10u || tdata->type == 11u || tdata->type == 12u || tdata->type == 13u)
    regcomp(&tdata->expr, tdata->data, 1);

  return tdata;
}

// gm_trigger_dup
// file ./gm-triggers.h line 112
struct _GmTrigger * gm_trigger_dup(struct _GmTrigger *source)
{
  struct _GmTrigger *result;
  result=gm_trigger_new();
  result->name=g_strdup(source->name);
  result->event = source->event;
  result->conditions=gm_trigger_list_dup(source->conditions);
  result->actions=gm_trigger_list_dup(source->actions);
  return result;
}

// gm_trigger_free
// file ./gm-triggers.h line 111
void gm_trigger_free(struct _GmTrigger *trigger)
{
  gm_trigger_free_list(trigger->conditions);
  gm_trigger_free_list(trigger->actions);
  g_free((void *)trigger->name);
  g_free((void *)trigger);
}

// gm_trigger_free_list
// file ./gm-triggers.h line 114
void gm_trigger_free_list(struct _GList *list)
{
  struct _GList *item;
  struct _GmTriggerData *data;
  item = list;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    data = (struct _GmTriggerData *)item->data;
    gm_trigger_data_free(data);
  }
  g_list_free(list);
}

// gm_trigger_list_dup
// file gm-triggers.c line 99
struct _GList * gm_trigger_list_dup(struct _GList *list)
{
  struct _GList *result = (struct _GList *)(void *)0;
  struct _GList *item;
  struct _GmTriggerData *data;
  item = list;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    data = (struct _GmTriggerData *)item->data;
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup(data->data);
    struct _GmTriggerData *return_value_gm_trigger_data_new$2;
    return_value_gm_trigger_data_new$2=gm_trigger_data_new((signed int)data->type, return_value_g_strdup$1);
    result=g_list_append(result, (void *)return_value_gm_trigger_data_new$2);
  }
  return result;
}

// gm_trigger_match
// file gm-triggers.c line 244
signed int gm_trigger_match(struct _GmTrigger *trigger, char *text, struct anonymous$17 *matches, signed int nmatch)
{
  struct _GmTriggerData *data;
  struct _GList *item;
  char *tmp;
  signed int istrue;
  signed int cmatch = 0;
  signed int ret;
  signed int offset;
  signed int len;
  _Bool tmp_if_expr$6;
  signed long int return_value_g_utf8_pointer_to_offset$4;
  signed long int return_value_g_utf8_strlen$5;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$12;
  if(trigger->conditions == ((struct _GList *)NULL))
    return 0;

  else
  {
    item = trigger->conditions;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      data = (struct _GmTriggerData *)item->data;
      signed long int return_value_g_utf8_strlen$1;
      return_value_g_utf8_strlen$1=g_utf8_strlen(data->data, (signed long int)-1);
      len = (signed int)return_value_g_utf8_strlen$1;
      if(cmatch >= nmatch)
        return 0;

      switch(data->type)
      {
        case (unsigned int)TCT_CONTAINS:

        case (unsigned int)TCT_NOT_CONTAINS:

        case (unsigned int)TCT_BEGINS:

        case (unsigned int)TCT_NOT_BEGINS:

        case (unsigned int)TCT_ENDS:

        case (unsigned int)TCT_NOT_ENDS:
        {
          tmp=strstr(text, data->data);
          switch(data->type)
          {
            case (unsigned int)TCT_CONTAINS:
            {
              if(!(tmp == ((char *)NULL)))
                while(!(tmp == ((char *)NULL)) && !(cmatch >= nmatch))
                {
                  signed long int return_value_g_utf8_pointer_to_offset$2;
                  return_value_g_utf8_pointer_to_offset$2=g_utf8_pointer_to_offset(text, tmp);
                  (matches + (signed long int)cmatch)->rm_so = (signed int)return_value_g_utf8_pointer_to_offset$2;
                  (matches + (signed long int)cmatch)->rm_eo = len;
                  tmp=strstr(tmp + (signed long int)len, data->data);
                  if(!(tmp == ((char *)NULL)))
                    cmatch = cmatch + 1;

                }

              else
                return 0;
              break;
            }
            case (unsigned int)TCT_NOT_CONTAINS:
            {
              if(tmp == ((char *)NULL))
              {
                (matches + (signed long int)cmatch)->rm_so = 0;
                (matches + (signed long int)cmatch)->rm_eo = len;
              }

              else
                return 0;
              break;
            }
            case (unsigned int)TCT_NOT_BEGINS:
            {
              if(!(tmp == text))
              {
                (matches + (signed long int)cmatch)->rm_so = 0;
                signed long int return_value_g_utf8_strlen$3;
                return_value_g_utf8_strlen$3=g_utf8_strlen(text, (signed long int)-1);
                (matches + (signed long int)cmatch)->rm_eo = (signed int)return_value_g_utf8_strlen$3;
              }

              else
                return 0;
              break;
            }
            default:
            {
              if(!(tmp == ((char *)NULL)))
              {
                return_value_g_utf8_pointer_to_offset$4=g_utf8_pointer_to_offset(text, tmp);
                return_value_g_utf8_strlen$5=g_utf8_strlen(text, (signed long int)-1);
                tmp_if_expr$6 = return_value_g_utf8_pointer_to_offset$4 + (signed long int)len == return_value_g_utf8_strlen$5 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$6 = (_Bool)0;
              istrue = (signed int)tmp_if_expr$6;
              if(!(istrue == 0))
                tmp_if_expr$10 = data->type == (unsigned int)TCT_ENDS ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$10 = (_Bool)0;
              if(tmp_if_expr$10)
              {
                signed long int return_value_g_utf8_pointer_to_offset$7;
                return_value_g_utf8_pointer_to_offset$7=g_utf8_pointer_to_offset(text, tmp);
                (matches + (signed long int)cmatch)->rm_so = (signed int)return_value_g_utf8_pointer_to_offset$7;
                (matches + (signed long int)cmatch)->rm_eo = len;
              }

              else
              {
                if(istrue == 0)
                  tmp_if_expr$9 = data->type == (unsigned int)TCT_NOT_ENDS ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$9 = (_Bool)0;
                if(tmp_if_expr$9)
                {
                  (matches + (signed long int)cmatch)->rm_so = 0;
                  signed long int return_value_g_utf8_strlen$8;
                  return_value_g_utf8_strlen$8=g_utf8_strlen(text, (signed long int)-1);
                  (matches + (signed long int)cmatch)->rm_eo = (signed int)return_value_g_utf8_strlen$8;
                }

                else
                  return 0;
              }
            }
          }
          cmatch = cmatch + 1;
          (matches + (signed long int)cmatch)->rm_so = -1;
          break;
        }
        case (unsigned int)TCT_MATCHES:

        case (unsigned int)TCT_NOT_MATCHES:
        {
          offset = 0;
          ret=regexec(&data->expr, (char *)text, (unsigned long int)((nmatch - cmatch) - 1), matches + (signed long int)cmatch, 0);
          if(ret == 0)
            tmp_if_expr$13 = data->type == (unsigned int)TCT_MATCHES ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
            while(ret == 0)
            {
              for( ; !((matches + (signed long int)cmatch)->rm_so == -1); cmatch = cmatch + 1)
              {
                (matches + (signed long int)cmatch)->rm_eo = (matches + (signed long int)cmatch)->rm_eo - (matches + (signed long int)cmatch)->rm_so;
                (matches + (signed long int)cmatch)->rm_so = (matches + (signed long int)cmatch)->rm_so + offset;
              }
              offset = (matches + (signed long int)(cmatch - 1))->rm_so + (matches + (signed long int)(cmatch - 1))->rm_eo;
              if(!(cmatch >= nmatch))
                ret=regexec(&data->expr, (char *)(text + (signed long int)offset), (unsigned long int)((nmatch - cmatch) - 1), matches + (signed long int)cmatch, 0);

              else
                ret = 1;
            }

          else
          {
            if(!(ret == 0))
              tmp_if_expr$12 = data->type == (unsigned int)TCT_NOT_MATCHES ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$12 = (_Bool)0;
            if(tmp_if_expr$12)
            {
              (matches + (signed long int)cmatch)->rm_so = 0;
              signed long int return_value_g_utf8_strlen$11;
              return_value_g_utf8_strlen$11=g_utf8_strlen(text, (signed long int)-1);
              (matches + (signed long int)cmatch)->rm_eo = (signed int)return_value_g_utf8_strlen$11;
            }

            else
              return 0;
          }
          break;
        }
        default:
          return 0;
      }
    }
    return cmatch;
  }
}

// gm_trigger_match_user
// file ./gm-triggers.h line 120
signed int gm_trigger_match_user(struct _GmTrigger *trigger, const char *username, enum _GmTriggerConditionType condition, struct anonymous$17 *matches, signed int nmatch)
{
  struct _GmTriggerData *data;
  struct _GList *item;
  signed int cmatch = 0;
  signed int offset;
  signed int ret;
  if(trigger->conditions == ((struct _GList *)NULL))
    return 0;

  else
  {
    item = trigger->conditions;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      data = (struct _GmTriggerData *)item->data;
      if(cmatch >= nmatch)
        return 0;

      if(data->type == (unsigned int)condition)
      {
        offset = 0;
        ret=regexec(&data->expr, (char *)username, (unsigned long int)((nmatch - cmatch) - 1), matches + (signed long int)cmatch, 0);
        if(ret == 0)
          for( ; !((matches + (signed long int)cmatch)->rm_so == -1); cmatch = cmatch + 1)
          {
            (matches + (signed long int)cmatch)->rm_eo = (matches + (signed long int)cmatch)->rm_eo - (matches + (signed long int)cmatch)->rm_so;
            (matches + (signed long int)cmatch)->rm_so = (matches + (signed long int)cmatch)->rm_so + offset;
          }

        else
          return 0;
      }

      else
        return 0;
    }
    return cmatch;
  }
}

// gm_trigger_name_from_type
// file gm-triggers.c line 380
const char * gm_trigger_name_from_type(signed int type, const struct _trigger_trans *trans_table)
{
  signed int i = 0;
  for( ; !((trans_table + (signed long int)i)->type == -1); i = i + 1)
    if((trans_table + (signed long int)i)->type == type)
      return (trans_table + (signed long int)i)->name;

  return (const char *)(void *)0;
}

// gm_trigger_new
// file ./gm-triggers.h line 110
struct _GmTrigger * gm_trigger_new()
{
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmTrigger) /*32ul*/ );
  return (struct _GmTrigger *)return_value_g_malloc0_n$1;
}

// gm_trigger_rules_xml
// file gm-triggers.c line 519
void gm_trigger_rules_xml(struct _GmTrigger *t, struct _xmlNode *trig)
{
  struct _GmTriggerData *data;
  struct _GList *item;
  struct _xmlNode *child;
  item = t->conditions;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    data = (struct _GmTriggerData *)item->data;
    child=xmlNewChild(trig, (struct _xmlNs *)(void *)0, (const unsigned char *)"condition", (const unsigned char *)(void *)0);
    const char *return_value_gm_trigger_name_from_type$1;
    return_value_gm_trigger_name_from_type$1=gm_trigger_name_from_type((signed int)data->type, table_conditions);
    xmlNewProp(child, (const unsigned char *)"type", (const unsigned char *)return_value_gm_trigger_name_from_type$1);
    if(!(data->data == ((char *)NULL)))
      xmlNewProp(child, (const unsigned char *)"data", (const unsigned char *)data->data);

  }
  item = t->actions;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    data = (struct _GmTriggerData *)item->data;
    child=xmlNewChild(trig, (struct _xmlNs *)(void *)0, (const unsigned char *)"action", (const unsigned char *)(void *)0);
    const char *return_value_gm_trigger_name_from_type$2;
    return_value_gm_trigger_name_from_type$2=gm_trigger_name_from_type((signed int)data->type, table_actions);
    xmlNewProp(child, (const unsigned char *)"type", (const unsigned char *)return_value_gm_trigger_name_from_type$2);
    if(!(data->data == ((char *)NULL)))
      xmlNewProp(child, (const unsigned char *)"data", (const unsigned char *)data->data);

  }
}

// gm_trigger_set_actions
// file ./gm-triggers.h line 118
void gm_trigger_set_actions(struct _GmTrigger *trigger, struct _GList *actions)
{
  gm_trigger_free_list(trigger->actions);
  trigger->actions = actions;
}

// gm_trigger_set_conditions
// file ./gm-triggers.h line 117
void gm_trigger_set_conditions(struct _GmTrigger *trigger, struct _GList *conditions)
{
  gm_trigger_free_list(trigger->conditions);
  trigger->conditions = conditions;
}

// gm_trigger_set_name
// file ./gm-triggers.h line 113
void gm_trigger_set_name(struct _GmTrigger *trigger, const char *name)
{
  g_free((void *)trigger->name);
  trigger->name=g_strdup(name);
}

// gm_trigger_type_from_name
// file gm-triggers.c line 366
signed int gm_trigger_type_from_name(const char *name, const struct _trigger_trans *trans_table)
{
  signed int i = 0;
  for( ; !((trans_table + (signed long int)i)->type == -1); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp((trans_table + (signed long int)i)->name, name);
    if(return_value_strcasecmp$1 == 0)
      return (trans_table + (signed long int)i)->type;

  }
  return -1;
}

// gm_triggers_add
// file ./gm-triggers.h line 107
void gm_triggers_add(struct _GmTriggers *trg, struct _GmTrigger *t)
{
  trg->priv->triggers=g_list_append(trg->priv->triggers, (void *)t);
}

// gm_triggers_class_init
// file gm-triggers.c line 78
static void gm_triggers_class_init(struct _GmTriggersClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_triggers_finalize;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmTriggersPrivate) /*16ul*/ );
}

// gm_triggers_class_intern_init
// file gm-triggers.c line 60
static void gm_triggers_class_intern_init(void *klass)
{
  gm_triggers_parent_class=g_type_class_peek_parent(klass);
  if(!(GmTriggers_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmTriggers_private_offset);

  gm_triggers_class_init((struct _GmTriggersClass *)klass);
}

// gm_triggers_clear
// file ./gm-triggers.h line 108
void gm_triggers_clear(struct _GmTriggers *trg)
{
  struct _GList *item = trg->priv->triggers;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    gm_trigger_free((struct _GmTrigger *)item->data);
  g_list_free(trg->priv->triggers);
  trg->priv->triggers = (struct _GList *)(void *)0;
}

// gm_triggers_dialog_collect_rules
// file dialogs/gm-triggers-dialog.c line 259
struct _GList * gm_triggers_dialog_collect_rules(struct _GmTriggersDialog *triggers, struct _GtkWidget *vbox)
{
  char *text;
  struct _GList *children;
  struct _GList *child;
  struct _GList *item;
  struct _GList *result = (struct _GList *)(void *)0;
  struct _GtkComboBox *combo;
  struct _GtkEntry *entry;
  struct _ModelData *data;
  struct _GmTriggerData *d;
  unsigned long int return_value_gtk_container_get_type$1;
  return_value_gtk_container_get_type$1=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type$1);
  children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$2);
  item = children;
  _Bool tmp_if_expr$3;
  signed int tmp_statement_expression$15;
  _Bool tmp_if_expr$16;
  void *return_value;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    if((struct _GtkWidget *)item->data == triggers->hbox_add_condition)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (struct _GtkWidget *)item->data == triggers->hbox_add_action ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      break;

    struct _GTypeInstance *__inst = (struct _GTypeInstance *)item->data;
    unsigned long int __t;
    __t=gtk_hbox_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$16 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$16 = (_Bool)0;
      if(tmp_if_expr$16)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$15 = __r;
    if(!(tmp_statement_expression$15 == 0))
    {
      unsigned long int return_value_gtk_container_get_type$4;
      return_value_gtk_container_get_type$4=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_container_get_type$4);
      child=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$5);
      unsigned long int return_value_gtk_combo_box_get_type$6;
      return_value_gtk_combo_box_get_type$6=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
      return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)child->data, return_value_gtk_combo_box_get_type$6);
      combo = (struct _GtkComboBox *)return_value_g_type_check_instance_cast$7;
      data=gm_triggers_dialog_combo_get_selected_data(triggers, combo);
      d = (struct _GmTriggerData *)(void *)0;
      switch(data->args)
      {
        case 0:
        {
          d=gm_trigger_data_new(data->type, (char *)(void *)0);
          break;
        }
        case 1:
        {
          if(!(child->next == ((struct _GList *)NULL)))
          {
            unsigned long int return_value_gtk_entry_get_type$8;
            return_value_gtk_entry_get_type$8=gtk_entry_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
            return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)child->next->data, return_value_gtk_entry_get_type$8);
            entry = (struct _GtkEntry *)return_value_g_type_check_instance_cast$9;
            const char *return_value_gtk_entry_get_text$10;
            return_value_gtk_entry_get_text$10=gtk_entry_get_text(entry);
            text = (char *)return_value_gtk_entry_get_text$10;
            signed long int return_value_g_utf8_strlen$12;
            return_value_g_utf8_strlen$12=g_utf8_strlen(text, (signed long int)-1);
            if(return_value_g_utf8_strlen$12 >= 1l)
            {
              char *return_value_g_strdup$11;
              return_value_g_strdup$11=g_strdup(text);
              d=gm_trigger_data_new(data->type, return_value_g_strdup$11);
            }

          }

          break;
        }
        case 2:
          return_value=data->func(triggers, (enum _CustomArgType)CUSTOM_ARG_GET_DATA, (void *)child->next, (void *)0);
        default:
          ;
      }
      if(!(d == ((struct _GmTriggerData *)NULL)))
        result=g_list_append(result, (void *)d);

      g_list_free(child);
    }

  }
  g_list_free(children);
  return result;
}

// gm_triggers_dialog_combo_get_selected_data
// file dialogs/gm-triggers-dialog.c line 246
struct _ModelData * gm_triggers_dialog_combo_get_selected_data(struct _GmTriggersDialog *triggers, struct _GtkComboBox *combo)
{
  struct _GtkTreeIter iter;
  struct _ModelData *data;
  gtk_combo_box_get_active_iter(combo, &iter);
  struct _GtkTreeModel *return_value_gtk_combo_box_get_model$1;
  return_value_gtk_combo_box_get_model$1=gtk_combo_box_get_model(combo);
  gtk_tree_model_get(return_value_gtk_combo_box_get_model$1, &iter, 1, &data, -1);
  return data;
}

// gm_triggers_dialog_create_item
// file dialogs/gm-triggers-dialog.c line 545
struct _GtkWidget * gm_triggers_dialog_create_item(struct _GmTriggersDialog *triggers, struct _GtkTreeModel *model, struct _GmTriggerData *t)
{
  struct _GtkWidget *hbox;
  struct _GtkWidget *combo;
  struct _GtkWidget *button;
  struct _ComboBoxTypeData *data;
  struct _GtkCellRenderer *renderer;
  renderer=gtk_cell_renderer_text_new();
  hbox=gtk_hbox_new(0, 6);
  combo=gtk_combo_box_new_with_model(model);
  unsigned long int return_value_gtk_cell_layout_get_type$1;
  return_value_gtk_cell_layout_get_type$1=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_cell_layout_get_type$1);
  gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$2, renderer, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_cell_layout_get_type$3;
  return_value_gtk_cell_layout_get_type$3=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_cell_layout_get_type$3);
  gtk_cell_layout_set_attributes((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$4, renderer, (const void *)"text", 0, (void *)0);
  void *return_value_g_malloc0_n$5;
  return_value_g_malloc0_n$5=g_malloc0_n((unsigned long int)1, sizeof(struct _ComboBoxTypeData) /*16ul*/ );
  data = (struct _ComboBoxTypeData *)return_value_g_malloc0_n$5;
  data->triggers = triggers;
  data->data = t;
  g_signal_connect_data((void *)combo, "changed", (void (*)(void))on_combo_box_type_changed, (void *)data, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)combo, "destroy", (void (*)(void))on_combo_box_type_destroy, (void *)data, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  button=gtk_button_new_from_stock("gtk-remove");
  g_signal_connect_data((void *)button, "clicked", (void (*)(void))on_button_remove_clicked, (void *)triggers, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_box_get_type$6;
  return_value_gtk_box_get_type$6=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$6);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$7, combo, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$8;
  return_value_gtk_box_get_type$8=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$8);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$9, button, 0, (signed int)!(0 != 0), (unsigned int)0);
  gtk_widget_show_all(hbox);
  return hbox;
}

// gm_triggers_dialog_create_models
// file dialogs/gm-triggers-dialog.c line 185
void gm_triggers_dialog_create_models(struct _GmTriggersDialog *triggers, const struct _ModelData *conditionData, const struct _ModelData *actionData)
{
  signed int i;
  struct _GtkTreeIter iter;
  struct _ModelData *data;
  struct _GtkListStore *return_value_gtk_list_store_new$1;
  return_value_gtk_list_store_new$1=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(17 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$2;
  return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_list_store_new$1, return_value_gtk_tree_model_get_type$2);
  triggers->action_model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3;
  struct _GtkListStore *return_value_gtk_list_store_new$4;
  return_value_gtk_list_store_new$4=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(17 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$5;
  return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_list_store_new$4, return_value_gtk_tree_model_get_type$5);
  triggers->condition_model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6;
  struct _GtkListStore *return_value_gtk_list_store_new$7;
  return_value_gtk_list_store_new$7=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$8;
  return_value_gtk_tree_model_get_type$8=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_list_store_new$7, return_value_gtk_tree_model_get_type$8);
  triggers->highlight_model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$9;
  i = 0;
  for( ; !((conditionData + (signed long int)i)->type == -1); i = i + 1)
  {
    data = (struct _ModelData *)&conditionData[(signed long int)i];
    unsigned long int return_value_gtk_list_store_get_type$10;
    return_value_gtk_list_store_get_type$10=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)triggers->condition_model, return_value_gtk_list_store_get_type$10);
    gtk_list_store_append((struct _GtkListStore *)return_value_g_type_check_instance_cast$11, &iter);
    unsigned long int return_value_gtk_list_store_get_type$12;
    return_value_gtk_list_store_get_type$12=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)triggers->condition_model, return_value_gtk_list_store_get_type$12);
    char *return_value_gettext$14;
    return_value_gettext$14=gettext(data->title);
    gtk_list_store_set((struct _GtkListStore *)return_value_g_type_check_instance_cast$13, &iter, 0, return_value_gettext$14, 1, data, -1);
  }
  i = 0;
  for( ; !((actionData + (signed long int)i)->type == -1); i = i + 1)
  {
    data = (struct _ModelData *)&actionData[(signed long int)i];
    unsigned long int return_value_gtk_list_store_get_type$15;
    return_value_gtk_list_store_get_type$15=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)triggers->action_model, return_value_gtk_list_store_get_type$15);
    gtk_list_store_append((struct _GtkListStore *)return_value_g_type_check_instance_cast$16, &iter);
    unsigned long int return_value_gtk_list_store_get_type$17;
    return_value_gtk_list_store_get_type$17=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)triggers->action_model, return_value_gtk_list_store_get_type$17);
    char *return_value_gettext$19;
    return_value_gettext$19=gettext(data->title);
    gtk_list_store_set((struct _GtkListStore *)return_value_g_type_check_instance_cast$18, &iter, 0, return_value_gettext$19, 1, data, -1);
  }
  i = 0;
  for( ; !(highlightTags[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
  {
    unsigned long int return_value_gtk_list_store_get_type$20;
    return_value_gtk_list_store_get_type$20=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)triggers->highlight_model, return_value_gtk_list_store_get_type$20);
    gtk_list_store_append((struct _GtkListStore *)return_value_g_type_check_instance_cast$21, &iter);
    unsigned long int return_value_gtk_list_store_get_type$22;
    return_value_gtk_list_store_get_type$22=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)triggers->highlight_model, return_value_gtk_list_store_get_type$22);
    char *return_value_gettext$24;
    return_value_gettext$24=gettext(highlightTags[(signed long int)i].name);
    gtk_list_store_set((struct _GtkListStore *)return_value_g_type_check_instance_cast$23, &iter, 0, return_value_gettext$24, 1, highlightTags[(signed long int)i].tag, -1);
  }
}

// gm_triggers_dialog_custom_arg_browse
// file dialogs/gm-triggers-dialog.c line 849
void * gm_triggers_dialog_custom_arg_browse(struct _GmTriggersDialog *triggers, enum _CustomArgType type, void *data, void *user_data)
{
  struct _GtkWidget *hbox;
  struct _GtkWidget *entry;
  struct _GtkWidget *browse;
  struct _GtkWidget *tmp;
  struct _GmTriggerData *t = (struct _GmTriggerData *)user_data;
  struct _GList *item;
  unsigned long int return_value_gtk_widget_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_container_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  unsigned long int return_value_gtk_box_get_type$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  struct _GtkWidget *return_value_gtk_image_new_from_stock$9;
  unsigned long int return_value_gtk_box_get_type$10;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  char *return_value_gettext$12;
  struct _GtkWidget *return_value_gtk_label_new$13;
  unsigned long int return_value_gtk_box_get_type$14;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  unsigned long int return_value_gtk_box_get_type$16;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  unsigned long int return_value_gtk_entry_get_type$18;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  const char *return_value_gtk_entry_get_text$20;
  char *return_value_g_strdup$21;
  switch((signed int)type)
  {
    case CUSTOM_ARG_CREATE:
    {
      return_value_gtk_widget_get_type$1=gtk_widget_get_type();
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_gtk_widget_get_type$1);
      hbox = (struct _GtkWidget *)return_value_g_type_check_instance_cast$2;
      entry=gtk_entry_new();
      if(!(t == ((struct _GmTriggerData *)NULL)))
      {
        unsigned long int return_value_gtk_entry_get_type$3;
        return_value_gtk_entry_get_type$3=gtk_entry_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$3);
        gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, t->data);
      }

      browse=gtk_button_new();
      tmp=gtk_hbox_new(0, 3);
      return_value_gtk_container_get_type$5=gtk_container_get_type();
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)browse, return_value_gtk_container_get_type$5);
      gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$6, tmp);
      return_value_gtk_box_get_type$7=gtk_box_get_type();
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)tmp, return_value_gtk_box_get_type$7);
      return_value_gtk_image_new_from_stock$9=gtk_image_new_from_stock("gtk-open", (enum anonymous$21)GTK_ICON_SIZE_BUTTON);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$8, return_value_gtk_image_new_from_stock$9, 0, (signed int)!(0 != 0), (unsigned int)0);
      return_value_gtk_box_get_type$10=gtk_box_get_type();
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)tmp, return_value_gtk_box_get_type$10);
      return_value_gettext$12=gettext("Browse");
      return_value_gtk_label_new$13=gtk_label_new(return_value_gettext$12);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$11, return_value_gtk_label_new$13, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
      g_signal_connect_data((void *)browse, "clicked", (void (*)(void))on_button_browse_clicked, (void *)entry, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
      gtk_widget_show(entry);
      gtk_widget_show_all(browse);
      return_value_gtk_box_get_type$14=gtk_box_get_type();
      return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$14);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$15, entry, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
      return_value_gtk_box_get_type$16=gtk_box_get_type();
      return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$16);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$17, browse, 0, (signed int)!(0 != 0), (unsigned int)0);
      goto __CPROVER_DUMP_L4;
    }
    case CUSTOM_ARG_GET_DATA:
    {
      item = (struct _GList *)data;
      return_value_gtk_entry_get_type$18=gtk_entry_get_type();
      return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_entry_get_type$18);
      return_value_gtk_entry_get_text$20=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$19);
      return_value_g_strdup$21=g_strdup(return_value_gtk_entry_get_text$20);
      return (void *)return_value_g_strdup$21;
    }
    default:
    {

    __CPROVER_DUMP_L4:
      ;
      return (void *)0;
    }
  }
}

// gm_triggers_dialog_custom_arg_highlight
// file dialogs/gm-triggers-dialog.c line 773
void * gm_triggers_dialog_custom_arg_highlight(struct _GmTriggersDialog *triggers, enum _CustomArgType type, void *data, void *user_data)
{
  struct _GtkWidget *hbox;
  struct _GtkWidget *combo;
  struct _GtkCellRenderer *renderer;
  struct _GList *item;
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  char *tag;
  struct _GmTriggerData *t = (struct _GmTriggerData *)user_data;
  unsigned long int return_value_gtk_widget_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_cell_layout_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  unsigned long int return_value_gtk_cell_layout_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  signed int return_value_gtk_tree_model_iter_next$11;
  unsigned long int return_value_gtk_box_get_type$16;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  unsigned long int return_value_gtk_combo_box_get_type$18;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  unsigned long int return_value_gtk_combo_box_get_type$20;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  switch((signed int)type)
  {
    case CUSTOM_ARG_CREATE:
    {
      return_value_gtk_widget_get_type$1=gtk_widget_get_type();
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_gtk_widget_get_type$1);
      hbox = (struct _GtkWidget *)return_value_g_type_check_instance_cast$2;
      combo=gtk_combo_box_new_with_model(triggers->highlight_model);
      renderer=gtk_cell_renderer_text_new();
      return_value_gtk_cell_layout_get_type$3=gtk_cell_layout_get_type();
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_cell_layout_get_type$3);
      gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$4, renderer, (signed int)!(0 != 0));
      return_value_gtk_cell_layout_get_type$5=gtk_cell_layout_get_type();
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_cell_layout_get_type$5);
      gtk_cell_layout_set_attributes((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$6, renderer, (const void *)"text", 0, (void *)0);
      if(user_data == NULL)
      {
        unsigned long int return_value_gtk_combo_box_get_type$7;
        return_value_gtk_combo_box_get_type$7=gtk_combo_box_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_combo_box_get_type$7);
        gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$8, 0);
      }

      else
      {
        unsigned long int return_value_gtk_combo_box_get_type$9;
        return_value_gtk_combo_box_get_type$9=gtk_combo_box_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_combo_box_get_type$9);
        model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$10);
        signed int return_value_gtk_tree_model_get_iter_first$15;
        return_value_gtk_tree_model_get_iter_first$15=gtk_tree_model_get_iter_first(model, &iter);
        if(!(return_value_gtk_tree_model_get_iter_first$15 == 0))
          do
          {
            gtk_tree_model_get(model, &iter, 1, &tag, -1);
            signed int return_value_strcmp$14;
            return_value_strcmp$14=strcmp(tag, t->data);
            if(return_value_strcmp$14 == 0)
            {
              unsigned long int return_value_gtk_combo_box_get_type$12;
              return_value_gtk_combo_box_get_type$12=gtk_combo_box_get_type();
              struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
              return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_combo_box_get_type$12);
              gtk_combo_box_set_active_iter((struct _GtkComboBox *)return_value_g_type_check_instance_cast$13, &iter);
              break;
            }

            g_free((void *)tag);
            return_value_gtk_tree_model_iter_next$11=gtk_tree_model_iter_next(model, &iter);
          }
          while(!(return_value_gtk_tree_model_iter_next$11 == 0));

      }
      gtk_widget_show(combo);
      return_value_gtk_box_get_type$16=gtk_box_get_type();
      return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type$16);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$17, combo, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
      goto __CPROVER_DUMP_L9;
    }
    case CUSTOM_ARG_GET_DATA:
    {
      item = (struct _GList *)data;
      return_value_gtk_combo_box_get_type$18=gtk_combo_box_get_type();
      return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_combo_box_get_type$18);
      model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$19);
      return_value_gtk_combo_box_get_type$20=gtk_combo_box_get_type();
      return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_combo_box_get_type$20);
      gtk_combo_box_get_active_iter((struct _GtkComboBox *)return_value_g_type_check_instance_cast$21, &iter);
      gtk_tree_model_get(model, &iter, 1, &tag, -1);
      return (void *)tag;
    }
    default:
    {

    __CPROVER_DUMP_L9:
      ;
      return (void *)0;
    }
  }
}

// gm_triggers_dialog_fill_trigger
// file dialogs/gm-triggers-dialog.c line 322
signed int gm_triggers_dialog_fill_trigger(struct _GmTriggersDialog *triggers)
{
  const char *name;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)triggers->entry_name, return_value_gtk_entry_get_type$1);
  name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  struct _GList *conditions = (struct _GList *)(void *)0;
  struct _GList *actions = (struct _GList *)(void *)0;
  signed long int return_value_g_utf8_strlen$6;
  return_value_g_utf8_strlen$6=g_utf8_strlen(name, (signed long int)-1);
  if(return_value_g_utf8_strlen$6 == 0l)
  {
    char *return_value_gettext$3;
    return_value_gettext$3=gettext("Please fill in a trigger name");
    unsigned long int return_value_gtk_window_get_type$4;
    return_value_gtk_window_get_type$4=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$4);
    gm_error_dialog(return_value_gettext$3, (struct _GtkWindow *)return_value_g_type_check_instance_cast$5);
    gtk_widget_grab_focus(triggers->entry_name);
    return 0;
  }

  conditions=gm_triggers_dialog_collect_rules(triggers, triggers->vbox_conditions);
  if(conditions == ((struct _GList *)NULL))
  {
    char *return_value_gettext$7;
    return_value_gettext$7=gettext("Please specify at least one condition");
    unsigned long int return_value_gtk_window_get_type$8;
    return_value_gtk_window_get_type$8=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$8);
    gm_error_dialog(return_value_gettext$7, (struct _GtkWindow *)return_value_g_type_check_instance_cast$9);
    return 0;
  }

  actions=gm_triggers_dialog_collect_rules(triggers, triggers->vbox_actions);
  if(actions == ((struct _GList *)NULL))
  {
    gm_trigger_free_list(conditions);
    char *return_value_gettext$10;
    return_value_gettext$10=gettext("Please specify at least one action");
    unsigned long int return_value_gtk_window_get_type$11;
    return_value_gtk_window_get_type$11=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$11);
    gm_error_dialog(return_value_gettext$10, (struct _GtkWindow *)return_value_g_type_check_instance_cast$12);
    return 0;
  }

  gm_trigger_set_name(triggers->trigger, name);
  gm_trigger_set_conditions(triggers->trigger, conditions);
  gm_trigger_set_actions(triggers->trigger, actions);
  return (signed int)!(0 != 0);
}

// gm_triggers_dialog_idle_remove_item
// file dialogs/gm-triggers-dialog.c line 980
signed int gm_triggers_dialog_idle_remove_item(struct _GtkWidget *parent)
{
  gtk_widget_destroy(parent);
  return 0;
}

// gm_triggers_dialog_initialize_event_types
// file dialogs/gm-triggers-dialog.c line 360
void gm_triggers_dialog_initialize_event_types(struct _GmTriggersDialog *triggers)
{
  struct _GtkListStore *store;
  unsigned long int return_value_gdk_pixbuf_get_type$1;
  return_value_gdk_pixbuf_get_type$1=gdk_pixbuf_get_type();
  store=gtk_list_store_new(3, return_value_gdk_pixbuf_get_type$1, (unsigned long int)(16 << 2), (unsigned long int)(6 << 2));
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GtkTreeIter iter;
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$2);
  unsigned long int return_value_gtk_tree_model_get_type$4;
  return_value_gtk_tree_model_get_type$4=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$4);
  gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$3, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$5);
  renderer=gtk_cell_renderer_pixbuf_new();
  column=gtk_tree_view_column_new_with_attributes((const char *)(void *)0, renderer, (const void *)"pixbuf", 0, (void *)0);
  gtk_tree_view_column_set_min_width(column, 40);
  unsigned long int return_value_gtk_tree_view_get_type$6;
  return_value_gtk_tree_view_get_type$6=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$6);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$7, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes((const char *)(void *)0, renderer, (const void *)"markup", 1, (void *)0);
  unsigned long int return_value_gtk_tree_view_get_type$8;
  return_value_gtk_tree_view_get_type$8=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$8);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$9, column);
  gtk_list_store_prepend(store, &iter);
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$10;
  return_value_gm_pixbuf_get_at_size$10=gm_pixbuf_get_at_size("ice-userlist/programmer.svg", 32, 32);
  char *return_value_gettext$11;
  return_value_gettext$11=gettext("<b>Player event</b>\nPlayer events are triggered on userlist activity");
  gtk_list_store_set(store, &iter, 0, return_value_gm_pixbuf_get_at_size$10, 1, return_value_gettext$11, 2, TT_USERS, -1);
  gtk_list_store_prepend(store, &iter);
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$12;
  return_value_gm_pixbuf_get_at_size$12=gm_pixbuf_get_at_size("world.svg", 32, 32);
  char *return_value_gettext$13;
  return_value_gettext$13=gettext("<b>World event</b>\nWorld events are triggered on incoming lines of text");
  gtk_list_store_set(store, &iter, 0, return_value_gm_pixbuf_get_at_size$12, 1, return_value_gettext$13, 2, TT_OUTPUT, -1);
  unsigned long int return_value_gtk_tree_view_get_type$14;
  return_value_gtk_tree_view_get_type$14=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$14);
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$16;
  return_value_gtk_tree_view_get_selection$16=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$15);
  gtk_tree_selection_select_iter(return_value_gtk_tree_view_get_selection$16, &iter);
  unsigned long int return_value_gtk_tree_view_get_type$17;
  return_value_gtk_tree_view_get_type$17=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$17);
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$19;
  return_value_gtk_tree_view_get_selection$19=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$18);
  g_signal_connect_data((void *)return_value_gtk_tree_view_get_selection$19, "changed", (void (*)(void))on_tree_view_event_types_changed, (void *)triggers, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
}

// gm_triggers_dialog_new_action
// file dialogs/gm-triggers-dialog.c line 627
void gm_triggers_dialog_new_action(struct _GmTriggersDialog *triggers)
{
  struct _GtkWidget *hbox;
  struct _GList *children;
  hbox=gm_triggers_dialog_create_item(triggers, triggers->action_model, (struct _GmTriggerData *)(void *)0);
  unsigned long int return_value_gtk_container_get_type$1;
  return_value_gtk_container_get_type$1=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_container_get_type$1);
  children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$2);
  if((signed int)triggers->trigger->event == TT_OUTPUT)
  {
    unsigned long int return_value_gtk_combo_box_get_type$3;
    return_value_gtk_combo_box_get_type$3=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)children->data, return_value_gtk_combo_box_get_type$3);
    gm_triggers_dialog_select_combo_by_type(triggers, (struct _GtkComboBox *)return_value_g_type_check_instance_cast$4, dataActionOutput[(signed long int)0].type);
  }

  else
  {
    unsigned long int return_value_gtk_combo_box_get_type$5;
    return_value_gtk_combo_box_get_type$5=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)children->data, return_value_gtk_combo_box_get_type$5);
    gm_triggers_dialog_select_combo_by_type(triggers, (struct _GtkComboBox *)return_value_g_type_check_instance_cast$6, dataActionUsers[(signed long int)0].type);
  }
  unsigned long int return_value_gtk_box_get_type$7;
  return_value_gtk_box_get_type$7=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)triggers->vbox_actions, return_value_gtk_box_get_type$7);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$8, hbox, 0, (signed int)!(0 != 0), (unsigned int)0);
  g_list_free(children);
}

// gm_triggers_dialog_new_condition
// file dialogs/gm-triggers-dialog.c line 579
void gm_triggers_dialog_new_condition(struct _GmTriggersDialog *triggers)
{
  struct _GtkWidget *hbox;
  struct _GList *children;
  hbox=gm_triggers_dialog_create_item(triggers, triggers->condition_model, (struct _GmTriggerData *)(void *)0);
  unsigned long int return_value_gtk_container_get_type$1;
  return_value_gtk_container_get_type$1=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_container_get_type$1);
  children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$2);
  if((signed int)triggers->trigger->event == TT_OUTPUT)
  {
    unsigned long int return_value_gtk_combo_box_get_type$3;
    return_value_gtk_combo_box_get_type$3=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)children->data, return_value_gtk_combo_box_get_type$3);
    gm_triggers_dialog_select_combo_by_type(triggers, (struct _GtkComboBox *)return_value_g_type_check_instance_cast$4, dataConditionOutput[(signed long int)0].type);
  }

  else
  {
    unsigned long int return_value_gtk_combo_box_get_type$5;
    return_value_gtk_combo_box_get_type$5=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)children->data, return_value_gtk_combo_box_get_type$5);
    gm_triggers_dialog_select_combo_by_type(triggers, (struct _GtkComboBox *)return_value_g_type_check_instance_cast$6, dataConditionUsers[(signed long int)0].type);
  }
  unsigned long int return_value_gtk_box_get_type$7;
  return_value_gtk_box_get_type$7=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)triggers->vbox_conditions, return_value_gtk_box_get_type$7);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$8, hbox, 0, (signed int)!(0 != 0), (unsigned int)0);
  g_list_free(children);
}

// gm_triggers_dialog_populate_actions
// file dialogs/gm-triggers-dialog.c line 648
void gm_triggers_dialog_populate_actions(struct _GmTriggersDialog *triggers)
{
  struct _GList *item;
  struct _GtkWidget *hbox;
  struct _GmTriggerData *t;
  struct _GList *children;
  if(!(triggers->trigger->actions == ((struct _GList *)NULL)))
  {
    item = triggers->trigger->actions;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      t = (struct _GmTriggerData *)item->data;
      hbox=gm_triggers_dialog_create_item(triggers, triggers->action_model, t);
      unsigned long int return_value_gtk_container_get_type$1;
      return_value_gtk_container_get_type$1=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_container_get_type$1);
      children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$2);
      unsigned long int return_value_gtk_box_get_type$3;
      return_value_gtk_box_get_type$3=gtk_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)triggers->vbox_actions, return_value_gtk_box_get_type$3);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$4, hbox, 0, (signed int)!(0 != 0), (unsigned int)0);
      unsigned long int return_value_gtk_combo_box_get_type$5;
      return_value_gtk_combo_box_get_type$5=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)children->data, return_value_gtk_combo_box_get_type$5);
      gm_triggers_dialog_select_combo_by_type(triggers, (struct _GtkComboBox *)return_value_g_type_check_instance_cast$6, (signed int)t->type);
      g_list_free(children);
    }
  }

  else
    gm_triggers_dialog_new_action(triggers);
}

// gm_triggers_dialog_populate_conditions
// file dialogs/gm-triggers-dialog.c line 601
void gm_triggers_dialog_populate_conditions(struct _GmTriggersDialog *triggers)
{
  struct _GList *item;
  struct _GtkWidget *hbox;
  struct _GmTriggerData *t;
  struct _GList *children;
  if(!(triggers->trigger->conditions == ((struct _GList *)NULL)))
  {
    item = triggers->trigger->conditions;
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      t = (struct _GmTriggerData *)item->data;
      hbox=gm_triggers_dialog_create_item(triggers, triggers->condition_model, t);
      unsigned long int return_value_gtk_container_get_type$1;
      return_value_gtk_container_get_type$1=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_container_get_type$1);
      children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$2);
      unsigned long int return_value_gtk_box_get_type$3;
      return_value_gtk_box_get_type$3=gtk_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)triggers->vbox_conditions, return_value_gtk_box_get_type$3);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$4, hbox, 0, (signed int)!(0 != 0), (unsigned int)0);
      unsigned long int return_value_gtk_combo_box_get_type$5;
      return_value_gtk_combo_box_get_type$5=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)children->data, return_value_gtk_combo_box_get_type$5);
      gm_triggers_dialog_select_combo_by_type(triggers, (struct _GtkComboBox *)return_value_g_type_check_instance_cast$6, (signed int)t->type);
      g_list_free(children);
    }
  }

  else
    gm_triggers_dialog_new_condition(triggers);
}

// gm_triggers_dialog_run
// file dialogs/gm-triggers-dialog.h line 7
struct _GmTrigger * gm_triggers_dialog_run(struct _GmWorld *world, struct _GmTrigger *trigger)
{
  struct _GmTrigger *return_value_gm_triggers_dialog_run_priv$1;
  return_value_gm_triggers_dialog_run_priv$1=gm_triggers_dialog_run_priv(world, trigger, 0);
  return return_value_gm_triggers_dialog_run_priv$1;
}

// gm_triggers_dialog_run_dialog
// file dialogs/gm-triggers-dialog.c line 404
struct _GmTrigger * gm_triggers_dialog_run_dialog(struct _GmTriggersDialog *triggers)
{
  signed int done = 0;
  struct _GmTrigger *result = (struct _GmTrigger *)(void *)0;
  while(done == 0)
  {
    done = (signed int)!(0 != 0);
    unsigned long int return_value_gtk_dialog_get_type$1;
    return_value_gtk_dialog_get_type$1=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_dialog_get_type$1);
    signed int return_value_gtk_dialog_run$3;
    return_value_gtk_dialog_run$3=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$2);
    if(return_value_gtk_dialog_run$3 == -5)
    {
      done=gm_triggers_dialog_fill_trigger(triggers);
      if(!(done == 0))
        result = triggers->trigger;

    }

  }
  if(!(triggers->action_model == ((struct _GtkTreeModel *)NULL)))
    g_object_unref((void *)triggers->action_model);

  if(!(triggers->condition_model == ((struct _GtkTreeModel *)NULL)))
    g_object_unref((void *)triggers->condition_model);

  if(!(triggers->highlight_model == ((struct _GtkTreeModel *)NULL)))
    g_object_unref((void *)triggers->highlight_model);

  if(result == ((struct _GmTrigger *)NULL))
  {
    if(!(triggers->is_new == 0))
      gm_trigger_free(triggers->trigger);

  }

  g_object_unref((void *)triggers->xml);
  gtk_widget_destroy(triggers->dialog);
  g_free((void *)triggers);
  return result;
}

// gm_triggers_dialog_run_new
// file dialogs/gm-triggers-dialog.h line 8
struct _GmTrigger * gm_triggers_dialog_run_new(struct _GmWorld *world, struct _GmTrigger *trigger)
{
  if(trigger == ((struct _GmTrigger *)NULL))
    trigger=gm_trigger_new();

  struct _GmTrigger *return_value_gm_triggers_dialog_run_priv$1;
  return_value_gm_triggers_dialog_run_priv$1=gm_triggers_dialog_run_priv(world, trigger, (signed int)!(0 != 0));
  return return_value_gm_triggers_dialog_run_priv$1;
}

// gm_triggers_dialog_run_priv
// file dialogs/gm-triggers-dialog.c line 450
struct _GmTrigger * gm_triggers_dialog_run_priv(struct _GmWorld *world, struct _GmTrigger *trigger, signed int is_new)
{
  struct _GladeXML *xml;
  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-triggers.glade", "gm_triggers_dialog", (const char *)(void *)0);
  if(xml == ((struct _GladeXML *)NULL))
  {
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-triggers.glade");
    return (struct _GmTrigger *)(void *)0;
  }

  else
  {
    struct _GmTriggersDialog *triggers;
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmTriggersDialog) /*136ul*/ );
    triggers = (struct _GmTriggersDialog *)return_value_g_malloc0_n$1;
    triggers->is_new = is_new;
    triggers->world = world;
    triggers->xml = xml;
    triggers->dialog=glade_xml_get_widget(triggers->xml, "gm_triggers_dialog");
    triggers->entry_name=glade_xml_get_widget(triggers->xml, "entry_name");
    triggers->vbox_conditions=glade_xml_get_widget(triggers->xml, "vbox_conditions");
    triggers->vbox_actions=glade_xml_get_widget(triggers->xml, "vbox_actions");
    triggers->notebook_triggers=glade_xml_get_widget(triggers->xml, "notebook_triggers");
    triggers->tree_view_event_types=glade_xml_get_widget(triggers->xml, "tree_view_event_types");
    triggers->button_ok=glade_xml_get_widget(triggers->xml, "button_ok");
    triggers->hbox_add_condition=glade_xml_get_widget(triggers->xml, "hbox_add_condition");
    triggers->hbox_add_action=glade_xml_get_widget(triggers->xml, "hbox_add_action");
    triggers->button_next=glade_xml_get_widget(triggers->xml, "button_next");
    gm_triggers_dialog_initialize_event_types(triggers);
    glade_xml_signal_connect_data(triggers->xml, "on_button_next_clicked", (void (*)(void))on_button_next_clicked, (void *)triggers);
    glade_xml_signal_connect_data(triggers->xml, "on_button_add_condition_clicked", (void (*)(void))on_button_add_condition_clicked, (void *)triggers);
    glade_xml_signal_connect_data(triggers->xml, "on_button_add_action_clicked", (void (*)(void))on_button_add_action_clicked, (void *)triggers);
    glade_xml_signal_connect_data(triggers->xml, "on_notebook_triggers_switch_page", (void (*)(void))on_notebook_triggers_switch_page, (void *)triggers);
    triggers->trigger = trigger;
    if(!(is_new == 0))
    {
      unsigned long int return_value_gtk_notebook_get_type$2;
      return_value_gtk_notebook_get_type$2=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)triggers->notebook_triggers, return_value_gtk_notebook_get_type$2);
      gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$3, 0);
    }

    else
    {
      unsigned long int return_value_gtk_notebook_get_type$4;
      return_value_gtk_notebook_get_type$4=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)triggers->notebook_triggers, return_value_gtk_notebook_get_type$4);
      gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$5, 1);
    }
    gtk_widget_show_all(triggers->dialog);
    struct _GmTrigger *return_value_gm_triggers_dialog_run_dialog$6;
    return_value_gm_triggers_dialog_run_dialog$6=gm_triggers_dialog_run_dialog(triggers);
    return return_value_gm_triggers_dialog_run_dialog$6;
  }
}

// gm_triggers_dialog_select_combo_by_type
// file dialogs/gm-triggers-dialog.c line 526
void gm_triggers_dialog_select_combo_by_type(struct _GmTriggersDialog *triggers, struct _GtkComboBox *combo, signed int type)
{
  struct _GtkTreeModel *model;
  model=gtk_combo_box_get_model(combo);
  struct _GtkTreeIter iter;
  struct _ModelData *data;
  signed int return_value_gtk_tree_model_get_iter_first$2;
  return_value_gtk_tree_model_get_iter_first$2=gtk_tree_model_get_iter_first(model, &iter);
  signed int return_value_gtk_tree_model_iter_next$1;
  if(!(return_value_gtk_tree_model_get_iter_first$2 == 0))
    do
    {
      gtk_tree_model_get(model, &iter, 1, &data, -1);
      if(type == data->type)
      {
        gtk_combo_box_set_active_iter(combo, &iter);
        goto __CPROVER_DUMP_L4;
      }

      return_value_gtk_tree_model_iter_next$1=gtk_tree_model_iter_next(model, &iter);
    }
    while(!(return_value_gtk_tree_model_iter_next$1 == 0));


__CPROVER_DUMP_L4:
  ;
}

// gm_triggers_dup
// file gm-triggers.c line 589
struct _GmTriggers * gm_triggers_dup(struct _GmTriggers *source)
{
  struct _GmTriggers *trg;
  unsigned long int return_value_gm_triggers_get_type$1;
  return_value_gm_triggers_get_type$1=gm_triggers_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_triggers_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_triggers_get_type$3;
  return_value_gm_triggers_get_type$3=gm_triggers_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_triggers_get_type$3);
  trg = (struct _GmTriggers *)return_value_g_type_check_instance_cast$4;
  struct _GList *item = source->priv->triggers;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    struct _GmTrigger *return_value_gm_trigger_dup$5;
    return_value_gm_trigger_dup$5=gm_trigger_dup((struct _GmTrigger *)item->data);
    trg->priv->triggers=g_list_append(trg->priv->triggers, (void *)return_value_gm_trigger_dup$5);
  }
  return trg;
}

// gm_triggers_finalize
// file gm-triggers.c line 63
static void gm_triggers_finalize(struct _GObject *object)
{
  struct _GmTriggers *trg;
  unsigned long int return_value_gm_triggers_get_type$1;
  return_value_gm_triggers_get_type$1=gm_triggers_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_triggers_get_type$1);
  trg = (struct _GmTriggers *)return_value_g_type_check_instance_cast$2;
  struct _GList *item = trg->priv->triggers;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    gm_trigger_free((struct _GmTrigger *)item->data);
  g_free((void *)trg->priv->path);
  g_list_free(trg->priv->triggers);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_triggers_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_triggers_get_type
// file gm-triggers.c line 60
unsigned long int gm_triggers_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmTriggers");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmTriggersClass) /*136ul*/ , (void (*)(void *, void *))gm_triggers_class_intern_init, (unsigned int)sizeof(struct _GmTriggers) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_triggers_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_triggers_init
// file gm-triggers.c line 87
static void gm_triggers_init(struct _GmTriggers *trg)
{
  unsigned long int return_value_gm_triggers_get_type$1;
  return_value_gm_triggers_get_type$1=gm_triggers_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)trg, return_value_gm_triggers_get_type$1);
  trg->priv = (struct _GmTriggersPrivate *)return_value_g_type_instance_get_private$2;
  trg->priv->triggers = (struct _GList *)(void *)0;
  trg->priv->path = (char *)(void *)0;
}

// gm_triggers_list
// file ./gm-triggers.h line 106
const struct _GList * gm_triggers_list(struct _GmTriggers *trg)
{
  return trg->priv->triggers;
}

// gm_triggers_new
// file gm-triggers.c line 445
struct _GmTriggers * gm_triggers_new(void)
{
  struct _GmTriggers *trg;
  unsigned long int return_value_gm_triggers_get_type$1;
  return_value_gm_triggers_get_type$1=gm_triggers_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_triggers_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_triggers_get_type$3;
  return_value_gm_triggers_get_type$3=gm_triggers_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_triggers_get_type$3);
  trg = (struct _GmTriggers *)return_value_g_type_check_instance_cast$4;
  return trg;
}

// gm_triggers_new_from_file
// file gm-triggers.c line 469
struct _GmTriggers * gm_triggers_new_from_file(char *filename)
{
  struct _GmTriggers *trg;
  unsigned long int return_value_gm_triggers_get_type$1;
  return_value_gm_triggers_get_type$1=gm_triggers_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_triggers_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_triggers_get_type$3;
  return_value_gm_triggers_get_type$3=gm_triggers_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_triggers_get_type$3);
  trg = (struct _GmTriggers *)return_value_g_type_check_instance_cast$4;
  struct _xmlDoc *doc;
  struct _xmlNode *cur;
  trg->priv->path=g_strdup(filename);
  signed int return_value_g_file_test$5;
  return_value_g_file_test$5=g_file_test(filename, (enum anonymous$106)G_FILE_TEST_EXISTS);
  if(return_value_g_file_test$5 == 0)
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmTriggers.NewFromFile: Trigger file does not exist");
    return trg;
  }

  else
  {
    doc=xmlParseFile(filename);
    if(doc == ((struct _xmlDoc *)NULL))
    {
      gm_debug_msg(DEBUG_DEFAULT, "GmTriggers.NewFromFile: Error on parsing triggers");
      return trg;
    }

    else
    {
      cur=xmlDocGetRootElement(doc);
      if(cur == ((struct _xmlNode *)NULL))
      {
        xmlFreeDoc(doc);
        return trg;
      }

      else
      {
        signed int return_value_xmlStrcmp$6;
        return_value_xmlStrcmp$6=xmlStrcmp(cur->name, (const unsigned char *)"triggers");
        if(!(return_value_xmlStrcmp$6 == 0))
        {
          gm_debug_msg(DEBUG_DEFAULT, "GmTriggers.NewFromFile: invalid root node");
          xmlFreeDoc(doc);
          return trg;
        }

        else
        {
          cur = cur->children;
          for( ; !(cur == ((struct _xmlNode *)NULL)); cur = cur->next)
          {
            signed int return_value_xmlStrcmp$7;
            return_value_xmlStrcmp$7=xmlStrcmp(cur->name, (const unsigned char *)"trigger");
            if(return_value_xmlStrcmp$7 == 0)
              gm_triggers_parse_trigger(trg, doc, cur);

          }
          xmlFreeDoc(doc);
          return trg;
        }
      }
    }
  }
}

// gm_triggers_parse_trigger
// file gm-triggers.c line 393
void gm_triggers_parse_trigger(struct _GmTriggers *trg, struct _xmlDoc *doc, struct _xmlNode *node)
{
  struct _GmTrigger *result;
  result=gm_trigger_new();
  unsigned char *tmp;
  unsigned char *tmp2;
  signed int type;
  tmp=xmlGetProp(node, (const unsigned char *)"name");
  result->name = (char *)tmp;
  tmp=xmlGetProp(node, (const unsigned char *)"event");
  signed int return_value_xmlStrcmp$2;
  return_value_xmlStrcmp$2=xmlStrcmp(tmp, (const unsigned char *)"world");
  signed int return_value_xmlStrcmp$1;
  if(return_value_xmlStrcmp$2 == 0)
    result->event = (enum _GmTriggerType)TT_OUTPUT;

  else
  {
    return_value_xmlStrcmp$1=xmlStrcmp(tmp, (const unsigned char *)"player");
    if(return_value_xmlStrcmp$1 == 0)
      result->event = (enum _GmTriggerType)TT_USERS;

    else
    {
      xmlFree((void *)tmp);
      gm_trigger_free(result);
    }
  }
  xmlFree((void *)tmp);
  node = node->children;
  signed int return_value_xmlStrcmp$7;
  if(!(node == ((struct _xmlNode *)NULL)))
  {
    tmp=xmlGetProp(node, (const unsigned char *)"type");
    tmp2=xmlGetProp(node, (const unsigned char *)"data");
    signed int return_value_xmlStrcmp$8;
    return_value_xmlStrcmp$8=xmlStrcmp(node->name, (const unsigned char *)"condition");
    if(return_value_xmlStrcmp$8 == 0)
    {
      type=gm_trigger_type_from_name((const char *)tmp, table_conditions);
      if(!(type == -1))
      {
        char *return_value_g_strdup$3;
        return_value_g_strdup$3=g_strdup((char *)tmp2);
        struct _GmTriggerData *return_value_gm_trigger_data_new$4;
        return_value_gm_trigger_data_new$4=gm_trigger_data_new(type, return_value_g_strdup$3);
        gm_trigger_add_condition(result, return_value_gm_trigger_data_new$4);
      }

    }

    else
    {
      return_value_xmlStrcmp$7=xmlStrcmp(node->name, (const unsigned char *)"action");
      if(return_value_xmlStrcmp$7 == 0)
      {
        type=gm_trigger_type_from_name((const char *)tmp, table_actions);
        if(!(type == -1))
        {
          char *return_value_g_strdup$5;
          return_value_g_strdup$5=g_strdup((char *)tmp2);
          struct _GmTriggerData *return_value_gm_trigger_data_new$6;
          return_value_gm_trigger_data_new$6=gm_trigger_data_new(type, return_value_g_strdup$5);
          gm_trigger_add_action(result, return_value_gm_trigger_data_new$6);
        }

      }

    }
    xmlFree((void *)tmp2);
    xmlFree((void *)tmp);
    node = node->next;
  }

  gm_triggers_add(trg, result);
}

// gm_triggers_save
// file ./gm-triggers.h line 102
void gm_triggers_save(struct _GmTriggers *trg)
{
  struct _xmlDoc *doc;
  struct _xmlNode *root;
  struct _xmlNode *trig;
  struct _GList *item;
  struct _GmTrigger *t;
  do
    if(trg->priv->path == ((char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_triggers_save", "trg->priv->path != NULL");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  doc=xmlNewDoc((const unsigned char *)"1.0");
  root=xmlNewNode((struct _xmlNs *)(void *)0, (const unsigned char *)"triggers");
  xmlDocSetRootElement(doc, root);
  item = trg->priv->triggers;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    t = (struct _GmTrigger *)item->data;
    trig=xmlNewChild(root, (struct _xmlNs *)(void *)0, (const unsigned char *)"trigger", (const unsigned char *)(void *)0);
    xmlNewProp(trig, (const unsigned char *)"name", (const unsigned char *)t->name);
    if((signed int)t->event == TT_OUTPUT)
      xmlNewProp(trig, (const unsigned char *)"event", (const unsigned char *)"world");

    else
      xmlNewProp(trig, (const unsigned char *)"event", (const unsigned char *)"player");
    gm_trigger_rules_xml(t, trig);
  }
  xmlSaveFormatFileEnc(trg->priv->path, doc, "UTF-8", 1);
  xmlFreeDoc(doc);

__CPROVER_DUMP_L7:
  ;
}

// gm_triggers_save_as
// file gm-triggers.c line 582
void gm_triggers_save_as(struct _GmTriggers *trg, const char *path)
{
  g_free((void *)trg->priv->path);
  trg->priv->path=g_strdup(path);
  gm_triggers_save(trg);
}

// gm_triggers_set_path
// file gm-triggers.c line 513
void gm_triggers_set_path(struct _GmTriggers *trg, char *path)
{
  g_free((void *)trg->priv->path);
  trg->priv->path=g_strdup(path);
}

// gm_url_regex_match
// file ./gm-support.h line 131
signed int gm_url_regex_match(const char *msg, signed int len, struct _GArray *start, struct _GArray *end)
{
  struct anonymous$17 matches[1l];
  signed int ret = 0;
  signed int num_matches = 0;
  signed int offset = 0;
  char *tmp;
  signed int s;
  static signed int inited = 0;
  if(inited == 0)
  {
    memset((void *)&url_regexp, 0, sizeof(struct re_pattern_buffer) /*64ul*/ );
    regcomp(&url_regexp, "(((mailto|news|telnet|nttp|file|http|sftp|ftp|https|dav|callto)://)|(www|ftp)[-A-Za-z0-9]*\\.)[-A-Za-z0-9\\.@:]+[^]''\\.}>\\) ,\\/\\\"\\!]+(:[0-9]*)?(/|/[-A-Za-z0-9_\\$\\.\\+\\!\\*\\(\\),;:@&=\\?/~\\#\\%]*[^]'\\.}>\\) ,\\\"\\!])?", 1);
    inited = (signed int)!(0 != 0);
  }

  tmp=g_strndup(msg, (unsigned long int)len);
  while(ret == 0)
  {
    ret=regexec(&url_regexp, (char *)(tmp + (signed long int)offset), (unsigned long int)1, matches, 0);
    if(ret == 0)
    {
      if(!(matches[0l].rm_eo >= matches[0l].rm_so))
        break;

      num_matches = num_matches + 1;
      s = matches[(signed long int)0].rm_so + offset;
      offset = matches[(signed long int)0].rm_eo + offset;
      g_array_append_vals(start, (const void *)&s, (unsigned int)1);
      g_array_append_vals(end, (const void *)&offset, (unsigned int)1);
    }

  }
  g_free((void *)tmp);
  return num_matches;
}

// gm_userlist_view_strcmp_safe
// file mcp/gm-mcp-userlist-view.c line 152
signed int gm_userlist_view_strcmp_safe(const char *str1, const char *str2)
{
  char *u1;
  char *u2;
  signed int result;
  if(str1 == ((const char *)NULL) || str2 == ((const char *)NULL))
  {
    if(str1 == ((const char *)NULL) && str2 == ((const char *)NULL))
      result = 0;

    else
      if(str1 == ((const char *)NULL))
        result = -1;

      else
        result = 1;
  }

  else
  {
    u1=g_utf8_casefold(str1, (signed long int)-1);
    u2=g_utf8_casefold(str2, (signed long int)-1);
    result=g_utf8_collate(u1, u2);
    g_free((void *)u1);
    g_free((void *)u2);
  }
  return result;
}

// gm_warning_dialog
// file gm-support.c line 145
signed int gm_warning_dialog(char *message, struct _GtkWindow *parent)
{
  signed int return_value_gm_dialog$1;
  return_value_gm_dialog$1=gm_dialog(message, (enum anonymous$79)GTK_MESSAGE_WARNING, GTK_BUTTONS_OK, parent);
  return return_value_gm_dialog$1;
}

// gm_widget_destroy_data
// file ./gm-support.h line 146
void gm_widget_destroy_data(struct _GtkWidget *caller, struct _GtkWidget *destroyer)
{
  signed int tmp_statement_expression$1;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)destroyer;
  unsigned long int __t;
  __t=gtk_widget_get_type();
  signed int __r;
  _Bool tmp_if_expr$2;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$1 = __r;
  if(!(tmp_statement_expression$1 == 0))
    gtk_widget_destroy(destroyer);

}

// gm_world_active
// file ./gm-world.h line 110
signed int gm_world_active(struct _GmWorld *world)
{
  return world->priv->active;
}

// gm_world_activity
// file ./gm-world.h line 109
signed int gm_world_activity(struct _GmWorld *world)
{
  return (signed int)world->priv->activity;
}

// gm_world_add_editor
// file ./gm-world.h line 131
void gm_world_add_editor(struct _GmWorld *world, struct _GmEditor *editor)
{
  world->priv->editors=g_slist_append(world->priv->editors, (void *)editor);
  g_signal_connect_data((void *)editor, "close", (void (*)(void))gm_world_remove_editor, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)G_CONNECT_SWAPPED);
  g_signal_emit((void *)world, world_signals[(signed long int)6], (unsigned int)0, editor);
}

// gm_world_apply_trigger
// file ./gm-world.h line 140
void gm_world_apply_trigger(struct _GmWorld *world, struct _GmTrigger *trigger, const char *text, struct anonymous$17 *matches, signed int nummatches)
{
  struct _GList *item;
  struct _GmTriggerData *data;
  signed int i;
  signed int nargs;
  char **spawn_args;
  char *tmp;
  item = trigger->actions;
  signed int return_value_g_shell_parse_argv$1;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    data = (struct _GmTriggerData *)item->data;
    switch(data->type)
    {
      case (unsigned int)0:
      {
        g_signal_emit((void *)world, world_signals[(signed long int)8], (unsigned int)0, -1, -1, data->data);
        break;
      }
      case (unsigned int)1:
      {
        i = 0;
        for( ; !((matches + (signed long int)i)->rm_so == -1); i = i + 1)
          g_signal_emit((void *)world, world_signals[(signed long int)8], (unsigned int)0, (matches + (signed long int)i)->rm_so, (matches + (signed long int)i)->rm_eo, data->data);
        break;
      }
      case (unsigned int)2:
      {
        gdk_beep();
        break;
      }
      case (unsigned int)3:
      {
        tmp=gm_world_triggers_subst(data->data, text, matches, nummatches);
        g_free((void *)tmp);
        break;
      }
      case (unsigned int)4:
      {
        tmp=gm_world_triggers_subst(data->data, text, matches, nummatches);
        g_signal_emit((void *)world, world_signals[(signed long int)9], (unsigned int)0, tmp);
        g_free((void *)tmp);
        break;
      }
      case (unsigned int)5:
        break;
      case (unsigned int)6:
      {
        tmp=gm_world_triggers_subst(data->data, text, matches, nummatches);
        return_value_g_shell_parse_argv$1=g_shell_parse_argv(tmp, &nargs, &spawn_args, (struct _GError **)(void *)0);
        if(!(return_value_g_shell_parse_argv$1 == 0))
        {
          g_spawn_async((const char *)(void *)0, spawn_args, (char **)(void *)0, (enum anonymous$104)G_SPAWN_SEARCH_PATH, (void (*)(void *))(void *)0, (void *)0, (signed int *)(void *)0, (struct _GError **)(void *)0);
          g_strfreev(spawn_args);
        }

        g_free((void *)tmp);
        break;
      }
      default:
        ;
    }
  }
}

// gm_world_auto_login
// file gm-world.c line 1277
void gm_world_auto_login(struct _GmWorld *world)
{
  const char *player_name;
  player_name=gm_options_get(world->priv->options, "player_name");
  const char *passwd;
  passwd=gm_options_get(world->priv->options, "password");
  char *sendln;
  if(!(player_name == ((const char *)NULL)))
  {
    if(!((signed int)*player_name == 0))
    {
      sendln=g_strconcat("connect ", player_name, (const void *)" ", passwd, (void *)0);
      gm_world_sendln_log(world, sendln, (enum _GmLogType)LOG_NONE);
      g_free((void *)sendln);
    }

  }

}

// gm_world_check_dirs
// file gm-world.c line 502
void gm_world_check_dirs(struct _GmWorld *world)
{
  char *tmp_path;
  tmp_path=g_strconcat(world->priv->path, (const void *)"/", (const void *)"logs", (void *)0);
  signed int return_value_g_file_test$1;
  return_value_g_file_test$1=g_file_test(tmp_path, (enum anonymous$106)G_FILE_TEST_EXISTS);
  if(return_value_g_file_test$1 == 0)
    mkdir(tmp_path, (unsigned int)0750);

  else
    chmod(tmp_path, (unsigned int)0750);
  g_free((void *)tmp_path);
}

// gm_world_class_init
// file gm-world.c line 182
static void gm_world_class_init(struct _GmWorldClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_world_finalize;
  object_class->get_property = gm_world_get_property;
  object_class->set_property = gm_world_set_property;
  struct _GParamSpec *return_value_g_param_spec_string$2;
  return_value_g_param_spec_string$2=g_param_spec_string("name", "NAME", "The worlds name", (const char *)(void *)0, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)1, return_value_g_param_spec_string$2);
  struct _GParamSpec *return_value_g_param_spec_string$3;
  return_value_g_param_spec_string$3=g_param_spec_string("path", "PATH", "The worlds path", (const char *)(void *)0, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)2, return_value_g_param_spec_string$3);
  struct _GParamSpec *return_value_g_param_spec_boolean$4;
  return_value_g_param_spec_boolean$4=g_param_spec_boolean("active", "ACTIVE", "If world is active", 0, (enum anonymous$5)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)3, return_value_g_param_spec_boolean$4);
  struct _GParamSpec *return_value_g_param_spec_boolean$5;
  return_value_g_param_spec_boolean$5=g_param_spec_boolean("activity", "ACTIVITY", "Lines of activity", 0, (enum anonymous$5)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)4, return_value_g_param_spec_boolean$5);
  unsigned long int return_value_gm_options_get_type$6;
  return_value_gm_options_get_type$6=gm_options_get_type();
  struct _GParamSpec *return_value_g_param_spec_object$7;
  return_value_g_param_spec_object$7=g_param_spec_object("options", "OPTIONS", "Options object", return_value_gm_options_get_type$6, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)5, return_value_g_param_spec_object$7);
  struct _GParamSpec *return_value_g_param_spec_int$8;
  return_value_g_param_spec_int$8=g_param_spec_int("state", "STATE", "World state", 0, GM_NET_STATE_END, 0, (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)6, return_value_g_param_spec_int$8);
  struct _GParamSpec *return_value_g_param_spec_string$9;
  return_value_g_param_spec_string$9=g_param_spec_string("current_host", "CURRENT_HOST", "Current host", ((const char *)NULL), (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)7, return_value_g_param_spec_string$9);
  struct _GParamSpec *return_value_g_param_spec_string$10;
  return_value_g_param_spec_string$10=g_param_spec_string("current_port", "CURRENT_PORT", "Current port", ((const char *)NULL), (enum anonymous$5)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)8, return_value_g_param_spec_string$10);
  world_signals[(signed long int)0]=g_signal_new("activate_request", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)136ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  world_signals[(signed long int)1]=g_signal_new("load", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)144ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  world_signals[(signed long int)2]=g_signal_new("unload", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)152ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  world_signals[(signed long int)3]=g_signal_new("state_changing", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)160ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__UINT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(7 << 2));
  world_signals[(signed long int)4]=g_signal_new("world_error", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)168ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, gm_marshal_VOID__STRING_INT, (unsigned long int)(1 << 2), (unsigned int)2, (unsigned long int)(16 << 2), (unsigned long int)(6 << 2));
  world_signals[(signed long int)5]=g_signal_new("text_received", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)176ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  world_signals[(signed long int)6]=g_signal_new("editor_added", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)184ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__OBJECT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(20 << 2));
  world_signals[(signed long int)7]=g_signal_new("editor_removed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)192ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__OBJECT, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(20 << 2));
  world_signals[(signed long int)8]=g_signal_new("highlight", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)200ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, gm_marshal_VOID__INT_INT_STRING, (unsigned long int)(1 << 2), (unsigned int)3, (unsigned long int)(6 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2));
  world_signals[(signed long int)9]=g_signal_new("notify_message", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)208ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmWorldPrivate) /*152ul*/ );
}

// gm_world_class_intern_init
// file gm-world.c line 94
static void gm_world_class_intern_init(void *klass)
{
  gm_world_parent_class=g_type_class_peek_parent(klass);
  if(!(GmWorld_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmWorld_private_offset);

  gm_world_class_init((struct _GmWorldClass *)klass);
}

// gm_world_connect
// file ./gm-world.h line 127
void gm_world_connect(struct _GmWorld *world)
{
  const char *return_value_gm_options_get$1;
  return_value_gm_options_get$1=gm_options_get(world->priv->options, "host");
  const char *return_value_gm_options_get$2;
  return_value_gm_options_get$2=gm_options_get(world->priv->options, "port");
  gm_world_connect_to(world, return_value_gm_options_get$1, return_value_gm_options_get$2);
}

// gm_world_connect_to
// file gm-world.c line 667
void gm_world_connect_to(struct _GmWorld *world, const char *host, const char *port)
{
  if(!(world->priv->reconnect_id == 0u))
    g_source_remove(world->priv->reconnect_id);

  gm_net_connect(world->priv->net, host, port);
}

// gm_world_connected
// file ./gm-world.h line 124
signed int gm_world_connected(struct _GmWorld *world)
{
  enum _GmNetState return_value_gm_net_state$1;
  return_value_gm_net_state$1=gm_net_state(world->priv->net);
  return (signed int)((signed int)return_value_gm_net_state$1 == GM_NET_STATE_CONNECTED);
}

// gm_world_create_default_settings
// file gm-world.c line 331
static void gm_world_create_default_settings(struct _GmWorld *world)
{
  const char *loc;
  loc=gm_default_charset();
  world->priv->options=gm_options_new();
  gm_options_set(world->priv->options, "name", "");
  gm_options_set(world->priv->options, "autoload", "0");
  gm_options_set(world->priv->options, "host", "");
  gm_options_set(world->priv->options, "port", "1111");
  gm_options_set(world->priv->options, "player_name", "");
  gm_options_set(world->priv->options, "reconnect", "0");
  gm_options_set(world->priv->options, "password", "");
  gm_options_set(world->priv->options, "charset", (char *)loc);
  gm_options_set(world->priv->options, "history_length", "500");
  gm_options_set(world->priv->options, "pane_position", "150");
}

// gm_world_current_host
// file ./gm-world.h line 113
const char * gm_world_current_host(struct _GmWorld *world)
{
  const char *return_value_gm_net_current_host$1;
  return_value_gm_net_current_host$1=gm_net_current_host(world->priv->net);
  return return_value_gm_net_current_host$1;
}

// gm_world_current_port
// file ./gm-world.h line 114
const char * gm_world_current_port(struct _GmWorld *world)
{
  const char *return_value_gm_net_current_port$1;
  return_value_gm_net_current_port$1=gm_net_current_port(world->priv->net);
  return return_value_gm_net_current_port$1;
}

// gm_world_disconnect
// file ./gm-world.h line 129
void gm_world_disconnect(struct _GmWorld *world)
{
  world->priv->manual_disconnect = (signed int)!(0 != 0);
  signed long int return_value_time$1;
  return_value_time$1=time(((signed long int *)NULL));
  world->priv->manual_disconnect_timeout = return_value_time$1 + (signed long int)5;
  gm_net_disconnect(world->priv->net);
}

// gm_world_disconnected
// file ./gm-world.h line 125
signed int gm_world_disconnected(struct _GmWorld *world)
{
  enum _GmNetState return_value_gm_net_state$1;
  return_value_gm_net_state$1=gm_net_state(world->priv->net);
  return (signed int)((signed int)return_value_gm_net_state$1 == GM_NET_STATE_DISCONNECTED);
}

// gm_world_dup
// file ./gm-world.h line 101
struct _GmWorld * gm_world_dup(struct _GmWorld *source)
{
  struct _GmWorld *copy;
  copy=gm_world_new((char *)(void *)0);
  g_object_unref((void *)copy->priv->options);
  copy->priv->options=gm_options_dup(source->priv->options);
  copy->priv->triggers=gm_triggers_dup(source->priv->triggers);
  return copy;
}

// gm_world_editors
// file ./gm-world.h line 133
const struct _GSList * gm_world_editors(struct _GmWorld *world)
{
  return world->priv->editors;
}

// gm_world_finalize
// file gm-world.c line 97
static void gm_world_finalize(struct _GObject *object)
{
  struct _GmWorld *world;
  unsigned long int return_value_gm_world_get_type$1;
  return_value_gm_world_get_type$1=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_get_type$1);
  world = (struct _GmWorld *)return_value_g_type_check_instance_cast$2;
  if(!(world->priv->path == ((char *)NULL)))
  {
    gm_options_save(world->priv->options);
    gm_world_save_input_history(world);
    gm_triggers_save(world->priv->triggers);
  }

  if(world->priv->fd_log >= 1)
    close(world->priv->fd_log);

  if(!(world->priv->reconnect_id == 0u))
    g_source_remove(world->priv->reconnect_id);

  if(!(world->priv->flush_history_id == 0u))
    g_source_remove(world->priv->flush_history_id);

  gm_g_list_free_simple(world->priv->history);
  g_free((void *)world->priv->path);
  g_free((void *)world->priv->buffer);
  g_free((void *)world->priv->editing_info.name);
  g_free((void *)world->priv->editing_info.upload);
  g_list_free(world->priv->editing_info.lines);
  g_object_unref((void *)world->priv->triggers);
  g_object_unref((void *)world->priv->options);
  g_object_unref((void *)world->priv->net);
  g_object_unref((void *)world->priv->mcp);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_world_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_world_get_mcp_session
// file ./gm-world.h line 120
struct _GmMcpSession * gm_world_get_mcp_session(struct _GmWorld *world)
{
  return world->priv->mcp;
}

// gm_world_get_property
// file gm-world.c line 135
static void gm_world_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _GmWorld *world;
  unsigned long int return_value_gm_world_get_type$1;
  return_value_gm_world_get_type$1=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_get_type$1);
  world = (struct _GmWorld *)return_value_g_type_check_instance_cast$2;
  const char *return_value_gm_world_name$3;
  enum _GmNetState return_value_gm_world_state$4;
  const char *return_value_gm_world_current_host$5;
  const char *return_value_gm_world_current_port$6;
  switch(prop_id)
  {
    case (unsigned int)1:
    {
      return_value_gm_world_name$3=gm_world_name(world);
      g_value_set_string(value, return_value_gm_world_name$3);
      break;
    }
    case (unsigned int)2:
    {
      g_value_set_string(value, world->priv->path);
      break;
    }
    case (unsigned int)3:
    {
      g_value_set_boolean(value, world->priv->active);
      break;
    }
    case (unsigned int)4:
    {
      g_value_set_int(value, (signed int)world->priv->activity);
      break;
    }
    case (unsigned int)5:
    {
      g_value_set_object(value, (void *)world->priv->options);
      break;
    }
    case (unsigned int)6:
    {
      return_value_gm_world_state$4=gm_world_state(world);
      g_value_set_int(value, (signed int)return_value_gm_world_state$4);
      break;
    }
    case (unsigned int)7:
    {
      return_value_gm_world_current_host$5=gm_world_current_host(world);
      g_value_set_string(value, return_value_gm_world_current_host$5);
      break;
    }
    case (unsigned int)8:
    {
      return_value_gm_world_current_port$6=gm_world_current_port(world);
      g_value_set_string(value, return_value_gm_world_current_port$6);
    }
  }
}

// gm_world_get_type
// file ./gm-world.h line 98
unsigned long int gm_world_get_type(void)
{
  _Bool tmp_statement_expression$2;
  void *tmp_statement_expression$3;
  signed int return_value___atomic_load_8$4;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$4=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$3 = (void *)return_value___atomic_load_8$4;
  _Bool tmp_if_expr$6;
  signed int return_value_g_once_init_enter$5;
  if(tmp_statement_expression$3 == NULL)
  {
    return_value_g_once_init_enter$5=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$6 = return_value_g_once_init_enter$5 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  tmp_statement_expression$2 = tmp_if_expr$6;
  if(tmp_statement_expression$2)
  {
    unsigned long int g_define_type_id;
    const char *return_value_g_intern_static_string$1;
    return_value_g_intern_static_string$1=g_intern_static_string("GmWorld");
    g_define_type_id=g_type_register_static_simple((unsigned long int)(20 << 2), return_value_g_intern_static_string$1, (unsigned int)sizeof(struct _GmWorldClass) /*216ul*/ , (void (*)(void *, void *))gm_world_class_intern_init, (unsigned int)sizeof(struct _GmWorld) /*32ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_world_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_world_history
// file ./gm-world.h line 108
struct _GList ** gm_world_history(struct _GmWorld *world)
{
  return &world->priv->history;
}

// gm_world_info_dialog_event_box_cursor
// file dialogs/gm-world-info-dialog.c line 31
void gm_world_info_dialog_event_box_cursor(struct _GtkWidget *widget)
{
  struct _GdkCursor *cursor;
  cursor=gdk_cursor_new((enum anonymous$37)GDK_HAND2);
  gdk_window_set_cursor(widget->window, cursor);
  gdk_cursor_unref(cursor);
}

// gm_world_info_dialog_new
// file dialogs/gm-world-info-dialog.c line 40
struct _GtkDialog * gm_world_info_dialog_new(const struct _GmWorldInfo *world_info)
{
  struct _GladeXML *xml;
  struct _GtkWidget *dlg;
  struct _GtkWidget *widget;
  char *tmp;
  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-world-info.glade", "gm_world_info_dialog", (const char *)(void *)0);
  if(xml == ((struct _GladeXML *)NULL))
  {
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-world-info.glade");
    return (struct _GtkDialog *)(void *)0;
  }

  else
  {
    dlg=glade_xml_get_widget(xml, "gm_world_info_dialog");
    if(!(world_info->name == ((char *)NULL)))
    {
      char *return_value_gettext$1;
      return_value_gettext$1=gettext("World info");
      tmp=g_strconcat(world_info->name, (const void *)" - ", return_value_gettext$1, (void *)0);
      unsigned long int return_value_gtk_window_get_type$2;
      return_value_gtk_window_get_type$2=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_window_get_type$2);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$3, tmp);
      g_free((void *)tmp);
    }

    struct _GtkWidget *return_value_glade_xml_get_widget$4;
    return_value_glade_xml_get_widget$4=glade_xml_get_widget(xml, "label_world_name");
    unsigned long int return_value_gtk_label_get_type$5;
    return_value_gtk_label_get_type$5=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$4, return_value_gtk_label_get_type$5);
    gm_world_info_dialog_set_label((struct _GtkLabel *)return_value_g_type_check_instance_cast$6, world_info->name);
    struct _GtkWidget *return_value_glade_xml_get_widget$7;
    return_value_glade_xml_get_widget$7=glade_xml_get_widget(xml, "label_name");
    unsigned long int return_value_gtk_label_get_type$8;
    return_value_gtk_label_get_type$8=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$7, return_value_gtk_label_get_type$8);
    gm_world_info_dialog_set_label((struct _GtkLabel *)return_value_g_type_check_instance_cast$9, world_info->admin);
    struct _GtkWidget *return_value_glade_xml_get_widget$10;
    return_value_glade_xml_get_widget$10=glade_xml_get_widget(xml, "label_location");
    unsigned long int return_value_gtk_label_get_type$11;
    return_value_gtk_label_get_type$11=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$10, return_value_gtk_label_get_type$11);
    gm_world_info_dialog_set_label((struct _GtkLabel *)return_value_g_type_check_instance_cast$12, world_info->location);
    struct _GtkWidget *return_value_glade_xml_get_widget$13;
    return_value_glade_xml_get_widget$13=glade_xml_get_widget(xml, "label_system");
    unsigned long int return_value_gtk_label_get_type$14;
    return_value_gtk_label_get_type$14=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$13, return_value_gtk_label_get_type$14);
    gm_world_info_dialog_set_label((struct _GtkLabel *)return_value_g_type_check_instance_cast$15, world_info->system);
    struct _GtkWidget *return_value_glade_xml_get_widget$16;
    return_value_glade_xml_get_widget$16=glade_xml_get_widget(xml, "label_characterset");
    unsigned long int return_value_gtk_label_get_type$17;
    return_value_gtk_label_get_type$17=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$16, return_value_gtk_label_get_type$17);
    gm_world_info_dialog_set_label((struct _GtkLabel *)return_value_g_type_check_instance_cast$18, world_info->charset);
    struct _GtkWidget *return_value_glade_xml_get_widget$19;
    return_value_glade_xml_get_widget$19=glade_xml_get_widget(xml, "label_language");
    unsigned long int return_value_gtk_label_get_type$20;
    return_value_gtk_label_get_type$20=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$19, return_value_gtk_label_get_type$20);
    gm_world_info_dialog_set_label((struct _GtkLabel *)return_value_g_type_check_instance_cast$21, world_info->language);
    if(!(world_info->homepage == ((char *)NULL)))
    {
      tmp=g_strconcat("<u><span color=\"#0000ff\">", world_info->homepage, (const void *)"</span></u>", (void *)0);
      glade_xml_signal_connect_data(xml, "on_label_homepage_button_release", (void (*)(void))on_gm_world_info_dialog_url_button_release, (void *)0);
      widget=glade_xml_get_widget(xml, "label_homepage");
      unsigned long int return_value_gtk_label_get_type$22;
      return_value_gtk_label_get_type$22=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
      return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$22);
      gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$23, tmp);
      g_free((void *)tmp);
      struct _GtkWidget *return_value_glade_xml_get_widget$24;
      return_value_glade_xml_get_widget$24=glade_xml_get_widget(xml, "event_box_homepage");
      gm_world_info_dialog_event_box_cursor(return_value_glade_xml_get_widget$24);
    }

    else
    {
      struct _GtkWidget *return_value_glade_xml_get_widget$25;
      return_value_glade_xml_get_widget$25=glade_xml_get_widget(xml, "label_homepage");
      unsigned long int return_value_gtk_label_get_type$26;
      return_value_gtk_label_get_type$26=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
      return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$25, return_value_gtk_label_get_type$26);
      char *return_value_gettext$28;
      return_value_gettext$28=gettext("<i>unspecified</i>");
      gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$27, return_value_gettext$28);
    }
    if(!(world_info->contact == ((char *)NULL)))
    {
      tmp=g_strconcat("<u><span color=\"#0000ff\">", world_info->contact, (const void *)"</span></u>", (void *)0);
      glade_xml_signal_connect_data(xml, "on_label_email_button_release", (void (*)(void))on_gm_world_info_dialog_url_button_release, (void *)"mailto:");
      widget=glade_xml_get_widget(xml, "label_email");
      unsigned long int return_value_gtk_label_get_type$29;
      return_value_gtk_label_get_type$29=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
      return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$29);
      gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$30, tmp);
      g_free((void *)tmp);
      struct _GtkWidget *return_value_glade_xml_get_widget$31;
      return_value_glade_xml_get_widget$31=glade_xml_get_widget(xml, "event_box_email");
      gm_world_info_dialog_event_box_cursor(return_value_glade_xml_get_widget$31);
    }

    else
    {
      struct _GtkWidget *return_value_glade_xml_get_widget$32;
      return_value_glade_xml_get_widget$32=glade_xml_get_widget(xml, "label_email");
      unsigned long int return_value_gtk_label_get_type$33;
      return_value_gtk_label_get_type$33=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
      return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$32, return_value_gtk_label_get_type$33);
      char *return_value_gettext$35;
      return_value_gettext$35=gettext("<i>unspecified</i>");
      gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$34, return_value_gettext$35);
    }
    if(!(world_info->logo == ((char *)NULL)))
    {
      struct _GtkWidget *return_value_glade_xml_get_widget$36;
      return_value_glade_xml_get_widget$36=glade_xml_get_widget(xml, "image_logo");
      unsigned long int return_value_gtk_image_get_type$37;
      return_value_gtk_image_get_type$37=gtk_image_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
      return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$36, return_value_gtk_image_get_type$37);
      struct _GdkPixbuf *return_value_gm_pixbuf_get$39;
      return_value_gm_pixbuf_get$39=gm_pixbuf_get(world_info->logo);
      gtk_image_set_from_pixbuf((struct _GtkImage *)return_value_g_type_check_instance_cast$38, return_value_gm_pixbuf_get$39);
    }

    glade_xml_signal_connect(xml, "on_gm_world_info_dialog_delete", (void (*)(void))gtk_widget_destroy);
    glade_xml_signal_connect_data(xml, "on_button_close_clicked", (void (*)(void))gm_widget_destroy_data, (void *)dlg);
    gtk_widget_show_all(dlg);
    g_object_unref((void *)xml);
    unsigned long int return_value_gtk_dialog_get_type$40;
    return_value_gtk_dialog_get_type$40=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
    return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_dialog_get_type$40);
    return (struct _GtkDialog *)return_value_g_type_check_instance_cast$41;
  }
}

// gm_world_info_dialog_set_label
// file dialogs/gm-world-info-dialog.c line 22
void gm_world_info_dialog_set_label(struct _GtkLabel *label, char *text)
{
  if(!(text == ((char *)NULL)))
    gtk_label_set_markup(label, text);

  else
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("<i>unspecified</i>");
    gtk_label_set_markup(label, return_value_gettext$1);
  }
}

// gm_world_init
// file gm-world.c line 351
static void gm_world_init(struct _GmWorld *world)
{
  unsigned long int return_value_gm_world_get_type$1;
  return_value_gm_world_get_type$1=gm_world_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)world, return_value_gm_world_get_type$1);
  world->priv = (struct _GmWorldPrivate *)return_value_g_type_instance_get_private$2;
  gm_world_create_default_settings(world);
  world->priv->path = (char *)(void *)0;
  world->priv->loaded = 0;
  world->priv->history = (struct _GList *)(void *)0;
  world->priv->activity = (unsigned int)0;
  world->priv->triggers=gm_triggers_new();
  world->priv->net=gm_net_new();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)world, (unsigned long int)(20 << 2));
  world->priv->mcp=gm_mcp_session_new((struct _GObject *)return_value_g_type_check_instance_cast$3);
  world->priv->buffer = (char *)(void *)0;
  world->priv->editing_info.is_editing = 0;
  g_signal_connect_data((void *)world->priv->net, "state_changing", (void (*)(void))on_gm_world_net_state_changing, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world->priv->net, "state_changed", (void (*)(void))on_gm_world_net_state_changed, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world->priv->net, "net_error", (void (*)(void))on_gm_world_net_net_error, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world->priv->net, "bytes_recv", (void (*)(void))on_gm_world_net_bytes_recv, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world->priv->options, "option_changed", (void (*)(void))on_gm_world_options_option_changed, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
}

// gm_world_input_view_class_init
// file widgets/gm-world-input-view.c line 243
static void gm_world_input_view_class_init(struct _GmWorldInputViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GtkWidgetClass *widget_class;
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_widget_get_type$2);
  widget_class = (struct _GtkWidgetClass *)return_value_g_type_check_class_cast$3;
  object_class->finalize = gm_world_input_view_finalize;
  widget_class->key_press_event = gm_world_input_view_key_press_event;
  unsigned long int return_value_gtk_widget_get_type$4;
  return_value_gtk_widget_get_type$4=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$5;
  return_value_g_type_check_class_cast$5=g_type_check_class_cast((struct _GTypeClass *)gm_world_input_view_parent_class, return_value_gtk_widget_get_type$4);
  widget_parent_class = (struct _GtkWidgetClass *)return_value_g_type_check_class_cast$5;
  world_input_view_signals[(signed long int)0]=g_signal_new("text_activate", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)984ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmWorldInputViewPrivate) /*48ul*/ );
}

// gm_world_input_view_class_intern_init
// file widgets/gm-world-input-view.c line 38
static void gm_world_input_view_class_intern_init(void *klass)
{
  gm_world_input_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmWorldInputView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmWorldInputView_private_offset);

  gm_world_input_view_class_init((struct _GmWorldInputViewClass *)klass);
}

// gm_world_input_view_color_table
// file widgets/gm-world-input-view.c line 341
struct _GmColorTable * gm_world_input_view_color_table(struct _GmWorldInputView *view)
{
  return view->priv->color_table;
}

// gm_world_input_view_finalize
// file widgets/gm-world-input-view.c line 42
static void gm_world_input_view_finalize(struct _GObject *object)
{
  struct _GmWorldInputView *view;
  unsigned long int return_value_gm_world_input_view_get_type$1;
  return_value_gm_world_input_view_get_type$1=gm_world_input_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_input_view_get_type$1);
  view = (struct _GmWorldInputView *)return_value_g_type_check_instance_cast$2;
  gm_world_input_view_set_color_table(view, (struct _GmColorTable *)(void *)0);
  if(!(view->priv->idle_scroll == 0u))
    g_source_remove(view->priv->idle_scroll);

  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_world_input_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_world_input_view_get_type
// file widgets/gm-world-input-view.h line 47
unsigned long int gm_world_input_view_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_text_view_get_type$1;
    return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmWorldInputView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_text_view_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmWorldInputViewClass) /*992ul*/ , (void (*)(void *, void *))gm_world_input_view_class_intern_init, (unsigned int)sizeof(struct _GmWorldInputView) /*360ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_world_input_view_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_world_input_view_history
// file widgets/gm-world-input-view.c line 317
struct _GList ** gm_world_input_view_history(struct _GmWorldInputView *view)
{
  return view->priv->history;
}

// gm_world_input_view_init
// file widgets/gm-world-input-view.c line 267
static void gm_world_input_view_init(struct _GmWorldInputView *view)
{
  unsigned long int return_value_gm_world_input_view_get_type$1;
  return_value_gm_world_input_view_get_type$1=gm_world_input_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)view, return_value_gm_world_input_view_get_type$1);
  view->priv = (struct _GmWorldInputViewPrivate *)return_value_g_type_instance_get_private$2;
  view->priv->color_table = (struct _GmColorTable *)(void *)0;
  view->priv->history = (struct _GList **)(void *)0;
  view->priv->position = (struct _GList *)(void *)0;
  view->priv->prefix = (char *)(void *)0;
  unsigned long int return_value_gtk_text_view_get_type$3;
  return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$3);
  gtk_text_view_set_wrap_mode((struct _GtkTextView *)return_value_g_type_check_instance_cast$4, (enum anonymous$77)GTK_WRAP_WORD_CHAR);
  unsigned long int return_value_gtk_text_view_get_type$5;
  return_value_gtk_text_view_get_type$5=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$5);
  gtk_text_view_set_accepts_tab((struct _GtkTextView *)return_value_g_type_check_instance_cast$6, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_text_view_get_type$7;
  return_value_gtk_text_view_get_type$7=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$7);
  gtk_text_view_set_left_margin((struct _GtkTextView *)return_value_g_type_check_instance_cast$8, 3);
  unsigned long int return_value_gtk_text_view_get_type$9;
  return_value_gtk_text_view_get_type$9=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$9);
  gtk_text_view_set_right_margin((struct _GtkTextView *)return_value_g_type_check_instance_cast$10, 3);
  unsigned long int return_value_gtk_text_view_get_type$11;
  return_value_gtk_text_view_get_type$11=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$11);
  gtk_text_view_set_pixels_above_lines((struct _GtkTextView *)return_value_g_type_check_instance_cast$12, 1);
  unsigned long int return_value_gtk_text_view_get_type$13;
  return_value_gtk_text_view_get_type$13=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$13);
  gtk_text_view_set_pixels_below_lines((struct _GtkTextView *)return_value_g_type_check_instance_cast$14, 1);
  unsigned long int return_value_gtk_text_view_get_type$15;
  return_value_gtk_text_view_get_type$15=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$15);
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$17;
  return_value_gtk_text_view_get_buffer$17=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$16);
  g_signal_connect_data((void *)return_value_gtk_text_view_get_buffer$17, "changed", (void (*)(void))on_gm_world_input_view_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
}

// gm_world_input_view_key_press_event
// file widgets/gm-world-input-view.c line 89
signed int gm_world_input_view_key_press_event(struct _GtkWidget *widget, struct _GdkEventKey *event)
{
  struct _GmWorldInputView *view;
  unsigned long int return_value_gm_world_input_view_get_type$1;
  return_value_gm_world_input_view_get_type$1=gm_world_input_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_world_input_view_get_type$1);
  view = (struct _GmWorldInputView *)return_value_g_type_check_instance_cast$2;
  char *text;
  signed int result = 0;
  signed int isUp;
  struct _GtkTextBuffer *buf;
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  struct _GtkTextIter cursor;
  struct _GtkTextMark *insert;
  struct _GList *item;
  struct _GList *found = (struct _GList *)(void *)0;
  signed int line;
  signed int len;
  unsigned long int return_value_gtk_text_view_get_type$3;
  return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$3);
  buf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$4);
  gtk_text_buffer_get_bounds(buf, &start, &end);
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  signed int return_value_gtk_text_buffer_get_line_count$5;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$10;
  struct _GList *tmp_if_expr$12;
  struct _GList *tmp_if_expr$15;
  switch(event->keyval)
  {
    case (unsigned int)0xff52:

    case (unsigned int)0xff54:
    {
      isUp = (signed int)(event->keyval == (unsigned int)0xff52);
      if(view->priv->history == ((struct _GList **)NULL))
        break;

      insert=gtk_text_buffer_get_insert(buf);
      gtk_text_buffer_get_iter_at_mark(buf, &cursor, insert);
      line=gtk_text_iter_get_line(&cursor);
      if(!(isUp == 0) && !(line == 0))
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        if(isUp == 0)
        {
          return_value_gtk_text_buffer_get_line_count$5=gtk_text_buffer_get_line_count(buf);
          tmp_if_expr$6 = line != return_value_gtk_text_buffer_get_line_count$5 - 1 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
        break;

      text=gtk_text_buffer_get_text(buf, &start, &end, 0);
      if(view->priv->position == ((struct _GList *)NULL))
      {
        char *return_value_g_strdup$8;
        return_value_g_strdup$8=g_strdup(text);
        *view->priv->history=g_list_append(*view->priv->history, (void *)return_value_g_strdup$8);
        view->priv->position=g_list_last(*view->priv->history);
      }

      if(!(isUp == 0))
        tmp_if_expr$9 = !(view->priv->position->prev != ((struct _GList *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        if(isUp == 0)
          tmp_if_expr$10 = !(view->priv->position->next != ((struct _GList *)NULL)) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$10 = (_Bool)0;
        tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
      {
        result = (signed int)!(0 != 0);
        break;
      }

      if(view->priv->prefix == ((char *)NULL))
        view->priv->prefix=g_strdup(text);

      if((signed int)*view->priv->prefix == 0)
      {
        if(!(isUp == 0))
          found = view->priv->position->prev;

        else
          found = view->priv->position->next;
      }

      else
      {
        if(!(isUp == 0))
          tmp_if_expr$12 = view->priv->position->prev;

        else
          tmp_if_expr$12 = view->priv->position->next;
        item = tmp_if_expr$12;
        while(!(item == ((struct _GList *)NULL)))
        {
          unsigned long int return_value_strlen$13;
          return_value_strlen$13=strlen(view->priv->prefix);
          signed int return_value_strncmp$14;
          return_value_strncmp$14=strncmp((char *)item->data, view->priv->prefix, return_value_strlen$13);
          if(return_value_strncmp$14 == 0)
          {
            found = item;
            break;
          }

          if(!(isUp == 0))
            tmp_if_expr$15 = item->prev;

          else
            tmp_if_expr$15 = item->next;
          item = tmp_if_expr$15;
        }
      }
      if(!(found == ((struct _GList *)NULL)))
      {
        char *return_value_gm_world_input_view_str_new_value$16;
        return_value_gm_world_input_view_str_new_value$16=gm_world_input_view_str_new_value((char *)view->priv->position->data, text);
        view->priv->position->data = (void *)return_value_gm_world_input_view_str_new_value$16;
        gm_world_input_view_set_text(view, (char *)found->data, -1);
        view->priv->position = found;
        struct _GList *return_value_g_list_last$17;
        return_value_g_list_last$17=g_list_last(*view->priv->history);
        if(found == return_value_g_list_last$17)
          gm_world_input_view_reset_prefix(view);

      }

      g_free((void *)text);
      result = (signed int)!(0 != 0);
      break;
    }
    case (unsigned int)0xff0d:
    {
      if((4u & event->state) == 0u)
      {
        if((1u & event->state) == 0u)
        {
          text=gtk_text_buffer_get_text(buf, &start, &end, 0);
          g_signal_emit((void *)view, world_input_view_signals[(signed long int)0], (unsigned int)0, text);
          if(!(view->priv->history == ((struct _GList **)NULL)))
          {
            item=g_list_last(*view->priv->history);
            if(!(item == ((struct _GList *)NULL)))
            {
              char *return_value_gm_world_input_view_str_new_value$18;
              return_value_gm_world_input_view_str_new_value$18=gm_world_input_view_str_new_value((char *)item->data, text);
              item->data = (void *)return_value_gm_world_input_view_str_new_value$18;
            }

            else
            {
              char *return_value_g_strdup$19;
              return_value_g_strdup$19=g_strdup(text);
              *view->priv->history=g_list_append(*view->priv->history, (void *)return_value_g_strdup$19);
            }
          }

          unsigned int return_value_g_list_length$20;
          return_value_g_list_length$20=g_list_length(*view->priv->history);
          len = (signed int)return_value_g_list_length$20;
          line = 0;
          for( ; !(line >= len + -500); line = line + 1)
            *view->priv->history=g_list_remove(*view->priv->history, (*view->priv->history)->data);
          if(!(view->priv->history == ((struct _GList **)NULL)))
          {
            char *return_value_g_strdup$21;
            return_value_g_strdup$21=g_strdup("");
            *view->priv->history=g_list_append(*view->priv->history, (void *)return_value_g_strdup$21);
            view->priv->position=g_list_last(*view->priv->history);
          }

          gm_world_input_view_reset_prefix(view);
          gm_world_input_view_set_text(view, "", 0);
          on_gm_world_input_view_changed(buf, view);
          g_free((void *)text);
          result = (signed int)!(0 != 0);
        }

      }

      break;
    }
    default:
      ;
  }
  if(result == 0)
  {
    if(!(widget_parent_class->key_press_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventKey *))NULL)))
    {
      signed int return_value;
      return_value=widget_parent_class->key_press_event(widget, event);
      return return_value;
    }

  }

  return result;
}

// gm_world_input_view_new
// file widgets/gm-world-input-view.c line 288
struct _GtkWidget * gm_world_input_view_new()
{
  struct _GtkWidget *result;
  struct _GmColorTable *table;
  table=gm_color_table_new();
  result=gm_world_input_view_new_with_color_table(table);
  g_object_unref((void *)table);
  return result;
}

// gm_world_input_view_new_with_color_table
// file widgets/gm-world-input-view.h line 49
struct _GtkWidget * gm_world_input_view_new_with_color_table(struct _GmColorTable *color_table)
{
  struct _GmWorldInputView *view;
  unsigned long int return_value_gm_world_input_view_get_type$1;
  return_value_gm_world_input_view_get_type$1=gm_world_input_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_world_input_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_world_input_view_get_type$3;
  return_value_gm_world_input_view_get_type$3=gm_world_input_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_world_input_view_get_type$3);
  view = (struct _GmWorldInputView *)return_value_g_type_check_instance_cast$4;
  gm_world_input_view_set_color_table(view, color_table);
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$5);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
}

// gm_world_input_view_reset_prefix
// file widgets/gm-world-input-view.c line 82
static void gm_world_input_view_reset_prefix(struct _GmWorldInputView *view)
{
  view->priv->prefix=gm_world_input_view_str_new_value(view->priv->prefix, (char *)(void *)0);
}

// gm_world_input_view_set_color_table
// file widgets/gm-world-input-view.c line 322
void gm_world_input_view_set_color_table(struct _GmWorldInputView *view, struct _GmColorTable *color_table)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$1);
  gm_register_schemed((struct _GtkWidget *)return_value_g_type_check_instance_cast$2, color_table, (enum _GmSchemedFlags)(GM_SCHEMED_COLORS | GM_SCHEMED_FONT));
  if(!(view->priv->color_table == ((struct _GmColorTable *)NULL)))
    g_object_unref((void *)view->priv->color_table);

  if(!(color_table == ((struct _GmColorTable *)NULL)))
  {
    void *return_value_g_object_ref$3;
    return_value_g_object_ref$3=g_object_ref((void *)color_table);
    view->priv->color_table = (struct _GmColorTable *)return_value_g_object_ref$3;
  }

  else
    view->priv->color_table = (struct _GmColorTable *)(void *)0;
}

// gm_world_input_view_set_history
// file widgets/gm-world-input-view.h line 53
void gm_world_input_view_set_history(struct _GmWorldInputView *view, struct _GList **history)
{
  view->priv->history = history;
  view->priv->position = (struct _GList *)(void *)0;
  gm_world_input_view_reset_prefix(view);
}

// gm_world_input_view_set_text
// file widgets/gm-world-input-view.c line 66
void gm_world_input_view_set_text(struct _GmWorldInputView *view, char *text, signed int len)
{
  struct _GtkTextIter end;
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  g_signal_handlers_block_matched((void *)buffer, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_world_input_view_changed, (void *)view);
  gtk_text_buffer_set_text(buffer, text, len);
  gtk_text_buffer_get_end_iter(buffer, &end);
  gtk_text_buffer_place_cursor(buffer, &end);
  g_signal_handlers_unblock_matched((void *)buffer, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_world_input_view_changed, (void *)view);
}

// gm_world_input_view_str_new_value
// file widgets/gm-world-input-view.c line 55
static char * gm_world_input_view_str_new_value(char *old, char *new)
{
  g_free((void *)old);
  if(!(new == ((char *)NULL)))
  {
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup(new);
    return return_value_g_strdup$1;
  }

  else
    return (char *)(void *)0;
}

// gm_world_load
// file ./gm-world.h line 102
void gm_world_load(struct _GmWorld *world)
{
  if(!(world->priv->loaded == 0))
    g_signal_emit((void *)world, world_signals[(signed long int)0], (unsigned int)0);

  else
  {
    world->priv->loaded = (signed int)!(0 != 0);
    g_signal_emit((void *)world, world_signals[(signed long int)1], (unsigned int)0);
    g_signal_emit((void *)world, world_signals[(signed long int)0], (unsigned int)0);
    gm_world_connect(world);
  }
}

// gm_world_load_input_history
// file gm-world.c line 379
static void gm_world_load_input_history(struct _GmWorld *world)
{
  struct _IO_FILE *f;
  char line[1024l];
  char *filename;
  struct _GString *str;
  filename=g_strconcat(world->priv->path, (const void *)"/", (const void *)"history", (void *)0);
  gm_debug_msg(DEBUG_DEFAULT, "GmWorld.LoadInputHistory: loading history (%s)!", filename);
  f=fopen(filename, "r");
  char *return_value_fgets$1;
  if(!(f == ((struct _IO_FILE *)NULL)))
  {
    str=g_string_new("");
    do
    {
      return_value_fgets$1=fgets(line, 1024 - 1, f);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      g_string_append(str, line);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(line);
      if((signed int)line[-1l + (signed long int)return_value_strlen$4] == 10)
      {
        if(!((signed int)line[1l] == 0))
        {
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(str->str);
          char *return_value_g_strndup$3;
          return_value_g_strndup$3=g_strndup(str->str, return_value_strlen$2 - (unsigned long int)1);
          world->priv->history=g_list_append(world->priv->history, (void *)return_value_g_strndup$3);
        }

        g_string_erase(str, (signed long int)0, (signed long int)-1);
      }

    }
    while((_Bool)1);
    g_string_free(str, (signed int)!(0 != 0));
    fclose(f);
  }

  else
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    gm_debug_msg(DEBUG_DEFAULT, "GmWorld.LoadInputHistory: could not retrieve contents of file %s (%s)", filename, return_value_strerror$6);
  }
  g_free((void *)filename);
}

// gm_world_load_triggers
// file gm-world.c line 459
static void gm_world_load_triggers(struct _GmWorld *world)
{
  char *path;
  char *oldpath;
  if(!(world->priv->triggers == ((struct _GmTriggers *)NULL)))
    g_object_unref((void *)world->priv->triggers);

  oldpath=g_strconcat(world->priv->path, (const void *)"/", (const void *)"triggers", (void *)0);
  path=g_strconcat(world->priv->path, (const void *)"/", (const void *)"triggers.xml", (void *)0);
  signed int return_value_g_file_test$2;
  return_value_g_file_test$2=g_file_test(oldpath, (enum anonymous$106)G_FILE_TEST_EXISTS);
  signed int return_value_g_file_test$1;
  if(!(return_value_g_file_test$2 == 0))
  {
    return_value_g_file_test$1=g_file_test(path, (enum anonymous$106)G_FILE_TEST_EXISTS);
    if(return_value_g_file_test$1 == 0)
      rename(oldpath, path);

  }

  g_free((void *)oldpath);
  world->priv->triggers=gm_triggers_new_from_file(path);
  g_free((void *)path);
}

// gm_world_loaded
// file ./gm-world.h line 122
signed int gm_world_loaded(struct _GmWorld *world)
{
  return world->priv->loaded;
}

// gm_world_log
// file gm-world.c line 733
void gm_world_log(struct _GmWorld *world, enum _GmLogType type, const char *text)
{
  struct _GString *s;
  char *start;
  char *log;
  char *no_ansi;
  struct tm *timet;
  signed long int timer;
  signed int len;
  struct _GmOptions *options;
  _Bool tmp_if_expr$4;
  if(!((signed int)type == LOG_NONE))
  {
    signed int return_value_gm_world_log_allowed$1;
    return_value_gm_world_log_allowed$1=gm_world_log_allowed(world, type);
    if(!(return_value_gm_world_log_allowed$1 == 0))
    {
      struct _GmApp *return_value_gm_app_instance$2;
      return_value_gm_app_instance$2=gm_app_instance();
      options=gm_app_options(return_value_gm_app_instance$2);
      signed int return_value_gm_options_get_int$3;
      return_value_gm_options_get_int$3=gm_options_get_int(world->priv->options, "logging_override");
      if(!(return_value_gm_options_get_int$3 == 0))
        options = world->priv->options;

      timer=time(((signed long int *)NULL));
      timet=localtime(&timer);
      if(!(world->priv->fd_log >= 1))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = world->priv->last_day != timet->tm_mday ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        if(world->priv->fd_log >= 1)
          close(world->priv->fd_log);

        log=g_strdup_printf("%s/logs/%04d-%02d-%02d.log", world->priv->path, timet->tm_year + 1900, timet->tm_mon + 1, timet->tm_mday);
        world->priv->fd_log=open(log, 02000 | 0100 | 02, 0400 | 0200);
        g_free((void *)log);
        world->priv->last_day = timet->tm_mday;
      }

      if(!(world->priv->fd_log == -1))
      {
        signed int return_value_gm_options_get_int$5;
        return_value_gm_options_get_int$5=gm_options_get_int(options, "logging_add_timestamp");
        if(!(return_value_gm_options_get_int$5 == 0))
        {
          start=g_strdup_printf("[%02d:%02d] ", timet->tm_hour, timet->tm_min);
          s=g_string_new(start);
          g_free((void *)start);
        }

        else
          s=g_string_new("");
        signed int return_value_gm_options_get_int$6;
        return_value_gm_options_get_int$6=gm_options_get_int(options, "logging_add_log_type");
        if(!(return_value_gm_options_get_int$6 == 0))
        {
          switch((signed int)type)
          {
            case LOG_IN:
            {
              s=g_string_append_c_inline$link4(s, (char)60);
              break;
            }
            case LOG_OUT:
            {
              s=g_string_append_c_inline$link4(s, (char)62);
              break;
            }
            case LOG_STATUS:
            {
              s=g_string_append_c_inline$link4(s, (char)35);
              break;
            }
            case LOG_MCP_IN:
            {
              s=g_string_append(s, "[MCP] <");
              break;
            }
            case LOG_MCP_OUT:
            {
              s=g_string_append(s, "[MCP] >");
              break;
            }
            case LOG_MCP_STATUS:
              s=g_string_append(s, "[MCP] #");
          }
          s=g_string_append_c_inline$link4(s, (char)32);
        }

        s=g_string_append(s, text);
        char *return_value_g_strdup$7;
        return_value_g_strdup$7=g_strdup(s->str);
        no_ansi=gm_ansi_strip(return_value_g_strdup$7);
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(no_ansi);
        len = (signed int)return_value_strlen$8;
        unsigned long int return_value_strlen$9;
        return_value_strlen$9=strlen(no_ansi);
        write(world->priv->fd_log, (const void *)no_ansi, return_value_strlen$9);
        if(!((signed int)no_ansi[(signed long int)(len + -1)] == 10))
          write(world->priv->fd_log, (const void *)"\n", (unsigned long int)1);

        g_free((void *)no_ansi);
        g_string_free(s, (signed int)!(0 != 0));
      }

    }

  }

}

// gm_world_log_allowed
// file gm-world.c line 696
signed int gm_world_log_allowed(struct _GmWorld *world, enum _GmLogType type)
{
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$1);
  signed int return_value_gm_options_get_int$2;
  return_value_gm_options_get_int$2=gm_options_get_int(options, "logging_enable");
  signed int return_value_gm_options_get_int$4;
  signed int return_value_gm_options_get_int$5;
  signed int return_value_gm_options_get_int$6;
  signed int return_value_gm_options_get_int$7;
  signed int return_value_gm_options_get_int$8;
  signed int return_value_gm_options_get_int$9;
  if(return_value_gm_options_get_int$2 == 0)
    return 0;

  else
  {
    signed int return_value_gm_options_get_int$3;
    return_value_gm_options_get_int$3=gm_options_get_int(world->priv->options, "logging_override");
    if(!(return_value_gm_options_get_int$3 == 0))
      options = world->priv->options;

    switch((signed int)type)
    {
      case LOG_IN:
      {
        return_value_gm_options_get_int$4=gm_options_get_int(options, "logging_in");
        return return_value_gm_options_get_int$4;
      }
      case LOG_OUT:
      {
        return_value_gm_options_get_int$5=gm_options_get_int(options, "logging_out");
        return return_value_gm_options_get_int$5;
      }
      case LOG_STATUS:
      {
        return_value_gm_options_get_int$6=gm_options_get_int(options, "logging_status");
        return return_value_gm_options_get_int$6;
      }
      case LOG_MCP_IN:
      {
        return_value_gm_options_get_int$7=gm_options_get_int(options, "logging_mcp_in");
        return return_value_gm_options_get_int$7;
      }
      case LOG_MCP_OUT:
      {
        return_value_gm_options_get_int$8=gm_options_get_int(options, "logging_mcp_out");
        return return_value_gm_options_get_int$8;
      }
      case LOG_MCP_STATUS:
      {
        return_value_gm_options_get_int$9=gm_options_get_int(options, "logging_mcp_status");
        return return_value_gm_options_get_int$9;
      }
      default:
        return 0;
    }
  }
}

// gm_world_logs_dialog_build_tree_view
// file dialogs/gm-world-logs-dialog.c line 20
void gm_world_logs_dialog_build_tree_view(struct _GtkTreeView *tree_view)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeModel *smodel;
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GtkListStore *return_value_gtk_list_store_new$1;
  return_value_gtk_list_store_new$1=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$2;
  return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_list_store_new$1, return_value_gtk_tree_model_get_type$2);
  model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3;
  renderer=gtk_cell_renderer_text_new();
  char *return_value_gettext$4;
  return_value_gettext$4=gettext("Logs");
  column=gtk_tree_view_column_new_with_attributes(return_value_gettext$4, renderer, (const void *)"text", 1, (void *)0);
  gtk_tree_view_append_column(tree_view, column);
  smodel=gtk_tree_model_sort_new_with_model(model);
  g_object_unref((void *)model);
  gtk_tree_view_column_set_sort_column_id(column, 0);
  unsigned long int return_value_gtk_tree_sortable_get_type$5;
  return_value_gtk_tree_sortable_get_type$5=gtk_tree_sortable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)smodel, return_value_gtk_tree_sortable_get_type$5);
  gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$6, 0, (enum anonymous$151)GTK_SORT_DESCENDING);
  unsigned long int return_value_gtk_tree_model_get_type$7;
  return_value_gtk_tree_model_get_type$7=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)smodel, return_value_gtk_tree_model_get_type$7);
  gtk_tree_view_set_model(tree_view, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$8);
  g_object_unref((void *)smodel);
}

// gm_world_logs_dialog_fill
// file dialogs/gm-world-logs-dialog.c line 45
signed int gm_world_logs_dialog_fill(struct _GmWorld *world, struct _GtkTreeView *view, struct _GtkTreeModel *model, struct _GError **err)
{
  signed int res = 0;
  char *path;
  char *tmp;
  char *tmp2;
  const char *fname;
  struct _GDir *dir;
  struct _GtkTreeIter iter;
  struct _IO_FILE *f;
  signed long int fsize;
  const char *return_value_gm_world_path$1;
  return_value_gm_world_path$1=gm_world_path(world);
  path=g_strdup_printf("%s/logs/", return_value_gm_world_path$1);
  dir=g_dir_open(path, (unsigned int)0, err);
  if(!(dir == ((struct _GDir *)NULL)))
  {
    do
    {
      fname=g_dir_read_name(dir);
      if(fname == ((const char *)NULL))
        break;

      res = res + 1;
      tmp=g_strconcat(path, fname, (void *)0);
      f=fopen(tmp, "r");
      if(!(f == ((struct _IO_FILE *)NULL)))
      {
        fseek(f, (signed long int)0, 2);
        fsize=ftell(f);
        fclose(f);
        g_free((void *)tmp);
        tmp=gnome_vfs_format_file_size_for_display((unsigned long int)fsize);
        tmp2=g_strconcat(fname, (const void *)" (", tmp, (const void *)")", (void *)0);
        unsigned long int return_value_gtk_list_store_get_type$2;
        return_value_gtk_list_store_get_type$2=gtk_list_store_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
        return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_list_store_get_type$2);
        gtk_list_store_prepend((struct _GtkListStore *)return_value_g_type_check_instance_cast$3, &iter);
        unsigned long int return_value_gtk_list_store_get_type$4;
        return_value_gtk_list_store_get_type$4=gtk_list_store_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
        return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_list_store_get_type$4);
        gtk_list_store_set((struct _GtkListStore *)return_value_g_type_check_instance_cast$5, &iter, 0, fname, 1, tmp2, -1);
        g_free((void *)tmp2);
      }

      g_free((void *)tmp);
    }
    while((_Bool)1);
    g_dir_close(dir);
    g_free((void *)path);
    return res;
  }

  else
  {
    g_free((void *)path);
    return -1;
  }
}

// gm_world_logs_dialog_new
// file ./dialogs/gm-world-logs-dialog.h line 7
struct _GtkDialog * gm_world_logs_dialog_new(struct _GmWorld *world, struct _GtkTreeView **view)
{
  struct _GladeXML *xml;
  struct _GtkDialog *dlg;
  struct _GError *err = (struct _GError *)(void *)0;
  signed int res;
  char *tmp;
  struct _GtkTreeModel *model;
  struct _GtkTreeModel *smodel;
  struct _GtkTreeIter iter;
  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-world-logs.glade", "gm_world_logs_dialog", (const char *)(void *)0);
  if(xml == ((struct _GladeXML *)NULL))
  {
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-world-logs.glade");
    return (struct _GtkDialog *)(void *)0;
  }

  else
  {
    struct _GtkWidget *return_value_glade_xml_get_widget$1;
    return_value_glade_xml_get_widget$1=glade_xml_get_widget(xml, "gm_world_logs_dialog");
    unsigned long int return_value_gtk_dialog_get_type$2;
    return_value_gtk_dialog_get_type$2=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_dialog_get_type$2);
    dlg = (struct _GtkDialog *)return_value_g_type_check_instance_cast$3;
    struct _GtkWidget *return_value_glade_xml_get_widget$4;
    return_value_glade_xml_get_widget$4=glade_xml_get_widget(xml, "tree_view_files");
    unsigned long int return_value_gtk_tree_view_get_type$5;
    return_value_gtk_tree_view_get_type$5=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$4, return_value_gtk_tree_view_get_type$5);
    *view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$6;
    gm_world_logs_dialog_build_tree_view(*view);
    smodel=gtk_tree_view_get_model(*view);
    unsigned long int return_value_gtk_tree_model_sort_get_type$7;
    return_value_gtk_tree_model_sort_get_type$7=gtk_tree_model_sort_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)smodel, return_value_gtk_tree_model_sort_get_type$7);
    model=gtk_tree_model_sort_get_model((struct _GtkTreeModelSort *)return_value_g_type_check_instance_cast$8);
    res=gm_world_logs_dialog_fill(world, *view, model, &err);
    if(res == -1)
    {
      char *return_value_gettext$9;
      return_value_gettext$9=gettext("Couldn't open the log directory: %s");
      tmp=g_strdup_printf(return_value_gettext$9, err->message);
      gm_error_dialog(tmp, (struct _GtkWindow *)(void *)0);
      g_error_free(err);
      g_free((void *)tmp);
      unsigned long int return_value_gtk_widget_get_type$10;
      return_value_gtk_widget_get_type$10=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_widget_get_type$10);
      gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$11);
      dlg = (struct _GtkDialog *)(void *)0;
    }

    else
      if(res == 0)
      {
        char *return_value_gettext$12;
        return_value_gettext$12=gettext("There are no log files for this world");
        gm_info_dialog(return_value_gettext$12, (struct _GtkWindow *)(void *)0);
        unsigned long int return_value_gtk_widget_get_type$13;
        return_value_gtk_widget_get_type$13=gtk_widget_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
        return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_widget_get_type$13);
        gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$14);
        dlg = (struct _GtkDialog *)(void *)0;
      }

      else
      {
        signed int return_value_gtk_tree_model_get_iter_first$16;
        return_value_gtk_tree_model_get_iter_first$16=gtk_tree_model_get_iter_first(smodel, &iter);
        if(!(return_value_gtk_tree_model_get_iter_first$16 == 0))
        {
          struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$15;
          return_value_gtk_tree_view_get_selection$15=gtk_tree_view_get_selection(*view);
          gtk_tree_selection_select_iter(return_value_gtk_tree_view_get_selection$15, &iter);
        }

        glade_xml_signal_connect_data(xml, "on_tree_view_files_row_activated", (void (*)(void))on_gm_world_logs_dialog_row_activated, (void *)dlg);
      }
    g_object_unref((void *)xml);
    return dlg;
  }
}

// gm_world_name
// file ./gm-world.h line 105
const char * gm_world_name(struct _GmWorld *world)
{
  const char *return_value_gm_options_get$1;
  return_value_gm_options_get$1=gm_options_get(world->priv->options, "name");
  return return_value_gm_options_get$1;
}

// gm_world_name_changed
// file gm-world.c line 1232
void gm_world_name_changed(struct _GmWorld *world)
{
  char *tmp_path;
  char *tmp_if_expr$2;
  char *return_value_g_strdup$1;
  if(!(world->priv->path == ((char *)NULL)))
  {
    return_value_g_strdup$1=g_strdup(world->priv->path);
    tmp_if_expr$2 = return_value_g_strdup$1;
  }

  else
    tmp_if_expr$2 = (char *)(void *)0;
  tmp_path = tmp_if_expr$2;
  char *new_path;
  struct _GmApp *return_value_gm_app_instance$3;
  return_value_gm_app_instance$3=gm_app_instance();
  const char *return_value_gm_app_worlds_path$4;
  return_value_gm_app_worlds_path$4=gm_app_worlds_path(return_value_gm_app_instance$3);
  const char *return_value_gm_options_get$5;
  return_value_gm_options_get$5=gm_options_get(world->priv->options, "name");
  new_path=g_strconcat(return_value_gm_app_worlds_path$4, (const void *)"/", return_value_gm_options_get$5, (void *)0);
  signed int return_value_strcmp$6;
  _Bool tmp_if_expr$9;
  signed int return_value_g_file_test$8;
  signed int return_value_g_file_test$7;
  if(!(tmp_path == ((char *)NULL)))
  {
    return_value_strcmp$6=strcmp(tmp_path, new_path);
    if(!(return_value_strcmp$6 == 0))
      goto __CPROVER_DUMP_L3;

    g_free((void *)new_path);
    g_free((void *)tmp_path);
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    g_free((void *)world->priv->path);
    world->priv->path = new_path;
    if(!(tmp_path == ((char *)NULL)))
    {
      return_value_g_file_test$8=g_file_test(tmp_path, (enum anonymous$106)G_FILE_TEST_EXISTS);
      tmp_if_expr$9 = return_value_g_file_test$8 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      rename(tmp_path, world->priv->path);

    else
    {
      return_value_g_file_test$7=g_file_test(world->priv->path, (enum anonymous$106)G_FILE_TEST_EXISTS);
      if(return_value_g_file_test$7 == 0)
        mkdir(world->priv->path, (unsigned int)0755);

    }
    g_free((void *)tmp_path);
    tmp_path=g_strconcat(world->priv->path, (const void *)"/", (const void *)"settings.xml", (void *)0);
    gm_options_save_as(world->priv->options, tmp_path);
    g_free((void *)tmp_path);
    tmp_path=g_strconcat(world->priv->path, (const void *)"/", (const void *)"triggers.xml", (void *)0);
    gm_triggers_save_as(world->priv->triggers, tmp_path);
    g_free((void *)tmp_path);
    gm_world_check_dirs(world);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)world, (unsigned long int)(20 << 2));
    g_object_notify((struct _GObject *)return_value_g_type_check_instance_cast$10, "name");
  }
}

// gm_world_new
// file ./gm-world.h line 99
struct _GmWorld * gm_world_new(char *path)
{
  struct _GmWorld *world;
  unsigned long int return_value_gm_world_get_type$1;
  return_value_gm_world_get_type$1=gm_world_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_world_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_world_get_type$3;
  return_value_gm_world_get_type$3=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_world_get_type$3);
  world = (struct _GmWorld *)return_value_g_type_check_instance_cast$4;
  char *options_path;
  char *basename;
  if(!(path == ((char *)NULL)))
  {
    options_path=g_strconcat(path, (const void *)"/", (const void *)"settings.xml", (void *)0);
    gm_debug_msg(DEBUG_DEFAULT, "GmWorld.new: creating new world for %s", path);
    world->priv->path=g_strdup(path);
    gm_debug_msg(DEBUG_DEFAULT, "GmWorld.new: creating default world settings for %s", path);
    _gm_options_check_old_options(options_path);
    signed int return_value_gm_options_load$5;
    return_value_gm_options_load$5=gm_options_load(world->priv->options, options_path);
    if(return_value_gm_options_load$5 == 0)
    {
      basename=g_path_get_basename(path);
      gm_options_set(world->priv->options, "name", basename);
      g_free((void *)basename);
    }

    const char *return_value_gm_options_get$7;
    return_value_gm_options_get$7=gm_options_get(world->priv->options, "charset");
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(return_value_gm_options_get$7);
    if(return_value_strlen$8 == 0ul)
    {
      const char *return_value_gm_default_charset$6;
      return_value_gm_default_charset$6=gm_default_charset();
      gm_options_set(world->priv->options, "charset", return_value_gm_default_charset$6);
    }

    g_free((void *)options_path);
    gm_world_load_input_history(world);
    gm_world_load_triggers(world);
    gm_world_check_dirs(world);
  }

  return world;
}

// gm_world_options
// file ./gm-world.h line 106
struct _GmOptions * gm_world_options(struct _GmWorld *world)
{
  return world->priv->options;
}

// gm_world_parse_legacy_editing_start
// file gm-world.c line 830
void gm_world_parse_legacy_editing_start(struct _GmWorld *world, char *line)
{
  char *name_start;
  char *upload_start;
  struct _GmEditingInfo *einfo = &world->priv->editing_info;
  name_start=strstr(line, "name: ");
  if(!(name_start == ((char *)NULL)))
  {
    upload_start=strstr(line, " upload: ");
    if(!(upload_start == ((char *)NULL)))
    {
      einfo->is_editing = (signed int)!(0 != 0);
      einfo->name=g_strndup(name_start + (signed long int)6, (unsigned long int)((upload_start - name_start) - (signed long int)6));
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(line);
      einfo->upload=g_strndup(upload_start + (signed long int)9, (return_value_strlen$1 - (unsigned long int)(upload_start - line)) - (unsigned long int)9);
      einfo->lines = (struct _GList *)(void *)0;
    }

  }

}

// gm_world_paste_dialog_do_paste
// file dialogs/gm-world-paste-dialog.c line 258
static void gm_world_paste_dialog_do_paste()
{
  struct _GmWorld *world;
  world=gm_app_view_active_world(gm_world_paste_dialog_instance->view);
  char *command;
  struct _GtkWidget *return_value_gm_world_paste_dialog_widget$1;
  return_value_gm_world_paste_dialog_widget$1=gm_world_paste_dialog_widget("combo_box_command");
  unsigned long int return_value_gtk_combo_box_get_type$2;
  return_value_gtk_combo_box_get_type$2=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_paste_dialog_widget$1, return_value_gtk_combo_box_get_type$2);
  command=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$3);
  char *to;
  to=gm_world_paste_get_to();
  char *cmd;
  const char *end_with;
  signed int return_value_gm_world_connected$14;
  return_value_gm_world_connected$14=gm_world_connected(world);
  _Bool tmp_if_expr$10;
  if(return_value_gm_world_connected$14 == 0)
  {
    char *return_value_gettext$4;
    return_value_gettext$4=gettext("The current world is not connected");
    unsigned long int return_value_gtk_window_get_type$5;
    return_value_gtk_window_get_type$5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)gm_world_paste_dialog_instance->dialog, return_value_gtk_window_get_type$5);
    gm_error_dialog(return_value_gettext$4, (struct _GtkWindow *)return_value_g_type_check_instance_cast$6);
  }

  else
    if(command == ((char *)NULL))
    {
      char *return_value_gettext$7;
      return_value_gettext$7=gettext("Please specify a command to be send");
      unsigned long int return_value_gtk_window_get_type$8;
      return_value_gtk_window_get_type$8=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)gm_world_paste_dialog_instance->dialog, return_value_gtk_window_get_type$8);
      gm_error_dialog(return_value_gettext$7, (struct _GtkWindow *)return_value_g_type_check_instance_cast$9);
    }

    else
    {
      if(!(to == ((char *)NULL)))
        tmp_if_expr$10 = (signed int)*to != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
        cmd=g_strconcat(command, (const void *)" ", to, (void *)0);

      else
        cmd=g_strdup(command);
      gm_world_sendln(world, cmd);
      g_free((void *)cmd);
      struct _GtkWidget *return_value_gm_world_paste_dialog_widget$11;
      return_value_gm_world_paste_dialog_widget$11=gm_world_paste_dialog_widget("entry_end_with");
      unsigned long int return_value_gtk_entry_get_type$12;
      return_value_gtk_entry_get_type$12=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
      return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_paste_dialog_widget$11, return_value_gtk_entry_get_type$12);
      end_with=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$13);
      gm_world_paste_dialog_send_text(world, end_with);
      if(!(end_with == ((const char *)NULL)))
        gm_world_sendln(world, end_with);

    }
  g_free((void *)command);
  g_free((void *)to);
}

// gm_world_paste_dialog_fill_to
// file dialogs/gm-world-paste-dialog.c line 70
static void gm_world_paste_dialog_fill_to()
{
  struct _GtkWidget *widget;
  widget=gm_world_paste_dialog_widget("combo_box_to");
  struct _GmWorldView *view;
  view=gm_app_view_active_world_view(gm_world_paste_dialog_instance->view);
  struct _GtkWidget *paned;
  struct _GtkHPaned *return_value_gm_world_view_hpaned$1;
  return_value_gm_world_view_hpaned$1=gm_world_view_hpaned(view);
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_view_hpaned$1, return_value_gtk_widget_get_type$2);
  paned = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  struct _GtkWidget *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$4;
  return_value_gtk_tree_view_get_type$4=gtk_tree_view_get_type();
  tree_view=gm_find_child(paned, return_value_gtk_tree_view_get_type$4);
  struct _GtkTreeModel *model;
  struct _GtkTreeModel *sorted;
  if(!(gm_world_paste_dialog_instance->model == ((struct _GtkTreeModel *)NULL)))
  {
    g_object_ref((void *)gm_world_paste_dialog_instance->model);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)gm_world_paste_dialog_instance->model, (unsigned long int)(20 << 2));
    g_object_remove_toggle_ref((struct _GObject *)return_value_g_type_check_instance_cast$5, gm_world_paste_dialog_remove_model, (void *)0);
  }

  unsigned long int return_value_gtk_combo_box_get_type$6;
  return_value_gtk_combo_box_get_type$6=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$6);
  gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$7, (struct _GtkTreeModel *)(void *)0);
  signed int tmp_statement_expression$12;
  _Bool tmp_if_expr$13;
  if(tree_view == ((struct _GtkWidget *)NULL))
    gm_world_paste_dialog_instance->model = (struct _GtkTreeModel *)(void *)0;

  else
  {
    unsigned long int return_value_gtk_tree_view_get_type$8;
    return_value_gtk_tree_view_get_type$8=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_tree_view_get_type$8);
    model=gtk_tree_view_get_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$9);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)model;
    unsigned long int __t;
    __t=gtk_tree_model_sort_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$13 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$13 = (_Bool)0;
      if(tmp_if_expr$13)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$12 = __r;
    if(!(tmp_statement_expression$12 == 0))
    {
      unsigned long int return_value_gtk_tree_model_sort_get_type$10;
      return_value_gtk_tree_model_sort_get_type$10=gtk_tree_model_sort_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_tree_model_sort_get_type$10);
      model=gtk_tree_model_sort_get_model((struct _GtkTreeModelSort *)return_value_g_type_check_instance_cast$11);
    }

    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)model, (unsigned long int)(20 << 2));
    g_object_add_toggle_ref((struct _GObject *)return_value_g_type_check_instance_cast$14, gm_world_paste_dialog_remove_model, (void *)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)model, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$15);
    gm_world_paste_dialog_instance->model = model;
    sorted=gtk_tree_model_sort_new_with_model(model);
    unsigned long int return_value_gtk_tree_sortable_get_type$16;
    return_value_gtk_tree_sortable_get_type$16=gtk_tree_sortable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)sorted, return_value_gtk_tree_sortable_get_type$16);
    gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$17, 1, (enum anonymous$151)GTK_SORT_ASCENDING);
    unsigned long int return_value_gtk_combo_box_get_type$18;
    return_value_gtk_combo_box_get_type$18=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$18);
    gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$19, sorted);
    unsigned long int return_value_gtk_combo_box_entry_get_type$22;
    return_value_gtk_combo_box_entry_get_type$22=gtk_combo_box_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_entry_get_type$22);
    signed int return_value_gtk_combo_box_entry_get_text_column$24;
    return_value_gtk_combo_box_entry_get_text_column$24=gtk_combo_box_entry_get_text_column((struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$23);
    if(return_value_gtk_combo_box_entry_get_text_column$24 == -1)
    {
      unsigned long int return_value_gtk_combo_box_entry_get_type$20;
      return_value_gtk_combo_box_entry_get_type$20=gtk_combo_box_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
      return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_entry_get_type$20);
      gtk_combo_box_entry_set_text_column((struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$21, 1);
    }

  }
}

// gm_world_paste_dialog_init_command
// file dialogs/gm-world-paste-dialog.c line 45
static void gm_world_paste_dialog_init_command()
{
  struct _GtkComboBox *combo_box;
  struct _GtkWidget *return_value_gm_world_paste_dialog_widget$1;
  return_value_gm_world_paste_dialog_widget$1=gm_world_paste_dialog_widget("combo_box_command");
  unsigned long int return_value_gtk_combo_box_get_type$2;
  return_value_gtk_combo_box_get_type$2=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_paste_dialog_widget$1, return_value_gtk_combo_box_get_type$2);
  combo_box = (struct _GtkComboBox *)return_value_g_type_check_instance_cast$3;
  const char **command = commands;
  for( ; !(*command == ((const char *)NULL)); command = command + 1l)
    gtk_combo_box_append_text(combo_box, *command);
  gtk_combo_box_set_active(combo_box, 0);
}

// gm_world_paste_dialog_init_end_with
// file dialogs/gm-world-paste-dialog.c line 147
static void gm_world_paste_dialog_init_end_with()
{
  struct _GtkWidget *return_value_gm_world_paste_dialog_widget$1;
  return_value_gm_world_paste_dialog_widget$1=gm_world_paste_dialog_widget("entry_end_with");
  unsigned long int return_value_gtk_entry_get_type$2;
  return_value_gtk_entry_get_type$2=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_paste_dialog_widget$1, return_value_gtk_entry_get_type$2);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$3, ".");
}

// gm_world_paste_dialog_init_text
// file dialogs/gm-world-paste-dialog.c line 133
static void gm_world_paste_dialog_init_text()
{
  struct _GtkWidget *widget;
  widget=gm_world_paste_dialog_widget("text_view_text");
  struct _GtkClipboard *clipboard;
  clipboard=gtk_clipboard_get((struct _GdkAtom *)(void *)(unsigned long int)1);
  char *text;
  text=gtk_clipboard_wait_for_text(clipboard);
  if(!(text == ((char *)NULL)))
  {
    unsigned long int return_value_gtk_text_view_get_type$1;
    return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_text_view_get_type$1);
    struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$3;
    return_value_gtk_text_view_get_buffer$3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
    gtk_text_buffer_set_text(return_value_gtk_text_view_get_buffer$3, text, -1);
  }

  g_free((void *)text);
}

// gm_world_paste_dialog_init_to
// file dialogs/gm-world-paste-dialog.c line 118
static void gm_world_paste_dialog_init_to()
{
  struct _GtkWidget *widget;
  widget=gm_world_paste_dialog_widget("combo_box_to");
  struct _GtkCellRenderer *cell;
  cell=gtk_cell_renderer_pixbuf_new();
  unsigned long int return_value_gtk_cell_layout_get_type$1;
  return_value_gtk_cell_layout_get_type$1=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_cell_layout_get_type$1);
  gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$2, cell, 0);
  unsigned long int return_value_gtk_cell_layout_get_type$3;
  return_value_gtk_cell_layout_get_type$3=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_cell_layout_get_type$3);
  gtk_cell_layout_add_attribute((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$4, cell, "pixbuf", 0);
  unsigned long int return_value_gtk_cell_layout_get_type$5;
  return_value_gtk_cell_layout_get_type$5=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_cell_layout_get_type$5);
  gtk_cell_layout_reorder((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$6, cell, 0);
  gm_world_paste_dialog_fill_to();
}

// gm_world_paste_dialog_remove_model
// file dialogs/gm-world-paste-dialog.c line 58
static void gm_world_paste_dialog_remove_model(void *data, struct _GObject *model, signed int is_last_ref)
{
  struct _GtkWidget *widget;
  if(!(is_last_ref == 0))
  {
    widget=gm_world_paste_dialog_widget("combo_box_to");
    unsigned long int return_value_gtk_combo_box_get_type$1;
    return_value_gtk_combo_box_get_type$1=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$1);
    gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$2, (struct _GtkTreeModel *)(void *)0);
    gm_world_paste_dialog_instance->model = (struct _GtkTreeModel *)(void *)0;
  }

}

// gm_world_paste_dialog_run
// file ./dialogs/gm-world-paste-dialog.h line 5
void gm_world_paste_dialog_run(struct _GmAppView *view)
{
  struct _GladeXML *xml;
  if(!(gm_world_paste_dialog_instance == ((struct _GmWorldPasteDialog *)NULL)))
  {
    if(!(view == gm_world_paste_dialog_instance->view))
    {
      g_signal_handlers_disconnect_matched((void *)view, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_paste_dialog_active_world_changed, (void *)0);
      g_signal_connect_data((void *)view, "active_world_changed", (void (*)(void))on_gm_world_paste_dialog_active_world_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    }

    gm_world_paste_dialog_fill_to();
    gtk_widget_show(gm_world_paste_dialog_instance->dialog);
    unsigned long int return_value_gtk_window_get_type$1;
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gm_world_paste_dialog_instance->dialog, return_value_gtk_window_get_type$1);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
    goto __CPROVER_DUMP_L4;
  }

  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-world-paste.glade", "gm_world_paste_dialog", (const char *)(void *)0);
  if(xml == ((struct _GladeXML *)NULL))
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-world-paste.glade");

  else
  {
    void *return_value_g_malloc0_n$3;
    return_value_g_malloc0_n$3=g_malloc0_n((unsigned long int)1, sizeof(struct _GmWorldPasteDialog) /*32ul*/ );
    gm_world_paste_dialog_instance = (struct _GmWorldPasteDialog *)return_value_g_malloc0_n$3;
    gm_world_paste_dialog_instance->xml = xml;
    gm_world_paste_dialog_instance->view = view;
    gm_world_paste_dialog_instance->dialog=gm_world_paste_dialog_widget("gm_world_paste_dialog");
    unsigned long int return_value_gtk_window_get_type$4;
    return_value_gtk_window_get_type$4=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)gm_world_paste_dialog_instance->dialog, return_value_gtk_window_get_type$4);
    unsigned long int return_value_gtk_window_get_type$6;
    return_value_gtk_window_get_type$6=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$6);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
    g_signal_connect_data((void *)gm_world_paste_dialog_instance->dialog, "response", (void (*)(void))on_gm_world_paste_dialog_response, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)view, "active_world_changed", (void (*)(void))on_gm_world_paste_dialog_active_world_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    gtk_widget_show(gm_world_paste_dialog_instance->dialog);
    gm_world_paste_dialog_init_command();
    gm_world_paste_dialog_init_to();
    gm_world_paste_dialog_init_text();
    gm_world_paste_dialog_init_end_with();
  }

__CPROVER_DUMP_L4:
  ;
}

// gm_world_paste_dialog_send_text
// file dialogs/gm-world-paste-dialog.c line 206
static void gm_world_paste_dialog_send_text(struct _GmWorld *world, const char *end_with)
{
  struct _GtkTextView *text_view;
  struct _GtkWidget *return_value_gm_world_paste_dialog_widget$1;
  return_value_gm_world_paste_dialog_widget$1=gm_world_paste_dialog_widget("text_view_text");
  unsigned long int return_value_gtk_text_view_get_type$2;
  return_value_gtk_text_view_get_type$2=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_paste_dialog_widget$1, return_value_gtk_text_view_get_type$2);
  text_view = (struct _GtkTextView *)return_value_g_type_check_instance_cast$3;
  struct _GtkTextBuffer *buffer;
  buffer=gtk_text_view_get_buffer(text_view);
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  char *text;
  char **lines;
  char **ptr;
  char *escape = (char *)(void *)0;
  gtk_text_buffer_get_bounds(buffer, &start, &end);
  text=gtk_text_buffer_get_text(buffer, &start, &end, 0);
  lines=g_strsplit(text, "\n", -1);
  if(!(end_with == ((const char *)NULL)))
    escape=g_strconcat(end_with, end_with, (void *)0);

  ptr = lines;
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  for( ; !(*ptr == ((char *)NULL)); ptr = ptr + 1l)
  {
    if(!(escape == ((char *)NULL)))
    {
      return_value_strcmp$4=strcmp(end_with, *ptr);
      tmp_if_expr$5 = return_value_strcmp$4 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      gm_world_sendln(world, escape);

    else
      gm_world_sendln(world, *ptr);
  }
  g_strfreev(lines);
  g_free((void *)text);
  g_free((void *)escape);
}

// gm_world_paste_dialog_widget
// file dialogs/gm-world-paste-dialog.c line 31
static struct _GtkWidget * gm_world_paste_dialog_widget(char *name)
{
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(gm_world_paste_dialog_instance->xml, name);
  return return_value_glade_xml_get_widget$1;
}

// gm_world_paste_get_to
// file dialogs/gm-world-paste-dialog.c line 238
static char * gm_world_paste_get_to()
{
  struct _GtkComboBox *combo;
  struct _GtkWidget *return_value_gm_world_paste_dialog_widget$1;
  return_value_gm_world_paste_dialog_widget$1=gm_world_paste_dialog_widget("combo_box_to");
  unsigned long int return_value_gtk_combo_box_get_type$2;
  return_value_gtk_combo_box_get_type$2=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_paste_dialog_widget$1, return_value_gtk_combo_box_get_type$2);
  combo = (struct _GtkComboBox *)return_value_g_type_check_instance_cast$3;
  signed int active;
  active=gtk_combo_box_get_active(combo);
  char *text;
  signed int id;
  struct _GtkTreeModel *model;
  model=gtk_combo_box_get_model(combo);
  struct _GtkTreeIter iter;
  signed int return_value_gtk_combo_box_get_active_iter$4;
  return_value_gtk_combo_box_get_active_iter$4=gtk_combo_box_get_active_iter(combo, &iter);
  if(return_value_gtk_combo_box_get_active_iter$4 == 0 || active == -1)
    text=gtk_combo_box_get_active_text(combo);

  else
  {
    gtk_tree_model_get(model, &iter, 3, &id, -1);
    text=g_strdup_printf("#%d", id);
  }
  return text;
}

// gm_world_path
// file ./gm-world.h line 107
const char * gm_world_path(struct _GmWorld *world)
{
  return world->priv->path;
}

// gm_world_prepare_disconnect
// file ./gm-world.h line 130
void gm_world_prepare_disconnect(struct _GmWorld *world)
{
  world->priv->manual_disconnect = (signed int)!(0 != 0);
  signed long int return_value_time$1;
  return_value_time$1=time(((signed long int *)NULL));
  world->priv->manual_disconnect_timeout = return_value_time$1 + (signed long int)5;
}

// gm_world_process_input
// file ./gm-world.h line 138
void gm_world_process_input(struct _GmWorld *world, const char *text)
{
  gm_world_sendln(world, text);
}

// gm_world_process_line
// file gm-world.c line 995
void gm_world_process_line(struct _GmWorld *world, char *line, signed int len)
{
  char *non_text_start = (char *)(void *)0;
  char *from;
  struct _GmEditingInfo *einfo = &world->priv->editing_info;
  struct _GmEditor *editor;
  char *no_ansi;
  signed int has_ansi_start;
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(line, "\033[0m", (unsigned long int)4);
  if(return_value_strncmp$1 == 0)
  {
    has_ansi_start = (signed int)!(0 != 0);
    from = line + (signed long int)4;
    if(!(len == -1))
      len = len - 4;

  }

  else
  {
    has_ansi_start = 0;
    from = line;
  }
  if(len == -1)
    non_text_start=g_strdup(from);

  else
    non_text_start=g_strndup(from, (unsigned long int)len);
  signed int return_value_strncmp$9;
  if(!(einfo->is_editing == 0))
  {
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(non_text_start, ".");
    if(return_value_strcmp$3 == 0)
    {
      editor=gm_editor_new(einfo->name, einfo->upload, einfo->lines);
      g_signal_connect_data((void *)editor, "save", (void (*)(void))on_gm_world_editor_save, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
      gm_world_add_editor(world, editor);
      einfo->is_editing = 0;
      g_free((void *)einfo->name);
      einfo->name = (char *)(void *)0;
      g_free((void *)einfo->upload);
      einfo->upload = (char *)(void *)0;
      g_list_free(einfo->lines);
      einfo->lines = (struct _GList *)(void *)0;
    }

    else
    {
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup(non_text_start);
      einfo->lines=g_list_append(einfo->lines, (void *)return_value_g_strdup$2);
    }
  }

  else
  {
    return_value_strncmp$9=strncmp(non_text_start, "#$#", (unsigned long int)3);
    if(return_value_strncmp$9 == 0)
    {
      signed int return_value_strncasecmp$4;
      return_value_strncasecmp$4=strncasecmp(non_text_start + (signed long int)3, " edit ", (unsigned long int)6);
      if(return_value_strncasecmp$4 == 0)
        gm_world_parse_legacy_editing_start(world, non_text_start + (signed long int)9);

      else
      {
        gm_mcp_session_handle_oob(world->priv->mcp, non_text_start + (signed long int)3);
        gm_world_log(world, (enum _GmLogType)LOG_MCP_IN, non_text_start);
      }
    }

    else
    {
      signed int return_value_gm_world_active$5;
      return_value_gm_world_active$5=gm_world_active(world);
      if(return_value_gm_world_active$5 == 0)
        gm_world_set_activity(world, (signed int)(world->priv->activity + (unsigned int)1));

      signed int return_value_strncmp$8;
      return_value_strncmp$8=strncmp(non_text_start, "#$\"", (unsigned long int)3);
      if(return_value_strncmp$8 == 0)
      {
        if(!(has_ansi_start == 0))
          g_signal_emit((void *)world, world_signals[(signed long int)5], (unsigned int)0, (const void *)"\033[0m");

        g_signal_emit((void *)world, world_signals[(signed long int)5], (unsigned int)0, non_text_start + (signed long int)3);
        g_signal_emit((void *)world, world_signals[(signed long int)5], (unsigned int)0, (const void *)"\n");
        gm_world_log(world, (enum _GmLogType)LOG_IN, non_text_start + (signed long int)3);
        char *return_value_g_strdup$6;
        return_value_g_strdup$6=g_strdup(non_text_start + (signed long int)3);
        no_ansi=gm_ansi_strip(return_value_g_strdup$6);
      }

      else
      {
        if(!(has_ansi_start == 0))
          g_signal_emit((void *)world, world_signals[(signed long int)5], (unsigned int)0, (const void *)"\033[0m");

        g_signal_emit((void *)world, world_signals[(signed long int)5], (unsigned int)0, non_text_start);
        g_signal_emit((void *)world, world_signals[(signed long int)5], (unsigned int)0, (const void *)"\n");
        gm_world_log(world, (enum _GmLogType)LOG_IN, non_text_start);
        char *return_value_g_strdup$7;
        return_value_g_strdup$7=g_strdup(non_text_start);
        no_ansi=gm_ansi_strip(return_value_g_strdup$7);
      }
      gm_world_process_triggers(world, no_ansi);
      g_free((void *)no_ansi);
    }
  }
  g_free((void *)non_text_start);
}

// gm_world_process_triggers
// file gm-world.c line 976
void gm_world_process_triggers(struct _GmWorld *world, char *text)
{
  const struct _GList *item;
  struct _GmTrigger *trigger;
  struct anonymous$17 matches[10l];
  signed int num;
  item=gm_triggers_list(world->priv->triggers);
  for( ; !(item == ((const struct _GList *)NULL)); item = item->next)
  {
    trigger = (struct _GmTrigger *)item->data;
    if((signed int)trigger->event == TT_OUTPUT)
    {
      num=gm_trigger_match(trigger, text, matches, 10);
      if(!(num == 0))
        gm_world_apply_trigger(world, trigger, text, matches, num);

    }

  }
}

// gm_world_properties_dialog_add_trigger
// file dialogs/gm-world-properties-dialog.c line 202
void gm_world_properties_dialog_add_trigger(struct _GmWorldPropertiesDialog *properties, struct _GmTrigger *t)
{
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->tree_view_triggers, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GtkListStore *store;
  struct _GtkTreeModel *return_value_gtk_tree_view_get_model$3;
  return_value_gtk_tree_view_get_model$3=gtk_tree_view_get_model(tree_view);
  unsigned long int return_value_gtk_list_store_get_type$4;
  return_value_gtk_list_store_get_type$4=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_get_model$3, return_value_gtk_list_store_get_type$4);
  store = (struct _GtkListStore *)return_value_g_type_check_instance_cast$5;
  struct _GtkTreeIter iter;
  gtk_list_store_append(store, &iter);
  gm_world_properties_dialog_update_trigger(properties, &iter, t);
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$6;
  return_value_gtk_tree_view_get_selection$6=gtk_tree_view_get_selection(tree_view);
  gtk_tree_selection_select_iter(return_value_gtk_tree_view_get_selection$6, &iter);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$7;
  return_value_gm_world_properties_dialog_widget$7=gm_world_properties_dialog_widget(properties, "button_edit_trigger");
  gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$7, (signed int)!(0 != 0));
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$8;
  return_value_gm_world_properties_dialog_widget$8=gm_world_properties_dialog_widget(properties, "button_delete_trigger");
  gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$8, (signed int)!(0 != 0));
}

// gm_world_properties_dialog_check_values
// file dialogs/gm-world-properties-dialog.c line 538
signed int gm_world_properties_dialog_check_values(struct _GmWorldPropertiesDialog *properties)
{
  struct _GmWorld *same_world;
  struct _GmOptions *options;
  options=gm_world_options(properties->world);
  struct _GtkWidget *dialog;
  struct _GtkEntry *entry_name;
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$1;
  return_value_gm_world_properties_dialog_widget$1=gm_world_properties_dialog_widget(properties, "entry_name");
  unsigned long int return_value_gtk_entry_get_type$2;
  return_value_gtk_entry_get_type$2=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$1, return_value_gtk_entry_get_type$2);
  entry_name = (struct _GtkEntry *)return_value_g_type_check_instance_cast$3;
  char *name;
  const char *return_value_gtk_entry_get_text$4;
  return_value_gtk_entry_get_text$4=gtk_entry_get_text(entry_name);
  name=g_strdup(return_value_gtk_entry_get_text$4);
  struct _GtkEntry *entry_host;
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$5;
  return_value_gm_world_properties_dialog_widget$5=gm_world_properties_dialog_widget(properties, "entry_host");
  unsigned long int return_value_gtk_entry_get_type$6;
  return_value_gtk_entry_get_type$6=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$5, return_value_gtk_entry_get_type$6);
  entry_host = (struct _GtkEntry *)return_value_g_type_check_instance_cast$7;
  char *host;
  const char *return_value_gtk_entry_get_text$8;
  return_value_gtk_entry_get_text$8=gtk_entry_get_text(entry_host);
  host=g_strdup(return_value_gtk_entry_get_text$8);
  char *return_value_g_strchug$9;
  return_value_g_strchug$9=g_strchug(name);
  g_strchomp(return_value_g_strchug$9);
  char *return_value_g_strchug$10;
  return_value_g_strchug$10=g_strchug(host);
  g_strchomp(return_value_g_strchug$10);
  struct _GmApp *return_value_gm_app_instance$11;
  return_value_gm_app_instance$11=gm_app_instance();
  same_world=gm_app_world_by_name(return_value_gm_app_instance$11, name);
  unsigned long int return_value_strlen$21;
  return_value_strlen$21=strlen(name);
  if(return_value_strlen$21 == 0ul)
  {
    unsigned long int return_value_gtk_window_get_type$12;
    return_value_gtk_window_get_type$12=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$12);
    dialog=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$13, (enum anonymous$154)(GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT), (enum anonymous$79)GTK_MESSAGE_ERROR, (enum anonymous$152)GTK_BUTTONS_CLOSE, "Name can not be empty, please fill in a name.");
    unsigned long int return_value_gtk_dialog_get_type$14;
    return_value_gtk_dialog_get_type$14=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$14);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$15);
    gtk_widget_destroy(dialog);
    struct _GtkWidget *return_value_gm_world_properties_dialog_widget$16;
    return_value_gm_world_properties_dialog_widget$16=gm_world_properties_dialog_widget(properties, "notebook_main");
    unsigned long int return_value_gtk_notebook_get_type$17;
    return_value_gtk_notebook_get_type$17=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$16, return_value_gtk_notebook_get_type$17);
    gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$18, 0);
    unsigned long int return_value_gtk_widget_get_type$19;
    return_value_gtk_widget_get_type$19=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)entry_name, return_value_gtk_widget_get_type$19);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$20);
    g_free((void *)name);
    g_free((void *)host);
    return 0;
  }

  if(!(same_world == ((struct _GmWorld *)NULL)))
  {
    if(!(same_world == properties->world))
    {
      unsigned long int return_value_gtk_window_get_type$22;
      return_value_gtk_window_get_type$22=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
      return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$22);
      char *return_value_gettext$24;
      return_value_gettext$24=gettext("Name can not be %s because a world with that name already exists.");
      dialog=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$23, (enum anonymous$154)(GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT), (enum anonymous$79)GTK_MESSAGE_ERROR, (enum anonymous$152)GTK_BUTTONS_CLOSE, return_value_gettext$24, name);
      unsigned long int return_value_gtk_dialog_get_type$25;
      return_value_gtk_dialog_get_type$25=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
      return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$25);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$26);
      gtk_widget_destroy(dialog);
      struct _GtkWidget *return_value_gm_world_properties_dialog_widget$27;
      return_value_gm_world_properties_dialog_widget$27=gm_world_properties_dialog_widget(properties, "notebook_main");
      unsigned long int return_value_gtk_notebook_get_type$28;
      return_value_gtk_notebook_get_type$28=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
      return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$27, return_value_gtk_notebook_get_type$28);
      gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$29, 0);
      unsigned long int return_value_gtk_widget_get_type$30;
      return_value_gtk_widget_get_type$30=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
      return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)entry_name, return_value_gtk_widget_get_type$30);
      gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$31);
      g_free((void *)name);
      g_free((void *)host);
      return 0;
    }

  }

  unsigned long int return_value_strlen$42;
  return_value_strlen$42=strlen(host);
  if(return_value_strlen$42 == 0ul)
  {
    unsigned long int return_value_gtk_window_get_type$32;
    return_value_gtk_window_get_type$32=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
    return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$32);
    char *return_value_gettext$34;
    return_value_gettext$34=gettext("Host can not be empty, please fill in a host.");
    dialog=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$33, (enum anonymous$154)(GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT), (enum anonymous$79)GTK_MESSAGE_ERROR, (enum anonymous$152)GTK_BUTTONS_CLOSE, return_value_gettext$34);
    unsigned long int return_value_gtk_dialog_get_type$35;
    return_value_gtk_dialog_get_type$35=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
    return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$35);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$36);
    gtk_widget_destroy(dialog);
    struct _GtkWidget *return_value_gm_world_properties_dialog_widget$37;
    return_value_gm_world_properties_dialog_widget$37=gm_world_properties_dialog_widget(properties, "notebook_main");
    unsigned long int return_value_gtk_notebook_get_type$38;
    return_value_gtk_notebook_get_type$38=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
    return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$37, return_value_gtk_notebook_get_type$38);
    gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$39, 0);
    unsigned long int return_value_gtk_widget_get_type$40;
    return_value_gtk_widget_get_type$40=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
    return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)entry_host, return_value_gtk_widget_get_type$40);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$41);
    g_free((void *)name);
    g_free((void *)host);
    return 0;
  }

  gm_world_properties_dialog_set_triggers(properties);
  gm_world_properties_dialog_set_logging(properties);
  gm_options_set(options, "host", host);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$43;
  return_value_gm_world_properties_dialog_widget$43=gm_world_properties_dialog_widget(properties, "spin_button_port");
  unsigned long int return_value_gtk_spin_button_get_type$44;
  return_value_gtk_spin_button_get_type$44=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$43, return_value_gtk_spin_button_get_type$44);
  signed int return_value_gtk_spin_button_get_value_as_int$46;
  return_value_gtk_spin_button_get_value_as_int$46=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$45);
  gm_options_set_int(options, "port", return_value_gtk_spin_button_get_value_as_int$46);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$47;
  return_value_gm_world_properties_dialog_widget$47=gm_world_properties_dialog_widget(properties, "check_button_auto_reconnect");
  unsigned long int return_value_gtk_toggle_button_get_type$48;
  return_value_gtk_toggle_button_get_type$48=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
  return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$47, return_value_gtk_toggle_button_get_type$48);
  signed int return_value_gtk_toggle_button_get_active$50;
  return_value_gtk_toggle_button_get_active$50=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$49);
  gm_options_set_int(options, "reconnect", return_value_gtk_toggle_button_get_active$50);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$51;
  return_value_gm_world_properties_dialog_widget$51=gm_world_properties_dialog_widget(properties, "check_button_auto_load");
  unsigned long int return_value_gtk_toggle_button_get_type$52;
  return_value_gtk_toggle_button_get_type$52=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$53;
  return_value_g_type_check_instance_cast$53=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$51, return_value_gtk_toggle_button_get_type$52);
  signed int return_value_gtk_toggle_button_get_active$54;
  return_value_gtk_toggle_button_get_active$54=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$53);
  gm_options_set_int(options, "autoload", return_value_gtk_toggle_button_get_active$54);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$55;
  return_value_gm_world_properties_dialog_widget$55=gm_world_properties_dialog_widget(properties, "entry_player_name");
  unsigned long int return_value_gtk_entry_get_type$56;
  return_value_gtk_entry_get_type$56=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
  return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$55, return_value_gtk_entry_get_type$56);
  const char *return_value_gtk_entry_get_text$58;
  return_value_gtk_entry_get_text$58=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$57);
  gm_options_set(options, "player_name", (char *)return_value_gtk_entry_get_text$58);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$59;
  return_value_gm_world_properties_dialog_widget$59=gm_world_properties_dialog_widget(properties, "entry_password");
  unsigned long int return_value_gtk_entry_get_type$60;
  return_value_gtk_entry_get_type$60=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$61;
  return_value_g_type_check_instance_cast$61=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$59, return_value_gtk_entry_get_type$60);
  const char *return_value_gtk_entry_get_text$62;
  return_value_gtk_entry_get_text$62=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$61);
  gm_options_set(options, "password", (char *)return_value_gtk_entry_get_text$62);
  unsigned long int return_value_gtk_bin_get_type$63;
  return_value_gtk_bin_get_type$63=gtk_bin_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$64;
  return_value_g_type_check_instance_cast$64=g_type_check_instance_cast((struct _GTypeInstance *)properties->combo_box_charset, return_value_gtk_bin_get_type$63);
  unsigned long int return_value_gtk_entry_get_type$65;
  return_value_gtk_entry_get_type$65=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$66;
  return_value_g_type_check_instance_cast$66=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$64)->child, return_value_gtk_entry_get_type$65);
  const char *return_value_gtk_entry_get_text$67;
  return_value_gtk_entry_get_text$67=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$66);
  char *return_value_gm_world_properties_dialog_get_charset$68;
  return_value_gm_world_properties_dialog_get_charset$68=gm_world_properties_dialog_get_charset((char *)return_value_gtk_entry_get_text$67);
  gm_options_set(options, "charset", return_value_gm_world_properties_dialog_get_charset$68);
  const char *return_value_gm_options_get$70;
  return_value_gm_options_get$70=gm_options_get(options, "name");
  _Bool tmp_if_expr$73;
  const char *return_value_gm_options_get$71;
  signed int return_value_strcmp$72;
  if(return_value_gm_options_get$70 == ((const char *)NULL))
    tmp_if_expr$73 = (_Bool)1;

  else
  {
    return_value_gm_options_get$71=gm_options_get(options, "name");
    return_value_strcmp$72=strcmp(name, return_value_gm_options_get$71);
    tmp_if_expr$73 = return_value_strcmp$72 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$73)
    gm_options_set(options, "name", name);

  else
  {
    gm_options_save(options);
    struct _GmTriggers *return_value_gm_world_triggers$69;
    return_value_gm_world_triggers$69=gm_world_triggers(properties->world);
    gm_triggers_save(return_value_gm_world_triggers$69);
  }
  g_free((void *)name);
  g_free((void *)host);
  return (signed int)!(0 != 0);
}

// gm_world_properties_dialog_find
// file dialogs/gm-world-properties-dialog.c line 262
struct _GmWorldPropertiesDialog * gm_world_properties_dialog_find(struct _GmWorld *world)
{
  struct _GmWorldPropertiesDialog *result = (struct _GmWorldPropertiesDialog *)(void *)0;
  struct _GList *item = gm_world_properties_dialog_open;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    result = (struct _GmWorldPropertiesDialog *)item->data;
    if(result->world == world)
      return result;

  }
  return (struct _GmWorldPropertiesDialog *)(void *)0;
}

// gm_world_properties_dialog_free_triggers
// file dialogs/gm-world-properties-dialog.c line 483
void gm_world_properties_dialog_free_triggers(struct _GmWorldPropertiesDialog *properties)
{
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->tree_view_triggers, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GtkTreeModel *store;
  store=gtk_tree_view_get_model(tree_view);
  struct _GtkTreeIter iter;
  struct _GmTrigger *t;
  signed int return_value_gtk_tree_model_get_iter_first$4;
  return_value_gtk_tree_model_get_iter_first$4=gtk_tree_model_get_iter_first(store, &iter);
  signed int return_value_gtk_tree_model_iter_next$3;
  if(!(return_value_gtk_tree_model_get_iter_first$4 == 0))
    do
    {
      gtk_tree_model_get(store, &iter, 2, &t, -1);
      gm_trigger_free(t);
      return_value_gtk_tree_model_iter_next$3=gtk_tree_model_iter_next(store, &iter);
    }
    while(!(return_value_gtk_tree_model_iter_next$3 == 0));

}

// gm_world_properties_dialog_get_charset
// file dialogs/gm-world-properties-dialog.c line 463
char * gm_world_properties_dialog_get_charset(char *charset)
{
  char *ch;
  signed int i = 0;
  for( ; !(i >= 59); i = i + 1)
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext(encodings[(signed long int)i].name);
    ch=g_strconcat(encodings[(signed long int)i].charset, (const void *)" - ", return_value_gettext$1, (void *)0);
    signed int return_value_g_strcasecmp$3;
    return_value_g_strcasecmp$3=g_strcasecmp(charset, ch);
    if(return_value_g_strcasecmp$3 == 0)
    {
      g_free((void *)ch);
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup(encodings[(signed long int)i].charset);
      return return_value_g_strdup$2;
    }

    g_free((void *)ch);
  }
  char *return_value_g_strdup$4;
  return_value_g_strdup$4=g_strdup(charset);
  return return_value_g_strdup$4;
}

// gm_world_properties_dialog_init_logging
// file dialogs/gm-world-properties-dialog.c line 290
void gm_world_properties_dialog_init_logging(struct _GmWorldPropertiesDialog *properties)
{
  struct _GtkWidget *check;
  char *name;
  struct _GmOptions *options;
  options=gm_world_options(properties->world);
  const char **entry;
  check=gm_world_properties_dialog_widget(properties, "check_button_logging_override");
  glade_xml_signal_connect_data(properties->xml, "on_check_button_logging_override_toggled", (void (*)(void))on_gm_world_properties_dialog_check_button_logging_override_toggled, (void *)properties);
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$1);
  signed int return_value_gm_options_get_int$3;
  return_value_gm_options_get_int$3=gm_options_get_int(options, "logging_override");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2, return_value_gm_options_get_int$3);
  unsigned long int return_value_gtk_toggle_button_get_type$4;
  return_value_gtk_toggle_button_get_type$4=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$4);
  gtk_toggle_button_toggled((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$5);
  entry = logging_button_names;
  for( ; !(*entry == ((const char *)NULL)); entry = entry + 1l)
  {
    name=g_strconcat("check_button_", *entry, (void *)0);
    check=gm_world_properties_dialog_widget(properties, name);
    g_free((void *)name);
    unsigned long int return_value_gtk_toggle_button_get_type$6;
    return_value_gtk_toggle_button_get_type$6=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$6);
    signed int return_value_gm_options_get_int$8;
    return_value_gm_options_get_int$8=gm_options_get_int(options, *entry);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$7, return_value_gm_options_get_int$8);
  }
}

// gm_world_properties_dialog_initialize
// file dialogs/gm-world-properties-dialog.c line 317
void gm_world_properties_dialog_initialize(struct _GmWorldPropertiesDialog *properties)
{
  struct _GmOptions *options;
  options=gm_world_options(properties->world);
  const char *logo;
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$1;
  return_value_gm_world_properties_dialog_widget$1=gm_world_properties_dialog_widget(properties, "entry_name");
  unsigned long int return_value_gtk_entry_get_type$2;
  return_value_gtk_entry_get_type$2=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$1, return_value_gtk_entry_get_type$2);
  const char *return_value_gm_options_get$4;
  return_value_gm_options_get$4=gm_options_get(options, "name");
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$3, return_value_gm_options_get$4);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$5;
  return_value_gm_world_properties_dialog_widget$5=gm_world_properties_dialog_widget(properties, "entry_host");
  unsigned long int return_value_gtk_entry_get_type$6;
  return_value_gtk_entry_get_type$6=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$5, return_value_gtk_entry_get_type$6);
  const char *return_value_gm_options_get$8;
  return_value_gm_options_get$8=gm_options_get(options, "host");
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$7, return_value_gm_options_get$8);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$9;
  return_value_gm_world_properties_dialog_widget$9=gm_world_properties_dialog_widget(properties, "spin_button_port");
  unsigned long int return_value_gtk_spin_button_get_type$10;
  return_value_gtk_spin_button_get_type$10=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$9, return_value_gtk_spin_button_get_type$10);
  signed int return_value_gm_options_get_int$12;
  return_value_gm_options_get_int$12=gm_options_get_int(options, "port");
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$11, (double)return_value_gm_options_get_int$12);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$13;
  return_value_gm_world_properties_dialog_widget$13=gm_world_properties_dialog_widget(properties, "entry_player_name");
  unsigned long int return_value_gtk_entry_get_type$14;
  return_value_gtk_entry_get_type$14=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$13, return_value_gtk_entry_get_type$14);
  const char *return_value_gm_options_get$16;
  return_value_gm_options_get$16=gm_options_get(options, "player_name");
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$15, return_value_gm_options_get$16);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$17;
  return_value_gm_world_properties_dialog_widget$17=gm_world_properties_dialog_widget(properties, "entry_password");
  unsigned long int return_value_gtk_entry_get_type$18;
  return_value_gtk_entry_get_type$18=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$17, return_value_gtk_entry_get_type$18);
  const char *return_value_gm_options_get$20;
  return_value_gm_options_get$20=gm_options_get(options, "password");
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$19, return_value_gm_options_get$20);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$21;
  return_value_gm_world_properties_dialog_widget$21=gm_world_properties_dialog_widget(properties, "entry_password");
  unsigned long int return_value_gtk_entry_get_type$22;
  return_value_gtk_entry_get_type$22=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$21, return_value_gtk_entry_get_type$22);
  gtk_entry_set_invisible_char((struct _GtkEntry *)return_value_g_type_check_instance_cast$23, (unsigned int)0x25CF);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$24;
  return_value_gm_world_properties_dialog_widget$24=gm_world_properties_dialog_widget(properties, "check_button_auto_reconnect");
  unsigned long int return_value_gtk_toggle_button_get_type$25;
  return_value_gtk_toggle_button_get_type$25=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$24, return_value_gtk_toggle_button_get_type$25);
  signed int return_value_gm_options_get_int$27;
  return_value_gm_options_get_int$27=gm_options_get_int(options, "reconnect");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$26, return_value_gm_options_get_int$27);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$28;
  return_value_gm_world_properties_dialog_widget$28=gm_world_properties_dialog_widget(properties, "check_button_auto_load");
  unsigned long int return_value_gtk_toggle_button_get_type$29;
  return_value_gtk_toggle_button_get_type$29=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$28, return_value_gtk_toggle_button_get_type$29);
  signed int return_value_gm_options_get_int$31;
  return_value_gm_options_get_int$31=gm_options_get_int(options, "autoload");
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$30, return_value_gm_options_get_int$31);
  gm_world_properties_dialog_populate_charsets(properties);
  gm_world_properties_dialog_populate_tree_view_triggers(properties);
  gm_world_properties_dialog_init_logging(properties);
  glade_xml_signal_connect_data(properties->xml, "on_button_add_trigger_clicked", (void (*)(void))on_button_add_trigger_clicked, (void *)properties);
  glade_xml_signal_connect_data(properties->xml, "on_button_edit_trigger_clicked", (void (*)(void))on_button_edit_trigger_clicked, (void *)properties);
  glade_xml_signal_connect_data(properties->xml, "on_button_delete_trigger_clicked", (void (*)(void))on_button_delete_trigger_clicked, (void *)properties);
  glade_xml_signal_connect_data(properties->xml, "on_tree_view_triggers_row_activated", (void (*)(void))on_tree_view_triggers_row_activated, (void *)properties);
  logo=gm_options_get(options, "logo");
  if(!(logo == ((const char *)NULL)))
  {
    unsigned long int return_value_gtk_window_get_type$32;
    return_value_gtk_window_get_type$32=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
    return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$32);
    struct _GdkPixbuf *return_value_gm_pixbuf_get$34;
    return_value_gm_pixbuf_get$34=gm_pixbuf_get(logo);
    gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$33, return_value_gm_pixbuf_get$34);
  }

  else
  {
    unsigned long int return_value_gtk_window_get_type$35;
    return_value_gtk_window_get_type$35=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
    return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$35);
    struct _GdkPixbuf *return_value_gm_pixbuf_get$37;
    return_value_gm_pixbuf_get$37=gm_pixbuf_get("world.svg");
    gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$36, return_value_gm_pixbuf_get$37);
  }
}

// gm_world_properties_dialog_populate_charsets
// file dialogs/gm-world-properties-dialog.c line 133
void gm_world_properties_dialog_populate_charsets(struct _GmWorldPropertiesDialog *properties)
{
  signed int i;
  const char *gm_world_properties_dialog_populate_charsets$$1$$select;
  struct _GmOptions *return_value_gm_world_options$1;
  return_value_gm_world_options$1=gm_world_options(properties->world);
  gm_world_properties_dialog_populate_charsets$$1$$select=gm_options_get(return_value_gm_world_options$1, "charset");
  char text[255l];
  struct _GtkListStore *store;
  struct _GtkComboBoxEntry *combo;
  unsigned long int return_value_gtk_combo_box_entry_get_type$2;
  return_value_gtk_combo_box_entry_get_type$2=gtk_combo_box_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)properties->combo_box_charset, return_value_gtk_combo_box_entry_get_type$2);
  combo = (struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$3;
  store=gtk_list_store_new(1, (unsigned long int)(16 << 2));
  unsigned long int return_value_gtk_combo_box_get_type$4;
  return_value_gtk_combo_box_get_type$4=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_combo_box_get_type$4);
  unsigned long int return_value_gtk_tree_model_get_type$6;
  return_value_gtk_tree_model_get_type$6=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$6);
  gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$5, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$7);
  gtk_combo_box_entry_set_text_column(combo, 0);
  i = 0;
  for( ; !(i >= 59); i = i + 1)
  {
    char *return_value_gettext$8;
    return_value_gettext$8=gettext(encodings[(signed long int)i].name);
    sprintf(text, "%s - %s", encodings[(signed long int)i].charset, return_value_gettext$8);
    unsigned long int return_value_gtk_combo_box_get_type$9;
    return_value_gtk_combo_box_get_type$9=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_combo_box_get_type$9);
    gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$10, text);
    signed int return_value_strcasecmp$15;
    return_value_strcasecmp$15=strcasecmp(encodings[(signed long int)i].charset, gm_world_properties_dialog_populate_charsets$$1$$select);
    if(return_value_strcasecmp$15 == 0)
    {
      unsigned long int return_value_gtk_bin_get_type$11;
      return_value_gtk_bin_get_type$11=gtk_bin_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_bin_get_type$11);
      unsigned long int return_value_gtk_entry_get_type$13;
      return_value_gtk_entry_get_type$13=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$12)->child, return_value_gtk_entry_get_type$13);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$14, text);
    }

  }
  g_object_unref((void *)store);
}

// gm_world_properties_dialog_populate_tree_view_triggers
// file dialogs/gm-world-properties-dialog.c line 221
void gm_world_properties_dialog_populate_tree_view_triggers(struct _GmWorldPropertiesDialog *properties)
{
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->tree_view_triggers, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GtkListStore *store;
  unsigned long int return_value_gdk_pixbuf_get_type$3;
  return_value_gdk_pixbuf_get_type$3=gdk_pixbuf_get_type();
  store=gtk_list_store_new(3, return_value_gdk_pixbuf_get_type$3, (unsigned long int)(16 << 2), (unsigned long int)(17 << 2));
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  const struct _GList *item;
  struct _GmTrigger *t;
  unsigned long int return_value_gtk_tree_view_get_type$4;
  return_value_gtk_tree_view_get_type$4=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_tree_view_get_type$4);
  unsigned long int return_value_gtk_tree_model_get_type$6;
  return_value_gtk_tree_model_get_type$6=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$6);
  gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$5, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$7);
  renderer=gtk_cell_renderer_pixbuf_new();
  column=gtk_tree_view_column_new_with_attributes((const char *)(void *)0, renderer, (const void *)"pixbuf", 0, (void *)0);
  gtk_tree_view_column_set_min_width(column, 40);
  gtk_tree_view_append_column(tree_view, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes((const char *)(void *)0, renderer, (const void *)"markup", 1, (void *)0);
  gtk_tree_view_append_column(tree_view, column);
  struct _GmTriggers *return_value_gm_world_triggers$8;
  return_value_gm_world_triggers$8=gm_world_triggers(properties->world);
  item=gm_triggers_list(return_value_gm_world_triggers$8);
  for( ; !(item == ((const struct _GList *)NULL)); item = item->next)
  {
    t=gm_trigger_dup((struct _GmTrigger *)item->data);
    gm_world_properties_dialog_add_trigger(properties, t);
  }
  unsigned long int return_value_gtk_tree_model_get_type$11;
  return_value_gtk_tree_model_get_type$11=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$11);
  signed int return_value_gtk_tree_model_iter_n_children$13;
  return_value_gtk_tree_model_iter_n_children$13=gtk_tree_model_iter_n_children((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$12, (struct _GtkTreeIter *)(void *)0);
  if(return_value_gtk_tree_model_iter_n_children$13 == 0)
  {
    struct _GtkWidget *return_value_gm_world_properties_dialog_widget$9;
    return_value_gm_world_properties_dialog_widget$9=gm_world_properties_dialog_widget(properties, "button_edit_trigger");
    gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$9, 0);
    struct _GtkWidget *return_value_gm_world_properties_dialog_widget$10;
    return_value_gm_world_properties_dialog_widget$10=gm_world_properties_dialog_widget(properties, "button_delete_trigger");
    gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$10, 0);
  }

  g_object_unref((void *)store);
}

// gm_world_properties_dialog_remove_trigger
// file dialogs/gm-world-properties-dialog.c line 158
void gm_world_properties_dialog_remove_trigger(struct _GmWorldPropertiesDialog *properties, struct _GtkTreeIter *iter)
{
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->tree_view_triggers, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GtkListStore *store;
  struct _GtkTreeModel *return_value_gtk_tree_view_get_model$3;
  return_value_gtk_tree_view_get_model$3=gtk_tree_view_get_model(tree_view);
  unsigned long int return_value_gtk_list_store_get_type$4;
  return_value_gtk_list_store_get_type$4=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_get_model$3, return_value_gtk_list_store_get_type$4);
  store = (struct _GtkListStore *)return_value_g_type_check_instance_cast$5;
  gtk_list_store_remove(store, iter);
  unsigned long int return_value_gtk_tree_model_get_type$8;
  return_value_gtk_tree_model_get_type$8=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$8);
  signed int return_value_gtk_tree_model_iter_n_children$10;
  return_value_gtk_tree_model_iter_n_children$10=gtk_tree_model_iter_n_children((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$9, (struct _GtkTreeIter *)(void *)0);
  if(return_value_gtk_tree_model_iter_n_children$10 == 0)
  {
    struct _GtkWidget *return_value_gm_world_properties_dialog_widget$6;
    return_value_gm_world_properties_dialog_widget$6=gm_world_properties_dialog_widget(properties, "button_edit_trigger");
    gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$6, 0);
    struct _GtkWidget *return_value_gm_world_properties_dialog_widget$7;
    return_value_gm_world_properties_dialog_widget$7=gm_world_properties_dialog_widget(properties, "button_delete_trigger");
    gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$7, 0);
  }

}

// gm_world_properties_dialog_run
// file ./dialogs/gm-world-properties-dialog.h line 12
void gm_world_properties_dialog_run(struct _GmWorld *world)
{
  gm_world_properties_dialog_run_priv(world, 0);
}

// gm_world_properties_dialog_run_dialog
// file dialogs/gm-world-properties-dialog.c line 652
void gm_world_properties_dialog_run_dialog(struct _GmWorldPropertiesDialog *properties)
{
  g_signal_connect_data((void *)properties->dialog, "response", (void (*)(void))on_gm_world_properties_dialog_response, (void *)properties, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_widget_get_type$1);
  gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
}

// gm_world_properties_dialog_run_new
// file ./dialogs/gm-world-properties-dialog.h line 13
void gm_world_properties_dialog_run_new(struct _GmWorld *world)
{
  if(world == ((struct _GmWorld *)NULL))
    world=gm_world_new((char *)(void *)0);

  gm_world_properties_dialog_run_priv(world, (signed int)!(0 != 0));
}

// gm_world_properties_dialog_run_priv
// file dialogs/gm-world-properties-dialog.c line 376
void gm_world_properties_dialog_run_priv(struct _GmWorld *world, signed int is_new)
{
  struct _GmWorldPropertiesDialog *properties;
  properties=gm_world_properties_dialog_find(world);
  char *title;
  struct _GladeXML *xml;
  if(!(properties == ((struct _GmWorldPropertiesDialog *)NULL)))
  {
    gtk_widget_show(properties->dialog);
    unsigned long int return_value_gtk_window_get_type$1;
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$1);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
    goto __CPROVER_DUMP_L5;
  }

  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-world-properties.glade", "gm_world_properties_dialog", (const char *)(void *)0);
  if(xml == ((struct _GladeXML *)NULL))
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-world-properties.glade");

  else
  {
    void *return_value_g_malloc0_n$3;
    return_value_g_malloc0_n$3=g_malloc0_n((unsigned long int)1, sizeof(struct _GmWorldPropertiesDialog) /*56ul*/ );
    properties = (struct _GmWorldPropertiesDialog *)return_value_g_malloc0_n$3;
    gm_world_properties_dialog_open=g_list_append(gm_world_properties_dialog_open, (void *)properties);
    properties->is_new = is_new;
    properties->world = world;
    properties->xml = xml;
    char *return_value_gettext$4;
    return_value_gettext$4=gettext("World properties - ");
    const char *return_value_gm_world_name$5;
    return_value_gm_world_name$5=gm_world_name(world);
    title=g_strconcat(return_value_gettext$4, return_value_gm_world_name$5, (void *)0);
    properties->dialog=gm_world_properties_dialog_widget(properties, "gm_world_properties_dialog");
    properties->tree_view_triggers=gm_world_properties_dialog_widget(properties, "tree_view_triggers");
    properties->combo_box_charset=gm_world_properties_dialog_widget(properties, "combo_box_charset");
    unsigned long int return_value_gtk_window_get_type$6;
    return_value_gtk_window_get_type$6=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$6);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$7, title);
    g_free((void *)title);
    gm_world_properties_dialog_initialize(properties);
    if(properties->is_new == 0)
    {
      struct _GmApp *return_value_gm_app_instance$8;
      return_value_gm_app_instance$8=gm_app_instance();
      properties->handler_id=g_signal_connect_data((void *)return_value_gm_app_instance$8, "world_removed", (void (*)(void))on_gm_world_properties_dialog_app_world_removed, (void *)properties, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    }

    else
      properties->handler_id = (unsigned long int)0;
    gm_world_properties_dialog_run_dialog(properties);
  }

__CPROVER_DUMP_L5:
  ;
}

// gm_world_properties_dialog_run_triggers
// file ./dialogs/gm-world-properties-dialog.h line 14
void gm_world_properties_dialog_run_triggers(struct _GmWorld *world)
{
  struct _GmWorldPropertiesDialog *dialog;
  struct _GtkWidget *widget;
  struct _GtkNotebook *notebook;
  gm_world_properties_dialog_run_priv(world, 0);
  dialog=gm_world_properties_dialog_find(world);
  widget=gm_world_properties_dialog_widget(dialog, "hbox_triggers");
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$1;
  return_value_gm_world_properties_dialog_widget$1=gm_world_properties_dialog_widget(dialog, "notebook_main");
  unsigned long int return_value_gtk_notebook_get_type$2;
  return_value_gtk_notebook_get_type$2=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_properties_dialog_widget$1, return_value_gtk_notebook_get_type$2);
  notebook = (struct _GtkNotebook *)return_value_g_type_check_instance_cast$3;
  signed int return_value_gtk_notebook_page_num$4;
  return_value_gtk_notebook_page_num$4=gtk_notebook_page_num(notebook, widget);
  gtk_notebook_set_current_page(notebook, return_value_gtk_notebook_page_num$4);
}

// gm_world_properties_dialog_selected_trigger
// file dialogs/gm-world-properties-dialog.c line 711
struct _GmTrigger * gm_world_properties_dialog_selected_trigger(struct _GmWorldPropertiesDialog *properties, struct _GtkTreeIter *iter)
{
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->tree_view_triggers, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GtkTreeModel *model;
  model=gtk_tree_view_get_model(tree_view);
  struct _GmTrigger *result = (struct _GmTrigger *)(void *)0;
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$3;
  return_value_gtk_tree_view_get_selection$3=gtk_tree_view_get_selection(tree_view);
  signed int return_value_gtk_tree_selection_get_selected$4;
  return_value_gtk_tree_selection_get_selected$4=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection$3, &model, iter);
  if(!(return_value_gtk_tree_selection_get_selected$4 == 0))
    gtk_tree_model_get(model, iter, 2, &result, -1);

  return result;
}

// gm_world_properties_dialog_set_logging
// file dialogs/gm-world-properties-dialog.c line 516
void gm_world_properties_dialog_set_logging(struct _GmWorldPropertiesDialog *properties)
{
  struct _GmOptions *options;
  options=gm_world_options(properties->world);
  const char **entry;
  char *name;
  struct _GtkWidget *check;
  check=gm_world_properties_dialog_widget(properties, "check_button_logging_override");
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$1);
  signed int return_value_gtk_toggle_button_get_active$3;
  return_value_gtk_toggle_button_get_active$3=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  gm_options_set_int(options, "logging_override", return_value_gtk_toggle_button_get_active$3);
  entry = logging_button_names;
  for( ; !(*entry == ((const char *)NULL)); entry = entry + 1l)
  {
    name=g_strconcat("check_button_", *entry, (void *)0);
    check=gm_world_properties_dialog_widget(properties, name);
    g_free((void *)name);
    unsigned long int return_value_gtk_toggle_button_get_type$4;
    return_value_gtk_toggle_button_get_type$4=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)check, return_value_gtk_toggle_button_get_type$4);
    signed int return_value_gtk_toggle_button_get_active$6;
    return_value_gtk_toggle_button_get_active$6=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$5);
    gm_options_set_int(options, *entry, return_value_gtk_toggle_button_get_active$6);
  }
}

// gm_world_properties_dialog_set_triggers
// file dialogs/gm-world-properties-dialog.c line 498
void gm_world_properties_dialog_set_triggers(struct _GmWorldPropertiesDialog *properties)
{
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->tree_view_triggers, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GtkTreeModel *store;
  store=gtk_tree_view_get_model(tree_view);
  struct _GtkTreeIter iter;
  struct _GmTrigger *t;
  struct _GmTriggers *triggers;
  triggers=gm_world_triggers(properties->world);
  gm_triggers_clear(triggers);
  signed int return_value_gtk_tree_model_get_iter_first$4;
  return_value_gtk_tree_model_get_iter_first$4=gtk_tree_model_get_iter_first(store, &iter);
  signed int return_value_gtk_tree_model_iter_next$3;
  if(!(return_value_gtk_tree_model_get_iter_first$4 == 0))
    do
    {
      gtk_tree_model_get(store, &iter, 2, &t, -1);
      gm_triggers_add(triggers, t);
      return_value_gtk_tree_model_iter_next$3=gtk_tree_model_iter_next(store, &iter);
    }
    while(!(return_value_gtk_tree_model_iter_next$3 == 0));

}

// gm_world_properties_dialog_update_trigger
// file dialogs/gm-world-properties-dialog.c line 174
void gm_world_properties_dialog_update_trigger(struct _GmWorldPropertiesDialog *properties, struct _GtkTreeIter *iter, struct _GmTrigger *t)
{
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->tree_view_triggers, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GtkListStore *store;
  struct _GtkTreeModel *return_value_gtk_tree_view_get_model$3;
  return_value_gtk_tree_view_get_model$3=gtk_tree_view_get_model(tree_view);
  unsigned long int return_value_gtk_list_store_get_type$4;
  return_value_gtk_list_store_get_type$4=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_get_model$3, return_value_gtk_list_store_get_type$4);
  store = (struct _GtkListStore *)return_value_g_type_check_instance_cast$5;
  char *text;
  char *return_value_gettext$6;
  return_value_gettext$6=gettext("<b>%s</b>\nConditions: %d\nActions: %d");
  unsigned int return_value_g_list_length$7;
  return_value_g_list_length$7=g_list_length(t->conditions);
  unsigned int return_value_g_list_length$8;
  return_value_g_list_length$8=g_list_length(t->actions);
  text=g_strdup_printf(return_value_gettext$6, t->name, return_value_g_list_length$7, return_value_g_list_length$8);
  gtk_list_store_set(store, iter, 1, text, 2, t, -1);
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$9;
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$10;
  switch((signed int)t->event)
  {
    case TT_OUTPUT:
    {
      return_value_gm_pixbuf_get_at_size$9=gm_pixbuf_get_at_size("world.svg", 32, 32);
      gtk_list_store_set(store, iter, 0, return_value_gm_pixbuf_get_at_size$9, -1);
      break;
    }
    case TT_USERS:
    {
      return_value_gm_pixbuf_get_at_size$10=gm_pixbuf_get_at_size("ice-userlist/programmer.svg", 32, 32);
      gtk_list_store_set(store, iter, 0, return_value_gm_pixbuf_get_at_size$10, -1);
      break;
    }
    default:
      ;
  }
  g_free((void *)text);
}

// gm_world_properties_dialog_widget
// file dialogs/gm-world-properties-dialog.c line 127
struct _GtkWidget * gm_world_properties_dialog_widget(struct _GmWorldPropertiesDialog *properties, char *name)
{
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(properties->xml, name);
  return return_value_glade_xml_get_widget$1;
}

// gm_world_reconnect
// file gm-world.c line 483
static signed int gm_world_reconnect(struct _GmWorld *world)
{
  world->priv->reconnect_id = (unsigned int)0;
  const char *host;
  const char *port;
  host=gm_net_current_host(world->priv->net);
  port=gm_net_current_port(world->priv->net);
  if(host == ((const char *)NULL))
    host=gm_options_get(world->priv->options, "host");

  if(port == ((const char *)NULL))
    port=gm_options_get(world->priv->options, "port");

  gm_world_connect_to(world, host, port);
  return 0;
}

// gm_world_remove_editor
// file gm-world.c line 1146
void gm_world_remove_editor(struct _GmWorld *world, struct _GmEditor *editor)
{
  do
  {
    struct _GSList *return_value_g_slist_find$1;
    return_value_g_slist_find$1=g_slist_find(world->priv->editors, (const void *)editor);
    if(return_value_g_slist_find$1 == ((struct _GSList *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_world_remove_editor", "g_slist_find(world->priv->editors, editor) != NULL");
      goto __CPROVER_DUMP_L3;
    }

  }
  while((_Bool)0);
  world->priv->editors=g_slist_remove(world->priv->editors, (const void *)editor);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)editor, (unsigned long int)(20 << 2));
  g_signal_emit((void *)world, world_signals[(signed long int)7], (unsigned int)0, (struct _GObject *)return_value_g_type_check_instance_cast$2);
  g_object_unref((void *)editor);

__CPROVER_DUMP_L3:
  ;
}

// gm_world_save_input_history
// file gm-world.c line 416
static void gm_world_save_input_history(struct _GmWorld *world)
{
  struct _IO_FILE *f;
  char *filename;
  struct _GList *elem;
  if(!(world->priv->path == ((char *)NULL)))
  {
    filename=g_strconcat(world->priv->path, (const void *)"/", (const void *)"history", (void *)0);
    f=fopen(filename, "w");
    if(!(f == ((struct _IO_FILE *)NULL)))
    {
      gm_debug_msg(DEBUG_DEFAULT, "GmWorld.SaveInputHistory: saving input history to %s", filename);
      elem = world->priv->history;
      for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
        fprintf(f, "%s\n", (char *)elem->data);
      fclose(f);
      chmod(filename, (unsigned int)0660);
    }

    else
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      gm_debug_msg(DEBUG_DEFAULT, "GmWorld.SaveInputHistory: couldn't open history file (%s) for saving: %s", filename, return_value_strerror$2);
    }
    g_free((void *)filename);
  }

}

// gm_world_sendln
// file ./gm-world.h line 135
void gm_world_sendln(struct _GmWorld *world, const char *text)
{
  world->priv->last_command=time(((signed long int *)NULL));
  gm_world_sendln_log(world, text, (enum _GmLogType)LOG_OUT);
}

// gm_world_sendln_log
// file ./gm-world.h line 134
void gm_world_sendln_log(struct _GmWorld *world, const char *text, enum _GmLogType logtype)
{
  char *normal;
  const char *return_value_gm_options_get$1;
  return_value_gm_options_get$1=gm_options_get(world->priv->options, "charset");
  normal=gm_from_utf8_with_fallback(text, (signed long int)-1, return_value_gm_options_get$1, "?");
  if(normal == ((char *)NULL))
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmWorld.SendlnLog: conversion failed!");
    normal=g_strdup(text);
  }

  _Bool tmp_if_expr$3;
  signed int return_value_gm_mcp_session_initialized$2;
  if(!((signed int)logtype == LOG_NONE))
  {
    if(!((signed int)logtype == LOG_OUT))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_gm_mcp_session_initialized$2=gm_mcp_session_initialized(world->priv->mcp);
      tmp_if_expr$3 = return_value_gm_mcp_session_initialized$2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      gm_world_log(world, logtype, text);

  }

  gm_net_send_line(world->priv->net, normal);
  g_free((void *)normal);
  if(!(world->priv->flush_history_id == 0u))
    g_source_remove(world->priv->flush_history_id);

  world->priv->flush_history_id=g_timeout_add((unsigned int)(10 * 60000), flush_history_cb, (void *)world);
}

// gm_world_set_active
// file ./gm-world.h line 118
void gm_world_set_active(struct _GmWorld *world, signed int active)
{
  world->priv->active = active;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)world, (unsigned long int)(20 << 2));
  g_object_notify((struct _GObject *)return_value_g_type_check_instance_cast$1, "active");
  if(!(active == 0))
    gm_world_set_activity(world, 0);

}

// gm_world_set_activity
// file gm-world.c line 1220
void gm_world_set_activity(struct _GmWorld *world, signed int activity)
{
  world->priv->activity = (unsigned int)activity;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)world, (unsigned long int)(20 << 2));
  g_object_notify((struct _GObject *)return_value_g_type_check_instance_cast$1, "activity");
}

// gm_world_set_property
// file gm-world.c line 168
static void gm_world_set_property(struct _GObject *object, unsigned int prop_id, const struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _GmWorld *world;
  unsigned long int return_value_gm_world_get_type$1;
  return_value_gm_world_get_type$1=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_get_type$1);
  world = (struct _GmWorld *)return_value_g_type_check_instance_cast$2;
  signed int return_value_g_value_get_boolean$3;
  signed int return_value_g_value_get_int$4;
  switch(prop_id)
  {
    case (unsigned int)3:
    {
      return_value_g_value_get_boolean$3=g_value_get_boolean(value);
      gm_world_set_active(world, return_value_g_value_get_boolean$3);
      break;
    }
    case (unsigned int)4:
    {
      return_value_g_value_get_int$4=g_value_get_int(value);
      gm_world_set_activity(world, return_value_g_value_get_int$4);
    }
  }
}

// gm_world_state
// file ./gm-world.h line 123
enum _GmNetState gm_world_state(struct _GmWorld *world)
{
  enum _GmNetState return_value_gm_net_state$1;
  return_value_gm_net_state$1=gm_net_state(world->priv->net);
  return return_value_gm_net_state$1;
}

// gm_world_status
// file ./gm-world.h line 137
void gm_world_status(struct _GmWorld *world, const char *text)
{
  char *line;
  line=g_strconcat("\033[1;33m# ", text, (const void *)"\033[0m", (void *)0);
  gm_world_writeln(world, line);
  gm_world_log(world, (enum _GmLogType)LOG_STATUS, line);
  g_free((void *)line);
}

// gm_world_tab_class_init
// file widgets/gm-world-tab.c line 63
static void gm_world_tab_class_init(struct _GmWorldTabClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_world_tab_finalize;
  gm_world_tab_signals[(signed long int)0]=g_signal_new("close", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)824ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__VOID, (unsigned long int)(1 << 2), (unsigned int)0);
  g_type_class_add_private((void *)object_class, sizeof(struct _GmWorldTabPrivate) /*40ul*/ );
}

// gm_world_tab_class_intern_init
// file widgets/gm-world-tab.c line 35
static void gm_world_tab_class_intern_init(void *klass)
{
  gm_world_tab_parent_class=g_type_class_peek_parent(klass);
  if(!(GmWorldTab_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmWorldTab_private_offset);

  gm_world_tab_class_init((struct _GmWorldTabClass *)klass);
}

// gm_world_tab_create_interface
// file widgets/gm-world-tab.c line 82
static void gm_world_tab_create_interface(struct _GmWorldTab *obj)
{
  struct _GtkWidget *image;
  struct _GtkWidget *label;
  struct _GtkWidget *button;
  struct _GtkWidget *image_button;
  struct _GtkSettings *settings;
  signed int w;
  signed int h;
  struct _GtkRcStyle *rcstyle;
  image=gtk_image_new();
  label=gtk_label_new("");
  button=gtk_button_new();
  image_button=gtk_image_new_from_stock("gtk-close", (enum anonymous$21)GTK_ICON_SIZE_MENU);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_widget_get_type$1);
  settings=gtk_widget_get_settings((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  gtk_icon_size_lookup_for_settings(settings, (enum anonymous$21)GTK_ICON_SIZE_MENU, &w, &h);
  gtk_widget_set_size_request(button, w + 2, h + 2);
  unsigned long int return_value_gtk_button_get_type$3;
  return_value_gtk_button_get_type$3=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_button_get_type$3);
  gtk_button_set_relief((struct _GtkButton *)return_value_g_type_check_instance_cast$4, (enum anonymous$94)GTK_RELIEF_NONE);
  unsigned long int return_value_gtk_button_get_type$5;
  return_value_gtk_button_get_type$5=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_button_get_type$5);
  gtk_button_set_focus_on_click((struct _GtkButton *)return_value_g_type_check_instance_cast$6, 0);
  rcstyle=gtk_rc_style_new();
  rcstyle->ythickness = 0;
  rcstyle->xthickness = rcstyle->ythickness;
  gtk_widget_modify_style(button, rcstyle);
  gtk_rc_style_unref(rcstyle);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_container_get_type$7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, image_button);
  unsigned long int return_value_gtk_box_get_type$9;
  return_value_gtk_box_get_type$9=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$10, image, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$11;
  return_value_gtk_box_get_type$11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$12, label, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$13;
  return_value_gtk_box_get_type$13=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$13);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$14, button, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$15;
  return_value_gtk_box_get_type$15=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_box_get_type$15);
  gtk_box_set_spacing((struct _GtkBox *)return_value_g_type_check_instance_cast$16, 3);
  unsigned long int return_value_gtk_image_get_type$17;
  return_value_gtk_image_get_type$17=gtk_image_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)image, return_value_gtk_image_get_type$17);
  obj->priv->image = (struct _GtkImage *)return_value_g_type_check_instance_cast$18;
  unsigned long int return_value_gtk_label_get_type$19;
  return_value_gtk_label_get_type$19=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)label, return_value_gtk_label_get_type$19);
  obj->priv->label = (struct _GtkLabel *)return_value_g_type_check_instance_cast$20;
  unsigned long int return_value_gtk_button_get_type$21;
  return_value_gtk_button_get_type$21=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_button_get_type$21);
  obj->priv->button = (struct _GtkButton *)return_value_g_type_check_instance_cast$22;
}

// gm_world_tab_finalize
// file widgets/gm-world-tab.c line 46
static void gm_world_tab_finalize(struct _GObject *object)
{
  struct _GmWorldTab *obj;
  unsigned long int return_value_gm_world_tab_get_type$1;
  return_value_gm_world_tab_get_type$1=gm_world_tab_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_tab_get_type$1);
  obj = (struct _GmWorldTab *)return_value_g_type_check_instance_cast$2;
  gm_world_tab_stop_recolor(obj);
  if(!(obj->priv->world == ((struct _GmWorld *)NULL)))
  {
    g_signal_handlers_disconnect_matched((void *)obj->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_tab_world_activity_changed, (void *)obj);
    g_signal_handlers_disconnect_matched((void *)obj->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_tab_world_name_changed, (void *)obj);
    g_object_unref((void *)obj->priv->world);
  }

  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_world_tab_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_world_tab_get_type
// file widgets/gm-world-tab.c line 35
unsigned long int gm_world_tab_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_hbox_get_type$1;
    return_value_gtk_hbox_get_type$1=gtk_hbox_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmWorldTab");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_hbox_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmWorldTabClass) /*832ul*/ , (void (*)(void *, void *))gm_world_tab_class_intern_init, (unsigned int)sizeof(struct _GmWorldTab) /*136ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_world_tab_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_world_tab_init
// file widgets/gm-world-tab.c line 121
static void gm_world_tab_init(struct _GmWorldTab *obj)
{
  unsigned long int return_value_gm_world_tab_get_type$1;
  return_value_gm_world_tab_get_type$1=gm_world_tab_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_world_tab_get_type$1);
  obj->priv = (struct _GmWorldTabPrivate *)return_value_g_type_instance_get_private$2;
  obj->priv->source_id = (unsigned int)0;
  obj->priv->world = (struct _GmWorld *)(void *)0;
  gm_world_tab_create_interface(obj);
  g_signal_connect_data((void *)obj->priv->button, "clicked", (void (*)(void))on_gm_world_tab_button_clicked, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_widget_get_type$3);
  gtk_widget_show_all((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_widget_get_type$5);
  gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$6);
}

// gm_world_tab_new
// file widgets/gm-world-tab.h line 47
struct _GmWorldTab * gm_world_tab_new(struct _GmWorld *world)
{
  struct _GmWorldTab *obj;
  unsigned long int return_value_gm_world_tab_get_type$1;
  return_value_gm_world_tab_get_type$1=gm_world_tab_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_world_tab_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_world_tab_get_type$3;
  return_value_gm_world_tab_get_type$3=gm_world_tab_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_world_tab_get_type$3);
  obj = (struct _GmWorldTab *)return_value_g_type_check_instance_cast$4;
  void *return_value_g_object_ref$5;
  return_value_g_object_ref$5=g_object_ref((void *)world);
  obj->priv->world = (struct _GmWorld *)return_value_g_object_ref$5;
  g_signal_connect_data((void *)world, "notify::activity", (void (*)(void))on_gm_world_tab_world_activity_changed, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "notify::name", (void (*)(void))on_gm_world_tab_world_name_changed, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  gm_world_tab_update(obj);
  return obj;
}

// gm_world_tab_stop_recolor
// file widgets/gm-world-tab.c line 38
static void gm_world_tab_stop_recolor(struct _GmWorldTab *tab)
{
  if(!(tab->priv->source_id == 0u))
  {
    g_source_remove(tab->priv->source_id);
    tab->priv->source_id = (unsigned int)0;
  }

}

// gm_world_tab_update
// file widgets/gm-world-tab.c line 152
static void gm_world_tab_update(struct _GmWorldTab *tab)
{
  signed int activity;
  activity=gm_world_activity(tab->priv->world);
  char *text;
  gm_world_tab_stop_recolor(tab);
  if(!(activity == 0))
  {
    const char *return_value_gm_world_name$1;
    return_value_gm_world_name$1=gm_world_name(tab->priv->world);
    text=g_strdup_printf("<span color=\"#%02x0000\">%s [%i]</span>", (signed int)((-((double)1 / ((double)activity * 0.5 + (double)1)) + (double)1) * (double)255), return_value_gm_world_name$1, activity);
    struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$2;
    return_value_gm_pixbuf_get_at_size$2=gm_pixbuf_get_at_size("world_activity.svg", 16, 16);
    gtk_image_set_from_pixbuf(tab->priv->image, return_value_gm_pixbuf_get_at_size$2);
    tab->priv->source_id=g_idle_add((signed int (*)(void *))gm_world_tab_update_color, (void *)tab);
  }

  else
  {
    const char *return_value_gm_world_name$3;
    return_value_gm_world_name$3=gm_world_name(tab->priv->world);
    text=g_strdup(return_value_gm_world_name$3);
    struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$4;
    return_value_gm_pixbuf_get_at_size$4=gm_pixbuf_get_at_size("world.svg", 16, 16);
    gtk_image_set_from_pixbuf(tab->priv->image, return_value_gm_pixbuf_get_at_size$4);
  }
  gtk_label_set_markup(tab->priv->label, text);
  g_free((void *)text);
}

// gm_world_tab_update_color
// file widgets/gm-world-tab.c line 136
signed int gm_world_tab_update_color(struct _GmWorldTab *tab)
{
  char *text;
  signed int activity;
  activity=gm_world_activity(tab->priv->world);
  const char *return_value_gm_world_name$1;
  return_value_gm_world_name$1=gm_world_name(tab->priv->world);
  text=g_strdup_printf("<span color=\"#0000%02x\">%s [%i]</span>", (signed int)((-((double)1 / ((double)activity * 0.5 + (double)1)) + (double)1) * (double)255), return_value_gm_world_name$1, activity);
  gtk_label_set_markup(tab->priv->label, text);
  g_free((void *)text);
  tab->priv->source_id = (unsigned int)0;
  return 0;
}

// gm_world_text_view_blink_timeout
// file widgets/gm-world-text-view.c line 782
static signed int gm_world_text_view_blink_timeout(struct _GmWorldTextView *view)
{
  unsigned int blink_state = view->priv->blink_state;
  struct _GSList *blinker;
  struct _BlinkInfo *info;
  if(view->priv->blinkers == ((struct _GSList *)NULL))
  {
    view->priv->blink_state = (unsigned int)0;
    view->priv->blink_timeout_id = (unsigned int)0;
    return 0;
  }

  else
  {
    blinker = view->priv->blinkers;
    for( ; !(blinker == ((struct _GSList *)NULL)); blinker = blinker->next)
    {
      info = (struct _BlinkInfo *)blinker->data;
      if((blink_state == 0u || blink_state == 2u) && info->blink == 1u)
      {
        gm_world_text_view_blinker_set_visible(info, (signed int)(blink_state == (unsigned int)2));
        goto __CPROVER_DUMP_L5;
      }

      if(info->blink == 2u)
        gm_world_text_view_blinker_set_visible(info, (signed int)(blink_state == (unsigned int)1 || blink_state == (unsigned int)3));


    __CPROVER_DUMP_L5:
      ;
    }
    if(blink_state == 3u)
      view->priv->blink_state = (unsigned int)0;

    else
      view->priv->blink_state = blink_state + (unsigned int)1;
    return (signed int)!(0 != 0);
  }
}

// gm_world_text_view_blinker_iters
// file widgets/gm-world-text-view.c line 718
static void gm_world_text_view_blinker_iters(struct _BlinkInfo *info, struct _GtkTextIter *start, struct _GtkTextIter *end, struct _GtkTextTag **tag_blink)
{
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)info->view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextTag *tag;
  if(info->blink == 1u)
    tag = info->view->priv->tag_blink;

  else
    tag = info->view->priv->tag_blink_fast;
  gtk_text_buffer_get_iter_at_mark(buffer, start, info->begin);
  if(!(end == ((struct _GtkTextIter *)NULL)))
  {
    *end = *start;
    signed long int return_value_g_utf8_strlen$3;
    return_value_g_utf8_strlen$3=g_utf8_strlen(info->fill, (signed long int)-1);
    gtk_text_iter_forward_chars(end, (signed int)return_value_g_utf8_strlen$3);
  }

  if(!(tag_blink == ((struct _GtkTextTag **)NULL)))
    *tag_blink = tag;

}

// gm_world_text_view_blinker_set_visible
// file widgets/gm-world-text-view.c line 742
static void gm_world_text_view_blinker_set_visible(struct _BlinkInfo *info, signed int visible)
{
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)info->view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  struct _GtkTextIter s;
  struct _GtkTextIter e;
  struct _GtkTextTag *tag;
  gm_world_text_view_blinker_iters(info, &start, &end, &tag);
  gtk_text_buffer_delete(buffer, &start, &end);
  gm_world_text_view_blinker_iters(info, &start, (struct _GtkTextIter *)(void *)0, (struct _GtkTextTag **)(void *)0);
  if(!(visible == 0))
  {
    gtk_text_buffer_get_bounds(info->text, &s, &e);
    gtk_text_buffer_insert_range(buffer, &start, &s, &e);
  }

  else
    gtk_text_buffer_insert_with_tags(buffer, &start, info->fill, -1, tag, (void *)0);
}

// gm_world_text_view_blinker_timeout
// file widgets/gm-world-text-view.c line 762
static signed int gm_world_text_view_blinker_timeout(struct _BlinkInfo *info)
{
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)info->view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextTag *tag;
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  gm_world_text_view_blinker_set_visible(info, (signed int)!(0 != 0));
  gm_world_text_view_blinker_iters(info, &start, &end, &tag);
  gtk_text_buffer_remove_tag(buffer, tag, &start, &end);
  gtk_text_buffer_apply_tag_by_name(buffer, "blink-after", &start, &end);
  info->view->priv->blinkers=g_slist_remove(info->view->priv->blinkers, (const void *)info);
  blink_info_free(info);
  return 0;
}

// gm_world_text_view_button_press_event
// file widgets/gm-world-text-view.c line 250
static signed int gm_world_text_view_button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event)
{
  struct _GtkTextView *text_view;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_text_view_get_type$1);
  text_view = (struct _GtkTextView *)return_value_g_type_check_instance_cast$2;
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$3;
  return_value_gm_world_text_view_get_type$3=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_world_text_view_get_type$3);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$4;
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  struct _GtkTextBuffer *buffer;
  buffer=gtk_text_view_get_buffer(text_view);
  struct _GtkTextTag *tag;
  signed int x;
  signed int y;
  struct _GdkDrawable *return_value_gtk_text_view_get_window$9;
  if(event->button == 1u)
  {
    if((8u & event->state) == 0u)
    {
      if((1u & event->state) == 0u)
      {
        return_value_gtk_text_view_get_window$9=gtk_text_view_get_window(text_view, (enum anonymous$91)GTK_TEXT_WINDOW_TEXT);
        if(event->window == return_value_gtk_text_view_get_window$9)
        {
          gtk_text_view_window_to_buffer_coords(text_view, (enum anonymous$91)GTK_TEXT_WINDOW_TEXT, (signed int)event->x, (signed int)event->y, &x, &y);
          gtk_text_view_get_iter_at_location(text_view, &start, x, y);
          struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$5;
          return_value_gtk_text_buffer_get_tag_table$5=gtk_text_buffer_get_tag_table(buffer);
          tag=gtk_text_tag_table_lookup(return_value_gtk_text_buffer_get_tag_table$5, "url");
          signed int return_value_gtk_text_iter_has_tag$8;
          return_value_gtk_text_iter_has_tag$8=gtk_text_iter_has_tag(&start, tag);
          if(!(return_value_gtk_text_iter_has_tag$8 == 0))
          {
            end = start;
            signed int return_value_gtk_text_iter_begins_tag$6;
            return_value_gtk_text_iter_begins_tag$6=gtk_text_iter_begins_tag(&start, tag);
            if(return_value_gtk_text_iter_begins_tag$6 == 0)
              gtk_text_iter_backward_to_tag_toggle(&start, tag);

            signed int return_value_gtk_text_iter_ends_tag$7;
            return_value_gtk_text_iter_ends_tag$7=gtk_text_iter_ends_tag(&end, tag);
            if(return_value_gtk_text_iter_ends_tag$7 == 0)
              gtk_text_iter_forward_to_tag_toggle(&end, tag);

            view->priv->drag_url_text=gtk_text_buffer_get_text(buffer, &start, &end, 0);
            view->priv->drag_x = (unsigned int)event->x;
            view->priv->drag_y = (unsigned int)event->y;
            view->priv->drag_url = (signed int)!(0 != 0);
            return (signed int)!(0 != 0);
          }

        }

      }

    }

  }

  unsigned long int return_value_gtk_widget_get_type$12;
  return_value_gtk_widget_get_type$12=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$13;
  return_value_g_type_check_class_cast$13=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$12);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$13)->button_press_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventButton *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$10;
    return_value_gtk_widget_get_type$10=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$11;
    return_value_g_type_check_class_cast$11=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$10);
    signed int return_value;
    return_value=((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$11)->button_press_event(widget, event);
    return return_value;
  }

  return 0;
}

// gm_world_text_view_button_release_event
// file widgets/gm-world-text-view.c line 309
static signed int gm_world_text_view_button_release_event(struct _GtkWidget *widget, struct _GdkEventButton *event)
{
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_world_text_view_get_type$1);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$2;
  if(event->button == 1u)
  {
    if(!(view->priv->drag_url == 0))
    {
      gm_world_text_view_no_selection(view);
      view->priv->drag_url = 0;
      g_free((void *)view->priv->drag_url_text);
      view->priv->drag_url_text = (char *)(void *)0;
    }

  }

  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$5);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->button_release_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventButton *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$4;
    return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$3);
    signed int return_value;
    return_value=((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$4)->button_release_event(widget, event);
    return return_value;
  }

  return 0;
}

// gm_world_text_view_check_buffer_size
// file widgets/gm-world-text-view.c line 544
static void gm_world_text_view_check_buffer_size(struct _GmWorldTextView *view)
{
  struct _GtkTextBuffer *buf;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  signed int d;
  signed int return_value_gtk_text_buffer_get_line_count$3;
  return_value_gtk_text_buffer_get_line_count$3=gtk_text_buffer_get_line_count(buf);
  d = return_value_gtk_text_buffer_get_line_count$3 - view->priv->max_lines;
  if(d >= 1)
  {
    gtk_text_buffer_get_iter_at_line(buf, &start, 0);
    gtk_text_buffer_get_iter_at_line(buf, &end, d);
    gm_world_text_view_remove_blinkers(view, &start, &end);
    gtk_text_buffer_delete(buf, &start, &end);
  }

}

// gm_world_text_view_class_init
// file widgets/gm-world-text-view.c line 144
static void gm_world_text_view_class_init(struct _GmWorldTextViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GtkWidgetClass *widget_class;
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_widget_get_type$2);
  widget_class = (struct _GtkWidgetClass *)return_value_g_type_check_class_cast$3;
  struct _GtkTextViewClass *text_view_class;
  unsigned long int return_value_gtk_text_view_get_type$4;
  return_value_gtk_text_view_get_type$4=gtk_text_view_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$5;
  return_value_g_type_check_class_cast$5=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_text_view_get_type$4);
  text_view_class = (struct _GtkTextViewClass *)return_value_g_type_check_class_cast$5;
  void *return_value_g_type_class_peek_parent$6;
  return_value_g_type_class_peek_parent$6=g_type_class_peek_parent((void *)klass);
  unsigned long int return_value_gtk_text_view_get_type$7;
  return_value_gtk_text_view_get_type$7=gtk_text_view_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$8;
  return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)return_value_g_type_class_peek_parent$6, return_value_gtk_text_view_get_type$7);
  parent_class = (struct _GtkTextViewClass *)return_value_g_type_check_class_cast$8;
  text_view_class->populate_popup = gm_world_text_view_populate_popup;
  object_class->finalize = gm_world_text_view_finalize;
  widget_class->button_press_event = gm_world_text_view_button_press_event;
  widget_class->button_release_event = gm_world_text_view_button_release_event;
  widget_class->leave_notify_event = gm_world_text_view_leave_event;
  widget_class->drag_data_get = gm_world_text_view_drag_data_get;
  widget_class->drag_end = gm_world_text_view_drag_end;
  widget_class->style_set = gm_world_text_view_style_set;
  world_text_view_signals[(signed long int)0]=g_signal_new("url_activate", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)984ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, g_cclosure_marshal_VOID__STRING, (unsigned long int)(1 << 2), (unsigned int)1, (unsigned long int)(16 << 2));
  world_text_view_signals[(signed long int)1]=g_signal_new("character_size_changed", ((struct _GTypeClass *)object_class)->g_type, (enum anonymous$68)G_SIGNAL_RUN_LAST, (unsigned int)(signed long int)992ul, (signed int (*)(struct _GSignalInvocationHint *, struct _GValue *, const struct _GValue *, void *))(void *)0, (void *)0, gm_marshal_VOID__UINT_UINT, (unsigned long int)(1 << 2), (unsigned int)2, (unsigned long int)(7 << 2), (unsigned long int)(7 << 2));
  g_type_class_add_private((void *)object_class, sizeof(struct _GmWorldTextViewPrivate) /*128ul*/ );
}

// gm_world_text_view_class_intern_init
// file widgets/gm-world-text-view.c line 113
static void gm_world_text_view_class_intern_init(void *klass)
{
  gm_world_text_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmWorldTextView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmWorldTextView_private_offset);

  gm_world_text_view_class_init((struct _GmWorldTextViewClass *)klass);
}

// gm_world_text_view_color_table
// file widgets/gm-world-text-view.c line 1174
struct _GmColorTable * gm_world_text_view_color_table(struct _GmWorldTextView *view)
{
  return view->priv->color_table;
}

// gm_world_text_view_create_tags
// file widgets/gm-world-text-view.c line 562
static void gm_world_text_view_create_tags(struct _GmWorldTextView *view)
{
  signed int i;
  struct _GtkTextTag *tag;
  struct _GtkTextBuffer *buf;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GdkColor col;
  tag=gtk_text_buffer_create_tag(buf, "url", "foreground", (const void *)"steelblue", (const void *)"underline", PANGO_UNDERLINE_SINGLE, (void *)0);
  g_signal_connect_data((void *)tag, "event", (void (*)(void))on_gm_world_text_view_url_event, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)view, "event", (void (*)(void))on_gm_world_text_view_event, (void *)tag, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  view->priv->tag_blink=gtk_text_buffer_create_tag(buf, "blink", (const char *)(void *)0);
  view->priv->tag_blink_fast=gtk_text_buffer_create_tag(buf, "blink-fast", (const char *)(void *)0);
  gtk_text_buffer_create_tag(buf, "blink-after", "weight", 800, (void *)0);
  tag=gtk_text_buffer_create_tag(buf, "inverse_bg", (const char *)(void *)0);
  if(!(view->priv->color_table == ((struct _GmColorTable *)NULL)))
  {
    gm_color_table_get(view->priv->color_table, "fg_default", &col);
    g_object_set((void *)tag, "background-gdk", &col, (void *)0);
  }

  tag=gtk_text_buffer_create_tag(buf, "inverse_fg", (const char *)(void *)0);
  if(!(view->priv->color_table == ((struct _GmColorTable *)NULL)))
  {
    gm_color_table_get(view->priv->color_table, "bg_default", &col);
    g_object_set((void *)tag, "background-gdk", &col, (void *)0);
  }

  i = 0;
  for( ; !(i >= 27); i = i + 1)
  {
    tag=gtk_text_buffer_create_tag(buf, ansi_colors[(signed long int)i].name, (const char *)(void *)0);
    gm_world_text_view_update_color_tag(view, ansi_colors[(signed long int)i].name, tag);
  }
  i = 0;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$16;
  for( ; !(i >= 12); i = i + 1)
  {
    tag=gtk_text_buffer_create_tag(buf, ansi_styles[(signed long int)i].name, (const char *)(void *)0);
    switch((signed int)ansi_styles[(signed long int)i].code)
    {
      case A_BOLD:
      {
        return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$3, "weight", 800, (void *)0);
        break;
      }
      case A_BOLD_OFF:
      {
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$4, "weight", 400, (void *)0);
        break;
      }
      case A_FAINT:
      {
        return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$5, "weight", 200, (void *)0);
        break;
      }
      case A_UNDERLINE:
      {
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6, "underline", PANGO_UNDERLINE_SINGLE, (void *)0);
        break;
      }
      case A_DOUBLE_UNDERLINE:
      {
        return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$7, "underline", PANGO_UNDERLINE_DOUBLE, (void *)0);
        break;
      }
      case A_UNDERLINE_OFF:
      {
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$8, "underline", PANGO_UNDERLINE_NONE, (void *)0);
        break;
      }
      case A_CROSSOUT:
      {
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$9, "strikethrough", !(0 != 0), (void *)0);
        break;
      }
      case A_CROSSOUT_OFF:
      {
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$10, "strikethrough", 0, (void *)0);
        break;
      }
      case A_ITALIC:
      {
        return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$11, "style", PANGO_STYLE_ITALIC, (void *)0);
        break;
      }
      case A_ITALIC_OFF:
      {
        return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$12, "style", PANGO_STYLE_NORMAL, (void *)0);
        break;
      }
      case A_INVISIBLE:
      {
        return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$13, "invisible", !(0 != 0), (void *)0);
        break;
      }
      case A_INVISIBLE_OFF:
      {
        return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$14, "invisible", 0, (void *)0);
        break;
      }
      case A_NOWRAP:
      {
        return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$15, "wrap-mode", GTK_WRAP_NONE, (void *)0);
        break;
      }
      default:
      {
        return_value_gtk_text_buffer_get_tag_table$16=gtk_text_buffer_get_tag_table(buf);
        gtk_text_tag_table_remove(return_value_gtk_text_buffer_get_tag_table$16, tag);
      }
    }
  }
}

// gm_world_text_view_drag_data_get
// file widgets/gm-world-text-view.c line 342
static void gm_world_text_view_drag_data_get(struct _GtkWidget *widget, struct _GdkDragContext *context, struct _GtkSelectionData *data, unsigned int info, unsigned int time)
{
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_world_text_view_get_type$1);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$2;
  struct _GdkAtom *target = data->target;
  char *str = (char *)(void *)0;
  _Bool tmp_if_expr$6;
  struct _GdkAtom *return_value_gdk_atom_intern$5;
  struct _GdkAtom *return_value_gdk_atom_intern$3;
  unsigned long int return_value_gtk_widget_get_type$9;
  struct _GTypeClass *return_value_g_type_check_class_cast$10;
  if(!(view->priv->drag_url_text == ((char *)NULL)))
  {
    struct _GdkAtom *return_value_gdk_atom_intern$4;
    return_value_gdk_atom_intern$4=gdk_atom_intern("_NETSCAPE_URL", 0);
    if(target == return_value_gdk_atom_intern$4)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_gdk_atom_intern$5=gdk_atom_intern("text/plain", 0);
      tmp_if_expr$6 = target == return_value_gdk_atom_intern$5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
      str=g_strdup(view->priv->drag_url_text);

    else
    {
      return_value_gdk_atom_intern$3=gdk_atom_intern("text/uri-list", 0);
      if(target == return_value_gdk_atom_intern$3)
        str=g_strconcat(view->priv->drag_url_text, (const void *)"\r\n", (void *)0);

      else
        do
          g_assertion_message_expr((char *)0, "widgets/gm-world-text-view.c", 355, (const char *)"gm_world_text_view_drag_data_get", (const char *)(void *)0);
        while((_Bool)0);
    }
  }

  else
  {
    return_value_gtk_widget_get_type$9=gtk_widget_get_type();
    return_value_g_type_check_class_cast$10=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$9);
    if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$10)->drag_data_get == ((void (*)(struct _GtkWidget *, struct _GdkDragContext *, struct _GtkSelectionData *, unsigned int, unsigned int))NULL)))
    {
      unsigned long int return_value_gtk_widget_get_type$7;
      return_value_gtk_widget_get_type$7=gtk_widget_get_type();
      struct _GTypeClass *return_value_g_type_check_class_cast$8;
      return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$7);
      ((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$8)->drag_data_get(widget, context, data, info, time);
    }

    else
      do
        g_assertion_message_expr((char *)0, "widgets/gm-world-text-view.c", 362, (const char *)"gm_world_text_view_drag_data_get", (const char *)(void *)0);
      while((_Bool)0);
  }
  unsigned long int return_value_strlen$11;
  return_value_strlen$11=strlen(str);
  gtk_selection_data_set(data, target, 8, (const unsigned char *)str, (signed int)return_value_strlen$11);
  g_free((void *)str);
}

// gm_world_text_view_drag_end
// file widgets/gm-world-text-view.c line 371
static void gm_world_text_view_drag_end(struct _GtkWidget *widget, struct _GdkDragContext *context)
{
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_world_text_view_get_type$1);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_widget_get_type$5;
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  if(!(view->priv->drag_url_text == ((char *)NULL)))
  {
    g_free((void *)view->priv->drag_url_text);
    view->priv->drag_url_text = (char *)(void *)0;
  }

  else
  {
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$5);
    if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->drag_end == ((void (*)(struct _GtkWidget *, struct _GdkDragContext *))NULL)))
    {
      unsigned long int return_value_gtk_widget_get_type$3;
      return_value_gtk_widget_get_type$3=gtk_widget_get_type();
      struct _GTypeClass *return_value_g_type_check_class_cast$4;
      return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$3);
      ((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$4)->drag_end(widget, context);
    }

  }
}

// gm_world_text_view_finalize
// file widgets/gm-world-text-view.c line 117
static void gm_world_text_view_finalize(struct _GObject *object)
{
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_text_view_get_type$1);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$2;
  struct _GSList *item;
  struct _BlinkInfo *info;
  gm_world_text_view_set_color_table(view, (struct _GmColorTable *)(void *)0);
  if(!(view->priv->blink_timeout_id == 0u))
    g_source_remove(view->priv->blink_timeout_id);

  item = view->priv->blinkers;
  for( ; !(item == ((struct _GSList *)NULL)); item = item->next)
  {
    info = (struct _BlinkInfo *)item->data;
    g_source_remove(info->timeout);
    blink_info_free(info);
  }
  g_slist_free(view->priv->blinkers);
  g_list_free(view->priv->last_info.tags);
  g_free((void *)view->priv->last_info.text);
  gtk_target_list_unref(view->priv->source_target_list);
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)gm_world_text_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// gm_world_text_view_get_metrics
// file widgets/gm-world-text-view.c line 1354
void gm_world_text_view_get_metrics(struct _GmWorldTextView *view, unsigned int *width, unsigned int *height)
{
  *width = view->priv->character_width;
  *height = view->priv->character_height;
}

// gm_world_text_view_get_type
// file widgets/gm-world-text-view.h line 49
unsigned long int gm_world_text_view_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_text_view_get_type$1;
    return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmWorldTextView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_text_view_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmWorldTextViewClass) /*1000ul*/ , (void (*)(void *, void *))gm_world_text_view_class_intern_init, (unsigned int)sizeof(struct _GmWorldTextView) /*360ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_world_text_view_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_world_text_view_init
// file widgets/gm-world-text-view.c line 205
static void gm_world_text_view_init(struct _GmWorldTextView *view)
{
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)view, return_value_gm_world_text_view_get_type$1);
  view->priv = (struct _GmWorldTextViewPrivate *)return_value_g_type_instance_get_private$2;
  do
  {
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$3);
    unsigned long int return_value_gtk_object_get_type$5;
    return_value_gtk_object_get_type$5=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkWidget *)return_value_g_type_check_instance_cast$4, return_value_gtk_object_get_type$5);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast$6)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast$6)->flags & (unsigned int)~2048;
  }
  while((_Bool)0);
  unsigned long int return_value_gtk_widget_get_type$7;
  return_value_gtk_widget_get_type$7=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$7);
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$9);
  gtk_widget_modify_base((struct _GtkWidget *)return_value_g_type_check_instance_cast$8, (enum anonymous$23)GTK_STATE_ACTIVE, &((struct _GtkWidget *)return_value_g_type_check_instance_cast$10)->style->base[(signed long int)GTK_STATE_SELECTED]);
  unsigned long int return_value_gtk_widget_get_type$11;
  return_value_gtk_widget_get_type$11=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$11);
  unsigned long int return_value_gtk_widget_get_type$13;
  return_value_gtk_widget_get_type$13=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$13);
  gtk_widget_modify_text((struct _GtkWidget *)return_value_g_type_check_instance_cast$12, (enum anonymous$23)GTK_STATE_ACTIVE, &((struct _GtkWidget *)return_value_g_type_check_instance_cast$14)->style->text[(signed long int)GTK_STATE_SELECTED]);
  unsigned long int return_value_gtk_text_view_get_type$15;
  return_value_gtk_text_view_get_type$15=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$15);
  gtk_text_view_set_editable((struct _GtkTextView *)return_value_g_type_check_instance_cast$16, 0);
  unsigned long int return_value_gtk_text_view_get_type$17;
  return_value_gtk_text_view_get_type$17=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$17);
  gtk_text_view_set_left_margin((struct _GtkTextView *)return_value_g_type_check_instance_cast$18, 3);
  unsigned long int return_value_gtk_text_view_get_type$19;
  return_value_gtk_text_view_get_type$19=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$19);
  gtk_text_view_set_right_margin((struct _GtkTextView *)return_value_g_type_check_instance_cast$20, 3);
  unsigned long int return_value_gtk_text_view_get_type$21;
  return_value_gtk_text_view_get_type$21=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$21);
  gtk_text_view_set_wrap_mode((struct _GtkTextView *)return_value_g_type_check_instance_cast$22, (enum anonymous$77)GTK_WRAP_WORD_CHAR);
  view->priv->color_table = (struct _GmColorTable *)(void *)0;
  view->priv->max_lines = 2000;
  view->priv->last_info.bold = 0;
  view->priv->last_info.inverse = 0;
  view->priv->last_info.tags = (struct _GList *)(void *)0;
  view->priv->last_info.text = (char *)(void *)0;
  view->priv->source_target_list=gtk_target_list_new(drag_targets, (unsigned int)3);
}

// gm_world_text_view_init_tags
// file widgets/gm-world-text-view.c line 677
static void gm_world_text_view_init_tags(struct _GmWorldTextView *view)
{
  struct _GdkColor col;
  gm_color_table_get(view->priv->color_table, "fg_default", &col);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$1);
  gtk_widget_modify_text((struct _GtkWidget *)return_value_g_type_check_instance_cast$2, (enum anonymous$23)GTK_STATE_NORMAL, &col);
  gm_color_table_get(view->priv->color_table, "bg_default", &col);
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$3);
  gtk_widget_modify_base((struct _GtkWidget *)return_value_g_type_check_instance_cast$4, (enum anonymous$23)GTK_STATE_NORMAL, &col);
  gm_world_text_view_update_tags(view);
}

// gm_world_text_view_insert
// file widgets/gm-world-text-view.h line 52
char * gm_world_text_view_insert(struct _GmWorldTextView *view, const char *text)
{
  char *ptr;
  char *ansi_start;
  char *ansi_stop;
  char **ansis;
  char *name;
  signed int i;
  unsigned int seq;
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextTagTable *tab;
  tab=gtk_text_buffer_get_tag_table(buffer);
  struct _GmWorldTextViewInsertInfo *info = &view->priv->last_info;
  struct _GString *new_line = (struct _GString *)(void *)0;
  struct _GtkTextIter started;
  struct _GtkTextIter ended;
  struct _GtkTextMark *start_mark;
  struct _GtkTextTag *tag;
  signed int skip;
  do
  {
    signed int return_value_g_utf8_validate$3;
    return_value_g_utf8_validate$3=g_utf8_validate(text, (signed long int)-1, (const char **)(void *)0);
    if(return_value_g_utf8_validate$3 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_world_text_view_insert", "g_utf8_validate(text, -1, NULL)");
      return (char *)(void *)0;
    }

  }
  while((_Bool)0);
  if(!(info->text == ((char *)NULL)))
  {
    new_line=g_string_new(info->text);
    g_free((void *)info->text);
    info->text = (char *)(void *)0;
  }

  else
    new_line=g_string_new("");
  g_string_append(new_line, text);
  ptr=g_utf8_strchr(new_line->str, (signed long int)-1, (unsigned int)7);
  if(!(ptr == ((char *)NULL)))
  {
    gdk_beep();
    while(!(ptr == ((char *)NULL)))
    {
      signed long int return_value_g_utf8_pointer_to_offset$4;
      return_value_g_utf8_pointer_to_offset$4=g_utf8_pointer_to_offset(new_line->str, ptr);
      g_string_erase(new_line, return_value_g_utf8_pointer_to_offset$4, (signed long int)1);
      ptr=g_utf8_strchr(new_line->str, (signed long int)-1, (unsigned int)7);
    }
  }

  gm_debug_msg(DEBUG_DEFAULT, "GmWorldTextView.Insert: %s", new_line->str);
  gtk_text_buffer_get_end_iter(buffer, &started);
  start_mark=gtk_text_buffer_create_mark(buffer, "last-insertion", &started, (signed int)!(0 != 0));
  signed int return_value_g_utf8_toint$7;
  while(!(new_line == ((struct _GString *)NULL)))
  {
    ansi_start=strstr(new_line->str, "\033[");
    if(ansi_start == ((char *)NULL))
      break;

    signed long int return_value_g_utf8_pointer_to_offset$5;
    return_value_g_utf8_pointer_to_offset$5=g_utf8_pointer_to_offset(new_line->str, ansi_start);
    i = (signed int)return_value_g_utf8_pointer_to_offset$5;
    if(!(i == 0))
    {
      ptr=g_strndup(new_line->str, (unsigned long int)(ansi_start - new_line->str));
      gm_world_text_view_insert_text(view, ptr, info);
      g_free((void *)ptr);
    }

    ansi_stop=g_utf8_strchr(ansi_start, (signed long int)-1, (unsigned int)109);
    if(!(ansi_stop == ((char *)NULL)))
    {
      ansi_start = ansi_start + (signed long int)2;
      ptr=g_strndup(ansi_start, (unsigned long int)(ansi_stop - ansi_start));
      ansis=g_strsplit(ptr, ";", -1);
      g_free((void *)ptr);
      i = 0;
      for( ; !(ansis[(signed long int)i] == ((char *)NULL)); i = i + 1)
        if(!((signed int)*ansis[(signed long int)i] == 0))
        {
          return_value_g_utf8_toint$7=g_utf8_toint(ansis[(signed long int)i], &seq);
          if(!(return_value_g_utf8_toint$7 == 0))
          {
            skip = 0;
            switch(seq)
            {
              case (unsigned int)A_FG_DEFAULT:

              case (unsigned int)A_FG_BLACK:

              case (unsigned int)A_FG_RED:

              case (unsigned int)A_FG_GREEN:

              case (unsigned int)A_FG_YELLOW:

              case (unsigned int)A_FG_BLUE:

              case (unsigned int)A_FG_PURPLE:

              case (unsigned int)A_FG_CYAN:

              case (unsigned int)A_FG_WHITE:
              {
                if(!(info->inverse == 0))
                  seq = seq + (unsigned int)10;

                break;
              }
              case (unsigned int)A_BG_DEFAULT:

              case (unsigned int)A_BG_BLACK:

              case (unsigned int)A_BG_RED:

              case (unsigned int)A_BG_GREEN:

              case (unsigned int)A_BG_YELLOW:

              case (unsigned int)A_BG_BLUE:

              case (unsigned int)A_BG_PURPLE:

              case (unsigned int)A_BG_CYAN:

              case (unsigned int)A_BG_WHITE:
              {
                if(!(info->inverse == 0))
                  seq = seq - (unsigned int)10;

                break;
              }
              case (unsigned int)A_BOLD:
              {
                info->bold = (signed int)!(0 != 0);
                if(!(info->inverse == 0))
                  skip = (signed int)!(0 != 0);

                break;
              }
              case (unsigned int)A_FAINT:
              {
                info->bold = (signed int)!(0 != 0);
                if(!(info->inverse == 0))
                  skip = (signed int)!(0 != 0);

                break;
              }
              case (unsigned int)A_BOLD_OFF:
              {
                info->bold = 0;
                if(!(info->inverse == 0))
                  skip = (signed int)!(0 != 0);

                break;
              }
              case (unsigned int)A_INVERSE:
              {
                info->inverse = (signed int)!(info->inverse != 0);
                info->tags=gm_world_text_view_tags_fix_for_inverse(view, info->tags);
                break;
              }
              case (unsigned int)A_INVERSE_OFF:
              {
                if(!(info->inverse == 0))
                {
                  info->tags=gm_world_text_view_tags_fix_for_inverse(view, info->tags);
                  info->inverse = 0;
                }

                break;
              }
              case (unsigned int)A_BLINK:
              {
                info->blink = (unsigned int)1;
                break;
              }
              case (unsigned int)A_BLINK_OFF:
              {
                info->blink = (unsigned int)0;
                break;
              }
              case (unsigned int)A_BLINK_FAST:
              {
                info->blink = (unsigned int)2;
                break;
              }
              case (unsigned int)A_BLINK_FAST_OFF:
              {
                info->blink = (unsigned int)0;
                break;
              }
              case (unsigned int)A_DEFAULT:
              {
                g_list_free(info->tags);
                info->tags = (struct _GList *)(void *)0;
                info->bold = 0;
                info->inverse = 0;
                info->blink = (unsigned int)0;
              }
            }
            const char *return_value_gm_world_text_view_tagname_from_code$6;
            return_value_gm_world_text_view_tagname_from_code$6=gm_world_text_view_tagname_from_code(seq);
            name = (char *)return_value_gm_world_text_view_tagname_from_code$6;
            if(skip == 0 && !(name == ((char *)NULL)))
            {
              tag=gtk_text_tag_table_lookup(tab, name);
              if(!(tag == ((struct _GtkTextTag *)NULL)))
                info->tags=gm_world_text_view_tags_add(view, info->tags, tag);

            }

          }

        }

      g_strfreev(ansis);
      g_string_erase(new_line, (signed long int)0, (ansi_stop - new_line->str) + (signed long int)1);
    }

    else
    {
      info->text=g_strdup(ansi_start);
      g_string_free(new_line, (signed int)!(0 != 0));
      new_line = (struct _GString *)(void *)0;
    }
  }
  if(!(new_line == ((struct _GString *)NULL)))
  {
    if(!(new_line->len == 0ul))
      gm_world_text_view_insert_text(view, new_line->str, info);

  }

  if(!(new_line == ((struct _GString *)NULL)))
    g_string_free(new_line, (signed int)!(0 != 0));

  gm_world_text_view_check_buffer_size(view);
  gtk_text_buffer_get_iter_at_mark(buffer, &started, start_mark);
  gtk_text_buffer_get_end_iter(buffer, &ended);
  gtk_text_buffer_delete_mark(buffer, start_mark);
  ptr=gtk_text_buffer_get_text(buffer, &started, &ended, 0);
  gm_world_text_view_tag_urls(view, ptr, &started, &ended);
  return ptr;
}

// gm_world_text_view_insert_text
// file widgets/gm-world-text-view.c line 1018
static void gm_world_text_view_insert_text(struct _GmWorldTextView *view, const char *text, struct _GmWorldTextViewInsertInfo *insert_info)
{
  struct _GtkTextIter end_iter;
  struct _GtkTextIter start_iter;
  struct _GtkTextIter ins;
  struct _GtkTextBuffer *tb;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  tb=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  signed int start_offset;
  struct _BlinkInfo *info;
  struct _GList *tags;
  if(!(insert_info->bold == 0))
    insert_info->tags=gm_world_text_view_tags_apply_bold(view, insert_info->tags);

  else
    insert_info->tags=gm_world_text_view_tags_remove_bold(view, insert_info->tags);
  gtk_text_buffer_get_end_iter(tb, &end_iter);
  start_offset=gtk_text_iter_get_offset(&end_iter);
  gtk_text_buffer_insert(tb, &end_iter, text, -1);
  gtk_text_buffer_get_iter_at_offset(tb, &start_iter, start_offset);
  gtk_text_buffer_get_end_iter(tb, &end_iter);
  tags = insert_info->tags;
  for( ; !(tags == ((struct _GList *)NULL)); tags = tags->next)
  {
    unsigned long int return_value_gtk_text_tag_get_type$3;
    return_value_gtk_text_tag_get_type$3=gtk_text_tag_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)tags->data, return_value_gtk_text_tag_get_type$3);
    gtk_text_buffer_apply_tag(tb, (struct _GtkTextTag *)return_value_g_type_check_instance_cast$4, &start_iter, &end_iter);
  }
  if(!(insert_info->blink == 0u))
  {
    void *return_value_g_malloc0_n$5;
    return_value_g_malloc0_n$5=g_malloc0_n((unsigned long int)1, sizeof(struct _BlinkInfo) /*48ul*/ );
    info = (struct _BlinkInfo *)return_value_g_malloc0_n$5;
    info->blink = insert_info->blink;
    struct _GtkTextMark *return_value_gtk_text_buffer_create_mark$6;
    return_value_gtk_text_buffer_create_mark$6=gtk_text_buffer_create_mark(tb, (const char *)(void *)0, &start_iter, (signed int)!(0 != 0));
    void *return_value_g_object_ref$7;
    return_value_g_object_ref$7=g_object_ref((void *)return_value_gtk_text_buffer_create_mark$6);
    info->begin = (struct _GtkTextMark *)return_value_g_object_ref$7;
    info->view = view;
    if(insert_info->blink == 1u)
      gtk_text_buffer_apply_tag_by_name(tb, "blink", &start_iter, &end_iter);

    else
      gtk_text_buffer_apply_tag_by_name(tb, "blink-fast", &start_iter, &end_iter);
    struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$8;
    return_value_gtk_text_buffer_get_tag_table$8=gtk_text_buffer_get_tag_table(tb);
    info->text=gtk_text_buffer_new(return_value_gtk_text_buffer_get_tag_table$8);
    gtk_text_buffer_get_iter_at_offset(info->text, &ins, 0);
    gtk_text_buffer_insert_range(info->text, &ins, &start_iter, &end_iter);
    signed long int return_value_g_utf8_strlen$9;
    return_value_g_utf8_strlen$9=g_utf8_strlen(text, (signed long int)-1);
    info->fill=g_strnfill((unsigned long int)return_value_g_utf8_strlen$9, (char)32);
    if(view->priv->blink_timeout_id == 0u)
      view->priv->blink_timeout_id=g_timeout_add((unsigned int)250, (signed int (*)(void *))gm_world_text_view_blink_timeout, (void *)view);

    info->timeout=g_timeout_add((unsigned int)10000, (signed int (*)(void *))gm_world_text_view_blinker_timeout, (void *)info);
    view->priv->blinkers=g_slist_append(view->priv->blinkers, (void *)info);
  }

}

// gm_world_text_view_leave_event
// file widgets/gm-world-text-view.c line 329
static signed int gm_world_text_view_leave_event(struct _GtkWidget *widget, struct _GdkEventCrossing *event)
{
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_world_text_view_get_type$1);
  ((struct _GmWorldTextView *)return_value_g_type_check_instance_cast$2)->priv->drag_url = 0;
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$5);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->leave_notify_event == ((signed int (*)(struct _GtkWidget *, struct _GdkEventCrossing *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$4;
    return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$3);
    signed int return_value;
    return_value=((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$4)->leave_notify_event(widget, event);
    return return_value;
  }

  return 0;
}

// gm_world_text_view_new
// file widgets/gm-world-text-view.c line 1126
struct _GtkWidget * gm_world_text_view_new(void)
{
  struct _GtkWidget *result;
  struct _GmColorTable *table;
  table=gm_color_table_new();
  result=gm_world_text_view_new_with_color_table(table);
  g_object_unref((void *)table);
  return result;
}

// gm_world_text_view_new_with_color_table
// file widgets/gm-world-text-view.h line 51
struct _GtkWidget * gm_world_text_view_new_with_color_table(struct _GmColorTable *color_table)
{
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_world_text_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_world_text_view_get_type$3;
  return_value_gm_world_text_view_get_type$3=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_world_text_view_get_type$3);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$4;
  gm_world_text_view_create_tags(view);
  gm_world_text_view_set_color_table(view, color_table);
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$5);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
}

// gm_world_text_view_no_selection
// file widgets/gm-world-text-view.c line 298
static void gm_world_text_view_no_selection(struct _GmWorldTextView *view)
{
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextIter iter;
  struct _GtkTextMark *return_value_gtk_text_buffer_get_insert$3;
  return_value_gtk_text_buffer_get_insert$3=gtk_text_buffer_get_insert(buffer);
  gtk_text_buffer_get_iter_at_mark(buffer, &iter, return_value_gtk_text_buffer_get_insert$3);
  struct _GtkTextMark *return_value_gtk_text_buffer_get_selection_bound$4;
  return_value_gtk_text_buffer_get_selection_bound$4=gtk_text_buffer_get_selection_bound(buffer);
  gtk_text_buffer_move_mark(buffer, return_value_gtk_text_buffer_get_selection_bound$4, &iter);
}

// gm_world_text_view_populate_popup
// file widgets/gm-world-text-view.c line 423
static void gm_world_text_view_populate_popup(struct _GtkTextView *text_view, struct _GtkMenu *menu)
{
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)text_view, return_value_gm_world_text_view_get_type$1);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$2;
  struct _GtkTextTagTable *table;
  struct _GtkTextTag *tag;
  signed int x;
  signed int y;
  struct _GtkTextIter iter;
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  struct _GtkWidget *item;
  char *str = (char *)(void *)0;
  if(!(parent_class->populate_popup == ((void (*)(struct _GtkTextView *, struct _GtkMenu *))NULL)))
    parent_class->populate_popup(text_view, menu);

  unsigned long int return_value_gtk_text_view_get_type$3;
  return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$3);
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$5;
  return_value_gtk_text_view_get_buffer$5=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$4);
  table=gtk_text_buffer_get_tag_table(return_value_gtk_text_view_get_buffer$5);
  tag=gtk_text_tag_table_lookup(table, "url");
  unsigned long int return_value_gtk_widget_get_type$6;
  return_value_gtk_widget_get_type$6=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$6);
  gtk_widget_get_pointer((struct _GtkWidget *)return_value_g_type_check_instance_cast$7, &x, &y);
  unsigned long int return_value_gtk_text_view_get_type$8;
  return_value_gtk_text_view_get_type$8=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$8);
  gtk_text_view_window_to_buffer_coords((struct _GtkTextView *)return_value_g_type_check_instance_cast$9, (enum anonymous$91)GTK_TEXT_WINDOW_WIDGET, x, y, &x, &y);
  unsigned long int return_value_gtk_text_view_get_type$10;
  return_value_gtk_text_view_get_type$10=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$10);
  gtk_text_view_get_iter_at_location((struct _GtkTextView *)return_value_g_type_check_instance_cast$11, &iter, x, y);
  end = iter;
  start = end;
  signed int return_value_gtk_text_iter_backward_to_tag_toggle$16;
  return_value_gtk_text_iter_backward_to_tag_toggle$16=gtk_text_iter_backward_to_tag_toggle(&start, tag);
  signed int return_value_gtk_text_iter_forward_to_tag_toggle$15;
  if(!(return_value_gtk_text_iter_backward_to_tag_toggle$16 == 0))
  {
    return_value_gtk_text_iter_forward_to_tag_toggle$15=gtk_text_iter_forward_to_tag_toggle(&end, tag);
    if(!(return_value_gtk_text_iter_forward_to_tag_toggle$15 == 0))
    {
      unsigned long int return_value_gtk_text_view_get_type$12;
      return_value_gtk_text_view_get_type$12=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
      return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$12);
      struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$14;
      return_value_gtk_text_view_get_buffer$14=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$13);
      str=gtk_text_buffer_get_text(return_value_gtk_text_view_get_buffer$14, &start, &end, 0);
    }

  }

  _Bool tmp_if_expr$17;
  if(str == ((char *)NULL))
    tmp_if_expr$17 = (_Bool)1;

  else
    tmp_if_expr$17 = (signed int)*str == 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$17)
  {
    item=gtk_menu_item_new();
    unsigned long int return_value_gtk_menu_shell_get_type$18;
    return_value_gtk_menu_shell_get_type$18=gtk_menu_shell_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)menu, return_value_gtk_menu_shell_get_type$18);
    gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast$19, item);
    gtk_widget_show(item);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)menu, (unsigned long int)(20 << 2));
    g_object_set_data_full((struct _GObject *)return_value_g_type_check_instance_cast$20, "url", (void *)str, (void (*)(void *))g_free);
    char *return_value_gettext$21;
    return_value_gettext$21=gettext("_Copy Link Address");
    item=gtk_menu_item_new_with_mnemonic(return_value_gettext$21);
    g_signal_connect_data((void *)item, "activate", (void (*)(void))on_gm_world_text_view_copy_address, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    unsigned long int return_value_gtk_menu_shell_get_type$22;
    return_value_gtk_menu_shell_get_type$22=gtk_menu_shell_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)menu, return_value_gtk_menu_shell_get_type$22);
    gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast$23, item);
    gtk_widget_show(item);
    char *return_value_gettext$24;
    return_value_gettext$24=gettext("_Open Link");
    item=gtk_menu_item_new_with_mnemonic(return_value_gettext$24);
    g_signal_connect_data((void *)item, "activate", (void (*)(void))on_gm_world_text_view_open_address, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    unsigned long int return_value_gtk_menu_shell_get_type$25;
    return_value_gtk_menu_shell_get_type$25=gtk_menu_shell_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
    return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)menu, return_value_gtk_menu_shell_get_type$25);
    gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast$26, item);
    gtk_widget_show(item);
  }

}

// gm_world_text_view_remove_blinkers
// file widgets/gm-world-text-view.c line 521
static void gm_world_text_view_remove_blinkers(struct _GmWorldTextView *view, struct _GtkTextIter *start, struct _GtkTextIter *end)
{
  struct _GtkTextIter blink;
  struct _BlinkInfo *info;
  struct _GSList *item;
  struct _GSList *list;
  struct _GtkTextBuffer *buffer;
  list=g_slist_copy(view->priv->blinkers);
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  item = list;
  for( ; !(item == ((struct _GSList *)NULL)); item = item->next)
  {
    info = (struct _BlinkInfo *)item->data;
    gtk_text_buffer_get_iter_at_mark(buffer, &blink, info->begin);
    signed int return_value_gtk_text_iter_in_range$3;
    return_value_gtk_text_iter_in_range$3=gtk_text_iter_in_range(&blink, start, end);
    if(!(return_value_gtk_text_iter_in_range$3 == 0))
      view->priv->blinkers=g_slist_remove(view->priv->blinkers, (const void *)info);

  }
  g_slist_free(list);
}

// gm_world_text_view_set_color_table
// file widgets/gm-world-text-view.c line 1147
void gm_world_text_view_set_color_table(struct _GmWorldTextView *view, struct _GmColorTable *color_table)
{
  if(!(view->priv->color_table == ((struct _GmColorTable *)NULL)))
  {
    g_signal_handlers_disconnect_matched((void *)view->priv->color_table, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_world_text_view_color_table_color_changed, (void *)view);
    g_signal_handlers_disconnect_matched((void *)view->priv->color_table, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_world_text_view_color_table_font_changed, (void *)view);
    g_object_unref((void *)view->priv->color_table);
  }

  if(!(color_table == ((struct _GmColorTable *)NULL)))
  {
    void *return_value_g_object_ref$1;
    return_value_g_object_ref$1=g_object_ref((void *)color_table);
    view->priv->color_table = (struct _GmColorTable *)return_value_g_object_ref$1;
    g_signal_connect_data((void *)view->priv->color_table, "color_changed", (void (*)(void))on_gm_world_text_view_color_table_color_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    g_signal_connect_data((void *)view->priv->color_table, "font_changed", (void (*)(void))on_gm_world_text_view_color_table_font_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    gm_world_text_view_init_tags(view);
    gm_world_text_view_update_font(view);
  }

  else
    view->priv->color_table = (struct _GmColorTable *)(void *)0;
}

// gm_world_text_view_style_set
// file widgets/gm-world-text-view.c line 383
static void gm_world_text_view_style_set(struct _GtkWidget *widget, struct _GtkStyle *previous_style)
{
  struct _GmWorldTextView *view;
  unsigned long int return_value_gm_world_text_view_get_type$1;
  return_value_gm_world_text_view_get_type$1=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gm_world_text_view_get_type$1);
  view = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$2;
  struct _GtkRcStyle *style;
  struct _PangoContext *pc;
  struct _PangoLayout *pl;
  signed int cwidth;
  signed int cheight;
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$5);
  if(!(((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$6)->style_set == ((void (*)(struct _GtkWidget *, struct _GtkStyle *))NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$4;
    return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)parent_class, return_value_gtk_widget_get_type$3);
    ((struct _GtkWidgetClass *)return_value_g_type_check_class_cast$4)->style_set(widget, previous_style);
  }

  style=gtk_widget_get_modifier_style(widget);
  pc=gtk_widget_create_pango_context(widget);
  _Bool tmp_if_expr$7;
  if(!(style->font_desc == ((struct _PangoFontDescription *)NULL)))
  {
    pango_context_set_font_description(pc, style->font_desc);
    pl=pango_layout_new(pc);
    pango_layout_set_text(pl, "G", 1);
    pango_layout_get_pixel_size(pl, &cwidth, &cheight);
    if(!(view->priv->character_width == (unsigned int)cwidth))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = view->priv->character_height != (unsigned int)cheight ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
    {
      view->priv->character_width = (unsigned int)cwidth;
      view->priv->character_height = (unsigned int)cheight;
      g_signal_emit((void *)view, world_text_view_signals[(signed long int)1], (unsigned int)0, view->priv->character_width, view->priv->character_height);
    }

    g_object_unref((void *)pl);
  }

  g_object_unref((void *)pc);
}

// gm_world_text_view_tag_urls
// file widgets/gm-world-text-view.c line 1090
static void gm_world_text_view_tag_urls(struct _GmWorldTextView *view, char *text, struct _GtkTextIter *started, struct _GtkTextIter *ended)
{
  signed int num_matches;
  signed int i;
  struct _GArray *start;
  struct _GArray *end;
  signed int s = 0;
  signed int e = 0;
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextTag *url_tag;
  struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$3;
  return_value_gtk_text_buffer_get_tag_table$3=gtk_text_buffer_get_tag_table(buffer);
  url_tag=gtk_text_tag_table_lookup(return_value_gtk_text_buffer_get_tag_table$3, "url");
  struct _GtkTextIter urlstart;
  struct _GtkTextIter urlend;
  start=g_array_new(0, 0, (unsigned int)sizeof(signed int) /*4ul*/ );
  end=g_array_new(0, 0, (unsigned int)sizeof(signed int) /*4ul*/ );
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(text);
  num_matches=gm_url_regex_match(text, (signed int)return_value_strlen$4, start, end);
  i = 0;
  for( ; !(i >= num_matches); i = i + 1)
  {
    urlstart = *started;
    urlend = *started;
    s = ((signed int *)(void *)start->data)[(signed long int)i];
    e = ((signed int *)(void *)end->data)[(signed long int)i];
    signed long int return_value_g_utf8_pointer_to_offset$5;
    return_value_g_utf8_pointer_to_offset$5=g_utf8_pointer_to_offset(text, text + (signed long int)s);
    gtk_text_iter_forward_cursor_positions(&urlstart, (signed int)return_value_g_utf8_pointer_to_offset$5);
    signed long int return_value_g_utf8_pointer_to_offset$6;
    return_value_g_utf8_pointer_to_offset$6=g_utf8_pointer_to_offset(text, text + (signed long int)e);
    gtk_text_iter_forward_cursor_positions(&urlend, (signed int)return_value_g_utf8_pointer_to_offset$6);
    gtk_text_buffer_apply_tag(buffer, url_tag, &urlstart, &urlend);
  }
  g_array_free(start, (signed int)!(0 != 0));
  g_array_free(end, (signed int)!(0 != 0));
}

// gm_world_text_view_tagname_from_code
// file widgets/gm-world-text-view.c line 814
static const char * gm_world_text_view_tagname_from_code(unsigned int code)
{
  signed int i;
  signed int len = (signed int)(sizeof(const struct _ansinamepair [27l]) /*432ul*/  / sizeof(struct _ansinamepair) /*16ul*/ );
  i = 0;
  for( ; !(i >= len); i = i + 1)
    if((unsigned int)ansi_colors[(signed long int)i].code == code)
      return ansi_colors[(signed long int)i].name;

  len = (signed int)(sizeof(const struct _ansinamepair [12l]) /*192ul*/  / sizeof(struct _ansinamepair) /*16ul*/ );
  i = 0;
  for( ; !(i >= len); i = i + 1)
    if((unsigned int)ansi_styles[(signed long int)i].code == code)
      return ansi_styles[(signed long int)i].name;

  return (const char *)(void *)0;
}

// gm_world_text_view_tags_add
// file widgets/gm-world-text-view.c line 1083
static struct _GList * gm_world_text_view_tags_add(struct _GmWorldTextView *view, struct _GList *tags, struct _GtkTextTag *tag)
{
  tags=gm_world_text_view_tags_remove_obsolete(view, tags, tag);
  struct _GList *return_value_g_list_append$1;
  return_value_g_list_append$1=g_list_append(tags, (void *)tag);
  return return_value_g_list_append$1;
}

// gm_world_text_view_tags_apply_bold
// file widgets/gm-world-text-view.c line 836
static struct _GList * gm_world_text_view_tags_apply_bold(struct _GmWorldTextView *view, struct _GList *tags)
{
  struct _GList *t;
  struct _GList *item;
  struct _GtkTextTag *tag;
  struct _GtkTextTag *htag;
  signed int fg_set;
  char *name;
  char *hname;
  signed int added = 0;
  struct _GtkTextTagTable *tag_table;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$3;
  return_value_gtk_text_view_get_buffer$3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  tag_table=gtk_text_buffer_get_tag_table(return_value_gtk_text_view_get_buffer$3);
  t=g_list_copy(tags);
  item = t;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    unsigned long int return_value_gtk_text_tag_get_type$4;
    return_value_gtk_text_tag_get_type$4=gtk_text_tag_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_text_tag_get_type$4);
    tag = (struct _GtkTextTag *)return_value_g_type_check_instance_cast$5;
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
    g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6, "foreground-set", &fg_set, (void *)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
    g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$7, "name", &name, (void *)0);
    if(!(fg_set == 0))
    {
      hname=g_strconcat(name, (const void *)"_h", (void *)0);
      htag=gtk_text_tag_table_lookup(tag_table, hname);
      if(!(htag == ((struct _GtkTextTag *)NULL)))
      {
        struct _GList *return_value_g_list_find$8;
        return_value_g_list_find$8=g_list_find(tags, (const void *)htag);
        if(return_value_g_list_find$8 == ((struct _GList *)NULL))
          tags=g_list_append(tags, (void *)htag);

        added = (signed int)!(0 != 0);
      }

      g_free((void *)hname);
    }

    g_free((void *)name);
  }
  if(added == 0)
  {
    struct _GtkTextTag *return_value_gtk_text_tag_table_lookup$9;
    return_value_gtk_text_tag_table_lookup$9=gtk_text_tag_table_lookup(tag_table, "fg_default_h");
    tags=g_list_append(tags, (void *)return_value_gtk_text_tag_table_lookup$9);
  }

  g_list_free(t);
  return tags;
}

// gm_world_text_view_tags_fix_for_inverse
// file widgets/gm-world-text-view.c line 881
static struct _GList * gm_world_text_view_tags_fix_for_inverse(struct _GmWorldTextView *view, struct _GList *tags)
{
  signed int bold = view->priv->last_info.bold;
  signed int fg_changed = 0;
  signed int bg_changed = 0;
  struct _GList *new_tags = (struct _GList *)(void *)0;
  struct _GList *item;
  struct _GtkTextTag *tag;
  char *name;
  char *base;
  char *tagname;
  signed int i;
  struct _GtkTextTagTable *tab;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$3;
  return_value_gtk_text_view_get_buffer$3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  tab=gtk_text_buffer_get_tag_table(return_value_gtk_text_view_get_buffer$3);
  item = tags;
  signed int return_value_strncmp$13;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    unsigned long int return_value_gtk_text_tag_get_type$4;
    return_value_gtk_text_tag_get_type$4=gtk_text_tag_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_text_tag_get_type$4);
    tag = (struct _GtkTextTag *)return_value_g_type_check_instance_cast$5;
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
    g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6, "name", &name, (void *)0);
    signed int return_value_strncmp$14;
    return_value_strncmp$14=strncmp(name, "fg_", (unsigned long int)3);
    if(return_value_strncmp$14 == 0)
    {
      base = name + (signed long int)3;
      bg_changed = (signed int)!(0 != 0);
      i = 0;
      for( ; !((signed int)base[(signed long int)i] == 95); i = i + 1)
        if((signed int)base[(signed long int)i] == 0)
          break;

      base[(signed long int)i] = (char)0;
      tagname=g_strconcat("bg_", base, (void *)0);
      struct _GtkTextTag *return_value_gtk_text_tag_table_lookup$7;
      return_value_gtk_text_tag_table_lookup$7=gtk_text_tag_table_lookup(tab, tagname);
      new_tags=g_list_append(new_tags, (void *)return_value_gtk_text_tag_table_lookup$7);
      g_free((void *)tagname);
    }

    else
    {
      return_value_strncmp$13=strncmp(name, "bg_", (unsigned long int)3);
      if(return_value_strncmp$13 == 0)
      {
        base = name + (signed long int)3;
        fg_changed = (signed int)!(0 != 0);
        if(!(bold == 0))
          tagname=g_strconcat("fg_", base, (const void *)"_h", (void *)0);

        else
          tagname=g_strconcat("fg_", base, (void *)0);
        struct _GtkTextTag *return_value_gtk_text_tag_table_lookup$8;
        return_value_gtk_text_tag_table_lookup$8=gtk_text_tag_table_lookup(tab, tagname);
        new_tags=g_list_append(new_tags, (void *)return_value_gtk_text_tag_table_lookup$8);
        g_free((void *)tagname);
      }

      else
      {
        return_value_strcmp$12=strcmp(name, "inverse_bg");
        if(return_value_strcmp$12 == 0)
        {
          fg_changed = (signed int)!(0 != 0);
          struct _GtkTextTag *return_value_gtk_text_tag_table_lookup$9;
          return_value_gtk_text_tag_table_lookup$9=gtk_text_tag_table_lookup(tab, "bg_default");
          new_tags=g_list_append(new_tags, (void *)return_value_gtk_text_tag_table_lookup$9);
        }

        else
        {
          return_value_strcmp$11=strcmp(name, "inverse_fg");
          if(return_value_strcmp$11 == 0)
          {
            bg_changed = (signed int)!(0 != 0);
            struct _GtkTextTag *return_value_gtk_text_tag_table_lookup$10;
            return_value_gtk_text_tag_table_lookup$10=gtk_text_tag_table_lookup(tab, "fg_default");
            new_tags=g_list_append(new_tags, (void *)return_value_gtk_text_tag_table_lookup$10);
          }

          else
            new_tags=g_list_append(new_tags, (void *)tag);
        }
      }
    }
    g_free((void *)name);
  }
  if(bg_changed == 0)
  {
    struct _GtkTextTag *return_value_gtk_text_tag_table_lookup$15;
    return_value_gtk_text_tag_table_lookup$15=gtk_text_tag_table_lookup(tab, "inverse_bg");
    new_tags=g_list_append(new_tags, (void *)return_value_gtk_text_tag_table_lookup$15);
  }

  if(fg_changed == 0)
  {
    struct _GtkTextTag *return_value_gtk_text_tag_table_lookup$16;
    return_value_gtk_text_tag_table_lookup$16=gtk_text_tag_table_lookup(tab, "inverse_fg");
    new_tags=g_list_append(new_tags, (void *)return_value_gtk_text_tag_table_lookup$16);
  }

  g_list_free(tags);
  return new_tags;
}

// gm_world_text_view_tags_overlap
// file widgets/gm-world-text-view.c line 963
static signed int gm_world_text_view_tags_overlap(struct _GtkTextTag *t1, struct _GtkTextTag *t2)
{
  signed int i = 0;
  signed int val1;
  signed int val2;
  while(!(tag_checks[(signed long int)i] == ((const char *)NULL)))
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)t1, (unsigned long int)(20 << 2));
    g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, tag_checks[(signed long int)i], &val1, (void *)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)t2, (unsigned long int)(20 << 2));
    g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$2, tag_checks[(signed long int)i], &val2, (void *)0);
    if(!(val1 == 0) && !(val2 == 0))
      return (signed int)!(0 != 0);

    i = i + 1;
  }
  return 0;
}

// gm_world_text_view_tags_remove_bold
// file widgets/gm-world-text-view.c line 1000
static struct _GList * gm_world_text_view_tags_remove_bold(struct _GmWorldTextView *view, struct _GList *tags)
{
  struct _GList *t;
  t=g_list_copy(tags);
  struct _GList *item;
  char *name;
  item = t;
  unsigned long int return_value_strlen$2;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)item->data, (unsigned long int)(20 << 2));
    g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, "name", &name, (void *)0);
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(name, "fg_", (unsigned long int)3);
    if(return_value_strncmp$3 == 0)
    {
      return_value_strlen$2=strlen(name);
      if((signed int)name[-1l + (signed long int)return_value_strlen$2] == 104)
        tags=g_list_remove(tags, item->data);

    }

    g_free((void *)name);
  }
  g_list_free(t);
  return tags;
}

// gm_world_text_view_tags_remove_obsolete
// file widgets/gm-world-text-view.c line 982
static struct _GList * gm_world_text_view_tags_remove_obsolete(struct _GmWorldTextView *view, struct _GList *tags, struct _GtkTextTag *tag)
{
  struct _GList *t;
  t=g_list_copy(tags);
  struct _GList *item;
  struct _GtkTextTag *tag2;
  item = t;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    unsigned long int return_value_gtk_text_tag_get_type$1;
    return_value_gtk_text_tag_get_type$1=gtk_text_tag_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_text_tag_get_type$1);
    tag2 = (struct _GtkTextTag *)return_value_g_type_check_instance_cast$2;
    signed int return_value_gm_world_text_view_tags_overlap$3;
    return_value_gm_world_text_view_tags_overlap$3=gm_world_text_view_tags_overlap(tag, tag2);
    if(!(return_value_gm_world_text_view_tags_overlap$3 == 0))
      tags=g_list_remove(tags, (const void *)tag2);

  }
  g_list_free(t);
  return tags;
}

// gm_world_text_view_update_color_tag
// file widgets/gm-world-text-view.c line 478
static void gm_world_text_view_update_color_tag(struct _GmWorldTextView *view, const char *name, struct _GtkTextTag *tag)
{
  struct _GtkTextBuffer *buf;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  struct _GtkTextTagTable *table;
  table=gtk_text_buffer_get_tag_table(buf);
  struct _GdkColor col;
  if(tag == ((struct _GtkTextTag *)NULL))
    tag=gtk_text_tag_table_lookup(table, name);

  if(!(view->priv->color_table == ((struct _GmColorTable *)NULL)))
    gm_color_table_get(view->priv->color_table, name, &col);

  if((signed int)*name == 102)
  {
    if(view->priv->color_table == ((struct _GmColorTable *)NULL))
      gdk_color_parse("#ffffff", &col);

    g_object_set((void *)tag, "foreground-gdk", &col, (void *)0);
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(name, "fg_default");
    if(return_value_strcmp$3 == 0)
    {
      tag=gtk_text_tag_table_lookup(table, "inverse_bg");
      g_object_set((void *)tag, "background-gdk", &col, (void *)0);
    }

  }

  else
  {
    if(view->priv->color_table == ((struct _GmColorTable *)NULL))
      gdk_color_parse("#000000", &col);

    g_object_set((void *)tag, "background-gdk", &col, (void *)0);
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(name, "bg_default");
    if(!(return_value_strcmp$4 == 0))
    {
      tag=gtk_text_tag_table_lookup(table, "inverse_fg");
      g_object_set((void *)tag, "foreground-gdk", &col, (void *)0);
    }

  }
}

// gm_world_text_view_update_font
// file widgets/gm-world-text-view.c line 690
static void gm_world_text_view_update_font(struct _GmWorldTextView *view)
{
  struct _PangoFontDescription *f;
  const char *return_value_gm_color_table_font_description$1;
  return_value_gm_color_table_font_description$1=gm_color_table_font_description(view->priv->color_table);
  f=pango_font_description_from_string(return_value_gm_color_table_font_description$1);
  if(!(f == ((struct _PangoFontDescription *)NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$2);
    gtk_widget_modify_font((struct _GtkWidget *)return_value_g_type_check_instance_cast$3, f);
    pango_font_description_free(f);
  }

}

// gm_world_text_view_update_tags
// file widgets/gm-world-text-view.c line 658
static void gm_world_text_view_update_tags(struct _GmWorldTextView *view)
{
  signed int i = 0;
  for( ; !(i >= 27); i = i + 1)
    gm_world_text_view_update_color_tag(view, ansi_colors[(signed long int)i].name, (struct _GtkTextTag *)(void *)0);
}

// gm_world_triggers
// file ./gm-world.h line 111
struct _GmTriggers * gm_world_triggers(struct _GmWorld *world)
{
  return world->priv->triggers;
}

// gm_world_triggers_subst
// file gm-world.c line 856
char * gm_world_triggers_subst(const char *data, const char *text, struct anonymous$17 *matches, signed int nummatches)
{
  char *tmp = (char *)data;
  char *p;
  char *ptr;
  char *tmp2;
  struct _GString *result = (struct _GString *)(void *)0;
  signed int n;
  unsigned int c;
  result=g_string_new((const char *)(void *)0);
  signed int return_value_g_unichar_isdigit$3;
  do
  {
    p=g_utf8_strchr(tmp, (signed long int)-1, (unsigned int)92);
    if(p == ((char *)NULL))
      break;

    n = 0;
    ptr = (char *)(p + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)p)]);
    signed long int return_value_g_utf8_strlen$1;
    return_value_g_utf8_strlen$1=g_utf8_strlen(tmp, (signed long int)-1);
    signed long int return_value_g_utf8_strlen$2;
    return_value_g_utf8_strlen$2=g_utf8_strlen(p, (signed long int)-1);
    g_string_append_len(result, tmp, return_value_g_utf8_strlen$1 - return_value_g_utf8_strlen$2);
    unsigned int return_value_g_utf8_get_char$6;
    return_value_g_utf8_get_char$6=g_utf8_get_char(ptr);
    signed int return_value_g_unichar_isdigit$7;
    return_value_g_unichar_isdigit$7=g_unichar_isdigit(return_value_g_utf8_get_char$6);
    if(!(return_value_g_unichar_isdigit$7 == 0))
    {
      do
      {
        c=g_utf8_get_char(ptr);
        if(c == 0u)
          break;

        return_value_g_unichar_isdigit$3=g_unichar_isdigit(c);
        if(return_value_g_unichar_isdigit$3 == 0)
          break;

        signed int return_value_g_unichar_digit_value$4;
        return_value_g_unichar_digit_value$4=g_unichar_digit_value(c);
        n = n * 10 + return_value_g_unichar_digit_value$4;
        ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
      }
      while((_Bool)1);
      if(!(n >= nummatches))
      {
        char *return_value_g_utf8_offset_to_pointer$5;
        return_value_g_utf8_offset_to_pointer$5=g_utf8_offset_to_pointer(text, (signed long int)(matches + (signed long int)n)->rm_so);
        tmp2=g_strndup(return_value_g_utf8_offset_to_pointer$5, (unsigned long int)(matches + (signed long int)n)->rm_eo);
        g_string_append(result, tmp2);
        g_free((void *)tmp2);
      }

      tmp = ptr;
    }

    else
      tmp = ptr;
  }
  while((_Bool)1);
  g_string_append(result, tmp);
  tmp = result->str;
  g_string_free(result, 0);
  return tmp;
}

// gm_world_unload
// file ./gm-world.h line 103
void gm_world_unload(struct _GmWorld *world)
{
  if(!(world->priv->loaded == 0))
  {
    world->priv->loaded = 0;
    gm_world_disconnect(world);
    while(!(world->priv->editors == ((struct _GSList *)NULL)))
    {
      unsigned long int return_value_gm_editor_get_type$1;
      return_value_gm_editor_get_type$1=gm_editor_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)world->priv->editors->data, return_value_gm_editor_get_type$1);
      gm_world_remove_editor(world, (struct _GmEditor *)return_value_g_type_check_instance_cast$2);
    }
    if(!(world->priv->reconnect_id == 0u))
    {
      g_source_remove(world->priv->reconnect_id);
      world->priv->reconnect_id = (unsigned int)0;
    }

    g_signal_emit((void *)world, world_signals[(signed long int)2], (unsigned int)0);
    if(!(world->priv->flush_history_id == 0u))
    {
      g_source_remove(world->priv->flush_history_id);
      flush_history_cb((void *)world);
    }

  }

}

// gm_world_view_buffer
// file widgets/gm-world-view.h line 77
struct _GtkTextBuffer * gm_world_view_buffer(struct _GmWorldView *view)
{
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_world, return_value_gtk_text_view_get_type$1);
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$3;
  return_value_gtk_text_view_get_buffer$3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  return return_value_gtk_text_view_get_buffer$3;
}

// gm_world_view_can_find
// file widgets/gm-world-view.c line 552
signed int gm_world_view_can_find(struct _GmWorldView *view)
{
  signed int np;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  np=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gm_world_view_page_can_find$3;
  return_value_gm_world_view_page_can_find$3=gm_world_view_page_can_find(view, np);
  return return_value_gm_world_view_page_can_find$3;
}

// gm_world_view_can_replace
// file widgets/gm-world-view.c line 653
signed int gm_world_view_can_replace(struct _GmWorldView *view)
{
  signed int np;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  np=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gm_world_view_page_can_replace$3;
  return_value_gm_world_view_page_can_replace$3=gm_world_view_page_can_replace(view, np);
  return return_value_gm_world_view_page_can_replace$3;
}

// gm_world_view_change_font_size
// file widgets/gm-world-view.c line 721
void gm_world_view_change_font_size(struct _GmWorldView *view, signed int size_change)
{
  struct _GtkStyle *style;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$1);
  style=gtk_widget_get_style((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  struct _PangoFontDescription *desc = style->font_desc;
  struct _PangoFontDescription *copy;
  copy=pango_font_description_copy(desc);
  char *new_font;
  signed int return_value_pango_font_description_get_size$3;
  return_value_pango_font_description_get_size$3=pango_font_description_get_size(copy);
  pango_font_description_set_size(copy, return_value_pango_font_description_get_size$3 + size_change * 1024);
  new_font=pango_font_description_to_string(copy);
  struct _GmApp *return_value_gm_app_instance$4;
  return_value_gm_app_instance$4=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$5;
  return_value_gm_app_color_table$5=gm_app_color_table(return_value_gm_app_instance$4);
  gm_color_table_set_font_description(return_value_gm_app_color_table$5, new_font);
  pango_font_description_free(copy);
  g_free((void *)new_font);
}

// gm_world_view_class_init
// file widgets/gm-world-view.c line 201
static void gm_world_view_class_init(struct _GmWorldViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  struct _GtkObjectClass *gtk_object_class;
  unsigned long int return_value_gtk_object_get_type$2;
  return_value_gtk_object_get_type$2=gtk_object_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_object_get_type$2);
  gtk_object_class = (struct _GtkObjectClass *)return_value_g_type_check_class_cast$3;
  struct _GtkContainerClass *container_class;
  unsigned long int return_value_gtk_container_get_type$4;
  return_value_gtk_container_get_type$4=gtk_container_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$5;
  return_value_g_type_check_class_cast$5=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_container_get_type$4);
  container_class = (struct _GtkContainerClass *)return_value_g_type_check_class_cast$5;
  object_class->finalize = gm_world_view_finalize;
  gtk_object_class->destroy = gm_world_view_destroy;
  unsigned long int return_value_gtk_notebook_get_type$6;
  return_value_gtk_notebook_get_type$6=gtk_notebook_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$7;
  return_value_g_type_check_class_cast$7=g_type_check_class_cast((struct _GTypeClass *)klass, return_value_gtk_notebook_get_type$6);
  ((struct _GtkNotebookClass *)return_value_g_type_check_class_cast$7)->switch_page = gm_world_view_switch_page;
  container_class->remove = gm_world_view_remove_page;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmWorldViewPrivate) /*72ul*/ );
}

// gm_world_view_class_intern_init
// file widgets/gm-world-view.c line 89
static void gm_world_view_class_intern_init(void *klass)
{
  gm_world_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmWorldView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmWorldView_private_offset);

  gm_world_view_class_init((struct _GmWorldViewClass *)klass);
}

// gm_world_view_create_input_text_view
// file widgets/gm-world-view.c line 257
struct _GtkWidget * gm_world_view_create_input_text_view(struct _GmWorldView *view)
{
  struct _GtkWidget *scrolled_window;
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  struct _GtkWidget *input_text_view;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$2;
  return_value_gm_app_color_table$2=gm_app_color_table(return_value_gm_app_instance$1);
  input_text_view=gm_world_input_view_new_with_color_table(return_value_gm_app_color_table$2);
  unsigned long int return_value_gtk_scrolled_window_get_type$3;
  return_value_gtk_scrolled_window_get_type$3=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$3);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$4, (enum anonymous$88)GTK_POLICY_NEVER, (enum anonymous$88)GTK_POLICY_NEVER);
  unsigned long int return_value_gtk_scrolled_window_get_type$5;
  return_value_gtk_scrolled_window_get_type$5=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$5);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$6, (enum anonymous$89)GTK_SHADOW_IN);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_container_get_type$7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, input_text_view);
  unsigned long int return_value_gm_world_input_view_get_type$9;
  return_value_gm_world_input_view_get_type$9=gm_world_input_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)input_text_view, return_value_gm_world_input_view_get_type$9);
  view->priv->text_view_input = (struct _GmWorldInputView *)return_value_g_type_check_instance_cast$10;
  g_signal_connect_data((void *)input_text_view, "key_press_event", (void (*)(void))on_gm_world_view_world_input_view_key_pressed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  return scrolled_window;
}

// gm_world_view_create_world_text_view
// file widgets/gm-world-view.c line 276
struct _GtkWidget * gm_world_view_create_world_text_view(struct _GmWorldView *view)
{
  struct _GtkWidget *world_text_view;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$2;
  return_value_gm_app_color_table$2=gm_app_color_table(return_value_gm_app_instance$1);
  world_text_view=gm_world_text_view_new_with_color_table(return_value_gm_app_color_table$2);
  struct _GtkWidget *scrolled_window;
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_scrolled_window_get_type$3;
  return_value_gtk_scrolled_window_get_type$3=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$3);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$4, (enum anonymous$88)GTK_POLICY_AUTOMATIC, (enum anonymous$88)GTK_POLICY_ALWAYS);
  unsigned long int return_value_gtk_scrolled_window_get_type$5;
  return_value_gtk_scrolled_window_get_type$5=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$5);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$6, (enum anonymous$89)GTK_SHADOW_IN);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_container_get_type$7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, world_text_view);
  unsigned long int return_value_gm_world_text_view_get_type$9;
  return_value_gm_world_text_view_get_type$9=gm_world_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)world_text_view, return_value_gm_world_text_view_get_type$9);
  view->priv->text_view_world = (struct _GmWorldTextView *)return_value_g_type_check_instance_cast$10;
  unsigned long int return_value_gtk_text_view_get_type$11;
  return_value_gtk_text_view_get_type$11=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_world, return_value_gtk_text_view_get_type$11);
  view->priv->text_scroller_world=gm_text_scroller_new((struct _GtkTextView *)return_value_g_type_check_instance_cast$12);
  g_signal_connect_data((void *)world_text_view, "scroll_event", (void (*)(void))on_gm_world_view_world_text_view_scroll_event, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world_text_view, "url_activate", (void (*)(void))on_gm_world_view_world_text_view_url_activate, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  return scrolled_window;
}

// gm_world_view_destroy
// file widgets/gm-world-view.c line 149
static void gm_world_view_destroy(struct _GtkObject *object)
{
  struct _GmWorldView *view;
  unsigned long int return_value_gm_world_view_get_type$1;
  return_value_gm_world_view_get_type$1=gm_world_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_view_get_type$1);
  view = (struct _GmWorldView *)return_value_g_type_check_instance_cast$2;
  signed int tmp_statement_expression$3;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)view;
  unsigned long int __t;
  __t=gm_world_view_get_type();
  signed int __r;
  _Bool tmp_if_expr$4;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$3 = __r;
  _Bool tmp_if_expr$7;
  signed int tmp_statement_expression$5;
  _Bool tmp_if_expr$6;
  if(tmp_statement_expression$3 == 0)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    struct _GTypeInstance *gm_world_view_destroy$$1$$2$$__inst = (struct _GTypeInstance *)view->priv->hpaned;
    unsigned long int gm_world_view_destroy$$1$$2$$__t;
    gm_world_view_destroy$$1$$2$$__t=gtk_widget_get_type();
    signed int gm_world_view_destroy$$1$$2$$__r;
    if(gm_world_view_destroy$$1$$2$$__inst == ((struct _GTypeInstance *)NULL))
      gm_world_view_destroy$$1$$2$$__r = 0;

    else
    {
      if(!(gm_world_view_destroy$$1$$2$$__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$6 = gm_world_view_destroy$$1$$2$$__inst->g_class->g_type == gm_world_view_destroy$$1$$2$$__t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        gm_world_view_destroy$$1$$2$$__r = (signed int)!(0 != 0);

      else
        gm_world_view_destroy$$1$$2$$__r=g_type_check_instance_is_a(gm_world_view_destroy$$1$$2$$__inst, gm_world_view_destroy$$1$$2$$__t);
    }
    tmp_statement_expression$5 = gm_world_view_destroy$$1$$2$$__r;
    tmp_if_expr$7 = !(tmp_statement_expression$5 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr$7)
  {
    struct _GmOptions *return_value_gm_world_options$8;
    return_value_gm_world_options$8=gm_world_options(view->priv->world);
    unsigned long int return_value_gtk_widget_get_type$9;
    return_value_gtk_widget_get_type$9=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hpaned, return_value_gtk_widget_get_type$9);
    unsigned long int return_value_gtk_paned_get_type$11;
    return_value_gtk_paned_get_type$11=gtk_paned_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hpaned, return_value_gtk_paned_get_type$11);
    signed int return_value_gtk_paned_get_position$13;
    return_value_gtk_paned_get_position$13=gtk_paned_get_position((struct _GtkPaned *)return_value_g_type_check_instance_cast$12);
    gm_options_set_int(return_value_gm_world_options$8, "pane_position", ((struct _GtkWidget *)return_value_g_type_check_instance_cast$10)->allocation.width - return_value_gtk_paned_get_position$13);
    struct _GmOptions *return_value_gm_world_options$14;
    return_value_gm_world_options$14=gm_world_options(view->priv->world);
    gm_options_save(return_value_gm_world_options$14);
    unsigned long int return_value_gtk_object_get_type$17;
    return_value_gtk_object_get_type$17=gtk_object_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$18;
    return_value_g_type_check_class_cast$18=g_type_check_class_cast((struct _GTypeClass *)gm_world_view_parent_class, return_value_gtk_object_get_type$17);
    if(!(((struct _GtkObjectClass *)return_value_g_type_check_class_cast$18)->destroy == ((void (*)(struct _GtkObject *))NULL)))
    {
      unsigned long int return_value_gtk_object_get_type$15;
      return_value_gtk_object_get_type$15=gtk_object_get_type();
      struct _GTypeClass *return_value_g_type_check_class_cast$16;
      return_value_g_type_check_class_cast$16=g_type_check_class_cast((struct _GTypeClass *)gm_world_view_parent_class, return_value_gtk_object_get_type$15);
      ((struct _GtkObjectClass *)return_value_g_type_check_class_cast$16)->destroy(object);
    }

  }

}

// gm_world_view_editor_create_view
// file widgets/gm-world-view.c line 358
struct _GtkWidget * gm_world_view_editor_create_view(struct _GmWorldView *view, struct _GmEditor *editor)
{
  struct _GtkWidget *editor_view;
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$1);
  const char *return_value_gm_options_get$10;
  return_value_gm_options_get$10=gm_options_get(options, "editor_alternative");
  signed int return_value_strcmp$11;
  return_value_strcmp$11=strcmp(return_value_gm_options_get$10, "0");
  if(!(return_value_strcmp$11 == 0))
  {
    signed int return_value_gm_options_get_int$6;
    return_value_gm_options_get_int$6=gm_options_get_int(options, "editor_embed");
    if(!(return_value_gm_options_get_int$6 == 0))
    {
      struct _GmEmbeddedView *return_value_gm_embedded_view_new$2;
      return_value_gm_embedded_view_new$2=gm_embedded_view_new(view->priv->world, editor);
      unsigned long int return_value_gtk_widget_get_type$3;
      return_value_gtk_widget_get_type$3=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_embedded_view_new$2, return_value_gtk_widget_get_type$3);
      editor_view = (struct _GtkWidget *)return_value_g_type_check_instance_cast$4;
    }

    else
    {
      struct _GmExternalView *return_value_gm_external_view_new$5;
      return_value_gm_external_view_new$5=gm_external_view_new(view->priv->world, editor);
      view->priv->external_editors=g_list_append(view->priv->external_editors, (void *)return_value_gm_external_view_new$5);
      return (struct _GtkWidget *)(void *)0;
    }
  }

  else
  {
    struct _GmEditorView *return_value_gm_editor_view_new$7;
    return_value_gm_editor_view_new$7=gm_editor_view_new(view->priv->world, editor);
    unsigned long int return_value_gtk_widget_get_type$8;
    return_value_gtk_widget_get_type$8=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_editor_view_new$7, return_value_gtk_widget_get_type$8);
    editor_view = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
    g_signal_connect_data((void *)editor_view, "modified-changed", (void (*)(void))on_gm_world_view_editor_view_modified_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  }
  gtk_widget_show(editor_view);
  return editor_view;
}

// gm_world_view_editor_page_new
// file widgets/gm-world-view.c line 384
struct _GtkWidget * gm_world_view_editor_page_new(struct _GmWorldView *view, struct _GmEditor *editor)
{
  struct _GtkWidget *label;
  struct _GtkWidget *editor_view;
  struct _GmLabelInfo info;
  const char *icon;
  signed int return_value_gm_editor_is_code$1;
  return_value_gm_editor_is_code$1=gm_editor_is_code(editor);
  if(!(return_value_gm_editor_is_code$1 == 0))
    icon = "editor_verb.xpm";

  else
    icon = "editor_text.xpm";
  char *return_value_gm_editor_name$2;
  return_value_gm_editor_name$2=gm_editor_name(editor);
  label=gm_create_tab_label("editor_verb.xpm", return_value_gm_editor_name$2, (signed int)!(0 != 0), &info);
  editor_view=gm_world_view_editor_create_view(view, editor);
  if(editor_view == ((struct _GtkWidget *)NULL))
    return (struct _GtkWidget *)(void *)0;

  else
  {
    gm_world_view_ensure_show_tabs(view);
    unsigned long int return_value_gtk_notebook_get_type$3;
    return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$3);
    gtk_notebook_append_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, editor_view, label);
    unsigned long int return_value_gtk_notebook_get_type$5;
    return_value_gtk_notebook_get_type$5=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$5);
    unsigned long int return_value_gtk_notebook_get_type$7;
    return_value_gtk_notebook_get_type$7=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$7);
    signed int return_value_gtk_notebook_page_num$9;
    return_value_gtk_notebook_page_num$9=gtk_notebook_page_num((struct _GtkNotebook *)return_value_g_type_check_instance_cast$8, editor_view);
    gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$6, return_value_gtk_notebook_page_num$9);
    g_signal_connect_data((void *)info.button_exit, "clicked", (void (*)(void))on_gm_world_view_editor_view_close_clicked, (void *)editor_view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    return editor_view;
  }
}

// gm_world_view_ensure_show_tabs
// file widgets/gm-world-view.c line 215
static void gm_world_view_ensure_show_tabs(struct _GmWorldView *view)
{
  unsigned long int return_value_gtk_notebook_get_type$3;
  return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$3);
  signed int return_value_gtk_notebook_get_show_tabs$5;
  return_value_gtk_notebook_get_show_tabs$5=gtk_notebook_get_show_tabs((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4);
  if(return_value_gtk_notebook_get_show_tabs$5 == 0)
  {
    unsigned long int return_value_gtk_notebook_get_type$1;
    return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
    gtk_notebook_set_show_tabs((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2, (signed int)!(0 != 0));
  }

}

// gm_world_view_finalize
// file widgets/gm-world-view.c line 108
static void gm_world_view_finalize(struct _GObject *object)
{
  struct _GmWorldView *view;
  unsigned long int return_value_gm_world_view_get_type$1;
  return_value_gm_world_view_get_type$1=gm_world_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_world_view_get_type$1);
  view = (struct _GmWorldView *)return_value_g_type_check_instance_cast$2;
  struct _GList *ext = view->priv->external_editors;
  for( ; !(ext == ((struct _GList *)NULL)); ext = ext->next)
    gm_external_view_destroy((struct _GmExternalView *)ext->data);
  if(!(view->priv->status_timeout == 0u))
    g_source_remove(view->priv->status_timeout);

  g_free((void *)view->priv->status_msg);
  g_list_free(view->priv->external_editors);
  g_signal_handlers_disconnect_matched((void *)view->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_text_received, (void *)view);
  g_signal_handlers_disconnect_matched((void *)view->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_error, (void *)view);
  g_signal_handlers_disconnect_matched((void *)view->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_state_changing, (void *)view);
  g_signal_handlers_disconnect_matched((void *)view->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_active_changed, (void *)view);
  g_signal_handlers_disconnect_matched((void *)view->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_highlight, (void *)view);
  g_signal_handlers_disconnect_matched((void *)view->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_editor_added, (void *)view);
  g_signal_handlers_disconnect_matched((void *)view->priv->world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_editor_removed, (void *)view);
  struct _GmMcpSession *return_value_gm_world_get_mcp_session$3;
  return_value_gm_world_get_mcp_session$3=gm_world_get_mcp_session(view->priv->world);
  g_signal_handlers_disconnect_matched((void *)return_value_gm_world_get_mcp_session$3, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_view_world_mcp_package_created, (void *)view);
  g_object_unref((void *)view->priv->world);
  struct _GTypeClass *return_value_g_type_check_class_cast$4;
  return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)gm_world_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$4)->finalize(object);
}

// gm_world_view_find_first
// file widgets/gm-world-view.h line 59
signed int gm_world_view_find_first(struct _GmWorldView *view, const char *str, enum _GmSearchableSearchFlags flags)
{
  signed int np;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  np=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  struct _GtkWidget *page;
  struct _GmSearchable *sea;
  signed int tmp_statement_expression$12;
  _Bool tmp_if_expr$13;
  if(np == 0)
  {
    unsigned long int return_value_gm_searchable_get_type$3;
    return_value_gm_searchable_get_type$3=gm_searchable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gm_searchable_get_type$3);
    signed int return_value_gm_searchable_find_first$5;
    return_value_gm_searchable_find_first$5=gm_searchable_find_first((struct _GmSearchable *)return_value_g_type_check_instance_cast$4, str, flags);
    return return_value_gm_searchable_find_first$5;
  }

  else
  {
    unsigned long int return_value_gtk_notebook_get_type$6;
    return_value_gtk_notebook_get_type$6=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$6);
    page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$7, np);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$13 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$13 = (_Bool)0;
      if(tmp_if_expr$13)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$12 = __r;
    if(!(tmp_statement_expression$12 == 0))
    {
      unsigned long int return_value_gm_searchable_get_type$8;
      return_value_gm_searchable_get_type$8=gm_searchable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_searchable_get_type$8);
      sea = (struct _GmSearchable *)return_value_g_type_check_instance_cast$9;
      signed int return_value_gm_searchable_can_find$11;
      return_value_gm_searchable_can_find$11=gm_searchable_can_find(sea);
      if(!(return_value_gm_searchable_can_find$11 == 0))
      {
        signed int return_value_gm_searchable_find_first$10;
        return_value_gm_searchable_find_first$10=gm_searchable_find_first(sea, str, flags);
        return return_value_gm_searchable_find_first$10;
      }

    }

  }
  return 0;
}

// gm_world_view_find_next
// file widgets/gm-world-view.h line 61
signed int gm_world_view_find_next(struct _GmWorldView *view, const char *str, enum _GmSearchableSearchFlags flags)
{
  signed int np;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  np=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  struct _GtkWidget *page;
  struct _GmSearchable *sea;
  signed int tmp_statement_expression$12;
  _Bool tmp_if_expr$13;
  if(np == 0)
  {
    unsigned long int return_value_gm_searchable_get_type$3;
    return_value_gm_searchable_get_type$3=gm_searchable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gm_searchable_get_type$3);
    signed int return_value_gm_searchable_find_next$5;
    return_value_gm_searchable_find_next$5=gm_searchable_find_next((struct _GmSearchable *)return_value_g_type_check_instance_cast$4, str, flags);
    return return_value_gm_searchable_find_next$5;
  }

  else
  {
    unsigned long int return_value_gtk_notebook_get_type$6;
    return_value_gtk_notebook_get_type$6=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$6);
    page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$7, np);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$13 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$13 = (_Bool)0;
      if(tmp_if_expr$13)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$12 = __r;
    if(!(tmp_statement_expression$12 == 0))
    {
      unsigned long int return_value_gm_searchable_get_type$8;
      return_value_gm_searchable_get_type$8=gm_searchable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_searchable_get_type$8);
      sea = (struct _GmSearchable *)return_value_g_type_check_instance_cast$9;
      signed int return_value_gm_searchable_can_find$11;
      return_value_gm_searchable_can_find$11=gm_searchable_can_find(sea);
      if(!(return_value_gm_searchable_can_find$11 == 0))
      {
        signed int return_value_gm_searchable_find_next$10;
        return_value_gm_searchable_find_next$10=gm_searchable_find_next(sea, str, flags);
        return return_value_gm_searchable_find_next$10;
      }

    }

  }
  return 0;
}

// gm_world_view_flash_status
// file widgets/gm-world-view.c line 316
void gm_world_view_flash_status(struct _GmWorldView *view, const char *status, unsigned int seconds)
{
  ;
}

// gm_world_view_get_type
// file widgets/gm-world-view.h line 56
unsigned long int gm_world_view_get_type(void)
{
  _Bool tmp_statement_expression$4;
  void *tmp_statement_expression$5;
  signed int return_value___atomic_load_8$6;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$6=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$5 = (void *)return_value___atomic_load_8$6;
  _Bool tmp_if_expr$8;
  signed int return_value_g_once_init_enter$7;
  if(tmp_statement_expression$5 == NULL)
  {
    return_value_g_once_init_enter$7=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$8 = return_value_g_once_init_enter$7 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  tmp_statement_expression$4 = tmp_if_expr$8;
  if(tmp_statement_expression$4)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_notebook_get_type$1;
    return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmWorldView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_notebook_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmWorldViewClass) /*896ul*/ , (void (*)(void *, void *))gm_world_view_class_intern_init, (unsigned int)sizeof(struct _GmWorldView) /*184ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_world_view_init, (enum anonymous)0);
    const struct _GInterfaceInfo g_implement_interface_info = { .interface_init=(void (*)(void *, void *))gm_world_view_searchable_iface_init, .interface_finalize=(void (*)(void *, void *))(void *)0,
    .interface_data=(void *)0 };
    unsigned long int return_value_gm_searchable_get_type$3;
    return_value_gm_searchable_get_type$3=gm_searchable_get_type();
    g_type_add_interface_static(g_define_type_id, return_value_gm_searchable_get_type$3, &g_implement_interface_info);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_world_view_hpaned
// file widgets/gm-world-view.c line 700
struct _GtkHPaned * gm_world_view_hpaned(struct _GmWorldView *view)
{
  return view->priv->hpaned;
}

// gm_world_view_init
// file widgets/gm-world-view.c line 471
static void gm_world_view_init(struct _GmWorldView *view)
{
  struct _GtkWidget *label;
  struct _GmLabelInfo info;
  unsigned long int return_value_gm_world_view_get_type$1;
  return_value_gm_world_view_get_type$1=gm_world_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)view, return_value_gm_world_view_get_type$1);
  view->priv = (struct _GmWorldViewPrivate *)return_value_g_type_instance_get_private$2;
  unsigned long int return_value_gtk_notebook_get_type$3;
  return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$3);
  gtk_notebook_set_show_tabs((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, 0);
  unsigned long int return_value_gtk_notebook_get_type$5;
  return_value_gtk_notebook_get_type$5=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$5);
  gtk_notebook_set_show_border((struct _GtkNotebook *)return_value_g_type_check_instance_cast$6, 0);
  unsigned long int return_value_gtk_notebook_get_type$7;
  return_value_gtk_notebook_get_type$7=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$7);
  gtk_notebook_set_tab_pos((struct _GtkNotebook *)return_value_g_type_check_instance_cast$8, (enum anonymous$46)GTK_POS_BOTTOM);
  unsigned long int return_value_gtk_notebook_get_type$9;
  return_value_gtk_notebook_get_type$9=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$9);
  gtk_notebook_set_scrollable((struct _GtkNotebook *)return_value_g_type_check_instance_cast$10, (signed int)!(0 != 0));
  char *return_value_gettext$11;
  return_value_gettext$11=gettext("World");
  label=gm_create_tab_label("world.svg", return_value_gettext$11, 0, &info);
  unsigned long int return_value_gtk_notebook_get_type$12;
  return_value_gtk_notebook_get_type$12=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$12);
  struct _GtkWidget *return_value_gm_world_view_world_page_new$14;
  return_value_gm_world_view_world_page_new$14=gm_world_view_world_page_new(view);
  gtk_notebook_append_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$13, return_value_gm_world_view_world_page_new$14, label);
  g_signal_connect_data((void *)view->priv->hpaned, "map", (void (*)(void))gm_world_view_restore_paned_size, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
}

// gm_world_view_input
// file widgets/gm-world-view.h line 73
struct _GmWorldInputView * gm_world_view_input(struct _GmWorldView *view)
{
  return view->priv->text_view_input;
}

// gm_world_view_input_grab_focus
// file widgets/gm-world-view.c line 169
static signed int gm_world_view_input_grab_focus(struct _GmWorldView *view)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_input, return_value_gtk_widget_get_type$1);
  gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  return 0;
}

// gm_world_view_log_page_new
// file widgets/gm-world-view.c line 322
struct _GtkWidget * gm_world_view_log_page_new(struct _GmWorldView *view, const char *filename)
{
  char *text;
  text=gm_read_file(filename);
  char *base;
  struct _GmLabelInfo info;
  struct _GtkWidget *log_view;
  struct _GtkWidget *label;
  if(text == ((char *)NULL))
    return (struct _GtkWidget *)(void *)0;

  else
  {
    base=g_path_get_basename(filename);
    label=gm_create_tab_label("editor_text.xpm", base, (signed int)!(0 != 0), &info);
    g_free((void *)base);
    struct _GmLogView *return_value_gm_log_view_new$1;
    return_value_gm_log_view_new$1=gm_log_view_new();
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_log_view_new$1, return_value_gtk_widget_get_type$2);
    log_view = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    gtk_widget_show(log_view);
    unsigned long int return_value_gtk_notebook_get_type$4;
    return_value_gtk_notebook_get_type$4=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$4);
    gtk_notebook_append_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$5, log_view, label);
    gm_world_view_ensure_show_tabs(view);
    unsigned long int return_value_gtk_notebook_get_type$6;
    return_value_gtk_notebook_get_type$6=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$6);
    unsigned long int return_value_gtk_notebook_get_type$8;
    return_value_gtk_notebook_get_type$8=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$8);
    signed int return_value_gtk_notebook_page_num$10;
    return_value_gtk_notebook_page_num$10=gtk_notebook_page_num((struct _GtkNotebook *)return_value_g_type_check_instance_cast$9, log_view);
    gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$7, return_value_gtk_notebook_page_num$10);
    g_signal_connect_data((void *)info.button_exit, "clicked", (void (*)(void))on_gm_world_view_log_view_close_clicked, (void *)log_view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    unsigned long int return_value_gm_log_view_get_type$11;
    return_value_gm_log_view_get_type$11=gm_log_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)log_view, return_value_gm_log_view_get_type$11);
    gm_log_view_set_text((struct _GmLogView *)return_value_g_type_check_instance_cast$12, text);
    g_free((void *)text);
    return log_view;
  }
}

// gm_world_view_new
// file widgets/gm-world-view.h line 57
struct _GtkWidget * gm_world_view_new(struct _GmWorld *world)
{
  struct _GmWorldView *view;
  unsigned long int return_value_gm_world_view_get_type$1;
  return_value_gm_world_view_get_type$1=gm_world_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_world_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_world_view_get_type$3;
  return_value_gm_world_view_get_type$3=gm_world_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_world_view_get_type$3);
  view = (struct _GmWorldView *)return_value_g_type_check_instance_cast$4;
  void *return_value_g_object_ref$5;
  return_value_g_object_ref$5=g_object_ref((void *)world);
  view->priv->world = (struct _GmWorld *)return_value_g_object_ref$5;
  struct _GList **return_value_gm_world_history$6;
  return_value_gm_world_history$6=gm_world_history(view->priv->world);
  gm_world_input_view_set_history(view->priv->text_view_input, return_value_gm_world_history$6);
  g_signal_connect_data((void *)world, "text_received", (void (*)(void))on_gm_world_view_world_text_received, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "world_error", (void (*)(void))on_gm_world_view_world_error, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "state_changing", (void (*)(void))on_gm_world_view_world_state_changing, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "notify::active", (void (*)(void))on_gm_world_view_world_active_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "highlight", (void (*)(void))on_gm_world_view_world_highlight, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "editor_added", (void (*)(void))on_gm_world_view_world_editor_added, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "editor_removed", (void (*)(void))on_gm_world_view_world_editor_removed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  struct _GmMcpSession *return_value_gm_world_get_mcp_session$7;
  return_value_gm_world_get_mcp_session$7=gm_world_get_mcp_session(world);
  g_signal_connect_data((void *)return_value_gm_world_get_mcp_session$7, "package_created", (void (*)(void))on_gm_world_view_world_mcp_package_created, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)view->priv->text_view_input, "text_activate", (void (*)(void))on_gm_world_input_view_world_text_activate, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$8);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
}

// gm_world_view_open_log
// file widgets/gm-world-view.h line 80
void gm_world_view_open_log(struct _GmWorldView *view, const char *filename)
{
  gm_world_view_log_page_new(view, filename);
}

// gm_world_view_page_can_find
// file widgets/gm-world-view.h line 64
signed int gm_world_view_page_can_find(struct _GmWorldView *view, signed int page_num)
{
  struct _GtkWidget *page;
  struct _GmSearchable *sea;
  signed int tmp_statement_expression$9;
  _Bool tmp_if_expr$10;
  if(page_num == -1)
    return 0;

  else
    if(page_num == 0)
    {
      unsigned long int return_value_gm_searchable_get_type$1;
      return_value_gm_searchable_get_type$1=gm_searchable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gm_searchable_get_type$1);
      signed int return_value_gm_searchable_can_find$3;
      return_value_gm_searchable_can_find$3=gm_searchable_can_find((struct _GmSearchable *)return_value_g_type_check_instance_cast$2);
      return return_value_gm_searchable_can_find$3;
    }

    else
    {
      unsigned long int return_value_gtk_notebook_get_type$4;
      return_value_gtk_notebook_get_type$4=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$4);
      page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$5, page_num);
      struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
      unsigned long int __t;
      __t=gm_searchable_get_type();
      signed int __r;
      if(__inst == ((struct _GTypeInstance *)NULL))
        __r = 0;

      else
      {
        if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
          tmp_if_expr$10 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$10 = (_Bool)0;
        if(tmp_if_expr$10)
          __r = (signed int)!(0 != 0);

        else
          __r=g_type_check_instance_is_a(__inst, __t);
      }
      tmp_statement_expression$9 = __r;
      if(!(tmp_statement_expression$9 == 0))
      {
        unsigned long int return_value_gm_searchable_get_type$6;
        return_value_gm_searchable_get_type$6=gm_searchable_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
        return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_searchable_get_type$6);
        sea = (struct _GmSearchable *)return_value_g_type_check_instance_cast$7;
        signed int return_value_gm_searchable_can_find$8;
        return_value_gm_searchable_can_find$8=gm_searchable_can_find(sea);
        return return_value_gm_searchable_can_find$8;
      }

    }
  return 0;
}

// gm_world_view_page_can_replace
// file widgets/gm-world-view.h line 70
signed int gm_world_view_page_can_replace(struct _GmWorldView *view, signed int page_num)
{
  struct _GtkWidget *page;
  struct _GmSearchable *sea;
  signed int tmp_statement_expression$9;
  _Bool tmp_if_expr$10;
  if(page_num == -1)
    return 0;

  else
    if(page_num == 0)
    {
      unsigned long int return_value_gm_searchable_get_type$1;
      return_value_gm_searchable_get_type$1=gm_searchable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gm_searchable_get_type$1);
      signed int return_value_gm_searchable_can_replace$3;
      return_value_gm_searchable_can_replace$3=gm_searchable_can_replace((struct _GmSearchable *)return_value_g_type_check_instance_cast$2);
      return return_value_gm_searchable_can_replace$3;
    }

    else
    {
      unsigned long int return_value_gtk_notebook_get_type$4;
      return_value_gtk_notebook_get_type$4=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$4);
      page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$5, page_num);
      struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
      unsigned long int __t;
      __t=gm_searchable_get_type();
      signed int __r;
      if(__inst == ((struct _GTypeInstance *)NULL))
        __r = 0;

      else
      {
        if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
          tmp_if_expr$10 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$10 = (_Bool)0;
        if(tmp_if_expr$10)
          __r = (signed int)!(0 != 0);

        else
          __r=g_type_check_instance_is_a(__inst, __t);
      }
      tmp_statement_expression$9 = __r;
      if(!(tmp_statement_expression$9 == 0))
      {
        unsigned long int return_value_gm_searchable_get_type$6;
        return_value_gm_searchable_get_type$6=gm_searchable_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
        return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_searchable_get_type$6);
        sea = (struct _GmSearchable *)return_value_g_type_check_instance_cast$7;
        signed int return_value_gm_searchable_can_replace$8;
        return_value_gm_searchable_can_replace$8=gm_searchable_can_replace(sea);
        return return_value_gm_searchable_can_replace$8;
      }

    }
  return 0;
}

// gm_world_view_remove_page
// file widgets/gm-world-view.c line 188
static void gm_world_view_remove_page(struct _GtkContainer *container, struct _GtkWidget *page)
{
  struct _GtkNotebook *notebook;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)container, return_value_gtk_notebook_get_type$1);
  notebook = (struct _GtkNotebook *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_container_get_type$5;
  return_value_gtk_container_get_type$5=gtk_container_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$6;
  return_value_g_type_check_class_cast$6=g_type_check_class_cast((struct _GTypeClass *)gm_world_view_parent_class, return_value_gtk_container_get_type$5);
  if(!(((struct _GtkContainerClass *)return_value_g_type_check_class_cast$6)->remove == ((void (*)(struct _GtkContainer *, struct _GtkWidget *))NULL)))
  {
    unsigned long int return_value_gtk_container_get_type$3;
    return_value_gtk_container_get_type$3=gtk_container_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$4;
    return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)gm_world_view_parent_class, return_value_gtk_container_get_type$3);
    ((struct _GtkContainerClass *)return_value_g_type_check_class_cast$4)->remove(container, page);
  }

  signed int return_value_gtk_notebook_get_n_pages$7;
  return_value_gtk_notebook_get_n_pages$7=gtk_notebook_get_n_pages(notebook);
  if(return_value_gtk_notebook_get_n_pages$7 == 1)
    gtk_notebook_set_show_tabs(notebook, 0);

}

// gm_world_view_replace
// file widgets/gm-world-view.h line 66
signed int gm_world_view_replace(struct _GmWorldView *view, const char *replace)
{
  signed int np;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  np=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  struct _GtkWidget *page;
  struct _GmSearchable *sea;
  signed int tmp_statement_expression$9;
  _Bool tmp_if_expr$10;
  if(np == 0)
    return 0;

  else
  {
    unsigned long int return_value_gtk_notebook_get_type$3;
    return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$3);
    page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, np);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$10 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$9 = __r;
    if(!(tmp_statement_expression$9 == 0))
    {
      unsigned long int return_value_gm_searchable_get_type$5;
      return_value_gm_searchable_get_type$5=gm_searchable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_searchable_get_type$5);
      sea = (struct _GmSearchable *)return_value_g_type_check_instance_cast$6;
      signed int return_value_gm_searchable_can_replace$8;
      return_value_gm_searchable_can_replace$8=gm_searchable_can_replace(sea);
      if(!(return_value_gm_searchable_can_replace$8 == 0))
      {
        signed int return_value_gm_searchable_replace$7;
        return_value_gm_searchable_replace$7=gm_searchable_replace(sea, replace);
        return return_value_gm_searchable_replace$7;
      }

    }

  }
  return 0;
}

// gm_world_view_replace_all
// file widgets/gm-world-view.h line 67
signed int gm_world_view_replace_all(struct _GmWorldView *view, const char *str, const char *replace, enum _GmSearchableSearchFlags flags)
{
  signed int np;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  np=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  struct _GtkWidget *page;
  struct _GmSearchable *sea;
  signed int tmp_statement_expression$9;
  _Bool tmp_if_expr$10;
  if(np == 0)
    return 0;

  else
  {
    unsigned long int return_value_gtk_notebook_get_type$3;
    return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$3);
    page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, np);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
    unsigned long int __t;
    __t=gm_searchable_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$10 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$9 = __r;
    if(!(tmp_statement_expression$9 == 0))
    {
      unsigned long int return_value_gm_searchable_get_type$5;
      return_value_gm_searchable_get_type$5=gm_searchable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_searchable_get_type$5);
      sea = (struct _GmSearchable *)return_value_g_type_check_instance_cast$6;
      signed int return_value_gm_searchable_can_replace$8;
      return_value_gm_searchable_can_replace$8=gm_searchable_can_replace(sea);
      if(!(return_value_gm_searchable_can_replace$8 == 0))
      {
        signed int return_value_gm_searchable_replace_all$7;
        return_value_gm_searchable_replace_all$7=gm_searchable_replace_all(sea, str, replace, flags);
        return return_value_gm_searchable_replace_all$7;
      }

    }

  }
  return 0;
}

// gm_world_view_restore_paned_size
// file widgets/gm-world-view.c line 460
static void gm_world_view_restore_paned_size(struct _GtkWidget *widget, struct _GmWorldView *view)
{
  g_idle_add((signed int (*)(void *))paned_restore_size, (void *)view);
  g_signal_handlers_disconnect_matched((void *)widget, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)gm_world_view_restore_paned_size, (void *)view);
}

// gm_world_view_searchable_get_text_view
// file widgets/gm-world-view.c line 99
static struct _GtkTextView * gm_world_view_searchable_get_text_view(struct _GmSearchable *sea)
{
  struct _GmWorldView *view = (struct _GmWorldView *)sea;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)sea;
    unsigned long int __t;
    __t=gm_world_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"gm_world_view_searchable_get_text_view", "GM_IS_WORLD_VIEW(sea)");
      return (struct _GtkTextView *)(void *)0;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gtk_text_view_get_type$3;
  return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_world, return_value_gtk_text_view_get_type$3);
  return (struct _GtkTextView *)return_value_g_type_check_instance_cast$4;
}

// gm_world_view_searchable_iface_init
// file widgets/gm-world-view.c line 94
static void gm_world_view_searchable_iface_init(struct _GmSearchableInterface *iface)
{
  iface->get_text_view = gm_world_view_searchable_get_text_view;
}

// gm_world_view_set_focus
// file widgets/gm-world-view.h line 82
void gm_world_view_set_focus(struct _GmWorldView *view)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_input, return_value_gtk_widget_get_type$1);
  gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
}

// gm_world_view_set_userlist_width
// file widgets/gm-world-view.c line 710
void gm_world_view_set_userlist_width(struct _GmWorldView *view, signed int width)
{
  unsigned long int return_value_gtk_paned_get_type$1;
  return_value_gtk_paned_get_type$1=gtk_paned_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hpaned, return_value_gtk_paned_get_type$1);
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hpaned, return_value_gtk_widget_get_type$3);
  gtk_paned_set_position((struct _GtkPaned *)return_value_g_type_check_instance_cast$2, ((struct _GtkWidget *)return_value_g_type_check_instance_cast$4)->allocation.width - width);
}

// gm_world_view_switch_page
// file widgets/gm-world-view.c line 175
static void gm_world_view_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num)
{
  unsigned long int return_value_gtk_notebook_get_type$3;
  return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$4;
  return_value_g_type_check_class_cast$4=g_type_check_class_cast((struct _GTypeClass *)gm_world_view_parent_class, return_value_gtk_notebook_get_type$3);
  if(!(((struct _GtkNotebookClass *)return_value_g_type_check_class_cast$4)->switch_page == ((void (*)(struct _GtkNotebook *, struct _GtkNotebookPage *, unsigned int))NULL)))
  {
    unsigned long int return_value_gtk_notebook_get_type$1;
    return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
    struct _GTypeClass *return_value_g_type_check_class_cast$2;
    return_value_g_type_check_class_cast$2=g_type_check_class_cast((struct _GTypeClass *)gm_world_view_parent_class, return_value_gtk_notebook_get_type$1);
    ((struct _GtkNotebookClass *)return_value_g_type_check_class_cast$2)->switch_page(notebook, page, page_num);
  }

  if(page_num == 0u)
  {
    unsigned long int return_value_gm_world_view_get_type$5;
    return_value_gm_world_view_get_type$5=gm_world_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gm_world_view_get_type$5);
    g_idle_add((signed int (*)(void *))gm_world_view_input_grab_focus, (void *)(struct _GmWorldView *)return_value_g_type_check_instance_cast$6);
  }

}

// gm_world_view_text_active
// file widgets/gm-world-view.c line 525
signed int gm_world_view_text_active(struct _GmWorldView *view)
{
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  signed int return_value_gtk_notebook_get_current_page$3;
  return_value_gtk_notebook_get_current_page$3=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  return (signed int)(return_value_gtk_notebook_get_current_page$3 == 0);
}

// gm_world_view_text_view
// file widgets/gm-world-view.c line 690
struct _GmWorldTextView * gm_world_view_text_view(struct _GmWorldView *view)
{
  return view->priv->text_view_world;
}

// gm_world_view_update_status
// file widgets/gm-world-view.c line 303
void gm_world_view_update_status(struct _GmWorldView *view, const char *status)
{
  gtk_statusbar_pop(view->priv->statusbar, (unsigned int)0);
  if(status == ((const char *)NULL))
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Welcome to GnoeMoe, explorer of new worlds!");
    gtk_statusbar_push(view->priv->statusbar, (unsigned int)0, return_value_gettext$1);
  }

  else
    gtk_statusbar_push(view->priv->statusbar, (unsigned int)0, status);
}

// gm_world_view_world
// file widgets/gm-world-view.h line 72
struct _GmWorld * gm_world_view_world(struct _GmWorldView *view)
{
  return view->priv->world;
}

// gm_world_view_world_page_new
// file widgets/gm-world-view.c line 420
struct _GtkWidget * gm_world_view_world_page_new(struct _GmWorldView *view)
{
  struct _GtkWidget *vbox;
  vbox=gtk_vbox_new(0, 0);
  struct _GtkWidget *hpaned;
  hpaned=gtk_hpaned_new();
  struct _GtkWidget *status;
  status=gtk_statusbar_new();
  struct _GtkWidget *vbox_world;
  vbox_world=gtk_vbox_new(0, 3);
  unsigned long int return_value_gtk_box_get_type$1;
  return_value_gtk_box_get_type$1=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)vbox_world, return_value_gtk_box_get_type$1);
  struct _GtkWidget *return_value_gm_world_view_create_world_text_view$3;
  return_value_gm_world_view_create_world_text_view$3=gm_world_view_create_world_text_view(view);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$2, return_value_gm_world_view_create_world_text_view$3, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$4;
  return_value_gtk_box_get_type$4=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)vbox_world, return_value_gtk_box_get_type$4);
  struct _GtkWidget *return_value_gm_world_view_create_input_text_view$6;
  return_value_gm_world_view_create_input_text_view$6=gm_world_view_create_input_text_view(view);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$5, return_value_gm_world_view_create_input_text_view$6, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)vbox_world, return_value_gtk_container_get_type$7);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, (unsigned int)3);
  unsigned long int return_value_gtk_paned_get_type$9;
  return_value_gtk_paned_get_type$9=gtk_paned_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)hpaned, return_value_gtk_paned_get_type$9);
  gtk_paned_pack1((struct _GtkPaned *)return_value_g_type_check_instance_cast$10, vbox_world, (signed int)!(0 != 0), (signed int)!(0 != 0));
  unsigned long int return_value_gtk_statusbar_get_type$11;
  return_value_gtk_statusbar_get_type$11=gtk_statusbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)status, return_value_gtk_statusbar_get_type$11);
  gtk_statusbar_set_has_resize_grip((struct _GtkStatusbar *)return_value_g_type_check_instance_cast$12, 0);
  unsigned long int return_value_gtk_box_get_type$13;
  return_value_gtk_box_get_type$13=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$13);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$14, hpaned, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type$15;
  return_value_gtk_box_get_type$15=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$15);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$16, status, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_statusbar_get_type$17;
  return_value_gtk_statusbar_get_type$17=gtk_statusbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)status, return_value_gtk_statusbar_get_type$17);
  view->priv->statusbar = (struct _GtkStatusbar *)return_value_g_type_check_instance_cast$18;
  unsigned long int return_value_gtk_hpaned_get_type$19;
  return_value_gtk_hpaned_get_type$19=gtk_hpaned_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)hpaned, return_value_gtk_hpaned_get_type$19);
  view->priv->hpaned = (struct _GtkHPaned *)return_value_g_type_check_instance_cast$20;
  gm_world_view_update_status(view, (const char *)(void *)0);
  return vbox;
}

// gm_world_writeln
// file gm-world.c line 1138
void gm_world_writeln(struct _GmWorld *world, const char *text)
{
  char *newline;
  newline=g_strconcat(text, (const void *)"\n", (void *)0);
  g_signal_emit((void *)world, world_signals[(signed long int)5], (unsigned int)0, newline);
  g_free((void *)newline);
}

// gm_worlds_list_dialog_connect_world
// file dialogs/gm-worlds-list-dialog.c line 237
void gm_worlds_list_dialog_connect_world()
{
  struct _GtkTreeView *tree_view;
  struct _GtkWidget *return_value_gm_worlds_list_dialog_widget$1;
  return_value_gm_worlds_list_dialog_widget$1=gm_worlds_list_dialog_widget("tree_view_worlds");
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_worlds_list_dialog_widget$1, return_value_gtk_tree_view_get_type$2);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gm_worlds_view_get_type$4;
  return_value_gm_worlds_view_get_type$4=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gm_worlds_view_get_type$4);
  model=gm_worlds_view_model((struct _GmWorldsView *)return_value_g_type_check_instance_cast$5);
  struct _GList *first_path;
  first_path=gm_worlds_list_dialog_selected_path();
  struct _GList *path;
  struct _GmWorld *world;
  struct _GtkTreeIter iter;
  if(!(first_path == ((struct _GList *)NULL)))
  {
    path = first_path;
    for( ; !(path == ((struct _GList *)NULL)); path = path->next)
    {
      gtk_tree_model_get_iter(model, &iter, (struct _GtkTreePath *)first_path->data);
      gtk_tree_model_get(model, &iter, 2, &world, -1);
      gm_world_load(world);
    }
  }

  else
  {
    char *return_value_gettext$6;
    return_value_gettext$6=gettext("You first need to select a world to connect to.");
    unsigned long int return_value_gtk_window_get_type$7;
    return_value_gtk_window_get_type$7=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)gm_worlds_list_dialog_instance->dialog, return_value_gtk_window_get_type$7);
    gm_error_dialog(return_value_gettext$6, (struct _GtkWindow *)return_value_g_type_check_instance_cast$8);
  }
  g_list_free(first_path);
}

// gm_worlds_list_dialog_create_tree_view
// file dialogs/gm-worlds-list-dialog.c line 60
struct _GtkWidget * gm_worlds_list_dialog_create_tree_view(char *widget_name, char *string1, char *string2, signed int int1, signed int int2)
{
  struct _GtkWidget *tree_view;
  tree_view=gm_worlds_view_new();
  g_signal_connect_data((void *)tree_view, "key-press-event", (void (*)(void))on_gm_worlds_list_dialog_tree_view_worlds_key_press, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)tree_view, "row-activated", (void (*)(void))on_gm_worlds_list_dialog_tree_view_worlds_row_activated, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$1);
  gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gtk_widget_get_type$3);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast$4;
}

// gm_worlds_list_dialog_delete_selected_worlds
// file dialogs/gm-worlds-list-dialog.c line 122
static void gm_worlds_list_dialog_delete_selected_worlds()
{
  struct _GtkTreeView *tree_view;
  struct _GtkWidget *return_value_gm_worlds_list_dialog_widget$1;
  return_value_gm_worlds_list_dialog_widget$1=gm_worlds_list_dialog_widget("tree_view_worlds");
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_worlds_list_dialog_widget$1, return_value_gtk_tree_view_get_type$2);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gm_worlds_view_get_type$4;
  return_value_gm_worlds_view_get_type$4=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gm_worlds_view_get_type$4);
  model=gm_worlds_view_model((struct _GmWorldsView *)return_value_g_type_check_instance_cast$5);
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(tree_view);
  struct _GtkTreeIter iter;
  struct _GList *paths;
  paths=gtk_tree_selection_get_selected_rows(selection, &model);
  struct _GList *refs = (struct _GList *)(void *)0;
  struct _GList *node = (struct _GList *)(void *)0;
  char *message;
  void *proxy;
  proxy=g_object_newv((unsigned long int)(20 << 2), (unsigned int)0, (struct _GParameter *)(void *)0);
  struct _GmWorld *world;
  node = paths;
  for( ; !(node == ((struct _GList *)NULL)); node = node->next)
  {
    struct _GtkTreeRowReference *return_value_gtk_tree_row_reference_new_proxy$6;
    return_value_gtk_tree_row_reference_new_proxy$6=gtk_tree_row_reference_new_proxy((struct _GObject *)proxy, model, (struct _GtkTreePath *)node->data);
    refs=g_list_append(refs, (void *)return_value_gtk_tree_row_reference_new_proxy$6);
    gtk_tree_path_free((struct _GtkTreePath *)node->data);
  }
  g_list_free(paths);
  _Bool tmp_if_expr$15;
  signed int return_value_gm_world_loaded$14;
  if(!(refs == ((struct _GList *)NULL)))
  {
    node = refs;
    for( ; !(node == ((struct _GList *)NULL)); node = node->next)
    {
      struct _GtkTreePath *path;
      path=gtk_tree_row_reference_get_path((struct _GtkTreeRowReference *)node->data);
      gtk_tree_model_get_iter(model, &iter, path);
      gtk_tree_model_get(model, &iter, 2, &world, -1);
      if(!(world == ((struct _GmWorld *)NULL)))
      {
        return_value_gm_world_loaded$14=gm_world_loaded(world);
        tmp_if_expr$15 = return_value_gm_world_loaded$14 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$15 = (_Bool)0;
      if(!tmp_if_expr$15)
      {
        struct _GmApp *return_value_gm_app_instance$7;
        return_value_gm_app_instance$7=gm_app_instance();
        gm_app_remove_world(return_value_gm_app_instance$7, world);
      }

      else
      {
        char *return_value_gettext$8;
        return_value_gettext$8=gettext("The world %s is still open. Do you want to close and remove the world?");
        const char *return_value_gm_world_name$9;
        return_value_gm_world_name$9=gm_world_name(world);
        message=g_strdup_printf(return_value_gettext$8, return_value_gm_world_name$9);
        unsigned long int return_value_gtk_window_get_type$11;
        return_value_gtk_window_get_type$11=gtk_window_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
        return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)gm_worlds_list_dialog_instance->dialog, return_value_gtk_window_get_type$11);
        signed int return_value_gm_question_dialog$13;
        return_value_gm_question_dialog$13=gm_question_dialog(message, (struct _GtkWindow *)return_value_g_type_check_instance_cast$12);
        if(return_value_gm_question_dialog$13 == -8)
        {
          gm_world_unload(world);
          struct _GmApp *return_value_gm_app_instance$10;
          return_value_gm_app_instance$10=gm_app_instance();
          gm_app_remove_world(return_value_gm_app_instance$10, world);
        }

        g_free((void *)message);
      }
      gtk_tree_row_reference_deleted((struct _GObject *)proxy, path);
      gtk_tree_path_free(path);
      gtk_tree_row_reference_free((struct _GtkTreeRowReference *)node->data);
    }
  }

  else
  {
    char *return_value_gettext$16;
    return_value_gettext$16=gettext("You first need to select a world to delete.");
    unsigned long int return_value_gtk_window_get_type$17;
    return_value_gtk_window_get_type$17=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)gm_worlds_list_dialog_instance->dialog, return_value_gtk_window_get_type$17);
    gm_error_dialog(return_value_gettext$16, (struct _GtkWindow *)return_value_g_type_check_instance_cast$18);
  }
  g_list_free(refs);
  g_object_unref(proxy);
}

// gm_worlds_list_dialog_modify_world
// file dialogs/gm-worlds-list-dialog.c line 183
void gm_worlds_list_dialog_modify_world()
{
  struct _GtkTreeView *tree_view;
  struct _GtkWidget *return_value_gm_worlds_list_dialog_widget$1;
  return_value_gm_worlds_list_dialog_widget$1=gm_worlds_list_dialog_widget("tree_view_worlds");
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_worlds_list_dialog_widget$1, return_value_gtk_tree_view_get_type$2);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gm_worlds_view_get_type$4;
  return_value_gm_worlds_view_get_type$4=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gm_worlds_view_get_type$4);
  model=gm_worlds_view_model((struct _GmWorldsView *)return_value_g_type_check_instance_cast$5);
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(tree_view);
  struct _GtkTreeIter iter;
  struct _GList *first_path;
  first_path=gtk_tree_selection_get_selected_rows(selection, &model);
  struct _GmWorld *world;
  if(!(first_path == ((struct _GList *)NULL)))
  {
    gtk_tree_model_get_iter(model, &iter, (struct _GtkTreePath *)first_path->data);
    gtk_tree_model_get(model, &iter, 2, &world, -1);
    gm_world_properties_dialog_run(world);
  }

  else
  {
    char *return_value_gettext$6;
    return_value_gettext$6=gettext("You first need to select a world to modify.");
    unsigned long int return_value_gtk_window_get_type$7;
    return_value_gtk_window_get_type$7=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)gm_worlds_list_dialog_instance->dialog, return_value_gtk_window_get_type$7);
    gm_error_dialog(return_value_gettext$6, (struct _GtkWindow *)return_value_g_type_check_instance_cast$8);
  }
  g_list_free(first_path);
}

// gm_worlds_list_dialog_run
// file ./dialogs/gm-worlds-list-dialog.h line 4
void gm_worlds_list_dialog_run()
{
  struct _GladeXML *xml;
  if(!(gm_worlds_list_dialog_instance == ((struct _GmWorldsListDialog *)NULL)))
  {
    gtk_widget_show(gm_worlds_list_dialog_instance->dialog);
    unsigned long int return_value_gtk_window_get_type$1;
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gm_worlds_list_dialog_instance->dialog, return_value_gtk_window_get_type$1);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
    goto __CPROVER_DUMP_L3;
  }

  xml=glade_xml_new("/usr/share/gnoemoe/ui/gm-worlds-list.glade", "gm_worlds_list_dialog", (const char *)(void *)0);
  if(xml == ((struct _GladeXML *)NULL))
    gm_debug_msg(DEBUG_ALWAYS, "Couldn't find glade file %s!", (const void *)"/usr/share/gnoemoe/ui/gm-worlds-list.glade");

  else
  {
    void *return_value_g_malloc0_n$3;
    return_value_g_malloc0_n$3=g_malloc0_n((unsigned long int)1, sizeof(struct _GmWorldsListDialog) /*16ul*/ );
    gm_worlds_list_dialog_instance = (struct _GmWorldsListDialog *)return_value_g_malloc0_n$3;
    gm_worlds_list_dialog_instance->xml = xml;
    glade_xml_signal_connect(xml, "on_button_delete_clicked", (void (*)(void))on_gm_worlds_list_dialog_button_delete_clicked);
    glade_xml_signal_connect(xml, "on_button_new_clicked", (void (*)(void))on_gm_worlds_list_dialog_button_new_clicked);
    glade_xml_signal_connect(xml, "on_button_modify_clicked", (void (*)(void))on_gm_worlds_list_dialog_button_modify_clicked);
    glade_xml_signal_connect(xml, "on_button_duplicate_clicked", (void (*)(void))on_gm_worlds_list_dialog_button_duplicate_clicked);
    glade_xml_signal_connect(xml, "on_button_connect_clicked", (void (*)(void))on_gm_worlds_list_dialog_button_connect_clicked);
    gm_worlds_list_dialog_instance->dialog=gm_worlds_list_dialog_widget("gm_worlds_list_dialog");
    unsigned long int return_value_gtk_window_get_type$4;
    return_value_gtk_window_get_type$4=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)gm_worlds_list_dialog_instance->dialog, return_value_gtk_window_get_type$4);
    struct _GdkPixbuf *return_value_gm_pixbuf_get$6;
    return_value_gm_pixbuf_get$6=gm_pixbuf_get("world.svg");
    gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, return_value_gm_pixbuf_get$6);
    g_signal_connect_data((void *)gm_worlds_list_dialog_instance->dialog, "response", (void (*)(void))on_gm_worlds_list_dialog_response, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
    gtk_widget_show(gm_worlds_list_dialog_instance->dialog);
  }

__CPROVER_DUMP_L3:
  ;
}

// gm_worlds_list_dialog_selected_path
// file dialogs/gm-worlds-list-dialog.c line 207
struct _GList * gm_worlds_list_dialog_selected_path()
{
  struct _GtkTreeView *tree_view;
  struct _GtkWidget *return_value_gm_worlds_list_dialog_widget$1;
  return_value_gm_worlds_list_dialog_widget$1=gm_worlds_list_dialog_widget("tree_view_worlds");
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_worlds_list_dialog_widget$1, return_value_gtk_tree_view_get_type$2);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gm_worlds_view_get_type$4;
  return_value_gm_worlds_view_get_type$4=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gm_worlds_view_get_type$4);
  model=gm_worlds_view_model((struct _GmWorldsView *)return_value_g_type_check_instance_cast$5);
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(tree_view);
  struct _GList *return_value_gtk_tree_selection_get_selected_rows$6;
  return_value_gtk_tree_selection_get_selected_rows$6=gtk_tree_selection_get_selected_rows(selection, &model);
  return return_value_gtk_tree_selection_get_selected_rows$6;
}

// gm_worlds_list_dialog_selected_world
// file dialogs/gm-worlds-list-dialog.c line 217
struct _GmWorld * gm_worlds_list_dialog_selected_world()
{
  struct _GtkTreeView *tree_view;
  struct _GtkWidget *return_value_gm_worlds_list_dialog_widget$1;
  return_value_gm_worlds_list_dialog_widget$1=gm_worlds_list_dialog_widget("tree_view_worlds");
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_worlds_list_dialog_widget$1, return_value_gtk_tree_view_get_type$2);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gm_worlds_view_get_type$4;
  return_value_gm_worlds_view_get_type$4=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gm_worlds_view_get_type$4);
  model=gm_worlds_view_model((struct _GmWorldsView *)return_value_g_type_check_instance_cast$5);
  struct _GtkTreeIter iter;
  struct _GList *first_path;
  first_path=gm_worlds_list_dialog_selected_path();
  struct _GmWorld *world = (struct _GmWorld *)(void *)0;
  if(!(first_path == ((struct _GList *)NULL)))
  {
    gtk_tree_model_get_iter(model, &iter, (struct _GtkTreePath *)first_path->data);
    gtk_tree_model_get(model, &iter, 2, &world, -1);
  }

  g_list_free(first_path);
  return world;
}

// gm_worlds_list_dialog_widget
// file dialogs/gm-worlds-list-dialog.c line 52
struct _GtkWidget * gm_worlds_list_dialog_widget(char *name)
{
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(gm_worlds_list_dialog_instance->xml, name);
  return return_value_glade_xml_get_widget$1;
}

// gm_worlds_view_add_world
// file widgets/gm-worlds-view.c line 198
void gm_worlds_view_add_world(struct _GmWorldsView *view, struct _GmWorld *world)
{
  struct _GtkTreeIter iter;
  struct _GdkPixbuf *pix_logo = (struct _GdkPixbuf *)(void *)0;
  char *name;
  name=gm_worlds_view_world_text(view, world);
  const char *logo;
  struct _GmOptions *return_value_gm_world_options$1;
  return_value_gm_world_options$1=gm_world_options(world);
  logo=gm_options_get(return_value_gm_world_options$1, "logo");
  struct _GtkListStore *store;
  unsigned long int return_value_gtk_list_store_get_type$2;
  return_value_gtk_list_store_get_type$2=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->model, return_value_gtk_list_store_get_type$2);
  store = (struct _GtkListStore *)return_value_g_type_check_instance_cast$3;
  if(!(logo == ((const char *)NULL)))
    pix_logo=gm_pixbuf_get_at_size(logo, 32, 32);

  if(pix_logo == ((struct _GdkPixbuf *)NULL))
    pix_logo=gm_pixbuf_get_at_size("world.svg", 32, 32);

  gtk_list_store_append(store, &iter);
  const char *return_value_gm_world_name$4;
  return_value_gm_world_name$4=gm_world_name(world);
  gtk_list_store_set(store, &iter, 0, pix_logo, 1, name, 2, world, 3, return_value_gm_world_name$4, -1);
  struct _GmOptions *return_value_gm_world_options$5;
  return_value_gm_world_options$5=gm_world_options(world);
  g_signal_connect_data((void *)return_value_gm_world_options$5, "option_changed", (void (*)(void))on_gm_worlds_view_world_option_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_free((void *)name);
}

// gm_worlds_view_build
// file widgets/gm-worlds-view.c line 121
static void gm_worlds_view_build(struct _GmWorldsView *view)
{
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GtkTreeView *tree_view;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_tree_view_get_type$1);
  tree_view = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gdk_pixbuf_get_type$3;
  return_value_gdk_pixbuf_get_type$3=gdk_pixbuf_get_type();
  struct _GtkListStore *return_value_gtk_list_store_new$4;
  return_value_gtk_list_store_new$4=gtk_list_store_new(4, return_value_gdk_pixbuf_get_type$3, (unsigned long int)(16 << 2), (unsigned long int)(17 << 2), (unsigned long int)(16 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$5;
  return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_list_store_new$4, return_value_gtk_tree_model_get_type$5);
  view->priv->model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6;
  gtk_tree_view_set_model(tree_view, view->priv->model);
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$7;
  return_value_gtk_tree_view_get_selection$7=gtk_tree_view_get_selection(tree_view);
  gtk_tree_selection_set_mode(return_value_gtk_tree_view_get_selection$7, (enum anonymous$78)GTK_SELECTION_MULTIPLE);
  renderer=gtk_cell_renderer_pixbuf_new();
  char *return_value_gettext$8;
  return_value_gettext$8=gettext("Logo");
  column=gtk_tree_view_column_new_with_attributes(return_value_gettext$8, renderer, (const void *)"pixbuf", 0, (void *)0);
  gtk_tree_view_column_set_min_width(column, 40);
  gtk_tree_view_append_column(tree_view, column);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_gettext$9;
  return_value_gettext$9=gettext("Name");
  column=gtk_tree_view_column_new_with_attributes(return_value_gettext$9, renderer, (const void *)"markup", 1, (void *)0);
  gtk_tree_view_append_column(tree_view, column);
  unsigned long int return_value_gtk_tree_sortable_get_type$10;
  return_value_gtk_tree_sortable_get_type$10=gtk_tree_sortable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->model, return_value_gtk_tree_sortable_get_type$10);
  gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$11, 3, (enum anonymous$151)GTK_SORT_ASCENDING);
  gm_worlds_view_populate_worlds(view);
}

// gm_worlds_view_class_init
// file widgets/gm-worlds-view.c line 62
static void gm_worlds_view_class_init(struct _GmWorldsViewClass *klass)
{
  struct _GObjectClass *object_class;
  struct _GTypeClass *return_value_g_type_check_class_cast$1;
  return_value_g_type_check_class_cast$1=g_type_check_class_cast((struct _GTypeClass *)klass, (unsigned long int)(20 << 2));
  object_class = (struct _GObjectClass *)return_value_g_type_check_class_cast$1;
  object_class->finalize = gm_worlds_view_finalize;
  g_type_class_add_private((void *)object_class, sizeof(struct _GmWorldsViewPrivate) /*8ul*/ );
}

// gm_worlds_view_class_intern_init
// file widgets/gm-worlds-view.c line 34
static void gm_worlds_view_class_intern_init(void *klass)
{
  gm_worlds_view_parent_class=g_type_class_peek_parent(klass);
  if(!(GmWorldsView_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &GmWorldsView_private_offset);

  gm_worlds_view_class_init((struct _GmWorldsViewClass *)klass);
}

// gm_worlds_view_finalize
// file widgets/gm-worlds-view.c line 37
static void gm_worlds_view_finalize(struct _GObject *object)
{
  struct _GmWorldsView *obj;
  unsigned long int return_value_gm_worlds_view_get_type$1;
  return_value_gm_worlds_view_get_type$1=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_gm_worlds_view_get_type$1);
  obj = (struct _GmWorldsView *)return_value_g_type_check_instance_cast$2;
  struct _GtkTreeModel *model = obj->priv->model;
  struct _GmWorld *list_world;
  struct _GtkTreeIter iter;
  signed int return_value_gtk_tree_model_get_iter_first$5;
  return_value_gtk_tree_model_get_iter_first$5=gtk_tree_model_get_iter_first(model, &iter);
  signed int return_value_gtk_tree_model_iter_next$3;
  if(!(return_value_gtk_tree_model_get_iter_first$5 == 0))
    do
    {
      gtk_tree_model_get(model, &iter, 2, &list_world, -1);
      struct _GmOptions *return_value_gm_world_options$4;
      return_value_gm_world_options$4=gm_world_options(list_world);
      g_signal_handlers_disconnect_matched((void *)return_value_gm_world_options$4, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_worlds_view_world_option_changed, (void *)obj);
      return_value_gtk_tree_model_iter_next$3=gtk_tree_model_iter_next(model, &iter);
    }
    while(!(return_value_gtk_tree_model_iter_next$3 == 0));

  struct _GmApp *return_value_gm_app_instance$6;
  return_value_gm_app_instance$6=gm_app_instance();
  g_signal_handlers_disconnect_matched((void *)return_value_gm_app_instance$6, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_worlds_view_app_world_added, (void *)obj);
  struct _GmApp *return_value_gm_app_instance$7;
  return_value_gm_app_instance$7=gm_app_instance();
  g_signal_handlers_disconnect_matched((void *)return_value_gm_app_instance$7, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_worlds_view_app_world_removed, (void *)obj);
  struct _GTypeClass *return_value_g_type_check_class_cast$8;
  return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)gm_worlds_view_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$8)->finalize(object);
}

// gm_worlds_view_find
// file widgets/gm-worlds-view.c line 176
static signed int gm_worlds_view_find(struct _GmWorldsView *view, struct _GmWorld *world, struct _GtkTreeIter *iter)
{
  struct _GmOptions *return_value_gm_world_options$1;
  return_value_gm_world_options$1=gm_world_options(world);
  signed int return_value_gm_worlds_view_find_by_options$2;
  return_value_gm_worlds_view_find_by_options$2=gm_worlds_view_find_by_options(view, return_value_gm_world_options$1, iter, (struct _GmWorld **)(void *)0);
  return return_value_gm_worlds_view_find_by_options$2;
}

// gm_worlds_view_find_by_options
// file widgets/gm-worlds-view.c line 152
static signed int gm_worlds_view_find_by_options(struct _GmWorldsView *view, struct _GmOptions *options, struct _GtkTreeIter *iter, struct _GmWorld **world)
{
  struct _GtkTreeModel *model = view->priv->model;
  struct _GmWorld *list_world;
  signed int return_value_gtk_tree_model_get_iter_first$3;
  return_value_gtk_tree_model_get_iter_first$3=gtk_tree_model_get_iter_first(model, iter);
  signed int return_value_gtk_tree_model_iter_next$1;
  if(!(return_value_gtk_tree_model_get_iter_first$3 == 0))
    do
    {
      gtk_tree_model_get(model, iter, 2, &list_world, -1);
      struct _GmOptions *return_value_gm_world_options$2;
      return_value_gm_world_options$2=gm_world_options(list_world);
      if(options == return_value_gm_world_options$2)
      {
        if(!(world == ((struct _GmWorld **)NULL)))
          *world = list_world;

        return (signed int)!(0 != 0);
      }

      return_value_gtk_tree_model_iter_next$1=gtk_tree_model_iter_next(model, iter);
    }
    while(!(return_value_gtk_tree_model_iter_next$1 == 0));

  return 0;
}

// gm_worlds_view_get_type
// file widgets/gm-worlds-view.c line 34
unsigned long int gm_worlds_view_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_tree_view_get_type$1;
    return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("GmWorldsView");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_tree_view_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _GmWorldsViewClass) /*992ul*/ , (void (*)(void *, void *))gm_worlds_view_class_intern_init, (unsigned int)sizeof(struct _GmWorldsView) /*128ul*/ , (void (*)(struct _GTypeInstance *, void *))gm_worlds_view_init, (enum anonymous)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// gm_worlds_view_init
// file widgets/gm-worlds-view.c line 81
static void gm_worlds_view_init(struct _GmWorldsView *obj)
{
  unsigned long int return_value_gm_worlds_view_get_type$1;
  return_value_gm_worlds_view_get_type$1=gm_worlds_view_get_type();
  void *return_value_g_type_instance_get_private$2;
  return_value_g_type_instance_get_private$2=g_type_instance_get_private((struct _GTypeInstance *)obj, return_value_gm_worlds_view_get_type$1);
  obj->priv = (struct _GmWorldsViewPrivate *)return_value_g_type_instance_get_private$2;
}

// gm_worlds_view_model
// file widgets/gm-worlds-view.c line 228
struct _GtkTreeModel * gm_worlds_view_model(struct _GmWorldsView *view)
{
  return view->priv->model;
}

// gm_worlds_view_new
// file widgets/gm-worlds-view.c line 183
struct _GtkWidget * gm_worlds_view_new()
{
  struct _GmWorldsView *obj;
  unsigned long int return_value_gm_worlds_view_get_type$1;
  return_value_gm_worlds_view_get_type$1=gm_worlds_view_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_gm_worlds_view_get_type$1, (const char *)(void *)0);
  unsigned long int return_value_gm_worlds_view_get_type$3;
  return_value_gm_worlds_view_get_type$3=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_new$2, return_value_gm_worlds_view_get_type$3);
  obj = (struct _GmWorldsView *)return_value_g_type_check_instance_cast$4;
  gm_worlds_view_build(obj);
  unsigned long int return_value_gtk_tree_view_get_type$5;
  return_value_gtk_tree_view_get_type$5=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_tree_view_get_type$5);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast$6, 0);
  struct _GmApp *return_value_gm_app_instance$7;
  return_value_gm_app_instance$7=gm_app_instance();
  g_signal_connect_data((void *)return_value_gm_app_instance$7, "world_added", (void (*)(void))on_gm_worlds_view_app_world_added, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  struct _GmApp *return_value_gm_app_instance$8;
  return_value_gm_app_instance$8=gm_app_instance();
  g_signal_connect_data((void *)return_value_gm_app_instance$8, "world_removed", (void (*)(void))on_gm_worlds_view_app_world_removed, (void *)obj, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)obj, return_value_gtk_widget_get_type$9);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
}

// gm_worlds_view_populate_worlds
// file widgets/gm-worlds-view.c line 106
static void gm_worlds_view_populate_worlds(struct _GmWorldsView *view)
{
  struct _GmApp *app;
  app=gm_app_instance();
  struct _GList *worlds;
  worlds=gm_app_worlds(app);
  struct _GList *item;
  struct _GmWorld *world;
  item = worlds;
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
  {
    world = (struct _GmWorld *)item->data;
    gm_worlds_view_add_world(view, world);
  }
  g_list_free(worlds);
}

// gm_worlds_view_world_text
// file widgets/gm-worlds-view.c line 86
static char * gm_worlds_view_world_text(struct _GmWorldsView *view, struct _GmWorld *world)
{
  char *text;
  const char *player;
  const char *server;
  struct _GmOptions *options;
  options=gm_world_options(world);
  player=gm_options_get(options, "player_name");
  server=gm_options_get(options, "host");
  const char *return_value_gm_options_get$1;
  return_value_gm_options_get$1=gm_options_get(options, "name");
  char *return_value_gettext$2;
  return_value_gettext$2=gettext("</b>\n<small>Server: ");
  _Bool tmp_if_expr$3;
  if(!(server == ((const char *)NULL)))
    tmp_if_expr$3 = (signed int)*server != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  const char *tmp_if_expr$5;
  char *return_value_gettext$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = server;

  else
  {
    return_value_gettext$4=gettext("<i>unspecified</i>");
    tmp_if_expr$5 = return_value_gettext$4;
  }
  char *return_value_gettext$6;
  return_value_gettext$6=gettext("\nPlayer: ");
  _Bool tmp_if_expr$7;
  if(!(player == ((const char *)NULL)))
    tmp_if_expr$7 = (signed int)*player != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$7 = (_Bool)0;
  const char *tmp_if_expr$9;
  char *return_value_gettext$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = player;

  else
  {
    return_value_gettext$8=gettext("<i>unspecified</i>");
    tmp_if_expr$9 = return_value_gettext$8;
  }
  text=g_strconcat("<b>", return_value_gm_options_get$1, return_value_gettext$2, tmp_if_expr$5, return_value_gettext$6, tmp_if_expr$9, (const void *)"</small>", (void *)0);
  return text;
}

// idle_create_tray
// file widgets/gm-app-view.c line 1738
signed int idle_create_tray(void *user_data)
{
  struct _GmAppView *view;
  unsigned long int return_value_gm_app_view_get_type$1;
  return_value_gm_app_view_get_type$1=gm_app_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_gm_app_view_get_type$1);
  view = (struct _GmAppView *)return_value_g_type_check_instance_cast$2;
  view->priv->tray_idle_create = (unsigned int)0;
  gm_app_view_create_tray(view);
  signed int return_value_gm_tray_has_manager$7;
  return_value_gm_tray_has_manager$7=gm_tray_has_manager();
  unsigned long int return_value_gtk_object_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  if(return_value_gm_tray_has_manager$7 == 0)
  {
    return_value_gtk_object_get_type$5=gtk_object_get_type();
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_object_get_type$5);
    if((256u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$6)->flags) == 0u)
    {
      gm_app_view_toggle_visibility(view);
      unsigned long int return_value_gtk_window_get_type$3;
      return_value_gtk_window_get_type$3=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$3);
      gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$4);
    }

  }

  return 0;
}

// idle_notification_expired
// file widgets/eggnotificationbubble.c line 371
static signed int idle_notification_expired(void *data)
{
  struct _EggNotificationBubble *bubble = (struct _EggNotificationBubble *)data;
  do
    if(!(gdk_threads_lock == ((void (*)(void))NULL)))
      gdk_threads_lock();

  while((_Bool)0);
  g_signal_emit((void *)bubble, egg_notification_bubble_signals[(signed long int)1], (unsigned int)0);
  egg_notification_bubble_hide(bubble);
  do
    if(!(gdk_threads_unlock == ((void (*)(void))NULL)))
      gdk_threads_unlock();

  while((_Bool)0);
  return 0;
}

// idle_proceed_addrinfo
// file gm-net.c line 478
static signed int idle_proceed_addrinfo(void *user_data)
{
  struct _threadinfo *info = (struct _threadinfo *)user_data;
  struct _GmNet *net = info->net;
  info->idle_id = (unsigned int)0;
  pthread_join(net->priv->thread, (void **)(void *)0);
  net->priv->thread = (unsigned long int)0;
  if(!(info->ret == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(info->ret);
    gm_debug_msg(DEBUG_DEFAULT, "GmNet.Connect: getaddrinfo failed: %s", return_value_gai_strerror$1);
    const char *return_value_gai_strerror$2;
    return_value_gai_strerror$2=gai_strerror(info->ret);
    gm_net_connect_failed(net, (char *)return_value_gai_strerror$2, info->ret);
    gm_net_free_thread_info(net);
    return 0;
  }

  net->priv->addr = info->addr;
  if(!(info->addr == ((struct addrinfo *)NULL)))
  {
    net->priv->current = info->addr;
    gm_net_free_thread_info(net);
    gm_net_connect_next(net);
  }

  else
  {
    gm_net_free_thread_info(net);
    char *return_value_gettext$3;
    return_value_gettext$3=gettext("No addresses available");
    gm_net_connect_failed(net, return_value_gettext$3, 0);
  }
  return 0;
}

// idle_proceed_connect_next
// file gm-net.c line 377
static signed int idle_proceed_connect_next(void *user_data)
{
  struct _threadinfo *info = (struct _threadinfo *)user_data;
  struct _GmNet *net = info->net;
  struct addrinfo *tmp;
  signed int ret = info->ret;
  signed int result;
  info->idle_id = (unsigned int)0;
  pthread_join(net->priv->thread, (void **)(void *)0);
  net->priv->thread = (unsigned long int)0;
  if(!(info->ret == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(info->ret);
    gm_debug_msg(DEBUG_DEFAULT, "GmNet.ConnectNext: getnameinfo error: %s", return_value_gai_strerror$1);
    gm_net_free_thread_info(net);
    const char *return_value_gai_strerror$2;
    return_value_gai_strerror$2=gai_strerror(ret);
    gm_net_connect_failed(net, (char *)return_value_gai_strerror$2, ret);
    return 0;
  }

  gm_net_set_host(net, info->host);
  gm_net_set_port(net, info->port);
  gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_TRY_ADDRESS);
  tmp = info->tmp;
  gm_net_free_thread_info(net);
  net->priv->socket=socket(tmp->ai_family, tmp->ai_socktype, tmp->ai_protocol);
  _Bool tmp_if_expr$11;
  signed int *return_value___errno_location$10;
  if(!(net->priv->socket >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    gm_net_connect_failed(net, return_value_strerror$4, *return_value___errno_location$5);
  }

  else
  {
    signed int return_value_fcntl$6;
    return_value_fcntl$6=fcntl(net->priv->socket, 3);
    fcntl(net->priv->socket, 4, return_value_fcntl$6 | 04000);
    result=connect(net->priv->socket, tmp->ai_addr, net->priv->addr->ai_addrlen);
    if(result == -1)
    {
      return_value___errno_location$10=__errno_location();
      tmp_if_expr$11 = *return_value___errno_location$10 != 115 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$11 = (_Bool)0;
    if(tmp_if_expr$11)
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      char *return_value_strerror$8;
      return_value_strerror$8=strerror(*return_value___errno_location$7);
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      gm_net_connect_failed(net, return_value_strerror$8, *return_value___errno_location$9);
    }

    else
    {
      net->priv->channel=g_io_channel_unix_new(net->priv->socket);
      g_io_channel_set_close_on_unref(net->priv->channel, (signed int)!(0 != 0));
      if(result == 0)
        gm_net_connect_succeed(net);

      else
      {
        net->priv->connect_check_id=g_io_add_watch(net->priv->channel, (enum anonymous$69)(G_IO_OUT | G_IO_ERR), (signed int (*)(struct _GIOChannel *, enum anonymous$69, void *))on_gm_net_connect_check, (void *)net);
        net->priv->connect_timeout_id=g_timeout_add((unsigned int)5000, (signed int (*)(void *))on_gm_net_connect_timeout, (void *)net);
      }
    }
  }
  return 0;
}

// idle_scroll
// file widgets/gm-world-input-view.c line 348
signed int idle_scroll(void *user_data)
{
  struct _GmWorldInputView *view;
  unsigned long int return_value_gm_world_input_view_get_type$1;
  return_value_gm_world_input_view_get_type$1=gm_world_input_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_gm_world_input_view_get_type$1);
  view = (struct _GmWorldInputView *)return_value_g_type_check_instance_cast$2;
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$3;
  return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$3);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$4);
  view->priv->idle_scroll = (unsigned int)0;
  unsigned long int return_value_gtk_text_view_get_type$5;
  return_value_gtk_text_view_get_type$5=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$5);
  struct _GtkTextMark *return_value_gtk_text_buffer_get_insert$7;
  return_value_gtk_text_buffer_get_insert$7=gtk_text_buffer_get_insert(buffer);
  gtk_text_view_scroll_to_mark((struct _GtkTextView *)return_value_g_type_check_instance_cast$6, return_value_gtk_text_buffer_get_insert$7, 0.0, (signed int)!(0 != 0), 0.5, 1.0);
  return 0;
}

// lines_match
// file widgets/gm-searchable.c line 252
static signed int lines_match(const struct _GtkTextIter *start, const char **lines, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end)
{
  struct _GtkTextIter next;
  char *line_text;
  const char *found;
  signed int offset;
  _Bool tmp_if_expr$1;
  if(*lines == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*(*lines) == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(!(match_start == ((struct _GtkTextIter *)NULL)))
      *match_start = *start;

    if(!(match_end == ((struct _GtkTextIter *)NULL)))
      *match_end = *start;

    return (signed int)!(0 != 0);
  }

  else
  {
    next = *start;
    gtk_text_iter_forward_line(&next);
    signed int return_value_gtk_text_iter_equal$2;
    return_value_gtk_text_iter_equal$2=gtk_text_iter_equal(start, &next);
    if(!(return_value_gtk_text_iter_equal$2 == 0))
      return 0;

    else
    {
      line_text=gtk_text_iter_get_visible_text(start, &next);
      if(!(match_start == ((struct _GtkTextIter *)NULL)))
        found=g_utf8_strcasestr(line_text, *lines);

      else
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(line_text);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(*lines);
        signed int return_value_g_utf8_caselessnmatch$5;
        return_value_g_utf8_caselessnmatch$5=g_utf8_caselessnmatch(line_text, *lines, (signed long int)return_value_strlen$3, (signed long int)return_value_strlen$4);
        if(!(return_value_g_utf8_caselessnmatch$5 == 0))
          found = line_text;

        else
          found = (const char *)(void *)0;
      }
      if(found == ((const char *)NULL))
      {
        g_free((void *)line_text);
        return 0;
      }

      else
      {
        signed long int return_value_g_utf8_strlen$6;
        return_value_g_utf8_strlen$6=g_utf8_strlen(line_text, found - line_text);
        offset = (signed int)return_value_g_utf8_strlen$6;
        next = *start;
        forward_chars_with_skipping(&next, offset, 0);
        if(!(match_start == ((struct _GtkTextIter *)NULL)))
          *match_start = next;

        signed long int return_value_g_utf8_strlen$7;
        return_value_g_utf8_strlen$7=g_utf8_strlen(*lines, (signed long int)-1);
        forward_chars_with_skipping(&next, (signed int)return_value_g_utf8_strlen$7, (signed int)!(0 != 0));
        g_free((void *)line_text);
        lines = lines + 1l;
        if(!(match_end == ((struct _GtkTextIter *)NULL)))
          *match_end = next;

        signed int return_value_lines_match$8;
        return_value_lines_match$8=lines_match(&next, lines, (struct _GtkTextIter *)(void *)0, match_end);
        return return_value_lines_match$8;
      }
    }
  }
}

// main
// file gm-app.c line 631
signed int main(signed int argc, char **argv)
{
  g_type_init();
  application=gm_app_new(argc, argv);
  if(!(application == ((struct _GmApp *)NULL)))
  {
    signal(15, on_signal_quit);
    signal(1, on_signal_quit);
    signal(2, on_signal_quit);
    gm_app_run(application);
    g_object_unref((void *)application);
  }

  return 0;
}

// modify_cursor_color
// file gm-support.c line 690
static void modify_cursor_color(struct _GtkWidget *textview, struct _GdkColor *color)
{
  const char *name;
  char *rc_temp;
  name=gtk_widget_get_name(textview);
  if(name == ((const char *)NULL))
  {
    gtk_widget_set_name(textview, "GmSchemedTextView");
    name=gtk_widget_get_name(textview);
  }

  do
    if(name == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"modify_cursor_color", "name != NULL");
      goto __CPROVER_DUMP_L5;
    }

  while((_Bool)0);
  static const char cursor_color_rc[105l] = { 's', 't', 'y', 'l', 'e', ' ', '"', 's', 'v', 's', '-', 'c', 'c', '"', '\n', '{', '\n', 'G', 't', 'k', 'T', 'e', 'x', 't', 'V', 'i', 'e', 'w', ':', ':', 'c', 'u', 'r', 's', 'o', 'r', '-', 'c', 'o', 'l', 'o', 'r', '=', '"', '#', '%', '0', '4', 'x', '%', '0', '4', 'x', '%', '0', '4', 'x', '"', '\n', '}', '\n', 'w', 'i', 'd', 'g', 'e', 't', ' ', '"', '*', '.', '%', 's', '"', ' ', 's', 't', 'y', 'l', 'e', ' ', ':', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', '"', 's', 'v', 's', '-', 'c', 'c', '"', '\n', 0 };
  if(!(color == ((struct _GdkColor *)NULL)))
    rc_temp=g_strdup_printf(cursor_color_rc, color->red, color->green, color->blue, name);

  else
  {
    struct _GtkRcStyle *rc_style;
    rc_style=gtk_widget_get_modifier_style(textview);
    rc_temp=g_strdup_printf(cursor_color_rc, rc_style->text[(signed long int)GTK_STATE_NORMAL].red, rc_style->text[(signed long int)GTK_STATE_NORMAL].green, rc_style->text[(signed long int)GTK_STATE_NORMAL].blue, name);
  }
  gtk_rc_parse_string(rc_temp);
  gtk_widget_reset_rc_styles(textview);
  g_free((void *)rc_temp);

__CPROVER_DUMP_L5:
  ;
}

// mutex_unlock
// file gm-net.c line 434
void mutex_unlock(void *ptr)
{
  pthread_mutex_unlock((union anonymous$66 *)ptr);
}

// nameinfo_thread
// file gm-net.c line 439
void * nameinfo_thread(void *ptr)
{
  struct _threadinfo *info = (struct _threadinfo *)ptr;
  char host[1025l];
  char port[32l];
  info->tmp = info->current;
  info->ret=getnameinfo(info->tmp->ai_addr, info->tmp->ai_addrlen, host, (unsigned int)1025, port, (unsigned int)32, 1 | 2);
  if(info->ret == 0)
  {
    info->host=g_strdup(host);
    info->port=g_strdup(port);
  }

  pthread_mutex_lock(info->mutex_idle);
  do
  {
    struct anonymous$65 __cancel_buf;
    void (*__cancel_routine)(void *) = mutex_unlock;
    void *__cancel_arg = (void *)info->mutex_idle;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      info->idle_id=g_idle_add(idle_proceed_connect_next, (void *)info);

    __CPROVER_DUMP_L5:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// new_tag_style
// file widgets/gm-source-style-scheme.c line 103
static struct _GtkTextTag * new_tag_style(const char *foreground, const char *background, signed int bold, signed int italic)
{
  struct _GtkTextTag *ts;
  ts=gtk_text_tag_new((const char *)(void *)0);
  struct _GdkColor *foreground_color = (struct _GdkColor *)(void *)0;
  gdk_color_parse(foreground, foreground_color);
  g_object_set((void *)ts, "foreground-set", !(0 != 0), (const void *)"foreground", foreground_color, !(0 != 0), (void *)0);
  if(!(background == ((const char *)NULL)))
  {
    struct _GdkColor *background_color = (struct _GdkColor *)(void *)0;
    gdk_color_parse(background, background_color);
    g_object_set((void *)ts, "background-set", !(0 != 0), (const void *)"background", background_color, !(0 != 0), (void *)0);
  }

  g_object_set((void *)ts, "style-set", italic, (const void *)"style", PANGO_STYLE_ITALIC, italic, (void *)0);
  g_object_set((void *)ts, "weight-set", bold, (const void *)"weight", 700, bold, (void *)0);
  return ts;
}

// on_action_edit_copy
// file ./widgets/gm-commands.h line 13
void on_action_edit_copy(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GtkWidget *active;
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  active=gtk_window_get_focus((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
  struct _GtkClipboard *clip;
  clip=gtk_clipboard_get((struct _GdkAtom *)(void *)(unsigned long int)69);
  struct _GtkTextBuffer *buf;
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  struct _GmWorldView *world_view;
  world_view=gm_app_view_active_world_view(view);
  struct _GmWorldInputView *return_value_gm_world_view_input$4;
  unsigned long int return_value_gtk_widget_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  if(!(world_view == ((struct _GmWorldView *)NULL)))
  {
    return_value_gm_world_view_input$4=gm_world_view_input(world_view);
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_view_input$4, return_value_gtk_widget_get_type$5);
    if(active == (struct _GtkWidget *)return_value_g_type_check_instance_cast$6)
    {
      buf=gm_world_view_buffer(world_view);
      signed int return_value_gtk_text_buffer_get_selection_bounds$3;
      return_value_gtk_text_buffer_get_selection_bounds$3=gtk_text_buffer_get_selection_bounds(buf, &start, &end);
      if(!(return_value_gtk_text_buffer_get_selection_bounds$3 == 0))
      {
        gtk_text_buffer_copy_clipboard(buf, clip);
        goto __CPROVER_DUMP_L9;
      }

    }

  }

  signed int tmp_statement_expression$9;
  _Bool tmp_if_expr$10;
  if(!(active == ((struct _GtkWidget *)NULL)))
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)active;
    unsigned long int __t;
    __t=gtk_text_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$10 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$9 = __r;
    if(!(tmp_statement_expression$9 == 0))
    {
      unsigned long int return_value_gtk_text_view_get_type$7;
      return_value_gtk_text_view_get_type$7=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)active, return_value_gtk_text_view_get_type$7);
      buf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$8);
      gtk_text_buffer_copy_clipboard(buf, clip);
    }

  }


__CPROVER_DUMP_L9:
  ;
}

// on_action_edit_cut
// file ./widgets/gm-commands.h line 12
void on_action_edit_cut(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GtkWidget *active;
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  active=gtk_window_get_focus((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
  struct _GtkClipboard *clip;
  clip=gtk_clipboard_get((struct _GdkAtom *)(void *)(unsigned long int)69);
  struct _GtkTextBuffer *buf;
  signed int tmp_statement_expression$5;
  _Bool tmp_if_expr$6;
  if(!(active == ((struct _GtkWidget *)NULL)))
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)active;
    unsigned long int __t;
    __t=gtk_text_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$6 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$5 = __r;
    if(!(tmp_statement_expression$5 == 0))
    {
      unsigned long int return_value_gtk_text_view_get_type$3;
      return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)active, return_value_gtk_text_view_get_type$3);
      buf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$4);
      gtk_text_buffer_cut_clipboard(buf, clip, (signed int)!(0 != 0));
    }

  }

}

// on_action_edit_paste
// file ./widgets/gm-commands.h line 14
void on_action_edit_paste(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GtkWidget *active;
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  active=gtk_window_get_focus((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
  struct _GtkClipboard *clip;
  clip=gtk_clipboard_get((struct _GdkAtom *)(void *)(unsigned long int)69);
  struct _GtkTextBuffer *buf;
  signed int tmp_statement_expression$5;
  _Bool tmp_if_expr$6;
  if(!(active == ((struct _GtkWidget *)NULL)))
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)active;
    unsigned long int __t;
    __t=gtk_text_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$6 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$5 = __r;
    if(!(tmp_statement_expression$5 == 0))
    {
      unsigned long int return_value_gtk_text_view_get_type$3;
      return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)active, return_value_gtk_text_view_get_type$3);
      buf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$4);
      gtk_text_buffer_paste_clipboard(buf, clip, (struct _GtkTextIter *)(void *)0, (signed int)!(0 != 0));
    }

  }

}

// on_action_edit_preferences
// file ./widgets/gm-commands.h line 17
void on_action_edit_preferences(struct _GtkAction *action, struct _GmAppView *view)
{
  gm_preferences_dialog_run();
}

// on_action_edit_scripts
// file ./widgets/gm-commands.h line 18
void on_action_edit_scripts(struct _GtkAction *action, struct _GmAppView *view)
{
  ;
}

// on_action_edit_triggers
// file ./widgets/gm-commands.h line 28
void on_action_edit_triggers(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmWorld *active;
  active=gm_app_view_active_world(view);
  gm_world_properties_dialog_run_triggers(active);
}

// on_action_edit_world
// file ./widgets/gm-commands.h line 16
void on_action_edit_world(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmWorld *active;
  active=gm_app_view_active_world(view);
  gm_world_properties_dialog_run(active);
}

// on_action_edit_worlds
// file ./widgets/gm-commands.h line 15
void on_action_edit_worlds(struct _GtkAction *action, struct _GmAppView *view)
{
  gm_worlds_list_dialog_run();
}

// on_action_editor_close
// file ./widgets/gm-commands.h line 26
void on_action_editor_close(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmEditorView *return_value_gm_app_view_active_editor_view$1;
  return_value_gm_app_view_active_editor_view$1=gm_app_view_active_editor_view(view);
  struct _GmEditor *return_value_gm_editor_view_editor$2;
  return_value_gm_editor_view_editor$2=gm_editor_view_editor(return_value_gm_app_view_active_editor_view$1);
  gm_editor_close(return_value_gm_editor_view_editor$2);
}

// on_action_editor_save
// file ./widgets/gm-commands.h line 23
void on_action_editor_save(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmEditorView *return_value_gm_app_view_active_editor_view$1;
  return_value_gm_app_view_active_editor_view$1=gm_app_view_active_editor_view(view);
  gm_editor_view_save(return_value_gm_app_view_active_editor_view$1);
}

// on_action_editor_save_close
// file ./widgets/gm-commands.h line 24
void on_action_editor_save_close(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmEditorView *editor_view;
  editor_view=gm_app_view_active_editor_view(view);
  gm_editor_view_save(editor_view);
  struct _GmEditor *return_value_gm_editor_view_editor$1;
  return_value_gm_editor_view_editor$1=gm_editor_view_editor(editor_view);
  gm_editor_close(return_value_gm_editor_view_editor$1);
}

// on_action_help_about
// file ./widgets/gm-commands.h line 30
void on_action_help_about(struct _GtkAction *action, struct _GmAppView *view)
{
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
  char *return_value_gettext$3;
  return_value_gettext$3=gettext("GnoeMoe");
  char *return_value_gettext$4;
  return_value_gettext$4=gettext("(C) 2004-2005 Icecrew.nl");
  char *return_value_gettext$5;
  return_value_gettext$5=gettext("GnoeMoe Gnome MOO Client");
  struct _GdkPixbuf *return_value_gm_pixbuf_get$6;
  return_value_gm_pixbuf_get$6=gm_pixbuf_get("gnoemoe_logo.svg");
  gtk_show_about_dialog((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, "name", return_value_gettext$3, (const void *)"version", (const void *)"2.2.0", (const void *)"copyright", return_value_gettext$4, (const void *)"comments", return_value_gettext$5, (const void *)"authors", (const void *)authors, (const void *)"artists", (const void *)artists, (const void *)"logo", return_value_gm_pixbuf_get$6, (void *)0);
}

// on_action_view_toolbar
// file ./widgets/gm-commands.h line 20
void on_action_view_toolbar(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  unsigned long int return_value_gtk_toggle_action_get_type$3;
  return_value_gtk_toggle_action_get_type$3=gtk_toggle_action_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)action, return_value_gtk_toggle_action_get_type$3);
  signed int return_value_gtk_toggle_action_get_active$5;
  return_value_gtk_toggle_action_get_active$5=gtk_toggle_action_get_active((struct _GtkToggleAction *)return_value_g_type_check_instance_cast$4);
  gm_options_set_int(return_value_gm_app_options$2, "show_toolbar", return_value_gtk_toggle_action_get_active$5 != 0 ? 1 : 0);
}

// on_action_view_userlist
// file ./widgets/gm-commands.h line 21
void on_action_view_userlist(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  unsigned long int return_value_gtk_toggle_action_get_type$3;
  return_value_gtk_toggle_action_get_type$3=gtk_toggle_action_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)action, return_value_gtk_toggle_action_get_type$3);
  signed int return_value_gtk_toggle_action_get_active$5;
  return_value_gtk_toggle_action_get_active$5=gtk_toggle_action_get_active((struct _GtkToggleAction *)return_value_g_type_check_instance_cast$4);
  gm_options_set_int(return_value_gm_app_options$2, "show_userlist", return_value_gtk_toggle_action_get_active$5 != 0 ? 1 : 0);
}

// on_action_world_close
// file ./widgets/gm-commands.h line 9
void on_action_world_close(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmWorld *world;
  world=gm_app_view_active_world(view);
  if(!(world == ((struct _GmWorld *)NULL)))
    gm_world_unload(world);

}

// on_action_world_connect
// file ./widgets/gm-commands.h line 6
void on_action_world_connect(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GmWorld *world;
  world=gm_app_view_active_world(view);
  if(!(world == ((struct _GmWorld *)NULL)))
  {
    signed int return_value_gm_world_disconnected$1;
    return_value_gm_world_disconnected$1=gm_world_disconnected(world);
    if(!(return_value_gm_world_disconnected$1 == 0))
      gm_world_connect(world);

    else
      gm_world_disconnect(world);
  }

}

// on_action_world_logs
// file ./widgets/gm-commands.h line 8
void on_action_world_logs(struct _GtkAction *action, struct _GmAppView *view)
{
  struct _GtkDialog *dlg;
  struct _GtkTreeView *tview;
  struct _GtkTreeModel *smodel;
  char *tmp;
  char *tmp2;
  struct _GtkTreeIter iter;
  signed int done = 0;
  struct _GdkCursor *wait_cursor;
  struct _GmWorld *world;
  world=gm_app_view_active_world(view);
  struct _GmWorld *return_value_gm_app_view_active_world$1;
  return_value_gm_app_view_active_world$1=gm_app_view_active_world(view);
  dlg=gm_world_logs_dialog_new(return_value_gm_app_view_active_world$1, &tview);
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$12;
  signed int return_value_gtk_tree_selection_get_selected$13;
  if(!(dlg == ((struct _GtkDialog *)NULL)))
  {
    smodel=gtk_tree_view_get_model(tview);
    while(done == 0)
    {
      done = (signed int)!(0 != 0);
      signed int return_value_gtk_dialog_run$2;
      return_value_gtk_dialog_run$2=gtk_dialog_run(dlg);
      if(return_value_gtk_dialog_run$2 == -5)
      {
        return_value_gtk_tree_view_get_selection$12=gtk_tree_view_get_selection(tview);
        return_value_gtk_tree_selection_get_selected$13=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection$12, &smodel, &iter);
        if(!(return_value_gtk_tree_selection_get_selected$13 == 0))
        {
          gtk_tree_model_get(smodel, &iter, 0, &tmp, -1);
          const char *return_value_gm_world_path$3;
          return_value_gm_world_path$3=gm_world_path(world);
          tmp2=g_strconcat(return_value_gm_world_path$3, (const void *)"/", (const void *)"logs", (const void *)"/", tmp, (void *)0);
          unsigned long int return_value_gtk_widget_get_type$4;
          return_value_gtk_widget_get_type$4=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
          return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_widget_get_type$4);
          gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$5, 0);
          wait_cursor=gdk_cursor_new((enum anonymous$37)GDK_WATCH);
          unsigned long int return_value_gtk_widget_get_type$6;
          return_value_gtk_widget_get_type$6=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
          return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_widget_get_type$6);
          gdk_window_set_cursor(((struct _GtkWidget *)return_value_g_type_check_instance_cast$7)->window, wait_cursor);
          gdk_cursor_unref(wait_cursor);
          struct _GmWorldView *return_value_gm_app_view_active_world_view$8;
          return_value_gm_app_view_active_world_view$8=gm_app_view_active_world_view(view);
          gm_world_view_open_log(return_value_gm_app_view_active_world_view$8, tmp2);
          unsigned long int return_value_gtk_widget_get_type$9;
          return_value_gtk_widget_get_type$9=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
          return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_widget_get_type$9);
          gdk_window_set_cursor(((struct _GtkWidget *)return_value_g_type_check_instance_cast$10)->window, (struct _GdkCursor *)(void *)0);
          g_free((void *)tmp2);
          g_free((void *)tmp);
        }

        else
        {
          char *return_value_gettext$11;
          return_value_gettext$11=gettext("You didn't select a log file");
          gm_error_dialog(return_value_gettext$11, (struct _GtkWindow *)(void *)0);
          done = 0;
        }
        goto __CPROVER_DUMP_L6;
      }


    __CPROVER_DUMP_L6:
      ;
    }
    unsigned long int return_value_gtk_widget_get_type$14;
    return_value_gtk_widget_get_type$14=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_widget_get_type$14);
    gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$15);
  }

}

// on_action_world_new
// file ./widgets/gm-commands.h line 4
void on_action_world_new(struct _GtkAction *action, struct _GmAppView *view)
{
  gm_world_properties_dialog_run_new((struct _GmWorld *)(void *)0);
}

// on_action_world_open
// file ./widgets/gm-commands.h line 5
void on_action_world_open(struct _GtkAction *action, struct _GmAppView *view)
{
  gm_open_world_dialog_run();
}

// on_action_world_paste
// file ./widgets/gm-commands.h line 7
void on_action_world_paste(struct _GtkAction *action, struct _GmAppView *view)
{
  gm_world_paste_dialog_run(view);
}

// on_action_world_quit
// file ./widgets/gm-commands.h line 10
void on_action_world_quit(struct _GtkAction *action, struct _GmAppView *view)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$1);
  gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
}

// on_adj_changed
// file mcp/gm-mcp-userlist-view.c line 270
static void on_adj_changed(struct _GtkAdjustment *adj, struct _GmMcpUserlistView *view)
{
  double return_value_gtk_adjustment_get_value$1;
  if(!(view->idle_scroll == 0ul))
  {
    return_value_gtk_adjustment_get_value$1=gtk_adjustment_get_value(adj);
    if(IEEE_FLOAT_NOTEQUAL(return_value_gtk_adjustment_get_value$1, view->scroll_position))
    {
      gtk_adjustment_set_value(adj, view->scroll_position);
      g_source_remove((unsigned int)view->idle_scroll);
      view->idle_scroll = (unsigned long int)0;
    }

  }

}

// on_button_add_action_clicked
// file dialogs/gm-triggers-dialog.c line 997
void on_button_add_action_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers)
{
  gm_triggers_dialog_new_action(triggers);
}

// on_button_add_condition_clicked
// file dialogs/gm-triggers-dialog.c line 992
void on_button_add_condition_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers)
{
  gm_triggers_dialog_new_condition(triggers);
}

// on_button_add_trigger_clicked
// file dialogs/gm-world-properties-dialog.c line 701
void on_button_add_trigger_clicked(struct _GtkButton *button, struct _GmWorldPropertiesDialog *properties)
{
  struct _GmTrigger *trigger;
  trigger=gm_triggers_dialog_run_new(properties->world, (struct _GmTrigger *)(void *)0);
  if(!(trigger == ((struct _GmTrigger *)NULL)))
    gm_world_properties_dialog_add_trigger(properties, trigger);

}

// on_button_browse_clicked
// file dialogs/gm-triggers-dialog.c line 831
void on_button_browse_clicked(struct _GtkButton *widget, struct _GtkEntry *entry)
{
  char *tmp;
  struct _GtkWidget *d;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Select file");
  d=gtk_file_chooser_dialog_new(return_value_gettext$1, (struct _GtkWindow *)(void *)0, (enum anonymous$155)GTK_FILE_CHOOSER_ACTION_OPEN, "gtk-cancel", -6, (const void *)"gtk-open", -3, (void *)0);
  unsigned long int return_value_gtk_dialog_get_type$4;
  return_value_gtk_dialog_get_type$4=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$4);
  signed int return_value_gtk_dialog_run$6;
  return_value_gtk_dialog_run$6=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$5);
  if(return_value_gtk_dialog_run$6 == -3)
  {
    unsigned long int return_value_gtk_file_chooser_get_type$2;
    return_value_gtk_file_chooser_get_type$2=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_file_chooser_get_type$2);
    tmp=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$3);
    gtk_entry_set_text(entry, tmp);
    g_free((void *)tmp);
  }

  gtk_widget_destroy(d);
}

// on_button_delete_trigger_clicked
// file dialogs/gm-world-properties-dialog.c line 747
void on_button_delete_trigger_clicked(struct _GtkButton *button, struct _GmWorldPropertiesDialog *properties)
{
  struct _GtkTreeIter iter;
  struct _GmTrigger *trigger;
  trigger=gm_world_properties_dialog_selected_trigger(properties, &iter);
  if(!(trigger == ((struct _GmTrigger *)NULL)))
  {
    gm_world_properties_dialog_remove_trigger(properties, &iter);
    gm_trigger_free(trigger);
  }

  else
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("First select a trigger to remove");
    unsigned long int return_value_gtk_window_get_type$2;
    return_value_gtk_window_get_type$2=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$2);
    gm_error_dialog(return_value_gettext$1, (struct _GtkWindow *)return_value_g_type_check_instance_cast$3);
  }
}

// on_button_edit_trigger_clicked
// file dialogs/gm-world-properties-dialog.c line 726
void on_button_edit_trigger_clicked(struct _GtkButton *button, struct _GmWorldPropertiesDialog *properties)
{
  struct _GtkTreeIter iter;
  struct _GmTrigger *trigger;
  struct _GmTrigger *newt;
  trigger=gm_world_properties_dialog_selected_trigger(properties, &iter);
  if(!(trigger == ((struct _GmTrigger *)NULL)))
  {
    newt=gm_triggers_dialog_run(properties->world, trigger);
    if(!(newt == ((struct _GmTrigger *)NULL)))
      gm_world_properties_dialog_update_trigger(properties, &iter, trigger);

  }

  else
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Select a trigger to edit first");
    unsigned long int return_value_gtk_window_get_type$2;
    return_value_gtk_window_get_type$2=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_window_get_type$2);
    gm_error_dialog(return_value_gettext$1, (struct _GtkWindow *)return_value_g_type_check_instance_cast$3);
  }
}

// on_button_next_clicked
// file dialogs/gm-triggers-dialog.c line 675
void on_button_next_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers)
{
  struct _GtkTreeSelection *selection;
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  signed int type;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$1);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_tree_view_get_type$3;
  return_value_gtk_tree_view_get_type$3=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$3);
  model=gtk_tree_view_get_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$4);
  signed int return_value_gtk_tree_selection_get_selected$10;
  return_value_gtk_tree_selection_get_selected$10=gtk_tree_selection_get_selected(selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$10 == 0))
  {
    gtk_tree_model_get(model, &iter, 2, &type, -1);
    triggers->trigger->event = (enum _GmTriggerType)type;
    unsigned long int return_value_gtk_notebook_get_type$5;
    return_value_gtk_notebook_get_type$5=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)triggers->notebook_triggers, return_value_gtk_notebook_get_type$5);
    gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$6, 1);
  }

  else
  {
    char *return_value_gettext$7;
    return_value_gettext$7=gettext("Select a event type first");
    unsigned long int return_value_gtk_window_get_type$8;
    return_value_gtk_window_get_type$8=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$8);
    gm_error_dialog(return_value_gettext$7, (struct _GtkWindow *)return_value_g_type_check_instance_cast$9);
  }
}

// on_button_remove_clicked
// file dialogs/gm-triggers-dialog.c line 986
void on_button_remove_clicked(struct _GtkButton *button, struct _GmTriggersDialog *triggers)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_widget_get_type$1);
  struct _GtkWidget *return_value_gtk_widget_get_parent$3;
  return_value_gtk_widget_get_parent$3=gtk_widget_get_parent((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  g_idle_add((signed int (*)(void *))gm_triggers_dialog_idle_remove_item, (void *)return_value_gtk_widget_get_parent$3);
}

// on_color_changed
// file gm-support.c line 729
void on_color_changed(struct _GmColorTable *table, const char *color, struct _GtkWidget *widget)
{
  struct _GdkColor col;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "gm_schemed_modifying_style", (void *)(signed long int)1);
  signed int return_value_strcmp$5;
  return_value_strcmp$5=strcmp(color, "fg_default");
  signed int tmp_statement_expression$2;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$4;
  if(return_value_strcmp$5 == 0)
  {
    gm_color_table_get(table, color, &col);
    gtk_widget_modify_text(widget, (enum anonymous$23)GTK_STATE_NORMAL, &col);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget;
    unsigned long int __t;
    __t=gtk_text_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$3 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$2 = __r;
    if(!(tmp_statement_expression$2 == 0))
      modify_cursor_color(widget, &col);

  }

  else
  {
    return_value_strcmp$4=strcmp(color, "bg_default");
    if(return_value_strcmp$4 == 0)
    {
      gm_color_table_get(table, color, &col);
      gtk_widget_modify_base(widget, (enum anonymous$23)GTK_STATE_NORMAL, &col);
    }

  }
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$6, "gm_schemed_modifying_style", (void *)(signed long int)0);
}

// on_combo_box_type_changed
// file dialogs/gm-triggers-dialog.c line 892
void on_combo_box_type_changed(struct _GtkComboBox *widget, struct _ComboBoxTypeData *tdata)
{
  struct _GtkWidget *parent;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_widget_get_type$1);
  parent=gtk_widget_get_parent((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  struct _GList *item;
  struct _GList *children;
  unsigned long int return_value_gtk_container_get_type$3;
  return_value_gtk_container_get_type$3=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gtk_container_get_type$3);
  children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$4);
  struct _ModelData *data;
  struct _GtkTreeIter iter;
  struct _GtkWidget *tmp;
  item = children->next;
  _Bool tmp_if_expr$5;
  do
  {
    if(!(item == ((struct _GList *)NULL)))
      tmp_if_expr$5 = item->next != ((struct _GList *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(!tmp_if_expr$5)
      break;

    unsigned long int return_value_gtk_widget_get_type$6;
    return_value_gtk_widget_get_type$6=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)item->data, return_value_gtk_widget_get_type$6);
    gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$7);
    item = item->next;
  }
  while((_Bool)1);
  g_list_free(children);
  signed int return_value_gtk_combo_box_get_active_iter$13;
  return_value_gtk_combo_box_get_active_iter$13=gtk_combo_box_get_active_iter(widget, &iter);
  unsigned long int return_value_gtk_box_get_type$11;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  if(!(return_value_gtk_combo_box_get_active_iter$13 == 0))
  {
    struct _GtkTreeModel *return_value_gtk_combo_box_get_model$8;
    return_value_gtk_combo_box_get_model$8=gtk_combo_box_get_model(widget);
    gtk_tree_model_get(return_value_gtk_combo_box_get_model$8, &iter, 1, &data, -1);
    switch(data->args)
    {
      case 1:
      {
        tmp=gtk_entry_new();
        if(!(tdata->data == ((struct _GmTriggerData *)NULL)))
        {
          unsigned long int return_value_gtk_entry_get_type$9;
          return_value_gtk_entry_get_type$9=gtk_entry_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
          return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)tmp, return_value_gtk_entry_get_type$9);
          gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$10, tdata->data->data);
        }

        gtk_widget_show(tmp);
        return_value_gtk_box_get_type$11=gtk_box_get_type();
        return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gtk_box_get_type$11);
        gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$12, tmp, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
        break;
      }
      case 2:
        data->func(tdata->triggers, (enum _CustomArgType)CUSTOM_ARG_CREATE, (void *)parent, (void *)tdata->data);
      default:
        ;
    }
    if(!(tdata->data == ((struct _GmTriggerData *)NULL)))
      tdata->data = (struct _GmTriggerData *)(void *)0;

  }

  else
    gm_debug_msg(DEBUG_ALWAYS, "No active iter!");
}

// on_combo_box_type_destroy
// file dialogs/gm-triggers-dialog.c line 938
void on_combo_box_type_destroy(struct _GtkObject *object, struct _ComboBoxTypeData *tdata)
{
  g_free((void *)tdata);
}

// on_font_changed
// file gm-support.c line 753
void on_font_changed(struct _GmColorTable *table, const char *font, struct _GtkWidget *widget)
{
  struct _PangoFontDescription *desc;
  desc=pango_font_description_from_string(font);
  if(!(desc == ((struct _PangoFontDescription *)NULL)))
  {
    gtk_widget_modify_font(widget, desc);
    pango_font_description_free(desc);
  }

}

// on_gm_app_save_session
// file gm-app.c line 226
static signed int on_gm_app_save_session(struct _GnomeClient *client, signed int phase, enum anonymous$55 save_style, signed int is_shutdown, enum anonymous$53 interact_style, signed int is_fast, char **client_data)
{
  char **argv;
  signed int argc = (signed int)(sizeof(char **) /*8ul*/  / sizeof(char *) /*8ul*/  + (unsigned long int)1);
  signed int i;
  struct _GString *ws;
  ws=g_string_new("");
  struct _GList *elem;
  struct _GList *list;
  struct _GmWorld *world;
  void *return_value_g_malloc_n$1;
  return_value_g_malloc_n$1=g_malloc_n((unsigned long int)argc, sizeof(char *) /*8ul*/ );
  argv = (char **)return_value_g_malloc_n$1;
  argv[(signed long int)0] = client_data[(signed long int)0];
  argv[(signed long int)1] = "--recover";
  i = 1;
  for( ; !(i >= argc + -1); i = i + 1)
    argv[(signed long int)(i + 1)] = client_data[(signed long int)i];
  gnome_client_set_clone_command(client, argc, argv);
  gnome_client_set_restart_command(client, argc, argv);
  list=gm_app_worlds(application);
  elem = list;
  for( ; !(elem == ((struct _GList *)NULL)); elem = elem->next)
  {
    world = (struct _GmWorld *)elem->data;
    signed int return_value_gm_world_loaded$4;
    return_value_gm_world_loaded$4=gm_world_loaded(world);
    if(!(return_value_gm_world_loaded$4 == 0))
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(ws->str);
      if(!(return_value_strlen$2 == 0ul))
        ws=g_string_append_c_inline$link3(ws, (char)59);

      const char *return_value_gm_world_name$3;
      return_value_gm_world_name$3=gm_world_name(world);
      ws=g_string_append(ws, return_value_gm_world_name$3);
    }

  }
  g_list_free(list);
  struct _GmOptions *return_value_gm_app_options$5;
  return_value_gm_app_options$5=gm_app_options(application);
  gm_options_set(return_value_gm_app_options$5, "worlds_saved_state", ws->str);
  struct _GmOptions *return_value_gm_app_options$6;
  return_value_gm_app_options$6=gm_app_options(application);
  gm_options_save(return_value_gm_app_options$6);
  g_string_free(ws, (signed int)!(0 != 0));
  return (signed int)!(0 != 0);
}

// on_gm_app_session_die
// file gm-app.c line 221
static void on_gm_app_session_die(struct _GnomeClient *client, void *client_data)
{
  gtk_main_quit();
}

// on_gm_app_view_accel_cycle_page
// file widgets/gm-app-view.c line 1168
void on_gm_app_view_accel_cycle_page(struct _GtkAccelGroup *accelgroup, struct _GObject *arg1, unsigned int arg2, enum anonymous$0 arg3, struct _AccelInfo *info)
{
  struct _GtkNotebook *note = info->view->priv->notebook;
  signed int p;
  signed int return_value_gtk_notebook_get_current_page$1;
  return_value_gtk_notebook_get_current_page$1=gtk_notebook_get_current_page(note);
  p = return_value_gtk_notebook_get_current_page$1 + info->num;
  signed int return_value_gtk_notebook_get_n_pages$3;
  if(!(p >= 0))
  {
    signed int return_value_gtk_notebook_get_n_pages$2;
    return_value_gtk_notebook_get_n_pages$2=gtk_notebook_get_n_pages(note);
    gtk_notebook_set_current_page(note, return_value_gtk_notebook_get_n_pages$2 - 1);
  }

  else
  {
    return_value_gtk_notebook_get_n_pages$3=gtk_notebook_get_n_pages(note);
    if(!(return_value_gtk_notebook_get_n_pages$3 + -1 >= p))
      gtk_notebook_set_current_page(note, 0);

    else
      gtk_notebook_set_current_page(note, p);
  }
}

// on_gm_app_view_accel_switch_edit
// file widgets/gm-app-view.c line 1158
void on_gm_app_view_accel_switch_edit(struct _GtkAccelGroup *accelgroup, struct _GObject *arg1, unsigned int arg2, enum anonymous$0 arg3, struct _AccelInfo *info)
{
  struct _GmWorldView *view;
  view=gm_app_view_active_world_view(info->view);
  if(!(view == ((struct _GmWorldView *)NULL)))
  {
    unsigned long int return_value_gtk_notebook_get_type$1;
    return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
    gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2, info->num);
  }

}

// on_gm_app_view_accel_switch_page
// file widgets/gm-app-view.c line 1151
void on_gm_app_view_accel_switch_page(struct _GtkAccelGroup *accelgroup, struct _GObject *arg1, unsigned int arg2, enum anonymous$0 arg3, struct _AccelInfo *info)
{
  gtk_notebook_set_current_page(info->view->priv->notebook, info->num);
}

// on_gm_app_view_button_find_clicked
// file widgets/gm-app-view.c line 1283
void on_gm_app_view_button_find_clicked(struct _GtkButton *button, void *user_data)
{
  on_gm_app_view_edit_find_next((struct _GtkMenuItem *)(void *)0, (struct _GmAppView *)(void *)0);
}

// on_gm_app_view_button_find_close_clicked
// file widgets/gm-app-view.c line 1331
void on_gm_app_view_button_find_close_clicked(struct _GtkButton *button, struct _GmAppView *view)
{
  struct _GmWorldView *world_view;
  world_view=gm_app_view_active_world_view(view);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->vbox_find, return_value_gtk_widget_get_type$1);
  gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  if(!(world_view == ((struct _GmWorldView *)NULL)))
    gm_world_view_set_focus(world_view);

}

// on_gm_app_view_button_replace_all_clicked
// file widgets/gm-app-view.c line 1298
void on_gm_app_view_button_replace_all_clicked(struct _GtkButton *button, struct _GmAppView *view)
{
  struct _GmWorldView *return_value_gm_app_view_active_world_view$1;
  return_value_gm_app_view_active_world_view$1=gm_app_view_active_world_view(view);
  const char *return_value_gtk_entry_get_text$2;
  return_value_gtk_entry_get_text$2=gtk_entry_get_text(view->priv->entry_find);
  const char *return_value_gtk_entry_get_text$3;
  return_value_gtk_entry_get_text$3=gtk_entry_get_text(view->priv->entry_replace);
  enum _GmSearchableSearchFlags return_value_gm_app_view_search_flags$4;
  return_value_gm_app_view_search_flags$4=gm_app_view_search_flags(view);
  gm_world_view_replace_all(return_value_gm_app_view_active_world_view$1, return_value_gtk_entry_get_text$2, return_value_gtk_entry_get_text$3, return_value_gm_app_view_search_flags$4);
}

// on_gm_app_view_button_replace_clicked
// file widgets/gm-app-view.c line 1288
void on_gm_app_view_button_replace_clicked(struct _GtkButton *button, struct _GmAppView *view)
{
  struct _GmWorldView *return_value_gm_app_view_active_world_view$4;
  return_value_gm_app_view_active_world_view$4=gm_app_view_active_world_view(view);
  const char *return_value_gtk_entry_get_text$5;
  return_value_gtk_entry_get_text$5=gtk_entry_get_text(view->priv->entry_replace);
  signed int return_value_gm_world_view_replace$6;
  return_value_gm_world_view_replace$6=gm_world_view_replace(return_value_gm_app_view_active_world_view$4, return_value_gtk_entry_get_text$5);
  if(!(return_value_gm_world_view_replace$6 == 0))
  {
    struct _GmWorldView *return_value_gm_app_view_active_world_view$1;
    return_value_gm_app_view_active_world_view$1=gm_app_view_active_world_view(view);
    const char *return_value_gtk_entry_get_text$2;
    return_value_gtk_entry_get_text$2=gtk_entry_get_text(view->priv->entry_find);
    enum _GmSearchableSearchFlags return_value_gm_app_view_search_flags$3;
    return_value_gm_app_view_search_flags$3=gm_app_view_search_flags(view);
    gm_world_view_find_next(return_value_gm_app_view_active_world_view$1, return_value_gtk_entry_get_text$2, return_value_gm_app_view_search_flags$3);
  }

}

// on_gm_app_view_check_button_search_direction_toggled
// file widgets/gm-app-view.c line 1352
void on_gm_app_view_check_button_search_direction_toggled(struct _GtkToggleButton *button, struct _GmAppView *view)
{
  struct _GmWorldView *active_view;
  signed int active;
  if(view->priv->ignore_toggling == 0)
  {
    active_view=gm_app_view_active_world_view(view);
    if(!(active_view == ((struct _GmWorldView *)NULL)))
    {
      active=gtk_toggle_button_get_active(button);
      unsigned long int return_value_gtk_notebook_get_type$3;
      return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)active_view, return_value_gtk_notebook_get_type$3);
      signed int return_value_gtk_notebook_get_current_page$5;
      return_value_gtk_notebook_get_current_page$5=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4);
      if(return_value_gtk_notebook_get_current_page$5 == 0)
      {
        struct _GmOptions *return_value_gm_app_options$1;
        return_value_gm_app_options$1=gm_app_options(view->priv->application);
        gm_options_set_int(return_value_gm_app_options$1, "search_direction_world", active != 0 ? 1 : 0);
      }

      else
      {
        struct _GmOptions *return_value_gm_app_options$2;
        return_value_gm_app_options$2=gm_app_options(view->priv->application);
        gm_options_set_int(return_value_gm_app_options$2, "search_direction", active != 0 ? 1 : 0);
      }
    }

  }

}

// on_gm_app_view_check_button_search_sensitive_toggled
// file widgets/gm-app-view.c line 1343
void on_gm_app_view_check_button_search_sensitive_toggled(struct _GtkToggleButton *button, struct _GmAppView *view)
{
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GmOptions *return_value_gm_app_options$1;
  return_value_gm_app_options$1=gm_app_options(view->priv->application);
  gm_options_set_int(return_value_gm_app_options$1, "search_sensitive", active != 0 ? 1 : 0);
}

// on_gm_app_view_edit_find
// file widgets/gm-app-view.c line 1256
void on_gm_app_view_edit_find(struct _GtkMenuItem *menuitem, struct _GmAppView *view)
{
  struct _GtkWidget *entry;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->entry_find, return_value_gtk_widget_get_type$1);
  entry = (struct _GtkWidget *)return_value_g_type_check_instance_cast$2;
  gm_app_view_show_find_box(view);
  gtk_widget_grab_focus(entry);
  gtk_widget_modify_base(entry, (enum anonymous$23)GTK_STATE_NORMAL, (const struct _GdkColor *)(void *)0);
}

// on_gm_app_view_edit_find_next
// file widgets/gm-app-view.c line 1265
void on_gm_app_view_edit_find_next(struct _GtkMenuItem *menuitem, struct _GmAppView *view)
{
  gm_app_view_show_find_box(view);
  struct _GmWorldView *return_value_gm_app_view_active_world_view$1;
  return_value_gm_app_view_active_world_view$1=gm_app_view_active_world_view(view);
  const char *return_value_gtk_entry_get_text$2;
  return_value_gtk_entry_get_text$2=gtk_entry_get_text(view->priv->entry_find);
  enum _GmSearchableSearchFlags return_value_gm_app_view_search_flags$3;
  return_value_gm_app_view_search_flags$3=gm_app_view_search_flags(view);
  gm_world_view_find_next(return_value_gm_app_view_active_world_view$1, return_value_gtk_entry_get_text$2, return_value_gm_app_view_search_flags$3);
}

// on_gm_app_view_edit_replace
// file widgets/gm-app-view.c line 1274
void on_gm_app_view_edit_replace(struct _GtkMenuItem *menuitem, struct _GmAppView *view)
{
  struct _GtkWidget *entry;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->entry_replace, return_value_gtk_widget_get_type$1);
  entry = (struct _GtkWidget *)return_value_g_type_check_instance_cast$2;
  gm_app_view_show_find_box(view);
  gm_app_view_show_replace_box(view);
  gtk_widget_grab_focus(entry);
}

// on_gm_app_view_entry_find_activate
// file widgets/gm-app-view.c line 1236
void on_gm_app_view_entry_find_activate(struct _GtkEntry *entry, struct _GmAppView *view)
{
  on_gm_app_view_edit_find_next((struct _GtkMenuItem *)(void *)0, view);
}

// on_gm_app_view_entry_find_changed
// file widgets/gm-app-view.c line 1231
void on_gm_app_view_entry_find_changed(struct _GtkEditable *editable, struct _GmAppView *view)
{
  g_idle_add((signed int (*)(void *))gm_app_view_find_first, (void *)view);
}

// on_gm_app_view_entry_find_key_press
// file widgets/gm-app-view.c line 1319
signed int on_gm_app_view_entry_find_key_press(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GmAppView *view)
{
  if(event->keyval == 65307u)
  {
    on_gm_app_view_button_find_close_clicked((struct _GtkButton *)(void *)0, view);
    struct _GmWorldView *return_value_gm_app_view_active_world_view$1;
    return_value_gm_app_view_active_world_view$1=gm_app_view_active_world_view(view);
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_app_view_active_world_view$1, return_value_gtk_widget_get_type$2);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$3);
    return (signed int)!(0 != 0);
  }

  else
    return 0;
}

// on_gm_app_view_expander_replace
// file widgets/gm-app-view.c line 1306
void on_gm_app_view_expander_replace(struct _GObject *object, struct _GParamSpec *param_spec, struct _GmAppView *view)
{
  signed int exp;
  exp=gtk_expander_get_expanded(view->priv->expander_replace);
  if(!(exp == 0))
    gm_app_view_show_replace_box(view);

  else
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->label_replace, return_value_gtk_widget_get_type$1);
    gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hbox_replace, return_value_gtk_widget_get_type$3);
    gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
  }
}

// on_gm_app_view_motion_notify
// file widgets/gm-app-view.c line 1477
signed int on_gm_app_view_motion_notify(struct _GtkWidget *widget, struct _GdkEventMotion *event, struct _GmAppView *view)
{
  signed int page_num;
  if(view->priv->drag_in_progress == 0)
  {
    signed int return_value_gtk_drag_check_threshold$1;
    return_value_gtk_drag_check_threshold$1=gtk_drag_check_threshold(widget, view->priv->x_start, view->priv->y_start, (signed int)event->x_root, (signed int)event->y_root);
    if(!(return_value_gtk_drag_check_threshold$1 == 0))
    {
      gm_app_view_drag_start(view, event->time);
      return (signed int)!(0 != 0);
    }

    return 0;
  }

  page_num=gm_app_view_find_tab_num_at_pos(view, (signed int)event->x_root, (signed int)event->y_root);
  if(!(page_num == -1))
    gm_app_view_move_current_tab(view, page_num);

  return 0;
}

// on_gm_app_view_notebook_button_press
// file widgets/gm-app-view.c line 1505
signed int on_gm_app_view_notebook_button_press(struct _GtkNotebook *notebook, struct _GdkEventButton *event, struct _GmAppView *view)
{
  signed int tab_clicked;
  _Bool tmp_if_expr$5;
  if(!(view->priv->drag_in_progress == 0))
    return (signed int)!(0 != 0);

  else
  {
    tab_clicked=gm_app_view_find_tab_num_at_pos(view, (signed int)event->x_root, (signed int)event->y_root);
    if(event->button == 1u)
      tmp_if_expr$5 = (signed int)event->type == GDK_BUTTON_PRESS ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tab_clicked >= 0 && tmp_if_expr$5)
    {
      view->priv->x_start = (signed int)event->x_root;
      view->priv->y_start = (signed int)event->y_root;
      view->priv->tab = tab_clicked;
      struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
      return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)notebook, (unsigned long int)(20 << 2));
      unsigned long int return_value_g_signal_connect_data$2;
      return_value_g_signal_connect_data$2=g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, "motion-notify-event", (void (*)(void))on_gm_app_view_motion_notify, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
      view->priv->motion_notify_handler_id = (signed int)return_value_g_signal_connect_data$2;
    }

    else
      if((signed int)event->type == GDK_BUTTON_PRESS)
      {
        if(event->button == 3u)
        {
          if(tab_clicked == -1)
            return (signed int)!(0 != 0);

          else
          {
            unsigned long int return_value_gtk_notebook_get_type$3;
            return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
            return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type$3);
            gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, tab_clicked);
          }
        }

      }

    return 0;
  }
}

// on_gm_app_view_notebook_button_release
// file widgets/gm-app-view.c line 1537
signed int on_gm_app_view_notebook_button_release(struct _GtkNotebook *notebook, struct _GdkEventButton *event, struct _GmAppView *view)
{
  if(!(view->priv->drag_in_progress == 0))
  {
    signed int cur_page_num;
    struct _GtkWidget *cur_page;
    cur_page_num=gtk_notebook_get_current_page(notebook);
    cur_page=gtk_notebook_get_nth_page(notebook, cur_page_num);
    signed int return_value_gdk_pointer_is_grabbed$1;
    return_value_gdk_pointer_is_grabbed$1=gdk_pointer_is_grabbed();
    if(!(return_value_gdk_pointer_is_grabbed$1 == 0))
      gdk_pointer_ungrab(event->time);

    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_widget_get_type$2);
    gtk_grab_remove((struct _GtkWidget *)return_value_g_type_check_instance_cast$3);
  }

  gm_app_view_drag_stop(view);
  return 0;
}

// on_gm_app_view_notebook_switch_page
// file widgets/gm-app-view.c line 1626
void on_gm_app_view_notebook_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num, struct _GmAppView *view)
{
  struct _GmWorld *world;
  world=gm_app_view_active_world(view);
  if(!(view->priv->active_world == world))
  {
    if(!(view->priv->active_world == ((struct _GmWorld *)NULL)))
      gm_world_set_active(view->priv->active_world, 0);

    if(!(world == ((struct _GmWorld *)NULL)))
    {
      view->priv->active_world = world;
      gm_world_set_active(view->priv->active_world, (signed int)!(0 != 0));
      struct _GmWorldView *return_value_gm_app_view_active_world_view$1;
      return_value_gm_app_view_active_world_view$1=gm_app_view_active_world_view(view);
      unsigned long int return_value_gtk_notebook_get_type$2;
      return_value_gtk_notebook_get_type$2=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_app_view_active_world_view$1, return_value_gtk_notebook_get_type$2);
      on_gm_app_view_world_view_notebook_switch_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$3, (struct _GtkNotebookPage *)(void *)0, (unsigned int)0, view);
    }

    struct _GmWorldView *return_value_gm_app_view_active_world_view$4;
    return_value_gm_app_view_active_world_view$4=gm_app_view_active_world_view(view);
    g_signal_emit((void *)view, gm_app_view_signals[(signed long int)0], (unsigned int)0, return_value_gm_app_view_active_world_view$4);
  }

}

// on_gm_app_view_option_changed
// file widgets/gm-app-view.c line 1763
void on_gm_app_view_option_changed(struct _GmOptions *options, const char *key, struct _GmAppView *view)
{
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(key, "show_toolbar");
  unsigned long int return_value_gtk_widget_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_widget_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  if(return_value_strcmp$6 == 0)
  {
    signed int return_value_gm_options_get_int$5;
    return_value_gm_options_get_int$5=gm_options_get_int(options, "show_toolbar");
    if(!(return_value_gm_options_get_int$5 == 0))
    {
      return_value_gtk_widget_get_type$1=gtk_widget_get_type();
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->toolbar, return_value_gtk_widget_get_type$1);
      gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    }

    else
    {
      return_value_gtk_widget_get_type$3=gtk_widget_get_type();
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->toolbar, return_value_gtk_widget_get_type$3);
      gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
    }
  }

}

// on_gm_app_view_tray_button_press
// file widgets/gm-app-view.c line 1714
signed int on_gm_app_view_tray_button_press(struct _GmTray *tray, struct _GdkEventButton *event, struct _GmAppView *view)
{
  _Bool tmp_if_expr$1;
  if((signed int)event->type == GDK_2BUTTON_PRESS)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)event->type == GDK_3BUTTON_PRESS ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    if(event->button == 1u)
      gm_app_view_toggle_visibility(view);

    return 0;
  }
}

// on_gm_app_view_tray_destroy
// file widgets/gm-app-view.c line 1754
void on_gm_app_view_tray_destroy(struct _GtkWidget *caller, struct _GmAppView *view)
{
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)caller, (unsigned long int)(20 << 2));
  g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1);
  view->priv->tray = (struct _GmTray *)(void *)0;
  view->priv->tray_idle_create=g_idle_add(idle_create_tray, (void *)view);
}

// on_gm_app_view_tray_message_clicked
// file widgets/gm-app-view.c line 1728
void on_gm_app_view_tray_message_clicked(struct _GmTray *tray, struct _GmAppView *view)
{
  signed int visible;
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_object_get_type$1);
  visible = (signed int)((((struct _GtkObject *)return_value_g_type_check_instance_cast$2)->flags & (unsigned int)256) != (unsigned int)0);
  _Bool tmp_if_expr$8;
  unsigned long int return_value_gtk_window_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  signed int return_value_gtk_window_is_active$7;
  if(visible == 0)
    tmp_if_expr$8 = (_Bool)1;

  else
  {
    return_value_gtk_window_get_type$5=gtk_window_get_type();
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$5);
    return_value_gtk_window_is_active$7=gtk_window_is_active((struct _GtkWindow *)return_value_g_type_check_instance_cast$6);
    tmp_if_expr$8 = !(return_value_gtk_window_is_active$7 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$8)
  {
    gm_app_view_toggle_visibility(view);
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$3);
    gdk_window_focus(((struct _GtkWidget *)return_value_g_type_check_instance_cast$4)->window, (unsigned int)0L);
  }

}

// on_gm_app_view_world_activate
// file widgets/gm-app-view.c line 1183
void on_gm_app_view_world_activate(struct _GtkAction *action, struct _GmWorld *world)
{
  gm_world_load(world);
}

// on_gm_app_view_world_activate_request
// file widgets/gm-app-view.c line 1134
void on_gm_app_view_world_activate_request(struct _GmWorld *world, struct _GmAppView *view)
{
  gm_world_set_active(world, (signed int)!(0 != 0));
}

// on_gm_app_view_world_active_changed
// file widgets/gm-app-view.c line 1661
void on_gm_app_view_world_active_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmAppView *view)
{
  struct _GmWorldView *world_view;
  world_view=gm_app_view_world_view_from_world(view, world);
  signed int return_value_gm_world_active$5;
  return_value_gm_world_active$5=gm_world_active(world);
  if(!(return_value_gm_world_active$5 == 0))
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)world_view, return_value_gtk_widget_get_type$1);
    signed int return_value_gtk_notebook_page_num$3;
    return_value_gtk_notebook_page_num$3=gtk_notebook_page_num(view->priv->notebook, (struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    gtk_notebook_set_current_page(view->priv->notebook, return_value_gtk_notebook_page_num$3);
    gm_app_view_update_title(view);
    enum _GmNetState return_value_gm_world_state$4;
    return_value_gm_world_state$4=gm_world_state(world);
    switch((signed int)return_value_gm_world_state$4)
    {
      case GM_NET_STATE_CONNECTING:

      case GM_NET_STATE_CONNECTED:
      {
        gm_app_view_update_connect_button(view, (signed int)!(0 != 0));
        break;
      }
      case GM_NET_STATE_DISCONNECTED:
        gm_app_view_update_connect_button(view, 0);
    }
  }

}

// on_gm_app_view_world_activity_changed
// file widgets/gm-app-view.c line 1686
void on_gm_app_view_world_activity_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmAppView *view)
{
  gm_app_view_update_tray(view);
}

// on_gm_app_view_world_added
// file widgets/gm-app-view.c line 1016
void on_gm_app_view_world_added(struct _GmApp *app, struct _GmWorld *world, struct _GmAppView *view)
{
  struct _GmAppViewWorldMenuItem *item;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct _GmAppViewWorldMenuItem) /*16ul*/ );
  item = (struct _GmAppViewWorldMenuItem *)return_value_g_malloc0_n$1;
  char *name;
  const char *return_value_gm_world_name$2;
  return_value_gm_world_name$2=gm_world_name(world);
  name=g_strconcat("WorldItem", return_value_gm_world_name$2, (void *)0);
  char *tooltip;
  char *return_value_gettext$3;
  return_value_gettext$3=gettext("Open world ");
  const char *return_value_gm_world_name$4;
  return_value_gm_world_name$4=gm_world_name(world);
  tooltip=g_strconcat(return_value_gettext$3, return_value_gm_world_name$4, (void *)0);
  char *path;
  struct _GList *worlds;
  struct _GList *position;
  signed int top;
  worlds=gm_app_worlds(app);
  position=g_list_find(worlds, (const void *)world);
  _Bool tmp_if_expr$6;
  if(position == ((struct _GList *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = !(position->prev != ((struct _GList *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$6)
  {
    path=g_strdup("/MenuBar/WorldMenu/WorldMenuAdditions");
    top = (signed int)!(0 != 0);
  }

  else
  {
    const char *return_value_gm_world_name$5;
    return_value_gm_world_name$5=gm_world_name((struct _GmWorld *)position->prev->data);
    path=g_strconcat("/MenuBar/WorldMenu/WorldMenuAdditions/WorldItem", return_value_gm_world_name$5, (void *)0);
    top = 0;
  }
  item->merge_id=gtk_ui_manager_new_merge_id(view->priv->manager);
  const char *return_value_gm_world_name$7;
  return_value_gm_world_name$7=gm_world_name(world);
  item->action=gtk_action_new(name, return_value_gm_world_name$7, tooltip, (const char *)(void *)0);
  gtk_action_group_add_action(view->priv->worlds_action_group, item->action);
  gtk_ui_manager_add_ui(view->priv->manager, item->merge_id, path, name, name, (enum anonymous$16)GTK_UI_MANAGER_MENUITEM, top);
  g_free((void *)path);
  gtk_ui_manager_ensure_update(view->priv->manager);
  g_signal_connect_data((void *)item->action, "activate", (void (*)(void))on_gm_app_view_world_activate, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "load", (void (*)(void))on_gm_app_view_world_load, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "unload", (void (*)(void))on_gm_app_view_world_unload, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "activate_request", (void (*)(void))on_gm_app_view_world_activate_request, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "notify::name", (void (*)(void))on_gm_app_view_world_name_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "state_changing", (void (*)(void))on_gm_app_view_world_state_changing, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "notify::active", (void (*)(void))on_gm_app_view_world_active_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "notify::activity", (void (*)(void))on_gm_app_view_world_activity_changed, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world, "notify_message", (void (*)(void))on_gm_app_view_world_notify_message, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_hash_table_insert(view->priv->world_menu_items, (void *)world, (void *)item);
  g_free((void *)name);
  g_free((void *)tooltip);
}

// on_gm_app_view_world_close_from_tab
// file widgets/gm-app-view.c line 999
void on_gm_app_view_world_close_from_tab(struct _GmWorldTab *tab, struct _GmWorld *world)
{
  gm_world_unload(world);
}

// on_gm_app_view_world_load
// file widgets/gm-app-view.c line 1091
void on_gm_app_view_world_load(struct _GmWorld *world, struct _GmAppView *view)
{
  struct _GtkWidget *world_view;
  world_view=gm_world_view_new(world);
  struct _GmWorldTab *tab;
  tab=gm_world_tab_new(world);
  g_signal_connect_data((void *)tab, "close", (void (*)(void))on_gm_app_view_world_close_from_tab, (void *)world, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  struct _GmMcpSession *return_value_gm_world_get_mcp_session$1;
  return_value_gm_world_get_mcp_session$1=gm_world_get_mcp_session(world);
  g_signal_connect_data((void *)return_value_gm_world_get_mcp_session$1, "package_created", (void (*)(void))on_gm_app_view_world_mcp_package_created, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world_view, "switch_page", (void (*)(void))on_gm_app_view_world_view_notebook_switch_page, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  g_signal_connect_data((void *)world_view, "destroy", (void (*)(void))on_gm_app_view_world_view_destroy, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)tab, return_value_gtk_widget_get_type$2);
  gtk_notebook_append_page(view->priv->notebook, world_view, (struct _GtkWidget *)return_value_g_type_check_instance_cast$3);
  gtk_widget_show_all(world_view);
  signed int return_value_gtk_notebook_get_n_pages$4;
  return_value_gtk_notebook_get_n_pages$4=gtk_notebook_get_n_pages(view->priv->notebook);
  if(return_value_gtk_notebook_get_n_pages$4 == 1)
    gm_app_view_worlds_loaded(view);

}

// on_gm_app_view_world_mcp_package_created
// file widgets/gm-app-view.c line 1692
void on_gm_app_view_world_mcp_package_created(struct _GmMcpSession *session, struct _GmMcpPackage *package, struct _GmAppView *view)
{
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)view, (unsigned long int)(20 << 2));
  gm_mcp_package_create_view(package, (struct _GObject *)return_value_g_type_check_instance_cast$1);
}

// on_gm_app_view_world_name_changed
// file widgets/gm-app-view.c line 1004
void on_gm_app_view_world_name_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmAppView *view)
{
  struct _GmAppViewWorldMenuItem *item;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(view->priv->world_menu_items, (const void *)world);
  item = (struct _GmAppViewWorldMenuItem *)return_value_g_hash_table_lookup$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)item->action, (unsigned long int)(20 << 2));
  const char *return_value_gm_world_name$3;
  return_value_gm_world_name$3=gm_world_name(world);
  g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$2, "label", return_value_gm_world_name$3, (void *)0);
  struct _GmWorld *return_value_gm_app_view_active_world$4;
  return_value_gm_app_view_active_world$4=gm_app_view_active_world(view);
  if(world == return_value_gm_app_view_active_world$4)
    gm_app_view_update_title(view);

}

// on_gm_app_view_world_notify_message
// file widgets/gm-app-view.c line 1139
void on_gm_app_view_world_notify_message(struct _GmWorld *world, const char *message, struct _GmAppView *view)
{
  unsigned long int return_value_gtk_window_get_type$3;
  return_value_gtk_window_get_type$3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$3);
  signed int return_value_gtk_window_is_active$5;
  return_value_gtk_window_is_active$5=gtk_window_is_active((struct _GtkWindow *)return_value_g_type_check_instance_cast$4);
  if(return_value_gtk_window_is_active$5 == 0)
  {
    if(!(view->priv->tray == ((struct _GmTray *)NULL)))
      gm_tray_notify(view->priv->tray, message);

    unsigned long int return_value_gtk_window_get_type$1;
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_window_get_type$1);
    gtk_window_set_urgency_hint((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, (signed int)!(0 != 0));
  }

}

// on_gm_app_view_world_removed
// file widgets/gm-app-view.c line 794
void on_gm_app_view_world_removed(struct _GmApp *app, struct _GmWorld *world, struct _GmAppView *view)
{
  struct _GmAppViewWorldMenuItem *item;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(view->priv->world_menu_items, (const void *)world);
  item = (struct _GmAppViewWorldMenuItem *)return_value_g_hash_table_lookup$1;
  gtk_ui_manager_remove_ui(view->priv->manager, item->merge_id);
  gtk_action_group_remove_action(view->priv->worlds_action_group, item->action);
  g_hash_table_remove(view->priv->world_menu_items, (const void *)world);
}

// on_gm_app_view_world_state_changing
// file widgets/gm-app-view.c line 1074
void on_gm_app_view_world_state_changing(struct _GmWorld *world, enum _GmNetState state, struct _GmAppView *view)
{
  struct _GmWorld *return_value_gm_app_view_active_world$1;
  return_value_gm_app_view_active_world$1=gm_app_view_active_world(view);
  if(world == return_value_gm_app_view_active_world$1)
    switch((signed int)state)
    {
      case GM_NET_STATE_CONNECTING:
      {
        gm_app_view_update_connect_button(view, (signed int)!(0 != 0));
        break;
      }
      case GM_NET_STATE_DISCONNECTED:
        gm_app_view_update_connect_button(view, 0);
    }

}

// on_gm_app_view_world_unload
// file widgets/gm-app-view.c line 1116
void on_gm_app_view_world_unload(struct _GmWorld *world, struct _GmAppView *view)
{
  struct _GmWorldView *world_view;
  world_view=gm_app_view_world_view_from_world(view, world);
  struct _GmMcpSession *return_value_gm_world_get_mcp_session$1;
  return_value_gm_world_get_mcp_session$1=gm_world_get_mcp_session(world);
  g_signal_handlers_disconnect_matched((void *)return_value_gm_world_get_mcp_session$1, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_app_view_world_mcp_package_created, (void *)view);
  if(!(world_view == ((struct _GmWorldView *)NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)world_view, return_value_gtk_widget_get_type$2);
    signed int return_value_gtk_notebook_page_num$4;
    return_value_gtk_notebook_page_num$4=gtk_notebook_page_num(view->priv->notebook, (struct _GtkWidget *)return_value_g_type_check_instance_cast$3);
    gtk_notebook_remove_page(view->priv->notebook, return_value_gtk_notebook_page_num$4);
    signed int return_value_gtk_notebook_get_n_pages$5;
    return_value_gtk_notebook_get_n_pages$5=gtk_notebook_get_n_pages(view->priv->notebook);
    if(return_value_gtk_notebook_get_n_pages$5 == 0)
      gm_app_view_worlds_unloaded(view);

  }

}

// on_gm_app_view_world_view_destroy
// file widgets/gm-app-view.c line 1698
void on_gm_app_view_world_view_destroy(struct _GmWorldView *world_view, struct _GmAppView *view)
{
  struct _GmWorld *world;
  world=gm_world_view_world(world_view);
  signed int return_value_gm_world_loaded$1;
  return_value_gm_world_loaded$1=gm_world_loaded(world);
  if(!(return_value_gm_world_loaded$1 == 0))
  {
    g_signal_handlers_disconnect_matched((void *)world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_app_view_world_unload, (void *)view);
    gm_world_unload(world);
  }

}

// on_gm_app_view_world_view_notebook_switch_page
// file widgets/gm-app-view.c line 1561
void on_gm_app_view_world_view_notebook_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *p, unsigned int page_num, struct _GmAppView *view)
{
  struct _GmWorldView *world_view;
  unsigned long int return_value_gm_world_view_get_type$1;
  return_value_gm_world_view_get_type$1=gm_world_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gm_world_view_get_type$1);
  world_view = (struct _GmWorldView *)return_value_g_type_check_instance_cast$2;
  struct _GtkWidget *page;
  signed int direction;
  signed int can_replace;
  signed int can_find;
  signed int tmp_statement_expression$3;
  struct _GTypeInstance *on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__inst = (struct _GTypeInstance *)view;
  unsigned long int __t;
  __t=gtk_widget_get_type();
  signed int on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__r;
  _Bool tmp_if_expr$4;
  if(on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__inst == ((struct _GTypeInstance *)NULL))
    on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__r = 0;

  else
  {
    if(!(on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$4 = on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__r = (signed int)!(0 != 0);

    else
      on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__r=g_type_check_instance_is_a(on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__inst, __t);
  }
  tmp_statement_expression$3 = on_gm_app_view_world_view_notebook_switch_page$$1$$1$$__r;
  _Bool tmp_if_expr$7;
  signed int tmp_statement_expression$5;
  _Bool tmp_if_expr$6;
  if(tmp_statement_expression$3 == 0)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    struct _GTypeInstance *on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__inst = (struct _GTypeInstance *)view->priv->hbox_control_find;
    unsigned long int on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__t;
    on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__t=gtk_widget_get_type();
    signed int __r;
    if(on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$6 = on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__inst->g_class->g_type == on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__inst, on_gm_app_view_world_view_notebook_switch_page$$1$$2$$__t);
    }
    tmp_statement_expression$5 = __r;
    tmp_if_expr$7 = !(tmp_statement_expression$5 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int tmp_statement_expression$27;
  _Bool tmp_if_expr$28;
  signed int tmp_statement_expression$29;
  _Bool tmp_if_expr$30;
  if(!tmp_if_expr$7)
  {
    can_find=gm_world_view_page_can_find(world_view, (signed int)page_num);
    struct _GtkAction *return_value_gm_app_view_action$8;
    return_value_gm_app_view_action$8=gm_app_view_action(view, "/MenuBar/EditMenu/EditFindMenu");
    gtk_action_set_sensitive(return_value_gm_app_view_action$8, can_find);
    struct _GtkAction *return_value_gm_app_view_action$9;
    return_value_gm_app_view_action$9=gm_app_view_action(view, "/MenuBar/EditMenu/EditFindNextMenu");
    gtk_action_set_sensitive(return_value_gm_app_view_action$9, can_find);
    unsigned long int return_value_gtk_widget_get_type$10;
    return_value_gtk_widget_get_type$10=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hbox_control_find, return_value_gtk_widget_get_type$10);
    gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$11, can_find);
    can_replace=gm_world_view_page_can_replace(world_view, (signed int)page_num);
    struct _GtkAction *return_value_gm_app_view_action$12;
    return_value_gm_app_view_action$12=gm_app_view_action(view, "/MenuBar/EditMenu/EditReplaceMenu");
    gtk_action_set_sensitive(return_value_gm_app_view_action$12, can_replace);
    if(can_replace == 0)
    {
      unsigned long int return_value_gtk_widget_get_type$13;
      return_value_gtk_widget_get_type$13=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hbox_replace, return_value_gtk_widget_get_type$13);
      gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$14);
      unsigned long int return_value_gtk_widget_get_type$15;
      return_value_gtk_widget_get_type$15=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
      return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->label_replace, return_value_gtk_widget_get_type$15);
      gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$16);
      gtk_expander_set_expanded(view->priv->expander_replace, 0);
      unsigned long int return_value_gtk_widget_get_type$17;
      return_value_gtk_widget_get_type$17=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
      return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->expander_replace, return_value_gtk_widget_get_type$17);
      gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$18, 0);
    }

    else
    {
      unsigned long int return_value_gtk_widget_get_type$19;
      return_value_gtk_widget_get_type$19=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
      return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->expander_replace, return_value_gtk_widget_get_type$19);
      gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$20, (signed int)!(0 != 0));
    }
    if(page_num == 0u)
    {
      struct _GmOptions *return_value_gm_app_options$21;
      return_value_gm_app_options$21=gm_app_options(view->priv->application);
      direction=gm_options_get_int(return_value_gm_app_options$21, "search_direction_world");
    }

    else
    {
      struct _GmOptions *return_value_gm_app_options$22;
      return_value_gm_app_options$22=gm_app_options(view->priv->application);
      direction=gm_options_get_int(return_value_gm_app_options$22, "search_direction");
    }
    view->priv->ignore_toggling = (signed int)!(0 != 0);
    unsigned long int return_value_gtk_toggle_button_get_type$23;
    return_value_gtk_toggle_button_get_type$23=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
    return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->check_button_search_direction, return_value_gtk_toggle_button_get_type$23);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$24, direction);
    view->priv->ignore_toggling = 0;
    unsigned long int return_value_gtk_notebook_get_type$25;
    return_value_gtk_notebook_get_type$25=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
    return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)world_view, return_value_gtk_notebook_get_type$25);
    page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$26, (signed int)page_num);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
    unsigned long int on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__t;
    on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__t=gm_editor_view_get_type();
    signed int on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$28 = __inst->g_class->g_type == on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$28 = (_Bool)0;
      if(tmp_if_expr$28)
        on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__r = (signed int)!(0 != 0);

      else
        on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__r=g_type_check_instance_is_a(__inst, on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__t);
    }
    tmp_statement_expression$27 = on_gm_app_view_world_view_notebook_switch_page$$1$$7$$__r;
    gtk_action_group_set_visible(view->priv->editor_action_group, tmp_statement_expression$27);
    struct _GTypeInstance *on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__inst = (struct _GTypeInstance *)page;
    unsigned long int on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__t;
    on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__t=gm_editor_view_get_type();
    signed int on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__r;
    if(on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__inst == ((struct _GTypeInstance *)NULL))
      on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__r = 0;

    else
    {
      if(!(on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$30 = on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__inst->g_class->g_type == on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$30 = (_Bool)0;
      if(tmp_if_expr$30)
        on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__r = (signed int)!(0 != 0);

      else
        on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__r=g_type_check_instance_is_a(on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__inst, on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__t);
    }
    tmp_statement_expression$29 = on_gm_app_view_world_view_notebook_switch_page$$1$$8$$__r;
    gtk_action_group_set_sensitive(view->priv->editor_action_group, tmp_statement_expression$29);
  }

}

// on_gm_color_table_monospace_font_change_notify
// file gm-color-table.c line 643
static void on_gm_color_table_monospace_font_change_notify(struct _GConfClient *client, unsigned int cnxn_id, struct _GConfEntry *entry, void *user_data)
{
  struct _GmColorTable *table;
  unsigned long int return_value_gm_color_table_get_type$1;
  return_value_gm_color_table_get_type$1=gm_color_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_gm_color_table_get_type$1);
  table = (struct _GmColorTable *)return_value_g_type_check_instance_cast$2;
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(entry->key, "/desktop/gnome/interface/monospace_font_name");
  if(return_value_strcmp$3 == 0)
    gm_color_table_set_font_description(table, (const char *)(void *)0);

}

// on_gm_editor_view_editor_saved
// file widgets/gm-editor-view.c line 649
void on_gm_editor_view_editor_saved(struct _GmEditor *editor, struct _GmEditorView *view)
{
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->source_view, return_value_gtk_text_view_get_type$1);
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$3;
  return_value_gtk_text_view_get_buffer$3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  gtk_text_buffer_set_modified(return_value_gtk_text_view_get_buffer$3, 0);
}

// on_gm_editor_view_font_changed
// file widgets/gm-editor-view.c line 635
void on_gm_editor_view_font_changed(struct _GmColorTable *color_table, const char *desc, struct _GmEditorView *view)
{
  struct _PangoFontDescription *f;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$2;
  return_value_gm_app_color_table$2=gm_app_color_table(return_value_gm_app_instance$1);
  const char *return_value_gm_color_table_font_description$3;
  return_value_gm_color_table_font_description$3=gm_color_table_font_description(return_value_gm_app_color_table$2);
  f=pango_font_description_from_string(return_value_gm_color_table_font_description$3);
  if(!(f == ((struct _PangoFontDescription *)NULL)))
  {
    unsigned long int return_value_gtk_widget_get_type$4;
    return_value_gtk_widget_get_type$4=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->source_view, return_value_gtk_widget_get_type$4);
    gtk_widget_modify_font((struct _GtkWidget *)return_value_g_type_check_instance_cast$5, f);
    pango_font_description_free(f);
  }

}

// on_gm_editor_view_modified_changed
// file widgets/gm-editor-view.c line 655
void on_gm_editor_view_modified_changed(struct _GtkTextBuffer *buffer, struct _GmEditorView *view)
{
  signed int return_value_gtk_text_buffer_get_modified$1;
  return_value_gtk_text_buffer_get_modified$1=gtk_text_buffer_get_modified(buffer);
  g_signal_emit((void *)view, gm_editor_view_signals[(signed long int)0], (unsigned int)0, return_value_gtk_text_buffer_get_modified$1);
}

// on_gm_embedded_view_exited
// file widgets/gm-embedded-view.c line 197
void on_gm_embedded_view_exited(struct _VteTerminal *vte, struct _GmEmbeddedView *embedded)
{
  gm_editor_close(embedded->priv->editor);
}

// on_gm_embedded_view_file_changed
// file widgets/gm-embedded-view.c line 177
void on_gm_embedded_view_file_changed(struct GnomeVFSMonitorHandle *handle, const char *monitor_uri, const char *info_uri, enum anonymous$102 event_type, struct _GmEmbeddedView *embedded)
{
  if((signed int)event_type == GNOME_VFS_MONITOR_EVENT_CHANGED || (signed int)event_type == GNOME_VFS_MONITOR_EVENT_CREATED)
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmEmbedded.OnFileChanged: change event detected!");
    gm_editor_set_lines_from_file(embedded->priv->editor, embedded->priv->filename);
    gm_editor_save(embedded->priv->editor);
    gm_embedded_view_update_last_modified(embedded);
  }

}

// on_gm_embedded_view_font_changed
// file widgets/gm-embedded-view.c line 202
void on_gm_embedded_view_font_changed(struct _GmColorTable *color_table, const char *desc, struct _GmEmbeddedView *view)
{
  unsigned long int return_value_vte_terminal_get_type$1;
  return_value_vte_terminal_get_type$1=vte_terminal_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->vte, return_value_vte_terminal_get_type$1);
  struct _GmApp *return_value_gm_app_instance$3;
  return_value_gm_app_instance$3=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$4;
  return_value_gm_app_color_table$4=gm_app_color_table(return_value_gm_app_instance$3);
  const char *return_value_gm_color_table_font_description$5;
  return_value_gm_color_table_font_description$5=gm_color_table_font_description(return_value_gm_app_color_table$4);
  vte_terminal_set_font_from_string((struct _VteTerminal *)return_value_g_type_check_instance_cast$2, return_value_gm_color_table_font_description$5);
}

// on_gm_external_view_exited
// file widgets/gm-external-view.c line 243
void on_gm_external_view_exited(signed int pid, signed int status, struct _GmExternalView *view)
{
  gm_editor_close(view->editor);
}

// on_gm_external_view_file_changed
// file widgets/gm-external-view.c line 248
void on_gm_external_view_file_changed(struct GnomeVFSMonitorHandle *handle, const char *monitor_uri, const char *info_uri, enum anonymous$102 event_type, struct _GmExternalView *view)
{
  if((signed int)event_type == GNOME_VFS_MONITOR_EVENT_CHANGED || (signed int)event_type == GNOME_VFS_MONITOR_EVENT_CREATED)
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmExternalView.OnFileChanged: change event detected!");
    gm_editor_set_lines_from_file(view->editor, view->filename);
    gm_editor_save(view->editor);
    gm_external_view_update_last_modified(view);
  }

}

// on_gm_log_view_filter_toggled
// file widgets/gm-log-view.c line 268
void on_gm_log_view_filter_toggled(struct _GtkToggleButton *button, struct _GmLogView *view)
{
  char *option;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)button, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "option");
  option = (char *)return_value_g_object_get_data$2;
  char *opt;
  opt=g_strconcat("logging_filter_", option, (void *)0);
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$3;
  return_value_gm_app_instance$3=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$3);
  struct _GtkTextTag *tag;
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$4;
  return_value_gtk_text_view_get_buffer$4=gtk_text_view_get_buffer(view->priv->text_view);
  struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$5;
  return_value_gtk_text_buffer_get_tag_table$5=gtk_text_buffer_get_tag_table(return_value_gtk_text_view_get_buffer$4);
  tag=gtk_text_tag_table_lookup(return_value_gtk_text_buffer_get_tag_table$5, option);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)tag, (unsigned long int)(20 << 2));
  g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6, "invisible", !(active != 0), (void *)0);
  gm_options_set_int(options, opt, active);
  g_free((void *)opt);
}

// on_gm_mcp_awns_status_view_status_changed
// file mcp/gm-mcp-awns-status.c line 96
void on_gm_mcp_awns_status_view_status_changed(struct _GmMcpAwnsStatus *package, const char *status, struct _GmMcpAwnsStatusView *view)
{
  gm_world_view_update_status(view->view, status);
}

// on_gm_mcp_awns_status_view_weak_notify
// file mcp/gm-mcp-awns-status.c line 102
void on_gm_mcp_awns_status_view_weak_notify(void *data, struct _GObject *obj)
{
  g_free(data);
}

// on_gm_mcp_icecrew_serverinfo_view_activate
// file mcp/gm-mcp-icecrew-serverinfo.c line 304
void on_gm_mcp_icecrew_serverinfo_view_activate(struct _GtkMenuItem *item, struct _GmMcpIcecrewServerinfoView *view)
{
  const struct _GmWorldInfo *return_value_gm_mcp_icecrew_serverinfo_info$1;
  return_value_gm_mcp_icecrew_serverinfo_info$1=gm_mcp_icecrew_serverinfo_info(view->package);
  gm_world_info_dialog_new(return_value_gm_mcp_icecrew_serverinfo_info$1);
}

// on_gm_mcp_icecrew_serverinfo_view_active_changed
// file mcp/gm-mcp-icecrew-serverinfo.c line 331
void on_gm_mcp_icecrew_serverinfo_view_active_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmMcpIcecrewServerinfoView *view)
{
  signed int active;
  active=gm_world_active(world);
  _Bool tmp_if_expr$2;
  signed int return_value_gm_mcp_icecrew_serverinfo_has_info$1;
  if(!(active == 0))
  {
    return_value_gm_mcp_icecrew_serverinfo_has_info$1=gm_mcp_icecrew_serverinfo_has_info(view->package);
    tmp_if_expr$2 = return_value_gm_mcp_icecrew_serverinfo_has_info$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    gm_mcp_icecrew_serverinfo_view_set_visible(view, (signed int)!(0 != 0));

  else
    if(active == 0)
      gm_mcp_icecrew_serverinfo_view_set_visible(view, 0);

}

// on_gm_mcp_icecrew_serverinfo_view_got_info
// file mcp/gm-mcp-icecrew-serverinfo.c line 358
void on_gm_mcp_icecrew_serverinfo_view_got_info(struct _GmMcpIcecrewServerinfo *package, struct _GmMcpIcecrewServerinfoView *view)
{
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  struct _GObject *return_value_gm_mcp_session_world$6;
  return_value_gm_mcp_session_world$6=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5);
  unsigned long int return_value_gm_world_get_type$7;
  return_value_gm_world_get_type$7=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$6, return_value_gm_world_get_type$7);
  signed int return_value_gm_world_active$9;
  return_value_gm_world_active$9=gm_world_active((struct _GmWorld *)return_value_g_type_check_instance_cast$8);
  if(!(return_value_gm_world_active$9 == 0))
    gm_mcp_icecrew_serverinfo_view_set_visible(view, (signed int)!(0 != 0));

  unsigned long int return_value_gm_mcp_package_get_type$10;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  struct _GObject *return_value_gm_mcp_package_get_session$12;
  unsigned long int return_value_gm_mcp_session_get_type$13;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  struct _GObject *return_value_gm_mcp_session_world$15;
  unsigned long int return_value_gm_world_get_type$16;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  struct _GmOptions *return_value_gm_world_options$18;
  if(!(package->priv->info.charset == ((char *)NULL)))
  {
    if(!((signed int)*package->priv->info.charset == 0))
    {
      return_value_gm_mcp_package_get_type$10=gm_mcp_package_get_type();
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$10);
      return_value_gm_mcp_package_get_session$12=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$11);
      return_value_gm_mcp_session_get_type$13=gm_mcp_session_get_type();
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$12, return_value_gm_mcp_session_get_type$13);
      return_value_gm_mcp_session_world$15=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$14);
      return_value_gm_world_get_type$16=gm_world_get_type();
      return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$15, return_value_gm_world_get_type$16);
      return_value_gm_world_options$18=gm_world_options((struct _GmWorld *)return_value_g_type_check_instance_cast$17);
      gm_options_set(return_value_gm_world_options$18, "charset", package->priv->info.charset);
    }

  }

}

// on_gm_mcp_icecrew_serverinfo_view_weak_notify
// file mcp/gm-mcp-icecrew-serverinfo.c line 343
void on_gm_mcp_icecrew_serverinfo_view_weak_notify(void *data, struct _GObject *obj)
{
  struct _GmMcpIcecrewServerinfoView *view = (struct _GmMcpIcecrewServerinfoView *)data;
  struct _GmWorld *world;
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  struct _GObject *return_value_gm_mcp_session_world$6;
  return_value_gm_mcp_session_world$6=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$5);
  unsigned long int return_value_gm_world_get_type$7;
  return_value_gm_world_get_type$7=gm_world_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$6, return_value_gm_world_get_type$7);
  world = (struct _GmWorld *)return_value_g_type_check_instance_cast$8;
  g_signal_handlers_disconnect_matched((void *)world, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_icecrew_serverinfo_view_active_changed, (void *)view);
  signed int return_value_gm_world_active$9;
  return_value_gm_world_active$9=gm_world_active(world);
  if(!(return_value_gm_world_active$9 == 0))
    gm_mcp_icecrew_serverinfo_view_set_visible(view, 0);

  g_free(data);
}

// on_gm_mcp_icecrew_userlist_add
// file mcp/gm-mcp-icecrew-userlist.c line 1212
void on_gm_mcp_icecrew_userlist_add(struct _GmMcpIcecrewPlayerdb *playerdb, struct _GmPlayerdbPlayerInfo *ppi, struct _GmMcpIcecrewUserlist *userlist)
{
  const char *name;
  name=gm_playerdb_player_info_get_prop(ppi, userlist->priv->property_names[(signed long int)0]);
  g_signal_emit_by_name((void *)userlist, "player-added", ppi->id);
  gm_mcp_icecrew_userlist_process_triggers(userlist, name, (enum _GmTriggerConditionType)TCT_USER_ONLINE);
}

// on_gm_mcp_icecrew_userlist_delete
// file mcp/gm-mcp-icecrew-userlist.c line 1240
void on_gm_mcp_icecrew_userlist_delete(struct _GmMcpIcecrewPlayerdb *playerdb, struct _GmPlayerdbPlayerInfo *ppi, struct _GmMcpIcecrewUserlist *userlist)
{
  const char *name;
  name=gm_playerdb_player_info_get_prop(ppi, userlist->priv->property_names[(signed long int)0]);
  g_signal_emit_by_name((void *)userlist, "player-removed", ppi->id);
  gm_mcp_icecrew_userlist_process_triggers(userlist, name, (enum _GmTriggerConditionType)TCT_USER_OFFLINE);
}

// on_gm_mcp_icecrew_userlist_set
// file mcp/gm-mcp-icecrew-userlist.c line 1222
void on_gm_mcp_icecrew_userlist_set(struct _GmMcpIcecrewPlayerdb *playerdb, struct _GmPlayerdbPlayerInfo *ppi, const char *key, const char *value, const char *old, struct _GmMcpIcecrewUserlist *userlist)
{
  signed int return_value_strcmp$4;
  return_value_strcmp$4=strcmp(key, userlist->priv->property_names[(signed long int)2]);
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$4 == 0)
  {
    g_signal_emit_by_name((void *)userlist, "state-changed", ppi->id);
    gm_mcp_icecrew_userlist_process_state_changed(userlist, ppi, value, old);
  }

  else
  {
    return_value_strcmp$3=strcmp(key, userlist->priv->property_names[(signed long int)1]);
    if(return_value_strcmp$3 == 0)
      g_signal_emit_by_name((void *)userlist, "rank-changed", ppi->id);

    else
    {
      return_value_strcmp$2=strcmp(key, userlist->priv->property_names[(signed long int)0]);
      if(return_value_strcmp$2 == 0)
        g_signal_emit_by_name((void *)userlist, "name-changed", ppi->id);

      else
      {
        return_value_strcmp$1=strcmp(key, userlist->priv->property_names[(signed long int)3]);
        if(return_value_strcmp$1 == 0)
          g_signal_emit_by_name((void *)userlist, "state-changed", ppi->id);

      }
    }
  }
}

// on_gm_mcp_mud_moo_simpleedit_editor_save
// file mcp/gm-mcp-mud-moo-simpleedit.c line 187
void on_gm_mcp_mud_moo_simpleedit_editor_save(struct _GmEditor *editor, struct _GmMcpMudMooSimpleedit *package)
{
  struct _GmMcpSession *session;
  unsigned long int return_value_gm_mcp_package_get_type$1;
  return_value_gm_mcp_package_get_type$1=gm_mcp_package_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_mcp_package_get_type$1);
  struct _GObject *return_value_gm_mcp_package_get_session$3;
  return_value_gm_mcp_package_get_session$3=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gm_mcp_session_get_type$4;
  return_value_gm_mcp_session_get_type$4=gm_mcp_session_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$3, return_value_gm_mcp_session_get_type$4);
  session = (struct _GmMcpSession *)return_value_g_type_check_instance_cast$5;
  char *data_tag;
  data_tag=gm_mcp_generate_data_tag();
  if(!(session == ((struct _GmMcpSession *)NULL)))
  {
    char *return_value_gm_editor_upload_cmd$6;
    return_value_gm_editor_upload_cmd$6=gm_editor_upload_cmd(editor);
    char *return_value_gm_editor_mcp_type$7;
    return_value_gm_editor_mcp_type$7=gm_editor_mcp_type(editor);
    gm_mcp_session_send_simple(session, "dns-org-mud-moo-simpleedit-set", "reference", return_value_gm_editor_upload_cmd$6, (const void *)"type", return_value_gm_editor_mcp_type$7, (const void *)"content*", (const void *)"", (const void *)"_data-tag", data_tag, (void *)0);
    struct _GList *return_value_gm_editor_lines$8;
    return_value_gm_editor_lines$8=gm_editor_lines(editor);
    gm_mcp_session_send_multiline(session, data_tag, "content", return_value_gm_editor_lines$8);
    gm_editor_saved(editor);
  }

  g_free((void *)data_tag);
}

// on_gm_mcp_userlist_view_button_press
// file mcp/gm-mcp-userlist-view.c line 863
static signed int on_gm_mcp_userlist_view_button_press(struct _GtkWidget *widget, struct _GdkEventButton *event, struct _GmMcpUserlistView *view)
{
  if(event->button == 3u)
  {
    if((signed int)event->type == GDK_BUTTON_PRESS)
      gm_mcp_userlist_view_do_popup(view, event);

  }

  return 0;
}

// on_gm_mcp_userlist_view_menuitem_activate
// file mcp/gm-mcp-userlist-view.c line 763
static void on_gm_mcp_userlist_view_menuitem_activate(struct _GtkMenuItem *item, struct _GmMcpUserlistView *view)
{
  char *on_gm_mcp_userlist_view_menuitem_activate$$1$$action;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)item, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "UserlistAction");
  on_gm_mcp_userlist_view_menuitem_activate$$1$$action = (char *)return_value_g_object_get_data$2;
  if(!(on_gm_mcp_userlist_view_menuitem_activate$$1$$action == ((char *)NULL)))
  {
    unsigned long int return_value_gm_mcp_package_get_type$3;
    return_value_gm_mcp_package_get_type$3=gm_mcp_package_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->package, return_value_gm_mcp_package_get_type$3);
    struct _GObject *return_value_gm_mcp_package_get_session$5;
    return_value_gm_mcp_package_get_session$5=gm_mcp_package_get_session((struct _GmMcpPackage *)return_value_g_type_check_instance_cast$4);
    unsigned long int return_value_gm_mcp_session_get_type$6;
    return_value_gm_mcp_session_get_type$6=gm_mcp_session_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_package_get_session$5, return_value_gm_mcp_session_get_type$6);
    struct _GObject *return_value_gm_mcp_session_world$8;
    return_value_gm_mcp_session_world$8=gm_mcp_session_world((struct _GmMcpSession *)return_value_g_type_check_instance_cast$7);
    unsigned long int return_value_gm_world_get_type$9;
    return_value_gm_world_get_type$9=gm_world_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_mcp_session_world$8, return_value_gm_world_get_type$9);
    gm_world_sendln((struct _GmWorld *)return_value_g_type_check_instance_cast$10, on_gm_mcp_userlist_view_menuitem_activate$$1$$action);
  }

}

// on_gm_mcp_userlist_view_name_changed
// file mcp/gm-mcp-userlist-view.c line 666
static void on_gm_mcp_userlist_view_name_changed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view)
{
  struct _GtkTreeIter iter;
  char *name;
  signed int return_value_gm_mcp_userlist_view_find$1;
  return_value_gm_mcp_userlist_view_find$1=gm_mcp_userlist_view_find(view, id, &iter);
  if(return_value_gm_mcp_userlist_view_find$1 == 0)
    gm_debug_msg(DEBUG_MCP, "GmMcpUserlistView.OnNameChanged: player %d is not in the list!", id);

  else
  {
    name=gm_mcp_userlist_view_get_name(view, id);
    if(!(name == ((char *)NULL)))
    {
      gtk_list_store_set(view->store, &iter, 1, name, -1);
      g_free((void *)name);
    }

  }
}

// on_gm_mcp_userlist_view_option_changed
// file mcp/gm-mcp-userlist-view.c line 562
static void on_gm_mcp_userlist_view_option_changed(struct _GmOptions *options, const char *key, struct _GmMcpUserlistView *view)
{
  signed int return_value_strcmp$10;
  return_value_strcmp$10=strcmp(key, "userlist_sort_type");
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  if(return_value_strcmp$10 == 0)
  {
    signed int return_value_gm_options_get_int$1;
    return_value_gm_options_get_int$1=gm_options_get_int(options, "userlist_sort_type");
    gm_mcp_userlist_view_update_sort_type(view, (enum _GmUserlistSortType)return_value_gm_options_get_int$1);
  }

  else
  {
    return_value_strcmp$9=strcmp(key, "userlist_show_status");
    if(return_value_strcmp$9 == 0)
    {
      signed int return_value_gm_options_get_int$2;
      return_value_gm_options_get_int$2=gm_options_get_int(options, "userlist_show_status");
      gm_mcp_userlist_view_update_show_status(view, return_value_gm_options_get_int$2);
    }

    else
    {
      return_value_strcmp$8=strcmp(key, "userlist_use_state_icon");
      if(return_value_strcmp$8 == 0)
      {
        signed int return_value_gm_options_get_int$3;
        return_value_gm_options_get_int$3=gm_options_get_int(options, "userlist_use_state_icon");
        gm_mcp_userlist_view_update_use_state_icon(view, return_value_gm_options_get_int$3);
      }

      else
      {
        return_value_strcmp$7=strcmp(key, "userlist_show_object_number");
        if(return_value_strcmp$7 == 0)
        {
          signed int return_value_gm_options_get_int$4;
          return_value_gm_options_get_int$4=gm_options_get_int(options, "userlist_show_object_number");
          gm_mcp_userlist_view_update_show_object_number(view, return_value_gm_options_get_int$4);
        }

        else
        {
          return_value_strcmp$6=strcmp(key, "show_userlist");
          if(return_value_strcmp$6 == 0)
          {
            signed int return_value_gm_options_get_int$5;
            return_value_gm_options_get_int$5=gm_options_get_int(options, "show_userlist");
            if(!(return_value_gm_options_get_int$5 == 0))
              gtk_widget_show(view->vbox);

            else
              gtk_widget_hide(view->vbox);
          }

        }
      }
    }
  }
}

// on_gm_mcp_userlist_view_player_added
// file mcp/gm-mcp-userlist-view.c line 603
static void on_gm_mcp_userlist_view_player_added(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view)
{
  struct _GtkTreeIter iter;
  char *name;
  char *status;
  struct _GmIUserlist *userlist;
  unsigned long int return_value_gm_iuserlist_get_type$1;
  return_value_gm_iuserlist_get_type$1=gm_iuserlist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_iuserlist_get_type$1);
  userlist = (struct _GmIUserlist *)return_value_g_type_check_instance_cast$2;
  signed int return_value_gm_mcp_userlist_view_find$3;
  return_value_gm_mcp_userlist_view_find$3=gm_mcp_userlist_view_find(view, id, &iter);
  if(!(return_value_gm_mcp_userlist_view_find$3 == 0))
    gm_debug_msg(DEBUG_MCP, "GmMcpUserlistView.OnPlayerAdded: player %d is already in the list, can't be added twice!", id);

  else
  {
    name=gm_mcp_userlist_view_get_name(view, id);
    status=gm_mcp_userlist_view_get_status(view, id);
    unsigned long int return_value_gtk_tree_model_get_type$4;
    return_value_gtk_tree_model_get_type$4=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view->store, return_value_gtk_tree_model_get_type$4);
    signed int return_value_gtk_tree_model_iter_n_children$6;
    return_value_gtk_tree_model_iter_n_children$6=gtk_tree_model_iter_n_children((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$5, (struct _GtkTreeIter *)(void *)0);
    const char *return_value_gm_iuserlist_get_icon$7;
    return_value_gm_iuserlist_get_icon$7=gm_iuserlist_get_icon(userlist, id, view->use_state_icon);
    struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$8;
    return_value_gm_pixbuf_get_at_size$8=gm_pixbuf_get_at_size(return_value_gm_iuserlist_get_icon$7, 22, 22);
    signed int return_value_gm_iuserlist_get_rank_priority$9;
    return_value_gm_iuserlist_get_rank_priority$9=gm_iuserlist_get_rank_priority(userlist, id);
    signed int return_value_gm_iuserlist_get_state_priority$10;
    return_value_gm_iuserlist_get_state_priority$10=gm_iuserlist_get_state_priority(userlist, id);
    gtk_list_store_insert_with_values(view->store, &iter, return_value_gtk_tree_model_iter_n_children$6, 3, id, 0, return_value_gm_pixbuf_get_at_size$8, 1, name, 2, status, 4, return_value_gm_iuserlist_get_rank_priority$9, 5, return_value_gm_iuserlist_get_state_priority$10, -1);
    g_free((void *)name);
    g_free((void *)status);
    view->num_players = view->num_players + 1;
    signed int return_value_gm_mcp_userlist_view_player_active$11;
    return_value_gm_mcp_userlist_view_player_active$11=gm_mcp_userlist_view_player_active(view, &iter);
    if(!(return_value_gm_mcp_userlist_view_player_active$11 == 0))
      view->num_active = view->num_active + 1;

    gm_mcp_userlist_view_update_label(view);
  }
}

// on_gm_mcp_userlist_view_player_removed
// file mcp/gm-mcp-userlist-view.c line 645
static void on_gm_mcp_userlist_view_player_removed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view)
{
  struct _GtkTreeIter iter;
  signed int return_value_gm_mcp_userlist_view_find$1;
  return_value_gm_mcp_userlist_view_find$1=gm_mcp_userlist_view_find(view, id, &iter);
  if(return_value_gm_mcp_userlist_view_find$1 == 0)
    gm_debug_msg(DEBUG_MCP, "GmMcpUserlistView.OnPlayerRemoved: player %d is not in the list, can't be removed!", id);

  else
  {
    view->num_players = view->num_players - 1;
    signed int return_value_gm_mcp_userlist_view_player_active$2;
    return_value_gm_mcp_userlist_view_player_active$2=gm_mcp_userlist_view_player_active(view, &iter);
    if(!(return_value_gm_mcp_userlist_view_player_active$2 == 0))
      view->num_active = view->num_active - 1;

    gm_mcp_userlist_view_update_label(view);
    gtk_list_store_remove(view->store, &iter);
  }
}

// on_gm_mcp_userlist_view_popup_menu
// file mcp/gm-mcp-userlist-view.c line 857
static signed int on_gm_mcp_userlist_view_popup_menu(struct _GtkWidget *widget, struct _GmMcpUserlistView *view)
{
  signed int return_value_gm_mcp_userlist_view_do_popup$1;
  return_value_gm_mcp_userlist_view_do_popup$1=gm_mcp_userlist_view_do_popup(view, (struct _GdkEventButton *)(void *)0);
  return return_value_gm_mcp_userlist_view_do_popup$1;
}

// on_gm_mcp_userlist_view_rank_changed
// file mcp/gm-mcp-userlist-view.c line 686
static void on_gm_mcp_userlist_view_rank_changed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view)
{
  struct _GtkTreeIter iter;
  const char *icon;
  signed int return_value_gm_mcp_userlist_view_find$1;
  return_value_gm_mcp_userlist_view_find$1=gm_mcp_userlist_view_find(view, id, &iter);
  if(return_value_gm_mcp_userlist_view_find$1 == 0)
    gm_debug_msg(DEBUG_MCP, "GmMcpUserlistView.OnRankChanged: player %d is not in the list!", id);

  else
  {
    unsigned long int return_value_gm_iuserlist_get_type$2;
    return_value_gm_iuserlist_get_type$2=gm_iuserlist_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_iuserlist_get_type$2);
    icon=gm_iuserlist_get_icon((struct _GmIUserlist *)return_value_g_type_check_instance_cast$3, id, view->use_state_icon);
    struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$4;
    return_value_gm_pixbuf_get_at_size$4=gm_pixbuf_get_at_size(icon, 22, 22);
    unsigned long int return_value_gm_iuserlist_get_type$5;
    return_value_gm_iuserlist_get_type$5=gm_iuserlist_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_iuserlist_get_type$5);
    signed int return_value_gm_iuserlist_get_rank_priority$7;
    return_value_gm_iuserlist_get_rank_priority$7=gm_iuserlist_get_rank_priority((struct _GmIUserlist *)return_value_g_type_check_instance_cast$6, id);
    gtk_list_store_set(view->store, &iter, 0, return_value_gm_pixbuf_get_at_size$4, 4, return_value_gm_iuserlist_get_rank_priority$7, -1);
  }
}

// on_gm_mcp_userlist_view_state_changed
// file mcp/gm-mcp-userlist-view.c line 709
static void on_gm_mcp_userlist_view_state_changed(struct _GmMcpPackage *package, signed int id, struct _GmMcpUserlistView *view)
{
  struct _GtkTreeIter iter;
  char *name;
  char *status;
  const char *icon;
  signed int active;
  signed int return_value_gm_mcp_userlist_view_find$1;
  return_value_gm_mcp_userlist_view_find$1=gm_mcp_userlist_view_find(view, id, &iter);
  if(return_value_gm_mcp_userlist_view_find$1 == 0)
    gm_debug_msg(DEBUG_MCP, "GmMcpUserlistView.OnStateChanged: player %d is not in the list!", id);

  else
  {
    active=gm_mcp_userlist_view_player_active(view, &iter);
    name=gm_mcp_userlist_view_get_name(view, id);
    status=gm_mcp_userlist_view_get_status(view, id);
    unsigned long int return_value_gm_iuserlist_get_type$2;
    return_value_gm_iuserlist_get_type$2=gm_iuserlist_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_iuserlist_get_type$2);
    icon=gm_iuserlist_get_icon((struct _GmIUserlist *)return_value_g_type_check_instance_cast$3, id, view->use_state_icon);
    struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$4;
    return_value_gm_pixbuf_get_at_size$4=gm_pixbuf_get_at_size(icon, 22, 22);
    unsigned long int return_value_gm_iuserlist_get_type$5;
    return_value_gm_iuserlist_get_type$5=gm_iuserlist_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)package, return_value_gm_iuserlist_get_type$5);
    signed int return_value_gm_iuserlist_get_state_priority$7;
    return_value_gm_iuserlist_get_state_priority$7=gm_iuserlist_get_state_priority((struct _GmIUserlist *)return_value_g_type_check_instance_cast$6, id);
    gtk_list_store_set(view->store, &iter, 0, return_value_gm_pixbuf_get_at_size$4, 1, name, 2, status, 5, return_value_gm_iuserlist_get_state_priority$7, -1);
    g_free((void *)name);
    g_free((void *)status);
    signed int return_value_gm_mcp_userlist_view_player_active$8;
    return_value_gm_mcp_userlist_view_player_active$8=gm_mcp_userlist_view_player_active(view, &iter);
    if(!(return_value_gm_mcp_userlist_view_player_active$8 == active))
    {
      if(!(active == 0))
        view->num_active = view->num_active - 1;

      else
        view->num_active = view->num_active + 1;
    }

    gm_mcp_userlist_view_update_label(view);
  }
}

// on_gm_mcp_userlist_view_weak_notify
// file mcp/gm-mcp-userlist-view.c line 529
static void on_gm_mcp_userlist_view_weak_notify(void *data, struct _GObject *obj)
{
  struct _GmMcpUserlistView *view = (struct _GmMcpUserlistView *)data;
  struct _GtkWidget *vbox;
  struct _GList *children;
  signed int tmp_statement_expression$8;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)view->view;
  unsigned long int __t;
  __t=gm_world_view_get_type();
  signed int __r;
  _Bool tmp_if_expr$9;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$9 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$8 = __r;
  if(!(tmp_statement_expression$8 == 0))
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->scrolled_window, return_value_gtk_widget_get_type$1);
    gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    gtk_widget_destroy(view->label);
    struct _GtkHPaned *return_value_gm_world_view_hpaned$3;
    return_value_gm_world_view_hpaned$3=gm_world_view_hpaned(view->view);
    unsigned long int return_value_gtk_paned_get_type$4;
    return_value_gtk_paned_get_type$4=gtk_paned_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_world_view_hpaned$3, return_value_gtk_paned_get_type$4);
    vbox=gtk_paned_get_child2((struct _GtkPaned *)return_value_g_type_check_instance_cast$5);
    if(!(vbox == ((struct _GtkWidget *)NULL)))
    {
      unsigned long int return_value_gtk_container_get_type$6;
      return_value_gtk_container_get_type$6=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
      return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type$6);
      children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$7);
      if(children == ((struct _GList *)NULL))
        gtk_widget_destroy(vbox);

      g_list_free(children);
    }

  }

  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)view->store, (unsigned long int)(20 << 2));
  g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$10);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)view->model, (unsigned long int)(20 << 2));
  g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$11);
  struct _GmApp *return_value_gm_app_instance$12;
  return_value_gm_app_instance$12=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$13;
  return_value_gm_app_options$13=gm_app_options(return_value_gm_app_instance$12);
  g_signal_handlers_disconnect_matched((void *)return_value_gm_app_options$13, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_mcp_userlist_view_option_changed, (void *)view);
  g_free(data);
}

// on_gm_mcp_vmoo_client_character_size_changed
// file mcp/gm-mcp-vmoo-client.c line 178
void on_gm_mcp_vmoo_client_character_size_changed(struct _GmWorldTextView *v, unsigned int width, unsigned int height, struct _GmMcpVmooClientView *view)
{
  gm_mcp_vmoo_client_install_timeout(view);
}

// on_gm_mcp_vmoo_client_text_view_size_allocate
// file mcp/gm-mcp-vmoo-client.c line 172
void on_gm_mcp_vmoo_client_text_view_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation, struct _GmMcpVmooClientView *view)
{
  gm_mcp_vmoo_client_install_timeout(view);
}

// on_gm_mcp_vmoo_client_view_weak_notify
// file mcp/gm-mcp-vmoo-client.c line 184
void on_gm_mcp_vmoo_client_view_weak_notify(void *data, struct _GObject *obj)
{
  struct _GmMcpVmooClientView *view = (struct _GmMcpVmooClientView *)data;
  g_signal_handlers_disconnect_matched((void *)view->view, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_vmoo_client_text_view_size_allocate, (void *)view);
  g_signal_handlers_disconnect_matched((void *)view->view, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_mcp_vmoo_client_character_size_changed, (void *)view);
  g_free(data);
}

// on_gm_net_connect_check
// file gm-net.c line 690
signed int on_gm_net_connect_check(struct _GIOChannel *source, enum anonymous$69 condition, struct _GmNet *net)
{
  signed int option = 0;
  unsigned int optionsize = (unsigned int)sizeof(signed int) /*4ul*/ ;
  if(!(net->priv->connect_timeout_id == 0u))
  {
    g_source_remove(net->priv->connect_timeout_id);
    net->priv->connect_timeout_id = (unsigned int)0;
  }

  if((signed int)condition == G_IO_ERR)
  {
    getsockopt(net->priv->socket, 1, 4, (void *)&option, &optionsize);
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(option);
    gm_net_connect_failed(net, return_value_strerror$1, option);
  }

  else
    gm_net_connect_succeed(net);
  return 0;
}

// on_gm_net_connect_timeout
// file gm-net.c line 711
signed int on_gm_net_connect_timeout(struct _GmNet *net)
{
  net->priv->connect_timeout_id = (unsigned int)0;
  if(!(net->priv->connect_check_id == 0u))
  {
    g_source_remove(net->priv->connect_check_id);
    net->priv->connect_check_id = (unsigned int)0;
  }

  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Connect timeout (5)");
  gm_net_connect_failed(net, return_value_gettext$1, 0);
  return 0;
}

// on_gm_net_input_recv
// file gm-net.c line 644
signed int on_gm_net_input_recv(struct _GIOChannel *source, enum anonymous$69 condition, struct _GmNet *net)
{
  unsigned char lbuf[1024l];
  signed int len;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if((signed int)condition == G_IO_HUP)
  {
    gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_DISCONNECTING);
    gm_net_clean_disconnection(net);
    return 0;
  }

  else
    if(!((signed int)net->priv->state == GM_NET_STATE_CONNECTED))
    {
      gm_debug_msg(DEBUG_DEFAULT, "GmNet.OnInputRecv: not connected!");
      return 0;
    }

    else
    {
      signed long int return_value_recv$1;
      return_value_recv$1=recv(net->priv->socket, (void *)lbuf, (unsigned long int)(1024 - 2), 0);
      len = (signed int)return_value_recv$1;
      gm_debug_msg(DEBUG_DEFAULT, "GmNet.OnInputRecv: received %d bytes", len);
      if(!(len >= 1))
      {
        if(!(len >= 0))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          if(*return_value___errno_location$2 == 11)
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            return_value___errno_location$3=__errno_location();
            tmp_if_expr$4 = *return_value___errno_location$3 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
            return (signed int)!(0 != 0);

          gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_DISCONNECTING);
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          gm_net_dirty_disconnection(net, *return_value___errno_location$5);
        }

        else
        {
          gm_net_set_state(net, (enum _GmNetState)GM_NET_STATE_DISCONNECTING);
          gm_net_clean_disconnection(net);
        }
        return 0;
      }

      else
      {
        gm_net_handle_telnet(net, lbuf, &len);
        g_signal_emit((void *)net, net_signals[(signed long int)3], (unsigned int)0, (const void *)lbuf, len);
      }
      return (signed int)!(0 != 0);
    }
}

// on_gm_open_world_dialog_response
// file dialogs/gm-open-world-dialog.c line 118
void on_gm_open_world_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data)
{
  if(response == -5)
    gm_open_world_dialog_open_selected_worlds();

  g_object_unref((void *)gm_open_world_dialog_instance->xml);
  gtk_widget_destroy(gm_open_world_dialog_instance->dialog);
  g_free((void *)gm_open_world_dialog_instance);
  gm_open_world_dialog_instance = (struct _GmOpenWorldDialog *)(void *)0;
}

// on_gm_open_world_dialog_tree_view_worlds_row_activated
// file dialogs/gm-open-world-dialog.c line 132
void on_gm_open_world_dialog_tree_view_worlds_row_activated(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _GmWorld *world;
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gm_worlds_view_get_type$1;
  return_value_gm_worlds_view_get_type$1=gm_worlds_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)tree_view, return_value_gm_worlds_view_get_type$1);
  model=gm_worlds_view_model((struct _GmWorldsView *)return_value_g_type_check_instance_cast$2);
  gtk_tree_model_get_iter(model, &iter, path);
  gtk_tree_model_get(model, &iter, 2, &world, -1);
  if(!(world == ((struct _GmWorld *)NULL)))
    gm_world_load(world);

  unsigned long int return_value_gtk_dialog_get_type$3;
  return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)gm_open_world_dialog_instance->dialog, return_value_gtk_dialog_get_type$3);
  gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$4, -7);
}

// on_gm_pixbuf_theme_changed
// file gm-pixbuf.c line 306
static void on_gm_pixbuf_theme_changed(struct _GtkIconTheme *theme, void *user_data)
{
  gm_pixbuf_populate_factory();
}

// on_gm_preferences_dialog_check_button_alt_editor_clicked
// file dialogs/gm-preferences-dialog.c line 481
void on_gm_preferences_dialog_check_button_alt_editor_clicked(struct _GtkButton *button, void *user_data)
{
  signed int active;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_toggle_button_get_type$1);
  active=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  if(active == 0)
  {
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$3;
    return_value_gm_preferences_dialog_widget$3=gm_preferences_dialog_widget("entry_alt_editor");
    unsigned long int return_value_gtk_entry_get_type$4;
    return_value_gtk_entry_get_type$4=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$3, return_value_gtk_entry_get_type$4);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$5, "");
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$6;
    return_value_gm_preferences_dialog_widget$6=gm_preferences_dialog_widget("check_button_embed_editor");
    unsigned long int return_value_gtk_toggle_button_get_type$7;
    return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$6, return_value_gtk_toggle_button_get_type$7);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8, 0);
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$9;
    return_value_gm_preferences_dialog_widget$9=gm_preferences_dialog_widget("check_button_needs_terminal");
    unsigned long int return_value_gtk_toggle_button_get_type$10;
    return_value_gtk_toggle_button_get_type$10=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$9, return_value_gtk_toggle_button_get_type$10);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$11, 0);
  }

  struct _GmApp *return_value_gm_app_instance$12;
  return_value_gm_app_instance$12=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$13;
  return_value_gm_app_options$13=gm_app_options(return_value_gm_app_instance$12);
  gm_options_set_int(return_value_gm_app_options$13, "editor_alternative", active);
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$14;
  return_value_gm_preferences_dialog_widget$14=gm_preferences_dialog_widget("entry_alt_editor");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$14, active);
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$15;
  return_value_gm_preferences_dialog_widget$15=gm_preferences_dialog_widget("check_button_embed_editor");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$15, active);
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$16;
  return_value_gm_preferences_dialog_widget$16=gm_preferences_dialog_widget("check_button_needs_terminal");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$16, active);
}

// on_gm_preferences_dialog_check_button_embed_editor_clicked
// file dialogs/gm-preferences-dialog.c line 458
void on_gm_preferences_dialog_check_button_embed_editor_clicked(struct _GtkButton *button, void *user_data)
{
  signed int active;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_toggle_button_get_type$1);
  active=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$3;
  return_value_gm_app_instance$3=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$3);
  if(!(active == 0))
  {
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$4;
    return_value_gm_preferences_dialog_widget$4=gm_preferences_dialog_widget("check_button_needs_terminal");
    unsigned long int return_value_gtk_toggle_button_get_type$5;
    return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$4, return_value_gtk_toggle_button_get_type$5);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6, (signed int)!(0 != 0));
  }

  else
  {
    struct _GtkWidget *return_value_gm_preferences_dialog_widget$7;
    return_value_gm_preferences_dialog_widget$7=gm_preferences_dialog_widget("check_button_needs_terminal");
    unsigned long int return_value_gtk_toggle_button_get_type$8;
    return_value_gtk_toggle_button_get_type$8=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$7, return_value_gtk_toggle_button_get_type$8);
    signed int return_value_gm_options_get_int$10;
    return_value_gm_options_get_int$10=gm_options_get_int(options, "editor_needs_terminal");
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$9, return_value_gm_options_get_int$10);
  }
  struct _GmApp *return_value_gm_app_instance$11;
  return_value_gm_app_instance$11=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$12;
  return_value_gm_app_options$12=gm_app_options(return_value_gm_app_instance$11);
  gm_options_set_int(return_value_gm_app_options$12, "editor_embed", active);
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$13;
  return_value_gm_preferences_dialog_widget$13=gm_preferences_dialog_widget("check_button_needs_terminal");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$13, (signed int)!(active != 0));
}

// on_gm_preferences_dialog_check_button_logging_disable_all_toggled
// file dialogs/gm-preferences-dialog.c line 599
void on_gm_preferences_dialog_check_button_logging_disable_all_toggled(struct _GtkToggleButton *button, void *user_data)
{
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  gm_options_set_int(return_value_gm_app_options$2, "logging_enable", (signed int)!(active != 0));
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$3;
  return_value_gm_preferences_dialog_widget$3=gm_preferences_dialog_widget("frame_log_types");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$3, (signed int)!(active != 0));
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$4;
  return_value_gm_preferences_dialog_widget$4=gm_preferences_dialog_widget("frame_log_format");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$4, (signed int)!(active != 0));
}

// on_gm_preferences_dialog_check_button_logging_toggled
// file dialogs/gm-preferences-dialog.c line 589
void on_gm_preferences_dialog_check_button_logging_toggled(struct _GtkToggleButton *button, void *user_data)
{
  char *option;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)button, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "gm_logging_name");
  option = (char *)return_value_g_object_get_data$2;
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GmApp *return_value_gm_app_instance$3;
  return_value_gm_app_instance$3=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$4;
  return_value_gm_app_options$4=gm_app_options(return_value_gm_app_instance$3);
  gm_options_set_int(return_value_gm_app_options$4, option, active);
}

// on_gm_preferences_dialog_check_button_needs_terminal_clicked
// file dialogs/gm-preferences-dialog.c line 508
void on_gm_preferences_dialog_check_button_needs_terminal_clicked(struct _GtkButton *button, void *user_data)
{
  signed int active;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_toggle_button_get_type$1);
  active=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  struct _GmApp *return_value_gm_app_instance$3;
  return_value_gm_app_instance$3=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$4;
  return_value_gm_app_options$4=gm_app_options(return_value_gm_app_instance$3);
  gm_options_set_int(return_value_gm_app_options$4, "editor_needs_terminal", active);
}

// on_gm_preferences_dialog_check_button_show_object_number_toggled
// file dialogs/gm-preferences-dialog.c line 613
void on_gm_preferences_dialog_check_button_show_object_number_toggled(struct _GtkToggleButton *button, void *user_data)
{
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  gm_options_set_int(return_value_gm_app_options$2, "userlist_show_object_number", active);
}

// on_gm_preferences_dialog_check_button_show_player_status_toggled
// file dialogs/gm-preferences-dialog.c line 621
void on_gm_preferences_dialog_check_button_show_player_status_toggled(struct _GtkToggleButton *button, void *user_data)
{
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  gm_options_set_int(return_value_gm_app_options$2, "userlist_show_status", active);
}

// on_gm_preferences_dialog_check_button_system_font_clicked
// file dialogs/gm-preferences-dialog.c line 436
void on_gm_preferences_dialog_check_button_system_font_clicked(struct _GtkButton *button, void *user_data)
{
  signed int active;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_toggle_button_get_type$1);
  active=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$3;
  return_value_gm_preferences_dialog_widget$3=gm_preferences_dialog_widget("label_font_description");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$3, (signed int)!(active != 0));
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$4;
  return_value_gm_preferences_dialog_widget$4=gm_preferences_dialog_widget("font_button_font");
  gtk_widget_set_sensitive(return_value_gm_preferences_dialog_widget$4, (signed int)!(active != 0));
  struct _GmApp *return_value_gm_app_instance$5;
  return_value_gm_app_instance$5=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$6;
  return_value_gm_app_color_table$6=gm_app_color_table(return_value_gm_app_instance$5);
  gm_color_table_set_use_system_font(return_value_gm_app_color_table$6, active);
}

// on_gm_preferences_dialog_check_button_use_state_icon_toggled
// file dialogs/gm-preferences-dialog.c line 630
void on_gm_preferences_dialog_check_button_use_state_icon_toggled(struct _GtkToggleButton *button, void *user_data)
{
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  gm_options_set_int(return_value_gm_app_options$2, "userlist_use_state_icon", active);
}

// on_gm_preferences_dialog_color_set
// file dialogs/gm-preferences-dialog.c line 543
void on_gm_preferences_dialog_color_set(struct _GtkColorButton *button, char *option)
{
  struct _GmColorTable *table;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  table=gm_app_color_table(return_value_gm_app_instance$1);
  struct _GdkColor col;
  char *col_str;
  struct _GtkComboBox *box;
  gtk_color_button_get_color(button, &col);
  col_str=g_strdup_printf("#%04X%04X%04X", col.red, col.green, col.blue);
  gm_color_table_set(table, option, col_str);
  g_free((void *)col_str);
  struct _GtkWidget *return_value_gm_preferences_dialog_widget$2;
  return_value_gm_preferences_dialog_widget$2=gm_preferences_dialog_widget("combo_box_scheme");
  unsigned long int return_value_gtk_combo_box_get_type$3;
  return_value_gtk_combo_box_get_type$3=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_preferences_dialog_widget$2, return_value_gtk_combo_box_get_type$3);
  box = (struct _GtkComboBox *)return_value_g_type_check_instance_cast$4;
  g_signal_handlers_block_matched((void *)box, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_preferences_dialog_combo_box_scheme_changed, (void *)0);
  signed int return_value_gtk_combo_box_get_active$5;
  return_value_gtk_combo_box_get_active$5=gtk_combo_box_get_active(box);
  if(!(return_value_gtk_combo_box_get_active$5 == preferences->user_scheme_index))
  {
    gtk_combo_box_set_active(box, preferences->user_scheme_index);
    gm_preferences_dialog_update_color_buttons(0);
  }

  g_signal_handlers_unblock_matched((void *)box, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_preferences_dialog_combo_box_scheme_changed, (void *)0);
}

// on_gm_preferences_dialog_combo_box_scheme_changed
// file dialogs/gm-preferences-dialog.c line 572
void on_gm_preferences_dialog_combo_box_scheme_changed(struct _GtkComboBox *box, void *user_data)
{
  struct _GtkTreeIter iter;
  char *scheme;
  struct _GtkTreeModel *model;
  model=gtk_combo_box_get_model(box);
  struct _GmColorTable *color_table;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  color_table=gm_app_color_table(return_value_gm_app_instance$1);
  gtk_combo_box_get_active_iter(box, &iter);
  gtk_tree_model_get(model, &iter, 1, &scheme, -1);
  gm_color_table_set_from_scheme_name(color_table, scheme);
  gm_preferences_dialog_update_color_buttons(0);
  g_free((void *)scheme);
}

// on_gm_preferences_dialog_entry_alt_editor_focus_out
// file dialogs/gm-preferences-dialog.c line 528
signed int on_gm_preferences_dialog_entry_alt_editor_focus_out(struct _GtkEntry *entry, struct _GdkEventFocus *event, void *user_data)
{
  const char *alt_editor;
  alt_editor=gtk_entry_get_text(entry);
  struct _GmOptions *options;
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  options=gm_app_options(return_value_gm_app_instance$1);
  if(!((signed int)*alt_editor == 0))
    gm_options_set(options, "editor_alternative", alt_editor);

  else
    gm_options_set(options, "editor_alternative", "0");
  return 0;
}

// on_gm_preferences_dialog_font_set
// file dialogs/gm-preferences-dialog.c line 450
void on_gm_preferences_dialog_font_set(struct _GtkFontButton *button, void *user_data)
{
  const char *font;
  font=gtk_font_button_get_font_name(button);
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$2;
  return_value_gm_app_color_table$2=gm_app_color_table(return_value_gm_app_instance$1);
  gm_color_table_set_font_description(return_value_gm_app_color_table$2, font);
}

// on_gm_preferences_dialog_radio_button_sort_toggled
// file dialogs/gm-preferences-dialog.c line 640
void on_gm_preferences_dialog_radio_button_sort_toggled(struct _GtkToggleButton *button, void *user_data)
{
  signed int active;
  active=gtk_toggle_button_get_active(button);
  signed int id;
  if(!(active == 0))
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)button, (unsigned long int)(20 << 2));
    void *return_value_g_object_get_data$2;
    return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "gm_userlist_sort_id");
    id = (signed int)(signed long int)return_value_g_object_get_data$2;
    struct _GmApp *return_value_gm_app_instance$3;
    return_value_gm_app_instance$3=gm_app_instance();
    struct _GmOptions *return_value_gm_app_options$4;
    return_value_gm_app_options$4=gm_app_options(return_value_gm_app_instance$3);
    gm_options_set_int(return_value_gm_app_options$4, "userlist_sort_type", id);
  }

}

// on_gm_preferences_dialog_response
// file dialogs/gm-preferences-dialog.c line 423
void on_gm_preferences_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data)
{
  struct _GmApp *return_value_gm_app_instance$1;
  return_value_gm_app_instance$1=gm_app_instance();
  struct _GmOptions *return_value_gm_app_options$2;
  return_value_gm_app_options$2=gm_app_options(return_value_gm_app_instance$1);
  gm_options_save(return_value_gm_app_options$2);
  struct _GmApp *return_value_gm_app_instance$3;
  return_value_gm_app_instance$3=gm_app_instance();
  struct _GmColorTable *return_value_gm_app_color_table$4;
  return_value_gm_app_color_table$4=gm_app_color_table(return_value_gm_app_instance$3);
  gm_color_table_save(return_value_gm_app_color_table$4);
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_widget_get_type$5);
  gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$6);
  g_object_unref((void *)preferences->xml);
  g_free((void *)preferences);
  preferences = (struct _GmPreferencesDialog *)(void *)0;
}

// on_gm_source_style_scheme_color_changed
// file widgets/gm-source-style-scheme.c line 212
static void on_gm_source_style_scheme_color_changed(struct _GmColorTable *table, const char *color)
{
  char **ids;
  const char *hex;
  hex=gm_color_table_get_hex(table, color);
  struct _GmSourceStyleEntry *entry;
  struct _GtkTextTag *style;
  entry = entries;
  for( ; !(entry->name == ((const char *)NULL)); entry = entry + 1l)
  {
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(entry->color_name, color);
    if(return_value_strcmp$4 == 0)
    {
      unsigned long int return_value_gm_source_style_scheme_get_type$1;
      return_value_gm_source_style_scheme_get_type$1=gm_source_style_scheme_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gm_style_scheme, return_value_gm_source_style_scheme_get_type$1);
      void *return_value_g_hash_table_lookup$3;
      return_value_g_hash_table_lookup$3=g_hash_table_lookup(((struct _GmSourceStyleScheme *)return_value_g_type_check_instance_cast$2)->styles, (const void *)entry->name);
      style = (struct _GtkTextTag *)return_value_g_hash_table_lookup$3;
      if(!(style == ((struct _GtkTextTag *)NULL)))
      {
        struct _GdkColor *hex_color = (struct _GdkColor *)(void *)0;
        gdk_color_parse(hex, hex_color);
        g_object_set((void *)style, "foreground-set", !(0 != 0), (const void *)"foreground", hex_color, !(0 != 0), (void *)0);
      }

    }

  }
  unsigned long int return_value_gm_source_style_scheme_get_type$5;
  return_value_gm_source_style_scheme_get_type$5=gm_source_style_scheme_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)gm_style_scheme, return_value_gm_source_style_scheme_get_type$5);
  void *return_value_g_hash_table_lookup$7;
  return_value_g_hash_table_lookup$7=g_hash_table_lookup(((struct _GmSourceStyleScheme *)return_value_g_type_check_instance_cast$6)->mapping, (const void *)color);
  ids = (char **)return_value_g_hash_table_lookup$7;
  if(!(ids == ((char **)NULL)))
    for( ; !(*ids == ((char *)NULL)); ids = ids + 1l)
      g_signal_emit_by_name((void *)gm_style_scheme, "style_changed", *ids);

}

// on_gm_text_scroller_text_buffer_changed
// file widgets/gm-text-scroller.c line 312
void on_gm_text_scroller_text_buffer_changed(struct _GtkTextBuffer *text_buffer, struct _GmTextScroller *scroller)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)scroller;
    unsigned long int __t;
    __t=gm_text_scroller_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"on_gm_text_scroller_text_buffer_changed", "GM_IS_TEXT_SCROLLER(scroller)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  gm_text_scroller_prepare(scroller);

__CPROVER_DUMP_L8:
  ;
}

// on_gm_text_scroller_text_view_destroy
// file widgets/gm-text-scroller.c line 321
void on_gm_text_scroller_text_view_destroy(struct _GtkTextView *text_view, struct _GmTextScroller *scroller)
{
  g_object_unref((void *)scroller);
}

// on_gm_text_scroller_text_view_notify
// file widgets/gm-text-scroller.c line 296
void on_gm_text_scroller_text_view_notify(struct _GtkTextView *text_view, struct _GParamSpec *arg1, struct _GmTextScroller *scroller)
{
  gm_text_scroller_update_text_buffer(scroller);
}

// on_gm_text_scroller_text_view_size_allocate
// file widgets/gm-text-scroller.c line 226
void on_gm_text_scroller_text_view_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation, struct _GmTextScroller *scroller)
{
  signed int return_value_abs$2;
  return_value_abs$2=abs(allocation->height - scroller->priv->allocation.height);
  signed int return_value_gm_text_scroller_is_end_scrolled_margin$3;
  return_value_gm_text_scroller_is_end_scrolled_margin$3=gm_text_scroller_is_end_scrolled_margin(scroller, return_value_abs$2);
  if(!(return_value_gm_text_scroller_is_end_scrolled_margin$3 == 0))
  {
    if(scroller->priv->idle_handler == 0)
    {
      gm_text_scroller_scroll_end(scroller);
      unsigned int return_value_g_idle_add$1;
      return_value_g_idle_add$1=g_idle_add((signed int (*)(void *))gm_text_scroller_scroll_end_idle, (void *)scroller);
      scroller->priv->idle_handler = (signed int)return_value_g_idle_add$1;
    }

  }

  scroller->priv->allocation = *allocation;
}

// on_gm_text_scroller_text_view_style_set
// file widgets/gm-text-scroller.c line 303
void on_gm_text_scroller_text_view_style_set(struct _GtkTextView *view, struct _GtkStyle *previous_style, struct _GmTextScroller *scroller)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)scroller;
    unsigned long int __t;
    __t=gm_text_scroller_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"on_gm_text_scroller_text_view_style_set", "GM_IS_TEXT_SCROLLER(scroller)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  gm_text_scroller_update_character_height(scroller);

__CPROVER_DUMP_L8:
  ;
}

// on_gm_world_editor_save
// file gm-world.c line 1293
static void on_gm_world_editor_save(struct _GmEditor *editor, struct _GmWorld *world)
{
  struct _GList *line;
  enum _GmNetState return_value_gm_net_state$3;
  return_value_gm_net_state$3=gm_net_state(world->priv->net);
  if((signed int)return_value_gm_net_state$3 == GM_NET_STATE_CONNECTED)
  {
    char *return_value_gm_editor_upload_cmd$1;
    return_value_gm_editor_upload_cmd$1=gm_editor_upload_cmd(editor);
    gm_world_sendln(world, return_value_gm_editor_upload_cmd$1);
    line=gm_editor_lines(editor);
    for( ; !(line == ((struct _GList *)NULL)); line = line->next)
      gm_world_sendln(world, (char *)line->data);
    gm_world_sendln(world, ".");
    gm_editor_saved(editor);
  }

  else
  {
    char *return_value_gettext$2;
    return_value_gettext$2=gettext("Could not save editor text, world is not connected at the moment");
    gm_world_status(world, return_value_gettext$2);
  }
}

// on_gm_world_info_dialog_url_button_release
// file dialogs/gm-world-info-dialog.c line 127
signed int on_gm_world_info_dialog_url_button_release(struct _GtkWidget *label, struct _GdkEventButton *event, char *prefix)
{
  struct _GError *err = (struct _GError *)(void *)0;
  char *tmp;
  char *link;
  if(!(prefix == ((char *)NULL)))
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label, return_value_gtk_label_get_type$1);
    const char *return_value_gtk_label_get_text$3;
    return_value_gtk_label_get_text$3=gtk_label_get_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2);
    link=g_strconcat(prefix, return_value_gtk_label_get_text$3, (void *)0);
  }

  else
  {
    unsigned long int return_value_gtk_label_get_type$4;
    return_value_gtk_label_get_type$4=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)label, return_value_gtk_label_get_type$4);
    const char *return_value_gtk_label_get_text$6;
    return_value_gtk_label_get_text$6=gtk_label_get_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$5);
    link=g_strdup(return_value_gtk_label_get_text$6);
  }
  signed int return_value_gnome_url_show$8;
  return_value_gnome_url_show$8=gnome_url_show(link, &err);
  if(return_value_gnome_url_show$8 == 0)
  {
    char *return_value_gettext$7;
    return_value_gettext$7=gettext("Could not open link: %s");
    tmp=g_strdup_printf(return_value_gettext$7, err->message);
    gm_error_dialog(tmp, (struct _GtkWindow *)(void *)0);
    g_free((void *)tmp);
    g_error_free(err);
  }

  g_free((void *)link);
  return 0;
}

// on_gm_world_input_view_changed
// file widgets/gm-world-input-view.c line 360
void on_gm_world_input_view_changed(struct _GtkTextBuffer *buffer, struct _GmWorldInputView *view)
{
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  struct _GtkWidget *parent;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$1);
  parent=gtk_widget_get_parent((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  struct _GtkScrolledWindow *sw;
  signed int lineheight;
  signed int y;
  if(!(view->priv->prefix == ((char *)NULL)))
  {
    gtk_text_buffer_get_bounds(buffer, &start, &end);
    signed int return_value_gtk_text_iter_equal$3;
    return_value_gtk_text_iter_equal$3=gtk_text_iter_equal(&start, &end);
    if(!(return_value_gtk_text_iter_equal$3 == 0))
    {
      view->priv->position=g_list_last(*view->priv->history);
      gm_world_input_view_reset_prefix(view);
    }

  }

  signed int tmp_statement_expression$4;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)parent;
  unsigned long int __t;
  __t=gtk_scrolled_window_get_type();
  signed int __r;
  _Bool tmp_if_expr$5;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$5 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$4 = __r;
  _Bool tmp_if_expr$17;
  signed int return_value_gtk_text_buffer_get_line_count$16;
  signed int return_value_gtk_text_buffer_get_line_count$15;
  if(!(tmp_statement_expression$4 == 0))
  {
    if(view->priv->is_scrolled == 0)
    {
      return_value_gtk_text_buffer_get_line_count$16=gtk_text_buffer_get_line_count(buffer);
      tmp_if_expr$17 = return_value_gtk_text_buffer_get_line_count$16 > 6 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$17 = (_Bool)0;
    if(tmp_if_expr$17)
    {
      unsigned long int return_value_gtk_scrolled_window_get_type$6;
      return_value_gtk_scrolled_window_get_type$6=gtk_scrolled_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
      return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gtk_scrolled_window_get_type$6);
      sw = (struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$7;
      view->priv->is_scrolled = (signed int)!(0 != 0);
      gtk_text_buffer_get_start_iter(buffer, &start);
      unsigned long int return_value_gtk_text_view_get_type$8;
      return_value_gtk_text_view_get_type$8=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$8);
      gtk_text_view_get_line_yrange((struct _GtkTextView *)return_value_g_type_check_instance_cast$9, &start, &y, &lineheight);
      unsigned long int return_value_gtk_container_get_type$10;
      return_value_gtk_container_get_type$10=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)sw, return_value_gtk_container_get_type$10);
      unsigned int return_value_gtk_container_get_border_width$12;
      return_value_gtk_container_get_border_width$12=gtk_container_get_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$11);
      gtk_widget_set_size_request(parent, -1, (signed int)((unsigned int)(lineheight * 6) + return_value_gtk_container_get_border_width$12 + (unsigned int)2));
      gtk_scrolled_window_set_policy(sw, (enum anonymous$88)GTK_POLICY_NEVER, (enum anonymous$88)GTK_POLICY_ALWAYS);
      view->priv->idle_scroll=g_idle_add(idle_scroll, (void *)view);
    }

    else
      if(!(view->priv->is_scrolled == 0))
      {
        return_value_gtk_text_buffer_get_line_count$15=gtk_text_buffer_get_line_count(buffer);
        if(!(return_value_gtk_text_buffer_get_line_count$15 >= 7))
        {
          unsigned long int return_value_gtk_scrolled_window_get_type$13;
          return_value_gtk_scrolled_window_get_type$13=gtk_scrolled_window_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
          return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)parent, return_value_gtk_scrolled_window_get_type$13);
          sw = (struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$14;
          view->priv->is_scrolled = 0;
          gtk_scrolled_window_set_policy(sw, (enum anonymous$88)GTK_POLICY_NEVER, (enum anonymous$88)GTK_POLICY_NEVER);
          gtk_widget_set_size_request(parent, -1, -1);
        }

      }

  }

}

// on_gm_world_input_view_world_text_activate
// file widgets/gm-world-view.c line 740
void on_gm_world_input_view_world_text_activate(struct _GmWorldInputView *iview, char *text, struct _GmWorldView *view)
{
  gm_world_process_input(view->priv->world, text);
  gm_text_scroller_scroll_end(view->priv->text_scroller_world);
}

// on_gm_world_logs_dialog_row_activated
// file dialogs/gm-world-logs-dialog.c line 150
void on_gm_world_logs_dialog_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *arg1, struct _GtkTreeViewColumn *arg2, struct _GtkDialog *dlg)
{
  gtk_dialog_response(dlg, -5);
}

// on_gm_world_net_bytes_recv
// file gm-world.c line 1369
static void on_gm_world_net_bytes_recv(struct _GmNet *net, char *text, signed int len, struct _GmWorld *world)
{
  char *all;
  char *utext;
  char *ptr;
  char *start;
  unsigned int ch;
  unsigned int prev;
  const char *return_value_gm_options_get$1;
  return_value_gm_options_get$1=gm_options_get(world->priv->options, "charset");
  utext=gm_to_utf8_with_fallback(text, (signed long int)len, return_value_gm_options_get$1, "?");
  if(utext == ((char *)NULL))
  {
    gm_debug_msg(DEBUG_DEFAULT, "GmWorld.NetBytesRecv: conversion failed!");
    utext=g_strndup(text, (unsigned long int)len);
  }

  if(!(world->priv->buffer == ((char *)NULL)))
  {
    all=g_strconcat(world->priv->buffer, utext, (void *)0);
    g_free((void *)utext);
    g_free((void *)world->priv->buffer);
    world->priv->buffer = (char *)(void *)0;
  }

  else
    all = utext;
  start = all;
  ptr = start;
  prev = (unsigned int)0;
  do
  {
    ch=g_utf8_get_char(ptr);
    if(ch == 0u)
      break;

    if(ch == 10u)
    {
      gm_world_process_line(world, start, (signed int)((ptr - start) - (signed long int)(prev == (unsigned int)13 ? 1 : 0)));
      start = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
      ptr = start;
      unsigned int return_value_g_utf8_get_char$2;
      return_value_g_utf8_get_char$2=g_utf8_get_char(ptr);
      if(return_value_g_utf8_get_char$2 == 13u)
      {
        start = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
        ptr = start;
      }

    }

    else
      ptr = (char *)(ptr + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)ptr)]);
    prev = ch;
  }
  while((_Bool)1);
  if(!((signed int)*start == 0))
    world->priv->buffer=g_strdup(start);

  g_free((void *)all);
}

// on_gm_world_net_net_error
// file gm-world.c line 1362
static void on_gm_world_net_net_error(struct _GmNet *net, char *error, signed int code, struct _GmWorld *world)
{
  g_signal_emit((void *)world, world_signals[(signed long int)4], (unsigned int)0, error, code);
  gm_world_log(world, (enum _GmLogType)LOG_STATUS, error);
}

// on_gm_world_net_state_changed
// file gm-world.c line 1349
static void on_gm_world_net_state_changed(struct _GmNet *net, enum _GmNetState state, struct _GmWorld *world)
{
  if((signed int)state == GM_NET_STATE_CONNECTED)
  {
    world->priv->manual_disconnect = 0;
    gm_world_auto_login(world);
  }

}

// on_gm_world_net_state_changing
// file gm-world.c line 1312
static void on_gm_world_net_state_changing(struct _GmNet *net, enum _GmNetState state, struct _GmWorld *world)
{
  enum _GmNetState prev_state;
  prev_state=gm_net_state(net);
  g_signal_emit((void *)world, world_signals[(signed long int)3], (unsigned int)0, state);
  signed int return_value_gm_options_get_int$6;
  _Bool tmp_if_expr$2;
  signed long int return_value_time$1;
  if((signed int)state == GM_NET_STATE_DISCONNECTED && ((signed int)prev_state == GM_NET_STATE_CONNECTED || (signed int)prev_state == GM_NET_STATE_DISCONNECTING))
  {
    gm_mcp_session_reset(world->priv->mcp);
    if(world->priv->reconnect_id == 0u)
    {
      return_value_gm_options_get_int$6=gm_options_get_int(world->priv->options, "reconnect");
      if(!(return_value_gm_options_get_int$6 == 0))
      {
        if(!(world->priv->manual_disconnect == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_time$1=time(((signed long int *)NULL));
          tmp_if_expr$2 = return_value_time$1 < world->priv->manual_disconnect_timeout ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
          goto __CPROVER_DUMP_L7;

        signed long int return_value_time$3;
        return_value_time$3=time(((signed long int *)NULL));
        double return_value_difftime$4;
        return_value_difftime$4=difftime(return_value_time$3, world->priv->last_command);
        if(return_value_difftime$4 <= 3.000000)
          goto __CPROVER_DUMP_L7;

        world->priv->reconnect_id=g_timeout_add((unsigned int)3000, (signed int (*)(void *))gm_world_reconnect, (void *)world);
        char *return_value_gettext$5;
        return_value_gettext$5=gettext("Reconnecting in 3 seconds...");
        gm_world_status(world, return_value_gettext$5);
      }

    }

  }


__CPROVER_DUMP_L7:
  ;
}

// on_gm_world_options_option_changed
// file gm-world.c line 1420
static void on_gm_world_options_option_changed(struct _GmOptions *options, char *key, struct _GmWorld *world)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(key, "name");
  if(return_value_strcmp$1 == 0)
    gm_world_name_changed(world);

}

// on_gm_world_paste_dialog_active_world_changed
// file dialogs/gm-world-paste-dialog.c line 324
static void on_gm_world_paste_dialog_active_world_changed(struct _GmAppView *view, struct _GmWorldView *world_view)
{
  gm_world_paste_dialog_fill_to();
}

// on_gm_world_paste_dialog_response
// file dialogs/gm-world-paste-dialog.c line 300
static void on_gm_world_paste_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data)
{
  if(response == -10)
    gm_world_paste_dialog_do_paste();

  if(!(gm_world_paste_dialog_instance->model == ((struct _GtkTreeModel *)NULL)))
  {
    g_object_ref((void *)gm_world_paste_dialog_instance->model);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)gm_world_paste_dialog_instance->model, (unsigned long int)(20 << 2));
    g_object_remove_toggle_ref((struct _GObject *)return_value_g_type_check_instance_cast$1, gm_world_paste_dialog_remove_model, (void *)0);
  }

  g_signal_handlers_disconnect_matched((void *)gm_world_paste_dialog_instance->view, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_gm_world_paste_dialog_active_world_changed, (void *)0);
  g_object_unref((void *)gm_world_paste_dialog_instance->xml);
  gtk_widget_destroy(gm_world_paste_dialog_instance->dialog);
  g_free((void *)gm_world_paste_dialog_instance);
  gm_world_paste_dialog_instance = (struct _GmWorldPasteDialog *)(void *)0;
}

// on_gm_world_properties_dialog_app_world_removed
// file dialogs/gm-world-properties-dialog.c line 770
void on_gm_world_properties_dialog_app_world_removed(struct _GmApp *app, struct _GmWorld *world, struct _GmWorldPropertiesDialog *properties)
{
  if(properties->world == world)
  {
    unsigned long int return_value_gtk_dialog_get_type$1;
    return_value_gtk_dialog_get_type$1=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)properties->dialog, return_value_gtk_dialog_get_type$1);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$2, -7);
  }

}

// on_gm_world_properties_dialog_check_button_logging_override_toggled
// file dialogs/gm-world-properties-dialog.c line 778
void on_gm_world_properties_dialog_check_button_logging_override_toggled(struct _GtkToggleButton *button, struct _GmWorldPropertiesDialog *properties)
{
  signed int active;
  active=gtk_toggle_button_get_active(button);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$1;
  return_value_gm_world_properties_dialog_widget$1=gm_world_properties_dialog_widget(properties, "frame_log_types");
  gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$1, active);
  struct _GtkWidget *return_value_gm_world_properties_dialog_widget$2;
  return_value_gm_world_properties_dialog_widget$2=gm_world_properties_dialog_widget(properties, "frame_log_format");
  gtk_widget_set_sensitive(return_value_gm_world_properties_dialog_widget$2, active);
}

// on_gm_world_properties_dialog_response
// file dialogs/gm-world-properties-dialog.c line 662
void on_gm_world_properties_dialog_response(struct _GtkDialog *dialog, signed int response, struct _GmWorldPropertiesDialog *properties)
{
  signed int is_okay = (signed int)!(0 != 0);
  if(response == -5)
  {
    is_okay=gm_world_properties_dialog_check_values(properties);
    goto __CPROVER_DUMP_L3;
  }

  gm_world_properties_dialog_free_triggers(properties);

__CPROVER_DUMP_L3:
  ;
  if(!(is_okay == 0))
  {
    if(!(properties->is_new == 0))
    {
      if(response == -5)
      {
        struct _GmApp *return_value_gm_app_instance$1;
        return_value_gm_app_instance$1=gm_app_instance();
        gm_app_add_world(return_value_gm_app_instance$1, properties->world);
      }

      else
        g_object_unref((void *)properties->world);
    }

    gtk_widget_destroy(properties->dialog);
    if(properties->handler_id >= 1ul)
    {
      struct _GmApp *return_value_gm_app_instance$2;
      return_value_gm_app_instance$2=gm_app_instance();
      g_signal_handler_disconnect((void *)return_value_gm_app_instance$2, properties->handler_id);
    }

    g_object_unref((void *)properties->xml);
    gm_world_properties_dialog_open=g_list_remove(gm_world_properties_dialog_open, (const void *)properties);
    g_free((void *)properties);
  }

}

// on_gm_world_tab_button_clicked
// file widgets/gm-world-tab.c line 196
void on_gm_world_tab_button_clicked(struct _GtkButton *button, struct _GmWorldTab *tab)
{
  g_signal_emit((void *)tab, gm_world_tab_signals[(signed long int)0], (unsigned int)0);
}

// on_gm_world_tab_world_activity_changed
// file widgets/gm-world-tab.c line 201
void on_gm_world_tab_world_activity_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmWorldTab *tab)
{
  gm_world_tab_update(tab);
}

// on_gm_world_tab_world_name_changed
// file widgets/gm-world-tab.c line 207
void on_gm_world_tab_world_name_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmWorldTab *tab)
{
  gm_world_tab_update(tab);
}

// on_gm_world_text_view_color_table_color_changed
// file widgets/gm-world-text-view.c line 1521
static void on_gm_world_text_view_color_table_color_changed(struct _GmColorTable *table, char *name, struct _GmWorldTextView *view)
{
  struct _GdkColor col;
  gm_world_text_view_update_color_tag(view, name, (struct _GtkTextTag *)(void *)0);
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(name, "fg_default");
  signed int return_value_strcmp$5;
  if(return_value_strcmp$6 == 0)
  {
    gm_color_table_get(view->priv->color_table, "fg_default", &col);
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$1);
    gtk_widget_modify_text((struct _GtkWidget *)return_value_g_type_check_instance_cast$2, (enum anonymous$23)GTK_STATE_NORMAL, &col);
  }

  else
  {
    return_value_strcmp$5=strcmp(name, "bg_default");
    if(return_value_strcmp$5 == 0)
    {
      gm_color_table_get(view->priv->color_table, "bg_default", &col);
      unsigned long int return_value_gtk_widget_get_type$3;
      return_value_gtk_widget_get_type$3=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$3);
      gtk_widget_modify_base((struct _GtkWidget *)return_value_g_type_check_instance_cast$4, (enum anonymous$23)GTK_STATE_NORMAL, &col);
    }

  }
}

// on_gm_world_text_view_color_table_font_changed
// file widgets/gm-world-text-view.c line 1537
static void on_gm_world_text_view_color_table_font_changed(struct _GmColorTable *table, char *font_description, struct _GmWorldTextView *view)
{
  gm_world_text_view_update_font(view);
}

// on_gm_world_text_view_copy_address
// file widgets/gm-world-text-view.c line 1457
static void on_gm_world_text_view_copy_address(struct _GtkMenuItem *item, struct _GmWorldTextView *view)
{
  struct _GtkClipboard *clipboard;
  char *url;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)item, return_value_gtk_widget_get_type$1);
  struct _GtkWidget *return_value_gtk_widget_get_parent$3;
  return_value_gtk_widget_get_parent$3=gtk_widget_get_parent((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_widget_get_parent$3, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$5;
  return_value_g_object_get_data$5=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$4, "url");
  url = (char *)return_value_g_object_get_data$5;
  clipboard=gtk_clipboard_get((struct _GdkAtom *)(void *)(unsigned long int)69);
  gtk_clipboard_set_text(clipboard, url, -1);
}

// on_gm_world_text_view_event
// file widgets/gm-world-text-view.c line 1399
static signed int on_gm_world_text_view_event(struct _GmWorldTextView *view, struct _GdkEventMotion *event, struct _GtkTextTag *tag)
{
  enum anonymous$91 type;
  struct _GtkTextIter iter;
  struct _GdkDrawable *win;
  signed int x;
  signed int y;
  signed int buf_x;
  signed int buf_y;
  signed int has_tag;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  type=gtk_text_view_get_window_type((struct _GtkTextView *)return_value_g_type_check_instance_cast$2, event->window);
  _Bool tmp_if_expr$9;
  unsigned long int return_value_gtk_widget_get_type$12;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  signed int return_value_gtk_drag_check_threshold$14;
  if(!((signed int)type == GTK_TEXT_WINDOW_TEXT))
    return 0;

  else
    if(!((signed int)event->type == GDK_MOTION_NOTIFY))
      return 0;

    else
    {
      unsigned long int return_value_gtk_text_view_get_type$3;
      return_value_gtk_text_view_get_type$3=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$3);
      win=gtk_text_view_get_window((struct _GtkTextView *)return_value_g_type_check_instance_cast$4, type);
      gdk_window_get_pointer(win, &x, &y, (enum anonymous$0 *)(void *)0);
      unsigned long int return_value_gtk_text_view_get_type$5;
      return_value_gtk_text_view_get_type$5=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$5);
      gtk_text_view_window_to_buffer_coords((struct _GtkTextView *)return_value_g_type_check_instance_cast$6, type, x, y, &buf_x, &buf_y);
      unsigned long int return_value_gtk_text_view_get_type$7;
      return_value_gtk_text_view_get_type$7=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$7);
      gtk_text_view_get_iter_at_location((struct _GtkTextView *)return_value_g_type_check_instance_cast$8, &iter, buf_x, buf_y);
      static struct _GdkCursor *hand = (struct _GdkCursor *)(void *)0;
      if(hand == ((struct _GdkCursor *)NULL))
        hand=gdk_cursor_new((enum anonymous$37)GDK_HAND1);

      has_tag=gtk_text_iter_has_tag(&iter, tag);
      if(!(has_tag == 0))
        tmp_if_expr$9 = !(view->priv->is_hand != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        view->priv->is_hand = (signed int)!(0 != 0);
        gdk_window_set_cursor(win, hand);
      }

      else
        if(has_tag == 0)
        {
          if(!(view->priv->is_hand == 0))
          {
            view->priv->is_hand = 0;
            gdk_window_set_cursor(win, (struct _GdkCursor *)(void *)0);
          }

        }

      if(!(view->priv->drag_url == 0))
      {
        return_value_gtk_widget_get_type$12=gtk_widget_get_type();
        return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$12);
        return_value_gtk_drag_check_threshold$14=gtk_drag_check_threshold((struct _GtkWidget *)return_value_g_type_check_instance_cast$13, (signed int)view->priv->drag_x, (signed int)view->priv->drag_y, (signed int)event->x, (signed int)event->y);
        if(!(return_value_gtk_drag_check_threshold$14 == 0))
        {
          view->priv->drag_url = 0;
          unsigned long int return_value_gtk_widget_get_type$10;
          return_value_gtk_widget_get_type$10=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
          return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_widget_get_type$10);
          gtk_drag_begin((struct _GtkWidget *)return_value_g_type_check_instance_cast$11, view->priv->source_target_list, (enum anonymous$43)(GDK_ACTION_COPY | GDK_ACTION_LINK | GDK_ACTION_ASK), 1, (union _GdkEvent *)event);
        }

      }

      return 0;
    }
}

// on_gm_world_text_view_open_address
// file widgets/gm-world-text-view.c line 1467
static void on_gm_world_text_view_open_address(struct _GtkMenuItem *item, struct _GmWorldTextView *view)
{
  char *url;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)item, return_value_gtk_widget_get_type$1);
  struct _GtkWidget *return_value_gtk_widget_get_parent$3;
  return_value_gtk_widget_get_parent$3=gtk_widget_get_parent((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_widget_get_parent$3, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$5;
  return_value_g_object_get_data$5=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$4, "url");
  url = (char *)return_value_g_object_get_data$5;
  g_signal_emit((void *)view, world_text_view_signals[(signed long int)0], (unsigned int)0, url);
}

// on_gm_world_text_view_url_event
// file widgets/gm-world-text-view.c line 1362
static signed int on_gm_world_text_view_url_event(struct _GtkTextTag *tag, struct _GObject *object, union _GdkEvent *event, struct _GtkTextIter *iter, struct _GmWorldTextView *view)
{
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  char *str = (char *)(void *)0;
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gtk_text_iter_forward_to_tag_toggle$3;
  if((signed int)event->type == GDK_BUTTON_RELEASE)
  {
    if(event->button.button == 1u)
    {
      if((4u & event->button.state) == 0u)
      {
        if((1u & event->button.state) == 0u)
        {
          if((8u & event->button.state) == 0u)
          {
            end = *iter;
            start = end;
            signed int return_value_gtk_text_iter_backward_to_tag_toggle$4;
            return_value_gtk_text_iter_backward_to_tag_toggle$4=gtk_text_iter_backward_to_tag_toggle(&start, tag);
            if(!(return_value_gtk_text_iter_backward_to_tag_toggle$4 == 0))
            {
              return_value_gtk_text_iter_forward_to_tag_toggle$3=gtk_text_iter_forward_to_tag_toggle(&end, tag);
              if(!(return_value_gtk_text_iter_forward_to_tag_toggle$3 == 0))
                str=gtk_text_buffer_get_text(buffer, &start, &end, 0);

            }

            if(str == ((char *)NULL))
              return 0;

            gtk_text_buffer_get_selection_bounds(buffer, &start, &end);
            signed int return_value_gtk_text_iter_equal$5;
            return_value_gtk_text_iter_equal$5=gtk_text_iter_equal(&start, &end);
            if(return_value_gtk_text_iter_equal$5 == 0)
            {
              g_free((void *)str);
              return 0;
            }

            g_signal_emit((void *)view, world_text_view_signals[(signed long int)0], (unsigned int)0, str);
            g_free((void *)str);
          }

        }

      }

    }

  }

  return 0;
}

// on_gm_world_view_editor_save
// file widgets/gm-world-view.c line 756
void on_gm_world_view_editor_save(struct _GmEditor *editor, struct _GmWorldView *view)
{
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2, 0);
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_input, return_value_gtk_widget_get_type$3);
  gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
}

// on_gm_world_view_editor_view_close_clicked
// file widgets/gm-world-view.c line 762
void on_gm_world_view_editor_view_close_clicked(struct _GtkButton *button, struct _GtkWidget *view)
{
  signed int tmp_statement_expression$9;
  struct _GTypeInstance *__inst = (struct _GTypeInstance *)view;
  unsigned long int __t;
  __t=gm_editor_view_get_type();
  signed int __r;
  _Bool tmp_if_expr$10;
  if(__inst == ((struct _GTypeInstance *)NULL))
    __r = 0;

  else
  {
    if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
      tmp_if_expr$10 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
      __r = (signed int)!(0 != 0);

    else
      __r=g_type_check_instance_is_a(__inst, __t);
  }
  tmp_statement_expression$9 = __r;
  signed int tmp_statement_expression$7;
  _Bool tmp_if_expr$8;
  if(!(tmp_statement_expression$9 == 0))
  {
    unsigned long int return_value_gm_editor_view_get_type$1;
    return_value_gm_editor_view_get_type$1=gm_editor_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gm_editor_view_get_type$1);
    struct _GmEditor *return_value_gm_editor_view_editor$3;
    return_value_gm_editor_view_editor$3=gm_editor_view_editor((struct _GmEditorView *)return_value_g_type_check_instance_cast$2);
    gm_editor_close(return_value_gm_editor_view_editor$3);
  }

  else
  {
    struct _GTypeInstance *on_gm_world_view_editor_view_close_clicked$$1$$3$$__inst = (struct _GTypeInstance *)view;
    unsigned long int on_gm_world_view_editor_view_close_clicked$$1$$3$$__t;
    on_gm_world_view_editor_view_close_clicked$$1$$3$$__t=gm_embedded_view_get_type();
    signed int on_gm_world_view_editor_view_close_clicked$$1$$3$$__r;
    if(on_gm_world_view_editor_view_close_clicked$$1$$3$$__inst == ((struct _GTypeInstance *)NULL))
      on_gm_world_view_editor_view_close_clicked$$1$$3$$__r = 0;

    else
    {
      if(!(on_gm_world_view_editor_view_close_clicked$$1$$3$$__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$8 = on_gm_world_view_editor_view_close_clicked$$1$$3$$__inst->g_class->g_type == on_gm_world_view_editor_view_close_clicked$$1$$3$$__t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
        on_gm_world_view_editor_view_close_clicked$$1$$3$$__r = (signed int)!(0 != 0);

      else
        on_gm_world_view_editor_view_close_clicked$$1$$3$$__r=g_type_check_instance_is_a(on_gm_world_view_editor_view_close_clicked$$1$$3$$__inst, on_gm_world_view_editor_view_close_clicked$$1$$3$$__t);
    }
    tmp_statement_expression$7 = on_gm_world_view_editor_view_close_clicked$$1$$3$$__r;
    if(!(tmp_statement_expression$7 == 0))
    {
      unsigned long int return_value_gm_embedded_view_get_type$4;
      return_value_gm_embedded_view_get_type$4=gm_embedded_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gm_embedded_view_get_type$4);
      struct _GmEditor *return_value_gm_embedded_view_editor$6;
      return_value_gm_embedded_view_editor$6=gm_embedded_view_editor((struct _GmEmbeddedView *)return_value_g_type_check_instance_cast$5);
      gm_editor_close(return_value_gm_embedded_view_editor$6);
    }

  }
}

// on_gm_world_view_editor_view_modified_changed
// file widgets/gm-world-view.c line 780
void on_gm_world_view_editor_view_modified_changed(struct _GmEditorView *editor_view, signed int modified, struct _GmWorldView *view)
{
  signed int i;
  signed int n;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  n=gtk_notebook_get_n_pages((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  struct _GtkWidget *page;
  struct _GtkLabel *label;
  char *str;
  i = 1;
  signed int tmp_statement_expression$24;
  _Bool tmp_if_expr$25;
  unsigned long int return_value_gm_editor_view_get_type$22;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  for( ; !(i >= n); i = i + 1)
  {
    unsigned long int return_value_gtk_notebook_get_type$3;
    return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$3);
    page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, i);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
    unsigned long int __t;
    __t=gm_editor_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$25 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$25 = (_Bool)0;
      if(tmp_if_expr$25)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$24 = __r;
    if(!(tmp_statement_expression$24 == 0))
    {
      return_value_gm_editor_view_get_type$22=gm_editor_view_get_type();
      return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_editor_view_get_type$22);
      if((struct _GmEditorView *)return_value_g_type_check_instance_cast$23 == editor_view)
      {
        unsigned long int return_value_gtk_notebook_get_type$5;
        return_value_gtk_notebook_get_type$5=gtk_notebook_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$5);
        struct _GtkWidget *return_value_gtk_notebook_get_tab_label$7;
        return_value_gtk_notebook_get_tab_label$7=gtk_notebook_get_tab_label((struct _GtkNotebook *)return_value_g_type_check_instance_cast$6, page);
        unsigned long int return_value_gtk_container_get_type$8;
        return_value_gtk_container_get_type$8=gtk_container_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_notebook_get_tab_label$7, return_value_gtk_container_get_type$8);
        unsigned long int return_value_gtk_label_get_type$10;
        return_value_gtk_label_get_type$10=gtk_label_get_type();
        struct _GtkWidget *return_value_gm_container_item$11;
        return_value_gm_container_item$11=gm_container_item((struct _GtkContainer *)return_value_g_type_check_instance_cast$9, return_value_gtk_label_get_type$10);
        unsigned long int return_value_gtk_label_get_type$12;
        return_value_gtk_label_get_type$12=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
        return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gm_container_item$11, return_value_gtk_label_get_type$12);
        label = (struct _GtkLabel *)return_value_g_type_check_instance_cast$13;
        if(modified == 0)
        {
          unsigned long int return_value_gm_editor_view_get_type$14;
          return_value_gm_editor_view_get_type$14=gm_editor_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
          return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_editor_view_get_type$14);
          struct _GmEditor *return_value_gm_editor_view_editor$16;
          return_value_gm_editor_view_editor$16=gm_editor_view_editor((struct _GmEditorView *)return_value_g_type_check_instance_cast$15);
          char *return_value_gm_editor_name$17;
          return_value_gm_editor_name$17=gm_editor_name(return_value_gm_editor_view_editor$16);
          gtk_label_set_label(label, return_value_gm_editor_name$17);
        }

        else
        {
          unsigned long int return_value_gm_editor_view_get_type$18;
          return_value_gm_editor_view_get_type$18=gm_editor_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
          return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_editor_view_get_type$18);
          struct _GmEditor *return_value_gm_editor_view_editor$20;
          return_value_gm_editor_view_editor$20=gm_editor_view_editor((struct _GmEditorView *)return_value_g_type_check_instance_cast$19);
          char *return_value_gm_editor_name$21;
          return_value_gm_editor_name$21=gm_editor_name(return_value_gm_editor_view_editor$20);
          str=g_strconcat(return_value_gm_editor_name$21, (const void *)"*", (void *)0);
          gtk_label_set_label(label, str);
          g_free((void *)str);
        }
      }

    }

  }
}

// on_gm_world_view_log_view_close_clicked
// file widgets/gm-world-view.c line 773
void on_gm_world_view_log_view_close_clicked(struct _GtkButton *button, struct _GtkWidget *view)
{
  gtk_widget_destroy(view);
}

// on_gm_world_view_world_active_changed
// file widgets/gm-world-view.c line 922
void on_gm_world_view_world_active_changed(struct _GmWorld *world, struct _GParamSpec *pspec, struct _GmWorldView *view)
{
  signed int return_value_gm_world_active$3;
  return_value_gm_world_active$3=gm_world_active(world);
  if(!(return_value_gm_world_active$3 == 0))
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_input, return_value_gtk_widget_get_type$1);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  }

}

// on_gm_world_view_world_editor_added
// file widgets/gm-world-view.c line 811
void on_gm_world_view_world_editor_added(struct _GmWorld *world, struct _GmEditor *editor, struct _GmWorldView *view)
{
  gm_world_view_editor_page_new(view, editor);
  g_signal_connect_data((void *)editor, "save", (void (*)(void))on_gm_world_view_editor_save, (void *)view, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$73)0);
}

// on_gm_world_view_world_editor_removed
// file widgets/gm-world-view.c line 820
void on_gm_world_view_world_editor_removed(struct _GmWorld *world, struct _GmEditor *editor, struct _GmWorldView *view)
{
  signed int i;
  signed int n;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$1);
  n=gtk_notebook_get_n_pages((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  struct _GtkWidget *page;
  signed int found = 0;
  struct _GList *ext;
  i = 1;
  signed int tmp_statement_expression$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$10;
  unsigned long int return_value_gm_editor_view_get_type$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  struct _GmEditor *return_value_gm_editor_view_editor$9;
  _Bool tmp_if_expr$17;
  signed int tmp_statement_expression$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$16;
  unsigned long int return_value_gm_embedded_view_get_type$13;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  struct _GmEditor *return_value_gm_embedded_view_editor$15;
  for( ; !(i >= n); i = i + 1)
  {
    unsigned long int return_value_gtk_notebook_get_type$3;
    return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$3);
    page=gtk_notebook_get_nth_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4, i);
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)page;
    unsigned long int __t;
    __t=gm_editor_view_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$6 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$5 = __r;
    if(!(tmp_statement_expression$5 == 0))
    {
      return_value_gm_editor_view_get_type$7=gm_editor_view_get_type();
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_editor_view_get_type$7);
      return_value_gm_editor_view_editor$9=gm_editor_view_editor((struct _GmEditorView *)return_value_g_type_check_instance_cast$8);
      tmp_if_expr$10 = return_value_gm_editor_view_editor$9 == editor ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$10 = (_Bool)0;
    found = (signed int)tmp_if_expr$10;
    if(!(found == 0))
      tmp_if_expr$17 = (_Bool)1;

    else
    {
      struct _GTypeInstance *on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__inst = (struct _GTypeInstance *)page;
      unsigned long int on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__t;
      on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__t=gm_embedded_view_get_type();
      signed int on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__r;
      if(on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__inst == ((struct _GTypeInstance *)NULL))
        on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__r = 0;

      else
      {
        if(!(on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__inst->g_class == ((struct _GTypeClass *)NULL)))
          tmp_if_expr$12 = on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__inst->g_class->g_type == on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__t ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$12 = (_Bool)0;
        if(tmp_if_expr$12)
          on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__r = (signed int)!(0 != 0);

        else
          on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__r=g_type_check_instance_is_a(on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__inst, on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__t);
      }
      tmp_statement_expression$11 = on_gm_world_view_world_editor_removed$$1$$1$$1$$2$$__r;
      if(!(tmp_statement_expression$11 == 0))
      {
        return_value_gm_embedded_view_get_type$13=gm_embedded_view_get_type();
        return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)page, return_value_gm_embedded_view_get_type$13);
        return_value_gm_embedded_view_editor$15=gm_embedded_view_editor((struct _GmEmbeddedView *)return_value_g_type_check_instance_cast$14);
        tmp_if_expr$16 = return_value_gm_embedded_view_editor$15 == editor ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$16 = (_Bool)0;
      tmp_if_expr$17 = tmp_if_expr$16 ? (_Bool)1 : (_Bool)0;
    }
    found = (signed int)tmp_if_expr$17;
    if(!(found == 0))
    {
      g_signal_handlers_disconnect_matched((void *)editor, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_world_view_editor_save, (void *)view);
      gtk_widget_destroy(page);
      unsigned long int return_value_gtk_notebook_get_type$18;
      return_value_gtk_notebook_get_type$18=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
      return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)view, return_value_gtk_notebook_get_type$18);
      gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$19, 0);
      unsigned long int return_value_gtk_widget_get_type$20;
      return_value_gtk_widget_get_type$20=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
      return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_input, return_value_gtk_widget_get_type$20);
      gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$21);
      break;
    }

  }
  if(found == 0)
  {
    ext = view->priv->external_editors;
    for( ; !(ext == ((struct _GList *)NULL)); ext = ext->next)
      if(((struct _GmExternalView *)ext->data)->editor == editor)
      {
        g_signal_handlers_disconnect_matched((void *)editor, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)on_gm_world_view_editor_save, (void *)view);
        gm_external_view_destroy((struct _GmExternalView *)ext->data);
        view->priv->external_editors=g_list_remove_link(view->priv->external_editors, ext);
        g_list_free_1(ext);
        break;
      }

  }

}

// on_gm_world_view_world_error
// file widgets/gm-world-view.c line 863
void on_gm_world_view_world_error(struct _GmWorld *world, char *text, signed int code, struct _GmWorldView *view)
{
  char *line;
  char *return_value_gettext$1;
  char *return_value_gettext$2;
  char *return_value_gettext$3;
  switch(code)
  {
    case 0:
    {
      return_value_gettext$1=gettext("Connect failed: %s");
      line=g_strdup_printf(return_value_gettext$1, text);
      break;
    }
    case 1:
    {
      return_value_gettext$2=gettext("Connection lost... (%s)");
      line=g_strdup_printf(return_value_gettext$2, text);
      break;
    }
    default:
    {
      return_value_gettext$3=gettext("Error: %s");
      line=g_strdup_printf(return_value_gettext$3, text);
    }
  }
  gm_world_status(world, line);
  g_free((void *)line);
}

// on_gm_world_view_world_highlight
// file widgets/gm-world-view.c line 930
void on_gm_world_view_world_highlight(struct _GmWorld *world, signed int start, signed int end, char *color, struct _GmWorldView *view)
{
  struct _GtkTextIter istart;
  struct _GtkTextIter iend;
  struct _GtkTextBuffer *buffer;
  unsigned long int return_value_gtk_text_view_get_type$1;
  return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->text_view_world, return_value_gtk_text_view_get_type$1);
  buffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
  gtk_text_buffer_get_end_iter(buffer, &iend);
  istart = iend;
  gtk_text_iter_backward_line(&istart);
  if(!(start == -1))
  {
    gtk_text_iter_forward_chars(&istart, start);
    iend = istart;
    gtk_text_iter_forward_chars(&iend, end);
  }

  gtk_text_buffer_apply_tag_by_name(buffer, color, &istart, &iend);
}

// on_gm_world_view_world_input_view_key_pressed
// file widgets/gm-world-view.c line 974
signed int on_gm_world_view_world_input_view_key_pressed(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GmWorldView *view)
{
  _Bool tmp_if_expr$1;
  switch(event->keyval)
  {
    case (unsigned int)0xff50:

    case (unsigned int)0xff57:
    {
      if((4u | event->state) == event->state)
      {
        if(event->keyval == 65367u)
          gm_text_scroller_scroll_end(view->priv->text_scroller_world);

        else
          gm_text_scroller_scroll_begin(view->priv->text_scroller_world);
        return (signed int)!(0 != 0);
      }

      goto __CPROVER_DUMP_L10;
    }
    case (unsigned int)0xff55:

    case (unsigned int)0xff56:
    {
      if(!((4u & event->state) == 0u))
        tmp_if_expr$1 = !((event->state & (unsigned int)GDK_SHIFT_MASK) != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
      {
        if(event->keyval == 65365u)
          gm_text_scroller_scroll_page(view->priv->text_scroller_world, -1);

        else
          gm_text_scroller_scroll_page(view->priv->text_scroller_world, 1);
        return (signed int)!(0 != 0);
      }

    }
    default:
    {

    __CPROVER_DUMP_L10:
      ;
      return 0;
    }
  }
}

// on_gm_world_view_world_mcp_package_created
// file widgets/gm-world-view.c line 1011
void on_gm_world_view_world_mcp_package_created(struct _GmMcpSession *session, struct _GmMcpPackage *package, struct _GmWorldView *view)
{
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)view, (unsigned long int)(20 << 2));
  gm_mcp_package_create_view(package, (struct _GObject *)return_value_g_type_check_instance_cast$1);
}

// on_gm_world_view_world_state_changing
// file widgets/gm-world-view.c line 884
void on_gm_world_view_world_state_changing(struct _GmWorld *world, unsigned int state, struct _GmWorldView *view)
{
  char *line = (char *)(void *)0;
  enum _GmNetState pstate;
  pstate=gm_world_state(world);
  char *return_value_gettext$1;
  const char *return_value_gm_world_current_host$2;
  const char *return_value_gm_world_current_port$3;
  char *return_value_gettext$4;
  const char *return_value_gm_world_current_host$5;
  const char *return_value_gm_world_current_port$6;
  char *return_value_gettext$7;
  char *return_value_gettext$9;
  switch(state)
  {
    case (unsigned int)GM_NET_STATE_TRY_ADDRESS:
    {
      return_value_gettext$1=gettext("Trying %s port %s");
      return_value_gm_world_current_host$2=gm_world_current_host(world);
      return_value_gm_world_current_port$3=gm_world_current_port(world);
      line=g_strdup_printf(return_value_gettext$1, return_value_gm_world_current_host$2, return_value_gm_world_current_port$3);
      break;
    }
    case (unsigned int)GM_NET_STATE_CONNECTING:
    {
      return_value_gettext$4=gettext("Connecting to %s port %s");
      return_value_gm_world_current_host$5=gm_world_current_host(world);
      return_value_gm_world_current_port$6=gm_world_current_port(world);
      line=g_strdup_printf(return_value_gettext$4, return_value_gm_world_current_host$5, return_value_gm_world_current_port$6);
      break;
    }
    case (unsigned int)GM_NET_STATE_CONNECTED:
    {
      return_value_gettext$7=gettext("Connected");
      line=g_strdup(return_value_gettext$7);
      break;
    }
    case (unsigned int)GM_NET_STATE_DISCONNECTED:
    {
      if((signed int)pstate == GM_NET_STATE_CONNECTED || (signed int)pstate == GM_NET_STATE_DISCONNECTING)
      {
        char *return_value_gettext$8;
        return_value_gettext$8=gettext("Disconnected");
        line=g_strdup(return_value_gettext$8);
      }

      gm_world_view_update_status(view, (const char *)(void *)0);
      break;
    }
    case (unsigned int)GM_NET_STATE_DISCONNECTING:
    {
      return_value_gettext$9=gettext("Disconnecting");
      line=g_strdup(return_value_gettext$9);
      break;
    }
    default:
      ;
  }
  if(!(line == ((char *)NULL)))
  {
    gm_world_status(world, line);
    g_free((void *)line);
  }

}

// on_gm_world_view_world_text_received
// file widgets/gm-world-view.c line 747
void on_gm_world_view_world_text_received(struct _GmWorld *world, char *text, struct _GmWorldView *view)
{
  char *inserted;
  inserted=gm_world_text_view_insert(view->priv->text_view_world, text);
  g_free((void *)inserted);
}

// on_gm_world_view_world_text_view_scroll_event
// file widgets/gm-world-view.c line 950
signed int on_gm_world_view_world_text_view_scroll_event(struct _GmWorldView *view, struct _GdkEventScroll *event, struct _GmWorldTextView *text)
{
  if(!((4u & event->state) == 0u))
  {
    switch((signed int)event->direction)
    {
      case GDK_SCROLL_UP:
      {
        gm_world_view_change_font_size(view, -1);
        break;
      }
      case GDK_SCROLL_DOWN:
        gm_world_view_change_font_size(view, 1);
    }
    return (signed int)!(0 != 0);
  }

  else
    return 0;
  return 0;
}

// on_gm_world_view_world_text_view_url_activate
// file widgets/gm-world-view.c line 1017
void on_gm_world_view_world_text_view_url_activate(struct _GmWorldView *view, const char *url)
{
  gm_open_url(url);
}

// on_gm_worlds_list_dialog_button_connect_clicked
// file dialogs/gm-worlds-list-dialog.c line 336
void on_gm_worlds_list_dialog_button_connect_clicked(struct _GtkButton *button, void *user_data)
{
  gm_worlds_list_dialog_connect_world();
}

// on_gm_worlds_list_dialog_button_delete_clicked
// file dialogs/gm-worlds-list-dialog.c line 274
void on_gm_worlds_list_dialog_button_delete_clicked(struct _GtkButton *button, void *user_data)
{
  gm_worlds_list_dialog_delete_selected_worlds();
}

// on_gm_worlds_list_dialog_button_duplicate_clicked
// file dialogs/gm-worlds-list-dialog.c line 317
void on_gm_worlds_list_dialog_button_duplicate_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GmWorld *world;
  world=gm_worlds_list_dialog_selected_world();
  struct _GmWorld *new_world;
  if(!(world == ((struct _GmWorld *)NULL)))
  {
    new_world=gm_world_dup(world);
    gm_world_properties_dialog_run_new(new_world);
  }

  else
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("You first need to select a world to duplicate.");
    unsigned long int return_value_gtk_window_get_type$2;
    return_value_gtk_window_get_type$2=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)gm_worlds_list_dialog_instance->dialog, return_value_gtk_window_get_type$2);
    gm_error_dialog(return_value_gettext$1, (struct _GtkWindow *)return_value_g_type_check_instance_cast$3);
  }
}

// on_gm_worlds_list_dialog_button_modify_clicked
// file dialogs/gm-worlds-list-dialog.c line 311
void on_gm_worlds_list_dialog_button_modify_clicked(struct _GtkButton *button, void *user_data)
{
  gm_worlds_list_dialog_modify_world();
}

// on_gm_worlds_list_dialog_button_new_clicked
// file dialogs/gm-worlds-list-dialog.c line 305
void on_gm_worlds_list_dialog_button_new_clicked(struct _GtkButton *button, void *user_data)
{
  gm_world_properties_dialog_run_new((struct _GmWorld *)(void *)0);
}

// on_gm_worlds_list_dialog_response
// file dialogs/gm-worlds-list-dialog.c line 265
void on_gm_worlds_list_dialog_response(struct _GtkDialog *dialog, signed int response, void *user_data)
{
  g_object_unref((void *)gm_worlds_list_dialog_instance->xml);
  gtk_widget_destroy(gm_worlds_list_dialog_instance->dialog);
  g_free((void *)gm_worlds_list_dialog_instance);
  gm_worlds_list_dialog_instance = (struct _GmWorldsListDialog *)(void *)0;
}

// on_gm_worlds_list_dialog_tree_view_worlds_key_press
// file dialogs/gm-worlds-list-dialog.c line 280
void on_gm_worlds_list_dialog_tree_view_worlds_key_press(struct _GtkWidget *widget, struct _GdkEventKey *event, void *user_data)
{
  switch(event->keyval)
  {
    case (unsigned int)0x044:

    case (unsigned int)0x064:
    {
      gm_worlds_list_dialog_delete_selected_worlds();
      break;
    }
    case (unsigned int)0x04f:

    case (unsigned int)0x06f:
      break;
    case (unsigned int)0x04e:

    case (unsigned int)0x06e:
    {
      gm_world_properties_dialog_run_new((struct _GmWorld *)(void *)0);
      break;
    }
    case (unsigned int)0x04d:

    case (unsigned int)0x06d:
      gm_worlds_list_dialog_modify_world();
    default:
      ;
  }
}

// on_gm_worlds_list_dialog_tree_view_worlds_row_activated
// file dialogs/gm-worlds-list-dialog.c line 298
void on_gm_worlds_list_dialog_tree_view_worlds_row_activated(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  gm_worlds_list_dialog_modify_world();
}

// on_gm_worlds_view_app_world_added
// file widgets/gm-worlds-view.c line 269
static void on_gm_worlds_view_app_world_added(struct _GmApp *app, struct _GmWorld *world, struct _GmWorldsView *view)
{
  gm_worlds_view_add_world(view, world);
}

// on_gm_worlds_view_app_world_removed
// file widgets/gm-worlds-view.c line 275
static void on_gm_worlds_view_app_world_removed(struct _GmApp *app, struct _GmWorld *world, struct _GmWorldsView *view)
{
  struct _GtkTreeIter iter;
  signed int return_value_gm_worlds_view_find$3;
  return_value_gm_worlds_view_find$3=gm_worlds_view_find(view, world, &iter);
  if(!(return_value_gm_worlds_view_find$3 == 0))
  {
    unsigned long int return_value_gtk_list_store_get_type$1;
    return_value_gtk_list_store_get_type$1=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->model, return_value_gtk_list_store_get_type$1);
    gtk_list_store_remove((struct _GtkListStore *)return_value_g_type_check_instance_cast$2, &iter);
  }

}

// on_gm_worlds_view_world_option_changed
// file widgets/gm-worlds-view.c line 235
static void on_gm_worlds_view_world_option_changed(struct _GmOptions *options, const char *key, struct _GmWorldsView *view)
{
  struct _GtkTreeIter iter;
  struct _GtkListStore *store;
  unsigned long int return_value_gtk_list_store_get_type$1;
  return_value_gtk_list_store_get_type$1=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->model, return_value_gtk_list_store_get_type$1);
  store = (struct _GtkListStore *)return_value_g_type_check_instance_cast$2;
  char *text;
  const char *logo;
  struct _GdkPixbuf *pix_logo;
  struct _GmWorld *world;
  signed int return_value_gm_worlds_view_find_by_options$3;
  return_value_gm_worlds_view_find_by_options$3=gm_worlds_view_find_by_options(view, options, &iter, &world);
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$6;
  _Bool tmp_if_expr$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$4;
  if(!(return_value_gm_worlds_view_find_by_options$3 == 0))
  {
    signed int return_value_strcmp$5;
    return_value_strcmp$5=strcmp(key, "name");
    if(return_value_strcmp$5 == 0)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strcmp$6=strcmp(key, "player_name");
      tmp_if_expr$7 = return_value_strcmp$6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      return_value_strcmp$8=strcmp(key, "host");
      tmp_if_expr$9 = return_value_strcmp$8 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$9)
    {
      text=gm_worlds_view_world_text(view, world);
      gtk_list_store_set(store, &iter, 1, text, -1);
      g_free((void *)text);
    }

    else
    {
      return_value_strcmp$4=strcmp(key, "logo");
      if(!(return_value_strcmp$4 == 0))
      {
        logo=gm_options_get(options, "logo");
        if(!(logo == ((const char *)NULL)))
          pix_logo=gm_pixbuf_get_at_size(logo, 32, 32);

        else
          pix_logo=gm_pixbuf_get_at_size("world.svg", 32, 32);
        gtk_list_store_set(store, &iter, 0, pix_logo, -1);
      }

    }
  }

}

// on_notebook_triggers_switch_page
// file dialogs/gm-triggers-dialog.c line 732
void on_notebook_triggers_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num, struct _GmTriggersDialog *triggers)
{
  const struct _ModelData *conditionData = (const struct _ModelData *)(void *)0;
  const struct _ModelData *actionData = (const struct _ModelData *)(void *)0;
  unsigned long int return_value_gtk_window_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$3;
  unsigned long int return_value_gtk_window_get_type$4;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$6;
  if(page_num == 1u)
  {
    gtk_widget_set_sensitive(triggers->button_ok, (signed int)!(0 != 0));
    switch((signed int)triggers->trigger->event)
    {
      case TT_OUTPUT:
      {
        return_value_gtk_window_get_type$1=gtk_window_get_type();
        return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$1);
        return_value_gm_pixbuf_get_at_size$3=gm_pixbuf_get_at_size("world.svg", 16, 16);
        gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, return_value_gm_pixbuf_get_at_size$3);
        conditionData = dataConditionOutput;
        actionData = dataActionOutput;
        break;
      }
      case TT_USERS:
      {
        return_value_gtk_window_get_type$4=gtk_window_get_type();
        return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$4);
        return_value_gm_pixbuf_get_at_size$6=gm_pixbuf_get_at_size("ice-userlist/programmer.svg", 16, 16);
        gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, return_value_gm_pixbuf_get_at_size$6);
        conditionData = dataConditionUsers;
        actionData = dataActionUsers;
        break;
      }
      default:
        ;
    }
    gm_triggers_dialog_create_models(triggers, conditionData, actionData);
    if(!(triggers->trigger->name == ((char *)NULL)))
    {
      unsigned long int return_value_gtk_entry_get_type$7;
      return_value_gtk_entry_get_type$7=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)triggers->entry_name, return_value_gtk_entry_get_type$7);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$8, triggers->trigger->name);
    }

    gm_triggers_dialog_populate_conditions(triggers);
    gm_triggers_dialog_populate_actions(triggers);
  }

}

// on_row_deleted
// file mcp/gm-mcp-userlist-view.c line 122
static void on_row_deleted(struct _GtkTreeModel *model, struct _GtkTreePath *path, struct _GmMcpUserlistView *view)
{
  gm_mcp_userlist_view_prepare_scroll(view);
}

// on_row_inserted
// file mcp/gm-mcp-userlist-view.c line 116
static void on_row_inserted(struct _GtkTreeModel *model, struct _GtkTreePath *path, struct _GtkTreeIter *iter, struct _GmMcpUserlistView *view)
{
  gm_mcp_userlist_view_prepare_scroll(view);
}

// on_rows_reordered
// file mcp/gm-mcp-userlist-view.c line 110
static void on_rows_reordered(struct _GtkTreeModel *model, struct _GtkTreePath *path, struct _GtkTreeIter *iter, void *arg3, struct _GmMcpUserlistView *view)
{
  gm_mcp_userlist_view_prepare_scroll(view);
}

// on_signal_quit
// file gm-app.c line 649
static void on_signal_quit(signed int signum)
{
  gtk_main_quit();
}

// on_style_set
// file gm-support.c line 763
void on_style_set(struct _GtkWidget *widget, struct _GtkStyle *prev, void *user_data)
{
  enum _GmSchemedFlags flags = (enum _GmSchemedFlags)(signed int)(signed long int)user_data;
  struct _GmColorTable *table;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "gm_color_table");
  unsigned long int return_value_gm_color_table_get_type$3;
  return_value_gm_color_table_get_type$3=gm_color_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_get_data$2, return_value_gm_color_table_get_type$3);
  table = (struct _GmColorTable *)return_value_g_type_check_instance_cast$4;
  void *modifying;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  modifying=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$5, "gm_schemed_modifying_style");
  if(!((signed int)modifying == 1) || modifying == NULL)
  {
    if(!((GM_SCHEMED_COLORS & (signed int)flags) == 0))
    {
      on_color_changed(table, "fg_default", widget);
      on_color_changed(table, "bg_default", widget);
    }

    if(!((GM_SCHEMED_FONT & (signed int)flags) == 0))
    {
      const char *return_value_gm_color_table_font_description$6;
      return_value_gm_color_table_font_description$6=gm_color_table_font_description(table);
      on_font_changed(table, return_value_gm_color_table_font_description$6, widget);
    }

  }

}

// on_tree_view_event_types_changed
// file dialogs/gm-triggers-dialog.c line 699
void on_tree_view_event_types_changed(struct _GtkTreeSelection *treeselection, struct _GmTriggersDialog *triggers)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  signed int type;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)triggers->tree_view_event_types, return_value_gtk_tree_view_get_type$1);
  model=gtk_tree_view_get_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gtk_tree_selection_get_selected$3;
  return_value_gtk_tree_selection_get_selected$3=gtk_tree_selection_get_selected(treeselection, &model, &iter);
  unsigned long int return_value_gtk_window_get_type$4;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$6;
  unsigned long int return_value_gtk_window_get_type$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  struct _GdkPixbuf *return_value_gm_pixbuf_get_at_size$9;
  if(return_value_gtk_tree_selection_get_selected$3 == 0)
    gtk_widget_set_sensitive(triggers->button_next, 0);

  else
  {
    gtk_widget_set_sensitive(triggers->button_next, (signed int)!(0 != 0));
    gtk_tree_model_get(model, &iter, 2, &type, -1);
    switch(type)
    {
      case TT_OUTPUT:
      {
        return_value_gtk_window_get_type$4=gtk_window_get_type();
        return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$4);
        return_value_gm_pixbuf_get_at_size$6=gm_pixbuf_get_at_size("world.svg", 16, 16);
        gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, return_value_gm_pixbuf_get_at_size$6);
        break;
      }
      case TT_USERS:
      {
        return_value_gtk_window_get_type$7=gtk_window_get_type();
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)triggers->dialog, return_value_gtk_window_get_type$7);
        return_value_gm_pixbuf_get_at_size$9=gm_pixbuf_get_at_size("ice-userlist/programmer.svg", 16, 16);
        gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$8, return_value_gm_pixbuf_get_at_size$9);
        break;
      }
      default:
        ;
    }
  }
}

// on_tree_view_triggers_row_activated
// file dialogs/gm-world-properties-dialog.c line 764
void on_tree_view_triggers_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *arg1, struct _GtkTreeViewColumn *arg2, struct _GmWorldPropertiesDialog *properties)
{
  on_button_edit_trigger_clicked((struct _GtkButton *)(void *)0, properties);
}

// on_widget_destroy
// file gm-support.c line 784
void on_widget_destroy(struct _GtkWidget *widget, void *data)
{
  enum _GmSchemedFlags flags = (enum _GmSchemedFlags)(signed int)(signed long int)data;
  struct _GmColorTable *table;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "gm_color_table");
  unsigned long int return_value_gm_color_table_get_type$3;
  return_value_gm_color_table_get_type$3=gm_color_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_get_data$2, return_value_gm_color_table_get_type$3);
  table = (struct _GmColorTable *)return_value_g_type_check_instance_cast$4;
  if(!((GM_SCHEMED_COLORS & (signed int)flags) == 0))
    g_signal_handlers_disconnect_matched((void *)table, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_color_changed, (void *)widget);

  if(!((GM_SCHEMED_FONT & (signed int)flags) == 0))
    g_signal_handlers_disconnect_matched((void *)table, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_font_changed, (void *)widget);

  g_signal_handlers_disconnect_matched((void *)widget, (enum anonymous$74)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_widget_destroy, data);
}

// paned_restore_size
// file widgets/gm-world-view.c line 448
static signed int paned_restore_size(struct _GmWorldView *view)
{
  struct _GtkWidget *widget;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)view->priv->hpaned, return_value_gtk_widget_get_type$1);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_paned_get_type$3;
  return_value_gtk_paned_get_type$3=gtk_paned_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_paned_get_type$3);
  struct _GmOptions *return_value_gm_world_options$5;
  return_value_gm_world_options$5=gm_world_options(view->priv->world);
  signed int return_value_gm_options_get_int$6;
  return_value_gm_options_get_int$6=gm_options_get_int(return_value_gm_world_options$5, "pane_position");
  gtk_paned_set_position((struct _GtkPaned *)return_value_g_type_check_instance_cast$4, widget->allocation.width - return_value_gm_options_get_int$6);
  return 0;
}

// parse_error
// file list.c line 248
signed int parse_error(const char *e, signed int *i, char **s)
{
  signed int return_value_g_strcasecmp$16;
  return_value_g_strcasecmp$16=g_strcasecmp(e, "E_NONE");
  signed int return_value_g_strcasecmp$15;
  signed int return_value_g_strcasecmp$14;
  signed int return_value_g_strcasecmp$13;
  signed int return_value_g_strcasecmp$12;
  signed int return_value_g_strcasecmp$11;
  signed int return_value_g_strcasecmp$10;
  signed int return_value_g_strcasecmp$9;
  signed int return_value_g_strcasecmp$8;
  signed int return_value_g_strcasecmp$7;
  signed int return_value_g_strcasecmp$6;
  signed int return_value_g_strcasecmp$5;
  signed int return_value_g_strcasecmp$4;
  signed int return_value_g_strcasecmp$3;
  signed int return_value_g_strcasecmp$2;
  signed int return_value_g_strcasecmp$1;
  if(return_value_g_strcasecmp$16 == 0)
  {
    *i = 0;
    *s=g_strdup("No error");
  }

  else
  {
    return_value_g_strcasecmp$15=g_strcasecmp(e, "E_TYPE");
    if(return_value_g_strcasecmp$15 == 0)
    {
      *i = 1;
      *s=g_strdup("Type mismatch");
    }

    else
    {
      return_value_g_strcasecmp$14=g_strcasecmp(e, "E_DIV");
      if(return_value_g_strcasecmp$14 == 0)
      {
        *i = 2;
        *s=g_strdup("Division by zero");
      }

      else
      {
        return_value_g_strcasecmp$13=g_strcasecmp(e, "E_PERM");
        if(return_value_g_strcasecmp$13 == 0)
        {
          *i = 3;
          *s=g_strdup("Permission denied");
        }

        else
        {
          return_value_g_strcasecmp$12=g_strcasecmp(e, "E_PROPNF");
          if(return_value_g_strcasecmp$12 == 0)
          {
            *i = 4;
            *s=g_strdup("Property not found");
          }

          else
          {
            return_value_g_strcasecmp$11=g_strcasecmp(e, "E_VERBNF");
            if(return_value_g_strcasecmp$11 == 0)
            {
              *i = 5;
              *s=g_strdup("Verb not found");
            }

            else
            {
              return_value_g_strcasecmp$10=g_strcasecmp(e, "E_VARNF");
              if(return_value_g_strcasecmp$10 == 0)
              {
                *i = 6;
                *s=g_strdup("Variable not found");
              }

              else
              {
                return_value_g_strcasecmp$9=g_strcasecmp(e, "E_INVIND");
                if(return_value_g_strcasecmp$9 == 0)
                {
                  *i = 7;
                  *s=g_strdup("Invalid indirection");
                }

                else
                {
                  return_value_g_strcasecmp$8=g_strcasecmp(e, "E_RECMOVE");
                  if(return_value_g_strcasecmp$8 == 0)
                  {
                    *i = 8;
                    *s=g_strdup("Recursive move");
                  }

                  else
                  {
                    return_value_g_strcasecmp$7=g_strcasecmp(e, "E_MAXREC");
                    if(return_value_g_strcasecmp$7 == 0)
                    {
                      *i = 9;
                      *s=g_strdup("Too many verb calls");
                    }

                    else
                    {
                      return_value_g_strcasecmp$6=g_strcasecmp(e, "E_RANGE");
                      if(return_value_g_strcasecmp$6 == 0)
                      {
                        *i = 10;
                        *s=g_strdup("Range error");
                      }

                      else
                      {
                        return_value_g_strcasecmp$5=g_strcasecmp(e, "E_ARGS");
                        if(return_value_g_strcasecmp$5 == 0)
                        {
                          *i = 11;
                          *s=g_strdup("Incorrect number of arguments");
                        }

                        else
                        {
                          return_value_g_strcasecmp$4=g_strcasecmp(e, "E_NACC");
                          if(return_value_g_strcasecmp$4 == 0)
                          {
                            *i = 12;
                            *s=g_strdup("Move refused by destination");
                          }

                          else
                          {
                            return_value_g_strcasecmp$3=g_strcasecmp(e, "E_INVARG");
                            if(return_value_g_strcasecmp$3 == 0)
                            {
                              *i = 13;
                              *s=g_strdup("Invalid argument");
                            }

                            else
                            {
                              return_value_g_strcasecmp$2=g_strcasecmp(e, "E_QUOTA");
                              if(return_value_g_strcasecmp$2 == 0)
                              {
                                *i = 14;
                                *s=g_strdup("Resource limit exceeded");
                              }

                              else
                              {
                                return_value_g_strcasecmp$1=g_strcasecmp(e, "E_FLOAT");
                                if(return_value_g_strcasecmp$1 == 0)
                                {
                                  *i = 15;
                                  *s=g_strdup("Floating-point arithmetic error");
                                }

                                else
                                  return 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (signed int)!(0 != 0);
}

// pointer_from_offset_skipping_decomp
// file widgets/gm-searchable.c line 32
static const char * pointer_from_offset_skipping_decomp(const char *str, signed int offset)
{
  char *casefold;
  char *normal;
  const char *p;
  const char *q;
  p = str;
  while(offset >= 1)
  {
    q = (char *)(p + (signed long int)g_utf8_skip[(signed long int)*((const unsigned char *)p)]);
    casefold=g_utf8_casefold(p, q - p);
    normal=g_utf8_normalize(casefold, (signed long int)-1, (enum anonymous$98)G_NORMALIZE_NFD);
    signed long int return_value_g_utf8_strlen$1;
    return_value_g_utf8_strlen$1=g_utf8_strlen(normal, (signed long int)-1);
    offset = offset - (signed int)return_value_g_utf8_strlen$1;
    g_free((void *)casefold);
    g_free((void *)normal);
    p = q;
  }
  return p;
}

// popup_menu_detach
// file mcp/gm-mcp-userlist-view.c line 755
static void popup_menu_detach(struct _GtkWidget *attach_widget, struct _GtkMenu *menu)
{
  struct _GmMcpUserlistView *view;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)menu, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "McpUserlistView");
  view = (struct _GmMcpUserlistView *)return_value_g_object_get_data$2;
  view->popup_menu = (struct _GtkWidget *)(void *)0;
}

// resolve_file
// file widgets/gm-external-view.c line 82
static char * resolve_file(const char *file)
{
  struct _GSList *paths = (struct _GSList *)(void *)0;
  struct _GSList *item;
  char *resolve;
  char *prog;
  prog=g_find_program_in_path(file);
  signed int return_value_g_file_test$1;
  while(!(prog == ((char *)NULL)))
  {
    return_value_g_file_test$1=g_file_test(prog, (enum anonymous$106)G_FILE_TEST_IS_SYMLINK);
    if(return_value_g_file_test$1 == 0)
      break;

    paths=g_slist_prepend(paths, (void *)prog);
    resolve=g_file_read_link(prog, (struct _GError **)(void *)0);
    struct _GSList *return_value_g_slist_find_custom$2;
    return_value_g_slist_find_custom$2=g_slist_find_custom(paths, (const void *)resolve, (signed int (*)(const void *, const void *))strcmp);
    if(!(return_value_g_slist_find_custom$2 == ((struct _GSList *)NULL)))
    {
      prog = (char *)(void *)0;
      g_free((void *)resolve);
      break;
    }

    prog = resolve;
  }
  item = paths;
  for( ; !(item == ((struct _GSList *)NULL)); item = item->next)
    if(!((char *)item->data == prog))
      g_free(item->data);

  g_slist_free(paths);
  return prog;
}

// strbreakup
// file widgets/gm-searchable.c line 407
static char ** strbreakup(const char *string, const char *delimiter, signed int max_tokens)
{
  struct _GSList *string_list = (struct _GSList *)(void *)0;
  struct _GSList *slist;
  char **str_array;
  char *s;
  char *casefold;
  char *new_string;
  unsigned int i;
  unsigned int n = (unsigned int)1;
  do
    if(string == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"strbreakup", "string != NULL");
      return (char **)(void *)0;
    }

  while((_Bool)0);
  do
    if(delimiter == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"strbreakup", "delimiter != NULL");
      return (char **)(void *)0;
    }

  while((_Bool)0);
  if(!(max_tokens >= 1))
    max_tokens = 0x7fffffff;

  s=strstr(string, delimiter);
  if(!(s == ((char *)NULL)))
  {
    unsigned int delimiter_len;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(delimiter);
    delimiter_len = (unsigned int)return_value_strlen$1;
    do
    {
      unsigned int len = (unsigned int)((s - string) + (signed long int)delimiter_len);
      void *return_value_g_malloc_n$2;
      return_value_g_malloc_n$2=g_malloc_n((unsigned long int)(len + (unsigned int)1), sizeof(char) /*1ul*/ );
      new_string = (char *)return_value_g_malloc_n$2;
      strncpy(new_string, string, (unsigned long int)len);
      new_string[(signed long int)len] = (char)0;
      casefold=g_utf8_casefold(new_string, (signed long int)-1);
      g_free((void *)new_string);
      new_string=g_utf8_normalize(casefold, (signed long int)-1, (enum anonymous$98)G_NORMALIZE_NFD);
      g_free((void *)casefold);
      string_list=g_slist_prepend(string_list, (void *)new_string);
      n = n + 1u;
      string = s + (signed long int)delimiter_len;
      s=strstr(string, delimiter);
      max_tokens = max_tokens - 1;
    }
    while(!(s == ((char *)NULL)) && !(max_tokens == 0));
  }

  if(!(*string == 0))
  {
    n = n + 1u;
    casefold=g_utf8_casefold(string, (signed long int)-1);
    new_string=g_utf8_normalize(casefold, (signed long int)-1, (enum anonymous$98)G_NORMALIZE_NFD);
    g_free((void *)casefold);
    string_list=g_slist_prepend(string_list, (void *)new_string);
  }

  void *return_value_g_malloc_n$3;
  return_value_g_malloc_n$3=g_malloc_n((unsigned long int)n, sizeof(char *) /*8ul*/ );
  str_array = (char **)return_value_g_malloc_n$3;
  i = n - (unsigned int)1;
  unsigned int tmp_post$4 = i;
  i = i - 1u;
  str_array[(signed long int)tmp_post$4] = (char *)(void *)0;
  slist = string_list;
  unsigned int tmp_post$5;
  for( ; !(slist == ((struct _GSList *)NULL)); slist = slist->next)
  {
    tmp_post$5 = i;
    i = i - 1u;
    str_array[(signed long int)tmp_post$5] = (char *)slist->data;
  }
  g_slist_free(string_list);
  return str_array;
}

// stream_append
// file list.c line 39
void stream_append(struct anonymous$90 *s, char c)
{
  if(s->pos >= s->len + -1)
  {
    s->len = s->len * 2;
    void *return_value_g_realloc$1;
    return_value_g_realloc$1=g_realloc((void *)s->buf, (unsigned long int)(s->len + 1));
    s->buf = (char *)return_value_g_realloc$1;
  }

  signed int tmp_post$2 = s->pos;
  s->pos = s->pos + 1;
  s->buf[(signed long int)tmp_post$2] = c;
  s->buf[(signed long int)s->pos] = (char)0;
}

// stream_append_string
// file list.c line 49
void stream_append_string(struct anonymous$90 *s, const char *string)
{
  if(!(string == ((const char *)NULL)))
    for( ; !(*string == 0); string = string + 1l)
      stream_append(s, *string);

}

// stream_append_string_quoted
// file list.c line 59
void stream_append_string_quoted(struct anonymous$90 *s, const char *string)
{
  signed int i;
  stream_append(s, (char)34);
  i = 0;
  _Bool tmp_if_expr$1;
  for( ; !(string[(signed long int)i] == 0); i = i + 1)
  {
    if((signed int)string[(signed long int)i] == 92)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)string[(signed long int)i] == 34 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      stream_append(s, (char)92);

    stream_append(s, string[(signed long int)i]);
  }
  stream_append(s, (char)34);
}

// stream_free
// file list.c line 72
void stream_free(struct anonymous$90 *s)
{
  g_free((void *)s->buf);
  g_free((void *)s);
}

// stream_new
// file list.c line 28
struct anonymous$90 * stream_new(signed int len)
{
  struct anonymous$90 *s;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$90) /*16ul*/ );
  s = (struct anonymous$90 *)return_value_g_malloc$1;
  s->len = len > 1 ? len : 1;
  s->pos = 0;
  void *return_value_g_malloc$2;
  return_value_g_malloc$2=g_malloc((unsigned long int)(s->len + 1));
  s->buf = (char *)return_value_g_malloc$2;
  s->buf[(signed long int)s->pos] = (char)0;
  return s;
}

// subtract_rectangle
// file widgets/eggnotificationbubble.c line 267
static void subtract_rectangle(struct _GdkRegion *region, struct _GdkRectangle *rectangle)
{
  struct _GdkRegion *temp_region;
  temp_region=gdk_region_rectangle(rectangle);
  gdk_region_subtract(region, temp_region);
  gdk_region_destroy(temp_region);
}

// to_error
// file list.c line 304
char * to_error(signed int e)
{
  if(e == 0)
    return "E_NONE";

  else
    if(e == 1)
      return "E_TYPE";

    else
      if(e == 2)
        return "E_DIV";

      else
        if(e == 3)
          return "E_PERM";

        else
          if(e == 4)
            return "E_PROPNF";

          else
            if(e == 5)
              return "E_VERBNF";

            else
              if(e == 6)
                return "E_VARNF";

              else
                if(e == 7)
                  return "E_INVIND";

                else
                  if(e == 8)
                    return "E_RECMOVE";

                  else
                    if(e == 9)
                      return "E_MAXREC";

                    else
                      if(e == 10)
                        return "E_RANGE";

                      else
                        if(e == 12)
                          return "E_NACC";

                        else
                          if(e == 13)
                            return "E_INVARG";

                          else
                            if(e == 14)
                              return "E_QUOTA";

                            else
                              if(e == 15)
                                return "E_FLOAT";

                              else
                                return "";
}

