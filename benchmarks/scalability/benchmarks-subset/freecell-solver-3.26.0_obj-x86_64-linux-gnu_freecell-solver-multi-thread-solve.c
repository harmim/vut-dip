// #anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 209
enum anonymous$26 { FCS_NO_SHUFFLING=0, FCS_RAND=1, FCS_WEIGHTING=2 };

// #anon_enum$FLARES_PLAN_RUN_INDEFINITELY=0$FLARES_PLAN_RUN_COUNT_ITERS=1$FLARES_PLAN_CHECKPOINT=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 78
enum anonymous$27 { FLARES_PLAN_RUN_INDEFINITELY=0, FLARES_PLAN_RUN_COUNT_ITERS=1, FLARES_PLAN_CHECKPOINT=2 };

// tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 693
struct anonymous$17;

// tag-#anon#ST[*{S8}$S8$'befs_positions_by_rank'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests_list'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests_list_end'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'recycle_bin'|]#'brfs'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#$'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#'befs'|]#'meth'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 813
struct anonymous$35;

// tag-#anon#ST[*{S8}$S8$'buffer'||*{S8}$S8$'end_of_buffer'||S32'max_size'||U32'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 43
struct anonymous$51;

// tag-#anon#ST[*{S8}$S8$'old_list'||*{S8}$S8$'max_ptr'||*{S8}$S8$'ptr'||*{S8}$S8$'rollback_ptr'||*{SYM#tag-#anon#ST[*{S8}$S8$'recycle_bin'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'recycle_bin'|]#$'meta'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 48
struct anonymous$5;

// tag-#anon#ST[*{S8}$S8$'recycle_bin'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 43
struct anonymous$10;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_hash_symlink_item_struct#}$SYM#tag-fc_solve_hash_symlink_item_struct#$'first_item'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fc_solve_hash_symlink_item_struct#}$SYM#tag-fc_solve_hash_symlink_item_struct#$'first_item'|]#$'entries'||*{SYM#tag-fc_solve_hash_symlink_item_struct#}$SYM#tag-fc_solve_hash_symlink_item_struct#$'list_of_vacant_items'||ENtag-FCS_INLINED_HASH_DATA_TYPE#{U32}$U32$'hash_type'||S32'size'||S32'size_bitmask'||U32'$pad0'||S64'num_elems'||S64'max_num_elems_before_resize'||SYM#tag-#anon#ST[*{S8}$S8$'old_list'||*{S8}$S8$'max_ptr'||*{S8}$S8$'ptr'||*{S8}$S8$'rollback_ptr'||*{SYM#tag-#anon#ST[*{S8}$S8$'recycle_bin'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'recycle_bin'|]#$'meta'|]#'allocator'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 81
struct anonymous$41;

// tag-#anon#ST[*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'||U16'num_moves'||U48'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/internal_move_struct.h line 97
struct anonymous$3;

// tag-#anon#ST[*{SYM#tag-#anon#ST[S32'num_flares'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#$'flares'||*{SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#}$SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#$'plan'||S32'num_plan_items'||S32'current_plan_item_idx'||S32'minimal_solution_flare_idx'||S32'all_plan_items_finished_so_far'||*{S8}$S8$'flares_plan_string'||B'flares_plan_compiled'||U24'$pad1'||S32'limit'|]#}$SYM#tag-#anon#ST[S32'num_flares'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#$'flares'||*{SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#}$SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#$'plan'||S32'num_plan_items'||S32'current_plan_item_idx'||S32'minimal_solution_flare_idx'||S32'all_plan_items_finished_so_far'||*{S8}$S8$'flares_plan_string'||B'flares_plan_compiled'||U24'$pad1'||S32'limit'|]#$'instances_list'||S32'num_instances'||S32'current_instance_idx'||S64'current_iterations_limit'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'iterations_board_started_at'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'init_num_checked_states'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#$'active_flare'||SYM#tag-fcs_state_keyval_pair_struct#'state'||SYM#tag-fcs_state_keyval_pair_struct#'running_state'||SYM#tag-fcs_state_keyval_pair_struct#'initial_non_canonized_state'||SYM#tag-#anon#ST[ARR10{S8}$S8$'stack_locs'||ARR8{S8}$S8$'fc_locs'|]#'state_locs'||SYM#tag-#anon#ST[ARR10{S8}$S8$'stack_locs'||ARR8{S8}$S8$'fc_locs'|]#'trace_solution_state_locs'||SYM#tag-#anon#ST[ARR10{S8}$S8$'stack_locs'||ARR8{S8}$S8$'fc_locs'|]#'initial_state_locs'||U16'$pad0'||S32'ret_code'||B'all_instances_were_suspended'||U24'$pad1'||S32'state_validity_ret'||S8'state_validity_card'||U24'$pad2'||*{V(*{V}$V$|S32|S32|*{V}$V$|S32|*{V}$V$)->V}$V(*{V}$V$|S32|S32|*{V}$V$|S32|*{V}$V$)->V$'iter_handler'||*{V(*{V}$V$|S64|S32|*{V}$V$|S64|*{V}$V$)->V}$V(*{V}$V$|S64|S32|*{V}$V$|S64|*{V}$V$)->V$'long_iter_handler'||*{V}$V$'iter_handler_context'||ENtag-FLARES_CHOICE_TYPE#{U32}$U32$'flares_choice'||U32'$pad3'||F64'flares_iters_factor'||*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$'soft_thread'||ARR1280{S8}$S8$'indirect_stacks_buffer'||*{S8}$S8$'state_string_copy'||SYM#tag-#anon#ST[S32'preset_id'||SYM#tag-#anon#ST[U8'freecells_num'||U8'stacks_num'||U8'decks_num'||U8'game_flags'|]#'game_params'||ARR73{S8}$S8$'tests_order'||ARR73{S8}$S8$'allowed_tests'||U16'$pad0'|]#'common_preset'||U32'$pad4'||*{S8}$S8$'error_string'||SYM#tag-#anon#ST[*{S8}$S8$'recycle_bin'|]#'meta_alloc'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 122
struct anonymous;

// tag-#anon#ST[*{SYM#tag-fc_solve_hash_symlink_item_struct#}$SYM#tag-fc_solve_hash_symlink_item_struct#$'first_item'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 74
struct anonymous$54;

// tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 63
struct anonymous$2;

// tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state'||SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}$SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#$'derived_states_random_indexes'||*{S8}$S8$'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 656
struct anonymous$50;

// tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 316
struct anonymous$38;

// tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 62
struct anonymous$19;

// tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'recycle_bin'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 819
struct anonymous$31;

// tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 524
struct anonymous$6;

// tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'||*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'s'||SYM#tag-#anon#ST[ARR10{S8}$S8$'stack_locs'||ARR8{S8}$S8$'fc_locs'|]#'locs'||U48'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 612
struct anonymous$13;

// tag-#anon#ST[*{cS8}$cS8$'alias'||S32'test_num'||U32'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.h line 17
struct anonymous$47;

// tag-#anon#ST[ARR10{S8}$S8$'stack_locs'||ARR8{S8}$S8$'fc_locs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 483
struct anonymous$7;

// tag-#anon#ST[ARR32{cS8}$cS8$'name'||S32'preset_id'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 308
struct anonymous$48;

// tag-#anon#ST[ARR4{U8}$U8$'c'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_move.h line 57
struct anonymous$4;

// tag-#anon#ST[B'debug_iter_state_output'||B'parseable_output'||B'canonized_order_output'||B'display_10_as_t'||B'display_parent_iter_num'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 53
struct anonymous$24;

// tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 192
struct anonymous$15;

// tag-#anon#ST[S32'argc'||U32'$pad0'||*{*{S8}$S8$}$*{S8}$S8$$'argv'||*{S8}$S8$'last_arg'||*{S8}$S8$'last_arg_ptr'||*{S8}$S8$'last_arg_end'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 32
struct anonymous$37;

// tag-#anon#ST[S32'argc'||U32'$pad0'||*{*{S8}$S8$}$*{S8}$S8$$'argv'||S32'arg'||S32'stop_at'||S32'end_board'||S32'board_num_step'||S32'update_total_num_iters_threshold'||U32'$pad1'||S64'total_iterations_limit_per_board'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 194
struct anonymous$22;

// tag-#anon#ST[S32'dfs_max_depth'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state'||SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}$SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#$'derived_states_random_indexes'||*{S8}$S8$'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state'||SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}$SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#$'derived_states_random_indexes'||*{S8}$S8$'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'$pad0'|]#$'soft_dfs_info'||S32'depth'||U32'$pad1'||S64'rand_gen'||S32'rand_seed'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_units'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]#'tests'|]#}$SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]#'tests'|]#$'by_depth_units'|]#'tests_by_depth_array'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 759
struct anonymous$49;

// tag-#anon#ST[S32'ds'||S32'dc'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 1003
struct anonymous$46;

// tag-#anon#ST[S32'idx'||S32'rating'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 651
struct anonymous$29;

// tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_groups'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'groups'|]#'tests_order'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 230
struct anonymous$21;

// tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]#'tests'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 705
struct anonymous$52;

// tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#$'Elements'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 68
struct anonymous$32;

// tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 49
struct anonymous$40;

// tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 216
struct anonymous$20;

// tag-#anon#ST[S32'num'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_groups'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'groups'|]#'tests_order'|]#}$SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_groups'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'groups'|]#'tests_order'|]#$'by_depth_tests'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 236
struct anonymous$28;

// tag-#anon#ST[S32'num_flares'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}$SYM#tag-fc_solve_instance_struct#$'obj'||S32'ret_code'||B'instance_is_ready'||U24'$pad0'||S32'limit'||U32'$pad1'||*{S8}$S8$'name'||S32'next_move'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]#$'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#$'flares'||*{SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#}$SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#$'plan'||S32'num_plan_items'||S32'current_plan_item_idx'||S32'minimal_solution_flare_idx'||S32'all_plan_items_finished_so_far'||*{S8}$S8$'flares_plan_string'||B'flares_plan_compiled'||U24'$pad1'||S32'limit'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 98
struct anonymous$1;

// tag-#anon#ST[S32'num_groups'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[S32'num'||U32'$pad0'||*{S32}$S32$'tests'||EN#anon_enum$FCS_NO_SHUFFLING=0$FCS_RAND=1$FCS_WEIGHTING=2#{U32}$U32$'shuffling_type'||U32'$pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'groups'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 224
struct anonymous$9;

// tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 700
struct anonymous$16;

// tag-#anon#ST[S32'num_moves'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#}$SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#$'moves'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_move.h line 85
struct anonymous$11;

// tag-#anon#ST[S32'num_separate_false_seqs'||ARR20{S32}$S32$'seq_points'||ARR10{S32}$S32$'junk_move_to_stacks'||S32'after_junk_num_freestacks'||ARR20{S32}$S32$'above_num_true_seqs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 198
struct anonymous$45;

// tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 326
struct anonymous$12;

// tag-#anon#ST[S32'num_units'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]#'tests'|]#}$SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]#'tests'|]#$'by_depth_units'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 710
struct anonymous$18;

// tag-#anon#ST[S32'preset_id'||SYM#tag-#anon#ST[U8'freecells_num'||U8'stacks_num'||U8'decks_num'||U8'game_flags'|]#'game_params'||ARR73{S8}$S8$'tests_order'||ARR73{S8}$S8$'allowed_tests'||U16'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 43
struct anonymous$36;

// tag-#anon#ST[S32'scan_idx'||S32'quota'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 562
struct anonymous$42;

// tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 91
struct anonymous$0;

// tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 53
struct anonymous$44;

// tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'recycle_bin'|]#'brfs'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#$'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#'befs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 817
struct anonymous$34;

// tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}$U8$'c'|]#'move'||B'to_empty_stack'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 43
struct anonymous$53;

// tag-#anon#ST[SYM#tag-#anon#ST[B'debug_iter_state_output'||B'parseable_output'||B'canonized_order_output'||B'display_10_as_t'||B'display_parent_iter_num'|]#'display_context'||U24'$pad0'||*{V}$V$'instance'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 99
struct anonymous$25;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'dfs_max_depth'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state'||SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}$SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#$'derived_states_random_indexes'||*{S8}$S8$'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state'||SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}$SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#$'derived_states_random_indexes'||*{S8}$S8$'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'$pad0'|]#$'soft_dfs_info'||S32'depth'||U32'$pad1'||S64'rand_gen'||S32'rand_seed'||U32'$pad2'||SYM#tag-#anon#ST[S32'num_units'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]#'tests'|]#}$SYM#tag-#anon#ST[S32'max_depth'||U32'$pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'$pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#}$SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#$'lists'|]#'tests'|]#$'by_depth_units'|]#'tests_by_depth_array'|]#'soft_dfs'||SYM#tag-#anon#ST[*{S8}$S8$'befs_positions_by_rank'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests_list'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$}$*{V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V}$V(*{SYM#tag-fc_solve_soft_thread_struct#}$SYM#tag-fc_solve_soft_thread_struct#$|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}$SYM#tag-fcs_struct_state_t#$'key'||*{SYM#tag-fcs_state_extra_info_struct#}$SYM#tag-fcs_state_extra_info_struct#$'val'|]#$|*{SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#}$SYM#tag-#anon#ST[S32'num_states'||U32'$pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'state_ptr'||SYM#tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]#'context'|]#$'states'|]#$)->V$$'tests_list_end'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}$SYM#tag-fcs_states_linked_list_item_struct#$'recycle_bin'|]#'brfs'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#$'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]#'befs'|]#'meth'|]#'befs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 757
struct anonymous$39;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'val'||S32'rating'||U32'$pad0'|]#$'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'$pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}$F64$'num_cards_out_lookup_table'||ARR6{F64}$F64$'befs_weights'|]#'weighting'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 837
struct anonymous$33;

// tag-#anon#ST[SYM#tag-fcs_struct_state_t#'s'||SYM#tag-fcs_state_extra_info_struct#'info'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 513
struct anonymous$55;

// tag-#anon#ST[SYM#tag-timeval#'tv'||SYM#tag-timezone#'tz'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/portable_time.h line 44
struct anonymous$30;

// tag-#anon#ST[U8'freecells_num'||U8'stacks_num'||U8'decks_num'||U8'game_flags'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/game_type_params.h line 33
struct anonymous$14;

// tag-#anon#UN[*{V}$V$'ptr'||S32'i'||ARR8{S8}$S8$'c'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 318
union anonymous$8;

// tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-fcs_struct_state_t#'s'||SYM#tag-fcs_state_extra_info_struct#'info'|]#'$anon0'||*{SYM#tag-fcs_state_keyval_pair_struct#}$SYM#tag-fcs_state_keyval_pair_struct#$'next'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 511
union anonymous$43;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$23;

// tag-FCS_INLINED_HASH_DATA_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 45
enum FCS_INLINED_HASH_DATA_TYPE { FCS_INLINED_HASH__COLUMNS=0, FCS_INLINED_HASH__STATES=1 };

// tag-FCS_SUPER_METHOD_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 715
enum FCS_SUPER_METHOD_TYPE { FCS_SUPER_METHOD_DFS=0, FCS_SUPER_METHOD_BEFS_BRFS=1 };

// tag-FLARES_CHOICE_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 85
enum FLARES_CHOICE_TYPE { FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN=0, FLARES_CHOICE_FCPRO_SOLUTION_LEN=1 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-fc_solve_hard_thread_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 154
struct fc_solve_hard_thread_struct;

// tag-fc_solve_hash_symlink_item_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 54
struct fc_solve_hash_symlink_item_struct;

// tag-fc_solve_instance_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 79
struct fc_solve_instance_struct;

// tag-fc_solve_soft_thread_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 155
struct fc_solve_soft_thread_struct;

// tag-fcs_state_extra_info_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 418
struct fcs_state_extra_info_struct;

// tag-fcs_state_keyval_pair_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 405
struct fcs_state_keyval_pair_struct;

// tag-fcs_states_linked_list_item_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 124
struct fcs_states_linked_list_item_struct;

// tag-fcs_struct_state_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 219
struct fcs_struct_state_t;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// Cvtf89
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 41
static inline signed int Cvtf89(signed int fcn);
// FCS_STATE_keyval_pair_to_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv(struct anonymous$6 *ret, struct fcs_state_keyval_pair_struct *s);
// FCS_STATE_keyval_pair_to_kv$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv$link1(struct anonymous$6 *ret$link1, struct fcs_state_keyval_pair_struct *s$link1);
// FCS_STATE_keyval_pair_to_kv$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv$link2(struct anonymous$6 *ret$link2, struct fcs_state_keyval_pair_struct *s$link2);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// accumulate_tests_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 199
static inline void accumulate_tests_by_ptr(signed int * const tests_order, struct anonymous$9 * const st_tests_order);
// accumulate_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 217
static inline void accumulate_tests_order(struct fc_solve_soft_thread_struct * const soft_thread, void * const context);
// add_checkpoint_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 476
static inline signed int add_checkpoint_to_plan(struct anonymous$1 *instance_item);
// add_count_iters_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 464
static inline signed int add_count_iters_to_plan(struct anonymous$1 *instance_item, signed int flare_idx, signed int count_iters);
// add_run_indef_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 485
static inline signed int add_run_indef_to_plan(struct anonymous$1 *instance_item, signed int flare_idx);
// add_to_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 65
static inline void add_to_last_arg(struct anonymous$37 *manager, char c);
// add_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 443
static inline signed int add_to_plan(struct anonymous$1 *instance_item, signed int mytype, signed int flare_idx, signed int count_iters);
// apply_game_params_for_all_instances
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1494
static void apply_game_params_for_all_instances(struct anonymous * const user);
// assign_dest_stack_and_col_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2059
static inline void assign_dest_stack_and_col_ptr(char * const positions_by_rank, signed int dest_stack, signed int dest_col, char dest_card);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// befs_rate_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 328
static inline signed int befs_rate_state(const struct fc_solve_soft_thread_struct * const soft_thread, const struct anonymous$15 * const weighting, const struct fcs_struct_state_t * const state, const signed int neg_depth);
// bsearch
// file /usr/include/stdlib.h line 754
extern void * bsearch(const void *, const void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 66
static inline signed int calc_depth(struct fcs_state_keyval_pair_struct *ptr_state);
// calc_foundation_to_put_card_on
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1903
static inline signed int calc_foundation_to_put_card_on(const struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const my_ptr_state, const char card);
// calc_moves_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 869
static signed int calc_moves_seq(const struct anonymous$3 * const solution_moves, struct anonymous$11 * const moves_seq);
// calculate_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 551
static inline void calculate_real_depth(const _Bool calc_real_depth, struct fcs_state_keyval_pair_struct * const ptr_state_orig);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// card_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 92
static inline char * card_to_string(char *s, signed int card, signed int not_append_ws);
// clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 287
static inline void clean_soft_dfs(struct fc_solve_instance_struct * const instance);
// cmd_line_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 106
static signed int cmd_line_callback(void *instance, signed int argc, const char **argv, signed int arg, signed int *num_to_skip, signed int *ret, void *context);
// compare_rating_with_index
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 962
static signed int compare_rating_with_index(const void *void_a, const void *void_b);
// compile_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 491
static inline signed int compile_prelude(struct fc_solve_hard_thread_struct * const hard_thread);
// convert_freecell_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 170
static inline signed int convert_freecell_num(signed int fcn);
// count_num_vacant_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 926
static inline unsigned char count_num_vacant_freecells(const unsigned char freecells_num, const struct fcs_struct_state_t * const state_ptr);
// count_num_vacant_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 943
static inline unsigned char count_num_vacant_stacks(const unsigned char stacks_num, const struct fcs_struct_state_t * const state_ptr);
// determine_scan_completeness
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 225
static inline void determine_scan_completeness(struct fc_solve_soft_thread_struct * const soft_thread, void * const global_tests_order);
// duplicate_string_while_adding_a_trailing_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 722
static inline char * duplicate_string_while_adding_a_trailing_newline(const char *orig_str);
// empty_two_cols_from_new_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 187
static inline signed int empty_two_cols_from_new_state(const struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const kv_ptr_new_state, struct anonymous$3 * const moves, const signed int *cols_indexes, const signed int nc1, const signed int nc2);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 606
static inline const _Bool false_seq_index_loop(const signed int stacks_num, struct anonymous$6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous$45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag);
// fc_solve_PQueueFree
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree(struct anonymous$32 *pq);
// fc_solve_PQueueFree$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree$link1(struct anonymous$32 *pq$link1);
// fc_solve_PQueueFree$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree$link2(struct anonymous$32 *pq$link2);
// fc_solve_PQueueInitialise
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 88
static inline void fc_solve_PQueueInitialise(struct anonymous$32 *pq, signed int MaxElements);
// fc_solve_PQueuePop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 177
static inline void fc_solve_PQueuePop(struct anonymous$32 *pq, struct fcs_state_keyval_pair_struct **val);
// fc_solve_PQueuePush
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 114
static inline void fc_solve_PQueuePush(struct anonymous$32 *pq, struct fcs_state_keyval_pair_struct *val, signed int r);
// fc_solve_alloc_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 394
struct fc_solve_instance_struct * fc_solve_alloc_instance(struct anonymous$10 * const meta_alloc);
// fc_solve_append_string_finalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 62
static inline char * fc_solve_append_string_finalize(struct anonymous$51 *app_str);
// fc_solve_append_string_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 53
static inline void fc_solve_append_string_init(struct anonymous$51 *app_str);
// fc_solve_append_string_sprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.c line 38
extern void fc_solve_append_string_sprintf(struct anonymous$51 *app_str, const char *format, ...);
// fc_solve_apply_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 120
void fc_solve_apply_move(struct anonymous$6 *state, struct anonymous$7 *locs, struct anonymous$4 move, signed int freecells_num, signed int stacks_num, signed int decks_num);
// fc_solve_apply_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 58
extern signed int fc_solve_apply_preset_by_name(struct fc_solve_instance_struct *instance, const char *name);
// fc_solve_apply_preset_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 53
extern signed int fc_solve_apply_preset_by_ptr(struct fc_solve_instance_struct *instance, const struct anonymous$36 *preset_ptr);
// fc_solve_apply_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 74
extern signed int fc_solve_apply_tests_order(struct anonymous$9 *tests_order, const char *string, char **error_string);
// fc_solve_args_man_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 40
extern struct anonymous$37 * fc_solve_args_man_alloc(void);
// fc_solve_args_man_chop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 42
extern signed int fc_solve_args_man_chop(struct anonymous$37 *manager, char *string);
// fc_solve_args_man_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 41
extern void fc_solve_args_man_free(struct anonymous$37 *manager);
// fc_solve_befs_or_bfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 925
extern signed int fc_solve_befs_or_bfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_befs_or_bfs_do_solve::1::6::12::next_test$object$object
// 
void next_test$object$object(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_befs_or_bfs_do_solve::1::debug_iter_output_func$object
// 
void debug_iter_output_func$object(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int);
// fc_solve_befs_or_bfs_do_solve::1::tests_list$object$object
// 
void tests_list$object$object(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_befs_or_bfs_do_solve::1::tests_list_end$object$object
// 
void tests_list_end$object$object(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_cache_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 82
static inline void fc_solve_cache_stacks(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous$6 * const new_state);
// fc_solve_calc_positions_by_rank_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2033
static inline char ** fc_solve_calc_positions_by_rank_location(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_canonize_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 634
extern void fc_solve_canonize_state(struct anonymous$6 *state_raw, signed int freecells_num, signed int stacks_num);
// fc_solve_canonize_state_with_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 640
void fc_solve_canonize_state_with_locs(struct anonymous$6 *state, struct anonymous$7 *locs, signed int freecells_num, signed int stacks_num);
// fc_solve_card_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare(const char c1, const char c2);
// fc_solve_card_compare$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare$link1(const char c1$link1, const char c2$link1);
// fc_solve_card_perl2user
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 266
extern char * fc_solve_card_perl2user(char card, char *str, _Bool t);
// fc_solve_card_user2perl
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 140
extern char fc_solve_card_user2perl(const char *str);
// fc_solve_check_and_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 316
_Bool fc_solve_check_and_add_state(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous$6 * const new_state, struct anonymous$6 * const existing_state_raw);
// fc_solve_check_state_validity
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1036
static inline signed int fc_solve_check_state_validity(struct fcs_state_keyval_pair_struct *state_pair, signed int freecells_num, signed int stacks_num, signed int decks_num, char *misplaced_card);
// fc_solve_compact_allocator_extend
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 57
extern void fc_solve_compact_allocator_extend(struct anonymous$5 *allocator);
// fc_solve_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 113
extern void fc_solve_compact_allocator_finish(struct anonymous$5 *allocator);
// fc_solve_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 81
extern void fc_solve_compact_allocator_init(struct anonymous$5 *allocator, struct anonymous$10 *meta_allocator);
// fc_solve_compact_allocator_init_helper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper(struct anonymous$5 *allocator);
// fc_solve_compact_allocator_init_helper$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper$link1(struct anonymous$5 *allocator$link1);
// fc_solve_compact_allocator_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 130
static inline void fc_solve_compact_allocator_recycle(struct anonymous$5 *allocator);
// fc_solve_derived_states_list_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 340
extern void fc_solve_derived_states_list_add_state(struct anonymous$12 *list, struct fcs_state_keyval_pair_struct *state, signed int context);
// fc_solve_finish_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1028
extern void fc_solve_finish_instance(struct fc_solve_instance_struct * const instance);
// fc_solve_foreach_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 240
extern void fc_solve_foreach_soft_thread(struct fc_solve_instance_struct * const instance, const signed int callback_choice, void * const context);
// fc_solve_free_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1830
static inline void fc_solve_free_instance(struct fc_solve_instance_struct *instance);
// fc_solve_free_soft_thread_by_depth_test_array
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 160
extern void fc_solve_free_soft_thread_by_depth_test_array(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_free_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order(struct anonymous$9 *tests_order);
// fc_solve_free_tests_order$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order$link1(struct anonymous$9 *tests_order$link1);
// fc_solve_free_tests_order$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order$link2(struct anonymous$9 *tests_order$link2);
// fc_solve_get_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 63
extern signed int fc_solve_get_preset_by_name(const char *name, const struct anonymous$36 **preset_ptr);
// fc_solve_get_the_positions_by_rank_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 54
extern char * fc_solve_get_the_positions_by_rank_data(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key, char * (*generator)(struct fc_solve_soft_thread_struct *, const struct fcs_struct_state_t *));
// fc_solve_get_the_positions_by_rank_data::generator$object
// 
char * generator$object(struct fc_solve_soft_thread_struct *, const struct fcs_struct_state_t *);
// fc_solve_get_the_positions_by_rank_data__freecell_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 49
extern char * fc_solve_get_the_positions_by_rank_data__freecell_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key);
// fc_solve_hash_foreach
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 195
static inline void fc_solve_hash_foreach(struct anonymous$41 * const hash, _Bool (*should_delete_ptr)(void *, void *), void * const context);
// fc_solve_hash_foreach::should_delete_ptr$object
// 
_Bool should_delete_ptr$object(void *, void *);
// fc_solve_hash_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 185
static inline void fc_solve_hash_free(struct anonymous$41 * const hash);
// fc_solve_hash_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 118
static inline void fc_solve_hash_init(struct anonymous$10 * const meta_alloc, struct anonymous$41 * const hash, const enum FCS_INLINED_HASH_DATA_TYPE hash_type);
// fc_solve_hash_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 170
extern _Bool fc_solve_hash_insert(struct anonymous$41 * const hash, void * const key, void ** const existing_key, const signed int hash_value);
// fc_solve_hash_rehash
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.c line 192
static inline void fc_solve_hash_rehash(struct anonymous$41 * const hash);
// fc_solve_increase_dfs_max_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 929
extern void fc_solve_increase_dfs_max_depth(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_init_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 557
extern void fc_solve_init_instance(struct fc_solve_instance_struct *instance);
// fc_solve_init_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 494
static inline void fc_solve_init_locs(struct anonymous$7 *locs);
// fc_solve_initial_user_state_to_c_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 793
static inline signed int fc_solve_initial_user_state_to_c_proto(const char *string, struct fcs_state_keyval_pair_struct *out_state, signed int freecells_num, signed int stacks_num, signed int decks_num, char *indirect_stacks_buffer);
// fc_solve_initialize_befs_rater
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$15 *weighting);
// fc_solve_initialize_befs_rater$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater$link1(struct fc_solve_soft_thread_struct * const soft_thread$link1, struct anonymous$15 *weighting$link1);
// fc_solve_initialize_bfs_queue
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 1540
static inline void fc_solve_initialize_bfs_queue(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_instance__init_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 357
extern void fc_solve_instance__init_hard_thread(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_instance__recycle_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1730
static inline void fc_solve_instance__recycle_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_instance_get_first_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1630
static inline struct fc_solve_soft_thread_struct * fc_solve_instance_get_first_soft_thread(struct fc_solve_instance_struct *instance);
// fc_solve_meta_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 77
extern void fc_solve_meta_compact_allocator_finish(struct anonymous$10 *meta_allocator);
// fc_solve_meta_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 70
static inline void fc_solve_meta_compact_allocator_init(struct anonymous$10 *meta);
// fc_solve_move_sequence_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function(struct anonymous$6 * const new_state_kv_ptr, struct anonymous$3 * const moves, const signed int dest_idx, const signed int source_idx, const signed int start, const signed int end);
// fc_solve_move_sequence_function$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function$link1(struct anonymous$6 * const new_state_kv_ptr$link1, struct anonymous$3 * const moves$link1, const signed int dest_idx$link1, const signed int source_idx$link1, const signed int start$link1, const signed int end$link1);
// fc_solve_move_stack_compact_allocate
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous$3 * fc_solve_move_stack_compact_allocate(struct fc_solve_hard_thread_struct *hard_thread, struct anonymous$3 *old_move_stack_to_parent);
// fc_solve_move_stack_compact_allocate$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous$3 * fc_solve_move_stack_compact_allocate$link1(struct fc_solve_hard_thread_struct *hard_thread$link1, struct anonymous$3 *old_move_stack_to_parent$link1);
// fc_solve_move_stack_normalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 156
static inline void fc_solve_move_stack_normalize(struct anonymous$3 *moves, struct anonymous$6 *init_state, struct anonymous$7 *locs, signed int freecells_num, signed int stacks_num, signed int decks_num);
// fc_solve_move_stack_pop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 97
static inline _Bool fc_solve_move_stack_pop(struct anonymous$3 *stack, struct anonymous$4 *move);
// fc_solve_move_stack_swallow_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 144
static inline void fc_solve_move_stack_swallow_stack(struct anonymous$3 *stack, struct anonymous$3 *src_stack);
// fc_solve_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 305
static inline char * fc_solve_move_to_string(struct anonymous$4 move, signed int standard_notation);
// fc_solve_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 296
extern char * fc_solve_move_to_string_w_state(struct fcs_state_keyval_pair_struct *state, signed int freecells_num, signed int stacks_num, signed int decks_num, struct anonymous$4 move, signed int standard_notation);
// fc_solve_moves_processed_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 80
static inline void fc_solve_moves_processed_free(struct anonymous$40 *moves);
// fc_solve_moves_processed_gen
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 123
extern void fc_solve_moves_processed_gen(struct anonymous$40 * const ret, struct fcs_state_keyval_pair_struct * const orig, const signed int num_freecells, const struct anonymous$11 * const moves_seq);
// fc_solve_moves_processed_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 65
static inline signed int fc_solve_moves_processed_get_moves_left(struct anonymous$40 *moves);
// fc_solve_moves_processed_render_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 46
char * fc_solve_moves_processed_render_move(struct anonymous$53 move, char *string);
// fc_solve_new_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread(struct fc_solve_instance_struct * const instance);
// fc_solve_new_hard_thread$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread$link1(struct fc_solve_instance_struct * const instance$link1);
// fc_solve_new_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1118
extern struct fc_solve_soft_thread_struct * fc_solve_new_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_optimize_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1430
static inline signed int fc_solve_optimize_solution(struct fc_solve_instance_struct *instance);
// fc_solve_p2u_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 181
extern char * fc_solve_p2u_rank(signed int rank_idx, char *str, _Bool *rank_is_null, _Bool t);
// fc_solve_p2u_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 224
static inline char * fc_solve_p2u_suit(signed int suit, char *str, _Bool rank_is_null);
// fc_solve_rand_get_random_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 55
static inline signed int fc_solve_rand_get_random_number(signed long int *my_rand);
// fc_solve_rand_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 38
static inline void fc_solve_rand_init(signed long int *my_rand, unsigned int seed);
// fc_solve_rand_rand15
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 43
static inline signed int fc_solve_rand_rand15(signed long int *my_rand);
// fc_solve_recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1747
static inline void fc_solve_recycle_instance(struct fc_solve_instance_struct * const instance);
// fc_solve_release_tests_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1696
static inline void fc_solve_release_tests_list(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_reset_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_reset_hard_thread$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread$link1(struct fc_solve_hard_thread_struct * const hard_thread$link1);
// fc_solve_reset_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_reset_soft_thread$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread$link1(struct fc_solve_soft_thread_struct * const soft_thread$link1);
// fc_solve_resume_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1499
static inline signed int fc_solve_resume_instance(struct fc_solve_instance_struct *instance);
// fc_solve_set_weights
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights(const char *start_num, double * const befs_weights);
// fc_solve_set_weights$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights$link1(const char *start_num$link1, double * const befs_weights$link1);
// fc_solve_sfs_atomic_move_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1582
extern void fc_solve_sfs_atomic_move_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_atomic_move_card_to_freecell
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1719
extern void fc_solve_sfs_atomic_move_card_to_freecell(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_atomic_move_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1656
extern void fc_solve_sfs_atomic_move_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_atomic_move_freecell_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1827
extern void fc_solve_sfs_atomic_move_freecell_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_atomic_move_freecell_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1777
extern void fc_solve_sfs_atomic_move_freecell_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_check_state_begin
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 63
extern signed int fc_solve_sfs_check_state_begin(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous$6 * const out_new_state_out, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$3 * const moves);
// fc_solve_sfs_check_state_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 70
extern void fc_solve_sfs_check_state_end(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$6 * const raw_ptr_new_state_raw, const signed int state_context_value, struct anonymous$3 * const moves, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_empty_stack_into_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1361
extern void fc_solve_sfs_empty_stack_into_freecells(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_cards_to_a_different_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1178
extern void fc_solve_sfs_move_cards_to_a_different_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_freecell_cards_on_top_of_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 345
extern void fc_solve_sfs_move_freecell_cards_on_top_of_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_freecell_cards_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1118
extern void fc_solve_sfs_move_freecell_cards_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_freecell_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 141
extern void fc_solve_sfs_move_freecell_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_non_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 529
extern void fc_solve_sfs_move_non_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_sequences_to_free_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 921
extern void fc_solve_sfs_move_sequences_to_free_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 617
extern void fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_stack_cards_to_different_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 775
extern void fc_solve_sfs_move_stack_cards_to_different_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_move_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 66
extern void fc_solve_sfs_move_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_raymond_prune
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1953
extern signed int fc_solve_sfs_raymond_prune(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct fcs_state_keyval_pair_struct ** const ptr_next_state_val);
// fc_solve_sfs_simple_simon_move_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 61
extern void fc_solve_sfs_simple_simon_move_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 45
extern void fc_solve_sfs_simple_simon_move_sequence_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 59
extern void fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 47
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 51
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 55
extern void fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 53
extern void fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 49
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 57
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_sfs_yukon_do_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1429
extern void fc_solve_sfs_yukon_do_nothing(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list);
// fc_solve_soft_dfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1210
extern signed int fc_solve_soft_dfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_soft_dfs_do_solve::1::debug_iter_output_func$object
// 
void debug_iter_output_func$object(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int);
// fc_solve_soft_thread_init_befs_or_bfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1212
extern void fc_solve_soft_thread_init_befs_or_bfs(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_soft_thread_init_befs_or_bfs::1::3::tests_list$object$object
// 
void tests_list$object$object(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_soft_thread_init_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1098
static inline void fc_solve_soft_thread_init_soft_dfs(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_soft_thread_init_soft_dfs::$tmp::tmp_post$4$object$object
// 
void tmp_post$4$object$object(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_soft_thread_init_soft_dfs::1::1::next_test$object$object
// 
void next_test$object$object(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_soft_thread_init_soft_dfs::1::1::tests_list$object$object
// 
void tests_list$object$object(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_soft_thread_update_initial_cards_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_soft_thread_update_initial_cards_val$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val$link1(struct fc_solve_soft_thread_struct *soft_thread$link1);
// fc_solve_stack_compare_for_comparison
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison(const void * const v_s1, const void * const v_s2);
// fc_solve_stack_compare_for_comparison$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison$link1(const void * const v_s1$link1, const void * const v_s2$link1);
// fc_solve_start_instance_process_with_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 808
extern void fc_solve_start_instance_process_with_board(struct fc_solve_instance_struct * const instance, struct fcs_state_keyval_pair_struct * const init_state);
// fc_solve_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1016
extern char * fc_solve_state_as_string(struct fcs_struct_state_t *state, struct anonymous$7 *state_locs, signed int freecells_num, signed int stacks_num, signed int decks_num, _Bool parseable_output, _Bool canonized_order_output, _Bool display_10_as_t);
// fc_solve_state_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 655
static inline signed int fc_solve_state_compare(const void *s1, const void *s2);
// fc_solve_state_compare_with_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.c line 216
extern signed int fc_solve_state_compare_with_context(const void *s1, const void *s2, void *context);
// fc_solve_state_init_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 736
static inline void fc_solve_state_init_proto(struct fcs_state_keyval_pair_struct *state, signed int stacks_num, char *indirect_stacks_buffer);
// fc_solve_string_to_test_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num(const char *s);
// fc_solve_string_to_test_num$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num$link1(const char *s$link1);
// fc_solve_string_to_test_num_compare_func
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func(const void *a, const void *b);
// fc_solve_string_to_test_num_compare_func$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func$link1(const void *a$link1, const void *b$link1);
// fc_solve_trace_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 716
extern void fc_solve_trace_solution(struct fc_solve_instance_struct * const instance);
// fc_solve_u2p_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 46
extern signed int fc_solve_u2p_rank(const char *string);
// fc_solve_u2p_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 99
extern signed int fc_solve_u2p_suit(const char *suit);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcs_compact_alloc_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr(struct anonymous$5 *allocator, signed int how_much);
// fcs_compact_alloc_ptr$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr$link1(struct anonymous$5 *allocator$link1, signed int how_much$link1);
// fcs_compact_alloc_ptr$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr$link2(struct anonymous$5 *allocator$link2, signed int how_much$link2);
// fcs_compact_alloc_ptr$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr$link3(struct anonymous$5 *allocator$link3, signed int how_much$link3);
// fcs_get_preset_by_id
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 531
static inline signed int fcs_get_preset_by_id(signed int preset_id, const struct anonymous$36 **preset_ptr);
// fcs_get_preset_id_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 412
static inline signed int fcs_get_preset_id_by_name(const char *name);
// fcs_is_ss_suit_true
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 58
static inline const _Bool fcs_is_ss_suit_true(const char parent, const char child);
// fcs_is_ss_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 65
static inline const _Bool fcs_is_ss_true_parent(const char parent, const char child);
// fcs_make_card
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card(const signed int rank, const signed int suit);
// fcs_make_card$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card$link1(const signed int rank$link1, const signed int suit$link1);
// fcs_move_stack_non_seq_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push(struct anonymous$3 * const stack, const signed int type, const signed int src, const signed int dest);
// fcs_move_stack_non_seq_push$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push$link1(struct anonymous$3 * const stack$link1, const signed int type$link1, const signed int src$link1, const signed int dest$link1);
// fcs_move_stack_params_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push(struct anonymous$3 * const stack, const signed int type, const signed int src, const signed int dest, const signed int num_cards_in_seq);
// fcs_move_stack_params_push$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push$link1(struct anonymous$3 * const stack$link1, const signed int type$link1, const signed int src$link1, const signed int dest$link1, const signed int num_cards_in_seq$link1);
// fcs_move_stack_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push(struct anonymous$3 * const stack, const struct anonymous$4 move);
// fcs_move_stack_push$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push$link1(struct anonymous$3 * const stack$link1, const struct anonymous$4 move$link1);
// fcs_move_stack_push$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push$link2(struct anonymous$3 * const stack$link2, const struct anonymous$4 move$link2);
// fcs_move_stack_push$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push$link3(struct anonymous$3 * const stack$link3, const struct anonymous$4 move$link3);
// fcs_push_1card_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 89
static inline void fcs_push_1card_seq(struct anonymous$3 * const stack, const signed int src, const signed int dest);
// fcs_state_ia_alloc_into_var
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 115
static inline struct fcs_state_keyval_pair_struct * fcs_state_ia_alloc_into_var(struct anonymous$5 *allocator);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_instance_hard_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1797
static inline void free_instance_hard_thread_callback(struct fc_solve_hard_thread_struct *hard_thread);
// free_instance_soft_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 181
static inline void free_instance_soft_thread_callback(struct fc_solve_soft_thread_struct * const soft_thread);
// free_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 233
static inline void free_states(struct fc_solve_instance_struct *instance);
// free_states_handle_soft_dfs_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 146
static inline void free_states_handle_soft_dfs_soft_thread(struct fc_solve_soft_thread_struct *soft_thread);
// free_states_should_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 125
static _Bool free_states_should_delete(void *key, void *context);
// freecell_solver_set_stored_states_trimming_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 265
extern void freecell_solver_set_stored_states_trimming_limit(void *api_instance, signed long int max_num_states);
// freecell_solver_user_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 46
extern void * freecell_solver_user_alloc(void);
// freecell_solver_user_apply_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 48
extern signed int freecell_solver_user_apply_preset(void *api_instance, const char *preset_name);
// freecell_solver_user_cmd_line_parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_cl.h line 62
extern signed int freecell_solver_user_cmd_line_parse_args(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg);
// freecell_solver_user_cmd_line_parse_args::callback$object
// 
signed int callback$object(void *, signed int, const char **, signed int, signed int *, signed int *, void *);
// freecell_solver_user_cmd_line_parse_args_with_file_nesting_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 309
extern signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg, signed int file_nesting_count, const char *opened_files_dir);
// freecell_solver_user_cmd_line_parse_args_with_file_nesting_count::callback$object
// 
signed int callback$object(void *, signed int, const char **, signed int, signed int *, signed int *, void *);
// freecell_solver_user_cmd_line_read_cmd_line_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 260
extern signed int freecell_solver_user_cmd_line_read_cmd_line_preset(void *instance, const char * const preset_name, const char **known_parameters, char **error_string, signed int file_nesting_count, const char *opened_files_dir);
// freecell_solver_user_current_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1349
extern char * freecell_solver_user_current_state_as_string(void *api_instance, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t);
// freecell_solver_user_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 90
extern void freecell_solver_user_free(void *api_instance);
// freecell_solver_user_get_current_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1455
extern signed int freecell_solver_user_get_current_depth(void *api_instance);
// freecell_solver_user_get_current_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2432
const char * freecell_solver_user_get_current_soft_thread_name(void *api_instance);
// freecell_solver_user_get_invalid_state_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1741
extern char * freecell_solver_user_get_invalid_state_error_string(void *api_instance, signed int print_ts);
// freecell_solver_user_get_last_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 366
const char * freecell_solver_user_get_last_error_string(void *api_instance);
// freecell_solver_user_get_lib_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2425
const char * freecell_solver_user_get_lib_version(void *api_instance);
// freecell_solver_user_get_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1653
extern signed int freecell_solver_user_get_limit_iterations(void *api_instance);
// freecell_solver_user_get_max_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 174
extern signed int freecell_solver_user_get_max_num_decks(void);
// freecell_solver_user_get_max_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 160
extern signed int freecell_solver_user_get_max_num_freecells(void);
// freecell_solver_user_get_max_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 167
extern signed int freecell_solver_user_get_max_num_stacks(void);
// freecell_solver_user_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1660
extern signed int freecell_solver_user_get_moves_left(void *api_instance);
// freecell_solver_user_get_moves_sequence
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2477
extern signed int freecell_solver_user_get_moves_sequence(void *api_instance, struct anonymous$11 * const moves_seq);
// freecell_solver_user_get_next_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1296
extern signed int freecell_solver_user_get_next_move(void *api_instance, struct anonymous$4 *user_move);
// freecell_solver_user_get_num_soft_threads_in_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2132
extern signed int freecell_solver_user_get_num_soft_threads_in_instance(void *api_instance);
// freecell_solver_user_get_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2027
extern signed int freecell_solver_user_get_num_states_in_collection(void *api_instance);
// freecell_solver_user_get_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2020
signed long int freecell_solver_user_get_num_states_in_collection_long(void *api_instance);
// freecell_solver_user_get_num_times
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1648
extern signed int freecell_solver_user_get_num_times(void *api_instance);
// freecell_solver_user_get_num_times_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 103
extern signed long int freecell_solver_user_get_num_times_long(void *api_instance);
// freecell_solver_user_iter_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 236
extern char * freecell_solver_user_iter_state_as_string(void *api_instance, void *ptr_state_void, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t);
// freecell_solver_user_limit_current_instance_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 316
extern void freecell_solver_user_limit_current_instance_iterations(void *api_instance, signed int max_iters);
// freecell_solver_user_limit_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 150
extern void freecell_solver_user_limit_depth(void *api_instance, signed int max_depth);
// freecell_solver_user_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 308
extern void freecell_solver_user_limit_iterations(void *api_instance, signed int max_iters);
// freecell_solver_user_limit_iterations_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 53
extern void freecell_solver_user_limit_iterations_long(void *api_instance, signed long int max_iters);
// freecell_solver_user_limit_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2055
extern void freecell_solver_user_limit_num_states_in_collection(void *api_instance, signed int max_num_states);
// freecell_solver_user_limit_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 255
extern void freecell_solver_user_limit_num_states_in_collection_long(void *api_instance, signed long int max_num_states);
// freecell_solver_user_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1680
extern char * freecell_solver_user_move_to_string(struct anonymous$4 move, signed int standard_notation);
// freecell_solver_user_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1688
extern char * freecell_solver_user_move_to_string_w_state(void *api_instance, struct anonymous$4 move, signed int standard_notation);
// freecell_solver_user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 341
extern signed int freecell_solver_user_next_flare(void *api_instance);
// freecell_solver_user_next_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 279
extern signed int freecell_solver_user_next_hard_thread(void *api_instance);
// freecell_solver_user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 337
extern signed int freecell_solver_user_next_instance(void *api_instance);
// freecell_solver_user_next_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 270
extern signed int freecell_solver_user_next_soft_thread(void *api_instance);
// freecell_solver_user_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 312
extern void freecell_solver_user_recycle(void *api_instance);
// freecell_solver_user_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 349
extern signed int freecell_solver_user_reset(void *api_instance);
// freecell_solver_user_resume_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 943
extern signed int freecell_solver_user_resume_solution(void *api_instance);
// freecell_solver_user_set_a_star_weight
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 197
extern signed int freecell_solver_user_set_a_star_weight(void *api_instance, signed int my_index, double weight);
// freecell_solver_user_set_cache_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 386
extern signed int freecell_solver_user_set_cache_limit(void *api_instance, signed long int limit);
// freecell_solver_user_set_calc_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 287
extern void freecell_solver_user_set_calc_real_depth(void *api_instance, signed int calc_real_depth);
// freecell_solver_user_set_depth_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 373
extern signed int freecell_solver_user_set_depth_tests_order(void *api_instance, signed int min_depth, const char *tests_order, char **error_string);
// freecell_solver_user_set_empty_stacks_filled_by
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 187
extern signed int freecell_solver_user_set_empty_stacks_filled_by(void *api_instance, signed int empty_stacks_fill);
// freecell_solver_user_set_flare_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 297
extern void freecell_solver_user_set_flare_name(void *api_instance, const char *name);
// freecell_solver_user_set_flares_choice
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 396
extern signed int freecell_solver_user_set_flares_choice(void *api_instance, const char * const new_flares_choice_string);
// freecell_solver_user_set_flares_iters_factor
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 401
extern void freecell_solver_user_set_flares_iters_factor(void *api_instance, double new_factor);
// freecell_solver_user_set_flares_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 307
extern signed int freecell_solver_user_set_flares_plan(void *api_instance, const char *flares_plan_string);
// freecell_solver_user_set_game
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1601
extern signed int freecell_solver_user_set_game(void *api_instance, signed int freecells_num, signed int stacks_num, signed int decks_num, signed int sequences_are_built_by, signed int unlimited_sequence_move, signed int empty_stacks_fill);
// freecell_solver_user_set_hard_thread_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 302
extern signed int freecell_solver_user_set_hard_thread_prelude(void *api_instance, const char *prelude);
// freecell_solver_user_set_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1965
extern void freecell_solver_user_set_iter_handler(void *api_instance, void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context);
// freecell_solver_user_set_iter_handler::iter_handler$object
// 
void iter_handler$object(void *, signed int, signed int, void *, signed int, void *);
// freecell_solver_user_set_iter_handler_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 229
extern void freecell_solver_user_set_iter_handler_long(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void *iter_handler_context);
// freecell_solver_user_set_iter_handler_long::long_iter_handler$object
// 
void long_iter_handler$object(void *, signed long int, signed int, void *, signed long int, void *);
// freecell_solver_user_set_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 169
extern signed int freecell_solver_user_set_num_decks(void *api_instance, signed int decks_num);
// freecell_solver_user_set_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 155
extern signed int freecell_solver_user_set_num_freecells(void *api_instance, signed int freecells_num);
// freecell_solver_user_set_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 162
extern signed int freecell_solver_user_set_num_stacks(void *api_instance, signed int stacks_num);
// freecell_solver_user_set_optimization_scan_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 316
extern signed int freecell_solver_user_set_optimization_scan_tests_order(void *api_instance, const char *tests_order, char **error_string);
// freecell_solver_user_set_pruning
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 380
extern signed int freecell_solver_user_set_pruning(void *api_instance, const char *pruning, char **error_string);
// freecell_solver_user_set_random_seed
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 244
extern void freecell_solver_user_set_random_seed(void *api_instance, signed int seed);
// freecell_solver_user_set_reparent_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 322
extern void freecell_solver_user_set_reparent_states(void *api_instance, signed int to_reparent_states);
// freecell_solver_user_set_scans_synergy
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 327
extern void freecell_solver_user_set_scans_synergy(void *api_instance, signed int synergy);
// freecell_solver_user_set_sequence_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 192
extern signed int freecell_solver_user_set_sequence_move(void *api_instance, signed int unlimited_sequence_move);
// freecell_solver_user_set_sequences_are_built_by_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 182
extern signed int freecell_solver_user_set_sequences_are_built_by_type(void *api_instance, signed int sequences_are_built_by);
// freecell_solver_user_set_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 292
extern void freecell_solver_user_set_soft_thread_name(void *api_instance, const char *name);
// freecell_solver_user_set_soft_thread_step
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 274
extern void freecell_solver_user_set_soft_thread_step(void *api_instance, signed int num_checked_states_step);
// freecell_solver_user_set_solution_optimization
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 134
extern void freecell_solver_user_set_solution_optimization(void *api_instance, signed int optimize);
// freecell_solver_user_set_solving_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 98
extern void freecell_solver_user_set_solving_method(void *api_instance, signed int method);
// freecell_solver_user_set_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 63
extern signed int freecell_solver_user_set_tests_order(void *api_instance, const char *tests_order, char **error_string);
// freecell_solver_user_solve_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 69
extern signed int freecell_solver_user_solve_board(void *api_instance, const char *state_as_string);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// generic_false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 501
static inline const _Bool generic_false_seq_index_loop(const signed int stacks_num, struct anonymous$6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous$45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag, const _Bool should_src_col, const char src_card, const signed int num_src_junk_true_seqs);
// generic_populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 460
static inline void generic_populate_seq_points(char * const dest_col, const signed int dc, struct anonymous$45 * const seqs, const signed int dest_cards_num);
// get_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 186
static inline void get_board(signed long int gamenumber, char *ret);
// get_board_l
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 123
static inline void get_board_l(const signed long long int gamenumber, char * const ret);
// get_current_instance_item
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 927
static inline struct anonymous$1 * get_current_instance_item(const struct anonymous *user);
// get_flare_move_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 898
static signed int get_flare_move_count(struct anonymous * const user, struct anonymous$2 * const flare);
// get_seq_h
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 370
static inline signed int get_seq_h(char * const col, signed int *num_true_seqs_out_ptr);
// get_the_positions_by_rank_data__ss_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 143
static char * get_the_positions_by_rank_data__ss_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const the_state);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// init_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 297
static inline void init_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread, struct fc_solve_soft_thread_struct * const soft_thread);
// init_stacks_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 189
static inline void init_stacks_map(_Bool * const stacks_map, const signed int stack_idx, const signed int ds);
// init_stats
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 775
static inline void init_stats(struct anonymous$44 * const s);
// is_whitespace
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 110
static inline _Bool is_whitespace(char c);
// iter_handler_wrapper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1882
static void iter_handler_wrapper(void *api_instance, signed long int iter_num, signed int depth, void *lp_instance, struct anonymous$6 *ptr_state, signed long int parent_iter_num);
// kv_calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 84
static inline signed int kv_calc_depth(struct anonymous$6 *ptr_state);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mark_as_dead_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 589
static inline void mark_as_dead_end(const _Bool scans_synergy, struct fcs_state_keyval_pair_struct * const ptr_state_input);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup(void *src, unsigned long int mysize);
// memdup$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup$link1(void *src$link1, unsigned long int mysize$link1);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// meta_request_new_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.c line 57
static inline char * meta_request_new_buffer(struct anonymous$10 *meta_allocator);
// microsoft_rand__game_num_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 59
static inline unsigned int microsoft_rand__game_num_rand(signed long long int *seedx_ptr, signed long long int gnGameNumber);
// microsoft_rand_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 47
static inline unsigned int microsoft_rand_rand(signed long long int *my_rand);
// microsoft_rand_randp
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 53
static inline unsigned int microsoft_rand_randp(signed long long int *my_rand);
// moves_processed_add_new_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 113
static inline void moves_processed_add_new_move(struct anonymous$40 * const moves, const struct anonymous$53 new_move);
// my_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 62
static void my_iter_handler(void *user_instance, signed long int iter_num, signed int depth, void *ptr_state, signed long int parent_iter_num, void *lp_context);
// normalize_iters_quota
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 936
static inline signed int normalize_iters_quota(signed int i);
// nullify_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 50
static inline void nullify_newline(char * const line);
// on_state_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 291
static inline void on_state_new(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread, struct fcs_state_extra_info_struct * const new_state_info);
// perl_hash_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 53
static inline unsigned long int perl_hash_function(const unsigned char *s_ptr, const unsigned long int length);
// populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 491
static inline void populate_seq_points(char * const dest_col, const signed int dc, struct anonymous$45 * const seqs);
// print_help
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 169
static void print_help(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$23 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$23 *);
// push_args_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 82
static inline void push_args_last_arg(struct anonymous$37 *manager);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// read_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 60
static inline signed int read_preset(const char *preset_name, struct anonymous$37 **args_man, char **opened_files_dir_to_assign, const char *user_preset_dir);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 782
static void recycle_instance(struct anonymous * const user, const signed int i);
// run_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1217
static inline signed int run_hard_thread(struct fc_solve_hard_thread_struct *hard_thread);
// set_any_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1931
static void set_any_iter_handler(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context);
// set_any_iter_handler::iter_handler$object
// 
void iter_handler$object(void *, signed int, signed int, void *, signed int, void *);
// set_any_iter_handler::long_iter_handler$object
// 
void long_iter_handler$object(void *, signed long int, signed int, void *, signed long int, void *);
// set_debug_iter_output_func_to_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1920
static void set_debug_iter_output_func_to_val(struct anonymous * const user, void (* const value)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int));
// set_debug_iter_output_func_to_val::value$object
// 
void value$object(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int);
// soft_thread_clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 119
static inline void soft_thread_clean_soft_dfs(struct fc_solve_soft_thread_struct * const soft_thread);
// sort_derived_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 116
static inline void sort_derived_states(struct anonymous$12 *derived_states_list, signed int initial_derived_states_num_states);
// sort_ds_dcs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 1008
static inline void sort_ds_dcs(struct anonymous$46 *ds_dcs, const signed int len);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// string_starts_with
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with(const char * const str, const char * const prefix, const char * const end);
// string_starts_with$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with$link1(const char * const str$link1, const char * const prefix$link1, const char * const end$link1);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strndup
// file /usr/include/string.h line 183
extern char * strndup(const char *, unsigned long int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// tests_order_dup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous$9 tests_order_dup(struct anonymous$9 *orig);
// tests_order_dup$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous$9 tests_order_dup$link1(struct anonymous$9 *orig$link1);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// update_col_cards_under_sequences
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences(const signed int sequences_are_built_by, const char * const col, signed int d);
// update_col_cards_under_sequences$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences$link1(const signed int sequences_are_built_by$link1, const char * const col$link1, signed int d$link1);
// user_compile_all_flares_plans
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 495
static signed int user_compile_all_flares_plans(struct anonymous * const user, signed int * const instance_list_index, char ** const error_string);
// user_free_resources
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1377
static void user_free_resources(struct anonymous * const user);
// user_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 212
static void user_initialize(struct anonymous * const user);
// user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2335
static signed int user_next_flare(struct anonymous *user);
// user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2379
static signed int user_next_instance(struct anonymous * const user);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// worker_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 209
static void * worker_thread(void *void_context);

struct anonymous$15
{
  // should_go_over_stacks
  _Bool should_go_over_stacks;
  // max_sequence_move_factor
  double max_sequence_move_factor;
  // cards_under_sequences_factor
  double cards_under_sequences_factor;
  // seqs_over_renegade_cards_factor
  double seqs_over_renegade_cards_factor;
  // depth_factor
  double depth_factor;
  // num_cards_not_on_parents_factor
  double num_cards_not_on_parents_factor;
  // num_cards_out_lookup_table
  double num_cards_out_lookup_table[14l];
  // befs_weights
  double befs_weights[6l];
};

struct anonymous$17
{
  // tests
  void (**tests)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
  // num_tests
  signed int num_tests;
  // shuffling_type
  signed int shuffling_type;
  // weighting
  struct anonymous$15 weighting;
};

struct anonymous$31
{
  // bfs_queue
  struct fcs_states_linked_list_item_struct *bfs_queue;
  // bfs_queue_last_item
  struct fcs_states_linked_list_item_struct *bfs_queue_last_item;
  // recycle_bin
  struct fcs_states_linked_list_item_struct *recycle_bin;
};

struct anonymous$32
{
  // max_size
  signed int max_size;
  // CurrentSize
  signed int CurrentSize;
  // Elements
  struct anonymous$19 *Elements;
};

struct anonymous$33
{
  // pqueue
  struct anonymous$32 pqueue;
  // weighting
  struct anonymous$15 weighting;
};

struct anonymous$34
{
  // brfs
  struct anonymous$31 brfs;
  // befs
  struct anonymous$33 befs;
};

struct anonymous$35
{
  // befs_positions_by_rank
  char *befs_positions_by_rank;
  // tests_list
  void (**tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
  // tests_list_end
  void (**tests_list_end)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
  // meth
  struct anonymous$34 meth;
};

struct anonymous$51
{
  // buffer
  char *buffer;
  // end_of_buffer
  char *end_of_buffer;
  // max_size
  signed int max_size;
};

struct anonymous$5
{
  // old_list
  char *old_list;
  // max_ptr
  char *max_ptr;
  // ptr
  char *ptr;
  // rollback_ptr
  char *rollback_ptr;
  // meta
  struct anonymous$10 *meta;
};

struct anonymous$10
{
  // recycle_bin
  char *recycle_bin;
};

struct anonymous$41
{
  // entries
  struct anonymous$54 *entries;
  // list_of_vacant_items
  struct fc_solve_hash_symlink_item_struct *list_of_vacant_items;
  // hash_type
  enum FCS_INLINED_HASH_DATA_TYPE hash_type;
  // size
  signed int size;
  // size_bitmask
  signed int size_bitmask;
  // num_elems
  signed long int num_elems;
  // max_num_elems_before_resize
  signed long int max_num_elems_before_resize;
  // allocator
  struct anonymous$5 allocator;
};

struct anonymous$3
{
  // moves
  struct anonymous$4 *moves;
  // num_moves
  unsigned short int num_moves;
};

struct anonymous$44
{
  // num_checked_states
  signed long int num_checked_states;
  // num_states_in_collection
  signed long int num_states_in_collection;
};

struct fcs_struct_state_t
{
  // stacks
  char *stacks[10l];
  // freecells
  char freecells[8l];
  // foundations
  char foundations[8l];
};

struct fcs_state_extra_info_struct
{
  // parent
  struct fcs_state_keyval_pair_struct *parent;
  // moves_to_parent
  struct anonymous$3 *moves_to_parent;
  // depth
  signed int depth;
  // visited_iter
  signed long int visited_iter;
  // num_active_children
  unsigned short int num_active_children;
  // visited
  unsigned char visited;
  // scan_visited
  unsigned char scan_visited[4l];
  // stacks_copy_on_write_flags
  signed int stacks_copy_on_write_flags;
};

struct anonymous$55
{
  // s
  struct fcs_struct_state_t s;
  // info
  struct fcs_state_extra_info_struct info;
};

union anonymous$43
{
  // $anon0
  struct anonymous$55 $anon0;
  // next
  struct fcs_state_keyval_pair_struct *next;
};

struct fcs_state_keyval_pair_struct
{
  // $anon0
  union anonymous$43 $anon0;
};

struct anonymous$7
{
  // stack_locs
  char stack_locs[10l];
  // fc_locs
  char fc_locs[8l];
};

struct anonymous$14
{
  // freecells_num
  unsigned char freecells_num;
  // stacks_num
  unsigned char stacks_num;
  // decks_num
  unsigned char decks_num;
  // game_flags
  unsigned char game_flags;
};

struct anonymous$36
{
  // preset_id
  signed int preset_id;
  // game_params
  struct anonymous$14 game_params;
  // tests_order
  char tests_order[73l];
  // allowed_tests
  char allowed_tests[73l];
};

struct anonymous
{
  // instances_list
  struct anonymous$1 *instances_list;
  // num_instances
  signed int num_instances;
  // current_instance_idx
  signed int current_instance_idx;
  // current_iterations_limit
  signed long int current_iterations_limit;
  // iterations_board_started_at
  struct anonymous$44 iterations_board_started_at;
  // init_num_checked_states
  struct anonymous$44 init_num_checked_states;
  // active_flare
  struct anonymous$2 *active_flare;
  // state
  struct fcs_state_keyval_pair_struct state;
  // running_state
  struct fcs_state_keyval_pair_struct running_state;
  // initial_non_canonized_state
  struct fcs_state_keyval_pair_struct initial_non_canonized_state;
  // state_locs
  struct anonymous$7 state_locs;
  // trace_solution_state_locs
  struct anonymous$7 trace_solution_state_locs;
  // initial_state_locs
  struct anonymous$7 initial_state_locs;
  // ret_code
  signed int ret_code;
  // all_instances_were_suspended
  _Bool all_instances_were_suspended;
  // state_validity_ret
  signed int state_validity_ret;
  // state_validity_card
  char state_validity_card;
  // iter_handler
  void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *);
  // long_iter_handler
  void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *);
  // iter_handler_context
  void *iter_handler_context;
  // flares_choice
  enum FLARES_CHOICE_TYPE flares_choice;
  // flares_iters_factor
  double flares_iters_factor;
  // soft_thread
  struct fc_solve_soft_thread_struct *soft_thread;
  // indirect_stacks_buffer
  char indirect_stacks_buffer[1280l];
  // state_string_copy
  char *state_string_copy;
  // common_preset
  struct anonymous$36 common_preset;
  // error_string
  char *error_string;
  // meta_alloc
  struct anonymous$10 meta_alloc;
};

struct anonymous$54
{
  // first_item
  struct fc_solve_hash_symlink_item_struct *first_item;
};

struct anonymous$11
{
  // num_moves
  signed int num_moves;
  // moves
  struct anonymous$4 *moves;
};

struct anonymous$40
{
  // next_move_idx
  signed int next_move_idx;
  // num_moves
  signed int num_moves;
  // moves
  struct anonymous$53 *moves;
};

struct anonymous$2
{
  // obj
  struct fc_solve_instance_struct *obj;
  // ret_code
  signed int ret_code;
  // instance_is_ready
  _Bool instance_is_ready;
  // limit
  signed int limit;
  // name
  char *name;
  // next_move
  signed int next_move;
  // moves_seq
  struct anonymous$11 moves_seq;
  // fc_pro_moves
  struct anonymous$40 fc_pro_moves;
  // obj_stats
  struct anonymous$44 obj_stats;
};

struct anonymous$12
{
  // num_states
  signed int num_states;
  // states
  struct anonymous$38 *states;
};

struct anonymous$50
{
  // state
  struct fcs_state_keyval_pair_struct *state;
  // derived_states_list
  struct anonymous$12 derived_states_list;
  // current_state_index
  signed int current_state_index;
  // tests_list_index
  signed int tests_list_index;
  // test_index
  signed int test_index;
  // derived_states_random_indexes_max_size
  signed int derived_states_random_indexes_max_size;
  // derived_states_random_indexes
  struct anonymous$29 *derived_states_random_indexes;
  // positions_by_rank
  char *positions_by_rank;
  // num_vacant_stacks
  unsigned char num_vacant_stacks;
  // num_vacant_freecells
  unsigned char num_vacant_freecells;
};

union anonymous$8
{
  // ptr
  void *ptr;
  // i
  signed int i;
  // c
  char c[(signed long int)sizeof(void *) /*8l*/ ];
};

struct anonymous$38
{
  // state_ptr
  struct fcs_state_keyval_pair_struct *state_ptr;
  // context
  union anonymous$8 context;
};

struct anonymous$19
{
  // val
  struct fcs_state_keyval_pair_struct *val;
  // rating
  signed int rating;
};

struct anonymous$6
{
  // key
  struct fcs_struct_state_t *key;
  // val
  struct fcs_state_extra_info_struct *val;
};

struct anonymous$13
{
  // key
  struct fcs_struct_state_t *key;
  // val
  struct fcs_state_extra_info_struct *val;
  // s
  struct fcs_state_keyval_pair_struct *s;
  // locs
  struct anonymous$7 locs;
};

struct anonymous$47
{
  // alias
  const char *alias;
  // test_num
  signed int test_num;
};

struct anonymous$48
{
  // name
  const char name[32l];
  // preset_id
  signed int preset_id;
};

struct anonymous$4
{
  // c
  unsigned char c[4l];
};

struct anonymous$24
{
  // debug_iter_state_output
  _Bool debug_iter_state_output;
  // parseable_output
  _Bool parseable_output;
  // canonized_order_output
  _Bool canonized_order_output;
  // display_10_as_t
  _Bool display_10_as_t;
  // display_parent_iter_num
  _Bool display_parent_iter_num;
};

struct anonymous$37
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // last_arg
  char *last_arg;
  // last_arg_ptr
  char *last_arg_ptr;
  // last_arg_end
  char *last_arg_end;
};

struct anonymous$22
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // arg
  signed int arg;
  // stop_at
  signed int stop_at;
  // end_board
  signed int end_board;
  // board_num_step
  signed int board_num_step;
  // update_total_num_iters_threshold
  signed int update_total_num_iters_threshold;
  // total_iterations_limit_per_board
  signed long int total_iterations_limit_per_board;
};

struct anonymous$18
{
  // num_units
  signed int num_units;
  // by_depth_units
  struct anonymous$52 *by_depth_units;
};

struct anonymous$49
{
  // dfs_max_depth
  signed int dfs_max_depth;
  // soft_dfs_info
  struct anonymous$50 *soft_dfs_info;
  // depth
  signed int depth;
  // rand_gen
  signed long int rand_gen;
  // rand_seed
  signed int rand_seed;
  // tests_by_depth_array
  struct anonymous$18 tests_by_depth_array;
};

struct anonymous$46
{
  // ds
  signed int ds;
  // dc
  signed int dc;
};

struct anonymous$29
{
  // idx
  signed int idx;
  // rating
  signed int rating;
};

struct anonymous$9
{
  // num_groups
  signed int num_groups;
  // groups
  struct anonymous$20 *groups;
};

struct anonymous$21
{
  // max_depth
  signed int max_depth;
  // tests_order
  struct anonymous$9 tests_order;
};

struct anonymous$16
{
  // num_lists
  signed int num_lists;
  // lists
  struct anonymous$17 *lists;
};

struct anonymous$52
{
  // max_depth
  signed int max_depth;
  // tests
  struct anonymous$16 tests;
};

struct anonymous$20
{
  // num
  signed int num;
  // tests
  signed int *tests;
  // shuffling_type
  enum anonymous$26 shuffling_type;
  // weighting
  struct anonymous$15 weighting;
};

struct anonymous$28
{
  // num
  signed int num;
  // by_depth_tests
  struct anonymous$21 *by_depth_tests;
};

struct anonymous$1
{
  // num_flares
  signed int num_flares;
  // flares
  struct anonymous$2 *flares;
  // plan
  struct anonymous$0 *plan;
  // num_plan_items
  signed int num_plan_items;
  // current_plan_item_idx
  signed int current_plan_item_idx;
  // minimal_solution_flare_idx
  signed int minimal_solution_flare_idx;
  // all_plan_items_finished_so_far
  signed int all_plan_items_finished_so_far;
  // flares_plan_string
  char *flares_plan_string;
  // flares_plan_compiled
  _Bool flares_plan_compiled;
  // limit
  signed int limit;
};

struct anonymous$45
{
  // num_separate_false_seqs
  signed int num_separate_false_seqs;
  // seq_points
  signed int seq_points[20l];
  // junk_move_to_stacks
  signed int junk_move_to_stacks[10l];
  // after_junk_num_freestacks
  signed int after_junk_num_freestacks;
  // above_num_true_seqs
  signed int above_num_true_seqs[20l];
};

struct anonymous$42
{
  // scan_idx
  signed int scan_idx;
  // quota
  signed int quota;
};

struct anonymous$0
{
  // type
  signed int type;
  // flare_idx
  signed int flare_idx;
  // count_iters
  signed int count_iters;
};

struct anonymous$53
{
  // move
  struct anonymous$4 move;
  // to_empty_stack
  _Bool to_empty_stack;
};

struct anonymous$25
{
  // display_context
  struct anonymous$24 display_context;
  // instance
  void *instance;
};

struct anonymous$39
{
  // soft_dfs
  struct anonymous$49 soft_dfs;
  // befs
  struct anonymous$35 befs;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct anonymous$30
{
  // tv
  struct timeval tv;
  // tz
  struct timezone tz;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$23
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct fc_solve_hard_thread_struct
{
  // instance
  struct fc_solve_instance_struct *instance;
  // soft_threads
  struct fc_solve_soft_thread_struct *soft_threads;
  // num_checked_states
  signed long int num_checked_states;
  // max_num_checked_states
  signed long int max_num_checked_states;
  // num_checked_states_step
  signed long int num_checked_states_step;
  // num_checked_states_left_for_soft_thread
  signed long int num_checked_states_left_for_soft_thread;
  // st_idx
  signed int st_idx;
  // allocator
  struct anonymous$5 allocator;
  // reusable_move_stack
  struct anonymous$3 reusable_move_stack;
  // indirect_stacks_buffer
  char indirect_stacks_buffer[1280l];
  // prelude_num_items
  signed long int prelude_num_items;
  // prelude_idx
  signed int prelude_idx;
  // prelude
  struct anonymous$42 *prelude;
  // allocated_from_list
  _Bool allocated_from_list;
  // num_soft_threads
  signed int num_soft_threads;
  // num_soft_threads_finished
  signed int num_soft_threads_finished;
  // prelude_as_string
  char *prelude_as_string;
};

struct fc_solve_hash_symlink_item_struct
{
  // key
  void *key;
  // hash_value
  signed int hash_value;
  // next
  struct fc_solve_hash_symlink_item_struct *next;
};

struct fc_solve_instance_struct
{
  // game_params
  struct anonymous$14 game_params;
  // num_checked_states
  signed long int num_checked_states;
  // effective_max_num_checked_states
  signed long int effective_max_num_checked_states;
  // effective_max_num_states_in_collection
  signed long int effective_max_num_states_in_collection;
  // effective_trim_states_in_collection_from
  signed long int effective_trim_states_in_collection_from;
  // hash
  struct anonymous$41 hash;
  // stacks_hash
  struct anonymous$41 stacks_hash;
  // list_of_vacant_states
  struct fcs_state_keyval_pair_struct *list_of_vacant_states;
  // runtime_flags
  unsigned char runtime_flags;
  // active_num_states_in_collection
  signed long int active_num_states_in_collection;
  // num_states_in_collection
  signed long int num_states_in_collection;
  // max_num_states_in_collection
  signed long int max_num_states_in_collection;
  // num_hard_threads
  signed int num_hard_threads;
  // hard_threads
  struct fc_solve_hard_thread_struct *hard_threads;
  // current_hard_thread
  struct fc_solve_hard_thread_struct *current_hard_thread;
  // instance_tests_order
  struct anonymous$9 instance_tests_order;
  // optimization_thread
  struct fc_solve_hard_thread_struct *optimization_thread;
  // num_hard_threads_finished
  signed int num_hard_threads_finished;
  // opt_tests_order
  struct anonymous$9 opt_tests_order;
  // max_depth
  signed int max_depth;
  // max_num_checked_states
  signed long int max_num_checked_states;
  // trim_states_in_collection_from
  signed long int trim_states_in_collection_from;
  // debug_iter_output_func
  void (*debug_iter_output_func)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int);
  // debug_iter_output_context
  void *debug_iter_output_context;
  // next_soft_thread_id
  signed int next_soft_thread_id;
  // state_copy_ptr
  struct fcs_state_keyval_pair_struct *state_copy_ptr;
  // final_state
  struct fcs_state_keyval_pair_struct *final_state;
  // solution_moves
  struct anonymous$3 solution_moves;
  // meta_alloc
  struct anonymous$10 *meta_alloc;
};

struct fc_solve_soft_thread_struct
{
  // hard_thread
  struct fc_solve_hard_thread_struct *hard_thread;
  // id
  signed int id;
  // by_depth_tests_order
  struct anonymous$28 by_depth_tests_order;
  // method
  signed int method;
  // super_method_type
  enum FCS_SUPER_METHOD_TYPE super_method_type;
  // initial_cards_under_sequences_value
  double initial_cards_under_sequences_value;
  // method_specific
  struct anonymous$39 method_specific;
  // first_state_to_check
  struct fcs_state_keyval_pair_struct *first_state_to_check;
  // runtime_flags
  unsigned char runtime_flags;
  // num_vacant_stacks
  unsigned char num_vacant_stacks;
  // num_vacant_freecells
  unsigned char num_vacant_freecells;
  // num_checked_states_step
  signed int num_checked_states_step;
  // name
  char *name;
  // enable_pruning
  _Bool enable_pruning;
};

struct fcs_states_linked_list_item_struct
{
  // s
  struct fcs_state_keyval_pair_struct *s;
  // next
  struct fcs_states_linked_list_item_struct *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};


// FLARES_PLAN_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 83
enum anonymous$27 FLARES_PLAN_TYPE;
// card_map_3_10
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 165
static char card_map_3_10[14l][4l] = { { ' ', 0, 0, 0 }, { 'A', 0, 0, 0 }, { '2', 0, 0, 0 }, { '3', 0, 0, 0 }, { '4', 0, 0, 0 }, { '5', 0, 0, 0 }, { '6', 0, 0, 0 }, { '7', 0, 0, 0 }, { '8', 0, 0, 0 }, { '9', 0, 0, 0 }, { '1', '0', 0, 0 }, { 'J', 0, 0, 0 }, { 'Q', 0, 0, 0 }, { 'K', 0, 0, 0 } };
// card_map_3_T
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 167
static char card_map_3_T[14l][4l] = { { ' ', 0, 0, 0 }, { 'A', 0, 0, 0 }, { '2', 0, 0, 0 }, { '3', 0, 0, 0 }, { '4', 0, 0, 0 }, { '5', 0, 0, 0 }, { '6', 0, 0, 0 }, { '7', 0, 0, 0 }, { '8', 0, 0, 0 }, { '9', 0, 0, 0 }, { 'T', 0, 0, 0 }, { 'J', 0, 0, 0 }, { 'Q', 0, 0, 0 }, { 'K', 0, 0, 0 } };
// card_to_string_suits
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 90
static const char *card_to_string_suits = "CDHS";
// card_to_string_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 89
static const char *card_to_string_values = "A23456789TJQK";
// fc_solve_default_befs_weights
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 84
const double fc_solve_default_befs_weights[6l] = { 0.5, (const double)0, 0.3, (const double)0, 0.2, (const double)0 };
// fc_solve_empty_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 44
const struct anonymous$4 fc_solve_empty_move = { .c={ 0, 0, 0, 0 } };
// fc_solve_foundations_prefixes
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 778
static const char * const fc_solve_foundations_prefixes[7l] = { "Decks:", "Deck:", "Founds:", "Foundations:", "Foundation:", "Found:", (const char *)(void *)0 };
// fc_solve_freecells_prefixes
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 776
static const char * const fc_solve_freecells_prefixes[4l] = { "FC:", "Freecells:", "Freecell:", (const char *)(void *)0 };
// fc_solve_seqs_over_cards_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rate_state.c line 13
const double fc_solve_seqs_over_cards_lookup[105l] = { (const double)0, (const double)1, 2.46228882668983, 4.17116751094773, 6.06286626604159, 8.10328298346381, 10.2706191564582, 12.549529737647, 14.9285278645889, 17.3986384043859, 19.9526231496888, 22.5845005502473, 25.2892307921337, 28.0624999774805, 30.9005668532199, 33.8001507126398, 36.7583473599051, 39.7725647725847, 42.8404729427359, 45.9599641482642, 49.1291210446316, 52.3461907193455, 55.6095633612443, 58.9177545493537, 62.2693904150512, 65.6631951100942, 69.097980143534, 72.5726352471017, 76.0861205010657, 79.6374595075119, 83.2257334401654, 86.8500758325527, 90.5096679918781, 94.2037349461726, 97.9315418483329, 101.692390773548, 105.485617857007, 109.310590727238, 113.166706197336, 117.053388182038, 120.970085813289, 124.916271730883, 128.891440528019, 132.895107334358, 136.926806521492, 140.9860905177, 145.072528720528, 149.185706497159, 153.325224263767, 157.490696636086, 161.681751644339, 165.898030006469, 170.13918445426, 174.404879107567, 178.694788892375, 183.008598998848, 187.34600437595, 191.706709259562, 196.090426731311, 200.49687830563, 204.925793542786, 209.376909685835, 213.849971319659, 218.344730050407, 222.860944203808, 227.398378540972, 231.956803990411, 236.535997395121, 241.135741273658, 245.755823594257, 250.396037561083, 255.056181411812, 259.736058225781, 264.435475742023, 269.154246186542, 273.892186108247, 278.649116222992, 283.424861265233, 288.21924984682, 293.032114322508, 297.863290661771, 302.712618326571, 307.579940154704, 312.465102248435, 317.367953868099, 322.288347330398, 327.226137911136, 332.181183752149, 337.15334577219, 342.142487581583, 347.148475400414, 352.17117798011, 357.210466528195, 362.26621463609, 367.338298209783, 372.426595403236, 377.530986554387, 382.65135412363, 387.787582634632, 392.939558617406, 398.107170553497, 403.290308823213, 408.488865654784, 413.702735075372, 418.931812863844 };
// fc_solve_sfs_tests
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.c line 17
void (*fc_solve_sfs_tests[24l])(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
// fc_solve_sfs_tests
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.c line 17
void (*fc_solve_sfs_tests[24l])(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *) = { fc_solve_sfs_move_top_stack_cards_to_founds, 
    fc_solve_sfs_move_freecell_cards_to_founds, 
    fc_solve_sfs_move_freecell_cards_on_top_of_stacks, 
    fc_solve_sfs_move_non_top_stack_cards_to_founds, 
    fc_solve_sfs_move_stack_cards_to_different_stacks, 
    fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack, 
    fc_solve_sfs_move_sequences_to_free_stacks, 
    fc_solve_sfs_move_freecell_cards_to_empty_stack, 
    fc_solve_sfs_move_cards_to_a_different_parent, 
    fc_solve_sfs_empty_stack_into_freecells, 
    fc_solve_sfs_atomic_move_card_to_empty_stack, 
    fc_solve_sfs_atomic_move_card_to_parent, 
    fc_solve_sfs_atomic_move_card_to_freecell, 
    fc_solve_sfs_atomic_move_freecell_card_to_parent, 
    fc_solve_sfs_atomic_move_freecell_card_to_empty_stack, 
    fc_solve_sfs_simple_simon_move_sequence_to_founds, 
    fc_solve_sfs_simple_simon_move_sequence_to_true_parent, 
    fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent, 
    fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above, 
    fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent, 
    fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above, 
    fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above, 
    fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack, 
    fc_solve_sfs_simple_simon_move_sequence_to_false_parent };
// fc_solve_sfs_tests_aliases
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.c line 46
struct anonymous$47 fc_solve_sfs_tests_aliases[24l] = { { .alias="0", .test_num=0 }, { .alias="1", .test_num=1 }, { .alias="2", .test_num=2 }, { .alias="3", .test_num=3 }, { .alias="4", .test_num=4 }, { .alias="5", .test_num=5 }, { .alias="6", .test_num=6 }, { .alias="7", .test_num=7 }, { .alias="8", .test_num=8 }, { .alias="9", .test_num=9 }, { .alias="A", .test_num=10 }, { .alias="B", .test_num=11 }, { .alias="C", .test_num=12 }, { .alias="D", .test_num=13 }, { .alias="E", .test_num=14 }, { .alias="a", .test_num=15 }, { .alias="b", .test_num=16 }, { .alias="c", .test_num=17 }, { .alias="d", .test_num=18 }, { .alias="e", .test_num=19 }, { .alias="f", .test_num=20 }, { .alias="g", .test_num=21 }, { .alias="h", .test_num=22 }, { .alias="i", .test_num=23 } };
// fcs_preset_names
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 314
static const struct anonymous$48 fcs_preset_names[23l] = { { .name={ 'b', 'a', 'k', 'e', 'r', 's', '_', 'd', 'o', 'z', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=0 }, 
    { .name={ 'b', 'a', 'k', 'e', 'r', 's', '_', 'g', 'a', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=1 }, 
    { .name={ 'b', 'e', 'l', 'e', 'a', 'g', 'u', 'e', 'r', 'e', 'd', '_', 'c', 'a', 's', 't', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=16 }, 
    { .name={ 'c', 'i', 't', 'a', 'd', 'e', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=16 }, 
    { .name={ 'c', 'r', 'u', 'e', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=2 }, 
    { .name={ 'd', 'e', 'r', '_', 'k', 'a', 't', 'z', 'e', 'n', 's', 'c', 'h', 'w', 'a', 'n', 'z', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=3 }, 
    { .name={ 'd', 'e', 'r', '_', 'k', 'a', 't', 'z', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=3 }, 
    { .name={ 'd', 'i', 'e', '_', 's', 'c', 'h', 'l', 'a', 'n', 'g', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=4 }, 
    { .name={ 'e', 'i', 'g', 'h', 't', '_', 'o', 'f', 'f', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=5 }, 
    { .name={ 'f', 'a', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=6 }, 
    { .name={ 'f', 'o', 'r', 'e', 'c', 'e', 'l', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=7 }, 
    { .name={ 'f', 'r', 'e', 'e', 'c', 'e', 'l', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=8 }, 
    { .name={ 'g', 'o', 'o', 'd', '_', 'm', 'e', 'a', 's', 'u', 'r', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=9 }, 
    { .name={ 'k', 'o', '_', 'b', 'a', 'k', 'e', 'r', 's', '_', 'g', 'a', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=10 }, 
    { .name={ 'k', 'i', 'n', 'g', 's', '_', 'o', 'n', 'l', 'y', '_', 'b', 'a', 'k', 'e', 'r', 's', '_', 'g', 'a', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=10 }, 
    { .name={ 'r', 'e', 'l', 'a', 'x', 'e', 'd', '_', 'f', 'r', 'e', 'e', 'c', 'e', 'l', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=11 }, 
    { .name={ 'r', 'e', 'l', 'a', 'x', 'e', 'd', '_', 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', '_', 't', 'o', 'w', 'e', 'r', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=12 }, 
    { .name={ 'r', 'e', 'l', 'a', 'x', 'e', 'd', '_', 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=12 }, 
    { .name={ 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', '_', 't', 'o', 'w', 'e', 'r', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=13 }, 
    { .name={ 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=13 }, 
    { .name={ 's', 'i', 'm', 'p', 'l', 'e', '_', 's', 'i', 'm', 'o', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=14 }, 
    { .name={ 's', 't', 'r', 'e', 'e', 't', 's', '_', 'a', 'n', 'd', '_', 'a', 'l', 'l', 'e', 'y', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=16 }, 
    { .name={ 'y', 'u', 'k', 'o', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=15 } };
// fcs_presets
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 64
static const struct anonymous$36 fcs_presets[16l] = { { .preset_id=0, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)13, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(2 | 2 << 2 | 0 << 4) }, .tests_order={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=1, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 0 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=16, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(2 | 0 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=2, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)12, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 2 << 2 | 0 << 4) }, .tests_order={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=3, .game_params={ .freecells_num=(unsigned char)8, .stacks_num=(unsigned char)9, .decks_num=(unsigned char)2,
    .game_flags=(unsigned char)(0 | 2 << 2 | 1 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=4, .game_params={ .freecells_num=(unsigned char)8, .stacks_num=(unsigned char)9, .decks_num=(unsigned char)2,
    .game_flags=(unsigned char)(0 | 2 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=5, .game_params={ .freecells_num=(unsigned char)8, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=6, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)18, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=7, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(0 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=8, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(0 | 0 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=9, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(2 | 2 << 2 | 0 << 4) }, .tests_order={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=10, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=11, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(0 | 0 << 2 | 1 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=12, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 1 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=13, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .preset_id=14, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 0 << 2 | 0 << 4) }, .tests_order={ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// initial_mutex_constant
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 187
static const union anonymous$23 initial_mutex_constant = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// known_parameters
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 158
static const char *known_parameters[11l] = { "-i", "--iter-output", "-s", "--state-output", "-p", "--parseable-output", "-t", "--display-10-as-t", "-pi", "--display-parent-iter", (const char *)(void *)0 };
// next_board_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 191
static signed int next_board_num;
// next_board_num_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 192
static union anonymous$23 next_board_num_lock;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// total_num_iters
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 206
signed long long int total_num_iters = (signed long long int)0;
// total_num_iters_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 207
static union anonymous$23 total_num_iters_lock;

// Cvtf89
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 41
static inline signed int Cvtf89(signed int fcn)
{
  return fcn >= 7 ? fcn + 3 : fcn;
}

// FCS_STATE_keyval_pair_to_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv(struct anonymous$6 *ret, struct fcs_state_keyval_pair_struct *s)
{
  ret->key = &s->$anon0.$anon0.s;
  ret->val = &s->$anon0.$anon0.info;
}

// FCS_STATE_keyval_pair_to_kv$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv$link1(struct anonymous$6 *ret$link1, struct fcs_state_keyval_pair_struct *s$link1)
{
  ret$link1->key = &s$link1->$anon0.$anon0.s;
  ret$link1->val = &s$link1->$anon0.$anon0.info;
}

// FCS_STATE_keyval_pair_to_kv$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv$link2(struct anonymous$6 *ret$link2, struct fcs_state_keyval_pair_struct *s$link2)
{
  ret$link2->key = &s$link2->$anon0.$anon0.s;
  ret$link2->val = &s$link2->$anon0.$anon0.info;
}

// accumulate_tests_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 199
static inline void accumulate_tests_by_ptr(signed int * const tests_order, struct anonymous$9 * const st_tests_order)
{
  const struct anonymous$20 *group_ptr = st_tests_order->groups;
  const struct anonymous$20 * const groups_end = group_ptr + (signed long int)st_tests_order->num_groups;
  for( ; !(group_ptr >= groups_end); group_ptr = group_ptr + 1l)
  {
    const signed int *test_ptr = group_ptr->tests;
    const signed int * const tests_end = test_ptr + (signed long int)group_ptr->num;
    for( ; !(test_ptr >= tests_end); test_ptr = test_ptr + 1l)
      *tests_order = *tests_order | 1 << *test_ptr;
  }
}

// accumulate_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 217
static inline void accumulate_tests_order(struct fc_solve_soft_thread_struct * const soft_thread, void * const context)
{
  accumulate_tests_by_ptr((signed int *)context, &(soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order);
}

// add_checkpoint_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 476
static inline signed int add_checkpoint_to_plan(struct anonymous$1 *instance_item)
{
  signed int return_value_add_to_plan$1;
  return_value_add_to_plan$1=add_to_plan(instance_item, FLARES_PLAN_CHECKPOINT, -1, -1);
  return return_value_add_to_plan$1;
}

// add_count_iters_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 464
static inline signed int add_count_iters_to_plan(struct anonymous$1 *instance_item, signed int flare_idx, signed int count_iters)
{
  signed int return_value_add_to_plan$1;
  return_value_add_to_plan$1=add_to_plan(instance_item, FLARES_PLAN_RUN_COUNT_ITERS, flare_idx, count_iters);
  return return_value_add_to_plan$1;
}

// add_run_indef_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 485
static inline signed int add_run_indef_to_plan(struct anonymous$1 *instance_item, signed int flare_idx)
{
  signed int return_value_add_to_plan$1;
  return_value_add_to_plan$1=add_to_plan(instance_item, FLARES_PLAN_RUN_INDEFINITELY, flare_idx, -1);
  return return_value_add_to_plan$1;
}

// add_to_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 65
static inline void add_to_last_arg(struct anonymous$37 *manager, char c)
{
  char *tmp_post$1 = manager->last_arg_ptr;
  manager->last_arg_ptr = manager->last_arg_ptr + 1l;
  *tmp_post$1 = c;
  if(manager->last_arg_ptr == manager->last_arg_end)
  {
    char *new_last_arg;
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)manager->last_arg, sizeof(char) /*1ul*/  * (unsigned long int)((manager->last_arg_end - manager->last_arg) + (signed long int)1024));
    new_last_arg = (char *)return_value_realloc$2;
    manager->last_arg_ptr = manager->last_arg_ptr + (new_last_arg - manager->last_arg);
    manager->last_arg_end = manager->last_arg_end + (new_last_arg - manager->last_arg) + (signed long int)1024;
    manager->last_arg = new_last_arg;
  }

}

// add_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 443
static inline signed int add_to_plan(struct anonymous$1 *instance_item, signed int mytype, signed int flare_idx, signed int count_iters)
{
  signed int next_item = instance_item->num_plan_items;
  instance_item->num_plan_items = instance_item->num_plan_items + 1;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)instance_item->plan, sizeof(struct anonymous$0) /*12ul*/  * (unsigned long int)instance_item->num_plan_items);
  instance_item->plan = (struct anonymous$0 *)return_value_realloc$1;
  (instance_item->plan + (signed long int)next_item)->type = mytype;
  (instance_item->plan + (signed long int)next_item)->flare_idx = flare_idx;
  (instance_item->plan + (signed long int)next_item)->count_iters = count_iters;
  return mytype;
}

// apply_game_params_for_all_instances
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1494
static void apply_game_params_for_all_instances(struct anonymous * const user)
{
  signed int user_inst_idx = 0;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous$1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
    signed int flare_idx = 0;
    for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
    {
      struct anonymous$2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      flare->obj->game_params = user->common_preset.game_params;
    }
  }
}

// assign_dest_stack_and_col_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2059
static inline void assign_dest_stack_and_col_ptr(char * const positions_by_rank, signed int dest_stack, signed int dest_col, char dest_card)
{
  char *ptr = &positions_by_rank[(signed long int)((2 << 3) * (((signed int)dest_card >> 2) - 1) + (((signed int)dest_card & 0x03) << 1))];
  for( ; !((signed int)*ptr == -1); ptr = ptr + (signed long int)(4 << 1))
    ;
  char *tmp_post$1 = ptr;
  ptr = ptr + 1l;
  *tmp_post$1 = (char)dest_stack;
  *ptr = (char)dest_col;
}

// befs_rate_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 328
static inline signed int befs_rate_state(const struct fc_solve_soft_thread_struct * const soft_thread, const struct anonymous$15 * const weighting, const struct fcs_struct_state_t * const state, const signed int neg_depth)
{
  const struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  const _Bool int_unlimited_sequence_move = (const _Bool)((signed int)instance->game_params.game_flags & 1 << 4);
  double cards_under_sequences = (double)0;
  double seqs_over_renegade_cards = (double)0;
  double sum = (double)(0 > neg_depth ? 0 : neg_depth) * weighting->depth_factor;
  if(IEEE_FLOAT_NOTEQUAL(weighting->num_cards_out_lookup_table[1l], 0.000000))
  {
    const signed int num_founds = (signed int)game_params.decks_num << 2;
    signed int found_idx = 0;
    for( ; !(found_idx >= num_founds); found_idx = found_idx + 1)
      sum = sum + weighting->num_cards_out_lookup_table[(signed long int)(signed int)state->foundations[(signed long int)found_idx]];
  }

  unsigned char num_vacant_stacks = (unsigned char)0;
  unsigned char num_vacant_freecells = (unsigned char)0;
  double tmp_if_expr$1;
  if(!(weighting->should_go_over_stacks == (_Bool)0))
  {
    signed int a = 0;
    for( ; !(a >= (signed int)game_params.stacks_num); a = a + 1)
    {
      const char * const befs_rate_state$$1$$2$$1$$1$$col = state->stacks[(signed long int)a];
      const signed int cards_num = (const signed int)befs_rate_state$$1$$2$$1$$1$$col[(signed long int)0];
      if(!(cards_num >= 2))
      {
        if(cards_num == 0)
          num_vacant_stacks = num_vacant_stacks + 1;

      }

      else
      {
        signed int c;
        c=update_col_cards_under_sequences$link1(sequences_are_built_by, befs_rate_state$$1$$2$$1$$1$$col, cards_num - 1);
        cards_under_sequences = cards_under_sequences + fc_solve_seqs_over_cards_lookup[(signed long int)c];
        if(c >= 1)
        {
          if(!(int_unlimited_sequence_move == (_Bool)0))
            tmp_if_expr$1 = (double)1;

          else
            tmp_if_expr$1 = fc_solve_seqs_over_cards_lookup[(signed long int)(cards_num - c)];
          seqs_over_renegade_cards = seqs_over_renegade_cards + tmp_if_expr$1;
        }

      }
    }
    signed int freecell_idx = 0;
    for( ; !(freecell_idx >= (signed int)game_params.freecells_num); freecell_idx = freecell_idx + 1)
      if((signed int)state->freecells[(signed long int)freecell_idx] >> 2 == 0)
        num_vacant_freecells = num_vacant_freecells + 1;

    sum = sum + (double)(((signed int)instance->game_params.game_flags >> 2 & 0x3) == 0 ? (int_unlimited_sequence_move != (_Bool)0 ? (signed int)num_vacant_freecells + (signed int)num_vacant_stacks : (signed int)num_vacant_freecells + 1 << (signed int)num_vacant_stacks) : (int_unlimited_sequence_move != (_Bool)0 ? (signed int)num_vacant_freecells : 0)) * weighting->max_sequence_move_factor + (soft_thread->initial_cards_under_sequences_value - cards_under_sequences) * weighting->cards_under_sequences_factor + seqs_over_renegade_cards * weighting->seqs_over_renegade_cards_factor;
  }

  double num_cards_not_on_parents_weight = weighting->num_cards_not_on_parents_factor;
  if(IEEE_FLOAT_NOTEQUAL(num_cards_not_on_parents_weight, 0.000000))
  {
    signed int num_cards_not_on_parents = (signed int)game_params.decks_num * 52;
    signed int stack_idx = 0;
    for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
    {
      const char * const col = state->stacks[(signed long int)stack_idx];
      const signed int col_len = (const signed int)col[(signed long int)0];
      char parent_card = col[(signed long int)(0 + 1)];
      signed int h = 1;
      for( ; !(h >= col_len); h = h + 1)
      {
        const char child_card = col[(signed long int)(h + 1)];
        if(!(((signed int)parent_card >> 2) + 1 == (signed int)child_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)parent_card) == (0x03 & (signed int)child_card) : !((1 & (signed int)parent_card) == (1 & (signed int)child_card))))
          num_cards_not_on_parents = num_cards_not_on_parents - 1;

        parent_card = child_card;
      }
    }
    sum = sum + (double)num_cards_not_on_parents * num_cards_not_on_parents_weight;
  }

  return (signed int)sum;
}

// calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 66
static inline signed int calc_depth(struct fcs_state_keyval_pair_struct *ptr_state)
{
  return ptr_state->$anon0.$anon0.info.depth;
}

// calc_foundation_to_put_card_on
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1903
static inline signed int calc_foundation_to_put_card_on(const struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const my_ptr_state, const char card)
{
  const struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  signed int deck = 0;
  for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
    if((signed int)my_ptr_state->foundations[(signed long int)((0x03 & (signed int)card) + (deck << 2))] == ((signed int)card >> 2) + -1)
    {
      signed int ret_val = (deck << 2) + ((signed int)card & 0x03);
      if(sequences_are_built_by == 1)
        return ret_val;

      signed int other_deck_idx = 0;
      for( ; !(other_deck_idx >= (signed int)instance->game_params.decks_num << 2); other_deck_idx = other_deck_idx + 1)
        if(!((signed int)my_ptr_state->foundations[(signed long int)other_deck_idx] >= ((signed int)card >> 2) + -2 + -(sequences_are_built_by == 2 ? 0 : (signed int)((0x1 & other_deck_idx) == (1 & (signed int)card)))))
          break;

      if(other_deck_idx == (signed int)instance->game_params.decks_num << 2)
        return ret_val;

    }

  return -1;
}

// calc_moves_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 869
static signed int calc_moves_seq(const struct anonymous$3 * const solution_moves, struct anonymous$11 * const moves_seq)
{
  moves_seq->num_moves = 0;
  moves_seq->moves = (struct anonymous$4 *)(void *)0;
  signed int num_moves = (signed int)solution_moves->num_moves;
  struct anonymous$4 *next_move_ptr = (solution_moves->moves + (signed long int)num_moves) - (signed long int)1;
  struct anonymous$4 *ret_moves;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)num_moves);
  ret_moves = (struct anonymous$4 *)return_value_malloc$1;
  struct anonymous$4 *tmp_post$2;
  if(ret_moves == ((struct anonymous$4 *)NULL))
    return -1;

  else
  {
    signed int i = 0;
    for( ; !(i >= num_moves); i = i + 1)
    {
      tmp_post$2 = next_move_ptr;
      next_move_ptr = next_move_ptr - 1l;
      ret_moves[(signed long int)i] = *tmp_post$2;
    }
    moves_seq->num_moves = num_moves;
    moves_seq->moves = ret_moves;
    return 0;
  }
}

// calculate_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 551
static inline void calculate_real_depth(const _Bool calc_real_depth, struct fcs_state_keyval_pair_struct * const ptr_state_orig)
{
  if(!(calc_real_depth == (_Bool)0))
  {
    signed int this_real_depth = 0;
    struct fcs_state_keyval_pair_struct *temp_state = ptr_state_orig;
    for( ; !(temp_state == ((struct fcs_state_keyval_pair_struct *)NULL)); this_real_depth = this_real_depth + 1)
      temp_state = temp_state->$anon0.$anon0.info.parent;
    this_real_depth = this_real_depth - 1;
    temp_state = ptr_state_orig;
    for( ; !(temp_state->$anon0.$anon0.info.depth == this_real_depth); temp_state = temp_state->$anon0.$anon0.info.parent)
    {
      temp_state->$anon0.$anon0.info.depth = this_real_depth;
      this_real_depth = this_real_depth - 1;
    }
  }

}

// card_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 92
static inline char * card_to_string(char *s, signed int card, signed int not_append_ws)
{
  s[(signed long int)0] = card_to_string_values[(signed long int)(card / 4)];
  s[(signed long int)1] = card_to_string_suits[(signed long int)(card % 4)];
  if(!(not_append_ws == 0))
    return &s[(signed long int)2];

  else
  {
    s[(signed long int)2] = (char)32;
    return &s[(signed long int)3];
  }
}

// clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 287
static inline void clean_soft_dfs(struct fc_solve_instance_struct * const instance)
{
  fc_solve_foreach_soft_thread(instance, 0, (void *)0);
}

// cmd_line_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 106
static signed int cmd_line_callback(void *instance, signed int argc, const char **argv, signed int arg, signed int *num_to_skip, signed int *ret, void *context)
{
  struct anonymous$24 * const dc = &((struct anonymous$25 *)context)->display_context;
  *num_to_skip = 0;
  signed int return_value_strcmp$16;
  return_value_strcmp$16=strcmp(argv[(signed long int)arg], "-i");
  _Bool tmp_if_expr$18;
  signed int return_value_strcmp$17;
  if(return_value_strcmp$16 == 0)
    tmp_if_expr$18 = (_Bool)1;

  else
  {
    return_value_strcmp$17=strcmp(argv[(signed long int)arg], "--iter-output");
    tmp_if_expr$18 = !(return_value_strcmp$17 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp$13;
  _Bool tmp_if_expr$15;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$10;
  _Bool tmp_if_expr$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$7;
  _Bool tmp_if_expr$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$1;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(tmp_if_expr$18)
    freecell_solver_user_set_iter_handler_long(instance, my_iter_handler, (void *)dc);

  else
  {
    return_value_strcmp$13=strcmp(argv[(signed long int)arg], "-s");
    if(return_value_strcmp$13 == 0)
      tmp_if_expr$15 = (_Bool)1;

    else
    {
      return_value_strcmp$14=strcmp(argv[(signed long int)arg], "--state-output");
      tmp_if_expr$15 = !(return_value_strcmp$14 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$15)
      dc->debug_iter_state_output = (_Bool)1;

    else
    {
      return_value_strcmp$10=strcmp(argv[(signed long int)arg], "-p");
      if(return_value_strcmp$10 == 0)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value_strcmp$11=strcmp(argv[(signed long int)arg], "--parseable-output");
        tmp_if_expr$12 = !(return_value_strcmp$11 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
        dc->parseable_output = (_Bool)1;

      else
      {
        return_value_strcmp$7=strcmp(argv[(signed long int)arg], "-c");
        if(return_value_strcmp$7 == 0)
          tmp_if_expr$9 = (_Bool)1;

        else
        {
          return_value_strcmp$8=strcmp(argv[(signed long int)arg], "--canonized-order-output");
          tmp_if_expr$9 = !(return_value_strcmp$8 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$9)
          dc->canonized_order_output = (_Bool)1;

        else
        {
          return_value_strcmp$4=strcmp(argv[(signed long int)arg], "-t");
          if(return_value_strcmp$4 == 0)
            tmp_if_expr$6 = (_Bool)1;

          else
          {
            return_value_strcmp$5=strcmp(argv[(signed long int)arg], "--display-10-as-t");
            tmp_if_expr$6 = !(return_value_strcmp$5 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$6)
            dc->display_10_as_t = (_Bool)1;

          else
          {
            return_value_strcmp$1=strcmp(argv[(signed long int)arg], "-pi");
            if(return_value_strcmp$1 == 0)
              tmp_if_expr$3 = (_Bool)1;

            else
            {
              return_value_strcmp$2=strcmp(argv[(signed long int)arg], "--display-parent-iter");
              tmp_if_expr$3 = !(return_value_strcmp$2 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$3)
              dc->display_parent_iter_num = (_Bool)1;

            else
            {
              fprintf(stderr, "Unknown option %s!\n", argv[(signed long int)arg]);
              exit(-1);
              return 0;
            }
          }
        }
      }
    }
  }
  *num_to_skip = 1;
  return 1;
}

// compare_rating_with_index
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 962
static signed int compare_rating_with_index(const void *void_a, const void *void_b)
{
  const struct anonymous$29 * const a = (const struct anonymous$29 *)void_a;
  const struct anonymous$29 * const b = (const struct anonymous$29 *)void_b;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(!(a->rating >= b->rating))
    tmp_if_expr$2 = -1;

  else
  {
    if(!(b->rating >= a->rating))
      tmp_if_expr$1 = 1;

    else
      tmp_if_expr$1 = a->idx - b->idx;
    tmp_if_expr$2 = tmp_if_expr$1;
  }
  return tmp_if_expr$2;
}

// compile_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 491
static inline signed int compile_prelude(struct fc_solve_hard_thread_struct * const hard_thread)
{
  _Bool last_one = (_Bool)0;
  signed int num_items = 0;
  struct anonymous$42 *prelude = (struct anonymous$42 *)(void *)0;
  const char *p = hard_thread->prelude_as_string;
  const unsigned short int **return_value___ctype_b_loc$1;
  signed int return_value_strcmp$2;
  while(last_one == (_Bool)0)
  {
    signed int p_quota;
    p_quota=atoi(p);
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*p]) == 0)
        break;

    }
    if(!((signed int)*p == 64))
    {
      free((void *)prelude);
      return 1;
    }

    p = p + 1l;
    const char * const p_scan = p;
    for( ; !(*p == 0); p = p + 1l)
      if((signed int)*p == 44)
        break;

    if((signed int)*p == 0)
      last_one = (_Bool)1;

    char *p_scan_copy;
    p_scan_copy=strndup(p_scan, (unsigned long int)(p - p_scan));
    p = p + 1l;
    struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
    struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
    for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
      if(!(soft_thread->name == ((char *)NULL)))
      {
        return_value_strcmp$2=strcmp(soft_thread->name, p_scan_copy);
        if(return_value_strcmp$2 == 0)
          break;

      }

    free((void *)p_scan_copy);
    if(soft_thread == end_soft_thread)
    {
      free((void *)prelude);
      return 2;
    }

    if((16 & num_items) == 0)
    {
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)prelude, sizeof(struct anonymous$42) /*8ul*/  * (unsigned long int)(num_items + 16));
      prelude = (struct anonymous$42 *)return_value_realloc$3;
    }

    (prelude + (signed long int)num_items)->scan_idx = (signed int)(soft_thread - hard_thread->soft_threads);
    (prelude + (signed long int)num_items)->quota = p_quota;
    num_items = num_items + 1;
  }
  void *return_value_realloc$4;
  return_value_realloc$4=realloc((void *)prelude, sizeof(struct anonymous$42) /*8ul*/  * (unsigned long int)num_items);
  hard_thread->prelude = (struct anonymous$42 *)return_value_realloc$4;
  hard_thread->prelude_num_items = (signed long int)num_items;
  hard_thread->prelude_idx = 0;
  return 0;
}

// convert_freecell_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 170
static inline signed int convert_freecell_num(signed int fcn)
{
  if(fcn >= 7)
    return fcn + 3;

  else
    return fcn;
}

// count_num_vacant_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 926
static inline unsigned char count_num_vacant_freecells(const unsigned char freecells_num, const struct fcs_struct_state_t * const state_ptr)
{
  unsigned char num_vacant_freecells = (unsigned char)0;
  signed int i = 0;
  for( ; !(i >= (signed int)freecells_num); i = i + 1)
    if((signed int)state_ptr->freecells[(signed long int)i] >> 2 == 0)
      num_vacant_freecells = num_vacant_freecells + 1;

  return num_vacant_freecells;
}

// count_num_vacant_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 943
static inline unsigned char count_num_vacant_stacks(const unsigned char stacks_num, const struct fcs_struct_state_t * const state_ptr)
{
  unsigned char num_vacant_stacks = (unsigned char)0;
  signed int i = 0;
  for( ; !(i >= (signed int)stacks_num); i = i + 1)
    if((signed int)*state_ptr->stacks[(signed long int)i] == 0)
      num_vacant_stacks = num_vacant_stacks + 1;

  return num_vacant_stacks;
}

// determine_scan_completeness
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 225
static inline void determine_scan_completeness(struct fc_solve_soft_thread_struct * const soft_thread, void * const global_tests_order)
{
  signed int tests_order = 0;
  accumulate_tests_by_ptr(&tests_order, &(soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order);
  soft_thread->runtime_flags = soft_thread->runtime_flags & (unsigned char)~2;
  if(tests_order == *((signed int *)global_tests_order))
    soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)2;

}

// duplicate_string_while_adding_a_trailing_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 722
static inline char * duplicate_string_while_adding_a_trailing_newline(const char *orig_str)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(orig_str);
  len = (signed int)return_value_strlen$1;
  char *s;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(len + 2));
  s = (char *)return_value_malloc$2;
  strcpy(s, orig_str);
  char *s_end = (s + (signed long int)len) - (signed long int)1;
  if(!((signed int)*s_end == 10))
  {
    s_end = s_end + 1l;
    *s_end = (char)10;
    s_end = s_end + 1l;
    *s_end = (char)0;
  }

  return s;
}

// empty_two_cols_from_new_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 187
static inline signed int empty_two_cols_from_new_state(const struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const kv_ptr_new_state, struct anonymous$3 * const moves, const signed int *cols_indexes, const signed int nc1, const signed int nc2)
{
  signed int ret = -1;
  signed int num_cards_to_move_from_columns[3l] = { nc1, nc2, -1 };
  const signed int *col_idx = cols_indexes;
  signed int *col_num_cards = num_cards_to_move_from_columns;
  const struct anonymous$14 game_params = soft_thread->hard_thread->instance->game_params;
  char * const indirect_stacks_buffer = soft_thread->hard_thread->indirect_stacks_buffer;
  signed int dest_fc_idx = 0;
  while((_Bool)1)
  {
    while(*col_num_cards == 0)
    {
      col_num_cards = col_num_cards + 1l;
      col_idx = col_idx + 1l;
      if(*col_idx == -1)
        return ret;

    }
    for( ; !(dest_fc_idx >= (signed int)game_params.freecells_num); dest_fc_idx = dest_fc_idx + 1)
      if((signed int)kv_ptr_new_state->key->freecells[(signed long int)dest_fc_idx] >> 2 == 0)
        break;

    if(dest_fc_idx == (signed int)game_params.freecells_num)
      break;

    char * const empty_two_cols_from_new_state$$1$$1$$1$$new_from_which_col = kv_ptr_new_state->key->stacks[(signed long int)*col_idx];
    char empty_two_cols_from_new_state$$1$$1$$1$$top_card = empty_two_cols_from_new_state$$1$$1$$1$$new_from_which_col[(signed long int)(((signed int)empty_two_cols_from_new_state$$1$$1$$1$$new_from_which_col[(signed long int)0] - 1) + 1)];
    empty_two_cols_from_new_state$$1$$1$$1$$new_from_which_col[(signed long int)0] = empty_two_cols_from_new_state$$1$$1$$1$$new_from_which_col[(signed long int)0] - 1;
    empty_two_cols_from_new_state$$1$$1$$1$$new_from_which_col[(signed long int)((signed int)empty_two_cols_from_new_state$$1$$1$$1$$new_from_which_col[(signed long int)0] + 1)] = (char)0;
    kv_ptr_new_state->key->freecells[(signed long int)dest_fc_idx] = empty_two_cols_from_new_state$$1$$1$$1$$top_card;
    fcs_move_stack_non_seq_push(moves, 1, *col_idx, dest_fc_idx);
    ret = dest_fc_idx;
    *col_num_cards = *col_num_cards - 1;
    dest_fc_idx = dest_fc_idx + 1;
  }
  while(*col_num_cards == 0)
  {
    col_num_cards = col_num_cards + 1l;
    col_idx = col_idx + 1l;
    if(*col_idx == -1)
      return ret;

  }
  signed int put_cards_in_col_idx = 0;
  char tmp_post$1;
  while((_Bool)1)
  {
    while(*col_num_cards == 0)
    {
      col_num_cards = col_num_cards + 1l;
      col_idx = col_idx + 1l;
      if(*col_idx == -1)
        return ret;

    }
    for( ; !(put_cards_in_col_idx >= (signed int)game_params.stacks_num); put_cards_in_col_idx = put_cards_in_col_idx + 1)
      if((signed int)*kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx] == 0)
        break;

    /* assertion put_cards_in_col_idx < (game_params.stacks_num) */
    assert(put_cards_in_col_idx < (signed int)game_params.stacks_num);
    if((kv_ptr_new_state->val->stacks_copy_on_write_flags & 1 << put_cards_in_col_idx) == 0)
    {
      char *copy_stack_col;
      kv_ptr_new_state->val->stacks_copy_on_write_flags = kv_ptr_new_state->val->stacks_copy_on_write_flags | 1 << put_cards_in_col_idx;
      copy_stack_col = kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx];
      memcpy((void *)&indirect_stacks_buffer[(signed long int)(put_cards_in_col_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx] = &indirect_stacks_buffer[(signed long int)(put_cards_in_col_idx << 7)];
    }

    char * const new_b_col = kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx];
    const signed int col_idx_val = *col_idx;
    char * const new_from_which_col = kv_ptr_new_state->key->stacks[(signed long int)col_idx_val];
    char top_card = new_from_which_col[(signed long int)(((signed int)new_from_which_col[(signed long int)0] - 1) + 1)];
    new_from_which_col[(signed long int)0] = new_from_which_col[(signed long int)0] - 1;
    new_from_which_col[(signed long int)((signed int)new_from_which_col[(signed long int)0] + 1)] = (char)0;
    tmp_post$1 = new_b_col[(signed long int)0];
    new_b_col[(signed long int)0] = new_b_col[(signed long int)0] + 1;
    new_b_col[(signed long int)((signed int)tmp_post$1 + 1)] = top_card;
    fcs_push_1card_seq(moves, col_idx_val, put_cards_in_col_idx);
    ret = put_cards_in_col_idx | 1 << 8;
    *col_num_cards = *col_num_cards - 1;
    put_cards_in_col_idx = put_cards_in_col_idx + 1;
  }
}

// false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 606
static inline const _Bool false_seq_index_loop(const signed int stacks_num, struct anonymous$6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous$45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag)
{
  _Bool return_value_generic_false_seq_index_loop$1;
  return_value_generic_false_seq_index_loop$1=generic_false_seq_index_loop(stacks_num, raw_ptr_state_raw, num_vacant_stacks, col, seqs, stack_idx, ds, behaviour_flag, (const _Bool)0, (char)0, 0);
  return return_value_generic_false_seq_index_loop$1;
}

// fc_solve_PQueueFree
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree(struct anonymous$32 *pq)
{
  free((void *)pq->Elements);
  pq->Elements = (struct anonymous$19 *)(void *)0;
}

// fc_solve_PQueueFree$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree$link1(struct anonymous$32 *pq$link1)
{
  free((void *)pq$link1->Elements);
  pq$link1->Elements = (struct anonymous$19 *)(void *)0;
}

// fc_solve_PQueueFree$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree$link2(struct anonymous$32 *pq$link2)
{
  free((void *)pq$link2->Elements);
  pq$link2->Elements = (struct anonymous$19 *)(void *)0;
}

// fc_solve_PQueueInitialise
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 88
static inline void fc_solve_PQueueInitialise(struct anonymous$32 *pq, signed int MaxElements)
{
  pq->max_size = MaxElements;
  pq->CurrentSize = 0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$19) /*16ul*/  * (unsigned long int)(MaxElements + 1));
  pq->Elements = (struct anonymous$19 *)return_value_malloc$1;
}

// fc_solve_PQueuePop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 177
static inline void fc_solve_PQueuePop(struct anonymous$32 *pq, struct fcs_state_keyval_pair_struct **val)
{
  signed int i;
  signed int child;
  struct anonymous$19 *Elements = pq->Elements;
  signed int CurrentSize = pq->CurrentSize;
  struct anonymous$19 pMaxElement;
  struct anonymous$19 pLastElement;
  signed int tmp_post$1;
  if(pq->CurrentSize == 0)
    *val = (struct fcs_state_keyval_pair_struct *)(void *)0;

  else
  {
    pMaxElement = Elements[(signed long int)1];
    tmp_post$1 = CurrentSize;
    CurrentSize = CurrentSize - 1;
    pLastElement = Elements[(signed long int)tmp_post$1];
    i = 1;
    do
    {
      child = i << 1;
      if(!(CurrentSize >= child))
        break;

      if(!(child == CurrentSize))
      {
        if(!((Elements + (signed long int)child)->rating >= (Elements + (signed long int)(1 + child))->rating))
          child = child + 1;

      }

      if(!(pLastElement.rating >= (Elements + (signed long int)child)->rating))
        Elements[(signed long int)i] = Elements[(signed long int)child];

      else
        break;
      i = child;
    }
    while((_Bool)1);
    Elements[(signed long int)i] = pLastElement;
    pq->CurrentSize = CurrentSize;
    *val = pMaxElement.val;
    goto __CPROVER_DUMP_L7;
  }

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_PQueuePush
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 114
static inline void fc_solve_PQueuePush(struct anonymous$32 *pq, struct fcs_state_keyval_pair_struct *val, signed int r)
{
  unsigned int i;
  struct anonymous$19 *Elements = pq->Elements;
  signed int CurrentSize = pq->CurrentSize;
  if(CurrentSize == pq->max_size)
  {
    pq->max_size = pq->max_size + 256;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)Elements, sizeof(struct anonymous$19) /*16ul*/  * (unsigned long int)(pq->max_size + 1));
    Elements = (struct anonymous$19 *)return_value_realloc$1;
    pq->Elements = Elements;
  }

  CurrentSize = CurrentSize + 1;
  i = (unsigned int)CurrentSize;
  signed int tmp_if_expr$2;
  do
  {
    if(i == 1u)
      tmp_if_expr$2 = 0x7fffffff;

    else
      tmp_if_expr$2 = (Elements + (signed long int)(i >> 1))->rating;
    if(tmp_if_expr$2 >= r)
      break;

    Elements[(signed long int)i] = Elements[(signed long int)(i >> 1)];
    i = i >> 1;
  }
  while((_Bool)1);
  (Elements + (signed long int)i)->val = val;
  (Elements + (signed long int)i)->rating = r;
  pq->CurrentSize = CurrentSize;
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// fc_solve_alloc_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 394
struct fc_solve_instance_struct * fc_solve_alloc_instance(struct anonymous$10 * const meta_alloc)
{
  struct fc_solve_instance_struct *instance;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct fc_solve_instance_struct) /*416ul*/  * (unsigned long int)1);
  instance = (struct fc_solve_instance_struct *)return_value_malloc$1;
  instance->meta_alloc = meta_alloc;
  instance->num_checked_states = (signed long int)0;
  instance->num_states_in_collection = (signed long int)0;
  instance->active_num_states_in_collection = (signed long int)0;
  instance->max_num_checked_states = (signed long int)-1;
  instance->effective_max_num_checked_states = (signed long int)0x7fffffff;
  instance->max_depth = -1;
  instance->max_num_states_in_collection = (signed long int)-1;
  instance->effective_max_num_states_in_collection = (signed long int)0x7fffffff;
  instance->trim_states_in_collection_from = (signed long int)-1;
  instance->effective_trim_states_in_collection_from = 0x7fffffffffffffffL;
  instance->instance_tests_order.num_groups = 0;
  instance->instance_tests_order.groups = (struct anonymous$20 *)(void *)0;
  instance->list_of_vacant_states = (struct fcs_state_keyval_pair_struct *)(void *)0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~8;
  instance->opt_tests_order.num_groups = 0;
  instance->opt_tests_order.groups = (struct anonymous$20 *)(void *)0;
  instance->num_hard_threads = 0;
  instance->hard_threads = (struct fc_solve_hard_thread_struct *)(void *)0;
  fc_solve_apply_preset_by_name(instance, "freecell");
  instance->debug_iter_output_func = (void (*)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int))(void *)0;
  instance->next_soft_thread_id = 0;
  fc_solve_new_hard_thread(instance);
  instance->solution_moves.moves = (struct anonymous$4 *)(void *)0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~1;
  instance->optimization_thread = (struct fc_solve_hard_thread_struct *)(void *)0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~2;
  instance->num_hard_threads_finished = 0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~4;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~16;
  instance->runtime_flags = instance->runtime_flags | (unsigned char)64;
  return instance;
}

// fc_solve_append_string_finalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 62
static inline char * fc_solve_append_string_finalize(struct anonymous$51 *app_str)
{
  char *ret;
  ret=strdup(app_str->buffer);
  free((void *)app_str->buffer);
  return ret;
}

// fc_solve_append_string_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 53
static inline void fc_solve_append_string_init(struct anonymous$51 *app_str)
{
  app_str->max_size = 4000;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)app_str->max_size);
  app_str->buffer = (char *)return_value_malloc$1;
  app_str->end_of_buffer = app_str->buffer;
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// fc_solve_append_string_sprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.c line 38
extern void fc_solve_append_string_sprintf(struct anonymous$51 *app_str, const char *format, ...)
{
  void **my_va_list = (void **)&format;
  signed int return_value_vsprintf$1;
  return_value_vsprintf$1=vsprintf(app_str->end_of_buffer, format, my_va_list);
  app_str->end_of_buffer = app_str->end_of_buffer + (signed long int)return_value_vsprintf$1;
  if(!((app_str->buffer + (signed long int)app_str->max_size) - app_str->end_of_buffer >= 500l))
  {
    char *old_buffer = app_str->buffer;
    app_str->max_size = app_str->max_size + 4000;
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)app_str->buffer, sizeof(char) /*1ul*/  * (unsigned long int)app_str->max_size);
    app_str->buffer = (char *)return_value_realloc$2;
    app_str->end_of_buffer = app_str->end_of_buffer + (app_str->buffer - old_buffer);
  }

  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// fc_solve_apply_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 120
void fc_solve_apply_move(struct anonymous$6 *state, struct anonymous$7 *locs, struct anonymous$4 move, signed int freecells_num, signed int stacks_num, signed int decks_num)
{
  char card;
  char *col;
  char tmp_post$1;
  char tmp_post$2;
  switch((signed int)move.c[(signed long int)0])
  {
    case 0:
    {
      char *dest_col;
      signed int i;
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      dest_col = state->key->stacks[(signed long int)move.c[(signed long int)2]];
      i = 0;
      for( ; !(i >= (signed int)move.c[3l]); i = i + 1)
      {
        tmp_post$1 = dest_col[(signed long int)0];
        dest_col[(signed long int)0] = dest_col[(signed long int)0] + 1;
        dest_col[(signed long int)((signed int)tmp_post$1 + 1)] = col[(signed long int)(((signed int)col[(signed long int)0] - (signed int)move.c[(signed long int)3]) + i + 1)];
      }
      i = 0;
      for( ; !(i >= (signed int)move.c[3l]); i = i + 1)
      {
        col[(signed long int)0] = col[(signed long int)0] - 1;
        col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
      }
      break;
    }
    case 2:
    {
      col = state->key->stacks[(signed long int)move.c[(signed long int)2]];
      tmp_post$2 = col[(signed long int)0];
      col[(signed long int)0] = col[(signed long int)0] + 1;
      col[(signed long int)((signed int)tmp_post$2 + 1)] = state->key->freecells[(signed long int)move.c[(signed long int)1]];
      state->key->freecells[(signed long int)move.c[(signed long int)1]] = (char)0;
      break;
    }
    case 3:
    {
      card = state->key->freecells[(signed long int)move.c[(signed long int)1]];
      state->key->freecells[(signed long int)move.c[(signed long int)2]] = card;
      state->key->freecells[(signed long int)move.c[(signed long int)1]] = (char)0;
      break;
    }
    case 1:
    {
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      card = col[(signed long int)(((signed int)col[(signed long int)0] - 1) + 1)];
      col[(signed long int)0] = col[(signed long int)0] - 1;
      col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
      state->key->freecells[(signed long int)move.c[(signed long int)2]] = card;
      break;
    }
    case 4:
    {
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      col[(signed long int)0] = col[(signed long int)0] - 1;
      col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
      state->key->foundations[(signed long int)move.c[(signed long int)2]] = state->key->foundations[(signed long int)move.c[(signed long int)2]] + 1;
      break;
    }
    case 5:
    {
      state->key->freecells[(signed long int)move.c[(signed long int)1]] = (char)0;
      state->key->foundations[(signed long int)move.c[(signed long int)2]] = state->key->foundations[(signed long int)move.c[(signed long int)2]] + 1;
      break;
    }
    case 11:
    {
      signed int fc_solve_apply_move$$1$$1$$7$$i;
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      fc_solve_apply_move$$1$$1$$7$$i = 0;
      for( ; !(fc_solve_apply_move$$1$$1$$7$$i >= 13); fc_solve_apply_move$$1$$1$$7$$i = fc_solve_apply_move$$1$$1$$7$$i + 1)
      {
        col[(signed long int)0] = col[(signed long int)0] - 1;
        col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
        state->key->foundations[(signed long int)move.c[(signed long int)2]] = state->key->foundations[(signed long int)move.c[(signed long int)2]] + 1;
      }
      break;
    }
    case 12:
      if(!(locs == ((struct anonymous$7 *)NULL)))
        fc_solve_canonize_state_with_locs(state, locs, freecells_num, stacks_num);

      else
        fc_solve_canonize_state(state, freecells_num, stacks_num);
  }
}

// fc_solve_apply_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 58
extern signed int fc_solve_apply_preset_by_name(struct fc_solve_instance_struct *instance, const char *name)
{
  signed int ret;
  const struct anonymous$36 *preset_ptr;
  ret=fc_solve_get_preset_by_name(name, &preset_ptr);
  if(!(ret == 0))
    return ret;

  else
  {
    signed int return_value_fc_solve_apply_preset_by_ptr$1;
    return_value_fc_solve_apply_preset_by_ptr$1=fc_solve_apply_preset_by_ptr(instance, preset_ptr);
    return return_value_fc_solve_apply_preset_by_ptr$1;
  }
}

// fc_solve_apply_preset_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 53
extern signed int fc_solve_apply_preset_by_ptr(struct fc_solve_instance_struct *instance, const struct anonymous$36 *preset_ptr)
{
  char *no_use;
  if((signed int)preset_ptr->game_params.freecells_num >= 9)
    return 2;

  else
    if((signed int)preset_ptr->game_params.stacks_num >= 11)
      return 3;

    else
      if((signed int)preset_ptr->game_params.decks_num >= 3)
        return 4;

      else
      {
        instance->game_params = preset_ptr->game_params;
        char test_name[2l] = { (char)0, 0 };
        struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
        struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
        for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
        {
          struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
          struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
          for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
          {
            signed int num_valid_tests;
            const char *s;
            signed int depth_idx;
            struct anonymous$21 *by_depth_tests_order;
            signed int tests_order_num;
            signed int *tests_order_tests;
            by_depth_tests_order = soft_thread->by_depth_tests_order.by_depth_tests;
            depth_idx = 0;
            for( ; !(depth_idx >= soft_thread->by_depth_tests_order.num); depth_idx = depth_idx + 1)
            {
              signed int group_idx = 0;
              for( ; !(group_idx >= (by_depth_tests_order + (signed long int)depth_idx)->tests_order.num_groups); group_idx = group_idx + 1)
              {
                tests_order_tests = ((by_depth_tests_order + (signed long int)depth_idx)->tests_order.groups + (signed long int)group_idx)->tests;
                tests_order_num = ((by_depth_tests_order + (signed long int)depth_idx)->tests_order.groups + (signed long int)group_idx)->num;
                num_valid_tests = 0;
                for( ; !(num_valid_tests >= tests_order_num); num_valid_tests = num_valid_tests + 1)
                {
                  s = preset_ptr->allowed_tests;
                  for( ; !((signed int)*s == 0); s = s + 1l)
                  {
                    test_name[(signed long int)0] = *s;
                    signed int return_value_fc_solve_string_to_test_num$1;
                    return_value_fc_solve_string_to_test_num$1=fc_solve_string_to_test_num$link1(test_name);
                    if((16777215 & tests_order_tests[(signed long int)num_valid_tests]) == return_value_fc_solve_string_to_test_num$1 % 24)
                      break;

                  }
                  if((signed int)*s == 0)
                    break;

                }
                if(!(num_valid_tests >= tests_order_num))
                  fc_solve_apply_tests_order(&(by_depth_tests_order + (signed long int)depth_idx)->tests_order, preset_ptr->tests_order, &no_use);

              }
            }
          }
        }
        fc_solve_apply_tests_order(&instance->instance_tests_order, preset_ptr->tests_order, &no_use);
        return 0;
      }
}

// fc_solve_apply_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 74
extern signed int fc_solve_apply_tests_order(struct anonymous$9 *tests_order, const char *string, char **error_string)
{
  signed int i;
  signed int len;
  _Bool is_group;
  _Bool is_start_group;
  char test_name[2l] = { (char)0, 0 };
  fc_solve_free_tests_order$link2(tests_order);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$20) /*232ul*/  * (unsigned long int)16);
  tests_order->groups = (struct anonymous$20 *)return_value_malloc$1;
  (tests_order->groups + (signed long int)tests_order->num_groups)->num = 0;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)16);
  (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)return_value_malloc$2;
  (tests_order->groups + (signed long int)tests_order->num_groups)->shuffling_type = (enum anonymous$26)FCS_NO_SHUFFLING;
  tests_order->num_groups = tests_order->num_groups + 1;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(string);
  len = (signed int)return_value_strlen$3;
  is_group = (_Bool)0;
  is_start_group = (_Bool)0;
  i = 0;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$11;
  _Bool return_value_string_starts_with$7;
  signed int tmp_post$13;
  for( ; !(i >= len); i = i + 1)
  {
    if((signed int)string[(signed long int)i] == 40)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)string[(signed long int)i] == 91 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      if(!(is_group == (_Bool)0))
      {
        *error_string=strdup("There's a nested random group.");
        return 1;
      }

      is_group = (_Bool)1;
      is_start_group = (_Bool)1;
      if(!((tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num == 0))
      {
        if((16 & tests_order->num_groups) == 0)
        {
          void *return_value_realloc$4;
          return_value_realloc$4=realloc((void *)tests_order->groups, sizeof(struct anonymous$20) /*232ul*/  * (unsigned long int)16);
          tests_order->groups = (struct anonymous$20 *)return_value_realloc$4;
        }

        (tests_order->groups + (signed long int)tests_order->num_groups)->num = 0;
        void *return_value_malloc$5;
        return_value_malloc$5=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)16);
        (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)return_value_malloc$5;
        tests_order->num_groups = tests_order->num_groups + 1;
      }

      (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous$26)FCS_RAND;
    }

    else
    {
      if((signed int)string[(signed long int)i] == 41)
        tmp_if_expr$11 = (_Bool)1;

      else
        tmp_if_expr$11 = (signed int)string[(signed long int)i] == 93 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$11)
      {
        if(!(is_start_group == (_Bool)0))
        {
          *error_string=strdup("There's an empty group.");
          return 2;
        }

        if(is_group == (_Bool)0)
        {
          *error_string=strdup("There's a renegade right parenthesis or bracket.");
          return 3;
        }

        if((signed int)string[(signed long int)(1 + i)] == 61)
        {
          i = i + 2;
          const char *open_paren;
          open_paren=strchr(string + (signed long int)i, 40);
          if(open_paren == ((const char *)NULL))
          {
            *error_string=strdup("A = ordering function is missing its open parenthesis - (");
            return 5;
          }

          _Bool return_value_string_starts_with$8;
          return_value_string_starts_with$8=string_starts_with$link1(string + (signed long int)i, "rand", open_paren);
          if(!(return_value_string_starts_with$8 == (_Bool)0))
            (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous$26)FCS_RAND;

          else
          {
            return_value_string_starts_with$7=string_starts_with$link1(string + (signed long int)i, "asw", open_paren);
            if(!(return_value_string_starts_with$7 == (_Bool)0))
              (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous$26)FCS_WEIGHTING;

            else
            {
              *error_string=strdup("Unknown = ordering function");
              return 6;
            }
          }
          const char * const aft_open_paren = open_paren + (signed long int)1;
          const char *close_paren;
          close_paren=strchr(aft_open_paren, 41);
          if(close_paren == ((const char *)NULL))
          {
            *error_string=strdup("= ordering function not terminated with a ')'");
            return 7;
          }

          if((signed int)(tests_order->groups + (signed long int)(tests_order->num_groups + -1))->shuffling_type == FCS_WEIGHTING)
          {
            char *copy;
            copy=strndup(aft_open_paren, (unsigned long int)(close_paren - aft_open_paren));
            fc_solve_set_weights$link1(copy, (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->weighting.befs_weights);
            free((void *)copy);
          }

          else
            if(!(close_paren == aft_open_paren))
            {
              *error_string=strdup("=rand() arguments are not empty.");
              return 8;
            }

          i = (signed int)(close_paren - string);
        }

        is_group = (_Bool)0;
        is_start_group = (_Bool)0;
        if(!((tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num == 0))
        {
          if((16 & tests_order->num_groups) == 0)
          {
            void *return_value_realloc$9;
            return_value_realloc$9=realloc((void *)tests_order->groups, sizeof(struct anonymous$20) /*232ul*/  * (unsigned long int)(tests_order->num_groups + 16));
            tests_order->groups = (struct anonymous$20 *)return_value_realloc$9;
          }

          (tests_order->groups + (signed long int)tests_order->num_groups)->num = 0;
          void *return_value_malloc$10;
          return_value_malloc$10=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)16);
          (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)return_value_malloc$10;
          tests_order->num_groups = tests_order->num_groups + 1;
        }

        (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous$26)FCS_NO_SHUFFLING;
      }

      else
      {
        if((16 & (tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num) == 0)
        {
          void *return_value_realloc$12;
          return_value_realloc$12=realloc((void *)(tests_order->groups + (signed long int)(tests_order->num_groups - 1))->tests, sizeof(signed int) /*4ul*/  * (unsigned long int)16);
          (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->tests = (signed int *)return_value_realloc$12;
        }

        test_name[(signed long int)0] = string[(signed long int)i];
        tmp_post$13 = (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->num;
        (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->num = (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->num + 1;
        signed int return_value_fc_solve_string_to_test_num$14;
        return_value_fc_solve_string_to_test_num$14=fc_solve_string_to_test_num(test_name);
        (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->tests[(signed long int)tmp_post$13] = return_value_fc_solve_string_to_test_num$14 % 24;
        is_start_group = (_Bool)0;
      }
    }
  }
  if(!(i == len))
  {
    *error_string=strdup("The Input string is too long.");
    return 4;
  }

  else
  {
    if((tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num == 0)
    {
      tests_order->num_groups = tests_order->num_groups - 1;
      free((void *)(tests_order->groups + (signed long int)tests_order->num_groups)->tests);
      (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)(void *)0;
    }

    *error_string = (char *)(void *)0;
    return 0;
  }
}

// fc_solve_args_man_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 40
extern struct anonymous$37 * fc_solve_args_man_alloc(void)
{
  struct anonymous$37 *ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$37) /*40ul*/  * (unsigned long int)1);
  ret = (struct anonymous$37 *)return_value_malloc$1;
  ret->argc = 0;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)32);
  ret->argv = (char **)return_value_malloc$2;
  return ret;
}

// fc_solve_args_man_chop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 42
extern signed int fc_solve_args_man_chop(struct anonymous$37 *manager, char *string)
{
  char *s = string;
  _Bool in_arg;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)1024);
  manager->last_arg = (char *)return_value_malloc$1;
  manager->last_arg_ptr = manager->last_arg;
  manager->last_arg_end = manager->last_arg + (signed long int)1023;
  _Bool return_value_is_whitespace$2;
  while(!((signed int)*s == 0))
  {
    _Bool push_next_arg_flag = (_Bool)0;
    in_arg = (_Bool)0;
    do
    {
      return_value_is_whitespace$2=is_whitespace(*s);
      if(return_value_is_whitespace$2 == (_Bool)0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if((signed int)*s == 0)
      break;

    if((signed int)*s == 35)
    {
      in_arg = (_Bool)0;
      for( ; !((signed int)*s == 0); s = s + 1l)
        if((signed int)*s == 10)
          break;

    }

    else
    {
      _Bool still_loop = (_Bool)1;
      while(!(still_loop == (_Bool)0))
        switch((signed int)*s)
        {
          case 32:

          case 9:

          case 10:

          case 0:

          case 13:
          {
            push_next_arg_flag = (_Bool)1;
            still_loop = (_Bool)0;
            break;
          }
          case 92:
          {
            char next_char;
            s = s + 1l;
            next_char = *s;
            s = s + 1l;
            if((signed int)next_char == 0)
            {
              s = s - 1l;
              push_next_arg_flag = (_Bool)1;
              still_loop = (_Bool)0;
            }

            else
              if((signed int)next_char == 10 || (signed int)next_char == 13)
              {
                if(in_arg == (_Bool)0)
                  still_loop = (_Bool)0;

              }

              else
                add_to_last_arg(manager, next_char);
            break;
          }
          case 34:
          {
            s = s + 1l;
            in_arg = (_Bool)1;
            for( ; !((signed int)*s == 34); s = s + 1l)
            {
              if((signed int)*s == 0)
                break;

              if((signed int)*s == 92)
              {
                char fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char;
                s = s + 1l;
                fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char = *s;
                if((signed int)fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char == 0)
                {
                  push_args_last_arg(manager);
                  goto END_OF_LOOP;
                }

                else
                  if(!((signed int)fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char == 10) && !((signed int)fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char == 13))
                  {
                    if((signed int)fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char == 34 || (signed int)fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char == 92)
                      add_to_last_arg(manager, fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char);

                    else
                    {
                      add_to_last_arg(manager, (char)92);
                      add_to_last_arg(manager, fc_solve_args_man_chop$$1$$1$$4$$1$$1$$2$$1$$next_char);
                    }
                  }

              }

              else
                add_to_last_arg(manager, *s);
            }
            s = s + 1l;
            break;
          }
          case 35:
          {
            in_arg = (_Bool)0;
            for( ; !((signed int)*s == 0); s = s + 1l)
              if((signed int)*s == 10)
                break;

            push_next_arg_flag = (_Bool)1;
            still_loop = (_Bool)0;
            break;
          }
          default:
          {
            in_arg = (_Bool)1;
            add_to_last_arg(manager, *s);
            s = s + 1l;
          }
        }
      if(!(push_next_arg_flag == (_Bool)0))
      {
        push_args_last_arg(manager);
        in_arg = (_Bool)0;
        if((signed int)*s == 0)
          break;

      }

    }
  }

END_OF_LOOP:
  ;
  if(!(manager->last_arg_ptr == manager->last_arg))
    push_args_last_arg(manager);

  free((void *)manager->last_arg);
  manager->last_arg_end = (char *)(void *)0;
  manager->last_arg_ptr = manager->last_arg_end;
  manager->last_arg = manager->last_arg_ptr;
  return 0;
}

// fc_solve_args_man_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 41
extern void fc_solve_args_man_free(struct anonymous$37 *manager)
{
  const signed int argc = manager->argc;
  char ** const argv = manager->argv;
  signed int i = 0;
  for( ; !(i >= argc); i = i + 1)
    free((void *)argv[(signed long int)i]);
  free((void *)argv);
  free((void *)manager);
}

// fc_solve_befs_or_bfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 925
extern signed int fc_solve_befs_or_bfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  struct fcs_state_keyval_pair_struct *ptr_new_state;
  struct anonymous$6 new_pass;
  struct fcs_state_keyval_pair_struct *ptr_state_raw;
  struct anonymous$6 pass;
  const unsigned char calc_real_depth = (const unsigned char)((signed int)instance->runtime_flags & 4);
  const unsigned char scans_synergy = (const unsigned char)((signed int)instance->runtime_flags & 64);
  const signed int soft_thread_id = soft_thread->id;
  const unsigned char is_a_complete_scan = (const unsigned char)((signed int)soft_thread->runtime_flags & 2);
  struct fcs_states_linked_list_item_struct *queue = (struct fcs_states_linked_list_item_struct *)(void *)0;
  struct fcs_states_linked_list_item_struct *queue_last_item = (struct fcs_states_linked_list_item_struct *)(void *)0;
  struct anonymous$32 *pqueue = (struct anonymous$32 *)(void *)0;
  signed int error_code;
  signed long int hard_thread_max_num_checked_states;
  struct anonymous$12 derived;
  derived.num_states = 0;
  derived.states = (struct anonymous$38 *)(void *)0;
  void (* const * const tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *) = soft_thread->method_specific.befs.tests_list;
  void (* const * const tests_list_end)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *) = soft_thread->method_specific.befs.tests_list_end;
  ptr_state_raw = soft_thread->first_state_to_check;
  if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    pass.key = &ptr_state_raw->$anon0.$anon0.s;
    pass.val = &ptr_state_raw->$anon0.$anon0.info;
  }

  const _Bool enable_pruning = soft_thread->enable_pruning;
  const signed int method = soft_thread->method;
  signed long int * const instance_num_checked_states_ptr = &instance->num_checked_states;
  signed long int * const hard_thread_num_checked_states_ptr = &hard_thread->num_checked_states;
  if(method == 3)
    pqueue = &soft_thread->method_specific.befs.meth.befs.pqueue;

  else
  {
    queue = soft_thread->method_specific.befs.meth.brfs.bfs_queue;
    queue_last_item = soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item;
  }
  const struct anonymous$14 game_params = instance->game_params;
  hard_thread_max_num_checked_states = hard_thread->max_num_checked_states;
  signed long int lim = hard_thread->num_checked_states + (instance->effective_max_num_checked_states - *instance_num_checked_states_ptr);
  hard_thread_max_num_checked_states = hard_thread_max_num_checked_states < lim ? hard_thread_max_num_checked_states : lim;
  void (* const debug_iter_output_func)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int) = instance->debug_iter_output_func;
  void * const debug_iter_output_context = instance->debug_iter_output_context;
  struct fcs_states_linked_list_item_struct *save_item;
  signed int tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  unsigned char num_vacant_freecells;
  unsigned char num_vacant_stacks;
  _Bool tmp_if_expr$4;
  signed long int tmp_if_expr$6;
  struct anonymous$38 *derived_iter;
  struct anonymous$38 *derived_end;
  while(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    if(!(enable_pruning == (_Bool)0))
    {
      if((16 & (signed int)ptr_state_raw->$anon0.$anon0.info.visited) == 0)
      {
        struct fcs_state_keyval_pair_struct *after_pruning_state;
        signed int return_value_fc_solve_sfs_raymond_prune$1;
        return_value_fc_solve_sfs_raymond_prune$1=fc_solve_sfs_raymond_prune(soft_thread, &pass, &after_pruning_state);
        if(return_value_fc_solve_sfs_raymond_prune$1 == 1)
        {
          ptr_state_raw = after_pruning_state;
          if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
          {
            pass.key = &ptr_state_raw->$anon0.$anon0.s;
            pass.val = &ptr_state_raw->$anon0.$anon0.info;
          }

        }

      }

    }

    signed int temp_visited = (signed int)ptr_state_raw->$anon0.$anon0.info.visited;
    if(method == 4)
      tmp_if_expr$3 = (signed int)(!((temp_visited & 1) != 0) || (temp_visited & 2) != 0);

    else
    {
      if(!((4 & temp_visited) == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = ((signed int)ptr_state_raw->$anon0.$anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] & 1 << (soft_thread_id & (1 << 3) - 1)) != 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$3 = (signed int)tmp_if_expr$2;
    }
    if(tmp_if_expr$3 == 0)
    {
      num_vacant_freecells=count_num_vacant_freecells(game_params.freecells_num, &ptr_state_raw->$anon0.$anon0.s);
      num_vacant_stacks=count_num_vacant_stacks(game_params.stacks_num, &ptr_state_raw->$anon0.$anon0.s);
      if(*hard_thread_num_checked_states_ptr == hard_thread_max_num_checked_states)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        soft_thread->first_state_to_check = ptr_state_raw;
        error_code = 5;
        goto my_return_label;
      }

      if(!(debug_iter_output_func == ((void (*)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int))NULL)))
      {
        signed int return_value_calc_depth$5;
        return_value_calc_depth$5=calc_depth(ptr_state_raw);
        if(ptr_state_raw->$anon0.$anon0.info.parent == ((struct fcs_state_keyval_pair_struct *)NULL))
          tmp_if_expr$6 = (signed long int)0;

        else
          tmp_if_expr$6 = ptr_state_raw->$anon0.$anon0.info.parent->$anon0.$anon0.info.visited_iter;
        debug_iter_output_func(debug_iter_output_context, *instance_num_checked_states_ptr, return_value_calc_depth$5, (void *)instance, &pass, tmp_if_expr$6);
      }

      if(num_vacant_freecells == game_params.freecells_num && num_vacant_stacks == game_params.stacks_num)
      {
        instance->final_state = ptr_state_raw;
        *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
        *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
        error_code = 0;
        goto my_return_label;
      }

      calculate_real_depth((const _Bool)calc_real_depth, ptr_state_raw);
      soft_thread->num_vacant_freecells = num_vacant_freecells;
      soft_thread->num_vacant_stacks = num_vacant_stacks;
      if(!(soft_thread->method_specific.befs.befs_positions_by_rank == ((char *)NULL)))
      {
        free((void *)soft_thread->method_specific.befs.befs_positions_by_rank);
        soft_thread->method_specific.befs.befs_positions_by_rank = (char *)(void *)0;
      }

      derived.num_states = 0;
      void (* const *next_test)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *) = tests_list;
      if(!(next_test >= tests_list_end))
      {
        (*next_test)(soft_thread, &pass, &derived);
        next_test = next_test + 1l;
      }

      if(!(is_a_complete_scan == 0))
        ptr_state_raw->$anon0.$anon0.info.visited = ptr_state_raw->$anon0.$anon0.info.visited | (unsigned char)8;

      *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
      *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
      derived_iter = derived.states;
      derived_end = derived_iter + (signed long int)derived.num_states;
      for( ; !(derived_iter >= derived_end); derived_iter = derived_iter + 1l)
      {
        ptr_new_state = derived_iter->state_ptr;
        new_pass.key = &ptr_new_state->$anon0.$anon0.s;
        new_pass.val = &ptr_new_state->$anon0.$anon0.info;
        if(method == 3)
        {
          signed int return_value_kv_calc_depth$7;
          return_value_kv_calc_depth$7=kv_calc_depth(&new_pass);
          signed int return_value_befs_rate_state$8;
          return_value_befs_rate_state$8=befs_rate_state(soft_thread, &soft_thread->method_specific.befs.meth.befs.weighting, new_pass.key, 20000 - return_value_kv_calc_depth$7);
          fc_solve_PQueuePush(pqueue, ptr_new_state, return_value_befs_rate_state$8);
        }

        else
        {
          struct fcs_states_linked_list_item_struct *last_item_next;
          if(!(soft_thread->method_specific.befs.meth.brfs.recycle_bin == ((struct fcs_states_linked_list_item_struct *)NULL)))
          {
            last_item_next = soft_thread->method_specific.befs.meth.brfs.recycle_bin;
            soft_thread->method_specific.befs.meth.brfs.recycle_bin = soft_thread->method_specific.befs.meth.brfs.recycle_bin->next;
          }

          else
          {
            void *return_value_fcs_compact_alloc_ptr$9;
            return_value_fcs_compact_alloc_ptr$9=fcs_compact_alloc_ptr$link2(&hard_thread->allocator, (signed int)sizeof(struct fcs_states_linked_list_item_struct) /*16ul*/ );
            last_item_next = (struct fcs_states_linked_list_item_struct *)return_value_fcs_compact_alloc_ptr$9;
          }
          queue_last_item->next = last_item_next;
          queue_last_item->s = ptr_new_state;
          last_item_next->next = (struct fcs_states_linked_list_item_struct *)(void *)0;
          queue_last_item = last_item_next;
        }
      }
      if(method == 4)
        ptr_state_raw->$anon0.$anon0.info.visited = ptr_state_raw->$anon0.$anon0.info.visited | (unsigned char)2;

      else
      {
        ptr_state_raw->$anon0.$anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] = ptr_state_raw->$anon0.$anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] | (unsigned char)(1 << (soft_thread_id & (1 << 3) - 1));
        if(derived.num_states == 0)
        {
          if(!(is_a_complete_scan == 0))
            mark_as_dead_end((const _Bool)scans_synergy, ptr_state_raw);

        }

      }
      ptr_state_raw->$anon0.$anon0.info.visited_iter = *instance_num_checked_states_ptr - (signed long int)1;
    }


  label_next_state:
    ;
    if(method == 3)
    {
      struct fcs_state_keyval_pair_struct *new_ptr_state;
      fc_solve_PQueuePop(pqueue, &new_ptr_state);
      ptr_state_raw = new_ptr_state;
      if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
      {
        pass.key = &ptr_state_raw->$anon0.$anon0.s;
        pass.val = &ptr_state_raw->$anon0.$anon0.info;
      }

    }

    else
    {
      save_item = queue->next;
      if(!(save_item == queue_last_item))
      {
        ptr_state_raw = save_item->s;
        if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
        {
          pass.key = &ptr_state_raw->$anon0.$anon0.s;
          pass.val = &ptr_state_raw->$anon0.$anon0.info;
        }

        queue->next = save_item->next;
        save_item->next = soft_thread->method_specific.befs.meth.brfs.recycle_bin;
        soft_thread->method_specific.befs.meth.brfs.recycle_bin = save_item;
      }

      else
      {
        ptr_state_raw = (struct fcs_state_keyval_pair_struct *)(void *)0;
        if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
        {
          pass.key = &ptr_state_raw->$anon0.$anon0.s;
          pass.val = &ptr_state_raw->$anon0.$anon0.info;
        }

      }
    }
  }
  error_code = 1;

my_return_label:
  ;
  if(!(derived.states == ((struct anonymous$38 *)NULL)))
    free((void *)derived.states);

  if(!(method == 3))
    soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item = queue_last_item;

  if(!(soft_thread->method_specific.befs.befs_positions_by_rank == ((char *)NULL)))
  {
    free((void *)soft_thread->method_specific.befs.befs_positions_by_rank);
    soft_thread->method_specific.befs.befs_positions_by_rank = (char *)(void *)0;
  }

  return error_code;
}

// fc_solve_cache_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 82
static inline void fc_solve_cache_stacks(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous$6 * const new_state)
{
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const struct anonymous$14 game_params = instance->game_params;
  struct fcs_struct_state_t * const new_state_key = new_state->key;
  struct fcs_state_extra_info_struct * const new_state_info = new_state->val;
  struct anonymous$5 * const stacks_allocator = &hard_thread->allocator;
  char **current_stack = new_state_key->stacks;
  signed int i = 0;
  for( ; !(i >= (signed int)game_params.stacks_num); current_stack = current_stack + 1l)
  {
    if(!((new_state_info->stacks_copy_on_write_flags & 1 << i) == 0))
    {
      char *column = new_state_key->stacks[(signed long int)i];
      const signed int col_len = (signed int)column[(signed long int)0] + 1;
      char *new_ptr;
      void *return_value_fcs_compact_alloc_ptr$1;
      return_value_fcs_compact_alloc_ptr$1=fcs_compact_alloc_ptr(stacks_allocator, col_len);
      new_ptr = (char *)return_value_fcs_compact_alloc_ptr$1;
      memcpy((void *)new_ptr, (const void *)column, (unsigned long int)col_len);
      *current_stack = new_ptr;
      void *cached_stack;
      column = new_state_key->stacks[(signed long int)i];
      unsigned long int return_value_perl_hash_function$2;
      return_value_perl_hash_function$2=perl_hash_function((unsigned char *)*current_stack, (const unsigned long int)col_len);
      _Bool return_value_fc_solve_hash_insert$3;
      return_value_fc_solve_hash_insert$3=fc_solve_hash_insert(&instance->stacks_hash, (void *)column, &cached_stack, (const signed int)return_value_perl_hash_function$2);
      if(!(return_value_fc_solve_hash_insert$3 == (_Bool)0))
      {
        stacks_allocator->ptr = stacks_allocator->rollback_ptr;
        *current_stack = (char *)cached_stack;
      }

    }

    i = i + 1;
  }
}

// fc_solve_calc_positions_by_rank_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2033
static inline char ** fc_solve_calc_positions_by_rank_location(struct fc_solve_soft_thread_struct *soft_thread)
{
  if(soft_thread->method == 1 || soft_thread->method == 5)
    return &(soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)soft_thread->method_specific.soft_dfs.depth)->positions_by_rank;

  return &soft_thread->method_specific.befs.befs_positions_by_rank;
}

// fc_solve_canonize_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 634
extern void fc_solve_canonize_state(struct anonymous$6 *state_raw, signed int freecells_num, signed int stacks_num)
{
  signed int b;
  signed int c;
  char *temp_stack;
  char temp_freecell;
  b = 1;
  signed int return_value_fc_solve_stack_compare_for_comparison$1;
  for( ; !(b >= stacks_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_stack_compare_for_comparison$1=fc_solve_stack_compare_for_comparison((const void *)state_raw->key->stacks[(signed long int)c], (const void *)state_raw->key->stacks[(signed long int)(c - 1)]);
      if(return_value_fc_solve_stack_compare_for_comparison$1 >= 0)
        break;

      temp_stack = state_raw->key->stacks[(signed long int)c];
      state_raw->key->stacks[(signed long int)c] = state_raw->key->stacks[(signed long int)(c - 1)];
      state_raw->key->stacks[(signed long int)(c - 1)] = temp_stack;
    }
  }
  b = 1;
  signed int return_value_fc_solve_card_compare$2;
  for( ; !(b >= freecells_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_card_compare$2=fc_solve_card_compare(state_raw->key->freecells[(signed long int)c], state_raw->key->freecells[(signed long int)(c - 1)]);
      if(return_value_fc_solve_card_compare$2 >= 0)
        break;

      temp_freecell = state_raw->key->freecells[(signed long int)c];
      state_raw->key->freecells[(signed long int)c] = state_raw->key->freecells[(signed long int)(c - 1)];
      state_raw->key->freecells[(signed long int)(c - 1)] = temp_freecell;
    }
  }
}

// fc_solve_canonize_state_with_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 640
void fc_solve_canonize_state_with_locs(struct anonymous$6 *state, struct anonymous$7 *locs, signed int freecells_num, signed int stacks_num)
{
  signed int b;
  signed int c;
  char *temp_stack;
  char temp_freecell;
  char temp_loc;
  b = 1;
  signed int return_value_fc_solve_stack_compare_for_comparison$1;
  for( ; !(b >= stacks_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_stack_compare_for_comparison$1=fc_solve_stack_compare_for_comparison((const void *)state->key->stacks[(signed long int)c], (const void *)state->key->stacks[(signed long int)(c - 1)]);
      if(return_value_fc_solve_stack_compare_for_comparison$1 >= 0)
        break;

      temp_stack = state->key->stacks[(signed long int)c];
      state->key->stacks[(signed long int)c] = state->key->stacks[(signed long int)(c - 1)];
      state->key->stacks[(signed long int)(c - 1)] = temp_stack;
      temp_loc = locs->stack_locs[(signed long int)c];
      locs->stack_locs[(signed long int)c] = locs->stack_locs[(signed long int)(c - 1)];
      locs->stack_locs[(signed long int)(c - 1)] = temp_loc;
    }
  }
  b = 1;
  signed int return_value_fc_solve_card_compare$2;
  for( ; !(b >= freecells_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_card_compare$2=fc_solve_card_compare(state->key->freecells[(signed long int)c], state->key->freecells[(signed long int)(c - 1)]);
      if(return_value_fc_solve_card_compare$2 >= 0)
        break;

      temp_freecell = state->key->freecells[(signed long int)c];
      state->key->freecells[(signed long int)c] = state->key->freecells[(signed long int)(c - 1)];
      state->key->freecells[(signed long int)(c - 1)] = temp_freecell;
      temp_loc = locs->fc_locs[(signed long int)c];
      locs->fc_locs[(signed long int)c] = locs->fc_locs[(signed long int)(c - 1)];
      locs->fc_locs[(signed long int)(c - 1)] = temp_loc;
    }
  }
}

// fc_solve_card_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare(const char c1, const char c2)
{
  return (signed int)c1 - (signed int)c2;
}

// fc_solve_card_compare$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare$link1(const char c1$link1, const char c2$link1)
{
  return (signed int)c1$link1 - (signed int)c2$link1;
}

// fc_solve_card_perl2user
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 266
extern char * fc_solve_card_perl2user(char card, char *str, _Bool t)
{
  _Bool rank_is_null;
  fc_solve_p2u_rank((signed int)card >> 2, str, &rank_is_null, t);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  fc_solve_p2u_suit((signed int)card & 0x03, str + (signed long int)return_value_strlen$1, rank_is_null);
  return str;
}

// fc_solve_card_user2perl
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 140
extern char fc_solve_card_user2perl(const char *str)
{
  signed int rank;
  rank=fc_solve_u2p_rank(str);
  signed int suit;
  suit=fc_solve_u2p_suit(str);
  char return_value_fcs_make_card$1;
  return_value_fcs_make_card$1=fcs_make_card(rank, suit);
  return return_value_fcs_make_card$1;
}

// fc_solve_check_and_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 316
_Bool fc_solve_check_and_add_state(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous$6 * const new_state, struct anonymous$6 * const existing_state_raw)
{
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  fc_solve_cache_stacks(hard_thread, new_state);
  fc_solve_canonize_state(new_state, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num);
  void *existing_void;
  unsigned long int return_value_perl_hash_function$1;
  return_value_perl_hash_function$1=perl_hash_function((unsigned char *)new_state->key, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  _Bool return_value_fc_solve_hash_insert$2;
  return_value_fc_solve_hash_insert$2=fc_solve_hash_insert(&instance->hash, (void *)(struct fcs_state_keyval_pair_struct *)new_state->key, &existing_void, (const signed int)return_value_perl_hash_function$1);
  if(!(return_value_fc_solve_hash_insert$2 == (_Bool)0))
  {
    FCS_STATE_keyval_pair_to_kv(existing_state_raw, (struct fcs_state_keyval_pair_struct *)existing_void);
    return (_Bool)0;
  }

  else
  {
    on_state_new(instance, hard_thread, new_state->val);
    return (_Bool)1;
  }
}

// fc_solve_check_state_validity
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1036
static inline signed int fc_solve_check_state_validity(struct fcs_state_keyval_pair_struct *state_pair, signed int freecells_num, signed int stacks_num, signed int decks_num, char *misplaced_card)
{
  signed int cards[4l][14l];
  signed int c;
  signed int s;
  signed int d;
  signed int f;
  signed int col_len;
  struct fcs_struct_state_t *state;
  char *col;
  char card;
  state = &state_pair->$anon0.$anon0.s;
  d = 0;
  for( ; !(d >= 4); d = d + 1)
  {
    c = 1;
    for( ; !(c >= 14); c = c + 1)
      cards[(signed long int)d][(signed long int)c] = 0;
  }
  d = 0;
  for( ; !(d >= 4 * decks_num); d = d + 1)
  {
    c = 1;
    for( ; (signed int)state->foundations[(signed long int)d] >= c; c = c + 1)
      cards[(signed long int)(d % 4)][(signed long int)c] = cards[(signed long int)(d % 4)][(signed long int)c] + 1;
  }
  f = 0;
  for( ; !(f >= freecells_num); f = f + 1)
  {
    card = state->freecells[(signed long int)f];
    if(!((signed int)card >> 2 == 0))
      cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] = cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] + 1;

  }
  s = 0;
  for( ; !(s >= stacks_num); s = s + 1)
  {
    col = state->stacks[(signed long int)s];
    col_len = (signed int)col[(signed long int)0];
    c = 0;
    for( ; !(c >= col_len); c = c + 1)
    {
      card = col[(signed long int)(c + 1)];
      if((signed int)card >> 2 == 0)
      {
        *misplaced_card = (char)0;
        return 3;
      }

      cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] = cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] + 1;
    }
  }
  signed int suit_idx = 0;
  for( ; !(suit_idx >= 4); suit_idx = suit_idx + 1)
  {
    signed int rank = 1;
    for( ; !(rank >= 14); rank = rank + 1)
      if(!(cards[(signed long int)suit_idx][(signed long int)rank] == decks_num))
      {
        *misplaced_card=fcs_make_card$link1(rank, suit_idx);
        return cards[(signed long int)suit_idx][(signed long int)rank] < decks_num ? 1 : 2;
      }

  }
  return 0;
}

// fc_solve_compact_allocator_extend
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 57
extern void fc_solve_compact_allocator_extend(struct anonymous$5 *allocator)
{
  char *new_data;
  new_data=meta_request_new_buffer(allocator->meta);
  *((char **)new_data) = allocator->old_list;
  allocator->old_list = new_data;
  allocator->rollback_ptr = (char *)&((char **)new_data)[(signed long int)1];
  allocator->ptr = allocator->rollback_ptr;
  allocator->max_ptr = new_data + (signed long int)(64 * 1024 - (256 + 128));
}

// fc_solve_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 113
extern void fc_solve_compact_allocator_finish(struct anonymous$5 *allocator)
{
  char *iter;
  char *iter_next;
  struct anonymous$10 *meta = allocator->meta;
  iter = allocator->old_list;
  iter_next = *((char **)iter);
  for( ; !(iter_next == ((char *)NULL)); iter_next = *((char **)iter))
  {
    *((char **)iter) = meta->recycle_bin;
    meta->recycle_bin = iter;
    iter = iter_next;
  }
  *((char **)iter) = meta->recycle_bin;
  meta->recycle_bin = iter;
}

// fc_solve_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 81
extern void fc_solve_compact_allocator_init(struct anonymous$5 *allocator, struct anonymous$10 *meta_allocator)
{
  allocator->meta = meta_allocator;
  fc_solve_compact_allocator_init_helper$link1(allocator);
}

// fc_solve_compact_allocator_init_helper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper(struct anonymous$5 *allocator)
{
  allocator->old_list = (char *)(void *)0;
  fc_solve_compact_allocator_extend(allocator);
}

// fc_solve_compact_allocator_init_helper$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper$link1(struct anonymous$5 *allocator$link1)
{
  allocator$link1->old_list = (char *)(void *)0;
  fc_solve_compact_allocator_extend(allocator$link1);
}

// fc_solve_compact_allocator_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 130
static inline void fc_solve_compact_allocator_recycle(struct anonymous$5 *allocator)
{
  fc_solve_compact_allocator_finish(allocator);
  fc_solve_compact_allocator_init_helper(allocator);
}

// fc_solve_derived_states_list_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 340
extern void fc_solve_derived_states_list_add_state(struct anonymous$12 *list, struct fcs_state_keyval_pair_struct *state, signed int context)
{
  if((list->num_states + (signed int)!(list->states == ((struct anonymous$38 *)NULL)) & 16) == 0)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)list->states, sizeof(struct anonymous$38) /*16ul*/  * (unsigned long int)(list->num_states + (signed int)(list->states != (struct anonymous$38 *)(void *)0) + 16));
    list->states = (struct anonymous$38 *)return_value_realloc$1;
  }

  (list->states + (signed long int)list->num_states)->state_ptr = state;
  signed int tmp_post$2 = list->num_states;
  list->num_states = list->num_states + 1;
  (list->states + (signed long int)tmp_post$2)->context.i = context;
}

// fc_solve_finish_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1028
extern void fc_solve_finish_instance(struct fc_solve_instance_struct * const instance)
{
  fc_solve_hash_free(&instance->hash);
  fc_solve_hash_free(&instance->stacks_hash);
  instance->num_states_in_collection = (signed long int)0;
  clean_soft_dfs(instance);
}

// fc_solve_foreach_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 240
extern void fc_solve_foreach_soft_thread(struct fc_solve_instance_struct * const instance, const signed int callback_choice, void * const context)
{
  signed int ht_idx = 0;
  for( ; instance->num_hard_threads >= ht_idx; ht_idx = ht_idx + 1)
  {
    struct fc_solve_hard_thread_struct *hard_thread;
    if(!(ht_idx >= instance->num_hard_threads))
      hard_thread = &instance->hard_threads[(signed long int)ht_idx];

    else
      if(!(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL)))
        hard_thread = instance->optimization_thread;

      else
        break;
    struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
    struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
    for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
      switch(callback_choice)
      {
        case 0:
        {
          soft_thread_clean_soft_dfs(soft_thread);
          break;
        }
        case 1:
        {
          free_instance_soft_thread_callback(soft_thread);
          break;
        }
        case 2:
        {
          accumulate_tests_order(soft_thread, context);
          break;
        }
        case 3:
          determine_scan_completeness(soft_thread, context);
      }
  }
}

// fc_solve_free_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1830
static inline void fc_solve_free_instance(struct fc_solve_instance_struct *instance)
{
  fc_solve_foreach_soft_thread(instance, 1, (void *)0);
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
    free_instance_hard_thread_callback(hard_thread);
  free((void *)instance->hard_threads);
  if(!(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL)))
  {
    free_instance_hard_thread_callback(instance->optimization_thread);
    free((void *)instance->optimization_thread);
  }

  fc_solve_free_tests_order$link1(&instance->instance_tests_order);
  if(!((8 & (signed int)instance->runtime_flags) == 0))
    fc_solve_free_tests_order$link1(&instance->opt_tests_order);

  free((void *)instance);
}

// fc_solve_free_soft_thread_by_depth_test_array
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 160
extern void fc_solve_free_soft_thread_by_depth_test_array(struct fc_solve_soft_thread_struct * const soft_thread)
{
  signed int depth_idx = 0;
  for( ; !(depth_idx >= soft_thread->by_depth_tests_order.num); depth_idx = depth_idx + 1)
    fc_solve_free_tests_order(&(soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order);
  soft_thread->by_depth_tests_order.num = 0;
  free((void *)soft_thread->by_depth_tests_order.by_depth_tests);
  soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous$21 *)(void *)0;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_free_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order(struct anonymous$9 *tests_order)
{
  signed int group_idx = 0;
  for( ; !(group_idx >= tests_order->num_groups); group_idx = group_idx + 1)
    free((void *)(tests_order->groups + (signed long int)group_idx)->tests);
  free((void *)tests_order->groups);
  tests_order->groups = (struct anonymous$20 *)(void *)0;
  tests_order->num_groups = 0;
}

// fc_solve_free_tests_order$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order$link1(struct anonymous$9 *tests_order$link1)
{
  signed int group_idx$link1 = 0;
  for( ; !(group_idx$link1 >= tests_order$link1->num_groups); group_idx$link1 = group_idx$link1 + 1)
    free((void *)(tests_order$link1->groups + (signed long int)group_idx$link1)->tests);
  free((void *)tests_order$link1->groups);
  tests_order$link1->groups = (struct anonymous$20 *)(void *)0;
  tests_order$link1->num_groups = 0;
}

// fc_solve_free_tests_order$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order$link2(struct anonymous$9 *tests_order$link2)
{
  signed int group_idx$link2 = 0;
  for( ; !(group_idx$link2 >= tests_order$link2->num_groups); group_idx$link2 = group_idx$link2 + 1)
    free((void *)(tests_order$link2->groups + (signed long int)group_idx$link2)->tests);
  free((void *)tests_order$link2->groups);
  tests_order$link2->groups = (struct anonymous$20 *)(void *)0;
  tests_order$link2->num_groups = 0;
}

// fc_solve_get_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 63
extern signed int fc_solve_get_preset_by_name(const char *name, const struct anonymous$36 **preset_ptr)
{
  signed int preset_id;
  preset_id=fcs_get_preset_id_by_name(name);
  if(preset_id >= 0)
  {
    signed int return_value_fcs_get_preset_by_id$1;
    return_value_fcs_get_preset_by_id$1=fcs_get_preset_by_id(preset_id, preset_ptr);
    return return_value_fcs_get_preset_by_id$1;
  }

  else
    return 1;
}

// fc_solve_get_the_positions_by_rank_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 54
extern char * fc_solve_get_the_positions_by_rank_data(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key, char * (*generator)(struct fc_solve_soft_thread_struct *, const struct fcs_struct_state_t *))
{
  char **positions_by_rank_location;
  positions_by_rank_location=fc_solve_calc_positions_by_rank_location(soft_thread);
  if(*positions_by_rank_location == ((char *)NULL))
    *positions_by_rank_location=generator(soft_thread, ptr_state_key);

  return *positions_by_rank_location;
}

// fc_solve_get_the_positions_by_rank_data__freecell_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 49
extern char * fc_solve_get_the_positions_by_rank_data__freecell_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key)
{
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const struct anonymous$14 game_params = instance->game_params;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  char *positions_by_rank;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(13 * (2 << 3)));
  positions_by_rank = (char *)return_value_malloc$1;
  memset((void *)positions_by_rank, -1, sizeof(char) /*1ul*/  * (unsigned long int)(13 * (2 << 3)));
  signed int ds = 0;
  signed int tmp_post$2;
  for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
  {
    const char * const dest_col = ptr_state_key->stacks[(signed long int)ds];
    signed int top_card_idx = (signed int)dest_col[(signed long int)0];
    tmp_post$2 = top_card_idx;
    top_card_idx = top_card_idx - 1;
    if(!(tmp_post$2 == 0))
    {
      char dest_card;
      char dest_below_card;
      dest_card = dest_col[(signed long int)(0 + 1)];
      signed int dc = 0;
      for( ; !(dc >= top_card_idx); dest_card = dest_below_card)
      {
        dest_below_card = dest_col[(signed long int)(dc + 1 + 1)];
        if(!(((signed int)dest_below_card >> 2) + 1 == (signed int)dest_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)dest_below_card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)dest_below_card) == (1 & (signed int)dest_card))))
          assign_dest_stack_and_col_ptr(positions_by_rank, ds, dc, dest_card);

        dc = dc + 1;
      }
      assign_dest_stack_and_col_ptr(positions_by_rank, ds, top_card_idx, dest_card);
    }

  }
  return positions_by_rank;
}

// fc_solve_hash_foreach
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 195
static inline void fc_solve_hash_foreach(struct anonymous$41 * const hash, _Bool (*should_delete_ptr)(void *, void *), void * const context)
{
  const signed int size = hash->size;
  signed int i = 0;
  for( ; !(i >= size); i = i + 1)
  {
    struct fc_solve_hash_symlink_item_struct **item = &(hash->entries + (signed long int)i)->first_item;
    if(!(*item == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
    {
      _Bool return_value;
      return_value=should_delete_ptr((*item)->key, context);
      if(!(return_value == (_Bool)0))
      {
        struct fc_solve_hash_symlink_item_struct *next_item = (*item)->next;
        (*item)->next = hash->list_of_vacant_items;
        hash->list_of_vacant_items = *item;
        *item = next_item;
        hash->num_elems = hash->num_elems - 1l;
      }

      else
        item = &(*item)->next;
    }

  }
}

// fc_solve_hash_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 185
static inline void fc_solve_hash_free(struct anonymous$41 * const hash)
{
  fc_solve_compact_allocator_finish(&hash->allocator);
  free((void *)hash->entries);
  hash->entries = (struct anonymous$54 *)(void *)0;
}

// fc_solve_hash_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 118
static inline void fc_solve_hash_init(struct anonymous$10 * const meta_alloc, struct anonymous$41 * const hash, const enum FCS_INLINED_HASH_DATA_TYPE hash_type)
{
  hash->size = 2048;
  hash->size_bitmask = 2048 - 1;
  hash->max_num_elems_before_resize = (signed long int)(2048 << 1);
  hash->num_elems = (signed long int)0;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)2048, sizeof(struct anonymous$54) /*8ul*/ );
  hash->entries = (struct anonymous$54 *)return_value_calloc$1;
  hash->list_of_vacant_items = (struct fc_solve_hash_symlink_item_struct *)(void *)0;
  hash->hash_type = hash_type;
  fc_solve_compact_allocator_init(&hash->allocator, meta_alloc);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// fc_solve_hash_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 170
extern _Bool fc_solve_hash_insert(struct anonymous$41 * const hash, void * const key, void ** const existing_key, const signed int hash_value)
{
  const enum FCS_INLINED_HASH_DATA_TYPE hash_type = hash->hash_type;
  struct anonymous$54 * const list = hash->entries + (signed long int)(hash_value & hash->size_bitmask);
  struct fc_solve_hash_symlink_item_struct **item_placeholder;
  signed int tmp_if_expr$3;
  signed int return_value_fc_solve_stack_compare_for_comparison$1;
  signed int return_value_fc_solve_state_compare$2;
  if(list->first_item == ((struct fc_solve_hash_symlink_item_struct *)NULL))
    item_placeholder = &list->first_item;

  else
  {
    struct fc_solve_hash_symlink_item_struct *item = list->first_item;
    struct fc_solve_hash_symlink_item_struct *last_item = (struct fc_solve_hash_symlink_item_struct *)(void *)0;
    while(!(item == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
    {
      if(item->hash_value == hash_value)
      {
        if((signed int)hash_type == FCS_INLINED_HASH__COLUMNS)
        {
          return_value_fc_solve_stack_compare_for_comparison$1=fc_solve_stack_compare_for_comparison$link1(item->key, key);
          tmp_if_expr$3 = return_value_fc_solve_stack_compare_for_comparison$1;
        }

        else
        {
          return_value_fc_solve_state_compare$2=fc_solve_state_compare(item->key, key);
          tmp_if_expr$3 = return_value_fc_solve_state_compare$2;
        }
        if(tmp_if_expr$3 == 0)
        {
          *existing_key = item->key;
          return (_Bool)1;
        }

      }

      last_item = item;
      item = item->next;
    }
    item_placeholder = &last_item->next;
  }
  struct fc_solve_hash_symlink_item_struct *fc_solve_hash_insert$$1$$item;
  if(!(hash->list_of_vacant_items == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
  {
    fc_solve_hash_insert$$1$$item = hash->list_of_vacant_items;
    hash->list_of_vacant_items = fc_solve_hash_insert$$1$$item->next;
  }

  else
  {
    void *return_value_fcs_compact_alloc_ptr$4;
    return_value_fcs_compact_alloc_ptr$4=fcs_compact_alloc_ptr$link3(&hash->allocator, (signed int)sizeof(struct fc_solve_hash_symlink_item_struct) /*24ul*/ );
    fc_solve_hash_insert$$1$$item = (struct fc_solve_hash_symlink_item_struct *)return_value_fcs_compact_alloc_ptr$4;
  }
  *item_placeholder = fc_solve_hash_insert$$1$$item;
  fc_solve_hash_insert$$1$$item->key = key;
  fc_solve_hash_insert$$1$$item->hash_value = hash_value;
  fc_solve_hash_insert$$1$$item->next = (struct fc_solve_hash_symlink_item_struct *)(void *)0;
  hash->num_elems = hash->num_elems + 1l;
  if(!(hash->max_num_elems_before_resize >= hash->num_elems))
    fc_solve_hash_rehash(hash);

  *existing_key = (void *)0;
  return (_Bool)0;
}

// fc_solve_hash_rehash
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.c line 192
static inline void fc_solve_hash_rehash(struct anonymous$41 * const hash)
{
  const signed int old_size = hash->size;
  const signed int new_size = old_size << 1;
  if(!(new_size >= old_size))
    hash->max_num_elems_before_resize = 9223372036854775807L;

  else
  {
    const signed int new_size_bitmask = new_size - 1;
    struct anonymous$54 *new_entries;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)new_size, sizeof(struct anonymous$54) /*8ul*/ );
    new_entries = (struct anonymous$54 *)return_value_calloc$1;
    signed int i = 0;
    for( ; !(i >= old_size); i = i + 1)
    {
      struct fc_solve_hash_symlink_item_struct *item = (hash->entries + (signed long int)i)->first_item;
      while(!(item == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
      {
        const signed int place = item->hash_value & new_size_bitmask;
        struct fc_solve_hash_symlink_item_struct * const next_item = item->next;
        item->next = (new_entries + (signed long int)place)->first_item;
        (new_entries + (signed long int)place)->first_item = item;
        item = next_item;
      }
    }
    free((void *)hash->entries);
    hash->entries = new_entries;
    hash->size = new_size;
    hash->size_bitmask = new_size_bitmask;
    hash->max_num_elems_before_resize = (signed long int)(new_size << 1);
  }
}

// fc_solve_increase_dfs_max_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 929
extern void fc_solve_increase_dfs_max_depth(struct fc_solve_soft_thread_struct *soft_thread)
{
  const signed int new_dfs_max_depth = soft_thread->method_specific.soft_dfs.dfs_max_depth + 16;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)soft_thread->method_specific.soft_dfs.soft_dfs_info, sizeof(struct anonymous$50) /*64ul*/  * (unsigned long int)new_dfs_max_depth);
  soft_thread->method_specific.soft_dfs.soft_dfs_info = (struct anonymous$50 *)return_value_realloc$1;
  struct anonymous$50 *soft_dfs_info = soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)soft_thread->method_specific.soft_dfs.dfs_max_depth;
  struct anonymous$50 * const end_soft_dfs_info = soft_dfs_info + (signed long int)16;
  for( ; !(soft_dfs_info >= end_soft_dfs_info); soft_dfs_info = soft_dfs_info + 1l)
  {
    soft_dfs_info->state = (struct fcs_state_keyval_pair_struct *)(void *)0;
    soft_dfs_info->tests_list_index = 0;
    soft_dfs_info->test_index = 0;
    soft_dfs_info->current_state_index = 0;
    soft_dfs_info->derived_states_list.num_states = 0;
    soft_dfs_info->derived_states_list.states = (struct anonymous$38 *)(void *)0;
    soft_dfs_info->derived_states_random_indexes = (struct anonymous$29 *)(void *)0;
    soft_dfs_info->derived_states_random_indexes_max_size = 0;
    soft_dfs_info->positions_by_rank = (char *)(void *)0;
  }
  soft_thread->method_specific.soft_dfs.dfs_max_depth = new_dfs_max_depth;
}

// fc_solve_init_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 557
extern void fc_solve_init_instance(struct fc_solve_instance_struct *instance)
{
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
  {
    if(!(hard_thread->prelude_as_string == ((char *)NULL)))
    {
      if(hard_thread->prelude == ((struct anonymous$42 *)NULL))
        compile_prelude(hard_thread);

    }

    hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->soft_threads + (signed long int)0)->num_checked_states_step;
  }
  signed int total_tests = 0;
  fc_solve_foreach_soft_thread(instance, 2, (void *)&total_tests);
  fc_solve_foreach_soft_thread(instance, 3, (void *)&total_tests);
  signed int tmp_post$2;
  if((8 & (signed int)instance->runtime_flags) == 0)
  {
    signed int num_tests = 0;
    signed int *tests;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(signed int) /*4ul*/  * sizeof(signed int) /*4ul*/  * (unsigned long int)8);
    tests = (signed int *)return_value_malloc$1;
    signed int bit_idx = 0;
    for( ; !(total_tests == 0); total_tests = total_tests >> 1)
    {
      if(!((0x1 & total_tests) == 0))
      {
        tmp_post$2 = num_tests;
        num_tests = num_tests + 1;
        tests[(signed long int)tmp_post$2] = bit_idx;
      }

      bit_idx = bit_idx + 1;
    }
    void *return_value_realloc$3;
    return_value_realloc$3=realloc((void *)tests, sizeof(signed int) /*4ul*/  * (unsigned long int)((num_tests & ~(16 - 1)) + 16));
    tests = (signed int *)return_value_realloc$3;
    instance->opt_tests_order.num_groups = 1;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct anonymous$20) /*232ul*/  * (unsigned long int)16);
    instance->opt_tests_order.groups = (struct anonymous$20 *)return_value_malloc$4;
    (instance->opt_tests_order.groups + (signed long int)0)->tests = tests;
    (instance->opt_tests_order.groups + (signed long int)0)->num = num_tests;
    (instance->opt_tests_order.groups + (signed long int)0)->shuffling_type = (enum anonymous$26)FCS_NO_SHUFFLING;
    instance->runtime_flags = instance->runtime_flags | (unsigned char)8;
  }

}

// fc_solve_init_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 494
static inline void fc_solve_init_locs(struct anonymous$7 *locs)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    locs->stack_locs[(signed long int)i] = (char)i;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    locs->fc_locs[(signed long int)i] = (char)i;
}

// fc_solve_initial_user_state_to_c_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 793
static inline signed int fc_solve_initial_user_state_to_c_proto(const char *string, struct fcs_state_keyval_pair_struct *out_state, signed int freecells_num, signed int stacks_num, signed int decks_num, char *indirect_stacks_buffer)
{
  signed int s;
  signed int c;
  const char *str;
  char card;
  char *col;
  signed int first_line;
  const char * const *prefix;
  signed int decks_index[4l];
  fc_solve_state_init_proto(out_state, stacks_num, indirect_stacks_buffer);
  str = string;
  first_line = 1;
  s = 0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$10;
  signed int tmp_if_expr$12;
  signed int return_value_fc_solve_u2p_rank$11;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  char tmp_post$15;
  for( ; !(s >= stacks_num); s = s + 1)
  {
    if(first_line == 0)
    {
      for( ; !((signed int)*str == 10); str = str + 1l)
        if((signed int)*str == 0)
          return 1;

      str = str + 1l;
    }

    first_line = 0;
    prefix = fc_solve_freecells_prefixes;
    for( ; !(*prefix == ((const char *)NULL)); prefix = prefix + 1l)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(*prefix);
      signed int return_value_strncasecmp$3;
      return_value_strncasecmp$3=strncasecmp(str, *prefix, return_value_strlen$2);
      if(return_value_strncasecmp$3 == 0)
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(*prefix);
        str = str + (signed long int)return_value_strlen$1;
        break;
      }

    }
    if(!(*prefix == ((const char *)NULL)))
    {
      c = 0;
      for( ; !(c >= freecells_num); c = c + 1)
        out_state->$anon0.$anon0.s.freecells[(signed long int)c] = (char)0;
      c = 0;
      for( ; !(c >= freecells_num); c = c + 1)
      {
        if(!(c == 0))
        {
          for( ; !((signed int)*str == 32); str = str + 1l)
          {
            if((signed int)*str == 9)
              break;

            if((signed int)*str == 10)
              break;

            if((signed int)*str == 13)
              break;

            if((signed int)*str == 0)
              return 1;

          }
          if((signed int)*str == 10)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            break;

          str = str + 1l;
        }

        for( ; (_Bool)1; str = str + 1l)
          if(!((signed int)*str == 32))
          {
            if(!((signed int)*str == 9))
              goto __CPROVER_DUMP_L19;

          }


      __CPROVER_DUMP_L19:
        ;
        if((signed int)*str == 13)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)*str == 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          break;

        if((signed int)*str == 42)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*str == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          card = (char)0;

        else
          card=fc_solve_card_user2perl(str);
        out_state->$anon0.$anon0.s.freecells[(signed long int)c] = card;
      }
      for( ; !((signed int)*str == 10); str = str + 1l)
        if((signed int)*str == 0)
          return 1;

      s = s - 1;
    }

    else
    {
      prefix = fc_solve_foundations_prefixes;
      for( ; !(*prefix == ((const char *)NULL)); prefix = prefix + 1l)
      {
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(*prefix);
        signed int return_value_strncasecmp$9;
        return_value_strncasecmp$9=strncasecmp(str, *prefix, return_value_strlen$8);
        if(return_value_strncasecmp$9 == 0)
        {
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(*prefix);
          str = str + (signed long int)return_value_strlen$7;
          break;
        }

      }
      if(!(*prefix == ((const char *)NULL)))
      {
        signed int d = 0;
        for( ; !(d >= 4 * decks_num); d = d + 1)
          out_state->$anon0.$anon0.s.foundations[(signed long int)d] = (char)0;
        d = 0;
        for( ; !(d >= 4); d = d + 1)
          decks_index[(signed long int)d] = 0;
        while((_Bool)1)
        {
          for( ; (_Bool)1; str = str + 1l)
            if(!((signed int)*str == 32))
            {
              if(!((signed int)*str == 9))
                goto __CPROVER_DUMP_L39;

            }


        __CPROVER_DUMP_L39:
          ;
          if((signed int)*str == 10)
            tmp_if_expr$10 = (_Bool)1;

          else
            tmp_if_expr$10 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$10)
            break;

          d=fc_solve_u2p_suit(str);
          str = str + 1l;
          for( ; (signed int)*str == 45; str = str + 1l)
            ;
          if((signed int)*str == 48)
            tmp_if_expr$12 = 0;

          else
          {
            return_value_fc_solve_u2p_rank$11=fc_solve_u2p_rank(str);
            tmp_if_expr$12 = return_value_fc_solve_u2p_rank$11;
          }
          c = tmp_if_expr$12;
          for( ; !((signed int)*str == 32); str = str + 1l)
          {
            if((signed int)*str == 9)
              break;

            if((signed int)*str == 10)
              break;

            if((signed int)*str == 13)
              break;

            if((signed int)*str == 0)
              return 1;

          }
          out_state->$anon0.$anon0.s.foundations[(signed long int)(decks_index[(signed long int)d] * 4 + d)] = (char)c;
          decks_index[(signed long int)d] = decks_index[(signed long int)d] + 1;
          if(decks_index[(signed long int)d] >= decks_num)
            decks_index[(signed long int)d] = 0;

        }
        s = s - 1;
        goto __CPROVER_DUMP_L65;
      }

      if((signed int)*str == 58)
        str = str + 1l;

      col = out_state->$anon0.$anon0.s.stacks[(signed long int)s];
      c = 0;
      for( ; !(c >= 8); c = c + 1)
      {
        if(!(c == 0))
        {
          for( ; !((signed int)*str == 32); str = str + 1l)
          {
            if((signed int)*str == 9)
              break;

            if((signed int)*str == 10)
              break;

            if((signed int)*str == 13)
              break;

            if((signed int)*str == 0)
              return 1;

          }
          if((signed int)*str == 10)
            tmp_if_expr$13 = (_Bool)1;

          else
            tmp_if_expr$13 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$13)
            break;

        }

        for( ; (_Bool)1; str = str + 1l)
          if(!((signed int)*str == 32))
          {
            if(!((signed int)*str == 9))
              goto __CPROVER_DUMP_L61;

          }


      __CPROVER_DUMP_L61:
        ;
        if((signed int)*str == 0)
          return 1;

        if((signed int)*str == 10)
          tmp_if_expr$14 = (_Bool)1;

        else
          tmp_if_expr$14 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$14)
          break;

        card=fc_solve_card_user2perl(str);
        tmp_post$15 = col[(signed long int)0];
        col[(signed long int)0] = col[(signed long int)0] + 1;
        col[(signed long int)((signed int)tmp_post$15 + 1)] = card;
      }
    }

  __CPROVER_DUMP_L65:
    ;
  }
  return 0;
}

// fc_solve_initialize_befs_rater
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$15 *weighting)
{
  double * const befs_weights = weighting->befs_weights;
  double normalized_befs_weights[6l];
  double sum = (double)0;
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    if(befs_weights[(signed long int)i] < 0.000000)
      befs_weights[(signed long int)i] = fc_solve_default_befs_weights[(signed long int)i];

    sum = sum + befs_weights[(signed long int)i];
  }
  if(sum < 1e-6)
    sum = (double)1;

  signed int fc_solve_initialize_befs_rater$$1$$3$$i = 0;
  for( ; !(fc_solve_initialize_befs_rater$$1$$3$$i >= 6); fc_solve_initialize_befs_rater$$1$$3$$i = fc_solve_initialize_befs_rater$$1$$3$$i + 1)
  {
    befs_weights[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i] = befs_weights[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i] / sum;
    normalized_befs_weights[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i] = befs_weights[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i] * (double)0x7fffffff;
  }
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const struct anonymous$14 game_params = instance->game_params;
  _Bool bool_unlimited_sequence_move = (_Bool)((signed int)instance->game_params.game_flags & 1 << 4);
  double num_cards_out_factor = normalized_befs_weights[(signed long int)0] / (double)((signed int)game_params.decks_num * 52);
  double out_sum = 0.0;
  signed int fc_solve_initialize_befs_rater$$1$$4$$i = 0;
  for( ; !(fc_solve_initialize_befs_rater$$1$$4$$i >= 14); out_sum = out_sum + num_cards_out_factor)
  {
    weighting->num_cards_out_lookup_table[(signed long int)fc_solve_initialize_befs_rater$$1$$4$$i] = out_sum;
    fc_solve_initialize_befs_rater$$1$$4$$i = fc_solve_initialize_befs_rater$$1$$4$$i + 1;
  }
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(((signed int)instance->game_params.game_flags >> 2 & 0x3) == 0)
  {
    if(!(bool_unlimited_sequence_move == (_Bool)0))
      tmp_if_expr$1 = (signed int)game_params.freecells_num + (signed int)instance->game_params.stacks_num;

    else
      tmp_if_expr$1 = (signed int)game_params.freecells_num + 1 << (signed int)instance->game_params.stacks_num;
    tmp_if_expr$2 = tmp_if_expr$1;
  }

  else
    tmp_if_expr$2 = bool_unlimited_sequence_move != (_Bool)0 ? (signed int)game_params.freecells_num : 1;
  weighting->max_sequence_move_factor = normalized_befs_weights[(signed long int)1] / (double)tmp_if_expr$2;
  weighting->cards_under_sequences_factor = normalized_befs_weights[(signed long int)2] / soft_thread->initial_cards_under_sequences_value;
  weighting->seqs_over_renegade_cards_factor = normalized_befs_weights[(signed long int)3] / fc_solve_seqs_over_cards_lookup[(signed long int)((signed int)game_params.decks_num * 13 * 4)];
  weighting->depth_factor = normalized_befs_weights[(signed long int)4] / (double)20000;
  weighting->num_cards_not_on_parents_factor = normalized_befs_weights[(signed long int)5] / (double)((signed int)game_params.decks_num * 52);
  _Bool tmp_if_expr$3;
  if(IEEE_FLOAT_NOTEQUAL(weighting->max_sequence_move_factor, 0.000000))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = IEEE_FLOAT_NOTEQUAL(weighting->cards_under_sequences_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = IEEE_FLOAT_NOTEQUAL(weighting->seqs_over_renegade_cards_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  weighting->should_go_over_stacks = tmp_if_expr$4;
}

// fc_solve_initialize_befs_rater$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater$link1(struct fc_solve_soft_thread_struct * const soft_thread$link1, struct anonymous$15 *weighting$link1)
{
  double * const befs_weights$link1 = weighting$link1->befs_weights;
  double normalized_befs_weights$link1[6l];
  double sum$link1 = (double)0;
  signed int fc_solve_initialize_befs_rater$$1$$1$$i$link1 = 0;
  for( ; !(fc_solve_initialize_befs_rater$$1$$1$$i$link1 >= 6); fc_solve_initialize_befs_rater$$1$$1$$i$link1 = fc_solve_initialize_befs_rater$$1$$1$$i$link1 + 1)
  {
    if(befs_weights$link1[(signed long int)fc_solve_initialize_befs_rater$$1$$1$$i$link1] < 0.000000)
      befs_weights$link1[(signed long int)fc_solve_initialize_befs_rater$$1$$1$$i$link1] = fc_solve_default_befs_weights[(signed long int)fc_solve_initialize_befs_rater$$1$$1$$i$link1];

    sum$link1 = sum$link1 + befs_weights$link1[(signed long int)fc_solve_initialize_befs_rater$$1$$1$$i$link1];
  }
  if(sum$link1 < 1e-6)
    sum$link1 = (double)1;

  signed int fc_solve_initialize_befs_rater$$1$$3$$i$link1 = 0;
  for( ; !(fc_solve_initialize_befs_rater$$1$$3$$i$link1 >= 6); fc_solve_initialize_befs_rater$$1$$3$$i$link1 = fc_solve_initialize_befs_rater$$1$$3$$i$link1 + 1)
  {
    befs_weights$link1[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i$link1] = befs_weights$link1[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i$link1] / sum$link1;
    normalized_befs_weights$link1[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i$link1] = befs_weights$link1[(signed long int)fc_solve_initialize_befs_rater$$1$$3$$i$link1] * (double)0x7fffffff;
  }
  struct fc_solve_hard_thread_struct * const hard_thread$link1 = soft_thread$link1->hard_thread;
  struct fc_solve_instance_struct * const instance$link1 = hard_thread$link1->instance;
  const struct anonymous$14 game_params$link1 = instance$link1->game_params;
  _Bool bool_unlimited_sequence_move$link1 = (_Bool)((signed int)instance$link1->game_params.game_flags & 1 << 4);
  double num_cards_out_factor$link1 = normalized_befs_weights$link1[(signed long int)0] / (double)((signed int)game_params$link1.decks_num * 52);
  double out_sum$link1 = 0.0;
  signed int i$link1 = 0;
  for( ; !(i$link1 >= 14); out_sum$link1 = out_sum$link1 + num_cards_out_factor$link1)
  {
    weighting$link1->num_cards_out_lookup_table[(signed long int)i$link1] = out_sum$link1;
    i$link1 = i$link1 + 1;
  }
  signed int tmp_if_expr$2$link1;
  signed int tmp_if_expr$1$link1;
  if(((signed int)instance$link1->game_params.game_flags >> 2 & 0x3) == 0)
  {
    if(!(bool_unlimited_sequence_move$link1 == (_Bool)0))
      tmp_if_expr$1$link1 = (signed int)game_params$link1.freecells_num + (signed int)instance$link1->game_params.stacks_num;

    else
      tmp_if_expr$1$link1 = (signed int)game_params$link1.freecells_num + 1 << (signed int)instance$link1->game_params.stacks_num;
    tmp_if_expr$2$link1 = tmp_if_expr$1$link1;
  }

  else
    tmp_if_expr$2$link1 = bool_unlimited_sequence_move$link1 != (_Bool)0 ? (signed int)game_params$link1.freecells_num : 1;
  weighting$link1->max_sequence_move_factor = normalized_befs_weights$link1[(signed long int)1] / (double)tmp_if_expr$2$link1;
  weighting$link1->cards_under_sequences_factor = normalized_befs_weights$link1[(signed long int)2] / soft_thread$link1->initial_cards_under_sequences_value;
  weighting$link1->seqs_over_renegade_cards_factor = normalized_befs_weights$link1[(signed long int)3] / fc_solve_seqs_over_cards_lookup[(signed long int)((signed int)game_params$link1.decks_num * 13 * 4)];
  weighting$link1->depth_factor = normalized_befs_weights$link1[(signed long int)4] / (double)20000;
  weighting$link1->num_cards_not_on_parents_factor = normalized_befs_weights$link1[(signed long int)5] / (double)((signed int)game_params$link1.decks_num * 52);
  _Bool tmp_if_expr$3$link1;
  if(IEEE_FLOAT_NOTEQUAL(weighting$link1->max_sequence_move_factor, 0.000000))
    tmp_if_expr$3$link1 = (_Bool)1;

  else
    tmp_if_expr$3$link1 = IEEE_FLOAT_NOTEQUAL(weighting$link1->cards_under_sequences_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4$link1;
  if(tmp_if_expr$3$link1)
    tmp_if_expr$4$link1 = (_Bool)1;

  else
    tmp_if_expr$4$link1 = IEEE_FLOAT_NOTEQUAL(weighting$link1->seqs_over_renegade_cards_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  weighting$link1->should_go_over_stacks = tmp_if_expr$4$link1;
}

// fc_solve_initialize_bfs_queue
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 1540
static inline void fc_solve_initialize_bfs_queue(struct fc_solve_soft_thread_struct *soft_thread)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  void *return_value_fcs_compact_alloc_ptr$1;
  return_value_fcs_compact_alloc_ptr$1=fcs_compact_alloc_ptr$link2(&hard_thread->allocator, (signed int)sizeof(struct fcs_states_linked_list_item_struct) /*16ul*/ );
  soft_thread->method_specific.befs.meth.brfs.bfs_queue = (struct fcs_states_linked_list_item_struct *)return_value_fcs_compact_alloc_ptr$1;
  void *return_value_fcs_compact_alloc_ptr$2;
  return_value_fcs_compact_alloc_ptr$2=fcs_compact_alloc_ptr$link2(&hard_thread->allocator, (signed int)sizeof(struct fcs_states_linked_list_item_struct) /*16ul*/ );
  soft_thread->method_specific.befs.meth.brfs.bfs_queue->next = (struct fcs_states_linked_list_item_struct *)return_value_fcs_compact_alloc_ptr$2;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item = soft_thread->method_specific.befs.meth.brfs.bfs_queue->next;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item->next = (struct fcs_states_linked_list_item_struct *)(void *)0;
  soft_thread->method_specific.befs.meth.brfs.recycle_bin = (struct fcs_states_linked_list_item_struct *)(void *)0;
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// fc_solve_instance__init_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 357
extern void fc_solve_instance__init_hard_thread(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread)
{
  hard_thread->instance = instance;
  hard_thread->num_soft_threads = 0;
  hard_thread->soft_threads = (struct fc_solve_soft_thread_struct *)(void *)0;
  fc_solve_new_soft_thread(hard_thread);
  hard_thread->num_checked_states_step = (signed long int)50;
  hard_thread->prelude_as_string = (char *)(void *)0;
  hard_thread->prelude = (struct anonymous$42 *)(void *)0;
  hard_thread->prelude_num_items = (signed long int)0;
  hard_thread->prelude_idx = 0;
  fc_solve_reset_hard_thread(hard_thread);
  fc_solve_compact_allocator_init(&hard_thread->allocator, instance->meta_alloc);
  hard_thread->reusable_move_stack.num_moves = (unsigned short int)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)16);
  hard_thread->reusable_move_stack.moves = (struct anonymous$4 *)return_value_malloc$1;
}

// fc_solve_instance__recycle_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1730
static inline void fc_solve_instance__recycle_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread)
{
  fc_solve_reset_hard_thread$link1(hard_thread);
  fc_solve_compact_allocator_recycle(&hard_thread->allocator);
  struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
  struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
  for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
  {
    fc_solve_PQueueFree$link1(&soft_thread->method_specific.befs.meth.befs.pqueue);
    fc_solve_reset_soft_thread$link1(soft_thread);
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_instance_get_first_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1630
static inline struct fc_solve_soft_thread_struct * fc_solve_instance_get_first_soft_thread(struct fc_solve_instance_struct *instance)
{
  return &(instance->hard_threads + (signed long int)0)->soft_threads[(signed long int)0];
}

// fc_solve_meta_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 77
extern void fc_solve_meta_compact_allocator_finish(struct anonymous$10 *meta_allocator)
{
  char *iter;
  char *iter_next;
  iter = meta_allocator->recycle_bin;
  char *tmp_if_expr$1;
  if(!(iter == ((char *)NULL)))
    tmp_if_expr$1 = *((char **)iter);

  else
    tmp_if_expr$1 = (char *)(void *)0;
  iter_next = tmp_if_expr$1;
  for( ; !(iter_next == ((char *)NULL)); iter_next = *((char **)iter))
  {
    free((void *)iter);
    iter = iter_next;
  }
  free((void *)iter);
  meta_allocator->recycle_bin = (char *)(void *)0;
}

// fc_solve_meta_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 70
static inline void fc_solve_meta_compact_allocator_init(struct anonymous$10 *meta)
{
  meta->recycle_bin = (char *)(void *)0;
}

// fc_solve_move_sequence_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function(struct anonymous$6 * const new_state_kv_ptr, struct anonymous$3 * const moves, const signed int dest_idx, const signed int source_idx, const signed int start, const signed int end)
{
  char *new_src_col = new_state_kv_ptr->key->stacks[(signed long int)source_idx];
  char *new_dest_col = new_state_kv_ptr->key->stacks[(signed long int)dest_idx];
  signed int fc_solve_move_sequence_function$$1$$1$$i = start;
  char tmp_post$1;
  for( ; end >= fc_solve_move_sequence_function$$1$$1$$i; fc_solve_move_sequence_function$$1$$1$$i = fc_solve_move_sequence_function$$1$$1$$i + 1)
  {
    tmp_post$1 = new_dest_col[(signed long int)0];
    new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
    new_dest_col[(signed long int)((signed int)tmp_post$1 + 1)] = new_src_col[(signed long int)(fc_solve_move_sequence_function$$1$$1$$i + 1)];
  }
  signed int i = start;
  for( ; end >= i; i = i + 1)
  {
    new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
    new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
  }
  fcs_move_stack_params_push(moves, 0, source_idx, dest_idx, (end - start) + 1);
}

// fc_solve_move_sequence_function$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function$link1(struct anonymous$6 * const new_state_kv_ptr$link1, struct anonymous$3 * const moves$link1, const signed int dest_idx$link1, const signed int source_idx$link1, const signed int start$link1, const signed int end$link1)
{
  char *new_src_col$link1 = new_state_kv_ptr$link1->key->stacks[(signed long int)source_idx$link1];
  char *new_dest_col$link1 = new_state_kv_ptr$link1->key->stacks[(signed long int)dest_idx$link1];
  signed int i$link1 = start$link1;
  char tmp_post$1$link1;
  for( ; end$link1 >= i$link1; i$link1 = i$link1 + 1)
  {
    tmp_post$1$link1 = new_dest_col$link1[(signed long int)0];
    new_dest_col$link1[(signed long int)0] = new_dest_col$link1[(signed long int)0] + 1;
    new_dest_col$link1[(signed long int)((signed int)tmp_post$1$link1 + 1)] = new_src_col$link1[(signed long int)(i$link1 + 1)];
  }
  signed int fc_solve_move_sequence_function$$1$$2$$i$link1 = start$link1;
  for( ; end$link1 >= fc_solve_move_sequence_function$$1$$2$$i$link1; fc_solve_move_sequence_function$$1$$2$$i$link1 = fc_solve_move_sequence_function$$1$$2$$i$link1 + 1)
  {
    new_src_col$link1[(signed long int)0] = new_src_col$link1[(signed long int)0] - 1;
    new_src_col$link1[(signed long int)((signed int)new_src_col$link1[(signed long int)0] + 1)] = (char)0;
  }
  fcs_move_stack_params_push$link1(moves$link1, 0, source_idx$link1, dest_idx$link1, (end$link1 - start$link1) + 1);
}

// fc_solve_move_stack_compact_allocate
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous$3 * fc_solve_move_stack_compact_allocate(struct fc_solve_hard_thread_struct *hard_thread, struct anonymous$3 *old_move_stack_to_parent)
{
  char *ptr;
  struct anonymous$3 *new_move_stack_to_parent;
  struct anonymous$4 *new_moves_to_parent;
  void *return_value_fcs_compact_alloc_ptr$1;
  return_value_fcs_compact_alloc_ptr$1=fcs_compact_alloc_ptr(&hard_thread->allocator, (signed int)(sizeof(struct anonymous$3) /*16ul*/  + sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent->num_moves));
  ptr = (char *)return_value_fcs_compact_alloc_ptr$1;
  new_move_stack_to_parent = (struct anonymous$3 *)ptr;
  new_moves_to_parent = (struct anonymous$4 *)(ptr + (signed long int)sizeof(struct anonymous$3) /*16ul*/ );
  new_move_stack_to_parent->moves = new_moves_to_parent;
  new_move_stack_to_parent->num_moves = old_move_stack_to_parent->num_moves;
  memcpy((void *)new_moves_to_parent, (const void *)old_move_stack_to_parent->moves, sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent->num_moves);
  return new_move_stack_to_parent;
}

// fc_solve_move_stack_compact_allocate$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous$3 * fc_solve_move_stack_compact_allocate$link1(struct fc_solve_hard_thread_struct *hard_thread$link1, struct anonymous$3 *old_move_stack_to_parent$link1)
{
  char *ptr$link1;
  struct anonymous$3 *new_move_stack_to_parent$link1;
  struct anonymous$4 *new_moves_to_parent$link1;
  void *return_value_fcs_compact_alloc_ptr$1$link1;
  return_value_fcs_compact_alloc_ptr$1$link1=fcs_compact_alloc_ptr$link2(&hard_thread$link1->allocator, (signed int)(sizeof(struct anonymous$3) /*16ul*/  + sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent$link1->num_moves));
  ptr$link1 = (char *)return_value_fcs_compact_alloc_ptr$1$link1;
  new_move_stack_to_parent$link1 = (struct anonymous$3 *)ptr$link1;
  new_moves_to_parent$link1 = (struct anonymous$4 *)(ptr$link1 + (signed long int)sizeof(struct anonymous$3) /*16ul*/ );
  new_move_stack_to_parent$link1->moves = new_moves_to_parent$link1;
  new_move_stack_to_parent$link1->num_moves = old_move_stack_to_parent$link1->num_moves;
  memcpy((void *)new_moves_to_parent$link1, (const void *)old_move_stack_to_parent$link1->moves, sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent$link1->num_moves);
  return new_move_stack_to_parent$link1;
}

// fc_solve_move_stack_normalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 156
static inline void fc_solve_move_stack_normalize(struct anonymous$3 *moves, struct anonymous$6 *init_state, struct anonymous$7 *locs, signed int freecells_num, signed int stacks_num, signed int decks_num)
{
  struct anonymous$4 in_move;
  struct fcs_state_keyval_pair_struct s_and_info;
  char indirect_stacks_buffer[1280l];
  signed int i;
  struct anonymous$6 dynamic_state;
  FCS_STATE_keyval_pair_to_kv$link1(&dynamic_state, &s_and_info);
  struct anonymous$4 out_move = fc_solve_empty_move;
  *(&dynamic_state)->key = *init_state->key;
  *(&dynamic_state)->val = *init_state->val;
  (&dynamic_state)->val->stacks_copy_on_write_flags = 0;
  i = 0;
  for( ; !(i >= stacks_num); i = i + 1)
    if((dynamic_state.val->stacks_copy_on_write_flags & 1 << i) == 0)
    {
      char *copy_stack_col;
      dynamic_state.val->stacks_copy_on_write_flags = dynamic_state.val->stacks_copy_on_write_flags | 1 << i;
      copy_stack_col = dynamic_state.key->stacks[(signed long int)i];
      memcpy((void *)&indirect_stacks_buffer[(signed long int)(i << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      dynamic_state.key->stacks[(signed long int)i] = &indirect_stacks_buffer[(signed long int)(i << 7)];
    }

  struct anonymous$3 temp_moves;
  temp_moves.num_moves = (unsigned short int)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)16);
  temp_moves.moves = (struct anonymous$4 *)return_value_malloc$1;
  _Bool return_value_fc_solve_move_stack_pop$2;
  do
  {
    return_value_fc_solve_move_stack_pop$2=fc_solve_move_stack_pop(moves, &in_move);
    if(!((signed int)return_value_fc_solve_move_stack_pop$2 == 0))
      break;

    fc_solve_apply_move(&dynamic_state, locs, in_move, freecells_num, stacks_num, decks_num);
    const signed int move_type = (const signed int)in_move.c[(signed long int)0];
    if(!(move_type == 12))
    {
      out_move.c[(signed long int)0] = (unsigned char)move_type;
      if(move_type == 0 || move_type == 1 || move_type == 4 || move_type == 11)
        out_move.c[(signed long int)1] = (unsigned char)locs->stack_locs[(signed long int)(signed int)in_move.c[(signed long int)1]];

      else
        if(move_type == 2 || move_type == 3 || move_type == 5)
          out_move.c[(signed long int)1] = (unsigned char)locs->fc_locs[(signed long int)(signed int)in_move.c[(signed long int)1]];

      if(move_type == 0 || move_type == 2)
        out_move.c[(signed long int)2] = (unsigned char)locs->stack_locs[(signed long int)(signed int)in_move.c[(signed long int)2]];

      else
        if(move_type == 1 || move_type == 3)
          out_move.c[(signed long int)2] = (unsigned char)locs->fc_locs[(signed long int)(signed int)in_move.c[(signed long int)2]];

        else
          if(move_type == 4 || move_type == 5 || move_type == 11)
            out_move.c[(signed long int)2] = (unsigned char)in_move.c[(signed long int)2];

      if(move_type == 0)
        out_move.c[(signed long int)3] = (unsigned char)in_move.c[(signed long int)3];

      fcs_move_stack_push$link2(&temp_moves, out_move);
    }

  }
  while((_Bool)1);
  moves->num_moves = (unsigned short int)0;
  fc_solve_move_stack_swallow_stack(moves, &temp_moves);
  free((void *)temp_moves.moves);
}

// fc_solve_move_stack_pop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 97
static inline _Bool fc_solve_move_stack_pop(struct anonymous$3 *stack, struct anonymous$4 *move)
{
  if((signed int)stack->num_moves >= 1)
  {
    stack->num_moves = stack->num_moves - 1;
    *move = stack->moves[(signed long int)stack->num_moves];
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// fc_solve_move_stack_swallow_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 144
static inline void fc_solve_move_stack_swallow_stack(struct anonymous$3 *stack, struct anonymous$3 *src_stack)
{
  struct anonymous$4 move;
  _Bool return_value_fc_solve_move_stack_pop$1;
  do
  {
    return_value_fc_solve_move_stack_pop$1=fc_solve_move_stack_pop(src_stack, &move);
    if(return_value_fc_solve_move_stack_pop$1 != (_Bool)0)
      break;

    fcs_move_stack_push$link2(stack, move);
  }
  while((_Bool)1);
}

// fc_solve_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 305
static inline char * fc_solve_move_to_string(struct anonymous$4 move, signed int standard_notation)
{
  char *return_value_fc_solve_move_to_string_w_state$1;
  return_value_fc_solve_move_to_string_w_state$1=fc_solve_move_to_string_w_state((struct fcs_state_keyval_pair_struct *)(void *)0, 4, 8, 1, move, standard_notation == 2 ? 1 : standard_notation);
  return return_value_fc_solve_move_to_string_w_state$1;
}

// fc_solve_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 296
extern char * fc_solve_move_to_string_w_state(struct fcs_state_keyval_pair_struct *state, signed int freecells_num, signed int stacks_num, signed int decks_num, struct anonymous$4 move, signed int standard_notation)
{
  char string[256l];
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  switch((signed int)move.c[(signed long int)0])
  {
    case 0:
    {
      if(standard_notation == 2)
        tmp_if_expr$1 = (signed int)move.c[(signed long int)3] > 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (signed int)(&state->$anon0.$anon0.s)->stacks[(signed long int)move.c[(signed long int)2]][(signed long int)0] == (signed int)move.c[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        sprintf(string, "%i%iv%x", 1 + (signed int)move.c[(signed long int)1], 1 + (signed int)move.c[(signed long int)2], move.c[(signed long int)3]);

      else
        if(!(standard_notation == 0))
          sprintf(string, "%i%i", 1 + (signed int)move.c[(signed long int)1], 1 + (signed int)move.c[(signed long int)2]);

        else
          sprintf(string, "Move %i cards from stack %i to stack %i", move.c[(signed long int)3], move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 2:
    {
      if(!(standard_notation == 0))
      {
        signed int return_value_convert_freecell_num$3;
        return_value_convert_freecell_num$3=convert_freecell_num((signed int)move.c[(signed long int)1]);
        sprintf(string, "%c%i", 97 + return_value_convert_freecell_num$3, 1 + (signed int)move.c[(signed long int)2]);
      }

      else
        sprintf(string, "Move a card from freecell %i to stack %i", move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 3:
    {
      if(!(standard_notation == 0))
      {
        char src_c;
        signed int return_value_convert_freecell_num$4;
        return_value_convert_freecell_num$4=convert_freecell_num((signed int)move.c[(signed long int)1]);
        src_c = (char)(97 + (signed int)(char)return_value_convert_freecell_num$4);
        char dest_c;
        signed int return_value_convert_freecell_num$5;
        return_value_convert_freecell_num$5=convert_freecell_num((signed int)move.c[(signed long int)2]);
        dest_c = (char)(97 + (signed int)(char)return_value_convert_freecell_num$5);
        sprintf(string, "%c%c", src_c, dest_c);
      }

      else
        sprintf(string, "Move a card from freecell %i to freecell %i", move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 1:
    {
      if(!(standard_notation == 0))
      {
        signed int return_value_convert_freecell_num$6;
        return_value_convert_freecell_num$6=convert_freecell_num((signed int)move.c[(signed long int)2]);
        sprintf(string, "%i%c", 1 + (signed int)move.c[(signed long int)1], 97 + return_value_convert_freecell_num$6);
      }

      else
        sprintf(string, "Move a card from stack %i to freecell %i", move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 4:
    {
      if(!(standard_notation == 0))
        sprintf(string, "%ih", 1 + (signed int)move.c[(signed long int)1]);

      else
        sprintf(string, "Move a card from stack %i to the foundations", move.c[(signed long int)1]);
      break;
    }
    case 5:
    {
      if(!(standard_notation == 0))
      {
        signed int return_value_convert_freecell_num$7;
        return_value_convert_freecell_num$7=convert_freecell_num((signed int)move.c[(signed long int)1]);
        sprintf(string, "%ch", 97 + return_value_convert_freecell_num$7);
      }

      else
        sprintf(string, "Move a card from freecell %i to the foundations", move.c[(signed long int)1]);
      break;
    }
    case 11:
    {
      if(!(standard_notation == 0))
        sprintf(string, "%ih", move.c[(signed long int)1]);

      else
        sprintf(string, "Move the sequence on top of Stack %i to the foundations", move.c[(signed long int)1]);
      break;
    }
    default:
      string[(signed long int)0] = (char)0;
  }
  char *return_value_strdup$8;
  return_value_strdup$8=strdup(string);
  return return_value_strdup$8;
}

// fc_solve_moves_processed_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 80
static inline void fc_solve_moves_processed_free(struct anonymous$40 *moves)
{
  free((void *)moves->moves);
  moves->moves = (struct anonymous$53 *)(void *)0;
}

// fc_solve_moves_processed_gen
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 123
extern void fc_solve_moves_processed_gen(struct anonymous$40 * const ret, struct fcs_state_keyval_pair_struct * const orig, const signed int num_freecells, const struct anonymous$11 * const moves_seq)
{
  struct fcs_state_keyval_pair_struct pos_proto;
  char indirect_stacks_buffer[1280l];
  struct anonymous$6 orig_pass;
  orig_pass.key = &orig->$anon0.$anon0.s;
  orig_pass.val = &orig->$anon0.$anon0.info;
  struct anonymous$6 pos_pass;
  pos_pass.key = &pos_proto.$anon0.$anon0.s;
  pos_pass.val = &pos_proto.$anon0.$anon0.info;
  *(&pos_pass)->key = *(&orig_pass)->key;
  *(&pos_pass)->val = *(&orig_pass)->val;
  (&pos_pass)->val->stacks_copy_on_write_flags = 0;
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    if((pos_proto.$anon0.$anon0.info.stacks_copy_on_write_flags & 1 << i) == 0)
    {
      char *copy_stack_col;
      pos_proto.$anon0.$anon0.info.stacks_copy_on_write_flags = pos_proto.$anon0.$anon0.info.stacks_copy_on_write_flags | 1 << i;
      copy_stack_col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)i];
      memcpy((void *)&indirect_stacks_buffer[(signed long int)(i << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      pos_proto.$anon0.$anon0.s.stacks[(signed long int)i] = &indirect_stacks_buffer[(signed long int)(i << 7)];
    }

  signed int virtual_stack_len[8l];
  signed int virtual_freecell_len[12l];
  signed int fc_solve_moves_processed_gen$$1$$i;
  signed int j;
  signed int move_idx;
  signed int num_back_end_moves;
  struct anonymous$4 move;
  struct anonymous$4 out_move;
  struct anonymous$4 *next_move_ptr;
  num_back_end_moves = moves_seq->num_moves;
  next_move_ptr = moves_seq->moves;
  ret->num_moves = 0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$53) /*5ul*/  * (unsigned long int)32);
  ret->moves = (struct anonymous$53 *)return_value_malloc$1;
  ret->next_move_idx = 0;
  fc_solve_moves_processed_gen$$1$$i = 0;
  for( ; !(fc_solve_moves_processed_gen$$1$$i >= 8); fc_solve_moves_processed_gen$$1$$i = fc_solve_moves_processed_gen$$1$$i + 1)
  {
    char *fc_solve_moves_processed_gen$$1$$3$$1$$col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)fc_solve_moves_processed_gen$$1$$i];
    virtual_stack_len[(signed long int)fc_solve_moves_processed_gen$$1$$i] = (signed int)fc_solve_moves_processed_gen$$1$$3$$1$$col[(signed long int)0];
  }
  fc_solve_moves_processed_gen$$1$$i = 0;
  for( ; !(fc_solve_moves_processed_gen$$1$$i >= num_freecells); fc_solve_moves_processed_gen$$1$$i = fc_solve_moves_processed_gen$$1$$i + 1)
    virtual_freecell_len[(signed long int)fc_solve_moves_processed_gen$$1$$i] = !((signed int)pos_proto.$anon0.$anon0.s.freecells[(signed long int)fc_solve_moves_processed_gen$$1$$i] >> 2 == 0) ? 1 : 0;
  move_idx = 0;
  struct anonymous$4 *tmp_post$2;
  char tmp_post$3;
  signed int tmp_if_expr$4;
  char tmp_post$5;
  for( ; !(move_idx >= num_back_end_moves); move_idx = move_idx + 1)
  {
    while((_Bool)1)
    {
      fc_solve_moves_processed_gen$$1$$i = 0;
      for( ; !(fc_solve_moves_processed_gen$$1$$i >= 8); fc_solve_moves_processed_gen$$1$$i = fc_solve_moves_processed_gen$$1$$i + 1)
      {
        signed int rank;
        signed int suit;
        char card;
        char *fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)fc_solve_moves_processed_gen$$1$$i];
        if((signed int)*fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col >= 1)
        {
          card = fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col[(signed long int)(((signed int)fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col[(signed long int)0] - 1) + 1)];
          rank = (signed int)card >> 2;
          suit = (signed int)card & 0x03;
          if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)(0x1 ^ suit)] >= rank + -2)
          {
            if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)(3 ^ suit)] >= rank + -2)
            {
              if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)(0x2 ^ suit)] >= rank + -3)
              {
                if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)suit] == rank + -1)
                {
                  pos_proto.$anon0.$anon0.s.foundations[(signed long int)suit] = pos_proto.$anon0.$anon0.s.foundations[(signed long int)suit] + 1;
                  fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col[(signed long int)0] = fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col[(signed long int)0] - 1;
                  fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col[(signed long int)((signed int)fc_solve_moves_processed_gen$$1$$5$$1$$1$$1$$1$$col[(signed long int)0] + 1)] = (char)0;
                  break;
                }

              }

            }

          }

        }

      }
      if(fc_solve_moves_processed_gen$$1$$i >= 8)
      {
        j = 0;
        for( ; !(j >= num_freecells); j = j + 1)
        {
          signed int fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$rank;
          signed int fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit;
          char fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$card;
          if(!((signed int)pos_proto.$anon0.$anon0.s.freecells[(signed long int)j] >> 2 == 0))
          {
            fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$card = pos_proto.$anon0.$anon0.s.freecells[(signed long int)j];
            fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$rank = (signed int)fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$card >> 2;
            fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit = (signed int)fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$card & 0x03;
            if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)(0x1 ^ fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit)] >= fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$rank + -2)
            {
              if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)(3 ^ fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit)] >= fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$rank + -2)
              {
                if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)(0x2 ^ fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit)] >= fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$rank + -3)
                {
                  if((signed int)pos_proto.$anon0.$anon0.s.foundations[(signed long int)fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit] == fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$rank + -1)
                  {
                    pos_proto.$anon0.$anon0.s.foundations[(signed long int)fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit] = pos_proto.$anon0.$anon0.s.foundations[(signed long int)fc_solve_moves_processed_gen$$1$$5$$1$$1$$3$$1$$suit] + 1;
                    pos_proto.$anon0.$anon0.s.freecells[(signed long int)j] = (char)0;
                    break;
                  }

                }

              }

            }

          }

        }
        if(fc_solve_moves_processed_gen$$1$$i == 8 && j == num_freecells)
          break;

      }

    }
    tmp_post$2 = next_move_ptr;
    next_move_ptr = next_move_ptr + 1l;
    move = *tmp_post$2;
    signed int src;
    signed int dest;
    char fc_solve_moves_processed_gen$$1$$5$$1$$2$$card;
    switch((signed int)move.c[(signed long int)0])
    {
      case 4:
      {
        src = (signed int)move.c[(signed long int)1];
        char *fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)src];
        /* assertion virtual_stack_len[src] >= ( ((col)[0]) ) */
        assert(virtual_stack_len[(signed long int)src] >= (signed int)fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col[(signed long int)0]);
        if(virtual_stack_len[(signed long int)src] == (signed int)*fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col)
        {
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$card = fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col[(signed long int)(((signed int)fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col[(signed long int)0] - 1) + 1)];
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col[(signed long int)0] = fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col[(signed long int)0] - 1;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col[(signed long int)((signed int)fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$col[(signed long int)0] + 1)] = (char)0;
          pos_proto.$anon0.$anon0.s.foundations[(signed long int)((signed int)fc_solve_moves_processed_gen$$1$$5$$1$$2$$card & 0x03)] = pos_proto.$anon0.$anon0.s.foundations[(signed long int)((signed int)fc_solve_moves_processed_gen$$1$$5$$1$$2$$card & 0x03)] + 1;
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - 1;
          struct anonymous$53 fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$1$$2$$ext_move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$1$$2$$ext_move.move = move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$1$$2$$ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$1$$1$$2$$ext_move);
        }

        else
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - 1;
        break;
      }
      case 5:
      {
        src = (signed int)move.c[(signed long int)1];
        /* assertion (virtual_freecell_len[src] == 1) */
        assert(virtual_freecell_len[(signed long int)src] == 1);
        if(!((signed int)pos_proto.$anon0.$anon0.s.freecells[(signed long int)src] >> 2 == 0))
        {
          struct anonymous$53 fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$2$$2$$1$$ext_move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$2$$2$$1$$ext_move.move = move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$2$$2$$1$$ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$2$$2$$1$$ext_move);
          pos_proto.$anon0.$anon0.s.foundations[(signed long int)((signed int)pos_proto.$anon0.$anon0.s.freecells[(signed long int)src] & 0x03)] = pos_proto.$anon0.$anon0.s.foundations[(signed long int)((signed int)pos_proto.$anon0.$anon0.s.freecells[(signed long int)src] & 0x03)] + 1;
          pos_proto.$anon0.$anon0.s.freecells[(signed long int)src] = (char)0;
        }

        virtual_freecell_len[(signed long int)src] = 0;
        break;
      }
      case 2:
      {
        src = (signed int)move.c[(signed long int)1];
        dest = (signed int)move.c[(signed long int)2];
        /* assertion virtual_freecell_len[src] == 1 */
        assert(virtual_freecell_len[(signed long int)src] == 1);
        if(!((signed int)pos_proto.$anon0.$anon0.s.freecells[(signed long int)src] >> 2 == 0))
        {
          struct anonymous$53 fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$1$$ext_move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$1$$ext_move.move = move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$1$$ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$1$$ext_move);
          char *fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$dest_col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)dest];
          tmp_post$3 = fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$dest_col[(signed long int)0];
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$dest_col[(signed long int)0] = fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$dest_col[(signed long int)0] + 1;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$3$$2$$dest_col[(signed long int)((signed int)tmp_post$3 + 1)] = pos_proto.$anon0.$anon0.s.freecells[(signed long int)src];
          pos_proto.$anon0.$anon0.s.freecells[(signed long int)src] = (char)0;
        }

        virtual_freecell_len[(signed long int)src] = 0;
        virtual_stack_len[(signed long int)dest] = virtual_stack_len[(signed long int)dest] + 1;
        break;
      }
      case 1:
      {
        src = (signed int)move.c[(signed long int)1];
        dest = (signed int)move.c[(signed long int)2];
        /* assertion virtual_stack_len[src] > 0 */
        assert(virtual_stack_len[(signed long int)src] > 0);
        char *col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)src];
        /* assertion ( ((col)[0]) ) <= virtual_stack_len[src] */
        assert((signed int)col[(signed long int)0] <= virtual_stack_len[(signed long int)src]);
        if((signed int)*col >= virtual_stack_len[(signed long int)src])
        {
          struct anonymous$53 ext_move;
          ext_move.move = move;
          ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, ext_move);
          char temp_card = col[(signed long int)(((signed int)col[(signed long int)0] - 1) + 1)];
          col[(signed long int)0] = col[(signed long int)0] - 1;
          col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
          pos_proto.$anon0.$anon0.s.freecells[(signed long int)dest] = temp_card;
        }

        virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - 1;
        virtual_freecell_len[(signed long int)dest] = 1;
        break;
      }
      case 0:
      {
        src = (signed int)move.c[(signed long int)1];
        dest = (signed int)move.c[(signed long int)2];
        signed int num_cards = (signed int)move.c[(signed long int)3];
        char *src_col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)src];
        char *dest_col = pos_proto.$anon0.$anon0.s.stacks[(signed long int)dest];
        signed int src_len = (signed int)src_col[(signed long int)0];
        /* assertion virtual_stack_len[src] >= src_len */
        assert(virtual_stack_len[(signed long int)src] >= src_len);
        if(!(src_len >= virtual_stack_len[(signed long int)src]))
        {
          signed int virt_num_cards;
          if(!(virtual_stack_len[(signed long int)src] + -src_len >= num_cards))
            tmp_if_expr$4 = virtual_stack_len[(signed long int)src] - src_len;

          else
            tmp_if_expr$4 = num_cards;
          virt_num_cards = tmp_if_expr$4;
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - virt_num_cards;
          virtual_stack_len[(signed long int)dest] = virtual_stack_len[(signed long int)dest] + virt_num_cards;
          num_cards = num_cards - virt_num_cards;
        }

        if(num_cards >= 1)
        {
          out_move.c[(signed long int)0] = (unsigned char)0;
          out_move.c[(signed long int)1] = (unsigned char)src;
          out_move.c[(signed long int)2] = (unsigned char)dest;
          out_move.c[(signed long int)3] = (unsigned char)num_cards;
          struct anonymous$53 fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$5$$2$$1$$ext_move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$5$$2$$1$$ext_move.move = out_move;
          fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$5$$2$$1$$ext_move.to_empty_stack = (signed int)dest_col[(signed long int)0] == 0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen$$1$$5$$1$$2$$1$$5$$2$$1$$ext_move);
          fc_solve_moves_processed_gen$$1$$i = 0;
          for( ; !(fc_solve_moves_processed_gen$$1$$i >= num_cards); fc_solve_moves_processed_gen$$1$$i = fc_solve_moves_processed_gen$$1$$i + 1)
          {
            tmp_post$5 = dest_col[(signed long int)0];
            dest_col[(signed long int)0] = dest_col[(signed long int)0] + 1;
            dest_col[(signed long int)((signed int)tmp_post$5 + 1)] = src_col[(signed long int)(((signed int)src_col[(signed long int)0] - num_cards) + fc_solve_moves_processed_gen$$1$$i + 1)];
          }
          fc_solve_moves_processed_gen$$1$$i = 0;
          for( ; !(fc_solve_moves_processed_gen$$1$$i >= num_cards); fc_solve_moves_processed_gen$$1$$i = fc_solve_moves_processed_gen$$1$$i + 1)
          {
            src_col[(signed long int)0] = src_col[(signed long int)0] - 1;
            src_col[(signed long int)((signed int)src_col[(signed long int)0] + 1)] = (char)0;
          }
          virtual_stack_len[(signed long int)dest] = virtual_stack_len[(signed long int)dest] + num_cards;
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - num_cards;
        }

      }
    }
  }
}

// fc_solve_moves_processed_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 65
static inline signed int fc_solve_moves_processed_get_moves_left(struct anonymous$40 *moves)
{
  return moves->num_moves - moves->next_move_idx;
}

// fc_solve_moves_processed_render_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 46
char * fc_solve_moves_processed_render_move(struct anonymous$53 move, char *string)
{
  _Bool tmp_if_expr$1;
  signed int return_value_Cvtf89$2;
  signed int return_value_Cvtf89$5;
  signed int return_value_Cvtf89$6;
  switch((signed int)move.move.c[(signed long int)0])
  {
    case 0:
    {
      if(!(move.to_empty_stack == (_Bool)0))
        tmp_if_expr$1 = (signed int)move.move.c[(signed long int)3] > 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        sprintf(string, "%i%iv%x", 1 + (signed int)move.move.c[(signed long int)1], 1 + (signed int)move.move.c[(signed long int)2], move.move.c[(signed long int)3]);

      else
        sprintf(string, "%i%i", 1 + (signed int)move.move.c[(signed long int)1], 1 + (signed int)move.move.c[(signed long int)2]);
      break;
    }
    case 2:
    {
      return_value_Cvtf89$2=Cvtf89((signed int)move.move.c[(signed long int)1]);
      sprintf(string, "%c%i", 97 + return_value_Cvtf89$2, 1 + (signed int)move.move.c[(signed long int)2]);
      break;
    }
    case 3:
    {
      char c1;
      char c2;
      signed int return_value_Cvtf89$3;
      return_value_Cvtf89$3=Cvtf89((signed int)move.move.c[(signed long int)1]);
      c1 = (char)(97 + return_value_Cvtf89$3);
      signed int return_value_Cvtf89$4;
      return_value_Cvtf89$4=Cvtf89((signed int)move.move.c[(signed long int)2]);
      c2 = (char)(97 + return_value_Cvtf89$4);
      sprintf(string, "%c%c", c1, c2);
      break;
    }
    case 1:
    {
      return_value_Cvtf89$5=Cvtf89((signed int)move.move.c[(signed long int)2]);
      sprintf(string, "%i%c", 1 + (signed int)move.move.c[(signed long int)1], 97 + return_value_Cvtf89$5);
      break;
    }
    case 4:
    {
      sprintf(string, "%ih", 1 + (signed int)move.move.c[(signed long int)1]);
      break;
    }
    case 5:
    {
      return_value_Cvtf89$6=Cvtf89((signed int)move.move.c[(signed long int)1]);
      sprintf(string, "%ch", 97 + return_value_Cvtf89$6);
      break;
    }
    case 11:
    {
      sprintf(string, "%ih", move.move.c[(signed long int)1]);
      break;
    }
    default:
      string[(signed long int)0] = (char)0;
  }
  unsigned long int return_value_strlen$7;
  return_value_strlen$7=strlen(string);
  return string + (signed long int)return_value_strlen$7;
}

// fc_solve_new_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread(struct fc_solve_instance_struct * const instance)
{
  struct fc_solve_hard_thread_struct *ret;
  if((unsigned long int)instance->next_soft_thread_id == sizeof(unsigned char) * 32 /*32ul*/ )
    return (struct fc_solve_soft_thread_struct *)(void *)0;

  else
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)instance->hard_threads, sizeof(struct fc_solve_hard_thread_struct) /*1440ul*/  * (unsigned long int)(instance->num_hard_threads + 1));
    instance->hard_threads = (struct fc_solve_hard_thread_struct *)return_value_realloc$1;
    struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
    struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
    for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
    {
      struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
      struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
      for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
        soft_thread->hard_thread = hard_thread;
    }
    ret = &instance->hard_threads[(signed long int)instance->num_hard_threads];
    fc_solve_instance__init_hard_thread(instance, ret);
    instance->num_hard_threads = instance->num_hard_threads + 1;
    return &ret->soft_threads[(signed long int)0];
  }
}

// fc_solve_new_hard_thread$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread$link1(struct fc_solve_instance_struct * const instance$link1)
{
  struct fc_solve_hard_thread_struct *ret$link1;
  if((unsigned long int)instance$link1->next_soft_thread_id == sizeof(unsigned char) * 32 /*32ul*/ )
    return (struct fc_solve_soft_thread_struct *)(void *)0;

  else
  {
    void *return_value_realloc$1$link1;
    return_value_realloc$1$link1=realloc((void *)instance$link1->hard_threads, sizeof(struct fc_solve_hard_thread_struct) /*1440ul*/  * (unsigned long int)(instance$link1->num_hard_threads + 1));
    instance$link1->hard_threads = (struct fc_solve_hard_thread_struct *)return_value_realloc$1$link1;
    struct fc_solve_hard_thread_struct *hard_thread$link1 = instance$link1->hard_threads;
    struct fc_solve_hard_thread_struct * const end_hard_thread$link1 = hard_thread$link1 + (signed long int)instance$link1->num_hard_threads;
    for( ; !(hard_thread$link1 >= end_hard_thread$link1); hard_thread$link1 = hard_thread$link1 + 1l)
    {
      struct fc_solve_soft_thread_struct *soft_thread$link1 = hard_thread$link1->soft_threads;
      struct fc_solve_soft_thread_struct * const end_soft_thread$link1 = soft_thread$link1 + (signed long int)hard_thread$link1->num_soft_threads;
      for( ; !(soft_thread$link1 >= end_soft_thread$link1); soft_thread$link1 = soft_thread$link1 + 1l)
        soft_thread$link1->hard_thread = hard_thread$link1;
    }
    ret$link1 = &instance$link1->hard_threads[(signed long int)instance$link1->num_hard_threads];
    fc_solve_instance__init_hard_thread(instance$link1, ret$link1);
    instance$link1->num_hard_threads = instance$link1->num_hard_threads + 1;
    return &ret$link1->soft_threads[(signed long int)0];
  }
}

// fc_solve_new_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1118
extern struct fc_solve_soft_thread_struct * fc_solve_new_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread)
{
  signed int tmp_post$2;
  if((unsigned long int)hard_thread->instance->next_soft_thread_id == sizeof(unsigned char) * 32 /*32ul*/ )
    return (struct fc_solve_soft_thread_struct *)(void *)0;

  else
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)hard_thread->soft_threads, sizeof(struct fc_solve_soft_thread_struct) /*408ul*/  * (unsigned long int)(hard_thread->num_soft_threads + 1));
    hard_thread->soft_threads = (struct fc_solve_soft_thread_struct *)return_value_realloc$1;
    struct fc_solve_soft_thread_struct *ret;
    tmp_post$2 = hard_thread->num_soft_threads;
    hard_thread->num_soft_threads = hard_thread->num_soft_threads + 1;
    ret = &hard_thread->soft_threads[(signed long int)tmp_post$2];
    init_soft_thread(hard_thread, ret);
    return ret;
  }
}

// fc_solve_optimize_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1430
static inline signed int fc_solve_optimize_solution(struct fc_solve_instance_struct *instance)
{
  struct fc_solve_soft_thread_struct *soft_thread;
  struct fc_solve_hard_thread_struct *old_hard_thread;
  struct fc_solve_hard_thread_struct *optimization_thread;
  instance->runtime_flags = instance->runtime_flags | (unsigned char)32;
  if(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct fc_solve_hard_thread_struct) /*1440ul*/  * (unsigned long int)1);
    optimization_thread = (struct fc_solve_hard_thread_struct *)return_value_malloc$1;
    instance->optimization_thread = optimization_thread;
    fc_solve_instance__init_hard_thread(instance, optimization_thread);
    old_hard_thread = instance->current_hard_thread;
    soft_thread = optimization_thread->soft_threads;
    soft_thread->enable_pruning = (old_hard_thread->soft_threads + (signed long int)old_hard_thread->st_idx)->enable_pruning;
  }

  else
  {
    optimization_thread = instance->optimization_thread;
    soft_thread = optimization_thread->soft_threads;
  }
  if(!((8 & (signed int)instance->runtime_flags) == 0))
  {
    if(!(soft_thread->by_depth_tests_order.by_depth_tests == ((struct anonymous$21 *)NULL)))
      fc_solve_free_soft_thread_by_depth_test_array(soft_thread);

    soft_thread->by_depth_tests_order.num = 1;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct anonymous$21) /*24ul*/  * (unsigned long int)1);
    soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous$21 *)return_value_malloc$2;
    (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->max_depth = 0x7fffffff;
    (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order=tests_order_dup$link1(&instance->opt_tests_order);
  }

  soft_thread->method = 4;
  soft_thread->super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_BEFS_BRFS;
  soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)2;
  optimization_thread->num_checked_states_left_for_soft_thread = (signed long int)1000000;
  optimization_thread->max_num_checked_states = (signed long int)0x7fffffff;
  fc_solve_soft_thread_init_befs_or_bfs(soft_thread);
  soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)1;
  instance->runtime_flags = instance->runtime_flags | (unsigned char)2;
  signed int return_value_fc_solve_befs_or_bfs_do_solve$3;
  return_value_fc_solve_befs_or_bfs_do_solve$3=fc_solve_befs_or_bfs_do_solve(soft_thread);
  return return_value_fc_solve_befs_or_bfs_do_solve$3;
}

// fc_solve_p2u_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 181
extern char * fc_solve_p2u_rank(signed int rank_idx, char *str, _Bool *rank_is_null, _Bool t)
{
  char (*card_map_3)[4l] = card_map_3_10;
  if(!(t == (_Bool)0))
    card_map_3 = card_map_3_T;

  if(rank_idx >= 0 && !(rank_idx >= 14))
  {
    strcpy(str, card_map_3[(signed long int)rank_idx]);
    *rank_is_null = rank_idx == 0;
  }

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(card_map_3[(signed long int)0]);
    strncpy(str, card_map_3[(signed long int)0], return_value_strlen$1 + (unsigned long int)1);
    *rank_is_null = (_Bool)1;
  }
  return str;
}

// fc_solve_p2u_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 224
static inline char * fc_solve_p2u_suit(signed int suit, char *str, _Bool rank_is_null)
{
  if(suit == 0)
  {
    if(!(rank_is_null == (_Bool)0))
      strncpy(str, " ", (unsigned long int)2);

    else
      strncpy(str, "H", (unsigned long int)2);
  }

  else
    if(suit == 1)
      strncpy(str, "C", (unsigned long int)2);

    else
      if(suit == 2)
        strncpy(str, "D", (unsigned long int)2);

      else
        if(suit == 3)
          strncpy(str, "S", (unsigned long int)2);

        else
          strncpy(str, " ", (unsigned long int)2);
  return str;
}

// fc_solve_rand_get_random_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 55
static inline signed int fc_solve_rand_get_random_number(signed long int *my_rand)
{
  signed int one;
  signed int two;
  one=fc_solve_rand_rand15(my_rand);
  two=fc_solve_rand_rand15(my_rand);
  return one | two << 15;
}

// fc_solve_rand_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 38
static inline void fc_solve_rand_init(signed long int *my_rand, unsigned int seed)
{
  *my_rand = (signed long int)seed;
}

// fc_solve_rand_rand15
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 43
static inline signed int fc_solve_rand_rand15(signed long int *my_rand)
{
  *my_rand = *my_rand * (signed long int)214013 + (signed long int)2531011;
  return (signed int)(*my_rand >> 16 & (signed long int)0x7fff);
}

// fc_solve_recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1747
static inline void fc_solve_recycle_instance(struct fc_solve_instance_struct * const instance)
{
  signed int ht_idx;
  fc_solve_finish_instance(instance);
  instance->num_checked_states = (signed long int)0;
  instance->num_hard_threads_finished = 0;
  ht_idx = 0;
  for( ; !(ht_idx >= instance->num_hard_threads); ht_idx = ht_idx + 1)
    fc_solve_instance__recycle_hard_thread(&instance->hard_threads[(signed long int)ht_idx]);
  if(!(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL)))
    fc_solve_instance__recycle_hard_thread(instance->optimization_thread);

  instance->runtime_flags = instance->runtime_flags & (unsigned char)~2;
}

// fc_solve_release_tests_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1696
static inline void fc_solve_release_tests_list(struct fc_solve_soft_thread_struct * const soft_thread)
{
  free((void *)soft_thread->method_specific.befs.tests_list);
  soft_thread->method_specific.befs.tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *))(void *)0;
  signed int unit_idx;
  struct anonymous$18 *arr = &soft_thread->method_specific.soft_dfs.tests_by_depth_array;
  unit_idx = 0;
  for( ; !(unit_idx >= arr->num_units); unit_idx = unit_idx + 1)
    if(!((arr->by_depth_units + (signed long int)unit_idx)->tests.lists == ((struct anonymous$17 *)NULL)))
    {
      struct anonymous$17 *lists = (arr->by_depth_units + (signed long int)unit_idx)->tests.lists;
      signed int num_lists = (arr->by_depth_units + (signed long int)unit_idx)->tests.num_lists;
      signed int i = 0;
      for( ; !(i >= num_lists); i = i + 1)
        free((void *)(lists + (signed long int)i)->tests);
      free((void *)lists);
    }

  free((void *)arr->by_depth_units);
  arr->by_depth_units = (struct anonymous$52 *)(void *)0;
}

// fc_solve_reset_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread)
{
  hard_thread->num_checked_states = (signed long int)0;
  hard_thread->max_num_checked_states = (signed long int)0x7fffffff;
  hard_thread->num_soft_threads_finished = 0;
}

// fc_solve_reset_hard_thread$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread$link1(struct fc_solve_hard_thread_struct * const hard_thread$link1)
{
  hard_thread$link1->num_checked_states = (signed long int)0;
  hard_thread$link1->max_num_checked_states = (signed long int)0x7fffffff;
  hard_thread$link1->num_soft_threads_finished = 0;
}

// fc_solve_reset_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread(struct fc_solve_soft_thread_struct * const soft_thread)
{
  soft_thread->runtime_flags = soft_thread->runtime_flags & (unsigned char)~4;
  soft_thread->runtime_flags = soft_thread->runtime_flags & (unsigned char)~1;
}

// fc_solve_reset_soft_thread$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread$link1(struct fc_solve_soft_thread_struct * const soft_thread$link1)
{
  soft_thread$link1->runtime_flags = soft_thread$link1->runtime_flags & (unsigned char)~4;
  soft_thread$link1->runtime_flags = soft_thread$link1->runtime_flags & (unsigned char)~1;
}

// fc_solve_resume_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1499
static inline signed int fc_solve_resume_instance(struct fc_solve_instance_struct *instance)
{
  signed int ret = 5;
  struct fc_solve_hard_thread_struct *hard_thread;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!((2 & (signed int)instance->runtime_flags) == 0))
    ret=fc_solve_befs_or_bfs_do_solve(&instance->optimization_thread->soft_threads[(signed long int)0]);

  else
  {
    struct fc_solve_hard_thread_struct *end_of_hard_threads = instance->hard_threads + (signed long int)instance->num_hard_threads;
    hard_thread = instance->current_hard_thread;
    for( ; !(instance->num_hard_threads_finished >= instance->num_hard_threads); hard_thread = instance->hard_threads)
      for( ; !(hard_thread >= end_of_hard_threads); hard_thread = hard_thread + 1l)
      {
        ret=run_hard_thread(hard_thread);
        if(ret == 0 || ret == 1)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          if(ret == 5)
          {
            if(instance->num_checked_states >= instance->effective_max_num_checked_states)
              tmp_if_expr$1 = (_Bool)1;

            else
              tmp_if_expr$1 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$2 = (_Bool)0;
          tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
          goto end_of_hard_threads_loop;

      }

  end_of_hard_threads_loop:
    ;
    instance->current_hard_thread = hard_thread;
    if(instance->num_hard_threads_finished == instance->num_hard_threads)
      ret = 1;

    if(ret == 0)
      fc_solve_trace_solution(instance);

  }
  if(ret == 0)
  {
    if(!((1 & (signed int)instance->runtime_flags) == 0))
    {
      if((2 & (signed int)instance->runtime_flags) == 0)
        ret=fc_solve_optimize_solution(instance);

      if(ret == 0)
        fc_solve_trace_solution(instance);

    }

  }

  return ret;
}

// fc_solve_set_weights
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights(const char *start_num, double * const befs_weights)
{
  signed int i = 0;
  signed int tmp_post$1;
  for( ; !(i >= 6); i = i + 1)
  {
    for( ; (signed int)*start_num == 44; start_num = start_num + 1l)
      ;
    if(*start_num == 0)
    {
      do
      {
        tmp_post$1 = i;
        i = i + 1;
        befs_weights[(signed long int)tmp_post$1] = 0.0;
      }
      while(!(i >= 6));
      goto __CPROVER_DUMP_L7;
    }

    char *end_num;
    befs_weights[(signed long int)i]=strtod(start_num, &end_num);
    start_num = end_num;
  }

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_set_weights$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights$link1(const char *start_num$link1, double * const befs_weights$link1)
{
  signed int i$link1 = 0;
  signed int tmp_post$1$link1;
  for( ; !(i$link1 >= 6); i$link1 = i$link1 + 1)
  {
    for( ; (signed int)*start_num$link1 == 44; start_num$link1 = start_num$link1 + 1l)
      ;
    if(*start_num$link1 == 0)
    {
      do
      {
        tmp_post$1$link1 = i$link1;
        i$link1 = i$link1 + 1;
        befs_weights$link1[(signed long int)tmp_post$1$link1] = 0.0;
      }
      while(!(i$link1 >= 6));
      goto __CPROVER_DUMP_L7;
    }

    char *end_num$link1;
    befs_weights$link1[(signed long int)i$link1]=strtod(start_num$link1, &end_num$link1);
    start_num$link1 = end_num$link1;
  }

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_sfs_atomic_move_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1582
extern void fc_solve_sfs_atomic_move_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  char tmp_post$1;
  if(!(empty_stacks_fill == 2))
  {
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    if(!((signed int)num_vacant_stacks == 0))
    {
      const struct anonymous$14 game_params = instance->game_params;
      signed int empty_stack_idx = 0;
      for( ; !(empty_stack_idx >= (signed int)game_params.stacks_num); empty_stack_idx = empty_stack_idx + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)empty_stack_idx] == 0)
          break;

      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
      {
        char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
        const signed int cards_num = (const signed int)col[(signed long int)0];
        if(cards_num >= 2)
        {
          const char card = col[(signed long int)((cards_num - 1) + 1)];
          if(empty_stacks_fill == 1 && !((signed int)card >> 2 == 13))
            goto __CPROVER_DUMP_L10;

          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *fc_solve_sfs_atomic_move_card_to_empty_stack$$1$$5$$1$$1$$2$$2$$1$$copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            fc_solve_sfs_atomic_move_card_to_empty_stack$$1$$5$$1$$1$$2$$2$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_atomic_move_card_to_empty_stack$$1$$5$$1$$1$$2$$2$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_atomic_move_card_to_empty_stack$$1$$5$$1$$1$$2$$2$$1$$copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
          new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << empty_stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << empty_stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)empty_stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(empty_stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)empty_stack_idx] = &indirect_stacks_buffer[(signed long int)(empty_stack_idx << 7)];
          }

          char *empty_stack_col = pass_new_state.key->stacks[(signed long int)empty_stack_idx];
          tmp_post$1 = empty_stack_col[(signed long int)0];
          empty_stack_col[(signed long int)0] = empty_stack_col[(signed long int)0] + 1;
          empty_stack_col[(signed long int)((signed int)tmp_post$1 + 1)] = card;
          fcs_push_1card_seq(moves, stack_idx, empty_stack_idx);
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }


      __CPROVER_DUMP_L10:
        ;
      }
      goto __CPROVER_DUMP_L12;
    }

  }


__CPROVER_DUMP_L12:
  ;
}

// fc_solve_sfs_atomic_move_card_to_freecell
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1719
extern void fc_solve_sfs_atomic_move_card_to_freecell(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  if(!((signed int)num_vacant_freecells == 0))
  {
    const signed int num_cards_in_col_threshold = empty_stacks_fill == 2 ? 1 : 0;
    signed int ds = 0;
    for( ; !(ds >= (signed int)game_params.freecells_num); ds = ds + 1)
      if((signed int)raw_ptr_state_raw->key->freecells[(signed long int)ds] >> 2 == 0)
        break;

    signed int stack_idx = 0;
    for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
    {
      char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
      const signed int cards_num = (const signed int)col[(signed long int)0];
      if(!(num_cards_in_col_threshold >= cards_num))
      {
        const char card = col[(signed long int)((cards_num - 1) + 1)];
        fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
        if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
        {
          char *copy_stack_col;
          pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
          copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
          pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
        }

        char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
        new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
        new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
        pass_new_state.key->freecells[(signed long int)ds] = card;
        fcs_move_stack_non_seq_push(moves, 1, stack_idx, ds);
        fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
      }

    }
    goto __CPROVER_DUMP_L8;
  }


__CPROVER_DUMP_L8:
  ;
}

// fc_solve_sfs_atomic_move_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1656
extern void fc_solve_sfs_atomic_move_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  const signed int num_cards_in_col_threshold = empty_stacks_fill == 2 ? 1 : 0;
  signed int stack_idx = 0;
  char tmp_post$1;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(!(num_cards_in_col_threshold >= cards_num))
    {
      const char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int ds = 0;
      for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
        if(!(ds == stack_idx))
        {
          char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
          if((signed int)*dest_col >= 1)
          {
            char dest_card = dest_col[(signed long int)(((signed int)dest_col[(signed long int)0] - 1) + 1)];
            if(((signed int)card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)card) == (1 & (signed int)dest_card)))))
            {
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
              }

              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *fc_solve_sfs_atomic_move_card_to_parent$$1$$2$$1$$1$$1$$1$$2$$1$$1$$3$$1$$copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                fc_solve_sfs_atomic_move_card_to_parent$$1$$2$$1$$1$$1$$1$$2$$1$$1$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_atomic_move_card_to_parent$$1$$2$$1$$1$$1$$1$$2$$1$$1$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_atomic_move_card_to_parent$$1$$2$$1$$1$$1$$1$$2$$1$$1$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
              char *new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
              new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
              new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
              tmp_post$1 = new_dest_col[(signed long int)0];
              new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
              new_dest_col[(signed long int)((signed int)tmp_post$1 + 1)] = card;
              fcs_push_1card_seq(moves, stack_idx, ds);
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }

    }

  }
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L11:
  ;
}

// fc_solve_sfs_atomic_move_freecell_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1827
extern void fc_solve_sfs_atomic_move_freecell_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  char tmp_post$1;
  if(!(empty_stacks_fill == 2))
  {
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    if(!((signed int)num_vacant_stacks == 0))
    {
      signed int ds = 0;
      for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)ds] == 0)
          break;

      signed int fc = 0;
      for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
      {
        const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
        if(!((signed int)card >> 2 == 0) && (!(empty_stacks_fill == 1) || (signed int)card >> 2 == 13))
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
          }

          char *new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          tmp_post$1 = new_dest_col[(signed long int)0];
          new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
          new_dest_col[(signed long int)((signed int)tmp_post$1 + 1)] = card;
          fcs_move_stack_non_seq_push(moves, 2, fc, ds);
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

      }
      goto __CPROVER_DUMP_L10;
    }

  }


__CPROVER_DUMP_L10:
  ;
}

// fc_solve_sfs_atomic_move_freecell_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1777
extern void fc_solve_sfs_atomic_move_freecell_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  signed int fc = 0;
  char tmp_post$1;
  for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
  {
    const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
    if(!((signed int)card >> 2 == 0))
    {
      signed int ds = 0;
      for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
      {
        char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
        if((signed int)*dest_col >= 1)
        {
          char dest_card = dest_col[(signed long int)(((signed int)dest_col[(signed long int)0] - 1) + 1)];
          if(((signed int)card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)card) == (1 & (signed int)dest_card)))))
          {
            fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
            if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
            {
              char *copy_stack_col;
              pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
              copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
              memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
              pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
            }

            char *new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
            pass_new_state.key->freecells[(signed long int)fc] = (char)0;
            tmp_post$1 = new_dest_col[(signed long int)0];
            new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
            new_dest_col[(signed long int)((signed int)tmp_post$1 + 1)] = card;
            fcs_move_stack_non_seq_push(moves, 2, fc, ds);
            fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
          }

        }

      }
    }

  }
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// fc_solve_sfs_check_state_begin
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 63
extern signed int fc_solve_sfs_check_state_begin(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous$6 * const out_new_state_out, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$3 * const moves)
{
  struct fcs_state_keyval_pair_struct *raw_ptr_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  hard_thread->allocated_from_list = instance->list_of_vacant_states != (struct fcs_state_keyval_pair_struct *)(void *)0;
  if(!(hard_thread->allocated_from_list == (_Bool)0))
  {
    raw_ptr_new_state = instance->list_of_vacant_states;
    instance->list_of_vacant_states = instance->list_of_vacant_states->$anon0.$anon0.info.parent;
  }

  else
    raw_ptr_new_state=fcs_state_ia_alloc_into_var(&hard_thread->allocator);
  FCS_STATE_keyval_pair_to_kv$link2(out_new_state_out, raw_ptr_new_state);
  *out_new_state_out->key = *raw_ptr_state_raw->key;
  *out_new_state_out->val = *raw_ptr_state_raw->val;
  out_new_state_out->val->stacks_copy_on_write_flags = 0;
  raw_ptr_new_state->$anon0.$anon0.info.parent = (struct fcs_state_keyval_pair_struct *)raw_ptr_state_raw->key;
  raw_ptr_new_state->$anon0.$anon0.info.moves_to_parent = moves;
  raw_ptr_new_state->$anon0.$anon0.info.depth = raw_ptr_new_state->$anon0.$anon0.info.depth + 1;
  raw_ptr_new_state->$anon0.$anon0.info.visited = (unsigned char)0;
  raw_ptr_new_state->$anon0.$anon0.info.num_active_children = (unsigned short int)0;
  memset((void *)&raw_ptr_new_state->$anon0.$anon0.info.scan_visited, 0, sizeof(unsigned char [4l]) /*4ul*/ );
  moves->num_moves = (unsigned short int)0;
  return 0;
}

// fc_solve_sfs_check_state_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 70
extern void fc_solve_sfs_check_state_end(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$6 * const raw_ptr_new_state_raw, const signed int state_context_value, struct anonymous$3 * const moves, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const unsigned char calc_real_depth = (const unsigned char)((signed int)instance->runtime_flags & 4);
  const unsigned char scans_synergy = (const unsigned char)((signed int)instance->runtime_flags & 64);
  struct anonymous$6 existing_state;
  _Bool return_value_fc_solve_check_and_add_state$3;
  return_value_fc_solve_check_and_add_state$3=fc_solve_check_and_add_state(hard_thread, raw_ptr_new_state_raw, &existing_state);
  signed int return_value_kv_calc_depth$1;
  signed int return_value_kv_calc_depth$2;
  if(return_value_fc_solve_check_and_add_state$3 == (_Bool)0)
  {
    if(!(hard_thread->allocated_from_list == (_Bool)0))
    {
      raw_ptr_new_state_raw->val->parent = instance->list_of_vacant_states;
      instance->list_of_vacant_states = (struct fcs_state_keyval_pair_struct *)raw_ptr_new_state_raw->key;
    }

    else
      (&hard_thread->allocator)->ptr = (&hard_thread->allocator)->rollback_ptr;
    calculate_real_depth((const _Bool)calc_real_depth, (struct fcs_state_keyval_pair_struct *)(&existing_state)->key);
    if(!((32 & (signed int)instance->runtime_flags) == 0))
    {
      return_value_kv_calc_depth$1=kv_calc_depth(&existing_state);
      return_value_kv_calc_depth$2=kv_calc_depth(raw_ptr_state_raw);
      if(!(1 + return_value_kv_calc_depth$2 >= return_value_kv_calc_depth$1))
      {
        existing_state.val->moves_to_parent=fc_solve_move_stack_compact_allocate$link1(hard_thread, moves);
        if((4 & (signed int)existing_state.val->visited) == 0)
        {
          existing_state.val->parent->$anon0.$anon0.info.num_active_children = existing_state.val->parent->$anon0.$anon0.info.num_active_children - 1;
          if((signed int)existing_state.val->parent->$anon0.$anon0.info.num_active_children == 0)
            mark_as_dead_end((const _Bool)scans_synergy, existing_state.val->parent);

          raw_ptr_state_raw->val->num_active_children = raw_ptr_state_raw->val->num_active_children + 1;
        }

        existing_state.val->parent = (struct fcs_state_keyval_pair_struct *)raw_ptr_state_raw->key;
        existing_state.val->depth = raw_ptr_state_raw->val->depth + 1;
      }

    }

    fc_solve_derived_states_list_add_state(derived_states_list, (struct fcs_state_keyval_pair_struct *)(&existing_state)->key, state_context_value);
  }

  else
    fc_solve_derived_states_list_add_state(derived_states_list, (struct fcs_state_keyval_pair_struct *)raw_ptr_new_state_raw->key, state_context_value);
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// fc_solve_sfs_empty_stack_into_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1361
extern void fc_solve_sfs_empty_stack_into_freecells(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  if(!(empty_stacks_fill == 2))
  {
    const struct anonymous$14 game_params = instance->game_params;
    const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    if((signed int)num_vacant_stacks == 0)
    {
      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
      {
        char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
        const signed int cards_num = (const signed int)col[(signed long int)0];
        if((signed int)num_vacant_freecells >= cards_num)
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char * const new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          signed int b = 0;
          signed int c = 0;
          for( ; !(c >= cards_num); b = b + 1)
          {
            for( ; !(b >= (signed int)game_params.freecells_num); b = b + 1)
              if((signed int)pass_new_state.key->freecells[(signed long int)b] >> 2 == 0)
                break;

            char top_card = new_src_col[(signed long int)(((signed int)new_src_col[(signed long int)0] - 1) + 1)];
            new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
            new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
            pass_new_state.key->freecells[(signed long int)b] = top_card;
            fcs_move_stack_non_seq_push(moves, 1, stack_idx, b);
            c = c + 1;
          }
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

      }
    }

    goto __CPROVER_DUMP_L11;
  }


__CPROVER_DUMP_L11:
  ;
}

// fc_solve_sfs_move_cards_to_a_different_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1178
extern void fc_solve_sfs_move_cards_to_a_different_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  const signed int initial_derived_states_num_states = derived_states_list->num_states;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, fc_solve_get_the_positions_by_rank_data__freecell_generator);
  signed int stack_idx = 0;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 2)
    {
      char upper_card = col[(signed long int)((cards_num - 1) + 1)];
      signed int min_card_height;
      char lower_card;
      min_card_height = cards_num - 2;
      for( ; min_card_height >= 0; min_card_height = min_card_height - 1)
      {
        lower_card = col[(signed long int)(min_card_height + 1)];
        if(!(((signed int)upper_card >> 2) + 1 == (signed int)lower_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)upper_card) == (0x03 & (signed int)lower_card) : !((1 & (signed int)upper_card) == (1 & (signed int)lower_card))))
          break;

        upper_card = lower_card;
      }
      min_card_height = min_card_height + 2;
      signed int c = min_card_height;
      for( ; !(c >= cards_num); c = c + 1)
      {
        const char card = col[(signed long int)(c + 1)];
        char *pos_idx_to_check = &positions_by_rank[(signed long int)((2 << 3) * ((signed int)card >> 2))];
        char *last_pos_idx = pos_idx_to_check + (signed long int)(2 << 3);
        pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 0 : (sequences_are_built_by == 1 ? (signed int)card & 0x03 : ((signed int)card & 0x03 ^ 0x1) & 0x2 - 1)) << 1);
        for( ; !(pos_idx_to_check >= last_pos_idx); pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? 4 : 2)) << 1))
        {
          const signed int ds = (const signed int)pos_idx_to_check[(signed long int)0];
          if(!(ds == -1) && !(ds == stack_idx))
          {
            const signed int dc = (const signed int)pos_idx_to_check[(signed long int)1];
            char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            signed int dest_cards_num = (signed int)dest_col[(signed long int)0];
            char dest_card = dest_col[(signed long int)(dc + 1)];
            if(!(1 + dc >= dest_cards_num))
            {
              if(!(((signed int)dest_col[(signed long int)(1 + dc)] >> 2) + 1 == (signed int)dest_card >> 2))
                goto __CPROVER_DUMP_L12;

              if(sequences_are_built_by == 2)
                tmp_if_expr$2 = 1;

              else
              {
                if(sequences_are_built_by == 1)
                  tmp_if_expr$1 = (signed int)(((signed int)dest_col[(signed long int)(dc + 1 + 1)] & 0x03) == ((signed int)dest_card & 0x03));

                else
                  tmp_if_expr$1 = (signed int)(((signed int)dest_col[(signed long int)(dc + 1 + 1)] & 0x03 & 0x1) != ((signed int)dest_card & 0x03 & 0x1));
                tmp_if_expr$2 = tmp_if_expr$1;
              }
              if(tmp_if_expr$2 == 0)
                goto __CPROVER_DUMP_L12;

            }

            else
            {

            __CPROVER_DUMP_L12:
              ;
              signed int num_cards_to_relocate = (dest_cards_num - dc) - 1;
              const signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
              num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
              signed int freestacks_to_fill;
              if(empty_stacks_fill == 0)
              {
                freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
                num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
              }

              else
                freestacks_to_fill = 0;
              if(num_cards_to_relocate == 0)
                tmp_if_expr$3 = (((signed int)instance->game_params.game_flags & 1 << 4) != 0 ? 0x7fffffff : (empty_stacks_fill == 0 ? ((signed int)num_vacant_freecells - freecells_to_fill) + 1 << (signed int)num_vacant_stacks - freestacks_to_fill : ((signed int)num_vacant_freecells - freecells_to_fill) + 1)) >= cards_num - c ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
              {
                signed int cols_indexes[3l];
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                cols_indexes[(signed long int)0] = ds;
                cols_indexes[(signed long int)1] = -1;
                cols_indexes[(signed long int)2] = -1;
                empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, freestacks_to_fill + freecells_to_fill, 0);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *fc_solve_sfs_move_cards_to_a_different_parent$$1$$2$$1$$3$$1$$1$$1$$6$$3$$1$$copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  fc_solve_sfs_move_cards_to_a_different_parent$$1$$2$$1$$3$$1$$1$$1$$6$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_move_cards_to_a_different_parent$$1$$2$$1$$3$$1$$1$$1$$6$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_cards_to_a_different_parent$$1$$2$$1$$3$$1$$1$$1$$6$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                fc_solve_move_sequence_function(&pass_new_state, moves, ds, stack_idx, c, cards_num - 1);
                state_context_value = ((stack_idx << 8 | c) << 8 | ds) << 8 | dc;
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }
          }

        }
      }
    }

  }
  sort_derived_states(derived_states_list, initial_derived_states_num_states);
  goto __CPROVER_DUMP_L25;

__CPROVER_DUMP_L25:
  ;
}

// fc_solve_sfs_move_freecell_cards_on_top_of_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 345
extern void fc_solve_sfs_move_freecell_cards_on_top_of_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int initial_derived_states_num_states = derived_states_list->num_states;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, fc_solve_get_the_positions_by_rank_data__freecell_generator);
  signed int fc = 0;
  char tmp_post$1;
  for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
  {
    char src_card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
    if(!((signed int)src_card >> 2 == 0) && !((signed int)src_card >> 2 == 13))
    {
      char *pos_idx_to_check = &positions_by_rank[(signed long int)((2 << 3) * ((signed int)src_card >> 2))];
      char *last_pos_idx = pos_idx_to_check + (signed long int)(2 << 3);
      pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 0 : (sequences_are_built_by == 1 ? (signed int)src_card & 0x03 : ((signed int)src_card & 0x03 ^ 0x1) & 0x2 - 1)) << 1);
      for( ; !(pos_idx_to_check >= last_pos_idx); pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? 4 : 2)) << 1))
      {
        signed int ds = (signed int)pos_idx_to_check[(signed long int)0];
        if(!(ds == -1))
        {
          signed int dc = (signed int)pos_idx_to_check[(signed long int)1];
          char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
          char dest_card = dest_col[(signed long int)(dc + 1)];
          signed int dest_cards_num = (signed int)dest_col[(signed long int)0];
          _Bool is_seq_in_dest = (_Bool)0;
          if(!(dc >= dest_cards_num + -1))
          {
            char dest_below_card = dest_col[(signed long int)(dc + 1 + 1)];
            if(((signed int)dest_below_card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)dest_below_card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)dest_below_card) == (1 & (signed int)dest_card)))))
              is_seq_in_dest = (_Bool)1;

          }

          if(is_seq_in_dest == (_Bool)0)
          {
            signed int num_cards_to_relocate = (dest_cards_num - dc) - 1;
            signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
            num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
            signed int freestacks_to_fill;
            if(empty_stacks_fill == 0)
            {
              freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
              num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
            }

            else
              freestacks_to_fill = 0;
            if(num_cards_to_relocate == 0)
            {
              signed int cols_indexes[3l];
              char *new_dest_col;
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              cols_indexes[(signed long int)0] = ds;
              cols_indexes[(signed long int)1] = -1;
              cols_indexes[(signed long int)2] = -1;
              empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, (dest_cards_num - dc) - 1, 0);
              new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
              tmp_post$1 = new_dest_col[(signed long int)0];
              new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
              new_dest_col[(signed long int)((signed int)tmp_post$1 + 1)] = src_card;
              pass_new_state.key->freecells[(signed long int)fc] = (char)0;
              fcs_move_stack_non_seq_push(moves, 2, fc, ds);
              state_context_value = ds << 16 | 255 - dc << 8 | fc;
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }

      }
    }

  }
  sort_derived_states(derived_states_list, initial_derived_states_num_states);
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// fc_solve_sfs_move_freecell_cards_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1118
extern void fc_solve_sfs_move_freecell_cards_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  char tmp_post$1;
  if(!(empty_stacks_fill == 2))
  {
    const struct anonymous$14 game_params = instance->game_params;
    if(!(soft_thread->num_vacant_stacks == 0))
    {
      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)stack_idx] == 0)
          break;

      signed int fc = 0;
      for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
      {
        const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
        if(empty_stacks_fill == 1 ? (signed int)card >> 2 == 13 : !((signed int)card >> 2 == 0))
        {
          char *new_src_col;
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          tmp_post$1 = new_src_col[(signed long int)0];
          new_src_col[(signed long int)0] = new_src_col[(signed long int)0] + 1;
          new_src_col[(signed long int)((signed int)tmp_post$1 + 1)] = card;
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          fcs_move_stack_non_seq_push(moves, 2, fc, stack_idx);
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

      }
    }

    goto __CPROVER_DUMP_L9;
  }


__CPROVER_DUMP_L9:
  ;
}

// fc_solve_sfs_move_freecell_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 141
extern void fc_solve_sfs_move_freecell_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const struct anonymous$14 game_params = instance->game_params;
  signed int fc = 0;
  for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
  {
    const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
    if(!((signed int)card >> 2 == 0))
    {
      signed int deck = 0;
      for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
        if((signed int)raw_ptr_state_raw->key->foundations[(signed long int)(4 * deck + (0x03 & (signed int)card))] == ((signed int)card >> 2) + -1)
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] = pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] + 1;
          fcs_move_stack_non_seq_push(moves, 5, fc, deck * 4 + ((signed int)card & 0x03));
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

    }

  }
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_sfs_move_non_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 529
extern void fc_solve_sfs_move_non_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    signed int c = cards_num - 2;
    for( ; c >= 0; c = c - 1)
    {
      const char card = col[(signed long int)(c + 1)];
      signed int deck = 0;
      for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
        if((signed int)raw_ptr_state_raw->key->foundations[(signed long int)(4 * deck + (0x03 & (signed int)card))] == ((signed int)card >> 2) + -1)
        {
          if((empty_stacks_fill == 0 ? (signed int)num_vacant_stacks : 0) + (signed int)num_vacant_freecells >= cards_num + -(1 + c))
          {
            signed int cols_indexes[3l];
            char *new_src_col;
            fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
            if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
            {
              char *copy_stack_col;
              pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
              copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
              memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
              pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
            }

            cols_indexes[(signed long int)0] = stack_idx;
            cols_indexes[(signed long int)1] = -1;
            cols_indexes[(signed long int)2] = -1;
            empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, cards_num - (c + 1), 0);
            new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            char top_card = new_src_col[(signed long int)(((signed int)new_src_col[(signed long int)0] - 1) + 1)];
            new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
            new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
            const signed int dest_found = deck * 4 + ((signed int)top_card & 0x03);
            pass_new_state.key->foundations[(signed long int)dest_found] = pass_new_state.key->foundations[(signed long int)dest_found] + 1;
            fcs_move_stack_non_seq_push(moves, 4, stack_idx, dest_found);
            fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
          }

          break;
        }

    }
  }
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// fc_solve_sfs_move_sequences_to_free_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 921
extern void fc_solve_sfs_move_sequences_to_free_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  if(!(empty_stacks_fill == 2))
  {
    const struct anonymous$14 game_params = instance->game_params;
    const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    const signed int max_sequence_len = ((signed int)instance->game_params.game_flags & 1 << 4) != 0 ? 0x7fffffff : (empty_stacks_fill == 0 ? (signed int)num_vacant_freecells + 1 << (signed int)num_vacant_stacks - 1 : (signed int)num_vacant_freecells + 1);
    if((signed int)num_vacant_stacks >= 1)
    {
      signed int dest_stack_idx = -1;
      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
      {
        char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
        const signed int cards_num = (const signed int)col[(signed long int)0];
        signed int seq_end;
        signed int c = 0;
        for( ; !(c >= cards_num); c = seq_end + 1)
        {
          seq_end = c;
          for( ; !(seq_end >= cards_num + -1); seq_end = seq_end + 1)
          {
            char this_card = col[(signed long int)(seq_end + 1 + 1)];
            char prev_card = col[(signed long int)(seq_end + 1)];
            if(!(((signed int)this_card >> 2) + 1 == (signed int)prev_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)this_card) == (0x03 & (signed int)prev_card) : !((1 & (signed int)this_card) == (1 & (signed int)prev_card))))
              break;

          }
          if(!((signed int)col[(signed long int)(1 + c)] >> 2 == 13))
          {
            if(empty_stacks_fill == 1)
              goto __CPROVER_DUMP_L30;

          }

          if(seq_end == cards_num + -1)
          {
            for( ; c >= 1 && !(max_sequence_len >= cards_num + -c); c = c - 1)
              ;
            if(c >= 1)
            {
              if(empty_stacks_fill == 1)
                tmp_if_expr$1 = (signed int)((signed int)col[(signed long int)(c + 1)] >> 2 == 13);

              else
                tmp_if_expr$1 = 1;
              if(!(tmp_if_expr$1 == 0))
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if(!(dest_stack_idx >= 0))
                {
                  dest_stack_idx = 0;
                  for( ; !(dest_stack_idx >= (signed int)game_params.stacks_num); dest_stack_idx = dest_stack_idx + 1)
                    if((signed int)*pass_new_state.key->stacks[(signed long int)dest_stack_idx] == 0)
                      break;

                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)dest_stack_idx] = &indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$3$$2$$4$$1$$copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$3$$2$$4$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$3$$2$$4$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$3$$2$$4$$1$$copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                fc_solve_move_sequence_function(&pass_new_state, moves, dest_stack_idx, stack_idx, c, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

          else
          {
            signed int num_cards_to_relocate = (cards_num - seq_end) - 1;
            const signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
            num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
            signed int freestacks_to_fill;
            if(empty_stacks_fill == 0)
            {
              freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
              num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
            }

            else
              freestacks_to_fill = 0;
            if(num_cards_to_relocate == 0 && (signed int)num_vacant_stacks + -freestacks_to_fill >= 1)
            {
              signed int seq_start = c;
              for( ; (16 & (signed int)instance->game_params.game_flags) == 0 && (empty_stacks_fill == 0 ? !(1 + (signed int)num_vacant_freecells + -freecells_to_fill << (signed int)num_vacant_stacks + -freestacks_to_fill + -1 >= 1 + seq_end + -seq_start) : !(1 + (signed int)num_vacant_freecells + -freecells_to_fill >= 1 + seq_end + -seq_start)); seq_start = seq_start + 1)
                if(!(seq_end >= seq_start))
                  break;

              if(seq_end >= seq_start)
              {
                if(empty_stacks_fill == 1)
                  tmp_if_expr$2 = (signed int)((signed int)col[(signed long int)(seq_start + 1)] >> 2 == 13);

                else
                  tmp_if_expr$2 = 1;
                if(!(tmp_if_expr$2 == 0))
                {
                  signed int cols_indexes[3l];
                  signed int empty_ret;
                  fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                  {
                    char *fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$2$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                    fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$2$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$2$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$2$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                  }

                  cols_indexes[(signed long int)0] = stack_idx;
                  cols_indexes[(signed long int)1] = -1;
                  cols_indexes[(signed long int)2] = -1;
                  empty_ret=empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, freecells_to_fill + freestacks_to_fill, 0);
                  signed int b = (empty_ret >> 8 & 0x1) != 0 ? (empty_ret & 0xFF) + 1 : 0;
                  for( ; !(b >= (signed int)game_params.stacks_num); b = b + 1)
                    if((signed int)*pass_new_state.key->stacks[(signed long int)b] == 0)
                      break;

                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << b) == 0)
                  {
                    char *fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$4$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << b;
                    fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$4$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)b];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(b << 7)], (const void *)fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$4$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_sequences_to_free_stacks$$1$$3$$1$$1$$1$$1$$4$$3$$2$$4$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)b] = &indirect_stacks_buffer[(signed long int)(b << 7)];
                  }

                  fc_solve_move_sequence_function(&pass_new_state, moves, b, stack_idx, seq_start, seq_end);
                  fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
                }

              }

            }

          }

        __CPROVER_DUMP_L30:
          ;
        }
      }
    }

    goto __CPROVER_DUMP_L34;
  }


__CPROVER_DUMP_L34:
  ;
}

// fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 617
extern void fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  char tmp_post$1;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    signed int c = 0;
    for( ; !(c >= cards_num); c = c + 1)
    {
      const char card = col[(signed long int)(c + 1)];
      _Bool should_perform_move = (_Bool)1;
      if(!(c == 0))
      {
        char prev_card = col[(signed long int)((c - 1) + 1)];
        if((signed int)prev_card >> 2 == ((signed int)card >> 2) + 1 && !((1 & (signed int)prev_card) == (1 & (signed int)card)))
          should_perform_move = (_Bool)0;

      }

      if(!(should_perform_move == (_Bool)0))
      {
        signed int dc = 0;
        for( ; !(dc >= c + -1); dc = dc + 1)
        {
          char dest_card = col[(signed long int)(dc + 1)];
          if(((signed int)card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)card) == (1 & (signed int)dest_card)))))
          {
            _Bool is_seq_in_dest = (_Bool)0;
            char dest_below_card = col[(signed long int)(dc + 1 + 1)];
            if(((signed int)dest_below_card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)dest_below_card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)dest_below_card) == (1 & (signed int)dest_card)))))
              is_seq_in_dest = (_Bool)1;

            if(is_seq_in_dest == (_Bool)0)
            {
              signed int num_cards_to_relocate = (cards_num - dc) - 1;
              signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
              num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
              signed int freestacks_to_fill;
              if(empty_stacks_fill == 0)
              {
                freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
                num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
              }

              else
                freestacks_to_fill = 0;
              if(num_cards_to_relocate == 0)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                char *new_dest_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                signed int cols_indexes[3l];
                cols_indexes[(signed long int)0] = stack_idx;
                cols_indexes[(signed long int)1] = -1;
                cols_indexes[(signed long int)2] = -1;
                signed int last_dest;
                last_dest=empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, cards_num - c, 0);
                signed int source_index = last_dest & 0xFF;
                empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, (c - dc) - 1, 0);
                char moved_card;
                if((last_dest >> 8 & 0x1) == 0)
                {
                  moved_card = pass_new_state.key->freecells[(signed long int)source_index];
                  pass_new_state.key->freecells[(signed long int)source_index] = (char)0;
                  fcs_move_stack_non_seq_push(moves, 2, source_index, stack_idx);
                }

                else
                {
                  char *new_source_col = pass_new_state.key->stacks[(signed long int)source_index];
                  moved_card = new_source_col[(signed long int)(((signed int)new_source_col[(signed long int)0] - 1) + 1)];
                  new_source_col[(signed long int)0] = new_source_col[(signed long int)0] - 1;
                  new_source_col[(signed long int)((signed int)new_source_col[(signed long int)0] + 1)] = (char)0;
                  fcs_push_1card_seq(moves, source_index, stack_idx);
                }
                tmp_post$1 = new_dest_col[(signed long int)0];
                new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
                new_dest_col[(signed long int)((signed int)tmp_post$1 + 1)] = moved_card;
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

        }
      }

    }
  }
  goto __CPROVER_DUMP_L19;

__CPROVER_DUMP_L19:
  ;
}

// fc_solve_sfs_move_stack_cards_to_different_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 775
extern void fc_solve_sfs_move_stack_cards_to_different_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous$14 game_params = instance->game_params;
  const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  const signed int initial_derived_states_num_states = derived_states_list->num_states;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, fc_solve_get_the_positions_by_rank_data__freecell_generator);
  signed int stack_idx = 0;
  _Bool tmp_if_expr$1;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    signed int seq_end;
    signed int c = 0;
    for( ; !(c >= (signed int)*col); c = seq_end + 1)
    {
      seq_end = c;
      for( ; !(seq_end >= (signed int)*col + -1); seq_end = seq_end + 1)
      {
        const char this_card = col[(signed long int)(seq_end + 1 + 1)];
        const char prev_card = col[(signed long int)(seq_end + 1)];
        if(!(((signed int)this_card >> 2) + 1 == (signed int)prev_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)this_card) == (0x03 & (signed int)prev_card) : !((1 & (signed int)this_card) == (1 & (signed int)prev_card))))
          break;

      }
      if(empty_stacks_fill == 2)
      {
        if(c == 0)
          goto __CPROVER_DUMP_L18;

      }

      const char card = col[(signed long int)(c + 1)];
      if(!((signed int)card >> 2 == 13))
      {
        char *pos_idx_to_check = &positions_by_rank[(signed long int)((2 << 3) * ((signed int)card >> 2))];
        char *last_pos_idx = pos_idx_to_check + (signed long int)(2 << 3);
        pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 0 : (sequences_are_built_by == 1 ? (signed int)card & 0x03 : ((signed int)card & 0x03 ^ 0x1) & 0x2 - 1)) << 1);
        for( ; !(pos_idx_to_check >= last_pos_idx); pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? 4 : 2)) << 1))
        {
          const signed int ds = (const signed int)pos_idx_to_check[(signed long int)0];
          if(ds >= 0 && !(ds == stack_idx))
          {
            const signed int dc = (const signed int)pos_idx_to_check[(signed long int)1];
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            signed int num_cards_to_relocate = (((((signed int)dest_col[(signed long int)0] - dc) - 1) + (signed int)col[(signed long int)0]) - seq_end) - 1;
            const signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
            num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
            signed int freestacks_to_fill;
            if(empty_stacks_fill == 0)
            {
              freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
              num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
            }

            else
              freestacks_to_fill = 0;
            if(num_cards_to_relocate == 0)
              tmp_if_expr$1 = (((signed int)instance->game_params.game_flags & 1 << 4) != 0 ? 0x7fffffff : (empty_stacks_fill == 0 ? ((signed int)num_vacant_freecells - freecells_to_fill) + 1 << (signed int)num_vacant_stacks - freestacks_to_fill : ((signed int)num_vacant_freecells - freecells_to_fill) + 1)) >= (seq_end - c) + 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$1 = (_Bool)0;
            if(tmp_if_expr$1)
            {
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
              }

              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *fc_solve_sfs_move_stack_cards_to_different_stacks$$1$$2$$1$$1$$1$$4$$1$$1$$3$$3$$1$$copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                fc_solve_sfs_move_stack_cards_to_different_stacks$$1$$2$$1$$1$$1$$4$$1$$1$$3$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_move_stack_cards_to_different_stacks$$1$$2$$1$$1$$1$$4$$1$$1$$3$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_stack_cards_to_different_stacks$$1$$2$$1$$1$$1$$4$$1$$1$$3$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              signed int cols_indexes[3l];
              cols_indexes[(signed long int)0] = ds;
              cols_indexes[(signed long int)1] = stack_idx;
              cols_indexes[(signed long int)2] = -1;
              empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, ((signed int)dest_col[(signed long int)0] - dc) - 1, ((signed int)col[(signed long int)0] - seq_end) - 1);
              fc_solve_move_sequence_function(&pass_new_state, moves, ds, stack_idx, c, seq_end);
              state_context_value = ((stack_idx << 8 | c) << 8 | ds) << 8 | dc;
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }
      }


    __CPROVER_DUMP_L18:
      ;
    }
  }
  sort_derived_states(derived_states_list, initial_derived_states_num_states);
  goto __CPROVER_DUMP_L21;

__CPROVER_DUMP_L21:
  ;
}

// fc_solve_sfs_move_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 66
extern void fc_solve_sfs_move_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(!(cards_num == 0))
    {
      const char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int deck = 0;
      for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
        if((signed int)raw_ptr_state_raw->key->foundations[(signed long int)(4 * deck + (0x03 & (signed int)card))] == ((signed int)card >> 2) + -1)
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char *new_temp_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          new_temp_col[(signed long int)0] = new_temp_col[(signed long int)0] - 1;
          new_temp_col[(signed long int)((signed int)new_temp_col[(signed long int)0] + 1)] = (char)0;
          pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] = pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] + 1;
          fcs_move_stack_non_seq_push(moves, 4, stack_idx, deck * 4 + ((signed int)card & 0x03));
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
          break;
        }

    }

  }
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// fc_solve_sfs_raymond_prune
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1953
extern signed int fc_solve_sfs_raymond_prune(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct fcs_state_keyval_pair_struct ** const ptr_next_state_val)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  struct anonymous$12 derived_states_list_struct = { .num_states=0, .states=(struct anonymous$38 *)(void *)0 };
  fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
  signed int num_total_cards_moved = 0;
  signed int num_cards_moved;
  do
  {
    num_cards_moved = 0;
    signed int stack_idx = 0;
    for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
    {
      char * const col = pass_new_state.key->stacks[(signed long int)stack_idx];
      const signed int cards_num = (const signed int)col[(signed long int)0];
      if(!(cards_num == 0))
      {
        const char card = col[(signed long int)((cards_num - 1) + 1)];
        signed int dest_foundation;
        dest_foundation=calc_foundation_to_put_card_on(soft_thread, pass_new_state.key, card);
        if(dest_foundation >= 0)
        {
          num_cards_moved = num_cards_moved + 1;
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char *new_temp_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          new_temp_col[(signed long int)0] = new_temp_col[(signed long int)0] - 1;
          new_temp_col[(signed long int)((signed int)new_temp_col[(signed long int)0] + 1)] = (char)0;
          pass_new_state.key->foundations[(signed long int)dest_foundation] = pass_new_state.key->foundations[(signed long int)dest_foundation] + 1;
          fcs_move_stack_non_seq_push(moves, 4, stack_idx, dest_foundation);
        }

      }

    }
    signed int fc = 0;
    for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
    {
      const char fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$card = pass_new_state.key->freecells[(signed long int)fc];
      if(!((signed int)fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$card >> 2 == 0))
      {
        signed int fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$1$$dest_foundation;
        fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$1$$dest_foundation=calc_foundation_to_put_card_on(soft_thread, pass_new_state.key, fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$card);
        if(fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$1$$dest_foundation >= 0)
        {
          num_cards_moved = num_cards_moved + 1;
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          pass_new_state.key->foundations[(signed long int)fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$1$$dest_foundation] = pass_new_state.key->foundations[(signed long int)fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$1$$dest_foundation] + 1;
          fcs_move_stack_non_seq_push(moves, 5, fc, fc_solve_sfs_raymond_prune$$1$$3$$2$$1$$1$$dest_foundation);
        }

      }

    }
    num_total_cards_moved = num_total_cards_moved + num_cards_moved;
  }
  while(!(num_cards_moved == 0));
  fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, &derived_states_list_struct);
  signed int ret_code;
  if(!(num_total_cards_moved == 0))
  {
    struct fcs_state_keyval_pair_struct * const ptr_next_state = (derived_states_list_struct.states + (signed long int)0)->state_ptr;
    *ptr_next_state_val = ptr_next_state;
    ptr_next_state->$anon0.$anon0.info.visited = ptr_next_state->$anon0.$anon0.info.visited | (unsigned char)16;
    ret_code = 1;
  }

  else
  {
    *ptr_next_state_val = (struct fcs_state_keyval_pair_struct *)(void *)0;
    ret_code = 0;
  }
  free((void *)derived_states_list_struct.states);
  return ret_code;
}

// fc_solve_sfs_simple_simon_move_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 61
extern void fc_solve_sfs_simple_simon_move_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_true_seqs;
      signed int h;
      h=get_seq_h(col, &num_true_seqs);
      if(1 << (signed int)num_vacant_stacks >= num_true_seqs)
      {
        const char card = col[(signed long int)(h + 1)];
        signed int ds = 0;
        for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
          if(!(ds == stack_idx))
          {
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dest_cards_num >= 1)
            {
              if((signed int)dest_col[(signed long int)dest_cards_num] >> 2 == ((signed int)card >> 2) + 1)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_sequence_to_false_parent$$1$$2$$1$$3$$1$$5$$1$$copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  fc_solve_sfs_simple_simon_move_sequence_to_false_parent$$1$$2$$1$$3$$1$$5$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_false_parent$$1$$2$$1$$3$$1$$5$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_false_parent$$1$$2$$1$$3$$1$$5$$1$$copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                fc_solve_move_sequence_function$link1(&pass_new_state, moves, ds, stack_idx, h, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

      }

    }

  }
  goto __CPROVER_DUMP_L13;

__CPROVER_DUMP_L13:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 45
extern void fc_solve_sfs_simple_simon_move_sequence_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 13)
    {
      char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int a = 2;
      for( ; !(a >= 14); a = a + 1)
      {
        const char above_card = col[(signed long int)((cards_num - a) + 1)];
        _Bool return_value_fcs_is_ss_true_parent$1;
        return_value_fcs_is_ss_true_parent$1=fcs_is_ss_true_parent(above_card, card);
        if(return_value_fcs_is_ss_true_parent$1 == (_Bool)0)
          break;

        card = above_card;
      }
      if(a == 14)
      {
        fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
        if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
        {
          char *copy_stack_col;
          pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
          copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
          pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
        }

        char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
        a = 0;
        for( ; !(a >= 13); a = a + 1)
        {
          new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
          new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
        }
        const signed int suit = (signed int)card & 0x03;
        pass_new_state.key->foundations[(signed long int)suit] = (char)a;
        fcs_move_stack_non_seq_push$link1(moves, 11, stack_idx, suit);
        fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
      }

    }

  }
  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 59
extern void fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  signed int tmp_post$4;
  signed int tmp_if_expr$6;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 3)
    {
      signed int parent_card_height = 0;
      for( ; !(parent_card_height >= cards_num + -2); parent_card_height = parent_card_height + 1)
      {
        const char parent_card = col[(signed long int)(parent_card_height + 1)];
        _Bool return_value_fcs_is_ss_true_parent$1;
        return_value_fcs_is_ss_true_parent$1=fcs_is_ss_true_parent(parent_card, col[(signed long int)(parent_card_height + 1 + 1)]);
        if(return_value_fcs_is_ss_true_parent$1 == (_Bool)0)
        {
          signed int child_card_height = parent_card_height + 2;
          for( ; !(child_card_height >= cards_num); child_card_height = child_card_height + 1)
          {
            _Bool return_value_fcs_is_ss_true_parent$2;
            return_value_fcs_is_ss_true_parent$2=fcs_is_ss_true_parent(parent_card, col[(signed long int)(child_card_height + 1)]);
            if(!(return_value_fcs_is_ss_true_parent$2 == (_Bool)0))
            {
              signed int end_of_child_seq = child_card_height;
              signed int child_num_true_seqs = 1;
              while(!(1 + end_of_child_seq >= cards_num))
              {
                if(!((signed int)col[(signed long int)(1 + end_of_child_seq)] >> 2 == ((signed int)col[(signed long int)(1 + end_of_child_seq)] >> 2) + 1))
                  break;

                _Bool return_value_fcs_is_ss_true_parent$3;
                return_value_fcs_is_ss_true_parent$3=fcs_is_ss_true_parent(col[(signed long int)(end_of_child_seq + 1)], col[(signed long int)(end_of_child_seq + 1 + 1)]);
                child_num_true_seqs = child_num_true_seqs + (signed int)!(return_value_fcs_is_ss_true_parent$3 != (_Bool)0);
                end_of_child_seq = end_of_child_seq + 1;
              }
              struct anonymous$45 seqs;
              populate_seq_points(col, end_of_child_seq, &seqs);
              const signed int child_seq_index = seqs.num_separate_false_seqs;
              seqs.above_num_true_seqs[(signed long int)seqs.num_separate_false_seqs] = child_num_true_seqs;
              tmp_post$4 = seqs.num_separate_false_seqs;
              seqs.num_separate_false_seqs = seqs.num_separate_false_seqs + 1;
              seqs.seq_points[(signed long int)tmp_post$4] = child_card_height;
              generic_populate_seq_points(col, parent_card_height, &seqs, child_card_height);
              _Bool return_value_false_seq_index_loop$5;
              return_value_false_seq_index_loop$5=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, col, &seqs, stack_idx, stack_idx, (const _Bool)0);
              if(!(return_value_false_seq_index_loop$5 == (_Bool)0) && 1 << seqs.after_junk_num_freestacks >= child_num_true_seqs)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$5$$1$$copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$5$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$5$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$5$$1$$copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                signed int seq_index = 0;
                for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                {
                  const signed int dest_idx = seqs.junk_move_to_stacks[(signed long int)seq_index];
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_idx) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$6$$1$$1$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_idx;
                    fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$6$$1$$1$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$6$$1$$1$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack$$1$$2$$1$$2$$1$$2$$1$$6$$1$$1$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)dest_idx] = &indirect_stacks_buffer[(signed long int)(dest_idx << 7)];
                  }

                  if(seq_index == 0)
                    tmp_if_expr$6 = cards_num - 1;

                  else
                    tmp_if_expr$6 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                  fc_solve_move_sequence_function$link1(&pass_new_state, moves, dest_idx, stack_idx, seqs.seq_points[(signed long int)seq_index], tmp_if_expr$6);
                }
                const signed int source_idx = seqs.junk_move_to_stacks[(signed long int)child_seq_index];
                char * const move_junk_to_col = pass_new_state.key->stacks[(signed long int)source_idx];
                const signed int end = (signed int)move_junk_to_col[(signed long int)0] - 1;
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << source_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << source_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)source_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(source_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)source_idx] = &indirect_stacks_buffer[(signed long int)(source_idx << 7)];
                }

                fc_solve_move_sequence_function$link1(&pass_new_state, moves, stack_idx, source_idx, end - (end_of_child_seq - child_card_height), end);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }
        }

      }
    }

  }
  goto __CPROVER_DUMP_L22;

__CPROVER_DUMP_L22:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 47
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int num_true_seqs = 1;
      signed int h = cards_num - 2;
      for( ; h >= -1; h = h - 1)
      {
        if(!((signed int)card >> 2 >= 13))
        {
          const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
          if(!(ds == stack_idx))
          {
            const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dc == dest_cards_num + -1)
            {
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
              }

              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *fc_solve_sfs_simple_simon_move_sequence_to_true_parent$$1$$2$$1$$2$$1$$1$$1$$1$$3$$1$$copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                fc_solve_sfs_simple_simon_move_sequence_to_true_parent$$1$$2$$1$$2$$1$$1$$1$$1$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_true_parent$$1$$2$$1$$2$$1$$1$$1$$1$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_true_parent$$1$$2$$1$$2$$1$$1$$1$$1$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              fc_solve_move_sequence_function$link1(&pass_new_state, moves, ds, stack_idx, h + 1, cards_num - 1);
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }

        if(h == -1)
          break;

        const char prev_card = card;
        card = col[(signed long int)(h + 1)];
        if(!((signed int)card >> 2 == ((signed int)prev_card >> 2) + 1))
          break;

        _Bool return_value_fcs_is_ss_suit_true$1;
        return_value_fcs_is_ss_suit_true$1=fcs_is_ss_suit_true(card, prev_card);
        if(return_value_fcs_is_ss_suit_true$1 == (_Bool)0)
        {
          num_true_seqs = num_true_seqs + 1;
          if(!(1 << (signed int)num_vacant_stacks >= num_true_seqs))
            break;

        }

      }
    }

  }
}

// fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 51
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  _Bool return_value_fcs_is_ss_suit_true$1;
  _Bool tmp_statement_expression$3;
  signed int tmp_if_expr$2;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int num_true_seqs = 1;
      signed int h = cards_num - 2;
      for( ; h >= -1; h = h - 1)
      {
        char h_above_card;
        _Bool should_search = (_Bool)1;
        _Bool should_increment_num_true_seqs = (_Bool)0;
        _Bool should_break = (_Bool)0;
        if(h == -1)
          should_break = (_Bool)1;

        else
        {
          h_above_card = col[(signed long int)(h + 1)];
          if(!((signed int)h_above_card >> 2 == ((signed int)card >> 2) + 1))
            should_break = (_Bool)1;

          else
          {
            return_value_fcs_is_ss_suit_true$1=fcs_is_ss_suit_true(h_above_card, card);
            should_search = !(return_value_fcs_is_ss_suit_true$1 != (_Bool)0);
            if(!(should_search == (_Bool)0))
              should_increment_num_true_seqs = (_Bool)1;

          }
        }
        if(!(should_search == (_Bool)0))
        {
          if(!((signed int)card >> 2 >= 13))
          {
            const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
            if(!(ds == stack_idx))
            {
              const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
              char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
              const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
              struct anonymous$45 seqs;
              populate_seq_points(dest_col, dc, &seqs);
              tmp_statement_expression$3=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, dest_col, &seqs, stack_idx, ds, (const _Bool)0);
              if(!(tmp_statement_expression$3 == (_Bool)0))
              {
                if(1 << seqs.after_junk_num_freestacks >= num_true_seqs)
                {
                  fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                  {
                    char *copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                    copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                  }

                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                    fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                  }

                  signed int seq_index = 0;
                  for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                  {
                    const signed int dest_index = seqs.junk_move_to_stacks[(signed long int)seq_index];
                    if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_index) == 0)
                    {
                      char *fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$4$$1$$1$$1$$copy_stack_col;
                      pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_index;
                      fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$4$$1$$1$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_index];
                      memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_index << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$4$$1$$1$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above$$1$$2$$1$$2$$1$$3$$1$$1$$2$$4$$1$$1$$1$$copy_stack_col[(signed long int)0] + 1));
                      pass_new_state.key->stacks[(signed long int)dest_index] = &indirect_stacks_buffer[(signed long int)(dest_index << 7)];
                    }

                    if(seq_index == 0)
                      tmp_if_expr$2 = dest_cards_num - 1;

                    else
                      tmp_if_expr$2 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                    fc_solve_move_sequence_function$link1(&pass_new_state, moves, dest_index, ds, seqs.seq_points[(signed long int)seq_index], tmp_if_expr$2);
                  }
                  fc_solve_move_sequence_function$link1(&pass_new_state, moves, ds, stack_idx, h + 1, cards_num - 1);
                  fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
                }

              }

            }

          }

        }

        if(should_break != (_Bool)0)
          break;

        if(!(should_increment_num_true_seqs == (_Bool)0))
          num_true_seqs = num_true_seqs + 1;

        card = h_above_card;
      }
    }

  }
  goto __CPROVER_DUMP_L22;

__CPROVER_DUMP_L22:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 55
extern void fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  signed int tmp_if_expr$2;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_src_junk_true_seqs = 1;
      signed int h;
      h=get_seq_h(col, &num_src_junk_true_seqs);
      if(!(h == 0))
      {
        char card = col[(signed long int)(h + 1)];
        signed int end_of_junk;
        h = h - 1;
        end_of_junk = h;
        signed int num_true_seqs = 1;
        for( ; h >= 0; h = h - 1)
        {
          const char next_card = col[(signed long int)(h + 1)];
          if(!((signed int)next_card >> 2 == ((signed int)card >> 2) + 1))
          {
            card = next_card;
            break;
          }

          _Bool return_value_fcs_is_ss_suit_true$1;
          return_value_fcs_is_ss_suit_true$1=fcs_is_ss_suit_true(next_card, card);
          if(return_value_fcs_is_ss_suit_true$1 == (_Bool)0)
            num_true_seqs = num_true_seqs + 1;

          card = next_card;
        }
        if(!((signed int)card >> 2 >= 13))
        {
          const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
          if(!(ds == stack_idx))
          {
            const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dest_cards_num + -2 >= dc)
            {
              struct anonymous$45 seqs;
              populate_seq_points(dest_col, dc, &seqs);
              _Bool verdict;
              verdict=generic_false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, dest_col, &seqs, stack_idx, ds, (const _Bool)0, (const _Bool)1, col[(signed long int)(end_of_junk + 1 + 1)], num_src_junk_true_seqs);
              if(1 << seqs.after_junk_num_freestacks >= num_true_seqs && !(verdict == (_Bool)0))
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$3$$1$$copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                signed int seq_index = 0;
                for( ; !(seq_index >= 1 + seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                {
                  signed int start;
                  signed int end;
                  signed int src_stack;
                  if(seq_index == seqs.num_separate_false_seqs)
                  {
                    start = end_of_junk + 1;
                    end = cards_num - 1;
                    src_stack = stack_idx;
                  }

                  else
                  {
                    start = seqs.seq_points[(signed long int)seq_index];
                    if(seq_index == 0)
                      tmp_if_expr$2 = dest_cards_num - 1;

                    else
                      tmp_if_expr$2 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                    end = tmp_if_expr$2;
                    src_stack = ds;
                  }
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << src_stack) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$3$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << src_stack;
                    fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)src_stack];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(src_stack << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)src_stack] = &indirect_stacks_buffer[(signed long int)(src_stack << 7)];
                  }

                  const signed int dest_index = seqs.junk_move_to_stacks[(signed long int)seq_index];
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_index) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$4$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_index;
                    fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$4$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_index];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_index << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$4$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above$$1$$2$$1$$4$$1$$1$$1$$4$$1$$4$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)dest_index] = &indirect_stacks_buffer[(signed long int)(dest_index << 7)];
                  }

                  fc_solve_move_sequence_function$link1(&pass_new_state, moves, dest_index, src_stack, start, end);
                }
                fc_solve_move_sequence_function$link1(&pass_new_state, moves, ds, stack_idx, h, end_of_junk);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

        }

      }

    }

  }
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L24:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 53
extern void fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  _Bool tmp_statement_expression$3;
  signed int tmp_if_expr$2;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int src_card_height = cards_num - 1;
      for( ; src_card_height >= 0; src_card_height = src_card_height - 1)
      {
        signed int end_of_src_seq;
        const char h_card = col[(signed long int)(src_card_height + 1)];
        char card = h_card;
        signed int num_true_seqs = 1;
        end_of_src_seq = src_card_height + 1;
        for( ; !(end_of_src_seq >= cards_num); end_of_src_seq = end_of_src_seq + 1)
        {
          const char above_card = col[(signed long int)(end_of_src_seq + 1)];
          if(!((signed int)card >> 2 == ((signed int)above_card >> 2) + 1))
            break;

          _Bool return_value_fcs_is_ss_suit_true$1;
          return_value_fcs_is_ss_suit_true$1=fcs_is_ss_suit_true(card, above_card);
          if(return_value_fcs_is_ss_suit_true$1 == (_Bool)0)
            num_true_seqs = num_true_seqs + 1;

          card = above_card;
        }
        if(!(end_of_src_seq == cards_num))
        {
          if(!((signed int)h_card >> 2 >= 13))
          {
            const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)h_card & 0x03) * (13 + 1) + ((signed int)h_card >> 2) + 1) * 2)];
            if(!(ds == stack_idx))
            {
              const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)h_card & 0x03) * (13 + 1) + ((signed int)h_card >> 2) + 1) * 2 + 1)];
              char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
              const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
              if(dc == dest_cards_num + -1)
              {
                struct anonymous$45 seqs;
                populate_seq_points(col, end_of_src_seq - 1, &seqs);
                tmp_statement_expression$3=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, col, &seqs, stack_idx, ds, (const _Bool)0);
                if(!(tmp_statement_expression$3 == (_Bool)0))
                {
                  if(!(num_true_seqs >= 1 << seqs.after_junk_num_freestacks))
                  {
                    fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                    if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                    {
                      char *fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$2$$1$$copy_stack_col;
                      pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                      fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$2$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                      memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$2$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$2$$1$$copy_stack_col[(signed long int)0] + 1));
                      pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                    }

                    if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                    {
                      char *fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col;
                      pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                      fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                      memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent$$1$$2$$1$$2$$1$$3$$1$$1$$2$$3$$1$$copy_stack_col[(signed long int)0] + 1));
                      pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                    }

                    signed int seq_index = 0;
                    for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                    {
                      const signed int dest_index = seqs.junk_move_to_stacks[(signed long int)seq_index];
                      if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_index) == 0)
                      {
                        char *copy_stack_col;
                        pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_index;
                        copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_index];
                        memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_index << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                        pass_new_state.key->stacks[(signed long int)dest_index] = &indirect_stacks_buffer[(signed long int)(dest_index << 7)];
                      }

                      if(seq_index == 0)
                        tmp_if_expr$2 = cards_num - 1;

                      else
                        tmp_if_expr$2 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                      fc_solve_move_sequence_function$link1(&pass_new_state, moves, dest_index, stack_idx, seqs.seq_points[(signed long int)seq_index], tmp_if_expr$2);
                    }
                    fc_solve_move_sequence_function$link1(&pass_new_state, moves, ds, stack_idx, src_card_height, end_of_src_seq - 1);
                    fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
                  }

                }

              }

            }

          }

        }

      }
    }

  }
  goto __CPROVER_DUMP_L23;

__CPROVER_DUMP_L23:
  ;
}

// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 49
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_true_seqs;
      signed int h;
      h=get_seq_h(col, &num_true_seqs);
      if(!(h >= 1) && 1 << (signed int)num_vacant_stacks >= num_true_seqs)
      {
        const char card = col[(signed long int)(h + 1)];
        signed int ds = 0;
        for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
          if(!(ds == stack_idx))
          {
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dest_cards_num >= 1)
            {
              const char dest_card = dest_col[(signed long int)((dest_cards_num - 1) + 1)];
              if((signed int)dest_card >> 2 == ((signed int)card >> 2) + 1)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent$$1$$2$$1$$3$$1$$6$$1$$copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent$$1$$2$$1$$3$$1$$6$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent$$1$$2$$1$$3$$1$$6$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent$$1$$2$$1$$3$$1$$6$$1$$copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                fc_solve_move_sequence_function$link1(&pass_new_state, moves, ds, stack_idx, h, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

      }

    }

  }
  goto __CPROVER_DUMP_L13;

__CPROVER_DUMP_L13:
  ;
}

// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 57
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous$3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous$6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous$14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  _Bool tmp_statement_expression$2;
  signed int tmp_if_expr$3;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_true_seqs;
      signed int return_value_get_seq_h$1;
      return_value_get_seq_h$1=get_seq_h(col, &num_true_seqs);
      if(return_value_get_seq_h$1 == 0)
      {
        char card = col[(signed long int)(0 + 1)];
        if(!((signed int)card >> 2 == 13))
        {
          struct anonymous$46 ds_dcs[4l];
          signed int len = 0;
          signed int parent_suit = 0;
          for( ; !(parent_suit >= 4); parent_suit = parent_suit + 1)
          {
            const signed int ds = (const signed int)positions_by_rank[(signed long int)((parent_suit * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
            if(!(ds == stack_idx) && ds >= 0)
            {
              const signed int dc = (const signed int)positions_by_rank[(signed long int)((parent_suit * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
              ds_dcs[(signed long int)len].ds = ds;
              ds_dcs[(signed long int)len].dc = dc;
              len = len + 1;
            }

          }
          sort_ds_dcs(ds_dcs, len);
          signed int i = 0;
          for( ; !(i >= len); i = i + 1)
          {
            const signed int fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds = ds_dcs[(signed long int)i].ds;
            const signed int fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$dc = ds_dcs[(signed long int)i].dc;
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            struct anonymous$45 seqs;
            populate_seq_points(dest_col, fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$dc, &seqs);
            tmp_statement_expression$2=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, dest_col, &seqs, stack_idx, fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds, (const _Bool)1);
            if(!(tmp_statement_expression$2 == (_Bool)0))
            {
              if(1 << (signed int)num_vacant_stacks >= num_true_seqs)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$6$$1$$copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds;
                  fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$6$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$6$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$6$$1$$copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds] = &indirect_stacks_buffer[(signed long int)(fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds << 7)];
                }

                signed int seq_index = 0;
                for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                {
                  const signed int src_stack_idx = fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds;
                  const signed int dest_stack_idx = seqs.junk_move_to_stacks[(signed long int)seq_index];
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << src_stack_idx) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$1$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << src_stack_idx;
                    fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$1$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)src_stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(src_stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$1$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$1$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)src_stack_idx] = &indirect_stacks_buffer[(signed long int)(src_stack_idx << 7)];
                  }

                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_stack_idx) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$2$$1$$copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_stack_idx;
                    fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$2$$1$$copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$2$$1$$copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$7$$1$$2$$1$$copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)dest_stack_idx] = &indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)];
                  }

                  if(seq_index == 0)
                    tmp_if_expr$3 = dest_cards_num - 1;

                  else
                    tmp_if_expr$3 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                  fc_solve_move_sequence_function$link1(&pass_new_state, moves, dest_stack_idx, src_stack_idx, seqs.seq_points[(signed long int)seq_index], tmp_if_expr$3);
                }
                fc_solve_move_sequence_function$link1(&pass_new_state, moves, fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above$$1$$2$$1$$5$$1$$ds, stack_idx, 0, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }
        }

      }

    }

  }
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L24:
  ;
}

// fc_solve_sfs_yukon_do_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1429
extern void fc_solve_sfs_yukon_do_nothing(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous$6 * const raw_ptr_state_raw, struct anonymous$12 * const derived_states_list)
{
  ;
}

// fc_solve_soft_dfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1210
extern signed int fc_solve_soft_dfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  struct fcs_state_keyval_pair_struct *ptr_state_raw;
  struct anonymous$6 pass;
  signed int by_depth_max_depth;
  signed int by_depth_min_depth;
  const unsigned char calc_real_depth = (const unsigned char)((signed int)instance->runtime_flags & 4);
  const unsigned char scans_synergy = (const unsigned char)((signed int)instance->runtime_flags & 64);
  const unsigned char is_a_complete_scan = (const unsigned char)((signed int)soft_thread->runtime_flags & 2);
  const signed int soft_thread_id = soft_thread->id;
  const struct anonymous$16 *the_tests_list_ptr;
  enum anonymous$26 local_shuffling_type = (enum anonymous$26)FCS_NO_SHUFFLING;
  signed long int hard_thread_max_num_checked_states;
  const struct anonymous$14 game_params = instance->game_params;
  signed int * const depth_ptr = &soft_thread->method_specific.soft_dfs.depth;
  struct anonymous$50 *the_soft_dfs_info = &soft_thread->method_specific.soft_dfs.soft_dfs_info[(signed long int)*depth_ptr];
  signed int dfs_max_depth = soft_thread->method_specific.soft_dfs.dfs_max_depth;
  _Bool enable_pruning = soft_thread->enable_pruning;
  ptr_state_raw = the_soft_dfs_info->state;
  if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    pass.key = &ptr_state_raw->$anon0.$anon0.s;
    pass.val = &ptr_state_raw->$anon0.$anon0.info;
  }

  struct anonymous$12 *derived_states_list = &the_soft_dfs_info->derived_states_list;
  signed long int * const rand_gen = &soft_thread->method_specific.soft_dfs.rand_gen;
  calculate_real_depth((const _Bool)calc_real_depth, ptr_state_raw);
  struct anonymous$52 *by_depth_units = soft_thread->method_specific.soft_dfs.tests_by_depth_array.by_depth_units;
  signed long int * const instance_num_checked_states_ptr = &instance->num_checked_states;
  signed long int * const hard_thread_num_checked_states_ptr = &hard_thread->num_checked_states;
  hard_thread_max_num_checked_states = hard_thread->max_num_checked_states;
  signed long int lim = hard_thread->num_checked_states + (instance->effective_max_num_checked_states - *instance_num_checked_states_ptr);
  hard_thread_max_num_checked_states = hard_thread_max_num_checked_states < lim ? hard_thread_max_num_checked_states : lim;
  void (* const debug_iter_output_func)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int) = instance->debug_iter_output_func;
  void * const debug_iter_output_context = instance->debug_iter_output_context;
  struct anonymous$52 *curr_by_depth_unit = by_depth_units;
  for( ; *depth_ptr >= curr_by_depth_unit->max_depth; curr_by_depth_unit = curr_by_depth_unit + 1l)
    ;
  by_depth_max_depth = curr_by_depth_unit->max_depth;
  signed int tmp_if_expr$1;
  if(curr_by_depth_unit == by_depth_units)
    tmp_if_expr$1 = 0;

  else
    tmp_if_expr$1 = (curr_by_depth_unit - (signed long int)1)->max_depth;
  by_depth_min_depth = tmp_if_expr$1;
  the_tests_list_ptr = &curr_by_depth_unit->tests;
  signed int tmp_if_expr$2;
  signed long int tmp_if_expr$3;
  struct anonymous$29 *tmp_post$7;
  struct anonymous$29 *tmp_post$10;
  signed int tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  while((_Bool)1)
  {
    if(1 + *depth_ptr >= dfs_max_depth)
    {
      fc_solve_increase_dfs_max_depth(soft_thread);
      the_soft_dfs_info = &soft_thread->method_specific.soft_dfs.soft_dfs_info[(signed long int)*depth_ptr];
      dfs_max_depth = soft_thread->method_specific.soft_dfs.dfs_max_depth;
      derived_states_list = &the_soft_dfs_info->derived_states_list;
    }

    if(the_soft_dfs_info->current_state_index == derived_states_list->num_states)
    {
      if(the_soft_dfs_info->tests_list_index == the_tests_list_ptr->num_lists)
      {
        if(!(is_a_complete_scan == 0))
        {
          ptr_state_raw->$anon0.$anon0.info.visited = ptr_state_raw->$anon0.$anon0.info.visited | (unsigned char)8;
          mark_as_dead_end((const _Bool)scans_synergy, ptr_state_raw);
        }

        free((void *)the_soft_dfs_info->positions_by_rank);
        *depth_ptr = *depth_ptr - 1;
        if(!(*depth_ptr >= 0))
          break;

        else
        {
          the_soft_dfs_info = the_soft_dfs_info - 1l;
          derived_states_list = &the_soft_dfs_info->derived_states_list;
          ptr_state_raw = the_soft_dfs_info->state;
          if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
          {
            pass.key = &ptr_state_raw->$anon0.$anon0.s;
            pass.val = &ptr_state_raw->$anon0.$anon0.info;
          }

          soft_thread->num_vacant_freecells = the_soft_dfs_info->num_vacant_freecells;
          soft_thread->num_vacant_stacks = the_soft_dfs_info->num_vacant_stacks;
          if(!(*depth_ptr >= by_depth_min_depth))
          {
            curr_by_depth_unit = curr_by_depth_unit - 1l;
            by_depth_max_depth = curr_by_depth_unit->max_depth;
            if(curr_by_depth_unit == by_depth_units)
              tmp_if_expr$2 = 0;

            else
              tmp_if_expr$2 = (curr_by_depth_unit - (signed long int)1)->max_depth;
            by_depth_min_depth = tmp_if_expr$2;
            the_tests_list_ptr = &curr_by_depth_unit->tests;
          }

        }
        continue;
      }

      derived_states_list->num_states = 0;
      if(the_soft_dfs_info->test_index == 0)
      {
        if(the_soft_dfs_info->tests_list_index == 0)
        {
          unsigned char num_vacant_stacks;
          unsigned char num_vacant_freecells;
          if(!(debug_iter_output_func == ((void (*)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int))NULL)))
          {
            if(*depth_ptr == 0)
              tmp_if_expr$3 = (signed long int)0;

            else
              tmp_if_expr$3 = (soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)(*depth_ptr - 1))->state->$anon0.$anon0.info.visited_iter;
            debug_iter_output_func(debug_iter_output_context, *instance_num_checked_states_ptr, *depth_ptr, (void *)instance, &pass, tmp_if_expr$3);
          }

          num_vacant_freecells=count_num_vacant_freecells(game_params.freecells_num, &ptr_state_raw->$anon0.$anon0.s);
          num_vacant_stacks=count_num_vacant_stacks(game_params.stacks_num, &ptr_state_raw->$anon0.$anon0.s);
          if(num_vacant_freecells == game_params.freecells_num && num_vacant_stacks == game_params.stacks_num)
          {
            instance->final_state = ptr_state_raw;
            *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
            *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
            return 0;
          }

          the_soft_dfs_info->num_vacant_freecells = num_vacant_freecells;
          soft_thread->num_vacant_freecells = the_soft_dfs_info->num_vacant_freecells;
          the_soft_dfs_info->num_vacant_stacks = num_vacant_stacks;
          soft_thread->num_vacant_stacks = the_soft_dfs_info->num_vacant_stacks;
          if(!(enable_pruning == (_Bool)0))
          {
            if((16 & (signed int)ptr_state_raw->$anon0.$anon0.info.visited) == 0)
            {
              struct fcs_state_keyval_pair_struct *derived;
              signed int return_value_fc_solve_sfs_raymond_prune$5;
              return_value_fc_solve_sfs_raymond_prune$5=fc_solve_sfs_raymond_prune(soft_thread, &pass, &derived);
              if(return_value_fc_solve_sfs_raymond_prune$5 == 1)
              {
                the_soft_dfs_info->tests_list_index = the_tests_list_ptr->num_lists;
                fc_solve_derived_states_list_add_state(derived_states_list, derived, 0);
                if(!(the_soft_dfs_info->derived_states_random_indexes_max_size >= 1))
                {
                  the_soft_dfs_info->derived_states_random_indexes_max_size = 1;
                  void *return_value_realloc$4;
                  return_value_realloc$4=realloc((void *)the_soft_dfs_info->derived_states_random_indexes, sizeof(struct anonymous$29) /*8ul*/  * (unsigned long int)the_soft_dfs_info->derived_states_random_indexes_max_size);
                  the_soft_dfs_info->derived_states_random_indexes = (struct anonymous$29 *)return_value_realloc$4;
                }

                (the_soft_dfs_info->derived_states_random_indexes + (signed long int)0)->idx = 0;
              }

            }

          }

        }

      }

      const signed int orig_tests_list_index = the_soft_dfs_info->tests_list_index;
      const struct anonymous$15 * const weighting = &(the_tests_list_ptr->lists + (signed long int)orig_tests_list_index)->weighting;
      if(!(the_soft_dfs_info->tests_list_index >= the_tests_list_ptr->num_lists))
      {
        local_shuffling_type = (enum anonymous$26)(the_tests_list_ptr->lists + (signed long int)the_soft_dfs_info->tests_list_index)->shuffling_type;
        (the_tests_list_ptr->lists + (signed long int)the_soft_dfs_info->tests_list_index)->tests[(signed long int)the_soft_dfs_info->test_index](soft_thread, &pass, derived_states_list);
        the_soft_dfs_info->test_index = the_soft_dfs_info->test_index + 1;
        if(the_soft_dfs_info->test_index == (the_tests_list_ptr->lists + (signed long int)the_soft_dfs_info->tests_list_index)->num_tests)
        {
          the_soft_dfs_info->tests_list_index = the_soft_dfs_info->tests_list_index + 1;
          the_soft_dfs_info->test_index = 0;
        }

      }

      signed int a;
      signed int j;
      struct anonymous$29 swap_save;
      struct anonymous$29 *rand_array;
      struct anonymous$29 *ra_ptr;
      signed int num_states = derived_states_list->num_states;
      if(!(the_soft_dfs_info->derived_states_random_indexes_max_size >= num_states))
      {
        the_soft_dfs_info->derived_states_random_indexes_max_size = num_states;
        void *return_value_realloc$6;
        return_value_realloc$6=realloc((void *)the_soft_dfs_info->derived_states_random_indexes, sizeof(struct anonymous$29) /*8ul*/  * (unsigned long int)the_soft_dfs_info->derived_states_random_indexes_max_size);
        the_soft_dfs_info->derived_states_random_indexes = (struct anonymous$29 *)return_value_realloc$6;
      }

      rand_array = the_soft_dfs_info->derived_states_random_indexes;
      a = 0;
      ra_ptr = rand_array;
      for( ; !(a >= num_states); a = a + 1)
      {
        tmp_post$7 = ra_ptr;
        ra_ptr = ra_ptr + 1l;
        tmp_post$7->idx = a;
      }
      if(num_states >= 2)
        switch((signed int)local_shuffling_type)
        {
          case FCS_RAND:
          {
            a = num_states - 1;
            while(a >= 1)
            {
              signed int return_value_fc_solve_rand_get_random_number$8;
              return_value_fc_solve_rand_get_random_number$8=fc_solve_rand_get_random_number(rand_gen);
              j = return_value_fc_solve_rand_get_random_number$8 % (a + 1);
              swap_save = rand_array[(signed long int)a];
              rand_array[(signed long int)a] = rand_array[(signed long int)j];
              rand_array[(signed long int)j] = swap_save;
              a = a - 1;
            }
            break;
          }
          case FCS_WEIGHTING:
            if(!(orig_tests_list_index >= the_tests_list_ptr->num_lists))
            {
              struct anonymous$38 *fc_solve_soft_dfs_do_solve$$1$$6$$3$$6$$4$$1$$2$$1$$derived_states = derived_states_list->states;
              a = 0;
              for( ; !(a >= num_states); a = a + 1)
              {
                signed int return_value_calc_depth$9;
                return_value_calc_depth$9=calc_depth((fc_solve_soft_dfs_do_solve$$1$$6$$3$$6$$4$$1$$2$$1$$derived_states + (signed long int)(rand_array + (signed long int)a)->idx)->state_ptr);
                (rand_array + (signed long int)a)->rating=befs_rate_state(soft_thread, weighting, &(fc_solve_soft_dfs_do_solve$$1$$6$$3$$6$$4$$1$$2$$1$$derived_states + (signed long int)(rand_array + (signed long int)a)->idx)->state_ptr->$anon0.$anon0.s, 20000 - return_value_calc_depth$9);
              }
              qsort((void *)rand_array, (unsigned long int)num_states, sizeof(struct anonymous$29) /*8ul*/ , compare_rating_with_index);
            }

          case FCS_NO_SHUFFLING:

          default:
            ;
        }

      the_soft_dfs_info->current_state_index = 0;
    }

    signed int fc_solve_soft_dfs_do_solve$$1$$6$$4$$num_states = derived_states_list->num_states;
    struct anonymous$38 *derived_states = derived_states_list->states;
    struct anonymous$29 *rand_int_ptr = the_soft_dfs_info->derived_states_random_indexes + (signed long int)the_soft_dfs_info->current_state_index;
    struct fcs_state_keyval_pair_struct *single_derived_state;
    while(!(the_soft_dfs_info->current_state_index >= fc_solve_soft_dfs_do_solve$$1$$6$$4$$num_states))
    {
      tmp_post$10 = rand_int_ptr;
      rand_int_ptr = rand_int_ptr + 1l;
      single_derived_state = (derived_states + (signed long int)tmp_post$10->idx)->state_ptr;
      the_soft_dfs_info->current_state_index = the_soft_dfs_info->current_state_index + 1;
      if((4 & (signed int)single_derived_state->$anon0.$anon0.info.visited) == 0)
      {
        if((1 << (7 & soft_thread_id) & (signed int)single_derived_state->$anon0.$anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)]) == 0)
        {
          *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
          *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
          single_derived_state->$anon0.$anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] = single_derived_state->$anon0.$anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] | (unsigned char)(1 << (soft_thread_id & (1 << 3) - 1));
          single_derived_state->$anon0.$anon0.info.visited_iter = instance->num_checked_states;
          *depth_ptr = *depth_ptr + 1;
          if(*depth_ptr >= by_depth_max_depth)
          {
            curr_by_depth_unit = curr_by_depth_unit + 1l;
            by_depth_max_depth = curr_by_depth_unit->max_depth;
            if(curr_by_depth_unit == by_depth_units)
              tmp_if_expr$11 = 0;

            else
              tmp_if_expr$11 = (curr_by_depth_unit - (signed long int)1)->max_depth;
            by_depth_min_depth = tmp_if_expr$11;
            the_tests_list_ptr = &curr_by_depth_unit->tests;
          }

          the_soft_dfs_info = the_soft_dfs_info + 1l;
          ptr_state_raw = single_derived_state;
          if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
          {
            pass.key = &ptr_state_raw->$anon0.$anon0.s;
            pass.val = &ptr_state_raw->$anon0.$anon0.info;
          }

          the_soft_dfs_info->state = ptr_state_raw;
          the_soft_dfs_info->tests_list_index = 0;
          the_soft_dfs_info->test_index = 0;
          the_soft_dfs_info->current_state_index = 0;
          the_soft_dfs_info->positions_by_rank = (char *)(void *)0;
          derived_states_list = &the_soft_dfs_info->derived_states_list;
          derived_states_list->num_states = 0;
          calculate_real_depth((const _Bool)calc_real_depth, ptr_state_raw);
          if(instance->active_num_states_in_collection >= instance->effective_trim_states_in_collection_from)
            free_states(instance);

          if(*hard_thread_num_checked_states_ptr == hard_thread_max_num_checked_states)
            tmp_if_expr$12 = (_Bool)1;

          else
            tmp_if_expr$12 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$12)
            return 5;

          break;
        }

      }

    }
  }
  *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
  *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
  *depth_ptr = -1;
  return 1;
}

// fc_solve_soft_thread_init_befs_or_bfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1212
extern void fc_solve_soft_thread_init_befs_or_bfs(struct fc_solve_soft_thread_struct *soft_thread)
{
  fc_solve_soft_thread_update_initial_cards_val$link1(soft_thread);
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  if(soft_thread->method == 3)
  {
    fc_solve_PQueueInitialise(&soft_thread->method_specific.befs.meth.befs.pqueue, 1024);
    fc_solve_initialize_befs_rater$link1(soft_thread, &soft_thread->method_specific.befs.meth.befs.weighting);
  }

  else
    fc_solve_initialize_bfs_queue(soft_thread);
  if(soft_thread->method_specific.befs.tests_list == ((void (**)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *))NULL))
  {
    signed int num = 0;
    void (**tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(void (*)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *)) /*8ul*/  * (unsigned long int)1);
    tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *))return_value_malloc$1;
    signed int group_idx = 0;
    for( ; !(group_idx >= soft_thread->by_depth_tests_order.by_depth_tests->tests_order.num_groups); group_idx = group_idx + 1)
    {
      signed int * const tests_order_tests = ((soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.groups + (signed long int)group_idx)->tests;
      const signed int tests_order_num = ((soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.groups + (signed long int)group_idx)->num;
      signed int i = 0;
      for( ; !(i >= tests_order_num); i = i + 1)
      {
        num = num + 1;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)tests_list, sizeof(void (*)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *)) /*8ul*/  * (unsigned long int)num);
        tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *))return_value_realloc$2;
        tests_list[(signed long int)(num - 1)] = fc_solve_sfs_tests[(signed long int)tests_order_tests[(signed long int)i]];
      }
    }
    soft_thread->method_specific.befs.tests_list = tests_list;
    soft_thread->method_specific.befs.tests_list_end = tests_list + (signed long int)num;
  }

  soft_thread->first_state_to_check = instance->state_copy_ptr;
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// fc_solve_soft_thread_init_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1098
static inline void fc_solve_soft_thread_init_soft_dfs(struct fc_solve_soft_thread_struct *soft_thread)
{
  fc_solve_soft_thread_update_initial_cards_val(soft_thread);
  struct fc_solve_instance_struct *instance = soft_thread->hard_thread->instance;
  struct fcs_state_keyval_pair_struct *ptr_orig_state = instance->state_copy_ptr;
  soft_thread->method_specific.soft_dfs.depth = 0;
  fc_solve_increase_dfs_max_depth(soft_thread);
  (soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)0)->state = ptr_orig_state;
  fc_solve_rand_init(&soft_thread->method_specific.soft_dfs.rand_gen, (unsigned int)soft_thread->method_specific.soft_dfs.rand_seed);
  void (**tmp_post$4)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
  signed int tmp_post$5;
  signed int tmp_if_expr$6;
  if(soft_thread->method_specific.soft_dfs.tests_by_depth_array.by_depth_units == ((struct anonymous$52 *)NULL))
  {
    struct anonymous$16 *tests_list_of_lists;
    void (**tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
    void (**next_test)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *);
    struct anonymous$17 *tests_list_struct_ptr;
    struct anonymous$18 *arr_ptr;
    signed int tests_order_num;
    struct anonymous$20 *tests_order_groups;
    _Bool master_to_randomize = soft_thread->method == 5;
    signed int depth_idx;
    struct anonymous$21 *by_depth_tests_order;
    arr_ptr = &soft_thread->method_specific.soft_dfs.tests_by_depth_array;
    arr_ptr->num_units = soft_thread->by_depth_tests_order.num;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$52) /*24ul*/  * (unsigned long int)arr_ptr->num_units);
    arr_ptr->by_depth_units = (struct anonymous$52 *)return_value_malloc$1;
    by_depth_tests_order = soft_thread->by_depth_tests_order.by_depth_tests;
    depth_idx = 0;
    for( ; !(depth_idx >= soft_thread->by_depth_tests_order.num); depth_idx = depth_idx + 1)
    {
      (arr_ptr->by_depth_units + (signed long int)depth_idx)->max_depth = (by_depth_tests_order + (signed long int)depth_idx)->max_depth;
      tests_order_groups = (by_depth_tests_order + (signed long int)depth_idx)->tests_order.groups;
      tests_order_num = (by_depth_tests_order + (signed long int)depth_idx)->tests_order.num_groups;
      tests_list_of_lists = &(arr_ptr->by_depth_units + (signed long int)depth_idx)->tests;
      tests_list_of_lists->num_lists = 0;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct anonymous$17) /*224ul*/  * (unsigned long int)tests_order_num);
      tests_list_of_lists->lists = (struct anonymous$17 *)return_value_malloc$2;
      signed int group_idx = 0;
      for( ; !(group_idx >= tests_order_num); group_idx = group_idx + 1)
      {
        signed int num = (tests_order_groups + (signed long int)group_idx)->num;
        signed int *tests_order_tests = (tests_order_groups + (signed long int)group_idx)->tests;
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(void (*)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *)) /*8ul*/  * (unsigned long int)num);
        tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *))return_value_malloc$3;
        next_test = tests_list;
        signed int i = 0;
        for( ; !(i >= num); i = i + 1)
        {
          tmp_post$4 = next_test;
          next_test = next_test + 1l;
          *tmp_post$4 = fc_solve_sfs_tests[(signed long int)tests_order_tests[(signed long int)i]];
        }
        tmp_post$5 = tests_list_of_lists->num_lists;
        tests_list_of_lists->num_lists = tests_list_of_lists->num_lists + 1;
        tests_list_struct_ptr = &tests_list_of_lists->lists[(signed long int)tmp_post$5];
        tests_list_struct_ptr->tests = tests_list;
        tests_list_struct_ptr->num_tests = num;
        if(!(master_to_randomize == (_Bool)0))
          tmp_if_expr$6 = (signed int)(tests_order_groups + (signed long int)group_idx)->shuffling_type;

        else
          tmp_if_expr$6 = FCS_NO_SHUFFLING;
        tests_list_struct_ptr->shuffling_type = tmp_if_expr$6;
        if(tests_list_struct_ptr->shuffling_type == FCS_WEIGHTING)
        {
          tests_list_struct_ptr->weighting = (tests_order_groups + (signed long int)group_idx)->weighting;
          fc_solve_initialize_befs_rater(soft_thread, &tests_list_struct_ptr->weighting);
        }

      }
      void *return_value_realloc$7;
      return_value_realloc$7=realloc((void *)tests_list_of_lists->lists, sizeof(struct anonymous$17) /*224ul*/  * (unsigned long int)tests_list_of_lists->num_lists);
      tests_list_of_lists->lists = (struct anonymous$17 *)return_value_realloc$7;
    }
  }

  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L11:
  ;
}

// fc_solve_soft_thread_update_initial_cards_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val(struct fc_solve_soft_thread_struct *soft_thread)
{
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  struct anonymous$6 pass;
  pass.key = &instance->state_copy_ptr->$anon0.$anon0.s;
  pass.val = &instance->state_copy_ptr->$anon0.$anon0.info;
  double cards_under_sequences = (double)0;
  signed int a = 0;
  for( ; !(a >= (signed int)instance->game_params.stacks_num); a = a + 1)
  {
    char * const col = pass.key->stacks[(signed long int)a];
    signed int return_value_update_col_cards_under_sequences$1;
    return_value_update_col_cards_under_sequences$1=update_col_cards_under_sequences(sequences_are_built_by, col, (signed int)col[(signed long int)0] - 1);
    cards_under_sequences = cards_under_sequences + fc_solve_seqs_over_cards_lookup[(signed long int)return_value_update_col_cards_under_sequences$1];
  }
  soft_thread->initial_cards_under_sequences_value = cards_under_sequences;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_soft_thread_update_initial_cards_val$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val$link1(struct fc_solve_soft_thread_struct *soft_thread$link1)
{
  struct fc_solve_instance_struct * const instance$link1 = soft_thread$link1->hard_thread->instance;
  const signed int sequences_are_built_by$link1 = (signed int)instance$link1->game_params.game_flags & 0x3;
  struct anonymous$6 pass$link1;
  pass$link1.key = &instance$link1->state_copy_ptr->$anon0.$anon0.s;
  pass$link1.val = &instance$link1->state_copy_ptr->$anon0.$anon0.info;
  double cards_under_sequences$link1 = (double)0;
  signed int a$link1 = 0;
  for( ; !(a$link1 >= (signed int)instance$link1->game_params.stacks_num); a$link1 = a$link1 + 1)
  {
    char * const col$link1 = pass$link1.key->stacks[(signed long int)a$link1];
    signed int return_value_update_col_cards_under_sequences$1$link1;
    return_value_update_col_cards_under_sequences$1$link1=update_col_cards_under_sequences$link1(sequences_are_built_by$link1, col$link1, (signed int)col$link1[(signed long int)0] - 1);
    cards_under_sequences$link1 = cards_under_sequences$link1 + fc_solve_seqs_over_cards_lookup[(signed long int)return_value_update_col_cards_under_sequences$1$link1];
  }
  soft_thread$link1->initial_cards_under_sequences_value = cards_under_sequences$link1;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_stack_compare_for_comparison
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison(const void * const v_s1, const void * const v_s2)
{
  const char * const s1 = (const char *)v_s1;
  const char * const s2 = (const char *)v_s2;
  signed int min_len;
  signed int tmp_if_expr$1;
  if(!((signed int)*s1 >= (signed int)*s2))
    tmp_if_expr$1 = (signed int)s1[(signed long int)0];

  else
    tmp_if_expr$1 = (signed int)s2[(signed long int)0];
  min_len = tmp_if_expr$1;
  signed int a = 1;
  for( ; min_len >= a; a = a + 1)
  {
    signed int ret;
    ret=fc_solve_card_compare(s1[(signed long int)a], s2[(signed long int)a]);
    if(!(ret == 0))
      return ret;

  }
  if(!((signed int)*s1 >= (signed int)*s2))
    return -1;

  else
    if(!((signed int)*s2 >= (signed int)*s1))
      return 1;

    else
      return 0;
}

// fc_solve_stack_compare_for_comparison$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison$link1(const void * const v_s1$link1, const void * const v_s2$link1)
{
  const char * const s1$link1 = (const char *)v_s1$link1;
  const char * const s2$link1 = (const char *)v_s2$link1;
  signed int min_len$link1;
  signed int tmp_if_expr$1$link1;
  if(!((signed int)*s1$link1 >= (signed int)*s2$link1))
    tmp_if_expr$1$link1 = (signed int)s1$link1[(signed long int)0];

  else
    tmp_if_expr$1$link1 = (signed int)s2$link1[(signed long int)0];
  min_len$link1 = tmp_if_expr$1$link1;
  signed int a$link1 = 1;
  for( ; min_len$link1 >= a$link1; a$link1 = a$link1 + 1)
  {
    signed int ret$link1;
    ret$link1=fc_solve_card_compare$link1(s1$link1[(signed long int)a$link1], s2$link1[(signed long int)a$link1]);
    if(!(ret$link1 == 0))
      return ret$link1;

  }
  if(!((signed int)*s1$link1 >= (signed int)*s2$link1))
    return -1;

  else
    if(!((signed int)*s2$link1 >= (signed int)*s1$link1))
      return 1;

    else
      return 0;
}

// fc_solve_start_instance_process_with_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 808
extern void fc_solve_start_instance_process_with_board(struct fc_solve_instance_struct * const instance, struct fcs_state_keyval_pair_struct * const init_state)
{
  struct fcs_state_keyval_pair_struct *state_copy_ptr;
  void *return_value_fcs_compact_alloc_ptr$1;
  return_value_fcs_compact_alloc_ptr$1=fcs_compact_alloc_ptr$link1(&(instance->hard_threads + (signed long int)0)->allocator, (signed int)sizeof(struct fcs_state_keyval_pair_struct) /*144ul*/ );
  state_copy_ptr = (struct fcs_state_keyval_pair_struct *)return_value_fcs_compact_alloc_ptr$1;
  struct anonymous$6 pass_copy;
  struct anonymous$6 pass_init;
  pass_copy.key = &state_copy_ptr->$anon0.$anon0.s;
  pass_copy.val = &state_copy_ptr->$anon0.$anon0.info;
  pass_init.key = &init_state->$anon0.$anon0.s;
  pass_init.val = &init_state->$anon0.$anon0.info;
  *(&pass_copy)->key = *(&pass_init)->key;
  *(&pass_copy)->val = *(&pass_init)->val;
  (&pass_copy)->val->stacks_copy_on_write_flags = 0;
  signed int i;
  char *buffer = (instance->hard_threads + (signed long int)0)->indirect_stacks_buffer;
  i = 0;
  for( ; !(i >= (signed int)instance->game_params.stacks_num); i = i + 1)
    if((state_copy_ptr->$anon0.$anon0.info.stacks_copy_on_write_flags & 1 << i) == 0)
    {
      char *copy_stack_col;
      state_copy_ptr->$anon0.$anon0.info.stacks_copy_on_write_flags = state_copy_ptr->$anon0.$anon0.info.stacks_copy_on_write_flags | 1 << i;
      copy_stack_col = state_copy_ptr->$anon0.$anon0.s.stacks[(signed long int)i];
      memcpy((void *)&buffer[(signed long int)(i << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      state_copy_ptr->$anon0.$anon0.s.stacks[(signed long int)i] = &buffer[(signed long int)(i << 7)];
    }

  state_copy_ptr->$anon0.$anon0.info.depth = 0;
  state_copy_ptr->$anon0.$anon0.info.moves_to_parent = (struct anonymous$3 *)(void *)0;
  state_copy_ptr->$anon0.$anon0.info.visited = (unsigned char)0;
  state_copy_ptr->$anon0.$anon0.info.parent = (struct fcs_state_keyval_pair_struct *)(void *)0;
  memset((void *)&state_copy_ptr->$anon0.$anon0.info.scan_visited, 0, sizeof(unsigned char [4l]) /*4ul*/ );
  instance->state_copy_ptr = state_copy_ptr;
  fc_solve_hash_init(instance->meta_alloc, &instance->hash, (const enum FCS_INLINED_HASH_DATA_TYPE)FCS_INLINED_HASH__STATES);
  fc_solve_hash_init(instance->meta_alloc, &instance->stacks_hash, (const enum FCS_INLINED_HASH_DATA_TYPE)FCS_INLINED_HASH__COLUMNS);
  struct anonymous$6 no_use;
  struct anonymous$6 pass;
  pass.key = &state_copy_ptr->$anon0.$anon0.s;
  pass.val = &state_copy_ptr->$anon0.$anon0.info;
  fc_solve_check_and_add_state(instance->hard_threads, &pass, &no_use);
  instance->current_hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
    if(!(hard_thread->prelude == ((struct anonymous$42 *)NULL)))
    {
      hard_thread->prelude_idx = 0;
      hard_thread->st_idx = (hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->scan_idx;
      hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->quota;
      hard_thread->prelude_idx = hard_thread->prelude_idx + 1;
    }

    else
      hard_thread->st_idx = 0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~32;
  if(!((16 & (signed int)instance->runtime_flags) == 0))
    instance->runtime_flags = instance->runtime_flags | (unsigned char)32;

  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
}

// fc_solve_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1016
extern char * fc_solve_state_as_string(struct fcs_struct_state_t *state, struct anonymous$7 *state_locs, signed int freecells_num, signed int stacks_num, signed int decks_num, _Bool parseable_output, _Bool canonized_order_output, _Bool display_10_as_t)
{
  char freecell[10l];
  char decks[8l][10l];
  char stack_card_str[10l];
  signed int a;
  signed int b;
  _Bool rank_is_null;
  signed int max_num_cards;
  signed int s;
  signed int card_idx;
  char *col;
  signed int col_len;
  char str2[128l];
  char str3[128l];
  char *str2_ptr;
  char *str3_ptr;
  struct anonymous$51 app_str_struct;
  signed int stack_locs[10l];
  signed int freecell_locs[8l];
  if(!(canonized_order_output == (_Bool)0))
  {
    a = 0;
    for( ; !(a >= stacks_num); a = a + 1)
      stack_locs[(signed long int)a] = a;
    a = 0;
    for( ; !(a >= freecells_num); a = a + 1)
      freecell_locs[(signed long int)a] = a;
  }

  else
  {
    a = 0;
    for( ; !(a >= stacks_num); a = a + 1)
      stack_locs[(signed long int)(signed int)state_locs->stack_locs[(signed long int)a]] = a;
    a = 0;
    for( ; !(a >= freecells_num); a = a + 1)
      freecell_locs[(signed long int)(signed int)state_locs->fc_locs[(signed long int)a]] = a;
  }
  a = 0;
  for( ; !(a >= 4 * decks_num); a = a + 1)
  {
    fc_solve_p2u_rank((signed int)state->foundations[(signed long int)a], decks[(signed long int)a], &rank_is_null, display_10_as_t);
    if((signed int)decks[(signed long int)a][0l] == 32)
      decks[(signed long int)a][(signed long int)0] = (char)48;

  }
  fc_solve_append_string_init(&app_str_struct);
  if(parseable_output == (_Bool)0)
  {
    a = 0;
    for( ; !(a >= freecells_num / 4 + (freecells_num % 4 == 0 ? 0 : 1)); a = a + 1)
    {
      str2_ptr = str2;
      str3_ptr = str3;
      b = 0;
      for( ; !(b >= (freecells_num + -(4 * a) >= 4 ? 4 : freecells_num + -(4 * a))); b = b + 1)
      {
        char *return_value_fc_solve_card_perl2user$1;
        return_value_fc_solve_card_perl2user$1=fc_solve_card_perl2user(state->freecells[(signed long int)freecell_locs[(signed long int)(a * 4 + b)]], freecell, display_10_as_t);
        signed int return_value_sprintf$2;
        return_value_sprintf$2=sprintf(str2_ptr, "%3s ", return_value_fc_solve_card_perl2user$1);
        str2_ptr = str2_ptr + (signed long int)return_value_sprintf$2;
        signed int return_value_sprintf$3;
        return_value_sprintf$3=sprintf(str3_ptr, "--- ");
        str3_ptr = str3_ptr + (signed long int)return_value_sprintf$3;
      }
      if(!(a >= decks_num))
        fc_solve_append_string_sprintf(&app_str_struct, "%-16s        H-%1s C-%1s D-%1s S-%1s\n", (const void *)str2, (const void *)decks[(signed long int)(a * 4)], (const void *)decks[(signed long int)(a * 4 + 1)], (const void *)decks[(signed long int)(a * 4 + 2)], (const void *)decks[(signed long int)(a * 4 + 3)]);

      else
        fc_solve_append_string_sprintf(&app_str_struct, "%s\n", (const void *)str2);
      fc_solve_append_string_sprintf(&app_str_struct, "%s\n", (const void *)str3);
    }
    for( ; !(a >= decks_num); a = a + 1)
      fc_solve_append_string_sprintf(&app_str_struct, "%-16s        H-%1s C-%1s D-%1s S-%1s\n", (const void *)"", (const void *)decks[(signed long int)(a * 4)], (const void *)decks[(signed long int)(a * 4 + 1)], (const void *)decks[(signed long int)(a * 4 + 2)], (const void *)decks[(signed long int)(a * 4 + 3)]);
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n\n");
    s = 0;
    for( ; !(s >= stacks_num); s = s + 1)
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)" -- ");
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    max_num_cards = 0;
    s = 0;
    for( ; !(s >= stacks_num); s = s + 1)
    {
      col = state->stacks[(signed long int)stack_locs[(signed long int)s]];
      col_len = (signed int)col[(signed long int)0];
      if(!(max_num_cards >= col_len))
        max_num_cards = col_len;

    }
    card_idx = 0;
    for( ; !(card_idx >= max_num_cards); card_idx = card_idx + 1)
    {
      s = 0;
      for( ; !(s >= stacks_num); s = s + 1)
      {
        col = state->stacks[(signed long int)stack_locs[(signed long int)s]];
        col_len = (signed int)col[(signed long int)0];
        if(card_idx >= col_len)
          fc_solve_append_string_sprintf(&app_str_struct, "    ");

        else
        {
          char *return_value_fc_solve_card_perl2user$4;
          return_value_fc_solve_card_perl2user$4=fc_solve_card_perl2user(col[(signed long int)(card_idx + 1)], stack_card_str, display_10_as_t);
          fc_solve_append_string_sprintf(&app_str_struct, "%3s ", return_value_fc_solve_card_perl2user$4);
        }
      }
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    }
  }

  else
  {
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"Foundations: ");
    a = 0;
    for( ; !(a >= decks_num); a = a + 1)
      fc_solve_append_string_sprintf(&app_str_struct, "H-%s C-%s D-%s S-%s ", (const void *)decks[(signed long int)(a * 4)], (const void *)decks[(signed long int)(a * 4 + 1)], (const void *)decks[(signed long int)(a * 4 + 2)], (const void *)decks[(signed long int)(a * 4 + 3)]);
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\nFreecells: ");
    a = 0;
    for( ; !(a >= freecells_num); a = a + 1)
    {
      char *return_value_fc_solve_card_perl2user$5;
      return_value_fc_solve_card_perl2user$5=fc_solve_card_perl2user(state->freecells[(signed long int)freecell_locs[(signed long int)a]], freecell, display_10_as_t);
      fc_solve_append_string_sprintf(&app_str_struct, "%3s", return_value_fc_solve_card_perl2user$5);
      if(!(a >= freecells_num + -1))
        fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)" ");

    }
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    s = 0;
    for( ; !(s >= stacks_num); s = s + 1)
    {
      col = state->stacks[(signed long int)stack_locs[(signed long int)s]];
      col_len = (signed int)col[(signed long int)0];
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)": ");
      card_idx = 0;
      for( ; !(card_idx >= col_len); card_idx = card_idx + 1)
      {
        fc_solve_card_perl2user(col[(signed long int)(card_idx + 1)], stack_card_str, display_10_as_t);
        fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)stack_card_str);
        if(!(card_idx >= col_len + -1))
          fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)" ");

      }
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    }
  }
  char *return_value_fc_solve_append_string_finalize$6;
  return_value_fc_solve_append_string_finalize$6=fc_solve_append_string_finalize(&app_str_struct);
  return return_value_fc_solve_append_string_finalize$6;
}

// fc_solve_state_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 655
static inline signed int fc_solve_state_compare(const void *s1, const void *s2)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp(s1, s2, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  return return_value_memcmp$1;
}

// fc_solve_state_compare_with_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.c line 216
extern signed int fc_solve_state_compare_with_context(const void *s1, const void *s2, void *context)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp(s1, s2, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  return return_value_memcmp$1;
}

// fc_solve_state_init_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 736
static inline void fc_solve_state_init_proto(struct fcs_state_keyval_pair_struct *state, signed int stacks_num, char *indirect_stacks_buffer)
{
  signed int i;
  memset((void *)&state->$anon0.$anon0.s, 0, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  i = 0;
  for( ; !(i >= stacks_num); i = i + 1)
  {
    state->$anon0.$anon0.s.stacks[(signed long int)i] = &indirect_stacks_buffer[(signed long int)(i << 7)];
    memset((void *)state->$anon0.$anon0.s.stacks[(signed long int)i], 0, (unsigned long int)(2 * 52 + 1));
  }
  for( ; !(i >= 10); i = i + 1)
    state->$anon0.$anon0.s.stacks[(signed long int)i] = (char *)(void *)0;
  state->$anon0.$anon0.info.parent = (struct fcs_state_keyval_pair_struct *)(void *)0;
  state->$anon0.$anon0.info.moves_to_parent = (struct anonymous$3 *)(void *)0;
  state->$anon0.$anon0.info.depth = 0;
  state->$anon0.$anon0.info.visited = (unsigned char)0;
  state->$anon0.$anon0.info.visited_iter = (signed long int)0;
  state->$anon0.$anon0.info.num_active_children = (unsigned short int)0;
  memset((void *)state->$anon0.$anon0.info.scan_visited, 0, sizeof(unsigned char [4l]) /*4ul*/ );
  state->$anon0.$anon0.info.stacks_copy_on_write_flags = 0;
}

// fc_solve_string_to_test_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num(const char *s)
{
  struct anonymous$47 needle;
  struct anonymous$47 *result;
  needle.alias = s;
  void *return_value_bsearch$1;
  return_value_bsearch$1=bsearch((const void *)&needle, (const void *)fc_solve_sfs_tests_aliases, (unsigned long int)24, sizeof(struct anonymous$47) /*16ul*/ , fc_solve_string_to_test_num_compare_func);
  result = (struct anonymous$47 *)return_value_bsearch$1;
  signed int tmp_if_expr$2;
  if(!(result == ((struct anonymous$47 *)NULL)))
    tmp_if_expr$2 = result->test_num;

  else
    tmp_if_expr$2 = 0;
  return tmp_if_expr$2;
}

// fc_solve_string_to_test_num$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num$link1(const char *s$link1)
{
  struct anonymous$47 needle$link1;
  struct anonymous$47 *result$link1;
  needle$link1.alias = s$link1;
  void *return_value_bsearch$1$link1;
  return_value_bsearch$1$link1=bsearch((const void *)&needle$link1, (const void *)fc_solve_sfs_tests_aliases, (unsigned long int)24, sizeof(struct anonymous$47) /*16ul*/ , fc_solve_string_to_test_num_compare_func$link1);
  result$link1 = (struct anonymous$47 *)return_value_bsearch$1$link1;
  signed int tmp_if_expr$2$link1;
  if(!(result$link1 == ((struct anonymous$47 *)NULL)))
    tmp_if_expr$2$link1 = result$link1->test_num;

  else
    tmp_if_expr$2$link1 = 0;
  return tmp_if_expr$2$link1;
}

// fc_solve_string_to_test_num_compare_func
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func(const void *a, const void *b)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(((const struct anonymous$47 *)a)->alias, ((const struct anonymous$47 *)b)->alias);
  return return_value_strcmp$1;
}

// fc_solve_string_to_test_num_compare_func$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func$link1(const void *a$link1, const void *b$link1)
{
  signed int return_value_strcmp$1$link1;
  return_value_strcmp$1$link1=strcmp(((const struct anonymous$47 *)a$link1)->alias, ((const struct anonymous$47 *)b$link1)->alias);
  return return_value_strcmp$1$link1;
}

// fc_solve_trace_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 716
extern void fc_solve_trace_solution(struct fc_solve_instance_struct * const instance)
{
  struct anonymous$4 canonize_move = fc_solve_empty_move;
  canonize_move.c[(signed long int)0] = (unsigned char)12;
  if(!(instance->solution_moves.moves == ((struct anonymous$4 *)NULL)))
  {
    free((void *)instance->solution_moves.moves);
    instance->solution_moves.moves = (struct anonymous$4 *)(void *)0;
  }

  instance->solution_moves.num_moves = (unsigned short int)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)16);
  instance->solution_moves.moves = (struct anonymous$4 *)return_value_malloc$1;
  struct fcs_state_keyval_pair_struct *s1 = instance->final_state;
  struct anonymous$3 * const solution_moves_ptr = &instance->solution_moves;
  for( ; !(s1->$anon0.$anon0.info.parent == ((struct fcs_state_keyval_pair_struct *)NULL)); s1 = s1->$anon0.$anon0.info.parent)
  {
    s1->$anon0.$anon0.info.visited = s1->$anon0.$anon0.info.visited | (unsigned char)1;
    fcs_move_stack_push$link1(solution_moves_ptr, canonize_move);
    const struct anonymous$3 * const stack = s1->$anon0.$anon0.info.moves_to_parent;
    const struct anonymous$4 * const moves = stack->moves;
    signed int move_idx = (signed int)stack->num_moves - 1;
    for( ; move_idx >= 0; move_idx = move_idx - 1)
      fcs_move_stack_push$link1(solution_moves_ptr, moves[(signed long int)move_idx]);
  }
  s1->$anon0.$anon0.info.visited = s1->$anon0.$anon0.info.visited | (unsigned char)1;
}

// fc_solve_u2p_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 46
extern signed int fc_solve_u2p_rank(const char *string)
{
  while((_Bool)1)
  {
    signed int return_value_toupper$1;
    return_value_toupper$1=toupper((signed int)*string);
    switch(return_value_toupper$1)
    {
      case 0:

      case 32:

      case 9:
        return 0;
      case 65:
        return 1;
      case 74:
        return 11;
      case 81:
        return 12;
      case 75:
        return 13;
      case 49:
        return (signed int)string[(signed long int)1] == 48 ? 10 : 1;
      case 84:

      case 48:
        return 10;
      case 50:
        return 2;
      case 51:
        return 3;
      case 52:
        return 4;
      case 53:
        return 5;
      case 54:
        return 6;
      case 55:
        return 7;
      case 56:
        return 8;
      case 57:
        return 9;
      default:
        string = string + 1l;
    }
  }
}

// fc_solve_u2p_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 99
extern signed int fc_solve_u2p_suit(const char *suit)
{
  while((_Bool)1)
  {
    signed int return_value_toupper$1;
    return_value_toupper$1=toupper((signed int)*suit);
    switch(return_value_toupper$1)
    {
      case 72:

      case 32:

      case 0:
        return 0;
      case 67:
        return 1;
      case 68:
        return 2;
      case 83:
        return 3;
      default:
        suit = suit + 1l;
    }
  }
}

// fcs_compact_alloc_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr(struct anonymous$5 *allocator, signed int how_much)
{
  how_much = how_much + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator->max_ptr - allocator->ptr >= (signed long int)how_much))
    fc_solve_compact_allocator_extend(allocator);

  else
    allocator->rollback_ptr = allocator->ptr;
  allocator->ptr = allocator->ptr + (signed long int)how_much;
  return (void *)allocator->rollback_ptr;
}

// fcs_compact_alloc_ptr$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr$link1(struct anonymous$5 *allocator$link1, signed int how_much$link1)
{
  how_much$link1 = how_much$link1 + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much$link1 & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator$link1->max_ptr - allocator$link1->ptr >= (signed long int)how_much$link1))
    fc_solve_compact_allocator_extend(allocator$link1);

  else
    allocator$link1->rollback_ptr = allocator$link1->ptr;
  allocator$link1->ptr = allocator$link1->ptr + (signed long int)how_much$link1;
  return (void *)allocator$link1->rollback_ptr;
}

// fcs_compact_alloc_ptr$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr$link2(struct anonymous$5 *allocator$link2, signed int how_much$link2)
{
  how_much$link2 = how_much$link2 + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much$link2 & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator$link2->max_ptr - allocator$link2->ptr >= (signed long int)how_much$link2))
    fc_solve_compact_allocator_extend(allocator$link2);

  else
    allocator$link2->rollback_ptr = allocator$link2->ptr;
  allocator$link2->ptr = allocator$link2->ptr + (signed long int)how_much$link2;
  return (void *)allocator$link2->rollback_ptr;
}

// fcs_compact_alloc_ptr$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr$link3(struct anonymous$5 *allocator$link3, signed int how_much$link3)
{
  how_much$link3 = how_much$link3 + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much$link3 & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator$link3->max_ptr - allocator$link3->ptr >= (signed long int)how_much$link3))
    fc_solve_compact_allocator_extend(allocator$link3);

  else
    allocator$link3->rollback_ptr = allocator$link3->ptr;
  allocator$link3->ptr = allocator$link3->ptr + (signed long int)how_much$link3;
  return (void *)allocator$link3->rollback_ptr;
}

// fcs_get_preset_by_id
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 531
static inline signed int fcs_get_preset_by_id(signed int preset_id, const struct anonymous$36 **preset_ptr)
{
  signed int preset_index = 0;
  for( ; !(preset_index >= 23); preset_index = preset_index + 1)
    if(fcs_presets[(signed long int)preset_index].preset_id == preset_id)
    {
      *preset_ptr = &fcs_presets[(signed long int)preset_index];
      return 0;
    }

  return 1;
}

// fcs_get_preset_id_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 412
static inline signed int fcs_get_preset_id_by_name(const char *name)
{
  signed int a;
  signed int ret = -1;
  a = 0;
  for( ; !(a >= 23); a = a + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(name, fcs_preset_names[(signed long int)a].name);
    if(return_value_strcmp$1 == 0)
    {
      ret = fcs_preset_names[(signed long int)a].preset_id;
      break;
    }

  }
  return ret;
}

// fcs_is_ss_suit_true
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 58
static inline const _Bool fcs_is_ss_suit_true(const char parent, const char child)
{
  return ((signed int)parent & 0x03) == ((signed int)child & 0x03);
}

// fcs_is_ss_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 65
static inline const _Bool fcs_is_ss_true_parent(const char parent, const char child)
{
  _Bool tmp_if_expr$2;
  _Bool return_value_fcs_is_ss_suit_true$1;
  if((signed int)parent >> 2 == ((signed int)child >> 2) + 1)
  {
    return_value_fcs_is_ss_suit_true$1=fcs_is_ss_suit_true(parent, child);
    tmp_if_expr$2 = return_value_fcs_is_ss_suit_true$1 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  return tmp_if_expr$2;
}

// fcs_make_card
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card(const signed int rank, const signed int suit)
{
  return (char)((signed int)(char)rank << 2 | (signed int)(char)suit);
}

// fcs_make_card$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card$link1(const signed int rank$link1, const signed int suit$link1)
{
  return (char)((signed int)(char)rank$link1 << 2 | (signed int)(char)suit$link1);
}

// fcs_move_stack_non_seq_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push(struct anonymous$3 * const stack, const signed int type, const signed int src, const signed int dest)
{
  fcs_move_stack_params_push(stack, type, src, dest, 1);
}

// fcs_move_stack_non_seq_push$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push$link1(struct anonymous$3 * const stack$link1, const signed int type$link1, const signed int src$link1, const signed int dest$link1)
{
  fcs_move_stack_params_push$link1(stack$link1, type$link1, src$link1, dest$link1, 1);
}

// fcs_move_stack_params_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push(struct anonymous$3 * const stack, const signed int type, const signed int src, const signed int dest, const signed int num_cards_in_seq)
{
  struct anonymous$4 temp_move;
  temp_move.c[(signed long int)0] = (unsigned char)type;
  temp_move.c[(signed long int)1] = (unsigned char)src;
  temp_move.c[(signed long int)2] = (unsigned char)dest;
  temp_move.c[(signed long int)3] = (unsigned char)num_cards_in_seq;
  fcs_move_stack_push(stack, temp_move);
}

// fcs_move_stack_params_push$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push$link1(struct anonymous$3 * const stack$link1, const signed int type$link1, const signed int src$link1, const signed int dest$link1, const signed int num_cards_in_seq$link1)
{
  struct anonymous$4 temp_move$link1;
  temp_move$link1.c[(signed long int)0] = (unsigned char)type$link1;
  temp_move$link1.c[(signed long int)1] = (unsigned char)src$link1;
  temp_move$link1.c[(signed long int)2] = (unsigned char)dest$link1;
  temp_move$link1.c[(signed long int)3] = (unsigned char)num_cards_in_seq$link1;
  fcs_move_stack_push$link3(stack$link1, temp_move$link1);
}

// fcs_move_stack_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push(struct anonymous$3 * const stack, const struct anonymous$4 move)
{
  signed int pos;
  stack->num_moves = stack->num_moves + 1;
  pos = (const signed int)stack->num_moves;
  if((16 & pos) == 0)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)stack->moves, sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)(pos + 16));
    stack->moves = (struct anonymous$4 *)return_value_realloc$1;
  }

  stack->moves[(signed long int)(pos - 1)] = move;
}

// fcs_move_stack_push$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push$link1(struct anonymous$3 * const stack$link1, const struct anonymous$4 move$link1)
{
  signed int pos$link1;
  stack$link1->num_moves = stack$link1->num_moves + 1;
  pos$link1 = (const signed int)stack$link1->num_moves;
  if((16 & pos$link1) == 0)
  {
    void *return_value_realloc$1$link1;
    return_value_realloc$1$link1=realloc((void *)stack$link1->moves, sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)(pos$link1 + 16));
    stack$link1->moves = (struct anonymous$4 *)return_value_realloc$1$link1;
  }

  stack$link1->moves[(signed long int)(pos$link1 - 1)] = move$link1;
}

// fcs_move_stack_push$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push$link2(struct anonymous$3 * const stack$link2, const struct anonymous$4 move$link2)
{
  signed int pos$link2;
  stack$link2->num_moves = stack$link2->num_moves + 1;
  pos$link2 = (const signed int)stack$link2->num_moves;
  if((16 & pos$link2) == 0)
  {
    void *return_value_realloc$1$link2;
    return_value_realloc$1$link2=realloc((void *)stack$link2->moves, sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)(pos$link2 + 16));
    stack$link2->moves = (struct anonymous$4 *)return_value_realloc$1$link2;
  }

  stack$link2->moves[(signed long int)(pos$link2 - 1)] = move$link2;
}

// fcs_move_stack_push$link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push$link3(struct anonymous$3 * const stack$link3, const struct anonymous$4 move$link3)
{
  signed int pos$link3;
  stack$link3->num_moves = stack$link3->num_moves + 1;
  pos$link3 = (const signed int)stack$link3->num_moves;
  if((16 & pos$link3) == 0)
  {
    void *return_value_realloc$1$link3;
    return_value_realloc$1$link3=realloc((void *)stack$link3->moves, sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)(pos$link3 + 16));
    stack$link3->moves = (struct anonymous$4 *)return_value_realloc$1$link3;
  }

  stack$link3->moves[(signed long int)(pos$link3 - 1)] = move$link3;
}

// fcs_push_1card_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 89
static inline void fcs_push_1card_seq(struct anonymous$3 * const stack, const signed int src, const signed int dest)
{
  fcs_move_stack_params_push(stack, 0, src, dest, 1);
}

// fcs_state_ia_alloc_into_var
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 115
static inline struct fcs_state_keyval_pair_struct * fcs_state_ia_alloc_into_var(struct anonymous$5 *allocator)
{
  struct fcs_state_keyval_pair_struct *ret_helper;
  void *return_value_fcs_compact_alloc_ptr$1;
  return_value_fcs_compact_alloc_ptr$1=fcs_compact_alloc_ptr$link2(allocator, (signed int)sizeof(struct fcs_state_keyval_pair_struct) /*144ul*/ );
  ret_helper = (struct fcs_state_keyval_pair_struct *)return_value_fcs_compact_alloc_ptr$1;
  return ret_helper;
}

// free_instance_hard_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1797
static inline void free_instance_hard_thread_callback(struct fc_solve_hard_thread_struct *hard_thread)
{
  if(!(hard_thread->prelude_as_string == ((char *)NULL)))
    free((void *)hard_thread->prelude_as_string);

  if(!(hard_thread->prelude == ((struct anonymous$42 *)NULL)))
    free((void *)hard_thread->prelude);

  free((void *)hard_thread->reusable_move_stack.moves);
  free((void *)hard_thread->soft_threads);
  fc_solve_compact_allocator_finish(&hard_thread->allocator);
}

// free_instance_soft_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 181
static inline void free_instance_soft_thread_callback(struct fc_solve_soft_thread_struct * const soft_thread)
{
  fc_solve_PQueueFree(&soft_thread->method_specific.befs.meth.befs.pqueue);
  fc_solve_release_tests_list(soft_thread);
  fc_solve_free_soft_thread_by_depth_test_array(soft_thread);
  if(!(soft_thread->name == ((char *)NULL)))
    free((void *)soft_thread->name);

}

// free_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 233
static inline void free_states(struct fc_solve_instance_struct *instance)
{
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
  {
    struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
    struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
    for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
      if((signed int)soft_thread->super_method_type == FCS_SUPER_METHOD_DFS)
        free_states_handle_soft_dfs_soft_thread(soft_thread);

      else
        if(soft_thread->method == 3)
        {
          struct anonymous$32 new_pq;
          fc_solve_PQueueInitialise(&new_pq, 1024);
          const signed int CurrentSize = soft_thread->method_specific.befs.meth.befs.pqueue.CurrentSize;
          struct anonymous$19 *next_element = soft_thread->method_specific.befs.meth.befs.pqueue.Elements + (signed long int)1;
          signed int i = 1;
          for( ; CurrentSize >= i; next_element = next_element + 1l)
          {
            if((4 & (signed int)next_element->val->$anon0.$anon0.info.visited) == 0)
              fc_solve_PQueuePush(&new_pq, next_element->val, next_element->rating);

            i = i + 1;
          }
          fc_solve_PQueueFree$link2(&soft_thread->method_specific.befs.meth.befs.pqueue);
          soft_thread->method_specific.befs.meth.befs.pqueue = new_pq;
        }

  }
  fc_solve_hash_foreach(&instance->hash, free_states_should_delete, (void *)instance);
}

// free_states_handle_soft_dfs_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 146
static inline void free_states_handle_soft_dfs_soft_thread(struct fc_solve_soft_thread_struct *soft_thread)
{
  struct anonymous$50 *soft_dfs_info = soft_thread->method_specific.soft_dfs.soft_dfs_info;
  struct anonymous$50 * const end_soft_dfs_info = soft_dfs_info + (signed long int)soft_thread->method_specific.soft_dfs.depth;
  struct anonymous$29 *tmp_post$1;
  for( ; !(soft_dfs_info >= end_soft_dfs_info); soft_dfs_info = soft_dfs_info + 1l)
  {
    struct anonymous$29 *rand_index_ptr;
    struct anonymous$29 *dest_rand_index_ptr;
    struct anonymous$38 * const states = soft_dfs_info->derived_states_list.states;
    rand_index_ptr = soft_dfs_info->derived_states_random_indexes + (signed long int)soft_dfs_info->current_state_index;
    dest_rand_index_ptr = rand_index_ptr;
    struct anonymous$29 * const end_rand_index_ptr = soft_dfs_info->derived_states_random_indexes + (signed long int)soft_dfs_info->derived_states_list.num_states;
    for( ; !(rand_index_ptr >= end_rand_index_ptr); rand_index_ptr = rand_index_ptr + 1l)
      if((4 & (signed int)(states + (signed long int)rand_index_ptr->idx)->state_ptr->$anon0.$anon0.info.visited) == 0)
      {
        tmp_post$1 = dest_rand_index_ptr;
        dest_rand_index_ptr = dest_rand_index_ptr + 1l;
        *tmp_post$1 = *rand_index_ptr;
      }

    soft_dfs_info->derived_states_list.num_states = (signed int)(dest_rand_index_ptr - soft_dfs_info->derived_states_random_indexes);
  }
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// free_states_should_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 125
static _Bool free_states_should_delete(void *key, void *context)
{
  struct fc_solve_instance_struct * const instance = (struct fc_solve_instance_struct *)context;
  struct fcs_state_keyval_pair_struct * const ptr_state = (struct fcs_state_keyval_pair_struct *)key;
  if(!((4 & (signed int)ptr_state->$anon0.$anon0.info.visited) == 0))
  {
    ptr_state->$anon0.$anon0.info.parent = instance->list_of_vacant_states;
    instance->list_of_vacant_states = ptr_state;
    instance->active_num_states_in_collection = instance->active_num_states_in_collection - 1l;
    return (_Bool)1;
  }

  else
    return (_Bool)0;
}

// freecell_solver_set_stored_states_trimming_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 265
extern void freecell_solver_set_stored_states_trimming_limit(void *api_instance, signed long int max_num_states)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(!(max_num_states >= 0l))
  {
    user->active_flare->obj->trim_states_in_collection_from = (signed long int)-1;
    user->active_flare->obj->effective_trim_states_in_collection_from = 0x7fffffffffffffffL;
  }

  else
  {
    user->active_flare->obj->trim_states_in_collection_from = max_num_states;
    user->active_flare->obj->effective_trim_states_in_collection_from = user->active_flare->obj->trim_states_in_collection_from;
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// freecell_solver_user_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 46
extern void * freecell_solver_user_alloc(void)
{
  struct anonymous *ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous) /*2080ul*/  * (unsigned long int)1);
  ret = (struct anonymous *)return_value_malloc$1;
  user_initialize(ret);
  return (void *)ret;
}

// freecell_solver_user_apply_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 48
extern signed int freecell_solver_user_apply_preset(void *api_instance, const char *preset_name)
{
  const struct anonymous$36 *new_preset_ptr;
  signed int status;
  struct anonymous * const user = (struct anonymous *)api_instance;
  status=fc_solve_get_preset_by_name(preset_name, &new_preset_ptr);
  if(!(status == 0))
    return status;

  else
  {
    signed int user_inst_idx = 0;
    for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
    {
      struct anonymous$1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
      signed int flare_idx = 0;
      for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
      {
        struct anonymous$2 * const flare = &instance_item->flares[(signed long int)flare_idx];
        status=fc_solve_apply_preset_by_ptr(flare->obj, new_preset_ptr);
        if(!(status == 0))
          return status;

      }
    }
    user->common_preset = *new_preset_ptr;
    return 0;
  }
}

// freecell_solver_user_cmd_line_parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_cl.h line 62
extern signed int freecell_solver_user_cmd_line_parse_args(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg)
{
  signed int return_value_freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$1;
  return_value_freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$1=freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(instance, argc, argv, start_arg, known_parameters, callback, callback_context, error_string, last_arg, -1, (const char *)(void *)0);
  return return_value_freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$1;
}

// freecell_solver_user_cmd_line_parse_args_with_file_nesting_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 309
extern signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg, signed int file_nesting_count, const char *opened_files_dir)
{
  signed int num_to_skip;
  const char *p;
  *error_string = (char *)(void *)0;
  const char **arg_argc = &argv[(signed long int)argc];
  const char **arg;
  const char **known_param;
  arg = &argv[(signed long int)start_arg];
  signed int return_value_strcmp$1;
  const char *tmp_post$83;
  const char *tmp_post$2;
  const char *tmp_post$3;
  const char *tmp_post$8;
  const char *tmp_post$5;
  const char *tmp_post$12;
  const char *tmp_post$9;
  const char *tmp_post$14;
  const char *tmp_post$15;
  const char *tmp_post$21;
  const char *tmp_post$17;
  const char *tmp_post$26;
  const char *tmp_post$27;
  const char *tmp_post$33;
  const char *tmp_post$39;
  const char *tmp_post$43;
  const char *tmp_post$51;
  const char *tmp_post$47;
  const char *tmp_post$52;
  const char *tmp_post$54;
  const char *tmp_post$55;
  const char *tmp_post$61;
  const char *tmp_post$64;
  const char *tmp_post$70;
  const char *tmp_post$72;
  const char *tmp_post$75;
  const char *tmp_post$78;
  const char *tmp_post$81;
  signed int return_value_strcmp$100;
  signed int return_value_strcmp$103;
  _Bool tmp_if_expr$120;
  signed int return_value_strcmp$119;
  signed int return_value_strcmp$117;
  signed int return_value_strcmp$116;
  signed int return_value_strcmp$115;
  signed int tmp_if_expr$126;
  signed int return_value_freecell_solver_user_next_soft_thread$124;
  signed int return_value_freecell_solver_user_next_hard_thread$125;
  signed int return_value_strcmp$133;
  const unsigned short int **return_value___ctype_b_loc$135;
  const unsigned short int **return_value___ctype_b_loc$144;
  while(!(arg >= arg_argc))
  {
    if(!(known_parameters == ((const char **)NULL)))
    {
      known_param = known_parameters;
      for( ; !(*known_param == ((const char *)NULL)); known_param = known_param + 1l)
      {
        return_value_strcmp$1=strcmp(*known_param, *arg);
        if(return_value_strcmp$1 == 0)
          break;

      }
      if(!(*known_param == ((const char *)NULL)))
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$1$$2$$ret;
        signed int callback_ret;
        callback_ret=callback(instance, argc, argv, (signed int)(arg - &argv[(signed long int)0]), &num_to_skip, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$1$$2$$ret, callback_context);
        if(callback_ret == 1)
          arg = arg + (signed long int)(num_to_skip - 1);

        else
          if(callback_ret == 2)
          {
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$1$$2$$ret;
          }

      }

    }

    signed int opt;
    p = *arg;
    opt = 0;
    tmp_post$83 = p;
    p = p + 1l;
    if((signed int)*tmp_post$83 == 45)
    {
      tmp_post$2 = p;
      p = p + 1l;
      switch((signed int)*tmp_post$2)
      {
        case 45:
        {
          tmp_post$3 = p;
          p = p + 1l;
          switch((signed int)*tmp_post$3)
          {
            case 97:
            {
              signed int return_value_strcmp$4;
              return_value_strcmp$4=strcmp(p, "-star-weights");
              if(return_value_strcmp$4 == 0)
                opt = 12;

              break;
            }
            case 99:
            {
              tmp_post$8 = p;
              p = p + 1l;
              if((signed int)*tmp_post$8 == 97)
              {
                tmp_post$5 = p;
                p = p + 1l;
                switch((signed int)*tmp_post$5)
                {
                  case 99:
                  {
                    signed int return_value_strcmp$6;
                    return_value_strcmp$6=strcmp(p, "he-limit");
                    if(return_value_strcmp$6 == 0)
                      opt = 36;

                    break;
                  }
                  case 108:
                  {
                    signed int return_value_strcmp$7;
                    return_value_strcmp$7=strcmp(p, "c-real-depth");
                    if(return_value_strcmp$7 == 0)
                      opt = 23;

                  }
                }
              }

              break;
            }
            case 100:
            {
              tmp_post$12 = p;
              p = p + 1l;
              if((signed int)*tmp_post$12 == 101)
              {
                tmp_post$9 = p;
                p = p + 1l;
                switch((signed int)*tmp_post$9)
                {
                  case 99:
                  {
                    signed int return_value_strcmp$10;
                    return_value_strcmp$10=strcmp(p, "ks-num");
                    if(return_value_strcmp$10 == 0)
                      opt = 6;

                    break;
                  }
                  case 112:
                  {
                    signed int return_value_strcmp$11;
                    return_value_strcmp$11=strcmp(p, "th-tests-order");
                    if(return_value_strcmp$11 == 0)
                      opt = 34;

                  }
                }
              }

              break;
            }
            case 101:
            {
              signed int return_value_strcmp$13;
              return_value_strcmp$13=strcmp(p, "mpty-stacks-filled-by");
              if(return_value_strcmp$13 == 0)
                opt = 9;

              break;
            }
            case 102:
            {
              tmp_post$14 = p;
              p = p + 1l;
              switch((signed int)*tmp_post$14)
              {
                case 108:
                {
                  signed int return_value_strncmp$22;
                  return_value_strncmp$22=strncmp(p, "are", (unsigned long int)3);
                  if(return_value_strncmp$22 == 0)
                  {
                    p = p + (signed long int)3;
                    tmp_post$15 = p;
                    p = p + 1l;
                    switch((signed int)*tmp_post$15)
                    {
                      case 45:
                      {
                        signed int return_value_strcmp$16;
                        return_value_strcmp$16=strcmp(p, "name");
                        if(return_value_strcmp$16 == 0)
                          opt = 25;

                        break;
                      }
                      case 115:
                      {
                        tmp_post$21 = p;
                        p = p + 1l;
                        if((signed int)*tmp_post$21 == 45)
                        {
                          tmp_post$17 = p;
                          p = p + 1l;
                          switch((signed int)*tmp_post$17)
                          {
                            case 99:
                            {
                              signed int return_value_strcmp$18;
                              return_value_strcmp$18=strcmp(p, "hoice");
                              if(return_value_strcmp$18 == 0)
                                opt = 37;

                              break;
                            }
                            case 105:
                            {
                              signed int return_value_strcmp$19;
                              return_value_strcmp$19=strcmp(p, "ters-factor");
                              if(return_value_strcmp$19 == 0)
                                opt = 28;

                              break;
                            }
                            case 112:
                            {
                              signed int return_value_strcmp$20;
                              return_value_strcmp$20=strcmp(p, "lan");
                              if(return_value_strcmp$20 == 0)
                                opt = 27;

                            }
                          }
                        }

                      }
                    }
                  }

                  break;
                }
                case 114:
                {
                  signed int return_value_strcmp$23;
                  return_value_strcmp$23=strcmp(p, "eecells-num");
                  if(return_value_strcmp$23 == 0)
                    opt = 4;

                }
              }
              break;
            }
            case 103:
            {
              signed int return_value_strcmp$24;
              return_value_strcmp$24=strcmp(p, "ame");
              if(return_value_strcmp$24 == 0)
                opt = 10;

              break;
            }
            case 108:
            {
              signed int return_value_strcmp$25;
              return_value_strcmp$25=strcmp(p, "oad-config");
              if(return_value_strcmp$25 == 0)
                opt = 33;

              break;
            }
            case 109:
            {
              tmp_post$26 = p;
              p = p + 1l;
              switch((signed int)*tmp_post$26)
              {
                case 97:
                {
                  signed int return_value_strncmp$31;
                  return_value_strncmp$31=strncmp(p, "x-", (unsigned long int)2);
                  if(return_value_strncmp$31 == 0)
                  {
                    p = p + (signed long int)2;
                    tmp_post$27 = p;
                    p = p + 1l;
                    switch((signed int)*tmp_post$27)
                    {
                      case 100:
                      {
                        signed int return_value_strcmp$28;
                        return_value_strcmp$28=strcmp(p, "epth");
                        if(return_value_strcmp$28 == 0)
                          opt = 1;

                        break;
                      }
                      case 105:
                      {
                        signed int return_value_strcmp$29;
                        return_value_strcmp$29=strcmp(p, "ters");
                        if(return_value_strcmp$29 == 0)
                          opt = 2;

                        break;
                      }
                      case 115:
                      {
                        signed int return_value_strcmp$30;
                        return_value_strcmp$30=strcmp(p, "tored-states");
                        if(return_value_strcmp$30 == 0)
                          opt = 15;

                      }
                    }
                  }

                  break;
                }
                case 101:
                {
                  signed int return_value_strcmp$32;
                  return_value_strcmp$32=strcmp(p, "thod");
                  if(return_value_strcmp$32 == 0)
                    opt = 11;

                }
              }
              break;
            }
            case 110:
            {
              signed int return_value_strncmp$38;
              return_value_strncmp$38=strncmp(p, "ext-", (unsigned long int)4);
              if(return_value_strncmp$38 == 0)
              {
                p = p + (signed long int)4;
                tmp_post$33 = p;
                p = p + 1l;
                switch((signed int)*tmp_post$33)
                {
                  case 102:
                  {
                    signed int return_value_strcmp$34;
                    return_value_strcmp$34=strcmp(p, "lare");
                    if(return_value_strcmp$34 == 0)
                      opt = 18;

                    break;
                  }
                  case 104:
                  {
                    signed int return_value_strcmp$35;
                    return_value_strcmp$35=strcmp(p, "ard-thread");
                    if(return_value_strcmp$35 == 0)
                      opt = 20;

                    break;
                  }
                  case 105:
                  {
                    signed int return_value_strcmp$36;
                    return_value_strcmp$36=strcmp(p, "nstance");
                    if(return_value_strcmp$36 == 0)
                      opt = 17;

                    break;
                  }
                  case 115:
                  {
                    signed int return_value_strcmp$37;
                    return_value_strcmp$37=strcmp(p, "oft-thread");
                    if(return_value_strcmp$37 == 0)
                      opt = 19;

                  }
                }
              }

              break;
            }
            case 111:
            {
              signed int return_value_strncmp$42;
              return_value_strncmp$42=strncmp(p, "ptimiz", (unsigned long int)6);
              if(return_value_strncmp$42 == 0)
              {
                p = p + (signed long int)6;
                tmp_post$39 = p;
                p = p + 1l;
                switch((signed int)*tmp_post$39)
                {
                  case 97:
                  {
                    signed int return_value_strcmp$40;
                    return_value_strcmp$40=strcmp(p, "tion-tests-order");
                    if(return_value_strcmp$40 == 0)
                      opt = 29;

                    break;
                  }
                  case 101:
                  {
                    signed int return_value_strcmp$41;
                    return_value_strcmp$41=strcmp(p, "-solution");
                    if(return_value_strcmp$41 == 0)
                      opt = 13;

                  }
                }
              }

              break;
            }
            case 112:
            {
              signed int return_value_strncmp$46;
              return_value_strncmp$46=strncmp(p, "re", (unsigned long int)2);
              if(return_value_strncmp$46 == 0)
              {
                p = p + (signed long int)2;
                tmp_post$43 = p;
                p = p + 1l;
                switch((signed int)*tmp_post$43)
                {
                  case 108:
                  {
                    signed int return_value_strcmp$44;
                    return_value_strcmp$44=strcmp(p, "ude");
                    if(return_value_strcmp$44 == 0)
                      opt = 26;

                    break;
                  }
                  case 115:
                  {
                    signed int return_value_strcmp$45;
                    return_value_strcmp$45=strcmp(p, "et");
                    if(return_value_strcmp$45 == 0)
                      opt = 10;

                  }
                }
              }

              break;
            }
            case 114:
            {
              tmp_post$51 = p;
              p = p + 1l;
              if((signed int)*tmp_post$51 == 101)
              {
                tmp_post$47 = p;
                p = p + 1l;
                switch((signed int)*tmp_post$47)
                {
                  case 97:
                  {
                    signed int return_value_strcmp$48;
                    return_value_strcmp$48=strcmp(p, "d-from-file");
                    if(return_value_strcmp$48 == 0)
                      opt = 32;

                    break;
                  }
                  case 112:
                  {
                    signed int return_value_strcmp$49;
                    return_value_strcmp$49=strcmp(p, "arent-states");
                    if(return_value_strcmp$49 == 0)
                      opt = 22;

                    break;
                  }
                  case 115:
                  {
                    signed int return_value_strcmp$50;
                    return_value_strcmp$50=strcmp(p, "et");
                    if(return_value_strcmp$50 == 0)
                      opt = 31;

                  }
                }
              }

              break;
            }
            case 115:
            {
              tmp_post$52 = p;
              p = p + 1l;
              switch((signed int)*tmp_post$52)
              {
                case 99:
                {
                  signed int return_value_strcmp$53;
                  return_value_strcmp$53=strcmp(p, "ans-synergy");
                  if(return_value_strcmp$53 == 0)
                    opt = 30;

                  break;
                }
                case 101:
                {
                  tmp_post$54 = p;
                  p = p + 1l;
                  switch((signed int)*tmp_post$54)
                  {
                    case 113:
                    {
                      signed int return_value_strncmp$58;
                      return_value_strncmp$58=strncmp(p, "uence", (unsigned long int)5);
                      if(return_value_strncmp$58 == 0)
                      {
                        p = p + (signed long int)5;
                        tmp_post$55 = p;
                        p = p + 1l;
                        switch((signed int)*tmp_post$55)
                        {
                          case 45:
                          {
                            signed int return_value_strcmp$56;
                            return_value_strcmp$56=strcmp(p, "move");
                            if(return_value_strcmp$56 == 0)
                              opt = 8;

                            break;
                          }
                          case 115:
                          {
                            signed int return_value_strcmp$57;
                            return_value_strcmp$57=strcmp(p, "-are-built-by");
                            if(return_value_strcmp$57 == 0)
                              opt = 7;

                          }
                        }
                      }

                      break;
                    }
                    case 116:
                    {
                      signed int return_value_strcmp$59;
                      return_value_strcmp$59=strcmp(p, "-pruning");
                      if(return_value_strcmp$59 == 0)
                        opt = 35;

                    }
                  }
                  break;
                }
                case 111:
                {
                  signed int return_value_strcmp$60;
                  return_value_strcmp$60=strcmp(p, "ft-thread-step");
                  if(return_value_strcmp$60 == 0)
                    opt = 21;

                  break;
                }
                case 116:
                {
                  tmp_post$61 = p;
                  p = p + 1l;
                  switch((signed int)*tmp_post$61)
                  {
                    case 45:
                    {
                      signed int return_value_strcmp$62;
                      return_value_strcmp$62=strcmp(p, "name");
                      if(return_value_strcmp$62 == 0)
                        opt = 24;

                      break;
                    }
                    case 97:
                    {
                      signed int return_value_strcmp$63;
                      return_value_strcmp$63=strcmp(p, "cks-num");
                      if(return_value_strcmp$63 == 0)
                        opt = 5;

                    }
                  }
                }
              }
              break;
            }
            case 116:
            {
              tmp_post$64 = p;
              p = p + 1l;
              switch((signed int)*tmp_post$64)
              {
                case 101:
                {
                  signed int return_value_strcmp$65;
                  return_value_strcmp$65=strcmp(p, "sts-order");
                  if(return_value_strcmp$65 == 0)
                    opt = 3;

                  break;
                }
                case 114:
                {
                  signed int return_value_strcmp$66;
                  return_value_strcmp$66=strcmp(p, "im-max-stored-states");
                  if(return_value_strcmp$66 == 0)
                    opt = 16;

                }
              }
            }
          }
          break;
        }
        case 97:
        {
          signed int return_value_strcmp$67;
          return_value_strcmp$67=strcmp(p, "sw");
          if(return_value_strcmp$67 == 0)
            opt = 12;

          break;
        }
        case 100:
        {
          signed int return_value_strcmp$68;
          return_value_strcmp$68=strcmp(p, "to");
          if(return_value_strcmp$68 == 0)
            opt = 34;

          break;
        }
        case 102:
        {
          signed int return_value_strcmp$69;
          return_value_strcmp$69=strcmp(p, "if");
          if(return_value_strcmp$69 == 0)
            opt = 28;

          break;
        }
        case 103:
        {
          if((signed int)*p == 0)
            opt = 10;

          break;
        }
        case 108:
        {
          if((signed int)*p == 0)
            opt = 33;

          break;
        }
        case 109:
        {
          tmp_post$70 = p;
          p = p + 1l;
          switch((signed int)*tmp_post$70)
          {
            case 100:
            {
              if((signed int)*p == 0)
                opt = 1;

              break;
            }
            case 101:
            {
              if((signed int)*p == 0)
                opt = 11;

              break;
            }
            case 105:
            {
              if((signed int)*p == 0)
                opt = 2;

              break;
            }
            case 115:
            {
              signed int return_value_strcmp$71;
              return_value_strcmp$71=strcmp(p, "s");
              if(return_value_strcmp$71 == 0)
                opt = 15;

            }
          }
          break;
        }
        case 110:
        {
          tmp_post$72 = p;
          p = p + 1l;
          switch((signed int)*tmp_post$72)
          {
            case 102:
            {
              if((signed int)*p == 0)
                opt = 18;

              break;
            }
            case 104:
            {
              signed int return_value_strcmp$73;
              return_value_strcmp$73=strcmp(p, "t");
              if(return_value_strcmp$73 == 0)
                opt = 20;

              break;
            }
            case 105:
            {
              if((signed int)*p == 0)
                opt = 17;

              break;
            }
            case 115:
            {
              signed int return_value_strcmp$74;
              return_value_strcmp$74=strcmp(p, "t");
              if(return_value_strcmp$74 == 0)
                opt = 19;

            }
          }
          break;
        }
        case 111:
        {
          signed int return_value_strncmp$77;
          return_value_strncmp$77=strncmp(p, "pt", (unsigned long int)2);
          if(return_value_strncmp$77 == 0)
          {
            p = p + (signed long int)2;
            tmp_post$75 = p;
            p = p + 1l;
            switch((signed int)*tmp_post$75)
            {
              case 0:
              {
                opt = 13;
                break;
              }
              case 45:
              {
                signed int return_value_strcmp$76;
                return_value_strcmp$76=strcmp(p, "to");
                if(return_value_strcmp$76 == 0)
                  opt = 29;

              }
            }
          }

          break;
        }
        case 115:
        {
          tmp_post$78 = p;
          p = p + 1l;
          switch((signed int)*tmp_post$78)
          {
            case 101:
            {
              signed int return_value_strcmp$79;
              return_value_strcmp$79=strcmp(p, "ed");
              if(return_value_strcmp$79 == 0)
                opt = 14;

              break;
            }
            case 112:
            {
              if((signed int)*p == 0)
                opt = 35;

              break;
            }
            case 116:
            {
              signed int return_value_strcmp$80;
              return_value_strcmp$80=strcmp(p, "ep");
              if(return_value_strcmp$80 == 0)
                opt = 21;

            }
          }
          break;
        }
        case 116:
        {
          tmp_post$81 = p;
          p = p + 1l;
          switch((signed int)*tmp_post$81)
          {
            case 109:
            {
              signed int return_value_strcmp$82;
              return_value_strcmp$82=strcmp(p, "ss");
              if(return_value_strcmp$82 == 0)
                opt = 16;

              break;
            }
            case 111:
              if((signed int)*p == 0)
                opt = 3;

          }
        }
      }
    }

    switch(opt)
    {
      case 0:
      {
        *last_arg = (signed int)(arg - &argv[(signed long int)0]);
        return 3;
      }
      case 1:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi$84;
        return_value_atoi$84=atoi(*arg);
        freecell_solver_user_limit_depth(instance, return_value_atoi$84);
        goto __CPROVER_DUMP_L276;
      }
      case 2:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol$85;
        return_value_atol$85=atol(*arg);
        freecell_solver_user_limit_iterations_long(instance, return_value_atol$85);
        goto __CPROVER_DUMP_L276;
      }
      case 3:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$ret;
        char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$fcs_user_errstr;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$ret=freecell_solver_user_set_tests_order(instance, *arg, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$fcs_user_errstr);
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$2$$errstr;
          unsigned long int return_value_strlen$86;
          return_value_strlen$86=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$fcs_user_errstr);
          void *return_value_malloc$87;
          return_value_malloc$87=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$86 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$2$$errstr = (char *)return_value_malloc$87;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$2$$errstr, "Error in tests' order!\n%s\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$fcs_user_errstr);
          free((void *)freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$fcs_user_errstr);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$4$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 4:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi$90;
        return_value_atoi$90=atoi(*arg);
        signed int return_value_freecell_solver_user_set_num_freecells$91;
        return_value_freecell_solver_user_set_num_freecells$91=freecell_solver_user_set_num_freecells(instance, return_value_atoi$90);
        if(!(return_value_freecell_solver_user_set_num_freecells$91 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$5$$2$$errstr;
          void *return_value_malloc$88;
          return_value_malloc$88=malloc(sizeof(char) /*1ul*/  * (unsigned long int)500);
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$5$$2$$errstr = (char *)return_value_malloc$88;
          signed int return_value_freecell_solver_user_get_max_num_freecells$89;
          return_value_freecell_solver_user_get_max_num_freecells$89=freecell_solver_user_get_max_num_freecells();
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$5$$2$$errstr, "Error! The freecells' number exceeds the maximum of %i.\nRecompile the program if you wish to have more.\n", return_value_freecell_solver_user_get_max_num_freecells$89);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$5$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 5:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi$94;
        return_value_atoi$94=atoi(*arg);
        signed int return_value_freecell_solver_user_set_num_stacks$95;
        return_value_freecell_solver_user_set_num_stacks$95=freecell_solver_user_set_num_stacks(instance, return_value_atoi$94);
        if(!(return_value_freecell_solver_user_set_num_stacks$95 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$6$$2$$errstr;
          void *return_value_malloc$92;
          return_value_malloc$92=malloc(sizeof(char) /*1ul*/  * (unsigned long int)500);
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$6$$2$$errstr = (char *)return_value_malloc$92;
          signed int return_value_freecell_solver_user_get_max_num_stacks$93;
          return_value_freecell_solver_user_get_max_num_stacks$93=freecell_solver_user_get_max_num_stacks();
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$6$$2$$errstr, "Error! The stacks' number exceeds the maximum of %i.\nRecompile the program if you wish to have more.\n", return_value_freecell_solver_user_get_max_num_stacks$93);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$6$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 6:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi$98;
        return_value_atoi$98=atoi(*arg);
        signed int return_value_freecell_solver_user_set_num_decks$99;
        return_value_freecell_solver_user_set_num_decks$99=freecell_solver_user_set_num_decks(instance, return_value_atoi$98);
        if(!(return_value_freecell_solver_user_set_num_decks$99 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$7$$2$$errstr;
          void *return_value_malloc$96;
          return_value_malloc$96=malloc(sizeof(char) /*1ul*/  * (unsigned long int)500);
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$7$$2$$errstr = (char *)return_value_malloc$96;
          signed int return_value_freecell_solver_user_get_max_num_decks$97;
          return_value_freecell_solver_user_get_max_num_decks$97=freecell_solver_user_get_max_num_decks();
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$7$$2$$errstr, "Error! The decks' number exceeds the maximum of %i.\nRecopmile the program if you wish to have more.\n", return_value_freecell_solver_user_get_max_num_decks$97);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$7$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 7:
      {
        signed int sbb;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp$101;
        return_value_strcmp$101=strcmp(*arg, "suit");
        if(return_value_strcmp$101 == 0)
          sbb = 1;

        else
        {
          return_value_strcmp$100=strcmp(*arg, "rank");
          if(return_value_strcmp$100 == 0)
            sbb = 2;

          else
            sbb = 0;
        }
        freecell_solver_user_set_sequences_are_built_by_type(instance, sbb);
        goto __CPROVER_DUMP_L276;
      }
      case 8:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp$102;
        return_value_strcmp$102=strcmp(*arg, "unlimited");
        freecell_solver_user_set_sequence_move(instance, (signed int)!(return_value_strcmp$102 != 0));
        goto __CPROVER_DUMP_L276;
      }
      case 9:
      {
        signed int es_fill;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp$104;
        return_value_strcmp$104=strcmp(*arg, "kings");
        if(return_value_strcmp$104 == 0)
          es_fill = 1;

        else
        {
          return_value_strcmp$103=strcmp(*arg, "none");
          if(return_value_strcmp$103 == 0)
            es_fill = 2;

          else
            es_fill = 0;
        }
        freecell_solver_user_set_empty_stacks_filled_by(instance, es_fill);
        goto __CPROVER_DUMP_L276;
      }
      case 10:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$ret;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$ret=freecell_solver_user_apply_preset(instance, *arg);
        if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$ret == 1)
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$2$$errstr;
          unsigned long int return_value_strlen$105;
          return_value_strlen$105=strlen(*arg);
          void *return_value_malloc$106;
          return_value_malloc$106=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$105 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$2$$errstr = (char *)return_value_malloc$106;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$2$$errstr, "Unknown game \"%s\"!\n\n", *arg);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        else
          if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$ret == 2)
          {
            char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$3$$errstr;
            unsigned long int return_value_strlen$107;
            return_value_strlen$107=strlen(*arg);
            void *return_value_malloc$108;
            return_value_malloc$108=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$107 + (unsigned long int)500));
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$3$$errstr = (char *)return_value_malloc$108;
            sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$3$$errstr, "The game \"%s\" exceeds the maximal number of freecells in the program.\nModify the file \"config.h\" and recompile, if you wish to solve one of its boards.\n", *arg);
            *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$3$$errstr;
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          else
            if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$ret == 3)
            {
              char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$4$$errstr;
              unsigned long int return_value_strlen$109;
              return_value_strlen$109=strlen(*arg);
              void *return_value_malloc$110;
              return_value_malloc$110=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$109 + (unsigned long int)500));
              freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$4$$errstr = (char *)return_value_malloc$110;
              sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$4$$errstr, "The game \"%s\" exceeds the maximal number of stacks in the program.\nModify the file \"config.h\" and recompile, if you wish to solve one of its boards.\n", *arg);
              *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$4$$errstr;
              *last_arg = (signed int)(arg - &argv[(signed long int)0]);
              return 5;
            }

            else
              if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$ret == 0))
              {
                char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$5$$errstr;
                unsigned long int return_value_strlen$111;
                return_value_strlen$111=strlen(*arg);
                void *return_value_malloc$112;
                return_value_malloc$112=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$111 + (unsigned long int)500));
                freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$5$$errstr = (char *)return_value_malloc$112;
                sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$5$$errstr, "The game \"%s\" exceeds the limits of the program.\nModify the file \"config.h\" and recompile, if you wish to solve one of its boards.\n", *arg);
                *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$11$$5$$errstr;
                *last_arg = (signed int)(arg - &argv[(signed long int)0]);
                return 5;
              }

        goto __CPROVER_DUMP_L276;
      }
      case 11:
      {
        signed int method;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp$118;
        return_value_strcmp$118=strcmp(*arg, "soft-dfs");
        if(return_value_strcmp$118 == 0)
          tmp_if_expr$120 = (_Bool)1;

        else
        {
          return_value_strcmp$119=strcmp(*arg, "dfs");
          tmp_if_expr$120 = !(return_value_strcmp$119 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$120)
          method = 1;

        else
        {
          return_value_strcmp$117=strcmp(*arg, "bfs");
          if(return_value_strcmp$117 == 0)
            method = 2;

          else
          {
            return_value_strcmp$116=strcmp(*arg, "a-star");
            if(return_value_strcmp$116 == 0)
              method = 3;

            else
            {
              return_value_strcmp$115=strcmp(*arg, "random-dfs");
              if(return_value_strcmp$115 == 0)
                method = 5;

              else
              {
                char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$12$$6$$errstr;
                unsigned long int return_value_strlen$113;
                return_value_strlen$113=strlen(*arg);
                void *return_value_malloc$114;
                return_value_malloc$114=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$113 + (unsigned long int)500));
                freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$12$$6$$errstr = (char *)return_value_malloc$114;
                sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$12$$6$$errstr, "Unknown solving method \"%s\".\n", *arg);
                *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$12$$6$$errstr;
                *last_arg = (signed int)(arg - &argv[(signed long int)0]);
                return 5;
              }
            }
          }
        }
        freecell_solver_user_set_solving_method(instance, method);
        goto __CPROVER_DUMP_L276;
      }
      case 12:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int i;
        double befs_weights[6l];
        fc_solve_set_weights(*arg, befs_weights);
        i = 0;
        for( ; !(i >= 6); i = i + 1)
          freecell_solver_user_set_a_star_weight(instance, i, befs_weights[(signed long int)i]);
        goto __CPROVER_DUMP_L276;
      }
      case 13:
      {
        freecell_solver_user_set_solution_optimization(instance, 1);
        goto __CPROVER_DUMP_L276;
      }
      case 14:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi$121;
        return_value_atoi$121=atoi(*arg);
        freecell_solver_user_set_random_seed(instance, return_value_atoi$121);
        goto __CPROVER_DUMP_L276;
      }
      case 15:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol$122;
        return_value_atol$122=atol(*arg);
        freecell_solver_user_limit_num_states_in_collection_long(instance, return_value_atol$122);
        goto __CPROVER_DUMP_L276;
      }
      case 16:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol$123;
        return_value_atol$123=atol(*arg);
        freecell_solver_set_stored_states_trimming_limit(instance, return_value_atol$123);
        goto __CPROVER_DUMP_L276;
      }
      case 17:
      {
        freecell_solver_user_next_instance(instance);
        goto __CPROVER_DUMP_L276;
      }
      case 18:
      {
        freecell_solver_user_next_flare(instance);
        goto __CPROVER_DUMP_L276;
      }
      case 19:

      case 20:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$20$$ret;
        if(opt == 19)
        {
          return_value_freecell_solver_user_next_soft_thread$124=freecell_solver_user_next_soft_thread(instance);
          tmp_if_expr$126 = return_value_freecell_solver_user_next_soft_thread$124;
        }

        else
        {
          return_value_freecell_solver_user_next_hard_thread$125=freecell_solver_user_next_hard_thread(instance);
          tmp_if_expr$126 = return_value_freecell_solver_user_next_hard_thread$125;
        }
        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$20$$ret = tmp_if_expr$126;
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$20$$ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$20$$1$$errstr;
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$20$$1$$errstr=strdup("The maximal number of soft threads has been exceeded\n");
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$20$$1$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 21:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi$127;
        return_value_atoi$127=atoi(*arg);
        freecell_solver_user_set_soft_thread_step(instance, return_value_atoi$127);
        goto __CPROVER_DUMP_L276;
      }
      case 22:
      {
        freecell_solver_user_set_reparent_states(instance, 1);
        goto __CPROVER_DUMP_L276;
      }
      case 23:
      {
        freecell_solver_user_set_calc_real_depth(instance, 1);
        goto __CPROVER_DUMP_L276;
      }
      case 24:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_soft_thread_name(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 25:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_flare_name(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 26:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_hard_thread_prelude(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 27:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_flares_plan(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 28:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        double return_value_atof$128;
        return_value_atof$128=atof(*arg);
        freecell_solver_user_set_flares_iters_factor(instance, return_value_atof$128);
        goto __CPROVER_DUMP_L276;
      }
      case 29:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$ret;
        char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$fcs_user_errstr;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$ret=freecell_solver_user_set_optimization_scan_tests_order(instance, *arg, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$fcs_user_errstr);
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$2$$errstr;
          unsigned long int return_value_strlen$129;
          return_value_strlen$129=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$fcs_user_errstr);
          void *return_value_malloc$130;
          return_value_malloc$130=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$129 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$2$$errstr = (char *)return_value_malloc$130;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$2$$errstr, "Error in the optimization scan's tests' order!\n%s\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$fcs_user_errstr);
          free((void *)freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$fcs_user_errstr);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$29$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 30:
      {
        signed int value;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp$134;
        return_value_strcmp$134=strcmp(*arg, "none");
        if(return_value_strcmp$134 == 0)
          value = 0;

        else
        {
          return_value_strcmp$133=strcmp(*arg, "dead-end-marks");
          if(return_value_strcmp$133 == 0)
            value = 1;

          else
          {
            char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$30$$4$$errstr;
            unsigned long int return_value_strlen$131;
            return_value_strlen$131=strlen(*arg);
            void *return_value_malloc$132;
            return_value_malloc$132=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$131 + (unsigned long int)500));
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$30$$4$$errstr = (char *)return_value_malloc$132;
            sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$30$$4$$errstr, "Unknown scans' synergy type \"%s\"!\n", *arg);
            *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$30$$4$$errstr;
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }
        }
        freecell_solver_user_set_scans_synergy(instance, value);
        goto __CPROVER_DUMP_L276;
      }
      case 31:
      {
        freecell_solver_user_reset(instance);
        goto __CPROVER_DUMP_L276;
      }
      case 32:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        if(!(file_nesting_count == 0))
        {
          const char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s;
          char *buffer;
          struct _IO_FILE *f;
          signed long int file_len;
          signed int ret;
          unsigned long int num_read;
          struct anonymous$37 *args_man;
          signed int num_file_args_to_skip = 0;
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s = *arg;
          do
          {
            return_value___ctype_b_loc$135=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc$135)[(signed long int)(signed int)*freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s]) == 0)
              break;

            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s + 1l;
          }
          while((_Bool)1);
          if((signed int)*freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s == 44)
          {
            num_file_args_to_skip=atoi(*arg);
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s + 1l;
          }

          if(!(opened_files_dir == ((const char *)NULL)))
          {
            char *complete_path;
            signed int len;
            unsigned long int return_value_strlen$136;
            return_value_strlen$136=strlen(opened_files_dir);
            len = (signed int)return_value_strlen$136;
            unsigned long int return_value_strlen$137;
            return_value_strlen$137=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s);
            len = len + (signed int)return_value_strlen$137;
            len = len + 1;
            void *return_value_malloc$138;
            return_value_malloc$138=malloc(sizeof(char) /*1ul*/  * (unsigned long int)len);
            complete_path = (char *)return_value_malloc$138;
            sprintf(complete_path, "%s%s", opened_files_dir, freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s);
            f=fopen(complete_path, "rt");
            free((void *)complete_path);
          }

          else
            f = (struct _IO_FILE *)(void *)0;
          if(f == ((struct _IO_FILE *)NULL))
            f=fopen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s, "rt");

          if(f == ((struct _IO_FILE *)NULL))
          {
            char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$6$$err_str;
            unsigned long int return_value_strlen$139;
            return_value_strlen$139=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s);
            void *return_value_malloc$140;
            return_value_malloc$140=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$139 + (unsigned long int)100));
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$6$$err_str = (char *)return_value_malloc$140;
            sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$6$$err_str, "Could not open file \"%s\"!\nQuitting.\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$s);
            *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$32$$3$$6$$err_str;
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          fseek(f, (signed long int)0, 2);
          file_len=ftell(f);
          void *return_value_malloc$141;
          return_value_malloc$141=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(file_len + (signed long int)1));
          buffer = (char *)return_value_malloc$141;
          if(buffer == ((char *)NULL))
          {
            *error_string=strdup("Could not allocate enough memory to parse the file. Quitting.\n");
            fclose(f);
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          fseek(f, (signed long int)0, 0);
          num_read=fread((void *)buffer, (unsigned long int)1, (unsigned long int)file_len, f);
          fclose(f);
          buffer[(signed long int)num_read] = (char)0;
          args_man=fc_solve_args_man_alloc();
          ret=fc_solve_args_man_chop(args_man, buffer);
          free((void *)buffer);
          if(!(ret == 0))
          {
            *error_string=strdup("Could not parse the file. Quitting\n");
            fc_solve_args_man_free(args_man);
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          if(!(num_file_args_to_skip >= args_man->argc))
          {
            ret=freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(instance, args_man->argc - num_file_args_to_skip, (const char **)(void *)(args_man->argv + (signed long int)num_file_args_to_skip), 0, known_parameters, callback, callback_context, error_string, last_arg, file_nesting_count < 0 ? file_nesting_count : file_nesting_count - 1, opened_files_dir);
            if(!(ret == 3))
            {
              if(!(ret == 0))
              {
                fc_solve_args_man_free(args_man);
                return ret;
              }

            }

          }

          fc_solve_args_man_free(args_man);
        }

        goto __CPROVER_DUMP_L276;
      }
      case 33:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$33$$ret;
        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$33$$ret=freecell_solver_user_cmd_line_read_cmd_line_preset(instance, *arg, known_parameters, error_string, file_nesting_count, opened_files_dir);
        if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$33$$ret == 5)
        {
          char *err_str;
          unsigned long int return_value_strlen$142;
          return_value_strlen$142=strlen(*arg);
          void *return_value_malloc$143;
          return_value_malloc$143=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$142 + (unsigned long int)100));
          err_str = (char *)return_value_malloc$143;
          sprintf(err_str, "Unable to load the \"%s\" configuration!\n", *arg);
          *error_string = err_str;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        else
          if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$33$$ret == 3))
          {
            if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$33$$ret == 0))
              return freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$33$$ret;

          }

        goto __CPROVER_DUMP_L276;
      }
      case 34:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        char *fcs_user_errstr;
        signed int min_depth;
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$34$$2$$ret;
        const char *s;
        min_depth = 0;
        s = *arg;
        do
        {
          return_value___ctype_b_loc$144=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$144)[(signed long int)(signed int)*s]) == 0)
            break;

          s = s + 1l;
        }
        while((_Bool)1);
        if((signed int)*s == 44)
        {
          min_depth=atoi(*arg);
          s = s + 1l;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$34$$2$$ret=freecell_solver_user_set_depth_tests_order(instance, min_depth, *arg, &fcs_user_errstr);
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$34$$2$$ret == 0))
        {
          char *errstr;
          unsigned long int return_value_strlen$145;
          return_value_strlen$145=strlen(fcs_user_errstr);
          void *return_value_malloc$146;
          return_value_malloc$146=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$145 + (unsigned long int)500));
          errstr = (char *)return_value_malloc$146;
          sprintf(errstr, "Error in depth tests' order!\n%s\n", fcs_user_errstr);
          free((void *)fcs_user_errstr);
          *error_string = errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 35:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$ret;
        char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$fcs_user_errstr;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$ret=freecell_solver_user_set_pruning(instance, *arg, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$fcs_user_errstr);
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$2$$errstr;
          unsigned long int return_value_strlen$147;
          return_value_strlen$147=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$fcs_user_errstr);
          void *return_value_malloc$148;
          return_value_malloc$148=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$147 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$2$$errstr = (char *)return_value_malloc$148;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$2$$errstr, "Error in the optimization scan's pruning!\n%s\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$fcs_user_errstr);
          free((void *)freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$fcs_user_errstr);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$35$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 36:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol$149;
        return_value_atol$149=atol(*arg);
        freecell_solver_user_set_cache_limit(instance, return_value_atol$149);
        goto __CPROVER_DUMP_L276;
      }
      case 37:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_freecell_solver_user_set_flares_choice$152;
        return_value_freecell_solver_user_set_flares_choice$152=freecell_solver_user_set_flares_choice(instance, *arg);
        if(!(return_value_freecell_solver_user_set_flares_choice$152 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$37$$2$$errstr;
          unsigned long int return_value_strlen$150;
          return_value_strlen$150=strlen(*arg);
          void *return_value_malloc$151;
          return_value_malloc$151=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$150 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$37$$2$$errstr = (char *)return_value_malloc$151;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$37$$2$$errstr, "Unknown flares choice argument '%s'.\n", *arg);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count$$1$$1$$1$$3$$37$$2$$errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

      }
      default:
      {

      __CPROVER_DUMP_L276:
        ;
        arg = arg + 1l;
      }
    }
  }
  *last_arg = (signed int)(arg - &argv[(signed long int)0]);
  return 0;
}

// freecell_solver_user_cmd_line_read_cmd_line_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 260
extern signed int freecell_solver_user_cmd_line_read_cmd_line_preset(void *instance, const char * const preset_name, const char **known_parameters, char **error_string, signed int file_nesting_count, const char *opened_files_dir)
{
  signed int status;
  struct anonymous$37 *preset_args;
  char *dir = (char *)(void *)0;
  status=read_preset(preset_name, &preset_args, &dir, (const char *)(void *)0);
  if(!(status == 0))
  {
    *error_string=strdup("Could not read preset.");
    return 5;
  }

  else
  {
    signed int ret;
    signed int last_arg = 0;
    ret=freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(instance, preset_args->argc, (const char **)(void *)preset_args->argv, 0, known_parameters, (signed int (*)(void *, signed int, const char **, signed int, signed int *, signed int *, void *))(void *)0, (void *)0, error_string, &last_arg, file_nesting_count < 0 ? file_nesting_count : file_nesting_count - 1, dir != ((char *)NULL) ? dir : opened_files_dir);
    if(!(dir == ((char *)NULL)))
      free((void *)dir);

    fc_solve_args_man_free(preset_args);
    return ret;
  }
}

// freecell_solver_user_current_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1349
extern char * freecell_solver_user_current_state_as_string(void *api_instance, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_instance_struct *instance = user->active_flare->obj;
  char *return_value_fc_solve_state_as_string$1;
  return_value_fc_solve_state_as_string$1=fc_solve_state_as_string(&user->running_state.$anon0.$anon0.s, &user->initial_state_locs, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, (_Bool)parseable_output, (_Bool)canonized_order_output, (_Bool)display_10_as_t);
  return return_value_fc_solve_state_as_string$1;
}

// freecell_solver_user_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 90
extern void freecell_solver_user_free(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user_free_resources(user);
  free((void *)user);
}

// freecell_solver_user_get_current_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1455
extern signed int freecell_solver_user_get_current_depth(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return user->soft_thread->method_specific.soft_dfs.depth;
}

// freecell_solver_user_get_current_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2432
const char * freecell_solver_user_get_current_soft_thread_name(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_hard_thread_struct *hard_thread = user->active_flare->obj->current_hard_thread;
  return (hard_thread->soft_threads + (signed long int)hard_thread->st_idx)->name;
}

// freecell_solver_user_get_invalid_state_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1741
extern char * freecell_solver_user_get_invalid_state_error_string(void *api_instance, signed int print_ts)
{
  char string[80l];
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(user->state_validity_ret == 0)
  {
    char *return_value_strdup$1;
    return_value_strdup$1=strdup("");
    return return_value_strdup$1;
  }

  _Bool tmp_if_expr$2;
  if(user->state_validity_ret == 3)
    sprintf(string, "%s", (const void *)"There's an empty slot in one of the stacks.");

  else
  {
    if(user->state_validity_ret == 2)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = user->state_validity_ret == 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      char card_str[10l];
      fc_solve_card_perl2user(user->state_validity_card, card_str, (_Bool)print_ts);
      sprintf(string, "%s%s.", user->state_validity_ret == 2 ? "There's an extra card: " : "There's a missing card: ", (const void *)card_str);
    }

    else
      if(user->state_validity_ret == 4)
        sprintf(string, "%s.", (const void *)"Not enough input");

  }
  char *return_value_strdup$3;
  return_value_strdup$3=strdup(string);
  return return_value_strdup$3;
}

// freecell_solver_user_get_last_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 366
const char * freecell_solver_user_get_last_error_string(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return user->error_string;
}

// freecell_solver_user_get_lib_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2425
const char * freecell_solver_user_get_lib_version(void *api_instance)
{
  return "3.26.0";
}

// freecell_solver_user_get_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1653
extern signed int freecell_solver_user_get_limit_iterations(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return (signed int)user->active_flare->obj->max_num_checked_states;
}

// freecell_solver_user_get_max_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 174
extern signed int freecell_solver_user_get_max_num_decks(void)
{
  return 2;
}

// freecell_solver_user_get_max_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 160
extern signed int freecell_solver_user_get_max_num_freecells(void)
{
  return 8;
}

// freecell_solver_user_get_max_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 167
extern signed int freecell_solver_user_get_max_num_stacks(void)
{
  return 10;
}

// freecell_solver_user_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1660
extern signed int freecell_solver_user_get_moves_left(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(user->ret_code == 0)
    return user->active_flare->moves_seq.num_moves - user->active_flare->next_move;

  else
    return 0;
}

// freecell_solver_user_get_moves_sequence
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2477
extern signed int freecell_solver_user_get_moves_sequence(void *api_instance, struct anonymous$11 * const moves_seq)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(!(user->ret_code == 0))
    return -2;

  else
  {
    struct anonymous$1 *instance_item;
    instance_item=get_current_instance_item(user);
    struct anonymous$2 * const flare = &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx];
    moves_seq->num_moves = flare->moves_seq.num_moves;
    void *return_value_memdup$1;
    return_value_memdup$1=memdup$link1((void *)flare->moves_seq.moves, sizeof(struct anonymous$4) /*4ul*/  * (unsigned long int)flare->moves_seq.num_moves);
    moves_seq->moves = (struct anonymous$4 *)return_value_memdup$1;
    return 0;
  }
}

// freecell_solver_user_get_next_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1296
extern signed int freecell_solver_user_get_next_move(void *api_instance, struct anonymous$4 *user_move)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_instance_struct *instance = user->active_flare->obj;
  signed int tmp_post$1;
  if(user->ret_code == 0)
  {
    signed int ret;
    const struct anonymous$1 *instance_item;
    instance_item=get_current_instance_item(user);
    struct anonymous$2 *flare = &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx];
    if(flare->next_move == flare->moves_seq.num_moves)
      ret = 1;

    else
    {
      ret = 0;
      tmp_post$1 = flare->next_move;
      flare->next_move = flare->next_move + 1;
      *user_move = flare->moves_seq.moves[(signed long int)tmp_post$1];
    }
    if(ret == 0)
    {
      struct anonymous$6 pass;
      FCS_STATE_keyval_pair_to_kv$link1(&pass, &user->running_state);
      fc_solve_apply_move(&pass, (struct anonymous$7 *)(void *)0, *user_move, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num);
    }

    return ret;
  }

  else
    return 1;
}

// freecell_solver_user_get_num_soft_threads_in_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2132
extern signed int freecell_solver_user_get_num_soft_threads_in_instance(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return user->active_flare->obj->next_soft_thread_id;
}

// freecell_solver_user_get_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2027
extern signed int freecell_solver_user_get_num_states_in_collection(void *api_instance)
{
  signed long int return_value_freecell_solver_user_get_num_states_in_collection_long$1;
  return_value_freecell_solver_user_get_num_states_in_collection_long$1=freecell_solver_user_get_num_states_in_collection_long(api_instance);
  return (signed int)return_value_freecell_solver_user_get_num_states_in_collection_long$1;
}

// freecell_solver_user_get_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2020
signed long int freecell_solver_user_get_num_states_in_collection_long(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return (user->iterations_board_started_at.num_states_in_collection + user->active_flare->obj_stats.num_states_in_collection) - user->init_num_checked_states.num_states_in_collection;
}

// freecell_solver_user_get_num_times
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1648
extern signed int freecell_solver_user_get_num_times(void *api_instance)
{
  signed long int return_value_freecell_solver_user_get_num_times_long$1;
  return_value_freecell_solver_user_get_num_times_long$1=freecell_solver_user_get_num_times_long(api_instance);
  return (signed int)return_value_freecell_solver_user_get_num_times_long$1;
}

// freecell_solver_user_get_num_times_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 103
extern signed long int freecell_solver_user_get_num_times_long(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed long int tmp_if_expr$1;
  if(!(user->active_flare->obj->num_checked_states >= user->active_flare->obj_stats.num_checked_states))
    tmp_if_expr$1 = user->active_flare->obj_stats.num_checked_states;

  else
    tmp_if_expr$1 = user->active_flare->obj->num_checked_states;
  return (user->iterations_board_started_at.num_checked_states + tmp_if_expr$1) - user->init_num_checked_states.num_checked_states;
}

// freecell_solver_user_iter_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 236
extern char * freecell_solver_user_iter_state_as_string(void *api_instance, void *ptr_state_void, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_instance_struct * const instance = user->active_flare->obj;
  char *return_value_fc_solve_state_as_string$1;
  return_value_fc_solve_state_as_string$1=fc_solve_state_as_string(((struct anonymous$13 *)ptr_state_void)->key, &((struct anonymous$13 *)ptr_state_void)->locs, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, (_Bool)parseable_output, (_Bool)canonized_order_output, (_Bool)display_10_as_t);
  return return_value_fc_solve_state_as_string$1;
}

// freecell_solver_user_limit_current_instance_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 316
extern void freecell_solver_user_limit_current_instance_iterations(void *api_instance, signed int max_iters)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  (user->instances_list + (signed long int)user->current_instance_idx)->limit = max_iters;
}

// freecell_solver_user_limit_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 150
extern void freecell_solver_user_limit_depth(void *api_instance, signed int max_depth)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->max_depth = max_depth;
}

// freecell_solver_user_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 308
extern void freecell_solver_user_limit_iterations(void *api_instance, signed int max_iters)
{
  freecell_solver_user_limit_iterations_long(api_instance, (signed long int)max_iters);
}

// freecell_solver_user_limit_iterations_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 53
extern void freecell_solver_user_limit_iterations_long(void *api_instance, signed long int max_iters)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->current_iterations_limit = max_iters;
}

// freecell_solver_user_limit_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2055
extern void freecell_solver_user_limit_num_states_in_collection(void *api_instance, signed int max_num_states)
{
  freecell_solver_user_limit_num_states_in_collection_long(api_instance, (signed long int)max_num_states);
}

// freecell_solver_user_limit_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 255
extern void freecell_solver_user_limit_num_states_in_collection_long(void *api_instance, signed long int max_num_states)
{
  struct anonymous *user = (struct anonymous *)api_instance;
  if(!(max_num_states >= 0l))
  {
    user->active_flare->obj->max_num_states_in_collection = (signed long int)-1;
    user->active_flare->obj->effective_max_num_states_in_collection = 9223372036854775807L;
  }

  else
  {
    user->active_flare->obj->max_num_states_in_collection = max_num_states;
    user->active_flare->obj->effective_max_num_states_in_collection = user->active_flare->obj->max_num_states_in_collection;
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// freecell_solver_user_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1680
extern char * freecell_solver_user_move_to_string(struct anonymous$4 move, signed int standard_notation)
{
  char *return_value_fc_solve_move_to_string$1;
  return_value_fc_solve_move_to_string$1=fc_solve_move_to_string(move, standard_notation);
  return return_value_fc_solve_move_to_string$1;
}

// freecell_solver_user_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1688
extern char * freecell_solver_user_move_to_string_w_state(void *api_instance, struct anonymous$4 move, signed int standard_notation)
{
  struct fc_solve_instance_struct *instance;
  struct anonymous * const user = (struct anonymous *)api_instance;
  instance = user->active_flare->obj;
  char *return_value_fc_solve_move_to_string_w_state$1;
  return_value_fc_solve_move_to_string_w_state$1=fc_solve_move_to_string_w_state(&user->running_state, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, move, standard_notation);
  return return_value_fc_solve_move_to_string_w_state$1;
}

// freecell_solver_user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 341
extern signed int freecell_solver_user_next_flare(void *api_instance)
{
  signed int return_value_user_next_flare$1;
  return_value_user_next_flare$1=user_next_flare((struct anonymous *)api_instance);
  return return_value_user_next_flare$1;
}

// freecell_solver_user_next_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 279
extern signed int freecell_solver_user_next_hard_thread(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_soft_thread_struct *soft_thread;
  soft_thread=fc_solve_new_hard_thread$link1(user->active_flare->obj);
  if(soft_thread == ((struct fc_solve_soft_thread_struct *)NULL))
    return 1;

  else
  {
    user->soft_thread = soft_thread;
    return 0;
  }
}

// freecell_solver_user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 337
extern signed int freecell_solver_user_next_instance(void *api_instance)
{
  signed int return_value_user_next_instance$1;
  return_value_user_next_instance$1=user_next_instance((struct anonymous *)api_instance);
  return return_value_user_next_instance$1;
}

// freecell_solver_user_next_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 270
extern signed int freecell_solver_user_next_soft_thread(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_soft_thread_struct *soft_thread;
  soft_thread=fc_solve_new_soft_thread(user->soft_thread->hard_thread);
  if(soft_thread == ((struct fc_solve_soft_thread_struct *)NULL))
    return 1;

  else
  {
    user->soft_thread = soft_thread;
    return 0;
  }
}

// freecell_solver_user_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 312
extern void freecell_solver_user_recycle(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed int i = 0;
  for( ; !(i >= user->num_instances); i = i + 1)
    recycle_instance(user, i);
  user->iterations_board_started_at.num_checked_states = (signed long int)0;
  user->iterations_board_started_at.num_states_in_collection = (signed long int)0;
  if(!(user->state_string_copy == ((char *)NULL)))
  {
    free((void *)user->state_string_copy);
    user->state_string_copy = (char *)(void *)0;
  }

}

// freecell_solver_user_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 349
extern signed int freecell_solver_user_reset(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user_free_resources(user);
  user_initialize(user);
  return 0;
}

// freecell_solver_user_resume_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 943
extern signed int freecell_solver_user_resume_solution(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct anonymous$44 init_num_checked_states;
  signed int ret = 1;
  signed int tmp_post$1;
  signed int tmp_if_expr$3;
  signed int return_value_normalize_iters_quota$2;
  signed long int tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$9;
  signed int return_value_get_flare_move_count$7;
  signed int return_value_get_flare_move_count$8;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  do
  {
    struct anonymous$1 *instance_item;
    instance_item=get_current_instance_item(user);
    if(instance_item->current_plan_item_idx == instance_item->num_plan_items)
    {
      if(!(instance_item->all_plan_items_finished_so_far == 0))
      {
        recycle_instance(user, user->current_instance_idx);
        user->current_instance_idx = user->current_instance_idx + 1;
        continue;
      }

      else
      {
        instance_item->all_plan_items_finished_so_far = 1;
        instance_item->current_plan_item_idx = 0;
      }
    }

    const struct anonymous$0 *current_plan_item;
    tmp_post$1 = instance_item->current_plan_item_idx;
    instance_item->current_plan_item_idx = instance_item->current_plan_item_idx + 1;
    current_plan_item = &instance_item->plan[(signed long int)tmp_post$1];
    if(current_plan_item->type == FLARES_PLAN_CHECKPOINT)
    {
      if(instance_item->minimal_solution_flare_idx >= 0)
      {
        user->active_flare = &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx];
        user->init_num_checked_states = user->active_flare->obj_stats;
        user->ret_code = 0;
        ret = user->ret_code;
        break;
      }

    }

    else
    {
      signed int flare_iters_quota;
      if(current_plan_item->type == FLARES_PLAN_RUN_INDEFINITELY)
        tmp_if_expr$3 = -1;

      else
      {
        return_value_normalize_iters_quota$2=normalize_iters_quota((signed int)(user->flares_iters_factor * (double)current_plan_item->count_iters));
        tmp_if_expr$3 = return_value_normalize_iters_quota$2;
      }
      flare_iters_quota = tmp_if_expr$3;
      const signed int flare_idx = current_plan_item->flare_idx;
      struct anonymous$2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      user->active_flare = flare;
      const _Bool is_start_of_flare_solving = flare->ret_code == 9;
      if(!(is_start_of_flare_solving == (_Bool)0))
      {
        struct fc_solve_instance_struct *instance = user->active_flare->obj;
        signed int return_value_fc_solve_initial_user_state_to_c_proto$4;
        return_value_fc_solve_initial_user_state_to_c_proto$4=fc_solve_initial_user_state_to_c_proto(user->state_string_copy, &user->state, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, user->indirect_stacks_buffer);
        if(!(return_value_fc_solve_initial_user_state_to_c_proto$4 == 0))
        {
          user->ret_code = 8;
          user->state_validity_ret = 4;
          return user->ret_code;
        }

        user->state_validity_ret=fc_solve_check_state_validity(&user->state, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, &user->state_validity_card);
        if(!(user->state_validity_ret == 0))
        {
          user->ret_code = 8;
          return user->ret_code;
        }

        fc_solve_init_locs(&user->initial_state_locs);
        user->state_locs = user->initial_state_locs;
        struct anonymous$6 state_pass;
        FCS_STATE_keyval_pair_to_kv$link1(&state_pass, &user->state);
        struct anonymous$6 pass;
        FCS_STATE_keyval_pair_to_kv$link1(&pass, &user->running_state);
        *(&pass)->key = *(&state_pass)->key;
        *(&pass)->val = *(&state_pass)->val;
        (&pass)->val->stacks_copy_on_write_flags = 0;
        struct anonymous$6 initial_pass;
        FCS_STATE_keyval_pair_to_kv$link1(&initial_pass, &user->initial_non_canonized_state);
        *(&initial_pass)->key = *(&state_pass)->key;
        *(&initial_pass)->val = *(&state_pass)->val;
        (&initial_pass)->val->stacks_copy_on_write_flags = 0;
        fc_solve_canonize_state_with_locs(&state_pass, &user->state_locs, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num);
        user->trace_solution_state_locs = user->state_locs;
        fc_solve_init_instance(user->active_flare->obj);
      }

      signed long int limits[3l];
      signed int limit_idx;
      signed long int mymin;
      signed long int new_lim;
      limits[(signed long int)0] = (signed long int)instance_item->limit;
      limits[(signed long int)1] = user->current_iterations_limit;
      if(!(flare_iters_quota >= 0))
        tmp_if_expr$5 = (signed long int)-1;

      else
        tmp_if_expr$5 = user->iterations_board_started_at.num_checked_states + (signed long int)flare_iters_quota;
      limits[(signed long int)2] = tmp_if_expr$5;
      mymin = limits[(signed long int)0];
      limit_idx = 1;
      for( ; !(limit_idx >= 3); limit_idx = limit_idx + 1)
      {
        new_lim = limits[(signed long int)limit_idx];
        if(new_lim >= 0l)
          mymin = mymin < (signed long int)0 ? new_lim : (mymin < new_lim ? mymin : new_lim);

      }
      if(!(mymin >= 0l))
      {
        user->active_flare->obj->max_num_checked_states = (signed long int)-1;
        user->active_flare->obj->effective_max_num_checked_states = 9223372036854775807L;
      }

      else
      {
        user->active_flare->obj->effective_max_num_checked_states = (user->active_flare->obj->num_checked_states + mymin) - user->iterations_board_started_at.num_checked_states;
        user->active_flare->obj->max_num_checked_states = user->active_flare->obj->effective_max_num_checked_states;
      }
      init_num_checked_states.num_checked_states = user->active_flare->obj->num_checked_states;
      user->init_num_checked_states.num_checked_states = init_num_checked_states.num_checked_states;
      init_num_checked_states.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
      user->init_num_checked_states.num_states_in_collection = init_num_checked_states.num_states_in_collection;
      if(!(is_start_of_flare_solving == (_Bool)0))
        fc_solve_start_instance_process_with_board(user->active_flare->obj, &user->state);

      _Bool was_run_now;
      if(flare->ret_code == 5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = flare->ret_code == 9 ? (_Bool)1 : (_Bool)0;
      was_run_now = tmp_if_expr$6;
      if(!(was_run_now == (_Bool)0))
      {
        flare->ret_code=fc_solve_resume_instance(user->active_flare->obj);
        user->ret_code = flare->ret_code;
        ret = user->ret_code;
        flare->instance_is_ready = (_Bool)0;
      }

      if(!(ret == 5))
        user->all_instances_were_suspended = (_Bool)0;

      user->active_flare->obj_stats.num_checked_states = user->active_flare->obj->num_checked_states;
      user->active_flare->obj_stats.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
      user->iterations_board_started_at.num_checked_states = user->iterations_board_started_at.num_checked_states + (user->active_flare->obj_stats.num_checked_states - init_num_checked_states.num_checked_states);
      user->iterations_board_started_at.num_states_in_collection = user->iterations_board_started_at.num_states_in_collection + (user->active_flare->obj_stats.num_states_in_collection - init_num_checked_states.num_states_in_collection);
      user->init_num_checked_states = user->active_flare->obj_stats;
      if(user->ret_code == 0)
      {
        struct fc_solve_instance_struct *freecell_solver_user_resume_solution$$1$$1$$8$$instance = user->active_flare->obj;
        struct anonymous$6 freecell_solver_user_resume_solution$$1$$1$$8$$pass;
        FCS_STATE_keyval_pair_to_kv$link1(&freecell_solver_user_resume_solution$$1$$1$$8$$pass, &user->state);
        fc_solve_move_stack_normalize(&user->active_flare->obj->solution_moves, &freecell_solver_user_resume_solution$$1$$1$$8$$pass, &user->trace_solution_state_locs, (signed int)freecell_solver_user_resume_solution$$1$$1$$8$$instance->game_params.freecells_num, (signed int)freecell_solver_user_resume_solution$$1$$1$$8$$instance->game_params.stacks_num, (signed int)freecell_solver_user_resume_solution$$1$$1$$8$$instance->game_params.decks_num);
        calc_moves_seq(&user->active_flare->obj->solution_moves, &flare->moves_seq);
        flare->next_move = 0;
        if(!(flare->obj->solution_moves.moves == ((struct anonymous$4 *)NULL)))
        {
          free((void *)flare->obj->solution_moves.moves);
          flare->obj->solution_moves.moves = (struct anonymous$4 *)(void *)0;
        }

        user->active_flare->obj_stats.num_checked_states = user->active_flare->obj->num_checked_states;
        user->active_flare->obj_stats.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
        fc_solve_recycle_instance(flare->obj);
        flare->instance_is_ready = (_Bool)1;
        user->trace_solution_state_locs = user->state_locs;
        if(!(instance_item->minimal_solution_flare_idx >= 0))
          tmp_if_expr$9 = (_Bool)1;

        else
        {
          return_value_get_flare_move_count$7=get_flare_move_count(user, &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx]);
          return_value_get_flare_move_count$8=get_flare_move_count(user, &instance_item->flares[(signed long int)flare_idx]);
          tmp_if_expr$9 = return_value_get_flare_move_count$7 > return_value_get_flare_move_count$8 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$9)
          instance_item->minimal_solution_flare_idx = flare_idx;

        user->ret_code = 1;
        ret = user->ret_code;
      }

      else
        if(user->ret_code == 1)
        {
          if(!(was_run_now == (_Bool)0))
          {
            fc_solve_recycle_instance(user->active_flare->obj);
            user->active_flare->instance_is_ready = (_Bool)1;
          }

        }

        else
          if(user->ret_code == 5)
          {
            if(user->current_iterations_limit >= 0l)
              tmp_if_expr$10 = user->iterations_board_started_at.num_checked_states >= user->current_iterations_limit ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$10 = (_Bool)0;
            if(tmp_if_expr$10)
              tmp_if_expr$11 = (_Bool)1;

            else
              tmp_if_expr$11 = user->active_flare->obj->num_states_in_collection >= user->active_flare->obj->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$11)
            {
              instance_item->current_plan_item_idx = instance_item->current_plan_item_idx - 1;
              break;
            }

            ret = 1;
            if(instance_item->limit >= 0)
            {
              if(user->active_flare->obj->num_checked_states >= (signed long int)instance_item->limit)
              {
                user->active_flare->obj_stats.num_checked_states = user->active_flare->obj->num_checked_states;
                user->active_flare->obj_stats.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
                recycle_instance(user, user->current_instance_idx);
                user->current_instance_idx = user->current_instance_idx + 1;
                continue;
              }

            }

            instance_item->all_plan_items_finished_so_far = 0;
          }

    }
  }
  while(ret == 1 && !(user->current_instance_idx >= user->num_instances));
  return user->all_instances_were_suspended != (_Bool)0 ? 5 : ret;
}

// freecell_solver_user_set_a_star_weight
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 197
extern signed int freecell_solver_user_set_a_star_weight(void *api_instance, signed int my_index, double weight)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if((unsigned long int)my_index >= 6ul || !(my_index >= 0))
    return 1;

  else
    if(weight < 0.000000)
      return 2;

    else
    {
      user->soft_thread->method_specific.befs.meth.befs.weighting.befs_weights[(signed long int)my_index] = weight;
      return 0;
    }
}

// freecell_solver_user_set_cache_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 386
extern signed int freecell_solver_user_set_cache_limit(void *api_instance, signed long int limit)
{
  return 0;
}

// freecell_solver_user_set_calc_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 287
extern void freecell_solver_user_set_calc_real_depth(void *api_instance, signed int calc_real_depth)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~4;
  if(!(calc_real_depth == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)4;

}

// freecell_solver_user_set_depth_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 373
extern signed int freecell_solver_user_set_depth_tests_order(void *api_instance, signed int min_depth, const char *tests_order, char **error_string)
{
  signed int depth_idx;
  signed int ret_code;
  struct anonymous * const user = (struct anonymous *)api_instance;
  *error_string = (char *)(void *)0;
  if(!(min_depth >= 0))
  {
    *error_string=strdup("Depth is negative.");
    return 1;
  }

  else
  {
    if(min_depth == 0)
      depth_idx = 0;

    else
    {
      depth_idx = 0;
      for( ; (_Bool)1; depth_idx = depth_idx + 1)
        if(depth_idx == user->soft_thread->by_depth_tests_order.num + -1)
          goto __CPROVER_DUMP_L6;

        else
          if(!(min_depth >= (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->max_depth))
            goto __CPROVER_DUMP_L6;


    __CPROVER_DUMP_L6:
      ;
      depth_idx = depth_idx + 1;
    }
    if(depth_idx == user->soft_thread->by_depth_tests_order.num)
    {
      user->soft_thread->by_depth_tests_order.num = user->soft_thread->by_depth_tests_order.num + 1;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)user->soft_thread->by_depth_tests_order.by_depth_tests, sizeof(struct anonymous$21) /*24ul*/  * (unsigned long int)user->soft_thread->by_depth_tests_order.num);
      user->soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous$21 *)return_value_realloc$1;
      (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order.num_groups = 0;
      (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order.groups = (struct anonymous$20 *)(void *)0;
    }

    if(depth_idx >= 1)
      (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)(depth_idx - 1))->max_depth = min_depth;

    (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->max_depth = 0x7fffffff;
    ret_code=fc_solve_apply_tests_order(&(user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order, tests_order, error_string);
    signed int further_depth_idx = depth_idx + 1;
    for( ; !(further_depth_idx >= user->soft_thread->by_depth_tests_order.num); further_depth_idx = further_depth_idx + 1)
      fc_solve_free_tests_order$link1(&(user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)further_depth_idx)->tests_order);
    user->soft_thread->by_depth_tests_order.num = depth_idx + 1;
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)user->soft_thread->by_depth_tests_order.by_depth_tests, sizeof(struct anonymous$21) /*24ul*/  * (unsigned long int)user->soft_thread->by_depth_tests_order.num);
    user->soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous$21 *)return_value_realloc$2;
    return ret_code;
  }
}

// freecell_solver_user_set_empty_stacks_filled_by
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 187
extern signed int freecell_solver_user_set_empty_stacks_filled_by(void *api_instance, signed int empty_stacks_fill)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(empty_stacks_fill >= 3 || !(empty_stacks_fill >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags & (unsigned char)~(0x3 << 2);
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags | (unsigned char)(empty_stacks_fill << 2);
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_flare_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 297
extern void freecell_solver_user_set_flare_name(void *api_instance, const char *name)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct anonymous$1 *instance_item;
  instance_item=get_current_instance_item(user);
  struct anonymous$2 *flare = &instance_item->flares[(signed long int)(instance_item->num_flares - 1)];
  if(!(flare->name == ((char *)NULL)))
    free((void *)flare->name);

  flare->name=strdup(name);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// freecell_solver_user_set_flares_choice
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 396
extern signed int freecell_solver_user_set_flares_choice(void *api_instance, const char * const new_flares_choice_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(new_flares_choice_string, "fc_solve");
  signed int return_value_strcmp$1;
  if(return_value_strcmp$2 == 0)
    user->flares_choice = (enum FLARES_CHOICE_TYPE)FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN;

  else
  {
    return_value_strcmp$1=strcmp(new_flares_choice_string, "fcpro");
    if(return_value_strcmp$1 == 0)
      user->flares_choice = (enum FLARES_CHOICE_TYPE)FLARES_CHOICE_FCPRO_SOLUTION_LEN;

    else
      return -1;
  }
  return 0;
}

// freecell_solver_user_set_flares_iters_factor
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 401
extern void freecell_solver_user_set_flares_iters_factor(void *api_instance, double new_factor)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->flares_iters_factor = new_factor;
}

// freecell_solver_user_set_flares_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 307
extern signed int freecell_solver_user_set_flares_plan(void *api_instance, const char *flares_plan_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct anonymous$1 *instance_item;
  instance_item=get_current_instance_item(user);
  if(!(instance_item->flares_plan_string == ((char *)NULL)))
    free((void *)instance_item->flares_plan_string);

  char *tmp_if_expr$2;
  char *return_value_strdup$1;
  if(!(flares_plan_string == ((const char *)NULL)))
  {
    return_value_strdup$1=strdup(flares_plan_string);
    tmp_if_expr$2 = return_value_strdup$1;
  }

  else
    tmp_if_expr$2 = (char *)(void *)0;
  instance_item->flares_plan_string = tmp_if_expr$2;
  instance_item->flares_plan_compiled = (_Bool)0;
  return 0;
}

// freecell_solver_user_set_game
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1601
extern signed int freecell_solver_user_set_game(void *api_instance, signed int freecells_num, signed int stacks_num, signed int decks_num, signed int sequences_are_built_by, signed int unlimited_sequence_move, signed int empty_stacks_fill)
{
  signed int return_value_freecell_solver_user_set_num_freecells$1;
  return_value_freecell_solver_user_set_num_freecells$1=freecell_solver_user_set_num_freecells(api_instance, freecells_num);
  if(!(return_value_freecell_solver_user_set_num_freecells$1 == 0))
    return 1;

  else
  {
    signed int return_value_freecell_solver_user_set_num_stacks$2;
    return_value_freecell_solver_user_set_num_stacks$2=freecell_solver_user_set_num_stacks(api_instance, stacks_num);
    if(!(return_value_freecell_solver_user_set_num_stacks$2 == 0))
      return 2;

    else
    {
      signed int return_value_freecell_solver_user_set_num_decks$3;
      return_value_freecell_solver_user_set_num_decks$3=freecell_solver_user_set_num_decks(api_instance, decks_num);
      if(!(return_value_freecell_solver_user_set_num_decks$3 == 0))
        return 3;

      else
      {
        signed int return_value_freecell_solver_user_set_sequences_are_built_by_type$4;
        return_value_freecell_solver_user_set_sequences_are_built_by_type$4=freecell_solver_user_set_sequences_are_built_by_type(api_instance, sequences_are_built_by);
        if(!(return_value_freecell_solver_user_set_sequences_are_built_by_type$4 == 0))
          return 4;

        else
        {
          signed int return_value_freecell_solver_user_set_sequence_move$5;
          return_value_freecell_solver_user_set_sequence_move$5=freecell_solver_user_set_sequence_move(api_instance, unlimited_sequence_move);
          if(!(return_value_freecell_solver_user_set_sequence_move$5 == 0))
            return 5;

          else
          {
            signed int return_value_freecell_solver_user_set_empty_stacks_filled_by$6;
            return_value_freecell_solver_user_set_empty_stacks_filled_by$6=freecell_solver_user_set_empty_stacks_filled_by(api_instance, empty_stacks_fill);
            if(!(return_value_freecell_solver_user_set_empty_stacks_filled_by$6 == 0))
              return 6;

            else
              return 0;
          }
        }
      }
    }
  }
}

// freecell_solver_user_set_hard_thread_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 302
extern signed int freecell_solver_user_set_hard_thread_prelude(void *api_instance, const char *prelude)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_hard_thread_struct *hard_thread = user->soft_thread->hard_thread;
  if(!(hard_thread->prelude_as_string == ((char *)NULL)))
  {
    free((void *)hard_thread->prelude_as_string);
    hard_thread->prelude_as_string = (char *)(void *)0;
  }

  hard_thread->prelude_as_string=strdup(prelude);
  return 0;
}

// freecell_solver_user_set_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1965
extern void freecell_solver_user_set_iter_handler(void *api_instance, void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context)
{
  set_any_iter_handler(api_instance, (void (*)(void *, signed long int, signed int, void *, signed long int, void *))(void *)0, iter_handler, iter_handler_context);
}

// freecell_solver_user_set_iter_handler_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 229
extern void freecell_solver_user_set_iter_handler_long(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void *iter_handler_context)
{
  set_any_iter_handler(api_instance, long_iter_handler, (void (*)(void *, signed int, signed int, void *, signed int, void *))(void *)0, iter_handler_context);
}

// freecell_solver_user_set_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 169
extern signed int freecell_solver_user_set_num_decks(void *api_instance, signed int decks_num)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(decks_num >= 3 || !(decks_num >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.decks_num = (unsigned char)decks_num;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 155
extern signed int freecell_solver_user_set_num_freecells(void *api_instance, signed int freecells_num)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(freecells_num >= 9 || !(freecells_num >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.freecells_num = (unsigned char)freecells_num;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 162
extern signed int freecell_solver_user_set_num_stacks(void *api_instance, signed int stacks_num)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(stacks_num >= 11 || !(stacks_num >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.stacks_num = (unsigned char)stacks_num;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_optimization_scan_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 316
extern signed int freecell_solver_user_set_optimization_scan_tests_order(void *api_instance, const char *tests_order, char **error_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  fc_solve_free_tests_order$link1(&user->active_flare->obj->opt_tests_order);
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~8;
  signed int ret;
  ret=fc_solve_apply_tests_order(&user->active_flare->obj->opt_tests_order, tests_order, error_string);
  if(ret == 0)
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)8;

  return ret;
}

// freecell_solver_user_set_pruning
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 380
extern signed int freecell_solver_user_set_pruning(void *api_instance, const char *pruning, char **error_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(pruning, "r:tf");
  if(return_value_strcmp$1 == 0)
    user->soft_thread->enable_pruning = (_Bool)1;

  else
    if((signed int)*pruning == 0)
      user->soft_thread->enable_pruning = (_Bool)0;

    else
    {
      *error_string=strdup("Unknown pruning value - must be \"r:tf\" or empty.");
      return 1;
    }
  return 0;
}

// freecell_solver_user_set_random_seed
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 244
extern void freecell_solver_user_set_random_seed(void *api_instance, signed int seed)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->soft_thread->method_specific.soft_dfs.rand_seed = seed;
  fc_solve_rand_init(&user->soft_thread->method_specific.soft_dfs.rand_gen, (unsigned int)user->soft_thread->method_specific.soft_dfs.rand_seed);
}

// freecell_solver_user_set_reparent_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 322
extern void freecell_solver_user_set_reparent_states(void *api_instance, signed int to_reparent_states)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~16;
  if(!(to_reparent_states == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)16;

}

// freecell_solver_user_set_scans_synergy
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 327
extern void freecell_solver_user_set_scans_synergy(void *api_instance, signed int synergy)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~64;
  if(!(synergy == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)64;

}

// freecell_solver_user_set_sequence_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 192
extern signed int freecell_solver_user_set_sequence_move(void *api_instance, signed int unlimited_sequence_move)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags & (unsigned char)~(1 << 4);
  user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags | (unsigned char)((signed int)(unlimited_sequence_move != 0) << 4);
  apply_game_params_for_all_instances(user);
  return 0;
}

// freecell_solver_user_set_sequences_are_built_by_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 182
extern signed int freecell_solver_user_set_sequences_are_built_by_type(void *api_instance, signed int sequences_are_built_by)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(sequences_are_built_by >= 3 || !(sequences_are_built_by >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags & (unsigned char)~0x3;
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags | (unsigned char)sequences_are_built_by;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 292
extern void freecell_solver_user_set_soft_thread_name(void *api_instance, const char *name)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(!(user->soft_thread->name == ((char *)NULL)))
    free((void *)user->soft_thread->name);

  user->soft_thread->name=strdup(name);
}

// freecell_solver_user_set_soft_thread_step
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 274
extern void freecell_solver_user_set_soft_thread_step(void *api_instance, signed int num_checked_states_step)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->soft_thread->num_checked_states_step = num_checked_states_step;
}

// freecell_solver_user_set_solution_optimization
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 134
extern void freecell_solver_user_set_solution_optimization(void *api_instance, signed int optimize)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~1;
  if(!(optimize == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)1;

}

// freecell_solver_user_set_solving_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 98
extern void freecell_solver_user_set_solving_method(void *api_instance, signed int method)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_soft_thread_struct * const soft_thread = user->soft_thread;
  enum FCS_SUPER_METHOD_TYPE super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_BEFS_BRFS;
  if(method == 0)
    method = 1;

  soft_thread->method = method;
  if(soft_thread->method == 1 || soft_thread->method == 5)
    super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_DFS;

  soft_thread->super_method_type = super_method_type;
}

// freecell_solver_user_set_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 63
extern signed int freecell_solver_user_set_tests_order(void *api_instance, const char *tests_order, char **error_string)
{
  signed int return_value_freecell_solver_user_set_depth_tests_order$1;
  return_value_freecell_solver_user_set_depth_tests_order$1=freecell_solver_user_set_depth_tests_order(api_instance, 0, tests_order, error_string);
  return return_value_freecell_solver_user_set_depth_tests_order$1;
}

// freecell_solver_user_solve_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 69
extern signed int freecell_solver_user_solve_board(void *api_instance, const char *state_as_string)
{
  signed int ret_code;
  char *error_string;
  signed int instance_list_index;
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->state_string_copy=duplicate_string_while_adding_a_trailing_newline(state_as_string);
  user->current_instance_idx = 0;
  ret_code=user_compile_all_flares_plans(user, &instance_list_index, &error_string);
  if(!(ret_code == 0))
  {
    user->error_string = error_string;
    return 12;
  }

  else
  {
    signed int return_value_freecell_solver_user_resume_solution$1;
    return_value_freecell_solver_user_resume_solution$1=freecell_solver_user_resume_solution(api_instance);
    return return_value_freecell_solver_user_resume_solution$1;
  }
}

// generic_false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 501
static inline const _Bool generic_false_seq_index_loop(const signed int stacks_num, struct anonymous$6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous$45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag, const _Bool should_src_col, const char src_card, const signed int num_src_junk_true_seqs)
{
  const signed int num_separate_false_seqs = seqs->num_separate_false_seqs;
  _Bool stacks_map[10l];
  init_stacks_map(stacks_map, stack_idx, ds);
  signed int after_junk_num_freestacks = num_vacant_stacks;
  const signed int false_seq_index_limit = num_separate_false_seqs + (should_src_col != (_Bool)0 ? 1 : 0);
  signed int false_seq_index = 0;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  for( ; !(false_seq_index >= false_seq_index_limit); false_seq_index = false_seq_index + 1)
  {
    const _Bool is_ultimate_iter = false_seq_index == num_separate_false_seqs;
    char the_card;
    if(!(is_ultimate_iter == (_Bool)0))
      tmp_if_expr$1 = (signed int)src_card;

    else
      tmp_if_expr$1 = (signed int)col[(signed long int)(seqs->seq_points[(signed long int)false_seq_index] + 1)];
    the_card = (const char)tmp_if_expr$1;
    signed int the_num_true_seqs;
    if(!(is_ultimate_iter == (_Bool)0))
      tmp_if_expr$2 = num_src_junk_true_seqs;

    else
      tmp_if_expr$2 = seqs->above_num_true_seqs[(signed long int)false_seq_index];
    the_num_true_seqs = tmp_if_expr$2;
    signed int clear_junk_dest_stack = 0;
    for( ; !(clear_junk_dest_stack >= stacks_num); clear_junk_dest_stack = clear_junk_dest_stack + 1)
    {
      char * const clear_junk_dest_col = raw_ptr_state_raw->key->stacks[(signed long int)clear_junk_dest_stack];
      const signed int clear_junk_stack_len = (const signed int)clear_junk_dest_col[(signed long int)0];
      if(clear_junk_stack_len >= 1)
        tmp_if_expr$3 = !(stacks_map[(signed long int)clear_junk_dest_stack] != (_Bool)0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        const char clear_junk_dest_card = clear_junk_dest_col[(signed long int)((clear_junk_stack_len - 1) + 1)];
        if((signed int)clear_junk_dest_card >> 2 == ((signed int)the_card >> 2) + 1)
        {
          if(1 << after_junk_num_freestacks >= the_num_true_seqs)
          {
            stacks_map[(signed long int)clear_junk_dest_stack] = (_Bool)1;
            break;
          }

        }

      }

    }
    if(clear_junk_dest_stack == stacks_num)
    {
      if(!(1 << after_junk_num_freestacks + -1 >= the_num_true_seqs) || !(num_vacant_stacks >= 1) || behaviour_flag != (_Bool)0)
        break;

      clear_junk_dest_stack = 0;
      for( ; !(clear_junk_dest_stack >= stacks_num); clear_junk_dest_stack = clear_junk_dest_stack + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)clear_junk_dest_stack] == 0)
        {
          if(stacks_map[(signed long int)clear_junk_dest_stack] == (_Bool)0)
          {
            stacks_map[(signed long int)clear_junk_dest_stack] = (_Bool)1;
            break;
          }

        }

      after_junk_num_freestacks = after_junk_num_freestacks - 1;
    }

    seqs->junk_move_to_stacks[(signed long int)false_seq_index] = clear_junk_dest_stack;
  }
  seqs->after_junk_num_freestacks = after_junk_num_freestacks;
  return false_seq_index == false_seq_index_limit;
}

// generic_populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 460
static inline void generic_populate_seq_points(char * const dest_col, const signed int dc, struct anonymous$45 * const seqs, const signed int dest_cards_num)
{
  signed int num_separate_false_seqs = seqs->num_separate_false_seqs;
  seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] = 1;
  char above_card = dest_col[(signed long int)((dest_cards_num - 1) + 1)];
  signed int above_c = dest_cards_num - 2;
  signed int tmp_post$1;
  for( ; !(dc >= above_c); above_c = above_c - 1)
  {
    const char up_above_card = dest_col[(signed long int)(above_c + 1)];
    if(!((signed int)up_above_card >> 2 == ((signed int)above_card >> 2) + 1))
    {
      tmp_post$1 = num_separate_false_seqs;
      num_separate_false_seqs = num_separate_false_seqs + 1;
      seqs->seq_points[(signed long int)tmp_post$1] = above_c + 1;
      seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] = 1;
    }

    _Bool return_value_fcs_is_ss_suit_true$2;
    return_value_fcs_is_ss_suit_true$2=fcs_is_ss_suit_true(up_above_card, above_card);
    seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] = seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] + (signed int)!(return_value_fcs_is_ss_suit_true$2 != (_Bool)0);
    above_card = up_above_card;
  }
  signed int tmp_post$3;
  if(dest_cards_num + -2 >= dc)
  {
    tmp_post$3 = num_separate_false_seqs;
    num_separate_false_seqs = num_separate_false_seqs + 1;
    seqs->seq_points[(signed long int)tmp_post$3] = dc + 1;
  }

  seqs->num_separate_false_seqs = num_separate_false_seqs;
}

// get_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 186
static inline void get_board(signed long int gamenumber, char *ret)
{
  get_board_l((signed long long int)gamenumber, ret);
}

// get_board_l
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 123
static inline void get_board_l(const signed long long int gamenumber, char * const ret)
{
  signed long long int seedx = (signed long long int)(unsigned int)(gamenumber < 0x100000000LL ? gamenumber : gamenumber - 0x100000000LL);
  signed int card[8l][7l];
  signed int i;
  signed int j;
  signed int wLeft = 52;
  signed int deck[52l];
  i = 0;
  for( ; !(i >= 52); i = i + 1)
    deck[(signed long int)i] = i;
  i = 0;
  for( ; !(i >= 52); i = i + 1)
  {
    unsigned int return_value_microsoft_rand__game_num_rand$1;
    return_value_microsoft_rand__game_num_rand$1=microsoft_rand__game_num_rand(&seedx, gamenumber);
    j = (signed int)(return_value_microsoft_rand__game_num_rand$1 % (unsigned int)wLeft);
    card[(signed long int)(i % 8)][(signed long int)(i / 8)] = deck[(signed long int)j];
    wLeft = wLeft - 1;
    deck[(signed long int)j] = deck[(signed long int)wLeft];
  }
  char *append_to = ret;
  signed int stack;
  signed int c;
  stack = 0;
  char *tmp_post$2;
  for( ; !(stack >= 8); stack = stack + 1)
  {
    c = 0;
    for( ; !(c >= 6 + (signed int)!(stack >= 4)); c = c + 1)
      append_to=card_to_string(append_to, card[(signed long int)stack][(signed long int)c], (signed int)(c == (6 - 1) + (signed int)(stack < 4)));
    tmp_post$2 = append_to;
    append_to = append_to + 1l;
    *tmp_post$2 = (char)10;
  }
  *append_to = (char)0;
}

// get_current_instance_item
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 927
static inline struct anonymous$1 * get_current_instance_item(const struct anonymous *user)
{
  return &user->instances_list[(signed long int)user->current_instance_idx];
}

// get_flare_move_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 898
static signed int get_flare_move_count(struct anonymous * const user, struct anonymous$2 * const flare)
{
  if((signed int)user->flares_choice == FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN)
    return flare->moves_seq.num_moves;

  else
  {
    if(flare->fc_pro_moves.moves == ((struct anonymous$53 *)NULL))
      fc_solve_moves_processed_gen(&flare->fc_pro_moves, &user->initial_non_canonized_state, (const signed int)user->common_preset.game_params.freecells_num, &flare->moves_seq);

    signed int return_value_fc_solve_moves_processed_get_moves_left$1;
    return_value_fc_solve_moves_processed_get_moves_left$1=fc_solve_moves_processed_get_moves_left(&flare->fc_pro_moves);
    return return_value_fc_solve_moves_processed_get_moves_left$1;
  }
}

// get_seq_h
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 370
static inline signed int get_seq_h(char * const col, signed int *num_true_seqs_out_ptr)
{
  const signed int cards_num = (const signed int)col[(signed long int)0];
  char card = col[(signed long int)((cards_num - 1) + 1)];
  signed int num_true_seqs = 1;
  signed int h = cards_num - 2;
  for( ; h >= 0; h = h - 1)
  {
    const char next_card = col[(signed long int)(h + 1)];
    if(!((signed int)next_card >> 2 == ((signed int)card >> 2) + 1))
      break;

    _Bool return_value_fcs_is_ss_suit_true$1;
    return_value_fcs_is_ss_suit_true$1=fcs_is_ss_suit_true(next_card, card);
    if(return_value_fcs_is_ss_suit_true$1 == (_Bool)0)
      num_true_seqs = num_true_seqs + 1;

    card = next_card;
  }
  *num_true_seqs_out_ptr = num_true_seqs;
  return h + 1;
}

// get_the_positions_by_rank_data__ss_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 143
static char * get_the_positions_by_rank_data__ss_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const the_state)
{
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const struct anonymous$14 game_params = instance->game_params;
  char *positions_by_rank;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)((13 + 1) * 2 * 4));
  positions_by_rank = (char *)return_value_malloc$1;
  memset((void *)positions_by_rank, -1, sizeof(char) /*1ul*/  * (unsigned long int)((13 + 1) * 2 * 4));
  signed int ds = 0;
  for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
  {
    const char * const dest_col = the_state->stacks[(signed long int)ds];
    const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
    signed int dc = 0;
    for( ; !(dc >= dest_cards_num); dc = dc + 1)
    {
      const char card = dest_col[(signed long int)(dc + 1)];
      const signed int suit = (signed int)card & 0x03;
      const signed int rank = (signed int)card >> 2;
      positions_by_rank[(signed long int)((suit * (13 + 1) + rank) * 2)] = (char)ds;
      positions_by_rank[(signed long int)((suit * (13 + 1) + rank) * 2 + 1)] = (char)dc;
    }
  }
  return positions_by_rank;
}

// init_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 297
static inline void init_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread, struct fc_solve_soft_thread_struct * const soft_thread)
{
  soft_thread->hard_thread = hard_thread;
  signed int tmp_post$1 = hard_thread->instance->next_soft_thread_id;
  hard_thread->instance->next_soft_thread_id = hard_thread->instance->next_soft_thread_id + 1;
  soft_thread->id = tmp_post$1;
  soft_thread->method_specific.soft_dfs.dfs_max_depth = 0;
  soft_thread->by_depth_tests_order.num = 1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct anonymous$21) /*24ul*/  * (unsigned long int)1);
  soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous$21 *)return_value_malloc$2;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->max_depth = 0x7fffffff;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.num_groups = 0;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.groups = (struct anonymous$20 *)(void *)0;
  soft_thread->method_specific.soft_dfs.soft_dfs_info = (struct anonymous$50 *)(void *)0;
  soft_thread->method_specific.soft_dfs.depth = 0;
  soft_thread->method_specific.soft_dfs.tests_by_depth_array.num_units = 0;
  soft_thread->method_specific.soft_dfs.tests_by_depth_array.by_depth_units = (struct anonymous$52 *)(void *)0;
  soft_thread->method_specific.soft_dfs.rand_seed = 24;
  soft_thread->method_specific.befs.tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous$6 *, struct anonymous$12 *))(void *)0;
  soft_thread->method = 1;
  soft_thread->super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_DFS;
  soft_thread->method_specific.befs.befs_positions_by_rank = (char *)(void *)0;
  memcpy((void *)soft_thread->method_specific.befs.meth.befs.weighting.befs_weights, (const void *)fc_solve_default_befs_weights, sizeof(const double [6l]) /*48ul*/ );
  soft_thread->method_specific.befs.meth.befs.pqueue.Elements = (struct anonymous$19 *)(void *)0;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item = (struct fcs_states_linked_list_item_struct *)(void *)0;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue = soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item;
  soft_thread->num_checked_states_step = 50;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order=tests_order_dup(&soft_thread->hard_thread->instance->instance_tests_order);
  fc_solve_reset_soft_thread(soft_thread);
  soft_thread->name = (char *)(void *)0;
  soft_thread->enable_pruning = (_Bool)0;
}

// init_stacks_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 189
static inline void init_stacks_map(_Bool * const stacks_map, const signed int stack_idx, const signed int ds)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    stacks_map[(signed long int)i] = (_Bool)0;
  stacks_map[(signed long int)ds] = (_Bool)1;
  stacks_map[(signed long int)stack_idx] = stacks_map[(signed long int)ds];
}

// init_stats
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 775
static inline void init_stats(struct anonymous$44 * const s)
{
  s->num_states_in_collection = (signed long int)0;
  s->num_checked_states = s->num_states_in_collection;
}

// is_whitespace
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 110
static inline _Bool is_whitespace(char c)
{
  return (signed int)c == 32 || (signed int)c == 9 || (signed int)c == 10 || (signed int)c == 13;
}

// iter_handler_wrapper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1882
static void iter_handler_wrapper(void *api_instance, signed long int iter_num, signed int depth, void *lp_instance, struct anonymous$6 *ptr_state, signed long int parent_iter_num)
{
  struct anonymous$13 state_raw;
  struct anonymous * const user = (struct anonymous *)api_instance;
  state_raw.key = ptr_state->key;
  state_raw.val = ptr_state->val;
  fc_solve_init_locs(&state_raw.locs);
  if(!(user->long_iter_handler == ((void (*)(void *, signed long int, signed int, void *, signed long int, void *))NULL)))
    user->long_iter_handler(api_instance, iter_num, depth, (void *)&state_raw, parent_iter_num, user->iter_handler_context);

  else
    user->iter_handler(api_instance, (signed int)iter_num, depth, (void *)&state_raw, (signed int)parent_iter_num, user->iter_handler_context);
}

// kv_calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 84
static inline signed int kv_calc_depth(struct anonymous$6 *ptr_state)
{
  signed int return_value_calc_depth$1;
  return_value_calc_depth$1=calc_depth((struct fcs_state_keyval_pair_struct *)ptr_state->key);
  return return_value_calc_depth$1;
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 361
signed int main(signed int argc, char **argv)
{
  signed int arg = 1;
  next_board_num_lock = initial_mutex_constant;
  total_num_iters_lock = initial_mutex_constant;
  if(!(argc >= 4))
  {
    fprintf(stderr, "Not Enough Arguments!\n");
    print_help();
    exit(-1);
  }

  signed int tmp_post$1 = arg;
  arg = arg + 1;
  next_board_num=atoi(argv[(signed long int)tmp_post$1]);
  signed int end_board;
  signed int tmp_post$2 = arg;
  arg = arg + 1;
  end_board=atoi(argv[(signed long int)tmp_post$2]);
  signed int stop_at;
  signed int tmp_post$3 = arg;
  arg = arg + 1;
  stop_at=atoi(argv[(signed long int)tmp_post$3]);
  if(!(stop_at >= 1))
  {
    fprintf(stderr, "print_step (the third argument) must be greater than 0.\n");
    print_help();
    exit(-1);
  }

  signed int num_workers = 3;
  signed int board_num_step = 1;
  signed int update_total_num_iters_threshold = 1000000;
  signed int total_iterations_limit_per_board = -1;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  for( ; !(arg >= argc); arg = arg + 1)
  {
    signed int return_value_strcmp$8;
    return_value_strcmp$8=strcmp(argv[(signed long int)arg], "--total-iterations-limit");
    if(return_value_strcmp$8 == 0)
    {
      arg = arg + 1;
      if(arg == argc)
      {
        fprintf(stderr, "--total-iterations-limit came without an argument!\n");
        print_help();
        exit(-1);
      }

      signed long int return_value_atol$4;
      return_value_atol$4=atol(argv[(signed long int)arg]);
      total_iterations_limit_per_board = (signed int)return_value_atol$4;
    }

    else
    {
      return_value_strcmp$7=strcmp(argv[(signed long int)arg], "--num-workers");
      if(return_value_strcmp$7 == 0)
      {
        arg = arg + 1;
        if(arg == argc)
        {
          fprintf(stderr, "--num-workers came without an argument!\n");
          print_help();
          exit(-1);
        }

        num_workers=atoi(argv[(signed long int)arg]);
      }

      else
      {
        return_value_strcmp$6=strcmp(argv[(signed long int)arg], "--worker-step");
        if(return_value_strcmp$6 == 0)
        {
          arg = arg + 1;
          if(arg == argc)
          {
            fprintf(stderr, "--worker-step came without an argument!\n");
            print_help();
            exit(-1);
          }

          board_num_step=atoi(argv[(signed long int)arg]);
        }

        else
        {
          return_value_strcmp$5=strcmp(argv[(signed long int)arg], "--iters-update-on");
          if(return_value_strcmp$5 == 0)
          {
            arg = arg + 1;
            if(arg == argc)
            {
              fprintf(stderr, "--iters-update-on came without an argument!\n");
              print_help();
              exit(-1);
            }

            update_total_num_iters_threshold=atoi(argv[(signed long int)arg]);
          }

          else
            break;
        }
      }
    }
  }
  struct anonymous$30 mytime;
  gettimeofday(&mytime.tv, &mytime.tz);
  printf("Started at %li.%.6li\n", mytime.tv.tv_sec, mytime.tv.tv_usec);
  fflush(stdout);
  struct anonymous$22 context = { .argc=argc, .argv=argv, .arg=arg, .stop_at=stop_at, .end_board=end_board,
    .board_num_step=board_num_step, .update_total_num_iters_threshold=update_total_num_iters_threshold,
    .total_iterations_limit_per_board=(signed long int)total_iterations_limit_per_board };
  unsigned long int *workers;
  void *return_value_malloc$9;
  return_value_malloc$9=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)num_workers);
  workers = (unsigned long int *)return_value_malloc$9;
  signed int main$$1$$5$$idx = 0;
  for( ; !(main$$1$$5$$idx >= num_workers); main$$1$$5$$idx = main$$1$$5$$idx + 1)
  {
    signed int check;
    check=pthread_create(&workers[(signed long int)main$$1$$5$$idx], (const union pthread_attr_t *)(void *)0, worker_thread, (void *)&context);
    if(!(check == 0))
    {
      fprintf(stderr, "Worker Thread No. %d Initialization failed with error %d!\n", main$$1$$5$$idx, check);
      exit(-1);
    }

  }
  signed int idx = 0;
  for( ; !(idx >= num_workers); idx = idx + 1)
    pthread_join(workers[(signed long int)idx], (void **)(void *)0);
  gettimeofday(&mytime.tv, &mytime.tz);
  printf("Finished at %li.%.6li (total_num_iters=%lli)\n", mytime.tv.tv_sec, mytime.tv.tv_usec, total_num_iters);
  free((void *)workers);
  return 0;
}

// mark_as_dead_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 589
static inline void mark_as_dead_end(const _Bool scans_synergy, struct fcs_state_keyval_pair_struct * const ptr_state_input)
{
  if(!(scans_synergy == (_Bool)0))
  {
    struct fcs_state_keyval_pair_struct *temp_state = ptr_state_input;
    temp_state->$anon0.$anon0.info.visited = temp_state->$anon0.$anon0.info.visited | (unsigned char)4;
    temp_state = temp_state->$anon0.$anon0.info.parent;
    if(!(temp_state == ((struct fcs_state_keyval_pair_struct *)NULL)))
    {
      temp_state->$anon0.$anon0.info.num_active_children = temp_state->$anon0.$anon0.info.num_active_children - 1;
      for( ; (signed int)temp_state->$anon0.$anon0.info.num_active_children == 0; temp_state->$anon0.$anon0.info.num_active_children = temp_state->$anon0.$anon0.info.num_active_children - 1)
      {
        if((8 & (signed int)temp_state->$anon0.$anon0.info.visited) == 0)
          break;

        temp_state->$anon0.$anon0.info.visited = temp_state->$anon0.$anon0.info.visited | (unsigned char)4;
        temp_state = temp_state->$anon0.$anon0.info.parent;
        if(temp_state == ((struct fcs_state_keyval_pair_struct *)NULL))
          break;

      }
    }

  }

}

// memdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup(void *src, unsigned long int mysize)
{
  void *dest;
  dest=malloc(mysize);
  if(dest == NULL)
    return (void *)0;

  else
  {
    memcpy(dest, src, mysize);
    return dest;
  }
}

// memdup$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup$link1(void *src$link1, unsigned long int mysize$link1)
{
  void *dest$link1;
  dest$link1=malloc(mysize$link1);
  if(dest$link1 == NULL)
    return (void *)0;

  else
  {
    memcpy(dest$link1, src$link1, mysize$link1);
    return dest$link1;
  }
}

// meta_request_new_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.c line 57
static inline char * meta_request_new_buffer(struct anonymous$10 *meta_allocator)
{
  if(!(meta_allocator->recycle_bin == ((char *)NULL)))
  {
    char *ret = meta_allocator->recycle_bin;
    meta_allocator->recycle_bin = *((char **)ret);
    return ret;
  }

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)(64 * 1024 - (256 + 128)));
    return (char *)return_value_malloc$1;
  }
}

// microsoft_rand__game_num_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 59
static inline unsigned int microsoft_rand__game_num_rand(signed long long int *seedx_ptr, signed long long int gnGameNumber)
{
  if(!(gnGameNumber >= 0x100000000LL))
  {
    unsigned int ret;
    ret=microsoft_rand_rand(seedx_ptr);
    if(!(gnGameNumber >= 2147483648l))
      return ret;

    else
      return ret | (unsigned int)0x8000;
  }

  else
  {
    unsigned int return_value_microsoft_rand_randp$1;
    return_value_microsoft_rand_randp$1=microsoft_rand_randp(seedx_ptr);
    return return_value_microsoft_rand_randp$1 + (unsigned int)1;
  }
}

// microsoft_rand_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 47
static inline unsigned int microsoft_rand_rand(signed long long int *my_rand)
{
  *my_rand = *my_rand * (signed long int)214013 + (signed long int)2531011;
  return (unsigned int)(*my_rand >> 16 & (signed long int)0x7fff);
}

// microsoft_rand_randp
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 53
static inline unsigned int microsoft_rand_randp(signed long long int *my_rand)
{
  *my_rand = *my_rand * (signed long int)214013 + (signed long int)2531011;
  return (unsigned int)(*my_rand >> 16 & (signed long int)0xffff);
}

// moves_processed_add_new_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 113
static inline void moves_processed_add_new_move(struct anonymous$40 * const moves, const struct anonymous$53 new_move)
{
  moves->num_moves = moves->num_moves + 1;
  if((32 & moves->num_moves) == 0)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)moves->moves, sizeof(struct anonymous$53) /*5ul*/  * (unsigned long int)(moves->num_moves + 32));
    moves->moves = (struct anonymous$53 *)return_value_realloc$1;
  }

  moves->moves[(signed long int)(moves->num_moves - 1)] = new_move;
}

// my_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 62
static void my_iter_handler(void *user_instance, signed long int iter_num, signed int depth, void *ptr_state, signed long int parent_iter_num, void *lp_context)
{
  fprintf(stdout, "Iteration: %li\n", (signed long int)iter_num);
  fprintf(stdout, "Depth: %i\n", depth);
  const struct anonymous$24 * const context = (const struct anonymous$24 *)lp_context;
  if(!(context->display_parent_iter_num == (_Bool)0))
    fprintf(stdout, "Parent Iteration: %li\n", (signed long int)parent_iter_num);

  fprintf(stdout, "\n");
  if(!(context->debug_iter_state_output == (_Bool)0))
  {
    char *state_string;
    state_string=freecell_solver_user_iter_state_as_string(user_instance, ptr_state, (signed int)context->parseable_output, (signed int)context->canonized_order_output, (signed int)context->display_10_as_t);
    printf("%s\n---------------\n\n\n", state_string);
    free((void *)state_string);
  }

}

// normalize_iters_quota
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 936
static inline signed int normalize_iters_quota(signed int i)
{
  return i > 0 ? i : 0;
}

// nullify_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 50
static inline void nullify_newline(char * const line)
{
  char *s;
  s=strchr(line, 10);
  if(!(s == ((char *)NULL)))
    *s = (char)0;

}

// on_state_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 291
static inline void on_state_new(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread, struct fcs_state_extra_info_struct * const new_state_info)
{
  struct fcs_state_keyval_pair_struct * const parent_state = new_state_info->parent;
  if(!(parent_state == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    parent_state->$anon0.$anon0.info.num_active_children = parent_state->$anon0.$anon0.info.num_active_children + 1;
    new_state_info->moves_to_parent=fc_solve_move_stack_compact_allocate(hard_thread, new_state_info->moves_to_parent);
  }

  instance->active_num_states_in_collection = instance->active_num_states_in_collection + 1l;
  instance->num_states_in_collection = instance->num_states_in_collection + 1l;
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// perl_hash_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 53
static inline unsigned long int perl_hash_function(const unsigned char *s_ptr, const unsigned long int length)
{
  unsigned long int hash_value_int = (unsigned long int)0;
  const unsigned char * const s_end = s_ptr + (signed long int)length;
  const unsigned char *tmp_post$1;
  for( ; !(s_ptr >= s_end); hash_value_int = hash_value_int + (hash_value_int << 5) + (unsigned long int)*tmp_post$1)
  {
    tmp_post$1 = s_ptr;
    s_ptr = s_ptr + 1l;
  }
  hash_value_int = hash_value_int + (hash_value_int >> 5);
  return hash_value_int;
}

// populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 491
static inline void populate_seq_points(char * const dest_col, const signed int dc, struct anonymous$45 * const seqs)
{
  seqs->num_separate_false_seqs = 0;
  generic_populate_seq_points(dest_col, dc, seqs, (const signed int)dest_col[(signed long int)0]);
}

// print_help
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 169
static void print_help(void)
{
  printf("\n%s", (const void *)"freecell-solver-range-parallel-solve start end print_step\n   [--binary-output-to filename] [--total-iterations-limit limit]\n   [fc-solve Arguments...]\n\nSolves a sequence of boards from the Microsoft/Freecell Pro Deals\n\nstart - the first board in the sequence\nend - the last board in the sequence (inclusive)\nprint_step - at which division to print a status line\n\n--total-iterations-limit  limit\n     Limits each board for up to 'limit' iterations.\n");
}

// push_args_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 82
static inline void push_args_last_arg(struct anonymous$37 *manager)
{
  const signed int length = (const signed int)(manager->last_arg_ptr - manager->last_arg);
  char *new_arg;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(length + 1));
  new_arg = (char *)return_value_malloc$1;
  strncpy(new_arg, manager->last_arg, (unsigned long int)length);
  new_arg[(signed long int)length] = (char)0;
  signed int tmp_post$2 = manager->argc;
  manager->argc = manager->argc + 1;
  manager->argv[(signed long int)tmp_post$2] = new_arg;
  if((32 & manager->argc) == 0)
  {
    void *return_value_realloc$3;
    return_value_realloc$3=realloc((void *)manager->argv, sizeof(char *) /*8ul*/  * (unsigned long int)(manager->argc + 32));
    manager->argv = (char **)return_value_realloc$3;
  }

  manager->last_arg_ptr = manager->last_arg;
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// read_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 60
static inline signed int read_preset(const char *preset_name, struct anonymous$37 **args_man, char **opened_files_dir_to_assign, const char *user_preset_dir)
{
  signed int ret_code = 1;
  char *home_dir_presetrc = (char *)(void *)0;
  char *env_var_presetrc = (char *)(void *)0;
  const char *global_presetrc = (const char *)(void *)0;
  const char **presetrc_pathes[5l];
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  char *opened_files_dir = (char *)(void *)0;
  signed int idx = 0;
  signed int tmp_post$1 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post$1] = (const char **)(void *)&env_var_presetrc;
  signed int tmp_post$2 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post$2] = (const char **)(void *)&home_dir_presetrc;
  signed int tmp_post$3 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post$3] = (const char **)&global_presetrc;
  signed int tmp_post$4 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post$4] = &user_preset_dir;
  signed int tmp_post$5 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post$5] = (const char **)(void *)0;
  char *home_dir;
  home_dir=getenv("HOME");
  if(!(home_dir == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(home_dir);
    void *return_value_malloc$7;
    return_value_malloc$7=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$6 + (unsigned long int)50));
    home_dir_presetrc = (char *)return_value_malloc$7;
    sprintf(home_dir_presetrc, "%s/.freecell-solver/presetrc", home_dir);
  }

  env_var_presetrc=getenv("FREECELL_SOLVER_PRESETRC");
  global_presetrc = "/usr/share/freecell-solver/presetrc";
  const char *path;
  _Bool read_next_preset = (_Bool)0;
  signed int path_idx = 0;
  signed int return_value_strncmp$11;
  signed int return_value_strncmp$10;
  for( ; !(presetrc_pathes[(signed long int)path_idx] == ((const char **)NULL)); path_idx = path_idx + 1)
  {
    path = *presetrc_pathes[(signed long int)path_idx];
    if(!(path == ((const char *)NULL)))
    {
      f=fopen(path, "rt");
      if(!(f == ((struct _IO_FILE *)NULL)))
      {
        while((_Bool)1)
        {
          char line[8192l];
          char *return_value_fgets$8;
          return_value_fgets$8=fgets(line, (signed int)sizeof(char [8192l]) /*8192ul*/ , f);
          if(return_value_fgets$8 == ((char *)NULL))
            break;

          signed int return_value_strncmp$12;
          return_value_strncmp$12=strncmp(line, "dir=", (unsigned long int)4);
          if(return_value_strncmp$12 == 0)
          {
            nullify_newline(line);
            if(!(opened_files_dir == ((char *)NULL)))
              free((void *)opened_files_dir);

            opened_files_dir=strdup(line + (signed long int)4);
          }

          else
          {
            return_value_strncmp$11=strncmp(line, "name=", (unsigned long int)5);
            if(return_value_strncmp$11 == 0)
            {
              nullify_newline(line);
              signed int return_value_strcmp$9;
              return_value_strcmp$9=strcmp(line + (signed long int)5, preset_name);
              if(return_value_strcmp$9 == 0)
                read_next_preset = (_Bool)1;

            }

            else
            {
              return_value_strncmp$10=strncmp(line, "command=", (unsigned long int)8);
              if(return_value_strncmp$10 == 0)
              {
                if(!(read_next_preset == (_Bool)0))
                {
                  *args_man=fc_solve_args_man_alloc();
                  fc_solve_args_man_chop(*args_man, line + (signed long int)8);
                  ret_code = 0;
                  goto have_preset;
                }

              }

            }
          }
        }
        fclose(f);
        f = (struct _IO_FILE *)(void *)0;
      }

    }

  }

have_preset:
  ;
  if(!(f == ((struct _IO_FILE *)NULL)))
    fclose(f);

  if(!(home_dir_presetrc == ((char *)NULL)))
    free((void *)home_dir_presetrc);

  if(ret_code == 0)
    *opened_files_dir_to_assign = opened_files_dir;

  else
    if(!(opened_files_dir == ((char *)NULL)))
      free((void *)opened_files_dir);

  return ret_code;
}

// recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 782
static void recycle_instance(struct anonymous * const user, const signed int i)
{
  struct anonymous$1 * const instance_item = &user->instances_list[(signed long int)i];
  signed int flare_idx = 0;
  for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
  {
    struct anonymous$2 *flare = &instance_item->flares[(signed long int)flare_idx];
    if(!(flare->fc_pro_moves.moves == ((struct anonymous$53 *)NULL)))
      fc_solve_moves_processed_free(&flare->fc_pro_moves);

    if(!(flare->ret_code == 9))
    {
      if(flare->instance_is_ready == (_Bool)0)
      {
        fc_solve_recycle_instance(flare->obj);
        flare->instance_is_ready = (_Bool)1;
      }

      user->init_num_checked_states.num_checked_states = (signed long int)0;
      user->init_num_checked_states.num_states_in_collection = (signed long int)0;
      flare->ret_code = 9;
    }

    if(!(flare->moves_seq.moves == ((struct anonymous$4 *)NULL)))
    {
      free((void *)flare->moves_seq.moves);
      flare->moves_seq.moves = (struct anonymous$4 *)(void *)0;
      flare->moves_seq.num_moves = 0;
      flare->next_move = 0;
    }

    init_stats(&flare->obj_stats);
  }
  instance_item->current_plan_item_idx = 0;
  instance_item->minimal_solution_flare_idx = -1;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// run_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1217
static inline signed int run_hard_thread(struct fc_solve_hard_thread_struct *hard_thread)
{
  struct fc_solve_soft_thread_struct *soft_thread;
  signed long int num_checked_states_started_at;
  signed int ret;
  struct fc_solve_instance_struct *instance = hard_thread->instance;
  signed int *st_idx_ptr = &hard_thread->st_idx;
  ret = 5;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  while(!(hard_thread->num_soft_threads_finished >= hard_thread->num_soft_threads))
  {
    soft_thread = &hard_thread->soft_threads[(signed long int)*st_idx_ptr];
    if(!((4 & (signed int)soft_thread->runtime_flags) == 0))
    {
      if(!(hard_thread->prelude == ((struct anonymous$42 *)NULL)))
        tmp_if_expr$1 = (signed long int)hard_thread->prelude_idx < hard_thread->prelude_num_items ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        *st_idx_ptr = (hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->scan_idx;
        hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->quota;
        hard_thread->prelude_idx = hard_thread->prelude_idx + 1;
      }

      else
      {
        *st_idx_ptr = *st_idx_ptr + 1;
        if(*st_idx_ptr == hard_thread->num_soft_threads)
          *st_idx_ptr = 0;

        hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->soft_threads + (signed long int)*st_idx_ptr)->num_checked_states_step;
      }
    }

    else
    {
      num_checked_states_started_at = hard_thread->num_checked_states;
      hard_thread->max_num_checked_states = hard_thread->num_checked_states + hard_thread->num_checked_states_left_for_soft_thread;
      if((1 & (signed int)soft_thread->runtime_flags) == 0)
      {
        fc_solve_soft_thread_init_soft_dfs(soft_thread);
        fc_solve_soft_thread_init_befs_or_bfs(soft_thread);
        soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)1;
      }

      switch((signed int)soft_thread->super_method_type)
      {
        case FCS_SUPER_METHOD_DFS:
        {
          ret=fc_solve_soft_dfs_do_solve(soft_thread);
          break;
        }
        case FCS_SUPER_METHOD_BEFS_BRFS:
        {
          ret=fc_solve_befs_or_bfs_do_solve(soft_thread);
          break;
        }
        default:
          ret = 1;
      }
      hard_thread->num_checked_states_left_for_soft_thread = hard_thread->num_checked_states_left_for_soft_thread - (hard_thread->num_checked_states - num_checked_states_started_at);
      if(!(hard_thread->num_checked_states_left_for_soft_thread >= 1l))
      {
        if(!(hard_thread->prelude == ((struct anonymous$42 *)NULL)))
          tmp_if_expr$2 = (signed long int)hard_thread->prelude_idx < hard_thread->prelude_num_items ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          *st_idx_ptr = (hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->scan_idx;
          hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->quota;
          hard_thread->prelude_idx = hard_thread->prelude_idx + 1;
        }

        else
        {
          *st_idx_ptr = *st_idx_ptr + 1;
          if(*st_idx_ptr == hard_thread->num_soft_threads)
            *st_idx_ptr = 0;

          hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->soft_threads + (signed long int)*st_idx_ptr)->num_checked_states_step;
        }
      }

      if(ret == 1)
      {
        soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)4;
        hard_thread->num_soft_threads_finished = hard_thread->num_soft_threads_finished + 1;
        if(hard_thread->num_soft_threads_finished == hard_thread->num_soft_threads)
          instance->num_hard_threads_finished = instance->num_hard_threads_finished + 1;

        if(!((2 & (signed int)soft_thread->runtime_flags) == 0))
          tmp_if_expr$3 = !(((signed int)instance->runtime_flags & 64) != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          return 1;

        else
          ret = 5;
      }

      if(ret == 0)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        if(ret == 5)
        {
          if(instance->num_checked_states >= instance->effective_max_num_checked_states)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        return ret;

    }
  }
  return ret;
}

// set_any_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1931
static void set_any_iter_handler(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->long_iter_handler = long_iter_handler;
  user->iter_handler = iter_handler;
  if(!(iter_handler == ((void (*)(void *, signed int, signed int, void *, signed int, void *))NULL)) || !(long_iter_handler == ((void (*)(void *, signed long int, signed int, void *, signed long int, void *))NULL)))
  {
    user->iter_handler_context = iter_handler_context;
    set_debug_iter_output_func_to_val(user, iter_handler_wrapper);
  }

  else
    set_debug_iter_output_func_to_val(user, (void (*)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int))(void *)0);
}

// set_debug_iter_output_func_to_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1920
static void set_debug_iter_output_func_to_val(struct anonymous * const user, void (* const value)(void *, signed long int, signed int, void *, struct anonymous$6 *, signed long int))
{
  signed int user_inst_idx = 0;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous$1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
    signed int flare_idx = 0;
    for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
    {
      struct anonymous$2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      flare->obj->debug_iter_output_func = value;
    }
  }
}

// soft_thread_clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 119
static inline void soft_thread_clean_soft_dfs(struct fc_solve_soft_thread_struct * const soft_thread)
{
  struct anonymous$50 * const soft_dfs_info = soft_thread->method_specific.soft_dfs.soft_dfs_info;
  if(!(soft_dfs_info == ((struct anonymous$50 *)NULL)))
  {
    const struct anonymous$50 *info_ptr = soft_dfs_info;
    const struct anonymous$50 * const max_info_ptr = info_ptr + (signed long int)soft_thread->method_specific.soft_dfs.depth;
    const struct anonymous$50 * const dfs_max_info_ptr = info_ptr + (signed long int)soft_thread->method_specific.soft_dfs.dfs_max_depth;
    for( ; !(info_ptr >= max_info_ptr); info_ptr = info_ptr + 1l)
    {
      free((void *)info_ptr->derived_states_list.states);
      free((void *)info_ptr->derived_states_random_indexes);
      free((void *)info_ptr->positions_by_rank);
    }
    for( ; !(info_ptr >= dfs_max_info_ptr); info_ptr = info_ptr + 1l)
      if(!(info_ptr->derived_states_list.states == ((struct anonymous$38 *)NULL)))
      {
        free((void *)info_ptr->derived_states_list.states);
        free((void *)info_ptr->derived_states_random_indexes);
      }

    free((void *)soft_dfs_info);
    soft_thread->method_specific.soft_dfs.soft_dfs_info = (struct anonymous$50 *)(void *)0;
    soft_thread->method_specific.soft_dfs.dfs_max_depth = 0;
  }

}

// sort_derived_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 116
static inline void sort_derived_states(struct anonymous$12 *derived_states_list, signed int initial_derived_states_num_states)
{
  struct anonymous$38 *start = derived_states_list->states + (signed long int)initial_derived_states_num_states;
  struct anonymous$38 *limit = derived_states_list->states + (signed long int)derived_states_list->num_states;
  struct anonymous$38 *b = start + (signed long int)1;
  _Bool tmp_if_expr$1;
  for( ; !(b >= limit); b = b + 1l)
  {
    struct anonymous$38 *c = b;
    do
    {
      if(!(start >= c))
        tmp_if_expr$1 = (c + (signed long int)0)->context.i < (c + (signed long int)-1)->context.i ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      struct anonymous$38 temp = c[(signed long int)-1];
      c[(signed long int)-1] = c[(signed long int)0];
      c[(signed long int)0] = temp;
      c = c - 1l;
    }
    while((_Bool)1);
  }
}

// sort_ds_dcs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 1008
static inline void sort_ds_dcs(struct anonymous$46 *ds_dcs, const signed int len)
{
  struct anonymous$46 *start = ds_dcs;
  struct anonymous$46 *limit = start + (signed long int)len;
  struct anonymous$46 *b = start + (signed long int)1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  for( ; !(b >= limit); b = b + 1l)
  {
    struct anonymous$46 *c = b;
    do
    {
      if(!(start >= c))
      {
        if(!(c->ds >= (c + -1l)->ds))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          if(c->ds == (c + -1l)->ds)
            tmp_if_expr$1 = (c + (signed long int)0)->dc > (c + (signed long int)-1)->dc ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      struct anonymous$46 temp = c[(signed long int)-1];
      c[(signed long int)-1] = c[(signed long int)0];
      c[(signed long int)0] = temp;
      c = c - 1l;
    }
    while((_Bool)1);
  }
}

// string_starts_with
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with(const char * const str, const char * const prefix, const char * const end)
{
  const signed int check_len = (const signed int)(end - str);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(prefix);
  _Bool tmp_if_expr$3;
  signed int return_value_strncmp$2;
  if((unsigned long int)check_len == return_value_strlen$1)
  {
    return_value_strncmp$2=strncmp(str, prefix, (unsigned long int)check_len);
    tmp_if_expr$3 = !(return_value_strncmp$2 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return tmp_if_expr$3;
}

// string_starts_with$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with$link1(const char * const str$link1, const char * const prefix$link1, const char * const end$link1)
{
  const signed int check_len$link1 = (const signed int)(end$link1 - str$link1);
  unsigned long int return_value_strlen$1$link1;
  return_value_strlen$1$link1=strlen(prefix$link1);
  _Bool tmp_if_expr$3$link1;
  signed int return_value_strncmp$2$link1;
  if((unsigned long int)check_len$link1 == return_value_strlen$1$link1)
  {
    return_value_strncmp$2$link1=strncmp(str$link1, prefix$link1, (unsigned long int)check_len$link1);
    tmp_if_expr$3$link1 = !(return_value_strncmp$2$link1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1 = (_Bool)0;
  return tmp_if_expr$3$link1;
}

// tests_order_dup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous$9 tests_order_dup(struct anonymous$9 *orig)
{
  struct anonymous$9 ret;
  ret.num_groups = orig->num_groups;
  void *return_value_memdup$1;
  return_value_memdup$1=memdup((void *)orig->groups, sizeof(struct anonymous$20) /*232ul*/  * (unsigned long int)((ret.num_groups & ~(16 - 1)) + 16));
  ret.groups = (struct anonymous$20 *)return_value_memdup$1;
  signed int i = 0;
  for( ; !(i >= ret.num_groups); i = i + 1)
  {
    void *return_value_memdup$2;
    return_value_memdup$2=memdup((void *)(ret.groups + (signed long int)i)->tests, sizeof(signed int) /*4ul*/  * (unsigned long int)(((ret.groups + (signed long int)i)->num & ~(16 - 1)) + 16));
    (ret.groups + (signed long int)i)->tests = (signed int *)return_value_memdup$2;
  }
  return ret;
}

// tests_order_dup$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous$9 tests_order_dup$link1(struct anonymous$9 *orig$link1)
{
  struct anonymous$9 ret$link1;
  ret$link1.num_groups = orig$link1->num_groups;
  void *return_value_memdup$1$link1;
  return_value_memdup$1$link1=memdup$link1((void *)orig$link1->groups, sizeof(struct anonymous$20) /*232ul*/  * (unsigned long int)((ret$link1.num_groups & ~(16 - 1)) + 16));
  ret$link1.groups = (struct anonymous$20 *)return_value_memdup$1$link1;
  signed int i$link1 = 0;
  for( ; !(i$link1 >= ret$link1.num_groups); i$link1 = i$link1 + 1)
  {
    void *return_value_memdup$2$link1;
    return_value_memdup$2$link1=memdup$link1((void *)(ret$link1.groups + (signed long int)i$link1)->tests, sizeof(signed int) /*4ul*/  * (unsigned long int)(((ret$link1.groups + (signed long int)i$link1)->num & ~(16 - 1)) + 16));
    (ret$link1.groups + (signed long int)i$link1)->tests = (signed int *)return_value_memdup$2$link1;
  }
  return ret$link1;
}

// update_col_cards_under_sequences
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences(const signed int sequences_are_built_by, const char * const col, signed int d)
{
  char this_card = col[(signed long int)(d + 1)];
  char prev_card = col[(signed long int)((d - 1) + 1)];
  _Bool tmp_if_expr$2;
  _Bool tmp_statement_expression$1;
  do
  {
    if(d >= 1)
    {
      prev_card = col[(signed long int)((d - 1) + 1)];
      tmp_statement_expression$1 = ((signed int)this_card >> 2) + 1 == (signed int)prev_card >> 2 && (sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? (signed int)(((signed int)this_card & 0x03) == ((signed int)prev_card & 0x03)) : (signed int)(((signed int)this_card & 0x03 & 0x1) != ((signed int)prev_card & 0x03 & 0x1)))) != 0;
      tmp_if_expr$2 = tmp_statement_expression$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    d = d - 1;
    this_card = prev_card;
  }
  while((_Bool)1);
  return d;
}

// update_col_cards_under_sequences$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences$link1(const signed int sequences_are_built_by$link1, const char * const col$link1, signed int d$link1)
{
  char this_card$link1 = col$link1[(signed long int)(d$link1 + 1)];
  char prev_card$link1 = col$link1[(signed long int)((d$link1 - 1) + 1)];
  _Bool tmp_if_expr$2$link1;
  _Bool tmp_statement_expression$1$link1;
  do
  {
    if(d$link1 >= 1)
    {
      prev_card$link1 = col$link1[(signed long int)((d$link1 - 1) + 1)];
      tmp_statement_expression$1$link1 = ((signed int)this_card$link1 >> 2) + 1 == (signed int)prev_card$link1 >> 2 && (sequences_are_built_by$link1 == 2 ? 1 : (sequences_are_built_by$link1 == 1 ? (signed int)(((signed int)this_card$link1 & 0x03) == ((signed int)prev_card$link1 & 0x03)) : (signed int)(((signed int)this_card$link1 & 0x03 & 0x1) != ((signed int)prev_card$link1 & 0x03 & 0x1)))) != 0;
      tmp_if_expr$2$link1 = tmp_statement_expression$1$link1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2$link1 = (_Bool)0;
    if(!tmp_if_expr$2$link1)
      break;

    d$link1 = d$link1 - 1;
    this_card$link1 = prev_card$link1;
  }
  while((_Bool)1);
  return d$link1;
}

// user_compile_all_flares_plans
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 495
static signed int user_compile_all_flares_plans(struct anonymous * const user, signed int * const instance_list_index, char ** const error_string)
{
  signed int user_inst_idx = 0;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  _Bool return_value_string_starts_with$10;
  _Bool tmp_if_expr$6;
  _Bool return_value_string_starts_with$9;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous$1 *instance_item;
    *instance_list_index = user_inst_idx;
    instance_item = &user->instances_list[(signed long int)user_inst_idx];
    if(instance_item->flares_plan_compiled == (_Bool)0)
    {
      if(instance_item->flares_plan_string == ((char *)NULL))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = !(instance_item->flares_plan_string[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        if(!(instance_item->plan == ((struct anonymous$0 *)NULL)))
          free((void *)instance_item->plan);

        instance_item->num_plan_items = 2;
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct anonymous$0) /*12ul*/  * (unsigned long int)instance_item->num_plan_items);
        instance_item->plan = (struct anonymous$0 *)return_value_malloc$1;
        (instance_item->plan + (signed long int)0)->type = FLARES_PLAN_RUN_INDEFINITELY;
        (instance_item->plan + (signed long int)0)->flare_idx = 0;
        (instance_item->plan + (signed long int)0)->count_iters = -1;
        (instance_item->plan + (signed long int)1)->type = FLARES_PLAN_CHECKPOINT;
        (instance_item->plan + (signed long int)1)->flare_idx = -1;
        (instance_item->plan + (signed long int)1)->count_iters = -1;
        instance_item->flares_plan_compiled = (_Bool)1;
        goto __CPROVER_DUMP_L35;
      }

      char *item_start;
      char *item_end;
      char *cmd_end;
      signed int last_item_type = -1;
      if(!(instance_item->plan == ((struct anonymous$0 *)NULL)))
      {
        free((void *)instance_item->plan);
        instance_item->plan = (struct anonymous$0 *)(void *)0;
        instance_item->num_plan_items = 0;
      }

      item_start = instance_item->flares_plan_string;
      do
      {
        cmd_end=strchr(item_start, 58);
        if(cmd_end == ((char *)NULL))
        {
          *error_string=strdup("Could not find a \":\" for a command.");
          *instance_list_index = user_inst_idx;
          return 1;
        }

        _Bool return_value_string_starts_with$11;
        return_value_string_starts_with$11=string_starts_with(item_start, "Run", cmd_end);
        if(!(return_value_string_starts_with$11 == (_Bool)0))
        {
          char *at_sign;
          char *after_at_sign;
          signed int count_iters;
          _Bool user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$found_flare;
          signed int user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$flare_idx;
          cmd_end = cmd_end + 1l;
          count_iters=atoi(cmd_end);
          at_sign = cmd_end;
          for( ; !(*at_sign == 0); at_sign = at_sign + 1l)
          {
            return_value___ctype_b_loc$3=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*at_sign]) == 0)
              break;

          }
          if(!((signed int)*at_sign == 64))
          {
            *error_string=strdup("Could not find a \"@\" directly after the digits after the 'Run:' command.");
            *instance_list_index = user_inst_idx;
            return 2;
          }

          after_at_sign = at_sign + (signed long int)1;
          item_end=strchr(after_at_sign, 44);
          if(item_end == ((char *)NULL))
          {
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(after_at_sign);
            item_end = after_at_sign + (signed long int)return_value_strlen$4;
          }

          user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$found_flare = (_Bool)0;
          user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$flare_idx = 0;
          for( ; !(user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$flare_idx >= instance_item->num_flares); user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$flare_idx = user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$flare_idx + 1)
          {
            struct anonymous$2 *flare = &instance_item->flares[(signed long int)user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$flare_idx];
            if(!(flare->name == ((char *)NULL)))
            {
              signed int return_value_strncmp$5;
              return_value_strncmp$5=strncmp(flare->name, after_at_sign, (unsigned long int)(item_end - after_at_sign));
              if(return_value_strncmp$5 == 0)
              {
                user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$found_flare = (_Bool)1;
                break;
              }

            }

          }
          if(user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$found_flare == (_Bool)0)
          {
            *error_string=strdup("Unknown flare name.");
            *instance_list_index = user_inst_idx;
            return 3;
          }

          last_item_type=add_count_iters_to_plan(instance_item, user_compile_all_flares_plans$$1$$1$$1$$3$$2$$2$$flare_idx, count_iters);
        }

        else
        {
          return_value_string_starts_with$10=string_starts_with(item_start, "CP", cmd_end);
          if(!(return_value_string_starts_with$10 == (_Bool)0))
          {
            item_end = cmd_end + (signed long int)1;
            if((signed int)*item_end == 44)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = !(*item_end != 0) ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr$6)
            {
              *error_string=strdup("Junk after CP (Checkpoint) command.");
              *instance_list_index = user_inst_idx;
              return 4;
            }

            last_item_type=add_checkpoint_to_plan(instance_item);
          }

          else
          {
            return_value_string_starts_with$9=string_starts_with(item_start, "RunIndef", cmd_end);
            if(!(return_value_string_starts_with$9 == (_Bool)0))
            {
              _Bool found_flare;
              signed int flare_idx;
              cmd_end = cmd_end + 1l;
              item_end=strchr(cmd_end, 44);
              if(!(item_end == ((char *)NULL)))
              {
                *error_string=strdup("Junk after last RunIndef command. Must be the final command.");
                *instance_list_index = user_inst_idx;
                return 6;
              }

              unsigned long int return_value_strlen$7;
              return_value_strlen$7=strlen(cmd_end);
              item_end = cmd_end + (signed long int)return_value_strlen$7;
              found_flare = (_Bool)0;
              flare_idx = 0;
              for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
              {
                struct anonymous$2 *user_compile_all_flares_plans$$1$$1$$1$$3$$2$$4$$2$$1$$flare = &instance_item->flares[(signed long int)flare_idx];
                if(!(user_compile_all_flares_plans$$1$$1$$1$$3$$2$$4$$2$$1$$flare->name == ((char *)NULL)))
                {
                  signed int return_value_strncmp$8;
                  return_value_strncmp$8=strncmp(user_compile_all_flares_plans$$1$$1$$1$$3$$2$$4$$2$$1$$flare->name, cmd_end, (unsigned long int)(item_end - cmd_end));
                  if(return_value_strncmp$8 == 0)
                  {
                    found_flare = (_Bool)1;
                    break;
                  }

                }

              }
              if(found_flare == (_Bool)0)
              {
                *error_string=strdup("Unknown flare name in RunIndef command.");
                *instance_list_index = user_inst_idx;
                return 3;
              }

              last_item_type=add_run_indef_to_plan(instance_item, flare_idx);
            }

            else
            {
              *error_string=strdup("Unknown command.");
              *instance_list_index = user_inst_idx;
              return 5;
            }
          }
        }
        item_start = item_end + (signed long int)1;
      }
      while(!(*item_end == 0));
      /* assertion last_item_type != -1 */
      assert(last_item_type != -1);
      if(!(last_item_type == FLARES_PLAN_CHECKPOINT))
        last_item_type=add_checkpoint_to_plan(instance_item);

      instance_item->flares_plan_compiled = (_Bool)1;
    }


  __CPROVER_DUMP_L35:
    ;
  }
  *instance_list_index = -1;
  *error_string = (char *)(void *)0;
  return 0;
}

// user_free_resources
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1377
static void user_free_resources(struct anonymous * const user)
{
  signed int user_inst_idx = 0;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous$1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
    signed int flare_idx = 0;
    for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
    {
      struct anonymous$2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      const signed int ret_code = flare->ret_code;
      if(!(ret_code == 8) && !(ret_code == 9))
      {
        if(flare->instance_is_ready == (_Bool)0)
          fc_solve_finish_instance(flare->obj);

      }

      fc_solve_free_instance(flare->obj);
      if(!(flare->name == ((char *)NULL)))
      {
        free((void *)flare->name);
        flare->name = (char *)(void *)0;
      }

      if(!(flare->fc_pro_moves.moves == ((struct anonymous$53 *)NULL)))
        fc_solve_moves_processed_free(&flare->fc_pro_moves);

      if(!(flare->moves_seq.moves == ((struct anonymous$4 *)NULL)))
      {
        free((void *)flare->moves_seq.moves);
        flare->moves_seq.moves = (struct anonymous$4 *)(void *)0;
        flare->moves_seq.num_moves = 0;
      }

    }
    free((void *)instance_item->flares);
    if(!(instance_item->flares_plan_string == ((char *)NULL)))
      free((void *)instance_item->flares_plan_string);

    if(!(instance_item->plan == ((struct anonymous$0 *)NULL)))
      free((void *)instance_item->plan);

  }
  free((void *)user->instances_list);
  if(!(user->state_string_copy == ((char *)NULL)))
  {
    free((void *)user->state_string_copy);
    user->state_string_copy = (char *)(void *)0;
  }

  if(!(user->error_string == ((char *)NULL)))
  {
    free((void *)user->error_string);
    user->error_string = (char *)(void *)0;
  }

  fc_solve_meta_compact_allocator_finish(&user->meta_alloc);
}

// user_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 212
static void user_initialize(struct anonymous * const user)
{
  const struct anonymous$36 *freecell_preset;
  fc_solve_get_preset_by_name("freecell", &freecell_preset);
  user->common_preset = *freecell_preset;
  fc_solve_meta_compact_allocator_init(&user->meta_alloc);
  user->instances_list = (struct anonymous$1 *)(void *)0;
  user->num_instances = 0;
  user->long_iter_handler = (void (*)(void *, signed long int, signed int, void *, signed long int, void *))(void *)0;
  user->iter_handler = (void (*)(void *, signed int, signed int, void *, signed int, void *))(void *)0;
  user->current_iterations_limit = (signed long int)-1;
  user->state_string_copy = (char *)(void *)0;
  user->iterations_board_started_at.num_checked_states = (signed long int)0;
  user->iterations_board_started_at.num_states_in_collection = (signed long int)0;
  user->all_instances_were_suspended = (_Bool)1;
  user->flares_choice = (enum FLARES_CHOICE_TYPE)FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN;
  user->flares_iters_factor = 1.0;
  user->error_string = (char *)(void *)0;
  user_next_instance(user);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2335
static signed int user_next_flare(struct anonymous *user)
{
  struct anonymous$1 *instance_item;
  instance_item=get_current_instance_item(user);
  instance_item->num_flares = instance_item->num_flares + 1;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)instance_item->flares, sizeof(struct anonymous$2) /*88ul*/  * (unsigned long int)instance_item->num_flares);
  instance_item->flares = (struct anonymous$2 *)return_value_realloc$1;
  struct anonymous$2 * const flare = &instance_item->flares[(signed long int)(instance_item->num_flares - 1)];
  flare->limit = -1;
  instance_item->limit = flare->limit;
  user->active_flare = flare;
  flare->obj=fc_solve_alloc_instance(&user->meta_alloc);
  user->soft_thread=fc_solve_instance_get_first_soft_thread(user->active_flare->obj);
  fc_solve_apply_preset_by_ptr(flare->obj, &user->common_preset);
  flare->ret_code = 9;
  user->ret_code = flare->ret_code;
  _Bool tmp_if_expr$2;
  if(!(user->iter_handler == ((void (*)(void *, signed int, signed int, void *, signed int, void *))NULL)))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = user->long_iter_handler != ((void (*)(void *, signed long int, signed int, void *, signed long int, void *))NULL) ? (_Bool)1 : (_Bool)0;
  flare->obj->debug_iter_output_func = tmp_if_expr$2 ? iter_handler_wrapper : (void (*)(void *api_instance, signed long int iter_num, signed int depth, void *lp_instance, struct anonymous$6 *ptr_state, signed long int parent_iter_num))(void *)0;
  flare->obj->debug_iter_output_context = (void *)user;
  flare->moves_seq.num_moves = 0;
  flare->moves_seq.moves = (struct anonymous$4 *)(void *)0;
  flare->name = (char *)(void *)0;
  flare->fc_pro_moves.moves = (struct anonymous$53 *)(void *)0;
  flare->instance_is_ready = (_Bool)1;
  init_stats(&flare->obj_stats);
  return 0;
}

// user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2379
static signed int user_next_instance(struct anonymous * const user)
{
  user->num_instances = user->num_instances + 1;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)user->instances_list, sizeof(struct anonymous$1) /*56ul*/  * (unsigned long int)user->num_instances);
  user->instances_list = (struct anonymous$1 *)return_value_realloc$1;
  user->current_instance_idx = user->num_instances - 1;
  struct anonymous$1 *instance_item;
  instance_item=get_current_instance_item(user);
  instance_item->num_flares = 0;
  instance_item->flares = (struct anonymous$2 *)(void *)0;
  instance_item->plan = (struct anonymous$0 *)(void *)0;
  instance_item->num_plan_items = 0;
  instance_item->flares_plan_string = (char *)(void *)0;
  instance_item->flares_plan_compiled = (_Bool)0;
  instance_item->current_plan_item_idx = 0;
  instance_item->minimal_solution_flare_idx = -1;
  instance_item->all_plan_items_finished_so_far = 1;
  signed int return_value_user_next_flare$2;
  return_value_user_next_flare$2=user_next_flare(user);
  return return_value_user_next_flare$2;
}

// worker_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 209
static void * worker_thread(void *void_context)
{
  const struct anonymous$22 * const context = (const struct anonymous$22 *)void_context;
  struct anonymous$25 user;
  void *return_value_freecell_solver_user_alloc$1;
  return_value_freecell_solver_user_alloc$1=freecell_solver_user_alloc();
  user = (struct anonymous$25){ .display_context={ .debug_iter_state_output=(_Bool)0, .parseable_output=(_Bool)0, .canonized_order_output=(_Bool)0,
    .display_10_as_t=(_Bool)0, .display_parent_iter_num=(_Bool)0 }, .instance=return_value_freecell_solver_user_alloc$1 };
  signed int arg = context->arg;
  char *error_string;
  char **argv = context->argv;
  signed int parser_ret;
  parser_ret=freecell_solver_user_cmd_line_parse_args(user.instance, context->argc, (const char **)(void *)argv, arg, known_parameters, cmd_line_callback, (void *)&user, &error_string, &arg);
  if(parser_ret == 3)
  {
    fprintf(stderr, "Unknown option: %s", argv[(signed long int)arg]);
    goto ret_label;
  }

  else
    if(parser_ret == 4)
    {
      fprintf(stderr, "The command line parameter \"%s\" requires an argument and was not supplied with one.\n", argv[(signed long int)arg]);
      goto ret_label;
    }

    else
      if(parser_ret == 5)
      {
        if(!(error_string == ((char *)NULL)))
        {
          fprintf(stderr, "%s", error_string);
          free((void *)error_string);
        }

        goto ret_label;
      }

  signed int board_num;
  const signed int end_board = context->end_board;
  const signed int board_num_step = context->board_num_step;
  const signed int update_total_num_iters_threshold = context->update_total_num_iters_threshold;
  const signed int past_end_board = end_board + 1;
  struct anonymous$30 mytime;
  signed long int total_num_iters_temp = (signed long int)0;
  const signed long int total_iterations_limit_per_board = context->total_iterations_limit_per_board;
  const signed int stop_at = context->stop_at;
  do
  {
    pthread_mutex_lock(&next_board_num_lock);
    board_num = next_board_num;
    signed int proposed_quota_end;
    next_board_num = next_board_num + board_num_step;
    proposed_quota_end = next_board_num;
    pthread_mutex_unlock(&next_board_num_lock);
    const signed int quota_end = proposed_quota_end < past_end_board ? proposed_quota_end : past_end_board;
    for( ; !(board_num >= quota_end); board_num = board_num + 1)
    {
      char state_string[165l];
      get_board((signed long int)board_num, state_string);
      freecell_solver_user_limit_iterations_long(user.instance, total_iterations_limit_per_board);
      signed int ret;
      ret=freecell_solver_user_solve_board(user.instance, state_string);
      if(ret == 5)
      {
        gettimeofday(&mytime.tv, &mytime.tz);
        printf("Intractable Board No. %i at %li.%.6li\n", board_num, mytime.tv.tv_sec, mytime.tv.tv_usec);
        fflush(stdout);
      }

      else
        if(ret == 12)
        {
          const char *flares_error_string;
          flares_error_string=freecell_solver_user_get_last_error_string(user.instance);
          fprintf(stderr, "Flares Plan: %s\n", flares_error_string);
          goto theme_error;
        }

        else
          if(ret == 1)
          {
            gettimeofday(&mytime.tv, &mytime.tz);
            printf("Unsolved Board No. %i at %li.%.6li\n", board_num, mytime.tv.tv_sec, mytime.tv.tv_usec);
          }

      signed long int return_value_freecell_solver_user_get_num_times_long$2;
      return_value_freecell_solver_user_get_num_times_long$2=freecell_solver_user_get_num_times_long(user.instance);
      total_num_iters_temp = total_num_iters_temp + return_value_freecell_solver_user_get_num_times_long$2;
      if(total_num_iters_temp >= (signed long int)update_total_num_iters_threshold)
      {
        pthread_mutex_lock(&total_num_iters_lock);
        total_num_iters = total_num_iters + total_num_iters_temp;
        pthread_mutex_unlock(&total_num_iters_lock);
        total_num_iters_temp = (signed long int)0;
      }

      if(board_num % stop_at == 0)
      {
        signed long long int total_num_iters_copy;
        pthread_mutex_lock(&total_num_iters_lock);
        total_num_iters = total_num_iters + total_num_iters_temp;
        total_num_iters_copy = total_num_iters;
        pthread_mutex_unlock(&total_num_iters_lock);
        total_num_iters_temp = (signed long int)0;
        gettimeofday(&mytime.tv, &mytime.tz);
        printf("Reached Board No. %i at %li.%.6li (total_num_iters=%lli)\n", board_num, mytime.tv.tv_sec, mytime.tv.tv_usec, total_num_iters_copy);
        fflush(stdout);
      }

      freecell_solver_user_recycle(user.instance);
    }
  }
  while(end_board >= board_num);
  pthread_mutex_lock(&total_num_iters_lock);
  total_num_iters = total_num_iters + total_num_iters_temp;
  pthread_mutex_unlock(&total_num_iters_lock);

theme_error:
  ;
  freecell_solver_user_free(user.instance);

ret_label:
  ;
  return (void *)0;
}

