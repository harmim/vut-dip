// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'visualid'||S32'screen'||S32'depth'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'colormap_size'||S32'bits_per_rgb'|]
// file /usr/include/X11/Xutil.h line 287
struct anonymous$49;

// tag-#anon#ST[*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'file'||*{V}$V$'data'||S64'position'||S64'size'|]
// file ../internal.h line 153
struct anonymous$59;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$40;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$50;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$43;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$52;

// tag-#anon#ST[S32'MousePosX'||S32'MousePosY'||S32'WheelPos'||ARR8{S8}$S8$'MouseButton'||ARR326{S8}$S8$'Key'||U16'$pad0'||S32'LastChar'||S32'StickyKeys'||S32'StickyMouseButtons'||S32'KeyRepeat'||S32'MouseMoved'||S32'CursorPosX'||S32'CursorPosY'|]
// file ./platform.h line 352
struct anonymous$51;

// tag-#anon#ST[S32'NextID'||U32'$pad0'||SYM#tag-_GLFWthread_struct#'First'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'CriticalSection'|]
// file ./platform.h line 458
struct anonymous$63;

// tag-#anon#ST[S32'Present'||S32'fd'||S32'NumAxes'||S32'NumButtons'||*{F32}$F32$'Axis'||*{U8}$U8$'Button'|]
// file ./platform.h line 481
struct anonymous$64;

// tag-#anon#ST[S32'Width'||S32'Height'||S32'Format'||S32'BytesPerPixel'||*{U8}$U8$'Data'|]
// file ./../../include/GL/glfw.h line 396
struct anonymous$60;

// tag-#anon#ST[S32'Width'||S32'Height'||S32'RedBits'||S32'BlueBits'||S32'GreenBits'|]
// file ./../../include/GL/glfw.h line 390
struct anonymous$57;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$3;

// tag-#anon#ST[S32'available'||S32'eventBase'||S32'errorBase'|]
// file ./platform.h line 402
struct anonymous$54;

// tag-#anon#ST[S32'changed'||S32'timeout'||S32'interval'||S32'blanking'||S32'exposure'|]
// file ./platform.h line 323
struct anonymous$45;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$37;

// tag-#anon#ST[S32'function'||U32'$pad0'||U64'plane_mask'||U64'foreground'||U64'background'||S32'line_width'||S32'line_style'||S32'cap_style'||S32'join_style'||S32'fill_style'||S32'fill_rule'||S32'arc_mode'||U32'$pad1'||U64'tile'||U64'stipple'||S32'ts_x_origin'||S32'ts_y_origin'||U64'font'||S32'subwindow_mode'||S32'graphics_exposures'||S32'clip_x_origin'||S32'clip_y_origin'||U64'clip_mask'||S32'dash_offset'||S8'dashes'||U24'$pad2'|]
// file /usr/include/X11/Xlib.h line 181
struct anonymous$46;

// tag-#anon#ST[S32'idlen'||S32'cmaptype'||S32'imagetype'||S32'cmapfirstidx'||S32'cmaplen'||S32'cmapentrysize'||S32'xorigin'||S32'yorigin'||S32'width'||S32'height'||S32'bitsperpixel'||S32'imageinfo'||S32'_alphabits'||S32'_origin'|]
// file ../tga.c line 53
struct anonymous$65;

// tag-#anon#ST[S32'mode'||S32'refreshRate'||S32'windowNoResize'||S32'glMajor'||S32'glMinor'||S32'glForward'||S32'glDebug'||S32'glProfile'|]
// file ../internal.h line 101
struct anonymous;

// tag-#anon#ST[S32'modeChanged'||U16'oldSizeID'||U16'$pad0'||S32'oldWidth'||S32'oldHeight'||U16'oldRotation'||U16'$pad1'|]
// file ./platform.h line 332
struct anonymous$47;

// tag-#anon#ST[S32'redBits'||S32'greenBits'||S32'blueBits'||S32'alphaBits'||S32'depthBits'||S32'stencilBits'||S32'accumRedBits'||S32'accumGreenBits'||S32'accumBlueBits'||S32'accumAlphaBits'||S32'auxBuffers'||S32'stereo'||S32'samples'||U32'$pad0'||S64'platformID'|]
// file ../internal.h line 120
struct anonymous$0;

// tag-#anon#ST[S32'refreshRate'||S32'accumRedBits'||S32'accumGreenBits'||S32'accumBlueBits'||S32'accumAlphaBits'||S32'auxBuffers'||S32'stereo'||S32'windowNoResize'||S32'samples'||S32'glMajor'||S32'glMinor'||S32'glForward'||S32'glDebug'||S32'glProfile'|]
// file ../internal.h line 69
struct anonymous$56;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$33;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$35;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$36;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$12;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$11;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$15;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$16;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$17;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$24;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$21;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$20;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$19;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$28;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$18;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous$25;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$14;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$23;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$29;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$5;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$34;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$9;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$32;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$13;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$22;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$10;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$26;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$30;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$31;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$8;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$7;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$6;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$4;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous$27;

// tag-#anon#ST[S32'versionMajor'||S32'versionMinor'||S32'eventBase'||S32'errorBase'|]
// file ./platform.h line 396
struct anonymous$53;

// tag-#anon#ST[S32'width'||S32'height'||S32'mwidth'||S32'mheight'|]
// file /usr/include/X11/extensions/Xrandr.h line 44
struct anonymous$38;

// tag-#anon#ST[S32'x'||S32'y'|]
// file /usr/include/X11/Xutil.h line 88
struct anonymous$41;

// tag-#anon#ST[S64'flags'||S32'input'||S32'initial_state'||U64'icon_pixmap'||U64'icon_window'||S32'icon_x'||S32'icon_y'||U64'icon_mask'||U64'window_group'|]
// file /usr/include/X11/Xutil.h line 119
struct anonymous$39;

// tag-#anon#ST[S64'flags'||S32'x'||S32'y'||S32'width'||S32'height'||S32'min_width'||S32'min_height'||S32'max_width'||S32'max_height'||S32'width_inc'||S32'height_inc'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'min_aspect'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'max_aspect'||S32'base_width'||S32'base_height'||S32'win_gravity'||U32'$pad0'|]
// file /usr/include/X11/Xutil.h line 81
struct anonymous$42;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'refreshRate'||S32'accumRedBits'||S32'accumGreenBits'||S32'accumBlueBits'||S32'accumAlphaBits'||S32'auxBuffers'||S32'stereo'||S32'windowNoResize'||S32'samples'||S32'glMajor'||S32'glMinor'||S32'glForward'||S32'glDebug'||S32'glProfile'|]#'hints'||SYM#tag-#anon#ST[S32'Width'||S32'Height'||S32'RedBits'||S32'BlueBits'||S32'GreenBits'|]#'desktopMode'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||SYM#tag-#anon#ST[S32'versionMajor'||S32'versionMinor'||S32'eventBase'||S32'errorBase'|]#'GLX'||SYM#tag-#anon#ST[S32'available'||S32'eventBase'||S32'errorBase'|]#'XF86VidMode'||SYM#tag-#anon#ST[S32'available'||S32'eventBase'||S32'errorBase'|]#'XRandR'||SYM#tag-#anon#ST[U8'monotonic'||U56'$pad0'||F64'resolution'||S64'base'|]#'Timer'|]
// file ./platform.h line 382
struct anonymous$58;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'$pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous$48;

// tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]
// file /usr/include/X11/Xlib.h line 410
struct anonymous$44;

// tag-#anon#ST[U8'monotonic'||U56'$pad0'||F64'resolution'||S64'base'|]
// file ./platform.h line 415
struct anonymous$55;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous$61;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$2;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$62;

// tag-_GLFWthread_struct
// file ./platform.h line 432
struct _GLFWthread_struct;

// tag-_GLFWwin_struct
// file ./platform.h line 226
struct _GLFWwin_struct;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XRRScreenConfiguration
// file /usr/include/X11/extensions/Xrandr.h line 158
struct _XRRScreenConfiguration;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__GLXFBConfigRec
// file /usr/include/GL/glx.h line 169
struct __GLXFBConfigRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_glfwResolution
// file x11_fullscreen.c line 344
struct _glfwResolution;

// tag-codepair
// file x11_keysym2unicode.c line 70
struct codepair;

// tag-js_event
// file x11_joystick.c line 61
struct js_event;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// BPP2RGB
// file x11_fullscreen.c line 44
static void BPP2RGB(signed int bpp, signed int *r, signed int *g, signed int *b);
// HalveImage
// file ../image.c line 147
static signed int HalveImage(unsigned char *src, signed int *width, signed int *height, signed int components);
// Max
// file ../window.c line 50
static signed int Max(signed int a, signed int b);
// ReadTGAHeader
// file ../tga.c line 96
static signed int ReadTGAHeader(struct anonymous$59 *s, struct anonymous$65 *h);
// ReadTGA_RLE
// file ../tga.c line 152
static void ReadTGA_RLE(unsigned char *buf, signed int size, signed int bpp, struct anonymous$59 *s);
// RescaleImage
// file ../image.c line 214
static signed int RescaleImage(struct anonymous$60 *image);
// UpsampleImage
// file ../image.c line 75
static void UpsampleImage(unsigned char *src, unsigned char *dst, signed int w1, signed int h1, signed int w2, signed int h2, signed int bpp);
// XAllocSizeHints
// file /usr/include/X11/Xutil.h line 374
extern struct anonymous$42 * XAllocSizeHints(void);
// XAllocWMHints
// file /usr/include/X11/Xutil.h line 382
extern struct anonymous$39 * XAllocWMHints(void);
// XChangeWindowAttributes
// file /usr/include/X11/Xlib.h line 2085
extern signed int XChangeWindowAttributes(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous$48 *);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XConvertCase
// file /usr/include/X11/Xutil.h line 528
extern void XConvertCase(unsigned long int, unsigned long int *, unsigned long int *);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous$52 *, signed int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous$46 *);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreatePixmapCursor
// file /usr/include/X11/Xlib.h line 1558
extern unsigned long int XCreatePixmapCursor(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous$44 *, struct anonymous$44 *, unsigned int, unsigned int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous$52 *, unsigned long int, struct anonymous$48 *);
// XDefineCursor
// file /usr/include/X11/Xlib.h line 2231
extern signed int XDefineCursor(struct _XDisplay *, unsigned long int, unsigned long int);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XEventsQueued
// file /usr/include/X11/Xlib.h line 2448
extern signed int XEventsQueued(struct _XDisplay *, signed int);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeColormap
// file /usr/include/X11/Xlib.h line 2520
extern signed int XFreeColormap(struct _XDisplay *, unsigned long int);
// XFreeCursor
// file /usr/include/X11/Xlib.h line 2533
extern signed int XFreeCursor(struct _XDisplay *, unsigned long int);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetScreenSaver
// file /usr/include/X11/Xlib.h line 2662
extern signed int XGetScreenSaver(struct _XDisplay *, signed int *, signed int *, signed int *, signed int *);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous$49 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous$49 *, signed int *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XGrabKeyboard
// file /usr/include/X11/Xlib.h line 2720
extern signed int XGrabKeyboard(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, unsigned long int);
// XGrabPointer
// file /usr/include/X11/Xlib.h line 2729
extern signed int XGrabPointer(struct _XDisplay *, unsigned long int, signed int, unsigned int, signed int, signed int, unsigned long int, unsigned long int, unsigned long int);
// XIconifyWindow
// file /usr/include/X11/Xlib.h line 1894
extern signed int XIconifyWindow(struct _XDisplay *, unsigned long int, signed int);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XKeycodeToKeysym
// file /usr/include/X11/Xlib.h line 1687
extern unsigned long int XKeycodeToKeysym(struct _XDisplay *, unsigned char, signed int);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous$4 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// XMoveWindow
// file /usr/include/X11/Xlib.h line 2834
extern signed int XMoveWindow(struct _XDisplay *, unsigned long int, signed int, signed int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XPeekEvent
// file /usr/include/X11/Xlib.h line 2865
extern signed int XPeekEvent(struct _XDisplay *, union _XEvent *);
// XPeekIfEvent
// file /usr/include/X11/Xlib.h line 2870
extern signed int XPeekIfEvent(struct _XDisplay *, union _XEvent *, signed int (*)(struct _XDisplay *, union _XEvent *, char *), char *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XPutBackEvent
// file /usr/include/X11/Xlib.h line 2898
extern signed int XPutBackEvent(struct _XDisplay *, union _XEvent *);
// XQueryPointer
// file /usr/include/X11/Xlib.h line 2983
extern signed int XQueryPointer(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, signed int *, signed int *, signed int *, signed int *, unsigned int *);
// XRRConfigCurrentConfiguration
// file /usr/include/X11/extensions/Xrandr.h line 204
unsigned short int XRRConfigCurrentConfiguration(struct _XRRScreenConfiguration *, unsigned short int *);
// XRRConfigCurrentRate
// file /usr/include/X11/extensions/Xrandr.h line 207
signed short int XRRConfigCurrentRate(struct _XRRScreenConfiguration *);
// XRRConfigRates
// file /usr/include/X11/extensions/Xrandr.h line 202
signed short int * XRRConfigRates(struct _XRRScreenConfiguration *, signed int, signed int *);
// XRRConfigSizes
// file /usr/include/X11/extensions/Xrandr.h line 200
struct anonymous$38 * XRRConfigSizes(struct _XRRScreenConfiguration *, signed int *);
// XRRFreeScreenConfigInfo
// file /usr/include/X11/extensions/Xrandr.h line 170
void XRRFreeScreenConfigInfo(struct _XRRScreenConfiguration *);
// XRRGetScreenInfo
// file /usr/include/X11/extensions/Xrandr.h line 167
struct _XRRScreenConfiguration * XRRGetScreenInfo(struct _XDisplay *, unsigned long int);
// XRRQueryExtension
// file /usr/include/X11/extensions/Xrandr.h line 160
signed int XRRQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XRRSelectInput
// file /usr/include/X11/extensions/Xrandr.h line 220
void XRRSelectInput(struct _XDisplay *, unsigned long int, signed int);
// XRRSetScreenConfig
// file /usr/include/X11/extensions/Xrandr.h line 179
signed int XRRSetScreenConfig(struct _XDisplay *, struct _XRRScreenConfiguration *, unsigned long int, signed int, unsigned short int, unsigned long int);
// XRRSetScreenConfigAndRate
// file /usr/include/X11/extensions/Xrandr.h line 187
signed int XRRSetScreenConfigAndRate(struct _XDisplay *, struct _XRRScreenConfiguration *, unsigned long int, signed int, unsigned short int, signed short int, unsigned long int);
// XRRUpdateConfiguration
// file /usr/include/X11/extensions/Xrandr.h line 451
signed int XRRUpdateConfiguration(union _XEvent *);
// XRaiseWindow
// file /usr/include/X11/Xlib.h line 3026
extern signed int XRaiseWindow(struct _XDisplay *, unsigned long int);
// XResizeWindow
// file /usr/include/X11/Xlib.h line 3099
extern signed int XResizeWindow(struct _XDisplay *, unsigned long int, unsigned int, unsigned int);
// XSendEvent
// file /usr/include/X11/Xlib.h line 3135
extern signed int XSendEvent(struct _XDisplay *, unsigned long int, signed int, signed long int, union _XEvent *);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous$33 *)))(struct _XDisplay *, struct anonymous$33 *);
// XSetIconName
// file /usr/include/X11/Xlib.h line 3245
extern signed int XSetIconName(struct _XDisplay *, unsigned long int, const char *);
// XSetInputFocus
// file /usr/include/X11/Xlib.h line 3251
extern signed int XSetInputFocus(struct _XDisplay *, unsigned long int, signed int, unsigned long int);
// XSetScreenSaver
// file /usr/include/X11/Xlib.h line 3284
extern signed int XSetScreenSaver(struct _XDisplay *, signed int, signed int, signed int, signed int);
// XSetWMHints
// file /usr/include/X11/Xutil.h line 641
extern signed int XSetWMHints(struct _XDisplay *, unsigned long int, struct anonymous$39 *);
// XSetWMNormalHints
// file /usr/include/X11/Xutil.h line 659
extern void XSetWMNormalHints(struct _XDisplay *, unsigned long int, struct anonymous$42 *);
// XSetWMProtocols
// file /usr/include/X11/Xlib.h line 1888
extern signed int XSetWMProtocols(struct _XDisplay *, unsigned long int, unsigned long int *, signed int);
// XStoreName
// file /usr/include/X11/Xlib.h line 3395
extern signed int XStoreName(struct _XDisplay *, unsigned long int, const char *);
// XUndefineCursor
// file /usr/include/X11/Xlib.h line 3457
extern signed int XUndefineCursor(struct _XDisplay *, unsigned long int);
// XUngrabKeyboard
// file /usr/include/X11/Xlib.h line 3476
extern signed int XUngrabKeyboard(struct _XDisplay *, unsigned long int);
// XUngrabPointer
// file /usr/include/X11/Xlib.h line 3481
extern signed int XUngrabPointer(struct _XDisplay *, unsigned long int);
// XUnmapWindow
// file /usr/include/X11/Xlib.h line 3505
extern signed int XUnmapWindow(struct _XDisplay *, unsigned long int);
// XWarpPointer
// file /usr/include/X11/Xlib.h line 3514
extern signed int XWarpPointer(struct _XDisplay *, unsigned long int, unsigned long int, signed int, signed int, unsigned int, unsigned int, signed int, signed int);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// _glfwAppendThread
// file ../thread.c line 63
void _glfwAppendThread(struct _GLFWthread_struct *t);
// _glfwChooseFBConfig
// file ../window.c line 259
const struct anonymous$0 * _glfwChooseFBConfig(const struct anonymous$0 *desired, const struct anonymous$0 *alternatives, unsigned int count);
// _glfwClearInput
// file ../window.c line 98
void _glfwClearInput(void);
// _glfwClearWindowHints
// file ../internal.h line 230
void _glfwClearWindowHints(void);
// _glfwCloseStream
// file ../internal.h line 255
void _glfwCloseStream(struct anonymous$59 *stream);
// _glfwGetClosestVideoMode
// file x11_fullscreen.c line 70
signed int _glfwGetClosestVideoMode(signed int screen, signed int *width, signed int *height, signed int *rate);
// _glfwGetThreadPointer
// file ../thread.c line 43
struct _GLFWthread_struct * _glfwGetThreadPointer(signed int ID);
// _glfwInitJoysticks
// file ./platform.h line 522
void _glfwInitJoysticks(void);
// _glfwInitTimer
// file ./platform.h line 513
void _glfwInitTimer(void);
// _glfwInputChar
// file ../window.c line 176
void _glfwInputChar(signed int character, signed int action);
// _glfwInputDeactivation
// file ../window.c line 70
void _glfwInputDeactivation(void);
// _glfwInputKey
// file ../window.c line 137
void _glfwInputKey(signed int key, signed int action);
// _glfwInputMouseClick
// file ../window.c line 231
void _glfwInputMouseClick(signed int button, signed int action);
// _glfwKeySym2Unicode
// file x11_keysym2unicode.c line 862
signed long int _glfwKeySym2Unicode(unsigned long int keysym);
// _glfwNewThread
// file x11_thread.c line 45
void * _glfwNewThread(void *arg);
// _glfwNewThread::1::threadfun$object
// 
void threadfun$object(void *);
// _glfwOpenBufferStream
// file ../internal.h line 251
signed int _glfwOpenBufferStream(struct anonymous$59 *stream, void *data, signed long int size);
// _glfwOpenFileStream
// file ../internal.h line 250
signed int _glfwOpenFileStream(struct anonymous$59 *stream, const char *name, const char *mode);
// _glfwParseGLVersion
// file ../glext.c line 54
void _glfwParseGLVersion(signed int *major, signed int *minor, signed int *rev);
// _glfwPlatformBroadcastCond
// file ../internal.h line 199
void _glfwPlatformBroadcastCond(void *cond);
// _glfwPlatformCloseWindow
// file ../internal.h line 209
void _glfwPlatformCloseWindow(void);
// _glfwPlatformCreateCond
// file ../internal.h line 195
void * _glfwPlatformCreateCond(void);
// _glfwPlatformCreateMutex
// file ../internal.h line 191
void * _glfwPlatformCreateMutex(void);
// _glfwPlatformCreateThread
// file ../internal.h line 187
signed int _glfwPlatformCreateThread(void (*fun)(void *), void *arg);
// _glfwPlatformCreateThread::fun$object
// 
void fun$object(void *);
// _glfwPlatformDestroyCond
// file ../internal.h line 196
void _glfwPlatformDestroyCond(void *cond);
// _glfwPlatformDestroyMutex
// file ../internal.h line 192
void _glfwPlatformDestroyMutex(void *mutex);
// _glfwPlatformDestroyThread
// file ../internal.h line 188
void _glfwPlatformDestroyThread(signed int ID);
// _glfwPlatformDisableSystemKeys
// file ../internal.h line 171
void _glfwPlatformDisableSystemKeys(void);
// _glfwPlatformEnableSystemKeys
// file ../internal.h line 170
void _glfwPlatformEnableSystemKeys(void);
// _glfwPlatformExtensionSupported
// file ../internal.h line 178
signed int _glfwPlatformExtensionSupported(const char *extension);
// _glfwPlatformGetDesktopMode
// file x11_fullscreen.c line 508
void _glfwPlatformGetDesktopMode(struct anonymous$57 *mode);
// _glfwPlatformGetJoystickButtons
// file ../internal.h line 184
signed int _glfwPlatformGetJoystickButtons(signed int joy, unsigned char *buttons, signed int numbuttons);
// _glfwPlatformGetJoystickParam
// file ../internal.h line 182
signed int _glfwPlatformGetJoystickParam(signed int joy, signed int param);
// _glfwPlatformGetJoystickPos
// file ../internal.h line 183
signed int _glfwPlatformGetJoystickPos(signed int joy, float *pos, signed int numaxes);
// _glfwPlatformGetNumberOfProcessors
// file ../internal.h line 200
signed int _glfwPlatformGetNumberOfProcessors(void);
// _glfwPlatformGetProcAddress
// file ../internal.h line 179
void * _glfwPlatformGetProcAddress(const char *procname);
// _glfwPlatformGetProcAddress::$tmp::return_value_glXGetProcAddress$1$object
// 
void return_value_glXGetProcAddress$1$object(void);
// _glfwPlatformGetThreadID
// file ../internal.h line 190
signed int _glfwPlatformGetThreadID(void);
// _glfwPlatformGetTime
// file ../internal.h line 203
double _glfwPlatformGetTime(void);
// _glfwPlatformGetVideoModes
// file ../internal.h line 174
signed int _glfwPlatformGetVideoModes(struct anonymous$57 *list, signed int maxcount);
// _glfwPlatformHideMouseCursor
// file ../internal.h line 220
void _glfwPlatformHideMouseCursor(void);
// _glfwPlatformIconifyWindow
// file ../internal.h line 213
void _glfwPlatformIconifyWindow(void);
// _glfwPlatformInit
// file ../internal.h line 166
signed int _glfwPlatformInit(void);
// _glfwPlatformLockMutex
// file ../internal.h line 193
void _glfwPlatformLockMutex(void *mutex);
// _glfwPlatformOpenWindow
// file ../internal.h line 208
signed int _glfwPlatformOpenWindow(signed int width, signed int height, const struct anonymous *wndconfig, const struct anonymous$0 *fbconfig);
// _glfwPlatformPollEvents
// file ../internal.h line 218
void _glfwPlatformPollEvents(void);
// _glfwPlatformRefreshWindowParams
// file ../internal.h line 217
void _glfwPlatformRefreshWindowParams(void);
// _glfwPlatformRestoreWindow
// file ../internal.h line 214
void _glfwPlatformRestoreWindow(void);
// _glfwPlatformSetMouseCursorPos
// file ../internal.h line 222
void _glfwPlatformSetMouseCursorPos(signed int x, signed int y);
// _glfwPlatformSetTime
// file ../internal.h line 204
void _glfwPlatformSetTime(double time);
// _glfwPlatformSetWindowPos
// file ../internal.h line 212
void _glfwPlatformSetWindowPos(signed int x, signed int y);
// _glfwPlatformSetWindowSize
// file ../internal.h line 211
void _glfwPlatformSetWindowSize(signed int width, signed int height);
// _glfwPlatformSetWindowTitle
// file ../internal.h line 210
void _glfwPlatformSetWindowTitle(const char *title);
// _glfwPlatformShowMouseCursor
// file ../internal.h line 221
void _glfwPlatformShowMouseCursor(void);
// _glfwPlatformSignalCond
// file ../internal.h line 198
void _glfwPlatformSignalCond(void *cond);
// _glfwPlatformSleep
// file ../internal.h line 205
void _glfwPlatformSleep(double time);
// _glfwPlatformSwapBuffers
// file ../internal.h line 215
void _glfwPlatformSwapBuffers(void);
// _glfwPlatformSwapInterval
// file ../internal.h line 216
void _glfwPlatformSwapInterval(signed int interval);
// _glfwPlatformTerminate
// file ../internal.h line 167
signed int _glfwPlatformTerminate(void);
// _glfwPlatformUnlockMutex
// file ../internal.h line 194
void _glfwPlatformUnlockMutex(void *mutex);
// _glfwPlatformWaitCond
// file ../internal.h line 197
void _glfwPlatformWaitCond(void *cond, void *mutex, double timeout);
// _glfwPlatformWaitEvents
// file ../internal.h line 219
void _glfwPlatformWaitEvents(void);
// _glfwPlatformWaitThread
// file ../internal.h line 189
signed int _glfwPlatformWaitThread(signed int ID, signed int waitmode);
// _glfwReadStream
// file ../stream.c line 72
signed long int _glfwReadStream(struct anonymous$59 *stream, void *data, signed long int size);
// _glfwReadTGA
// file ../internal.h line 258
signed int _glfwReadTGA(struct anonymous$59 *s, struct anonymous$60 *img, signed int flags);
// _glfwRefreshContextParams
// file ../glext.c line 136
void _glfwRefreshContextParams(void);
// _glfwRemoveThread
// file ../thread.c line 82
void _glfwRemoveThread(struct _GLFWthread_struct *t);
// _glfwRestoreVideoMode
// file x11_fullscreen.c line 302
void _glfwRestoreVideoMode(void);
// _glfwSeekStream
// file ../stream.c line 127
signed int _glfwSeekStream(struct anonymous$59 *stream, signed long int offset, signed int whence);
// _glfwSetVideoMode
// file x11_fullscreen.c line 286
void _glfwSetVideoMode(signed int screen, signed int *width, signed int *height, signed int *rate);
// _glfwSetVideoModeMODE
// file x11_fullscreen.c line 196
void _glfwSetVideoModeMODE(signed int screen, signed int mode, signed int rate);
// _glfwStringInExtensionString
// file ../glext.c line 100
signed int _glfwStringInExtensionString(const char *string, const unsigned char *extensions);
// _glfwTellStream
// file ../stream.c line 107
signed long int _glfwTellStream(struct anonymous$59 *stream);
// _glfwTerminateJoysticks
// file ./platform.h line 523
void _glfwTerminateJoysticks(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// checkForEWMH
// file x11_window.c line 153
static unsigned char checkForEWMH(void);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_window_callback
// file heightmap.c line 650
static signed int close_window_callback(void);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// createContext
// file x11_window.c line 586
static signed int createContext(const struct anonymous *wndconfig, unsigned long int fbconfigID);
// createLegacyContext
// file x11_window.c line 557
static struct __GLXcontextRec * createLegacyContext(struct __GLXFBConfigRec *fbconfig);
// createNULLCursor
// file x11_window.c line 388
static unsigned long int createNULLCursor(struct _XDisplay *display, unsigned long int root);
// createWindow
// file x11_window.c line 851
static unsigned char createWindow(signed int width, signed int height, const struct anonymous *wndconfig);
// disableAutoPollEvents
// file ../enable.c line 227
static void disableAutoPollEvents(void);
// disableKeyRepeat
// file ../enable.c line 208
static void disableKeyRepeat(void);
// disableMouseCursor
// file ../enable.c line 82
static void disableMouseCursor(void);
// disableStickyKeys
// file ../enable.c line 113
static void disableStickyKeys(void);
// disableStickyMouseButtons
// file ../enable.c line 143
static void disableStickyMouseButtons(void);
// disableSystemKeys
// file ../enable.c line 181
static void disableSystemKeys(void);
// enableAutoPollEvents
// file ../enable.c line 218
static void enableAutoPollEvents(void);
// enableKeyRepeat
// file ../enable.c line 199
static void enableKeyRepeat(void);
// enableMouseCursor
// file ../enable.c line 42
static void enableMouseCursor(void);
// enableStickyKeys
// file ../enable.c line 104
static void enableStickyKeys(void);
// enableStickyMouseButtons
// file ../enable.c line 134
static void enableStickyMouseButtons(void);
// enableSystemKeys
// file ../enable.c line 164
static void enableSystemKeys(void);
// enterFullscreenMode
// file x11_window.c line 1012
static void enterFullscreenMode(void);
// errorHandler
// file x11_window.c line 70
static signed int errorHandler(struct _XDisplay *display, struct anonymous$33 *event);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// generate_heightmap__circle
// file heightmap.c line 551
static void generate_heightmap__circle(float *center_x, float *center_y, float *size, float *displacement);
// getFBConfigAttrib
// file x11_window.c line 417
static signed int getFBConfigAttrib(struct __GLXFBConfigRec *fbconfig, signed int attrib);
// getFBConfigs
// file x11_window.c line 438
static struct anonymous$0 * getFBConfigs(unsigned int *found);
// getRawTime
// file x11_time.c line 40
static unsigned long int getRawTime(void);
// getSupportedAtom
// file x11_window.c line 127
static unsigned long int getSupportedAtom(unsigned long int *supportedAtoms, unsigned long int atomCount, const char *atomName);
// getWindowProperty
// file x11_window.c line 92
static unsigned long int getWindowProperty(unsigned long int window, unsigned long int property, unsigned long int type, unsigned char **value);
// getopt
// file getopt.h line 51
signed int getopt(signed int, char **, char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glClear
// file /usr/include/GL/gl.h line 752
void glClear(unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glDrawElements
// file /usr/include/GL/gl.h line 1147
void glDrawElements(unsigned int, signed int, unsigned int, const void *);
// glGetIntegerv
// file /usr/include/GL/gl.h line 814
void glGetIntegerv(unsigned int, signed int *);
// glGetString
// file /usr/include/GL/gl.h line 831
const unsigned char * glGetString(unsigned int);
// glGetTexParameteriv
// file /usr/include/GL/gl.h line 1279
void glGetTexParameteriv(unsigned int, unsigned int, signed int *);
// glPixelStorei
// file /usr/include/GL/gl.h line 1194
void glPixelStorei(unsigned int, signed int);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// glXChooseFBConfig
// file /usr/include/GL/glx.h line 242
extern struct __GLXFBConfigRec ** glXChooseFBConfig(struct _XDisplay *, signed int, const signed int *, signed int *);
// glXCreateNewContext
// file /usr/include/GL/glx.h line 272
extern struct __GLXcontextRec * glXCreateNewContext(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int);
// glXDestroyContext
// file /usr/include/GL/glx.h line 193
extern void glXDestroyContext(struct _XDisplay *, struct __GLXcontextRec *);
// glXGetClientString
// file /usr/include/GL/glx.h line 234
extern const char * glXGetClientString(struct _XDisplay *, signed int);
// glXGetConfig
// file /usr/include/GL/glx.h line 214
extern signed int glXGetConfig(struct _XDisplay *, struct anonymous$49 *, signed int, signed int *);
// glXGetFBConfigAttrib
// file /usr/include/GL/glx.h line 245
extern signed int glXGetFBConfigAttrib(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *);
// glXGetFBConfigs
// file /usr/include/GL/glx.h line 248
extern struct __GLXFBConfigRec ** glXGetFBConfigs(struct _XDisplay *, signed int, signed int *);
// glXGetProcAddress
// file /usr/include/GL/glx.h line 325
extern void (*glXGetProcAddress(const unsigned char *))(void);
// glXGetVisualFromFBConfig
// file /usr/include/GL/glx.h line 251
extern struct anonymous$49 * glXGetVisualFromFBConfig(struct _XDisplay *, struct __GLXFBConfigRec *);
// glXMakeCurrent
// file /usr/include/GL/glx.h line 195
extern signed int glXMakeCurrent(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
// glXQueryExtension
// file /usr/include/GL/glx.h line 208
extern signed int glXQueryExtension(struct _XDisplay *, signed int *, signed int *);
// glXQueryExtensionsString
// file /usr/include/GL/glx.h line 230
extern const char * glXQueryExtensionsString(struct _XDisplay *, signed int);
// glXQueryVersion
// file /usr/include/GL/glx.h line 210
extern signed int glXQueryVersion(struct _XDisplay *, signed int *, signed int *);
// glXSwapBuffers
// file /usr/include/GL/glx.h line 201
extern void glXSwapBuffers(struct _XDisplay *, unsigned long int);
// glfwBroadcastCond
// file ../thread.c line 313
void glfwBroadcastCond(void *cond);
// glfwCloseWindow
// file ../window.c line 674
void glfwCloseWindow(void);
// glfwCreateCond
// file ../thread.c line 248
void * glfwCreateCond(void);
// glfwCreateMutex
// file ../thread.c line 184
void * glfwCreateMutex(void);
// glfwCreateThread
// file ../thread.c line 105
signed int glfwCreateThread(void (*fun)(void *), void *arg);
// glfwCreateThread::fun$object
// 
void fun$object(void *);
// glfwDestroyCond
// file ../thread.c line 264
void glfwDestroyCond(void *cond);
// glfwDestroyMutex
// file ../thread.c line 200
void glfwDestroyMutex(void *mutex);
// glfwDestroyThread
// file ../thread.c line 124
void glfwDestroyThread(signed int ID);
// glfwDisable
// file ../enable.c line 280
void glfwDisable(signed int token);
// glfwEnable
// file ../include/GL/glfw.h line 501
void glfwEnable(signed int token);
// glfwExtensionSupported
// file ../glext.c line 182
signed int glfwExtensionSupported(const char *extension);
// glfwFreeImage
// file ../image.c line 419
void glfwFreeImage(struct anonymous$60 *img);
// glfwGetDesktopMode
// file ../fullscreen.c line 85
void glfwGetDesktopMode(struct anonymous$57 *mode);
// glfwGetGLVersion
// file ../glext.c line 263
void glfwGetGLVersion(signed int *major, signed int *minor, signed int *rev);
// glfwGetJoystickButtons
// file ../joystick.c line 80
signed int glfwGetJoystickButtons(signed int joy, unsigned char *buttons, signed int numbuttons);
// glfwGetJoystickParam
// file ../joystick.c line 42
signed int glfwGetJoystickParam(signed int joy, signed int param);
// glfwGetJoystickPos
// file ../joystick.c line 57
signed int glfwGetJoystickPos(signed int joy, float *pos, signed int numaxes);
// glfwGetKey
// file ../input.c line 38
signed int glfwGetKey(signed int key);
// glfwGetMouseButton
// file ../input.c line 66
signed int glfwGetMouseButton(signed int button);
// glfwGetMousePos
// file ../input.c line 94
void glfwGetMousePos(signed int *xpos, signed int *ypos);
// glfwGetMouseWheel
// file ../input.c line 149
signed int glfwGetMouseWheel(void);
// glfwGetNumberOfProcessors
// file ../thread.c line 331
signed int glfwGetNumberOfProcessors(void);
// glfwGetProcAddress
// file ../include/GL/glfw.h line 481
void * glfwGetProcAddress(const char *procname);
// glfwGetThreadID
// file ../thread.c line 168
signed int glfwGetThreadID(void);
// glfwGetTime
// file ../include/GL/glfw.h line 475
double glfwGetTime(void);
// glfwGetVersion
// file ../init.c line 104
void glfwGetVersion(signed int *major, signed int *minor, signed int *rev);
// glfwGetVideoModes
// file ../fullscreen.c line 42
signed int glfwGetVideoModes(struct anonymous$57 *list, signed int maxcount);
// glfwGetWindowParam
// file ../window.c line 847
signed int glfwGetWindowParam(signed int param);
// glfwGetWindowSize
// file ../window.c line 710
void glfwGetWindowSize(signed int *width, signed int *height);
// glfwIconifyWindow
// file ../window.c line 775
void glfwIconifyWindow(void);
// glfwInit
// file ../include/GL/glfw.h line 429
signed int glfwInit(void);
// glfwLoadMemoryTexture2D
// file ../image.c line 484
signed int glfwLoadMemoryTexture2D(const void *data, signed long int size, signed int flags);
// glfwLoadTexture2D
// file ../image.c line 446
signed int glfwLoadTexture2D(const char *name, signed int flags);
// glfwLoadTextureImage2D
// file ../image.c line 522
signed int glfwLoadTextureImage2D(struct anonymous$60 *img, signed int flags);
// glfwLockMutex
// file ../thread.c line 216
void glfwLockMutex(void *mutex);
// glfwOpenWindow
// file ../include/GL/glfw.h line 434
signed int glfwOpenWindow(signed int width, signed int height, signed int redbits, signed int greenbits, signed int bluebits, signed int alphabits, signed int depthbits, signed int stencilbits, signed int mode);
// glfwOpenWindowHint
// file ../include/GL/glfw.h line 435
void glfwOpenWindowHint(signed int target, signed int hint);
// glfwPollEvents
// file ../window.c line 979
void glfwPollEvents(void);
// glfwReadImage
// file ../image.c line 276
signed int glfwReadImage(const char *name, struct anonymous$60 *img, signed int flags);
// glfwReadMemoryImage
// file ../image.c line 348
signed int glfwReadMemoryImage(const void *data, signed long int size, struct anonymous$60 *img, signed int flags);
// glfwRestoreWindow
// file ../window.c line 791
void glfwRestoreWindow(void);
// glfwSetCharCallback
// file ../input.c line 197
void glfwSetCharCallback(void (*cbfun)(signed int, signed int));
// glfwSetCharCallback::cbfun$object
// 
//void cbfun$object(signed int, signed int);
// glfwSetKeyCallback
// file ../include/GL/glfw.h line 463
void glfwSetKeyCallback(void (*cbfun)(signed int, signed int));
// glfwSetKeyCallback::cbfun$object
// 
//void cbfun$object(signed int, signed int);
// glfwSetMouseButtonCallback
// file ../input.c line 213
void glfwSetMouseButtonCallback(void (*cbfun)(signed int, signed int));
// glfwSetMouseButtonCallback::cbfun$object
// 
//void cbfun$object(signed int, signed int);
// glfwSetMousePos
// file ../input.c line 117
void glfwSetMousePos(signed int xpos, signed int ypos);
// glfwSetMousePosCallback
// file ../input.c line 229
void glfwSetMousePosCallback(void (*cbfun)(signed int, signed int));
// glfwSetMousePosCallback::cbfun$object
// 
//void cbfun$object(signed int, signed int);
// glfwSetMouseWheel
// file ../input.c line 165
void glfwSetMouseWheel(signed int pos);
// glfwSetMouseWheelCallback
// file ../input.c line 252
void glfwSetMouseWheelCallback(void (*cbfun)(signed int));
// glfwSetMouseWheelCallback::cbfun$object
// 
//void cbfun$object(signed int);
// glfwSetTime
// file ../time.c line 58
void glfwSetTime(double time);
// glfwSetWindowCloseCallback
// file ../include/GL/glfw.h line 447
void glfwSetWindowCloseCallback(signed int (*cbfun)(void));
// glfwSetWindowCloseCallback::cbfun$object
// 
signed int cbfun$object(void);
// glfwSetWindowPos
// file ../window.c line 758
void glfwSetWindowPos(signed int x, signed int y);
// glfwSetWindowRefreshCallback
// file ../window.c line 963
void glfwSetWindowRefreshCallback(void (*cbfun)(void));
// glfwSetWindowRefreshCallback::cbfun$object
// 
//void cbfun$object(void);
// glfwSetWindowSize
// file ../window.c line 732
void glfwSetWindowSize(signed int width, signed int height);
// glfwSetWindowSizeCallback
// file ../window.c line 925
void glfwSetWindowSizeCallback(void (*cbfun)(signed int, signed int));
// glfwSetWindowSizeCallback::cbfun$object
// 
//void cbfun$object(signed int, signed int);
// glfwSetWindowTitle
// file ../include/GL/glfw.h line 437
void glfwSetWindowTitle(const char *title);
// glfwSignalCond
// file ../thread.c line 297
void glfwSignalCond(void *cond);
// glfwSleep
// file ../time.c line 74
void glfwSleep(double time);
// glfwSwapBuffers
// file ../include/GL/glfw.h line 443
void glfwSwapBuffers(void);
// glfwSwapInterval
// file ../window.c line 831
void glfwSwapInterval(signed int interval);
// glfwTerminate
// file ../init.c line 81
void glfwTerminate(void);
// glfwUnlockMutex
// file ../thread.c line 232
void glfwUnlockMutex(void *mutex);
// glfwWaitCond
// file ../thread.c line 280
void glfwWaitCond(void *cond, void *mutex, double timeout);
// glfwWaitEvents
// file ../window.c line 995
void glfwWaitEvents(void);
// glfwWaitThread
// file ../thread.c line 146
signed int glfwWaitThread(signed int ID, signed int waitmode);
// glfw_atexit
// file x11_init.c line 138
static void glfw_atexit(void);
// initDisplay
// file x11_init.c line 148
static signed int initDisplay(void);
// initGLXExtensions
// file x11_window.c line 750
static void initGLXExtensions(void);
// initLibraries
// file x11_init.c line 109
static void initLibraries(void);
// initThreads
// file x11_init.c line 43
static void initThreads(void);
// init_map
// file heightmap.c line 467
static void init_map(void);
// init_opengl
// file heightmap.c line 256
static unsigned char init_opengl(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isMapNotify
// file x11_window.c line 81
static signed int isMapNotify(struct _XDisplay *d, union _XEvent *e, char *arg);
// key_callback
// file heightmap.c line 659
static void key_callback(signed int key, signed int action);
// leaveFullscreenMode
// file x11_window.c line 1111
static void leaveFullscreenMode(void);
// make_mesh
// file heightmap.c line 603
static void make_mesh(unsigned int program);
// make_shader
// file heightmap.c line 384
static unsigned int make_shader(unsigned int type, const char *shader_src);
// make_shader_program
// file heightmap.c line 411
static unsigned int make_shader_program(const char *vertex_shader_src, const char *fragment_shader_src);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// pglAttachShader$object
// 
void pglAttachShader$object(unsigned int, unsigned int);
// pglBindBuffer$object
// 
void pglBindBuffer$object(unsigned int, unsigned int);
// pglBindVertexArray$object
// 
void pglBindVertexArray$object(unsigned int);
// pglBufferData$object
// 
void pglBufferData$object(unsigned int, signed long int, const void *, unsigned int);
// pglBufferSubData$object
// 
void pglBufferSubData$object(unsigned int, signed long int, signed long int, const void *);
// pglCompileShader$object
// 
void pglCompileShader$object(unsigned int);
// pglCreateProgram$object
// 
unsigned int pglCreateProgram$object(void);
// pglCreateShader$object
// 
unsigned int pglCreateShader$object(unsigned int);
// pglDeleteProgram$object
// 
void pglDeleteProgram$object(unsigned int);
// pglDeleteShader$object
// 
void pglDeleteShader$object(unsigned int);
// pglDeleteVertexArrays$object
// 
void pglDeleteVertexArrays$object(signed int, unsigned int *);
// pglEnableVertexAttribArray$object
// 
void pglEnableVertexAttribArray$object(unsigned int);
// pglGenBuffers$object
// 
void pglGenBuffers$object(signed int, unsigned int *);
// pglGenVertexArrays$object
// 
void pglGenVertexArrays$object(signed int, unsigned int *);
// pglGetAttribLocation$object
// 
signed int pglGetAttribLocation$object(unsigned int, const char *);
// pglGetProgramInfoLog$object
// 
void pglGetProgramInfoLog$object(unsigned int, signed int, signed int *, char *);
// pglGetProgramiv$object
// 
void pglGetProgramiv$object(unsigned int, unsigned int, signed int *);
// pglGetShaderInfoLog$object
// 
void pglGetShaderInfoLog$object(unsigned int, signed int, signed int *, char *);
// pglGetShaderiv$object
// 
void pglGetShaderiv$object(unsigned int, unsigned int, signed int *);
// pglGetUniformLocation$object
// 
signed int pglGetUniformLocation$object(unsigned int, const char *);
// pglLinkProgram$object
// 
void pglLinkProgram$object(unsigned int);
// pglShaderSource$object
// 
void pglShaderSource$object(unsigned int, signed int, const char **, const signed int *);
// pglUniformMatrix4fv$object
// 
void pglUniformMatrix4fv$object(signed int, signed int, unsigned char, const float *);
// pglUseProgram$object
// 
void pglUseProgram$object(unsigned int);
// pglVertexAttribPointer$object
// 
void pglVertexAttribPointer$object(unsigned int, signed int, unsigned int, unsigned char, signed int, const void *);
// pollJoystickEvents
// file x11_joystick.c line 215
static void pollJoystickEvents(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// processSingleEvent
// file x11_window.c line 1165
static unsigned char processSingleEvent(void);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$1 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$1 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$1 *, const union anonymous$2 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$1 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$1 *, union anonymous$62 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$1 *, union anonymous$62 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$62 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$62 *, const union anonymous$2 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$62 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$62 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_file_content
// file heightmap.c line 358
static char * read_file_content(const char *filename);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrtf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern float sqrtf(float);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// tanf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 67
extern float tanf(float);
// terminateDisplay
// file x11_init.c line 205
static void terminateDisplay(void);
// terminateThreads
// file x11_init.c line 68
static void terminateThreads(void);
// translateChar
// file x11_window.c line 372
static signed int translateChar(struct anonymous$4 *event);
// translateKey
// file x11_window.c line 243
static signed int translateKey(signed int keycode);
// update_map
// file heightmap.c line 567
static void update_map(signed int num_iter);
// update_mesh
// file heightmap.c line 636
static void update_mesh(void);
// usage
// file heightmap.c line 671
static void usage(void);

struct anonymous$49
{
  // visual
  struct anonymous$52 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous$59
{
  // file
  struct _IO_FILE *file;
  // data
  void *data;
  // position
  signed long int position;
  // size
  signed long int size;
};

struct anonymous$40
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$37 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$52 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$50
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$43 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$40 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$43
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$52
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$51
{
  // MousePosX
  signed int MousePosX;
  // MousePosY
  signed int MousePosY;
  // WheelPos
  signed int WheelPos;
  // MouseButton
  char MouseButton[8l];
  // Key
  char Key[326l];
  // LastChar
  signed int LastChar;
  // StickyKeys
  signed int StickyKeys;
  // StickyMouseButtons
  signed int StickyMouseButtons;
  // KeyRepeat
  signed int KeyRepeat;
  // MouseMoved
  signed int MouseMoved;
  // CursorPosX
  signed int CursorPosX;
  // CursorPosY
  signed int CursorPosY;
};

struct _GLFWthread_struct
{
  // Previous
  struct _GLFWthread_struct *Previous;
  // Next
  struct _GLFWthread_struct *Next;
  // ID
  signed int ID;
  // Function
  void (*Function)(void *);
  // PosixID
  unsigned long int PosixID;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$62
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$63
{
  // NextID
  signed int NextID;
  // First
  struct _GLFWthread_struct First;
  // CriticalSection
  union anonymous$62 CriticalSection;
};

struct anonymous$64
{
  // Present
  signed int Present;
  // fd
  signed int fd;
  // NumAxes
  signed int NumAxes;
  // NumButtons
  signed int NumButtons;
  // Axis
  float *Axis;
  // Button
  unsigned char *Button;
};

struct anonymous$60
{
  // Width
  signed int Width;
  // Height
  signed int Height;
  // Format
  signed int Format;
  // BytesPerPixel
  signed int BytesPerPixel;
  // Data
  unsigned char *Data;
};

struct anonymous$57
{
  // Width
  signed int Width;
  // Height
  signed int Height;
  // RedBits
  signed int RedBits;
  // BlueBits
  signed int BlueBits;
  // GreenBits
  signed int GreenBits;
};

struct anonymous$3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$54
{
  // available
  signed int available;
  // eventBase
  signed int eventBase;
  // errorBase
  signed int errorBase;
};

struct anonymous$45
{
  // changed
  signed int changed;
  // timeout
  signed int timeout;
  // interval
  signed int interval;
  // blanking
  signed int blanking;
  // exposure
  signed int exposure;
};

struct anonymous$37
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$52 *visuals;
};

struct anonymous$46
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous$65
{
  // idlen
  signed int idlen;
  // cmaptype
  signed int cmaptype;
  // imagetype
  signed int imagetype;
  // cmapfirstidx
  signed int cmapfirstidx;
  // cmaplen
  signed int cmaplen;
  // cmapentrysize
  signed int cmapentrysize;
  // xorigin
  signed int xorigin;
  // yorigin
  signed int yorigin;
  // width
  signed int width;
  // height
  signed int height;
  // bitsperpixel
  signed int bitsperpixel;
  // imageinfo
  signed int imageinfo;
  // _alphabits
  signed int _alphabits;
  // _origin
  signed int _origin;
};

struct anonymous
{
  // mode
  signed int mode;
  // refreshRate
  signed int refreshRate;
  // windowNoResize
  signed int windowNoResize;
  // glMajor
  signed int glMajor;
  // glMinor
  signed int glMinor;
  // glForward
  signed int glForward;
  // glDebug
  signed int glDebug;
  // glProfile
  signed int glProfile;
};

struct anonymous$47
{
  // modeChanged
  signed int modeChanged;
  // oldSizeID
  unsigned short int oldSizeID;
  // oldWidth
  signed int oldWidth;
  // oldHeight
  signed int oldHeight;
  // oldRotation
  unsigned short int oldRotation;
};

struct anonymous$0
{
  // redBits
  signed int redBits;
  // greenBits
  signed int greenBits;
  // blueBits
  signed int blueBits;
  // alphaBits
  signed int alphaBits;
  // depthBits
  signed int depthBits;
  // stencilBits
  signed int stencilBits;
  // accumRedBits
  signed int accumRedBits;
  // accumGreenBits
  signed int accumGreenBits;
  // accumBlueBits
  signed int accumBlueBits;
  // accumAlphaBits
  signed int accumAlphaBits;
  // auxBuffers
  signed int auxBuffers;
  // stereo
  signed int stereo;
  // samples
  signed int samples;
  // platformID
  signed long int platformID;
};

struct anonymous$56
{
  // refreshRate
  signed int refreshRate;
  // accumRedBits
  signed int accumRedBits;
  // accumGreenBits
  signed int accumGreenBits;
  // accumBlueBits
  signed int accumBlueBits;
  // accumAlphaBits
  signed int accumAlphaBits;
  // auxBuffers
  signed int auxBuffers;
  // stereo
  signed int stereo;
  // windowNoResize
  signed int windowNoResize;
  // samples
  signed int samples;
  // glMajor
  signed int glMajor;
  // glMinor
  signed int glMinor;
  // glForward
  signed int glForward;
  // glDebug
  signed int glDebug;
  // glProfile
  signed int glProfile;
};

struct anonymous$33
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$12
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$11
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$15
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$16
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$17
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$24
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$21
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$20
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$19
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$18
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$14
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$5
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$34
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$9
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$13
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$10
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$61
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$61 data;
};

struct anonymous$8
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$7
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$6
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$4
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$53
{
  // versionMajor
  signed int versionMajor;
  // versionMinor
  signed int versionMinor;
  // eventBase
  signed int eventBase;
  // errorBase
  signed int errorBase;
};

struct anonymous$38
{
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
};

struct anonymous$41
{
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$39
{
  // flags
  signed long int flags;
  // input
  signed int input;
  // initial_state
  signed int initial_state;
  // icon_pixmap
  unsigned long int icon_pixmap;
  // icon_window
  unsigned long int icon_window;
  // icon_x
  signed int icon_x;
  // icon_y
  signed int icon_y;
  // icon_mask
  unsigned long int icon_mask;
  // window_group
  unsigned long int window_group;
};

struct anonymous$42
{
  // flags
  signed long int flags;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // min_width
  signed int min_width;
  // min_height
  signed int min_height;
  // max_width
  signed int max_width;
  // max_height
  signed int max_height;
  // width_inc
  signed int width_inc;
  // height_inc
  signed int height_inc;
  // min_aspect
  struct anonymous$41 min_aspect;
  // max_aspect
  struct anonymous$41 max_aspect;
  // base_width
  signed int base_width;
  // base_height
  signed int base_height;
  // win_gravity
  signed int win_gravity;
};

struct anonymous$55
{
  // monotonic
  unsigned char monotonic;
  // resolution
  double resolution;
  // base
  signed long long int base;
};

struct anonymous$58
{
  // hints
  struct anonymous$56 hints;
  // desktopMode
  struct anonymous$57 desktopMode;
  // display
  struct _XDisplay *display;
  // GLX
  struct anonymous$53 GLX;
  // XF86VidMode
  struct anonymous$54 XF86VidMode;
  // XRandR
  struct anonymous$54 XRandR;
  // Timer
  struct anonymous$55 Timer;
};

struct anonymous$48
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous$44
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

union anonymous$2
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$1
{
  // __data
  struct anonymous$3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct _GLFWwin_struct
{
  // windowSizeCallback
  void (*windowSizeCallback)(signed int, signed int);
  // windowCloseCallback
  signed int (*windowCloseCallback)(void);
  // windowRefreshCallback
  void (*windowRefreshCallback)(void);
  // mouseButtonCallback
  void (*mouseButtonCallback)(signed int, signed int);
  // mousePosCallback
  void (*mousePosCallback)(signed int, signed int);
  // mouseWheelCallback
  void (*mouseWheelCallback)(signed int);
  // keyCallback
  void (*keyCallback)(signed int, signed int);
  // charCallback
  void (*charCallback)(signed int, signed int);
  // fullscreen
  signed int fullscreen;
  // mouseLock
  signed int mouseLock;
  // autoPollEvents
  signed int autoPollEvents;
  // sysKeysDisabled
  signed int sysKeysDisabled;
  // windowNoResize
  signed int windowNoResize;
  // refreshRate
  signed int refreshRate;
  // opened
  signed int opened;
  // active
  signed int active;
  // iconified
  signed int iconified;
  // width
  signed int width;
  // height
  signed int height;
  // accelerated
  signed int accelerated;
  // redBits
  signed int redBits;
  // greenBits
  signed int greenBits;
  // blueBits
  signed int blueBits;
  // alphaBits
  signed int alphaBits;
  // depthBits
  signed int depthBits;
  // stencilBits
  signed int stencilBits;
  // accumRedBits
  signed int accumRedBits;
  // accumGreenBits
  signed int accumGreenBits;
  // accumBlueBits
  signed int accumBlueBits;
  // accumAlphaBits
  signed int accumAlphaBits;
  // auxBuffers
  signed int auxBuffers;
  // stereo
  signed int stereo;
  // samples
  signed int samples;
  // has_GL_SGIS_generate_mipmap
  signed int has_GL_SGIS_generate_mipmap;
  // has_GL_ARB_texture_non_power_of_two
  signed int has_GL_ARB_texture_non_power_of_two;
  // glMajor
  signed int glMajor;
  // glMinor
  signed int glMinor;
  // glRevision
  signed int glRevision;
  // glForward
  signed int glForward;
  // glDebug
  signed int glDebug;
  // glProfile
  signed int glProfile;
  // GetStringi
  const unsigned char * (*GetStringi)(unsigned int, unsigned int);
  // colormap
  unsigned long int colormap;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // screen
  signed int screen;
  // visual
  struct anonymous$49 *visual;
  // fbconfigID
  unsigned long int fbconfigID;
  // context
  struct __GLXcontextRec *context;
  // wmDeleteWindow
  unsigned long int wmDeleteWindow;
  // wmPing
  unsigned long int wmPing;
  // wmState
  unsigned long int wmState;
  // wmStateFullscreen
  unsigned long int wmStateFullscreen;
  // wmActiveWindow
  unsigned long int wmActiveWindow;
  // cursor
  unsigned long int cursor;
  // SwapIntervalEXT
  void (*SwapIntervalEXT)(struct _XDisplay *, unsigned long int, signed int);
  // SwapIntervalMESA
  signed int (*SwapIntervalMESA)(unsigned int);
  // SwapIntervalSGI
  signed int (*SwapIntervalSGI)(signed int);
  // GetFBConfigAttribSGIX
  signed int (*GetFBConfigAttribSGIX)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *);
  // ChooseFBConfigSGIX
  struct __GLXFBConfigRec ** (*ChooseFBConfigSGIX)(struct _XDisplay *, signed int, signed int *, signed int *);
  // CreateContextWithConfigSGIX
  struct __GLXcontextRec * (*CreateContextWithConfigSGIX)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int);
  // GetVisualFromFBConfigSGIX
  struct anonymous$49 * (*GetVisualFromFBConfigSGIX)(struct _XDisplay *, struct __GLXFBConfigRec *);
  // CreateContextAttribsARB
  struct __GLXcontextRec * (*CreateContextAttribsARB)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *);
  // has_GLX_SGIX_fbconfig
  unsigned char has_GLX_SGIX_fbconfig;
  // has_GLX_EXT_swap_control
  unsigned char has_GLX_EXT_swap_control;
  // has_GLX_MESA_swap_control
  unsigned char has_GLX_MESA_swap_control;
  // has_GLX_SGI_swap_control
  unsigned char has_GLX_SGI_swap_control;
  // has_GLX_ARB_multisample
  unsigned char has_GLX_ARB_multisample;
  // has_GLX_ARB_create_context
  unsigned char has_GLX_ARB_create_context;
  // has_GLX_ARB_create_context_profile
  unsigned char has_GLX_ARB_create_context_profile;
  // hasEWMH
  unsigned char hasEWMH;
  // overrideRedirect
  unsigned char overrideRedirect;
  // keyboardGrabbed
  unsigned char keyboardGrabbed;
  // pointerGrabbed
  unsigned char pointerGrabbed;
  // pointerHidden
  unsigned char pointerHidden;
  // Saver
  struct anonymous$45 Saver;
  // FS
  struct anonymous$47 FS;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$5 xany;
  // xkey
  struct anonymous$4 xkey;
  // xbutton
  struct anonymous$6 xbutton;
  // xmotion
  struct anonymous$7 xmotion;
  // xcrossing
  struct anonymous$8 xcrossing;
  // xfocus
  struct anonymous$9 xfocus;
  // xexpose
  struct anonymous$10 xexpose;
  // xgraphicsexpose
  struct anonymous$11 xgraphicsexpose;
  // xnoexpose
  struct anonymous$12 xnoexpose;
  // xvisibility
  struct anonymous$13 xvisibility;
  // xcreatewindow
  struct anonymous$14 xcreatewindow;
  // xdestroywindow
  struct anonymous$15 xdestroywindow;
  // xunmap
  struct anonymous$16 xunmap;
  // xmap
  struct anonymous$17 xmap;
  // xmaprequest
  struct anonymous$18 xmaprequest;
  // xreparent
  struct anonymous$19 xreparent;
  // xconfigure
  struct anonymous$20 xconfigure;
  // xgravity
  struct anonymous$21 xgravity;
  // xresizerequest
  struct anonymous$22 xresizerequest;
  // xconfigurerequest
  struct anonymous$23 xconfigurerequest;
  // xcirculate
  struct anonymous$24 xcirculate;
  // xcirculaterequest
  struct anonymous$25 xcirculaterequest;
  // xproperty
  struct anonymous$26 xproperty;
  // xselectionclear
  struct anonymous$27 xselectionclear;
  // xselectionrequest
  struct anonymous$28 xselectionrequest;
  // xselection
  struct anonymous$29 xselection;
  // xcolormap
  struct anonymous$30 xcolormap;
  // xclient
  struct anonymous$31 xclient;
  // xmapping
  struct anonymous$32 xmapping;
  // xerror
  struct anonymous$33 xerror;
  // xkeymap
  struct anonymous$34 xkeymap;
  // xgeneric
  struct anonymous$35 xgeneric;
  // xcookie
  struct anonymous$36 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct _glfwResolution
{
  // width
  signed int width;
  // height
  signed int height;
};

struct codepair
{
  // keysym
  unsigned short int keysym;
  // ucs
  unsigned short int ucs;
};

struct js_event
{
  // time
  unsigned int time;
  // value
  signed short int value;
  // type
  unsigned char type;
  // number
  unsigned char number;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// _glfwErrorCode
// file x11_window.c line 58
static unsigned long int _glfwErrorCode = (unsigned long int)0;
// _glfwInitialized
// file ../internal.h line 144
signed int _glfwInitialized = 0;
// _glfwInput
// file ./platform.h line 376
struct anonymous$51 _glfwInput;
// _glfwJoy
// file ./platform.h line 488
struct anonymous$64 _glfwJoy[16l];
// _glfwLibrary
// file ./platform.h line 426
struct anonymous$58 _glfwLibrary;
// _glfwThrd
// file ./platform.h line 475
struct anonymous$63 _glfwThrd;
// _glfwWin
// file ./platform.h line 346
struct _GLFWwin_struct _glfwWin;
// aspect_ratio
// file heightmap.c line 317
static float aspect_ratio = 4.0f / 3.0f;
// default_fragment_shader
// file heightmap.c line 303
static const char *default_fragment_shader = "#version 150\nout vec4 gl_FragColor;\nvoid main()\n{\n    gl_FragColor = vec4(0.2, 1.0, 0.2, 1.0); \n}\n";
// default_vertex_shader
// file heightmap.c line 290
static const char *default_vertex_shader = "#version 150\nuniform mat4 project;\nuniform mat4 modelview;\nin float x;\nin float y;\nin float z;\n\nvoid main()\n{\n   gl_Position = project * modelview * vec4(x, y, z, 1.0);\n}\n";
// keysymtab
// file x11_keysym2unicode.c line 73
static struct codepair keysymtab[776l] = { { .keysym=(unsigned short int)0x01a1, .ucs=(unsigned short int)0x0104 }, 
    { .keysym=(unsigned short int)0x01a2, .ucs=(unsigned short int)0x02d8 }, 
    { .keysym=(unsigned short int)0x01a3, .ucs=(unsigned short int)0x0141 }, 
    { .keysym=(unsigned short int)0x01a5, .ucs=(unsigned short int)0x013d }, 
    { .keysym=(unsigned short int)0x01a6, .ucs=(unsigned short int)0x015a }, 
    { .keysym=(unsigned short int)0x01a9, .ucs=(unsigned short int)0x0160 }, 
    { .keysym=(unsigned short int)0x01aa, .ucs=(unsigned short int)0x015e }, 
    { .keysym=(unsigned short int)0x01ab, .ucs=(unsigned short int)0x0164 }, 
    { .keysym=(unsigned short int)0x01ac, .ucs=(unsigned short int)0x0179 }, 
    { .keysym=(unsigned short int)0x01ae, .ucs=(unsigned short int)0x017d }, 
    { .keysym=(unsigned short int)0x01af, .ucs=(unsigned short int)0x017b }, 
    { .keysym=(unsigned short int)0x01b1, .ucs=(unsigned short int)0x0105 }, 
    { .keysym=(unsigned short int)0x01b2, .ucs=(unsigned short int)0x02db }, 
    { .keysym=(unsigned short int)0x01b3, .ucs=(unsigned short int)0x0142 }, 
    { .keysym=(unsigned short int)0x01b5, .ucs=(unsigned short int)0x013e }, 
    { .keysym=(unsigned short int)0x01b6, .ucs=(unsigned short int)0x015b }, 
    { .keysym=(unsigned short int)0x01b7, .ucs=(unsigned short int)0x02c7 }, 
    { .keysym=(unsigned short int)0x01b9, .ucs=(unsigned short int)0x0161 }, 
    { .keysym=(unsigned short int)0x01ba, .ucs=(unsigned short int)0x015f }, 
    { .keysym=(unsigned short int)0x01bb, .ucs=(unsigned short int)0x0165 }, 
    { .keysym=(unsigned short int)0x01bc, .ucs=(unsigned short int)0x017a }, 
    { .keysym=(unsigned short int)0x01bd, .ucs=(unsigned short int)0x02dd }, 
    { .keysym=(unsigned short int)0x01be, .ucs=(unsigned short int)0x017e }, 
    { .keysym=(unsigned short int)0x01bf, .ucs=(unsigned short int)0x017c }, 
    { .keysym=(unsigned short int)0x01c0, .ucs=(unsigned short int)0x0154 }, 
    { .keysym=(unsigned short int)0x01c3, .ucs=(unsigned short int)0x0102 }, 
    { .keysym=(unsigned short int)0x01c5, .ucs=(unsigned short int)0x0139 }, 
    { .keysym=(unsigned short int)0x01c6, .ucs=(unsigned short int)0x0106 }, 
    { .keysym=(unsigned short int)0x01c8, .ucs=(unsigned short int)0x010c }, 
    { .keysym=(unsigned short int)0x01ca, .ucs=(unsigned short int)0x0118 }, 
    { .keysym=(unsigned short int)0x01cc, .ucs=(unsigned short int)0x011a }, 
    { .keysym=(unsigned short int)0x01cf, .ucs=(unsigned short int)0x010e }, 
    { .keysym=(unsigned short int)0x01d0, .ucs=(unsigned short int)0x0110 }, 
    { .keysym=(unsigned short int)0x01d1, .ucs=(unsigned short int)0x0143 }, 
    { .keysym=(unsigned short int)0x01d2, .ucs=(unsigned short int)0x0147 }, 
    { .keysym=(unsigned short int)0x01d5, .ucs=(unsigned short int)0x0150 }, 
    { .keysym=(unsigned short int)0x01d8, .ucs=(unsigned short int)0x0158 }, 
    { .keysym=(unsigned short int)0x01d9, .ucs=(unsigned short int)0x016e }, 
    { .keysym=(unsigned short int)0x01db, .ucs=(unsigned short int)0x0170 }, 
    { .keysym=(unsigned short int)0x01de, .ucs=(unsigned short int)0x0162 }, 
    { .keysym=(unsigned short int)0x01e0, .ucs=(unsigned short int)0x0155 }, 
    { .keysym=(unsigned short int)0x01e3, .ucs=(unsigned short int)0x0103 }, 
    { .keysym=(unsigned short int)0x01e5, .ucs=(unsigned short int)0x013a }, 
    { .keysym=(unsigned short int)0x01e6, .ucs=(unsigned short int)0x0107 }, 
    { .keysym=(unsigned short int)0x01e8, .ucs=(unsigned short int)0x010d }, 
    { .keysym=(unsigned short int)0x01ea, .ucs=(unsigned short int)0x0119 }, 
    { .keysym=(unsigned short int)0x01ec, .ucs=(unsigned short int)0x011b }, 
    { .keysym=(unsigned short int)0x01ef, .ucs=(unsigned short int)0x010f }, 
    { .keysym=(unsigned short int)0x01f0, .ucs=(unsigned short int)0x0111 }, 
    { .keysym=(unsigned short int)0x01f1, .ucs=(unsigned short int)0x0144 }, 
    { .keysym=(unsigned short int)0x01f2, .ucs=(unsigned short int)0x0148 }, 
    { .keysym=(unsigned short int)0x01f5, .ucs=(unsigned short int)0x0151 }, 
    { .keysym=(unsigned short int)0x01f8, .ucs=(unsigned short int)0x0159 }, 
    { .keysym=(unsigned short int)0x01f9, .ucs=(unsigned short int)0x016f }, 
    { .keysym=(unsigned short int)0x01fb, .ucs=(unsigned short int)0x0171 }, 
    { .keysym=(unsigned short int)0x01fe, .ucs=(unsigned short int)0x0163 }, 
    { .keysym=(unsigned short int)0x01ff, .ucs=(unsigned short int)0x02d9 }, 
    { .keysym=(unsigned short int)0x02a1, .ucs=(unsigned short int)0x0126 }, 
    { .keysym=(unsigned short int)0x02a6, .ucs=(unsigned short int)0x0124 }, 
    { .keysym=(unsigned short int)0x02a9, .ucs=(unsigned short int)0x0130 }, 
    { .keysym=(unsigned short int)0x02ab, .ucs=(unsigned short int)0x011e }, 
    { .keysym=(unsigned short int)0x02ac, .ucs=(unsigned short int)0x0134 }, 
    { .keysym=(unsigned short int)0x02b1, .ucs=(unsigned short int)0x0127 }, 
    { .keysym=(unsigned short int)0x02b6, .ucs=(unsigned short int)0x0125 }, 
    { .keysym=(unsigned short int)0x02b9, .ucs=(unsigned short int)0x0131 }, 
    { .keysym=(unsigned short int)0x02bb, .ucs=(unsigned short int)0x011f }, 
    { .keysym=(unsigned short int)0x02bc, .ucs=(unsigned short int)0x0135 }, 
    { .keysym=(unsigned short int)0x02c5, .ucs=(unsigned short int)0x010a }, 
    { .keysym=(unsigned short int)0x02c6, .ucs=(unsigned short int)0x0108 }, 
    { .keysym=(unsigned short int)0x02d5, .ucs=(unsigned short int)0x0120 }, 
    { .keysym=(unsigned short int)0x02d8, .ucs=(unsigned short int)0x011c }, 
    { .keysym=(unsigned short int)0x02dd, .ucs=(unsigned short int)0x016c }, 
    { .keysym=(unsigned short int)0x02de, .ucs=(unsigned short int)0x015c }, 
    { .keysym=(unsigned short int)0x02e5, .ucs=(unsigned short int)0x010b }, 
    { .keysym=(unsigned short int)0x02e6, .ucs=(unsigned short int)0x0109 }, 
    { .keysym=(unsigned short int)0x02f5, .ucs=(unsigned short int)0x0121 }, 
    { .keysym=(unsigned short int)0x02f8, .ucs=(unsigned short int)0x011d }, 
    { .keysym=(unsigned short int)0x02fd, .ucs=(unsigned short int)0x016d }, 
    { .keysym=(unsigned short int)0x02fe, .ucs=(unsigned short int)0x015d }, 
    { .keysym=(unsigned short int)0x03a2, .ucs=(unsigned short int)0x0138 }, 
    { .keysym=(unsigned short int)0x03a3, .ucs=(unsigned short int)0x0156 }, 
    { .keysym=(unsigned short int)0x03a5, .ucs=(unsigned short int)0x0128 }, 
    { .keysym=(unsigned short int)0x03a6, .ucs=(unsigned short int)0x013b }, 
    { .keysym=(unsigned short int)0x03aa, .ucs=(unsigned short int)0x0112 }, 
    { .keysym=(unsigned short int)0x03ab, .ucs=(unsigned short int)0x0122 }, 
    { .keysym=(unsigned short int)0x03ac, .ucs=(unsigned short int)0x0166 }, 
    { .keysym=(unsigned short int)0x03b3, .ucs=(unsigned short int)0x0157 }, 
    { .keysym=(unsigned short int)0x03b5, .ucs=(unsigned short int)0x0129 }, 
    { .keysym=(unsigned short int)0x03b6, .ucs=(unsigned short int)0x013c }, 
    { .keysym=(unsigned short int)0x03ba, .ucs=(unsigned short int)0x0113 }, 
    { .keysym=(unsigned short int)0x03bb, .ucs=(unsigned short int)0x0123 }, 
    { .keysym=(unsigned short int)0x03bc, .ucs=(unsigned short int)0x0167 }, 
    { .keysym=(unsigned short int)0x03bd, .ucs=(unsigned short int)0x014a }, 
    { .keysym=(unsigned short int)0x03bf, .ucs=(unsigned short int)0x014b }, 
    { .keysym=(unsigned short int)0x03c0, .ucs=(unsigned short int)0x0100 }, 
    { .keysym=(unsigned short int)0x03c7, .ucs=(unsigned short int)0x012e }, 
    { .keysym=(unsigned short int)0x03cc, .ucs=(unsigned short int)0x0116 }, 
    { .keysym=(unsigned short int)0x03cf, .ucs=(unsigned short int)0x012a }, 
    { .keysym=(unsigned short int)0x03d1, .ucs=(unsigned short int)0x0145 }, 
    { .keysym=(unsigned short int)0x03d2, .ucs=(unsigned short int)0x014c }, 
    { .keysym=(unsigned short int)0x03d3, .ucs=(unsigned short int)0x0136 }, 
    { .keysym=(unsigned short int)0x03d9, .ucs=(unsigned short int)0x0172 }, 
    { .keysym=(unsigned short int)0x03dd, .ucs=(unsigned short int)0x0168 }, 
    { .keysym=(unsigned short int)0x03de, .ucs=(unsigned short int)0x016a }, 
    { .keysym=(unsigned short int)0x03e0, .ucs=(unsigned short int)0x0101 }, 
    { .keysym=(unsigned short int)0x03e7, .ucs=(unsigned short int)0x012f }, 
    { .keysym=(unsigned short int)0x03ec, .ucs=(unsigned short int)0x0117 }, 
    { .keysym=(unsigned short int)0x03ef, .ucs=(unsigned short int)0x012b }, 
    { .keysym=(unsigned short int)0x03f1, .ucs=(unsigned short int)0x0146 }, 
    { .keysym=(unsigned short int)0x03f2, .ucs=(unsigned short int)0x014d }, 
    { .keysym=(unsigned short int)0x03f3, .ucs=(unsigned short int)0x0137 }, 
    { .keysym=(unsigned short int)0x03f9, .ucs=(unsigned short int)0x0173 }, 
    { .keysym=(unsigned short int)0x03fd, .ucs=(unsigned short int)0x0169 }, 
    { .keysym=(unsigned short int)0x03fe, .ucs=(unsigned short int)0x016b }, 
    { .keysym=(unsigned short int)0x047e, .ucs=(unsigned short int)0x203e }, 
    { .keysym=(unsigned short int)0x04a1, .ucs=(unsigned short int)0x3002 }, 
    { .keysym=(unsigned short int)0x04a2, .ucs=(unsigned short int)0x300c }, 
    { .keysym=(unsigned short int)0x04a3, .ucs=(unsigned short int)0x300d }, 
    { .keysym=(unsigned short int)0x04a4, .ucs=(unsigned short int)0x3001 }, 
    { .keysym=(unsigned short int)0x04a5, .ucs=(unsigned short int)0x30fb }, 
    { .keysym=(unsigned short int)0x04a6, .ucs=(unsigned short int)0x30f2 }, 
    { .keysym=(unsigned short int)0x04a7, .ucs=(unsigned short int)0x30a1 }, 
    { .keysym=(unsigned short int)0x04a8, .ucs=(unsigned short int)0x30a3 }, 
    { .keysym=(unsigned short int)0x04a9, .ucs=(unsigned short int)0x30a5 }, 
    { .keysym=(unsigned short int)0x04aa, .ucs=(unsigned short int)0x30a7 }, 
    { .keysym=(unsigned short int)0x04ab, .ucs=(unsigned short int)0x30a9 }, 
    { .keysym=(unsigned short int)0x04ac, .ucs=(unsigned short int)0x30e3 }, 
    { .keysym=(unsigned short int)0x04ad, .ucs=(unsigned short int)0x30e5 }, 
    { .keysym=(unsigned short int)0x04ae, .ucs=(unsigned short int)0x30e7 }, 
    { .keysym=(unsigned short int)0x04af, .ucs=(unsigned short int)0x30c3 }, 
    { .keysym=(unsigned short int)0x04b0, .ucs=(unsigned short int)0x30fc }, 
    { .keysym=(unsigned short int)0x04b1, .ucs=(unsigned short int)0x30a2 }, 
    { .keysym=(unsigned short int)0x04b2, .ucs=(unsigned short int)0x30a4 }, 
    { .keysym=(unsigned short int)0x04b3, .ucs=(unsigned short int)0x30a6 }, 
    { .keysym=(unsigned short int)0x04b4, .ucs=(unsigned short int)0x30a8 }, 
    { .keysym=(unsigned short int)0x04b5, .ucs=(unsigned short int)0x30aa }, 
    { .keysym=(unsigned short int)0x04b6, .ucs=(unsigned short int)0x30ab }, 
    { .keysym=(unsigned short int)0x04b7, .ucs=(unsigned short int)0x30ad }, 
    { .keysym=(unsigned short int)0x04b8, .ucs=(unsigned short int)0x30af }, 
    { .keysym=(unsigned short int)0x04b9, .ucs=(unsigned short int)0x30b1 }, 
    { .keysym=(unsigned short int)0x04ba, .ucs=(unsigned short int)0x30b3 }, 
    { .keysym=(unsigned short int)0x04bb, .ucs=(unsigned short int)0x30b5 }, 
    { .keysym=(unsigned short int)0x04bc, .ucs=(unsigned short int)0x30b7 }, 
    { .keysym=(unsigned short int)0x04bd, .ucs=(unsigned short int)0x30b9 }, 
    { .keysym=(unsigned short int)0x04be, .ucs=(unsigned short int)0x30bb }, 
    { .keysym=(unsigned short int)0x04bf, .ucs=(unsigned short int)0x30bd }, 
    { .keysym=(unsigned short int)0x04c0, .ucs=(unsigned short int)0x30bf }, 
    { .keysym=(unsigned short int)0x04c1, .ucs=(unsigned short int)0x30c1 }, 
    { .keysym=(unsigned short int)0x04c2, .ucs=(unsigned short int)0x30c4 }, 
    { .keysym=(unsigned short int)0x04c3, .ucs=(unsigned short int)0x30c6 }, 
    { .keysym=(unsigned short int)0x04c4, .ucs=(unsigned short int)0x30c8 }, 
    { .keysym=(unsigned short int)0x04c5, .ucs=(unsigned short int)0x30ca }, 
    { .keysym=(unsigned short int)0x04c6, .ucs=(unsigned short int)0x30cb }, 
    { .keysym=(unsigned short int)0x04c7, .ucs=(unsigned short int)0x30cc }, 
    { .keysym=(unsigned short int)0x04c8, .ucs=(unsigned short int)0x30cd }, 
    { .keysym=(unsigned short int)0x04c9, .ucs=(unsigned short int)0x30ce }, 
    { .keysym=(unsigned short int)0x04ca, .ucs=(unsigned short int)0x30cf }, 
    { .keysym=(unsigned short int)0x04cb, .ucs=(unsigned short int)0x30d2 }, 
    { .keysym=(unsigned short int)0x04cc, .ucs=(unsigned short int)0x30d5 }, 
    { .keysym=(unsigned short int)0x04cd, .ucs=(unsigned short int)0x30d8 }, 
    { .keysym=(unsigned short int)0x04ce, .ucs=(unsigned short int)0x30db }, 
    { .keysym=(unsigned short int)0x04cf, .ucs=(unsigned short int)0x30de }, 
    { .keysym=(unsigned short int)0x04d0, .ucs=(unsigned short int)0x30df }, 
    { .keysym=(unsigned short int)0x04d1, .ucs=(unsigned short int)0x30e0 }, 
    { .keysym=(unsigned short int)0x04d2, .ucs=(unsigned short int)0x30e1 }, 
    { .keysym=(unsigned short int)0x04d3, .ucs=(unsigned short int)0x30e2 }, 
    { .keysym=(unsigned short int)0x04d4, .ucs=(unsigned short int)0x30e4 }, 
    { .keysym=(unsigned short int)0x04d5, .ucs=(unsigned short int)0x30e6 }, 
    { .keysym=(unsigned short int)0x04d6, .ucs=(unsigned short int)0x30e8 }, 
    { .keysym=(unsigned short int)0x04d7, .ucs=(unsigned short int)0x30e9 }, 
    { .keysym=(unsigned short int)0x04d8, .ucs=(unsigned short int)0x30ea }, 
    { .keysym=(unsigned short int)0x04d9, .ucs=(unsigned short int)0x30eb }, 
    { .keysym=(unsigned short int)0x04da, .ucs=(unsigned short int)0x30ec }, 
    { .keysym=(unsigned short int)0x04db, .ucs=(unsigned short int)0x30ed }, 
    { .keysym=(unsigned short int)0x04dc, .ucs=(unsigned short int)0x30ef }, 
    { .keysym=(unsigned short int)0x04dd, .ucs=(unsigned short int)0x30f3 }, 
    { .keysym=(unsigned short int)0x04de, .ucs=(unsigned short int)0x309b }, 
    { .keysym=(unsigned short int)0x04df, .ucs=(unsigned short int)0x309c }, 
    { .keysym=(unsigned short int)0x05ac, .ucs=(unsigned short int)0x060c }, 
    { .keysym=(unsigned short int)0x05bb, .ucs=(unsigned short int)0x061b }, 
    { .keysym=(unsigned short int)0x05bf, .ucs=(unsigned short int)0x061f }, 
    { .keysym=(unsigned short int)0x05c1, .ucs=(unsigned short int)0x0621 }, 
    { .keysym=(unsigned short int)0x05c2, .ucs=(unsigned short int)0x0622 }, 
    { .keysym=(unsigned short int)0x05c3, .ucs=(unsigned short int)0x0623 }, 
    { .keysym=(unsigned short int)0x05c4, .ucs=(unsigned short int)0x0624 }, 
    { .keysym=(unsigned short int)0x05c5, .ucs=(unsigned short int)0x0625 }, 
    { .keysym=(unsigned short int)0x05c6, .ucs=(unsigned short int)0x0626 }, 
    { .keysym=(unsigned short int)0x05c7, .ucs=(unsigned short int)0x0627 }, 
    { .keysym=(unsigned short int)0x05c8, .ucs=(unsigned short int)0x0628 }, 
    { .keysym=(unsigned short int)0x05c9, .ucs=(unsigned short int)0x0629 }, 
    { .keysym=(unsigned short int)0x05ca, .ucs=(unsigned short int)0x062a }, 
    { .keysym=(unsigned short int)0x05cb, .ucs=(unsigned short int)0x062b }, 
    { .keysym=(unsigned short int)0x05cc, .ucs=(unsigned short int)0x062c }, 
    { .keysym=(unsigned short int)0x05cd, .ucs=(unsigned short int)0x062d }, 
    { .keysym=(unsigned short int)0x05ce, .ucs=(unsigned short int)0x062e }, 
    { .keysym=(unsigned short int)0x05cf, .ucs=(unsigned short int)0x062f }, 
    { .keysym=(unsigned short int)0x05d0, .ucs=(unsigned short int)0x0630 }, 
    { .keysym=(unsigned short int)0x05d1, .ucs=(unsigned short int)0x0631 }, 
    { .keysym=(unsigned short int)0x05d2, .ucs=(unsigned short int)0x0632 }, 
    { .keysym=(unsigned short int)0x05d3, .ucs=(unsigned short int)0x0633 }, 
    { .keysym=(unsigned short int)0x05d4, .ucs=(unsigned short int)0x0634 }, 
    { .keysym=(unsigned short int)0x05d5, .ucs=(unsigned short int)0x0635 }, 
    { .keysym=(unsigned short int)0x05d6, .ucs=(unsigned short int)0x0636 }, 
    { .keysym=(unsigned short int)0x05d7, .ucs=(unsigned short int)0x0637 }, 
    { .keysym=(unsigned short int)0x05d8, .ucs=(unsigned short int)0x0638 }, 
    { .keysym=(unsigned short int)0x05d9, .ucs=(unsigned short int)0x0639 }, 
    { .keysym=(unsigned short int)0x05da, .ucs=(unsigned short int)0x063a }, 
    { .keysym=(unsigned short int)0x05e0, .ucs=(unsigned short int)0x0640 }, 
    { .keysym=(unsigned short int)0x05e1, .ucs=(unsigned short int)0x0641 }, 
    { .keysym=(unsigned short int)0x05e2, .ucs=(unsigned short int)0x0642 }, 
    { .keysym=(unsigned short int)0x05e3, .ucs=(unsigned short int)0x0643 }, 
    { .keysym=(unsigned short int)0x05e4, .ucs=(unsigned short int)0x0644 }, 
    { .keysym=(unsigned short int)0x05e5, .ucs=(unsigned short int)0x0645 }, 
    { .keysym=(unsigned short int)0x05e6, .ucs=(unsigned short int)0x0646 }, 
    { .keysym=(unsigned short int)0x05e7, .ucs=(unsigned short int)0x0647 }, 
    { .keysym=(unsigned short int)0x05e8, .ucs=(unsigned short int)0x0648 }, 
    { .keysym=(unsigned short int)0x05e9, .ucs=(unsigned short int)0x0649 }, 
    { .keysym=(unsigned short int)0x05ea, .ucs=(unsigned short int)0x064a }, 
    { .keysym=(unsigned short int)0x05eb, .ucs=(unsigned short int)0x064b }, 
    { .keysym=(unsigned short int)0x05ec, .ucs=(unsigned short int)0x064c }, 
    { .keysym=(unsigned short int)0x05ed, .ucs=(unsigned short int)0x064d }, 
    { .keysym=(unsigned short int)0x05ee, .ucs=(unsigned short int)0x064e }, 
    { .keysym=(unsigned short int)0x05ef, .ucs=(unsigned short int)0x064f }, 
    { .keysym=(unsigned short int)0x05f0, .ucs=(unsigned short int)0x0650 }, 
    { .keysym=(unsigned short int)0x05f1, .ucs=(unsigned short int)0x0651 }, 
    { .keysym=(unsigned short int)0x05f2, .ucs=(unsigned short int)0x0652 }, 
    { .keysym=(unsigned short int)0x06a1, .ucs=(unsigned short int)0x0452 }, 
    { .keysym=(unsigned short int)0x06a2, .ucs=(unsigned short int)0x0453 }, 
    { .keysym=(unsigned short int)0x06a3, .ucs=(unsigned short int)0x0451 }, 
    { .keysym=(unsigned short int)0x06a4, .ucs=(unsigned short int)0x0454 }, 
    { .keysym=(unsigned short int)0x06a5, .ucs=(unsigned short int)0x0455 }, 
    { .keysym=(unsigned short int)0x06a6, .ucs=(unsigned short int)0x0456 }, 
    { .keysym=(unsigned short int)0x06a7, .ucs=(unsigned short int)0x0457 }, 
    { .keysym=(unsigned short int)0x06a8, .ucs=(unsigned short int)0x0458 }, 
    { .keysym=(unsigned short int)0x06a9, .ucs=(unsigned short int)0x0459 }, 
    { .keysym=(unsigned short int)0x06aa, .ucs=(unsigned short int)0x045a }, 
    { .keysym=(unsigned short int)0x06ab, .ucs=(unsigned short int)0x045b }, 
    { .keysym=(unsigned short int)0x06ac, .ucs=(unsigned short int)0x045c }, 
    { .keysym=(unsigned short int)0x06ae, .ucs=(unsigned short int)0x045e }, 
    { .keysym=(unsigned short int)0x06af, .ucs=(unsigned short int)0x045f }, 
    { .keysym=(unsigned short int)0x06b0, .ucs=(unsigned short int)0x2116 }, 
    { .keysym=(unsigned short int)0x06b1, .ucs=(unsigned short int)0x0402 }, 
    { .keysym=(unsigned short int)0x06b2, .ucs=(unsigned short int)0x0403 }, 
    { .keysym=(unsigned short int)0x06b3, .ucs=(unsigned short int)0x0401 }, 
    { .keysym=(unsigned short int)0x06b4, .ucs=(unsigned short int)0x0404 }, 
    { .keysym=(unsigned short int)0x06b5, .ucs=(unsigned short int)0x0405 }, 
    { .keysym=(unsigned short int)0x06b6, .ucs=(unsigned short int)0x0406 }, 
    { .keysym=(unsigned short int)0x06b7, .ucs=(unsigned short int)0x0407 }, 
    { .keysym=(unsigned short int)0x06b8, .ucs=(unsigned short int)0x0408 }, 
    { .keysym=(unsigned short int)0x06b9, .ucs=(unsigned short int)0x0409 }, 
    { .keysym=(unsigned short int)0x06ba, .ucs=(unsigned short int)0x040a }, 
    { .keysym=(unsigned short int)0x06bb, .ucs=(unsigned short int)0x040b }, 
    { .keysym=(unsigned short int)0x06bc, .ucs=(unsigned short int)0x040c }, 
    { .keysym=(unsigned short int)0x06be, .ucs=(unsigned short int)0x040e }, 
    { .keysym=(unsigned short int)0x06bf, .ucs=(unsigned short int)0x040f }, 
    { .keysym=(unsigned short int)0x06c0, .ucs=(unsigned short int)0x044e }, 
    { .keysym=(unsigned short int)0x06c1, .ucs=(unsigned short int)0x0430 }, 
    { .keysym=(unsigned short int)0x06c2, .ucs=(unsigned short int)0x0431 }, 
    { .keysym=(unsigned short int)0x06c3, .ucs=(unsigned short int)0x0446 }, 
    { .keysym=(unsigned short int)0x06c4, .ucs=(unsigned short int)0x0434 }, 
    { .keysym=(unsigned short int)0x06c5, .ucs=(unsigned short int)0x0435 }, 
    { .keysym=(unsigned short int)0x06c6, .ucs=(unsigned short int)0x0444 }, 
    { .keysym=(unsigned short int)0x06c7, .ucs=(unsigned short int)0x0433 }, 
    { .keysym=(unsigned short int)0x06c8, .ucs=(unsigned short int)0x0445 }, 
    { .keysym=(unsigned short int)0x06c9, .ucs=(unsigned short int)0x0438 }, 
    { .keysym=(unsigned short int)0x06ca, .ucs=(unsigned short int)0x0439 }, 
    { .keysym=(unsigned short int)0x06cb, .ucs=(unsigned short int)0x043a }, 
    { .keysym=(unsigned short int)0x06cc, .ucs=(unsigned short int)0x043b }, 
    { .keysym=(unsigned short int)0x06cd, .ucs=(unsigned short int)0x043c }, 
    { .keysym=(unsigned short int)0x06ce, .ucs=(unsigned short int)0x043d }, 
    { .keysym=(unsigned short int)0x06cf, .ucs=(unsigned short int)0x043e }, 
    { .keysym=(unsigned short int)0x06d0, .ucs=(unsigned short int)0x043f }, 
    { .keysym=(unsigned short int)0x06d1, .ucs=(unsigned short int)0x044f }, 
    { .keysym=(unsigned short int)0x06d2, .ucs=(unsigned short int)0x0440 }, 
    { .keysym=(unsigned short int)0x06d3, .ucs=(unsigned short int)0x0441 }, 
    { .keysym=(unsigned short int)0x06d4, .ucs=(unsigned short int)0x0442 }, 
    { .keysym=(unsigned short int)0x06d5, .ucs=(unsigned short int)0x0443 }, 
    { .keysym=(unsigned short int)0x06d6, .ucs=(unsigned short int)0x0436 }, 
    { .keysym=(unsigned short int)0x06d7, .ucs=(unsigned short int)0x0432 }, 
    { .keysym=(unsigned short int)0x06d8, .ucs=(unsigned short int)0x044c }, 
    { .keysym=(unsigned short int)0x06d9, .ucs=(unsigned short int)0x044b }, 
    { .keysym=(unsigned short int)0x06da, .ucs=(unsigned short int)0x0437 }, 
    { .keysym=(unsigned short int)0x06db, .ucs=(unsigned short int)0x0448 }, 
    { .keysym=(unsigned short int)0x06dc, .ucs=(unsigned short int)0x044d }, 
    { .keysym=(unsigned short int)0x06dd, .ucs=(unsigned short int)0x0449 }, 
    { .keysym=(unsigned short int)0x06de, .ucs=(unsigned short int)0x0447 }, 
    { .keysym=(unsigned short int)0x06df, .ucs=(unsigned short int)0x044a }, 
    { .keysym=(unsigned short int)0x06e0, .ucs=(unsigned short int)0x042e }, 
    { .keysym=(unsigned short int)0x06e1, .ucs=(unsigned short int)0x0410 }, 
    { .keysym=(unsigned short int)0x06e2, .ucs=(unsigned short int)0x0411 }, 
    { .keysym=(unsigned short int)0x06e3, .ucs=(unsigned short int)0x0426 }, 
    { .keysym=(unsigned short int)0x06e4, .ucs=(unsigned short int)0x0414 }, 
    { .keysym=(unsigned short int)0x06e5, .ucs=(unsigned short int)0x0415 }, 
    { .keysym=(unsigned short int)0x06e6, .ucs=(unsigned short int)0x0424 }, 
    { .keysym=(unsigned short int)0x06e7, .ucs=(unsigned short int)0x0413 }, 
    { .keysym=(unsigned short int)0x06e8, .ucs=(unsigned short int)0x0425 }, 
    { .keysym=(unsigned short int)0x06e9, .ucs=(unsigned short int)0x0418 }, 
    { .keysym=(unsigned short int)0x06ea, .ucs=(unsigned short int)0x0419 }, 
    { .keysym=(unsigned short int)0x06eb, .ucs=(unsigned short int)0x041a }, 
    { .keysym=(unsigned short int)0x06ec, .ucs=(unsigned short int)0x041b }, 
    { .keysym=(unsigned short int)0x06ed, .ucs=(unsigned short int)0x041c }, 
    { .keysym=(unsigned short int)0x06ee, .ucs=(unsigned short int)0x041d }, 
    { .keysym=(unsigned short int)0x06ef, .ucs=(unsigned short int)0x041e }, 
    { .keysym=(unsigned short int)0x06f0, .ucs=(unsigned short int)0x041f }, 
    { .keysym=(unsigned short int)0x06f1, .ucs=(unsigned short int)0x042f }, 
    { .keysym=(unsigned short int)0x06f2, .ucs=(unsigned short int)0x0420 }, 
    { .keysym=(unsigned short int)0x06f3, .ucs=(unsigned short int)0x0421 }, 
    { .keysym=(unsigned short int)0x06f4, .ucs=(unsigned short int)0x0422 }, 
    { .keysym=(unsigned short int)0x06f5, .ucs=(unsigned short int)0x0423 }, 
    { .keysym=(unsigned short int)0x06f6, .ucs=(unsigned short int)0x0416 }, 
    { .keysym=(unsigned short int)0x06f7, .ucs=(unsigned short int)0x0412 }, 
    { .keysym=(unsigned short int)0x06f8, .ucs=(unsigned short int)0x042c }, 
    { .keysym=(unsigned short int)0x06f9, .ucs=(unsigned short int)0x042b }, 
    { .keysym=(unsigned short int)0x06fa, .ucs=(unsigned short int)0x0417 }, 
    { .keysym=(unsigned short int)0x06fb, .ucs=(unsigned short int)0x0428 }, 
    { .keysym=(unsigned short int)0x06fc, .ucs=(unsigned short int)0x042d }, 
    { .keysym=(unsigned short int)0x06fd, .ucs=(unsigned short int)0x0429 }, 
    { .keysym=(unsigned short int)0x06fe, .ucs=(unsigned short int)0x0427 }, 
    { .keysym=(unsigned short int)0x06ff, .ucs=(unsigned short int)0x042a }, 
    { .keysym=(unsigned short int)0x07a1, .ucs=(unsigned short int)0x0386 }, 
    { .keysym=(unsigned short int)0x07a2, .ucs=(unsigned short int)0x0388 }, 
    { .keysym=(unsigned short int)0x07a3, .ucs=(unsigned short int)0x0389 }, 
    { .keysym=(unsigned short int)0x07a4, .ucs=(unsigned short int)0x038a }, 
    { .keysym=(unsigned short int)0x07a5, .ucs=(unsigned short int)0x03aa }, 
    { .keysym=(unsigned short int)0x07a7, .ucs=(unsigned short int)0x038c }, 
    { .keysym=(unsigned short int)0x07a8, .ucs=(unsigned short int)0x038e }, 
    { .keysym=(unsigned short int)0x07a9, .ucs=(unsigned short int)0x03ab }, 
    { .keysym=(unsigned short int)0x07ab, .ucs=(unsigned short int)0x038f }, 
    { .keysym=(unsigned short int)0x07ae, .ucs=(unsigned short int)0x0385 }, 
    { .keysym=(unsigned short int)0x07af, .ucs=(unsigned short int)0x2015 }, 
    { .keysym=(unsigned short int)0x07b1, .ucs=(unsigned short int)0x03ac }, 
    { .keysym=(unsigned short int)0x07b2, .ucs=(unsigned short int)0x03ad }, 
    { .keysym=(unsigned short int)0x07b3, .ucs=(unsigned short int)0x03ae }, 
    { .keysym=(unsigned short int)0x07b4, .ucs=(unsigned short int)0x03af }, 
    { .keysym=(unsigned short int)0x07b5, .ucs=(unsigned short int)0x03ca }, 
    { .keysym=(unsigned short int)0x07b6, .ucs=(unsigned short int)0x0390 }, 
    { .keysym=(unsigned short int)0x07b7, .ucs=(unsigned short int)0x03cc }, 
    { .keysym=(unsigned short int)0x07b8, .ucs=(unsigned short int)0x03cd }, 
    { .keysym=(unsigned short int)0x07b9, .ucs=(unsigned short int)0x03cb }, 
    { .keysym=(unsigned short int)0x07ba, .ucs=(unsigned short int)0x03b0 }, 
    { .keysym=(unsigned short int)0x07bb, .ucs=(unsigned short int)0x03ce }, 
    { .keysym=(unsigned short int)0x07c1, .ucs=(unsigned short int)0x0391 }, 
    { .keysym=(unsigned short int)0x07c2, .ucs=(unsigned short int)0x0392 }, 
    { .keysym=(unsigned short int)0x07c3, .ucs=(unsigned short int)0x0393 }, 
    { .keysym=(unsigned short int)0x07c4, .ucs=(unsigned short int)0x0394 }, 
    { .keysym=(unsigned short int)0x07c5, .ucs=(unsigned short int)0x0395 }, 
    { .keysym=(unsigned short int)0x07c6, .ucs=(unsigned short int)0x0396 }, 
    { .keysym=(unsigned short int)0x07c7, .ucs=(unsigned short int)0x0397 }, 
    { .keysym=(unsigned short int)0x07c8, .ucs=(unsigned short int)0x0398 }, 
    { .keysym=(unsigned short int)0x07c9, .ucs=(unsigned short int)0x0399 }, 
    { .keysym=(unsigned short int)0x07ca, .ucs=(unsigned short int)0x039a }, 
    { .keysym=(unsigned short int)0x07cb, .ucs=(unsigned short int)0x039b }, 
    { .keysym=(unsigned short int)0x07cc, .ucs=(unsigned short int)0x039c }, 
    { .keysym=(unsigned short int)0x07cd, .ucs=(unsigned short int)0x039d }, 
    { .keysym=(unsigned short int)0x07ce, .ucs=(unsigned short int)0x039e }, 
    { .keysym=(unsigned short int)0x07cf, .ucs=(unsigned short int)0x039f }, 
    { .keysym=(unsigned short int)0x07d0, .ucs=(unsigned short int)0x03a0 }, 
    { .keysym=(unsigned short int)0x07d1, .ucs=(unsigned short int)0x03a1 }, 
    { .keysym=(unsigned short int)0x07d2, .ucs=(unsigned short int)0x03a3 }, 
    { .keysym=(unsigned short int)0x07d4, .ucs=(unsigned short int)0x03a4 }, 
    { .keysym=(unsigned short int)0x07d5, .ucs=(unsigned short int)0x03a5 }, 
    { .keysym=(unsigned short int)0x07d6, .ucs=(unsigned short int)0x03a6 }, 
    { .keysym=(unsigned short int)0x07d7, .ucs=(unsigned short int)0x03a7 }, 
    { .keysym=(unsigned short int)0x07d8, .ucs=(unsigned short int)0x03a8 }, 
    { .keysym=(unsigned short int)0x07d9, .ucs=(unsigned short int)0x03a9 }, 
    { .keysym=(unsigned short int)0x07e1, .ucs=(unsigned short int)0x03b1 }, 
    { .keysym=(unsigned short int)0x07e2, .ucs=(unsigned short int)0x03b2 }, 
    { .keysym=(unsigned short int)0x07e3, .ucs=(unsigned short int)0x03b3 }, 
    { .keysym=(unsigned short int)0x07e4, .ucs=(unsigned short int)0x03b4 }, 
    { .keysym=(unsigned short int)0x07e5, .ucs=(unsigned short int)0x03b5 }, 
    { .keysym=(unsigned short int)0x07e6, .ucs=(unsigned short int)0x03b6 }, 
    { .keysym=(unsigned short int)0x07e7, .ucs=(unsigned short int)0x03b7 }, 
    { .keysym=(unsigned short int)0x07e8, .ucs=(unsigned short int)0x03b8 }, 
    { .keysym=(unsigned short int)0x07e9, .ucs=(unsigned short int)0x03b9 }, 
    { .keysym=(unsigned short int)0x07ea, .ucs=(unsigned short int)0x03ba }, 
    { .keysym=(unsigned short int)0x07eb, .ucs=(unsigned short int)0x03bb }, 
    { .keysym=(unsigned short int)0x07ec, .ucs=(unsigned short int)0x03bc }, 
    { .keysym=(unsigned short int)0x07ed, .ucs=(unsigned short int)0x03bd }, 
    { .keysym=(unsigned short int)0x07ee, .ucs=(unsigned short int)0x03be }, 
    { .keysym=(unsigned short int)0x07ef, .ucs=(unsigned short int)0x03bf }, 
    { .keysym=(unsigned short int)0x07f0, .ucs=(unsigned short int)0x03c0 }, 
    { .keysym=(unsigned short int)0x07f1, .ucs=(unsigned short int)0x03c1 }, 
    { .keysym=(unsigned short int)0x07f2, .ucs=(unsigned short int)0x03c3 }, 
    { .keysym=(unsigned short int)0x07f3, .ucs=(unsigned short int)0x03c2 }, 
    { .keysym=(unsigned short int)0x07f4, .ucs=(unsigned short int)0x03c4 }, 
    { .keysym=(unsigned short int)0x07f5, .ucs=(unsigned short int)0x03c5 }, 
    { .keysym=(unsigned short int)0x07f6, .ucs=(unsigned short int)0x03c6 }, 
    { .keysym=(unsigned short int)0x07f7, .ucs=(unsigned short int)0x03c7 }, 
    { .keysym=(unsigned short int)0x07f8, .ucs=(unsigned short int)0x03c8 }, 
    { .keysym=(unsigned short int)0x07f9, .ucs=(unsigned short int)0x03c9 }, 
    { .keysym=(unsigned short int)0x08a1, .ucs=(unsigned short int)0x23b7 }, 
    { .keysym=(unsigned short int)0x08a2, .ucs=(unsigned short int)0x250c }, 
    { .keysym=(unsigned short int)0x08a3, .ucs=(unsigned short int)0x2500 }, 
    { .keysym=(unsigned short int)0x08a4, .ucs=(unsigned short int)0x2320 }, 
    { .keysym=(unsigned short int)0x08a5, .ucs=(unsigned short int)0x2321 }, 
    { .keysym=(unsigned short int)0x08a6, .ucs=(unsigned short int)0x2502 }, 
    { .keysym=(unsigned short int)0x08a7, .ucs=(unsigned short int)0x23a1 }, 
    { .keysym=(unsigned short int)0x08a8, .ucs=(unsigned short int)0x23a3 }, 
    { .keysym=(unsigned short int)0x08a9, .ucs=(unsigned short int)0x23a4 }, 
    { .keysym=(unsigned short int)0x08aa, .ucs=(unsigned short int)0x23a6 }, 
    { .keysym=(unsigned short int)0x08ab, .ucs=(unsigned short int)0x239b }, 
    { .keysym=(unsigned short int)0x08ac, .ucs=(unsigned short int)0x239d }, 
    { .keysym=(unsigned short int)0x08ad, .ucs=(unsigned short int)0x239e }, 
    { .keysym=(unsigned short int)0x08ae, .ucs=(unsigned short int)0x23a0 }, 
    { .keysym=(unsigned short int)0x08af, .ucs=(unsigned short int)0x23a8 }, 
    { .keysym=(unsigned short int)0x08b0, .ucs=(unsigned short int)0x23ac }, 
    { .keysym=(unsigned short int)0x08bc, .ucs=(unsigned short int)0x2264 }, 
    { .keysym=(unsigned short int)0x08bd, .ucs=(unsigned short int)0x2260 }, 
    { .keysym=(unsigned short int)0x08be, .ucs=(unsigned short int)0x2265 }, 
    { .keysym=(unsigned short int)0x08bf, .ucs=(unsigned short int)0x222b }, 
    { .keysym=(unsigned short int)0x08c0, .ucs=(unsigned short int)0x2234 }, 
    { .keysym=(unsigned short int)0x08c1, .ucs=(unsigned short int)0x221d }, 
    { .keysym=(unsigned short int)0x08c2, .ucs=(unsigned short int)0x221e }, 
    { .keysym=(unsigned short int)0x08c5, .ucs=(unsigned short int)0x2207 }, 
    { .keysym=(unsigned short int)0x08c8, .ucs=(unsigned short int)0x223c }, 
    { .keysym=(unsigned short int)0x08c9, .ucs=(unsigned short int)0x2243 }, 
    { .keysym=(unsigned short int)0x08cd, .ucs=(unsigned short int)0x21d4 }, 
    { .keysym=(unsigned short int)0x08ce, .ucs=(unsigned short int)0x21d2 }, 
    { .keysym=(unsigned short int)0x08cf, .ucs=(unsigned short int)0x2261 }, 
    { .keysym=(unsigned short int)0x08d6, .ucs=(unsigned short int)0x221a }, 
    { .keysym=(unsigned short int)0x08da, .ucs=(unsigned short int)0x2282 }, 
    { .keysym=(unsigned short int)0x08db, .ucs=(unsigned short int)0x2283 }, 
    { .keysym=(unsigned short int)0x08dc, .ucs=(unsigned short int)0x2229 }, 
    { .keysym=(unsigned short int)0x08dd, .ucs=(unsigned short int)0x222a }, 
    { .keysym=(unsigned short int)0x08de, .ucs=(unsigned short int)0x2227 }, 
    { .keysym=(unsigned short int)0x08df, .ucs=(unsigned short int)0x2228 }, 
    { .keysym=(unsigned short int)0x08ef, .ucs=(unsigned short int)0x2202 }, 
    { .keysym=(unsigned short int)0x08f6, .ucs=(unsigned short int)0x0192 }, 
    { .keysym=(unsigned short int)0x08fb, .ucs=(unsigned short int)0x2190 }, 
    { .keysym=(unsigned short int)0x08fc, .ucs=(unsigned short int)0x2191 }, 
    { .keysym=(unsigned short int)0x08fd, .ucs=(unsigned short int)0x2192 }, 
    { .keysym=(unsigned short int)0x08fe, .ucs=(unsigned short int)0x2193 }, 
    { .keysym=(unsigned short int)0x09e0, .ucs=(unsigned short int)0x25c6 }, 
    { .keysym=(unsigned short int)0x09e1, .ucs=(unsigned short int)0x2592 }, 
    { .keysym=(unsigned short int)0x09e2, .ucs=(unsigned short int)0x2409 }, 
    { .keysym=(unsigned short int)0x09e3, .ucs=(unsigned short int)0x240c }, 
    { .keysym=(unsigned short int)0x09e4, .ucs=(unsigned short int)0x240d }, 
    { .keysym=(unsigned short int)0x09e5, .ucs=(unsigned short int)0x240a }, 
    { .keysym=(unsigned short int)0x09e8, .ucs=(unsigned short int)0x2424 }, 
    { .keysym=(unsigned short int)0x09e9, .ucs=(unsigned short int)0x240b }, 
    { .keysym=(unsigned short int)0x09ea, .ucs=(unsigned short int)0x2518 }, 
    { .keysym=(unsigned short int)0x09eb, .ucs=(unsigned short int)0x2510 }, 
    { .keysym=(unsigned short int)0x09ec, .ucs=(unsigned short int)0x250c }, 
    { .keysym=(unsigned short int)0x09ed, .ucs=(unsigned short int)0x2514 }, 
    { .keysym=(unsigned short int)0x09ee, .ucs=(unsigned short int)0x253c }, 
    { .keysym=(unsigned short int)0x09ef, .ucs=(unsigned short int)0x23ba }, 
    { .keysym=(unsigned short int)0x09f0, .ucs=(unsigned short int)0x23bb }, 
    { .keysym=(unsigned short int)0x09f1, .ucs=(unsigned short int)0x2500 }, 
    { .keysym=(unsigned short int)0x09f2, .ucs=(unsigned short int)0x23bc }, 
    { .keysym=(unsigned short int)0x09f3, .ucs=(unsigned short int)0x23bd }, 
    { .keysym=(unsigned short int)0x09f4, .ucs=(unsigned short int)0x251c }, 
    { .keysym=(unsigned short int)0x09f5, .ucs=(unsigned short int)0x2524 }, 
    { .keysym=(unsigned short int)0x09f6, .ucs=(unsigned short int)0x2534 }, 
    { .keysym=(unsigned short int)0x09f7, .ucs=(unsigned short int)0x252c }, 
    { .keysym=(unsigned short int)0x09f8, .ucs=(unsigned short int)0x2502 }, 
    { .keysym=(unsigned short int)0x0aa1, .ucs=(unsigned short int)0x2003 }, 
    { .keysym=(unsigned short int)0x0aa2, .ucs=(unsigned short int)0x2002 }, 
    { .keysym=(unsigned short int)0x0aa3, .ucs=(unsigned short int)0x2004 }, 
    { .keysym=(unsigned short int)0x0aa4, .ucs=(unsigned short int)0x2005 }, 
    { .keysym=(unsigned short int)0x0aa5, .ucs=(unsigned short int)0x2007 }, 
    { .keysym=(unsigned short int)0x0aa6, .ucs=(unsigned short int)0x2008 }, 
    { .keysym=(unsigned short int)0x0aa7, .ucs=(unsigned short int)0x2009 }, 
    { .keysym=(unsigned short int)0x0aa8, .ucs=(unsigned short int)0x200a }, 
    { .keysym=(unsigned short int)0x0aa9, .ucs=(unsigned short int)0x2014 }, 
    { .keysym=(unsigned short int)0x0aaa, .ucs=(unsigned short int)0x2013 }, 
    { .keysym=(unsigned short int)0x0aae, .ucs=(unsigned short int)0x2026 }, 
    { .keysym=(unsigned short int)0x0aaf, .ucs=(unsigned short int)0x2025 }, 
    { .keysym=(unsigned short int)0x0ab0, .ucs=(unsigned short int)0x2153 }, 
    { .keysym=(unsigned short int)0x0ab1, .ucs=(unsigned short int)0x2154 }, 
    { .keysym=(unsigned short int)0x0ab2, .ucs=(unsigned short int)0x2155 }, 
    { .keysym=(unsigned short int)0x0ab3, .ucs=(unsigned short int)0x2156 }, 
    { .keysym=(unsigned short int)0x0ab4, .ucs=(unsigned short int)0x2157 }, 
    { .keysym=(unsigned short int)0x0ab5, .ucs=(unsigned short int)0x2158 }, 
    { .keysym=(unsigned short int)0x0ab6, .ucs=(unsigned short int)0x2159 }, 
    { .keysym=(unsigned short int)0x0ab7, .ucs=(unsigned short int)0x215a }, 
    { .keysym=(unsigned short int)0x0ab8, .ucs=(unsigned short int)0x2105 }, 
    { .keysym=(unsigned short int)0x0abb, .ucs=(unsigned short int)0x2012 }, 
    { .keysym=(unsigned short int)0x0abc, .ucs=(unsigned short int)0x2329 }, 
    { .keysym=(unsigned short int)0x0abe, .ucs=(unsigned short int)0x232a }, 
    { .keysym=(unsigned short int)0x0ac3, .ucs=(unsigned short int)0x215b }, 
    { .keysym=(unsigned short int)0x0ac4, .ucs=(unsigned short int)0x215c }, 
    { .keysym=(unsigned short int)0x0ac5, .ucs=(unsigned short int)0x215d }, 
    { .keysym=(unsigned short int)0x0ac6, .ucs=(unsigned short int)0x215e }, 
    { .keysym=(unsigned short int)0x0ac9, .ucs=(unsigned short int)0x2122 }, 
    { .keysym=(unsigned short int)0x0aca, .ucs=(unsigned short int)0x2613 }, 
    { .keysym=(unsigned short int)0x0acc, .ucs=(unsigned short int)0x25c1 }, 
    { .keysym=(unsigned short int)0x0acd, .ucs=(unsigned short int)0x25b7 }, 
    { .keysym=(unsigned short int)0x0ace, .ucs=(unsigned short int)0x25cb }, 
    { .keysym=(unsigned short int)0x0acf, .ucs=(unsigned short int)0x25af }, 
    { .keysym=(unsigned short int)0x0ad0, .ucs=(unsigned short int)0x2018 }, 
    { .keysym=(unsigned short int)0x0ad1, .ucs=(unsigned short int)0x2019 }, 
    { .keysym=(unsigned short int)0x0ad2, .ucs=(unsigned short int)0x201c }, 
    { .keysym=(unsigned short int)0x0ad3, .ucs=(unsigned short int)0x201d }, 
    { .keysym=(unsigned short int)0x0ad4, .ucs=(unsigned short int)0x211e }, 
    { .keysym=(unsigned short int)0x0ad6, .ucs=(unsigned short int)0x2032 }, 
    { .keysym=(unsigned short int)0x0ad7, .ucs=(unsigned short int)0x2033 }, 
    { .keysym=(unsigned short int)0x0ad9, .ucs=(unsigned short int)0x271d }, 
    { .keysym=(unsigned short int)0x0adb, .ucs=(unsigned short int)0x25ac }, 
    { .keysym=(unsigned short int)0x0adc, .ucs=(unsigned short int)0x25c0 }, 
    { .keysym=(unsigned short int)0x0add, .ucs=(unsigned short int)0x25b6 }, 
    { .keysym=(unsigned short int)0x0ade, .ucs=(unsigned short int)0x25cf }, 
    { .keysym=(unsigned short int)0x0adf, .ucs=(unsigned short int)0x25ae }, 
    { .keysym=(unsigned short int)0x0ae0, .ucs=(unsigned short int)0x25e6 }, 
    { .keysym=(unsigned short int)0x0ae1, .ucs=(unsigned short int)0x25ab }, 
    { .keysym=(unsigned short int)0x0ae2, .ucs=(unsigned short int)0x25ad }, 
    { .keysym=(unsigned short int)0x0ae3, .ucs=(unsigned short int)0x25b3 }, 
    { .keysym=(unsigned short int)0x0ae4, .ucs=(unsigned short int)0x25bd }, 
    { .keysym=(unsigned short int)0x0ae5, .ucs=(unsigned short int)0x2606 }, 
    { .keysym=(unsigned short int)0x0ae6, .ucs=(unsigned short int)0x2022 }, 
    { .keysym=(unsigned short int)0x0ae7, .ucs=(unsigned short int)0x25aa }, 
    { .keysym=(unsigned short int)0x0ae8, .ucs=(unsigned short int)0x25b2 }, 
    { .keysym=(unsigned short int)0x0ae9, .ucs=(unsigned short int)0x25bc }, 
    { .keysym=(unsigned short int)0x0aea, .ucs=(unsigned short int)0x261c }, 
    { .keysym=(unsigned short int)0x0aeb, .ucs=(unsigned short int)0x261e }, 
    { .keysym=(unsigned short int)0x0aec, .ucs=(unsigned short int)0x2663 }, 
    { .keysym=(unsigned short int)0x0aed, .ucs=(unsigned short int)0x2666 }, 
    { .keysym=(unsigned short int)0x0aee, .ucs=(unsigned short int)0x2665 }, 
    { .keysym=(unsigned short int)0x0af0, .ucs=(unsigned short int)0x2720 }, 
    { .keysym=(unsigned short int)0x0af1, .ucs=(unsigned short int)0x2020 }, 
    { .keysym=(unsigned short int)0x0af2, .ucs=(unsigned short int)0x2021 }, 
    { .keysym=(unsigned short int)0x0af3, .ucs=(unsigned short int)0x2713 }, 
    { .keysym=(unsigned short int)0x0af4, .ucs=(unsigned short int)0x2717 }, 
    { .keysym=(unsigned short int)0x0af5, .ucs=(unsigned short int)0x266f }, 
    { .keysym=(unsigned short int)0x0af6, .ucs=(unsigned short int)0x266d }, 
    { .keysym=(unsigned short int)0x0af7, .ucs=(unsigned short int)0x2642 }, 
    { .keysym=(unsigned short int)0x0af8, .ucs=(unsigned short int)0x2640 }, 
    { .keysym=(unsigned short int)0x0af9, .ucs=(unsigned short int)0x260e }, 
    { .keysym=(unsigned short int)0x0afa, .ucs=(unsigned short int)0x2315 }, 
    { .keysym=(unsigned short int)0x0afb, .ucs=(unsigned short int)0x2117 }, 
    { .keysym=(unsigned short int)0x0afc, .ucs=(unsigned short int)0x2038 }, 
    { .keysym=(unsigned short int)0x0afd, .ucs=(unsigned short int)0x201a }, 
    { .keysym=(unsigned short int)0x0afe, .ucs=(unsigned short int)0x201e }, 
    { .keysym=(unsigned short int)0x0ba3, .ucs=(unsigned short int)0x003c }, 
    { .keysym=(unsigned short int)0x0ba6, .ucs=(unsigned short int)0x003e }, 
    { .keysym=(unsigned short int)0x0ba8, .ucs=(unsigned short int)0x2228 }, 
    { .keysym=(unsigned short int)0x0ba9, .ucs=(unsigned short int)0x2227 }, 
    { .keysym=(unsigned short int)0x0bc0, .ucs=(unsigned short int)0x00af }, 
    { .keysym=(unsigned short int)0x0bc2, .ucs=(unsigned short int)0x22a5 }, 
    { .keysym=(unsigned short int)0x0bc3, .ucs=(unsigned short int)0x2229 }, 
    { .keysym=(unsigned short int)0x0bc4, .ucs=(unsigned short int)0x230a }, 
    { .keysym=(unsigned short int)0x0bc6, .ucs=(unsigned short int)0x005f }, 
    { .keysym=(unsigned short int)0x0bca, .ucs=(unsigned short int)0x2218 }, 
    { .keysym=(unsigned short int)0x0bcc, .ucs=(unsigned short int)0x2395 }, 
    { .keysym=(unsigned short int)0x0bce, .ucs=(unsigned short int)0x22a4 }, 
    { .keysym=(unsigned short int)0x0bcf, .ucs=(unsigned short int)0x25cb }, 
    { .keysym=(unsigned short int)0x0bd3, .ucs=(unsigned short int)0x2308 }, 
    { .keysym=(unsigned short int)0x0bd6, .ucs=(unsigned short int)0x222a }, 
    { .keysym=(unsigned short int)0x0bd8, .ucs=(unsigned short int)0x2283 }, 
    { .keysym=(unsigned short int)0x0bda, .ucs=(unsigned short int)0x2282 }, 
    { .keysym=(unsigned short int)0x0bdc, .ucs=(unsigned short int)0x22a2 }, 
    { .keysym=(unsigned short int)0x0bfc, .ucs=(unsigned short int)0x22a3 }, 
    { .keysym=(unsigned short int)0x0cdf, .ucs=(unsigned short int)0x2017 }, 
    { .keysym=(unsigned short int)0x0ce0, .ucs=(unsigned short int)0x05d0 }, 
    { .keysym=(unsigned short int)0x0ce1, .ucs=(unsigned short int)0x05d1 }, 
    { .keysym=(unsigned short int)0x0ce2, .ucs=(unsigned short int)0x05d2 }, 
    { .keysym=(unsigned short int)0x0ce3, .ucs=(unsigned short int)0x05d3 }, 
    { .keysym=(unsigned short int)0x0ce4, .ucs=(unsigned short int)0x05d4 }, 
    { .keysym=(unsigned short int)0x0ce5, .ucs=(unsigned short int)0x05d5 }, 
    { .keysym=(unsigned short int)0x0ce6, .ucs=(unsigned short int)0x05d6 }, 
    { .keysym=(unsigned short int)0x0ce7, .ucs=(unsigned short int)0x05d7 }, 
    { .keysym=(unsigned short int)0x0ce8, .ucs=(unsigned short int)0x05d8 }, 
    { .keysym=(unsigned short int)0x0ce9, .ucs=(unsigned short int)0x05d9 }, 
    { .keysym=(unsigned short int)0x0cea, .ucs=(unsigned short int)0x05da }, 
    { .keysym=(unsigned short int)0x0ceb, .ucs=(unsigned short int)0x05db }, 
    { .keysym=(unsigned short int)0x0cec, .ucs=(unsigned short int)0x05dc }, 
    { .keysym=(unsigned short int)0x0ced, .ucs=(unsigned short int)0x05dd }, 
    { .keysym=(unsigned short int)0x0cee, .ucs=(unsigned short int)0x05de }, 
    { .keysym=(unsigned short int)0x0cef, .ucs=(unsigned short int)0x05df }, 
    { .keysym=(unsigned short int)0x0cf0, .ucs=(unsigned short int)0x05e0 }, 
    { .keysym=(unsigned short int)0x0cf1, .ucs=(unsigned short int)0x05e1 }, 
    { .keysym=(unsigned short int)0x0cf2, .ucs=(unsigned short int)0x05e2 }, 
    { .keysym=(unsigned short int)0x0cf3, .ucs=(unsigned short int)0x05e3 }, 
    { .keysym=(unsigned short int)0x0cf4, .ucs=(unsigned short int)0x05e4 }, 
    { .keysym=(unsigned short int)0x0cf5, .ucs=(unsigned short int)0x05e5 }, 
    { .keysym=(unsigned short int)0x0cf6, .ucs=(unsigned short int)0x05e6 }, 
    { .keysym=(unsigned short int)0x0cf7, .ucs=(unsigned short int)0x05e7 }, 
    { .keysym=(unsigned short int)0x0cf8, .ucs=(unsigned short int)0x05e8 }, 
    { .keysym=(unsigned short int)0x0cf9, .ucs=(unsigned short int)0x05e9 }, 
    { .keysym=(unsigned short int)0x0cfa, .ucs=(unsigned short int)0x05ea }, 
    { .keysym=(unsigned short int)0x0da1, .ucs=(unsigned short int)0x0e01 }, 
    { .keysym=(unsigned short int)0x0da2, .ucs=(unsigned short int)0x0e02 }, 
    { .keysym=(unsigned short int)0x0da3, .ucs=(unsigned short int)0x0e03 }, 
    { .keysym=(unsigned short int)0x0da4, .ucs=(unsigned short int)0x0e04 }, 
    { .keysym=(unsigned short int)0x0da5, .ucs=(unsigned short int)0x0e05 }, 
    { .keysym=(unsigned short int)0x0da6, .ucs=(unsigned short int)0x0e06 }, 
    { .keysym=(unsigned short int)0x0da7, .ucs=(unsigned short int)0x0e07 }, 
    { .keysym=(unsigned short int)0x0da8, .ucs=(unsigned short int)0x0e08 }, 
    { .keysym=(unsigned short int)0x0da9, .ucs=(unsigned short int)0x0e09 }, 
    { .keysym=(unsigned short int)0x0daa, .ucs=(unsigned short int)0x0e0a }, 
    { .keysym=(unsigned short int)0x0dab, .ucs=(unsigned short int)0x0e0b }, 
    { .keysym=(unsigned short int)0x0dac, .ucs=(unsigned short int)0x0e0c }, 
    { .keysym=(unsigned short int)0x0dad, .ucs=(unsigned short int)0x0e0d }, 
    { .keysym=(unsigned short int)0x0dae, .ucs=(unsigned short int)0x0e0e }, 
    { .keysym=(unsigned short int)0x0daf, .ucs=(unsigned short int)0x0e0f }, 
    { .keysym=(unsigned short int)0x0db0, .ucs=(unsigned short int)0x0e10 }, 
    { .keysym=(unsigned short int)0x0db1, .ucs=(unsigned short int)0x0e11 }, 
    { .keysym=(unsigned short int)0x0db2, .ucs=(unsigned short int)0x0e12 }, 
    { .keysym=(unsigned short int)0x0db3, .ucs=(unsigned short int)0x0e13 }, 
    { .keysym=(unsigned short int)0x0db4, .ucs=(unsigned short int)0x0e14 }, 
    { .keysym=(unsigned short int)0x0db5, .ucs=(unsigned short int)0x0e15 }, 
    { .keysym=(unsigned short int)0x0db6, .ucs=(unsigned short int)0x0e16 }, 
    { .keysym=(unsigned short int)0x0db7, .ucs=(unsigned short int)0x0e17 }, 
    { .keysym=(unsigned short int)0x0db8, .ucs=(unsigned short int)0x0e18 }, 
    { .keysym=(unsigned short int)0x0db9, .ucs=(unsigned short int)0x0e19 }, 
    { .keysym=(unsigned short int)0x0dba, .ucs=(unsigned short int)0x0e1a }, 
    { .keysym=(unsigned short int)0x0dbb, .ucs=(unsigned short int)0x0e1b }, 
    { .keysym=(unsigned short int)0x0dbc, .ucs=(unsigned short int)0x0e1c }, 
    { .keysym=(unsigned short int)0x0dbd, .ucs=(unsigned short int)0x0e1d }, 
    { .keysym=(unsigned short int)0x0dbe, .ucs=(unsigned short int)0x0e1e }, 
    { .keysym=(unsigned short int)0x0dbf, .ucs=(unsigned short int)0x0e1f }, 
    { .keysym=(unsigned short int)0x0dc0, .ucs=(unsigned short int)0x0e20 }, 
    { .keysym=(unsigned short int)0x0dc1, .ucs=(unsigned short int)0x0e21 }, 
    { .keysym=(unsigned short int)0x0dc2, .ucs=(unsigned short int)0x0e22 }, 
    { .keysym=(unsigned short int)0x0dc3, .ucs=(unsigned short int)0x0e23 }, 
    { .keysym=(unsigned short int)0x0dc4, .ucs=(unsigned short int)0x0e24 }, 
    { .keysym=(unsigned short int)0x0dc5, .ucs=(unsigned short int)0x0e25 }, 
    { .keysym=(unsigned short int)0x0dc6, .ucs=(unsigned short int)0x0e26 }, 
    { .keysym=(unsigned short int)0x0dc7, .ucs=(unsigned short int)0x0e27 }, 
    { .keysym=(unsigned short int)0x0dc8, .ucs=(unsigned short int)0x0e28 }, 
    { .keysym=(unsigned short int)0x0dc9, .ucs=(unsigned short int)0x0e29 }, 
    { .keysym=(unsigned short int)0x0dca, .ucs=(unsigned short int)0x0e2a }, 
    { .keysym=(unsigned short int)0x0dcb, .ucs=(unsigned short int)0x0e2b }, 
    { .keysym=(unsigned short int)0x0dcc, .ucs=(unsigned short int)0x0e2c }, 
    { .keysym=(unsigned short int)0x0dcd, .ucs=(unsigned short int)0x0e2d }, 
    { .keysym=(unsigned short int)0x0dce, .ucs=(unsigned short int)0x0e2e }, 
    { .keysym=(unsigned short int)0x0dcf, .ucs=(unsigned short int)0x0e2f }, 
    { .keysym=(unsigned short int)0x0dd0, .ucs=(unsigned short int)0x0e30 }, 
    { .keysym=(unsigned short int)0x0dd1, .ucs=(unsigned short int)0x0e31 }, 
    { .keysym=(unsigned short int)0x0dd2, .ucs=(unsigned short int)0x0e32 }, 
    { .keysym=(unsigned short int)0x0dd3, .ucs=(unsigned short int)0x0e33 }, 
    { .keysym=(unsigned short int)0x0dd4, .ucs=(unsigned short int)0x0e34 }, 
    { .keysym=(unsigned short int)0x0dd5, .ucs=(unsigned short int)0x0e35 }, 
    { .keysym=(unsigned short int)0x0dd6, .ucs=(unsigned short int)0x0e36 }, 
    { .keysym=(unsigned short int)0x0dd7, .ucs=(unsigned short int)0x0e37 }, 
    { .keysym=(unsigned short int)0x0dd8, .ucs=(unsigned short int)0x0e38 }, 
    { .keysym=(unsigned short int)0x0dd9, .ucs=(unsigned short int)0x0e39 }, 
    { .keysym=(unsigned short int)0x0dda, .ucs=(unsigned short int)0x0e3a }, 
    { .keysym=(unsigned short int)0x0ddf, .ucs=(unsigned short int)0x0e3f }, 
    { .keysym=(unsigned short int)0x0de0, .ucs=(unsigned short int)0x0e40 }, 
    { .keysym=(unsigned short int)0x0de1, .ucs=(unsigned short int)0x0e41 }, 
    { .keysym=(unsigned short int)0x0de2, .ucs=(unsigned short int)0x0e42 }, 
    { .keysym=(unsigned short int)0x0de3, .ucs=(unsigned short int)0x0e43 }, 
    { .keysym=(unsigned short int)0x0de4, .ucs=(unsigned short int)0x0e44 }, 
    { .keysym=(unsigned short int)0x0de5, .ucs=(unsigned short int)0x0e45 }, 
    { .keysym=(unsigned short int)0x0de6, .ucs=(unsigned short int)0x0e46 }, 
    { .keysym=(unsigned short int)0x0de7, .ucs=(unsigned short int)0x0e47 }, 
    { .keysym=(unsigned short int)0x0de8, .ucs=(unsigned short int)0x0e48 }, 
    { .keysym=(unsigned short int)0x0de9, .ucs=(unsigned short int)0x0e49 }, 
    { .keysym=(unsigned short int)0x0dea, .ucs=(unsigned short int)0x0e4a }, 
    { .keysym=(unsigned short int)0x0deb, .ucs=(unsigned short int)0x0e4b }, 
    { .keysym=(unsigned short int)0x0dec, .ucs=(unsigned short int)0x0e4c }, 
    { .keysym=(unsigned short int)0x0ded, .ucs=(unsigned short int)0x0e4d }, 
    { .keysym=(unsigned short int)0x0df0, .ucs=(unsigned short int)0x0e50 }, 
    { .keysym=(unsigned short int)0x0df1, .ucs=(unsigned short int)0x0e51 }, 
    { .keysym=(unsigned short int)0x0df2, .ucs=(unsigned short int)0x0e52 }, 
    { .keysym=(unsigned short int)0x0df3, .ucs=(unsigned short int)0x0e53 }, 
    { .keysym=(unsigned short int)0x0df4, .ucs=(unsigned short int)0x0e54 }, 
    { .keysym=(unsigned short int)0x0df5, .ucs=(unsigned short int)0x0e55 }, 
    { .keysym=(unsigned short int)0x0df6, .ucs=(unsigned short int)0x0e56 }, 
    { .keysym=(unsigned short int)0x0df7, .ucs=(unsigned short int)0x0e57 }, 
    { .keysym=(unsigned short int)0x0df8, .ucs=(unsigned short int)0x0e58 }, 
    { .keysym=(unsigned short int)0x0df9, .ucs=(unsigned short int)0x0e59 }, 
    { .keysym=(unsigned short int)0x0ea1, .ucs=(unsigned short int)0x3131 }, 
    { .keysym=(unsigned short int)0x0ea2, .ucs=(unsigned short int)0x3132 }, 
    { .keysym=(unsigned short int)0x0ea3, .ucs=(unsigned short int)0x3133 }, 
    { .keysym=(unsigned short int)0x0ea4, .ucs=(unsigned short int)0x3134 }, 
    { .keysym=(unsigned short int)0x0ea5, .ucs=(unsigned short int)0x3135 }, 
    { .keysym=(unsigned short int)0x0ea6, .ucs=(unsigned short int)0x3136 }, 
    { .keysym=(unsigned short int)0x0ea7, .ucs=(unsigned short int)0x3137 }, 
    { .keysym=(unsigned short int)0x0ea8, .ucs=(unsigned short int)0x3138 }, 
    { .keysym=(unsigned short int)0x0ea9, .ucs=(unsigned short int)0x3139 }, 
    { .keysym=(unsigned short int)0x0eaa, .ucs=(unsigned short int)0x313a }, 
    { .keysym=(unsigned short int)0x0eab, .ucs=(unsigned short int)0x313b }, 
    { .keysym=(unsigned short int)0x0eac, .ucs=(unsigned short int)0x313c }, 
    { .keysym=(unsigned short int)0x0ead, .ucs=(unsigned short int)0x313d }, 
    { .keysym=(unsigned short int)0x0eae, .ucs=(unsigned short int)0x313e }, 
    { .keysym=(unsigned short int)0x0eaf, .ucs=(unsigned short int)0x313f }, 
    { .keysym=(unsigned short int)0x0eb0, .ucs=(unsigned short int)0x3140 }, 
    { .keysym=(unsigned short int)0x0eb1, .ucs=(unsigned short int)0x3141 }, 
    { .keysym=(unsigned short int)0x0eb2, .ucs=(unsigned short int)0x3142 }, 
    { .keysym=(unsigned short int)0x0eb3, .ucs=(unsigned short int)0x3143 }, 
    { .keysym=(unsigned short int)0x0eb4, .ucs=(unsigned short int)0x3144 }, 
    { .keysym=(unsigned short int)0x0eb5, .ucs=(unsigned short int)0x3145 }, 
    { .keysym=(unsigned short int)0x0eb6, .ucs=(unsigned short int)0x3146 }, 
    { .keysym=(unsigned short int)0x0eb7, .ucs=(unsigned short int)0x3147 }, 
    { .keysym=(unsigned short int)0x0eb8, .ucs=(unsigned short int)0x3148 }, 
    { .keysym=(unsigned short int)0x0eb9, .ucs=(unsigned short int)0x3149 }, 
    { .keysym=(unsigned short int)0x0eba, .ucs=(unsigned short int)0x314a }, 
    { .keysym=(unsigned short int)0x0ebb, .ucs=(unsigned short int)0x314b }, 
    { .keysym=(unsigned short int)0x0ebc, .ucs=(unsigned short int)0x314c }, 
    { .keysym=(unsigned short int)0x0ebd, .ucs=(unsigned short int)0x314d }, 
    { .keysym=(unsigned short int)0x0ebe, .ucs=(unsigned short int)0x314e }, 
    { .keysym=(unsigned short int)0x0ebf, .ucs=(unsigned short int)0x314f }, 
    { .keysym=(unsigned short int)0x0ec0, .ucs=(unsigned short int)0x3150 }, 
    { .keysym=(unsigned short int)0x0ec1, .ucs=(unsigned short int)0x3151 }, 
    { .keysym=(unsigned short int)0x0ec2, .ucs=(unsigned short int)0x3152 }, 
    { .keysym=(unsigned short int)0x0ec3, .ucs=(unsigned short int)0x3153 }, 
    { .keysym=(unsigned short int)0x0ec4, .ucs=(unsigned short int)0x3154 }, 
    { .keysym=(unsigned short int)0x0ec5, .ucs=(unsigned short int)0x3155 }, 
    { .keysym=(unsigned short int)0x0ec6, .ucs=(unsigned short int)0x3156 }, 
    { .keysym=(unsigned short int)0x0ec7, .ucs=(unsigned short int)0x3157 }, 
    { .keysym=(unsigned short int)0x0ec8, .ucs=(unsigned short int)0x3158 }, 
    { .keysym=(unsigned short int)0x0ec9, .ucs=(unsigned short int)0x3159 }, 
    { .keysym=(unsigned short int)0x0eca, .ucs=(unsigned short int)0x315a }, 
    { .keysym=(unsigned short int)0x0ecb, .ucs=(unsigned short int)0x315b }, 
    { .keysym=(unsigned short int)0x0ecc, .ucs=(unsigned short int)0x315c }, 
    { .keysym=(unsigned short int)0x0ecd, .ucs=(unsigned short int)0x315d }, 
    { .keysym=(unsigned short int)0x0ece, .ucs=(unsigned short int)0x315e }, 
    { .keysym=(unsigned short int)0x0ecf, .ucs=(unsigned short int)0x315f }, 
    { .keysym=(unsigned short int)0x0ed0, .ucs=(unsigned short int)0x3160 }, 
    { .keysym=(unsigned short int)0x0ed1, .ucs=(unsigned short int)0x3161 }, 
    { .keysym=(unsigned short int)0x0ed2, .ucs=(unsigned short int)0x3162 }, 
    { .keysym=(unsigned short int)0x0ed3, .ucs=(unsigned short int)0x3163 }, 
    { .keysym=(unsigned short int)0x0ed4, .ucs=(unsigned short int)0x11a8 }, 
    { .keysym=(unsigned short int)0x0ed5, .ucs=(unsigned short int)0x11a9 }, 
    { .keysym=(unsigned short int)0x0ed6, .ucs=(unsigned short int)0x11aa }, 
    { .keysym=(unsigned short int)0x0ed7, .ucs=(unsigned short int)0x11ab }, 
    { .keysym=(unsigned short int)0x0ed8, .ucs=(unsigned short int)0x11ac }, 
    { .keysym=(unsigned short int)0x0ed9, .ucs=(unsigned short int)0x11ad }, 
    { .keysym=(unsigned short int)0x0eda, .ucs=(unsigned short int)0x11ae }, 
    { .keysym=(unsigned short int)0x0edb, .ucs=(unsigned short int)0x11af }, 
    { .keysym=(unsigned short int)0x0edc, .ucs=(unsigned short int)0x11b0 }, 
    { .keysym=(unsigned short int)0x0edd, .ucs=(unsigned short int)0x11b1 }, 
    { .keysym=(unsigned short int)0x0ede, .ucs=(unsigned short int)0x11b2 }, 
    { .keysym=(unsigned short int)0x0edf, .ucs=(unsigned short int)0x11b3 }, 
    { .keysym=(unsigned short int)0x0ee0, .ucs=(unsigned short int)0x11b4 }, 
    { .keysym=(unsigned short int)0x0ee1, .ucs=(unsigned short int)0x11b5 }, 
    { .keysym=(unsigned short int)0x0ee2, .ucs=(unsigned short int)0x11b6 }, 
    { .keysym=(unsigned short int)0x0ee3, .ucs=(unsigned short int)0x11b7 }, 
    { .keysym=(unsigned short int)0x0ee4, .ucs=(unsigned short int)0x11b8 }, 
    { .keysym=(unsigned short int)0x0ee5, .ucs=(unsigned short int)0x11b9 }, 
    { .keysym=(unsigned short int)0x0ee6, .ucs=(unsigned short int)0x11ba }, 
    { .keysym=(unsigned short int)0x0ee7, .ucs=(unsigned short int)0x11bb }, 
    { .keysym=(unsigned short int)0x0ee8, .ucs=(unsigned short int)0x11bc }, 
    { .keysym=(unsigned short int)0x0ee9, .ucs=(unsigned short int)0x11bd }, 
    { .keysym=(unsigned short int)0x0eea, .ucs=(unsigned short int)0x11be }, 
    { .keysym=(unsigned short int)0x0eeb, .ucs=(unsigned short int)0x11bf }, 
    { .keysym=(unsigned short int)0x0eec, .ucs=(unsigned short int)0x11c0 }, 
    { .keysym=(unsigned short int)0x0eed, .ucs=(unsigned short int)0x11c1 }, 
    { .keysym=(unsigned short int)0x0eee, .ucs=(unsigned short int)0x11c2 }, 
    { .keysym=(unsigned short int)0x0eef, .ucs=(unsigned short int)0x316d }, 
    { .keysym=(unsigned short int)0x0ef0, .ucs=(unsigned short int)0x3171 }, 
    { .keysym=(unsigned short int)0x0ef1, .ucs=(unsigned short int)0x3178 }, 
    { .keysym=(unsigned short int)0x0ef2, .ucs=(unsigned short int)0x317f }, 
    { .keysym=(unsigned short int)0x0ef3, .ucs=(unsigned short int)0x3181 }, 
    { .keysym=(unsigned short int)0x0ef4, .ucs=(unsigned short int)0x3184 }, 
    { .keysym=(unsigned short int)0x0ef5, .ucs=(unsigned short int)0x3186 }, 
    { .keysym=(unsigned short int)0x0ef6, .ucs=(unsigned short int)0x318d }, 
    { .keysym=(unsigned short int)0x0ef7, .ucs=(unsigned short int)0x318e }, 
    { .keysym=(unsigned short int)0x0ef8, .ucs=(unsigned short int)0x11eb }, 
    { .keysym=(unsigned short int)0x0ef9, .ucs=(unsigned short int)0x11f0 }, 
    { .keysym=(unsigned short int)0x0efa, .ucs=(unsigned short int)0x11f9 }, 
    { .keysym=(unsigned short int)0x0eff, .ucs=(unsigned short int)0x20a9 }, 
    { .keysym=(unsigned short int)0x13a4, .ucs=(unsigned short int)0x20ac }, 
    { .keysym=(unsigned short int)0x13bc, .ucs=(unsigned short int)0x0152 }, 
    { .keysym=(unsigned short int)0x13bd, .ucs=(unsigned short int)0x0153 }, 
    { .keysym=(unsigned short int)0x13be, .ucs=(unsigned short int)0x0178 }, 
    { .keysym=(unsigned short int)0x20ac, .ucs=(unsigned short int)0x20ac }, 
    { .keysym=(unsigned short int)0xff80, .ucs=(unsigned short int)32 }, 
    { .keysym=(unsigned short int)0xffbd, .ucs=(unsigned short int)61 }, 
    { .keysym=(unsigned short int)0xffaa, .ucs=(unsigned short int)42 }, 
    { .keysym=(unsigned short int)0xffab, .ucs=(unsigned short int)43 }, 
    { .keysym=(unsigned short int)0xffac, .ucs=(unsigned short int)44 }, 
    { .keysym=(unsigned short int)0xffad, .ucs=(unsigned short int)45 }, 
    { .keysym=(unsigned short int)0xffae, .ucs=(unsigned short int)46 }, 
    { .keysym=(unsigned short int)0xffaf, .ucs=(unsigned short int)47 }, 
    { .keysym=(unsigned short int)0xffb0, .ucs=(unsigned short int)0x0030 }, 
    { .keysym=(unsigned short int)0xffb1, .ucs=(unsigned short int)0x0031 }, 
    { .keysym=(unsigned short int)0xffb2, .ucs=(unsigned short int)0x0032 }, 
    { .keysym=(unsigned short int)0xffb3, .ucs=(unsigned short int)0x0033 }, 
    { .keysym=(unsigned short int)0xffb4, .ucs=(unsigned short int)0x0034 }, 
    { .keysym=(unsigned short int)0xffb5, .ucs=(unsigned short int)0x0035 }, 
    { .keysym=(unsigned short int)0xffb6, .ucs=(unsigned short int)0x0036 }, 
    { .keysym=(unsigned short int)0xffb7, .ucs=(unsigned short int)0x0037 }, 
    { .keysym=(unsigned short int)0xffb8, .ucs=(unsigned short int)0x0038 }, 
    { .keysym=(unsigned short int)0xffb9, .ucs=(unsigned short int)0x0039 } };
// map_line_indices
// file heightmap.c line 342
static unsigned int map_line_indices[37762l];
// map_vertices
// file heightmap.c line 341
static float map_vertices[3l][6400l];
// mesh
// file heightmap.c line 349
static unsigned int mesh;
// mesh_vbo
// file heightmap.c line 350
static unsigned int mesh_vbo[4l];
// modelview_matrix
// file heightmap.c line 330
static float modelview_matrix[16l] = { 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f };
// optarg
// file getopt.h line 46
extern char *optarg;
// pglAttachShader
// file heightmap.c line 211
static void (*pglAttachShader)(unsigned int, unsigned int) = (void (*)(unsigned int, unsigned int))(void *)0;
// pglBindBuffer
// file heightmap.c line 240
static void (*pglBindBuffer)(unsigned int, unsigned int) = (void (*)(unsigned int, unsigned int))(void *)0;
// pglBindVertexArray
// file heightmap.c line 238
static void (*pglBindVertexArray)(unsigned int) = (void (*)(unsigned int))(void *)0;
// pglBufferData
// file heightmap.c line 239
static void (*pglBufferData)(unsigned int, signed long int, const void *, unsigned int) = (void (*)(unsigned int, signed long int, const void *, unsigned int))(void *)0;
// pglBufferSubData
// file heightmap.c line 241
static void (*pglBufferSubData)(unsigned int, signed long int, signed long int, const void *) = (void (*)(unsigned int, signed long int, signed long int, const void *))(void *)0;
// pglCompileShader
// file heightmap.c line 206
static void (*pglCompileShader)(unsigned int) = (void (*)(unsigned int))(void *)0;
// pglCreateProgram
// file heightmap.c line 210
static unsigned int (*pglCreateProgram)(void) = (unsigned int (*)(void))(void *)0;
// pglCreateShader
// file heightmap.c line 204
static unsigned int (*pglCreateShader)(unsigned int) = (unsigned int (*)(unsigned int))(void *)0;
// pglDeleteProgram
// file heightmap.c line 216
static void (*pglDeleteProgram)(unsigned int) = (void (*)(unsigned int))(void *)0;
// pglDeleteShader
// file heightmap.c line 209
static void (*pglDeleteShader)(unsigned int) = (void (*)(unsigned int))(void *)0;
// pglDeleteVertexArrays
// file heightmap.c line 203
static void (*pglDeleteVertexArrays)(signed int, unsigned int *) = (void (*)(signed int, unsigned int *))(void *)0;
// pglEnableVertexAttribArray
// file heightmap.c line 242
static void (*pglEnableVertexAttribArray)(unsigned int) = (void (*)(unsigned int))(void *)0;
// pglGenBuffers
// file heightmap.c line 201
static void (*pglGenBuffers)(signed int, unsigned int *) = (void (*)(signed int, unsigned int *))(void *)0;
// pglGenVertexArrays
// file heightmap.c line 202
static void (*pglGenVertexArrays)(signed int, unsigned int *) = (void (*)(signed int, unsigned int *))(void *)0;
// pglGetAttribLocation
// file heightmap.c line 219
static signed int (*pglGetAttribLocation)(unsigned int, const char *) = (signed int (*)(unsigned int, const char *))(void *)0;
// pglGetProgramInfoLog
// file heightmap.c line 215
static void (*pglGetProgramInfoLog)(unsigned int, signed int, signed int *, char *) = (void (*)(unsigned int, signed int, signed int *, char *))(void *)0;
// pglGetProgramiv
// file heightmap.c line 214
static void (*pglGetProgramiv)(unsigned int, unsigned int, signed int *) = (void (*)(unsigned int, unsigned int, signed int *))(void *)0;
// pglGetShaderInfoLog
// file heightmap.c line 208
static void (*pglGetShaderInfoLog)(unsigned int, signed int, signed int *, char *) = (void (*)(unsigned int, signed int, signed int *, char *))(void *)0;
// pglGetShaderiv
// file heightmap.c line 207
static void (*pglGetShaderiv)(unsigned int, unsigned int, signed int *) = (void (*)(unsigned int, unsigned int, signed int *))(void *)0;
// pglGetUniformLocation
// file heightmap.c line 217
static signed int (*pglGetUniformLocation)(unsigned int, const char *) = (signed int (*)(unsigned int, const char *))(void *)0;
// pglLinkProgram
// file heightmap.c line 212
static void (*pglLinkProgram)(unsigned int) = (void (*)(unsigned int))(void *)0;
// pglShaderSource
// file heightmap.c line 205
static void (*pglShaderSource)(unsigned int, signed int, const char **, const signed int *) = (void (*)(unsigned int, signed int, const char **, const signed int *))(void *)0;
// pglUniformMatrix4fv
// file heightmap.c line 218
static void (*pglUniformMatrix4fv)(signed int, signed int, unsigned char, const float *) = (void (*)(signed int, signed int, unsigned char, const float *))(void *)0;
// pglUseProgram
// file heightmap.c line 213
static void (*pglUseProgram)(unsigned int) = (void (*)(unsigned int))(void *)0;
// pglVertexAttribPointer
// file heightmap.c line 243
static void (*pglVertexAttribPointer)(unsigned int, signed int, unsigned int, unsigned char, signed int, const void *) = (void (*)(unsigned int, signed int, unsigned int, unsigned char, signed int, const void *))(void *)0;
// projection_matrix
// file heightmap.c line 322
static float projection_matrix[16l] = { 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f };
// running
// file heightmap.c line 647
static unsigned char running = (unsigned char)1;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// view_angle
// file heightmap.c line 316
static float view_angle = 45.0f;
// z_far
// file heightmap.c line 319
static float z_far = 100.f;
// z_near
// file heightmap.c line 318
static float z_near = 1.0f;

// BPP2RGB
// file x11_fullscreen.c line 44
static void BPP2RGB(signed int bpp, signed int *r, signed int *g, signed int *b)
{
  signed int delta;
  if(bpp == 32)
    bpp = 24;

  *b = bpp / 3;
  *g = *b;
  *r = *g;
  delta = bpp - *r * 3;
  if(delta >= 1)
    *g = *g + 1;

  if(delta == 2)
    *r = *r + 1;

}

// HalveImage
// file ../image.c line 147
static signed int HalveImage(unsigned char *src, signed int *width, signed int *height, signed int components)
{
  signed int halfwidth;
  signed int halfheight;
  signed int m;
  signed int n;
  signed int k;
  signed int idx1;
  signed int idx2;
  unsigned char *dst;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  unsigned char *tmp_post$3;
  unsigned char *tmp_post$4;
  if(!(*width >= 2))
  {
    if(*height >= 2)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(*width >= 2)
      tmp_if_expr$1 = *width / 2;

    else
      tmp_if_expr$1 = 1;
    halfwidth = tmp_if_expr$1;
    if(*height >= 2)
      tmp_if_expr$2 = *height / 2;

    else
      tmp_if_expr$2 = 1;
    halfheight = tmp_if_expr$2;
    dst = src;
    if(*width == 1)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = *height == 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      m = 0;
      for( ; !(m >= halfheight + halfwidth + -1); m = m + 1)
      {
        k = 0;
        for( ; !(k >= components); k = k + 1)
        {
          tmp_post$3 = dst;
          dst = dst + 1l;
          *tmp_post$3 = (unsigned char)((signed int)*src + (signed int)src[(signed long int)components] + 1 >> 1);
          src = src + 1l;
        }
        src = src + (signed long int)components;
      }
    }

    else
    {
      idx1 = *width * components;
      idx2 = (*width + 1) * components;
      m = 0;
      for( ; !(m >= halfheight); m = m + 1)
      {
        n = 0;
        for( ; !(n >= halfwidth); n = n + 1)
        {
          k = 0;
          for( ; !(k >= components); k = k + 1)
          {
            tmp_post$4 = dst;
            dst = dst + 1l;
            *tmp_post$4 = (unsigned char)((signed int)*src + (signed int)src[(signed long int)components] + (signed int)src[(signed long int)idx1] + (signed int)src[(signed long int)idx2] + 2 >> 2);
            src = src + 1l;
          }
          src = src + (signed long int)components;
        }
        src = src + (signed long int)(components * *width);
      }
    }
    *width = halfwidth;
    *height = halfheight;
    return 1;
  }
}

// Max
// file ../window.c line 50
static signed int Max(signed int a, signed int b)
{
  return a > b ? a : b;
}

// ReadTGAHeader
// file ../tga.c line 96
static signed int ReadTGAHeader(struct anonymous$59 *s, struct anonymous$65 *h)
{
  unsigned char buf[18l];
  signed int pos;
  signed long int return_value__glfwTellStream$1;
  return_value__glfwTellStream$1=_glfwTellStream(s);
  pos = (signed int)return_value__glfwTellStream$1;
  _glfwReadStream(s, (void *)buf, (signed long int)18);
  h->idlen = (signed int)buf[(signed long int)0];
  h->cmaptype = (signed int)buf[(signed long int)1];
  h->imagetype = (signed int)buf[(signed long int)2];
  h->cmapfirstidx = (signed int)buf[(signed long int)3] | (signed int)buf[(signed long int)4] << 8;
  h->cmaplen = (signed int)buf[(signed long int)5] | (signed int)buf[(signed long int)6] << 8;
  h->cmapentrysize = (signed int)buf[(signed long int)7];
  h->xorigin = (signed int)buf[(signed long int)8] | (signed int)buf[(signed long int)9] << 8;
  h->yorigin = (signed int)buf[(signed long int)10] | (signed int)buf[(signed long int)11] << 8;
  h->width = (signed int)buf[(signed long int)12] | (signed int)buf[(signed long int)13] << 8;
  h->height = (signed int)buf[(signed long int)14] | (signed int)buf[(signed long int)15] << 8;
  h->bitsperpixel = (signed int)buf[(signed long int)16];
  h->imageinfo = (signed int)buf[(signed long int)17];
  h->_alphabits = (signed int)(h->imageinfo & 0x0f) >> 0;
  h->_origin = (signed int)(h->imageinfo & 0x30) >> 4;
  _Bool tmp_if_expr$2;
  if(h->cmaptype == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = h->cmaptype == 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$2)
  {
    if(h->imagetype >= 1)
      tmp_if_expr$3 = h->imagetype <= 3 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if(h->imagetype >= 9)
        tmp_if_expr$4 = h->imagetype <= 11 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$6)
  {
    if(h->bitsperpixel == 8)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = h->bitsperpixel == 24 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = h->bitsperpixel == 32 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$9 = (_Bool)0;
  if(tmp_if_expr$9)
  {
    _glfwSeekStream(s, (signed long int)h->idlen, 1);
    return 1;
  }

  else
  {
    _glfwSeekStream(s, (signed long int)pos, 0);
    return 0;
  }
}

// ReadTGA_RLE
// file ../tga.c line 152
static void ReadTGA_RLE(unsigned char *buf, signed int size, signed int bpp, struct anonymous$59 *s)
{
  signed int repcount;
  signed int bytes;
  signed int k;
  signed int n;
  unsigned char pixel[4l];
  char c;
  unsigned char *tmp_post$1;
  if(!(bpp >= 5))
    for( ; size >= 1; size = size - bytes)
    {
      _glfwReadStream(s, (void *)&c, (signed long int)1);
      repcount = (signed int)(unsigned int)c;
      bytes = ((repcount & 127) + 1) * bpp;
      if(!(size >= bytes))
        bytes = size;

      if(!((128 & repcount) == 0))
      {
        _glfwReadStream(s, (void *)pixel, (signed long int)bpp);
        n = 0;
        for( ; !(n >= (127 & repcount) + 1); n = n + 1)
        {
          k = 0;
          for( ; !(k >= bpp); k = k + 1)
          {
            tmp_post$1 = buf;
            buf = buf + 1l;
            *tmp_post$1 = pixel[(signed long int)k];
          }
        }
      }

      else
      {
        _glfwReadStream(s, (void *)buf, (signed long int)bytes);
        buf = buf + (signed long int)bytes;
      }
    }

}

// RescaleImage
// file ../image.c line 214
static signed int RescaleImage(struct anonymous$60 *image)
{
  signed int width;
  signed int height;
  signed int log2;
  signed int newsize;
  unsigned char *data;
  log2 = 0;
  width = image->Width;
  for( ; width >= 2; log2 = log2 + 1)
    width = width >> 1;
  width = (signed int)1 << log2;
  if(!(width >= image->Width))
    width = width << 1;

  log2 = 0;
  height = image->Height;
  for( ; height >= 2; log2 = log2 + 1)
    height = height >> 1;
  height = (signed int)1 << log2;
  if(!(height >= image->Height))
    height = height << 1;

  _Bool tmp_if_expr$2;
  if(!(width == image->Width))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = height != image->Height ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    newsize = width * height * image->BytesPerPixel;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)newsize);
    data = (unsigned char *)return_value_malloc$1;
    if(data == ((unsigned char *)NULL))
    {
      free((void *)image->Data);
      return 0;
    }

    UpsampleImage(image->Data, data, image->Width, image->Height, width, height, image->BytesPerPixel);
    free((void *)image->Data);
    image->Data = data;
    image->Width = width;
    image->Height = height;
  }

  return 1;
}

// UpsampleImage
// file ../image.c line 75
static void UpsampleImage(unsigned char *src, unsigned char *dst, signed int w1, signed int h1, signed int w2, signed int h2, signed int bpp)
{
  signed int m;
  signed int n;
  signed int k;
  signed int x;
  signed int y;
  signed int col8;
  float dx;
  float dy;
  float xstep;
  float ystep;
  float col;
  float col1;
  float col2;
  unsigned char *src1;
  unsigned char *src2;
  unsigned char *src3;
  unsigned char *src4;
  xstep = (float)(w1 - 1) / (float)(w2 - 1);
  ystep = (float)(h1 - 1) / (float)(h2 - 1);
  dy = 0.0f;
  y = 0;
  n = 0;
  unsigned char *tmp_post$1;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  unsigned char *tmp_post$4;
  unsigned char *tmp_post$5;
  for( ; !(n >= h2); n = n + 1)
  {
    dx = 0.0f;
    src1 = &src[(signed long int)(y * w1 * bpp)];
    src3 = y < h1 - 1 ? src1 + (signed long int)(w1 * bpp) : src1;
    src2 = src1 + (signed long int)bpp;
    src4 = src3 + (signed long int)bpp;
    x = 0;
    m = 0;
    for( ; !(m >= w2); m = m + 1)
    {
      k = 0;
      for( ; !(k >= bpp); k = k + 1)
      {
        tmp_post$1 = src1;
        src1 = src1 + 1l;
        col1 = (float)*tmp_post$1;
        tmp_post$2 = src2;
        src2 = src2 + 1l;
        col2 = (float)*tmp_post$2;
        col = col1 + (col2 - col1) * dx;
        tmp_post$3 = src3;
        src3 = src3 + 1l;
        col1 = (float)*tmp_post$3;
        tmp_post$4 = src4;
        src4 = src4 + 1l;
        col2 = (float)*tmp_post$4;
        col2 = col1 + (col2 - col1) * dx;
        col = col + (col2 - col) * dy;
        col8 = (signed int)((double)col + 0.5);
        if(col8 >= 256)
          col8 = 255;

        tmp_post$5 = dst;
        dst = dst + 1l;
        *tmp_post$5 = (unsigned char)col8;
      }
      dx = dx + xstep;
      if(dx >= 1.0f)
      {
        x = x + 1;
        dx = dx - 1.0f;
        if(x >= w1 + -1)
        {
          src2 = src1;
          src4 = src3;
        }

      }

      else
      {
        src1 = src1 - (signed long int)bpp;
        src2 = src2 - (signed long int)bpp;
        src3 = src3 - (signed long int)bpp;
        src4 = src4 - (signed long int)bpp;
      }
    }
    dy = dy + ystep;
    if(dy >= 1.0f)
    {
      y = y + 1;
      dy = dy - 1.0f;
    }

  }
}

// _glfwAppendThread
// file ../thread.c line 63
void _glfwAppendThread(struct _GLFWthread_struct *t)
{
  struct _GLFWthread_struct *t_tmp = &_glfwThrd.First;
  for( ; !(t_tmp->Next == ((struct _GLFWthread_struct *)NULL)); t_tmp = t_tmp->Next)
    ;
  t_tmp->Next = t;
  t->Previous = t_tmp;
  t->Next = (struct _GLFWthread_struct *)(void *)0;
}

// _glfwChooseFBConfig
// file ../window.c line 259
const struct anonymous$0 * _glfwChooseFBConfig(const struct anonymous$0 *desired, const struct anonymous$0 *alternatives, unsigned int count)
{
  unsigned int i;
  unsigned int missing;
  unsigned int leastMissing = (unsigned int)0x7fffffff * 2U + 1U;
  unsigned int colorDiff;
  unsigned int leastColorDiff = (unsigned int)0x7fffffff * 2U + 1U;
  unsigned int extraDiff;
  unsigned int leastExtraDiff = (unsigned int)0x7fffffff * 2U + 1U;
  const struct anonymous$0 *current;
  const struct anonymous$0 *closest = (const struct anonymous$0 *)(void *)0;
  i = (unsigned int)0;
  for( ; !(i >= count); i = i + 1u)
  {
    current = alternatives + (signed long int)i;
    if(desired->stereo >= 1)
    {
      if(current->stereo == 0)
        goto __CPROVER_DUMP_L21;

    }

    missing = (unsigned int)0;
    if(desired->alphaBits >= 1)
    {
      if(current->alphaBits == 0)
        missing = missing + 1u;

    }

    if(desired->depthBits >= 1)
    {
      if(current->depthBits == 0)
        missing = missing + 1u;

    }

    if(desired->stencilBits >= 1)
    {
      if(current->stencilBits == 0)
        missing = missing + 1u;

    }

    if(desired->auxBuffers >= 1)
    {
      if(!(current->auxBuffers >= desired->auxBuffers))
        missing = missing + (unsigned int)(desired->auxBuffers - current->auxBuffers);

    }

    if(desired->samples >= 1)
    {
      if(current->samples == 0)
        missing = missing + 1u;

    }

    colorDiff = (unsigned int)0;
    if(desired->redBits >= 1)
      colorDiff = colorDiff + (unsigned int)((desired->redBits - current->redBits) * (desired->redBits - current->redBits));

    if(desired->greenBits >= 1)
      colorDiff = colorDiff + (unsigned int)((desired->greenBits - current->greenBits) * (desired->greenBits - current->greenBits));

    if(desired->blueBits >= 1)
      colorDiff = colorDiff + (unsigned int)((desired->blueBits - current->blueBits) * (desired->blueBits - current->blueBits));

    extraDiff = (unsigned int)0;
    if(desired->alphaBits >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->alphaBits - current->alphaBits) * (desired->alphaBits - current->alphaBits));

    if(desired->depthBits >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->depthBits - current->depthBits) * (desired->depthBits - current->depthBits));

    if(desired->stencilBits >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->stencilBits - current->stencilBits) * (desired->stencilBits - current->stencilBits));

    if(desired->accumRedBits >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->accumRedBits - current->accumRedBits) * (desired->accumRedBits - current->accumRedBits));

    if(desired->accumGreenBits >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->accumGreenBits - current->accumGreenBits) * (desired->accumGreenBits - current->accumGreenBits));

    if(desired->accumBlueBits >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->accumBlueBits - current->accumBlueBits) * (desired->accumBlueBits - current->accumBlueBits));

    if(desired->accumAlphaBits >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->accumAlphaBits - current->accumAlphaBits) * (desired->accumAlphaBits - current->accumAlphaBits));

    if(desired->samples >= 1)
      extraDiff = extraDiff + (unsigned int)((desired->samples - current->samples) * (desired->samples - current->samples));

    if(!(missing >= leastMissing))
      closest = current;

    else
      if(missing == leastMissing)
      {
        if(colorDiff == leastColorDiff && !(extraDiff >= leastExtraDiff) || !(colorDiff >= leastColorDiff))
          closest = current;

      }

    if(current == closest)
    {
      leastMissing = missing;
      leastColorDiff = colorDiff;
      leastExtraDiff = extraDiff;
    }


  __CPROVER_DUMP_L21:
    ;
  }
  return closest;
}

// _glfwClearInput
// file ../window.c line 98
void _glfwClearInput(void)
{
  signed int i = 0;
  for( ; !(i >= 326); i = i + 1)
    _glfwInput.Key[(signed long int)i] = (char)0;
  _glfwInput.LastChar = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    _glfwInput.MouseButton[(signed long int)i] = (char)0;
  _glfwInput.MousePosX = 0;
  _glfwInput.MousePosY = 0;
  _glfwInput.WheelPos = 0;
  _glfwInput.StickyKeys = 0;
  _glfwInput.StickyMouseButtons = 0;
  _glfwInput.KeyRepeat = 0;
}

// _glfwClearWindowHints
// file ../internal.h line 230
void _glfwClearWindowHints(void)
{
  memset((void *)&_glfwLibrary.hints, 0, sizeof(struct anonymous$56) /*56ul*/ );
  _glfwLibrary.hints.glMajor = 1;
}

// _glfwCloseStream
// file ../internal.h line 255
void _glfwCloseStream(struct anonymous$59 *stream)
{
  if(!(stream->file == ((struct _IO_FILE *)NULL)))
    fclose(stream->file);

  memset((void *)stream, 0, sizeof(struct anonymous$59) /*32ul*/ );
}

// _glfwGetClosestVideoMode
// file x11_fullscreen.c line 70
signed int _glfwGetClosestVideoMode(signed int screen, signed int *width, signed int *height, signed int *rate)
{
  signed int i;
  signed int match;
  signed int bestmatch;
  signed int sizecount;
  signed int bestsize;
  signed int ratecount;
  signed int bestrate;
  signed short int *ratelist;
  struct _XRRScreenConfiguration *sc;
  struct anonymous$38 *sizelist;
  if(!(_glfwLibrary.XRandR.available == 0))
  {
    sc=XRRGetScreenInfo(_glfwLibrary.display, (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)screen])->root);
    sizelist=XRRConfigSizes(sc, &sizecount);
    bestsize = -1;
    bestmatch = 0x7fffffff;
    i = 0;
    for( ; !(i >= sizecount); i = i + 1)
    {
      match = (*width - (sizelist + (signed long int)i)->width) * (*width - (sizelist + (signed long int)i)->width) + (*height - (sizelist + (signed long int)i)->height) * (*height - (sizelist + (signed long int)i)->height);
      if(!(match >= bestmatch))
      {
        bestmatch = match;
        bestsize = i;
      }

    }
    if(!(bestsize == -1))
    {
      *width = (sizelist + (signed long int)bestsize)->width;
      *height = (sizelist + (signed long int)bestsize)->height;
      if(*rate >= 1)
      {
        ratelist=XRRConfigRates(sc, bestsize, &ratecount);
        bestrate = -1;
        bestmatch = 0x7fffffff;
        i = 0;
        for( ; !(i >= ratecount); i = i + 1)
        {
          match=abs((signed int)ratelist[(signed long int)i] - *rate);
          if(!(match >= bestmatch))
          {
            bestmatch = match;
            bestrate = (signed int)ratelist[(signed long int)i];
          }

        }
        if(!(bestrate == -1))
          *rate = bestrate;

      }

    }

    XRRFreeScreenConfigInfo(sc);
    if(bestsize == -1)
      goto __CPROVER_DUMP_L8;

    return bestsize;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    *width = (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)screen])->width;
    *height = (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)screen])->height;
    return 0;
  }
}

// _glfwGetThreadPointer
// file ../thread.c line 43
struct _GLFWthread_struct * _glfwGetThreadPointer(signed int ID)
{
  struct _GLFWthread_struct *t = &_glfwThrd.First;
  for( ; !(t == ((struct _GLFWthread_struct *)NULL)); t = t->Next)
    if(t->ID == ID)
      break;

  return t;
}

// _glfwInitJoysticks
// file ./platform.h line 522
void _glfwInitJoysticks(void)
{
  signed int k;
  signed int n;
  signed int fd;
  signed int joy_count;
  char *joy_base_name;
  char joy_dev_name[20l];
  signed int driver_version = 0x000800;
  char ret_data;
  signed int i = 0;
  for( ; !(i >= 16); i = i + 1)
    _glfwJoy[(signed long int)i].Present = 0;
  joy_count = 0;
  k = 0;
  for( ; !(joy_count >= 16) && !(k >= 2); k = k + 1)
  {
    switch(k)
    {
      case 0:
      {
        joy_base_name = "/dev/input/js";
        break;
      }
      case 1:
      {
        joy_base_name = "/dev/js";
        break;
      }
      default:
        goto __CPROVER_DUMP_L17;
    }
    i = 0;
    for( ; !(i >= 51) && !(joy_count >= 16); i = i + 1)
    {
      sprintf(joy_dev_name, "%s%d", joy_base_name, i);
      fd=open(joy_dev_name, 04000);
      if(!(fd == -1))
      {
        _glfwJoy[(signed long int)joy_count].fd = fd;
        ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(106 << 0 + 8) | (unsigned int)(0x01 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &driver_version);
        if(!(driver_version >= 0x010000))
          close(fd);

        else
        {
          ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(106 << 0 + 8) | (unsigned int)(0x11 << 0)) | sizeof(char) /*1ul*/  << 0 + 8 + 8, &ret_data);
          _glfwJoy[(signed long int)joy_count].NumAxes = (signed int)ret_data;
          ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(106 << 0 + 8) | (unsigned int)(0x12 << 0)) | sizeof(char) /*1ul*/  << 0 + 8 + 8, &ret_data);
          _glfwJoy[(signed long int)joy_count].NumButtons = (signed int)ret_data;
          void *return_value_malloc$1;
          return_value_malloc$1=malloc(sizeof(float) /*4ul*/  * (unsigned long int)_glfwJoy[(signed long int)joy_count].NumAxes);
          _glfwJoy[(signed long int)joy_count].Axis = (float *)return_value_malloc$1;
          if(_glfwJoy[(signed long int)joy_count].Axis == ((float *)NULL))
            close(fd);

          else
          {
            void *return_value_malloc$2;
            return_value_malloc$2=malloc(sizeof(char) /*1ul*/  * (unsigned long int)_glfwJoy[(signed long int)joy_count].NumButtons);
            _glfwJoy[(signed long int)joy_count].Button = (unsigned char *)return_value_malloc$2;
            if(_glfwJoy[(signed long int)joy_count].Button == ((unsigned char *)NULL))
            {
              free((void *)_glfwJoy[(signed long int)joy_count].Axis);
              close(fd);
            }

            else
            {
              n = 0;
              for( ; !(n >= _glfwJoy[(signed long int)joy_count].NumAxes); n = n + 1)
                _glfwJoy[(signed long int)joy_count].Axis[(signed long int)n] = 0.0f;
              n = 0;
              for( ; !(n >= _glfwJoy[(signed long int)joy_count].NumButtons); n = n + 1)
                _glfwJoy[(signed long int)joy_count].Button[(signed long int)n] = (unsigned char)0;
              _glfwJoy[(signed long int)joy_count].Present = 1;
              joy_count = joy_count + 1;
            }
          }
        }
      }

    }

  __CPROVER_DUMP_L17:
    ;
  }
}

// _glfwInitTimer
// file ./platform.h line 513
void _glfwInitTimer(void)
{
  struct timespec ts;
  signed int return_value_clock_gettime$1;
  return_value_clock_gettime$1=clock_gettime(1, &ts);
  if(return_value_clock_gettime$1 == 0)
  {
    _glfwLibrary.Timer.monotonic = (unsigned char)1;
    _glfwLibrary.Timer.resolution = 1e-9;
  }

  else
    _glfwLibrary.Timer.resolution = 1e-6;
  unsigned long int return_value_getRawTime$2;
  return_value_getRawTime$2=getRawTime();
  _glfwLibrary.Timer.base = (signed long long int)return_value_getRawTime$2;
}

// _glfwInputChar
// file ../window.c line 176
void _glfwInputChar(signed int character, signed int action)
{
  signed int keyrepeat = 0;
  if(character >= 160 || !(character >= 127) && character >= 32)
  {
    if(_glfwInput.LastChar == character && action == 1)
      keyrepeat = 1;

    if(action == 1)
      _glfwInput.LastChar = character;

    else
      _glfwInput.LastChar = 0;
    if(action == 1)
    {
      if(!(_glfwWin.charCallback == ((void (*)(signed int, signed int))NULL)) && (keyrepeat == 0 || !(_glfwInput.KeyRepeat == 0)))
        _glfwWin.charCallback(character, action);

    }

  }

}

// _glfwInputDeactivation
// file ../window.c line 70
void _glfwInputDeactivation(void)
{
  signed int i = 0;
  for( ; !(i >= 326); i = i + 1)
    if((signed int)_glfwInput.Key[(signed long int)i] == 1)
      _glfwInputKey(i, 0);

  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if((signed int)_glfwInput.MouseButton[(signed long int)i] == 1)
      _glfwInputMouseClick(i, 0);

}

// _glfwInputKey
// file ../window.c line 137
void _glfwInputKey(signed int key, signed int action)
{
  signed int keyrepeat = 0;
  if(!(key >= 326) && key >= 0)
  {
    if(action == 0)
    {
      if((signed int)_glfwInput.Key[(signed long int)key] == 1)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(action == 0 && !(_glfwInput.StickyKeys == 0))
        _glfwInput.Key[(signed long int)key] = (char)2;

      else
      {
        keyrepeat = (signed int)((signed int)_glfwInput.Key[(signed long int)key] == 1 ? (action == 1 ? (_Bool)1 : (_Bool)0) : (_Bool)0);
        _glfwInput.Key[(signed long int)key] = (char)action;
      }
      if(!(_glfwWin.keyCallback == ((void (*)(signed int, signed int))NULL)) && (keyrepeat == 0 || !(_glfwInput.KeyRepeat == 0)))
        _glfwWin.keyCallback(key, action);

    }
  }

}

// _glfwInputMouseClick
// file ../window.c line 231
void _glfwInputMouseClick(signed int button, signed int action)
{
  if(button >= 0 && !(button >= 8))
  {
    if(action == 0 && !(_glfwInput.StickyMouseButtons == 0))
      _glfwInput.MouseButton[(signed long int)button] = (char)2;

    else
      _glfwInput.MouseButton[(signed long int)button] = (char)action;
    if(!(_glfwWin.mouseButtonCallback == ((void (*)(signed int, signed int))NULL)))
      _glfwWin.mouseButtonCallback(button, action);

  }

}

// _glfwKeySym2Unicode
// file x11_keysym2unicode.c line 862
signed long int _glfwKeySym2Unicode(unsigned long int keysym)
{
  signed int min = 0;
  signed int max = (signed int)(sizeof(struct codepair [776l]) /*3104ul*/  / sizeof(struct codepair) /*4ul*/  - (unsigned long int)1);
  signed int mid;
  if(keysym >= 32ul && !(keysym >= 127ul) || keysym >= 160ul && !(keysym >= 256ul))
    return (signed long int)keysym;

  else
    if((4278190080ul & keysym) == 16777216ul)
      return (signed long int)(keysym & (unsigned long int)0x00ffffff);

    else
    {
      while(max >= min)
      {
        mid = (min + max) / 2;
        if(!((unsigned long int)keysymtab[(signed long int)mid].keysym >= keysym))
          min = mid + 1;

        else
          if(!(keysym >= (unsigned long int)keysymtab[(signed long int)mid].keysym))
            max = mid - 1;

          else
            return (signed long int)keysymtab[(signed long int)mid].ucs;
      }
      return (signed long int)-1;
    }
}

// _glfwNewThread
// file x11_thread.c line 45
void * _glfwNewThread(void *arg)
{
  void (*threadfun)(void *);
  struct _GLFWthread_struct *t;
  unsigned long int posixID;
  posixID=pthread_self();
  pthread_mutex_lock(&_glfwThrd.CriticalSection);
  t = &_glfwThrd.First;
  for( ; !(t == ((struct _GLFWthread_struct *)NULL)); t = t->Next)
    if(t->PosixID == posixID)
      break;

  if(t == ((struct _GLFWthread_struct *)NULL))
  {
    pthread_mutex_unlock(&_glfwThrd.CriticalSection);
    return (void *)0;
  }

  else
  {
    threadfun = t->Function;
    pthread_mutex_unlock(&_glfwThrd.CriticalSection);
    threadfun(arg);
    pthread_mutex_lock(&_glfwThrd.CriticalSection);
    _glfwRemoveThread(t);
    pthread_mutex_unlock(&_glfwThrd.CriticalSection);
    return (void *)0;
  }
}

// _glfwOpenBufferStream
// file ../internal.h line 251
signed int _glfwOpenBufferStream(struct anonymous$59 *stream, void *data, signed long int size)
{
  memset((void *)stream, 0, sizeof(struct anonymous$59) /*32ul*/ );
  stream->data = data;
  stream->size = size;
  return 1;
}

// _glfwOpenFileStream
// file ../internal.h line 250
signed int _glfwOpenFileStream(struct anonymous$59 *stream, const char *name, const char *mode)
{
  memset((void *)stream, 0, sizeof(struct anonymous$59) /*32ul*/ );
  stream->file=fopen(name, mode);
  if(stream->file == ((struct _IO_FILE *)NULL))
    return 0;

  else
    return 1;
}

// _glfwParseGLVersion
// file ../glext.c line 54
void _glfwParseGLVersion(signed int *major, signed int *minor, signed int *rev)
{
  unsigned int _major;
  unsigned int _minor = (unsigned int)0;
  unsigned int _rev = (unsigned int)0;
  const unsigned char *version;
  const unsigned char *ptr;
  version=glGetString((unsigned int)0x1F02);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!(version == ((const unsigned char *)NULL)))
  {
    ptr = version;
    _major = (unsigned int)0;
    do
    {
      if((signed int)*ptr >= 48)
        tmp_if_expr$1 = (signed int)*ptr <= 57 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      _major = (unsigned int)10 * _major + (unsigned int)((signed int)*ptr - 48);
      ptr = ptr + 1l;
    }
    while((_Bool)1);
    if((signed int)*ptr == 46)
    {
      ptr = ptr + 1l;
      _minor = (unsigned int)0;
      do
      {
        if((signed int)*ptr >= 48)
          tmp_if_expr$2 = (signed int)*ptr <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        _minor = (unsigned int)10 * _minor + (unsigned int)((signed int)*ptr - 48);
        ptr = ptr + 1l;
      }
      while((_Bool)1);
      if((signed int)*ptr == 46)
      {
        ptr = ptr + 1l;
        _rev = (unsigned int)0;
        do
        {
          if((signed int)*ptr >= 48)
            tmp_if_expr$3 = (signed int)*ptr <= 57 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(!tmp_if_expr$3)
            break;

          _rev = (unsigned int)10 * _rev + (unsigned int)((signed int)*ptr - 48);
          ptr = ptr + 1l;
        }
        while((_Bool)1);
      }

    }

    *major = (signed int)_major;
    *minor = (signed int)_minor;
    *rev = (signed int)_rev;
  }

}

// _glfwPlatformBroadcastCond
// file ../internal.h line 199
void _glfwPlatformBroadcastCond(void *cond)
{
  pthread_cond_broadcast((union anonymous$1 *)cond);
}

// _glfwPlatformCloseWindow
// file ../internal.h line 209
void _glfwPlatformCloseWindow(void)
{
  if(!(_glfwWin.fullscreen == 0))
    leaveFullscreenMode();

  if(!(_glfwWin.context == ((struct __GLXcontextRec *)NULL)))
  {
    glXMakeCurrent(_glfwLibrary.display, (unsigned long int)0L, (struct __GLXcontextRec *)(void *)0);
    glXDestroyContext(_glfwLibrary.display, _glfwWin.context);
    _glfwWin.context = (struct __GLXcontextRec *)(void *)0;
  }

  if(!(_glfwWin.visual == ((struct anonymous$49 *)NULL)))
  {
    XFree((void *)_glfwWin.visual);
    _glfwWin.visual = (struct anonymous$49 *)(void *)0;
  }

  if(!(_glfwWin.window == 0ul))
  {
    XUnmapWindow(_glfwLibrary.display, _glfwWin.window);
    XDestroyWindow(_glfwLibrary.display, _glfwWin.window);
    _glfwWin.window = (unsigned long int)0;
  }

  if(!(_glfwWin.colormap == 0ul))
  {
    XFreeColormap(_glfwLibrary.display, _glfwWin.colormap);
    _glfwWin.colormap = (unsigned long int)0;
  }

  if(!(_glfwWin.cursor == 0ul))
  {
    XFreeCursor(_glfwLibrary.display, _glfwWin.cursor);
    _glfwWin.cursor = (unsigned long int)0;
  }

  XFlush(_glfwLibrary.display);
}

// _glfwPlatformCreateCond
// file ../internal.h line 195
void * _glfwPlatformCreateCond(void)
{
  union anonymous$1 *cond;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(union anonymous$1) /*48ul*/ );
  cond = (union anonymous$1 *)return_value_malloc$1;
  if(cond == ((union anonymous$1 *)NULL))
    return (void *)0;

  else
  {
    pthread_cond_init(cond, (const union anonymous$2 *)(void *)0);
    return (void *)cond;
  }
}

// _glfwPlatformCreateMutex
// file ../internal.h line 191
void * _glfwPlatformCreateMutex(void)
{
  union anonymous$62 *mutex;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(union anonymous$62) /*40ul*/ );
  mutex = (union anonymous$62 *)return_value_malloc$1;
  if(mutex == ((union anonymous$62 *)NULL))
    return (void *)0;

  else
  {
    pthread_mutex_init(mutex, (const union anonymous$2 *)(void *)0);
    return (void *)mutex;
  }
}

// _glfwPlatformCreateThread
// file ../internal.h line 187
signed int _glfwPlatformCreateThread(void (*fun)(void *), void *arg)
{
  signed int ID;
  struct _GLFWthread_struct *t;
  signed int result;
  pthread_mutex_lock(&_glfwThrd.CriticalSection);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _GLFWthread_struct) /*40ul*/ );
  t = (struct _GLFWthread_struct *)return_value_malloc$1;
  signed int tmp_post$2;
  if(t == ((struct _GLFWthread_struct *)NULL))
  {
    pthread_mutex_unlock(&_glfwThrd.CriticalSection);
    return -1;
  }

  else
  {
    tmp_post$2 = _glfwThrd.NextID;
    _glfwThrd.NextID = _glfwThrd.NextID + 1;
    ID = tmp_post$2;
    t->Function = fun;
    t->ID = ID;
    result=pthread_create(&t->PosixID, (const union pthread_attr_t *)(void *)0, _glfwNewThread, (void *)arg);
    if(!(result == 0))
    {
      free((void *)t);
      pthread_mutex_unlock(&_glfwThrd.CriticalSection);
      return -1;
    }

    else
    {
      _glfwAppendThread(t);
      pthread_mutex_unlock(&_glfwThrd.CriticalSection);
      return ID;
    }
  }
}

// _glfwPlatformDestroyCond
// file ../internal.h line 196
void _glfwPlatformDestroyCond(void *cond)
{
  pthread_cond_destroy((union anonymous$1 *)cond);
  free((void *)cond);
}

// _glfwPlatformDestroyMutex
// file ../internal.h line 192
void _glfwPlatformDestroyMutex(void *mutex)
{
  pthread_mutex_destroy((union anonymous$62 *)mutex);
  free((void *)mutex);
}

// _glfwPlatformDestroyThread
// file ../internal.h line 188
void _glfwPlatformDestroyThread(signed int ID)
{
  struct _GLFWthread_struct *t;
  pthread_mutex_lock(&_glfwThrd.CriticalSection);
  t=_glfwGetThreadPointer(ID);
  if(t == ((struct _GLFWthread_struct *)NULL))
    pthread_mutex_unlock(&_glfwThrd.CriticalSection);

  else
  {
    pthread_kill(t->PosixID, 9);
    _glfwRemoveThread(t);
    pthread_mutex_unlock(&_glfwThrd.CriticalSection);
  }
}

// _glfwPlatformDisableSystemKeys
// file ../internal.h line 171
void _glfwPlatformDisableSystemKeys(void)
{
  signed int return_value_XGrabKeyboard$1;
  return_value_XGrabKeyboard$1=XGrabKeyboard(_glfwLibrary.display, _glfwWin.window, 1, 1, 1, (unsigned long int)0L);
  if(return_value_XGrabKeyboard$1 == 0)
    _glfwWin.keyboardGrabbed = (unsigned char)1;

}

// _glfwPlatformEnableSystemKeys
// file ../internal.h line 170
void _glfwPlatformEnableSystemKeys(void)
{
  if(!(_glfwWin.keyboardGrabbed == 0))
  {
    XUngrabKeyboard(_glfwLibrary.display, (unsigned long int)0L);
    _glfwWin.keyboardGrabbed = (unsigned char)0;
  }

}

// _glfwPlatformExtensionSupported
// file ../internal.h line 178
signed int _glfwPlatformExtensionSupported(const char *extension)
{
  const unsigned char *extensions;
  const char *return_value_glXQueryExtensionsString$1;
  return_value_glXQueryExtensionsString$1=glXQueryExtensionsString(_glfwLibrary.display, _glfwWin.screen);
  extensions = (const unsigned char *)return_value_glXQueryExtensionsString$1;
  if(!(extensions == ((const unsigned char *)NULL)))
  {
    signed int return_value__glfwStringInExtensionString$2;
    return_value__glfwStringInExtensionString$2=_glfwStringInExtensionString(extension, extensions);
    if(!(return_value__glfwStringInExtensionString$2 == 0))
      return 1;

  }

  return 0;
}

// _glfwPlatformGetDesktopMode
// file x11_fullscreen.c line 508
void _glfwPlatformGetDesktopMode(struct anonymous$57 *mode)
{
  struct _XDisplay *dpy;
  signed int bpp;
  signed int screen;
  dpy = _glfwLibrary.display;
  screen = ((struct anonymous$50 *)dpy)->default_screen;
  bpp = (&((struct anonymous$50 *)dpy)->screens[(signed long int)screen])->root_depth;
  BPP2RGB(bpp, &mode->RedBits, &mode->GreenBits, &mode->BlueBits);
  if(!(_glfwLibrary.XRandR.available == 0))
  {
    if(_glfwWin.FS.modeChanged == 0)
      goto __CPROVER_DUMP_L1;

    mode->Width = _glfwWin.FS.oldWidth;
    mode->Height = _glfwWin.FS.oldHeight;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    mode->Width = (&((struct anonymous$50 *)dpy)->screens[(signed long int)screen])->width;
    mode->Height = (&((struct anonymous$50 *)dpy)->screens[(signed long int)screen])->height;
  }
}

// _glfwPlatformGetJoystickButtons
// file ../internal.h line 184
signed int _glfwPlatformGetJoystickButtons(signed int joy, unsigned char *buttons, signed int numbuttons)
{
  signed int i;
  if(_glfwJoy[(signed long int)joy].Present == 0)
    return 0;

  else
  {
    pollJoystickEvents();
    if(!(_glfwJoy[(signed long int)joy].NumButtons >= numbuttons))
      numbuttons = _glfwJoy[(signed long int)joy].NumButtons;

    i = 0;
    for( ; !(i >= numbuttons); i = i + 1)
      buttons[(signed long int)i] = _glfwJoy[(signed long int)joy].Button[(signed long int)i];
    return numbuttons;
  }
}

// _glfwPlatformGetJoystickParam
// file ../internal.h line 182
signed int _glfwPlatformGetJoystickParam(signed int joy, signed int param)
{
  if(_glfwJoy[(signed long int)joy].Present == 0)
    return 0;

  else
    switch(param)
    {
      case 0x00050001:
        return 1;
      case 0x00050002:
        return _glfwJoy[(signed long int)joy].NumAxes;
      case 0x00050003:
        return _glfwJoy[(signed long int)joy].NumButtons;
      default:
        return 0;
    }
}

// _glfwPlatformGetJoystickPos
// file ../internal.h line 183
signed int _glfwPlatformGetJoystickPos(signed int joy, float *pos, signed int numaxes)
{
  signed int i;
  if(_glfwJoy[(signed long int)joy].Present == 0)
    return 0;

  else
  {
    pollJoystickEvents();
    if(!(_glfwJoy[(signed long int)joy].NumAxes >= numaxes))
      numaxes = _glfwJoy[(signed long int)joy].NumAxes;

    i = 0;
    for( ; !(i >= numaxes); i = i + 1)
      pos[(signed long int)i] = _glfwJoy[(signed long int)joy].Axis[(signed long int)i];
    return numaxes;
  }
}

// _glfwPlatformGetNumberOfProcessors
// file ../internal.h line 200
signed int _glfwPlatformGetNumberOfProcessors(void)
{
  signed int n;
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(84);
  n = (signed int)return_value_sysconf$1;
  return n;
}

// _glfwPlatformGetProcAddress
// file ../internal.h line 179
void * _glfwPlatformGetProcAddress(const char *procname)
{
  void (*return_value_glXGetProcAddress$1)(void);
  return_value_glXGetProcAddress$1=glXGetProcAddress((const unsigned char *)procname);
  return (void *)return_value_glXGetProcAddress$1;
}

// _glfwPlatformGetThreadID
// file ../internal.h line 190
signed int _glfwPlatformGetThreadID(void)
{
  struct _GLFWthread_struct *t;
  signed int ID = -1;
  unsigned long int posixID;
  posixID=pthread_self();
  pthread_mutex_lock(&_glfwThrd.CriticalSection);
  t = &_glfwThrd.First;
  for( ; !(t == ((struct _GLFWthread_struct *)NULL)); t = t->Next)
    if(t->PosixID == posixID)
    {
      ID = t->ID;
      break;
    }

  pthread_mutex_unlock(&_glfwThrd.CriticalSection);
  return ID;
}

// _glfwPlatformGetTime
// file ../internal.h line 203
double _glfwPlatformGetTime(void)
{
  unsigned long int return_value_getRawTime$1;
  return_value_getRawTime$1=getRawTime();
  return (double)(return_value_getRawTime$1 - (unsigned long int)_glfwLibrary.Timer.base) * _glfwLibrary.Timer.resolution;
}

// _glfwPlatformGetVideoModes
// file ../internal.h line 174
signed int _glfwPlatformGetVideoModes(struct anonymous$57 *list, signed int maxcount)
{
  signed int count;
  signed int k;
  signed int l;
  signed int r;
  signed int g;
  signed int b;
  signed int rgba;
  signed int gl;
  signed int depth;
  signed int screen;
  struct _XDisplay *dpy;
  struct anonymous$49 *vislist;
  struct anonymous$49 dummy;
  signed int viscount;
  signed int rgbcount;
  signed int rescount;
  signed int *rgbarray;
  struct _glfwResolution *resarray;
  dpy = _glfwLibrary.display;
  screen = ((struct anonymous$50 *)dpy)->default_screen;
  vislist=XGetVisualInfo(dpy, (signed long int)0, &dummy, &viscount);
  if(vislist == ((struct anonymous$49 *)NULL))
    return 0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)viscount);
    rgbarray = (signed int *)return_value_malloc$1;
    rgbcount = 0;
    k = 0;
    for( ; !(k >= viscount); k = k + 1)
    {
      glXGetConfig(dpy, &vislist[(signed long int)k], 1, &gl);
      glXGetConfig(dpy, &vislist[(signed long int)k], 4, &rgba);
      if(!(gl == 0) && !(rgba == 0))
      {
        depth = (vislist + (signed long int)k)->depth;
        BPP2RGB(depth, &r, &g, &b);
        depth = r << 16 | g << 8 | b;
        l = 0;
        for( ; !(l >= rgbcount); l = l + 1)
          if(depth == rgbarray[(signed long int)l])
            break;

        if(l >= rgbcount)
        {
          rgbarray[(signed long int)rgbcount] = depth;
          rgbcount = rgbcount + 1;
        }

      }

    }
    rescount = 0;
    resarray = (struct _glfwResolution *)(void *)0;
    if(!(_glfwLibrary.XRandR.available == 0))
    {
      struct _XRRScreenConfiguration *sc;
      struct anonymous$38 *sizelist;
      signed int sizecount;
      sc=XRRGetScreenInfo(dpy, (&((struct anonymous$50 *)dpy)->screens[(signed long int)screen])->root);
      sizelist=XRRConfigSizes(sc, &sizecount);
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct _glfwResolution) /*8ul*/  * (unsigned long int)sizecount);
      resarray = (struct _glfwResolution *)return_value_malloc$2;
      k = 0;
      for( ; !(k >= sizecount); k = k + 1)
      {
        (resarray + (signed long int)rescount)->width = (sizelist + (signed long int)k)->width;
        (resarray + (signed long int)rescount)->height = (sizelist + (signed long int)k)->height;
        rescount = rescount + 1;
      }
      XRRFreeScreenConfigInfo(sc);
    }

    if(resarray == ((struct _glfwResolution *)NULL))
    {
      rescount = 1;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct _glfwResolution) /*8ul*/  * (unsigned long int)rescount);
      resarray = (struct _glfwResolution *)return_value_malloc$3;
      (resarray + (signed long int)0)->width = (&((struct anonymous$50 *)dpy)->screens[(signed long int)screen])->width;
      (resarray + (signed long int)0)->height = (&((struct anonymous$50 *)dpy)->screens[(signed long int)screen])->height;
    }

    count = 0;
    k = 0;
    for( ; !(count >= maxcount) && !(k >= rgbcount); k = k + 1)
    {
      l = 0;
      for( ; !(count >= maxcount) && !(l >= rescount); l = l + 1)
      {
        (list + (signed long int)count)->Width = (resarray + (signed long int)l)->width;
        (list + (signed long int)count)->Height = (resarray + (signed long int)l)->height;
        (list + (signed long int)count)->RedBits = rgbarray[(signed long int)k] >> 16 & 255;
        (list + (signed long int)count)->GreenBits = rgbarray[(signed long int)k] >> 8 & 255;
        (list + (signed long int)count)->BlueBits = rgbarray[(signed long int)k] & 255;
        count = count + 1;
      }
    }
    XFree((void *)vislist);
    free((void *)resarray);
    free((void *)rgbarray);
    return count;
  }
}

// _glfwPlatformHideMouseCursor
// file ../internal.h line 220
void _glfwPlatformHideMouseCursor(void)
{
  if(_glfwWin.pointerHidden == 0)
  {
    XDefineCursor(_glfwLibrary.display, _glfwWin.window, _glfwWin.cursor);
    _glfwWin.pointerHidden = (unsigned char)1;
  }

  if(_glfwWin.pointerGrabbed == 0)
  {
    signed int return_value_XGrabPointer$1;
    return_value_XGrabPointer$1=XGrabPointer(_glfwLibrary.display, _glfwWin.window, 1, (unsigned int)(1L << 2 | 1L << 3 | 1L << 6), 1, 1, _glfwWin.window, (unsigned long int)0L, (unsigned long int)0L);
    if(return_value_XGrabPointer$1 == 0)
      _glfwWin.pointerGrabbed = (unsigned char)1;

  }

  _glfwPlatformSetMouseCursorPos(_glfwWin.width / 2, _glfwWin.height / 2);
}

// _glfwPlatformIconifyWindow
// file ../internal.h line 213
void _glfwPlatformIconifyWindow(void)
{
  if(_glfwWin.overrideRedirect == 0)
    XIconifyWindow(_glfwLibrary.display, _glfwWin.window, _glfwWin.screen);

}

// _glfwPlatformInit
// file ../internal.h line 166
signed int _glfwPlatformInit(void)
{
  signed int return_value_initDisplay$1;
  return_value_initDisplay$1=initDisplay();
  if(return_value_initDisplay$1 == 0)
    return 0;

  else
  {
    initThreads();
    initLibraries();
    _glfwPlatformGetDesktopMode(&_glfwLibrary.desktopMode);
    atexit(glfw_atexit);
    _glfwInitJoysticks();
    _glfwInitTimer();
    return 1;
  }
}

// _glfwPlatformLockMutex
// file ../internal.h line 193
void _glfwPlatformLockMutex(void *mutex)
{
  pthread_mutex_lock((union anonymous$62 *)mutex);
}

// _glfwPlatformOpenWindow
// file ../internal.h line 208
signed int _glfwPlatformOpenWindow(signed int width, signed int height, const struct anonymous *wndconfig, const struct anonymous$0 *fbconfig)
{
  struct anonymous$0 closest;
  _glfwWin.refreshRate = wndconfig->refreshRate;
  _glfwWin.windowNoResize = wndconfig->windowNoResize;
  _glfwWin.screen = ((struct anonymous$50 *)_glfwLibrary.display)->default_screen;
  _glfwWin.root = (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)_glfwWin.screen])->root;
  _glfwWin.cursor=createNULLCursor(_glfwLibrary.display, _glfwWin.root);
  initGLXExtensions();
  unsigned int fbcount;
  struct anonymous$0 *fbconfigs;
  const struct anonymous$0 *result;
  fbconfigs=getFBConfigs(&fbcount);
  if(fbconfigs == ((struct anonymous$0 *)NULL))
    return 0;

  else
  {
    result=_glfwChooseFBConfig(fbconfig, fbconfigs, fbcount);
    if(result == ((const struct anonymous$0 *)NULL))
    {
      free((void *)fbconfigs);
      return 0;
    }

    else
    {
      closest = *result;
      free((void *)fbconfigs);
      signed int return_value_createContext$1;
      return_value_createContext$1=createContext(wndconfig, (unsigned long int)closest.platformID);
      if(return_value_createContext$1 == 0)
        return 0;

      else
      {
        unsigned char return_value_createWindow$2;
        return_value_createWindow$2=createWindow(width, height, wndconfig);
        if(return_value_createWindow$2 == 0)
          return 0;

        else
        {
          if(wndconfig->mode == 0x00010002)
          {
            if(!(_glfwLibrary.XRandR.available == 0))
              XRRSelectInput(_glfwLibrary.display, _glfwWin.window, (signed int)(1L << 0));

            enterFullscreenMode();
          }

          _glfwPlatformPollEvents();
          unsigned long int window;
          unsigned long int root;
          signed int windowX;
          signed int windowY;
          signed int rootX;
          signed int rootY;
          unsigned int mask;
          XQueryPointer(_glfwLibrary.display, _glfwWin.window, &root, &window, &rootX, &rootY, &windowX, &windowY, &mask);
          _glfwInput.MousePosX = windowX;
          _glfwInput.MousePosY = windowY;
          glXMakeCurrent(_glfwLibrary.display, _glfwWin.window, _glfwWin.context);
          return 1;
        }
      }
    }
  }
}

// _glfwPlatformPollEvents
// file ../internal.h line 218
void _glfwPlatformPollEvents(void)
{
  unsigned char closeRequested = (unsigned char)0;
  _glfwInput.MouseMoved = 0;
  signed int return_value_XPending$1;
  do
  {
    return_value_XPending$1=XPending(_glfwLibrary.display);
    if(return_value_XPending$1 == 0)
      break;

    unsigned char return_value_processSingleEvent$2;
    return_value_processSingleEvent$2=processSingleEvent();
    if(!(return_value_processSingleEvent$2 == 0))
      closeRequested = (unsigned char)1;

  }
  while((_Bool)1);
  if(!(_glfwInput.MouseMoved == 0) && !(_glfwWin.pointerHidden == 0))
  {
    _glfwPlatformSetMouseCursorPos(_glfwWin.width / 2, _glfwWin.height / 2);
    XFlush(_glfwLibrary.display);
  }

  if(!(_glfwWin.windowCloseCallback == ((signed int (*)(void))NULL)) && !(closeRequested == 0))
  {
    signed int return_value;
    return_value=_glfwWin.windowCloseCallback();
    closeRequested = (unsigned char)return_value;
  }

  if(!(closeRequested == 0))
    glfwCloseWindow();

}

// _glfwPlatformRefreshWindowParams
// file ../internal.h line 217
void _glfwPlatformRefreshWindowParams(void)
{
  signed int dummy;
  struct __GLXFBConfigRec **fbconfig;
  struct _XRRScreenConfiguration *sc;
  signed int attribs[3l] = { 0x8013, (signed int)_glfwWin.fbconfigID, (signed int)0L };
  if(!(_glfwWin.has_GLX_SGIX_fbconfig == 0))
    fbconfig=_glfwWin.ChooseFBConfigSGIX(_glfwLibrary.display, _glfwWin.screen, attribs, &dummy);

  else
    fbconfig=glXChooseFBConfig(_glfwLibrary.display, _glfwWin.screen, attribs, &dummy);
  if(fbconfig == ((struct __GLXFBConfigRec **)NULL))
  {
    fprintf(stderr, "Cannot find known GLXFBConfig by ID. This cannot happen. Have a nice day.\n");
    abort();
  }

  _glfwWin.accelerated = 1;
  _glfwWin.redBits=getFBConfigAttrib(*fbconfig, 8);
  _glfwWin.greenBits=getFBConfigAttrib(*fbconfig, 9);
  _glfwWin.blueBits=getFBConfigAttrib(*fbconfig, 10);
  _glfwWin.alphaBits=getFBConfigAttrib(*fbconfig, 11);
  _glfwWin.depthBits=getFBConfigAttrib(*fbconfig, 12);
  _glfwWin.stencilBits=getFBConfigAttrib(*fbconfig, 13);
  _glfwWin.accumRedBits=getFBConfigAttrib(*fbconfig, 14);
  _glfwWin.accumGreenBits=getFBConfigAttrib(*fbconfig, 15);
  _glfwWin.accumBlueBits=getFBConfigAttrib(*fbconfig, 16);
  _glfwWin.accumAlphaBits=getFBConfigAttrib(*fbconfig, 17);
  _glfwWin.auxBuffers=getFBConfigAttrib(*fbconfig, 7);
  signed int return_value_getFBConfigAttrib$1;
  return_value_getFBConfigAttrib$1=getFBConfigAttrib(*fbconfig, 6);
  _glfwWin.stereo = return_value_getFBConfigAttrib$1 != 0 ? 1 : 0;
  if(!(_glfwWin.has_GLX_ARB_multisample == 0))
    _glfwWin.samples=getFBConfigAttrib(*fbconfig, 0x186a1);

  else
    _glfwWin.samples = 0;
  _glfwWin.refreshRate = 0;
  if(!(_glfwLibrary.XRandR.available == 0))
  {
    sc=XRRGetScreenInfo(_glfwLibrary.display, _glfwWin.root);
    signed short int return_value_XRRConfigCurrentRate$2;
    return_value_XRRConfigCurrentRate$2=XRRConfigCurrentRate(sc);
    _glfwWin.refreshRate = (signed int)return_value_XRRConfigCurrentRate$2;
    XRRFreeScreenConfigInfo(sc);
  }

  XFree((void *)fbconfig);
}

// _glfwPlatformRestoreWindow
// file ../internal.h line 214
void _glfwPlatformRestoreWindow(void)
{
  if(_glfwWin.overrideRedirect == 0)
    XMapWindow(_glfwLibrary.display, _glfwWin.window);

}

// _glfwPlatformSetMouseCursorPos
// file ../internal.h line 222
void _glfwPlatformSetMouseCursorPos(signed int x, signed int y)
{
  _glfwInput.CursorPosX = x;
  _glfwInput.CursorPosY = y;
  XWarpPointer(_glfwLibrary.display, (unsigned long int)0L, _glfwWin.window, 0, 0, (unsigned int)0, (unsigned int)0, x, y);
}

// _glfwPlatformSetTime
// file ../internal.h line 204
void _glfwPlatformSetTime(double time)
{
  unsigned long int return_value_getRawTime$1;
  return_value_getRawTime$1=getRawTime();
  _glfwLibrary.Timer.base = (signed long long int)(return_value_getRawTime$1 - (unsigned long int)(time / _glfwLibrary.Timer.resolution));
}

// _glfwPlatformSetWindowPos
// file ../internal.h line 212
void _glfwPlatformSetWindowPos(signed int x, signed int y)
{
  XMoveWindow(_glfwLibrary.display, _glfwWin.window, x, y);
}

// _glfwPlatformSetWindowSize
// file ../internal.h line 211
void _glfwPlatformSetWindowSize(signed int width, signed int height)
{
  signed int mode = 0;
  signed int rate;
  signed int sizeChanged = 0;
  rate = _glfwWin.refreshRate;
  if(!(_glfwWin.fullscreen == 0))
    mode=_glfwGetClosestVideoMode(_glfwWin.screen, &width, &height, &rate);

  if(!(_glfwWin.windowNoResize == 0))
  {
    struct anonymous$42 *hints;
    hints=XAllocSizeHints();
    hints->flags = hints->flags | 1L << 4 | 1L << 5;
    hints->max_width = width;
    hints->min_width = hints->max_width;
    hints->max_height = height;
    hints->min_height = hints->max_height;
    XSetWMNormalHints(_glfwLibrary.display, _glfwWin.window, hints);
    XFree((void *)hints);
  }

  if(!(_glfwWin.fullscreen == 0) && !(_glfwWin.width >= width))
  {
    XResizeWindow(_glfwLibrary.display, _glfwWin.window, (unsigned int)width, (unsigned int)height);
    sizeChanged = 1;
  }

  if(!(_glfwWin.fullscreen == 0))
    _glfwSetVideoModeMODE(_glfwWin.screen, mode, _glfwWin.refreshRate);

  if(sizeChanged == 0)
    XResizeWindow(_glfwLibrary.display, _glfwWin.window, (unsigned int)width, (unsigned int)height);

}

// _glfwPlatformSetWindowTitle
// file ../internal.h line 210
void _glfwPlatformSetWindowTitle(const char *title)
{
  XStoreName(_glfwLibrary.display, _glfwWin.window, title);
  XSetIconName(_glfwLibrary.display, _glfwWin.window, title);
}

// _glfwPlatformShowMouseCursor
// file ../internal.h line 221
void _glfwPlatformShowMouseCursor(void)
{
  if(!(_glfwWin.pointerGrabbed == 0))
  {
    XUngrabPointer(_glfwLibrary.display, (unsigned long int)0L);
    _glfwWin.pointerGrabbed = (unsigned char)0;
  }

  if(!(_glfwWin.pointerHidden == 0))
  {
    XUndefineCursor(_glfwLibrary.display, _glfwWin.window);
    _glfwWin.pointerHidden = (unsigned char)0;
  }

}

// _glfwPlatformSignalCond
// file ../internal.h line 198
void _glfwPlatformSignalCond(void *cond)
{
  pthread_cond_signal((union anonymous$1 *)cond);
}

// _glfwPlatformSleep
// file ../internal.h line 205
void _glfwPlatformSleep(double time)
{
  if(IEEE_FLOAT_EQUAL(time, 0.0))
    sched_yield();

  else
  {
    struct timeval currenttime;
    struct timespec wait;
    union anonymous$62 mutex;
    union anonymous$1 cond;
    signed long int dt_sec;
    signed long int dt_usec;
    gettimeofday(&currenttime, (struct timezone *)(void *)0);
    dt_sec = (signed long int)time;
    dt_usec = (signed long int)((time - (double)dt_sec) * 1000000.0);
    wait.tv_nsec = (currenttime.tv_usec + dt_usec) * 1000L;
    if(wait.tv_nsec >= 1000000001l)
    {
      wait.tv_nsec = wait.tv_nsec - 1000000000L;
      dt_sec = dt_sec + 1l;
    }

    wait.tv_sec = currenttime.tv_sec + dt_sec;
    pthread_mutex_init(&mutex, (const union anonymous$2 *)(void *)0);
    pthread_cond_init(&cond, (const union anonymous$2 *)(void *)0);
    pthread_mutex_lock(&mutex);
    pthread_cond_timedwait(&cond, &mutex, &wait);
    pthread_mutex_unlock(&mutex);
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
  }
}

// _glfwPlatformSwapBuffers
// file ../internal.h line 215
void _glfwPlatformSwapBuffers(void)
{
  glXSwapBuffers(_glfwLibrary.display, _glfwWin.window);
}

// _glfwPlatformSwapInterval
// file ../internal.h line 216
void _glfwPlatformSwapInterval(signed int interval)
{
  if(!(_glfwWin.has_GLX_EXT_swap_control == 0))
    _glfwWin.SwapIntervalEXT(_glfwLibrary.display, _glfwWin.window, interval);

  else
    if(!(_glfwWin.has_GLX_MESA_swap_control == 0))
      _glfwWin.SwapIntervalMESA((unsigned int)interval);

    else
      if(!(_glfwWin.has_GLX_SGI_swap_control == 0))
      {
        if(interval >= 1)
          _glfwWin.SwapIntervalSGI(interval);

      }

}

// _glfwPlatformTerminate
// file ../internal.h line 167
signed int _glfwPlatformTerminate(void)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  if(!(return_value_pthread_self$1 == _glfwThrd.First.PosixID))
    return 0;

  else
  {
    glfwCloseWindow();
    terminateThreads();
    terminateDisplay();
    _glfwTerminateJoysticks();
    return 1;
  }
}

// _glfwPlatformUnlockMutex
// file ../internal.h line 194
void _glfwPlatformUnlockMutex(void *mutex)
{
  pthread_mutex_unlock((union anonymous$62 *)mutex);
}

// _glfwPlatformWaitCond
// file ../internal.h line 197
void _glfwPlatformWaitCond(void *cond, void *mutex, double timeout)
{
  struct timeval currenttime;
  struct timespec wait;
  signed long int dt_sec;
  signed long int dt_usec;
  if(timeout >= 100000.0)
    pthread_cond_wait((union anonymous$1 *)cond, (union anonymous$62 *)mutex);

  else
  {
    gettimeofday(&currenttime, (struct timezone *)(void *)0);
    dt_sec = (signed long int)timeout;
    dt_usec = (signed long int)((timeout - (double)dt_sec) * 1000000.0);
    wait.tv_nsec = (currenttime.tv_usec + dt_usec) * 1000L;
    if(wait.tv_nsec >= 1000000001l)
    {
      wait.tv_nsec = wait.tv_nsec - 1000000000L;
      dt_sec = dt_sec + 1l;
    }

    wait.tv_sec = currenttime.tv_sec + dt_sec;
    pthread_cond_timedwait((union anonymous$1 *)cond, (union anonymous$62 *)mutex, &wait);
  }
}

// _glfwPlatformWaitEvents
// file ../internal.h line 219
void _glfwPlatformWaitEvents(void)
{
  union _XEvent event;
  XNextEvent(_glfwLibrary.display, &event);
  XPutBackEvent(_glfwLibrary.display, &event);
  _glfwPlatformPollEvents();
}

// _glfwPlatformWaitThread
// file ../internal.h line 189
signed int _glfwPlatformWaitThread(signed int ID, signed int waitmode)
{
  unsigned long int thread;
  struct _GLFWthread_struct *t;
  pthread_mutex_lock(&_glfwThrd.CriticalSection);
  t=_glfwGetThreadPointer(ID);
  if(t == ((struct _GLFWthread_struct *)NULL))
  {
    pthread_mutex_unlock(&_glfwThrd.CriticalSection);
    return 1;
  }

  else
    if(waitmode == 0x00040002)
    {
      pthread_mutex_unlock(&_glfwThrd.CriticalSection);
      return 0;
    }

    else
    {
      thread = t->PosixID;
      pthread_mutex_unlock(&_glfwThrd.CriticalSection);
      pthread_join(thread, (void **)(void *)0);
      return 1;
    }
}

// _glfwReadStream
// file ../stream.c line 72
signed long int _glfwReadStream(struct anonymous$59 *stream, void *data, signed long int size)
{
  if(!(stream->file == ((struct _IO_FILE *)NULL)))
  {
    unsigned long int return_value_fread$1;
    return_value_fread$1=fread(data, (unsigned long int)1, (unsigned long int)size, stream->file);
    return (signed long int)return_value_fread$1;
  }

  if(!(stream->data == NULL))
  {
    if(stream->position == stream->size)
      return (signed long int)0;

    if(!(stream->size >= stream->position + size))
      size = stream->size - stream->position;

    memcpy(data, (const void *)((unsigned char *)stream->data + stream->position), (unsigned long int)size);
    stream->position = stream->position + size;
    return size;
  }

  else
    return (signed long int)0;
}

// _glfwReadTGA
// file ../internal.h line 258
signed int _glfwReadTGA(struct anonymous$59 *s, struct anonymous$60 *img, signed int flags)
{
  struct anonymous$65 h;
  unsigned char *cmap;
  unsigned char *pix;
  unsigned char tmp;
  unsigned char *src;
  unsigned char *dst;
  signed int cmapsize;
  signed int pixsize;
  signed int pixsize2;
  signed int bpp;
  signed int bpp2;
  signed int k;
  signed int m;
  signed int n;
  signed int swapx;
  signed int swapy;
  signed int return_value_ReadTGAHeader$1;
  return_value_ReadTGAHeader$1=ReadTGAHeader(s, &h);
  unsigned char *tmp_post$4;
  unsigned char *tmp_post$5;
  unsigned char *tmp_post$6;
  unsigned char *tmp_post$7;
  if(return_value_ReadTGAHeader$1 == 0)
    return 0;

  else
  {
    cmapsize = (h.cmaptype == 1 ? 1 : 0) * h.cmaplen * ((h.cmapentrysize + 7) / 8);
    if(cmapsize >= 1)
    {
      if(h.cmaplen == 0 || h.cmaplen >= 257 || !(h.cmapentrysize == 24) && !(h.cmapentrysize == 32))
        return 0;

      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)cmapsize);
      cmap = (unsigned char *)return_value_malloc$2;
      if(cmap == ((unsigned char *)NULL))
        return 0;

      _glfwReadStream(s, (void *)cmap, (signed long int)cmapsize);
    }

    else
      cmap = (unsigned char *)(void *)0;
    pixsize = h.width * h.height * ((h.bitsperpixel + 7) / 8);
    bpp = (h.bitsperpixel + 7) / 8;
    if(!(cmap == ((unsigned char *)NULL)))
      bpp2 = (h.cmapentrysize + 7) / 8;

    else
      bpp2 = bpp;
    pixsize2 = h.width * h.height * bpp2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)pixsize2);
    pix = (unsigned char *)return_value_malloc$3;
    if(pix == ((unsigned char *)NULL))
    {
      if(!(cmap == ((unsigned char *)NULL)))
        free((void *)cmap);

      return 0;
    }

    else
    {
      if(h.imagetype >= 9)
        ReadTGA_RLE(pix, pixsize, bpp, s);

      else
        _glfwReadStream(s, (void *)pix, (signed long int)pixsize);
      if(!(h._origin == 2))
      {
        if(h._origin == 0)
          goto __CPROVER_DUMP_L13;

        if(h._origin == 3)
          goto __CPROVER_DUMP_L14;

        if(h._origin == 1)
          goto __CPROVER_DUMP_L15;

      }

      swapx = 0;
      swapy = 1;
      goto __CPROVER_DUMP_L16;

    __CPROVER_DUMP_L13:
      ;
      swapx = 0;
      swapy = 0;
      goto __CPROVER_DUMP_L16;

    __CPROVER_DUMP_L14:
      ;
      swapx = 1;
      swapy = 1;
      goto __CPROVER_DUMP_L16;

    __CPROVER_DUMP_L15:
      ;
      swapx = 1;
      swapy = 0;

    __CPROVER_DUMP_L16:
      ;
      if((0x00000002 & flags) == 0 && !(swapy == 0) || swapy == 0 && !((0x00000002 & flags) == 0))
      {
        src = pix;
        dst = &pix[(signed long int)((h.height - 1) * h.width * bpp)];
        n = 0;
        for( ; !(n >= h.height / 2); n = n + 1)
        {
          m = 0;
          for( ; !(m >= h.width); m = m + 1)
          {
            k = 0;
            for( ; !(k >= bpp); k = k + 1)
            {
              tmp = *src;
              tmp_post$4 = src;
              src = src + 1l;
              *tmp_post$4 = *dst;
              tmp_post$5 = dst;
              dst = dst + 1l;
              *tmp_post$5 = tmp;
            }
          }
          dst = dst - (signed long int)(2 * h.width * bpp);
        }
      }

      if(!(swapx == 0))
      {
        src = pix;
        dst = &pix[(signed long int)((h.width - 1) * bpp)];
        n = 0;
        for( ; !(n >= h.height); n = n + 1)
        {
          m = 0;
          for( ; !(m >= h.width / 2); m = m + 1)
          {
            k = 0;
            for( ; !(k >= bpp); k = k + 1)
            {
              tmp = *src;
              tmp_post$6 = src;
              src = src + 1l;
              *tmp_post$6 = *dst;
              tmp_post$7 = dst;
              dst = dst + 1l;
              *tmp_post$7 = tmp;
            }
            dst = dst - (signed long int)(2 * bpp);
          }
          src = src + (signed long int)(((h.width + 1) / 2) * bpp);
          dst = dst + (signed long int)(((3 * h.width + 1) / 2) * bpp);
        }
      }

      if(!(cmap == ((unsigned char *)NULL)))
      {
        if(bpp2 == 3 || bpp2 == 4)
        {
          n = 0;
          for( ; !(n >= h.cmaplen); n = n + 1)
          {
            tmp = cmap[(signed long int)(n * bpp2)];
            cmap[(signed long int)(n * bpp2)] = cmap[(signed long int)(n * bpp2 + 2)];
            cmap[(signed long int)(n * bpp2 + 2)] = tmp;
          }
        }

        m = h.width * h.height - 1;
        for( ; m >= 0; m = m - 1)
        {
          n = (signed int)pix[(signed long int)m];
          k = 0;
          for( ; !(k >= bpp2); k = k + 1)
            pix[(signed long int)(m * bpp2 + k)] = cmap[(signed long int)(n * bpp2 + k)];
        }
        free((void *)cmap);
      }

      else
        if(bpp2 == 3 || bpp2 == 4)
        {
          src = pix;
          dst = &pix[(signed long int)2];
          n = 0;
          for( ; !(n >= h.height * h.width); n = n + 1)
          {
            tmp = *src;
            *src = *dst;
            *dst = tmp;
            src = src + (signed long int)bpp2;
            dst = dst + (signed long int)bpp2;
          }
        }

      img->Width = h.width;
      img->Height = h.height;
      img->BytesPerPixel = bpp2;
      img->Data = pix;
      return 1;
    }
  }
}

// _glfwRefreshContextParams
// file ../glext.c line 136
void _glfwRefreshContextParams(void)
{
  _glfwParseGLVersion(&_glfwWin.glMajor, &_glfwWin.glMinor, &_glfwWin.glRevision);
  _glfwWin.glProfile = 0;
  _glfwWin.glForward = 0;
  if(_glfwWin.glMajor >= 3)
  {
    signed int flags;
    glGetIntegerv((unsigned int)0x821E, &flags);
    if(!((0x00000001 & flags) == 0))
      _glfwWin.glForward = 1;

  }

  if(_glfwWin.glMajor >= 4 || _glfwWin.glMajor == 3 && _glfwWin.glMinor >= 2)
  {
    signed int mask;
    glGetIntegerv((unsigned int)0x9126, &mask);
    if(!((0x00000002 & mask) == 0))
      _glfwWin.glProfile = 0x00050002;

    else
      if(!((0x00000001 & mask) == 0))
        _glfwWin.glProfile = 0x00050001;

  }

}

// _glfwRemoveThread
// file ../thread.c line 82
void _glfwRemoveThread(struct _GLFWthread_struct *t)
{
  if(!(t->Previous == ((struct _GLFWthread_struct *)NULL)))
    t->Previous->Next = t->Next;

  if(!(t->Next == ((struct _GLFWthread_struct *)NULL)))
    t->Next->Previous = t->Previous;

  free((void *)t);
}

// _glfwRestoreVideoMode
// file x11_fullscreen.c line 302
void _glfwRestoreVideoMode(void)
{
  if(!(_glfwWin.FS.modeChanged == 0))
  {
    if(!(_glfwLibrary.XRandR.available == 0))
    {
      struct _XRRScreenConfiguration *sc;
      sc=XRRGetScreenInfo(_glfwLibrary.display, _glfwWin.root);
      XRRSetScreenConfig(_glfwLibrary.display, sc, _glfwWin.root, (signed int)_glfwWin.FS.oldSizeID, _glfwWin.FS.oldRotation, (unsigned long int)0L);
      XRRFreeScreenConfigInfo(sc);
    }

    _glfwWin.FS.modeChanged = 0;
  }

}

// _glfwSeekStream
// file ../stream.c line 127
signed int _glfwSeekStream(struct anonymous$59 *stream, signed long int offset, signed int whence)
{
  signed long int position;
  if(!(stream->file == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fseek$1;
    return_value_fseek$1=fseek(stream->file, offset, whence);
    if(!(return_value_fseek$1 == 0))
      return 0;

    return 1;
  }

  if(!(stream->data == NULL))
  {
    position = offset;
    if(whence == 1)
      position = position + stream->position;

    else
      if(whence == 2)
        position = position + stream->size;

      else
        if(!(whence == 0))
          return 0;

    if(!(stream->size >= position))
      stream->position = stream->size;

    else
      if(!(position >= 0l))
        stream->position = (signed long int)0;

      else
        stream->position = position;
    return 1;
  }

  else
    return 0;
}

// _glfwSetVideoMode
// file x11_fullscreen.c line 286
void _glfwSetVideoMode(signed int screen, signed int *width, signed int *height, signed int *rate)
{
  signed int bestmode;
  bestmode=_glfwGetClosestVideoMode(screen, width, height, rate);
  _glfwSetVideoModeMODE(screen, bestmode, *rate);
}

// _glfwSetVideoModeMODE
// file x11_fullscreen.c line 196
void _glfwSetVideoModeMODE(signed int screen, signed int mode, signed int rate)
{
  struct _XRRScreenConfiguration *sc;
  unsigned long int root;
  if(!(_glfwLibrary.XRandR.available == 0))
  {
    root = (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)screen])->root;
    sc=XRRGetScreenInfo(_glfwLibrary.display, root);
    if(_glfwWin.FS.modeChanged == 0)
    {
      _glfwWin.FS.oldSizeID=XRRConfigCurrentConfiguration(sc, &_glfwWin.FS.oldRotation);
      _glfwWin.FS.oldWidth = (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)screen])->width;
      _glfwWin.FS.oldHeight = (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)screen])->height;
      _glfwWin.FS.modeChanged = 1;
    }

    if(rate >= 1)
      XRRSetScreenConfigAndRate(_glfwLibrary.display, sc, root, mode, (unsigned short int)1, (signed short int)rate, (unsigned long int)0L);

    else
      XRRSetScreenConfig(_glfwLibrary.display, sc, root, mode, (unsigned short int)1, (unsigned long int)0L);
    XRRFreeScreenConfigInfo(sc);
  }

}

// _glfwStringInExtensionString
// file ../glext.c line 100
signed int _glfwStringInExtensionString(const char *string, const unsigned char *extensions)
{
  const unsigned char *start;
  unsigned char *where;
  unsigned char *terminator;
  start = extensions;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  while((_Bool)1)
  {
    char *return_value_strstr$1;
    return_value_strstr$1=strstr((const char *)start, string);
    where = (unsigned char *)return_value_strstr$1;
    if(where == ((unsigned char *)NULL))
      return 0;

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(string);
    terminator = where + (signed long int)return_value_strlen$2;
    if(where == start)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*(where - (signed long int)1) == 32 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      if((signed int)*terminator == 32)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*terminator == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        break;

    }

    start = terminator;
  }
  return 1;
}

// _glfwTellStream
// file ../stream.c line 107
signed long int _glfwTellStream(struct anonymous$59 *stream)
{
  if(!(stream->file == ((struct _IO_FILE *)NULL)))
  {
    signed long int return_value_ftell$1;
    return_value_ftell$1=ftell(stream->file);
    return return_value_ftell$1;
  }

  if(!(stream->data == NULL))
    return stream->position;

  else
    return (signed long int)0;
}

// _glfwTerminateJoysticks
// file ./platform.h line 523
void _glfwTerminateJoysticks(void)
{
  signed int i = 0;
  for( ; !(i >= 16); i = i + 1)
    if(!(_glfwJoy[(signed long int)i].Present == 0))
    {
      close(_glfwJoy[(signed long int)i].fd);
      free((void *)_glfwJoy[(signed long int)i].Axis);
      free((void *)_glfwJoy[(signed long int)i].Button);
      _glfwJoy[(signed long int)i].Present = 0;
    }

}

// checkForEWMH
// file x11_window.c line 153
static unsigned char checkForEWMH(void)
{
  unsigned long int *windowFromRoot = (unsigned long int *)(void *)0;
  unsigned long int *windowFromChild = (unsigned long int *)(void *)0;
  unsigned long int supportingWmCheck;
  supportingWmCheck=XInternAtom(_glfwLibrary.display, "_NET_SUPPORTING_WM_CHECK", 1);
  unsigned long int wmSupported;
  wmSupported=XInternAtom(_glfwLibrary.display, "_NET_SUPPORTED", 1);
  if(supportingWmCheck == 0ul || wmSupported == 0ul)
    return (unsigned char)0;

  else
  {
    unsigned long int return_value_getWindowProperty$1;
    return_value_getWindowProperty$1=getWindowProperty(_glfwWin.root, supportingWmCheck, (unsigned long int)33, (unsigned char **)&windowFromRoot);
    if(!(return_value_getWindowProperty$1 == 1ul))
    {
      XFree((void *)windowFromRoot);
      return (unsigned char)0;
    }

    else
    {
      unsigned long int return_value_getWindowProperty$2;
      return_value_getWindowProperty$2=getWindowProperty(*windowFromRoot, supportingWmCheck, (unsigned long int)33, (unsigned char **)&windowFromChild);
      if(!(return_value_getWindowProperty$2 == 1ul))
      {
        XFree((void *)windowFromRoot);
        XFree((void *)windowFromChild);
        return (unsigned char)0;
      }

      else
        if(!(*windowFromRoot == *windowFromChild))
        {
          XFree((void *)windowFromRoot);
          XFree((void *)windowFromChild);
          return (unsigned char)0;
        }

        else
        {
          XFree((void *)windowFromRoot);
          XFree((void *)windowFromChild);
          unsigned long int *supportedAtoms;
          unsigned long int atomCount;
          atomCount=getWindowProperty(_glfwWin.root, wmSupported, (unsigned long int)4, (unsigned char **)&supportedAtoms);
          _glfwWin.wmState=getSupportedAtom(supportedAtoms, atomCount, "_NET_WM_STATE");
          _glfwWin.wmStateFullscreen=getSupportedAtom(supportedAtoms, atomCount, "_NET_WM_STATE_FULLSCREEN");
          _glfwWin.wmPing=getSupportedAtom(supportedAtoms, atomCount, "_NET_WM_PING");
          _glfwWin.wmActiveWindow=getSupportedAtom(supportedAtoms, atomCount, "_NET_ACTIVE_WINDOW");
          XFree((void *)supportedAtoms);
          return (unsigned char)1;
        }
    }
  }
}

// close_window_callback
// file heightmap.c line 650
static signed int close_window_callback(void)
{
  running = (unsigned char)0;
  return 0;
}

// createContext
// file x11_window.c line 586
static signed int createContext(const struct anonymous *wndconfig, unsigned long int fbconfigID)
{
  signed int attribs[40l];
  signed int flags;
  signed int dummy;
  signed int index;
  struct __GLXFBConfigRec **fbconfig;
  index = 0;
  signed int tmp_post$1 = index;
  index = index + 1;
  attribs[(signed long int)tmp_post$1] = 0x8013;
  signed int tmp_post$2 = index;
  index = index + 1;
  attribs[(signed long int)tmp_post$2] = (signed int)fbconfigID;
  signed int tmp_post$3 = index;
  index = index + 1;
  attribs[(signed long int)tmp_post$3] = (signed int)0L;
  signed int tmp_post$4 = index;
  index = index + 1;
  attribs[(signed long int)tmp_post$4] = (signed int)0L;
  if(!(_glfwWin.has_GLX_SGIX_fbconfig == 0))
    fbconfig=_glfwWin.ChooseFBConfigSGIX(_glfwLibrary.display, _glfwWin.screen, attribs, &dummy);

  else
    fbconfig=glXChooseFBConfig(_glfwLibrary.display, _glfwWin.screen, attribs, &dummy);
  _Bool tmp_if_expr$9;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  _Bool tmp_if_expr$12;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$13;
  signed int tmp_post$14;
  signed int tmp_post$15;
  signed int tmp_post$16;
  if(fbconfig == ((struct __GLXFBConfigRec **)NULL))
  {
    fprintf(stderr, "Unable to retrieve the selected GLXFBConfig\n");
    return 0;
  }

  else
  {
    if(!(_glfwWin.has_GLX_SGIX_fbconfig == 0))
      _glfwWin.visual=_glfwWin.GetVisualFromFBConfigSGIX(_glfwLibrary.display, *fbconfig);

    else
      _glfwWin.visual=glXGetVisualFromFBConfig(_glfwLibrary.display, *fbconfig);
    if(_glfwWin.visual == ((struct anonymous$49 *)NULL))
    {
      XFree((void *)fbconfig);
      fprintf(stderr, "Unable to retrieve visual for GLXFBconfig\n");
      return 0;
    }

    else
    {
      if(!(_glfwWin.has_GLX_ARB_create_context == 0))
      {
        index = 0;
        if(!(wndconfig->glMajor == 1))
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = wndconfig->glMinor != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
        {
          tmp_post$5 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$5] = 0x2091;
          tmp_post$6 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$6] = wndconfig->glMajor;
          tmp_post$7 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$7] = 0x2092;
          tmp_post$8 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$8] = wndconfig->glMinor;
        }

        if(!(wndconfig->glForward == 0))
          tmp_if_expr$12 = (_Bool)1;

        else
          tmp_if_expr$12 = wndconfig->glDebug != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$12)
        {
          flags = 0;
          if(!(wndconfig->glForward == 0))
            flags = flags | 0x00000002;

          if(!(wndconfig->glDebug == 0))
            flags = flags | 0x00000001;

          tmp_post$10 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$10] = 0x2094;
          tmp_post$11 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$11] = flags;
        }

        if(!(wndconfig->glProfile == 0))
        {
          if(_glfwWin.has_GLX_ARB_create_context_profile == 0)
          {
            fprintf(stderr, "OpenGL profile requested but GLX_ARB_create_context_profile is unavailable\n");
            return 0;
          }

          if(wndconfig->glProfile == 0x00050001)
            flags = 0x00000001;

          else
            flags = 0x00000002;
          tmp_post$13 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$13] = 0x9126;
          tmp_post$14 = index;
          index = index + 1;
          attribs[(signed long int)tmp_post$14] = flags;
        }

        tmp_post$15 = index;
        index = index + 1;
        attribs[(signed long int)tmp_post$15] = (signed int)0L;
        tmp_post$16 = index;
        index = index + 1;
        attribs[(signed long int)tmp_post$16] = (signed int)0L;
        XSetErrorHandler(errorHandler);
        _glfwWin.context=_glfwWin.CreateContextAttribsARB(_glfwLibrary.display, *fbconfig, (struct __GLXcontextRec *)(void *)0, 1, attribs);
        XSetErrorHandler((signed int (*)(struct _XDisplay *, struct anonymous$33 *))(void *)0);
        if(_glfwWin.context == ((struct __GLXcontextRec *)NULL))
        {
          if(_glfwErrorCode == (unsigned long int)(13 + _glfwLibrary.GLX.errorBase))
          {
            if(wndconfig->glProfile == 0)
            {
              if(wndconfig->glForward == 0)
                _glfwWin.context=createLegacyContext(*fbconfig);

            }

          }

        }

        _glfwWin.glDebug = wndconfig->glDebug;
      }

      else
        _glfwWin.context=createLegacyContext(*fbconfig);
      XFree((void *)fbconfig);
      if(_glfwWin.context == ((struct __GLXcontextRec *)NULL))
      {
        fprintf(stderr, "Unable to create OpenGL context\n");
        return 0;
      }

      else
      {
        _glfwWin.fbconfigID = fbconfigID;
        return 1;
      }
    }
  }
}

// createLegacyContext
// file x11_window.c line 557
static struct __GLXcontextRec * createLegacyContext(struct __GLXFBConfigRec *fbconfig)
{
  if(!(_glfwWin.has_GLX_SGIX_fbconfig == 0))
  {
    struct __GLXcontextRec *return_value;
    return_value=_glfwWin.CreateContextWithConfigSGIX(_glfwLibrary.display, fbconfig, 0x8014, (struct __GLXcontextRec *)(void *)0, 1);
    return return_value;
  }

  else
  {
    struct __GLXcontextRec *return_value_glXCreateNewContext$1;
    return_value_glXCreateNewContext$1=glXCreateNewContext(_glfwLibrary.display, fbconfig, 0x8014, (struct __GLXcontextRec *)(void *)0, 1);
    return return_value_glXCreateNewContext$1;
  }
}

// createNULLCursor
// file x11_window.c line 388
static unsigned long int createNULLCursor(struct _XDisplay *display, unsigned long int root)
{
  unsigned long int cursormask;
  struct anonymous$46 xgc;
  struct _XGC *gc;
  struct anonymous$44 col;
  unsigned long int cursor;
  cursormask=XCreatePixmap(display, root, (unsigned int)1, (unsigned int)1, (unsigned int)1);
  xgc.function = 0x0;
  gc=XCreateGC(display, cursormask, (unsigned long int)(1L << 0), &xgc);
  XFillRectangle(display, cursormask, gc, 0, 0, (unsigned int)1, (unsigned int)1);
  col.pixel = (unsigned long int)0;
  col.red = (unsigned short int)0;
  col.flags = (char)4;
  cursor=XCreatePixmapCursor(display, cursormask, cursormask, &col, &col, (unsigned int)0, (unsigned int)0);
  XFreePixmap(display, cursormask);
  XFreeGC(display, gc);
  return cursor;
}

// createWindow
// file x11_window.c line 851
static unsigned char createWindow(signed int width, signed int height, const struct anonymous *wndconfig)
{
  union _XEvent event;
  unsigned long int wamask;
  struct anonymous$48 wa;
  _glfwWin.colormap=XCreateColormap(_glfwLibrary.display, _glfwWin.root, _glfwWin.visual->visual, 0);
  wamask = (unsigned long int)(1L << 3 | 1L << 13 | 1L << 11);
  wa.colormap = _glfwWin.colormap;
  wa.border_pixel = (unsigned long int)0;
  wa.event_mask = 1L << 17 | 1L << 0 | 1L << 1 | 1L << 6 | 1L << 2 | 1L << 3 | 1L << 15 | 1L << 21 | 1L << 16;
  if(wndconfig->mode == 0x00010001)
  {
    wa.background_pixel = (&((struct anonymous$50 *)_glfwLibrary.display)->screens[(signed long int)_glfwWin.screen])->black_pixel;
    wamask = wamask | (unsigned long int)(1L << 1);
  }

  _glfwWin.window=XCreateWindow(_glfwLibrary.display, _glfwWin.root, 0, 0, (unsigned int)_glfwWin.width, (unsigned int)_glfwWin.height, (unsigned int)0, _glfwWin.visual->depth, (unsigned int)1, _glfwWin.visual->visual, wamask, &wa);
  signed int tmp_post$1;
  signed int tmp_post$2;
  if(_glfwWin.window == 0ul)
  {
    _glfwPlatformCloseWindow();
    return (unsigned char)0;
  }

  else
  {
    _glfwWin.hasEWMH=checkForEWMH();
    if(_glfwWin.hasEWMH == 0 && !(_glfwWin.fullscreen == 0))
    {
      struct anonymous$48 attributes;
      attributes.override_redirect = 1;
      XChangeWindowAttributes(_glfwLibrary.display, _glfwWin.window, (unsigned long int)(1L << 9), &attributes);
      _glfwWin.overrideRedirect = (unsigned char)1;
    }

    _glfwWin.wmDeleteWindow=XInternAtom(_glfwLibrary.display, "WM_DELETE_WINDOW", 0);
    signed int count = 0;
    unsigned long int protocols[2l];
    if(!(_glfwWin.wmDeleteWindow == 0ul))
    {
      tmp_post$1 = count;
      count = count + 1;
      protocols[(signed long int)tmp_post$1] = _glfwWin.wmDeleteWindow;
    }

    if(!(_glfwWin.wmPing == 0ul))
    {
      tmp_post$2 = count;
      count = count + 1;
      protocols[(signed long int)tmp_post$2] = _glfwWin.wmPing;
    }

    if(count >= 1)
      XSetWMProtocols(_glfwLibrary.display, _glfwWin.window, protocols, count);

    struct anonymous$39 *hints;
    hints=XAllocWMHints();
    if(hints == ((struct anonymous$39 *)NULL))
    {
      _glfwPlatformCloseWindow();
      return (unsigned char)0;
    }

    else
    {
      hints->flags = 1L << 1;
      hints->initial_state = 1;
      XSetWMHints(_glfwLibrary.display, _glfwWin.window, hints);
      XFree((void *)hints);
      struct anonymous$42 *createWindow$$1$$5$$hints;
      createWindow$$1$$5$$hints=XAllocSizeHints();
      if(createWindow$$1$$5$$hints == ((struct anonymous$42 *)NULL))
      {
        _glfwPlatformCloseWindow();
        return (unsigned char)0;
      }

      else
      {
        createWindow$$1$$5$$hints->flags = (signed long int)0;
        if(!(wndconfig->windowNoResize == 0))
        {
          if(_glfwWin.fullscreen == 0)
          {
            createWindow$$1$$5$$hints->flags = createWindow$$1$$5$$hints->flags | 1L << 4 | 1L << 5;
            createWindow$$1$$5$$hints->max_width = _glfwWin.width;
            createWindow$$1$$5$$hints->min_width = createWindow$$1$$5$$hints->max_width;
            createWindow$$1$$5$$hints->max_height = _glfwWin.height;
            createWindow$$1$$5$$hints->min_height = createWindow$$1$$5$$hints->max_height;
          }

        }

        XSetWMNormalHints(_glfwLibrary.display, _glfwWin.window, createWindow$$1$$5$$hints);
        XFree((void *)createWindow$$1$$5$$hints);
        _glfwPlatformSetWindowTitle("GLFW Window");
        XMapWindow(_glfwLibrary.display, _glfwWin.window);
        XPeekIfEvent(_glfwLibrary.display, &event, isMapNotify, (char *)_glfwWin.window);
        return (unsigned char)1;
      }
    }
  }
}

// disableAutoPollEvents
// file ../enable.c line 227
static void disableAutoPollEvents(void)
{
  _glfwWin.autoPollEvents = 0;
}

// disableKeyRepeat
// file ../enable.c line 208
static void disableKeyRepeat(void)
{
  _glfwInput.KeyRepeat = 0;
}

// disableMouseCursor
// file ../enable.c line 82
static void disableMouseCursor(void)
{
  if(!(_glfwWin.opened == 0) && _glfwWin.mouseLock == 0)
  {
    if(!(_glfwWin.active == 0))
      _glfwPlatformHideMouseCursor();

    _glfwWin.mouseLock = 1;
  }

}

// disableStickyKeys
// file ../enable.c line 113
static void disableStickyKeys(void)
{
  signed int i;
  _glfwInput.StickyKeys = 0;
  i = 0;
  for( ; !(i >= 326); i = i + 1)
    if((signed int)_glfwInput.Key[(signed long int)i] == 2)
      _glfwInput.Key[(signed long int)i] = (char)0;

}

// disableStickyMouseButtons
// file ../enable.c line 143
static void disableStickyMouseButtons(void)
{
  signed int i;
  _glfwInput.StickyMouseButtons = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if((signed int)_glfwInput.MouseButton[(signed long int)i] == 2)
      _glfwInput.MouseButton[(signed long int)i] = (char)0;

}

// disableSystemKeys
// file ../enable.c line 181
static void disableSystemKeys(void)
{
  if(_glfwWin.sysKeysDisabled == 0)
  {
    _glfwPlatformDisableSystemKeys();
    _glfwWin.sysKeysDisabled = 1;
  }

}

// enableAutoPollEvents
// file ../enable.c line 218
static void enableAutoPollEvents(void)
{
  _glfwWin.autoPollEvents = 1;
}

// enableKeyRepeat
// file ../enable.c line 199
static void enableKeyRepeat(void)
{
  _glfwInput.KeyRepeat = 1;
}

// enableMouseCursor
// file ../enable.c line 42
static void enableMouseCursor(void)
{
  signed int centerPosX;
  signed int centerPosY;
  if(!(_glfwWin.mouseLock == 0) && !(_glfwWin.opened == 0))
  {
    if(!(_glfwWin.active == 0))
    {
      _glfwPlatformShowMouseCursor();
      centerPosX = _glfwWin.width / 2;
      centerPosY = _glfwWin.height / 2;
      if(!(centerPosX == _glfwInput.MousePosX) || !(centerPosY == _glfwInput.MousePosY))
      {
        _glfwPlatformSetMouseCursorPos(centerPosX, centerPosY);
        _glfwInput.MousePosX = centerPosX;
        _glfwInput.MousePosY = centerPosY;
        if(!(_glfwWin.mousePosCallback == ((void (*)(signed int, signed int))NULL)))
          _glfwWin.mousePosCallback(_glfwInput.MousePosX, _glfwInput.MousePosY);

      }

    }

    _glfwWin.mouseLock = 0;
  }

}

// enableStickyKeys
// file ../enable.c line 104
static void enableStickyKeys(void)
{
  _glfwInput.StickyKeys = 1;
}

// enableStickyMouseButtons
// file ../enable.c line 134
static void enableStickyMouseButtons(void)
{
  _glfwInput.StickyMouseButtons = 1;
}

// enableSystemKeys
// file ../enable.c line 164
static void enableSystemKeys(void)
{
  if(!(_glfwWin.sysKeysDisabled == 0))
  {
    _glfwPlatformEnableSystemKeys();
    _glfwWin.sysKeysDisabled = 0;
  }

}

// enterFullscreenMode
// file x11_window.c line 1012
static void enterFullscreenMode(void)
{
  if(_glfwWin.Saver.changed == 0)
  {
    XGetScreenSaver(_glfwLibrary.display, &_glfwWin.Saver.timeout, &_glfwWin.Saver.interval, &_glfwWin.Saver.blanking, &_glfwWin.Saver.exposure);
    XSetScreenSaver(_glfwLibrary.display, 0, 0, 0, 2);
    _glfwWin.Saver.changed = 1;
  }

  _glfwSetVideoMode(_glfwWin.screen, &_glfwWin.width, &_glfwWin.height, &_glfwWin.refreshRate);
  if(!(_glfwWin.wmState == 0ul) && !(_glfwWin.wmStateFullscreen == 0ul) && !(_glfwWin.hasEWMH == 0))
  {
    if(!(_glfwWin.wmActiveWindow == 0ul))
    {
      union _XEvent event;
      memset((void *)&event, 0, sizeof(union _XEvent) /*192ul*/ );
      event.type = 33;
      event.xclient.window = _glfwWin.window;
      event.xclient.format = 32;
      event.xclient.message_type = _glfwWin.wmActiveWindow;
      event.xclient.data.l[(signed long int)0] = (signed long int)1;
      event.xclient.data.l[(signed long int)1] = (signed long int)0;
      XSendEvent(_glfwLibrary.display, _glfwWin.root, 0, 1L << 19 | 1L << 20, &event);
    }

    union _XEvent enterFullscreenMode$$1$$2$$event;
    memset((void *)&enterFullscreenMode$$1$$2$$event, 0, sizeof(union _XEvent) /*192ul*/ );
    enterFullscreenMode$$1$$2$$event.type = 33;
    enterFullscreenMode$$1$$2$$event.xclient.window = _glfwWin.window;
    enterFullscreenMode$$1$$2$$event.xclient.format = 32;
    enterFullscreenMode$$1$$2$$event.xclient.message_type = _glfwWin.wmState;
    enterFullscreenMode$$1$$2$$event.xclient.data.l[(signed long int)0] = (signed long int)1;
    enterFullscreenMode$$1$$2$$event.xclient.data.l[(signed long int)1] = (signed long int)_glfwWin.wmStateFullscreen;
    enterFullscreenMode$$1$$2$$event.xclient.data.l[(signed long int)2] = (signed long int)0;
    enterFullscreenMode$$1$$2$$event.xclient.data.l[(signed long int)3] = (signed long int)1;
    XSendEvent(_glfwLibrary.display, _glfwWin.root, 0, 1L << 19 | 1L << 20, &enterFullscreenMode$$1$$2$$event);
  }

  else
    if(!(_glfwWin.overrideRedirect == 0))
    {
      XRaiseWindow(_glfwLibrary.display, _glfwWin.window);
      XSetInputFocus(_glfwLibrary.display, _glfwWin.window, 2, (unsigned long int)0L);
      XMoveWindow(_glfwLibrary.display, _glfwWin.window, 0, 0);
      XResizeWindow(_glfwLibrary.display, _glfwWin.window, (unsigned int)_glfwWin.width, (unsigned int)_glfwWin.height);
    }

  if(!(_glfwWin.mouseLock == 0))
    _glfwPlatformHideMouseCursor();

  XWarpPointer(_glfwLibrary.display, (unsigned long int)0L, _glfwWin.window, 0, 0, (unsigned int)0, (unsigned int)0, 0, 0);
  XWarpPointer(_glfwLibrary.display, (unsigned long int)0L, _glfwWin.window, 0, 0, (unsigned int)0, (unsigned int)0, _glfwWin.width / 2, _glfwWin.height / 2);
}

// errorHandler
// file x11_window.c line 70
static signed int errorHandler(struct _XDisplay *display, struct anonymous$33 *event)
{
  _glfwErrorCode = (unsigned long int)event->error_code;
  return 0;
}

// generate_heightmap__circle
// file heightmap.c line 551
static void generate_heightmap__circle(float *center_x, float *center_y, float *size, float *displacement)
{
  float sign;
  signed int return_value_rand$1;
  return_value_rand$1=rand();
  *center_x = (10.0f * (float)return_value_rand$1) / (1.0f * (float)2147483647);
  signed int return_value_rand$2;
  return_value_rand$2=rand();
  *center_y = (10.0f * (float)return_value_rand$2) / (1.0f * (float)2147483647);
  signed int return_value_rand$3;
  return_value_rand$3=rand();
  *size = (5.0f * (float)return_value_rand$3) / (1.0f * (float)2147483647);
  signed int return_value_rand$4;
  return_value_rand$4=rand();
  sign = (1.0f * (float)return_value_rand$4) / (1.0f * (float)2147483647);
  sign = sign < 0.3f ? -1.0f : 1.0f;
  signed int return_value_rand$5;
  return_value_rand$5=rand();
  *displacement = (sign * 1.0f * (float)return_value_rand$5) / (1.0f * (float)2147483647);
}

// getFBConfigAttrib
// file x11_window.c line 417
static signed int getFBConfigAttrib(struct __GLXFBConfigRec *fbconfig, signed int attrib)
{
  signed int value;
  if(!(_glfwWin.has_GLX_SGIX_fbconfig == 0))
    _glfwWin.GetFBConfigAttribSGIX(_glfwLibrary.display, fbconfig, attrib, &value);

  else
    glXGetFBConfigAttrib(_glfwLibrary.display, fbconfig, attrib, &value);
  return value;
}

// getFBConfigs
// file x11_window.c line 438
static struct anonymous$0 * getFBConfigs(unsigned int *found)
{
  struct __GLXFBConfigRec **fbconfigs;
  struct anonymous$0 *result;
  signed int i;
  signed int count = 0;
  unsigned char trustWindowBit = (unsigned char)1;
  *found = (unsigned int)0;
  _Bool tmp_if_expr$6;
  signed int return_value_getFBConfigAttrib$5;
  if(_glfwLibrary.GLX.versionMajor == 1 && !(_glfwLibrary.GLX.versionMinor >= 3))
  {
    if(!(_glfwWin.has_GLX_SGIX_fbconfig == 0))
      goto __CPROVER_DUMP_L1;

    fprintf(stderr, "GLXFBConfigs are not supported by the X server\n");
    return (struct anonymous$0 *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    const char *return_value_glXGetClientString$1;
    return_value_glXGetClientString$1=glXGetClientString(_glfwLibrary.display, 1);
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(return_value_glXGetClientString$1, "Chromium");
    if(return_value_strcmp$2 == 0)
      trustWindowBit = (unsigned char)0;

    if(!(_glfwWin.has_GLX_SGIX_fbconfig == 0))
    {
      fbconfigs=_glfwWin.ChooseFBConfigSGIX(_glfwLibrary.display, _glfwWin.screen, (signed int *)(void *)0, &count);
      if(count == 0)
      {
        fprintf(stderr, "No GLXFBConfigs returned\n");
        return (struct anonymous$0 *)(void *)0;
      }

    }

    else
    {
      fbconfigs=glXGetFBConfigs(_glfwLibrary.display, _glfwWin.screen, &count);
      if(count == 0)
      {
        fprintf(stderr, "No GLXFBConfigs returned\n");
        return (struct anonymous$0 *)(void *)0;
      }

    }
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct anonymous$0) /*64ul*/  * (unsigned long int)count);
    result = (struct anonymous$0 *)return_value_malloc$3;
    if(result == ((struct anonymous$0 *)NULL))
    {
      fprintf(stderr, "Out of memory\n");
      return (struct anonymous$0 *)(void *)0;
    }

    else
    {
      i = 0;
      for( ; !(i >= count); i = i + 1)
      {
        signed int return_value_getFBConfigAttrib$4;
        return_value_getFBConfigAttrib$4=getFBConfigAttrib(fbconfigs[(signed long int)i], 5);
        if(return_value_getFBConfigAttrib$4 == 0)
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value_getFBConfigAttrib$5=getFBConfigAttrib(fbconfigs[(signed long int)i], 0x800B);
          tmp_if_expr$6 = !(return_value_getFBConfigAttrib$5 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$6)
        {
          signed int return_value_getFBConfigAttrib$7;
          return_value_getFBConfigAttrib$7=getFBConfigAttrib(fbconfigs[(signed long int)i], 0x8011);
          if(!((0x00000001 & return_value_getFBConfigAttrib$7) == 0))
          {
            signed int return_value_getFBConfigAttrib$8;
            return_value_getFBConfigAttrib$8=getFBConfigAttrib(fbconfigs[(signed long int)i], 0x8010);
            if((0x00000001 & return_value_getFBConfigAttrib$8) == 0)
            {
              if(trustWindowBit == 0)
                goto __CPROVER_DUMP_L11;

            }

            else
            {

            __CPROVER_DUMP_L11:
              ;
              (result + (signed long int)*found)->redBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 8);
              (result + (signed long int)*found)->greenBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 9);
              (result + (signed long int)*found)->blueBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 10);
              (result + (signed long int)*found)->alphaBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 11);
              (result + (signed long int)*found)->depthBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 12);
              (result + (signed long int)*found)->stencilBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 13);
              (result + (signed long int)*found)->accumRedBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 14);
              (result + (signed long int)*found)->accumGreenBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 15);
              (result + (signed long int)*found)->accumBlueBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 16);
              (result + (signed long int)*found)->accumAlphaBits=getFBConfigAttrib(fbconfigs[(signed long int)i], 17);
              (result + (signed long int)*found)->auxBuffers=getFBConfigAttrib(fbconfigs[(signed long int)i], 7);
              (result + (signed long int)*found)->stereo=getFBConfigAttrib(fbconfigs[(signed long int)i], 6);
              if(!(_glfwWin.has_GLX_ARB_multisample == 0))
                (result + (signed long int)*found)->samples=getFBConfigAttrib(fbconfigs[(signed long int)i], 0x186a1);

              else
                (result + (signed long int)*found)->samples = 0;
              signed int return_value_getFBConfigAttrib$9;
              return_value_getFBConfigAttrib$9=getFBConfigAttrib(fbconfigs[(signed long int)i], 0x8013);
              (result + (signed long int)*found)->platformID = (signed long int)return_value_getFBConfigAttrib$9;
              *found = *found + 1u;
            }
          }

        }

      }
      XFree((void *)fbconfigs);
      return result;
    }
  }
}

// getRawTime
// file x11_time.c line 40
static unsigned long int getRawTime(void)
{
  if(!(_glfwLibrary.Timer.monotonic == 0))
  {
    struct timespec ts;
    clock_gettime(1, &ts);
    return (unsigned long int)ts.tv_sec * (unsigned long int)1000000000 + (unsigned long int)ts.tv_nsec;
  }

  else
  {
    struct timeval tv;
    gettimeofday(&tv, (struct timezone *)(void *)0);
    return (unsigned long int)tv.tv_sec * (unsigned long int)1000000 + (unsigned long int)tv.tv_usec;
  }
}

// getSupportedAtom
// file x11_window.c line 127
static unsigned long int getSupportedAtom(unsigned long int *supportedAtoms, unsigned long int atomCount, const char *atomName)
{
  unsigned long int atom;
  atom=XInternAtom(_glfwLibrary.display, atomName, 1);
  if(!(atom == 0ul))
  {
    unsigned long int i = (unsigned long int)0;
    for( ; !(i >= atomCount); i = i + 1ul)
      if(supportedAtoms[(signed long int)i] == atom)
        return atom;

  }

  return (unsigned long int)0L;
}

// getWindowProperty
// file x11_window.c line 92
static unsigned long int getWindowProperty(unsigned long int window, unsigned long int property, unsigned long int type, unsigned char **value)
{
  unsigned long int actualType;
  signed int actualFormat;
  unsigned long int itemCount;
  unsigned long int bytesAfter;
  XGetWindowProperty(_glfwLibrary.display, window, property, (signed long int)0, 0x7fffffffffffffffL, 0, type, &actualType, &actualFormat, &itemCount, &bytesAfter, value);
  if(!(actualType == type))
    return (unsigned long int)0;

  else
    return itemCount;
}

// glfwBroadcastCond
// file ../thread.c line 313
void glfwBroadcastCond(void *cond)
{
  if(!(cond == NULL) && !(_glfwInitialized == 0))
    _glfwPlatformBroadcastCond(cond);

}

// glfwCloseWindow
// file ../window.c line 674
void glfwCloseWindow(void)
{
  if(!(_glfwInitialized == 0))
  {
    glfwEnable(0x00030001);
    _glfwPlatformCloseWindow();
    memset((void *)&_glfwWin, 0, sizeof(struct _GLFWwin_struct) /*432ul*/ );
  }

}

// glfwCreateCond
// file ../thread.c line 248
void * glfwCreateCond(void)
{
  if(_glfwInitialized == 0)
    return (void *)0;

  else
  {
    void *return_value__glfwPlatformCreateCond$1;
    return_value__glfwPlatformCreateCond$1=_glfwPlatformCreateCond();
    return return_value__glfwPlatformCreateCond$1;
  }
}

// glfwCreateMutex
// file ../thread.c line 184
void * glfwCreateMutex(void)
{
  if(_glfwInitialized == 0)
    return (void *)0;

  else
  {
    void *return_value__glfwPlatformCreateMutex$1;
    return_value__glfwPlatformCreateMutex$1=_glfwPlatformCreateMutex();
    return return_value__glfwPlatformCreateMutex$1;
  }
}

// glfwCreateThread
// file ../thread.c line 105
signed int glfwCreateThread(void (*fun)(void *), void *arg)
{
  if(_glfwInitialized == 0)
    return -1;

  else
  {
    signed int return_value__glfwPlatformCreateThread$1;
    return_value__glfwPlatformCreateThread$1=_glfwPlatformCreateThread(fun, arg);
    return return_value__glfwPlatformCreateThread$1;
  }
}

// glfwDestroyCond
// file ../thread.c line 264
void glfwDestroyCond(void *cond)
{
  if(!(cond == NULL) && !(_glfwInitialized == 0))
    _glfwPlatformDestroyCond(cond);

}

// glfwDestroyMutex
// file ../thread.c line 200
void glfwDestroyMutex(void *mutex)
{
  if(!(mutex == NULL) && !(_glfwInitialized == 0))
    _glfwPlatformDestroyMutex(mutex);

}

// glfwDestroyThread
// file ../thread.c line 124
void glfwDestroyThread(signed int ID)
{
  if(!(_glfwInitialized == 0))
  {
    if(ID >= 1)
      _glfwPlatformDestroyThread(ID);

  }

}

// glfwDisable
// file ../enable.c line 280
void glfwDisable(signed int token)
{
  if(!(_glfwInitialized == 0))
    switch(token)
    {
      case 0x00030001:
      {
        disableMouseCursor();
        break;
      }
      case 0x00030002:
      {
        disableStickyKeys();
        break;
      }
      case 0x00030003:
      {
        disableStickyMouseButtons();
        break;
      }
      case 0x00030004:
      {
        disableSystemKeys();
        break;
      }
      case 0x00030005:
      {
        disableKeyRepeat();
        break;
      }
      case 0x00030006:
        disableAutoPollEvents();
    }

}

// glfwEnable
// file ../include/GL/glfw.h line 501
void glfwEnable(signed int token)
{
  if(!(_glfwInitialized == 0))
    switch(token)
    {
      case 0x00030001:
      {
        enableMouseCursor();
        break;
      }
      case 0x00030002:
      {
        enableStickyKeys();
        break;
      }
      case 0x00030003:
      {
        enableStickyMouseButtons();
        break;
      }
      case 0x00030004:
      {
        enableSystemKeys();
        break;
      }
      case 0x00030005:
      {
        enableKeyRepeat();
        break;
      }
      case 0x00030006:
        enableAutoPollEvents();
    }

}

// glfwExtensionSupported
// file ../glext.c line 182
signed int glfwExtensionSupported(const char *extension)
{
  const unsigned char *extensions;
  unsigned char *where;
  _Bool tmp_if_expr$2;
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return 0;

  else
  {
    char *return_value_strchr$1;
    return_value_strchr$1=strchr(extension, 32);
    where = (unsigned char *)return_value_strchr$1;
    if(!(where == ((unsigned char *)NULL)))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*extension == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return 0;

    else
    {
      if(!(_glfwWin.glMajor >= 3))
      {
        extensions=glGetString((unsigned int)0x1F03);
        if(!(extensions == ((const unsigned char *)NULL)))
        {
          signed int return_value__glfwStringInExtensionString$3;
          return_value__glfwStringInExtensionString$3=_glfwStringInExtensionString(extension, extensions);
          if(!(return_value__glfwStringInExtensionString$3 == 0))
            return 1;

        }

      }

      else
      {
        signed int count;
        signed int i;
        glGetIntegerv((unsigned int)0x821D, &count);
        i = 0;
        if(!(i >= count))
        {
          const unsigned char *return_value;
          return_value=_glfwWin.GetStringi((unsigned int)0x1F03, (unsigned int)i);
          signed int return_value_strcmp$4;
          return_value_strcmp$4=strcmp((const char *)return_value, extension);
          if(return_value_strcmp$4 == 0)
            return 1;

          i = i + 1;
        }

      }
      signed int return_value__glfwPlatformExtensionSupported$5;
      return_value__glfwPlatformExtensionSupported$5=_glfwPlatformExtensionSupported(extension);
      if(!(return_value__glfwPlatformExtensionSupported$5 == 0))
        return 1;

      else
        return 0;
    }
  }
}

// glfwFreeImage
// file ../image.c line 419
void glfwFreeImage(struct anonymous$60 *img)
{
  if(!(_glfwInitialized == 0))
  {
    if(!(img->Data == ((unsigned char *)NULL)))
    {
      free((void *)img->Data);
      img->Data = (unsigned char *)(void *)0;
    }

    img->Width = 0;
    img->Height = 0;
    img->Format = 0;
    img->BytesPerPixel = 0;
  }

}

// glfwGetDesktopMode
// file ../fullscreen.c line 85
void glfwGetDesktopMode(struct anonymous$57 *mode)
{
  if(!(mode == ((struct anonymous$57 *)NULL)) && !(_glfwInitialized == 0))
    *mode = _glfwLibrary.desktopMode;

}

// glfwGetGLVersion
// file ../glext.c line 263
void glfwGetGLVersion(signed int *major, signed int *minor, signed int *rev)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    if(!(major == ((signed int *)NULL)))
      *major = _glfwWin.glMajor;

    if(!(minor == ((signed int *)NULL)))
      *minor = _glfwWin.glMinor;

    if(!(rev == ((signed int *)NULL)))
      *rev = _glfwWin.glRevision;

  }

}

// glfwGetJoystickButtons
// file ../joystick.c line 80
signed int glfwGetJoystickButtons(signed int joy, unsigned char *buttons, signed int numbuttons)
{
  signed int i;
  if(_glfwInitialized == 0)
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= numbuttons); i = i + 1)
      buttons[(signed long int)i] = (unsigned char)0;
    signed int return_value__glfwPlatformGetJoystickButtons$1;
    return_value__glfwPlatformGetJoystickButtons$1=_glfwPlatformGetJoystickButtons(joy, buttons, numbuttons);
    return return_value__glfwPlatformGetJoystickButtons$1;
  }
}

// glfwGetJoystickParam
// file ../joystick.c line 42
signed int glfwGetJoystickParam(signed int joy, signed int param)
{
  if(_glfwInitialized == 0)
    return 0;

  else
  {
    signed int return_value__glfwPlatformGetJoystickParam$1;
    return_value__glfwPlatformGetJoystickParam$1=_glfwPlatformGetJoystickParam(joy, param);
    return return_value__glfwPlatformGetJoystickParam$1;
  }
}

// glfwGetJoystickPos
// file ../joystick.c line 57
signed int glfwGetJoystickPos(signed int joy, float *pos, signed int numaxes)
{
  signed int i;
  if(_glfwInitialized == 0)
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= numaxes); i = i + 1)
      pos[(signed long int)i] = 0.0f;
    signed int return_value__glfwPlatformGetJoystickPos$1;
    return_value__glfwPlatformGetJoystickPos$1=_glfwPlatformGetJoystickPos(joy, pos, numaxes);
    return return_value__glfwPlatformGetJoystickPos$1;
  }
}

// glfwGetKey
// file ../input.c line 38
signed int glfwGetKey(signed int key)
{
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return 0;

  else
    if(key >= 326 || !(key >= 0))
      return 0;

    else
      if((signed int)_glfwInput.Key[(signed long int)key] == 2)
      {
        _glfwInput.Key[(signed long int)key] = (char)0;
        return 1;
      }

      else
        return (signed int)_glfwInput.Key[(signed long int)key];
}

// glfwGetMouseButton
// file ../input.c line 66
signed int glfwGetMouseButton(signed int button)
{
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return 0;

  else
    if(button >= 8 || !(button >= 0))
      return 0;

    else
      if((signed int)_glfwInput.MouseButton[(signed long int)button] == 2)
      {
        _glfwInput.MouseButton[(signed long int)button] = (char)0;
        return 1;
      }

      else
        return (signed int)_glfwInput.MouseButton[(signed long int)button];
}

// glfwGetMousePos
// file ../input.c line 94
void glfwGetMousePos(signed int *xpos, signed int *ypos)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    if(!(xpos == ((signed int *)NULL)))
      *xpos = _glfwInput.MousePosX;

    if(!(ypos == ((signed int *)NULL)))
      *ypos = _glfwInput.MousePosY;

  }

}

// glfwGetMouseWheel
// file ../input.c line 149
signed int glfwGetMouseWheel(void)
{
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return 0;

  else
    return _glfwInput.WheelPos;
}

// glfwGetNumberOfProcessors
// file ../thread.c line 331
signed int glfwGetNumberOfProcessors(void)
{
  if(_glfwInitialized == 0)
    return 0;

  else
  {
    signed int return_value__glfwPlatformGetNumberOfProcessors$1;
    return_value__glfwPlatformGetNumberOfProcessors$1=_glfwPlatformGetNumberOfProcessors();
    return return_value__glfwPlatformGetNumberOfProcessors$1;
  }
}

// glfwGetProcAddress
// file ../include/GL/glfw.h line 481
void * glfwGetProcAddress(const char *procname)
{
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return (void *)0;

  else
  {
    void *return_value__glfwPlatformGetProcAddress$1;
    return_value__glfwPlatformGetProcAddress$1=_glfwPlatformGetProcAddress(procname);
    return return_value__glfwPlatformGetProcAddress$1;
  }
}

// glfwGetThreadID
// file ../thread.c line 168
signed int glfwGetThreadID(void)
{
  if(_glfwInitialized == 0)
    return 0;

  else
  {
    signed int return_value__glfwPlatformGetThreadID$1;
    return_value__glfwPlatformGetThreadID$1=_glfwPlatformGetThreadID();
    return return_value__glfwPlatformGetThreadID$1;
  }
}

// glfwGetTime
// file ../include/GL/glfw.h line 475
double glfwGetTime(void)
{
  if(_glfwInitialized == 0)
    return 0.0;

  else
  {
    double return_value__glfwPlatformGetTime$1;
    return_value__glfwPlatformGetTime$1=_glfwPlatformGetTime();
    return return_value__glfwPlatformGetTime$1;
  }
}

// glfwGetVersion
// file ../init.c line 104
void glfwGetVersion(signed int *major, signed int *minor, signed int *rev)
{
  if(!(major == ((signed int *)NULL)))
    *major = 2;

  if(!(minor == ((signed int *)NULL)))
    *minor = 7;

  if(!(rev == ((signed int *)NULL)))
    *rev = 9;

}

// glfwGetVideoModes
// file ../fullscreen.c line 42
signed int glfwGetVideoModes(struct anonymous$57 *list, signed int maxcount)
{
  signed int count;
  signed int i;
  signed int swap;
  signed int res1;
  signed int res2;
  signed int depth1;
  signed int depth2;
  struct anonymous$57 vm;
  if(list == ((struct anonymous$57 *)NULL) || _glfwInitialized == 0 || !(maxcount >= 1))
    return 0;

  else
  {
    count=_glfwPlatformGetVideoModes(list, maxcount);
    do
    {
      swap = 0;
      i = 0;
      for( ; !(i >= count + -1); i = i + 1)
      {
        res1 = (list + (signed long int)i)->Width * (list + (signed long int)i)->Height;
        depth1 = (list + (signed long int)i)->RedBits + (list + (signed long int)i)->GreenBits + (list + (signed long int)i)->BlueBits;
        res2 = (list + (signed long int)(i + 1))->Width * (list + (signed long int)(i + 1))->Height;
        depth2 = (list + (signed long int)(i + 1))->RedBits + (list + (signed long int)(i + 1))->GreenBits + (list + (signed long int)(i + 1))->BlueBits;
        if(depth2 == depth1 && !(res2 >= res1) || !(depth2 >= depth1))
        {
          vm = list[(signed long int)i];
          list[(signed long int)i] = list[(signed long int)(i + 1)];
          list[(signed long int)(i + 1)] = vm;
          swap = 1;
        }

      }
    }
    while(!(swap == 0));
    return count;
  }
}

// glfwGetWindowParam
// file ../window.c line 847
signed int glfwGetWindowParam(signed int param)
{
  if(_glfwInitialized == 0)
    return 0;

  else
    if(_glfwWin.opened == 0)
    {
      if(param == 0x00020001)
        return 0;

      return 0;
    }

    else
      switch(param)
      {
        case 0x00020001:
          return 1;
        case 0x00020002:
          return _glfwWin.active;
        case 0x00020003:
          return _glfwWin.iconified;
        case 0x00020004:
          return _glfwWin.accelerated;
        case 0x00020005:
          return _glfwWin.redBits;
        case 0x00020006:
          return _glfwWin.greenBits;
        case 0x00020007:
          return _glfwWin.blueBits;
        case 0x00020008:
          return _glfwWin.alphaBits;
        case 0x00020009:
          return _glfwWin.depthBits;
        case 0x0002000A:
          return _glfwWin.stencilBits;
        case 0x0002000C:
          return _glfwWin.accumRedBits;
        case 0x0002000D:
          return _glfwWin.accumGreenBits;
        case 0x0002000E:
          return _glfwWin.accumBlueBits;
        case 0x0002000F:
          return _glfwWin.accumAlphaBits;
        case 0x00020010:
          return _glfwWin.auxBuffers;
        case 0x00020011:
          return _glfwWin.stereo;
        case 0x0002000B:
          return _glfwWin.refreshRate;
        case 0x00020012:
          return _glfwWin.windowNoResize;
        case 0x00020013:
          return _glfwWin.samples;
        case 0x00020014:
          return _glfwWin.glMajor;
        case 0x00020015:
          return _glfwWin.glMinor;
        case 0x00020016:
          return _glfwWin.glForward;
        case 0x00020017:
          return _glfwWin.glDebug;
        case 0x00020018:
          return _glfwWin.glProfile;
        default:
          return 0;
      }
}

// glfwGetWindowSize
// file ../window.c line 710
void glfwGetWindowSize(signed int *width, signed int *height)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    if(!(width == ((signed int *)NULL)))
      *width = _glfwWin.width;

    if(!(height == ((signed int *)NULL)))
      *height = _glfwWin.height;

  }

}

// glfwIconifyWindow
// file ../window.c line 775
void glfwIconifyWindow(void)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0) && _glfwWin.iconified == 0)
    _glfwPlatformIconifyWindow();

}

// glfwInit
// file ../include/GL/glfw.h line 429
signed int glfwInit(void)
{
  if(!(_glfwInitialized == 0))
    return 1;

  else
  {
    memset((void *)&_glfwLibrary, 0, sizeof(struct anonymous$58) /*152ul*/ );
    memset((void *)&_glfwWin, 0, sizeof(struct _GLFWwin_struct) /*432ul*/ );
    _glfwWin.opened = 0;
    _glfwWin.sysKeysDisabled = 0;
    _glfwClearWindowHints();
    signed int return_value__glfwPlatformInit$1;
    return_value__glfwPlatformInit$1=_glfwPlatformInit();
    if(return_value__glfwPlatformInit$1 == 0)
      return 0;

    else
    {
      _glfwInitialized = 1;
      return 1;
    }
  }
}

// glfwLoadMemoryTexture2D
// file ../image.c line 484
signed int glfwLoadMemoryTexture2D(const void *data, signed long int size, signed int flags)
{
  struct anonymous$60 img;
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return 0;

  else
  {
    if(_glfwWin.has_GL_ARB_texture_non_power_of_two == 0)
      flags = flags & ~0x00000001;

    signed int return_value_glfwReadMemoryImage$1;
    return_value_glfwReadMemoryImage$1=glfwReadMemoryImage(data, size, &img, flags);
    if(return_value_glfwReadMemoryImage$1 == 0)
      return 0;

    else
    {
      signed int return_value_glfwLoadTextureImage2D$2;
      return_value_glfwLoadTextureImage2D$2=glfwLoadTextureImage2D(&img, flags);
      if(return_value_glfwLoadTextureImage2D$2 == 0)
        return 0;

      else
      {
        glfwFreeImage(&img);
        return 1;
      }
    }
  }
}

// glfwLoadTexture2D
// file ../image.c line 446
signed int glfwLoadTexture2D(const char *name, signed int flags)
{
  struct anonymous$60 img;
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return 0;

  else
  {
    if(_glfwWin.has_GL_ARB_texture_non_power_of_two == 0)
      flags = flags & ~0x00000001;

    signed int return_value_glfwReadImage$1;
    return_value_glfwReadImage$1=glfwReadImage(name, &img, flags);
    if(return_value_glfwReadImage$1 == 0)
      return 0;

    else
    {
      signed int return_value_glfwLoadTextureImage2D$2;
      return_value_glfwLoadTextureImage2D$2=glfwLoadTextureImage2D(&img, flags);
      if(return_value_glfwLoadTextureImage2D$2 == 0)
        return 0;

      else
      {
        glfwFreeImage(&img);
        return 1;
      }
    }
  }
}

// glfwLoadTextureImage2D
// file ../image.c line 522
signed int glfwLoadTextureImage2D(struct anonymous$60 *img, signed int flags)
{
  signed int UnpackAlignment;
  signed int GenMipMap;
  signed int level;
  signed int format;
  signed int AutoGen;
  signed int newsize;
  signed int n;
  unsigned char *data;
  unsigned char *dataptr;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  unsigned char *tmp_post$4;
  unsigned char *tmp_post$5;
  if(_glfwWin.opened == 0 || _glfwInitialized == 0)
    return 0;

  else
  {
    if(_glfwWin.glMajor == 1 && _glfwWin.glMinor == 0)
    {
      if(img->Format == 0x1906)
      {
        img->BytesPerPixel = 4;
        newsize = img->Width * img->Height * img->BytesPerPixel;
        void *return_value_malloc$1;
        return_value_malloc$1=malloc((unsigned long int)newsize);
        data = (unsigned char *)return_value_malloc$1;
        if(data == ((unsigned char *)NULL))
        {
          free((void *)img->Data);
          return 0;
        }

        dataptr = data;
        n = 0;
        for( ; !(n >= img->Height * img->Width); n = n + 1)
        {
          tmp_post$2 = dataptr;
          dataptr = dataptr + 1l;
          *tmp_post$2 = (unsigned char)255;
          tmp_post$3 = dataptr;
          dataptr = dataptr + 1l;
          *tmp_post$3 = (unsigned char)255;
          tmp_post$4 = dataptr;
          dataptr = dataptr + 1l;
          *tmp_post$4 = (unsigned char)255;
          tmp_post$5 = dataptr;
          dataptr = dataptr + 1l;
          *tmp_post$5 = img->Data[(signed long int)n];
        }
        free((void *)img->Data);
        img->Data = data;
      }

    }

    glGetIntegerv((unsigned int)0x0CF5, &UnpackAlignment);
    glPixelStorei((unsigned int)0x0CF5, 1);
    AutoGen = (signed int)((flags & 0x00000004) != 0 && _glfwWin.has_GL_SGIS_generate_mipmap != 0);
    if(!(AutoGen == 0))
    {
      glGetTexParameteriv((unsigned int)0x0DE1, (unsigned int)0x8191, &GenMipMap);
      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x8191, 1);
    }

    if(_glfwWin.glMajor == 1 && _glfwWin.glMinor == 0)
      format = img->BytesPerPixel;

    else
      format = img->Format;
    level = 0;
    do
    {
      glTexImage2D((unsigned int)0x0DE1, level, format, img->Width, img->Height, 0, (unsigned int)format, (unsigned int)0x1401, (void *)img->Data);
      if(AutoGen == 0 && !((0x00000004 & flags) == 0))
      {
        signed int return_value_HalveImage$6;
        return_value_HalveImage$6=HalveImage(img->Data, &img->Width, &img->Height, img->BytesPerPixel);
        level = return_value_HalveImage$6 != 0 ? level + 1 : 0;
      }

    }
    while(!(level == 0));
    if(!(AutoGen == 0))
      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x8191, GenMipMap);

    glPixelStorei((unsigned int)0x0CF5, UnpackAlignment);
    return 1;
  }
}

// glfwLockMutex
// file ../thread.c line 216
void glfwLockMutex(void *mutex)
{
  if(!(mutex == NULL) || !(_glfwInitialized == 0))
    _glfwPlatformLockMutex(mutex);

}

// glfwOpenWindow
// file ../include/GL/glfw.h line 434
signed int glfwOpenWindow(signed int width, signed int height, signed int redbits, signed int greenbits, signed int bluebits, signed int alphabits, signed int depthbits, signed int stencilbits, signed int mode)
{
  struct anonymous$0 fbconfig;
  struct anonymous wndconfig;
  _Bool tmp_if_expr$3;
  signed int return_value_glfwExtensionSupported$2;
  _Bool tmp_if_expr$5;
  signed int return_value_glfwExtensionSupported$4;
  if(_glfwInitialized == 0 || !(_glfwWin.opened == 0))
    return 0;

  else
  {
    fbconfig.redBits=Max(redbits, 0);
    fbconfig.greenBits=Max(greenbits, 0);
    fbconfig.blueBits=Max(bluebits, 0);
    fbconfig.alphaBits=Max(alphabits, 0);
    fbconfig.depthBits=Max(depthbits, 0);
    fbconfig.stencilBits=Max(stencilbits, 0);
    fbconfig.accumRedBits=Max(_glfwLibrary.hints.accumRedBits, 0);
    fbconfig.accumGreenBits=Max(_glfwLibrary.hints.accumGreenBits, 0);
    fbconfig.accumBlueBits=Max(_glfwLibrary.hints.accumBlueBits, 0);
    fbconfig.accumAlphaBits=Max(_glfwLibrary.hints.accumAlphaBits, 0);
    fbconfig.auxBuffers=Max(_glfwLibrary.hints.auxBuffers, 0);
    fbconfig.stereo = _glfwLibrary.hints.stereo != 0 ? 1 : 0;
    fbconfig.samples=Max(_glfwLibrary.hints.samples, 0);
    wndconfig.mode = mode;
    wndconfig.refreshRate=Max(_glfwLibrary.hints.refreshRate, 0);
    wndconfig.windowNoResize = _glfwLibrary.hints.windowNoResize != 0 ? 1 : 0;
    wndconfig.glMajor=Max(_glfwLibrary.hints.glMajor, 1);
    wndconfig.glMinor=Max(_glfwLibrary.hints.glMinor, 0);
    wndconfig.glForward = _glfwLibrary.hints.glForward != 0 ? 1 : 0;
    wndconfig.glDebug = _glfwLibrary.hints.glDebug != 0 ? 1 : 0;
    wndconfig.glProfile = _glfwLibrary.hints.glProfile;
    if(wndconfig.glMajor == 1 && wndconfig.glMinor >= 6)
      return 0;

    else
      if(wndconfig.glMajor == 2 && wndconfig.glMinor >= 2)
        return 0;

      else
        if(wndconfig.glMajor == 3 && wndconfig.glMinor >= 4)
          return 0;

    if(!(wndconfig.glProfile == 0) && (wndconfig.glMajor == 3 && !(wndconfig.glMinor >= 2) || !(wndconfig.glMajor >= 3)))
      return 0;

    else
      if(!(wndconfig.glForward == 0) && !(wndconfig.glMajor >= 3))
        return 0;

      else
      {
        _glfwClearWindowHints();
        if(!(mode == 0x00010001) && !(mode == 0x00010002))
          return 0;

        else
        {
          _glfwWin.active = 1;
          _glfwWin.iconified = 0;
          _glfwWin.mouseLock = 0;
          _glfwWin.autoPollEvents = 1;
          _glfwClearInput();
          _glfwWin.windowSizeCallback = (void (*)(signed int, signed int))(void *)0;
          _glfwWin.windowCloseCallback = (signed int (*)(void))(void *)0;
          _glfwWin.windowRefreshCallback = (void (*)(void))(void *)0;
          _glfwWin.keyCallback = (void (*)(signed int, signed int))(void *)0;
          _glfwWin.charCallback = (void (*)(signed int, signed int))(void *)0;
          _glfwWin.mousePosCallback = (void (*)(signed int, signed int))(void *)0;
          _glfwWin.mouseButtonCallback = (void (*)(signed int, signed int))(void *)0;
          _glfwWin.mouseWheelCallback = (void (*)(signed int))(void *)0;
          if(width >= 1 && !(height >= 1))
            height = (width * 3) / 4;

          else
            if(height >= 1 && !(width >= 1))
              width = (height * 4) / 3;

            else
              if(!(height >= 1) && !(width >= 1))
              {
                width = 640;
                height = 480;
              }

          _glfwWin.width = width;
          _glfwWin.height = height;
          _glfwWin.fullscreen = mode == 0x00010002 ? 1 : 0;
          signed int return_value__glfwPlatformOpenWindow$1;
          return_value__glfwPlatformOpenWindow$1=_glfwPlatformOpenWindow(width, height, &wndconfig, &fbconfig);
          if(return_value__glfwPlatformOpenWindow$1 == 0)
          {
            glfwCloseWindow();
            return 0;
          }

          else
          {
            _glfwWin.opened = 1;
            _glfwPlatformRefreshWindowParams();
            _glfwRefreshContextParams();
            if(_glfwWin.glMajor == wndconfig.glMajor && !(_glfwWin.glMinor >= wndconfig.glMinor) || !(_glfwWin.glMajor >= wndconfig.glMajor))
            {
              glfwCloseWindow();
              return 0;
            }

            else
            {
              if(_glfwWin.glMajor >= 2)
                tmp_if_expr$3 = (_Bool)1;

              else
              {
                return_value_glfwExtensionSupported$2=glfwExtensionSupported("GL_ARB_texture_non_power_of_two");
                tmp_if_expr$3 = return_value_glfwExtensionSupported$2 != 0 ? (_Bool)1 : (_Bool)0;
              }
              _glfwWin.has_GL_ARB_texture_non_power_of_two = (signed int)tmp_if_expr$3;
              if(_glfwWin.glMajor >= 2 || _glfwWin.glMinor >= 4)
                tmp_if_expr$5 = (_Bool)1;

              else
              {
                return_value_glfwExtensionSupported$4=glfwExtensionSupported("GL_SGIS_generate_mipmap");
                tmp_if_expr$5 = return_value_glfwExtensionSupported$4 != 0 ? (_Bool)1 : (_Bool)0;
              }
              _glfwWin.has_GL_SGIS_generate_mipmap = (signed int)tmp_if_expr$5;
              if(_glfwWin.glMajor >= 3)
              {
                void *return_value_glfwGetProcAddress$6;
                return_value_glfwGetProcAddress$6=glfwGetProcAddress("glGetStringi");
                _glfwWin.GetStringi = (const unsigned char * (*)(unsigned int, unsigned int))return_value_glfwGetProcAddress$6;
                if(_glfwWin.GetStringi == ((const unsigned char * (*)(unsigned int, unsigned int))NULL))
                {
                  glfwCloseWindow();
                  return 0;
                }

              }

              if(mode == 0x00010002)
                glfwDisable(0x00030001);

              glClear((unsigned int)0x00004000);
              _glfwPlatformSwapBuffers();
              return 1;
            }
          }
        }
      }
  }
}

// glfwOpenWindowHint
// file ../include/GL/glfw.h line 435
void glfwOpenWindowHint(signed int target, signed int hint)
{
  if(!(_glfwInitialized == 0))
    switch(target)
    {
      case 0x0002000B:
      {
        _glfwLibrary.hints.refreshRate = hint;
        break;
      }
      case 0x0002000C:
      {
        _glfwLibrary.hints.accumRedBits = hint;
        break;
      }
      case 0x0002000D:
      {
        _glfwLibrary.hints.accumGreenBits = hint;
        break;
      }
      case 0x0002000E:
      {
        _glfwLibrary.hints.accumBlueBits = hint;
        break;
      }
      case 0x0002000F:
      {
        _glfwLibrary.hints.accumAlphaBits = hint;
        break;
      }
      case 0x00020010:
      {
        _glfwLibrary.hints.auxBuffers = hint;
        break;
      }
      case 0x00020011:
      {
        _glfwLibrary.hints.stereo = hint;
        break;
      }
      case 0x00020012:
      {
        _glfwLibrary.hints.windowNoResize = hint;
        break;
      }
      case 0x00020013:
      {
        _glfwLibrary.hints.samples = hint;
        break;
      }
      case 0x00020014:
      {
        _glfwLibrary.hints.glMajor = hint;
        break;
      }
      case 0x00020015:
      {
        _glfwLibrary.hints.glMinor = hint;
        break;
      }
      case 0x00020016:
      {
        _glfwLibrary.hints.glForward = hint;
        break;
      }
      case 0x00020017:
      {
        _glfwLibrary.hints.glDebug = hint;
        break;
      }
      case 0x00020018:
        _glfwLibrary.hints.glProfile = hint;
    }

}

// glfwPollEvents
// file ../window.c line 979
void glfwPollEvents(void)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwPlatformPollEvents();

}

// glfwReadImage
// file ../image.c line 276
signed int glfwReadImage(const char *name, struct anonymous$60 *img, signed int flags)
{
  struct anonymous$59 stream;
  if(_glfwInitialized == 0)
    return 0;

  else
  {
    img->Width = 0;
    img->Height = 0;
    img->BytesPerPixel = 0;
    img->Data = (unsigned char *)(void *)0;
    signed int return_value__glfwOpenFileStream$1;
    return_value__glfwOpenFileStream$1=_glfwOpenFileStream(&stream, name, "rb");
    if(return_value__glfwOpenFileStream$1 == 0)
      return 0;

    else
    {
      signed int return_value__glfwReadTGA$2;
      return_value__glfwReadTGA$2=_glfwReadTGA(&stream, img, flags);
      if(return_value__glfwReadTGA$2 == 0)
      {
        _glfwCloseStream(&stream);
        return 0;
      }

      else
      {
        _glfwCloseStream(&stream);
        if((0x00000001 & flags) == 0)
        {
          signed int return_value_RescaleImage$3;
          return_value_RescaleImage$3=RescaleImage(img);
          if(return_value_RescaleImage$3 == 0)
            return 0;

        }

        if(!(img->BytesPerPixel == 1))
        {
          if(img->BytesPerPixel == 3)
            goto __CPROVER_DUMP_L9;

          if(img->BytesPerPixel == 4)
            goto __CPROVER_DUMP_L10;

        }

        if(!((0x00000008 & flags) == 0))
          img->Format = 0x1906;

        else
          img->Format = 0x1909;
        goto __CPROVER_DUMP_L11;

      __CPROVER_DUMP_L9:
        ;
        img->Format = 0x1907;
        goto __CPROVER_DUMP_L11;

      __CPROVER_DUMP_L10:
        ;
        img->Format = 0x1908;

      __CPROVER_DUMP_L11:
        ;
        return 1;
      }
    }
  }
}

// glfwReadMemoryImage
// file ../image.c line 348
signed int glfwReadMemoryImage(const void *data, signed long int size, struct anonymous$60 *img, signed int flags)
{
  struct anonymous$59 stream;
  if(_glfwInitialized == 0)
    return 0;

  else
  {
    img->Width = 0;
    img->Height = 0;
    img->BytesPerPixel = 0;
    img->Data = (unsigned char *)(void *)0;
    signed int return_value__glfwOpenBufferStream$1;
    return_value__glfwOpenBufferStream$1=_glfwOpenBufferStream(&stream, (void *)data, size);
    if(return_value__glfwOpenBufferStream$1 == 0)
      return 0;

    else
    {
      signed int return_value__glfwReadTGA$2;
      return_value__glfwReadTGA$2=_glfwReadTGA(&stream, img, flags);
      if(return_value__glfwReadTGA$2 == 0)
      {
        _glfwCloseStream(&stream);
        return 0;
      }

      else
      {
        _glfwCloseStream(&stream);
        if((0x00000001 & flags) == 0)
        {
          signed int return_value_RescaleImage$3;
          return_value_RescaleImage$3=RescaleImage(img);
          if(return_value_RescaleImage$3 == 0)
            return 0;

        }

        if(!(img->BytesPerPixel == 1))
        {
          if(img->BytesPerPixel == 3)
            goto __CPROVER_DUMP_L9;

          if(img->BytesPerPixel == 4)
            goto __CPROVER_DUMP_L10;

        }

        if(!((0x00000008 & flags) == 0))
          img->Format = 0x1906;

        else
          img->Format = 0x1909;
        goto __CPROVER_DUMP_L11;

      __CPROVER_DUMP_L9:
        ;
        img->Format = 0x1907;
        goto __CPROVER_DUMP_L11;

      __CPROVER_DUMP_L10:
        ;
        img->Format = 0x1908;

      __CPROVER_DUMP_L11:
        ;
        return 1;
      }
    }
  }
}

// glfwRestoreWindow
// file ../window.c line 791
void glfwRestoreWindow(void)
{
  if(!(_glfwWin.iconified == 0) && !(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    _glfwPlatformRestoreWindow();
    _glfwPlatformRefreshWindowParams();
  }

}

// glfwSetCharCallback
// file ../input.c line 197
void glfwSetCharCallback(void (*cbfun)(signed int, signed int))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwWin.charCallback = cbfun;

}

// glfwSetKeyCallback
// file ../include/GL/glfw.h line 463
void glfwSetKeyCallback(void (*cbfun)(signed int, signed int))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwWin.keyCallback = cbfun;

}

// glfwSetMouseButtonCallback
// file ../input.c line 213
void glfwSetMouseButtonCallback(void (*cbfun)(signed int, signed int))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwWin.mouseButtonCallback = cbfun;

}

// glfwSetMousePos
// file ../input.c line 117
void glfwSetMousePos(signed int xpos, signed int ypos)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    if(!(xpos == _glfwInput.MousePosX) || !(ypos == _glfwInput.MousePosY))
    {
      _glfwInput.MousePosX = xpos;
      _glfwInput.MousePosY = ypos;
      if(_glfwWin.mouseLock == 0)
        _glfwPlatformSetMouseCursorPos(xpos, ypos);

    }

  }

}

// glfwSetMousePosCallback
// file ../input.c line 229
void glfwSetMousePosCallback(void (*cbfun)(signed int, signed int))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    _glfwWin.mousePosCallback = cbfun;
    if(!(cbfun == ((void (*)(signed int, signed int))NULL)))
      cbfun(_glfwInput.MousePosX, _glfwInput.MousePosY);

  }

}

// glfwSetMouseWheel
// file ../input.c line 165
void glfwSetMouseWheel(signed int pos)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwInput.WheelPos = pos;

}

// glfwSetMouseWheelCallback
// file ../input.c line 252
void glfwSetMouseWheelCallback(void (*cbfun)(signed int))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    _glfwWin.mouseWheelCallback = cbfun;
    if(!(cbfun == ((void (*)(signed int))NULL)))
      cbfun(_glfwInput.WheelPos);

  }

}

// glfwSetTime
// file ../time.c line 58
void glfwSetTime(double time)
{
  if(!(_glfwInitialized == 0))
    _glfwPlatformSetTime(time);

}

// glfwSetWindowCloseCallback
// file ../include/GL/glfw.h line 447
void glfwSetWindowCloseCallback(signed int (*cbfun)(void))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwWin.windowCloseCallback = cbfun;

}

// glfwSetWindowPos
// file ../window.c line 758
void glfwSetWindowPos(signed int x, signed int y)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0) && _glfwWin.fullscreen == 0 && _glfwWin.iconified == 0)
    _glfwPlatformSetWindowPos(x, y);

}

// glfwSetWindowRefreshCallback
// file ../window.c line 963
void glfwSetWindowRefreshCallback(void (*cbfun)(void))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwWin.windowRefreshCallback = cbfun;

}

// glfwSetWindowSize
// file ../window.c line 732
void glfwSetWindowSize(signed int width, signed int height)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0) && _glfwWin.iconified == 0)
  {
    if(!(height == _glfwWin.height) || !(width == _glfwWin.width))
    {
      _glfwPlatformSetWindowSize(width, height);
      _glfwPlatformRefreshWindowParams();
    }

  }

}

// glfwSetWindowSizeCallback
// file ../window.c line 925
void glfwSetWindowSizeCallback(void (*cbfun)(signed int, signed int))
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    _glfwWin.windowSizeCallback = cbfun;
    if(!(cbfun == ((void (*)(signed int, signed int))NULL)))
      cbfun(_glfwWin.width, _glfwWin.height);

  }

}

// glfwSetWindowTitle
// file ../include/GL/glfw.h line 437
void glfwSetWindowTitle(const char *title)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwPlatformSetWindowTitle(title);

}

// glfwSignalCond
// file ../thread.c line 297
void glfwSignalCond(void *cond)
{
  if(!(cond == NULL) && !(_glfwInitialized == 0))
    _glfwPlatformSignalCond(cond);

}

// glfwSleep
// file ../time.c line 74
void glfwSleep(double time)
{
  if(!(_glfwInitialized == 0))
    _glfwPlatformSleep(time);

}

// glfwSwapBuffers
// file ../include/GL/glfw.h line 443
void glfwSwapBuffers(void)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
  {
    _glfwPlatformSwapBuffers();
    if(!(_glfwWin.autoPollEvents == 0))
      glfwPollEvents();

  }

}

// glfwSwapInterval
// file ../window.c line 831
void glfwSwapInterval(signed int interval)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwPlatformSwapInterval(interval);

}

// glfwTerminate
// file ../init.c line 81
void glfwTerminate(void)
{
  if(!(_glfwInitialized == 0))
  {
    signed int return_value__glfwPlatformTerminate$1;
    return_value__glfwPlatformTerminate$1=_glfwPlatformTerminate();
    if(!(return_value__glfwPlatformTerminate$1 == 0))
      _glfwInitialized = 0;

  }

}

// glfwUnlockMutex
// file ../thread.c line 232
void glfwUnlockMutex(void *mutex)
{
  if(!(mutex == NULL) || !(_glfwInitialized == 0))
    _glfwPlatformUnlockMutex(mutex);

}

// glfwWaitCond
// file ../thread.c line 280
void glfwWaitCond(void *cond, void *mutex, double timeout)
{
  if(!(cond == NULL) && !(mutex == NULL) && !(_glfwInitialized == 0))
    _glfwPlatformWaitCond(cond, mutex, timeout);

}

// glfwWaitEvents
// file ../window.c line 995
void glfwWaitEvents(void)
{
  if(!(_glfwWin.opened == 0) && !(_glfwInitialized == 0))
    _glfwPlatformWaitEvents();

}

// glfwWaitThread
// file ../thread.c line 146
signed int glfwWaitThread(signed int ID, signed int waitmode)
{
  if(_glfwInitialized == 0)
    return 1;

  else
    if(!(ID >= 1))
      return 1;

    else
    {
      signed int return_value__glfwPlatformWaitThread$1;
      return_value__glfwPlatformWaitThread$1=_glfwPlatformWaitThread(ID, waitmode);
      return return_value__glfwPlatformWaitThread$1;
    }
}

// glfw_atexit
// file x11_init.c line 138
static void glfw_atexit(void)
{
  glfwTerminate();
}

// initDisplay
// file x11_init.c line 148
static signed int initDisplay(void)
{
  _glfwLibrary.display=XOpenDisplay(((const char *)NULL));
  if(_glfwLibrary.display == ((struct _XDisplay *)NULL))
  {
    fprintf(stderr, "Failed to open X display\n");
    return 0;
  }

  else
  {
    _glfwLibrary.XF86VidMode.available = 0;
    _glfwLibrary.XRandR.available=XRRQueryExtension(_glfwLibrary.display, &_glfwLibrary.XRandR.eventBase, &_glfwLibrary.XRandR.errorBase);
    signed int return_value_glXQueryExtension$1;
    return_value_glXQueryExtension$1=glXQueryExtension(_glfwLibrary.display, &_glfwLibrary.GLX.errorBase, &_glfwLibrary.GLX.eventBase);
    if(return_value_glXQueryExtension$1 == 0)
    {
      fprintf(stderr, "GLX not supported\n");
      return 0;
    }

    else
    {
      signed int return_value_glXQueryVersion$2;
      return_value_glXQueryVersion$2=glXQueryVersion(_glfwLibrary.display, &_glfwLibrary.GLX.versionMajor, &_glfwLibrary.GLX.versionMinor);
      if(return_value_glXQueryVersion$2 == 0)
      {
        fprintf(stderr, "Unable to query GLX version\n");
        return 0;
      }

      else
        return 1;
    }
  }
}

// initGLXExtensions
// file x11_window.c line 750
static void initGLXExtensions(void)
{
  _glfwWin.SwapIntervalEXT = (void (*)(struct _XDisplay *, unsigned long int, signed int))(void *)0;
  _glfwWin.SwapIntervalMESA = (signed int (*)(unsigned int))(void *)0;
  _glfwWin.SwapIntervalSGI = (signed int (*)(signed int))(void *)0;
  _glfwWin.GetFBConfigAttribSGIX = (signed int (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *))(void *)0;
  _glfwWin.ChooseFBConfigSGIX = (struct __GLXFBConfigRec ** (*)(struct _XDisplay *, signed int, signed int *, signed int *))(void *)0;
  _glfwWin.CreateContextWithConfigSGIX = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int))(void *)0;
  _glfwWin.GetVisualFromFBConfigSGIX = (struct anonymous$49 * (*)(struct _XDisplay *, struct __GLXFBConfigRec *))(void *)0;
  _glfwWin.CreateContextAttribsARB = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *))(void *)0;
  _glfwWin.has_GLX_SGIX_fbconfig = (unsigned char)0;
  _glfwWin.has_GLX_EXT_swap_control = (unsigned char)0;
  _glfwWin.has_GLX_MESA_swap_control = (unsigned char)0;
  _glfwWin.has_GLX_SGI_swap_control = (unsigned char)0;
  _glfwWin.has_GLX_ARB_multisample = (unsigned char)0;
  _glfwWin.has_GLX_ARB_create_context = (unsigned char)0;
  _glfwWin.has_GLX_ARB_create_context_profile = (unsigned char)0;
  signed int return_value__glfwPlatformExtensionSupported$2;
  return_value__glfwPlatformExtensionSupported$2=_glfwPlatformExtensionSupported("GLX_EXT_swap_control");
  if(!(return_value__glfwPlatformExtensionSupported$2 == 0))
  {
    void *return_value__glfwPlatformGetProcAddress$1;
    return_value__glfwPlatformGetProcAddress$1=_glfwPlatformGetProcAddress("glXSwapIntervalEXT");
    _glfwWin.SwapIntervalEXT = (void (*)(struct _XDisplay *, unsigned long int, signed int))return_value__glfwPlatformGetProcAddress$1;
    if(!(_glfwWin.SwapIntervalEXT == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL)))
      _glfwWin.has_GLX_EXT_swap_control = (unsigned char)1;

  }

  signed int return_value__glfwPlatformExtensionSupported$4;
  return_value__glfwPlatformExtensionSupported$4=_glfwPlatformExtensionSupported("GLX_MESA_swap_control");
  if(!(return_value__glfwPlatformExtensionSupported$4 == 0))
  {
    void *return_value__glfwPlatformGetProcAddress$3;
    return_value__glfwPlatformGetProcAddress$3=_glfwPlatformGetProcAddress("glXSwapIntervalMESA");
    _glfwWin.SwapIntervalMESA = (signed int (*)(unsigned int))return_value__glfwPlatformGetProcAddress$3;
    if(!(_glfwWin.SwapIntervalMESA == ((signed int (*)(unsigned int))NULL)))
      _glfwWin.has_GLX_MESA_swap_control = (unsigned char)1;

  }

  signed int return_value__glfwPlatformExtensionSupported$6;
  return_value__glfwPlatformExtensionSupported$6=_glfwPlatformExtensionSupported("GLX_SGI_swap_control");
  if(!(return_value__glfwPlatformExtensionSupported$6 == 0))
  {
    void *return_value__glfwPlatformGetProcAddress$5;
    return_value__glfwPlatformGetProcAddress$5=_glfwPlatformGetProcAddress("glXSwapIntervalSGI");
    _glfwWin.SwapIntervalSGI = (signed int (*)(signed int))return_value__glfwPlatformGetProcAddress$5;
    if(!(_glfwWin.SwapIntervalSGI == ((signed int (*)(signed int))NULL)))
      _glfwWin.has_GLX_SGI_swap_control = (unsigned char)1;

  }

  signed int return_value__glfwPlatformExtensionSupported$11;
  return_value__glfwPlatformExtensionSupported$11=_glfwPlatformExtensionSupported("GLX_SGIX_fbconfig");
  if(!(return_value__glfwPlatformExtensionSupported$11 == 0))
  {
    void *return_value__glfwPlatformGetProcAddress$7;
    return_value__glfwPlatformGetProcAddress$7=_glfwPlatformGetProcAddress("glXGetFBConfigAttribSGIX");
    _glfwWin.GetFBConfigAttribSGIX = (signed int (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *))return_value__glfwPlatformGetProcAddress$7;
    void *return_value__glfwPlatformGetProcAddress$8;
    return_value__glfwPlatformGetProcAddress$8=_glfwPlatformGetProcAddress("glXChooseFBConfigSGIX");
    _glfwWin.ChooseFBConfigSGIX = (struct __GLXFBConfigRec ** (*)(struct _XDisplay *, signed int, signed int *, signed int *))return_value__glfwPlatformGetProcAddress$8;
    void *return_value__glfwPlatformGetProcAddress$9;
    return_value__glfwPlatformGetProcAddress$9=_glfwPlatformGetProcAddress("glXCreateContextWithConfigSGIX");
    _glfwWin.CreateContextWithConfigSGIX = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int))return_value__glfwPlatformGetProcAddress$9;
    void *return_value__glfwPlatformGetProcAddress$10;
    return_value__glfwPlatformGetProcAddress$10=_glfwPlatformGetProcAddress("glXGetVisualFromFBConfigSGIX");
    _glfwWin.GetVisualFromFBConfigSGIX = (struct anonymous$49 * (*)(struct _XDisplay *, struct __GLXFBConfigRec *))return_value__glfwPlatformGetProcAddress$10;
    if(!(_glfwWin.ChooseFBConfigSGIX == ((struct __GLXFBConfigRec ** (*)(struct _XDisplay *, signed int, signed int *, signed int *))NULL)) && !(_glfwWin.GetVisualFromFBConfigSGIX == ((struct anonymous$49 * (*)(struct _XDisplay *, struct __GLXFBConfigRec *))NULL)) && !(_glfwWin.CreateContextWithConfigSGIX == ((struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int))NULL)) && !(_glfwWin.GetFBConfigAttribSGIX == ((signed int (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *))NULL)))
      _glfwWin.has_GLX_SGIX_fbconfig = (unsigned char)1;

  }

  signed int return_value__glfwPlatformExtensionSupported$12;
  return_value__glfwPlatformExtensionSupported$12=_glfwPlatformExtensionSupported("GLX_ARB_multisample");
  if(!(return_value__glfwPlatformExtensionSupported$12 == 0))
    _glfwWin.has_GLX_ARB_multisample = (unsigned char)1;

  signed int return_value__glfwPlatformExtensionSupported$14;
  return_value__glfwPlatformExtensionSupported$14=_glfwPlatformExtensionSupported("GLX_ARB_create_context");
  if(!(return_value__glfwPlatformExtensionSupported$14 == 0))
  {
    void *return_value__glfwPlatformGetProcAddress$13;
    return_value__glfwPlatformGetProcAddress$13=_glfwPlatformGetProcAddress("glXCreateContextAttribsARB");
    _glfwWin.CreateContextAttribsARB = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *))return_value__glfwPlatformGetProcAddress$13;
    if(!(_glfwWin.CreateContextAttribsARB == ((struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *))NULL)))
      _glfwWin.has_GLX_ARB_create_context = (unsigned char)1;

  }

  signed int return_value__glfwPlatformExtensionSupported$15;
  return_value__glfwPlatformExtensionSupported$15=_glfwPlatformExtensionSupported("GLX_ARB_create_context_profile");
  if(!(return_value__glfwPlatformExtensionSupported$15 == 0))
    _glfwWin.has_GLX_ARB_create_context_profile = (unsigned char)1;

}

// initLibraries
// file x11_init.c line 109
static void initLibraries(void)
{
  ;
}

// initThreads
// file x11_init.c line 43
static void initThreads(void)
{
  pthread_mutex_init(&_glfwThrd.CriticalSection, (const union anonymous$2 *)(void *)0);
  _glfwThrd.NextID = 0;
  signed int tmp_post$1 = _glfwThrd.NextID;
  _glfwThrd.NextID = _glfwThrd.NextID + 1;
  _glfwThrd.First.ID = tmp_post$1;
  _glfwThrd.First.Function = (void (*)(void *))(void *)0;
  _glfwThrd.First.Previous = (struct _GLFWthread_struct *)(void *)0;
  _glfwThrd.First.Next = (struct _GLFWthread_struct *)(void *)0;
  _glfwThrd.First.PosixID=pthread_self();
}

// init_map
// file heightmap.c line 467
static void init_map(void)
{
  signed int i;
  signed int j;
  signed int k;
  float step = 10.0f / (float)(80 - 1);
  float x = 0.0f;
  float z = 0.0f;
  k = 0;
  i = 0;
  for( ; !(i >= 80); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 80); j = j + 1)
    {
      map_vertices[(signed long int)0][(signed long int)k] = x;
      map_vertices[(signed long int)1][(signed long int)k] = 0.0f;
      map_vertices[(signed long int)2][(signed long int)k] = z;
      z = z + step;
      k = k + 1;
    }
    x = x + step;
    z = 0.0f;
  }
  k = 0;
  i = 0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  for( ; !(i >= 80); i = i + 1)
  {
    tmp_post$1 = k;
    k = k + 1;
    map_line_indices[(signed long int)tmp_post$1] = (unsigned int)((i + 1) * 80 - 1);
    tmp_post$2 = k;
    k = k + 1;
    map_line_indices[(signed long int)tmp_post$2] = (unsigned int)((i + 2) * 80 - 1);
  }
  i = 0;
  signed int tmp_post$3;
  signed int tmp_post$4;
  for( ; !(i >= 80); i = i + 1)
  {
    tmp_post$3 = k;
    k = k + 1;
    map_line_indices[(signed long int)tmp_post$3] = (unsigned int)((80 - 1) * 80 + i);
    tmp_post$4 = k;
    k = k + 1;
    map_line_indices[(signed long int)tmp_post$4] = (unsigned int)((80 - 1) * 80 + i + 1);
  }
  i = 0;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  for( ; !(i >= 80); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 80); j = j + 1)
    {
      signed int ref = i * 80 + j;
      tmp_post$5 = k;
      k = k + 1;
      map_line_indices[(signed long int)tmp_post$5] = (unsigned int)ref;
      tmp_post$6 = k;
      k = k + 1;
      map_line_indices[(signed long int)tmp_post$6] = (unsigned int)(ref + 1);
      tmp_post$7 = k;
      k = k + 1;
      map_line_indices[(signed long int)tmp_post$7] = (unsigned int)ref;
      tmp_post$8 = k;
      k = k + 1;
      map_line_indices[(signed long int)tmp_post$8] = (unsigned int)(ref + 80);
      tmp_post$9 = k;
      k = k + 1;
      map_line_indices[(signed long int)tmp_post$9] = (unsigned int)ref;
      tmp_post$10 = k;
      k = k + 1;
      map_line_indices[(signed long int)tmp_post$10] = (unsigned int)(ref + 80 + 1);
    }
  }
}

// init_opengl
// file heightmap.c line 256
static unsigned char init_opengl(void)
{
  unsigned char status = (unsigned char)1;
  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$1;
    return_value_glfwGetProcAddress$1=glfwGetProcAddress("glCreateShader");
    pglCreateShader = (unsigned int (*)(unsigned int))return_value_glfwGetProcAddress$1;
    if(pglCreateShader == ((unsigned int (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$2;
    return_value_glfwGetProcAddress$2=glfwGetProcAddress("glShaderSource");
    pglShaderSource = (void (*)(unsigned int, signed int, const char **, const signed int *))return_value_glfwGetProcAddress$2;
    if(pglShaderSource == ((void (*)(unsigned int, signed int, const char **, const signed int *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$3;
    return_value_glfwGetProcAddress$3=glfwGetProcAddress("glCompileShader");
    pglCompileShader = (void (*)(unsigned int))return_value_glfwGetProcAddress$3;
    if(pglCompileShader == ((void (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$4;
    return_value_glfwGetProcAddress$4=glfwGetProcAddress("glGetShaderiv");
    pglGetShaderiv = (void (*)(unsigned int, unsigned int, signed int *))return_value_glfwGetProcAddress$4;
    if(pglGetShaderiv == ((void (*)(unsigned int, unsigned int, signed int *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$5;
    return_value_glfwGetProcAddress$5=glfwGetProcAddress("glGetShaderInfoLog");
    pglGetShaderInfoLog = (void (*)(unsigned int, signed int, signed int *, char *))return_value_glfwGetProcAddress$5;
    if(pglGetShaderInfoLog == ((void (*)(unsigned int, signed int, signed int *, char *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$6;
    return_value_glfwGetProcAddress$6=glfwGetProcAddress("glDeleteShader");
    pglDeleteShader = (void (*)(unsigned int))return_value_glfwGetProcAddress$6;
    if(pglDeleteShader == ((void (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$7;
    return_value_glfwGetProcAddress$7=glfwGetProcAddress("glCreateProgram");
    pglCreateProgram = (unsigned int (*)(void))return_value_glfwGetProcAddress$7;
    if(pglCreateProgram == ((unsigned int (*)(void))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$8;
    return_value_glfwGetProcAddress$8=glfwGetProcAddress("glAttachShader");
    pglAttachShader = (void (*)(unsigned int, unsigned int))return_value_glfwGetProcAddress$8;
    if(pglAttachShader == ((void (*)(unsigned int, unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$9;
    return_value_glfwGetProcAddress$9=glfwGetProcAddress("glLinkProgram");
    pglLinkProgram = (void (*)(unsigned int))return_value_glfwGetProcAddress$9;
    if(pglLinkProgram == ((void (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$10;
    return_value_glfwGetProcAddress$10=glfwGetProcAddress("glUseProgram");
    pglUseProgram = (void (*)(unsigned int))return_value_glfwGetProcAddress$10;
    if(pglUseProgram == ((void (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$11;
    return_value_glfwGetProcAddress$11=glfwGetProcAddress("glGetProgramiv");
    pglGetProgramiv = (void (*)(unsigned int, unsigned int, signed int *))return_value_glfwGetProcAddress$11;
    if(pglGetProgramiv == ((void (*)(unsigned int, unsigned int, signed int *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$12;
    return_value_glfwGetProcAddress$12=glfwGetProcAddress("glGetProgramInfoLog");
    pglGetProgramInfoLog = (void (*)(unsigned int, signed int, signed int *, char *))return_value_glfwGetProcAddress$12;
    if(pglGetProgramInfoLog == ((void (*)(unsigned int, signed int, signed int *, char *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$13;
    return_value_glfwGetProcAddress$13=glfwGetProcAddress("glDeleteProgram");
    pglDeleteProgram = (void (*)(unsigned int))return_value_glfwGetProcAddress$13;
    if(pglDeleteProgram == ((void (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$14;
    return_value_glfwGetProcAddress$14=glfwGetProcAddress("glGetUniformLocation");
    pglGetUniformLocation = (signed int (*)(unsigned int, const char *))return_value_glfwGetProcAddress$14;
    if(pglGetUniformLocation == ((signed int (*)(unsigned int, const char *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$15;
    return_value_glfwGetProcAddress$15=glfwGetProcAddress("glUniformMatrix4fv");
    pglUniformMatrix4fv = (void (*)(signed int, signed int, unsigned char, const float *))return_value_glfwGetProcAddress$15;
    if(pglUniformMatrix4fv == ((void (*)(signed int, signed int, unsigned char, const float *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$16;
    return_value_glfwGetProcAddress$16=glfwGetProcAddress("glGetAttribLocation");
    pglGetAttribLocation = (signed int (*)(unsigned int, const char *))return_value_glfwGetProcAddress$16;
    if(pglGetAttribLocation == ((signed int (*)(unsigned int, const char *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$17;
    return_value_glfwGetProcAddress$17=glfwGetProcAddress("glGenVertexArrays");
    pglGenVertexArrays = (void (*)(signed int, unsigned int *))return_value_glfwGetProcAddress$17;
    if(pglGenVertexArrays == ((void (*)(signed int, unsigned int *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$18;
    return_value_glfwGetProcAddress$18=glfwGetProcAddress("glDeleteVertexArrays");
    pglDeleteVertexArrays = (void (*)(signed int, unsigned int *))return_value_glfwGetProcAddress$18;
    if(pglDeleteVertexArrays == ((void (*)(signed int, unsigned int *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$19;
    return_value_glfwGetProcAddress$19=glfwGetProcAddress("glBindVertexArray");
    pglBindVertexArray = (void (*)(unsigned int))return_value_glfwGetProcAddress$19;
    if(pglBindVertexArray == ((void (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$20;
    return_value_glfwGetProcAddress$20=glfwGetProcAddress("glGenBuffers");
    pglGenBuffers = (void (*)(signed int, unsigned int *))return_value_glfwGetProcAddress$20;
    if(pglGenBuffers == ((void (*)(signed int, unsigned int *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$21;
    return_value_glfwGetProcAddress$21=glfwGetProcAddress("glBindBuffer");
    pglBindBuffer = (void (*)(unsigned int, unsigned int))return_value_glfwGetProcAddress$21;
    if(pglBindBuffer == ((void (*)(unsigned int, unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$22;
    return_value_glfwGetProcAddress$22=glfwGetProcAddress("glBufferData");
    pglBufferData = (void (*)(unsigned int, signed long int, const void *, unsigned int))return_value_glfwGetProcAddress$22;
    if(pglBufferData == ((void (*)(unsigned int, signed long int, const void *, unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$23;
    return_value_glfwGetProcAddress$23=glfwGetProcAddress("glBufferSubData");
    pglBufferSubData = (void (*)(unsigned int, signed long int, signed long int, const void *))return_value_glfwGetProcAddress$23;
    if(pglBufferSubData == ((void (*)(unsigned int, signed long int, signed long int, const void *))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$24;
    return_value_glfwGetProcAddress$24=glfwGetProcAddress("glEnableVertexAttribArray");
    pglEnableVertexAttribArray = (void (*)(unsigned int))return_value_glfwGetProcAddress$24;
    if(pglEnableVertexAttribArray == ((void (*)(unsigned int))NULL))
      status = (unsigned char)0;

  }

  if((signed int)status == 1)
  {
    void *return_value_glfwGetProcAddress$25;
    return_value_glfwGetProcAddress$25=glfwGetProcAddress("glVertexAttribPointer");
    pglVertexAttribPointer = (void (*)(unsigned int, signed int, unsigned int, unsigned char, signed int, const void *))return_value_glfwGetProcAddress$25;
    if(pglVertexAttribPointer == ((void (*)(unsigned int, signed int, unsigned int, unsigned char, signed int, const void *))NULL))
      status = (unsigned char)0;

  }

  return status;
}

// isMapNotify
// file x11_window.c line 81
static signed int isMapNotify(struct _XDisplay *d, union _XEvent *e, char *arg)
{
  _Bool tmp_if_expr$1;
  if(e->type == 19)
    tmp_if_expr$1 = e->xmap.window == (unsigned long int)arg ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// key_callback
// file heightmap.c line 659
static void key_callback(signed int key, signed int action)
{
  if(key == 1)
    running = (unsigned char)0;

}

// leaveFullscreenMode
// file x11_window.c line 1111
static void leaveFullscreenMode(void)
{
  _glfwRestoreVideoMode();
  if(!(_glfwWin.Saver.changed == 0))
  {
    XSetScreenSaver(_glfwLibrary.display, _glfwWin.Saver.timeout, _glfwWin.Saver.interval, _glfwWin.Saver.blanking, _glfwWin.Saver.exposure);
    _glfwWin.Saver.changed = 0;
  }

  if(!(_glfwWin.wmState == 0ul) && !(_glfwWin.wmStateFullscreen == 0ul) && !(_glfwWin.hasEWMH == 0))
  {
    union _XEvent event;
    memset((void *)&event, 0, sizeof(union _XEvent) /*192ul*/ );
    event.type = 33;
    event.xclient.window = _glfwWin.window;
    event.xclient.format = 32;
    event.xclient.message_type = _glfwWin.wmState;
    event.xclient.data.l[(signed long int)0] = (signed long int)0;
    event.xclient.data.l[(signed long int)1] = (signed long int)_glfwWin.wmStateFullscreen;
    event.xclient.data.l[(signed long int)2] = (signed long int)0;
    event.xclient.data.l[(signed long int)3] = (signed long int)1;
    XSendEvent(_glfwLibrary.display, _glfwWin.root, 0, 1L << 19 | 1L << 20, &event);
  }

  if(!(_glfwWin.mouseLock == 0))
    _glfwPlatformShowMouseCursor();

}

// main
// file heightmap.c line 677
signed int main(signed int argc, char **argv)
{
  signed int ch;
  signed int iter;
  double dt;
  double last_update_time;
  signed int frame;
  float f;
  signed int uloc_modelview;
  signed int uloc_project;
  char *vertex_shader_path = (char *)(void *)0;
  char *fragment_shader_path = (char *)(void *)0;
  char *vertex_shader_src = (char *)(void *)0;
  char *fragment_shader_src = (char *)(void *)0;
  unsigned int shader_program;
  do
  {
    ch=getopt(argc, argv, "f:v:h");
    if(ch == -1)
      break;

    switch(ch)
    {
      case 102:
      {
        fragment_shader_path = optarg;
        break;
      }
      case 118:
      {
        vertex_shader_path = optarg;
        break;
      }
      case 104:
      {
        usage();
        exit(0);
      }
      default:
      {
        usage();
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(!(fragment_shader_path == ((char *)NULL)))
  {
    vertex_shader_src=read_file_content(fragment_shader_path);
    if(fragment_shader_src == ((char *)NULL))
    {
      fprintf(stderr, "ERROR: unable to load fragment shader from '%s'\n", fragment_shader_path);
      exit(1);
    }

  }

  if(!(vertex_shader_path == ((char *)NULL)))
  {
    vertex_shader_src=read_file_content(vertex_shader_path);
    if(vertex_shader_src == ((char *)NULL))
    {
      fprintf(stderr, "ERROR: unable to load vertex shader from '%s'\n", fragment_shader_path);
      exit(1);
    }

  }

  signed int return_value_glfwInit$1;
  return_value_glfwInit$1=glfwInit();
  if(!(return_value_glfwInit$1 == 1))
  {
    fprintf(stderr, "ERROR: Unable to initialize GLFW\n");
    usage();
    free((void *)vertex_shader_src);
    free((void *)fragment_shader_src);
    exit(1);
  }

  glfwEnable(0x00030006);
  glfwOpenWindowHint(0x00020012, 1);
  glfwOpenWindowHint(0x00020014, 3);
  glfwOpenWindowHint(0x00020015, 2);
  glfwOpenWindowHint(0x00020018, 0x00050001);
  glfwOpenWindowHint(0x00020016, 0);
  signed int return_value_glfwOpenWindow$2;
  return_value_glfwOpenWindow$2=glfwOpenWindow(800, 600, 0, 0, 0, 0, 0, 0, 0x00010001);
  if(!(return_value_glfwOpenWindow$2 == 1))
  {
    fprintf(stderr, "ERROR: Unable to create the OpenGL context and associated window\n");
    usage();
    free((void *)vertex_shader_src);
    free((void *)fragment_shader_src);
    exit(1);
  }

  glfwSetWindowTitle("GLFW OpenGL3 Heightmap demo");
  glfwSetWindowCloseCallback(close_window_callback);
  glfwSetKeyCallback(key_callback);
  unsigned char return_value_init_opengl$3;
  return_value_init_opengl$3=init_opengl();
  if(!((signed int)return_value_init_opengl$3 == 1))
  {
    fprintf(stderr, "ERROR: unable to resolve OpenGL function pointers\n");
    free((void *)vertex_shader_src);
    free((void *)fragment_shader_src);
    exit(1);
  }

  shader_program=make_shader_program(vertex_shader_src, fragment_shader_src);
  free((void *)vertex_shader_src);
  free((void *)fragment_shader_src);
  if(shader_program == 0u)
  {
    fprintf(stderr, "ERROR: during creation of the shader program\n");
    usage();
    exit(1);
  }

  pglUseProgram(shader_program);
  uloc_project=pglGetUniformLocation(shader_program, "project");
  uloc_modelview=pglGetUniformLocation(shader_program, "modelview");
  float return_value_tanf$4;
  return_value_tanf$4=tanf(view_angle / 2.0f);
  f = 1.0f / return_value_tanf$4;
  projection_matrix[(signed long int)0] = f / aspect_ratio;
  projection_matrix[(signed long int)5] = f;
  projection_matrix[(signed long int)10] = (z_far + z_near) / (z_near - z_far);
  projection_matrix[(signed long int)11] = -1.0f;
  projection_matrix[(signed long int)14] = (2.0f * z_far * z_near) / (z_near - z_far);
  pglUniformMatrix4fv(uloc_project, 1, (unsigned char)0, projection_matrix);
  modelview_matrix[(signed long int)12] = -5.0f;
  modelview_matrix[(signed long int)13] = -5.0f;
  modelview_matrix[(signed long int)14] = -20.0f;
  pglUniformMatrix4fv(uloc_modelview, 1, (unsigned char)0, modelview_matrix);
  init_map();
  make_mesh(shader_program);
  glViewport(0, 0, 800, 600);
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
  frame = 0;
  iter = 0;
  last_update_time=glfwGetTime();
  dt = last_update_time;
  if(!(running == 0))
  {
    frame = frame + 1;
    glClear((unsigned int)0x00004000);
    glDrawElements((unsigned int)0x0001, 2 * (3 * (80 - 1) * (80 - 1) + 2 * (80 - 1)), (unsigned int)0x1405, NULL);
    glfwSwapBuffers();
    dt=glfwGetTime();
    if(dt + -last_update_time > 0.2)
    {
      if(!(iter >= 200))
      {
        update_map(1);
        update_mesh();
        iter = iter + 1;
      }

      last_update_time = dt;
      frame = 0;
    }

  }

  exit(0);
}

// make_mesh
// file heightmap.c line 603
static void make_mesh(unsigned int program)
{
  unsigned int attrloc;
  pglGenVertexArrays(1, &mesh);
  pglGenBuffers(4, mesh_vbo);
  pglBindVertexArray(mesh);
  pglBindBuffer((unsigned int)0x8893, mesh_vbo[(signed long int)3]);
  pglBufferData((unsigned int)0x8893, (signed long int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(3 * (80 - 1) * (80 - 1) + 2 * (80 - 1)) * (unsigned long int)2), (const void *)map_line_indices, (unsigned int)0x88E4);
  signed int return_value;
  return_value=pglGetAttribLocation(program, "x");
  attrloc = (unsigned int)return_value;
  pglBindBuffer((unsigned int)0x8892, mesh_vbo[(signed long int)0]);
  pglBufferData((unsigned int)0x8892, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)(80 * 80)), (const void *)&map_vertices[(signed long int)0][(signed long int)0], (unsigned int)0x88E4);
  pglEnableVertexAttribArray(attrloc);
  pglVertexAttribPointer(attrloc, 1, (unsigned int)0x1406, (unsigned char)0, 0, NULL);
  signed int return_value_1;
  return_value_1=pglGetAttribLocation(program, "z");
  attrloc = (unsigned int)return_value_1;
  pglBindBuffer((unsigned int)0x8892, mesh_vbo[(signed long int)2]);
  pglBufferData((unsigned int)0x8892, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)(80 * 80)), (const void *)&map_vertices[(signed long int)2][(signed long int)0], (unsigned int)0x88E4);
  pglEnableVertexAttribArray(attrloc);
  pglVertexAttribPointer(attrloc, 1, (unsigned int)0x1406, (unsigned char)0, 0, NULL);
  signed int return_value_2;
  return_value_2=pglGetAttribLocation(program, "y");
  attrloc = (unsigned int)return_value_2;
  pglBindBuffer((unsigned int)0x8892, mesh_vbo[(signed long int)1]);
  pglBufferData((unsigned int)0x8892, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)(80 * 80)), (const void *)&map_vertices[(signed long int)1][(signed long int)0], (unsigned int)0x88E8);
  pglEnableVertexAttribArray(attrloc);
  pglVertexAttribPointer(attrloc, 1, (unsigned int)0x1406, (unsigned char)0, 0, NULL);
}

// make_shader
// file heightmap.c line 384
static unsigned int make_shader(unsigned int type, const char *shader_src)
{
  unsigned int shader;
  signed int shader_ok;
  signed int log_length;
  char info_log[8192l];
  shader=pglCreateShader(type);
  if(!(shader == 0u))
  {
    pglShaderSource(shader, 1, (const char **)&shader_src, (const signed int *)(void *)0);
    pglCompileShader(shader);
    pglGetShaderiv(shader, (unsigned int)0x8B81, &shader_ok);
    if(!(shader_ok == 1))
    {
      fprintf(stderr, "ERROR: Failed to compile %s shader\n", type == (unsigned int)0x8B30 ? "fragment" : "vertex");
      pglGetShaderInfoLog(shader, 8192, &log_length, info_log);
      fprintf(stderr, "ERROR: \n%s\n\n", (const void *)info_log);
      pglDeleteShader(shader);
      shader = (unsigned int)0;
    }

  }

  return shader;
}

// make_shader_program
// file heightmap.c line 411
static unsigned int make_shader_program(const char *vertex_shader_src, const char *fragment_shader_src)
{
  unsigned int program = 0u;
  signed int program_ok;
  unsigned int vertex_shader = 0u;
  unsigned int fragment_shader = 0u;
  signed int log_length;
  char info_log[8192l];
  vertex_shader=make_shader((unsigned int)0x8B31, vertex_shader_src == (const char *)(void *)0 ? default_vertex_shader : vertex_shader_src);
  if(!(vertex_shader == 0u))
  {
    fragment_shader=make_shader((unsigned int)0x8B30, fragment_shader_src == (const char *)(void *)0 ? default_fragment_shader : fragment_shader_src);
    if(!(fragment_shader == 0u))
    {
      program=pglCreateProgram();
      if(!(program == 0u))
      {
        pglAttachShader(program, vertex_shader);
        pglAttachShader(program, fragment_shader);
        pglLinkProgram(program);
        pglGetProgramiv(program, (unsigned int)0x8B82, &program_ok);
        if(!(program_ok == 1))
        {
          fprintf(stderr, "ERROR, failed to link shader program\n");
          pglGetProgramInfoLog(program, 8192, &log_length, info_log);
          fprintf(stderr, "ERROR: \n%s\n\n", (const void *)info_log);
          pglDeleteProgram(program);
          pglDeleteShader(fragment_shader);
          pglDeleteShader(vertex_shader);
          program = 0u;
        }

      }

    }

    else
    {
      fprintf(stderr, "ERROR: Unable to load fragment shader\n");
      pglDeleteShader(vertex_shader);
    }
  }

  else
    fprintf(stderr, "ERROR: Unable to load vertex shader\n");
  return program;
}

// pollJoystickEvents
// file x11_joystick.c line 215
static void pollJoystickEvents(void)
{
  struct js_event e;
  signed int i = 0;
  signed long int return_value_read$1;
  for( ; !(i >= 16); i = i + 1)
    if(!(_glfwJoy[(signed long int)i].Present == 0))
      do
      {
        return_value_read$1=read(_glfwJoy[(signed long int)i].fd, (void *)&e, sizeof(struct js_event) /*8ul*/ );
        if(!(return_value_read$1 >= 1l))
          break;

        e.type = e.type & (unsigned char)~0x80;
        switch((signed int)e.type)
        {
          case 0x02:
          {
            _glfwJoy[(signed long int)i].Axis[(signed long int)e.number] = (float)e.value / 32767.0f;
            if(!((1 & (signed int)e.number) == 0))
              _glfwJoy[(signed long int)i].Axis[(signed long int)e.number] = -_glfwJoy[(signed long int)i].Axis[(signed long int)e.number];

            break;
          }
          case 0x01:
            _glfwJoy[(signed long int)i].Button[(signed long int)e.number] = (unsigned char)(e.value != 0 ? 1 : 0);
        }
      }
      while((_Bool)1);

}

// processSingleEvent
// file x11_window.c line 1165
static unsigned char processSingleEvent(void)
{
  union _XEvent event;
  XNextEvent(_glfwLibrary.display, &event);
  signed int return_value_translateKey$1;
  signed int return_value_XEventsQueued$3;
  signed int return_value_translateKey$4;
  switch(event.type)
  {
    case 2:
    {
      return_value_translateKey$1=translateKey((signed int)event.xkey.keycode);
      _glfwInputKey(return_value_translateKey$1, 1);
      if(!(_glfwWin.charCallback == ((void (*)(signed int, signed int))NULL)))
      {
        signed int return_value_translateChar$2;
        return_value_translateChar$2=translateChar(&event.xkey);
        _glfwInputChar(return_value_translateChar$2, 1);
      }

      break;
    }
    case 3:
    {
      return_value_XEventsQueued$3=XEventsQueued(_glfwLibrary.display, 1);
      if(!(return_value_XEventsQueued$3 == 0))
      {
        union _XEvent nextEvent;
        XPeekEvent(_glfwLibrary.display, &nextEvent);
        if(nextEvent.xkey.keycode == event.xkey.keycode && nextEvent.xkey.window == event.xkey.window && nextEvent.type == 2)
        {
          if(!(nextEvent.xkey.time + -event.xkey.time >= 20ul))
            break;

        }

      }

      return_value_translateKey$4=translateKey((signed int)event.xkey.keycode);
      _glfwInputKey(return_value_translateKey$4, 0);
      if(!(_glfwWin.charCallback == ((void (*)(signed int, signed int))NULL)))
      {
        signed int return_value_translateChar$5;
        return_value_translateChar$5=translateChar(&event.xkey);
        _glfwInputChar(return_value_translateChar$5, 0);
      }

      break;
    }
    case 4:
    {
      if(event.xbutton.button == 1u)
        _glfwInputMouseClick(0, 1);

      else
        if(event.xbutton.button == 2u)
          _glfwInputMouseClick(2, 1);

        else
          if(event.xbutton.button == 3u)
            _glfwInputMouseClick(1, 1);

          else
            if(event.xbutton.button == 4u)
            {
              _glfwInput.WheelPos = _glfwInput.WheelPos + 1;
              if(!(_glfwWin.mouseWheelCallback == ((void (*)(signed int))NULL)))
                _glfwWin.mouseWheelCallback(_glfwInput.WheelPos);

            }

            else
              if(event.xbutton.button == 5u)
              {
                _glfwInput.WheelPos = _glfwInput.WheelPos - 1;
                if(!(_glfwWin.mouseWheelCallback == ((void (*)(signed int))NULL)))
                  _glfwWin.mouseWheelCallback(_glfwInput.WheelPos);

              }

      break;
    }
    case 5:
    {
      if(event.xbutton.button == 1u)
        _glfwInputMouseClick(0, 0);

      else
        if(event.xbutton.button == 2u)
          _glfwInputMouseClick(2, 0);

        else
          if(event.xbutton.button == 3u)
            _glfwInputMouseClick(1, 0);

      break;
    }
    case 6:
    {
      if(!(event.xmotion.x == _glfwInput.CursorPosX) || !(event.xmotion.y == _glfwInput.CursorPosY))
      {
        if(!(_glfwWin.mouseLock == 0))
        {
          if(!(_glfwWin.pointerHidden == 0))
          {
            _glfwInput.MousePosX = _glfwInput.MousePosX + (event.xmotion.x - _glfwInput.CursorPosX);
            _glfwInput.MousePosY = _glfwInput.MousePosY + (event.xmotion.y - _glfwInput.CursorPosY);
          }

        }

        else
        {
          _glfwInput.MousePosX = event.xmotion.x;
          _glfwInput.MousePosY = event.xmotion.y;
        }
        _glfwInput.CursorPosX = event.xmotion.x;
        _glfwInput.CursorPosY = event.xmotion.y;
        _glfwInput.MouseMoved = 1;
        if(!(_glfwWin.mousePosCallback == ((void (*)(signed int, signed int))NULL)))
          _glfwWin.mousePosCallback(_glfwInput.MousePosX, _glfwInput.MousePosY);

      }

      break;
    }
    case 22:
    {
      if(!(event.xconfigure.height == _glfwWin.height) || !(event.xconfigure.width == _glfwWin.width))
      {
        _glfwWin.width = event.xconfigure.width;
        _glfwWin.height = event.xconfigure.height;
        if(!(_glfwWin.windowSizeCallback == ((void (*)(signed int, signed int))NULL)))
          _glfwWin.windowSizeCallback(_glfwWin.width, _glfwWin.height);

      }

      break;
    }
    case 33:
    {
      if((unsigned long int)event.xclient.data.l[0l] == _glfwWin.wmDeleteWindow)
        return (unsigned char)1;

      else
        if(!(_glfwWin.wmPing == 0ul))
        {
          if((unsigned long int)event.xclient.data.l[0l] == _glfwWin.wmPing)
          {
            event.xclient.window = _glfwWin.root;
            XSendEvent(_glfwLibrary.display, event.xclient.window, 0, 1L << 19 | 1L << 20, &event);
          }

        }

      break;
    }
    case 19:
    {
      _glfwWin.iconified = 0;
      break;
    }
    case 18:
    {
      _glfwWin.iconified = 1;
      break;
    }
    case 9:
    {
      _glfwWin.active = 1;
      if(!(_glfwWin.mouseLock == 0))
        _glfwPlatformHideMouseCursor();

      break;
    }
    case 10:
    {
      _glfwWin.active = 0;
      _glfwInputDeactivation();
      if(!(_glfwWin.mouseLock == 0))
        _glfwPlatformShowMouseCursor();

      break;
    }
    case 12:
    {
      if(!(_glfwWin.windowRefreshCallback == ((void (*)(void))NULL)))
        _glfwWin.windowRefreshCallback();

      break;
    }
    case 17:
      return (unsigned char)0;
    default:
      if(event.type == _glfwLibrary.XRandR.eventBase)
        XRRUpdateConfiguration(&event);

  }
  return (unsigned char)0;
}

// read_file_content
// file heightmap.c line 358
static char * read_file_content(const char *filename)
{
  struct _IO_FILE *fd;
  unsigned long int size = (unsigned long int)0;
  char *result = (char *)(void *)0;
  fd=fopen(filename, "r");
  if(!(fd == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fseek$1;
    return_value_fseek$1=fseek(fd, (signed long int)0, 2);
    size = (unsigned long int)return_value_fseek$1;
    fseek(fd, (signed long int)0, 0);
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(size + (unsigned long int)1);
    result = (char *)return_value_malloc$2;
    result[(signed long int)size] = (char)0;
    unsigned long int return_value_fread$3;
    return_value_fread$3=fread((void *)result, size, (unsigned long int)1, fd);
    if(!(return_value_fread$3 == 1ul))
    {
      free((void *)result);
      result = (char *)(void *)0;
    }

    fclose(fd);
  }

  return result;
}

// terminateDisplay
// file x11_init.c line 205
static void terminateDisplay(void)
{
  if(!(_glfwLibrary.display == ((struct _XDisplay *)NULL)))
  {
    XCloseDisplay(_glfwLibrary.display);
    _glfwLibrary.display = (struct _XDisplay *)(void *)0;
  }

}

// terminateThreads
// file x11_init.c line 68
static void terminateThreads(void)
{
  struct _GLFWthread_struct *t;
  struct _GLFWthread_struct *t_next;
  pthread_mutex_lock(&_glfwThrd.CriticalSection);
  t = _glfwThrd.First.Next;
  for( ; !(t == ((struct _GLFWthread_struct *)NULL)); t = t_next)
  {
    t_next = t->Next;
    pthread_kill(t->PosixID, 9);
    free((void *)t);
  }
  pthread_mutex_unlock(&_glfwThrd.CriticalSection);
  pthread_mutex_destroy(&_glfwThrd.CriticalSection);
}

// translateChar
// file x11_window.c line 372
static signed int translateChar(struct anonymous$4 *event)
{
  unsigned long int keysym;
  XLookupString(event, (char *)(void *)0, 0, &keysym, (struct _XComposeStatus *)(void *)0);
  signed long int return_value__glfwKeySym2Unicode$1;
  return_value__glfwKeySym2Unicode$1=_glfwKeySym2Unicode(keysym);
  return (signed int)return_value__glfwKeySym2Unicode$1;
}

// translateKey
// file x11_window.c line 243
static signed int translateKey(signed int keycode)
{
  unsigned long int key;
  unsigned long int key_lc;
  unsigned long int key_uc;
  key=XKeycodeToKeysym(_glfwLibrary.display, (unsigned char)keycode, 1);
  switch(key)
  {
    case (unsigned long int)0xffb0:
      return 256 + 46;
    case (unsigned long int)0xffb1:
      return 256 + 47;
    case (unsigned long int)0xffb2:
      return 256 + 48;
    case (unsigned long int)0xffb3:
      return 256 + 49;
    case (unsigned long int)0xffb4:
      return 256 + 50;
    case (unsigned long int)0xffb5:
      return 256 + 51;
    case (unsigned long int)0xffb6:
      return 256 + 52;
    case (unsigned long int)0xffb7:
      return 256 + 53;
    case (unsigned long int)0xffb8:
      return 256 + 54;
    case (unsigned long int)0xffb9:
      return 256 + 55;
    case (unsigned long int)0xffac:

    case (unsigned long int)0xffae:
      return 256 + 60;
    case (unsigned long int)0xffbd:
      return 256 + 61;
    case (unsigned long int)0xff8d:
      return 256 + 62;
    default:
    {
      key=XKeycodeToKeysym(_glfwLibrary.display, (unsigned char)keycode, 0);
      switch(key)
      {
        case (unsigned long int)0xff1b:
          return 256 + 1;
        case (unsigned long int)0xff09:
          return 256 + 37;
        case (unsigned long int)0xffe1:
          return 256 + 31;
        case (unsigned long int)0xffe2:
          return 256 + 32;
        case (unsigned long int)0xffe3:
          return 256 + 33;
        case (unsigned long int)0xffe4:
          return 256 + 34;
        case (unsigned long int)0xffe7:

        case (unsigned long int)0xffe9:
          return 256 + 35;
        case (unsigned long int)0xff7e:

        case (unsigned long int)0xffe8:

        case (unsigned long int)0xfe03:

        case (unsigned long int)0xffea:
          return 256 + 36;
        case (unsigned long int)0xffeb:
          return 256 + 67;
        case (unsigned long int)0xffec:
          return 256 + 68;
        case (unsigned long int)0xff67:
          return 256 + 69;
        case (unsigned long int)0xff7f:
          return 256 + 63;
        case (unsigned long int)0xffe5:
          return 256 + 64;
        case (unsigned long int)0xff14:
          return 256 + 65;
        case (unsigned long int)0xff13:
          return 256 + 66;
        case (unsigned long int)0xff9f:

        case (unsigned long int)0xffff:
          return 256 + 41;
        case (unsigned long int)0xff08:
          return 256 + 39;
        case (unsigned long int)0xff0d:
          return 256 + 38;
        case (unsigned long int)0xff95:

        case (unsigned long int)0xff50:
          return 256 + 44;
        case (unsigned long int)0xff9c:

        case (unsigned long int)0xff57:
          return 256 + 45;
        case (unsigned long int)0xff9a:

        case (unsigned long int)0xff55:
          return 256 + 42;
        case (unsigned long int)0xff9b:

        case (unsigned long int)0xff56:
          return 256 + 43;
        case (unsigned long int)0xff9e:

        case (unsigned long int)0xff63:
          return 256 + 40;
        case (unsigned long int)0xff96:

        case (unsigned long int)0xff51:
          return 256 + 29;
        case (unsigned long int)0xff98:

        case (unsigned long int)0xff53:
          return 256 + 30;
        case (unsigned long int)0xff99:

        case (unsigned long int)0xff54:
          return 256 + 28;
        case (unsigned long int)0xff97:

        case (unsigned long int)0xff52:
          return 256 + 27;
        case (unsigned long int)0xffbe:
          return 256 + 2;
        case (unsigned long int)0xffbf:
          return 256 + 3;
        case (unsigned long int)0xffc0:
          return 256 + 4;
        case (unsigned long int)0xffc1:
          return 256 + 5;
        case (unsigned long int)0xffc2:
          return 256 + 6;
        case (unsigned long int)0xffc3:
          return 256 + 7;
        case (unsigned long int)0xffc4:
          return 256 + 8;
        case (unsigned long int)0xffc5:
          return 256 + 9;
        case (unsigned long int)0xffc6:
          return 256 + 10;
        case (unsigned long int)0xffc7:
          return 256 + 11;
        case (unsigned long int)0xffc8:
          return 256 + 12;
        case (unsigned long int)0xffc9:
          return 256 + 13;
        case (unsigned long int)0xffca:
          return 256 + 14;
        case (unsigned long int)0xffcb:
          return 256 + 15;
        case (unsigned long int)0xffcc:
          return 256 + 16;
        case (unsigned long int)0xffcd:
          return 256 + 17;
        case (unsigned long int)0xffce:
          return 256 + 18;
        case (unsigned long int)0xffcf:
          return 256 + 19;
        case (unsigned long int)0xffd0:
          return 256 + 20;
        case (unsigned long int)0xffd1:
          return 256 + 21;
        case (unsigned long int)0xffd2:
          return 256 + 22;
        case (unsigned long int)0xffd3:
          return 256 + 23;
        case (unsigned long int)0xffd4:
          return 256 + 24;
        case (unsigned long int)0xffd5:
          return 256 + 25;
        case (unsigned long int)0xffd6:
          return 256 + 26;
        case (unsigned long int)0xffaf:
          return 256 + 56;
        case (unsigned long int)0xffaa:
          return 256 + 57;
        case (unsigned long int)0xffad:
          return 256 + 58;
        case (unsigned long int)0xffab:
          return 256 + 59;
        case (unsigned long int)0xffbd:
          return 256 + 61;
        case (unsigned long int)0xff8d:
          return 256 + 62;
        default:
        {
          XConvertCase(key, &key_lc, &key_uc);
          key = key_uc;
          if(key >= 32ul && !(key >= 127ul) || key >= 160ul && !(key >= 256ul))
            return (signed int)key;

          return -1;
        }
      }
    }
  }
}

// update_map
// file heightmap.c line 567
static void update_map(signed int num_iter)
{
  /* assertion num_iter > 0 */
  assert(num_iter > 0);
  while(!(num_iter == 0))
  {
    float center_x;
    float center_z;
    float circle_size;
    float disp;
    unsigned long int ii;
    generate_heightmap__circle(&center_x, &center_z, &circle_size, &disp);
    disp = disp / 2.0f;
    ii = (unsigned long int)0u;
    for( ; !(ii >= 6400ul); ii = ii + 1ul)
    {
      float dx = center_x - map_vertices[(signed long int)0][(signed long int)ii];
      float dz = center_z - map_vertices[(signed long int)2][(signed long int)ii];
      float pd;
      float return_value_sqrtf$1;
      return_value_sqrtf$1=sqrtf(dx * dx + dz * dz);
      pd = (2.0f * return_value_sqrtf$1) / circle_size;
      double return_value_fabs$3;
      return_value_fabs$3=fabs((double)pd);
      if(return_value_fabs$3 <= 1.000000)
      {
        float new_height;
        double return_value_cos$2;
        return_value_cos$2=cos((double)(pd * 3.14f));
        new_height = disp + (float)return_value_cos$2 * disp;
        map_vertices[(signed long int)1][(signed long int)ii] = map_vertices[(signed long int)1][(signed long int)ii] + new_height;
      }

    }
    num_iter = num_iter - 1;
  }
}

// update_mesh
// file heightmap.c line 636
static void update_mesh(void)
{
  pglBufferSubData((unsigned int)0x8892, (signed long int)0, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)(80 * 80)), (const void *)&map_vertices[(signed long int)1][(signed long int)0]);
}

// usage
// file heightmap.c line 671
static void usage(void)
{
  printf("Usage: heightmap [-v <vertex_shader_path>] [-f <fragment_shader_path>]\n");
  printf("       heightmap [-h]\n");
}

