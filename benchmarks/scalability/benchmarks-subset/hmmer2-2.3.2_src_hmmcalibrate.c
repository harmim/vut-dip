// #anon_enum$CUT_NONE=0$CUT_GA=1$CUT_NC=2$CUT_TC=3
// file structs.h line 521
enum anonymous$4 { CUT_NONE=0, CUT_GA=1, CUT_NC=2, CUT_TC=3 };

// tag-#anon#ST[*{*{SYM#tag-gki_elem#}$SYM#tag-gki_elem#$}$*{SYM#tag-gki_elem#}$SYM#tag-gki_elem#$$'table'||S32'primelevel'||S32'nhash'||S32'nkeys'||U32'$pad0'|]
// file ../squid/gki.h line 36
struct anonymous$0;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$3;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$1;

// tag-#anon#UN[U32'i32'||U64'i64'|]
// file ../squid/ssi.h line 37
union anonymous;

// tag-ReadSeqVars
// file squid.h line 196
struct ReadSeqVars;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-aliinfo_s
// file msa.h line 65
struct aliinfo_s;

// tag-basic_state
// file structs.h line 557
struct basic_state;

// tag-clust_strategy
// file squid.h line 272
enum clust_strategy { CLUSTER_MEAN=0, CLUSTER_MAX=1, CLUSTER_MIN=2 };

// tag-comp
// file hsregex.c line 295
struct comp;

// tag-dpmatrix_s
// file structs.h line 286
struct dpmatrix_s;

// tag-dpshadow_s
// file structs.h line 317
struct dpshadow_s;

// tag-exec
// file hsregex.c line 823
struct exec;

// tag-fancyali_s
// file structs.h line 444
struct fancyali_s;

// tag-gki_elem
// file ../squid/gki.h line 26
struct gki_elem;

// tag-gsi_s
// file gsi.h line 46
struct gsi_s;

// tag-gsiindex_s
// file gsi.h line 58
struct gsiindex_s;

// tag-gsikey_s
// file gsi.h line 53
struct gsikey_s;

// tag-histogram_s
// file structs.h line 416
struct histogram_s;

// tag-hit_s
// file structs.h line 467
struct hit_s;

// tag-hmmfile_s
// file structs.h line 329
struct hmmfile_s;

// tag-intstack_s
// file squid.h line 281
struct intstack_s;

// tag-iupactype
// file squid.h line 116
struct iupactype;

// tag-msa_struct
// file ../squid/msa.h line 112
struct msa_struct;

// tag-msafile_struct
// file msa.h line 186
struct msafile_struct;

// tag-opt_s
// file ../squid/squid.h line 329
struct opt_s;

// tag-p7prior_s
// file structs.h line 382
struct p7prior_s;

// tag-p7trace_s
// file structs.h line 371
struct p7trace_s;

// tag-phylo_s
// file squid.h line 257
struct phylo_s;

// tag-plan7_s
// file structs.h line 98
struct plan7_s;

// tag-plan9_s
// file structs.h line 564
struct plan9_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-pvmhostinfo
// file /usr/include/pvm3.h line 493
struct pvmhostinfo;

// tag-seqinfo_s
// file ../squid/squid.h line 83
struct seqinfo_s;

// tag-sqd_regexp
// file squid.h line 348
struct sqd_regexp;

// tag-ssifile_s
// file ../squid/ssi.h line 49
struct ssifile_s;

// tag-ssiindex_s
// file ssi.h line 102
struct ssiindex_s;

// tag-ssioffset_s
// file ../squid/ssi.h line 35
struct ssioffset_s;

// tag-ssipkey_s
// file ssi.h line 91
struct ssipkey_s;

// tag-ssiskey_s
// file ssi.h line 98
struct ssiskey_s;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stopwatch_s
// file ../squid/stopwatch.h line 34
struct stopwatch_s;

// tag-threshold_s
// file structs.h line 515
struct threshold_s;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-tms
// file /usr/include/x86_64-linux-gnu/sys/times.h line 34
struct tms;

// tag-tophit_s
// file structs.h line 494
struct tophit_s;

// tag-workpool_s
// file hmmcalibrate.c line 86
struct workpool_s;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// AddToHistogram
// file funcs.h line 125
extern void AddToHistogram(struct histogram_s *h, float sc);
// AlignmentBootstrap
// file shuffle.c line 512
extern signed int AlignmentBootstrap(char **ali1, char **ali2, signed int nseq, signed int alen);
// AlignmentHomogenousGapsym
// file alignio.c line 635
extern void AlignmentHomogenousGapsym(char **aseq, signed int nseq, signed int alen, char gapsym);
// AlignmentIdentityBySampling
// file aligneval.c line 443
extern float AlignmentIdentityBySampling(char **aseq, signed int L, signed int N, signed int nsample);
// AlignmentShuffle
// file shuffle.c line 463
extern signed int AlignmentShuffle(char **ali1, char **ali2, signed int nseq, signed int alen);
// AllocAlignment
// file alignio.c line 43
extern void AllocAlignment(signed int nseq, signed int alen, char ***ret_aseq, struct aliinfo_s *ainfo);
// AllocFancyAli
// file tophits.c line 113
extern struct fancyali_s * AllocFancyAli(void);
// AllocHistogram
// file funcs.h line 122
extern struct histogram_s * AllocHistogram(signed int min, signed int max, signed int lumpsize);
// AllocPhylo
// file cluster.c line 329
extern struct phylo_s * AllocPhylo(signed int N);
// AllocPlan7
// file funcs.h line 212
extern struct plan7_s * AllocPlan7(signed int M);
// AllocPlan7Body
// file funcs.h line 214
extern void AllocPlan7Body(struct plan7_s *hmm, signed int M);
// AllocPlan7Matrix
// file core_algorithms.c line 203
struct dpmatrix_s * AllocPlan7Matrix(signed int rows, signed int M, signed int ***xmx, signed int ***mmx, signed int ***imx, signed int ***dmx);
// AllocPlan7Shell
// file funcs.h line 213
extern struct plan7_s * AllocPlan7Shell(void);
// AllocShadowMatrix
// file core_algorithms.c line 250
extern struct dpshadow_s * AllocShadowMatrix(signed int rows, signed int M, char ***xtb, char ***mtb, char ***itb, char ***dtb);
// AllocTophits
// file tophits.c line 78
extern struct tophit_s * AllocTophits(signed int lumpsize);
// AlphabetType2String
// file debug.c line 67
extern char * AlphabetType2String(signed int type);
// BlosumWeights
// file weight.c line 394
extern void BlosumWeights(char **aseqs, signed int nseq, signed int alen, float maxid, float *wgt);
// Byteswap
// file types.c line 133
extern void Byteswap(char *swap, signed int nbytes);
// Cluster
// file cluster.c line 148
extern signed int Cluster(float **dmx, signed int N, enum clust_strategy mode, struct phylo_s **ret_tree);
// CompareMultAlignments
// file aligneval.c line 334
extern float CompareMultAlignments(char **kseqs, char **tseqs, signed int N);
// ComparePairAlignments
// file aligneval.c line 95
extern float ComparePairAlignments(char *known1, char *known2, char *calc1, char *calc2);
// CompareRefMultAlignments
// file aligneval.c line 366
extern float CompareRefMultAlignments(signed int *ref, char **kseqs, char **tseqs, signed int N);
// CompareRefPairAlignments
// file aligneval.c line 133
extern float CompareRefPairAlignments(signed int *ref, char *known1, char *known2, char *calc1, char *calc2);
// CreateFancyAli
// file funcs.h line 349
extern struct fancyali_s * CreateFancyAli(struct p7trace_s *tr, struct plan7_s *hmm, unsigned char *dsq, char *name);
// CreatePlan7Matrix
// file funcs.h line 41
extern struct dpmatrix_s * CreatePlan7Matrix(signed int N, signed int M, signed int padN, signed int padM);
// DAdd
// file vectorops.c line 78
extern void DAdd(double *vec1, double *vec2, signed int n);
// DArgMax
// file vectorops.c line 172
extern signed int DArgMax(double *vec, signed int n);
// DArgMin
// file vectorops.c line 194
extern signed int DArgMin(double *vec, signed int n);
// DChoose
// file sre_random.c line 283
extern signed int DChoose(double *p, signed int N);
// DCopy
// file vectorops.c line 92
extern void DCopy(double *vec1, double *vec2, signed int n);
// DDot
// file vectorops.c line 106
extern double DDot(double *vec1, double *vec2, signed int n);
// DExp
// file vectorops.c line 255
extern void DExp(double *vec, signed int n);
// DLog
// file vectorops.c line 237
extern void DLog(double *vec, signed int n);
// DLogSum
// file vectorops.c line 269
extern double DLogSum(double *vec, signed int n);
// DMX2Alloc
// file sre_math.c line 185
extern double ** DMX2Alloc(signed int rows, signed int cols);
// DMX2Free
// file sre_math.c line 197
extern void DMX2Free(double **mx);
// DMax
// file vectorops.c line 124
extern double DMax(double *vec, signed int n);
// DMin
// file vectorops.c line 148
extern double DMin(double *vec, signed int n);
// DNorm
// file vectorops.c line 215
extern void DNorm(double *vec, signed int n);
// DScale
// file vectorops.c line 46
extern void DScale(double *vec, signed int n, double scale);
// DSet
// file vectorops.c line 32
extern void DSet(double *vec, signed int n, double value);
// DSum
// file vectorops.c line 60
extern double DSum(double *vec, signed int n);
// DealignAseqs
// file selex.c line 729
extern signed int DealignAseqs(char **aseqs, signed int num, char ***ret_rseqs);
// DealignedLength
// file ../squid/sqfuncs.h line 48
extern signed int DealignedLength(char *aseq);
// DedigitizeSequence
// file alphabet.c line 228
extern char * DedigitizeSequence(unsigned char *dsq, signed int L);
// DefaultCodonBias
// file alphabet.c line 341
extern void DefaultCodonBias(float *codebias);
// DefaultGeneticCode
// file alphabet.c line 318
extern void DefaultGeneticCode(signed int *aacode);
// DegenerateSymbolScore
// file funcs.h line 233
extern signed int DegenerateSymbolScore(float *p, float *null, signed int ambig);
// DetermineAlphabet
// file alphabet.c line 44
extern void DetermineAlphabet(char **rseqs, signed int nseq);
// Die
// file ../squid/sqfuncs.h line 150
extern void Die(char *format, ...);
// DigitizeAlignment
// file alphabet.c line 255
extern void DigitizeAlignment(struct msa_struct *msa, unsigned char ***ret_dsqs);
// DigitizeSequence
// file funcs.h line 31
extern unsigned char * DigitizeSequence(char *seq, signed int L);
// DisplayPlan7Matrix
// file display.c line 298
extern void DisplayPlan7Matrix(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s *mx);
// DisplayPlan7PostAlign
// file display.c line 90
extern void DisplayPlan7PostAlign(signed int L, struct plan7_s *hmm, struct dpmatrix_s *forward, struct dpmatrix_s *backward, struct p7trace_s **alignment, signed int A);
// DisplayPlan7Posteriors
// file display.c line 62
extern void DisplayPlan7Posteriors(signed int L, struct plan7_s *hmm, struct dpmatrix_s *forward, struct dpmatrix_s *backward, struct p7trace_s *viterbi, struct p7trace_s *optacc);
// EPSWriteSmallMSA
// file eps.c line 43
extern void EPSWriteSmallMSA(struct _IO_FILE *fp, struct msa_struct *msa);
// EVDBasicFit
// file histogram.c line 476
extern void EVDBasicFit(struct histogram_s *h);
// EVDCensoredFit
// file histogram.c line 1271
extern signed int EVDCensoredFit(float *x, signed int *y, signed int n, signed int z, float c, float *ret_mu, float *ret_lambda);
// EVDDensity
// file histogram.c line 891
extern double EVDDensity(float x, float mu, float lambda);
// EVDDistribution
// file histogram.c line 905
extern double EVDDistribution(float x, float mu, float lambda);
// EVDMaxLikelyFit
// file histogram.c line 1147
extern signed int EVDMaxLikelyFit(float *x, signed int *c, signed int n, float *ret_mu, float *ret_lambda);
// EVDrandom
// file histogram.c line 993
extern float EVDrandom(float mu, float lambda);
// EmitConsensusSequence
// file emit.c line 203
extern void EmitConsensusSequence(struct plan7_s *hmm, char **ret_seq, unsigned char **ret_dsq, signed int *ret_L, struct p7trace_s **ret_tr);
// EmitSequence
// file emit.c line 42
extern void EmitSequence(struct plan7_s *hmm, unsigned char **ret_dsq, signed int *ret_L, struct p7trace_s **ret_tr);
// EnvFileOpen
// file ../squid/sqfuncs.h line 81
extern struct _IO_FILE * EnvFileOpen(char *fname, char *env, char **ret_dir);
// ExponentialRandom
// file sre_random.c line 148
extern double ExponentialRandom(void);
// ExtremeValueE
// file histogram.c line 978
extern double ExtremeValueE(float x, float mu, float lambda, signed int N);
// ExtremeValueFitHistogram
// file funcs.h line 131
extern signed int ExtremeValueFitHistogram(struct histogram_s *h, signed int censor, float high_hint);
// ExtremeValueP
// file histogram.c line 928
extern double ExtremeValueP(float x, float mu, float lambda);
// ExtremeValueP2
// file histogram.c line 957
extern double ExtremeValueP2(float x, float mu, float lambda, signed int N);
// ExtremeValueSetHistogram
// file histogram.c line 682
extern void ExtremeValueSetHistogram(struct histogram_s *h, float mu, float lambda, float lowbound, float highbound, signed int ndegrees);
// FAdd
// file ../squid/vectorops.h line 15
extern void FAdd(float *vec1, float *vec2, signed int n);
// FArgMax
// file ../squid/vectorops.h line 25
extern signed int FArgMax(float *vec, signed int n);
// FArgMin
// file vectorops.c line 204
extern signed int FArgMin(float *vec, signed int n);
// FChoose
// file ../squid/sre_random.h line 14
extern signed int FChoose(float *p, signed int N);
// FCopy
// file ../squid/vectorops.h line 17
extern void FCopy(float *vec1, float *vec2, signed int n);
// FDot
// file ../squid/vectorops.h line 19
extern float FDot(float *vec1, float *vec2, signed int n);
// FExp
// file vectorops.c line 262
extern void FExp(float *vec, signed int n);
// FLog
// file vectorops.c line 246
extern void FLog(float *vec, signed int n);
// FLogSum
// file vectorops.c line 284
extern float FLogSum(float *vec, signed int n);
// FMX2Alloc
// file sqfuncs.h line 202
extern float ** FMX2Alloc(signed int rows, signed int cols);
// FMX2Free
// file sre_math.c line 179
extern void FMX2Free(float **mx);
// FMX2Multiply
// file sre_math.c line 211
extern void FMX2Multiply(float **A, float **B, float **C, signed int m, signed int p, signed int n);
// FMax
// file vectorops.c line 136
extern float FMax(float *vec, signed int n);
// FMin
// file vectorops.c line 160
extern float FMin(float *vec, signed int n);
// FNorm
// file ../squid/vectorops.h line 29
extern void FNorm(float *vec, signed int n);
// FScale
// file ../squid/vectorops.h line 11
extern void FScale(float *vec, signed int n, float scale);
// FSet
// file ../squid/vectorops.h line 9
extern void FSet(float *vec, signed int n, float value);
// FSum
// file ../squid/vectorops.h line 13
extern float FSum(float *vec, signed int n);
// FileAddSuffix
// file file.c line 187
extern char * FileAddSuffix(char *filename, char *sfx);
// FileConcat
// file ../squid/sqfuncs.h line 79
extern char * FileConcat(char *dir, char *file);
// FileDirname
// file file.c line 65
extern char * FileDirname(char *file);
// FileExists
// file ../squid/sqfuncs.h line 82
extern signed int FileExists(char *filename);
// FileSameDirectory
// file file.c line 139
extern char * FileSameDirectory(char *file1, char *file2);
// FileTail
// file file.c line 98
extern char * FileTail(char *file, signed int noextension);
// FilterAlignment
// file weight.c line 521
extern void FilterAlignment(struct msa_struct *msa, float cutoff, struct msa_struct **ret_new);
// Free2DArray
// file ../squid/sqfuncs.h line 222
extern void Free2DArray(void **p, signed int dim1);
// Free3DArray
// file sqfuncs.h line 223
extern void Free3DArray(void ***p, signed int dim1, signed int dim2);
// FreeAlignment
// file alignio.c line 105
extern void FreeAlignment(char **aseqs, struct aliinfo_s *ainfo);
// FreeFancyAli
// file tophits.c line 124
extern void FreeFancyAli(struct fancyali_s *ali);
// FreeHistogram
// file funcs.h line 123
extern void FreeHistogram(struct histogram_s *h);
// FreeIntStack
// file sqfuncs.h line 239
extern signed int FreeIntStack(struct intstack_s *stack);
// FreePhylo
// file cluster.c line 360
extern void FreePhylo(struct phylo_s *tree, signed int N);
// FreePlan7
// file funcs.h line 215
extern void FreePlan7(struct plan7_s *hmm);
// FreePlan7Matrix
// file funcs.h line 48
extern void FreePlan7Matrix(struct dpmatrix_s *mx);
// FreeSequence
// file sqio.c line 329
extern void FreeSequence(char *seq, struct seqinfo_s *sqinfo);
// FreeShadowMatrix
// file core_algorithms.c line 287
extern void FreeShadowMatrix(struct dpshadow_s *tb);
// FreeTophits
// file tophits.c line 97
extern void FreeTophits(struct tophit_s *h);
// FullSortTophits
// file tophits.c line 289
extern void FullSortTophits(struct tophit_s *h);
// GCGBinaryToSequence
// file sqio.c line 1299
extern signed int GCGBinaryToSequence(char *seq, signed int len);
// GCGMultchecksum
// file sqfuncs.h line 176
extern signed int GCGMultchecksum(char **seqs, signed int nseq);
// GCGchecksum
// file sqfuncs.h line 175
extern signed int GCGchecksum(char *seq, signed int len);
// GKIFree
// file gki.c line 135
void GKIFree(struct anonymous$0 *hash);
// GKIInit
// file gki.c line 117
struct anonymous$0 * GKIInit(void);
// GKIKeyIndex
// file gki.c line 219
signed int GKIKeyIndex(struct anonymous$0 *hash, char *key);
// GKIStatus
// file gki.c line 243
void GKIStatus(struct anonymous$0 *hash);
// GKIStoreKey
// file gki.h line 47
signed int GKIStoreKey(struct anonymous$0 *hash, char *key);
// GSCWeights
// file weight.c line 46
extern void GSCWeights(char **aseq, signed int nseq, signed int alen, float *wgt);
// GSIAddFileToIndex
// file gsi.c line 219
extern void GSIAddFileToIndex(struct gsiindex_s *g, char *filename, signed int fmt);
// GSIAddKeyToIndex
// file gsi.c line 234
extern void GSIAddKeyToIndex(struct gsiindex_s *g, char *key, signed int filenum, signed long int offset);
// GSIAllocIndex
// file gsi.c line 196
extern struct gsiindex_s * GSIAllocIndex(void);
// GSIClose
// file gsi.c line 171
extern void GSIClose(struct gsi_s *gsi);
// GSIFreeIndex
// file gsi.c line 209
extern void GSIFreeIndex(struct gsiindex_s *g);
// GSIGetOffset
// file gsi.c line 128
extern signed int GSIGetOffset(struct gsi_s *gsi, char *key, char *ret_seqfile, signed int *ret_format, signed long int *ret_offset);
// GSIGetRecord
// file gsi.c line 93
extern signed int GSIGetRecord(struct gsi_s *gsi, char *f1, unsigned short int *f2, unsigned int *f3);
// GSIOpen
// file gsi.c line 53
extern struct gsi_s * GSIOpen(char *gsifile);
// GSISortIndex
// file gsi.c line 259
extern void GSISortIndex(struct gsiindex_s *g);
// GSIWriteFileRecord
// file gsi.c line 333
extern signed int GSIWriteFileRecord(struct _IO_FILE *fp, char *fname, signed int idx, signed int fmt);
// GSIWriteHeader
// file gsi.c line 297
extern void GSIWriteHeader(struct _IO_FILE *fp, signed int nfiles, signed long int nkeys);
// GSIWriteIndex
// file gsi.c line 264
extern void GSIWriteIndex(struct _IO_FILE *fp, struct gsiindex_s *g);
// GSIWriteKeyRecord
// file gsi.c line 368
extern signed int GSIWriteKeyRecord(struct _IO_FILE *fp, char *key, signed int fileidx, signed long int offset);
// Gammln
// file ../squid/sqfuncs.h line 201
extern double Gammln(double x);
// GaussianFitHistogram
// file histogram.c line 747
extern signed int GaussianFitHistogram(struct histogram_s *h, float high_hint);
// GaussianSetHistogram
// file histogram.c line 830
extern void GaussianSetHistogram(struct histogram_s *h, float mean, float sd);
// Gaussrandom
// file ../squid/sre_random.h line 12
extern double Gaussrandom(double mean, double stddev);
// GetRankedHit
// file tophits.c line 220
extern void GetRankedHit(struct tophit_s *h, signed int rank, double *r_pvalue, float *r_score, double *r_motherp, float *r_mothersc, char **r_name, char **r_acc, char **r_desc, signed int *r_sqfrom, signed int *r_sqto, signed int *r_sqlen, signed int *r_hmmfrom, signed int *r_hmmto, signed int *r_hmmlen, signed int *r_domidx, signed int *r_ndom, struct fancyali_s **r_ali);
// Getline
// file misc.c line 129
char * Getline(char *s, signed int n, struct _IO_FILE *fp);
// Getopt
// file ../squid/sqfuncs.h line 87
extern signed int Getopt(signed int argc, char **argv, struct opt_s *opt, signed int nopts, char *usage, signed int *ret_optind, char **ret_optname, char **ret_optarg);
// Getword
// file misc.c line 76
char * Getword(struct _IO_FILE *fp, signed int type);
// GrowTophits
// file tophits.c line 91
extern void GrowTophits(struct tophit_s *h);
// GuessAlignmentSeqtype
// file sqfuncs.h line 180
extern signed int GuessAlignmentSeqtype(char **aseq, signed int nseq);
// HMMERBanner
// file misc.c line 55
void HMMERBanner(struct _IO_FILE *fp, char *banner);
// HMMFileClose
// file funcs.h line 157
extern void HMMFileClose(struct hmmfile_s *hmmfp);
// HMMFileOpen
// file funcs.h line 155
extern struct hmmfile_s * HMMFileOpen(char *hmmfile, char *env);
// HMMFilePositionByIndex
// file hmmio.c line 358
extern signed int HMMFilePositionByIndex(struct hmmfile_s *hmmfp, signed int idx);
// HMMFilePositionByName
// file hmmio.c line 347
extern signed int HMMFilePositionByName(struct hmmfile_s *hmmfp, char *name);
// HMMFileRead
// file funcs.h line 156
extern signed int HMMFileRead(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// HMMFileRewind
// file funcs.h line 159
extern void HMMFileRewind(struct hmmfile_s *hmmfp);
// ILogsum
// file funcs.h line 179
extern signed int ILogsum(signed int p1, signed int p2);
// ImposeMasterTrace
// file trace.c line 1118
extern void ImposeMasterTrace(char **aseq, signed int nseq, struct p7trace_s *mtr, struct p7trace_s ***ret_tr);
// IncompleteGamma
// file ../squid/sqfuncs.h line 207
extern double IncompleteGamma(double a, double x);
// InitAinfo
// file alignio.c line 80
extern void InitAinfo(struct aliinfo_s *ainfo);
// InitIntStack
// file sqfuncs.h line 235
extern struct intstack_s * InitIntStack(void);
// IsBlankline
// file sqfuncs.h line 231
extern signed int IsBlankline(char *s);
// IsInt
// file ../squid/sqfuncs.h line 249
extern signed int IsInt(char *s);
// IsReal
// file ../squid/sqfuncs.h line 250
extern signed int IsReal(char *s);
// IsSELEXFormat
// file selex.c line 775
extern signed int IsSELEXFormat(char *filename);
// Lawless416
// file histogram.c line 1028
extern void Lawless416(float *x, signed int *y, signed int n, float lambda, float *ret_f, float *ret_df);
// Lawless422
// file histogram.c line 1085
extern void Lawless422(float *x, signed int *y, signed int n, signed int z, float c, float lambda, float *ret_f, float *ret_df);
// Linefit
// file ../squid/sqfuncs.h line 197
extern signed int Linefit(float *x, float *y, signed int N, float *ret_a, float *ret_b, float *ret_r);
// LogNorm
// file mathsupport.c line 185
extern void LogNorm(float *vec, signed int n);
// LogSum
// file mathsupport.c line 115
extern float LogSum(float p1, float p2);
// Logp_cvec
// file mathsupport.c line 217
extern float Logp_cvec(float *cvec, signed int n, float *alpha);
// MSAAddComment
// file msa.c line 355
extern void MSAAddComment(struct msa_struct *msa, char *s);
// MSAAddGF
// file msa.c line 388
extern void MSAAddGF(struct msa_struct *msa, char *tag, char *value);
// MSAAddGS
// file msa.c line 433
extern void MSAAddGS(struct msa_struct *msa, char *tag, signed int sqidx, char *value);
// MSAAlloc
// file ../squid/msa.h line 234
extern struct msa_struct * MSAAlloc(signed int nseq, signed int alen);
// MSAAppendGC
// file msa.c line 507
extern void MSAAppendGC(struct msa_struct *msa, char *tag, char *value);
// MSAAppendGR
// file msa.c line 590
extern void MSAAppendGR(struct msa_struct *msa, char *tag, signed int sqidx, char *value);
// MSAAverageSequenceLength
// file msa.c line 1427
extern float MSAAverageSequenceLength(struct msa_struct *msa);
// MSAExpand
// file msa.h line 235
extern void MSAExpand(struct msa_struct *msa);
// MSAFileClose
// file msa.c line 941
extern void MSAFileClose(struct msafile_struct *afp);
// MSAFileFormat
// file msa.c line 1121
extern signed int MSAFileFormat(struct msafile_struct *afp);
// MSAFileGetLine
// file msa.h line 236
extern char * MSAFileGetLine(struct msafile_struct *afp);
// MSAFileOpen
// file msa.c line 756
extern struct msafile_struct * MSAFileOpen(char *filename, signed int format, char *env);
// MSAFilePositionByIndex
// file msa.c line 891
extern signed int MSAFilePositionByIndex(struct msafile_struct *afp, signed int idx);
// MSAFilePositionByKey
// file msa.c line 880
extern signed int MSAFilePositionByKey(struct msafile_struct *afp, char *key);
// MSAFileRead
// file msa.c line 914
extern struct msa_struct * MSAFileRead(struct msafile_struct *afp);
// MSAFileRewind
// file msa.c line 873
extern signed int MSAFileRewind(struct msafile_struct *afp);
// MSAFileWrite
// file msa.c line 964
extern void MSAFileWrite(struct _IO_FILE *fp, struct msa_struct *msa, signed int outfmt, signed int do_oneline);
// MSAFree
// file msa.h line 226
extern void MSAFree(struct msa_struct *msa);
// MSAFromAINFO
// file msa.c line 1032
extern struct msa_struct * MSAFromAINFO(char **aseq, struct aliinfo_s *ainfo);
// MSAGetGC
// file ../squid/msa.h line 243
extern char * MSAGetGC(struct msa_struct *msa, char *tag);
// MSAGetSeqAccession
// file msa.c line 1377
extern char * MSAGetSeqAccession(struct msa_struct *msa, signed int idx);
// MSAGetSeqDescription
// file msa.c line 1385
extern char * MSAGetSeqDescription(struct msa_struct *msa, signed int idx);
// MSAGetSeqSA
// file msa.c line 1401
extern char * MSAGetSeqSA(struct msa_struct *msa, signed int idx);
// MSAGetSeqSS
// file msa.c line 1393
extern char * MSAGetSeqSS(struct msa_struct *msa, signed int idx);
// MSAGetSeqidx
// file msa.h line 246
extern signed int MSAGetSeqidx(struct msa_struct *msa, char *name, signed int guess);
// MSAMingap
// file msa.c line 1150
extern void MSAMingap(struct msa_struct *msa);
// MSANogap
// file msa.c line 1182
extern void MSANogap(struct msa_struct *msa);
// MSASetSeqAccession
// file ../squid/msa.h line 237
extern void MSASetSeqAccession(struct msa_struct *msa, signed int seqidx, char *acc);
// MSASetSeqDescription
// file ../squid/msa.h line 238
extern void MSASetSeqDescription(struct msa_struct *msa, signed int seqidx, char *desc);
// MSAShorterAlignment
// file msa.c line 1218
extern void MSAShorterAlignment(struct msa_struct *msa, signed int *useme);
// MSASmallerAlignment
// file msa.c line 1305
extern void MSASmallerAlignment(struct msa_struct *msa, signed int *useme, struct msa_struct **ret_new);
// MSAToSqinfo
// file sqio.c line 1849
extern struct seqinfo_s * MSAToSqinfo(struct msa_struct *msa);
// MSAVerifyParse
// file msa.h line 245
extern void MSAVerifyParse(struct msa_struct *msa);
// MajorityRuleConsensus
// file aligneval.c line 475
extern char * MajorityRuleConsensus(char **aseq, signed int nseq, signed int alen);
// MakeAlignedString
// file ../squid/sqfuncs.h line 46
extern signed int MakeAlignedString(char *aseq, signed int alen, char *ss, char **ret_s);
// MakeDealignedString
// file alignio.c line 275
extern signed int MakeDealignedString(char *aseq, signed int alen, char *ss, char **ret_s);
// MakeDiffMx
// file cluster.c line 384
extern void MakeDiffMx(char **aseqs, signed int num, float ***ret_dmx);
// MakeIdentityMx
// file cluster.c line 420
extern void MakeIdentityMx(char **aseqs, signed int num, float ***ret_imx);
// MasterTraceFromMap
// file trace.c line 1036
extern struct p7trace_s * MasterTraceFromMap(signed int *map, signed int M, signed int alen);
// MergeTraceArrays
// file trace.c line 105
extern struct p7trace_s ** MergeTraceArrays(struct p7trace_s **t1, signed int n1, struct p7trace_s **t2, signed int n2);
// MingapAlignment
// file alignio.c line 431
extern signed int MingapAlignment(char **aseqs, struct aliinfo_s *ainfo);
// P7AllocPrior
// file prior.c line 36
extern struct p7prior_s * P7AllocPrior(void);
// P7AllocTrace
// file funcs.h line 335
extern void P7AllocTrace(signed int tlen, struct p7trace_s **ret_tr);
// P7Backward
// file postprob.c line 132
extern float P7Backward(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s **ret_mx);
// P7CountSymbol
// file alphabet.c line 291
extern void P7CountSymbol(float *counters, unsigned char symidx, float wt);
// P7DefaultNullModel
// file funcs.h line 269
extern void P7DefaultNullModel(float *null, float *ret_p1);
// P7DefaultPrior
// file prior.c line 81
extern struct p7prior_s * P7DefaultPrior(void);
// P7EmitterPosterior
// file postprob.c line 250
extern void P7EmitterPosterior(signed int L, struct plan7_s *hmm, struct dpmatrix_s *forward, struct dpmatrix_s *backward, struct dpmatrix_s *mx);
// P7Fastmodelmaker
// file modelmakers.c line 162
extern void P7Fastmodelmaker(struct msa_struct *msa, unsigned char **dsq, float maxgap, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr);
// P7FillOptimalAccuracy
// file postprob.c line 319
extern float P7FillOptimalAccuracy(signed int L, signed int M, struct dpmatrix_s *posterior, struct dpmatrix_s *mx, struct p7trace_s **ret_tr);
// P7Forward
// file core_algorithms.c line 454
extern float P7Forward(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s **ret_mx);
// P7FreePrior
// file prior.c line 39
extern void P7FreePrior(struct p7prior_s *pri);
// P7FreeTrace
// file funcs.h line 337
extern void P7FreeTrace(struct p7trace_s *tr);
// P7Handmodelmaker
// file modelmakers.c line 100
extern void P7Handmodelmaker(struct msa_struct *msa, unsigned char **dsq, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr);
// P7LaplacePrior
// file prior.c line 53
extern struct p7prior_s * P7LaplacePrior(void);
// P7Logoddsify
// file funcs.h line 223
extern void P7Logoddsify(struct plan7_s *hmm, signed int viterbi_mode);
// P7Maxmodelmaker
// file modelmakers.c line 227
extern void P7Maxmodelmaker(struct msa_struct *msa, unsigned char **dsq, float maxgap, struct p7prior_s *prior, float *null, float null_p1, float mpri, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr);
// P7OptimalAccuracy
// file postprob.c line 97
extern float P7OptimalAccuracy(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct p7trace_s **ret_tr);
// P7OptimalAccuracyTrace
// file postprob.c line 449
extern void P7OptimalAccuracyTrace(signed int L, signed int M, struct dpmatrix_s *posterior, struct dpmatrix_s *mx, struct p7trace_s **ret_tr);
// P7ParsingViterbi
// file core_algorithms.c line 1128
extern float P7ParsingViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct p7trace_s **ret_tr);
// P7PrintPrior
// file debug.c line 167
extern void P7PrintPrior(struct _IO_FILE *fp, struct p7prior_s *pri);
// P7PrintTrace
// file debug.c line 89
extern void P7PrintTrace(struct _IO_FILE *fp, struct p7trace_s *tr, struct plan7_s *hmm, unsigned char *dsq);
// P7PriorifyEmissionVector
// file funcs.h line 274
extern void P7PriorifyEmissionVector(float *vec, struct p7prior_s *pri, signed int num, float *eq, float (*e)[20l], float *ret_mix);
// P7PriorifyHMM
// file prior.c line 342
extern void P7PriorifyHMM(struct plan7_s *hmm, struct p7prior_s *pri);
// P7PriorifyTransitionVector
// file funcs.h line 272
extern void P7PriorifyTransitionVector(float *t, struct p7prior_s *prior, float *tq);
// P7ReadNullModel
// file prior.c line 294
extern void P7ReadNullModel(char *rndfile, float *null, float *ret_p1);
// P7ReadPrior
// file prior.c line 97
extern struct p7prior_s * P7ReadPrior(char *prifile);
// P7ReallocTrace
// file funcs.h line 336
extern void P7ReallocTrace(struct p7trace_s *tr, signed int tlen);
// P7ReverseTrace
// file funcs.h line 340
extern void P7ReverseTrace(struct p7trace_s *tr);
// P7SmallViterbi
// file funcs.h line 60
extern float P7SmallViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s *mx, struct p7trace_s **ret_tr);
// P7SmallViterbiSize
// file core_algorithms.c line 404
extern signed int P7SmallViterbiSize(signed int L, signed int M);
// P7TraceCount
// file funcs.h line 341
extern void P7TraceCount(struct plan7_s *hmm, unsigned char *dsq, float wt, struct p7trace_s *tr);
// P7TraceScore
// file funcs.h line 343
extern float P7TraceScore(struct plan7_s *hmm, unsigned char *dsq, struct p7trace_s *tr);
// P7Traces2Alignment
// file trace.c line 379
extern struct msa_struct * P7Traces2Alignment(unsigned char **dsq, struct seqinfo_s *sqinfo, float *wgt, signed int nseq, signed int mlen, struct p7trace_s **tr, signed int matchonly);
// P7Viterbi
// file funcs.h line 56
extern float P7Viterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s *mx, struct p7trace_s **ret_tr);
// P7ViterbiAlignAlignment
// file core_algorithms.c line 2086
extern struct p7trace_s * P7ViterbiAlignAlignment(struct msa_struct *msa, struct plan7_s *hmm);
// P7ViterbiSize
// file core_algorithms.c line 364
extern signed int P7ViterbiSize(signed int L, signed int M);
// P7ViterbiSpaceOK
// file funcs.h line 50
extern signed int P7ViterbiSpaceOK(signed int L, signed int M, struct dpmatrix_s *mx);
// P7ViterbiTrace
// file core_algorithms.c line 684
extern void P7ViterbiTrace(struct plan7_s *hmm, unsigned char *dsq, signed int N, struct dpmatrix_s *mx, struct p7trace_s **ret_tr);
// P7WeeViterbi
// file core_algorithms.c line 1327
extern float P7WeeViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct p7trace_s **ret_tr);
// P7WeeViterbiSize
// file core_algorithms.c line 427
extern signed int P7WeeViterbiSize(signed int L, signed int M);
// P9AllocHMM
// file funcs.h line 240
extern struct plan9_s * P9AllocHMM(signed int M);
// P9DefaultNullModel
// file funcs.h line 244
extern void P9DefaultNullModel(float *null);
// P9FreeHMM
// file funcs.h line 242
extern signed int P9FreeHMM(struct plan9_s *hmm);
// P9Renormalize
// file funcs.h line 243
extern void P9Renormalize(struct plan9_s *hmm);
// P9ZeroHMM
// file plan9.c line 70
extern void P9ZeroHMM(struct plan9_s *hmm);
// PAMPrior
// file prior.c line 214
extern void PAMPrior(char *pamfile, struct p7prior_s *pri, float wt);
// PVMCheckSlaves
// file funcs.h line 286
extern void PVMCheckSlaves(signed int *slave_tid, signed int nslaves);
// PVMConfirmSlaves
// file funcs.h line 285
extern void PVMConfirmSlaves(signed int *slave_tid, signed int nslaves);
// PVMKillSlaves
// file pvm.c line 236
extern void PVMKillSlaves(signed int *slave_tid, signed int nslaves);
// PVMPackHMM
// file funcs.h line 292
extern signed int PVMPackHMM(struct plan7_s *hmm);
// PVMPackString
// file pvm.c line 259
extern signed int PVMPackString(char *s);
// PVMPackTrace
// file pvm.c line 306
extern signed int PVMPackTrace(struct p7trace_s *tr);
// PVMSpawnSlaves
// file funcs.h line 284
extern void PVMSpawnSlaves(char *slave, signed int **ret_tid, signed int *ret_nslaves);
// PVMUnpackHMM
// file pvm.c line 406
extern struct plan7_s * PVMUnpackHMM(void);
// PVMUnpackString
// file pvm.c line 280
extern char * PVMUnpackString(void);
// PVMUnpackTrace
// file pvm.c line 328
extern struct p7trace_s * PVMUnpackTrace(void);
// PValue
// file funcs.h line 177
extern double PValue(struct plan7_s *hmm, float sc);
// P_PvecGivenDirichlet
// file mathsupport.c line 350
extern float P_PvecGivenDirichlet(float *p, signed int n, float *alpha);
// PairwiseIdentity
// file aligneval.c line 401
extern float PairwiseIdentity(char *s1, char *s2);
// Panic
// file ../squid/sqfuncs.h line 152
extern void Panic(char *file, signed int line);
// ParsePAMFile
// file ../squid/sqfuncs.h line 70
extern signed int ParsePAMFile(struct _IO_FILE *fp, signed int ***ret_pam, float *ret_scale);
// Plan7ComlogAppend
// file funcs.h line 220
extern void Plan7ComlogAppend(struct plan7_s *hmm, signed int argc, char **argv);
// Plan7ESTViterbi
// file core_algorithms.c line 1547
extern float Plan7ESTViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s **ret_mx);
// Plan7FSConfig
// file plan7.c line 789
extern void Plan7FSConfig(struct plan7_s *hmm, float pentry, float pexit);
// Plan7GlobalConfig
// file plan7.c line 665
extern void Plan7GlobalConfig(struct plan7_s *hmm);
// Plan7LSConfig
// file funcs.h line 228
extern void Plan7LSConfig(struct plan7_s *hmm);
// Plan7NakedConfig
// file plan7.c line 632
extern void Plan7NakedConfig(struct plan7_s *hmm);
// Plan7Renormalize
// file funcs.h line 224
extern void Plan7Renormalize(struct plan7_s *hmm);
// Plan7RenormalizeExits
// file plan7.c line 580
extern void Plan7RenormalizeExits(struct plan7_s *hmm);
// Plan7SWConfig
// file plan7.c line 739
extern void Plan7SWConfig(struct plan7_s *hmm, float pentry, float pexit);
// Plan7SetAccession
// file funcs.h line 218
extern void Plan7SetAccession(struct plan7_s *hmm, char *acc);
// Plan7SetCtime
// file funcs.h line 221
extern void Plan7SetCtime(struct plan7_s *hmm);
// Plan7SetDescription
// file funcs.h line 219
extern void Plan7SetDescription(struct plan7_s *hmm, char *desc);
// Plan7SetName
// file funcs.h line 217
extern void Plan7SetName(struct plan7_s *hmm, char *name);
// Plan7SetNullModel
// file plan7.c line 333
extern void Plan7SetNullModel(struct plan7_s *hmm, float *null, float p1);
// Plan9toPlan7
// file funcs.h line 234
extern void Plan9toPlan7(struct plan9_s *hmm, struct plan7_s **ret_plan7);
// PopIntStack
// file sqfuncs.h line 237
extern signed int PopIntStack(struct intstack_s *stack, signed int *ret_data);
// PositionBasedWeights
// file weight.c line 463
extern void PositionBasedWeights(char **aseq, signed int nseq, signed int alen, float *wgt);
// PostalCode
// file postprob.c line 685
extern char * PostalCode(signed int L, struct dpmatrix_s *mx, struct p7trace_s *tr);
// PostprocessSignificantHit
// file core_algorithms.c line 2500
extern float PostprocessSignificantHit(struct tophit_s *ghit, struct tophit_s *dhit, struct p7trace_s *tr, struct plan7_s *hmm, unsigned char *dsq, signed int L, char *seqname, char *seqacc, char *seqdesc, signed int do_forward, float sc_override, signed int do_null2, struct threshold_s *thresh, signed int hmmpfam_mode);
// PrintASCIIHistogram
// file funcs.h line 126
extern void PrintASCIIHistogram(struct _IO_FILE *fp, struct histogram_s *h);
// PrintFancyAli
// file trace.c line 809
extern void PrintFancyAli(struct _IO_FILE *fp, struct fancyali_s *ali);
// PrintIscore
// file display.c line 331
void PrintIscore(signed int sc);
// PrintNewHampshireTree
// file cluster.c line 457
extern void PrintNewHampshireTree(struct _IO_FILE *fp, struct aliinfo_s *ainfo, struct phylo_s *tree, signed int N);
// PrintPhylo
// file cluster.c line 520
extern void PrintPhylo(struct _IO_FILE *fp, struct aliinfo_s *ainfo, struct phylo_s *tree, signed int N);
// PrintPlan7Stats
// file plan7.c line 896
extern void PrintPlan7Stats(struct _IO_FILE *fp, struct plan7_s *hmm, unsigned char **dsq, signed int nseq, struct p7trace_s **tr);
// PrintTransition
// file display.c line 341
void PrintTransition(char src, signed int isrc, signed int ksrc, char dest, signed int idest, signed int kdest, signed int sc, struct p7trace_s **alignment, signed int *min, signed int *max, signed int *on, signed int A);
// PrintXMGRDistribution
// file histogram.c line 384
extern void PrintXMGRDistribution(struct _IO_FILE *fp, struct histogram_s *h);
// PrintXMGRHistogram
// file histogram.c line 348
extern void PrintXMGRHistogram(struct _IO_FILE *fp, struct histogram_s *h);
// PrintXMGRRegressionLine
// file histogram.c line 423
extern void PrintXMGRRegressionLine(struct _IO_FILE *fp, struct histogram_s *h);
// Prob2Score
// file funcs.h line 174
extern signed int Prob2Score(float p, float null);
// PushIntStack
// file sqfuncs.h line 236
extern void PushIntStack(struct intstack_s *stack, signed int data);
// QRNAShuffle
// file shuffle.c line 555
extern signed int QRNAShuffle(char *xs, char *ys, char *x, char *y);
// RandomAlignment
// file alignio.c line 514
extern signed int RandomAlignment(char **rseqs, struct seqinfo_s *sqinfo, signed int nseq, float pop, float pex, char ***ret_aseqs, struct aliinfo_s *ainfo);
// RandomSequence
// file ../squid/sqfuncs.h line 224
extern char * RandomSequence(char *alphabet, float *p, signed int n, signed int len);
// ReadA2M
// file a2m.c line 40
extern struct msa_struct * ReadA2M(struct msafile_struct *afp);
// ReadClustal
// file clustal.c line 79
extern struct msa_struct * ReadClustal(struct msafile_struct *afp);
// ReadMSF
// file msa.h line 278
extern struct msa_struct * ReadMSF(struct msafile_struct *afp);
// ReadMultipleRseqs
// file sqio.c line 1712
extern signed int ReadMultipleRseqs(char *seqfile, signed int fformat, char ***ret_rseqs, struct seqinfo_s **ret_sqinfo, signed int *ret_num);
// ReadPhylip
// file msa.h line 283
extern struct msa_struct * ReadPhylip(struct msafile_struct *afp);
// ReadSELEX
// file msa.h line 288
extern struct msa_struct * ReadSELEX(struct msafile_struct *afp);
// ReadSeq
// file sqio.c line 1038
extern signed int ReadSeq(struct ReadSeqVars *V, signed int format, char **ret_seq, struct seqinfo_s *sqinfo);
// ReadStockholm
// file msa.h line 294
extern struct msa_struct * ReadStockholm(struct msafile_struct *afp);
// RegisterHit
// file funcs.h line 312
extern void RegisterHit(struct tophit_s *h, double key, double pvalue, float score, double motherp, float mothersc, char *name, char *acc, char *desc, signed int sqfrom, signed int sqto, signed int sqlen, signed int hmmfrom, signed int hmmto, signed int hmmlen, signed int domidx, signed int ndom, struct fancyali_s *ali);
// ResizePlan7Matrix
// file core_algorithms.c line 134
extern void ResizePlan7Matrix(struct dpmatrix_s *mx, signed int N, signed int M, signed int ***xmx, signed int ***mmx, signed int ***imx, signed int ***dmx);
// ReverseIntStack
// file stack.c line 75
extern void ReverseIntStack(struct intstack_s *stack);
// SAMizeAlignment
// file alignio.c line 144
extern void SAMizeAlignment(char **aseq, signed int nseq, signed int alen);
// SAMizeAlignmentByGapFrac
// file alignio.c line 190
extern void SAMizeAlignmentByGapFrac(char **aseq, signed int nseq, signed int alen, float maxgap);
// SSIAddFileToIndex
// file ssi.c line 623
extern signed int SSIAddFileToIndex(struct ssiindex_s *g, char *filename, signed int fmt, signed int *ret_fh);
// SSIAddPrimaryKeyToIndex
// file ssi.c line 720
extern signed int SSIAddPrimaryKeyToIndex(struct ssiindex_s *g, char *key, signed int fh, struct ssioffset_s *r_off, struct ssioffset_s *d_off, signed int L);
// SSIAddSecondaryKeyToIndex
// file ssi.c line 797
extern signed int SSIAddSecondaryKeyToIndex(struct ssiindex_s *g, char *key, char *pkey);
// SSIClose
// file ../squid/ssi.h line 167
extern void SSIClose(struct ssifile_s *sfp);
// SSICreateIndex
// file ssi.c line 509
extern struct ssiindex_s * SSICreateIndex(signed int mode);
// SSIErrorString
// file ssi.c line 1108
extern char * SSIErrorString(signed int n);
// SSIFileInfo
// file ssi.c line 416
extern signed int SSIFileInfo(struct ssifile_s *sfp, signed int fh, char **ret_filename, signed int *ret_format);
// SSIForceExternalSort
// file ssi.c line 1430
extern void SSIForceExternalSort(struct ssiindex_s *g);
// SSIFreeIndex
// file ssi.c line 1067
extern void SSIFreeIndex(struct ssiindex_s *g);
// SSIGetFilePosition
// file ../squid/ssi.h line 173
extern signed int SSIGetFilePosition(struct _IO_FILE *fp, signed int mode, struct ssioffset_s *ret_offset);
// SSIGetOffsetByName
// file ../squid/ssi.h line 158
extern signed int SSIGetOffsetByName(struct ssifile_s *sfp, char *key, signed int *ret_fh, struct ssioffset_s *ret_offset);
// SSIGetOffsetByNumber
// file ../squid/ssi.h line 160
extern signed int SSIGetOffsetByNumber(struct ssifile_s *sfp, signed int n, signed int *ret_fh, struct ssioffset_s *ret_offset);
// SSIGetSubseqOffset
// file ssi.c line 291
extern signed int SSIGetSubseqOffset(struct ssifile_s *sfp, char *key, signed int requested_start, signed int *ret_fh, struct ssioffset_s *record_offset, struct ssioffset_s *data_offset, signed int *ret_actual_start);
// SSIOpen
// file ../squid/ssi.h line 157
extern signed int SSIOpen(char *filename, struct ssifile_s **ret_sfp);
// SSIRecommendMode
// file ../squid/ssi.h line 171
extern signed int SSIRecommendMode(char *file);
// SSISetFileForSubseq
// file ssi.c line 676
extern signed int SSISetFileForSubseq(struct ssiindex_s *g, signed int fh, signed int bpl, signed int rpl);
// SSISetFilePosition
// file ../squid/ssi.h line 165
extern signed int SSISetFilePosition(struct _IO_FILE *fp, struct ssioffset_s *offset);
// SSIWriteIndex
// file ssi.c line 872
extern signed int SSIWriteIndex(char *file, struct ssiindex_s *g);
// SampleAlignment
// file weight.c line 587
extern void SampleAlignment(struct msa_struct *msa, signed int sample, struct msa_struct **ret_new);
// SampleCountvector
// file mathsupport.c line 330
extern void SampleCountvector(float *p, signed int n, signed int c, float *cvec);
// SampleDirichlet
// file mathsupport.c line 257
extern void SampleDirichlet(float *alpha, signed int n, float *p);
// SampleGamma
// file mathsupport.c line 281
extern float SampleGamma(float alpha);
// SantaCruzCorrection
// file masks.c line 366
float SantaCruzCorrection(struct plan7_s *hmm, struct p7trace_s *tr, unsigned char *dsq);
// Score2Prob
// file funcs.h line 175
extern float Score2Prob(signed int sc, float null);
// Scorify
// file funcs.h line 176
extern float Scorify(signed int sc);
// SeqfileClose
// file sqio.c line 284
extern void SeqfileClose(struct ReadSeqVars *sqfp);
// SeqfileFormat
// file sqfuncs.h line 168
extern signed int SeqfileFormat(struct _IO_FILE *fp);
// SeqfileFormat2String
// file sqfuncs.h line 182
extern char * SeqfileFormat2String(signed int code);
// SeqfileGetLine
// file sqio.c line 317
static void SeqfileGetLine(struct ReadSeqVars *V);
// SeqfileLineParameters
// file sqio.c line 270
void SeqfileLineParameters(struct ReadSeqVars *V, signed int *ret_bpl, signed int *ret_rpl);
// SeqfileOpen
// file sqio.c line 87
extern struct ReadSeqVars * SeqfileOpen(char *filename, signed int format, char *env);
// SeqfileOpenForIndexing
// file sqio.c line 92
extern struct ReadSeqVars * SeqfileOpenForIndexing(char *filename, signed int format, char *env, signed int ssimode);
// SeqfilePosition
// file sqio.c line 221
extern void SeqfilePosition(struct ReadSeqVars *sqfp, struct ssioffset_s *offset);
// SeqfileRewind
// file sqio.c line 242
extern void SeqfileRewind(struct ReadSeqVars *sqfp);
// SeqinfoCopy
// file sqfuncs.h line 160
extern void SeqinfoCopy(struct seqinfo_s *sq1, struct seqinfo_s *sq2);
// Seqtype
// file ../squid/sqfuncs.h line 179
extern signed int Seqtype(char *seq);
// SetAlphabet
// file alphabet.c line 88
extern void SetAlphabet(signed int type);
// SetAutocuts
// file misc.c line 158
signed int SetAutocuts(struct threshold_s *thresh, struct plan7_s *hmm);
// SetSeqinfoString
// file sqfuncs.h line 159
extern signed int SetSeqinfoString(struct seqinfo_s *sqinfo, char *sptr, signed int flag);
// ShadowTrace
// file core_algorithms.c line 2277
extern struct p7trace_s * ShadowTrace(struct dpshadow_s *tb, struct plan7_s *hmm, signed int L);
// SingleLinkCluster
// file weight.c line 704
extern void SingleLinkCluster(char **aseq, signed int nseq, signed int alen, float maxid, signed int **ret_c, signed int *ret_nc);
// SqdBanner
// file squidcore.c line 46
extern void SqdBanner(struct _IO_FILE *fp, char *banner);
// SqdClean
// file ../squid/sqfuncs.h line 96
extern void SqdClean(void);
// StateOccupancy
// file emit.c line 315
extern void StateOccupancy(struct plan7_s *hmm, float **ret_mp, float **ret_ip, float **ret_dp);
// Statetype
// file funcs.h line 80
extern char * Statetype(char st);
// StopwatchCopy
// file stopwatch.c line 214
extern void StopwatchCopy(struct stopwatch_s *w1, struct stopwatch_s *w2);
// StopwatchCreate
// file stopwatch.c line 200
extern struct stopwatch_s * StopwatchCreate(void);
// StopwatchDisplay
// file stopwatch.c line 252
extern void StopwatchDisplay(struct _IO_FILE *fp, char *s, struct stopwatch_s *w);
// StopwatchFree
// file stopwatch.c line 230
extern void StopwatchFree(struct stopwatch_s *w);
// StopwatchInclude
// file ../squid/stopwatch.h line 50
extern void StopwatchInclude(struct stopwatch_s *w1, struct stopwatch_s *w2);
// StopwatchPVMPack
// file stopwatch.c line 280
extern void StopwatchPVMPack(struct stopwatch_s *w);
// StopwatchPVMUnpack
// file ../squid/stopwatch.h line 59
extern void StopwatchPVMUnpack(struct stopwatch_s *w);
// StopwatchStart
// file ../squid/stopwatch.h line 48
extern void StopwatchStart(struct stopwatch_s *w);
// StopwatchStop
// file ../squid/stopwatch.h line 49
extern void StopwatchStop(struct stopwatch_s *w);
// StopwatchZero
// file ../squid/stopwatch.h line 52
extern void StopwatchZero(struct stopwatch_s *w);
// StrDPShuffle
// file shuffle.c line 100
extern signed int StrDPShuffle(char *s1, char *s2);
// StrMarkov0
// file shuffle.c line 290
extern signed int StrMarkov0(char *s1, char *s2);
// StrMarkov1
// file shuffle.c line 335
extern signed int StrMarkov1(char *s1, char *s2);
// StrRegionalShuffle
// file shuffle.c line 424
extern signed int StrRegionalShuffle(char *s1, char *s2, signed int w);
// StrReverse
// file sqfuncs.h line 141
extern signed int StrReverse(char *s1, char *s2);
// StrShuffle
// file shuffle.c line 59
extern signed int StrShuffle(char *s1, char *s2);
// Strdelete
// file sre_string.c line 82
extern signed int Strdelete(char *s1, signed int pos);
// Strdup
// file ../squid/sqfuncs.h line 214
extern char * Strdup(char *s);
// String2SeqfileFormat
// file sqio.c line 1766
extern signed int String2SeqfileFormat(char *s);
// StringChop
// file ../squid/sqfuncs.h line 215
extern void StringChop(char *s);
// Strinsert
// file sre_string.c line 61
extern signed int Strinsert(char *s1, char c, signed int pos);
// Strparse
// file hsregex.c line 92
extern signed int Strparse(char *rexp, char *s, signed int ntok);
// SymbolIndex
// file alphabet.c line 182
extern unsigned char SymbolIndex(char sym);
// ThreadNumber
// file funcs.h line 300
extern signed int ThreadNumber(void);
// ToDNA
// file sqio.c line 444
extern void ToDNA(char *seq);
// ToIUPAC
// file sqio.c line 485
extern void ToIUPAC(char *seq, signed int is_aseq);
// ToRNA
// file sqio.c line 459
extern void ToRNA(char *seq);
// TophitsMaxName
// file tophits.c line 253
extern signed int TophitsMaxName(struct tophit_s *h);
// TophitsReport
// file tophits.c line 328
extern void TophitsReport(struct tophit_s *h, double E, signed int nseq);
// TraceCompare
// file debug.c line 361
extern signed int TraceCompare(struct p7trace_s *t1, struct p7trace_s *t2);
// TraceDecompose
// file funcs.h line 352
extern void TraceDecompose(struct p7trace_s *otr, struct p7trace_s ***ret_tr, signed int *ret_ntr);
// TraceDomainNumber
// file trace.c line 947
extern signed int TraceDomainNumber(struct p7trace_s *tr);
// TraceScoreCorrection
// file funcs.h line 169
extern float TraceScoreCorrection(struct plan7_s *hmm, struct p7trace_s *tr, unsigned char *dsq);
// TraceSet
// file funcs.h line 338
extern void TraceSet(struct p7trace_s *tr, signed int tpos, char type, signed int idx, signed int pos);
// TraceSimpleBounds
// file funcs.h line 355
extern void TraceSimpleBounds(struct p7trace_s *tr, signed int *ret_i1, signed int *ret_i2, signed int *ret_k1, signed int *ret_k2);
// TraceVerify
// file debug.c line 225
extern signed int TraceVerify(struct p7trace_s *tr, signed int M, signed int N);
// TransitionScoreLookup
// file funcs.h line 347
extern signed int TransitionScoreLookup(struct plan7_s *hmm, char st1, signed int k1, char st2, signed int k2);
// Translate
// file translate.c line 48
extern char * Translate(char *seq, char **code);
// UnfitHistogram
// file histogram.c line 102
extern void UnfitHistogram(struct histogram_s *h);
// VoronoiWeights
// file weight.c line 154
extern void VoronoiWeights(char **aseq, signed int nseq, signed int alen, float *wgt);
// Warn
// file ../squid/sqfuncs.h line 151
extern void Warn(char *format, ...);
// WeightedLinefit
// file sre_math.c line 85
extern void WeightedLinefit(float *x, float *y, float *var, signed int N, float *ret_m, float *ret_b);
// WriteA2M
// file a2m.c line 96
extern void WriteA2M(struct _IO_FILE *fp, struct msa_struct *msa);
// WriteAscHMM
// file funcs.h line 162
extern void WriteAscHMM(struct _IO_FILE *fp, struct plan7_s *hmm);
// WriteBinHMM
// file funcs.h line 163
extern void WriteBinHMM(struct _IO_FILE *fp, struct plan7_s *hmm);
// WriteClustal
// file clustal.c line 145
extern void WriteClustal(struct _IO_FILE *fp, struct msa_struct *msa);
// WriteMSF
// file msa.h line 279
extern void WriteMSF(struct _IO_FILE *fp, struct msa_struct *msa);
// WritePairwiseAlignment
// file alignio.c line 333
extern signed int WritePairwiseAlignment(struct _IO_FILE *ofp, char *aseq1, char *name1, signed int spos1, char *aseq2, char *name2, signed int spos2, signed int **pam, signed int indent);
// WritePhylip
// file msa.h line 284
extern void WritePhylip(struct _IO_FILE *fp, struct msa_struct *msa);
// WriteProfile
// file emulation.c line 91
extern void WriteProfile(struct _IO_FILE *fp, struct plan7_s *hmm, signed int do_xsw);
// WriteSELEX
// file msa.h line 289
extern void WriteSELEX(struct _IO_FILE *fp, struct msa_struct *msa);
// WriteSELEXOneBlock
// file selex.c line 547
extern void WriteSELEXOneBlock(struct _IO_FILE *fp, struct msa_struct *msa);
// WriteSeq
// file sqio.c line 1507
extern signed int WriteSeq(struct _IO_FILE *outf, signed int outform, char *seq, struct seqinfo_s *sqinfo);
// WriteSimpleFASTA
// file sqio.c line 1490
extern void WriteSimpleFASTA(struct _IO_FILE *fp, char *seq, char *name, char *desc);
// WriteStockholm
// file msa.h line 295
extern void WriteStockholm(struct _IO_FILE *fp, struct msa_struct *msa);
// WriteStockholmOneBlock
// file msa.h line 296
extern void WriteStockholmOneBlock(struct _IO_FILE *fp, struct msa_struct *msa);
// XNU
// file masks.c line 84
extern signed int XNU(unsigned char *dsq, signed int len);
// ZeroPlan7
// file funcs.h line 216
extern void ZeroPlan7(struct plan7_s *hmm);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// activate_external_sort
// file ssi.c line 1378
static signed int activate_external_sort(struct ssiindex_s *g);
// actually_write_selex
// file selex.c line 568
static void actually_write_selex(struct _IO_FILE *fp, struct msa_struct *msa, signed int cpl);
// actually_write_stockholm
// file stockholm.c line 216
static void actually_write_stockholm(struct _IO_FILE *fp, struct msa_struct *msa, signed int cpl);
// addseq
// file sqio.c line 508
static void addseq(char *s, struct ReadSeqVars *V);
// annotate_model
// file modelmakers.c line 839
static void annotate_model(struct plan7_s *hmm, signed int *matassign, struct msa_struct *msa);
// ascii2prob
// file hmmio.c line 1285
static float ascii2prob(char *s, float null);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// binary_search
// file ssi.c line 1277
static signed int binary_search(struct ssifile_s *sfp, char *key, signed int klen, struct ssioffset_s *base, unsigned int recsize, unsigned int maxidx);
// build_cij
// file modelmakers.c line 437
static signed int build_cij(char **aseqs, signed int nseq, signed int *insopt, signed int i, signed int j, float *wgt, float *cij);
// byteswap
// file hmmio.c line 1312
static void byteswap(char *swap, signed int nbytes);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// clear_ssifile
// file ssi.c line 446
static void clear_ssifile(struct ssifile_s *sfp);
// coded_revcomp
// file seqencode.c line 98
extern signed int coded_revcomp(char *comp, char *seq);
// compare_lists
// file aligneval.c line 295
static signed int compare_lists(signed int *k1, signed int *k2, signed int *t1, signed int *t2, signed int len1, signed int len2, float *ret_sc);
// copy_alignment_line
// file selex.c line 678
static signed int copy_alignment_line(char *aseq, signed int apos, signed int name_rcol, char *buffer, signed int lcol, signed int rcol, char gapsym);
// ctime
// file /usr/include/time.h line 264
extern char * ctime(const signed long int *);
// current_index_size
// file ssi.c line 1349
static unsigned long int current_index_size(struct ssiindex_s *g);
// default_amino_prior
// file prior.c line 579
static struct p7prior_s * default_amino_prior(void);
// default_nucleic_prior
// file prior.c line 693
static struct p7prior_s * default_nucleic_prior(void);
// difftime
// file /usr/include/time.h line 195
extern double difftime(signed long int, signed long int);
// downweight
// file weight.c line 110
static void downweight(struct phylo_s *tree, signed int nseq, float *lwt, float *rwt, float *fwt, signed int node);
// endEMBL
// file sqio.c line 887
static signed int endEMBL(char *s, signed int *addend);
// endGB
// file sqio.c line 728
static signed int endGB(char *s, signed int *addend);
// endGCGdata
// file sqio.c line 804
static signed int endGCGdata(char *s, signed int *addend);
// endIG
// file sqio.c line 668
static signed int endIG(char *s, signed int *addend);
// endPIR
// file sqio.c line 611
static signed int endPIR(char *s, signed int *addend);
// endPearson
// file sqio.c line 853
static signed int endPearson(char *s, signed int *addend);
// endStrider
// file sqio.c line 696
static signed int endStrider(char *s, signed int *addend);
// endZuker
// file sqio.c line 962
static signed int endZuker(char *s, signed int *addend);
// estimate_model_length
// file modelmakers.c line 478
static signed int estimate_model_length(struct msa_struct *msa);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fake_tracebacks
// file modelmakers.c line 597
static void fake_tracebacks(char **aseq, signed int nseq, signed int alen, signed int *matassign, struct p7trace_s ***ret_tr);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// format_time_string
// file stopwatch.c line 80
static void format_time_string(char *buf, double sec, signed int do_frac);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fseeko
// file /usr/include/stdio.h line 781
extern signed int fseeko(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// ftello
// file /usr/include/stdio.h line 784
extern signed long int ftello(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_wee_midpt
// file core_algorithms.c line 1717
static float get_wee_midpt(struct plan7_s *hmm, unsigned char *dsq, signed int L, signed int k1, char t1, signed int s1, signed int k3, char t3, signed int s3, signed int *ret_k2, char *ret_t2, signed int *ret_s2);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gki_alloc
// file gki.c line 287
static struct anonymous$0 * gki_alloc(signed int primelevel);
// gki_hashvalue
// file gki.c line 325
static signed int gki_hashvalue(struct anonymous$0 *hash, char *key);
// gki_upsize
// file gki.c line 350
static signed int gki_upsize(struct anonymous$0 *old);
// gsi_keysorter
// file gsi.c line 250
static signed int gsi_keysorter(const void *k1, const void *k2);
// hit_comparison
// file tophits.c line 276
signed int hit_comparison(const void *vh1, const void *vh2);
// indexfile_position
// file ssi.c line 1326
static signed int indexfile_position(struct ssifile_s *sfp, struct ssioffset_s *base, unsigned int len, unsigned int n);
// init_ilogsum
// file mathsupport.c line 149
static void init_ilogsum(void);
// load_indexfile
// file ssi.c line 77
static signed int load_indexfile(struct ssifile_s *sfp);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// main_loop_pvm
// file hmmcalibrate.c line 816
static void main_loop_pvm(struct plan7_s *hmm, signed int seed, signed int nsample, signed int lumpsize, float lenmean, float lensd, signed int fixedlen, struct histogram_s **ret_hist, float *ret_max, struct stopwatch_s *extrawatch, signed int *ret_nslaves);
// main_loop_serial
// file hmmcalibrate.c line 454
static void main_loop_serial(struct plan7_s *hmm, signed int seed, signed int nsample, float lenmean, float lensd, signed int fixedlen, struct histogram_s **ret_hist, float *ret_max);
// main_loop_threaded
// file hmmcalibrate.c line 531
static void main_loop_threaded(struct plan7_s *hmm, signed int seed, signed int nsample, float lenmean, float lensd, signed int fixedlen, signed int nthreads, struct histogram_s **ret_hist, float *ret_max, struct stopwatch_s *twatch);
// make_alilist
// file aligneval.c line 170
static signed int make_alilist(char *s1, char *s2, signed int **ret_s1_list, signed int *ret_listlen);
// make_ref_alilist
// file aligneval.c line 224
static signed int make_ref_alilist(signed int *ref, char *k1, char *k2, char *s1, char *s2, signed int **ret_s1_list, signed int *ret_listlen);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// matassign2hmm
// file modelmakers.c line 512
static void matassign2hmm(struct msa_struct *msa, unsigned char **dsq, signed int *matassign, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// multiline
// file hmmio.c line 1402
static void multiline(struct _IO_FILE *fp, char *pfx, char *s);
// parse_comment
// file stockholm.c line 595
static signed int parse_comment(struct msa_struct *msa, char *buf);
// parse_gc
// file stockholm.c line 507
static signed int parse_gc(struct msa_struct *msa, char *buf);
// parse_gf
// file stockholm.c line 399
static signed int parse_gf(struct msa_struct *msa, char *buf);
// parse_gr
// file stockholm.c line 536
static signed int parse_gr(struct msa_struct *msa, char *buf);
// parse_gs
// file stockholm.c line 464
static signed int parse_gs(struct msa_struct *msa, char *buf);
// parse_pkey_info
// file ssi.c line 1202
static signed int parse_pkey_info(char *buf, char mode, struct ssipkey_s *pkey);
// parse_sequence
// file stockholm.c line 609
static signed int parse_sequence(struct msa_struct *msa, char *buf);
// parse_skey_info
// file ssi.c line 1241
static signed int parse_skey_info(char *buf, struct ssiskey_s *skey);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pkeysort
// file ssi.c line 854
static signed int pkeysort(const void *k1, const void *k2);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// prob2ascii
// file hmmio.c line 1270
static char * prob2ascii(float p, float null);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setscope
// file /usr/include/pthread.h line 353
extern signed int pthread_attr_setscope(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$1 *, const union anonymous$2 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$1 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$1 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// pvm_config
// file /usr/include/pvm3.h line 592
signed int pvm_config(signed int *, signed int *, struct pvmhostinfo **);
// pvm_exit
// file /usr/include/pvm3.h line 597
signed int pvm_exit(void);
// pvm_initsend
// file /usr/include/pvm3.h line 617
signed int pvm_initsend(signed int);
// pvm_kill
// file /usr/include/pvm3.h line 619
signed int pvm_kill(signed int);
// pvm_mcast
// file /usr/include/pvm3.h line 623
signed int pvm_mcast(signed int *, signed int, signed int);
// pvm_mytid
// file /usr/include/pvm3.h line 626
signed int pvm_mytid(void);
// pvm_notify
// file /usr/include/pvm3.h line 628
signed int pvm_notify(signed int, signed int, signed int, signed int *);
// pvm_nrecv
// file /usr/include/pvm3.h line 630
signed int pvm_nrecv(signed int, signed int);
// pvm_pkbyte
// file /usr/include/pvm3.h line 634
signed int pvm_pkbyte(char *, signed int, signed int);
// pvm_pkdouble
// file /usr/include/pvm3.h line 637
signed int pvm_pkdouble(double *, signed int, signed int);
// pvm_pkfloat
// file /usr/include/pvm3.h line 638
signed int pvm_pkfloat(float *, signed int, signed int);
// pvm_pkint
// file /usr/include/pvm3.h line 639
signed int pvm_pkint(signed int *, signed int, signed int);
// pvm_pkstr
// file /usr/include/pvm3.h line 642
signed int pvm_pkstr(char *);
// pvm_recv
// file /usr/include/pvm3.h line 656
signed int pvm_recv(signed int, signed int);
// pvm_send
// file /usr/include/pvm3.h line 684
signed int pvm_send(signed int, signed int);
// pvm_spawn
// file /usr/include/pvm3.h line 692
signed int pvm_spawn(char *, char **, signed int, char *, signed int, signed int *);
// pvm_trecv
// file /usr/include/pvm3.h line 700
signed int pvm_trecv(signed int, signed int, struct timeval *);
// pvm_upkbyte
// file /usr/include/pvm3.h line 703
signed int pvm_upkbyte(char *, signed int, signed int);
// pvm_upkdouble
// file /usr/include/pvm3.h line 706
signed int pvm_upkdouble(double *, signed int, signed int);
// pvm_upkfloat
// file /usr/include/pvm3.h line 707
signed int pvm_upkfloat(float *, signed int, signed int);
// pvm_upkint
// file /usr/include/pvm3.h line 708
signed int pvm_upkint(signed int *, signed int, signed int);
// pvm_upkstr
// file /usr/include/pvm3.h line 711
signed int pvm_upkstr(char *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// readEMBL
// file sqio.c line 903
static void readEMBL(struct ReadSeqVars *V);
// readGCGdata
// file sqio.c line 811
static void readGCGdata(struct ReadSeqVars *V);
// readGenBank
// file sqio.c line 735
static void readGenBank(struct ReadSeqVars *V);
// readIG
// file sqio.c line 675
static void readIG(struct ReadSeqVars *V);
// readLoop
// file sqio.c line 584
static void readLoop(signed int addfirst, signed int (*endTest)(char *, signed int *), struct ReadSeqVars *V);
// readLoop::endTest$object
// 
signed int endTest$object(char *, signed int *);
// readPIR
// file sqio.c line 622
static void readPIR(struct ReadSeqVars *V);
// readPearson
// file sqio.c line 860
static void readPearson(struct ReadSeqVars *V);
// readStrider
// file sqio.c line 703
static void readStrider(struct ReadSeqVars *V);
// readUWGCG
// file sqio.c line 988
static void readUWGCG(struct ReadSeqVars *V);
// readZuker
// file sqio.c line 969
static void readZuker(struct ReadSeqVars *V);
// read_asc10hmm
// file hmmio.c line 1227
static signed int read_asc10hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_asc11hmm
// file hmmio.c line 1195
static signed int read_asc11hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_asc17hmm
// file hmmio.c line 1143
static signed int read_asc17hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_asc19hmm
// file hmmio.c line 967
static signed int read_asc19hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_asc20hmm
// file hmmio.c line 566
static signed int read_asc20hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_bin10hmm
// file hmmio.c line 1234
static signed int read_bin10hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_bin11hmm
// file hmmio.c line 1201
static signed int read_bin11hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_bin17hmm
// file hmmio.c line 1169
static signed int read_bin17hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_bin19hmm
// file hmmio.c line 1118
static signed int read_bin19hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_bin20hmm
// file hmmio.c line 781
static signed int read_bin20hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm);
// read_bin_string
// file hmmio.c line 1362
static signed int read_bin_string(struct _IO_FILE *fp, signed int doswap, char **ret_s);
// read_i16
// file ssi.c line 1134
static signed int read_i16(struct _IO_FILE *fp, unsigned short int *ret_result);
// read_i32
// file ssi.c line 1149
static signed int read_i32(struct _IO_FILE *fp, unsigned int *ret_result);
// read_i64
// file ssi.c line 1164
static signed int read_i64(struct _IO_FILE *fp, unsigned long int *ret_result);
// read_offset
// file ssi.c line 1179
static signed int read_offset(struct _IO_FILE *fp, char mode, struct ssioffset_s *ret_offset);
// read_plan9_aschmm
// file hmmio.c line 1584
static struct plan9_s * read_plan9_aschmm(struct _IO_FILE *fp, signed int version);
// read_plan9_binhmm
// file hmmio.c line 1438
static struct plan9_s * read_plan9_binhmm(struct _IO_FILE *fp, signed int version, signed int swapped);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reg
// file hsregex.c line 423
static char * reg(struct comp *cp, signed int paren, signed int *flagp);
// regatom
// file hsregex.c line 603
static char * regatom(struct comp *cp, signed int *flagp);
// regbranch
// file hsregex.c line 493
static char * regbranch(struct comp *cp, signed int *flagp);
// regc
// file hsregex.c line 739
static void regc(struct comp *cp, char b);
// reginsert
// file hsregex.c line 755
static void reginsert(struct comp *cp, char op, char *opnd);
// regmatch
// file hsregex.c line 937
static signed int regmatch(struct exec *ep, char *prog);
// regnext
// file hsregex.c line 1135
static char * regnext(char *p);
// regnode
// file hsregex.c line 714
static char * regnode(struct comp *cp, char op);
// regoptail
// file hsregex.c line 805
static void regoptail(struct comp *cp, char *p, char *val);
// regpiece
// file hsregex.c line 534
static char * regpiece(struct comp *cp, signed int *flagp);
// regrepeat
// file hsregex.c line 1096
static unsigned long int regrepeat(struct exec *ep, char *node);
// regtail
// file hsregex.c line 780
static void regtail(struct comp *cp, char *p, char *val);
// regtry
// file hsregex.c line 901
static signed int regtry(struct exec *ep, struct sqd_regexp *prog, char *string);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// revcomp
// file revcomp.c line 35
extern char * revcomp(char *comp, char *seq);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rightjustify
// file trace.c line 1197
static void rightjustify(char *s, signed int n);
// rkcomp
// file rk.c line 34
extern unsigned long int rkcomp(char *probe);
// rkseq
// file rk.c line 61
extern signed int rkseq(unsigned long int hashprobe, char *sequence);
// s2lower
// file sqfuncs.h line 218
extern void s2lower(char *s);
// s2upper
// file ../squid/sqfuncs.h line 219
extern void s2upper(char *s);
// score2postcode
// file postprob.c line 678
static char score2postcode(signed int sc);
// seqcmp
// file seqencode.c line 28
extern signed int seqcmp(char *s1, char *s2, signed int allow);
// seqdecode
// file seqencode.c line 127
extern signed int seqdecode(char *str, char *codeseq);
// seqencode
// file sqfuncs.h line 129
extern signed int seqencode(char *codeseq, char *str);
// seqfile_open
// file sqio.c line 97
static struct ReadSeqVars * seqfile_open(char *filename, signed int format, char *env, signed int ssimode);
// seqncmp
// file seqencode.c line 47
extern signed int seqncmp(char *s1, char *s2, signed int n, signed int allow);
// seqndecode
// file seqencode.c line 152
extern signed int seqndecode(char *str, char *codeseq, signed int n);
// set_degenerate
// file alphabet.c line 417
static void set_degenerate(char iupac, char *syms);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$3 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$3 *);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous$3 *, struct anonymous$3 *);
// simple_diffmx
// file weight.c line 343
static signed int simple_diffmx(char **aseqs, signed int num, float ***ret_dmx);
// simple_distance
// file weight.c line 316
static float simple_distance(char *s1, char *s2);
// skeysort
// file ssi.c line 863
static signed int skeysort(const void *k1, const void *k2);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqd_regcomp
// file hsregex.c line 334
extern struct sqd_regexp * sqd_regcomp(const char *exp);
// sqd_regerror
// file hsregex.c line 1330
extern void sqd_regerror(char *s);
// sqd_regexec
// file hsregex.c line 847
extern signed int sqd_regexec(struct sqd_regexp *prog, const char *str);
// sqd_regsub
// file hsregex.c line 1281
extern void sqd_regsub(const struct sqd_regexp *rp, const char *source, char *dest);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// sre_fgets
// file sqfuncs.h line 225
extern char * sre_fgets(char **buf, signed int *n, struct _IO_FILE *fp);
// sre_hton16
// file sqfuncs.h line 255
extern unsigned short int sre_hton16(unsigned short int hostshort);
// sre_hton32
// file sqfuncs.h line 256
extern unsigned int sre_hton32(unsigned int hostlong);
// sre_hton64
// file sqfuncs.h line 259
extern unsigned long int sre_hton64(unsigned long int host_int64);
// sre_malloc
// file ../squid/sqfuncs.h line 220
extern void * sre_malloc(char *file, signed int line, unsigned long int size);
// sre_ntoh16
// file sqfuncs.h line 253
extern unsigned short int sre_ntoh16(unsigned short int netshort);
// sre_ntoh32
// file sqfuncs.h line 254
extern unsigned int sre_ntoh32(unsigned int netlong);
// sre_ntoh64
// file sqfuncs.h line 258
extern unsigned long int sre_ntoh64(unsigned long int net_int64);
// sre_random
// file ../squid/sre_random.h line 8
extern double sre_random(void);
// sre_random_positive
// file sre_random.c line 130
extern double sre_random_positive(void);
// sre_realloc
// file ../squid/sqfuncs.h line 221
extern void * sre_realloc(char *file, signed int line, void *p, unsigned long int size);
// sre_srandom
// file ../squid/sre_random.h line 9
extern void sre_srandom(signed int seed);
// sre_strcat
// file sqfuncs.h line 226
extern signed int sre_strcat(char **dest, signed int ldest, char *src, signed int lsrc);
// sre_strdup
// file ../squid/sqfuncs.h line 228
extern char * sre_strdup(char *s, signed int n);
// sre_strncpy
// file sre_string.c line 462
extern char * sre_strncpy(char *s1, char *s2, signed int n);
// sre_strtok
// file sqfuncs.h line 227
extern char * sre_strtok(char **s, char *delim, signed int *len);
// sre_tolower
// file sqfuncs.h line 192
extern signed int sre_tolower(signed int c);
// sre_toupper
// file ../squid/sqfuncs.h line 193
extern signed int sre_toupper(signed int c);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strpbrk
// file /usr/include/string.h line 314
extern char * strpbrk(const char *, const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// times
// file /usr/include/x86_64-linux-gnu/sys/times.h line 48
extern signed long int times(struct tms *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// trace_doctor
// file modelmakers.c line 745
static void trace_doctor(struct p7trace_s *tr, signed int mlen, signed int *ret_ndi, signed int *ret_nid);
// upweight
// file weight.c line 96
static void upweight(struct phylo_s *tree, signed int nseq, float *lwt, float *rwt, signed int node);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// worker_thread
// file hmmcalibrate.c line 707
static void * worker_thread(void *ptr);
// workpool_free
// file hmmcalibrate.c line 689
static void workpool_free(struct workpool_s *wpool);
// workpool_start
// file hmmcalibrate.c line 594
static struct workpool_s * workpool_start(struct plan7_s *hmm, float lenmean, float lensd, signed int fixedlen, float *randomseq, signed int nsample, struct histogram_s *hist, signed int num_threads);
// workpool_stop
// file hmmcalibrate.c line 668
static void workpool_stop(struct workpool_s *wpool);
// write_bin_string
// file hmmio.c line 1333
static void write_bin_string(struct _IO_FILE *fp, char *s);
// write_i16
// file ssi.c line 1142
static signed int write_i16(struct _IO_FILE *fp, unsigned short int n);
// write_i32
// file ssi.c line 1157
static signed int write_i32(struct _IO_FILE *fp, unsigned int n);
// write_i64
// file ssi.c line 1172
static signed int write_i64(struct _IO_FILE *fp, unsigned long int n);
// write_offset
// file ssi.c line 1192
static signed int write_offset(struct _IO_FILE *fp, struct ssioffset_s *offset);

struct anonymous$0
{
  // table
  struct gki_elem **table;
  // primelevel
  signed int primelevel;
  // nhash
  signed int nhash;
  // nkeys
  signed int nkeys;
};

struct anonymous$3
{
  // __val
  unsigned long int __val[16l];
};

union anonymous$2
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$1
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous
{
  // i32
  unsigned int i32;
  // i64
  unsigned long int i64;
};

struct ssioffset_s
{
  // mode
  char mode;
  // off
  union anonymous off;
};

struct ReadSeqVars
{
  // f
  struct _IO_FILE *f;
  // fname
  char *fname;
  // linenumber
  signed int linenumber;
  // buf
  char *buf;
  // buflen
  signed int buflen;
  // ssimode
  signed int ssimode;
  // ssioffset
  struct ssioffset_s ssioffset;
  // r_off
  struct ssioffset_s r_off;
  // d_off
  struct ssioffset_s d_off;
  // rpl
  signed int rpl;
  // lastrpl
  signed int lastrpl;
  // maxrpl
  signed int maxrpl;
  // bpl
  signed int bpl;
  // lastbpl
  signed int lastbpl;
  // maxbpl
  signed int maxbpl;
  // seq
  char *seq;
  // sqinfo
  struct seqinfo_s *sqinfo;
  // sp
  char *sp;
  // seqlen
  signed int seqlen;
  // maxseq
  signed int maxseq;
  // format
  signed int format;
  // do_gzip
  signed int do_gzip;
  // do_stdin
  signed int do_stdin;
  // msa
  struct msa_struct *msa;
  // afp
  struct msafile_struct *afp;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct aliinfo_s
{
  // flags
  signed int flags;
  // alen
  signed int alen;
  // nseq
  signed int nseq;
  // wgt
  float *wgt;
  // cs
  char *cs;
  // rf
  char *rf;
  // sqinfo
  struct seqinfo_s *sqinfo;
  // name
  char *name;
  // desc
  char *desc;
  // acc
  char *acc;
  // au
  char *au;
  // tc1
  float tc1;
  // tc2
  float tc2;
  // nc1
  float nc1;
  // nc2
  float nc2;
  // ga1
  float ga1;
  // ga2
  float ga2;
};

struct basic_state
{
  // t
  float t[3l];
  // p
  float p[20l];
};

struct comp
{
  // regparse
  char *regparse;
  // regnpar
  signed int regnpar;
  // regcode
  char *regcode;
  // regdummy
  char regdummy[3l];
  // regsize
  signed long int regsize;
};

struct dpmatrix_s
{
  // xmx
  signed int **xmx;
  // mmx
  signed int **mmx;
  // imx
  signed int **imx;
  // dmx
  signed int **dmx;
  // xmx_mem
  void *xmx_mem;
  // mmx_mem
  void *mmx_mem;
  // imx_mem
  void *imx_mem;
  // dmx_mem
  void *dmx_mem;
  // maxN
  signed int maxN;
  // maxM
  signed int maxM;
  // padN
  signed int padN;
  // padM
  signed int padM;
};

struct dpshadow_s
{
  // xtb
  char **xtb;
  // mtb
  char **mtb;
  // itb
  char **itb;
  // dtb
  char **dtb;
  // esrc
  signed int *esrc;
};

struct exec
{
  // reginput
  char *reginput;
  // regbol
  char *regbol;
  // regstartp
  char **regstartp;
  // regendp
  char **regendp;
};

struct fancyali_s
{
  // rfline
  char *rfline;
  // csline
  char *csline;
  // model
  char *model;
  // mline
  char *mline;
  // aseq
  char *aseq;
  // len
  signed int len;
  // query
  char *query;
  // target
  char *target;
  // sqfrom
  signed int sqfrom;
  // sqto
  signed int sqto;
};

struct gki_elem
{
  // key
  char *key;
  // idx
  signed int idx;
  // nxt
  struct gki_elem *nxt;
};

struct gsi_s
{
  // gsifp
  struct _IO_FILE *gsifp;
  // nfiles
  unsigned short int nfiles;
  // recnum
  unsigned int recnum;
};

struct gsiindex_s
{
  // filenames
  char **filenames;
  // fmt
  signed int *fmt;
  // nfiles
  unsigned short int nfiles;
  // elems
  struct gsikey_s *elems;
  // nkeys
  signed int nkeys;
};

struct gsikey_s
{
  // key
  char key[32l];
  // filenum
  unsigned short int filenum;
  // offset
  unsigned int offset;
};

struct histogram_s
{
  // histogram
  signed int *histogram;
  // min
  signed int min;
  // max
  signed int max;
  // highscore
  signed int highscore;
  // lowscore
  signed int lowscore;
  // lumpsize
  signed int lumpsize;
  // total
  signed int total;
  // expect
  float *expect;
  // fit_type
  signed int fit_type;
  // param
  float param[3l];
  // chisq
  float chisq;
  // chip
  float chip;
};

struct hit_s
{
  // sortkey
  double sortkey;
  // score
  float score;
  // pvalue
  double pvalue;
  // mothersc
  float mothersc;
  // motherp
  double motherp;
  // name
  char *name;
  // acc
  char *acc;
  // desc
  char *desc;
  // sqfrom
  signed int sqfrom;
  // sqto
  signed int sqto;
  // sqlen
  signed int sqlen;
  // hmmfrom
  signed int hmmfrom;
  // hmmto
  signed int hmmto;
  // hmmlen
  signed int hmmlen;
  // domidx
  signed int domidx;
  // ndom
  signed int ndom;
  // ali
  struct fancyali_s *ali;
};

struct hmmfile_s
{
  // f
  struct _IO_FILE *f;
  // ssi
  struct ssifile_s *ssi;
  // parser
  signed int (*parser)(struct hmmfile_s *, struct plan7_s **);
  // is_binary
  signed int is_binary;
  // byteswap
  signed int byteswap;
  // is_seekable
  signed int is_seekable;
  // mode
  signed int mode;
  // offset
  struct ssioffset_s offset;
};

struct intstack_s
{
  // data
  signed int data;
  // nxt
  struct intstack_s *nxt;
};

struct iupactype
{
  // sym
  char sym;
  // symcomp
  char symcomp;
  // code
  char code;
  // comp
  char comp;
};

struct msa_struct
{
  // aseq
  char **aseq;
  // sqname
  char **sqname;
  // wgt
  float *wgt;
  // alen
  signed int alen;
  // nseq
  signed int nseq;
  // flags
  signed int flags;
  // type
  signed int type;
  // name
  char *name;
  // desc
  char *desc;
  // acc
  char *acc;
  // au
  char *au;
  // ss_cons
  char *ss_cons;
  // sa_cons
  char *sa_cons;
  // rf
  char *rf;
  // sqacc
  char **sqacc;
  // sqdesc
  char **sqdesc;
  // ss
  char **ss;
  // sa
  char **sa;
  // cutoff
  float cutoff[6l];
  // cutoff_is_set
  signed int cutoff_is_set[6l];
  // comment
  char **comment;
  // ncomment
  signed int ncomment;
  // alloc_ncomment
  signed int alloc_ncomment;
  // gf_tag
  char **gf_tag;
  // gf
  char **gf;
  // ngf
  signed int ngf;
  // alloc_ngf
  signed int alloc_ngf;
  // gs_tag
  char **gs_tag;
  // gs
  char ***gs;
  // gs_idx
  struct anonymous$0 *gs_idx;
  // ngs
  signed int ngs;
  // gc_tag
  char **gc_tag;
  // gc
  char **gc;
  // gc_idx
  struct anonymous$0 *gc_idx;
  // ngc
  signed int ngc;
  // gr_tag
  char **gr_tag;
  // gr
  char ***gr;
  // gr_idx
  struct anonymous$0 *gr_idx;
  // ngr
  signed int ngr;
  // index
  struct anonymous$0 *index;
  // nseqalloc
  signed int nseqalloc;
  // nseqlump
  signed int nseqlump;
  // sqlen
  signed int *sqlen;
  // sslen
  signed int *sslen;
  // salen
  signed int *salen;
  // lastidx
  signed int lastidx;
};

struct msafile_struct
{
  // f
  struct _IO_FILE *f;
  // fname
  char *fname;
  // linenumber
  signed int linenumber;
  // buf
  char *buf;
  // buflen
  signed int buflen;
  // ssi
  struct ssifile_s *ssi;
  // do_gzip
  signed int do_gzip;
  // do_stdin
  signed int do_stdin;
  // format
  signed int format;
};

struct opt_s
{
  // name
  char *name;
  // single
  signed int single;
  // argtype
  signed int argtype;
};

struct p7prior_s
{
  // strategy
  signed int strategy;
  // tnum
  signed int tnum;
  // tq
  float tq[200l];
  // t
  float t[200l][7l];
  // mnum
  signed int mnum;
  // mq
  float mq[200l];
  // m
  float m[200l][20l];
  // inum
  signed int inum;
  // iq
  float iq[200l];
  // i
  float i[200l][20l];
};

struct p7trace_s
{
  // tlen
  signed int tlen;
  // statetype
  char *statetype;
  // nodeidx
  signed int *nodeidx;
  // pos
  signed int *pos;
};

struct phylo_s
{
  // parent
  signed int parent;
  // left
  signed int left;
  // right
  signed int right;
  // diff
  float diff;
  // lblen
  float lblen;
  // rblen
  float rblen;
  // is_in
  char *is_in;
  // incnum
  signed int incnum;
};

struct plan7_s
{
  // name
  char *name;
  // acc
  char *acc;
  // desc
  char *desc;
  // rf
  char *rf;
  // cs
  char *cs;
  // ca
  char *ca;
  // comlog
  char *comlog;
  // nseq
  signed int nseq;
  // ctime
  char *ctime;
  // map
  signed int *map;
  // checksum
  signed int checksum;
  // tpri
  signed int *tpri;
  // mpri
  signed int *mpri;
  // ipri
  signed int *ipri;
  // ga1
  float ga1;
  // ga2
  float ga2;
  // tc1
  float tc1;
  // tc2
  float tc2;
  // nc1
  float nc1;
  // nc2
  float nc2;
  // M
  signed int M;
  // t
  float **t;
  // mat
  float **mat;
  // ins
  float **ins;
  // tbd1
  float tbd1;
  // xt
  float xt[4l][2l];
  // begin
  float *begin;
  // end
  float *end;
  // null
  float null[20l];
  // p1
  float p1;
  // tsc
  signed int **tsc;
  // msc
  signed int **msc;
  // isc
  signed int **isc;
  // xsc
  signed int xsc[4l][2l];
  // bsc
  signed int *bsc;
  // esc
  signed int *esc;
  // tsc_mem
  signed int *tsc_mem;
  // msc_mem
  signed int *msc_mem;
  // isc_mem
  signed int *isc_mem;
  // bsc_mem
  signed int *bsc_mem;
  // esc_mem
  signed int *esc_mem;
  // dnam
  signed int **dnam;
  // dnai
  signed int **dnai;
  // dna2
  signed int dna2;
  // dna4
  signed int dna4;
  // mu
  float mu;
  // lambda
  float lambda;
  // flags
  signed int flags;
};

struct plan9_s
{
  // M
  signed int M;
  // ins
  struct basic_state *ins;
  // mat
  struct basic_state *mat;
  // del
  struct basic_state *del;
  // null
  float null[20l];
  // name
  char *name;
  // ref
  char *ref;
  // cs
  char *cs;
  // xray
  float *xray;
  // flags
  signed int flags;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct pvmhostinfo
{
  // hi_tid
  signed int hi_tid;
  // hi_name
  char *hi_name;
  // hi_arch
  char *hi_arch;
  // hi_speed
  signed int hi_speed;
  // hi_dsig
  signed int hi_dsig;
};

struct seqinfo_s
{
  // flags
  signed int flags;
  // name
  char name[64l];
  // id
  char id[64l];
  // acc
  char acc[64l];
  // desc
  char desc[128l];
  // len
  signed int len;
  // start
  signed int start;
  // stop
  signed int stop;
  // olen
  signed int olen;
  // type
  signed int type;
  // ss
  char *ss;
  // sa
  char *sa;
};

struct sqd_regexp
{
  // startp
  char *startp[10l];
  // endp
  char *endp[10l];
  // regstart
  char regstart;
  // reganch
  char reganch;
  // regmust
  char *regmust;
  // regmlen
  signed int regmlen;
  // program
  char program[1l];
};

struct ssifile_s
{
  // fp
  struct _IO_FILE *fp;
  // flags
  unsigned int flags;
  // nfiles
  unsigned short int nfiles;
  // nprimary
  unsigned int nprimary;
  // nsecondary
  unsigned int nsecondary;
  // flen
  unsigned int flen;
  // plen
  unsigned int plen;
  // slen
  unsigned int slen;
  // frecsize
  unsigned int frecsize;
  // precsize
  unsigned int precsize;
  // srecsize
  unsigned int srecsize;
  // foffset
  struct ssioffset_s foffset;
  // poffset
  struct ssioffset_s poffset;
  // soffset
  struct ssioffset_s soffset;
  // imode
  char imode;
  // smode
  char smode;
  // filename
  char **filename;
  // fileformat
  unsigned int *fileformat;
  // fileflags
  unsigned int *fileflags;
  // bpl
  unsigned int *bpl;
  // rpl
  unsigned int *rpl;
};

struct ssiindex_s
{
  // smode
  signed int smode;
  // imode
  signed int imode;
  // external
  signed int external;
  // max_ram
  signed int max_ram;
  // filenames
  char **filenames;
  // fileformat
  unsigned int *fileformat;
  // bpl
  unsigned int *bpl;
  // rpl
  unsigned int *rpl;
  // flen
  unsigned int flen;
  // nfiles
  unsigned short int nfiles;
  // pkeys
  struct ssipkey_s *pkeys;
  // plen
  unsigned int plen;
  // nprimary
  unsigned int nprimary;
  // ptmpfile
  char *ptmpfile;
  // ptmp
  struct _IO_FILE *ptmp;
  // skeys
  struct ssiskey_s *skeys;
  // slen
  unsigned int slen;
  // nsecondary
  unsigned int nsecondary;
  // stmpfile
  char *stmpfile;
  // stmp
  struct _IO_FILE *stmp;
};

struct ssipkey_s
{
  // key
  char *key;
  // fnum
  unsigned short int fnum;
  // r_off
  struct ssioffset_s r_off;
  // d_off
  struct ssioffset_s d_off;
  // len
  unsigned int len;
};

struct ssiskey_s
{
  // key
  char *key;
  // pkey
  char *pkey;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct tms
{
  // tms_utime
  signed long int tms_utime;
  // tms_stime
  signed long int tms_stime;
  // tms_cutime
  signed long int tms_cutime;
  // tms_cstime
  signed long int tms_cstime;
};

struct stopwatch_s
{
  // t0
  signed long int t0;
  // cpu0
  struct tms cpu0;
  // elapsed
  double elapsed;
  // user
  double user;
  // sys
  double sys;
};

struct threshold_s
{
  // globT
  float globT;
  // globE
  double globE;
  // domT
  float domT;
  // domE
  double domE;
  // autocut
  enum anonymous$4 autocut;
  // Z
  signed int Z;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct tophit_s
{
  // hit
  struct hit_s **hit;
  // unsrt
  struct hit_s *unsrt;
  // alloc
  signed int alloc;
  // num
  signed int num;
  // lump
  signed int lump;
};

struct workpool_s
{
  // hmm
  struct plan7_s *hmm;
  // fixedlen
  signed int fixedlen;
  // lenmean
  float lenmean;
  // lensd
  float lensd;
  // randomseq
  float *randomseq;
  // nsample
  signed int nsample;
  // nseq
  signed int nseq;
  // hist
  struct histogram_s *hist;
  // max_score
  float max_score;
  // watch
  struct stopwatch_s watch;
  // thread
  unsigned long int *thread;
  // num_threads
  signed int num_threads;
  // input_lock
  union anonymous$1 input_lock;
  // output_lock
  union anonymous$1 output_lock;
};


// Alphabet
// file globals.h line 23
char Alphabet[25l];
// Alphabet_iupac
// file globals.h line 26
signed int Alphabet_iupac;
// Alphabet_size
// file globals.h line 25
signed int Alphabet_size;
// Alphabet_type
// file globals.h line 24
signed int Alphabet_type;
// DegenCount
// file globals.h line 28
signed int DegenCount[24l];
// Degenerate
// file globals.h line 27
char Degenerate[24l][20l];
// OPTIONS
// file hmmcalibrate.c line 64
static struct opt_s OPTIONS[9l] = { { .name="-h", .single=1, .argtype=0 }, { .name="--cpu", .single=0, .argtype=1 }, 
    { .name="--fixed", .single=0, .argtype=1 }, 
    { .name="--histfile", .single=0, .argtype=4 }, 
    { .name="--mean", .single=0, .argtype=2 }, 
    { .name="--num", .single=0, .argtype=1 }, 
    { .name="--pvm", .single=0, .argtype=0 }, 
    { .name="--sd", .single=0, .argtype=2 }, 
    { .name="--seed", .single=0, .argtype=1 } };
// aa_alphabet
// file iupac.c line 56
char aa_alphabet[21l] = { 'A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 0 };
// aa_index
// file iupac.c line 58
signed int aa_index[20l] = { 0, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18, 19, 21, 22, 24 };
// aafq
// file iupac.c line 33
float aafq[20l] = { (float)0.075520, (float)0.016973, (float)0.053029, (float)0.063204, (float)0.040762, (float)0.068448, (float)0.022406, (float)0.057284, (float)0.059398, (float)0.093399, (float)0.023569, (float)0.045293, (float)0.049262, (float)0.040231, (float)0.051573, (float)0.072214, (float)0.057454, (float)0.065252, (float)0.012513, (float)0.031985 };
// aminos
// file sqio.c line 68
static char *aminos = "ABCDEFGHIKLMNPQRSTVWXYZ*";
// banner
// file hmmcalibrate.c line 45
static char banner[48l] = { 'h', 'm', 'm', 'c', 'a', 'l', 'i', 'b', 'r', 'a', 't', 'e', ' ', '-', '-', ' ', 'c', 'a', 'l', 'i', 'b', 'r', 'a', 't', 'e', ' ', 'H', 'M', 'M', ' ', 's', 'e', 'a', 'r', 'c', 'h', ' ', 's', 't', 'a', 't', 'i', 's', 't', 'i', 'c', 's', 0 };
// commentsyms
// file selex.c line 53
static char commentsyms[3l] = { '%', '#', 0 };
// dnafq
// file iupac.c line 25
float dnafq[4l] = { (float)0.25, (float)0.25, (float)0.25, (float)0.25 };
// experts
// file hmmcalibrate.c line 53
static char experts[456l] = { ' ', ' ', '-', '-', 'c', 'p', 'u', ' ', '<', 'n', '>', ' ', ' ', ' ', ' ', ' ', ' ', ':', ' ', 'r', 'u', 'n', ' ', '<', 'n', '>', ' ', 't', 'h', 'r', 'e', 'a', 'd', 's', ' ', 'i', 'n', ' ', 'p', 'a', 'r', 'a', 'l', 'l', 'e', 'l', ' ', '(', 'i', 'f', ' ', 't', 'h', 'r', 'e', 'a', 'd', 'e', 'd', ')', '\n', ' ', ' ', '-', '-', 'f', 'i', 'x', 'e', 'd', ' ', '<', 'n', '>', ' ', ' ', ' ', ' ', ':', ' ', 'f', 'i', 'x', ' ', 'r', 'a', 'n', 'd', 'o', 'm', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ', 'l', 'e', 'n', 'g', 't', 'h', ' ', 'a', 't', ' ', '<', 'n', '>', '\n', ' ', ' ', '-', '-', 'h', 'i', 's', 't', 'f', 'i', 'l', 'e', ' ', '<', 'f', '>', ' ', ':', ' ', 's', 'a', 'v', 'e', ' ', 'h', 'i', 's', 't', 'o', 'g', 'r', 'a', 'm', '(', 's', ')', ' ', 't', 'o', ' ', 'f', 'i', 'l', 'e', ' ', '<', 'f', '>', '\n', ' ', ' ', '-', '-', 'm', 'e', 'a', 'n', ' ', '<', 'x', '>', ' ', ' ', ' ', ' ', ' ', ':', ' ', 's', 'e', 't', ' ', 'r', 'a', 'n', 'd', 'o', 'm', ' ', 's', 'e', 'q', ' ', 'l', 'e', 'n', 'g', 't', 'h', ' ', 'm', 'e', 'a', 'n', ' ', 'a', 't', ' ', '<', 'x', '>', ' ', '[', '3', '5', '0', ']', '\n', ' ', ' ', '-', '-', 'n', 'u', 'm', ' ', '<', 'n', '>', ' ', ' ', ' ', ' ', ' ', ' ', ':', ' ', 's', 'e', 't', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 's', 'a', 'm', 'p', 'l', 'e', 'd', ' ', 's', 'e', 'q', 's', ' ', 't', 'o', ' ', '<', 'n', '>', ' ', '[', '5', '0', '0', '0', ']', '\n', ' ', ' ', '-', '-', 'p', 'v', 'm', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ':', ' ', 'r', 'u', 'n', ' ', 'o', 'n', ' ', 'a', ' ', 'P', 'a', 'r', 'a', 'l', 'l', 'e', 'l', ' ', 'V', 'i', 'r', 't', 'u', 'a', 'l', ' ', 'M', 'a', 'c', 'h', 'i', 'n', 'e', ' ', '(', 'P', 'V', 'M', ')', '\n', ' ', ' ', '-', '-', 's', 'd', ' ', '<', 'x', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ':', ' ', 's', 'e', 't', ' ', 'r', 'a', 'n', 'd', 'o', 'm', ' ', 's', 'e', 'q', ' ', 'l', 'e', 'n', 'g', 't', 'h', ' ', 's', 't', 'd', '.', ' ', 'd', 'e', 'v', ' ', 't', 'o', ' ', '<', 'x', '>', ' ', '[', '3', '5', '0', ']', '\n', ' ', ' ', '-', '-', 's', 'e', 'e', 'd', ' ', '<', 'n', '>', ' ', ' ', ' ', ' ', ' ', ':', ' ', 's', 'e', 't', ' ', 'r', 'a', 'n', 'd', 'o', 'm', ' ', 's', 'e', 'e', 'd', ' ', 't', 'o', ' ', '<', 'n', '>', ' ', '[', 't', 'i', 'm', 'e', '(', ')', ']', '\n', 0 };
// gki_primes
// file gki.c line 96
static signed int gki_primes[4l] = { 101, 1009, 10007, 100003 };
// ilogsum_lookup
// file mathsupport.c line 147
static signed int ilogsum_lookup[20000l];
// iupac
// file iupac.c line 63
struct iupactype iupac[17l] = { { .sym=(char)65, .symcomp=(char)84, .code=(char)8, .comp=(char)1 }, 
    { .sym=(char)67, .symcomp=(char)71, .code=(char)4, .comp=(char)2 }, 
    { .sym=(char)71, .symcomp=(char)67, .code=(char)2, .comp=(char)4 }, 
    { .sym=(char)84, .symcomp=(char)65, .code=(char)1, .comp=(char)8 }, 
    { .sym=(char)85, .symcomp=(char)65, .code=(char)1, .comp=(char)8 }, 
    { .sym=(char)78, .symcomp=(char)78, .code=(char)15, .comp=(char)15 }, 
    { .sym=(char)32, .symcomp=(char)32, .code=(char)16, .comp=(char)16 }, 
    { .sym=(char)82, .symcomp=(char)89, .code=(char)10, .comp=(char)5 }, 
    { .sym=(char)89, .symcomp=(char)82, .code=(char)5, .comp=(char)10 }, 
    { .sym=(char)77, .symcomp=(char)75, .code=(char)12, .comp=(char)3 }, 
    { .sym=(char)75, .symcomp=(char)77, .code=(char)3, .comp=(char)12 }, 
    { .sym=(char)83, .symcomp=(char)83, .code=(char)6, .comp=(char)6 }, 
    { .sym=(char)87, .symcomp=(char)87, .code=(char)9, .comp=(char)9 }, 
    { .sym=(char)72, .symcomp=(char)68, .code=(char)13, .comp=(char)11 }, 
    { .sym=(char)66, .symcomp=(char)86, .code=(char)7, .comp=(char)14 }, 
    { .sym=(char)86, .symcomp=(char)66, .code=(char)14, .comp=(char)7 }, 
    { .sym=(char)68, .symcomp=(char)72, .code=(char)11, .comp=(char)13 } };
// primenuc
// file sqio.c line 69
static char *primenuc = "ACGTUN";
// protonly
// file sqio.c line 70
static char *protonly = "EFIPQZ";
// sqd_parse
// file hsregex.c line 41
char *sqd_parse[10l];
// squid_errno
// file sqerror.c line 24
signed int squid_errno;
// sre_randseed
// file sre_random.c line 16
static signed int sre_randseed = 42;
// stdcode1
// file iupac.c line 84
char *stdcode1[65l] = { "K", "N", "K", "N", "T", "T", "T", "T", "R", "S", "R", "S", "I", "I", "M", "I", "Q", "H", "Q", "H", "P", "P", "P", "P", "R", "R", "R", "R", "L", "L", "L", "L", "E", "D", "E", "D", "A", "A", "A", "A", "G", "G", "G", "G", "V", "V", "V", "V", "*", "Y", "*", "Y", "S", "S", "S", "S", "*", "C", "W", "C", "L", "F", "L", "F", "X" };
// stdcode3
// file iupac.c line 155
char *stdcode3[65l] = { "Lys", "Asn", "Lys", "Asn", "Thr", "Thr", "Thr", "Thr", "Arg", "Ser", "Arg", "Ser", "Ile", "Ile", "Met", "Ile", "Gln", "His", "Gln", "His", "Pro", "Pro", "Pro", "Pro", "Arg", "Arg", "Arg", "Arg", "Leu", "Leu", "Leu", "Leu", "Glu", "Asp", "Glu", "Asp", "Ala", "Ala", "Ala", "Ala", "Gly", "Gly", "Gly", "Gly", "Val", "Val", "Val", "Val", "***", "Tyr", "***", "Tyr", "Ser", "Ser", "Ser", "Ser", "***", "Cys", "Trp", "Cys", "Leu", "Phe", "Leu", "Trp", "XXX" };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// usage
// file hmmcalibrate.c line 47
static char usage[130l] = { 'U', 's', 'a', 'g', 'e', ':', ' ', 'h', 'm', 'm', 'c', 'a', 'l', 'i', 'b', 'r', 'a', 't', 'e', ' ', '[', '-', 'o', 'p', 't', 'i', 'o', 'n', 's', ']', ' ', '<', 'h', 'm', 'm', 'f', 'i', 'l', 'e', '>', '\n', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'o', 'p', 't', 'i', 'o', 'n', 's', ' ', 'a', 'r', 'e', ':', '\n', ' ', ' ', '-', 'h', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ':', ' ', 'p', 'r', 'i', 'n', 't', ' ', 's', 'h', 'o', 'r', 't', ' ', 'u', 's', 'a', 'g', 'e', ' ', 'a', 'n', 'd', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'i', 'n', 'f', 'o', ',', ' ', 't', 'h', 'e', 'n', ' ', 'e', 'x', 'i', 't', '\n', 0 };
// v10magic
// file hmmio.c line 92
static unsigned int v10magic = 0xe8ededb1;
// v10swap
// file hmmio.c line 93
static unsigned int v10swap = 0xb1edede8;
// v11magic
// file hmmio.c line 94
static unsigned int v11magic = 0xe8ededb2;
// v11swap
// file hmmio.c line 95
static unsigned int v11swap = 0xb2edede8;
// v17magic
// file hmmio.c line 96
static unsigned int v17magic = 0xe8ededb3;
// v17swap
// file hmmio.c line 97
static unsigned int v17swap = 0xb3edede8;
// v19magic
// file hmmio.c line 98
static unsigned int v19magic = 0xe8ededb4;
// v19swap
// file hmmio.c line 99
static unsigned int v19swap = 0xb4edede8;
// v20magic
// file hmmio.c line 100
static unsigned int v20magic = 0xe8ededb5;
// v20magic$link1
// file ssi.c line 22
static unsigned int v20magic$link1 = 0xf3f3e9b1;
// v20swap
// file hmmio.c line 101
static unsigned int v20swap = 0xb5edede8;
// v20swap$link1
// file ssi.c line 23
static unsigned int v20swap$link1 = 0xb1e9f3f3;
// xpam120
// file masks.c line 43
static signed int xpam120[23l][23l] = { { 3, -3, 0, 0, -4, 1, -3, -1, -2, -3, -2, -1, 1, -1, -3, 1, 1, 0, -7, -4, 1, 0, 0 }, 
    { -3, 9, -7, -7, -6, -4, -4, -3, -7, -7, -6, -5, -4, -7, -4, 0, -3, -3, -8, -1, -4, -6, 0 }, 
    { 0, -7, 5, 3, -7, 0, 0, -3, -1, -5, -4, 2, -3, 1, -3, 0, -1, -3, -8, -5, 5, 3, 0 }, 
    { 0, -7, 3, 5, -7, -1, -1, -3, -1, -4, -3, 1, -2, 2, -3, -1, -2, -3, -8, -5, 3, 5, 0 }, 
    { -4, -6, -7, -7, 8, -5, -3, 0, -7, 0, -1, -4, -5, -6, -5, -3, -4, -3, -1, 4, -4, -5, 0 }, 
    { 1, -4, 0, -1, -5, 5, -4, -4, -3, -5, -4, 0, -2, -3, -4, 1, -1, -2, -8, -6, 1, -1, 0 }, 
    { -3, -4, 0, -1, -3, -4, 7, -4, -2, -3, -4, 2, -1, 3, 1, -2, -3, -3, -3, -1, 2, 2, 0 }, 
    { -1, -3, -3, -3, 0, -4, -4, 6, -3, 1, 1, -2, -3, -3, -2, -2, 0, 3, -6, -2, -2, -2, 0 }, 
    { -2, -7, -1, -1, -7, -3, -2, -3, 5, -4, 0, 1, -2, 0, 2, -1, -1, -4, -5, -5, 1, 0, 0 }, 
    { -3, -7, -5, -4, 0, -5, -3, 1, -4, 5, 3, -4, -3, -2, -4, -4, -3, 1, -3, -2, -3, -2, 0 }, 
    { -2, -6, -4, -3, -1, -4, -4, 1, 0, 3, 8, -3, -3, -1, -1, -2, -1, 1, -6, -4, -3, -1, 0 }, 
    { -1, -5, 2, 1, -4, 0, 2, -2, 1, -4, -3, 4, -2, 0, -1, 1, 0, -3, -4, -2, 4, 1, 0 }, 
    { 1, -4, -3, -2, -5, -2, -1, -3, -2, -3, -3, -2, 6, 0, -1, 1, -1, -2, -7, -6, -1, 0, 0 }, 
    { -1, -7, 1, 2, -6, -3, 3, -3, 0, -2, -1, 0, 0, 6, 1, -2, -2, -3, -6, -5, 1, 5, 0 }, 
    { -3, -4, -3, -3, -5, -4, 1, -2, 2, -4, -1, -1, -1, 1, 6, -1, -2, -3, 1, -5, -1, 0, 0 }, 
    { 1, 0, 0, -1, -3, 1, -2, -2, -1, -4, -2, 1, 1, -2, -1, 3, 2, -2, -2, -3, 1, 0, 0 }, 
    { 1, -3, -1, -2, -4, -1, -3, 0, -1, -3, -1, 0, -1, -2, -2, 2, 4, 0, -6, -3, 1, -1, 0 }, 
    { 0, -3, -3, -3, -3, -2, -3, 3, -4, 1, 1, -3, -2, -3, -3, -2, 0, 5, -8, -3, -2, -2, 0 }, 
    { -7, -8, -8, -8, -1, -8, -3, -6, -5, -3, -6, -4, -7, -6, 1, -2, -6, -8, 12, -2, -5, -6, 0 }, 
    { -4, -1, -5, -5, 4, -6, -1, -2, -5, -2, -4, -2, -6, -5, -5, -3, -3, -3, -2, 8, -2, -4, 0 }, 
    { 1, -4, 5, 3, -4, 1, 2, -2, 1, -3, -3, 4, -1, 1, -1, 1, 1, -2, -5, -2, 6, 4, 0 }, 
    { 0, -6, 3, 5, -5, -1, 2, -2, 0, -2, -1, 1, 0, 5, 0, 0, -1, -2, -6, -4, 4, 6, 0 }, 
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };

// AddToHistogram
// file funcs.h line 125
extern void AddToHistogram(struct histogram_s *h, float sc)
{
  signed int score;
  signed int moveby;
  signed int prevsize;
  signed int newsize;
  signed int i;
  if(!(h->fit_type == 0))
    Die("AddToHistogram(): Can't add to a fitted histogram\n");

  double return_value_floor$1;
  return_value_floor$1=floor((double)sc);
  score = (signed int)return_value_floor$1;
  if(!(score >= h->min))
  {
    prevsize = (h->max - h->min) + 1;
    moveby = (h->min - score) + h->lumpsize;
    newsize = prevsize + moveby;
    h->min = h->min - moveby;
    void *return_value_sre_realloc$2;
    return_value_sre_realloc$2=sre_realloc("histogram.c", 148, (void *)h->histogram, sizeof(signed int) /*4ul*/  * (unsigned long int)newsize);
    h->histogram = (signed int *)return_value_sre_realloc$2;
    memmove((void *)(h->histogram + (signed long int)moveby), (const void *)h->histogram, sizeof(signed int) /*4ul*/  * (unsigned long int)prevsize);
    i = 0;
    for( ; !(i >= moveby); i = i + 1)
      h->histogram[(signed long int)i] = 0;
  }

  else
    if(!(h->max >= score))
    {
      prevsize = (h->max - h->min) + 1;
      h->max = h->lumpsize + score;
      newsize = (h->max - h->min) + 1;
      void *return_value_sre_realloc$3;
      return_value_sre_realloc$3=sre_realloc("histogram.c", 159, (void *)h->histogram, sizeof(signed int) /*4ul*/  * (unsigned long int)newsize);
      h->histogram = (signed int *)return_value_sre_realloc$3;
      i = prevsize;
      for( ; !(i >= newsize); i = i + 1)
        h->histogram[(signed long int)i] = 0;
    }

  h->histogram[(signed long int)(score - h->min)] = h->histogram[(signed long int)(score - h->min)] + 1;
  h->total = h->total + 1;
  if(!(score >= h->lowscore))
    h->lowscore = score;

  if(!(h->highscore >= score))
    h->highscore = score;

  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// AlignmentBootstrap
// file shuffle.c line 512
extern signed int AlignmentBootstrap(char **ali1, char **ali2, signed int nseq, signed int alen)
{
  signed int pos;
  signed int col;
  signed int i;
  pos = 0;
  for( ; !(pos >= alen); pos = pos + 1)
  {
    double return_value_sre_random$1;
    return_value_sre_random$1=sre_random();
    col = (signed int)(return_value_sre_random$1 * (double)alen);
    i = 0;
    for( ; !(i >= nseq); i = i + 1)
      ali1[(signed long int)i][(signed long int)pos] = ali2[(signed long int)i][(signed long int)col];
  }
  i = 0;
  for( ; !(i >= nseq); i = i + 1)
    ali1[(signed long int)i][(signed long int)alen] = (char)0;
  return 1;
}

// AlignmentHomogenousGapsym
// file alignio.c line 635
extern void AlignmentHomogenousGapsym(char **aseq, signed int nseq, signed int alen, char gapsym)
{
  signed int i;
  signed int apos;
  i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  for( ; !(i >= nseq); i = i + 1)
  {
    apos = 0;
    for( ; !(apos >= alen); apos = apos + 1)
    {
      if((signed int)aseq[(signed long int)i][(signed long int)apos] == 32)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)aseq[(signed long int)i][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)aseq[(signed long int)i][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)aseq[(signed long int)i][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)aseq[(signed long int)i][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        aseq[(signed long int)i][(signed long int)apos] = gapsym;

    }
  }
}

// AlignmentIdentityBySampling
// file aligneval.c line 443
extern float AlignmentIdentityBySampling(char **aseq, signed int L, signed int N, signed int nsample)
{
  signed int x;
  signed int i;
  signed int j;
  float sum;
  if(!(N >= 2))
    return (float)1.0;

  else
  {
    sum = (float)0.;
    x = 0;
    for( ; !(x >= nsample); x = x + 1)
    {
      double return_value_sre_random$1;
      return_value_sre_random$1=sre_random();
      i = (signed int)(return_value_sre_random$1 * (double)N);
      do
      {
        double return_value_sre_random$2;
        return_value_sre_random$2=sre_random();
        j = (signed int)(return_value_sre_random$2 * (double)N);
      }
      while(j == i);
      float return_value_PairwiseIdentity$3;
      return_value_PairwiseIdentity$3=PairwiseIdentity(aseq[(signed long int)i], aseq[(signed long int)j]);
      sum = sum + return_value_PairwiseIdentity$3;
    }
    return sum / (float)nsample;
  }
}

// AlignmentShuffle
// file shuffle.c line 463
extern signed int AlignmentShuffle(char **ali1, char **ali2, signed int nseq, signed int alen)
{
  signed int i;
  signed int pos;
  char c;
  if(!(ali1 == ali2))
  {
    i = 0;
    for( ; !(i >= nseq); i = i + 1)
      strcpy(ali1[(signed long int)i], ali2[(signed long int)i]);
  }

  i = 0;
  for( ; !(i >= nseq); i = i + 1)
    ali1[(signed long int)i][(signed long int)alen] = (char)0;
  for( ; alen >= 2; alen = alen - 1)
  {
    double return_value_sre_random$1;
    return_value_sre_random$1=sre_random();
    pos = (signed int)(return_value_sre_random$1 * (double)alen);
    i = 0;
    for( ; !(i >= nseq); i = i + 1)
    {
      c = ali1[(signed long int)i][(signed long int)pos];
      ali1[(signed long int)i][(signed long int)pos] = ali1[(signed long int)i][(signed long int)(alen - 1)];
      ali1[(signed long int)i][(signed long int)(alen - 1)] = c;
    }
  }
  return 1;
}

// AllocAlignment
// file alignio.c line 43
extern void AllocAlignment(signed int nseq, signed int alen, char ***ret_aseq, struct aliinfo_s *ainfo)
{
  char **aseq;
  signed int idx;
  InitAinfo(ainfo);
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("alignio.c", 50, sizeof(char *) /*8ul*/  * (unsigned long int)nseq);
  aseq = (char **)return_value_sre_malloc$1;
  idx = 0;
  void *return_value_sre_malloc$2;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    return_value_sre_malloc$2=sre_malloc("alignio.c", 52, sizeof(char) /*1ul*/  * (unsigned long int)(alen + 1));
    aseq[(signed long int)idx] = (char *)return_value_sre_malloc$2;
  }
  ainfo->alen = alen;
  ainfo->nseq = nseq;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("alignio.c", 57, sizeof(float) /*4ul*/  * (unsigned long int)nseq);
  ainfo->wgt = (float *)return_value_sre_malloc$3;
  FSet(ainfo->wgt, nseq, (float)1.0);
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("alignio.c", 60, sizeof(struct seqinfo_s) /*360ul*/  * (unsigned long int)nseq);
  ainfo->sqinfo = (struct seqinfo_s *)return_value_sre_malloc$4;
  idx = 0;
  for( ; !(idx >= nseq); idx = idx + 1)
    (ainfo->sqinfo + (signed long int)idx)->flags = 0;
  *ret_aseq = aseq;
}

// AllocFancyAli
// file tophits.c line 113
extern struct fancyali_s * AllocFancyAli(void)
{
  struct fancyali_s *ali;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("tophits.c", 117, sizeof(struct fancyali_s) /*72ul*/ );
  ali = (struct fancyali_s *)return_value_sre_malloc$1;
  ali->aseq = (char *)(void *)0;
  ali->mline = ali->aseq;
  ali->model = ali->mline;
  ali->csline = ali->model;
  ali->rfline = ali->csline;
  ali->target = (char *)(void *)0;
  ali->query = ali->target;
  ali->sqto = 0;
  ali->sqfrom = ali->sqto;
  return ali;
}

// AllocHistogram
// file funcs.h line 122
extern struct histogram_s * AllocHistogram(signed int min, signed int max, signed int lumpsize)
{
  struct histogram_s *h;
  signed int newsize;
  signed int i;
  newsize = (max - min) + 1;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("histogram.c", 68, sizeof(struct histogram_s) /*64ul*/ );
  h = (struct histogram_s *)return_value_sre_malloc$1;
  h->min = min;
  h->max = max;
  h->total = 0;
  h->lowscore = 0x7fffffff;
  h->highscore = -0x7fffffff - 1;
  h->lumpsize = lumpsize;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("histogram.c", 75, sizeof(signed int) /*4ul*/  * (unsigned long int)newsize);
  h->histogram = (signed int *)return_value_sre_malloc$2;
  i = 0;
  for( ; !(i >= newsize); i = i + 1)
    h->histogram[(signed long int)i] = 0;
  h->expect = (float *)(void *)0;
  h->fit_type = 0;
  return h;
}

// AllocPhylo
// file cluster.c line 329
extern struct phylo_s * AllocPhylo(signed int N)
{
  struct phylo_s *tree;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(N - 1) * sizeof(struct phylo_s) /*40ul*/ );
  tree = (struct phylo_s *)return_value_malloc$1;
  if(tree == ((struct phylo_s *)NULL))
    return (struct phylo_s *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= N + -1); i = i + 1)
    {
      (tree + (signed long int)i)->diff = (float)0.0;
      (tree + (signed long int)i)->rblen = (float)0.0;
      (tree + (signed long int)i)->lblen = (tree + (signed long int)i)->rblen;
      (tree + (signed long int)i)->parent = -1;
      (tree + (signed long int)i)->right = (tree + (signed long int)i)->parent;
      (tree + (signed long int)i)->left = (tree + (signed long int)i)->right;
      (tree + (signed long int)i)->incnum = 0;
      void *return_value_calloc$2;
      return_value_calloc$2=calloc((unsigned long int)N, sizeof(char) /*1ul*/ );
      (tree + (signed long int)i)->is_in = (char *)return_value_calloc$2;
      if((tree + (signed long int)i)->is_in == ((char *)NULL))
        return (struct phylo_s *)(void *)0;

    }
    return tree;
  }
}

// AllocPlan7
// file funcs.h line 212
extern struct plan7_s * AllocPlan7(signed int M)
{
  struct plan7_s *hmm;
  hmm=AllocPlan7Shell();
  AllocPlan7Body(hmm, M);
  return hmm;
}

// AllocPlan7Body
// file funcs.h line 214
extern void AllocPlan7Body(struct plan7_s *hmm, signed int M)
{
  signed int k;
  signed int x;
  hmm->M = M;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("plan7.c", 110, (unsigned long int)(M + 2) * sizeof(char) /*1ul*/ );
  hmm->rf = (char *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("plan7.c", 111, (unsigned long int)(M + 2) * sizeof(char) /*1ul*/ );
  hmm->cs = (char *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("plan7.c", 112, (unsigned long int)(M + 2) * sizeof(char) /*1ul*/ );
  hmm->ca = (char *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("plan7.c", 113, (unsigned long int)(M + 1) * sizeof(signed int) /*4ul*/ );
  hmm->map = (signed int *)return_value_sre_malloc$4;
  void *return_value_sre_malloc$5;
  return_value_sre_malloc$5=sre_malloc("plan7.c", 115, (unsigned long int)M * sizeof(float *) /*8ul*/ );
  hmm->t = (float **)return_value_sre_malloc$5;
  void *return_value_sre_malloc$6;
  return_value_sre_malloc$6=sre_malloc("plan7.c", 116, (unsigned long int)(M + 1) * sizeof(float *) /*8ul*/ );
  hmm->mat = (float **)return_value_sre_malloc$6;
  void *return_value_sre_malloc$7;
  return_value_sre_malloc$7=sre_malloc("plan7.c", 117, (unsigned long int)M * sizeof(float *) /*8ul*/ );
  hmm->ins = (float **)return_value_sre_malloc$7;
  void *return_value_sre_malloc$8;
  return_value_sre_malloc$8=sre_malloc("plan7.c", 118, (unsigned long int)(7 * M) * sizeof(float) /*4ul*/ );
  hmm->t[(signed long int)0] = (float *)return_value_sre_malloc$8;
  void *return_value_sre_malloc$9;
  return_value_sre_malloc$9=sre_malloc("plan7.c", 119, (unsigned long int)(20 * (M + 1)) * sizeof(float) /*4ul*/ );
  hmm->mat[(signed long int)0] = (float *)return_value_sre_malloc$9;
  void *return_value_sre_malloc$10;
  return_value_sre_malloc$10=sre_malloc("plan7.c", 120, (unsigned long int)(20 * M) * sizeof(float) /*4ul*/ );
  hmm->ins[(signed long int)0] = (float *)return_value_sre_malloc$10;
  void *return_value_sre_malloc$11;
  return_value_sre_malloc$11=sre_malloc("plan7.c", 122, (unsigned long int)7 * sizeof(signed int *) /*8ul*/ );
  hmm->tsc = (signed int **)return_value_sre_malloc$11;
  void *return_value_sre_malloc$12;
  return_value_sre_malloc$12=sre_malloc("plan7.c", 123, (unsigned long int)24 * sizeof(signed int *) /*8ul*/ );
  hmm->msc = (signed int **)return_value_sre_malloc$12;
  void *return_value_sre_malloc$13;
  return_value_sre_malloc$13=sre_malloc("plan7.c", 124, (unsigned long int)24 * sizeof(signed int *) /*8ul*/ );
  hmm->isc = (signed int **)return_value_sre_malloc$13;
  void *return_value_sre_malloc$14;
  return_value_sre_malloc$14=sre_malloc("plan7.c", 125, (unsigned long int)(7 * M) * sizeof(signed int) /*4ul*/ );
  hmm->tsc_mem = (signed int *)return_value_sre_malloc$14;
  void *return_value_sre_malloc$15;
  return_value_sre_malloc$15=sre_malloc("plan7.c", 126, (unsigned long int)(24 * (M + 1)) * sizeof(signed int) /*4ul*/ );
  hmm->msc_mem = (signed int *)return_value_sre_malloc$15;
  void *return_value_sre_malloc$16;
  return_value_sre_malloc$16=sre_malloc("plan7.c", 127, (unsigned long int)(24 * M) * sizeof(signed int) /*4ul*/ );
  hmm->isc_mem = (signed int *)return_value_sre_malloc$16;
  hmm->tsc[(signed long int)0] = hmm->tsc_mem;
  hmm->msc[(signed long int)0] = hmm->msc_mem;
  hmm->isc[(signed long int)0] = hmm->isc_mem;
  k = 1;
  for( ; M >= k; k = k + 1)
  {
    hmm->mat[(signed long int)k] = hmm->mat[(signed long int)0] + (signed long int)(k * 20);
    if(!(k >= M))
    {
      hmm->ins[(signed long int)k] = hmm->ins[(signed long int)0] + (signed long int)(k * 20);
      hmm->t[(signed long int)k] = hmm->t[(signed long int)0] + (signed long int)(k * 7);
    }

  }
  x = 1;
  for( ; !(x >= 24); x = x + 1)
  {
    hmm->msc[(signed long int)x] = hmm->msc[(signed long int)0] + (signed long int)(x * (M + 1));
    hmm->isc[(signed long int)x] = hmm->isc[(signed long int)0] + (signed long int)(x * M);
  }
  x = 0;
  for( ; !(x >= 7); x = x + 1)
    hmm->tsc[(signed long int)x] = hmm->tsc[(signed long int)0] + (signed long int)(x * M);
  x = 0;
  for( ; !(x >= 7); x = x + 1)
    hmm->tsc[(signed long int)x][(signed long int)0] = -987654321;
  void *return_value_sre_malloc$17;
  return_value_sre_malloc$17=sre_malloc("plan7.c", 156, (unsigned long int)(M + 1) * sizeof(float) /*4ul*/ );
  hmm->begin = (float *)return_value_sre_malloc$17;
  void *return_value_sre_malloc$18;
  return_value_sre_malloc$18=sre_malloc("plan7.c", 157, (unsigned long int)(M + 1) * sizeof(float) /*4ul*/ );
  hmm->end = (float *)return_value_sre_malloc$18;
  void *return_value_sre_malloc$19;
  return_value_sre_malloc$19=sre_malloc("plan7.c", 159, (unsigned long int)(M + 1) * sizeof(signed int) /*4ul*/ );
  hmm->bsc_mem = (signed int *)return_value_sre_malloc$19;
  void *return_value_sre_malloc$20;
  return_value_sre_malloc$20=sre_malloc("plan7.c", 160, (unsigned long int)(M + 1) * sizeof(signed int) /*4ul*/ );
  hmm->esc_mem = (signed int *)return_value_sre_malloc$20;
  hmm->bsc = hmm->bsc_mem;
  hmm->esc = hmm->esc_mem;
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// AllocPlan7Matrix
// file core_algorithms.c line 203
struct dpmatrix_s * AllocPlan7Matrix(signed int rows, signed int M, signed int ***xmx, signed int ***mmx, signed int ***imx, signed int ***dmx)
{
  struct dpmatrix_s *mx;
  mx=CreatePlan7Matrix(rows - 1, M, 0, 0);
  if(!(xmx == ((signed int ***)NULL)))
    *xmx = mx->xmx;

  if(!(mmx == ((signed int ***)NULL)))
    *mmx = mx->mmx;

  if(!(imx == ((signed int ***)NULL)))
    *imx = mx->imx;

  if(!(dmx == ((signed int ***)NULL)))
    *dmx = mx->dmx;

  return mx;
}

// AllocPlan7Shell
// file funcs.h line 213
extern struct plan7_s * AllocPlan7Shell(void)
{
  struct plan7_s *hmm;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("plan7.c", 54, sizeof(struct plan7_s) /*464ul*/ );
  hmm = (struct plan7_s *)return_value_sre_malloc$1;
  hmm->M = 0;
  hmm->name = (char *)(void *)0;
  hmm->acc = (char *)(void *)0;
  hmm->desc = (char *)(void *)0;
  hmm->rf = (char *)(void *)0;
  hmm->cs = (char *)(void *)0;
  hmm->ca = (char *)(void *)0;
  hmm->comlog = (char *)(void *)0;
  hmm->nseq = 0;
  hmm->ctime = (char *)(void *)0;
  hmm->map = (signed int *)(void *)0;
  hmm->checksum = 0;
  hmm->tpri = (signed int *)(void *)0;
  hmm->mpri = (signed int *)(void *)0;
  hmm->ipri = (signed int *)(void *)0;
  hmm->ga2 = (float)0.0;
  hmm->ga1 = hmm->ga2;
  hmm->tc2 = (float)0.0;
  hmm->tc1 = hmm->tc2;
  hmm->nc2 = (float)0.0;
  hmm->nc1 = hmm->nc2;
  hmm->t = (float **)(void *)0;
  hmm->mat = (float **)(void *)0;
  hmm->ins = (float **)(void *)0;
  hmm->isc = (signed int **)(void *)0;
  hmm->msc = hmm->isc;
  hmm->tsc = hmm->msc;
  hmm->msc_mem = (signed int *)(void *)0;
  hmm->msc_mem = hmm->msc_mem;
  hmm->tsc_mem = hmm->msc_mem;
  hmm->begin = (float *)(void *)0;
  hmm->end = (float *)(void *)0;
  hmm->bsc_mem = (signed int *)(void *)0;
  hmm->bsc = hmm->bsc_mem;
  hmm->esc_mem = (signed int *)(void *)0;
  hmm->esc = hmm->esc_mem;
  hmm->dnam = (signed int **)(void *)0;
  hmm->dnai = (signed int **)(void *)0;
  hmm->dna2 = -987654321;
  hmm->dna4 = -987654321;
  hmm->mu = (float)0.;
  hmm->lambda = (float)0.;
  hmm->flags = 0;
  return hmm;
}

// AllocShadowMatrix
// file core_algorithms.c line 250
extern struct dpshadow_s * AllocShadowMatrix(signed int rows, signed int M, char ***xtb, char ***mtb, char ***itb, char ***dtb)
{
  struct dpshadow_s *tb;
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("core_algorithms.c", 255, sizeof(struct dpshadow_s) /*40ul*/ );
  tb = (struct dpshadow_s *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("core_algorithms.c", 256, sizeof(char *) /*8ul*/  * (unsigned long int)rows);
  tb->xtb = (char **)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("core_algorithms.c", 257, sizeof(char *) /*8ul*/  * (unsigned long int)rows);
  tb->mtb = (char **)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("core_algorithms.c", 258, sizeof(char *) /*8ul*/  * (unsigned long int)rows);
  tb->itb = (char **)return_value_sre_malloc$4;
  void *return_value_sre_malloc$5;
  return_value_sre_malloc$5=sre_malloc("core_algorithms.c", 259, sizeof(char *) /*8ul*/  * (unsigned long int)rows);
  tb->dtb = (char **)return_value_sre_malloc$5;
  void *return_value_sre_malloc$6;
  return_value_sre_malloc$6=sre_malloc("core_algorithms.c", 260, sizeof(signed int) /*4ul*/  * (unsigned long int)rows);
  tb->esrc = (signed int *)return_value_sre_malloc$6;
  void *return_value_sre_malloc$7;
  return_value_sre_malloc$7=sre_malloc("core_algorithms.c", 261, sizeof(char) /*1ul*/  * (unsigned long int)(rows * 5));
  tb->xtb[(signed long int)0] = (char *)return_value_sre_malloc$7;
  void *return_value_sre_malloc$8;
  return_value_sre_malloc$8=sre_malloc("core_algorithms.c", 262, sizeof(char) /*1ul*/  * (unsigned long int)(rows * (M + 2)));
  tb->mtb[(signed long int)0] = (char *)return_value_sre_malloc$8;
  void *return_value_sre_malloc$9;
  return_value_sre_malloc$9=sre_malloc("core_algorithms.c", 263, sizeof(char) /*1ul*/  * (unsigned long int)(rows * (M + 2)));
  tb->itb[(signed long int)0] = (char *)return_value_sre_malloc$9;
  void *return_value_sre_malloc$10;
  return_value_sre_malloc$10=sre_malloc("core_algorithms.c", 264, sizeof(char) /*1ul*/  * (unsigned long int)(rows * (M + 2)));
  tb->dtb[(signed long int)0] = (char *)return_value_sre_malloc$10;
  i = 1;
  for( ; !(i >= rows); i = i + 1)
  {
    tb->xtb[(signed long int)i] = tb->xtb[(signed long int)0] + (signed long int)(i * 5);
    tb->mtb[(signed long int)i] = tb->mtb[(signed long int)0] + (signed long int)(i * (M + 2));
    tb->itb[(signed long int)i] = tb->itb[(signed long int)0] + (signed long int)(i * (M + 2));
    tb->dtb[(signed long int)i] = tb->dtb[(signed long int)0] + (signed long int)(i * (M + 2));
  }
  if(!(xtb == ((char ***)NULL)))
    *xtb = tb->xtb;

  if(!(mtb == ((char ***)NULL)))
    *mtb = tb->mtb;

  if(!(itb == ((char ***)NULL)))
    *itb = tb->itb;

  if(!(dtb == ((char ***)NULL)))
    *dtb = tb->dtb;

  return tb;
}

// AllocTophits
// file tophits.c line 78
extern struct tophit_s * AllocTophits(signed int lumpsize)
{
  struct tophit_s *hitlist;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("tophits.c", 82, sizeof(struct tophit_s) /*32ul*/ );
  hitlist = (struct tophit_s *)return_value_sre_malloc$1;
  hitlist->hit = (struct hit_s **)(void *)0;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("tophits.c", 84, (unsigned long int)lumpsize * sizeof(struct hit_s) /*104ul*/ );
  hitlist->unsrt = (struct hit_s *)return_value_sre_malloc$2;
  hitlist->alloc = lumpsize;
  hitlist->num = 0;
  hitlist->lump = lumpsize;
  return hitlist;
}

// AlphabetType2String
// file debug.c line 67
extern char * AlphabetType2String(signed int type)
{
  switch(type)
  {
    case 3:
      return "protein";
    case 2:
      return "nucleic acid";
    case 0:
      return "unknown";
    default:
      return "BOGUS";
  }
}

// BlosumWeights
// file weight.c line 394
extern void BlosumWeights(char **aseqs, signed int nseq, signed int alen, float maxid, float *wgt)
{
  signed int *c;
  signed int nc;
  signed int *nmem;
  signed int i;
  SingleLinkCluster(aseqs, nseq, alen, maxid, &c, &nc);
  FSet(wgt, nseq, (float)1.0);
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("weight.c", 403, sizeof(signed int) /*4ul*/  * (unsigned long int)nc);
  nmem = (signed int *)return_value_sre_malloc$1;
  i = 0;
  for( ; !(i >= nc); i = i + 1)
    nmem[(signed long int)i] = 0;
  i = 0;
  for( ; !(i >= nseq); i = i + 1)
    nmem[(signed long int)c[(signed long int)i]] = nmem[(signed long int)c[(signed long int)i]] + 1;
  i = 0;
  for( ; !(i >= nseq); i = i + 1)
    wgt[(signed long int)i] = (float)(1. / (double)(float)nmem[(signed long int)c[(signed long int)i]]);
  free((void *)nmem);
  free((void *)c);
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// Byteswap
// file types.c line 133
extern void Byteswap(char *swap, signed int nbytes)
{
  signed int x;
  char byte;
  x = 0;
  for( ; !(x >= nbytes / 2); x = x + 1)
  {
    byte = swap[(signed long int)((nbytes - x) - 1)];
    swap[(signed long int)((nbytes - x) - 1)] = swap[(signed long int)x];
    swap[(signed long int)x] = byte;
  }
}

// Cluster
// file cluster.c line 148
extern signed int Cluster(float **dmx, signed int N, enum clust_strategy mode, struct phylo_s **ret_tree)
{
  struct phylo_s *tree;
  float **mx;
  signed int *coord;
  signed int i;
  signed int j;
  signed int idx;
  signed int Np;
  signed int row;
  signed int col;
  float min;
  float *trow;
  float tcol;
  float *diff;
  signed int swapfoo;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("cluster.c", 168, sizeof(float *) /*8ul*/  * (unsigned long int)N);
  mx = (float **)return_value_sre_malloc$1;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("cluster.c", 171, sizeof(float) /*4ul*/  * (unsigned long int)N);
    mx[(signed long int)i] = (float *)return_value_sre_malloc$2;
    j = 0;
    for( ; !(j >= N); j = j + 1)
      mx[(signed long int)i][(signed long int)j] = dmx[(signed long int)i][(signed long int)j];
  }
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("cluster.c", 176, (unsigned long int)N * sizeof(signed int) /*4ul*/ );
  coord = (signed int *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("cluster.c", 177, (unsigned long int)(N - 1) * sizeof(float) /*4ul*/ );
  diff = (float *)return_value_sre_malloc$4;
  col = 0;
  for( ; !(col >= N); col = col + 1)
    coord[(signed long int)col] = col;
  i = 0;
  for( ; !(i >= N + -1); i = i + 1)
    diff[(signed long int)i] = (float)0.0;
  tree=AllocPhylo(N);
  if(tree == ((struct phylo_s *)NULL))
    Die("AllocPhylo() failed");

  j = 0;
  Np = N;
  float tmp_if_expr$5;
  float tmp_if_expr$6;
  for( ; Np >= 2; Np = Np - 1)
  {
    min = (float)999999.;
    row = 0;
    for( ; !(row >= Np); row = row + 1)
    {
      col = row + 1;
      for( ; !(col >= Np); col = col + 1)
        if(mx[(signed long int)row][(signed long int)col] < min)
        {
          min = mx[(signed long int)row][(signed long int)col];
          i = row;
          j = col;
        }

    }
    (tree + (signed long int)(Np - 2))->left = coord[(signed long int)i];
    (tree + (signed long int)(Np - 2))->right = coord[(signed long int)j];
    if(coord[(signed long int)i] >= N)
      (tree + (signed long int)(coord[(signed long int)i] - N))->parent = (N + Np) - 2;

    if(coord[(signed long int)j] >= N)
      (tree + (signed long int)(coord[(signed long int)j] - N))->parent = (N + Np) - 2;

    (tree + (signed long int)(Np - 2))->diff = min;
    diff[(signed long int)(Np - 2)] = (tree + (signed long int)(Np - 2))->diff;
    (tree + (signed long int)(Np - 2))->rblen = min;
    (tree + (signed long int)(Np - 2))->lblen = (tree + (signed long int)(Np - 2))->rblen;
    if(coord[(signed long int)i] >= N)
      (tree + (signed long int)(Np - 2))->lblen = (tree + (signed long int)(Np - 2))->lblen - diff[(signed long int)(coord[(signed long int)i] - N)];

    if(coord[(signed long int)j] >= N)
      (tree + (signed long int)(Np - 2))->rblen = (tree + (signed long int)(Np - 2))->rblen - diff[(signed long int)(coord[(signed long int)j] - N)];

    if(!(coord[(signed long int)i] >= N))
    {
      (tree + (signed long int)(Np - 2))->incnum = (tree + (signed long int)(Np - 2))->incnum + 1;
      (tree + (signed long int)(Np - 2))->is_in[(signed long int)coord[(signed long int)i]] = (char)1;
    }

    else
    {
      (tree + (signed long int)(Np - 2))->incnum = (tree + (signed long int)(Np - 2))->incnum + (tree + (signed long int)(coord[(signed long int)i] - N))->incnum;
      idx = 0;
      for( ; !(idx >= N); idx = idx + 1)
        (tree + (signed long int)(Np - 2))->is_in[(signed long int)idx] = (tree + (signed long int)(Np - 2))->is_in[(signed long int)idx] | (tree + (signed long int)(coord[(signed long int)i] - N))->is_in[(signed long int)idx];
    }
    if(!(coord[(signed long int)j] >= N))
    {
      (tree + (signed long int)(Np - 2))->incnum = (tree + (signed long int)(Np - 2))->incnum + 1;
      (tree + (signed long int)(Np - 2))->is_in[(signed long int)coord[(signed long int)j]] = (char)1;
    }

    else
    {
      (tree + (signed long int)(Np - 2))->incnum = (tree + (signed long int)(Np - 2))->incnum + (tree + (signed long int)(coord[(signed long int)j] - N))->incnum;
      idx = 0;
      for( ; !(idx >= N); idx = idx + 1)
        (tree + (signed long int)(Np - 2))->is_in[(signed long int)idx] = (tree + (signed long int)(Np - 2))->is_in[(signed long int)idx] | (tree + (signed long int)(coord[(signed long int)j] - N))->is_in[(signed long int)idx];
    }
    if(i == Np + -1 || j == Np + -2)
    {
      swapfoo = j;
      j = i;
      i = swapfoo;
    }

    if(!(i == Np + -2))
    {
      trow = mx[(signed long int)(Np - 2)];
      mx[(signed long int)(Np - 2)] = mx[(signed long int)i];
      mx[(signed long int)i] = trow;
      row = 0;
      for( ; !(row >= Np); row = row + 1)
      {
        tcol = mx[(signed long int)row][(signed long int)(Np - 2)];
        mx[(signed long int)row][(signed long int)(Np - 2)] = mx[(signed long int)row][(signed long int)i];
        mx[(signed long int)row][(signed long int)i] = tcol;
      }
      swapfoo = coord[(signed long int)(Np - 2)];
      coord[(signed long int)(Np - 2)] = coord[(signed long int)i];
      coord[(signed long int)i] = swapfoo;
    }

    if(!(j == Np + -1))
    {
      trow = mx[(signed long int)(Np - 1)];
      mx[(signed long int)(Np - 1)] = mx[(signed long int)j];
      mx[(signed long int)j] = trow;
      row = 0;
      for( ; !(row >= Np); row = row + 1)
      {
        tcol = mx[(signed long int)row][(signed long int)(Np - 1)];
        mx[(signed long int)row][(signed long int)(Np - 1)] = mx[(signed long int)row][(signed long int)j];
        mx[(signed long int)row][(signed long int)j] = tcol;
      }
      swapfoo = coord[(signed long int)(Np - 1)];
      coord[(signed long int)(Np - 1)] = coord[(signed long int)j];
      coord[(signed long int)j] = swapfoo;
    }

    i = Np - 2;
    j = Np - 1;
    col = 0;
    for( ; !(col >= Np); col = col + 1)
      switch((signed int)mode)
      {
        case CLUSTER_MEAN:
        {
          mx[(signed long int)i][(signed long int)col] = (float)((double)(mx[(signed long int)i][(signed long int)col] + mx[(signed long int)j][(signed long int)col]) / 2.0);
          break;
        }
        case CLUSTER_MIN:
        {
          if(mx[(signed long int)i][(signed long int)col] < mx[(signed long int)j][(signed long int)col])
            tmp_if_expr$5 = mx[(signed long int)i][(signed long int)col];

          else
            tmp_if_expr$5 = mx[(signed long int)j][(signed long int)col];
          mx[(signed long int)i][(signed long int)col] = tmp_if_expr$5;
          break;
        }
        case CLUSTER_MAX:
        {
          if(mx[(signed long int)i][(signed long int)col] > mx[(signed long int)j][(signed long int)col])
            tmp_if_expr$6 = mx[(signed long int)i][(signed long int)col];

          else
            tmp_if_expr$6 = mx[(signed long int)j][(signed long int)col];
          mx[(signed long int)i][(signed long int)col] = tmp_if_expr$6;
          break;
        }
        default:
          mx[(signed long int)i][(signed long int)col] = (float)((double)(mx[(signed long int)i][(signed long int)col] + mx[(signed long int)j][(signed long int)col]) / 2.0);
      }
    col = 0;
    for( ; !(col >= Np); col = col + 1)
      mx[(signed long int)col][(signed long int)i] = mx[(signed long int)i][(signed long int)col];
    coord[(signed long int)(Np - 2)] = (Np + N) - 2;
  }
  Free2DArray((void **)mx, N);
  free((void *)coord);
  free((void *)diff);
  *ret_tree = tree;
  return 1;
}

// CompareMultAlignments
// file aligneval.c line 334
extern float CompareMultAlignments(char **kseqs, char **tseqs, signed int N)
{
  signed int i;
  signed int j;
  float score;
  float tot_score = (float)0.0;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    j = i + 1;
    for( ; !(j >= N); j = j + 1)
    {
      score=ComparePairAlignments(kseqs[(signed long int)i], kseqs[(signed long int)j], tseqs[(signed long int)i], tseqs[(signed long int)j]);
      if(score < 0.000000f)
        return (float)-1.0;

      tot_score = tot_score + score;
    }
  }
  return (float)(((double)tot_score * 2.0) / ((double)(float)N * ((double)(float)N - 1.0)));
}

// ComparePairAlignments
// file aligneval.c line 95
extern float ComparePairAlignments(char *known1, char *known2, char *calc1, char *calc2)
{
  signed int *klist1;
  signed int *klist2;
  signed int *tlist1;
  signed int *tlist2;
  signed int len1;
  signed int len2;
  float score;
  signed int return_value_make_alilist$1;
  return_value_make_alilist$1=make_alilist(calc1, calc2, &tlist1, &len1);
  if(return_value_make_alilist$1 == 0)
    return (float)-1.0;

  else
  {
    signed int return_value_make_alilist$2;
    return_value_make_alilist$2=make_alilist(calc2, calc1, &tlist2, &len2);
    if(return_value_make_alilist$2 == 0)
      return (float)-1.0;

    else
    {
      signed int return_value_make_alilist$3;
      return_value_make_alilist$3=make_alilist(known1, known2, &klist1, &len1);
      if(return_value_make_alilist$3 == 0)
        return (float)-1.0;

      else
      {
        signed int return_value_make_alilist$4;
        return_value_make_alilist$4=make_alilist(known2, known1, &klist2, &len2);
        if(return_value_make_alilist$4 == 0)
          return (float)-1.0;

        else
        {
          signed int return_value_compare_lists$5;
          return_value_compare_lists$5=compare_lists(klist1, klist2, tlist1, tlist2, len1, len2, &score);
          if(return_value_compare_lists$5 == 0)
            return (float)-1.0;

          else
          {
            free((void *)klist1);
            free((void *)klist2);
            free((void *)tlist1);
            free((void *)tlist2);
            return score;
          }
        }
      }
    }
  }
}

// CompareRefMultAlignments
// file aligneval.c line 366
extern float CompareRefMultAlignments(signed int *ref, char **kseqs, char **tseqs, signed int N)
{
  signed int i;
  signed int j;
  float score;
  float tot_score = (float)0.0;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    j = i + 1;
    for( ; !(j >= N); j = j + 1)
    {
      score=CompareRefPairAlignments(ref, kseqs[(signed long int)i], kseqs[(signed long int)j], tseqs[(signed long int)i], tseqs[(signed long int)j]);
      if(score < 0.000000f)
        return (float)-1.0;

      tot_score = tot_score + score;
    }
  }
  return (float)(((double)tot_score * 2.0) / ((double)(float)N * ((double)(float)N - 1.0)));
}

// CompareRefPairAlignments
// file aligneval.c line 133
extern float CompareRefPairAlignments(signed int *ref, char *known1, char *known2, char *calc1, char *calc2)
{
  signed int *klist1;
  signed int *klist2;
  signed int *tlist1;
  signed int *tlist2;
  signed int len1;
  signed int len2;
  float score;
  signed int return_value_make_ref_alilist$1;
  return_value_make_ref_alilist$1=make_ref_alilist(ref, known1, known2, calc1, calc2, &tlist1, &len1);
  if(return_value_make_ref_alilist$1 == 0)
    return (float)-1.0;

  else
  {
    signed int return_value_make_ref_alilist$2;
    return_value_make_ref_alilist$2=make_ref_alilist(ref, known2, known1, calc2, calc1, &tlist2, &len2);
    if(return_value_make_ref_alilist$2 == 0)
      return (float)-1.0;

    else
    {
      signed int return_value_make_ref_alilist$3;
      return_value_make_ref_alilist$3=make_ref_alilist(ref, known1, known2, known1, known2, &klist1, &len1);
      if(return_value_make_ref_alilist$3 == 0)
        return (float)-1.0;

      else
      {
        signed int return_value_make_ref_alilist$4;
        return_value_make_ref_alilist$4=make_ref_alilist(ref, known2, known1, known2, known1, &klist2, &len2);
        if(return_value_make_ref_alilist$4 == 0)
          return (float)-1.0;

        else
        {
          signed int return_value_compare_lists$5;
          return_value_compare_lists$5=compare_lists(klist1, klist2, tlist1, tlist2, len1, len2, &score);
          if(return_value_compare_lists$5 == 0)
            return (float)-1.0;

          else
          {
            free((void *)klist1);
            free((void *)klist2);
            free((void *)tlist1);
            free((void *)tlist2);
            return score;
          }
        }
      }
    }
  }
}

// CreateFancyAli
// file funcs.h line 349
extern struct fancyali_s * CreateFancyAli(struct p7trace_s *tr, struct plan7_s *hmm, unsigned char *dsq, char *name)
{
  struct fancyali_s *ali;
  signed int tpos;
  signed int bestsym;
  float mthresh;
  ali=AllocFancyAli();
  ali->rfline = (char *)(void *)0;
  ali->csline = (char *)(void *)0;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("trace.c", 680, sizeof(char) /*1ul*/  * (unsigned long int)(tr->tlen + 1));
  ali->model = (char *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("trace.c", 681, sizeof(char) /*1ul*/  * (unsigned long int)(tr->tlen + 1));
  ali->mline = (char *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("trace.c", 682, sizeof(char) /*1ul*/  * (unsigned long int)(tr->tlen + 1));
  ali->aseq = (char *)return_value_sre_malloc$3;
  memset((void *)ali->model, 32, (unsigned long int)tr->tlen);
  memset((void *)ali->mline, 32, (unsigned long int)tr->tlen);
  memset((void *)ali->aseq, 32, (unsigned long int)tr->tlen);
  if(!((4 & hmm->flags) == 0))
  {
    void *return_value_sre_malloc$4;
    return_value_sre_malloc$4=sre_malloc("trace.c", 690, sizeof(char) /*1ul*/  * (unsigned long int)(tr->tlen + 1));
    ali->rfline = (char *)return_value_sre_malloc$4;
    memset((void *)ali->rfline, 32, (unsigned long int)tr->tlen);
  }

  if(!((8 & hmm->flags) == 0))
  {
    void *return_value_sre_malloc$5;
    return_value_sre_malloc$5=sre_malloc("trace.c", 695, sizeof(char) /*1ul*/  * (unsigned long int)(tr->tlen + 1));
    ali->csline = (char *)return_value_sre_malloc$5;
    memset((void *)ali->csline, 32, (unsigned long int)tr->tlen);
  }

  ali->query=Strdup(hmm->name);
  ali->target=Strdup(name);
  if(Alphabet_type == 3)
    mthresh = (float)0.5;

  else
    mthresh = (float)0.9;
  tpos = 0;
  for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
    if(tr->pos[(signed long int)tpos] >= 1)
    {
      ali->sqfrom = tr->pos[(signed long int)tpos];
      break;
    }

  tpos = tr->tlen - 1;
  for( ; tpos >= 0; tpos = tpos - 1)
    if(tr->pos[(signed long int)tpos] >= 1)
    {
      ali->sqto = tr->pos[(signed long int)tpos];
      break;
    }

  tpos = 0;
  signed int return_value_tolower$7;
  signed int return_value_tolower$8;
  signed int return_value_tolower$9;
  signed int return_value_tolower$10;
  for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
    switch((signed int)tr->statetype[(signed long int)tpos])
    {
      case 4:

      case 9:
      {
        ali->model[(signed long int)tpos] = (char)42;
        break;
      }
      case 5:

      case 10:

      case 8:
      {
        ali->model[(signed long int)tpos] = (char)45;
        if(tr->pos[(signed long int)tpos] >= 1)
        {
          signed int return_value_tolower$6;
          return_value_tolower$6=tolower((signed int)Alphabet[(signed long int)dsq[(signed long int)tr->pos[(signed long int)tpos]]]);
          ali->aseq[(signed long int)tpos] = (char)return_value_tolower$6;
        }

        break;
      }
      case 6:
      {
        ali->model[(signed long int)tpos] = (char)62;
        break;
      }
      case 7:
      {
        ali->model[(signed long int)tpos] = (char)60;
        break;
      }
      case 1:
      {
        if(!((4 & hmm->flags) == 0))
          ali->rfline[(signed long int)tpos] = hmm->rf[(signed long int)tr->nodeidx[(signed long int)tpos]];

        if(!((8 & hmm->flags) == 0))
          ali->csline[(signed long int)tpos] = hmm->cs[(signed long int)tr->nodeidx[(signed long int)tpos]];

        bestsym=FArgMax(hmm->mat[(signed long int)tr->nodeidx[(signed long int)tpos]], Alphabet_size);
        ali->model[(signed long int)tpos] = Alphabet[(signed long int)bestsym];
        if(hmm->mat[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)bestsym] < mthresh)
        {
          return_value_tolower$7=tolower((signed int)ali->model[(signed long int)tpos]);
          ali->model[(signed long int)tpos] = (char)return_value_tolower$7;
        }

        if((signed int)dsq[(signed long int)tr->pos[(signed long int)tpos]] == bestsym)
        {
          ali->mline[(signed long int)tpos] = Alphabet[(signed long int)dsq[(signed long int)tr->pos[(signed long int)tpos]]];
          if(hmm->mat[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)bestsym] < mthresh)
          {
            return_value_tolower$8=tolower((signed int)ali->mline[(signed long int)tpos]);
            ali->mline[(signed long int)tpos] = (char)return_value_tolower$8;
          }

        }

        else
          if(hmm->msc[(signed long int)dsq[(signed long int)tr->pos[(signed long int)tpos]]][(signed long int)tr->nodeidx[(signed long int)tpos]] >= 1)
            ali->mline[(signed long int)tpos] = (char)43;

        ali->aseq[(signed long int)tpos] = Alphabet[(signed long int)dsq[(signed long int)tr->pos[(signed long int)tpos]]];
        break;
      }
      case 2:
      {
        if(!((4 & hmm->flags) == 0))
          ali->rfline[(signed long int)tpos] = hmm->rf[(signed long int)tr->nodeidx[(signed long int)tpos]];

        if(!((8 & hmm->flags) == 0))
          ali->csline[(signed long int)tpos] = hmm->cs[(signed long int)tr->nodeidx[(signed long int)tpos]];

        bestsym=FArgMax(hmm->mat[(signed long int)tr->nodeidx[(signed long int)tpos]], Alphabet_size);
        ali->model[(signed long int)tpos] = Alphabet[(signed long int)bestsym];
        if(hmm->mat[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)bestsym] < mthresh)
        {
          return_value_tolower$9=tolower((signed int)ali->model[(signed long int)tpos]);
          ali->model[(signed long int)tpos] = (char)return_value_tolower$9;
        }

        ali->aseq[(signed long int)tpos] = (char)45;
        break;
      }
      case 3:
      {
        ali->model[(signed long int)tpos] = (char)46;
        if(hmm->isc[(signed long int)dsq[(signed long int)tr->pos[(signed long int)tpos]]][(signed long int)tr->nodeidx[(signed long int)tpos]] >= 1)
          ali->mline[(signed long int)tpos] = (char)43;

        return_value_tolower$10=tolower((signed int)Alphabet[(signed long int)dsq[(signed long int)tr->pos[(signed long int)tpos]]]);
        ali->aseq[(signed long int)tpos] = (char)return_value_tolower$10;
        break;
      }
      default:
        Die("bogus statetype");
    }
  ali->len = tpos;
  if(!((4 & hmm->flags) == 0))
    ali->rfline[(signed long int)tpos] = (char)0;

  if(!((8 & hmm->flags) == 0))
    ali->csline[(signed long int)tpos] = (char)0;

  ali->model[(signed long int)tpos] = (char)0;
  ali->mline[(signed long int)tpos] = (char)0;
  ali->aseq[(signed long int)tpos] = (char)0;
  return ali;
}

// CreatePlan7Matrix
// file funcs.h line 41
extern struct dpmatrix_s * CreatePlan7Matrix(signed int N, signed int M, signed int padN, signed int padM)
{
  struct dpmatrix_s *mx;
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("core_algorithms.c", 65, sizeof(struct dpmatrix_s) /*80ul*/ );
  mx = (struct dpmatrix_s *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("core_algorithms.c", 66, sizeof(signed int *) /*8ul*/  * (unsigned long int)(N + 1));
  mx->xmx = (signed int **)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("core_algorithms.c", 67, sizeof(signed int *) /*8ul*/  * (unsigned long int)(N + 1));
  mx->mmx = (signed int **)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("core_algorithms.c", 68, sizeof(signed int *) /*8ul*/  * (unsigned long int)(N + 1));
  mx->imx = (signed int **)return_value_sre_malloc$4;
  void *return_value_sre_malloc$5;
  return_value_sre_malloc$5=sre_malloc("core_algorithms.c", 69, sizeof(signed int *) /*8ul*/  * (unsigned long int)(N + 1));
  mx->dmx = (signed int **)return_value_sre_malloc$5;
  void *return_value_sre_malloc$6;
  return_value_sre_malloc$6=sre_malloc("core_algorithms.c", 70, sizeof(signed int) /*4ul*/  * (unsigned long int)((N + 1) * 5));
  mx->xmx_mem = (void *)return_value_sre_malloc$6;
  void *return_value_sre_malloc$7;
  return_value_sre_malloc$7=sre_malloc("core_algorithms.c", 71, sizeof(signed int) /*4ul*/  * (unsigned long int)((N + 1) * (M + 2)));
  mx->mmx_mem = (void *)return_value_sre_malloc$7;
  void *return_value_sre_malloc$8;
  return_value_sre_malloc$8=sre_malloc("core_algorithms.c", 72, sizeof(signed int) /*4ul*/  * (unsigned long int)((N + 1) * (M + 2)));
  mx->imx_mem = (void *)return_value_sre_malloc$8;
  void *return_value_sre_malloc$9;
  return_value_sre_malloc$9=sre_malloc("core_algorithms.c", 73, sizeof(signed int) /*4ul*/  * (unsigned long int)((N + 1) * (M + 2)));
  mx->dmx_mem = (void *)return_value_sre_malloc$9;
  mx->xmx[(signed long int)0] = (signed int *)mx->xmx_mem;
  mx->mmx[(signed long int)0] = (signed int *)mx->mmx_mem;
  mx->imx[(signed long int)0] = (signed int *)mx->imx_mem;
  mx->dmx[(signed long int)0] = (signed int *)mx->dmx_mem;
  i = 1;
  for( ; N >= i; i = i + 1)
  {
    mx->xmx[(signed long int)i] = mx->xmx[(signed long int)0] + (signed long int)(i * 5);
    mx->mmx[(signed long int)i] = mx->mmx[(signed long int)0] + (signed long int)(i * (M + 2));
    mx->imx[(signed long int)i] = mx->imx[(signed long int)0] + (signed long int)(i * (M + 2));
    mx->dmx[(signed long int)i] = mx->dmx[(signed long int)0] + (signed long int)(i * (M + 2));
  }
  mx->maxN = N;
  mx->maxM = M;
  mx->padN = padN;
  mx->padM = padM;
  return mx;
}

// DAdd
// file vectorops.c line 78
extern void DAdd(double *vec1, double *vec2, signed int n)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec1[(signed long int)x] = vec1[(signed long int)x] + vec2[(signed long int)x];
}

// DArgMax
// file vectorops.c line 172
extern signed int DArgMax(double *vec, signed int n)
{
  signed int i;
  signed int best = 0;
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] > vec[(signed long int)best])
      best = i;

  return best;
}

// DArgMin
// file vectorops.c line 194
extern signed int DArgMin(double *vec, signed int n)
{
  signed int i;
  signed int best = 0;
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] < vec[(signed long int)best])
      best = i;

  return best;
}

// DChoose
// file sre_random.c line 283
extern signed int DChoose(double *p, signed int N)
{
  double roll;
  double sum;
  signed int i;
  roll=sre_random();
  sum = 0.0;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    sum = sum + p[(signed long int)i];
    if(roll < sum)
      return i;

  }
  double return_value_sre_random$1;
  return_value_sre_random$1=sre_random();
  return (signed int)(return_value_sre_random$1 * (double)N);
}

// DCopy
// file vectorops.c line 92
extern void DCopy(double *vec1, double *vec2, signed int n)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec1[(signed long int)x] = vec2[(signed long int)x];
}

// DDot
// file vectorops.c line 106
extern double DDot(double *vec1, double *vec2, signed int n)
{
  double result = 0.;
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    result = result + vec1[(signed long int)x] * vec2[(signed long int)x];
  return result;
}

// DExp
// file vectorops.c line 255
extern void DExp(double *vec, signed int n)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec[(signed long int)x]=exp(vec[(signed long int)x]);
}

// DLog
// file vectorops.c line 237
extern void DLog(double *vec, signed int n)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    if(vec[(signed long int)x] > 0.)
      vec[(signed long int)x]=log(vec[(signed long int)x]);

    else
      vec[(signed long int)x] = -((double)1.79769313486231570815e+308L);
}

// DLogSum
// file vectorops.c line 269
extern double DLogSum(double *vec, signed int n)
{
  signed int x;
  double max;
  double sum;
  max=DMax(vec, n);
  sum = 0.0;
  x = 0;
  double return_value_exp$1;
  for( ; !(x >= n); x = x + 1)
    if(vec[(signed long int)x] > max + -50.000000)
    {
      return_value_exp$1=exp(vec[(signed long int)x] - max);
      sum = sum + return_value_exp$1;
    }

  double return_value_log$2;
  return_value_log$2=log(sum);
  sum = return_value_log$2 + max;
  return sum;
}

// DMX2Alloc
// file sre_math.c line 185
extern double ** DMX2Alloc(signed int rows, signed int cols)
{
  double **mx;
  signed int r;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("sre_math.c", 190, sizeof(double *) /*8ul*/  * (unsigned long int)rows);
  mx = (double **)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("sre_math.c", 191, sizeof(double) /*8ul*/  * (unsigned long int)rows * (unsigned long int)cols);
  mx[(signed long int)0] = (double *)return_value_sre_malloc$2;
  r = 1;
  for( ; !(r >= rows); r = r + 1)
    mx[(signed long int)r] = mx[(signed long int)0] + (signed long int)(r * cols);
  return mx;
}

// DMX2Free
// file sre_math.c line 197
extern void DMX2Free(double **mx)
{
  free((void *)mx[(signed long int)0]);
  free((void *)mx);
}

// DMax
// file vectorops.c line 124
extern double DMax(double *vec, signed int n)
{
  signed int i;
  double best = vec[(signed long int)0];
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] > best)
      best = vec[(signed long int)i];

  return best;
}

// DMin
// file vectorops.c line 148
extern double DMin(double *vec, signed int n)
{
  signed int i;
  double best = vec[(signed long int)0];
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] < best)
      best = vec[(signed long int)i];

  return best;
}

// DNorm
// file vectorops.c line 215
extern void DNorm(double *vec, signed int n)
{
  signed int x;
  double sum;
  sum=DSum(vec, n);
  if(IEEE_FLOAT_NOTEQUAL(sum, 0.0))
  {
    x = 0;
    for( ; !(x >= n); x = x + 1)
      vec[(signed long int)x] = vec[(signed long int)x] / sum;
  }

  else
  {
    x = 0;
    for( ; !(x >= n); x = x + 1)
      vec[(signed long int)x] = 1. / (double)n;
  }
}

// DScale
// file vectorops.c line 46
extern void DScale(double *vec, signed int n, double scale)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec[(signed long int)x] = vec[(signed long int)x] * scale;
}

// DSet
// file vectorops.c line 32
extern void DSet(double *vec, signed int n, double value)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec[(signed long int)x] = value;
}

// DSum
// file vectorops.c line 60
extern double DSum(double *vec, signed int n)
{
  double sum = 0.;
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    sum = sum + vec[(signed long int)x];
  return sum;
}

// DealignAseqs
// file selex.c line 729
extern signed int DealignAseqs(char **aseqs, signed int num, char ***ret_rseqs)
{
  char **rseqs;
  signed int idx;
  signed int depos;
  signed int apos;
  signed int seqlen;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("selex.c", 738, (unsigned long int)num * sizeof(char *) /*8ul*/ );
  rseqs = (char **)return_value_sre_malloc$1;
  idx = 0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  for( ; !(idx >= num); idx = idx + 1)
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(aseqs[(signed long int)idx]);
    seqlen = (signed int)return_value_strlen$2;
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("selex.c", 744, (unsigned long int)(seqlen + 1) * sizeof(char) /*1ul*/ );
    rseqs[(signed long int)idx] = (char *)return_value_sre_malloc$3;
    depos = 0;
    apos = 0;
    for( ; !((signed int)aseqs[(signed long int)idx][(signed long int)apos] == 0); apos = apos + 1)
    {
      if((signed int)aseqs[(signed long int)idx][(signed long int)apos] == 32)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$7)
      {
        rseqs[(signed long int)idx][(signed long int)depos] = aseqs[(signed long int)idx][(signed long int)apos];
        depos = depos + 1;
      }

    }
    rseqs[(signed long int)idx][(signed long int)depos] = (char)0;
  }
  *ret_rseqs = rseqs;
  return 1;
}

// DealignedLength
// file ../squid/sqfuncs.h line 48
extern signed int DealignedLength(char *aseq)
{
  signed int rlen = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  for( ; !(*aseq == 0); aseq = aseq + 1l)
  {
    if((signed int)*aseq == 32)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*aseq == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*aseq == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)*aseq == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*aseq == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$4)
      rlen = rlen + 1;

  }
  return rlen;
}

// DedigitizeSequence
// file alphabet.c line 228
extern char * DedigitizeSequence(unsigned char *dsq, signed int L)
{
  char *seq;
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("alphabet.c", 233, sizeof(char) /*1ul*/  * (unsigned long int)(L + 1));
  seq = (char *)return_value_sre_malloc$1;
  i = 0;
  for( ; !(i >= L); i = i + 1)
    seq[(signed long int)i] = Alphabet[(signed long int)dsq[(signed long int)(i + 1)]];
  seq[(signed long int)L] = (char)0;
  return seq;
}

// DefaultCodonBias
// file alphabet.c line 341
extern void DefaultCodonBias(float *codebias)
{
  codebias[(signed long int)0] = (float)(1. / 2.);
  codebias[(signed long int)1] = (float)(1. / 2.);
  codebias[(signed long int)2] = (float)(1. / 2.);
  codebias[(signed long int)3] = (float)(1. / 2.);
  codebias[(signed long int)4] = (float)(1. / 4.);
  codebias[(signed long int)5] = (float)(1. / 4.);
  codebias[(signed long int)6] = (float)(1. / 4.);
  codebias[(signed long int)7] = (float)(1. / 4.);
  codebias[(signed long int)8] = (float)(1. / 6.);
  codebias[(signed long int)9] = (float)(1. / 6.);
  codebias[(signed long int)10] = (float)(1. / 6.);
  codebias[(signed long int)11] = (float)(1. / 6.);
  codebias[(signed long int)12] = (float)(1. / 3.);
  codebias[(signed long int)13] = (float)(1. / 3.);
  codebias[(signed long int)14] = (float)1.;
  codebias[(signed long int)15] = (float)(1. / 3.);
  codebias[(signed long int)16] = (float)(1. / 2.);
  codebias[(signed long int)17] = (float)(1. / 2.);
  codebias[(signed long int)18] = (float)(1. / 2.);
  codebias[(signed long int)19] = (float)(1. / 2.);
  codebias[(signed long int)20] = (float)(1. / 4.);
  codebias[(signed long int)21] = (float)(1. / 4.);
  codebias[(signed long int)22] = (float)(1. / 4.);
  codebias[(signed long int)23] = (float)(1. / 4.);
  codebias[(signed long int)24] = (float)(1. / 6.);
  codebias[(signed long int)25] = (float)(1. / 6.);
  codebias[(signed long int)26] = (float)(1. / 6.);
  codebias[(signed long int)27] = (float)(1. / 6.);
  codebias[(signed long int)28] = (float)(1. / 6.);
  codebias[(signed long int)29] = (float)(1. / 6.);
  codebias[(signed long int)30] = (float)(1. / 6.);
  codebias[(signed long int)31] = (float)(1. / 6.);
  codebias[(signed long int)32] = (float)(1. / 2.);
  codebias[(signed long int)33] = (float)(1. / 2.);
  codebias[(signed long int)34] = (float)(1. / 2.);
  codebias[(signed long int)35] = (float)(1. / 2.);
  codebias[(signed long int)36] = (float)(1. / 4.);
  codebias[(signed long int)37] = (float)(1. / 4.);
  codebias[(signed long int)38] = (float)(1. / 4.);
  codebias[(signed long int)39] = (float)(1. / 4.);
  codebias[(signed long int)40] = (float)(1. / 4.);
  codebias[(signed long int)41] = (float)(1. / 4.);
  codebias[(signed long int)42] = (float)(1. / 4.);
  codebias[(signed long int)43] = (float)(1. / 4.);
  codebias[(signed long int)44] = (float)(1. / 4.);
  codebias[(signed long int)45] = (float)(1. / 4.);
  codebias[(signed long int)46] = (float)(1. / 4.);
  codebias[(signed long int)47] = (float)(1. / 4.);
  codebias[(signed long int)48] = (float)0.;
  codebias[(signed long int)49] = (float)(1. / 2.);
  codebias[(signed long int)50] = (float)0.;
  codebias[(signed long int)51] = (float)(1. / 2.);
  codebias[(signed long int)52] = (float)(1. / 6.);
  codebias[(signed long int)53] = (float)(1. / 6.);
  codebias[(signed long int)54] = (float)(1. / 6.);
  codebias[(signed long int)55] = (float)(1. / 6.);
  codebias[(signed long int)56] = (float)0.;
  codebias[(signed long int)57] = (float)(1. / 2.);
  codebias[(signed long int)58] = (float)1.;
  codebias[(signed long int)59] = (float)(1. / 2.);
  codebias[(signed long int)60] = (float)(1. / 6.);
  codebias[(signed long int)61] = (float)(1. / 2.);
  codebias[(signed long int)62] = (float)(1. / 6.);
  codebias[(signed long int)63] = (float)(1. / 2.);
}

// DefaultGeneticCode
// file alphabet.c line 318
extern void DefaultGeneticCode(signed int *aacode)
{
  signed int x = 0;
  char *return_value_strchr$1;
  for( ; !(x >= 64); x = x + 1)
    if((signed int)*stdcode1[(signed long int)x] == 42)
      aacode[(signed long int)x] = -1;

    else
    {
      return_value_strchr$1=strchr(Alphabet, (signed int)*stdcode1[(signed long int)x]);
      aacode[(signed long int)x] = (signed int)(return_value_strchr$1 - Alphabet);
    }
}

// DegenerateSymbolScore
// file funcs.h line 233
extern signed int DegenerateSymbolScore(float *p, float *null, signed int ambig)
{
  signed int x;
  float numer = (float)0.;
  float denom = (float)0.;
  x = 0;
  double tmp_if_expr$2;
  double return_value_log$1;
  for( ; !(x >= Alphabet_size); x = x + 1)
    if(!(Degenerate[(signed long int)ambig][(signed long int)x] == 0))
    {
      if(p[(signed long int)x] / null[(signed long int)x] > 0.000000f)
      {
        return_value_log$1=log((double)(p[(signed long int)x] / null[(signed long int)x]));
        tmp_if_expr$2 = return_value_log$1 * 1.44269504;
      }

      else
        tmp_if_expr$2 = -9999.;
      numer = numer + (float)((double)null[(signed long int)x] * tmp_if_expr$2);
      denom = denom + null[(signed long int)x];
    }

  return (signed int)((1000.0 * (double)numer) / (double)denom);
}

// DetermineAlphabet
// file alphabet.c line 44
extern void DetermineAlphabet(char **rseqs, signed int nseq)
{
  signed int idx;
  signed int other;
  signed int nucleic;
  signed int amino;
  signed int type = 0;
  amino = 0;
  nucleic = amino;
  other = nucleic;
  idx = 0;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    signed int return_value_Seqtype$1;
    return_value_Seqtype$1=Seqtype(rseqs[(signed long int)idx]);
    switch(return_value_Seqtype$1)
    {
      case 2:
      {
        nucleic = nucleic + 1;
        break;
      }
      case 1:
      {
        nucleic = nucleic + 1;
        break;
      }
      case 3:
      {
        amino = amino + 1;
        break;
      }
      case 0:
      {
        other = other + 1;
        break;
      }
      default:
        Die("No such alphabet type");
    }
  }
  if(nucleic == nseq)
    type = 2;

  else
    if(amino == nseq)
      type = 3;

    else
      if(!(amino >= nucleic) && !(other >= nucleic))
      {
        Warn("Looks like nucleic acid sequence, hope that's right");
        type = 2;
      }

      else
        if(!(nucleic >= amino) && !(other >= amino))
        {
          Warn("Looks like amino acid sequence, hope that's right");
          type = 3;
        }

        else
          Die("Sorry, I can't tell if that's protein or DNA");
  SetAlphabet(type);
}

// Die
// file ../squid/sqfuncs.h line 150
extern void Die(char *format, ...)
{
  void **argp;
  fprintf(stderr, "\nFATAL: ");
  argp = (void **)&format;
  vfprintf(stderr, format, argp);
  argp = ((void **)NULL);
  fprintf(stderr, "\n");
  fflush(stderr);
  exit(1);
}

// DigitizeAlignment
// file alphabet.c line 255
extern void DigitizeAlignment(struct msa_struct *msa, unsigned char ***ret_dsqs)
{
  unsigned char **dsq;
  signed int idx;
  signed int dpos;
  signed int apos;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("alphabet.c", 262, sizeof(unsigned char *) /*8ul*/  * (unsigned long int)msa->nseq);
  dsq = (unsigned char **)return_value_sre_malloc$1;
  idx = 0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  signed int tmp_post$3;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("alphabet.c", 264, sizeof(unsigned char) /*1ul*/  * (unsigned long int)(msa->alen + 2));
    dsq[(signed long int)idx] = (unsigned char *)return_value_sre_malloc$2;
    dsq[(signed long int)idx][(signed long int)0] = (unsigned char)Alphabet_iupac;
    apos = 0;
    dpos = 1;
    for( ; !(apos >= msa->alen); apos = apos + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 32)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$7)
      {
        tmp_post$3 = dpos;
        dpos = dpos + 1;
        dsq[(signed long int)idx][(signed long int)tmp_post$3]=SymbolIndex(msa->aseq[(signed long int)idx][(signed long int)apos]);
      }

    }
    dsq[(signed long int)idx][(signed long int)dpos] = (unsigned char)Alphabet_iupac;
  }
  *ret_dsqs = dsq;
}

// DigitizeSequence
// file funcs.h line 31
extern unsigned char * DigitizeSequence(char *seq, signed int L)
{
  unsigned char *dsq;
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("alphabet.c", 213, sizeof(unsigned char) /*1ul*/  * (unsigned long int)(L + 2));
  dsq = (unsigned char *)return_value_sre_malloc$1;
  dsq[(signed long int)(L + 1)] = (unsigned char)Alphabet_iupac;
  dsq[(signed long int)0] = dsq[(signed long int)(L + 1)];
  i = 1;
  for( ; L >= i; i = i + 1)
    dsq[(signed long int)i]=SymbolIndex(seq[(signed long int)(i - 1)]);
  return dsq;
}

// DisplayPlan7Matrix
// file display.c line 298
extern void DisplayPlan7Matrix(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s *mx)
{
  signed int i;
  signed int k;
  printf("         *      ");
  i = 1;
  for( ; L >= i; i = i + 1)
    printf("    %c      ", Alphabet[(signed long int)dsq[(signed long int)i]]);
  printf("\nN    ");
  i = 0;
  for( ; L >= i; i = i + 1)
    PrintIscore(mx->xmx[(signed long int)i][(signed long int)4]);
  k = 1;
  for( ; hmm->M >= k; k = k + 1)
  {
    printf("\nM%-3d ", k);
    i = 0;
    for( ; L >= i; i = i + 1)
      PrintIscore(mx->mmx[(signed long int)i][(signed long int)k]);
  }
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    printf("\nI%-3d ", k);
    i = 0;
    for( ; L >= i; i = i + 1)
      PrintIscore(mx->imx[(signed long int)i][(signed long int)k]);
  }
  printf("\nE    ");
  i = 0;
  for( ; L >= i; i = i + 1)
    PrintIscore(mx->xmx[(signed long int)i][(signed long int)1]);
  printf("\nC    ");
  i = 0;
  for( ; L >= i; i = i + 1)
    PrintIscore(mx->xmx[(signed long int)i][(signed long int)2]);
  printf("\nJ    ");
  i = 0;
  for( ; L >= i; i = i + 1)
    PrintIscore(mx->xmx[(signed long int)i][(signed long int)3]);
  printf("\nB    ");
  i = 0;
  for( ; L >= i; i = i + 1)
    PrintIscore(mx->xmx[(signed long int)i][(signed long int)0]);
  k = 2;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    printf("\nD%-3d ", k);
    i = 0;
    for( ; L >= i; i = i + 1)
      PrintIscore(mx->dmx[(signed long int)i][(signed long int)k]);
  }
  printf("\n\n");
}

// DisplayPlan7PostAlign
// file display.c line 90
extern void DisplayPlan7PostAlign(signed int L, struct plan7_s *hmm, struct dpmatrix_s *forward, struct dpmatrix_s *backward, struct p7trace_s **alignment, signed int A)
{
  signed int sc;
  signed int i;
  signed int j;
  signed int k;
  signed int kmin;
  signed int kmax;
  signed int *min;
  signed int *max;
  signed int *on;
  char state;
  sc = forward->xmx[(signed long int)L][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)0];
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)A, sizeof(signed int) /*4ul*/ );
  min = (signed int *)return_value_calloc$1;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)A, sizeof(signed int) /*4ul*/ );
  max = (signed int *)return_value_calloc$2;
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)A, sizeof(signed int) /*4ul*/ );
  on = (signed int *)return_value_calloc$3;
  i = 0;
  for( ; L >= i; i = i + 1)
  {
    j = 0;
    for( ; !(j >= A); j = j + 1)
    {
      for( ; !(alignment[(signed long int)j]->pos[(signed long int)min[(signed long int)j]] >= i + -1); min[(signed long int)j] = min[(signed long int)j] + 1)
        if(min[(signed long int)j] >= alignment[(signed long int)j]->tlen + -1)
          break;

      for( ; 1 + i >= alignment[(signed long int)j]->pos[(signed long int)max[(signed long int)j]]; max[(signed long int)j] = max[(signed long int)j] + 1)
        if(max[(signed long int)j] >= alignment[(signed long int)j]->tlen + -1)
          break;

    }
    state = (char)1;
    for( ; !((signed int)state >= 11); state = state + 1)
    {
      if((signed int)state == 1 || (signed int)state == 6)
      {
        kmin = 1;
        kmax = hmm->M;
      }

      else
        if((signed int)state == 2)
        {
          kmin = 2;
          kmax = hmm->M - 1;
        }

        else
          if((signed int)state == 3)
          {
            kmin = 1;
            kmax = hmm->M - 1;
          }

          else
          {
            kmax = 0;
            kmin = kmax;
          }
      k = kmin;
      for( ; kmax >= k; k = k + 1)
        switch((signed int)state)
        {
          case 1:
          {
            if(!(i >= L))
            {
              if(!(k >= hmm->M))
                PrintTransition((char)1, i, k, (char)1, i + 1, k + 1, (forward->mmx[(signed long int)i][(signed long int)k] + hmm->tsc[(signed long int)0][(signed long int)k] + backward->mmx[(signed long int)(i + 1)][(signed long int)(k + 1)]) - sc, alignment, min, max, on, A);

            }

            if(!(i >= L))
            {
              if(!(k >= hmm->M))
                PrintTransition((char)1, i, k, (char)3, i + 1, k, (forward->mmx[(signed long int)i][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k] + backward->imx[(signed long int)(i + 1)][(signed long int)k]) - sc, alignment, min, max, on, A);

            }

            if(!(k >= hmm->M + -1))
              PrintTransition((char)1, i, k, (char)2, i, k + 1, (forward->mmx[(signed long int)i][(signed long int)k] + hmm->tsc[(signed long int)2][(signed long int)k] + backward->dmx[(signed long int)i][(signed long int)(k + 1)]) - sc, alignment, min, max, on, A);

            PrintTransition((char)1, i, k, (char)7, i, 0, (forward->mmx[(signed long int)i][(signed long int)k] + hmm->esc[(signed long int)k] + backward->xmx[(signed long int)i][(signed long int)1]) - sc, alignment, min, max, on, A);
            break;
          }
          case 2:
          {
            if(!(i >= L))
              PrintTransition((char)2, i, k, (char)1, i + 1, k + 1, (forward->dmx[(signed long int)i][(signed long int)k] + hmm->tsc[(signed long int)5][(signed long int)k] + backward->mmx[(signed long int)(i + 1)][(signed long int)(k + 1)]) - sc, alignment, min, max, on, A);

            PrintTransition((char)2, i, k, (char)2, i, k + 1, (forward->dmx[(signed long int)i][(signed long int)k] + hmm->tsc[(signed long int)6][(signed long int)k] + backward->dmx[(signed long int)i][(signed long int)(k + 1)]) - sc, alignment, min, max, on, A);
            break;
          }
          case 3:
          {
            if(!(i >= L))
              PrintTransition((char)3, i, k, (char)1, i + 1, k + 1, (forward->imx[(signed long int)i][(signed long int)k] + hmm->tsc[(signed long int)3][(signed long int)k] + backward->mmx[(signed long int)(i + 1)][(signed long int)(k + 1)]) - sc, alignment, min, max, on, A);

            if(!(i >= L))
              PrintTransition((char)3, i, k, (char)3, i + 1, k, (forward->imx[(signed long int)i][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k] + backward->imx[(signed long int)(i + 1)][(signed long int)k]) - sc, alignment, min, max, on, A);

            break;
          }
          case 6:
            if(!(i >= L))
              PrintTransition((char)6, i, 0, (char)1, i + 1, k, (forward->xmx[(signed long int)i][(signed long int)0] + hmm->bsc[(signed long int)k] + backward->mmx[(signed long int)(i + 1)][(signed long int)k]) - sc, alignment, min, max, on, A);

        }
      switch((signed int)state)
      {
        case 5:
        {
          PrintTransition((char)5, i, 0, (char)6, i, 0, (forward->xmx[(signed long int)i][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0] + backward->xmx[(signed long int)i][(signed long int)0]) - sc, alignment, min, max, on, A);
          if(!(i >= L))
            PrintTransition((char)5, i, 0, (char)5, i + 1, 0, (forward->xmx[(signed long int)i][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1] + backward->xmx[(signed long int)(i + 1)][(signed long int)4]) - sc, alignment, min, max, on, A);

          break;
        }
        case 10:
        {
          PrintTransition((char)10, i, 0, (char)6, i, 0, (forward->xmx[(signed long int)i][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)0] + backward->xmx[(signed long int)i][(signed long int)0]) - sc, alignment, min, max, on, A);
          if(!(i >= L))
            PrintTransition((char)10, i, 0, (char)10, i + 1, 0, (forward->xmx[(signed long int)i][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)1] + backward->xmx[(signed long int)(i + 1)][(signed long int)3]) - sc, alignment, min, max, on, A);

          break;
        }
        case 8:
        {
          PrintTransition((char)8, i, 0, (char)9, i, 0, (forward->xmx[(signed long int)i][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)0]) - sc, alignment, min, max, on, A);
          if(!(i >= L))
            PrintTransition((char)8, i, 0, (char)8, i + 1, 0, (forward->xmx[(signed long int)i][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1] + backward->xmx[(signed long int)(i + 1)][(signed long int)2]) - sc, alignment, min, max, on, A);

          break;
        }
        case 7:
        {
          PrintTransition((char)7, i, 0, (char)8, i, 0, (forward->xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0] + backward->xmx[(signed long int)i][(signed long int)2]) - sc, alignment, min, max, on, A);
          PrintTransition((char)7, i, 0, (char)10, i, 0, (forward->xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)1] + backward->xmx[(signed long int)i][(signed long int)3]) - sc, alignment, min, max, on, A);
          break;
        }
        case 4:
        {
          if(i == 0)
            PrintTransition((char)4, i, 0, (char)5, i, 0, backward->xmx[(signed long int)i][(signed long int)4] - sc, alignment, min, max, on, A);

          break;
        }
        case 1:

        case 2:

        case 3:

        case 6:

        case 9:
          break;
        default:
          Die("unknown state");
      }
    }
  }
  free((void *)min);
  free((void *)max);
  free((void *)on);
}

// DisplayPlan7Posteriors
// file display.c line 62
extern void DisplayPlan7Posteriors(signed int L, struct plan7_s *hmm, struct dpmatrix_s *forward, struct dpmatrix_s *backward, struct p7trace_s *viterbi, struct p7trace_s *optacc)
{
  struct p7trace_s *alignment[2l];
  alignment[(signed long int)0] = viterbi;
  alignment[(signed long int)1] = optacc;
  DisplayPlan7PostAlign(L, hmm, forward, backward, alignment, 2);
}

// EPSWriteSmallMSA
// file eps.c line 43
extern void EPSWriteSmallMSA(struct _IO_FILE *fp, struct msa_struct *msa)
{
  signed int namewidth;
  signed int fontwidth;
  signed int hspace;
  signed int vspace;
  char *font;
  signed int fontsize;
  signed int i;
  signed int j;
  signed int len;
  signed int width;
  signed int height;
  signed int xpos;
  signed int ypos;
  fontwidth = 8;
  hspace = 9;
  vspace = 15;
  font=sre_strdup("Courier", -1);
  fontsize = 12;
  namewidth = 0;
  i = 0;
  unsigned long int return_value_strlen$1;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    return_value_strlen$1=strlen(msa->sqname[(signed long int)i]);
    len = (signed int)return_value_strlen$1;
    if(!(namewidth >= len))
      namewidth = len;

  }
  namewidth = namewidth + 1;
  namewidth = namewidth * fontwidth;
  if(msa->alen >= 51)
    Die("No EPS fmt if alignment is >50 columns");

  width = namewidth + hspace * msa->alen;
  if(width >= 613)
    Die("Alignment too wide to write in EPS");

  height = vspace * msa->nseq;
  if(height >= 793)
    Die("Too many seqs to write in EPS");

  fprintf(fp, "%%!PS-Adobe-3.0 EPSF-3.0\n");
  fprintf(fp, "%%%%BoundingBox: %d %d %d %d\n", 0, 0, width, height);
  fprintf(fp, "%%%%Pages: 1\n");
  fprintf(fp, "%%%%EndComments\n");
  fprintf(fp, "/%s findfont\n", font);
  fprintf(fp, "%d scalefont\n", fontsize);
  fprintf(fp, "setfont\n");
  fprintf(fp, "newpath\n");
  i = 0;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    ypos = ((msa->nseq - i) - 1) * vspace;
    fprintf(fp, "%d %d moveto\n", 0, ypos);
    fprintf(fp, "(%s) show\n", msa->sqname[(signed long int)i]);
    xpos = namewidth;
    j = 0;
    for( ; !(j >= msa->alen); j = j + 1)
    {
      fprintf(fp, "%d %d moveto\n", xpos, ypos);
      fprintf(fp, "(%c) show\n", msa->aseq[(signed long int)i][(signed long int)j]);
      xpos = xpos + hspace;
    }
  }
  free((void *)font);
}

// EVDBasicFit
// file histogram.c line 476
extern void EVDBasicFit(struct histogram_s *h)
{
  float *d;
  float *x;
  signed int hsize;
  signed int sum;
  signed int sc;
  signed int idx;
  float slope;
  float intercept;
  float corr;
  float lambda;
  float mu;
  hsize = (h->highscore - h->lowscore) + 1;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("histogram.c", 492, sizeof(float) /*4ul*/  * (unsigned long int)hsize);
  d = (float *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("histogram.c", 493, sizeof(float) /*4ul*/  * (unsigned long int)hsize);
  x = (float *)return_value_sre_malloc$2;
  idx = 0;
  for( ; !(idx >= hsize); idx = idx + 1)
  {
    x[(signed long int)idx] = (float)0.;
    d[(signed long int)idx] = x[(signed long int)idx];
  }
  sum = 0;
  sc = h->lowscore;
  for( ; h->highscore >= sc; sc = sc + 1)
  {
    sum = sum + h->histogram[(signed long int)(sc - h->min)];
    d[(signed long int)(sc - h->lowscore)] = (float)sum / (float)h->total;
    x[(signed long int)(sc - h->lowscore)] = (float)(sc + 1);
  }
  sc = h->lowscore;
  double return_value_log$3;
  double return_value_log$4;
  for( ; !(sc >= h->highscore); sc = sc + 1)
  {
    return_value_log$3=log((double)d[(signed long int)(sc - h->lowscore)]);
    return_value_log$4=log(-1. * return_value_log$3);
    d[(signed long int)(sc - h->lowscore)] = (float)return_value_log$4;
  }
  Linefit(x, d, hsize - 1, &intercept, &slope, &corr);
  lambda = (float)(-1. * (double)slope);
  mu = intercept / lambda;
  ExtremeValueSetHistogram(h, mu, lambda, (float)h->lowscore, (float)h->highscore, 2);
  free((void *)x);
  free((void *)d);
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// EVDCensoredFit
// file histogram.c line 1271
extern signed int EVDCensoredFit(float *x, signed int *y, signed int n, signed int z, float c, float *ret_mu, float *ret_lambda)
{
  float lambda;
  float mu;
  float fx;
  float dfx;
  double esum;
  double mult;
  double total;
  float tol = (float)1e-5;
  signed int i;
  lambda = (float)0.2;
  i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    Lawless422(x, y, n, z, c, lambda, &fx, &dfx);
    double return_value_fabs$1;
    return_value_fabs$1=fabs((double)fx);
    if(return_value_fabs$1 < (double)tol)
      break;

    lambda = lambda - fx / dfx;
    if(lambda <= 0.000000f)
      lambda = (float)0.001;

  }
  if(i == 100)
  {
    float left;
    float right;
    float mid;
    left = (float)0.2;
    right = left;
    lambda = right;
    Lawless422(x, y, n, z, c, lambda, &fx, &dfx);
    if(fx < 0.000000f)
      do
      {
        left = left - (float)0.03;
        if(left < 0.000000f)
          return 0;

        Lawless422(x, y, n, z, c, left, &fx, &dfx);
      }
      while(fx < 0.000000f);

    else
      do
      {
        right = right + (float)0.1;
        Lawless422(x, y, n, z, c, left, &fx, &dfx);
        if(right > 100.000000f)
          return 0;

      }
      while(fx > 0.000000f);
    i = 0;
    for( ; !(i >= 100); i = i + 1)
    {
      mid = (float)((double)(left + right) / 2.);
      Lawless422(x, y, n, z, c, left, &fx, &dfx);
      double return_value_fabs$2;
      return_value_fabs$2=fabs((double)fx);
      if(return_value_fabs$2 < (double)tol)
        break;

      if(fx > 0.000000f)
        left = mid;

      else
        right = mid;
    }
    if(i == 100)
      return 0;

    lambda = mid;
  }

  total = 0.;
  esum = total;
  i = 0;
  double tmp_if_expr$3;
  for( ; !(i >= n); i = i + 1)
  {
    if(y == ((signed int *)NULL))
      tmp_if_expr$3 = 1.;

    else
      tmp_if_expr$3 = (double)y[(signed long int)i];
    mult = tmp_if_expr$3;
    double return_value_exp$4;
    return_value_exp$4=exp(-1. * (double)lambda * (double)x[(signed long int)i]);
    esum = esum + mult * return_value_exp$4;
    total = total + mult;
  }
  double return_value_exp$5;
  return_value_exp$5=exp(-1. * (double)lambda * (double)c);
  esum = esum + (double)z * return_value_exp$5;
  double return_value_log$6;
  return_value_log$6=log(esum / total);
  mu = (float)((-1. * return_value_log$6) / (double)lambda);
  *ret_lambda = lambda;
  *ret_mu = mu;
  return 1;
}

// EVDDensity
// file histogram.c line 891
extern double EVDDensity(float x, float mu, float lambda)
{
  double return_value_exp$1;
  return_value_exp$1=exp(-1. * (double)lambda * (double)(x - mu));
  double return_value_exp$2;
  return_value_exp$2=exp(-1. * (double)lambda * (double)(x - mu) - return_value_exp$1);
  return (double)lambda * return_value_exp$2;
}

// EVDDistribution
// file histogram.c line 905
extern double EVDDistribution(float x, float mu, float lambda)
{
  double return_value_exp$1;
  return_value_exp$1=exp(-1. * (double)lambda * (double)(x - mu));
  double return_value_exp$2;
  return_value_exp$2=exp(-1. * return_value_exp$1);
  return return_value_exp$2;
}

// EVDMaxLikelyFit
// file histogram.c line 1147
extern signed int EVDMaxLikelyFit(float *x, signed int *c, signed int n, float *ret_mu, float *ret_lambda)
{
  float lambda;
  float mu;
  float fx;
  float dfx;
  double esum;
  double mult;
  double total;
  float tol = (float)1e-5;
  signed int i;
  lambda = (float)0.2;
  i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    Lawless416(x, c, n, lambda, &fx, &dfx);
    double return_value_fabs$1;
    return_value_fabs$1=fabs((double)fx);
    if(return_value_fabs$1 < (double)tol)
      break;

    lambda = lambda - fx / dfx;
    if(lambda <= 0.000000f)
      lambda = (float)0.001;

  }
  if(i == 100)
  {
    float left;
    float right;
    float mid;
    left = (float)0.2;
    right = left;
    lambda = right;
    Lawless416(x, c, n, lambda, &fx, &dfx);
    if(fx < 0.000000f)
      do
      {
        left = left - (float)0.1;
        if(left < 0.000000f)
          return 0;

        Lawless416(x, c, n, left, &fx, &dfx);
      }
      while(fx < 0.000000f);

    else
      do
      {
        right = right + (float)0.1;
        Lawless416(x, c, n, right, &fx, &dfx);
        if(right > 100.000000f)
          return 0;

      }
      while(fx > 0.000000f);
    i = 0;
    for( ; !(i >= 100); i = i + 1)
    {
      mid = (float)((double)(left + right) / 2.);
      Lawless416(x, c, n, mid, &fx, &dfx);
      double return_value_fabs$2;
      return_value_fabs$2=fabs((double)fx);
      if(return_value_fabs$2 < (double)tol)
        break;

      if(fx > 0.000000f)
        left = mid;

      else
        right = mid;
    }
    if(i == 100)
      return 0;

    lambda = mid;
  }

  esum = 0.;
  total = 0.;
  i = 0;
  double tmp_if_expr$3;
  for( ; !(i >= n); i = i + 1)
  {
    if(c == ((signed int *)NULL))
      tmp_if_expr$3 = 1.;

    else
      tmp_if_expr$3 = (double)c[(signed long int)i];
    mult = tmp_if_expr$3;
    double return_value_exp$4;
    return_value_exp$4=exp((double)((float)-1 * lambda * x[(signed long int)i]));
    esum = esum + mult * return_value_exp$4;
    total = total + mult;
  }
  double return_value_log$5;
  return_value_log$5=log(esum / total);
  mu = (float)((-1. * return_value_log$5) / (double)lambda);
  *ret_lambda = lambda;
  *ret_mu = mu;
  return 1;
}

// EVDrandom
// file histogram.c line 993
extern float EVDrandom(float mu, float lambda)
{
  float p = (float)0.0;
  double return_value_sre_random$1;
  for( ; IEEE_FLOAT_EQUAL((double)p, 0.) || IEEE_FLOAT_EQUAL((double)p, 1.); p = (float)return_value_sre_random$1)
    return_value_sre_random$1=sre_random();
  double return_value_log$2;
  return_value_log$2=log((double)p);
  double return_value_log$3;
  return_value_log$3=log(-1. * return_value_log$2);
  return (float)((double)mu - return_value_log$3 / (double)lambda);
}

// EmitConsensusSequence
// file emit.c line 203
extern void EmitConsensusSequence(struct plan7_s *hmm, char **ret_seq, unsigned char **ret_dsq, signed int *ret_L, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  unsigned char *dsq;
  char *seq;
  float *mp;
  float *ip;
  float *dp;
  signed int nmat;
  signed int ndel;
  signed int nins;
  signed int k;
  signed int tpos;
  signed int i;
  signed int x;
  float mthresh;
  if(Alphabet_type == 3)
    mthresh = (float)0.5;

  else
    mthresh = (float)0.9;
  StateOccupancy(hmm, &mp, &ip, &dp);
  nins = 0;
  ndel = nins;
  nmat = ndel;
  k = 1;
  for( ; hmm->M >= k; k = k + 1)
  {
    if(mp[(signed long int)k] >= 5.000000e-1f)
      nmat = nmat + 1;

    else
      ndel = ndel + 1;
    if(!(k >= hmm->M))
    {
      if(ip[(signed long int)k] >= 5.000000e-1f)
        nins = nins + (signed int)(1.f / (1.f - hmm->t[(signed long int)k][(signed long int)4]));

    }

  }
  P7AllocTrace(6 + nmat + ndel + nins, &tr);
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("emit.c", 235, sizeof(unsigned char) /*1ul*/  * (unsigned long int)(nmat + nins + 3));
  dsq = (unsigned char *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("emit.c", 236, sizeof(char) /*1ul*/  * (unsigned long int)(nmat + nins + 1));
  seq = (char *)return_value_sre_malloc$2;
  TraceSet(tr, 0, (char)4, 0, 0);
  TraceSet(tr, 1, (char)5, 0, 0);
  TraceSet(tr, 2, (char)6, 0, 0);
  dsq[(signed long int)0] = (unsigned char)Alphabet_iupac;
  tpos = 3;
  i = 0;
  k = 1;
  signed int return_value_tolower$3;
  signed int tmp_post$4;
  for( ; hmm->M >= k; k = k + 1)
  {
    if(mp[(signed long int)k] >= 5.000000e-1f)
    {
      x=FArgMax(hmm->mat[(signed long int)k], Alphabet_size);
      TraceSet(tr, tpos, (char)1, k, i + 1);
      seq[(signed long int)i] = Alphabet[(signed long int)x];
      dsq[(signed long int)(i + 1)] = (unsigned char)x;
      if(hmm->mat[(signed long int)k][(signed long int)x] < mthresh)
      {
        return_value_tolower$3=tolower((signed int)seq[(signed long int)i]);
        seq[(signed long int)i] = (char)return_value_tolower$3;
      }

      i = i + 1;
      tpos = tpos + 1;
    }

    else
    {
      TraceSet(tr, tpos, (char)2, k, 0);
      tpos = tpos + 1;
    }
    if(!(k >= hmm->M))
    {
      if(ip[(signed long int)k] >= 5.000000e-1f)
      {
        x = (signed int)(1.f / (1.f - hmm->t[(signed long int)k][(signed long int)4]));
        do
        {
          tmp_post$4 = x;
          x = x - 1;
          if(tmp_post$4 == 0)
            break;

          TraceSet(tr, tpos, (char)3, k, i + 1);
          seq[(signed long int)i] = (char)120;
          dsq[(signed long int)(i + 1)] = (unsigned char)(Alphabet_iupac - 1);
          i = i + 1;
          tpos = tpos + 1;
        }
        while((_Bool)1);
      }

    }

  }
  TraceSet(tr, tpos, (char)7, 0, 0);
  tpos = tpos + 1;
  TraceSet(tr, tpos, (char)8, 0, 0);
  tpos = tpos + 1;
  TraceSet(tr, tpos, (char)9, 0, 0);
  tpos = tpos + 1;
  dsq[(signed long int)(i + 1)] = (unsigned char)Alphabet_iupac;
  free((void *)mp);
  free((void *)ip);
  free((void *)dp);
  if(!(ret_seq == ((char **)NULL)))
    *ret_seq = seq;

  else
    free((void *)seq);
  if(!(ret_dsq == ((unsigned char **)NULL)))
    *ret_dsq = dsq;

  else
    free((void *)dsq);
  if(!(ret_L == ((signed int *)NULL)))
    *ret_L = i;

  if(!(ret_tr == ((struct p7trace_s **)NULL)))
    *ret_tr = tr;

  else
    P7FreeTrace(tr);
}

// EmitSequence
// file emit.c line 42
extern void EmitSequence(struct plan7_s *hmm, unsigned char **ret_dsq, signed int *ret_L, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  unsigned char *dsq;
  char type;
  signed int k;
  signed int L;
  signed int alloc_tlen;
  signed int alloc_L;
  signed int tpos;
  unsigned char sym;
  float t[4l];
  P7AllocTrace(64, &tr);
  alloc_tlen = 64;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("emit.c", 59, sizeof(unsigned char) /*1ul*/  * (unsigned long int)64);
  dsq = (unsigned char *)return_value_sre_malloc$1;
  alloc_L = 64;
  TraceSet(tr, 0, (char)4, 0, 0);
  TraceSet(tr, 1, (char)5, 0, 0);
  dsq[(signed long int)0] = (unsigned char)Alphabet_iupac;
  L = 1;
  k = 0;
  type = (char)5;
  tpos = 2;
  signed int return_value_FChoose$2;
  signed int return_value_FChoose$3;
  signed int return_value_FChoose$4;
  signed int return_value_FChoose$5;
  signed int return_value_FChoose$6;
  signed int return_value_FChoose$9;
  signed int return_value_FChoose$10;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$15;
  signed int return_value_FChoose$11;
  while(!((signed int)type == 9))
  {
    switch((signed int)type)
    {
      case 6:
      {
        hmm->begin[(signed long int)0] = hmm->tbd1;
        k=FChoose(hmm->begin, hmm->M + 1);
        if(k == 0)
        {
          type = (char)2;
          k = 1;
        }

        else
          type = (char)1;
        break;
      }
      case 3:
      {
        return_value_FChoose$2=FChoose(hmm->t[(signed long int)k] + (signed long int)3, 2);
        type = (char)(return_value_FChoose$2 == 0 ? 1 : 3);
        if((signed int)type == 1)
          k = k + 1;

        break;
      }
      case 5:
      {
        return_value_FChoose$3=FChoose(hmm->xt[(signed long int)0], 2);
        type = (char)(return_value_FChoose$3 == 1 ? 5 : 6);
        k = 0;
        break;
      }
      case 7:
      {
        return_value_FChoose$4=FChoose(hmm->xt[(signed long int)1], 2);
        type = (char)(return_value_FChoose$4 == 1 ? 10 : 8);
        k = 0;
        break;
      }
      case 8:
      {
        return_value_FChoose$5=FChoose(hmm->xt[(signed long int)2], 2);
        type = (char)(return_value_FChoose$5 == 1 ? 8 : 9);
        k = 0;
        break;
      }
      case 10:
      {
        return_value_FChoose$6=FChoose(hmm->xt[(signed long int)3], 2);
        type = (char)(return_value_FChoose$6 == 1 ? 10 : 6);
        k = 0;
        break;
      }
      case 2:
      {
        if(!(k >= hmm->M))
        {
          signed int return_value_FChoose$7;
          return_value_FChoose$7=FChoose(hmm->t[(signed long int)k] + (signed long int)5, 2);
          type = (char)(return_value_FChoose$7 == 0 ? 1 : 2);
          k = k + 1;
        }

        else
        {
          type = (char)7;
          k = 0;
        }
        break;
      }
      case 1:
      {
        if(!(k >= hmm->M))
        {
          FCopy(t, hmm->t[(signed long int)k], 3);
          t[(signed long int)3] = hmm->end[(signed long int)k];
          signed int return_value_FChoose$8;
          return_value_FChoose$8=FChoose(t, 4);
          switch(return_value_FChoose$8)
          {
            case 0:
            {
              k = k + 1;
              type = (char)1;
              break;
            }
            case 1:
            {
              type = (char)3;
              break;
            }
            case 2:
            {
              k = k + 1;
              type = (char)2;
              break;
            }
            case 3:
            {
              k = 0;
              type = (char)7;
              break;
            }
            default:
              Die("never happens");
          }
        }

        else
        {
          k = 0;
          type = (char)7;
        }
        break;
      }
      case 9:

      case 0:

      default:
        Die("can't happen.");
    }
    sym = (unsigned char)Alphabet_iupac;
    if((signed int)type == 1)
    {
      return_value_FChoose$9=FChoose(hmm->mat[(signed long int)k], Alphabet_size);
      sym = (unsigned char)return_value_FChoose$9;
    }

    else
      if((signed int)type == 3)
      {
        return_value_FChoose$10=FChoose(hmm->ins[(signed long int)k], Alphabet_size);
        sym = (unsigned char)return_value_FChoose$10;
      }

      else
      {
        if((signed int)type == 5)
          tmp_if_expr$12 = (signed int)tr->statetype[(signed long int)(tpos - 1)] == 5 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$12 = (_Bool)0;
        if(tmp_if_expr$12)
          tmp_if_expr$14 = (_Bool)1;

        else
        {
          if((signed int)type == 8)
            tmp_if_expr$13 = (signed int)tr->statetype[(signed long int)(tpos - 1)] == 8 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$13 = (_Bool)0;
          tmp_if_expr$14 = tmp_if_expr$13 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$14)
          tmp_if_expr$16 = (_Bool)1;

        else
        {
          if((signed int)type == 10)
            tmp_if_expr$15 = (signed int)tr->statetype[(signed long int)(tpos - 1)] == 10 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$15 = (_Bool)0;
          tmp_if_expr$16 = tmp_if_expr$15 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$16)
        {
          return_value_FChoose$11=FChoose(hmm->null, Alphabet_size);
          sym = (unsigned char)return_value_FChoose$11;
        }

      }
    TraceSet(tr, tpos, type, k, (signed int)sym != Alphabet_iupac ? L : 0);
    tpos = tpos + 1;
    if(tpos == alloc_tlen)
    {
      alloc_tlen = alloc_tlen + 64;
      P7ReallocTrace(tr, alloc_tlen);
    }

    if(!((signed int)sym == Alphabet_iupac))
    {
      dsq[(signed long int)L] = sym;
      L = L + 1;
      if(L == alloc_L)
      {
        alloc_L = alloc_L + 64;
        void *return_value_sre_realloc$17;
        return_value_sre_realloc$17=sre_realloc("emit.c", 146, (void *)dsq, sizeof(unsigned char) /*1ul*/  * (unsigned long int)alloc_L);
        dsq = (unsigned char *)return_value_sre_realloc$17;
      }

    }

  }
  tr->tlen = tpos;
  dsq[(signed long int)L] = (unsigned char)Alphabet_iupac;
  L = L - 1;
  if(!(ret_dsq == ((unsigned char **)NULL)))
    *ret_dsq = dsq;

  else
    free((void *)dsq);
  if(!(ret_L == ((signed int *)NULL)))
    *ret_L = L;

  if(!(ret_tr == ((struct p7trace_s **)NULL)))
    *ret_tr = tr;

  else
    P7FreeTrace(tr);
  goto __CPROVER_DUMP_L46;

__CPROVER_DUMP_L46:
  ;
}

// EnvFileOpen
// file ../squid/sqfuncs.h line 81
extern struct _IO_FILE * EnvFileOpen(char *fname, char *env, char **ret_dir)
{
  struct _IO_FILE *fp;
  char *path;
  char *s;
  char full[1024l];
  if(env == ((char *)NULL))
    return (struct _IO_FILE *)(void *)0;

  else
  {
    char *return_value_getenv$1;
    return_value_getenv$1=getenv(env);
    path=Strdup(return_value_getenv$1);
    if(path == ((char *)NULL))
      return (struct _IO_FILE *)(void *)0;

    else
    {
      fp = (struct _IO_FILE *)(void *)0;
      s=strtok(path, ":");
      while(!(s == ((char *)NULL)))
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(fname);
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(s);
        if(2 + (signed int)return_value_strlen$2 + (signed int)return_value_strlen$3 >= 1025)
        {
          free((void *)path);
          return (struct _IO_FILE *)(void *)0;
        }

        sprintf(full, "%s%c%s", s, 47, fname);
        fp=fopen(full, "r");
        if(!(fp == ((struct _IO_FILE *)NULL)))
          break;

        s=strtok((char *)(void *)0, ":");
      }
      if(!(ret_dir == ((char **)NULL)))
        *ret_dir=Strdup(s);

      free((void *)path);
      return fp;
    }
  }
}

// ExponentialRandom
// file sre_random.c line 148
extern double ExponentialRandom(void)
{
  double x;
  do
    x=sre_random();
  while(IEEE_FLOAT_EQUAL(x, 0.0));
  double return_value_log$1;
  return_value_log$1=log(x);
  return -return_value_log$1;
}

// ExtremeValueE
// file histogram.c line 978
extern double ExtremeValueE(float x, float mu, float lambda, signed int N)
{
  double return_value_ExtremeValueP$1;
  return_value_ExtremeValueP$1=ExtremeValueP(x, mu, lambda);
  return (double)N * return_value_ExtremeValueP$1;
}

// ExtremeValueFitHistogram
// file funcs.h line 131
extern signed int ExtremeValueFitHistogram(struct histogram_s *h, signed int censor, float high_hint)
{
  float *x;
  signed int *y;
  signed int n;
  signed int z;
  signed int hsize;
  float lambda;
  float mu;
  signed int sc;
  signed int lowbound;
  signed int highbound;
  signed int new_highbound;
  signed int iteration;
  lowbound = h->lowscore;
  if(!(censor == 0))
  {
    signed int max = -1;
    sc = h->lowscore;
    for( ; h->highscore >= sc; sc = sc + 1)
      if(!(max >= h->histogram[(signed long int)(sc + -h->min)]))
      {
        max = h->histogram[(signed long int)(sc - h->min)];
        lowbound = sc;
      }

  }

  float tmp_if_expr$1;
  if(high_hint < (float)h->highscore)
    tmp_if_expr$1 = high_hint;

  else
    tmp_if_expr$1 = (float)h->highscore;
  highbound = (signed int)tmp_if_expr$1;
  iteration = 0;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  signed int return_value_EVDMaxLikelyFit$7;
  for( ; !(iteration >= 100); iteration = iteration + 1)
  {
    x = (float *)(void *)0;
    y = (signed int *)(void *)0;
    hsize = (highbound - lowbound) + 1;
    if(!(hsize >= 5))
      goto FITFAILED;

    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("histogram.c", 600, sizeof(float) /*4ul*/  * (unsigned long int)hsize);
    x = (float *)return_value_sre_malloc$2;
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("histogram.c", 601, sizeof(signed int) /*4ul*/  * (unsigned long int)hsize);
    y = (signed int *)return_value_sre_malloc$3;
    n = 0;
    sc = lowbound;
    for( ; highbound >= sc; sc = sc + 1)
    {
      x[(signed long int)(sc - lowbound)] = (float)((double)(float)sc + 0.5);
      y[(signed long int)(sc - lowbound)] = h->histogram[(signed long int)(sc - h->min)];
      n = n + h->histogram[(signed long int)(sc - h->min)];
    }
    if(!(n >= 100))
      goto FITFAILED;

    if(!(censor == 0))
    {
      if(iteration == 0)
      {
        if(!(h->total + -n >= (signed int)(0.58198 * (double)(float)n)))
          tmp_if_expr$4 = h->total - n;

        else
          tmp_if_expr$4 = (signed int)(0.58198 * (double)(float)n);
        z = tmp_if_expr$4;
      }

      else
      {
        double psx;
        psx=EVDDistribution((float)lowbound, mu, lambda);
        if(!(h->total + -n >= (signed int)(((double)n * psx) / (1. + -psx))))
          tmp_if_expr$5 = h->total - n;

        else
          tmp_if_expr$5 = (signed int)(((double)n * psx) / (1. - psx));
        z = tmp_if_expr$5;
      }
    }

    if(!(censor == 0))
    {
      signed int return_value_EVDCensoredFit$6;
      return_value_EVDCensoredFit$6=EVDCensoredFit(x, y, hsize, z, (float)lowbound, &mu, &lambda);
      if(return_value_EVDCensoredFit$6 == 0)
        goto FITFAILED;

    }

    else
    {
      return_value_EVDMaxLikelyFit$7=EVDMaxLikelyFit(x, y, hsize, &mu, &lambda);
      if(return_value_EVDMaxLikelyFit$7 == 0)
        goto FITFAILED;

    }
    double return_value_log$8;
    return_value_log$8=log((double)((n + z) - 1) / (double)(n + z));
    double return_value_log$9;
    return_value_log$9=log(-1. * return_value_log$8);
    new_highbound = (signed int)((double)mu - return_value_log$9 / (double)lambda);
    free((void *)x);
    free((void *)y);
    if(new_highbound >= highbound)
      break;

    highbound = new_highbound;
  }
  ExtremeValueSetHistogram(h, mu, lambda, (float)lowbound, (float)highbound, 1);
  return 1;

FITFAILED:
  ;
  UnfitHistogram(h);
  if(!(x == ((float *)NULL)))
    free((void *)x);

  if(!(y == ((signed int *)NULL)))
    free((void *)y);

  return 0;
}

// ExtremeValueP
// file histogram.c line 928
extern double ExtremeValueP(float x, float mu, float lambda)
{
  double y;
  double return_value_log$1;
  return_value_log$1=log((double)2.22044604925031308085e-16L);
  double return_value_log$2;
  return_value_log$2=log(-1. * return_value_log$1);
  double return_value_exp$3;
  if((double)(lambda * (x + -mu)) <= -1.000000 * return_value_log$2)
    return 1.0;

  else
    if((double)(lambda * (x + -mu)) >= 7.084000e+2)
      return 0.0;

    else
    {
      y=exp(-1. * (double)lambda * (double)(x - mu));
      if(y < 1e-7)
        return y;

      else
      {
        return_value_exp$3=exp(-1. * y);
        return 1.0 - return_value_exp$3;
      }
    }
}

// ExtremeValueP2
// file histogram.c line 957
extern double ExtremeValueP2(float x, float mu, float lambda, signed int N)
{
  double y;
  double return_value_ExtremeValueP$1;
  return_value_ExtremeValueP$1=ExtremeValueP(x, mu, lambda);
  y = (double)N * return_value_ExtremeValueP$1;
  double return_value_exp$2;
  if(y < 1e-7)
    return y;

  else
  {
    return_value_exp$2=exp(-1. * y);
    return 1.0 - return_value_exp$2;
  }
}

// ExtremeValueSetHistogram
// file histogram.c line 682
extern void ExtremeValueSetHistogram(struct histogram_s *h, float mu, float lambda, float lowbound, float highbound, signed int ndegrees)
{
  signed int sc;
  signed int hsize;
  signed int idx;
  signed int nbins;
  float delta;
  UnfitHistogram(h);
  h->fit_type = 1;
  h->param[(signed long int)1] = lambda;
  h->param[(signed long int)0] = mu;
  hsize = (h->max - h->min) + 1;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("histogram.c", 696, sizeof(float) /*4ul*/  * (unsigned long int)hsize);
  h->expect = (float *)return_value_sre_malloc$1;
  idx = 0;
  for( ; !(idx >= hsize); idx = idx + 1)
    h->expect[(signed long int)idx] = (float)0.;
  sc = h->min;
  double return_value_ExtremeValueE$2;
  double return_value_ExtremeValueE$3;
  for( ; h->max >= sc; sc = sc + 1)
  {
    return_value_ExtremeValueE$2=ExtremeValueE((float)sc, h->param[(signed long int)0], h->param[(signed long int)1], h->total);
    return_value_ExtremeValueE$3=ExtremeValueE((float)(sc + 1), h->param[(signed long int)0], h->param[(signed long int)1], h->total);
    h->expect[(signed long int)(sc - h->min)] = (float)(return_value_ExtremeValueE$2 - return_value_ExtremeValueE$3);
  }
  h->chisq = (float)0.;
  nbins = 0;
  sc = (signed int)lowbound;
  for( ; (float)sc <= highbound; sc = sc + 1)
    if(h->expect[(signed long int)(sc + -h->min)] >= 5.000000f)
    {
      if(h->histogram[(signed long int)(sc + -h->min)] >= 5)
      {
        delta = (float)h->histogram[(signed long int)(sc - h->min)] - h->expect[(signed long int)(sc - h->min)];
        h->chisq = h->chisq + (delta * delta) / h->expect[(signed long int)(sc - h->min)];
        nbins = nbins + 1;
      }

    }

  double return_value_IncompleteGamma$4;
  if(!(1 + ndegrees >= nbins))
  {
    return_value_IncompleteGamma$4=IncompleteGamma((double)((nbins - 1) - ndegrees) / 2., (double)h->chisq / 2.);
    h->chip = (float)return_value_IncompleteGamma$4;
  }

  else
    h->chip = (float)0.;
}

// FAdd
// file ../squid/vectorops.h line 15
extern void FAdd(float *vec1, float *vec2, signed int n)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec1[(signed long int)x] = vec1[(signed long int)x] + vec2[(signed long int)x];
}

// FArgMax
// file ../squid/vectorops.h line 25
extern signed int FArgMax(float *vec, signed int n)
{
  signed int i;
  signed int best = 0;
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] > vec[(signed long int)best])
      best = i;

  return best;
}

// FArgMin
// file vectorops.c line 204
extern signed int FArgMin(float *vec, signed int n)
{
  signed int i;
  signed int best = 0;
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] < vec[(signed long int)best])
      best = i;

  return best;
}

// FChoose
// file ../squid/sre_random.h line 14
extern signed int FChoose(float *p, signed int N)
{
  float roll;
  float sum;
  signed int i;
  double return_value_sre_random$1;
  return_value_sre_random$1=sre_random();
  roll = (float)return_value_sre_random$1;
  sum = (float)0.0;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    sum = sum + p[(signed long int)i];
    if(roll < sum)
      return i;

  }
  double return_value_sre_random$2;
  return_value_sre_random$2=sre_random();
  return (signed int)(return_value_sre_random$2 * (double)N);
}

// FCopy
// file ../squid/vectorops.h line 17
extern void FCopy(float *vec1, float *vec2, signed int n)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec1[(signed long int)x] = vec2[(signed long int)x];
}

// FDot
// file ../squid/vectorops.h line 19
extern float FDot(float *vec1, float *vec2, signed int n)
{
  float result = (float)0.;
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    result = result + vec1[(signed long int)x] * vec2[(signed long int)x];
  return result;
}

// FExp
// file vectorops.c line 262
extern void FExp(float *vec, signed int n)
{
  signed int x = 0;
  double return_value_exp$1;
  for( ; !(x >= n); x = x + 1)
  {
    return_value_exp$1=exp((double)vec[(signed long int)x]);
    vec[(signed long int)x] = (float)return_value_exp$1;
  }
}

// FLog
// file vectorops.c line 246
extern void FLog(float *vec, signed int n)
{
  signed int x = 0;
  double return_value_log$1;
  for( ; !(x >= n); x = x + 1)
    if(vec[(signed long int)x] > 0.000000f)
    {
      return_value_log$1=log((double)vec[(signed long int)x]);
      vec[(signed long int)x] = (float)return_value_log$1;
    }

    else
      vec[(signed long int)x] = -3.40282346638528859812e+38F;
}

// FLogSum
// file vectorops.c line 284
extern float FLogSum(float *vec, signed int n)
{
  signed int x;
  float max;
  float sum;
  max=FMax(vec, n);
  sum = (float)0.0;
  x = 0;
  double return_value_exp$1;
  for( ; !(x >= n); x = x + 1)
    if((double)vec[(signed long int)x] > (double)max + -50.000000)
    {
      return_value_exp$1=exp((double)(vec[(signed long int)x] - max));
      sum = sum + (float)return_value_exp$1;
    }

  double return_value_log$2;
  return_value_log$2=log((double)sum);
  sum = (float)(return_value_log$2 + (double)max);
  return sum;
}

// FMX2Alloc
// file sqfuncs.h line 202
extern float ** FMX2Alloc(signed int rows, signed int cols)
{
  float **mx;
  signed int r;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("sre_math.c", 172, sizeof(float *) /*8ul*/  * (unsigned long int)rows);
  mx = (float **)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("sre_math.c", 173, sizeof(float) /*4ul*/  * (unsigned long int)rows * (unsigned long int)cols);
  mx[(signed long int)0] = (float *)return_value_sre_malloc$2;
  r = 1;
  for( ; !(r >= rows); r = r + 1)
    mx[(signed long int)r] = mx[(signed long int)0] + (signed long int)(r * cols);
  return mx;
}

// FMX2Free
// file sre_math.c line 179
extern void FMX2Free(float **mx)
{
  free((void *)mx[(signed long int)0]);
  free((void *)mx);
}

// FMX2Multiply
// file sre_math.c line 211
extern void FMX2Multiply(float **A, float **B, float **C, signed int m, signed int p, signed int n)
{
  signed int i;
  signed int j;
  signed int k;
  i = 0;
  for( ; !(i >= m); i = i + 1)
  {
    j = 0;
    for( ; !(j >= n); j = j + 1)
    {
      C[(signed long int)i][(signed long int)j] = (float)0.;
      k = 0;
      for( ; !(k >= p); k = k + 1)
        C[(signed long int)i][(signed long int)j] = C[(signed long int)i][(signed long int)j] + A[(signed long int)i][(signed long int)p] * B[(signed long int)p][(signed long int)j];
    }
  }
}

// FMax
// file vectorops.c line 136
extern float FMax(float *vec, signed int n)
{
  signed int i;
  float best = vec[(signed long int)0];
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] > best)
      best = vec[(signed long int)i];

  return best;
}

// FMin
// file vectorops.c line 160
extern float FMin(float *vec, signed int n)
{
  signed int i;
  float best = vec[(signed long int)0];
  i = 1;
  for( ; !(i >= n); i = i + 1)
    if(vec[(signed long int)i] < best)
      best = vec[(signed long int)i];

  return best;
}

// FNorm
// file ../squid/vectorops.h line 29
extern void FNorm(float *vec, signed int n)
{
  signed int x;
  float sum;
  sum=FSum(vec, n);
  if(IEEE_FLOAT_NOTEQUAL((double)sum, 0.0))
  {
    x = 0;
    for( ; !(x >= n); x = x + 1)
      vec[(signed long int)x] = vec[(signed long int)x] / sum;
  }

  else
  {
    x = 0;
    for( ; !(x >= n); x = x + 1)
      vec[(signed long int)x] = (float)(1. / (double)(float)n);
  }
}

// FScale
// file ../squid/vectorops.h line 11
extern void FScale(float *vec, signed int n, float scale)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec[(signed long int)x] = vec[(signed long int)x] * scale;
}

// FSet
// file ../squid/vectorops.h line 9
extern void FSet(float *vec, signed int n, float value)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    vec[(signed long int)x] = value;
}

// FSum
// file ../squid/vectorops.h line 13
extern float FSum(float *vec, signed int n)
{
  float sum = (float)0.;
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    sum = sum + vec[(signed long int)x];
  return sum;
}

// FileAddSuffix
// file file.c line 187
extern char * FileAddSuffix(char *filename, char *sfx)
{
  char *new;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(filename);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(sfx);
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("file.c", 190, return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)2);
  new = (char *)return_value_sre_malloc$3;
  sprintf(new, "%s.%s", filename, sfx);
  return new;
}

// FileConcat
// file ../squid/sqfuncs.h line 79
extern char * FileConcat(char *dir, char *file)
{
  char *full;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(dir);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(file);
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("file.c", 170, sizeof(char) /*1ul*/  * (return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)2));
  full = (char *)return_value_sre_malloc$3;
  if((signed int)*file == 47)
    strcpy(full, file);

  else
    sprintf(full, "%s%c%s", dir, 47, file);
  return full;
}

// FileDirname
// file file.c line 65
extern char * FileDirname(char *file)
{
  char *dirname;
  char *lastslash;
  signed int len;
  lastslash=strrchr(file, 47);
  len = lastslash == (char *)(void *)0 ? 0 : (signed int)(lastslash - file);
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("file.c", 73, sizeof(char) /*1ul*/  * (unsigned long int)(len + 2));
  dirname = (char *)return_value_sre_malloc$1;
  if(len >= 1)
    strncpy(dirname, file, (unsigned long int)len);

  else
    if(!((signed int)*file == 47))
    {
      *dirname = (char)46;
      len = 1;
    }

    else
    {
      *dirname = (char)47;
      len = 1;
    }
  dirname[(signed long int)len] = (char)0;
  return dirname;
}

// FileExists
// file ../squid/sqfuncs.h line 82
extern signed int FileExists(char *filename)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "r");
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    fclose(fp);
    return 1;
  }

  else
    return 0;
}

// FileSameDirectory
// file file.c line 139
extern char * FileSameDirectory(char *file1, char *file2)
{
  char *path;
  char *tail;
  char *result;
  signed int seems_ok = 1;
  path=FileDirname(file1);
  tail=FileTail(file2, 0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(file2, tail);
  if(!(return_value_strcmp$1 == 0))
    seems_ok = 0;

  result=FileConcat(path, tail);
  signed int return_value_strcmp$2;
  if(seems_ok == 0)
  {
    return_value_strcmp$2=strcmp(result, file2);
    if(!(return_value_strcmp$2 == 0))
    {
      free((void *)result);
      result = (char *)(void *)0;
    }

  }

  free((void *)path);
  free((void *)tail);
  return result;
}

// FileTail
// file file.c line 98
extern char * FileTail(char *file, signed int noextension)
{
  char *tail;
  char *lastslash;
  char *lastdot;
  lastslash=strrchr(file, 47);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(file);
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("file.c", 105, sizeof(char) /*1ul*/  * (return_value_strlen$1 + (unsigned long int)1));
  tail = (char *)return_value_sre_malloc$2;
  if(lastslash == ((char *)NULL))
    strcpy(tail, file);

  else
    strcpy(tail, lastslash + (signed long int)1);
  if(!(noextension == 0))
  {
    lastdot=strrchr(tail, 46);
    if(!(lastdot == ((char *)NULL)))
      *lastdot = (char)0;

  }

  return tail;
}

// FilterAlignment
// file weight.c line 521
extern void FilterAlignment(struct msa_struct *msa, float cutoff, struct msa_struct **ret_new)
{
  signed int nnew;
  signed int *list;
  signed int *useme;
  float ident;
  signed int i;
  signed int j;
  signed int FilterAlignment$$1$$remove;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("weight.c", 532, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseq);
  list = (signed int *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("weight.c", 533, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseq);
  useme = (signed int *)return_value_sre_malloc$2;
  i = 0;
  for( ; !(i >= msa->nseq); i = i + 1)
    useme[(signed long int)i] = 0;
  nnew = 0;
  i = 0;
  signed int tmp_post$3;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    FilterAlignment$$1$$remove = 0;
    j = 0;
    for( ; !(j >= nnew); j = j + 1)
    {
      ident=PairwiseIdentity(msa->aseq[(signed long int)i], msa->aseq[(signed long int)list[(signed long int)j]]);
      if(ident > cutoff)
      {
        FilterAlignment$$1$$remove = 1;
        printf("removing %12s -- fractional identity %.2f to %s\n", msa->sqname[(signed long int)i], ident, msa->sqname[(signed long int)list[(signed long int)j]]);
        break;
      }

    }
    if(FilterAlignment$$1$$remove == 0)
    {
      tmp_post$3 = nnew;
      nnew = nnew + 1;
      list[(signed long int)tmp_post$3] = i;
      useme[(signed long int)i] = 1;
    }

  }
  MSASmallerAlignment(msa, useme, ret_new);
  free((void *)list);
  free((void *)useme);
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
}

// Free2DArray
// file ../squid/sqfuncs.h line 222
extern void Free2DArray(void **p, signed int dim1)
{
  signed int i;
  if(!(p == ((void **)NULL)))
  {
    i = 0;
    for( ; !(i >= dim1); i = i + 1)
      if(!(p[(signed long int)i] == NULL))
        free(p[(signed long int)i]);

    free((void *)p);
  }

}

// Free3DArray
// file sqfuncs.h line 223
extern void Free3DArray(void ***p, signed int dim1, signed int dim2)
{
  signed int i;
  signed int j;
  if(!(p == ((void ***)NULL)))
  {
    i = 0;
    for( ; !(i >= dim1); i = i + 1)
      if(!(p[(signed long int)i] == ((void **)NULL)))
      {
        j = 0;
        for( ; !(j >= dim2); j = j + 1)
          if(!(p[(signed long int)i][(signed long int)j] == NULL))
            free(p[(signed long int)i][(signed long int)j]);

        free((void *)p[(signed long int)i]);
      }

    free((void *)p);
  }

}

// FreeAlignment
// file alignio.c line 105
extern void FreeAlignment(char **aseqs, struct aliinfo_s *ainfo)
{
  signed int i = 0;
  for( ; !(i >= ainfo->nseq); i = i + 1)
  {
    if(!((512 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
      free((void *)(ainfo->sqinfo + (signed long int)i)->ss);

    if(!((1024 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
      free((void *)(ainfo->sqinfo + (signed long int)i)->sa);

  }
  if(!(ainfo->cs == ((char *)NULL)))
    free((void *)ainfo->cs);

  if(!(ainfo->rf == ((char *)NULL)))
    free((void *)ainfo->rf);

  if(!(ainfo->name == ((char *)NULL)))
    free((void *)ainfo->name);

  if(!(ainfo->desc == ((char *)NULL)))
    free((void *)ainfo->desc);

  if(!(ainfo->acc == ((char *)NULL)))
    free((void *)ainfo->acc);

  if(!(ainfo->au == ((char *)NULL)))
    free((void *)ainfo->au);

  free((void *)ainfo->sqinfo);
  free((void *)ainfo->wgt);
  Free2DArray((void **)aseqs, ainfo->nseq);
}

// FreeFancyAli
// file tophits.c line 124
extern void FreeFancyAli(struct fancyali_s *ali)
{
  if(!(ali == ((struct fancyali_s *)NULL)))
  {
    if(!(ali->rfline == ((char *)NULL)))
      free((void *)ali->rfline);

    if(!(ali->csline == ((char *)NULL)))
      free((void *)ali->csline);

    if(!(ali->model == ((char *)NULL)))
      free((void *)ali->model);

    if(!(ali->mline == ((char *)NULL)))
      free((void *)ali->mline);

    if(!(ali->aseq == ((char *)NULL)))
      free((void *)ali->aseq);

    if(!(ali->query == ((char *)NULL)))
      free((void *)ali->query);

    if(!(ali->target == ((char *)NULL)))
      free((void *)ali->target);

    free((void *)ali);
  }

}

// FreeHistogram
// file funcs.h line 123
extern void FreeHistogram(struct histogram_s *h)
{
  free((void *)h->histogram);
  if(!(h->expect == ((float *)NULL)))
    free((void *)h->expect);

  free((void *)h);
}

// FreeIntStack
// file sqfuncs.h line 239
extern signed int FreeIntStack(struct intstack_s *stack)
{
  signed int data;
  signed int count = 0;
  signed int return_value_PopIntStack$1;
  do
  {
    return_value_PopIntStack$1=PopIntStack(stack, &data);
    if(return_value_PopIntStack$1 == 0)
      break;

    count = count + 1;
  }
  while((_Bool)1);
  free((void *)stack);
  return count;
}

// FreePhylo
// file cluster.c line 360
extern void FreePhylo(struct phylo_s *tree, signed int N)
{
  signed int idx = 0;
  for( ; !(idx >= N + -1); idx = idx + 1)
    free((void *)(tree + (signed long int)idx)->is_in);
  free((void *)tree);
}

// FreePlan7
// file funcs.h line 215
extern void FreePlan7(struct plan7_s *hmm)
{
  if(!(hmm->name == ((char *)NULL)))
    free((void *)hmm->name);

  if(!(hmm->acc == ((char *)NULL)))
    free((void *)hmm->acc);

  if(!(hmm->desc == ((char *)NULL)))
    free((void *)hmm->desc);

  if(!(hmm->rf == ((char *)NULL)))
    free((void *)hmm->rf);

  if(!(hmm->cs == ((char *)NULL)))
    free((void *)hmm->cs);

  if(!(hmm->ca == ((char *)NULL)))
    free((void *)hmm->ca);

  if(!(hmm->comlog == ((char *)NULL)))
    free((void *)hmm->comlog);

  if(!(hmm->ctime == ((char *)NULL)))
    free((void *)hmm->ctime);

  if(!(hmm->map == ((signed int *)NULL)))
    free((void *)hmm->map);

  if(!(hmm->tpri == ((signed int *)NULL)))
    free((void *)hmm->tpri);

  if(!(hmm->mpri == ((signed int *)NULL)))
    free((void *)hmm->mpri);

  if(!(hmm->ipri == ((signed int *)NULL)))
    free((void *)hmm->ipri);

  if(!(hmm->bsc_mem == ((signed int *)NULL)))
    free((void *)hmm->bsc_mem);

  if(!(hmm->begin == ((float *)NULL)))
    free((void *)hmm->begin);

  if(!(hmm->esc_mem == ((signed int *)NULL)))
    free((void *)hmm->esc_mem);

  if(!(hmm->end == ((float *)NULL)))
    free((void *)hmm->end);

  if(!(hmm->msc_mem == ((signed int *)NULL)))
    free((void *)hmm->msc_mem);

  if(!(hmm->isc_mem == ((signed int *)NULL)))
    free((void *)hmm->isc_mem);

  if(!(hmm->tsc_mem == ((signed int *)NULL)))
    free((void *)hmm->tsc_mem);

  if(!(hmm->mat == ((float **)NULL)))
    free((void *)hmm->mat[(signed long int)0]);

  if(!(hmm->ins == ((float **)NULL)))
    free((void *)hmm->ins[(signed long int)0]);

  if(!(hmm->t == ((float **)NULL)))
    free((void *)hmm->t[(signed long int)0]);

  if(!(hmm->msc == ((signed int **)NULL)))
    free((void *)hmm->msc);

  if(!(hmm->isc == ((signed int **)NULL)))
    free((void *)hmm->isc);

  if(!(hmm->tsc == ((signed int **)NULL)))
    free((void *)hmm->tsc);

  if(!(hmm->mat == ((float **)NULL)))
    free((void *)hmm->mat);

  if(!(hmm->ins == ((float **)NULL)))
    free((void *)hmm->ins);

  if(!(hmm->t == ((float **)NULL)))
    free((void *)hmm->t);

  if(!(hmm->dnam == ((signed int **)NULL)))
    free((void *)hmm->dnam);

  if(!(hmm->dnai == ((signed int **)NULL)))
    free((void *)hmm->dnai);

  free((void *)hmm);
}

// FreePlan7Matrix
// file funcs.h line 48
extern void FreePlan7Matrix(struct dpmatrix_s *mx)
{
  free(mx->xmx_mem);
  free(mx->mmx_mem);
  free(mx->imx_mem);
  free(mx->dmx_mem);
  free((void *)mx->xmx);
  free((void *)mx->mmx);
  free((void *)mx->imx);
  free((void *)mx->dmx);
  free((void *)mx);
}

// FreeSequence
// file sqio.c line 329
extern void FreeSequence(char *seq, struct seqinfo_s *sqinfo)
{
  if(!(seq == ((char *)NULL)))
    free((void *)seq);

  if(!((512 & sqinfo->flags) == 0))
    free((void *)sqinfo->ss);

  if(!((1024 & sqinfo->flags) == 0))
    free((void *)sqinfo->sa);

}

// FreeShadowMatrix
// file core_algorithms.c line 287
extern void FreeShadowMatrix(struct dpshadow_s *tb)
{
  free((void *)tb->xtb[(signed long int)0]);
  free((void *)tb->mtb[(signed long int)0]);
  free((void *)tb->itb[(signed long int)0]);
  free((void *)tb->dtb[(signed long int)0]);
  free((void *)tb->esrc);
  free((void *)tb->xtb);
  free((void *)tb->mtb);
  free((void *)tb->itb);
  free((void *)tb->dtb);
  free((void *)tb);
}

// FreeTophits
// file tophits.c line 97
extern void FreeTophits(struct tophit_s *h)
{
  signed int pos = 0;
  for( ; !(pos >= h->num); pos = pos + 1)
  {
    if(!((h->unsrt + (signed long int)pos)->ali == ((struct fancyali_s *)NULL)))
      FreeFancyAli((h->unsrt + (signed long int)pos)->ali);

    if(!((h->unsrt + (signed long int)pos)->name == ((char *)NULL)))
      free((void *)(h->unsrt + (signed long int)pos)->name);

    if(!((h->unsrt + (signed long int)pos)->acc == ((char *)NULL)))
      free((void *)(h->unsrt + (signed long int)pos)->acc);

    if(!((h->unsrt + (signed long int)pos)->desc == ((char *)NULL)))
      free((void *)(h->unsrt + (signed long int)pos)->desc);

  }
  free((void *)h->unsrt);
  if(!(h->hit == ((struct hit_s **)NULL)))
    free((void *)h->hit);

  free((void *)h);
}

// FullSortTophits
// file tophits.c line 289
extern void FullSortTophits(struct tophit_s *h)
{
  signed int i;
  if(!(h->num == 0))
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("tophits.c", 300, (unsigned long int)h->num * sizeof(struct hit_s *) /*8ul*/ );
    h->hit = (struct hit_s **)return_value_sre_malloc$1;
    i = 0;
    for( ; !(i >= h->num); i = i + 1)
      h->hit[(signed long int)i] = &h->unsrt[(signed long int)i];
    if(h->num >= 2)
      qsort((void *)h->hit, (unsigned long int)h->num, sizeof(struct hit_s *) /*8ul*/ , hit_comparison);

  }

}

// GCGBinaryToSequence
// file sqio.c line 1299
extern signed int GCGBinaryToSequence(char *seq, signed int len)
{
  signed int bpos;
  signed int spos;
  char twobit;
  signed int i;
  bpos = (len - 1) / 4;
  for( ; bpos >= 0; bpos = bpos - 1)
  {
    twobit = seq[(signed long int)bpos];
    spos = bpos * 4;
    i = 3;
    for( ; i >= 0; i = i - 1)
    {
      switch((signed int)twobit & 0x3)
      {
        case 0:
        {
          seq[(signed long int)(spos + i)] = (char)67;
          break;
        }
        case 1:
        {
          seq[(signed long int)(spos + i)] = (char)84;
          break;
        }
        case 2:
        {
          seq[(signed long int)(spos + i)] = (char)65;
          break;
        }
        case 3:
          seq[(signed long int)(spos + i)] = (char)71;
      }
      twobit = (char)((signed int)twobit >> 2);
    }
  }
  seq[(signed long int)len] = (char)0;
  return 1;
}

// GCGMultchecksum
// file sqfuncs.h line 176
extern signed int GCGMultchecksum(char **seqs, signed int nseq)
{
  signed int chk = 0;
  signed int idx = 0;
  unsigned long int return_value_strlen$1;
  signed int return_value_GCGchecksum$2;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    return_value_strlen$1=strlen(seqs[(signed long int)idx]);
    return_value_GCGchecksum$2=GCGchecksum(seqs[(signed long int)idx], (signed int)return_value_strlen$1);
    chk = (chk + return_value_GCGchecksum$2) % 10000;
  }
  return chk;
}

// GCGchecksum
// file sqfuncs.h line 175
extern signed int GCGchecksum(char *seq, signed int len)
{
  signed int i;
  signed int chk = 0;
  i = 0;
  signed int return_value_sre_toupper$1;
  for( ; !(i >= len); i = i + 1)
  {
    return_value_sre_toupper$1=sre_toupper((signed int)seq[(signed long int)i]);
    chk = (chk + (i % 57 + 1) * return_value_sre_toupper$1) % 10000;
  }
  return chk;
}

// GKIFree
// file gki.c line 135
void GKIFree(struct anonymous$0 *hash)
{
  struct gki_elem *ptr;
  signed int i;
  if(!(hash == ((struct anonymous$0 *)NULL)))
  {
    i = 0;
    for( ; !(i >= hash->nhash); i = i + 1)
      for( ; !(hash->table[(signed long int)i] == ((struct gki_elem *)NULL)); hash->table[(signed long int)i] = ptr)
      {
        ptr = hash->table[(signed long int)i]->nxt;
        if(!(hash->table[(signed long int)i]->key == ((char *)NULL)))
          free((void *)hash->table[(signed long int)i]->key);

        free((void *)hash->table[(signed long int)i]);
      }
    free((void *)hash->table);
    free((void *)hash);
  }

}

// GKIInit
// file gki.c line 117
struct anonymous$0 * GKIInit(void)
{
  struct anonymous$0 *hash;
  hash=gki_alloc(0);
  return hash;
}

// GKIKeyIndex
// file gki.c line 219
signed int GKIKeyIndex(struct anonymous$0 *hash, char *key)
{
  struct gki_elem *ptr;
  signed int val;
  val=gki_hashvalue(hash, key);
  ptr = hash->table[(signed long int)val];
  signed int return_value_strcmp$1;
  for( ; !(ptr == ((struct gki_elem *)NULL)); ptr = ptr->nxt)
  {
    return_value_strcmp$1=strcmp(key, ptr->key);
    if(return_value_strcmp$1 == 0)
      return ptr->idx;

  }
  return -1;
}

// GKIStatus
// file gki.c line 243
void GKIStatus(struct anonymous$0 *hash)
{
  struct gki_elem *ptr;
  signed int i;
  signed int nkeys;
  signed int nempty = 0;
  signed int maxkeys = -1;
  signed int minkeys = 0x7fffffff;
  i = 0;
  for( ; !(i >= hash->nhash); i = i + 1)
  {
    nkeys = 0;
    ptr = hash->table[(signed long int)i];
    for( ; !(ptr == ((struct gki_elem *)NULL)); ptr = ptr->nxt)
      nkeys = nkeys + 1;
    if(nkeys == 0)
      nempty = nempty + 1;

    if(!(maxkeys >= nkeys))
      maxkeys = nkeys;

    if(!(nkeys >= minkeys))
      minkeys = nkeys;

  }
  printf("Total keys:        %d\n", hash->nkeys);
  printf("Hash table size:   %d\n", hash->nhash);
  printf("Average occupancy: %.1f\n", (float)hash->nkeys / (float)hash->nhash);
  printf("Unoccupied slots:  %d\n", nempty);
  printf("Most in one slot:  %d\n", maxkeys);
  printf("Least in one slot: %d\n", minkeys);
}

// GKIStoreKey
// file gki.h line 47
signed int GKIStoreKey(struct anonymous$0 *hash, char *key)
{
  signed int val;
  struct gki_elem *ptr;
  val=gki_hashvalue(hash, key);
  ptr = hash->table[(signed long int)val];
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("gki.c", 189, sizeof(struct gki_elem) /*24ul*/ );
  hash->table[(signed long int)val] = (struct gki_elem *)return_value_sre_malloc$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(key);
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("gki.c", 190, sizeof(char) /*1ul*/  * (return_value_strlen$2 + (unsigned long int)1));
  hash->table[(signed long int)val]->key = (char *)return_value_sre_malloc$3;
  strcpy(hash->table[(signed long int)val]->key, key);
  hash->table[(signed long int)val]->idx = hash->nkeys;
  hash->table[(signed long int)val]->nxt = ptr;
  hash->nkeys = hash->nkeys + 1;
  if(!(3 * hash->nhash >= hash->nkeys))
  {
    if(!(hash->primelevel >= 4))
      gki_upsize(hash);

  }

  return hash->nkeys - 1;
}

// GSCWeights
// file weight.c line 46
extern void GSCWeights(char **aseq, signed int nseq, signed int alen, float *wgt)
{
  float **dmx;
  struct phylo_s *tree;
  float *lwt;
  float *rwt;
  float *fwt;
  signed int i;
  if(nseq == 1)
    wgt[(signed long int)0] = (float)1.0;

  else
  {
    MakeDiffMx(aseq, nseq, &dmx);
    signed int return_value_Cluster$1;
    return_value_Cluster$1=Cluster(dmx, nseq, (enum clust_strategy)CLUSTER_MIN, &tree);
    if(return_value_Cluster$1 == 0)
      Die("Cluster() failed");

    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("weight.c", 67, sizeof(float) /*4ul*/  * (unsigned long int)(2 * nseq - 1));
    lwt = (float *)return_value_sre_malloc$2;
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("weight.c", 68, sizeof(float) /*4ul*/  * (unsigned long int)(2 * nseq - 1));
    rwt = (float *)return_value_sre_malloc$3;
    void *return_value_sre_malloc$4;
    return_value_sre_malloc$4=sre_malloc("weight.c", 69, sizeof(float) /*4ul*/  * (unsigned long int)(2 * nseq - 1));
    fwt = (float *)return_value_sre_malloc$4;
    i = 0;
    for( ; !(i >= nseq); i = i + 1)
    {
      rwt[(signed long int)i] = (float)0.0;
      lwt[(signed long int)i] = rwt[(signed long int)i];
    }
    upweight(tree, nseq, lwt, rwt, nseq);
    fwt[(signed long int)nseq] = (float)nseq;
    downweight(tree, nseq, lwt, rwt, fwt, nseq);
    i = 0;
    for( ; !(i >= nseq); i = i + 1)
      wgt[(signed long int)i] = fwt[(signed long int)i];
    FMX2Free(dmx);
    FreePhylo(tree, nseq);
    free((void *)lwt);
    free((void *)rwt);
    free((void *)fwt);
  }
}

// GSIAddFileToIndex
// file gsi.c line 219
extern void GSIAddFileToIndex(struct gsiindex_s *g, char *filename, signed int fmt)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(filename);
  len = (signed int)return_value_strlen$1;
  if(len >= 32)
    Die("File name too long to be indexed.");

  g->filenames[(signed long int)g->nfiles]=sre_strdup(filename, len);
  g->fmt[(signed long int)g->nfiles] = fmt;
  g->nfiles = g->nfiles + 1;
  if((signed int)g->nfiles % 10 == 0)
  {
    void *return_value_sre_realloc$2;
    return_value_sre_realloc$2=sre_realloc("gsi.c", 229, (void *)g->filenames, sizeof(char *) /*8ul*/  * (unsigned long int)((signed int)g->nfiles + 10));
    g->filenames = (char **)return_value_sre_realloc$2;
    void *return_value_sre_realloc$3;
    return_value_sre_realloc$3=sre_realloc("gsi.c", 230, (void *)g->fmt, sizeof(signed int) /*4ul*/  * (unsigned long int)((signed int)g->nfiles + 10));
    g->fmt = (signed int *)return_value_sre_realloc$3;
  }

}

// GSIAddKeyToIndex
// file gsi.c line 234
extern void GSIAddKeyToIndex(struct gsiindex_s *g, char *key, signed int filenum, signed long int offset)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(key);
  if(return_value_strlen$1 >= 32ul)
    Die("key too long in GSI index");

  if(filenum >= 65536)
    Die("too many files in GSI index");

  if(offset >= 4294967296l)
    Die("offset too big in GSI index");

  strncpy((g->elems + (signed long int)g->nkeys)->key, key, (unsigned long int)(32 - 1));
  (g->elems + (signed long int)g->nkeys)->key[(signed long int)(32 - 1)] = (char)0;
  (g->elems + (signed long int)g->nkeys)->filenum = (unsigned short int)filenum;
  (g->elems + (signed long int)g->nkeys)->offset = (unsigned int)offset;
  g->nkeys = g->nkeys + 1;
  void *return_value_sre_realloc$2;
  if(g->nkeys % 100 == 0)
  {
    return_value_sre_realloc$2=sre_realloc("gsi.c", 247, (void *)g->elems, sizeof(struct gsikey_s) /*40ul*/  * (unsigned long int)(g->nkeys + 100));
    g->elems = (struct gsikey_s *)return_value_sre_realloc$2;
  }

}

// GSIAllocIndex
// file gsi.c line 196
extern struct gsiindex_s * GSIAllocIndex(void)
{
  struct gsiindex_s *g;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("gsi.c", 200, sizeof(struct gsiindex_s) /*40ul*/ );
  g = (struct gsiindex_s *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("gsi.c", 201, sizeof(char *) /*8ul*/  * (unsigned long int)10);
  g->filenames = (char **)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("gsi.c", 202, sizeof(signed int) /*4ul*/  * (unsigned long int)10);
  g->fmt = (signed int *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("gsi.c", 203, sizeof(struct gsikey_s) /*40ul*/  * (unsigned long int)100);
  g->elems = (struct gsikey_s *)return_value_sre_malloc$4;
  g->nfiles = (unsigned short int)0;
  g->nkeys = 0;
  return g;
}

// GSIClose
// file gsi.c line 171
extern void GSIClose(struct gsi_s *gsi)
{
  fclose(gsi->gsifp);
  free((void *)gsi);
}

// GSIFreeIndex
// file gsi.c line 209
extern void GSIFreeIndex(struct gsiindex_s *g)
{
  signed int i = 0;
  for( ; !(i >= (signed int)g->nfiles); i = i + 1)
    free((void *)g->filenames[(signed long int)i]);
  free((void *)g->filenames);
  free((void *)g->fmt);
  free((void *)g->elems);
  free((void *)g);
}

// GSIGetOffset
// file gsi.c line 128
extern signed int GSIGetOffset(struct gsi_s *gsi, char *key, char *ret_seqfile, signed int *ret_format, signed long int *ret_offset)
{
  unsigned int left;
  unsigned int right;
  unsigned int mid;
  signed int cmp;
  char name[33l];
  unsigned int offset;
  unsigned short int filenum;
  unsigned int fmt;
  name[(signed long int)32] = (char)0;
  left = (unsigned int)((signed int)gsi->nfiles + 1);
  right = (unsigned int)gsi->nfiles + gsi->recnum;
  mid = (left + right) / (unsigned int)2;
  fseek(gsi->gsifp, (signed long int)(mid * (unsigned int)38), 0);
  signed int return_value_GSIGetRecord$1;
  do
  {
    return_value_GSIGetRecord$1=GSIGetRecord(gsi, name, &filenum, &offset);
    if(return_value_GSIGetRecord$1 == 0)
      break;

    cmp=strcmp(name, key);
    if(cmp == 0)
      break;

    else
      if(left >= right)
        return 0;

      else
        if(!(cmp >= 0))
          left = mid + (unsigned int)1;

        else
          if(cmp >= 1)
            right = mid - (unsigned int)1;

    mid = (left + right) / (unsigned int)2;
    fseek(gsi->gsifp, (signed long int)(mid * (unsigned int)38), 0);
  }
  while((_Bool)1);
  fseek(gsi->gsifp, (signed long int)((signed int)filenum * 38), 0);
  GSIGetRecord(gsi, ret_seqfile, (unsigned short int *)(void *)0, &fmt);
  *ret_format = (signed int)fmt;
  *ret_offset = (signed long int)offset;
  return 1;
}

// GSIGetRecord
// file gsi.c line 93
extern signed int GSIGetRecord(struct gsi_s *gsi, char *f1, unsigned short int *f2, unsigned int *f3)
{
  unsigned long int return_value_fread$1;
  if(f1 == ((char *)NULL))
    fseek(gsi->gsifp, (signed long int)32, 1);

  else
  {
    return_value_fread$1=fread((void *)f1, (unsigned long int)32, (unsigned long int)1, gsi->gsifp);
    if(return_value_fread$1 == 0ul)
    {
      squid_errno = 2;
      return 0;
    }

  }
  unsigned long int return_value_fread$2;
  if(f2 == ((unsigned short int *)NULL))
    fseek(gsi->gsifp, (signed long int)sizeof(unsigned short int) /*2ul*/ , 1);

  else
  {
    return_value_fread$2=fread((void *)f2, sizeof(unsigned short int) /*2ul*/ , (unsigned long int)1, gsi->gsifp);
    if(return_value_fread$2 == 0ul)
    {
      squid_errno = 2;
      return 0;
    }

  }
  unsigned long int return_value_fread$3;
  if(f3 == ((unsigned int *)NULL))
    fseek(gsi->gsifp, (signed long int)sizeof(unsigned int) /*4ul*/ , 1);

  else
  {
    return_value_fread$3=fread((void *)f3, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, gsi->gsifp);
    if(return_value_fread$3 == 0ul)
    {
      squid_errno = 2;
      return 0;
    }

  }
  if(!(f2 == ((unsigned short int *)NULL)))
    *f2=sre_ntoh16(*f2);

  if(!(f3 == ((unsigned int *)NULL)))
    *f3=sre_ntoh32(*f3);

  return 1;
}

// GSIOpen
// file gsi.c line 53
extern struct gsi_s * GSIOpen(char *gsifile)
{
  struct gsi_s *gsi;
  char magic[32l];
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("gsi.c", 58, sizeof(struct gsi_s) /*16ul*/ );
  gsi = (struct gsi_s *)return_value_sre_malloc$1;
  gsi->gsifp=fopen(gsifile, "r");
  if(gsi->gsifp == ((struct _IO_FILE *)NULL))
  {
    free((void *)gsi);
    squid_errno = 4;
    return (struct gsi_s *)(void *)0;
  }

  else
  {
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)magic, sizeof(char) /*1ul*/ , (unsigned long int)32, gsi->gsifp);
    if(return_value_fread$2 == 0ul)
    {
      free((void *)gsi);
      squid_errno = 2;
      return (struct gsi_s *)(void *)0;
    }

    else
    {
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(magic, "GSI");
      if(!(return_value_strcmp$3 == 0))
      {
        free((void *)gsi);
        squid_errno = 5;
        return (struct gsi_s *)(void *)0;
      }

      else
      {
        unsigned long int return_value_fread$4;
        return_value_fread$4=fread((void *)&gsi->nfiles, sizeof(unsigned short int) /*2ul*/ , (unsigned long int)1, gsi->gsifp);
        if(return_value_fread$4 == 0ul)
        {
          free((void *)gsi);
          squid_errno = 2;
          return (struct gsi_s *)(void *)0;
        }

        else
        {
          unsigned long int return_value_fread$5;
          return_value_fread$5=fread((void *)&gsi->recnum, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, gsi->gsifp);
          if(return_value_fread$5 == 0ul)
          {
            free((void *)gsi);
            squid_errno = 2;
            return (struct gsi_s *)(void *)0;
          }

          else
          {
            gsi->nfiles=sre_ntoh16(gsi->nfiles);
            gsi->recnum=sre_ntoh32(gsi->recnum);
            return gsi;
          }
        }
      }
    }
  }
}

// GSISortIndex
// file gsi.c line 259
extern void GSISortIndex(struct gsiindex_s *g)
{
  qsort((void *)g->elems, (unsigned long int)g->nkeys, sizeof(struct gsikey_s) /*40ul*/ , gsi_keysorter);
}

// GSIWriteFileRecord
// file gsi.c line 333
extern signed int GSIWriteFileRecord(struct _IO_FILE *fp, char *fname, signed int idx, signed int fmt)
{
  unsigned short int f1;
  unsigned int f2;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(fname);
  if(return_value_strlen$1 >= 32ul)
    return 0;

  else
  {
    if(idx >= 65536)
      Die("GSI: file index out of range");

    f1 = (unsigned short int)idx;
    f2 = (unsigned int)fmt;
    f1=sre_hton16(f1);
    f2=sre_hton32(f2);
    unsigned long int return_value_fwrite$2;
    return_value_fwrite$2=fwrite((const void *)fname, (unsigned long int)1, (unsigned long int)32, fp);
    if(!(return_value_fwrite$2 >= 32ul))
      Panic("gsi.c", 347);

    unsigned long int return_value_fwrite$3;
    return_value_fwrite$3=fwrite((const void *)&f1, (unsigned long int)2, (unsigned long int)1, fp);
    if(!(return_value_fwrite$3 >= 1ul))
      Panic("gsi.c", 348);

    unsigned long int return_value_fwrite$4;
    return_value_fwrite$4=fwrite((const void *)&f2, (unsigned long int)4, (unsigned long int)1, fp);
    if(!(return_value_fwrite$4 >= 1ul))
      Panic("gsi.c", 349);

    return 1;
  }
}

// GSIWriteHeader
// file gsi.c line 297
extern void GSIWriteHeader(struct _IO_FILE *fp, signed int nfiles, signed long int nkeys)
{
  char key[32l];
  unsigned short int f1;
  unsigned int f2;
  if(nfiles >= 65536)
    Die("GSI: nfiles out of range");

  if(nkeys >= 4294967296l)
    Die("GSI: nkeys out of range");

  f1 = (unsigned short int)nfiles;
  f2 = (unsigned int)nkeys;
  f1=sre_hton16(f1);
  f2=sre_hton32(f2);
  strcpy(key, "GSI");
  unsigned long int return_value_fwrite$1;
  return_value_fwrite$1=fwrite((const void *)key, (unsigned long int)1, (unsigned long int)32, fp);
  if(!(return_value_fwrite$1 >= 32ul))
    Panic("gsi.c", 314);

  unsigned long int return_value_fwrite$2;
  return_value_fwrite$2=fwrite((const void *)&f1, (unsigned long int)2, (unsigned long int)1, fp);
  if(!(return_value_fwrite$2 >= 1ul))
    Panic("gsi.c", 315);

  unsigned long int return_value_fwrite$3;
  return_value_fwrite$3=fwrite((const void *)&f2, (unsigned long int)4, (unsigned long int)1, fp);
  if(!(return_value_fwrite$3 >= 1ul))
    Panic("gsi.c", 316);

}

// GSIWriteIndex
// file gsi.c line 264
extern void GSIWriteIndex(struct _IO_FILE *fp, struct gsiindex_s *g)
{
  unsigned int i;
  if((signed int)g->nfiles >= 65536)
    Die("Too many files in GSI index.");

  GSIWriteHeader(fp, (signed int)g->nfiles, (signed long int)g->nkeys);
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)g->nfiles); i = i + 1u)
    GSIWriteFileRecord(fp, g->filenames[(signed long int)i], (signed int)(i + (unsigned int)1), g->fmt[(signed long int)i]);
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)g->nkeys); i = i + 1u)
    GSIWriteKeyRecord(fp, (g->elems + (signed long int)i)->key, (signed int)(g->elems + (signed long int)i)->filenum, (signed long int)(g->elems + (signed long int)i)->offset);
}

// GSIWriteKeyRecord
// file gsi.c line 368
extern signed int GSIWriteKeyRecord(struct _IO_FILE *fp, char *key, signed int fileidx, signed long int offset)
{
  unsigned short int f1;
  unsigned int f2;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(key);
  if(return_value_strlen$1 >= 32ul)
    return 0;

  else
  {
    if(fileidx >= 65536)
      Die("GSI: file index out of range");

    if(offset >= 4294967296l)
      Die("GSI: offset out of range");

    f1 = (unsigned short int)fileidx;
    f2 = (unsigned int)offset;
    f1=sre_hton16(f1);
    f2=sre_hton32(f2);
    unsigned long int return_value_fwrite$2;
    return_value_fwrite$2=fwrite((const void *)key, (unsigned long int)1, (unsigned long int)32, fp);
    if(!(return_value_fwrite$2 >= 32ul))
      Panic("gsi.c", 382);

    unsigned long int return_value_fwrite$3;
    return_value_fwrite$3=fwrite((const void *)&f1, (unsigned long int)2, (unsigned long int)1, fp);
    if(!(return_value_fwrite$3 >= 1ul))
      Panic("gsi.c", 383);

    unsigned long int return_value_fwrite$4;
    return_value_fwrite$4=fwrite((const void *)&f2, (unsigned long int)4, (unsigned long int)1, fp);
    if(!(return_value_fwrite$4 >= 1ul))
      Panic("gsi.c", 384);

    return 1;
  }
}

// Gammln
// file ../squid/sqfuncs.h line 201
extern double Gammln(double x)
{
  signed int i;
  double xx;
  double tx;
  double tmp;
  double value;
  if(x <= 0.0)
    return 999999.;

  else
  {
    xx = x - 1.0;
    tmp = xx + 11.0;
    tx = tmp;
    value = 1.0;
    i = 10;
    for( ; i >= 0; i = i - 1)
    {
      static double cof[11l] = { 4.694580336184385e+04, -1.560605207784446e+05, 2.065049568014106e+05, -1.388934775095388e+05, 5.031796415085709e+04, -9.601592329182778e+03, 8.785855930895250e+02, -3.155153906098611e+01, 2.908143421162229e-01, -2.319827630494973e-04, 1.251639670050933e-10 };
      value = value + cof[(signed long int)i] / tmp;
      tmp = tmp - 1.0;
    }
    value=log(value);
    tx = tx + 0.5;
    double return_value_log$1;
    return_value_log$1=log(tx);
    value = value + ((0.918938533 + (xx + 0.5) * return_value_log$1) - tx);
    return value;
  }
}

// GaussianFitHistogram
// file histogram.c line 747
extern signed int GaussianFitHistogram(struct histogram_s *h, float high_hint)
{
  float sum;
  float sqsum;
  float delta;
  signed int sc;
  signed int nbins;
  signed int hsize;
  signed int idx;
  UnfitHistogram(h);
  double return_value_IncompleteGamma$5;
  if(!(h->total >= 1000))
  {
    h->fit_type = 0;
    return 0;
  }

  else
  {
    sqsum = (float)0.;
    sum = sqsum;
    sc = h->lowscore;
    for( ; h->highscore >= sc; sc = sc + 1)
    {
      delta = (float)((double)(float)sc + 0.5);
      sum = sum + (float)h->histogram[(signed long int)(sc - h->min)] * delta;
      sqsum = sqsum + (float)h->histogram[(signed long int)(sc - h->min)] * delta * delta;
    }
    h->fit_type = 2;
    h->param[(signed long int)0] = sum / (float)h->total;
    double return_value_sqrt$1;
    return_value_sqrt$1=sqrt((double)((sqsum - (sum * sum) / (float)h->total) / (float)(h->total - 1)));
    h->param[(signed long int)1] = (float)return_value_sqrt$1;
    hsize = (h->max - h->min) + 1;
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("histogram.c", 790, sizeof(float) /*4ul*/  * (unsigned long int)hsize);
    h->expect = (float *)return_value_sre_malloc$2;
    idx = 0;
    for( ; !(idx >= hsize); idx = idx + 1)
      h->expect[(signed long int)idx] = (float)0.;
    sc = h->min;
    for( ; h->max >= sc; sc = sc + 1)
    {
      delta = (float)(((double)(float)sc + 0.5) - (double)h->param[(signed long int)0]);
      double return_value_sqrt$3;
      return_value_sqrt$3=sqrt(2. * 3.14159);
      double return_value_exp$4;
      return_value_exp$4=exp((-1. * (double)delta * (double)delta) / (2. * (double)h->param[(signed long int)1] * (double)h->param[(signed long int)1]));
      h->expect[(signed long int)(sc - h->min)] = (float)((double)(float)h->total * (1. / ((double)h->param[(signed long int)1] * return_value_sqrt$3)) * return_value_exp$4);
    }
    h->chisq = (float)0.;
    nbins = 0;
    sc = h->lowscore;
    for( ; h->highscore >= sc; sc = sc + 1)
      if(h->expect[(signed long int)(sc + -h->min)] >= 5.000000f)
      {
        if(h->histogram[(signed long int)(sc + -h->min)] >= 5)
        {
          delta = (float)h->histogram[(signed long int)(sc - h->min)] - h->expect[(signed long int)(sc - h->min)];
          h->chisq = h->chisq + (delta * delta) / h->expect[(signed long int)(sc - h->min)];
          nbins = nbins + 1;
        }

      }

    if(nbins >= 4)
    {
      return_value_IncompleteGamma$5=IncompleteGamma((double)(nbins - 3) / 2., (double)h->chisq / 2.);
      h->chip = (float)return_value_IncompleteGamma$5;
    }

    else
      h->chip = (float)0.;
    return 1;
  }
}

// GaussianSetHistogram
// file histogram.c line 830
extern void GaussianSetHistogram(struct histogram_s *h, float mean, float sd)
{
  signed int sc;
  signed int hsize;
  signed int idx;
  signed int nbins;
  float delta;
  UnfitHistogram(h);
  h->fit_type = 2;
  h->param[(signed long int)0] = mean;
  h->param[(signed long int)1] = sd;
  hsize = (h->max - h->min) + 1;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("histogram.c", 845, sizeof(float) /*4ul*/  * (unsigned long int)hsize);
  h->expect = (float *)return_value_sre_malloc$1;
  idx = 0;
  for( ; !(idx >= hsize); idx = idx + 1)
    h->expect[(signed long int)idx] = (float)0.;
  sc = h->min;
  for( ; h->max >= sc; sc = sc + 1)
  {
    delta = (float)(((double)(float)sc + 0.5) - (double)h->param[(signed long int)0]);
    double return_value_sqrt$2;
    return_value_sqrt$2=sqrt(2. * 3.14159);
    double return_value_exp$3;
    return_value_exp$3=exp((-1. * (double)delta * (double)delta) / (2. * (double)h->param[(signed long int)1] * (double)h->param[(signed long int)1]));
    h->expect[(signed long int)(sc - h->min)] = (float)((double)(float)h->total * (1. / ((double)h->param[(signed long int)1] * return_value_sqrt$2)) * return_value_exp$3);
  }
  h->chisq = (float)0.;
  nbins = 0;
  sc = h->lowscore;
  for( ; h->highscore >= sc; sc = sc + 1)
    if(h->expect[(signed long int)(sc + -h->min)] >= 5.000000f)
    {
      if(h->histogram[(signed long int)(sc + -h->min)] >= 5)
      {
        delta = (float)h->histogram[(signed long int)(sc - h->min)] - h->expect[(signed long int)(sc - h->min)];
        h->chisq = h->chisq + (delta * delta) / h->expect[(signed long int)(sc - h->min)];
        nbins = nbins + 1;
      }

    }

  double return_value_IncompleteGamma$4;
  if(nbins >= 2)
  {
    return_value_IncompleteGamma$4=IncompleteGamma((double)(nbins - 1) / 2., (double)h->chisq / 2.);
    h->chip = (float)return_value_IncompleteGamma$4;
  }

  else
    h->chip = (float)0.;
}

// Gaussrandom
// file ../squid/sre_random.h line 12
extern double Gaussrandom(double mean, double stddev)
{
  static double u;
  u=sre_random();
  static double s;
  s = 0.0;
  if(u > 0.5)
    s = 1.0;

  u = u + (u - s);
  u = 32.0 * u;
  static signed long int i;
  i = (signed long int)u;
  if(i == 32l)
    i = (signed long int)31;

  static double tt;
  static double w;
  static double a[32l] = { 0.0, 3.917609E-2, 7.841241E-2, 0.11777, 0.1573107, 0.1970991, 0.2372021, 0.2776904, 0.3186394, 0.36013, 0.4022501, 0.4450965, 0.4887764, 0.5334097, 0.5791322, 0.626099, 0.6744898, 0.7245144, 0.7764218, 0.8305109, 0.8871466, 0.9467818, 1.00999, 1.077516, 1.150349, 1.229859, 1.318011, 1.417797, 1.534121, 1.67594, 1.862732, 2.153875 };
  static double aa;
  static double ustar;
  if(!(i == 0l))
  {
    ustar = u - (double)i;
    aa = *((a + i) - (signed long int)1);

  S40:
    ;
    while((_Bool)1)
    {
      static double t[31l] = { 7.673828E-4, 2.30687E-3, 3.860618E-3, 5.438454E-3, 7.0507E-3, 8.708396E-3, 1.042357E-2, 1.220953E-2, 1.408125E-2, 1.605579E-2, 1.81529E-2, 2.039573E-2, 2.281177E-2, 2.543407E-2, 2.830296E-2, 3.146822E-2, 3.499233E-2, 3.895483E-2, 4.345878E-2, 4.864035E-2, 5.468334E-2, 6.184222E-2, 7.047983E-2, 8.113195E-2, 9.462444E-2, 0.1123001, 0.136498, 0.1716886, 0.2276241, 0.330498, 0.5847031 };
      if(!(ustar <= t[-1l + i]))
      {
        static double h[31l] = { 3.920617E-2, 3.932705E-2, 3.951E-2, 3.975703E-2, 4.007093E-2, 4.045533E-2, 4.091481E-2, 4.145507E-2, 4.208311E-2, 4.280748E-2, 4.363863E-2, 4.458932E-2, 4.567523E-2, 4.691571E-2, 4.833487E-2, 4.996298E-2, 5.183859E-2, 5.401138E-2, 5.654656E-2, 5.95313E-2, 6.308489E-2, 6.737503E-2, 7.264544E-2, 7.926471E-2, 8.781922E-2, 9.930398E-2, 0.11556, 0.1404344, 0.1836142, 0.2790016, 0.7010474 };
        w = (ustar - *((t + i) - (signed long int)1)) * *((h + i) - (signed long int)1);

      S50:
        ;
        static double y;
        y = aa + w;
        static double snorm;
        snorm = y;
        if(IEEE_FLOAT_EQUAL(s, 1.0))
          snorm = -y;

        return stddev * snorm + mean;
      }


    S60:
      ;
      u=sre_random();
      w = u * (a[i] - aa);
      tt = (0.5 * w + aa) * w;
      goto S80;

    S70:
      ;
      tt = u;
      ustar=sre_random();

    S80:
      ;
      if(ustar > tt)
        goto S50;

      u=sre_random();
      if(ustar >= u)
        goto S70;

      ustar=sre_random();
    }
  }


S100:
  ;
  i = (signed long int)6;
  aa = a[(signed long int)31];
  goto S120;

S110:
  ;
  static double d[31l] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.2636843, 0.2425085, 0.2255674, 0.2116342, 0.1999243, 0.1899108, 0.1812252, 0.1736014, 0.1668419, 0.1607967, 0.1553497, 0.1504094, 0.1459026, 0.14177, 0.1379632, 0.1344418, 0.1311722, 0.128126, 0.1252791, 0.1226109, 0.1201036, 0.1177417, 0.1155119, 0.1134023, 0.1114027, 0.1095039 };
  aa = aa + *((d + i) - (signed long int)1);
  i = i + (signed long int)1;

S120:
  ;
  u = u + u;
  if(u < 1.0)
    goto S110;

  u = u - 1.0;
  do
  {

  S140:
    ;
    w = u * *((d + i) - (signed long int)1);
    tt = (0.5 * w + aa) * w;
    goto S160;

  S150:
    ;
    tt = u;

  S160:
    ;
    ustar=sre_random();
    if(ustar > tt)
      goto S50;

    u=sre_random();
    if(ustar >= u)
      goto S150;

    u=sre_random();
  }
  while((_Bool)1);
}

// GetRankedHit
// file tophits.c line 220
extern void GetRankedHit(struct tophit_s *h, signed int rank, double *r_pvalue, float *r_score, double *r_motherp, float *r_mothersc, char **r_name, char **r_acc, char **r_desc, signed int *r_sqfrom, signed int *r_sqto, signed int *r_sqlen, signed int *r_hmmfrom, signed int *r_hmmto, signed int *r_hmmlen, signed int *r_domidx, signed int *r_ndom, struct fancyali_s **r_ali)
{
  if(!(r_pvalue == ((double *)NULL)))
    *r_pvalue = h->hit[(signed long int)rank]->pvalue;

  if(!(r_score == ((float *)NULL)))
    *r_score = h->hit[(signed long int)rank]->score;

  if(!(r_motherp == ((double *)NULL)))
    *r_motherp = h->hit[(signed long int)rank]->motherp;

  if(!(r_mothersc == ((float *)NULL)))
    *r_mothersc = h->hit[(signed long int)rank]->mothersc;

  if(!(r_name == ((char **)NULL)))
    *r_name = h->hit[(signed long int)rank]->name;

  if(!(r_acc == ((char **)NULL)))
    *r_acc = h->hit[(signed long int)rank]->acc;

  if(!(r_desc == ((char **)NULL)))
    *r_desc = h->hit[(signed long int)rank]->desc;

  if(!(r_sqfrom == ((signed int *)NULL)))
    *r_sqfrom = h->hit[(signed long int)rank]->sqfrom;

  if(!(r_sqto == ((signed int *)NULL)))
    *r_sqto = h->hit[(signed long int)rank]->sqto;

  if(!(r_sqlen == ((signed int *)NULL)))
    *r_sqlen = h->hit[(signed long int)rank]->sqlen;

  if(!(r_hmmfrom == ((signed int *)NULL)))
    *r_hmmfrom = h->hit[(signed long int)rank]->hmmfrom;

  if(!(r_hmmto == ((signed int *)NULL)))
    *r_hmmto = h->hit[(signed long int)rank]->hmmto;

  if(!(r_hmmlen == ((signed int *)NULL)))
    *r_hmmlen = h->hit[(signed long int)rank]->hmmlen;

  if(!(r_domidx == ((signed int *)NULL)))
    *r_domidx = h->hit[(signed long int)rank]->domidx;

  if(!(r_ndom == ((signed int *)NULL)))
    *r_ndom = h->hit[(signed long int)rank]->ndom;

  if(!(r_ali == ((struct fancyali_s **)NULL)))
    *r_ali = h->hit[(signed long int)rank]->ali;

}

// Getline
// file misc.c line 129
char * Getline(char *s, signed int n, struct _IO_FILE *fp)
{
  char *first;
  const unsigned short int **return_value___ctype_b_loc$3;
  _Bool tmp_if_expr$1;
  do
  {
    char *return_value_fgets$2;
    return_value_fgets$2=fgets(s, n, fp);
    if(return_value_fgets$2 == ((char *)NULL))
      return (char *)(void *)0;

    first = s;
    do
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*first]) == 0)
        break;

      first = first + 1l;
    }
    while((_Bool)1);
    if((signed int)*first == 35)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*first == 0 ? (_Bool)1 : (_Bool)0;
  }
  while(tmp_if_expr$1);
  return s;
}

// Getopt
// file ../squid/sqfuncs.h line 87
extern signed int Getopt(signed int argc, char **argv, struct opt_s *opt, signed int nopts, char *usage, signed int *ret_optind, char **ret_optname, char **ret_optarg)
{
  signed int i;
  signed int arglen;
  signed int nmatch;
  signed int opti = 0;
  _Bool tmp_if_expr$1;
  static signed int optind = 1;
  if(optind >= argc)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)argv[(signed long int)optind][(signed long int)0] != 45 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strcmp$2=strcmp(argv[(signed long int)optind], "-");
    tmp_if_expr$3 = return_value_strcmp$2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$10;
  signed int return_value_strncmp$9;
  signed int return_value_strncmp$7;
  unsigned long int return_value_strlen$8;
  _Bool tmp_if_expr$15;
  signed int return_value_IsInt$14;
  _Bool tmp_if_expr$13;
  signed int return_value_IsReal$12;
  unsigned long int return_value_strlen$11;
  if(tmp_if_expr$3)
  {
    *ret_optind = optind;
    *ret_optarg = (char *)(void *)0;
    *ret_optname = (char *)(void *)0;
    return 0;
  }

  else
  {
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(argv[(signed long int)optind], "--");
    if(return_value_strcmp$4 == 0)
    {
      optind = optind + 1;
      *ret_optind = optind;
      *ret_optname = (char *)(void *)0;
      *ret_optarg = (char *)(void *)0;
      return 0;
    }

    else
    {
      static char *optptr = (char *)(void *)0;
      if(optptr == ((char *)NULL))
      {
        return_value_strncmp$9=strncmp(argv[(signed long int)optind], "--", (unsigned long int)2);
        tmp_if_expr$10 = return_value_strncmp$9 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
      {
        optptr=strchr(argv[(signed long int)optind], 61);
        if(!(optptr == ((char *)NULL)))
        {
          *optptr = (char)0;
          optptr = optptr + 1l;
        }

        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(argv[(signed long int)optind]);
        arglen = (signed int)return_value_strlen$5;
        nmatch = 0;
        i = 0;
        for( ; !(i >= nopts); i = i + 1)
          if((opt + (signed long int)i)->single == 0)
          {
            return_value_strncmp$7=strncmp((opt + (signed long int)i)->name, argv[(signed long int)optind], (unsigned long int)arglen);
            if(return_value_strncmp$7 == 0)
            {
              nmatch = nmatch + 1;
              opti = i;
              unsigned long int return_value_strlen$6;
              return_value_strlen$6=strlen((opt + (signed long int)i)->name);
              if((unsigned long int)arglen == return_value_strlen$6)
                break;

            }

          }

        if(nmatch >= 2)
        {
          return_value_strlen$8=strlen((opt + (signed long int)i)->name);
          if(!((unsigned long int)arglen == return_value_strlen$8))
            Die("Option \"%s\" is ambiguous; please be more specific.\n%s", argv[(signed long int)optind], usage);

        }

        if(nmatch == 0)
          Die("No such option \"%s\".\n%s", argv[(signed long int)optind], usage);

        *ret_optname = (opt + (signed long int)opti)->name;
        if(!((opt + (signed long int)opti)->argtype == 0))
        {
          if(!(optptr == ((char *)NULL)))
          {
            *ret_optarg = optptr;
            optptr = (char *)(void *)0;
            optind = optind + 1;
          }

          else
            if(1 + optind >= argc)
              Die("Option %s requires an argument\n%s", (opt + (signed long int)opti)->name, usage);

            else
            {
              *ret_optarg = argv[(signed long int)(optind + 1)];
              optind = optind + 2;
            }
        }

        else
        {
          if(!(optptr == ((char *)NULL)))
            Die("Option %s does not take an argument\n%s", (opt + (signed long int)opti)->name, usage);

          *ret_optarg = (char *)(void *)0;
          optind = optind + 1;
        }
      }

      else
      {
        if(optptr == ((char *)NULL))
          optptr = argv[(signed long int)optind] + (signed long int)1;

        opti = -1;
        i = 0;
        for( ; !(i >= nopts); i = i + 1)
          if((opt + (signed long int)i)->single == 1)
          {
            if(*optptr == (opt + (signed long int)i)->name[1l])
            {
              opti = i;
              break;
            }

          }

        if(opti == -1)
          Die("No such option \"%c\".\n%s", *optptr, usage);

        *ret_optname = (opt + (signed long int)opti)->name;
        if(!((opt + (signed long int)opti)->argtype == 0))
        {
          if(!((signed int)optptr[1l] == 0))
          {
            *ret_optarg = optptr + (signed long int)1;
            optind = optind + 1;
          }

          else
            if(!(1 + optind >= argc))
            {
              *ret_optarg = argv[(signed long int)(optind + 1)];
              optind = optind + 2;
            }

            else
              Die("Option %s requires an argument\n%s", (opt + (signed long int)opti)->name, usage);
          optptr = (char *)(void *)0;
        }

        else
        {
          *ret_optarg = (char *)(void *)0;
          if(!((signed int)optptr[1l] == 0))
            optptr = optptr + 1l;

          else
          {
            optind = optind + 1;
            optptr = (char *)(void *)0;
          }
        }
      }
      if(!((opt + (signed long int)opti)->argtype == 0))
      {
        if((opt + (signed long int)opti)->argtype == 1)
        {
          return_value_IsInt$14=IsInt(*ret_optarg);
          tmp_if_expr$15 = !(return_value_IsInt$14 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$15 = (_Bool)0;
        if(tmp_if_expr$15)
          Die("Option %s requires an integer argument\n%s", (opt + (signed long int)opti)->name, usage);

        else
        {
          if((opt + (signed long int)opti)->argtype == 2)
          {
            return_value_IsReal$12=IsReal(*ret_optarg);
            tmp_if_expr$13 = !(return_value_IsReal$12 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
            Die("Option %s requires a numerical argument\n%s", (opt + (signed long int)opti)->name, usage);

          else
            if((opt + (signed long int)opti)->argtype == 3)
            {
              return_value_strlen$11=strlen(*ret_optarg);
              if(!(return_value_strlen$11 == 1ul))
                Die("Option %s requires a single-character argument\n%s", (opt + (signed long int)opti)->name, usage);

            }

        }
      }

      *ret_optind = optind;
      return 1;
    }
  }
}

// Getword
// file misc.c line 76
char * Getword(struct _IO_FILE *fp, signed int type)
{
  static char *sptr = (char *)(void *)0;
  if(!(sptr == ((char *)NULL)))
    sptr=strtok((char *)(void *)0, " \t\n");

  while(sptr == ((char *)NULL))
  {
    static char buffer[512l];
    sptr=fgets(buffer, 512, fp);
    if(sptr == ((char *)NULL))
      return (char *)(void *)0;

    sptr=strchr(buffer, 35);
    if(!(sptr == ((char *)NULL)))
      *sptr = (char)0;

    sptr=strtok(buffer, " \t\n");
  }
  unsigned long int return_value_strlen$1;
  signed int return_value_IsInt$2;
  signed int return_value_IsReal$3;
  switch(type)
  {
    case 4:
    {
      return_value_strlen$1=strlen(sptr);
      if(return_value_strlen$1 == 0ul)
      {
        Warn("Parse failed: expected string, got nothing");
        sptr = (char *)(void *)0;
      }

      break;
    }
    case 1:
    {
      return_value_IsInt$2=IsInt(sptr);
      if(return_value_IsInt$2 == 0)
      {
        Warn("Parse failed: expected integer, got %s", sptr);
        sptr = (char *)(void *)0;
      }

      break;
    }
    case 2:
    {
      return_value_IsReal$3=IsReal(sptr);
      if(return_value_IsReal$3 == 0)
      {
        Warn("Parse failed: expected real value, got %s", sptr);
        sptr = (char *)(void *)0;
      }

    }
  }
  return sptr;
}

// GrowTophits
// file tophits.c line 91
extern void GrowTophits(struct tophit_s *h)
{
  void *return_value_sre_realloc$1;
  return_value_sre_realloc$1=sre_realloc("tophits.c", 93, (void *)h->unsrt, (unsigned long int)(h->alloc + h->lump) * sizeof(struct hit_s) /*104ul*/ );
  h->unsrt = (struct hit_s *)return_value_sre_realloc$1;
  h->alloc = h->alloc + h->lump;
}

// GuessAlignmentSeqtype
// file sqfuncs.h line 180
extern signed int GuessAlignmentSeqtype(char **aseq, signed int nseq)
{
  signed int idx;
  signed int nrna = 0;
  signed int ndna = 0;
  signed int namino = 0;
  signed int nother = 0;
  idx = 0;
  signed int return_value_Seqtype$1;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    return_value_Seqtype$1=Seqtype(aseq[(signed long int)idx]);
    switch(return_value_Seqtype$1)
    {
      case 2:
      {
        nrna = nrna + 1;
        break;
      }
      case 1:
      {
        ndna = ndna + 1;
        break;
      }
      case 3:
      {
        namino = namino + 1;
        break;
      }
      default:
        nother = nother + 1;
    }
  }
  if(!(nother == 0))
    return 0;

  else
    if(namino == nseq)
      return 3;

    else
      if(ndna == nseq)
        return 1;

      else
        if(nrna == nseq)
          return 2;

        else
          if(namino == 0)
            return 2;

          else
            return 3;
}

// HMMERBanner
// file misc.c line 55
void HMMERBanner(struct _IO_FILE *fp, char *banner)
{
  fprintf(fp, "%s\n", banner);
  fprintf(fp, "%s %s (%s)\n", (const void *)"HMMER", (const void *)"2.3.2", (const void *)"Oct 2003");
  fprintf(fp, "%s\n", (const void *)"Copyright (C) 1992-2003 HHMI/Washington University School of Medicine");
  fprintf(fp, "%s\n", (const void *)"Freely distributed under the GNU General Public License (GPL)");
  fprintf(fp, "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
}

// HMMFileClose
// file funcs.h line 157
extern void HMMFileClose(struct hmmfile_s *hmmfp)
{
  if(!(hmmfp->f == ((struct _IO_FILE *)NULL)))
    fclose(hmmfp->f);

  if(!(hmmfp->ssi == ((struct ssifile_s *)NULL)))
    SSIClose(hmmfp->ssi);

  free((void *)hmmfp);
}

// HMMFileOpen
// file funcs.h line 155
extern struct hmmfile_s * HMMFileOpen(char *hmmfile, char *env)
{
  struct hmmfile_s *hmmfp;
  unsigned int magic;
  char buf[512l];
  char *ssifile;
  char *dir;
  signed int status;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("hmmio.c", 163, sizeof(struct hmmfile_s) /*56ul*/ );
  hmmfp = (struct hmmfile_s *)return_value_sre_malloc$1;
  hmmfp->f = (struct _IO_FILE *)(void *)0;
  hmmfp->parser = (signed int (*)(struct hmmfile_s *, struct plan7_s **))(void *)0;
  hmmfp->is_binary = 0;
  hmmfp->byteswap = 0;
  hmmfp->is_seekable = 1;
  hmmfp->f = (struct _IO_FILE *)(void *)0;
  hmmfp->ssi = (struct ssifile_s *)(void *)0;
  hmmfp->f=fopen(hmmfile, "r");
  if(!(hmmfp->f == ((struct _IO_FILE *)NULL)))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(hmmfile);
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("hmmio.c", 180, sizeof(char) /*1ul*/  * (return_value_strlen$2 + (unsigned long int)5));
    ssifile = (char *)return_value_sre_malloc$3;
    sprintf(ssifile, "%s.ssi", hmmfile);
    hmmfp->mode=SSIRecommendMode(hmmfile);
    if(hmmfp->mode == -1)
      Die("SSIRecommendMode() failed");

  }

  else
  {
    hmmfp->f=EnvFileOpen(hmmfile, env, &dir);
    if(!(hmmfp->f == ((struct _IO_FILE *)NULL)))
    {
      char *full;
      full=FileConcat(dir, hmmfile);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(full);
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(hmmfile);
      void *return_value_sre_malloc$6;
      return_value_sre_malloc$6=sre_malloc("hmmio.c", 191, sizeof(char) /*1ul*/  * (return_value_strlen$4 + return_value_strlen$5 + (unsigned long int)5));
      ssifile = (char *)return_value_sre_malloc$6;
      sprintf(ssifile, "%s.ssi", full);
      hmmfp->mode=SSIRecommendMode(full);
      if(hmmfp->mode == -1)
        Die("SSIRecommendMode() failed");

      free((void *)full);
      free((void *)dir);
    }

    else
      return (struct hmmfile_s *)(void *)0;
  }
  SSIOpen(ssifile, &hmmfp->ssi);
  free((void *)ssifile);
  status=SSIGetFilePosition(hmmfp->f, hmmfp->mode, &hmmfp->offset);
  if(!(status == 0))
    Die("SSIGetFilePosition() failed");

  unsigned long int return_value_fread$7;
  return_value_fread$7=fread((void *)(char *)&magic, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
  signed int return_value_strncmp$12;
  signed int return_value_strncmp$11;
  signed int return_value_strncmp$10;
  signed int return_value_strncmp$9;
  if(return_value_fread$7 == 0ul)
  {
    HMMFileClose(hmmfp);
    return (struct hmmfile_s *)(void *)0;
  }

  else
  {
    rewind(hmmfp->f);
    if(magic == v20magic)
    {
      hmmfp->parser = read_bin20hmm;
      hmmfp->is_binary = 1;
      return hmmfp;
    }

    else
      if(magic == v20swap)
      {
        hmmfp->parser = read_bin20hmm;
        hmmfp->is_binary = 1;
        hmmfp->byteswap = 1;
        return hmmfp;
      }

      else
        if(magic == v19magic)
        {
          hmmfp->parser = read_bin19hmm;
          hmmfp->is_binary = 1;
          return hmmfp;
        }

        else
          if(magic == v19swap)
          {
            hmmfp->parser = read_bin19hmm;
            hmmfp->is_binary = 1;
            hmmfp->byteswap = 1;
            return hmmfp;
          }

          else
            if(magic == v17magic)
            {
              hmmfp->parser = read_bin17hmm;
              hmmfp->is_binary = 1;
              return hmmfp;
            }

            else
              if(magic == v17swap)
              {
                hmmfp->parser = read_bin17hmm;
                hmmfp->is_binary = 1;
                hmmfp->byteswap = 1;
                return hmmfp;
              }

              else
                if(magic == v11magic)
                {
                  hmmfp->parser = read_bin11hmm;
                  hmmfp->is_binary = 1;
                  return hmmfp;
                }

                else
                  if(magic == v11swap)
                  {
                    hmmfp->parser = read_bin11hmm;
                    hmmfp->is_binary = 1;
                    hmmfp->byteswap = 1;
                    return hmmfp;
                  }

                  else
                    if(magic == v10magic)
                    {
                      hmmfp->parser = read_bin10hmm;
                      hmmfp->is_binary = 1;
                      return hmmfp;
                    }

                    else
                      if(magic == v10swap)
                      {
                        hmmfp->parser = read_bin10hmm;
                        hmmfp->is_binary = 1;
                        hmmfp->byteswap = 1;
                        return hmmfp;
                      }

    if(!((0x80000000 & magic) == 0u))
    {
      Warn("%s appears to be a binary but format is not recognized\nIt may be from a HMMER version more recent than yours,\nor may be a different kind of binary altogether.\n", hmmfile);
      HMMFileClose(hmmfp);
      return (struct hmmfile_s *)(void *)0;
    }

    else
    {
      char *return_value_fgets$8;
      return_value_fgets$8=fgets(buf, 512, hmmfp->f);
      if(return_value_fgets$8 == ((char *)NULL))
      {
        HMMFileClose(hmmfp);
        return (struct hmmfile_s *)(void *)0;
      }

      else
      {
        rewind(hmmfp->f);
        signed int return_value_strncmp$13;
        return_value_strncmp$13=strncmp("HMMER2.0", buf, (unsigned long int)8);
        if(return_value_strncmp$13 == 0)
        {
          hmmfp->parser = read_asc20hmm;
          return hmmfp;
        }

        else
        {
          return_value_strncmp$12=strncmp("HMMER v1.9", buf, (unsigned long int)10);
          if(return_value_strncmp$12 == 0)
          {
            hmmfp->parser = read_asc19hmm;
            return hmmfp;
          }

          else
          {
            return_value_strncmp$11=strncmp("# HMM v1.7", buf, (unsigned long int)10);
            if(return_value_strncmp$11 == 0)
            {
              hmmfp->parser = read_asc17hmm;
              return hmmfp;
            }

            else
            {
              return_value_strncmp$10=strncmp("# HMM v1.1", buf, (unsigned long int)10);
              if(return_value_strncmp$10 == 0)
              {
                hmmfp->parser = read_asc11hmm;
                return hmmfp;
              }

              else
              {
                return_value_strncmp$9=strncmp("# HMM v1.0", buf, (unsigned long int)10);
                if(return_value_strncmp$9 == 0)
                {
                  hmmfp->parser = read_asc10hmm;
                  return hmmfp;
                }

              }
            }
          }
        }
        HMMFileClose(hmmfp);
        return (struct hmmfile_s *)(void *)0;
      }
    }
  }
}

// HMMFilePositionByIndex
// file hmmio.c line 358
extern signed int HMMFilePositionByIndex(struct hmmfile_s *hmmfp, signed int idx)
{
  signed int fh;
  struct ssioffset_s offset;
  if(hmmfp->ssi == ((struct ssifile_s *)NULL))
    return 0;

  else
  {
    signed int return_value_SSIGetOffsetByNumber$1;
    return_value_SSIGetOffsetByNumber$1=SSIGetOffsetByNumber(hmmfp->ssi, idx, &fh, &offset);
    if(!(return_value_SSIGetOffsetByNumber$1 == 0))
      return 0;

    else
    {
      signed int return_value_SSISetFilePosition$2;
      return_value_SSISetFilePosition$2=SSISetFilePosition(hmmfp->f, &offset);
      if(!(return_value_SSISetFilePosition$2 == 0))
        return 0;

      else
        return 1;
    }
  }
}

// HMMFilePositionByName
// file hmmio.c line 347
extern signed int HMMFilePositionByName(struct hmmfile_s *hmmfp, char *name)
{
  struct ssioffset_s offset;
  signed int fh;
  if(hmmfp->ssi == ((struct ssifile_s *)NULL))
    return 0;

  else
  {
    signed int return_value_SSIGetOffsetByName$1;
    return_value_SSIGetOffsetByName$1=SSIGetOffsetByName(hmmfp->ssi, name, &fh, &offset);
    if(!(return_value_SSIGetOffsetByName$1 == 0))
      return 0;

    else
    {
      signed int return_value_SSISetFilePosition$2;
      return_value_SSISetFilePosition$2=SSISetFilePosition(hmmfp->f, &offset);
      if(!(return_value_SSISetFilePosition$2 == 0))
        return 0;

      else
        return 1;
    }
  }
}

// HMMFileRead
// file funcs.h line 156
extern signed int HMMFileRead(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  signed int status;
  if(!(hmmfp->is_seekable == 0))
  {
    status=SSIGetFilePosition(hmmfp->f, hmmfp->mode, &hmmfp->offset);
    if(!(status == 0))
      Die("SSIGetFilePosition() failed");

  }

  signed int return_value;
  return_value=hmmfp->parser(hmmfp, ret_hmm);
  return return_value;
}

// HMMFileRewind
// file funcs.h line 159
extern void HMMFileRewind(struct hmmfile_s *hmmfp)
{
  rewind(hmmfp->f);
}

// ILogsum
// file funcs.h line 179
extern signed int ILogsum(signed int p1, signed int p2)
{
  signed int diff;
  static signed int firsttime = 0;
  pthread_once(&firsttime, init_ilogsum);
  diff = p1 - p2;
  if(diff >= 20000)
    return p1;

  else
    if(!(diff >= -19999))
      return p2;

    else
      if(diff >= 1)
        return p1 + ilogsum_lookup[(signed long int)diff];

      else
        return p2 + ilogsum_lookup[(signed long int)-diff];
}

// ImposeMasterTrace
// file trace.c line 1118
extern void ImposeMasterTrace(char **aseq, signed int nseq, struct p7trace_s *mtr, struct p7trace_s ***ret_tr)
{
  struct p7trace_s **tr;
  signed int idx;
  signed int i;
  signed int tpos;
  signed int mpos;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("trace.c", 1126, sizeof(struct p7trace_s *) /*8ul*/  * (unsigned long int)nseq);
  tr = (struct p7trace_s **)return_value_sre_malloc$1;
  idx = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    P7AllocTrace(mtr->tlen, &tr[(signed long int)idx]);
    tpos = 0;
    i = 1;
    mpos = 0;
    for( ; !(mpos >= mtr->tlen); mpos = mpos + 1)
      switch((signed int)mtr->statetype[(signed long int)mpos])
      {
        case 4:

        case 6:

        case 2:

        case 7:

        case 9:
        {
          TraceSet(tr[(signed long int)idx], tpos, mtr->statetype[(signed long int)mpos], mtr->nodeidx[(signed long int)mpos], 0);
          tpos = tpos + 1;
          break;
        }
        case 1:
        {
          if((signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] + -1)] == 32)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 126 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            TraceSet(tr[(signed long int)idx], tpos, (char)2, mtr->nodeidx[(signed long int)mpos], 0);

          else
          {
            TraceSet(tr[(signed long int)idx], tpos, (char)1, mtr->nodeidx[(signed long int)mpos], i);
            i = i + 1;
          }
          tpos = tpos + 1;
          break;
        }
        case 3:
        {
          if((signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] + -1)] == 32)
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$6)
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
            tmp_if_expr$8 = (_Bool)1;

          else
            tmp_if_expr$8 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$8)
            tmp_if_expr$9 = (_Bool)1;

          else
            tmp_if_expr$9 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 126 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$9)
          {
            TraceSet(tr[(signed long int)idx], tpos, (char)3, mtr->nodeidx[(signed long int)mpos], i);
            i = i + 1;
            tpos = tpos + 1;
          }

          break;
        }
        case 10:

        case 5:

        case 8:
        {
          if(mtr->pos[(signed long int)mpos] == 0)
          {
            TraceSet(tr[(signed long int)idx], tpos, mtr->statetype[(signed long int)mpos], 0, 0);
            tpos = tpos + 1;
          }

          else
          {
            if((signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] + -1)] == 32)
              tmp_if_expr$10 = (_Bool)1;

            else
              tmp_if_expr$10 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 46 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$10)
              tmp_if_expr$11 = (_Bool)1;

            else
              tmp_if_expr$11 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 95 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$11)
              tmp_if_expr$12 = (_Bool)1;

            else
              tmp_if_expr$12 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 45 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$12)
              tmp_if_expr$13 = (_Bool)1;

            else
              tmp_if_expr$13 = (signed int)aseq[(signed long int)idx][(signed long int)(mtr->pos[(signed long int)mpos] - 1)] == 126 ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr$13)
            {
              TraceSet(tr[(signed long int)idx], tpos, mtr->statetype[(signed long int)mpos], 0, i);
              i = i + 1;
              tpos = tpos + 1;
            }

          }
          break;
        }
        case 0:
          Die("never happens. Trust me.");
      }
    tr[(signed long int)idx]->tlen = tpos;
  }
  *ret_tr = tr;
}

// IncompleteGamma
// file ../squid/sqfuncs.h line 207
extern double IncompleteGamma(double a, double x)
{
  signed int iter;
  if(a <= 0.)
    Die("IncompleteGamma(): a must be > 0");

  if(x < 0.)
    Die("IncompleteGamma(): x must be >= 0");

  double return_value_log$1;
  double return_value_Gammln$2;
  double return_value_exp$3;
  double return_value_log$5;
  double return_value_Gammln$6;
  double return_value_exp$7;
  if(x > a + 1.000000)
  {
    double oldp;
    double nu0;
    double nu1;
    double de0;
    double de1;
    nu0 = 0.;
    de0 = 1.;
    nu1 = 1.;
    de1 = x;
    oldp = nu1;
    iter = 1;
    for( ; !(iter >= 100); iter = iter + 1)
    {
      nu0 = nu1 + ((double)iter - a) * nu0;
      de0 = de1 + ((double)iter - a) * de0;
      nu1 = x * nu0 + (double)iter * nu1;
      de1 = x * de0 + (double)iter * de1;
      if(IEEE_FLOAT_NOTEQUAL(de1, 0.))
      {
        nu0 = nu0 / de1;
        de0 = de0 / de1;
        nu1 = nu1 / de1;
        de1 = 1.;
      }

      double return_value_fabs$4;
      return_value_fabs$4=fabs((nu1 - oldp) / nu1);
      if(return_value_fabs$4 < 1.e-7)
      {
        return_value_log$1=log(x);
        return_value_Gammln$2=Gammln(a);
        return_value_exp$3=exp((a * return_value_log$1 - x) - return_value_Gammln$2);
        return nu1 * return_value_exp$3;
      }

      oldp = nu1;
    }
    Die("IncompleteGamma(): failed to converge using continued fraction approx");
  }

  else
  {
    double p;
    double val = 1. / a;
    p = val;
    iter = 1;
    for( ; !(iter >= 10000); iter = iter + 1)
    {
      val = val * (x / (a + (double)iter));
      p = p + val;
      double return_value_fabs$8;
      return_value_fabs$8=fabs(val / p);
      if(return_value_fabs$8 < 1.e-7)
      {
        return_value_log$5=log(x);
        return_value_Gammln$6=Gammln(a);
        return_value_exp$7=exp((a * return_value_log$5 - x) - return_value_Gammln$6);
        return 1. - p * return_value_exp$7;
      }

    }
    Die("IncompleteGamma(): failed to converge using series approx");
  }
  return 0.;
}

// InitAinfo
// file alignio.c line 80
extern void InitAinfo(struct aliinfo_s *ainfo)
{
  ainfo->name = (char *)(void *)0;
  ainfo->desc = (char *)(void *)0;
  ainfo->cs = (char *)(void *)0;
  ainfo->rf = (char *)(void *)0;
  ainfo->acc = (char *)(void *)0;
  ainfo->au = (char *)(void *)0;
  ainfo->flags = 0;
  ainfo->tc2 = (float)0.0;
  ainfo->tc1 = ainfo->tc2;
  ainfo->nc2 = (float)0.0;
  ainfo->nc1 = ainfo->nc2;
  ainfo->ga2 = (float)0.0;
  ainfo->ga1 = ainfo->ga2;
}

// InitIntStack
// file sqfuncs.h line 235
extern struct intstack_s * InitIntStack(void)
{
  struct intstack_s *stack;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct intstack_s) /*16ul*/ );
  stack = (struct intstack_s *)return_value_malloc$1;
  if(stack == ((struct intstack_s *)NULL))
    Die("Memory allocation failure at %s line %d", (const void *)"stack.c", 42);

  stack->nxt = (struct intstack_s *)(void *)0;
  return stack;
}

// IsBlankline
// file sqfuncs.h line 231
extern signed int IsBlankline(char *s)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  for( ; !((signed int)*s == 0); s = s + 1l)
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
      return 0;

  }
  return 1;
}

// IsInt
// file ../squid/sqfuncs.h line 249
extern signed int IsInt(char *s)
{
  signed int hex = 0;
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$6;
  unsigned long int return_value_strlen$5;
  _Bool tmp_if_expr$10;
  signed int return_value_strncmp$7;
  _Bool tmp_if_expr$9;
  unsigned long int return_value_strlen$8;
  unsigned long int return_value_strlen$3;
  if(s == ((char *)NULL))
  {
    squid_errno = 6;
    return 0;
  }

  else
  {
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if((signed int)*s == 45)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*s == 43 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      s = s + 1l;

    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp(s, "0x", (unsigned long int)2);
    if(return_value_strncmp$4 == 0)
    {
      return_value_strlen$5=strlen(s);
      tmp_if_expr$6 = (signed int)return_value_strlen$5 > 2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$10 = (_Bool)1;

    else
    {
      return_value_strncmp$7=strncmp(s, "0X", (unsigned long int)2);
      if(return_value_strncmp$7 == 0)
      {
        return_value_strlen$8=strlen(s);
        tmp_if_expr$9 = (signed int)return_value_strlen$8 > 2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$10)
    {
      s = s + (signed long int)2;
      hex = 1;
    }

    else
      if((signed int)*s == 48)
      {
        return_value_strlen$3=strlen(s);
        if((signed int)return_value_strlen$3 >= 2)
          s = s + 1l;

      }

    if(hex == 0)
      while(!((signed int)*s == 0))
      {
        const unsigned short int **return_value___ctype_b_loc$11;
        return_value___ctype_b_loc$11=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)*s]) == 0)
          return 0;

        s = s + 1l;
      }

    else
      while(!((signed int)*s == 0))
      {
        const unsigned short int **return_value___ctype_b_loc$12;
        return_value___ctype_b_loc$12=__ctype_b_loc();
        if((4096 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)*s]) == 0)
          return 0;

        s = s + 1l;
      }
    return 1;
  }
}

// IsReal
// file ../squid/sqfuncs.h line 250
extern signed int IsReal(char *s)
{
  signed int gotdecimal = 0;
  signed int gotexp = 0;
  signed int gotreal = 0;
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$6;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if((signed int)*s == 45)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*s == 43 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      s = s + 1l;

    while(!((signed int)*s == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$5;
      return_value___ctype_b_loc$5=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*s]) == 0))
        gotreal = gotreal + 1;

      else
        if((signed int)*s == 46)
        {
          if(!(gotdecimal == 0))
            return 0;

          if(!(gotexp == 0))
            return 0;

          else
            gotdecimal = gotdecimal + 1;
        }

        else
        {
          if((signed int)*s == 101)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = (signed int)*s == 69 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
          {
            if(!(gotexp == 0))
              return 0;

            else
              gotexp = gotexp + 1;
          }

          else
          {
            return_value___ctype_b_loc$3=__ctype_b_loc();
            if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*s]) == 0))
              break;

          }
        }
      s = s + 1l;
    }
    do
    {
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if((signed int)*s == 0 && !(gotreal == 0))
      return 1;

    else
      return 0;
  }
}

// IsSELEXFormat
// file selex.c line 775
extern signed int IsSELEXFormat(char *filename)
{
  struct _IO_FILE *fp;
  char buffer[4096l];
  char *sptr;
  signed int linenum;
  fp=fopen(filename, "r");
  char *return_value_fgets$1;
  signed int return_value_strncmp$11;
  signed int return_value_strncmp$10;
  signed int return_value_strncmp$9;
  signed int return_value_strncmp$8;
  signed int return_value_strncmp$7;
  signed int return_value_strncmp$6;
  signed int return_value_strncmp$5;
  signed int return_value_strncmp$4;
  signed int return_value_strncmp$3;
  signed int return_value_strncmp$2;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    squid_errno = 4;
    return 0;
  }

  else
  {
    linenum = 0;
    while(!(linenum >= 500))
    {
      return_value_fgets$1=fgets(buffer, 4096, fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      linenum = linenum + 1;
      signed int return_value_strncmp$12;
      return_value_strncmp$12=strncmp(buffer, "#=AU", (unsigned long int)4);
      if(return_value_strncmp$12 == 0)
        break;

      else
      {
        return_value_strncmp$11=strncmp(buffer, "#=ID", (unsigned long int)4);
        if(return_value_strncmp$11 == 0)
          break;

        else
        {
          return_value_strncmp$10=strncmp(buffer, "#=AC", (unsigned long int)4);
          if(return_value_strncmp$10 == 0)
            break;

          else
          {
            return_value_strncmp$9=strncmp(buffer, "#=DE", (unsigned long int)4);
            if(return_value_strncmp$9 == 0)
              break;

            else
            {
              return_value_strncmp$8=strncmp(buffer, "#=GA", (unsigned long int)4);
              if(return_value_strncmp$8 == 0)
                break;

              else
              {
                return_value_strncmp$7=strncmp(buffer, "#=TC", (unsigned long int)4);
                if(return_value_strncmp$7 == 0)
                  break;

                else
                {
                  return_value_strncmp$6=strncmp(buffer, "#=NC", (unsigned long int)4);
                  if(return_value_strncmp$6 == 0)
                    break;

                  else
                  {
                    return_value_strncmp$5=strncmp(buffer, "#=SQ", (unsigned long int)4);
                    if(return_value_strncmp$5 == 0)
                      break;

                    else
                    {
                      return_value_strncmp$4=strncmp(buffer, "#=SS", (unsigned long int)4);
                      if(return_value_strncmp$4 == 0)
                        break;

                      else
                      {
                        return_value_strncmp$3=strncmp(buffer, "#=CS", (unsigned long int)4);
                        if(return_value_strncmp$3 == 0)
                          break;

                        else
                        {
                          return_value_strncmp$2=strncmp(buffer, "#=RF", (unsigned long int)4);
                          if(return_value_strncmp$2 == 0)
                            break;

                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      char *return_value_strchr$13;
      return_value_strchr$13=strchr(commentsyms, (signed int)buffer[0l]);
      if(return_value_strchr$13 == ((char *)NULL))
      {
        sptr=strtok(buffer, " \t\n");
        if(!(sptr == ((char *)NULL)))
        {
          sptr=strtok((char *)(void *)0, "\n");
          if(!(sptr == ((char *)NULL)))
          {
            signed int return_value_Seqtype$14;
            return_value_Seqtype$14=Seqtype(sptr);
            if(return_value_Seqtype$14 == 0)
            {
              fclose(fp);
              return 0;
            }

          }

        }

      }

    }

  DONE:
    ;
    fclose(fp);
    return 1;
  }
}

// Lawless416
// file histogram.c line 1028
extern void Lawless416(float *x, signed int *y, signed int n, float lambda, float *ret_f, float *ret_df)
{
  double esum;
  double xesum;
  double xxesum;
  double xsum;
  double mult;
  double total;
  signed int i;
  total = 0.;
  xxesum = total;
  xsum = xxesum;
  xesum = xsum;
  esum = xesum;
  i = 0;
  double tmp_if_expr$1;
  for( ; !(i >= n); i = i + 1)
  {
    if(y == ((signed int *)NULL))
      tmp_if_expr$1 = 1.;

    else
      tmp_if_expr$1 = (double)y[(signed long int)i];
    mult = tmp_if_expr$1;
    xsum = xsum + mult * (double)x[(signed long int)i];
    double return_value_exp$2;
    return_value_exp$2=exp(-1. * (double)lambda * (double)x[(signed long int)i]);
    xesum = xesum + mult * (double)x[(signed long int)i] * return_value_exp$2;
    double return_value_exp$3;
    return_value_exp$3=exp(-1. * (double)lambda * (double)x[(signed long int)i]);
    xxesum = xxesum + mult * (double)x[(signed long int)i] * (double)x[(signed long int)i] * return_value_exp$3;
    double return_value_exp$4;
    return_value_exp$4=exp(-1. * (double)lambda * (double)x[(signed long int)i]);
    esum = esum + mult * return_value_exp$4;
    total = total + mult;
  }
  *ret_f = (float)((1. / (double)lambda - xsum / total) + xesum / esum);
  *ret_df = (float)(((xesum / esum) * (xesum / esum) - xxesum / esum) - 1. / (double)(lambda * lambda));
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// Lawless422
// file histogram.c line 1085
extern void Lawless422(float *x, signed int *y, signed int n, signed int z, float c, float lambda, float *ret_f, float *ret_df)
{
  double esum;
  double xesum;
  double xxesum;
  double xsum;
  double mult;
  double total;
  signed int i;
  total = 0.;
  xxesum = total;
  xsum = xxesum;
  xesum = xsum;
  esum = xesum;
  i = 0;
  double tmp_if_expr$1;
  for( ; !(i >= n); i = i + 1)
  {
    if(y == ((signed int *)NULL))
      tmp_if_expr$1 = 1.;

    else
      tmp_if_expr$1 = (double)y[(signed long int)i];
    mult = tmp_if_expr$1;
    xsum = xsum + mult * (double)x[(signed long int)i];
    double return_value_exp$2;
    return_value_exp$2=exp(-1. * (double)lambda * (double)x[(signed long int)i]);
    esum = esum + mult * return_value_exp$2;
    double return_value_exp$3;
    return_value_exp$3=exp(-1. * (double)lambda * (double)x[(signed long int)i]);
    xesum = xesum + mult * (double)x[(signed long int)i] * return_value_exp$3;
    double return_value_exp$4;
    return_value_exp$4=exp(-1. * (double)lambda * (double)x[(signed long int)i]);
    xxesum = xxesum + mult * (double)x[(signed long int)i] * (double)x[(signed long int)i] * return_value_exp$4;
    total = total + mult;
  }
  double return_value_exp$5;
  return_value_exp$5=exp(-1. * (double)lambda * (double)c);
  esum = esum + (double)z * return_value_exp$5;
  double return_value_exp$6;
  return_value_exp$6=exp(-1. * (double)lambda * (double)c);
  xesum = xesum + (double)z * (double)c * return_value_exp$6;
  double return_value_exp$7;
  return_value_exp$7=exp(-1. * (double)lambda * (double)c);
  xxesum = xxesum + (double)z * (double)c * (double)c * return_value_exp$7;
  *ret_f = (float)((1. / (double)lambda - xsum / total) + xesum / esum);
  *ret_df = (float)(((xesum / esum) * (xesum / esum) - xxesum / esum) - 1. / (double)(lambda * lambda));
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// Linefit
// file ../squid/sqfuncs.h line 197
extern signed int Linefit(float *x, float *y, signed int N, float *ret_a, float *ret_b, float *ret_r)
{
  float xavg;
  float yavg;
  float sxx;
  float syy;
  float sxy;
  signed int i;
  yavg = (float)0.0;
  xavg = yavg;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    xavg = xavg + x[(signed long int)i];
    yavg = yavg + y[(signed long int)i];
  }
  xavg = xavg / (float)N;
  yavg = yavg / (float)N;
  sxy = (float)0.0;
  syy = sxy;
  sxx = syy;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    sxx = sxx + (x[(signed long int)i] - xavg) * (x[(signed long int)i] - xavg);
    syy = syy + (y[(signed long int)i] - yavg) * (y[(signed long int)i] - xavg);
    sxy = sxy + (x[(signed long int)i] - xavg) * (y[(signed long int)i] - yavg);
  }
  *ret_b = sxy / sxx;
  *ret_a = yavg - xavg * *ret_b;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt((double)sxx);
  double return_value_sqrt$2;
  return_value_sqrt$2=sqrt((double)syy);
  *ret_r = (float)((double)sxy / (return_value_sqrt$1 * return_value_sqrt$2));
  return 1;
}

// LogNorm
// file mathsupport.c line 185
extern void LogNorm(float *vec, signed int n)
{
  signed int x;
  float max = (float)-1.0e30;
  float denom = (float)0.;
  x = 0;
  for( ; !(x >= n); x = x + 1)
    if(vec[(signed long int)x] > max)
      max = vec[(signed long int)x];

  x = 0;
  double return_value_exp$1;
  for( ; !(x >= n); x = x + 1)
    if((double)vec[(signed long int)x] > (double)max + -50.000000)
    {
      return_value_exp$1=exp((double)(vec[(signed long int)x] - max));
      denom = denom + (float)return_value_exp$1;
    }

  x = 0;
  double return_value_exp$2;
  for( ; !(x >= n); x = x + 1)
    if((double)vec[(signed long int)x] > (double)max + -50.000000)
    {
      return_value_exp$2=exp((double)(vec[(signed long int)x] - max));
      vec[(signed long int)x] = (float)(return_value_exp$2 / (double)denom);
    }

    else
      vec[(signed long int)x] = (float)0.0;
}

// LogSum
// file mathsupport.c line 115
extern float LogSum(float p1, float p2)
{
  double tmp_if_expr$3;
  double return_value_exp$1;
  double return_value_log$2;
  double tmp_if_expr$6;
  double return_value_exp$4;
  double return_value_log$5;
  if(p1 > p2)
  {
    if(p1 + -p2 > 50.000000f)
      tmp_if_expr$3 = (double)p1;

    else
    {
      return_value_exp$1=exp((double)(p2 - p1));
      return_value_log$2=log(1. + return_value_exp$1);
      tmp_if_expr$3 = (double)p1 + return_value_log$2;
    }
    return (float)tmp_if_expr$3;
  }

  else
  {
    if(p2 + -p1 > 50.000000f)
      tmp_if_expr$6 = (double)p2;

    else
    {
      return_value_exp$4=exp((double)(p1 - p2));
      return_value_log$5=log(1. + return_value_exp$4);
      tmp_if_expr$6 = (double)p2 + return_value_log$5;
    }
    return (float)tmp_if_expr$6;
  }
}

// Logp_cvec
// file mathsupport.c line 217
extern float Logp_cvec(float *cvec, signed int n, float *alpha)
{
  float lnp;
  float sum1;
  float sum2;
  float sum3;
  signed int x;
  lnp = (float)0.0;
  sum3 = lnp;
  sum2 = sum3;
  sum1 = sum2;
  x = 0;
  for( ; !(x >= n); x = x + 1)
  {
    sum1 = sum1 + cvec[(signed long int)x] + alpha[(signed long int)x];
    sum2 = sum2 + alpha[(signed long int)x];
    sum3 = sum3 + cvec[(signed long int)x];
    double return_value_Gammln$1;
    return_value_Gammln$1=Gammln((double)(alpha[(signed long int)x] + cvec[(signed long int)x]));
    lnp = lnp + (float)return_value_Gammln$1;
    double return_value_Gammln$2;
    return_value_Gammln$2=Gammln((double)cvec[(signed long int)x] + 1.);
    lnp = lnp - (float)return_value_Gammln$2;
    double return_value_Gammln$3;
    return_value_Gammln$3=Gammln((double)alpha[(signed long int)x]);
    lnp = lnp - (float)return_value_Gammln$3;
  }
  double return_value_Gammln$4;
  return_value_Gammln$4=Gammln((double)sum1);
  lnp = lnp - (float)return_value_Gammln$4;
  double return_value_Gammln$5;
  return_value_Gammln$5=Gammln((double)sum2);
  lnp = lnp + (float)return_value_Gammln$5;
  double return_value_Gammln$6;
  return_value_Gammln$6=Gammln((double)sum3 + 1.);
  lnp = lnp + (float)return_value_Gammln$6;
  return lnp;
}

// MSAAddComment
// file msa.c line 355
extern void MSAAddComment(struct msa_struct *msa, char *s)
{
  if(msa->comment == ((char **)NULL))
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("msa.c", 362, sizeof(char *) /*8ul*/  * (unsigned long int)10);
    msa->comment = (char **)return_value_sre_malloc$1;
    msa->alloc_ncomment = 10;
  }

  if(msa->ncomment == msa->alloc_ncomment)
  {
    msa->alloc_ncomment = msa->alloc_ncomment + 10;
    void *return_value_sre_realloc$2;
    return_value_sre_realloc$2=sre_realloc("msa.c", 367, (void *)msa->comment, sizeof(char *) /*8ul*/  * (unsigned long int)msa->alloc_ncomment);
    msa->comment = (char **)return_value_sre_realloc$2;
  }

  msa->comment[(signed long int)msa->ncomment]=sre_strdup(s, -1);
  msa->ncomment = msa->ncomment + 1;
}

// MSAAddGF
// file msa.c line 388
extern void MSAAddGF(struct msa_struct *msa, char *tag, char *value)
{
  if(msa->gf_tag == ((char **)NULL))
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("msa.c", 395, sizeof(char *) /*8ul*/  * (unsigned long int)10);
    msa->gf_tag = (char **)return_value_sre_malloc$1;
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("msa.c", 396, sizeof(char *) /*8ul*/  * (unsigned long int)10);
    msa->gf = (char **)return_value_sre_malloc$2;
    msa->alloc_ngf = 10;
  }

  if(msa->ngf == msa->alloc_ngf)
  {
    msa->alloc_ngf = msa->alloc_ngf + 10;
    void *return_value_sre_realloc$3;
    return_value_sre_realloc$3=sre_realloc("msa.c", 401, (void *)msa->gf_tag, sizeof(char *) /*8ul*/  * (unsigned long int)msa->alloc_ngf);
    msa->gf_tag = (char **)return_value_sre_realloc$3;
    void *return_value_sre_realloc$4;
    return_value_sre_realloc$4=sre_realloc("msa.c", 402, (void *)msa->gf, sizeof(char *) /*8ul*/  * (unsigned long int)msa->alloc_ngf);
    msa->gf = (char **)return_value_sre_realloc$4;
  }

  msa->gf_tag[(signed long int)msa->ngf]=sre_strdup(tag, -1);
  msa->gf[(signed long int)msa->ngf]=sre_strdup(value, -1);
  msa->ngf = msa->ngf + 1;
}

// MSAAddGS
// file msa.c line 433
extern void MSAAddGS(struct msa_struct *msa, char *tag, signed int sqidx, char *value)
{
  signed int tagidx;
  signed int i;
  if(msa->gs_tag == ((char **)NULL))
  {
    msa->gs_idx=GKIInit();
    tagidx=GKIStoreKey(msa->gs_idx, tag);
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("msa.c", 447, sizeof(char *) /*8ul*/ );
    msa->gs_tag = (char **)return_value_sre_malloc$1;
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("msa.c", 448, sizeof(char **) /*8ul*/ );
    msa->gs = (char ***)return_value_sre_malloc$2;
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("msa.c", 449, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->gs[(signed long int)0] = (char **)return_value_sre_malloc$3;
    i = 0;
    for( ; !(i >= msa->nseqalloc); i = i + 1)
      msa->gs[(signed long int)0][(signed long int)i] = (char *)(void *)0;
  }

  else
  {
    tagidx=GKIKeyIndex(msa->gs_idx, tag);
    if(!(tagidx >= 0))
    {
      tagidx=GKIStoreKey(msa->gs_idx, tag);
      void *return_value_sre_realloc$4;
      return_value_sre_realloc$4=sre_realloc("msa.c", 463, (void *)msa->gs_tag, (unsigned long int)(msa->ngs + 1) * sizeof(char *) /*8ul*/ );
      msa->gs_tag = (char **)return_value_sre_realloc$4;
      void *return_value_sre_realloc$5;
      return_value_sre_realloc$5=sre_realloc("msa.c", 464, (void *)msa->gs, (unsigned long int)(msa->ngs + 1) * sizeof(char **) /*8ul*/ );
      msa->gs = (char ***)return_value_sre_realloc$5;
      void *return_value_sre_malloc$6;
      return_value_sre_malloc$6=sre_malloc("msa.c", 465, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
      msa->gs[(signed long int)msa->ngs] = (char **)return_value_sre_malloc$6;
      i = 0;
      for( ; !(i >= msa->nseqalloc); i = i + 1)
        msa->gs[(signed long int)msa->ngs][(signed long int)i] = (char *)(void *)0;
    }

  }
  if(tagidx == msa->ngs)
  {
    msa->gs_tag[(signed long int)tagidx]=sre_strdup(tag, -1);
    msa->ngs = msa->ngs + 1;
  }

  if(msa->gs[(signed long int)tagidx][(signed long int)sqidx] == ((char *)NULL))
    msa->gs[(signed long int)tagidx][(signed long int)sqidx]=sre_strdup(value, -1);

  else
  {
    signed int len;
    len=sre_strcat(&msa->gs[(signed long int)tagidx][(signed long int)sqidx], -1, "\n", 1);
    if(!(len >= 0))
      Die("failed to sre_strcat()");

    signed int return_value_sre_strcat$7;
    return_value_sre_strcat$7=sre_strcat(&msa->gs[(signed long int)tagidx][(signed long int)sqidx], len, value, -1);
    if(!(return_value_sre_strcat$7 >= 0))
      Die("failed to sre_strcat()");

  }
  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
}

// MSAAlloc
// file ../squid/msa.h line 234
extern struct msa_struct * MSAAlloc(signed int nseq, signed int alen)
{
  struct msa_struct *msa;
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("msa.c", 68, sizeof(struct msa_struct) /*360ul*/ );
  msa = (struct msa_struct *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("msa.c", 69, sizeof(char *) /*8ul*/  * (unsigned long int)nseq);
  msa->aseq = (char **)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("msa.c", 70, sizeof(char *) /*8ul*/  * (unsigned long int)nseq);
  msa->sqname = (char **)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("msa.c", 71, sizeof(signed int) /*4ul*/  * (unsigned long int)nseq);
  msa->sqlen = (signed int *)return_value_sre_malloc$4;
  void *return_value_sre_malloc$5;
  return_value_sre_malloc$5=sre_malloc("msa.c", 72, sizeof(float) /*4ul*/  * (unsigned long int)nseq);
  msa->wgt = (float *)return_value_sre_malloc$5;
  i = 0;
  void *return_value_sre_malloc$6;
  for( ; !(i >= nseq); i = i + 1)
  {
    msa->sqname[(signed long int)i] = (char *)(void *)0;
    msa->sqlen[(signed long int)i] = 0;
    msa->wgt[(signed long int)i] = (float)-1.0;
    if(!(alen == 0))
    {
      return_value_sre_malloc$6=sre_malloc("msa.c", 80, sizeof(char) /*1ul*/  * (unsigned long int)(alen + 1));
      msa->aseq[(signed long int)i] = (char *)return_value_sre_malloc$6;
    }

    else
      msa->aseq[(signed long int)i] = (char *)(void *)0;
  }
  msa->alen = alen;
  msa->nseq = 0;
  msa->nseqalloc = nseq;
  msa->nseqlump = nseq;
  msa->flags = 0;
  msa->type = 0;
  msa->name = (char *)(void *)0;
  msa->desc = (char *)(void *)0;
  msa->acc = (char *)(void *)0;
  msa->au = (char *)(void *)0;
  msa->ss_cons = (char *)(void *)0;
  msa->sa_cons = (char *)(void *)0;
  msa->rf = (char *)(void *)0;
  msa->sqacc = (char **)(void *)0;
  msa->sqdesc = (char **)(void *)0;
  msa->ss = (char **)(void *)0;
  msa->sslen = (signed int *)(void *)0;
  msa->sa = (char **)(void *)0;
  msa->salen = (signed int *)(void *)0;
  msa->index=GKIInit();
  msa->lastidx = 0;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    msa->cutoff[(signed long int)i] = (float)0.;
    msa->cutoff_is_set[(signed long int)i] = 0;
  }
  msa->comment = (char **)(void *)0;
  msa->ncomment = 0;
  msa->alloc_ncomment = 0;
  msa->gf_tag = (char **)(void *)0;
  msa->gf = (char **)(void *)0;
  msa->ngf = 0;
  msa->gs_tag = (char **)(void *)0;
  msa->gs = (char ***)(void *)0;
  msa->gs_idx = (struct anonymous$0 *)(void *)0;
  msa->ngs = 0;
  msa->gc_tag = (char **)(void *)0;
  msa->gc = (char **)(void *)0;
  msa->gc_idx = (struct anonymous$0 *)(void *)0;
  msa->ngc = 0;
  msa->gr_tag = (char **)(void *)0;
  msa->gr = (char ***)(void *)0;
  msa->gr_idx = (struct anonymous$0 *)(void *)0;
  msa->ngr = 0;
  return msa;
}

// MSAAppendGC
// file msa.c line 507
extern void MSAAppendGC(struct msa_struct *msa, char *tag, char *value)
{
  signed int tagidx;
  if(msa->gc_tag == ((char **)NULL))
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("msa.c", 517, sizeof(char *) /*8ul*/ );
    msa->gc_tag = (char **)return_value_sre_malloc$1;
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("msa.c", 518, sizeof(char *) /*8ul*/ );
    msa->gc = (char **)return_value_sre_malloc$2;
    msa->gc_idx=GKIInit();
    tagidx=GKIStoreKey(msa->gc_idx, tag);
    msa->gc[(signed long int)0] = (char *)(void *)0;
  }

  else
  {
    tagidx=GKIKeyIndex(msa->gc_idx, tag);
    if(!(tagidx >= 0))
    {
      tagidx=GKIStoreKey(msa->gc_idx, tag);
      void *return_value_sre_realloc$3;
      return_value_sre_realloc$3=sre_realloc("msa.c", 533, (void *)msa->gc_tag, (unsigned long int)(msa->ngc + 1) * sizeof(char **) /*8ul*/ );
      msa->gc_tag = (char **)return_value_sre_realloc$3;
      void *return_value_sre_realloc$4;
      return_value_sre_realloc$4=sre_realloc("msa.c", 534, (void *)msa->gc, (unsigned long int)(msa->ngc + 1) * sizeof(char **) /*8ul*/ );
      msa->gc = (char **)return_value_sre_realloc$4;
      msa->gc[(signed long int)tagidx] = (char *)(void *)0;
    }

  }
  if(tagidx == msa->ngc)
  {
    msa->gc_tag[(signed long int)tagidx]=sre_strdup(tag, -1);
    msa->ngc = msa->ngc + 1;
  }

  sre_strcat(&msa->gc[(signed long int)tagidx], -1, value, -1);
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// MSAAppendGR
// file msa.c line 590
extern void MSAAppendGR(struct msa_struct *msa, char *tag, signed int sqidx, char *value)
{
  signed int tagidx;
  signed int i;
  if(msa->gr_tag == ((char **)NULL))
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("msa.c", 601, sizeof(char *) /*8ul*/ );
    msa->gr_tag = (char **)return_value_sre_malloc$1;
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("msa.c", 602, sizeof(char **) /*8ul*/ );
    msa->gr = (char ***)return_value_sre_malloc$2;
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("msa.c", 603, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->gr[(signed long int)0] = (char **)return_value_sre_malloc$3;
    i = 0;
    for( ; !(i >= msa->nseqalloc); i = i + 1)
      msa->gr[(signed long int)0][(signed long int)i] = (char *)(void *)0;
    msa->gr_idx=GKIInit();
    tagidx=GKIStoreKey(msa->gr_idx, tag);
  }

  else
  {
    tagidx=GKIKeyIndex(msa->gr_idx, tag);
    if(!(tagidx >= 0))
    {
      tagidx=GKIStoreKey(msa->gr_idx, tag);
      void *return_value_sre_realloc$4;
      return_value_sre_realloc$4=sre_realloc("msa.c", 620, (void *)msa->gr_tag, (unsigned long int)(msa->ngr + 1) * sizeof(char *) /*8ul*/ );
      msa->gr_tag = (char **)return_value_sre_realloc$4;
      void *return_value_sre_realloc$5;
      return_value_sre_realloc$5=sre_realloc("msa.c", 621, (void *)msa->gr, (unsigned long int)(msa->ngr + 1) * sizeof(char **) /*8ul*/ );
      msa->gr = (char ***)return_value_sre_realloc$5;
      void *return_value_sre_malloc$6;
      return_value_sre_malloc$6=sre_malloc("msa.c", 622, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
      msa->gr[(signed long int)msa->ngr] = (char **)return_value_sre_malloc$6;
      i = 0;
      for( ; !(i >= msa->nseqalloc); i = i + 1)
        msa->gr[(signed long int)msa->ngr][(signed long int)i] = (char *)(void *)0;
    }

  }
  if(tagidx == msa->ngr)
  {
    msa->gr_tag[(signed long int)tagidx]=sre_strdup(tag, -1);
    msa->ngr = msa->ngr + 1;
  }

  sre_strcat(&msa->gr[(signed long int)tagidx][(signed long int)sqidx], -1, value, -1);
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// MSAAverageSequenceLength
// file msa.c line 1427
extern float MSAAverageSequenceLength(struct msa_struct *msa)
{
  signed int i;
  float avg = (float)0.;
  i = 0;
  signed int return_value_DealignedLength$1;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    return_value_DealignedLength$1=DealignedLength(msa->aseq[(signed long int)i]);
    avg = avg + (float)return_value_DealignedLength$1;
  }
  if(msa->nseq == 0)
    return (float)0.;

  else
    return avg / (float)msa->nseq;
}

// MSAExpand
// file msa.h line 235
extern void MSAExpand(struct msa_struct *msa)
{
  signed int i;
  signed int j;
  msa->nseqalloc = msa->nseqalloc + msa->nseqlump;
  void *return_value_sre_realloc$1;
  return_value_sre_realloc$1=sre_realloc("msa.c", 162, (void *)msa->aseq, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
  msa->aseq = (char **)return_value_sre_realloc$1;
  void *return_value_sre_realloc$2;
  return_value_sre_realloc$2=sre_realloc("msa.c", 163, (void *)msa->sqname, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
  msa->sqname = (char **)return_value_sre_realloc$2;
  void *return_value_sre_realloc$3;
  return_value_sre_realloc$3=sre_realloc("msa.c", 164, (void *)msa->sqlen, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
  msa->sqlen = (signed int *)return_value_sre_realloc$3;
  void *return_value_sre_realloc$4;
  return_value_sre_realloc$4=sre_realloc("msa.c", 165, (void *)msa->wgt, sizeof(float) /*4ul*/  * (unsigned long int)msa->nseqalloc);
  msa->wgt = (float *)return_value_sre_realloc$4;
  if(!(msa->ss == ((char **)NULL)))
  {
    void *return_value_sre_realloc$5;
    return_value_sre_realloc$5=sre_realloc("msa.c", 168, (void *)msa->ss, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->ss = (char **)return_value_sre_realloc$5;
    void *return_value_sre_realloc$6;
    return_value_sre_realloc$6=sre_realloc("msa.c", 169, (void *)msa->sslen, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseqalloc);
    msa->sslen = (signed int *)return_value_sre_realloc$6;
  }

  if(!(msa->sa == ((char **)NULL)))
  {
    void *return_value_sre_realloc$7;
    return_value_sre_realloc$7=sre_realloc("msa.c", 172, (void *)msa->sa, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->sa = (char **)return_value_sre_realloc$7;
    void *return_value_sre_realloc$8;
    return_value_sre_realloc$8=sre_realloc("msa.c", 173, (void *)msa->salen, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseqalloc);
    msa->salen = (signed int *)return_value_sre_realloc$8;
  }

  void *return_value_sre_realloc$9;
  if(!(msa->sqacc == ((char **)NULL)))
  {
    return_value_sre_realloc$9=sre_realloc("msa.c", 176, (void *)msa->sqacc, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->sqacc = (char **)return_value_sre_realloc$9;
  }

  void *return_value_sre_realloc$10;
  if(!(msa->sqdesc == ((char **)NULL)))
  {
    return_value_sre_realloc$10=sre_realloc("msa.c", 178, (void *)msa->sqdesc, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->sqdesc = (char **)return_value_sre_realloc$10;
  }

  i = msa->nseqalloc - msa->nseqlump;
  void *return_value_sre_realloc$11;
  void *return_value_sre_realloc$12;
  void *return_value_sre_realloc$13;
  for( ; !(i >= msa->nseqalloc); i = i + 1)
  {
    msa->sqname[(signed long int)i] = (char *)(void *)0;
    msa->wgt[(signed long int)i] = (float)-1.0;
    if(!(msa->sqacc == ((char **)NULL)))
      msa->sqacc[(signed long int)i] = (char *)(void *)0;

    if(!(msa->sqdesc == ((char **)NULL)))
      msa->sqdesc[(signed long int)i] = (char *)(void *)0;

    if(!(msa->alen == 0))
    {
      return_value_sre_realloc$11=sre_realloc("msa.c", 189, (void *)msa->aseq[(signed long int)i], sizeof(char) /*1ul*/  * (unsigned long int)(msa->alen + 1));
      msa->aseq[(signed long int)i] = (char *)return_value_sre_realloc$11;
    }

    else
      msa->aseq[(signed long int)i] = (char *)(void *)0;
    msa->sqlen[(signed long int)i] = 0;
    if(!(msa->ss == ((char **)NULL)))
    {
      if(!(msa->alen == 0))
      {
        return_value_sre_realloc$12=sre_realloc("msa.c", 195, (void *)msa->ss[(signed long int)i], sizeof(char) /*1ul*/  * (unsigned long int)(msa->alen + 1));
        msa->ss[(signed long int)i] = (char *)return_value_sre_realloc$12;
      }

      else
        msa->ss[(signed long int)i] = (char *)(void *)0;
      msa->sslen[(signed long int)i] = 0;
    }

    if(!(msa->sa == ((char **)NULL)))
    {
      if(!(msa->alen == 0))
      {
        return_value_sre_realloc$13=sre_realloc("msa.c", 201, (void *)msa->ss[(signed long int)i], sizeof(char) /*1ul*/  * (unsigned long int)(msa->alen + 1));
        msa->sa[(signed long int)i] = (char *)return_value_sre_realloc$13;
      }

      else
        msa->sa[(signed long int)i] = (char *)(void *)0;
      msa->salen[(signed long int)i] = 0;
    }

  }
  if(!(msa->gs == ((char ***)NULL)))
  {
    i = 0;
    for( ; !(i >= msa->ngs); i = i + 1)
      if(!(msa->gs[(signed long int)i] == ((char **)NULL)))
      {
        void *return_value_sre_realloc$14;
        return_value_sre_realloc$14=sre_realloc("msa.c", 217, (void *)msa->gs[(signed long int)i], sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
        msa->gs[(signed long int)i] = (char **)return_value_sre_realloc$14;
        j = msa->nseqalloc - msa->nseqlump;
        for( ; !(j >= msa->nseqalloc); j = j + 1)
          msa->gs[(signed long int)i][(signed long int)j] = (char *)(void *)0;
      }

  }

  if(!(msa->gr == ((char ***)NULL)))
  {
    i = 0;
    for( ; !(i >= msa->ngr); i = i + 1)
      if(!(msa->gr[(signed long int)i] == ((char **)NULL)))
      {
        void *return_value_sre_realloc$15;
        return_value_sre_realloc$15=sre_realloc("msa.c", 232, (void *)msa->gr[(signed long int)i], sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
        msa->gr[(signed long int)i] = (char **)return_value_sre_realloc$15;
        j = msa->nseqalloc - msa->nseqlump;
        for( ; !(j >= msa->nseqalloc); j = j + 1)
          msa->gr[(signed long int)i][(signed long int)j] = (char *)(void *)0;
      }

  }

  goto __CPROVER_DUMP_L27;

__CPROVER_DUMP_L27:
  ;
}

// MSAFileClose
// file msa.c line 941
extern void MSAFileClose(struct msafile_struct *afp)
{
  if(!(afp->do_gzip == 0))
    pclose(afp->f);

  if(afp->do_stdin == 0)
    fclose(afp->f);

  if(!(afp->buf == ((char *)NULL)))
    free((void *)afp->buf);

  if(!(afp->ssi == ((struct ssifile_s *)NULL)))
    SSIClose(afp->ssi);

  if(!(afp->fname == ((char *)NULL)))
    free((void *)afp->fname);

  free((void *)afp);
}

// MSAFileFormat
// file msa.c line 1121
extern signed int MSAFileFormat(struct msafile_struct *afp)
{
  signed int fmt;
  fmt=SeqfileFormat(afp->f);
  if(fmt == 7)
    fmt = 105;

  char *return_value_SeqfileFormat2String$1;
  if(!(fmt == 0) && !(fmt >= 101))
  {
    return_value_SeqfileFormat2String$1=SeqfileFormat2String(fmt);
    Die("File %s does not appear to be an alignment file;\nrather, it appears to be an unaligned file in %s format.\nI'm expecting an alignment file in this context.\n", afp->fname, return_value_SeqfileFormat2String$1);
  }

  return fmt;
}

// MSAFileGetLine
// file msa.h line 236
extern char * MSAFileGetLine(struct msafile_struct *afp)
{
  char *s;
  s=sre_fgets(&afp->buf, &afp->buflen, afp->f);
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    afp->linenumber = afp->linenumber + 1;
    return afp->buf;
  }
}

// MSAFileOpen
// file msa.c line 756
extern struct msafile_struct * MSAFileOpen(char *filename, signed int format, char *env)
{
  struct msafile_struct *afp;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("msa.c", 760, sizeof(struct msafile_struct) /*64ul*/ );
  afp = (struct msafile_struct *)return_value_sre_malloc$1;
  signed int return_value_strcmp$11;
  return_value_strcmp$11=strcmp(filename, "-");
  signed int return_value_Strparse$10;
  if(return_value_strcmp$11 == 0)
  {
    afp->f = stdin;
    afp->do_stdin = 1;
    afp->do_gzip = 0;
    afp->fname=sre_strdup("[STDIN]", -1);
    afp->ssi = (struct ssifile_s *)(void *)0;
  }

  else
  {
    return_value_Strparse$10=Strparse("^.*\\.gz$", filename, 0);
    if(!(return_value_Strparse$10 == 0))
    {
      char cmd[256l];
      signed int return_value_FileExists$2;
      return_value_FileExists$2=FileExists(filename);
      if(return_value_FileExists$2 == 0)
        Die("%s: file does not exist", filename);

      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(filename);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen("gzip -dc ");
      if(return_value_strlen$3 + return_value_strlen$4 >= 256ul)
        Die("filename > 255 char in MSAFileOpen()");

      sprintf(cmd, "gzip -dc %s", filename);
      afp->f=popen(cmd, "r");
      if(afp->f == ((struct _IO_FILE *)NULL))
        return (struct msafile_struct *)(void *)0;

      afp->do_stdin = 0;
      afp->do_gzip = 1;
      afp->fname=sre_strdup(filename, -1);
      afp->ssi = (struct ssifile_s *)(void *)0;
    }

    else
    {
      char *ssifile;
      char *dir;
      afp->f=fopen(filename, "r");
      if(!(afp->f == ((struct _IO_FILE *)NULL)))
      {
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(filename);
        void *return_value_sre_malloc$6;
        return_value_sre_malloc$6=sre_malloc("msa.c", 806, sizeof(char) /*1ul*/  * (return_value_strlen$5 + (unsigned long int)5));
        ssifile = (char *)return_value_sre_malloc$6;
        sprintf(ssifile, "%s.ssi", filename);
      }

      else
      {
        afp->f=EnvFileOpen(filename, env, &dir);
        if(!(afp->f == ((struct _IO_FILE *)NULL)))
        {
          char *full;
          full=FileConcat(dir, filename);
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(full);
          unsigned long int return_value_strlen$8;
          return_value_strlen$8=strlen(filename);
          void *return_value_sre_malloc$9;
          return_value_sre_malloc$9=sre_malloc("msa.c", 813, sizeof(char) /*1ul*/  * (return_value_strlen$7 + return_value_strlen$8 + (unsigned long int)5));
          ssifile = (char *)return_value_sre_malloc$9;
          sprintf(ssifile, "%s.ssi", full);
          free((void *)dir);
        }

        else
          return (struct msafile_struct *)(void *)0;
      }
      afp->do_stdin = 0;
      afp->do_gzip = 0;
      afp->fname=sre_strdup(filename, -1);
      afp->ssi = (struct ssifile_s *)(void *)0;
      SSIOpen(ssifile, &afp->ssi);
      free((void *)ssifile);
    }
  }
  _Bool tmp_if_expr$12;
  if(format == 0)
  {
    if(afp->do_stdin == 1)
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = afp->do_gzip != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
      Die("Can't autodetect alignment file format from a stdin or gzip pipe");

    format=MSAFileFormat(afp);
    if(format == 0)
      Die("Can't determine format of multiple alignment file %s", afp->fname);

  }

  afp->format = format;
  afp->linenumber = 0;
  afp->buf = (char *)(void *)0;
  afp->buflen = 0;
  return afp;
}

// MSAFilePositionByIndex
// file msa.c line 891
extern signed int MSAFilePositionByIndex(struct msafile_struct *afp, signed int idx)
{
  signed int fh;
  struct ssioffset_s offset;
  if(afp->ssi == ((struct ssifile_s *)NULL))
    return 0;

  else
  {
    signed int return_value_SSIGetOffsetByNumber$1;
    return_value_SSIGetOffsetByNumber$1=SSIGetOffsetByNumber(afp->ssi, idx, &fh, &offset);
    if(!(return_value_SSIGetOffsetByNumber$1 == 0))
      return 0;

    else
    {
      signed int return_value_SSISetFilePosition$2;
      return_value_SSISetFilePosition$2=SSISetFilePosition(afp->f, &offset);
      if(!(return_value_SSISetFilePosition$2 == 0))
        return 0;

      else
        return 1;
    }
  }
}

// MSAFilePositionByKey
// file msa.c line 880
extern signed int MSAFilePositionByKey(struct msafile_struct *afp, char *key)
{
  signed int fh;
  struct ssioffset_s offset;
  if(afp->ssi == ((struct ssifile_s *)NULL))
    return 0;

  else
  {
    signed int return_value_SSIGetOffsetByName$1;
    return_value_SSIGetOffsetByName$1=SSIGetOffsetByName(afp->ssi, key, &fh, &offset);
    if(!(return_value_SSIGetOffsetByName$1 == 0))
      return 0;

    else
    {
      signed int return_value_SSISetFilePosition$2;
      return_value_SSISetFilePosition$2=SSISetFilePosition(afp->f, &offset);
      if(!(return_value_SSISetFilePosition$2 == 0))
        return 0;

      else
        return 1;
    }
  }
}

// MSAFileRead
// file msa.c line 914
extern struct msa_struct * MSAFileRead(struct msafile_struct *afp)
{
  struct msa_struct *msa = (struct msa_struct *)(void *)0;
  switch(afp->format)
  {
    case 101:
    {
      msa=ReadStockholm(afp);
      break;
    }
    case 103:
    {
      msa=ReadMSF(afp);
      break;
    }
    case 105:
    {
      msa=ReadA2M(afp);
      break;
    }
    case 104:
    {
      msa=ReadClustal(afp);
      break;
    }
    case 102:
    {
      msa=ReadSELEX(afp);
      break;
    }
    case 106:
    {
      msa=ReadPhylip(afp);
      break;
    }
    default:
      Die("MSAFILE corrupted: bad format index");
  }
  return msa;
}

// MSAFileRewind
// file msa.c line 873
extern signed int MSAFileRewind(struct msafile_struct *afp)
{
  _Bool tmp_if_expr$1;
  if(!(afp->do_gzip == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = afp->do_stdin != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    rewind(afp->f);
    return 1;
  }
}

// MSAFileWrite
// file msa.c line 964
extern void MSAFileWrite(struct _IO_FILE *fp, struct msa_struct *msa, signed int outfmt, signed int do_oneline)
{
  switch(outfmt)
  {
    case 105:
    {
      WriteA2M(fp, msa);
      break;
    }
    case 104:
    {
      WriteClustal(fp, msa);
      break;
    }
    case 103:
    {
      WriteMSF(fp, msa);
      break;
    }
    case 106:
    {
      WritePhylip(fp, msa);
      break;
    }
    case 102:
    {
      WriteSELEX(fp, msa);
      break;
    }
    case 101:
    {
      if(!(do_oneline == 0))
        WriteStockholmOneBlock(fp, msa);

      else
        WriteStockholm(fp, msa);
      break;
    }
    default:
      Die("can't write. no such alignment format %d\n", outfmt);
  }
}

// MSAFree
// file msa.h line 226
extern void MSAFree(struct msa_struct *msa)
{
  Free2DArray((void **)msa->aseq, msa->nseq);
  Free2DArray((void **)msa->sqname, msa->nseq);
  Free2DArray((void **)msa->sqacc, msa->nseq);
  Free2DArray((void **)msa->sqdesc, msa->nseq);
  Free2DArray((void **)msa->ss, msa->nseq);
  Free2DArray((void **)msa->sa, msa->nseq);
  if(!(msa->sqlen == ((signed int *)NULL)))
    free((void *)msa->sqlen);

  if(!(msa->wgt == ((float *)NULL)))
    free((void *)msa->wgt);

  if(!(msa->name == ((char *)NULL)))
    free((void *)msa->name);

  if(!(msa->desc == ((char *)NULL)))
    free((void *)msa->desc);

  if(!(msa->acc == ((char *)NULL)))
    free((void *)msa->acc);

  if(!(msa->au == ((char *)NULL)))
    free((void *)msa->au);

  if(!(msa->ss_cons == ((char *)NULL)))
    free((void *)msa->ss_cons);

  if(!(msa->sa_cons == ((char *)NULL)))
    free((void *)msa->sa_cons);

  if(!(msa->rf == ((char *)NULL)))
    free((void *)msa->rf);

  if(!(msa->sslen == ((signed int *)NULL)))
    free((void *)msa->sslen);

  if(!(msa->salen == ((signed int *)NULL)))
    free((void *)msa->salen);

  Free2DArray((void **)msa->comment, msa->ncomment);
  Free2DArray((void **)msa->gf_tag, msa->ngf);
  Free2DArray((void **)msa->gf, msa->ngf);
  Free2DArray((void **)msa->gs_tag, msa->ngs);
  Free3DArray((void ***)msa->gs, msa->ngs, msa->nseq);
  Free2DArray((void **)msa->gc_tag, msa->ngc);
  Free2DArray((void **)msa->gc, msa->ngc);
  Free2DArray((void **)msa->gr_tag, msa->ngr);
  Free3DArray((void ***)msa->gr, msa->ngr, msa->nseq);
  GKIFree(msa->index);
  GKIFree(msa->gs_idx);
  GKIFree(msa->gc_idx);
  GKIFree(msa->gr_idx);
  free((void *)msa);
}

// MSAFromAINFO
// file msa.c line 1032
extern struct msa_struct * MSAFromAINFO(char **aseq, struct aliinfo_s *ainfo)
{
  struct msa_struct *msa;
  signed int i;
  signed int j;
  msa=MSAAlloc(ainfo->nseq, ainfo->alen);
  i = 0;
  for( ; !(i >= ainfo->nseq); i = i + 1)
  {
    strcpy(msa->aseq[(signed long int)i], aseq[(signed long int)i]);
    msa->wgt[(signed long int)i] = ainfo->wgt[(signed long int)i];
    msa->sqname[(signed long int)i]=sre_strdup((ainfo->sqinfo + (signed long int)i)->name, -1);
    msa->sqlen[(signed long int)i] = msa->alen;
    GKIStoreKey(msa->index, msa->sqname[(signed long int)i]);
    if(!((4 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
      MSASetSeqAccession(msa, i, (ainfo->sqinfo + (signed long int)i)->acc);

    if(!((8 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
      MSASetSeqDescription(msa, i, (ainfo->sqinfo + (signed long int)i)->desc);

    if(!((512 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
    {
      if(msa->ss == ((char **)NULL))
      {
        void *return_value_sre_malloc$1;
        return_value_sre_malloc$1=sre_malloc("msa.c", 1054, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
        msa->ss = (char **)return_value_sre_malloc$1;
        void *return_value_sre_malloc$2;
        return_value_sre_malloc$2=sre_malloc("msa.c", 1055, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseqalloc);
        msa->sslen = (signed int *)return_value_sre_malloc$2;
        j = 0;
        for( ; !(j >= msa->nseqalloc); j = j + 1)
        {
          msa->ss[(signed long int)j] = (char *)(void *)0;
          msa->sslen[(signed long int)j] = 0;
        }
      }

      MakeAlignedString(msa->aseq[(signed long int)i], msa->alen, (ainfo->sqinfo + (signed long int)i)->ss, &msa->ss[(signed long int)i]);
      msa->sslen[(signed long int)i] = msa->alen;
    }

    if(!((1024 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
    {
      if(msa->sa == ((char **)NULL))
      {
        void *return_value_sre_malloc$3;
        return_value_sre_malloc$3=sre_malloc("msa.c", 1067, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
        msa->sa = (char **)return_value_sre_malloc$3;
        void *return_value_sre_malloc$4;
        return_value_sre_malloc$4=sre_malloc("msa.c", 1068, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseqalloc);
        msa->salen = (signed int *)return_value_sre_malloc$4;
        j = 0;
        for( ; !(j >= msa->nseqalloc); j = j + 1)
        {
          msa->sa[(signed long int)j] = (char *)(void *)0;
          msa->salen[(signed long int)j] = 0;
        }
      }

      MakeAlignedString(msa->aseq[(signed long int)i], msa->alen, (ainfo->sqinfo + (signed long int)i)->sa, &msa->sa[(signed long int)i]);
      msa->salen[(signed long int)i] = msa->alen;
    }

  }
  msa->name=sre_strdup(ainfo->name, -1);
  msa->desc=sre_strdup(ainfo->desc, -1);
  msa->acc=sre_strdup(ainfo->acc, -1);
  msa->au=sre_strdup(ainfo->au, -1);
  msa->ss_cons=sre_strdup(ainfo->cs, -1);
  msa->rf=sre_strdup(ainfo->rf, -1);
  if(!((1 & ainfo->flags) == 0))
  {
    msa->cutoff[(signed long int)0] = ainfo->tc1;
    msa->cutoff_is_set[(signed long int)0] = 1;
    msa->cutoff[(signed long int)1] = ainfo->tc2;
    msa->cutoff_is_set[(signed long int)1] = 1;
  }

  if(!((2 & ainfo->flags) == 0))
  {
    msa->cutoff[(signed long int)4] = ainfo->nc1;
    msa->cutoff_is_set[(signed long int)4] = 1;
    msa->cutoff[(signed long int)5] = ainfo->nc2;
    msa->cutoff_is_set[(signed long int)5] = 1;
  }

  if(!((4 & ainfo->flags) == 0))
  {
    msa->cutoff[(signed long int)2] = ainfo->ga1;
    msa->cutoff_is_set[(signed long int)2] = 1;
    msa->cutoff[(signed long int)3] = ainfo->ga2;
    msa->cutoff_is_set[(signed long int)3] = 1;
  }

  msa->nseq = ainfo->nseq;
  msa->alen = ainfo->alen;
  return msa;
}

// MSAGetGC
// file ../squid/msa.h line 243
extern char * MSAGetGC(struct msa_struct *msa, char *tag)
{
  signed int tagidx;
  if(msa->gc_idx == ((struct anonymous$0 *)NULL))
    return (char *)(void *)0;

  else
  {
    tagidx=GKIKeyIndex(msa->gc_idx, tag);
    if(!(tagidx >= 0))
      return (char *)(void *)0;

    else
      return msa->gc[(signed long int)tagidx];
  }
}

// MSAGetSeqAccession
// file msa.c line 1377
extern char * MSAGetSeqAccession(struct msa_struct *msa, signed int idx)
{
  _Bool tmp_if_expr$1;
  if(!(msa->sqacc == ((char **)NULL)))
    tmp_if_expr$1 = msa->sqacc[(signed long int)idx] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    return msa->sqacc[(signed long int)idx];

  else
    return (char *)(void *)0;
}

// MSAGetSeqDescription
// file msa.c line 1385
extern char * MSAGetSeqDescription(struct msa_struct *msa, signed int idx)
{
  _Bool tmp_if_expr$1;
  if(!(msa->sqdesc == ((char **)NULL)))
    tmp_if_expr$1 = msa->sqdesc[(signed long int)idx] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    return msa->sqdesc[(signed long int)idx];

  else
    return (char *)(void *)0;
}

// MSAGetSeqSA
// file msa.c line 1401
extern char * MSAGetSeqSA(struct msa_struct *msa, signed int idx)
{
  _Bool tmp_if_expr$1;
  if(!(msa->sa == ((char **)NULL)))
    tmp_if_expr$1 = msa->sa[(signed long int)idx] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    return msa->sa[(signed long int)idx];

  else
    return (char *)(void *)0;
}

// MSAGetSeqSS
// file msa.c line 1393
extern char * MSAGetSeqSS(struct msa_struct *msa, signed int idx)
{
  _Bool tmp_if_expr$1;
  if(!(msa->ss == ((char **)NULL)))
    tmp_if_expr$1 = msa->ss[(signed long int)idx] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    return msa->ss[(signed long int)idx];

  else
    return (char *)(void *)0;
}

// MSAGetSeqidx
// file msa.h line 246
extern signed int MSAGetSeqidx(struct msa_struct *msa, char *name, signed int guess)
{
  signed int seqidx;
  signed int return_value_strcmp$1;
  if(guess >= 0)
  {
    if(guess >= msa->nseq)
      goto __CPROVER_DUMP_L1;

    return_value_strcmp$1=strcmp(name, msa->sqname[(signed long int)guess]);
    if(!(return_value_strcmp$1 == 0))
      goto __CPROVER_DUMP_L1;

    return guess;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    seqidx=GKIKeyIndex(msa->index, name);
    if(seqidx >= 0)
      return seqidx;

    else
    {
      seqidx=GKIStoreKey(msa->index, name);
      if(seqidx >= msa->nseqalloc)
        MSAExpand(msa);

      msa->sqname[(signed long int)seqidx]=sre_strdup(name, -1);
      msa->nseq = msa->nseq + 1;
      return seqidx;
    }
  }
}

// MSAMingap
// file msa.c line 1150
extern void MSAMingap(struct msa_struct *msa)
{
  signed int *useme;
  signed int apos;
  signed int idx;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("msa.c", 1156, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->alen);
  useme = (signed int *)return_value_sre_malloc$1;
  apos = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  for( ; !(apos >= msa->alen); apos = apos + 1)
  {
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 32)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$5)
        break;

    }
    if(idx == msa->nseq)
      useme[(signed long int)apos] = 0;

    else
      useme[(signed long int)apos] = 1;
  }
  MSAShorterAlignment(msa, useme);
  free((void *)useme);
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// MSANogap
// file msa.c line 1182
extern void MSANogap(struct msa_struct *msa)
{
  signed int *useme;
  signed int apos;
  signed int idx;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("msa.c", 1188, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->alen);
  useme = (signed int *)return_value_sre_malloc$1;
  apos = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  for( ; !(apos >= msa->alen); apos = apos + 1)
  {
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 32)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        break;

    }
    if(idx == msa->nseq)
      useme[(signed long int)apos] = 1;

    else
      useme[(signed long int)apos] = 0;
  }
  MSAShorterAlignment(msa, useme);
  free((void *)useme);
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// MSASetSeqAccession
// file ../squid/msa.h line 237
extern void MSASetSeqAccession(struct msa_struct *msa, signed int seqidx, char *acc)
{
  signed int x;
  if(msa->sqacc == ((char **)NULL))
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("msa.c", 310, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->sqacc = (char **)return_value_sre_malloc$1;
    x = 0;
    for( ; !(x >= msa->nseqalloc); x = x + 1)
      msa->sqacc[(signed long int)x] = (char *)(void *)0;
  }

  msa->sqacc[(signed long int)seqidx]=sre_strdup(acc, -1);
}

// MSASetSeqDescription
// file ../squid/msa.h line 238
extern void MSASetSeqDescription(struct msa_struct *msa, signed int seqidx, char *desc)
{
  signed int x;
  if(msa->sqdesc == ((char **)NULL))
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("msa.c", 335, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
    msa->sqdesc = (char **)return_value_sre_malloc$1;
    x = 0;
    for( ; !(x >= msa->nseqalloc); x = x + 1)
      msa->sqdesc[(signed long int)x] = (char *)(void *)0;
  }

  msa->sqdesc[(signed long int)seqidx]=sre_strdup(desc, -1);
}

// MSAShorterAlignment
// file msa.c line 1218
extern void MSAShorterAlignment(struct msa_struct *msa, signed int *useme)
{
  signed int apos;
  signed int mpos;
  signed int idx;
  signed int i;
  apos = 0;
  mpos = 0;
  for( ; !(apos >= msa->alen); apos = apos + 1)
    if(!(useme[(signed long int)apos] == 0))
    {
      if(!(mpos == apos))
      {
        idx = 0;
        for( ; !(idx >= msa->nseq); idx = idx + 1)
        {
          msa->aseq[(signed long int)idx][(signed long int)mpos] = msa->aseq[(signed long int)idx][(signed long int)apos];
          if(!(msa->ss == ((char **)NULL)))
          {
            if(!(msa->ss[(signed long int)idx] == ((char *)NULL)))
              msa->ss[(signed long int)idx][(signed long int)mpos] = msa->ss[(signed long int)idx][(signed long int)apos];

          }

          if(!(msa->sa == ((char **)NULL)))
          {
            if(!(msa->sa[(signed long int)idx] == ((char *)NULL)))
              msa->sa[(signed long int)idx][(signed long int)mpos] = msa->sa[(signed long int)idx][(signed long int)apos];

          }

          i = 0;
          for( ; !(i >= msa->ngr); i = i + 1)
            if(!(msa->gr[(signed long int)i][(signed long int)idx] == ((char *)NULL)))
              msa->gr[(signed long int)i][(signed long int)idx][(signed long int)mpos] = msa->gr[(signed long int)i][(signed long int)idx][(signed long int)apos];

        }
        if(!(msa->ss_cons == ((char *)NULL)))
          msa->ss_cons[(signed long int)mpos] = msa->ss_cons[(signed long int)apos];

        if(!(msa->sa_cons == ((char *)NULL)))
          msa->sa_cons[(signed long int)mpos] = msa->sa_cons[(signed long int)apos];

        if(!(msa->rf == ((char *)NULL)))
          msa->rf[(signed long int)mpos] = msa->rf[(signed long int)apos];

        i = 0;
        for( ; !(i >= msa->ngc); i = i + 1)
          msa->gc[(signed long int)i][(signed long int)mpos] = msa->gc[(signed long int)i][(signed long int)apos];
      }

      mpos = mpos + 1;
    }

  msa->alen = mpos;
  idx = 0;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    msa->aseq[(signed long int)idx][(signed long int)mpos] = (char)0;
    if(!(msa->ss == ((char **)NULL)))
    {
      if(!(msa->ss[(signed long int)idx] == ((char *)NULL)))
        msa->ss[(signed long int)idx][(signed long int)mpos] = (char)0;

    }

    if(!(msa->sa == ((char **)NULL)))
    {
      if(!(msa->sa[(signed long int)idx] == ((char *)NULL)))
        msa->sa[(signed long int)idx][(signed long int)mpos] = (char)0;

    }

    i = 0;
    for( ; !(i >= msa->ngr); i = i + 1)
      if(!(msa->gr[(signed long int)i][(signed long int)idx] == ((char *)NULL)))
        msa->gr[(signed long int)i][(signed long int)idx][(signed long int)mpos] = (char)0;

  }
  if(!(msa->ss_cons == ((char *)NULL)))
    msa->ss_cons[(signed long int)mpos] = (char)0;

  if(!(msa->sa_cons == ((char *)NULL)))
    msa->sa_cons[(signed long int)mpos] = (char)0;

  if(!(msa->rf == ((char *)NULL)))
    msa->rf[(signed long int)mpos] = (char)0;

  i = 0;
  for( ; !(i >= msa->ngc); i = i + 1)
    msa->gc[(signed long int)i][(signed long int)mpos] = (char)0;
  goto __CPROVER_DUMP_L28;

__CPROVER_DUMP_L28:
  ;
}

// MSASmallerAlignment
// file msa.c line 1305
extern void MSASmallerAlignment(struct msa_struct *msa, signed int *useme, struct msa_struct **ret_new)
{
  struct msa_struct *new;
  signed int nnew;
  signed int oidx;
  signed int nidx;
  signed int i;
  nnew = 0;
  oidx = 0;
  for( ; !(oidx >= msa->nseq); oidx = oidx + 1)
    if(!(useme[(signed long int)oidx] == 0))
      nnew = nnew + 1;

  void *return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  if(nnew == 0)
    *ret_new = (struct msa_struct *)(void *)0;

  else
  {
    new=MSAAlloc(nnew, 0);
    nidx = 0;
    oidx = 0;
    for( ; !(oidx >= msa->nseq); oidx = oidx + 1)
      if(!(useme[(signed long int)oidx] == 0))
      {
        new->aseq[(signed long int)nidx]=sre_strdup(msa->aseq[(signed long int)oidx], msa->alen);
        new->sqname[(signed long int)nidx]=sre_strdup(msa->sqname[(signed long int)oidx], msa->alen);
        GKIStoreKey(new->index, msa->sqname[(signed long int)oidx]);
        new->wgt[(signed long int)nidx] = msa->wgt[(signed long int)oidx];
        if(!(msa->sqacc == ((char **)NULL)))
          MSASetSeqAccession(new, nidx, msa->sqacc[(signed long int)oidx]);

        if(!(msa->sqdesc == ((char **)NULL)))
          MSASetSeqDescription(new, nidx, msa->sqdesc[(signed long int)oidx]);

        if(!(msa->ss == ((char **)NULL)))
        {
          if(!(msa->ss[(signed long int)oidx] == ((char *)NULL)))
          {
            if(new->ss == ((char **)NULL))
            {
              return_value_sre_malloc$1=sre_malloc("msa.c", 1332, sizeof(char *) /*8ul*/  * (unsigned long int)new->nseq);
              new->ss = (char **)return_value_sre_malloc$1;
            }

            new->ss[(signed long int)nidx]=sre_strdup(msa->ss[(signed long int)oidx], -1);
          }

        }

        if(!(msa->sa == ((char **)NULL)))
        {
          if(!(msa->sa[(signed long int)oidx] == ((char *)NULL)))
          {
            if(new->sa == ((char **)NULL))
            {
              return_value_sre_malloc$2=sre_malloc("msa.c", 1337, sizeof(char *) /*8ul*/  * (unsigned long int)new->nseq);
              new->sa = (char **)return_value_sre_malloc$2;
            }

            new->sa[(signed long int)nidx]=sre_strdup(msa->sa[(signed long int)oidx], -1);
          }

        }

        nidx = nidx + 1;
      }

    new->nseq = nnew;
    new->alen = msa->alen;
    new->flags = msa->flags;
    new->type = msa->type;
    new->name=sre_strdup(msa->name, -1);
    new->desc=sre_strdup(msa->desc, -1);
    new->acc=sre_strdup(msa->acc, -1);
    new->au=sre_strdup(msa->au, -1);
    new->ss_cons=sre_strdup(msa->ss_cons, -1);
    new->sa_cons=sre_strdup(msa->sa_cons, -1);
    new->rf=sre_strdup(msa->rf, -1);
    i = 0;
    for( ; !(i >= 6); i = i + 1)
    {
      new->cutoff[(signed long int)i] = msa->cutoff[(signed long int)i];
      new->cutoff_is_set[(signed long int)i] = msa->cutoff_is_set[(signed long int)i];
    }
    free((void *)new->sqlen);
    MSAMingap(new);
    *ret_new = new;
    goto __CPROVER_DUMP_L16;
  }

__CPROVER_DUMP_L16:
  ;
}

// MSAToSqinfo
// file sqio.c line 1849
extern struct seqinfo_s * MSAToSqinfo(struct msa_struct *msa)
{
  signed int idx;
  struct seqinfo_s *sqinfo;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("sqio.c", 1854, sizeof(struct seqinfo_s) /*360ul*/  * (unsigned long int)msa->nseq);
  sqinfo = (struct seqinfo_s *)return_value_sre_malloc$1;
  idx = 0;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    (sqinfo + (signed long int)idx)->flags = 0;
    SetSeqinfoString(&sqinfo[(signed long int)idx], msa->sqname[(signed long int)idx], 1 << 0);
    char *return_value_MSAGetSeqAccession$2;
    return_value_MSAGetSeqAccession$2=MSAGetSeqAccession(msa, idx);
    SetSeqinfoString(&sqinfo[(signed long int)idx], return_value_MSAGetSeqAccession$2, 1 << 2);
    char *return_value_MSAGetSeqDescription$3;
    return_value_MSAGetSeqDescription$3=MSAGetSeqDescription(msa, idx);
    SetSeqinfoString(&sqinfo[(signed long int)idx], return_value_MSAGetSeqDescription$3, 1 << 3);
    if(!(msa->ss == ((char **)NULL)))
    {
      if(!(msa->ss[(signed long int)idx] == ((char *)NULL)))
      {
        MakeDealignedString(msa->aseq[(signed long int)idx], msa->alen, msa->ss[(signed long int)idx], &(sqinfo + (signed long int)idx)->ss);
        (sqinfo + (signed long int)idx)->flags = (sqinfo + (signed long int)idx)->flags | 1 << 9;
      }

    }

    if(!(msa->sa == ((char **)NULL)))
    {
      if(!(msa->sa[(signed long int)idx] == ((char *)NULL)))
      {
        MakeDealignedString(msa->aseq[(signed long int)idx], msa->alen, msa->sa[(signed long int)idx], &(sqinfo + (signed long int)idx)->sa);
        (sqinfo + (signed long int)idx)->flags = (sqinfo + (signed long int)idx)->flags | 1 << 10;
      }

    }

    (sqinfo + (signed long int)idx)->len=DealignedLength(msa->aseq[(signed long int)idx]);
    (sqinfo + (signed long int)idx)->flags = (sqinfo + (signed long int)idx)->flags | 1 << 6;
  }
  return sqinfo;
}

// MSAVerifyParse
// file msa.h line 245
extern void MSAVerifyParse(struct msa_struct *msa)
{
  signed int idx;
  char *tmp_if_expr$1;
  if(msa->nseq == 0)
  {
    if(!(msa->name == ((char *)NULL)))
      tmp_if_expr$1 = msa->name;

    else
      tmp_if_expr$1 = "";
    Die("Parse error: no sequences were found for alignment %s", tmp_if_expr$1);
  }

  msa->alen = msa->sqlen[(signed long int)0];
  idx = 0;
  char *tmp_if_expr$2;
  char *tmp_if_expr$3;
  char *tmp_if_expr$4;
  char *tmp_if_expr$5;
  char *tmp_if_expr$6;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    if(msa->aseq[(signed long int)idx] == ((char *)NULL))
    {
      if(!(msa->name == ((char *)NULL)))
        tmp_if_expr$2 = msa->name;

      else
        tmp_if_expr$2 = "";
      Die("Parse error: No sequence for %s in alignment %s", msa->sqname[(signed long int)idx], tmp_if_expr$2);
    }

    if(!((1 & msa->flags) == 0))
    {
      if(IEEE_FLOAT_EQUAL((double)msa->wgt[(signed long int)idx], -1.000000))
      {
        if(!(msa->name == ((char *)NULL)))
          tmp_if_expr$3 = msa->name;

        else
          tmp_if_expr$3 = "";
        Die("Parse error: some weights are set, but %s doesn't have one in alignment %s", msa->sqname[(signed long int)idx], tmp_if_expr$3);
      }

    }

    if(!(msa->sqlen[(signed long int)idx] == msa->alen))
    {
      if(!(msa->name == ((char *)NULL)))
        tmp_if_expr$4 = msa->name;

      else
        tmp_if_expr$4 = "";
      Die("Parse error: sequence %s: length %d, expected %d in alignment %s", msa->sqname[(signed long int)idx], msa->sqlen[(signed long int)idx], msa->alen, tmp_if_expr$4);
    }

    if(!(msa->ss == ((char **)NULL)))
    {
      if(!(msa->ss[(signed long int)idx] == ((char *)NULL)))
      {
        if(!(msa->sslen[(signed long int)idx] == msa->alen))
        {
          if(!(msa->name == ((char *)NULL)))
            tmp_if_expr$5 = msa->name;

          else
            tmp_if_expr$5 = "";
          Die("Parse error: #=GR SS annotation for %s: length %d, expected %d in alignment %s", msa->sqname[(signed long int)idx], msa->sslen[(signed long int)idx], msa->alen, tmp_if_expr$5);
        }

      }

    }

    if(!(msa->sa == ((char **)NULL)))
    {
      if(!(msa->sa[(signed long int)idx] == ((char *)NULL)))
      {
        if(!(msa->salen[(signed long int)idx] == msa->alen))
        {
          if(!(msa->name == ((char *)NULL)))
            tmp_if_expr$6 = msa->name;

          else
            tmp_if_expr$6 = "";
          Die("Parse error: #=GR SA annotation for %s: length %d, expected %d in alignment %s", msa->sqname[(signed long int)idx], msa->salen[(signed long int)idx], msa->alen, tmp_if_expr$6);
        }

      }

    }

  }
  unsigned long int return_value_strlen$9;
  unsigned long int return_value_strlen$7;
  char *tmp_if_expr$8;
  if(!(msa->ss_cons == ((char *)NULL)))
  {
    return_value_strlen$9=strlen(msa->ss_cons);
    if(!(return_value_strlen$9 == (unsigned long int)msa->alen))
    {
      return_value_strlen$7=strlen(msa->ss_cons);
      if(!(msa->name == ((char *)NULL)))
        tmp_if_expr$8 = msa->name;

      else
        tmp_if_expr$8 = "";
      Die("Parse error: #=GC SS_cons annotation: length %d, expected %d in alignment %s", return_value_strlen$7, msa->alen, tmp_if_expr$8);
    }

  }

  unsigned long int return_value_strlen$12;
  unsigned long int return_value_strlen$10;
  char *tmp_if_expr$11;
  if(!(msa->sa_cons == ((char *)NULL)))
  {
    return_value_strlen$12=strlen(msa->sa_cons);
    if(!(return_value_strlen$12 == (unsigned long int)msa->alen))
    {
      return_value_strlen$10=strlen(msa->sa_cons);
      if(!(msa->name == ((char *)NULL)))
        tmp_if_expr$11 = msa->name;

      else
        tmp_if_expr$11 = "";
      Die("Parse error: #=GC SA_cons annotation: length %d, expected %d in alignment %s", return_value_strlen$10, msa->alen, tmp_if_expr$11);
    }

  }

  unsigned long int return_value_strlen$15;
  unsigned long int return_value_strlen$13;
  char *tmp_if_expr$14;
  if(!(msa->rf == ((char *)NULL)))
  {
    return_value_strlen$15=strlen(msa->rf);
    if(!(return_value_strlen$15 == (unsigned long int)msa->alen))
    {
      return_value_strlen$13=strlen(msa->rf);
      if(!(msa->name == ((char *)NULL)))
        tmp_if_expr$14 = msa->name;

      else
        tmp_if_expr$14 = "";
      Die("Parse error: #=GC RF annotation: length %d, expected %d in alignment %s", return_value_strlen$13, msa->alen, tmp_if_expr$14);
    }

  }

  if((1 & msa->flags) == 0)
    FSet(msa->wgt, msa->nseq, (float)1.0);

  if(!(msa->sqlen == ((signed int *)NULL)))
  {
    free((void *)msa->sqlen);
    msa->sqlen = (signed int *)(void *)0;
  }

  if(!(msa->sslen == ((signed int *)NULL)))
  {
    free((void *)msa->sslen);
    msa->sslen = (signed int *)(void *)0;
  }

  if(!(msa->salen == ((signed int *)NULL)))
  {
    free((void *)msa->salen);
    msa->salen = (signed int *)(void *)0;
  }

  goto __CPROVER_DUMP_L34;

__CPROVER_DUMP_L34:
  ;
}

// MajorityRuleConsensus
// file aligneval.c line 475
extern char * MajorityRuleConsensus(char **aseq, signed int nseq, signed int alen)
{
  char *cs;
  signed int count[27l];
  signed int idx;
  signed int apos;
  signed int spos;
  signed int x;
  signed int sym;
  signed int max;
  signed int bestx;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("aligneval.c", 485, sizeof(char) /*1ul*/  * (unsigned long int)(alen + 1));
  cs = (char *)return_value_sre_malloc$1;
  spos = 0;
  apos = 0;
  signed int tmp_post$3;
  for( ; !(apos >= alen); apos = apos + 1)
  {
    x = 0;
    for( ; !(x >= 27); x = x + 1)
      count[(signed long int)x] = 0;
    idx = 0;
    for( ; !(idx >= nseq); idx = idx + 1)
    {
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)aseq[(signed long int)idx][(signed long int)apos]]) == 0))
      {
        sym=toupper((signed int)aseq[(signed long int)idx][(signed long int)apos]);
        count[(signed long int)(sym - 65)] = count[(signed long int)(sym - 65)] + 1;
      }

      else
        count[(signed long int)26] = count[(signed long int)26] + 1;
    }
    if((float)count[26l] / (float)nseq <= 5.000000e-1f)
    {
      bestx = -1;
      max = bestx;
      x = 0;
      for( ; !(x >= 26); x = x + 1)
        if(!(max >= count[(signed long int)x]))
        {
          max = count[(signed long int)x];
          bestx = x;
        }

      tmp_post$3 = spos;
      spos = spos + 1;
      cs[(signed long int)tmp_post$3] = (char)(65 + bestx);
    }

  }
  cs[(signed long int)spos] = (char)0;
  return cs;
}

// MakeAlignedString
// file ../squid/sqfuncs.h line 46
extern signed int MakeAlignedString(char *aseq, signed int alen, char *ss, char **ret_s)
{
  char *new;
  signed int apos;
  signed int rpos;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("alignio.c", 242, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
  new = (char *)return_value_sre_malloc$1;
  rpos = 0;
  apos = rpos;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  for( ; !(apos >= alen); apos = apos + 1)
  {
    if((signed int)aseq[(signed long int)apos] == 32)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)aseq[(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)aseq[(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)aseq[(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)aseq[(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$5)
    {
      new[(signed long int)apos] = ss[(signed long int)rpos];
      rpos = rpos + 1;
    }

    else
      new[(signed long int)apos] = (char)46;
  }
  new[(signed long int)apos] = (char)0;
  unsigned long int return_value_strlen$6;
  return_value_strlen$6=strlen(ss);
  if(!((unsigned long int)rpos == return_value_strlen$6))
  {
    squid_errno = 6;
    free((void *)new);
    return 0;
  }

  else
  {
    *ret_s = new;
    return 1;
  }
}

// MakeDealignedString
// file alignio.c line 275
extern signed int MakeDealignedString(char *aseq, signed int alen, char *ss, char **ret_s)
{
  char *new;
  signed int apos;
  signed int rpos;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("alignio.c", 280, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
  new = (char *)return_value_sre_malloc$1;
  rpos = 0;
  apos = rpos;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  for( ; !(apos >= alen); apos = apos + 1)
  {
    if((signed int)aseq[(signed long int)apos] == 32)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)aseq[(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)aseq[(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)aseq[(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)aseq[(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$5)
    {
      new[(signed long int)rpos] = ss[(signed long int)apos];
      rpos = rpos + 1;
    }

  }
  new[(signed long int)rpos] = (char)0;
  unsigned long int return_value_strlen$6;
  return_value_strlen$6=strlen(ss);
  if(!((unsigned long int)alen == return_value_strlen$6))
  {
    squid_errno = 6;
    free((void *)new);
    return 0;
  }

  else
  {
    *ret_s = new;
    return 1;
  }
}

// MakeDiffMx
// file cluster.c line 384
extern void MakeDiffMx(char **aseqs, signed int num, float ***ret_dmx)
{
  float **dmx;
  signed int i;
  signed int j;
  dmx=FMX2Alloc(num, num);
  i = 0;
  float return_value_PairwiseIdentity$1;
  for( ; !(i >= num); i = i + 1)
  {
    j = i;
    for( ; !(j >= num); j = j + 1)
    {
      return_value_PairwiseIdentity$1=PairwiseIdentity(aseqs[(signed long int)i], aseqs[(signed long int)j]);
      dmx[(signed long int)j][(signed long int)i] = (float)(1.0 - (double)return_value_PairwiseIdentity$1);
      dmx[(signed long int)i][(signed long int)j] = dmx[(signed long int)j][(signed long int)i];
    }
  }
  *ret_dmx = dmx;
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// MakeIdentityMx
// file cluster.c line 420
extern void MakeIdentityMx(char **aseqs, signed int num, float ***ret_imx)
{
  float **imx;
  signed int i;
  signed int j;
  imx=FMX2Alloc(num, num);
  i = 0;
  for( ; !(i >= num); i = i + 1)
  {
    j = i;
    for( ; !(j >= num); j = j + 1)
    {
      imx[(signed long int)j][(signed long int)i]=PairwiseIdentity(aseqs[(signed long int)i], aseqs[(signed long int)j]);
      imx[(signed long int)i][(signed long int)j] = imx[(signed long int)j][(signed long int)i];
    }
  }
  *ret_imx = imx;
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// MasterTraceFromMap
// file trace.c line 1036
extern struct p7trace_s * MasterTraceFromMap(signed int *map, signed int M, signed int alen)
{
  struct p7trace_s *tr;
  signed int tpos;
  signed int apos;
  signed int k;
  P7AllocTrace(alen + 6, &tr);
  tpos = 0;
  TraceSet(tr, tpos, (char)4, 0, 0);
  tpos = tpos + 1;
  TraceSet(tr, tpos, (char)5, 0, 0);
  tpos = tpos + 1;
  apos = 1;
  for( ; !(apos >= map[1l]); apos = apos + 1)
  {
    TraceSet(tr, tpos, (char)5, 0, apos);
    tpos = tpos + 1;
  }
  TraceSet(tr, tpos, (char)6, 0, 0);
  tpos = tpos + 1;
  k = 1;
  for( ; !(k >= M); k = k + 1)
  {
    TraceSet(tr, tpos, (char)1, k, apos);
    tpos = tpos + 1;
    apos = apos + 1;
    for( ; !(apos >= map[(signed long int)(1 + k)]); apos = apos + 1)
    {
      TraceSet(tr, tpos, (char)3, k, apos);
      tpos = tpos + 1;
    }
  }
  TraceSet(tr, tpos, (char)1, M, apos);
  tpos = tpos + 1;
  apos = apos + 1;
  TraceSet(tr, tpos, (char)7, 0, 0);
  tpos = tpos + 1;
  TraceSet(tr, tpos, (char)8, 0, 0);
  tpos = tpos + 1;
  for( ; alen >= apos; apos = apos + 1)
  {
    TraceSet(tr, tpos, (char)8, 0, apos);
    tpos = tpos + 1;
  }
  TraceSet(tr, tpos, (char)9, 0, 0);
  tpos = tpos + 1;
  tr->tlen = tpos;
  return tr;
}

// MergeTraceArrays
// file trace.c line 105
extern struct p7trace_s ** MergeTraceArrays(struct p7trace_s **t1, signed int n1, struct p7trace_s **t2, signed int n2)
{
  struct p7trace_s **tr;
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("trace.c", 110, sizeof(struct p7trace_s *) /*8ul*/  * (unsigned long int)(n1 + n2));
  tr = (struct p7trace_s **)return_value_sre_malloc$1;
  i = 0;
  for( ; !(i >= n1); i = i + 1)
    tr[(signed long int)i] = t1[(signed long int)i];
  i = 0;
  for( ; !(i >= n2); i = i + 1)
    tr[(signed long int)(n1 + i)] = t2[(signed long int)i];
  free((void *)t1);
  free((void *)t2);
  return tr;
}

// MingapAlignment
// file alignio.c line 431
extern signed int MingapAlignment(char **aseqs, struct aliinfo_s *ainfo)
{
  signed int apos;
  signed int mpos;
  signed int idx;
  apos = 0;
  mpos = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  for( ; !((signed int)(*aseqs)[(signed long int)apos] == 0); apos = apos + 1)
  {
    idx = 0;
    for( ; !(idx >= ainfo->nseq); idx = idx + 1)
    {
      if((signed int)aseqs[(signed long int)idx][(signed long int)apos] == 32)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)aseqs[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$4)
        break;

    }
    if(!(idx == ainfo->nseq))
    {
      if(!(mpos == apos))
      {
        idx = 0;
        for( ; !(idx >= ainfo->nseq); idx = idx + 1)
          aseqs[(signed long int)idx][(signed long int)mpos] = aseqs[(signed long int)idx][(signed long int)apos];
        if(!(ainfo->cs == ((char *)NULL)))
          ainfo->cs[(signed long int)mpos] = ainfo->cs[(signed long int)apos];

        if(!(ainfo->rf == ((char *)NULL)))
          ainfo->rf[(signed long int)mpos] = ainfo->rf[(signed long int)apos];

      }

      mpos = mpos + 1;
    }

  }
  idx = 0;
  for( ; !(idx >= ainfo->nseq); idx = idx + 1)
    aseqs[(signed long int)idx][(signed long int)mpos] = (char)0;
  ainfo->alen = mpos;
  if(!(ainfo->cs == ((char *)NULL)))
    ainfo->cs[(signed long int)mpos] = (char)0;

  if(!(ainfo->rf == ((char *)NULL)))
    ainfo->rf[(signed long int)mpos] = (char)0;

  return 1;
}

// P7AllocPrior
// file prior.c line 36
extern struct p7prior_s * P7AllocPrior(void)
{
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("prior.c", 37, sizeof(struct p7prior_s) /*40016ul*/ );
  return (struct p7prior_s *)return_value_sre_malloc$1;
}

// P7AllocTrace
// file funcs.h line 335
extern void P7AllocTrace(signed int tlen, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("trace.c", 40, sizeof(struct p7trace_s) /*32ul*/ );
  tr = (struct p7trace_s *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("trace.c", 41, sizeof(char) /*1ul*/  * (unsigned long int)tlen);
  tr->statetype = (char *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("trace.c", 42, sizeof(signed int) /*4ul*/  * (unsigned long int)tlen);
  tr->nodeidx = (signed int *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("trace.c", 43, sizeof(signed int) /*4ul*/  * (unsigned long int)tlen);
  tr->pos = (signed int *)return_value_sre_malloc$4;
  *ret_tr = tr;
}

// P7Backward
// file postprob.c line 132
extern float P7Backward(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s **ret_mx)
{
  struct dpmatrix_s *mx;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int i;
  signed int k;
  signed int sc;
  mx=AllocPlan7Matrix(L + 1, hmm->M, &xmx, &mmx, &imx, &dmx);
  xmx[(signed long int)L][(signed long int)2] = hmm->xsc[(signed long int)2][(signed long int)0];
  xmx[(signed long int)L][(signed long int)1] = xmx[(signed long int)L][(signed long int)2] + hmm->xsc[(signed long int)1][(signed long int)0];
  xmx[(signed long int)L][(signed long int)4] = -987654321;
  xmx[(signed long int)L][(signed long int)0] = xmx[(signed long int)L][(signed long int)4];
  xmx[(signed long int)L][(signed long int)3] = xmx[(signed long int)L][(signed long int)0];
  k = hmm->M;
  for( ; k >= 1; k = k - 1)
  {
    mmx[(signed long int)L][(signed long int)k] = xmx[(signed long int)L][(signed long int)1] + hmm->esc[(signed long int)k];
    mmx[(signed long int)L][(signed long int)k] = mmx[(signed long int)L][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)L]][(signed long int)k];
    dmx[(signed long int)L][(signed long int)k] = -987654321;
    imx[(signed long int)L][(signed long int)k] = dmx[(signed long int)L][(signed long int)k];
  }
  hmm->tsc[(signed long int)2][(signed long int)(hmm->M - 1)] = -987654321;
  hmm->tsc[(signed long int)6][(signed long int)(hmm->M - 1)] = hmm->tsc[(signed long int)2][(signed long int)(hmm->M - 1)];
  i = L - 1;
  for( ; i >= 0; i = i - 1)
  {
    xmx[(signed long int)i][(signed long int)2] = xmx[(signed long int)(i + 1)][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1];
    xmx[(signed long int)i][(signed long int)0] = -987654321;
    xmx[(signed long int)i][(signed long int)0]=ILogsum(xmx[(signed long int)i][(signed long int)0], mmx[(signed long int)(i + 1)][(signed long int)hmm->M] + hmm->bsc[(signed long int)(hmm->M - 1)]);
    k = hmm->M - 1;
    for( ; k >= 1; k = k - 1)
      xmx[(signed long int)i][(signed long int)0]=ILogsum(xmx[(signed long int)i][(signed long int)0], mmx[(signed long int)(i + 1)][(signed long int)k] + hmm->bsc[(signed long int)k]);
    xmx[(signed long int)i][(signed long int)3]=ILogsum(xmx[(signed long int)i][(signed long int)0] + hmm->xsc[(signed long int)3][(signed long int)0], xmx[(signed long int)(i + 1)][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)1]);
    xmx[(signed long int)i][(signed long int)1]=ILogsum(xmx[(signed long int)i][(signed long int)2] + hmm->xsc[(signed long int)1][(signed long int)0], xmx[(signed long int)i][(signed long int)3] + hmm->xsc[(signed long int)1][(signed long int)1]);
    xmx[(signed long int)i][(signed long int)4]=ILogsum(xmx[(signed long int)i][(signed long int)0] + hmm->xsc[(signed long int)0][(signed long int)0], xmx[(signed long int)(i + 1)][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1]);
    if(i >= 1)
    {
      mmx[(signed long int)i][(signed long int)hmm->M] = xmx[(signed long int)i][(signed long int)1] + hmm->esc[(signed long int)hmm->M] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)hmm->M];
      dmx[(signed long int)i][(signed long int)hmm->M] = -987654321;
      k = hmm->M - 1;
      for( ; k >= 1; k = k - 1)
      {
        signed int return_value_ILogsum$1;
        return_value_ILogsum$1=ILogsum(xmx[(signed long int)i][(signed long int)1] + hmm->esc[(signed long int)k], mmx[(signed long int)(i + 1)][(signed long int)(k + 1)] + hmm->tsc[(signed long int)0][(signed long int)k]);
        signed int return_value_ILogsum$2;
        return_value_ILogsum$2=ILogsum(imx[(signed long int)(i + 1)][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k], dmx[(signed long int)i][(signed long int)(k + 1)] + hmm->tsc[(signed long int)2][(signed long int)k]);
        mmx[(signed long int)i][(signed long int)k]=ILogsum(return_value_ILogsum$1, return_value_ILogsum$2);
        mmx[(signed long int)i][(signed long int)k] = mmx[(signed long int)i][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k];
        imx[(signed long int)i][(signed long int)k]=ILogsum(imx[(signed long int)(i + 1)][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k], mmx[(signed long int)(i + 1)][(signed long int)(k + 1)] + hmm->tsc[(signed long int)3][(signed long int)k]);
        imx[(signed long int)i][(signed long int)k] = imx[(signed long int)i][(signed long int)k] + hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k];
        dmx[(signed long int)i][(signed long int)k]=ILogsum(dmx[(signed long int)i][(signed long int)(k + 1)] + hmm->tsc[(signed long int)6][(signed long int)k], mmx[(signed long int)(i + 1)][(signed long int)(k + 1)] + hmm->tsc[(signed long int)5][(signed long int)k]);
      }
    }

  }
  sc = xmx[(signed long int)0][(signed long int)4];
  if(!(ret_mx == ((struct dpmatrix_s **)NULL)))
    *ret_mx = mx;

  else
    FreePlan7Matrix(mx);
  float return_value_Scorify$3;
  return_value_Scorify$3=Scorify(sc);
  return return_value_Scorify$3;
}

// P7CountSymbol
// file alphabet.c line 291
extern void P7CountSymbol(float *counters, unsigned char symidx, float wt)
{
  signed int x;
  if(!((signed int)symidx >= Alphabet_size))
    counters[(signed long int)symidx] = counters[(signed long int)symidx] + wt;

  else
  {
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      if(!(Degenerate[(signed long int)symidx][(signed long int)x] == 0))
        counters[(signed long int)x] = counters[(signed long int)x] + wt / (float)DegenCount[(signed long int)symidx];

  }
}

// P7DefaultNullModel
// file funcs.h line 269
extern void P7DefaultNullModel(float *null, float *ret_p1)
{
  signed int x;
  if(Alphabet_type == 3)
  {
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      null[(signed long int)x] = aafq[(signed long int)x];
    *ret_p1 = (float)(350. / 351.);
  }

  else
  {
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      null[(signed long int)x] = (float)(1.0 / (double)(float)Alphabet_size);
    *ret_p1 = (float)(1000. / 1001.);
  }
}

// P7DefaultPrior
// file prior.c line 81
extern struct p7prior_s * P7DefaultPrior(void)
{
  struct p7prior_s *return_value_default_amino_prior$1;
  struct p7prior_s *return_value_default_nucleic_prior$2;
  switch(Alphabet_type)
  {
    case 3:
    {
      return_value_default_amino_prior$1=default_amino_prior();
      return return_value_default_amino_prior$1;
    }
    case 2:
    {
      return_value_default_nucleic_prior$2=default_nucleic_prior();
      return return_value_default_nucleic_prior$2;
    }
    case 0:
      Die("Can't set prior; alphabet type not set yet");
    default:
      return (struct p7prior_s *)(void *)0;
  }
}

// P7EmitterPosterior
// file postprob.c line 250
extern void P7EmitterPosterior(signed int L, struct plan7_s *hmm, struct dpmatrix_s *forward, struct dpmatrix_s *backward, struct dpmatrix_s *mx)
{
  signed int i;
  signed int k;
  signed int sc = backward->xmx[(signed long int)0][(signed long int)4];
  i = L;
  for( ; i >= 1; i = i - 1)
  {
    mx->xmx[(signed long int)i][(signed long int)2] = (forward->xmx[(signed long int)(i - 1)][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1] + backward->xmx[(signed long int)i][(signed long int)2]) - sc;
    mx->xmx[(signed long int)i][(signed long int)3] = (forward->xmx[(signed long int)(i - 1)][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)1] + backward->xmx[(signed long int)i][(signed long int)3]) - sc;
    mx->xmx[(signed long int)i][(signed long int)4] = (forward->xmx[(signed long int)(i - 1)][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1] + backward->xmx[(signed long int)i][(signed long int)4]) - sc;
    mx->xmx[(signed long int)i][(signed long int)1] = -987654321;
    mx->xmx[(signed long int)i][(signed long int)0] = mx->xmx[(signed long int)i][(signed long int)1];
    k = 1;
    for( ; !(k >= hmm->M); k = k + 1)
    {
      mx->mmx[(signed long int)i][(signed long int)k] = backward->mmx[(signed long int)i][(signed long int)k];
      signed int return_value_ILogsum$1;
      return_value_ILogsum$1=ILogsum(forward->mmx[(signed long int)(i - 1)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)], forward->imx[(signed long int)(i - 1)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)]);
      signed int return_value_ILogsum$2;
      return_value_ILogsum$2=ILogsum(forward->xmx[(signed long int)(i - 1)][(signed long int)0] + hmm->bsc[(signed long int)k], forward->dmx[(signed long int)(i - 1)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)]);
      signed int return_value_ILogsum$3;
      return_value_ILogsum$3=ILogsum(return_value_ILogsum$1, return_value_ILogsum$2);
      mx->mmx[(signed long int)i][(signed long int)k] = mx->mmx[(signed long int)i][(signed long int)k] + return_value_ILogsum$3;
      mx->mmx[(signed long int)i][(signed long int)k] = mx->mmx[(signed long int)i][(signed long int)k] - sc;
      mx->imx[(signed long int)i][(signed long int)k] = backward->imx[(signed long int)i][(signed long int)k];
      signed int return_value_ILogsum$4;
      return_value_ILogsum$4=ILogsum(forward->mmx[(signed long int)(i - 1)][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k], forward->imx[(signed long int)(i - 1)][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k]);
      mx->imx[(signed long int)i][(signed long int)k] = mx->imx[(signed long int)i][(signed long int)k] + return_value_ILogsum$4;
      mx->imx[(signed long int)i][(signed long int)k] = mx->imx[(signed long int)i][(signed long int)k] - sc;
      mx->dmx[(signed long int)i][(signed long int)k] = -987654321;
    }
    mx->mmx[(signed long int)i][(signed long int)hmm->M] = backward->mmx[(signed long int)i][(signed long int)hmm->M];
    signed int return_value_ILogsum$5;
    return_value_ILogsum$5=ILogsum(forward->mmx[(signed long int)(i - 1)][(signed long int)(hmm->M - 1)] + hmm->tsc[(signed long int)0][(signed long int)(hmm->M - 1)], forward->imx[(signed long int)(i - 1)][(signed long int)(hmm->M - 1)] + hmm->tsc[(signed long int)3][(signed long int)(hmm->M - 1)]);
    signed int return_value_ILogsum$6;
    return_value_ILogsum$6=ILogsum(forward->xmx[(signed long int)(i - 1)][(signed long int)0] + hmm->bsc[(signed long int)hmm->M], forward->dmx[(signed long int)(i - 1)][(signed long int)(hmm->M - 1)] + hmm->tsc[(signed long int)5][(signed long int)(hmm->M - 1)]);
    signed int return_value_ILogsum$7;
    return_value_ILogsum$7=ILogsum(return_value_ILogsum$5, return_value_ILogsum$6);
    mx->mmx[(signed long int)i][(signed long int)hmm->M] = mx->mmx[(signed long int)i][(signed long int)hmm->M] + return_value_ILogsum$7;
    mx->mmx[(signed long int)i][(signed long int)hmm->M] = mx->mmx[(signed long int)i][(signed long int)hmm->M] - sc;
    mx->dmx[(signed long int)i][(signed long int)0] = -987654321;
    mx->dmx[(signed long int)i][(signed long int)hmm->M] = mx->dmx[(signed long int)i][(signed long int)0];
    mx->imx[(signed long int)i][(signed long int)hmm->M] = mx->dmx[(signed long int)i][(signed long int)hmm->M];
  }
}

// P7Fastmodelmaker
// file modelmakers.c line 162
extern void P7Fastmodelmaker(struct msa_struct *msa, unsigned char **dsq, float maxgap, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr)
{
  signed int *matassign;
  signed int idx;
  signed int apos;
  signed int ngap;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("modelmakers.c", 172, sizeof(signed int) /*4ul*/  * (unsigned long int)(msa->alen + 1));
  matassign = (signed int *)return_value_sre_malloc$1;
  matassign[(signed long int)0] = 0;
  apos = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  for( ; !(apos >= msa->alen); apos = apos + 1)
  {
    matassign[(signed long int)(apos + 1)] = 0;
    ngap = 0;
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 32)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)msa->aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        ngap = ngap + 1;

    }
    if((float)ngap / (float)msa->nseq > maxgap)
      matassign[(signed long int)(apos + 1)] = matassign[(signed long int)(apos + 1)] | 1 << 3;

    else
      matassign[(signed long int)(apos + 1)] = matassign[(signed long int)(apos + 1)] | 1 << 0;
  }
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
  free((void *)matassign);
  goto __CPROVER_DUMP_L16;

__CPROVER_DUMP_L16:
  ;
}

// P7FillOptimalAccuracy
// file postprob.c line 319
extern float P7FillOptimalAccuracy(signed int L, signed int M, struct dpmatrix_s *posterior, struct dpmatrix_s *mx, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int i;
  signed int k;
  signed int sc;
  xmx = mx->xmx;
  mmx = mx->mmx;
  imx = mx->imx;
  dmx = mx->dmx;
  xmx[(signed long int)0][(signed long int)3] = -987654321;
  xmx[(signed long int)0][(signed long int)2] = xmx[(signed long int)0][(signed long int)3];
  xmx[(signed long int)0][(signed long int)1] = xmx[(signed long int)0][(signed long int)2];
  xmx[(signed long int)0][(signed long int)0] = xmx[(signed long int)0][(signed long int)1];
  xmx[(signed long int)0][(signed long int)4] = xmx[(signed long int)0][(signed long int)0];
  k = 0;
  for( ; M >= k; k = k + 1)
  {
    dmx[(signed long int)0][(signed long int)k] = -987654321;
    imx[(signed long int)0][(signed long int)k] = dmx[(signed long int)0][(signed long int)k];
    mmx[(signed long int)0][(signed long int)k] = imx[(signed long int)0][(signed long int)k];
  }
  i = 1;
  for( ; L >= i; i = i + 1)
  {
    dmx[(signed long int)i][(signed long int)0] = -987654321;
    imx[(signed long int)i][(signed long int)0] = dmx[(signed long int)i][(signed long int)0];
    mmx[(signed long int)i][(signed long int)0] = imx[(signed long int)i][(signed long int)0];
    k = 1;
    for( ; M >= k; k = k + 1)
    {
      mmx[(signed long int)i][(signed long int)k] = -987654321;
      sc = mmx[(signed long int)(i - 1)][(signed long int)(k - 1)];
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      sc = imx[(signed long int)(i - 1)][(signed long int)(k - 1)];
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      sc = dmx[(signed long int)(i - 1)][(signed long int)(k - 1)];
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      sc = xmx[(signed long int)(i - 1)][(signed long int)0];
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      mmx[(signed long int)i][(signed long int)k]=ILogsum(mmx[(signed long int)i][(signed long int)k], posterior->mmx[(signed long int)i][(signed long int)k]);
      dmx[(signed long int)i][(signed long int)k] = -987654321;
      sc = mmx[(signed long int)i][(signed long int)(k - 1)];
      if(!(dmx[(signed long int)i][(signed long int)k] >= sc))
        dmx[(signed long int)i][(signed long int)k] = sc;

      sc = dmx[(signed long int)i][(signed long int)(k - 1)];
      if(!(dmx[(signed long int)i][(signed long int)k] >= sc))
        dmx[(signed long int)i][(signed long int)k] = sc;

      imx[(signed long int)i][(signed long int)k] = -987654321;
      sc = mmx[(signed long int)(i - 1)][(signed long int)k];
      if(!(imx[(signed long int)i][(signed long int)k] >= sc))
        imx[(signed long int)i][(signed long int)k] = sc;

      sc = imx[(signed long int)(i - 1)][(signed long int)k];
      if(!(imx[(signed long int)i][(signed long int)k] >= sc))
        imx[(signed long int)i][(signed long int)k] = sc;

      imx[(signed long int)i][(signed long int)k]=ILogsum(imx[(signed long int)i][(signed long int)k], posterior->imx[(signed long int)i][(signed long int)k]);
    }
    xmx[(signed long int)i][(signed long int)4] = -987654321;
    sc=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)4], posterior->xmx[(signed long int)i][(signed long int)4]);
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)4] = sc;

    xmx[(signed long int)i][(signed long int)1] = -987654321;
    k = 1;
    for( ; M >= k; k = k + 1)
    {
      sc = mmx[(signed long int)i][(signed long int)k];
      if(!(xmx[(signed long int)i][1l] >= sc))
        xmx[(signed long int)i][(signed long int)1] = sc;

    }
    xmx[(signed long int)i][(signed long int)3] = -987654321;
    sc=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)3], posterior->xmx[(signed long int)i][(signed long int)3]);
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)3] = sc;

    sc = xmx[(signed long int)i][(signed long int)1];
    if(!(xmx[(signed long int)i][3l] >= sc))
      xmx[(signed long int)i][(signed long int)3] = sc;

    xmx[(signed long int)i][(signed long int)0] = -987654321;
    sc = xmx[(signed long int)i][(signed long int)4];
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)0] = sc;

    sc = xmx[(signed long int)i][(signed long int)3];
    if(!(*xmx[(signed long int)i] >= sc))
      xmx[(signed long int)i][(signed long int)0] = sc;

    xmx[(signed long int)i][(signed long int)2] = -987654321;
    sc=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)2], posterior->xmx[(signed long int)i][(signed long int)2]);
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)2] = sc;

    sc = xmx[(signed long int)i][(signed long int)1];
    if(!(xmx[(signed long int)i][2l] >= sc))
      xmx[(signed long int)i][(signed long int)2] = sc;

  }
  sc = xmx[(signed long int)L][(signed long int)2];
  if(!(ret_tr == ((struct p7trace_s **)NULL)))
  {
    P7OptimalAccuracyTrace(L, M, posterior, mx, &tr);
    *ret_tr = tr;
  }

  float return_value_Score2Prob$1;
  return_value_Score2Prob$1=Score2Prob(sc, (float)1);
  return return_value_Score2Prob$1;
}

// P7Forward
// file core_algorithms.c line 454
extern float P7Forward(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s **ret_mx)
{
  struct dpmatrix_s *mx;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int i;
  signed int k;
  signed int sc;
  mx=AllocPlan7Matrix(L + 1, hmm->M, &xmx, &mmx, &imx, &dmx);
  xmx[(signed long int)0][(signed long int)4] = 0;
  xmx[(signed long int)0][(signed long int)0] = hmm->xsc[(signed long int)0][(signed long int)0];
  xmx[(signed long int)0][(signed long int)3] = -987654321;
  xmx[(signed long int)0][(signed long int)2] = xmx[(signed long int)0][(signed long int)3];
  xmx[(signed long int)0][(signed long int)1] = xmx[(signed long int)0][(signed long int)2];
  k = 0;
  for( ; hmm->M >= k; k = k + 1)
  {
    dmx[(signed long int)0][(signed long int)k] = -987654321;
    imx[(signed long int)0][(signed long int)k] = dmx[(signed long int)0][(signed long int)k];
    mmx[(signed long int)0][(signed long int)k] = imx[(signed long int)0][(signed long int)k];
  }
  i = 1;
  for( ; L >= i; i = i + 1)
  {
    dmx[(signed long int)i][(signed long int)0] = -987654321;
    imx[(signed long int)i][(signed long int)0] = dmx[(signed long int)i][(signed long int)0];
    mmx[(signed long int)i][(signed long int)0] = imx[(signed long int)i][(signed long int)0];
    k = 1;
    for( ; !(k >= hmm->M); k = k + 1)
    {
      signed int return_value_ILogsum$1;
      return_value_ILogsum$1=ILogsum(mmx[(signed long int)(i - 1)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)], imx[(signed long int)(i - 1)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)]);
      signed int return_value_ILogsum$2;
      return_value_ILogsum$2=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)0] + hmm->bsc[(signed long int)k], dmx[(signed long int)(i - 1)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)]);
      mmx[(signed long int)i][(signed long int)k]=ILogsum(return_value_ILogsum$1, return_value_ILogsum$2);
      mmx[(signed long int)i][(signed long int)k] = mmx[(signed long int)i][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k];
      dmx[(signed long int)i][(signed long int)k]=ILogsum(mmx[(signed long int)i][(signed long int)(k - 1)] + hmm->tsc[(signed long int)2][(signed long int)(k - 1)], dmx[(signed long int)i][(signed long int)(k - 1)] + hmm->tsc[(signed long int)6][(signed long int)(k - 1)]);
      imx[(signed long int)i][(signed long int)k]=ILogsum(mmx[(signed long int)(i - 1)][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k], imx[(signed long int)(i - 1)][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k]);
      imx[(signed long int)i][(signed long int)k] = imx[(signed long int)i][(signed long int)k] + hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k];
    }
    signed int return_value_ILogsum$3;
    return_value_ILogsum$3=ILogsum(mmx[(signed long int)(i - 1)][(signed long int)(hmm->M - 1)] + hmm->tsc[(signed long int)0][(signed long int)(hmm->M - 1)], imx[(signed long int)(i - 1)][(signed long int)(hmm->M - 1)] + hmm->tsc[(signed long int)3][(signed long int)(hmm->M - 1)]);
    signed int return_value_ILogsum$4;
    return_value_ILogsum$4=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)0] + hmm->bsc[(signed long int)hmm->M], dmx[(signed long int)(i - 1)][(signed long int)(hmm->M - 1)] + hmm->tsc[(signed long int)5][(signed long int)(hmm->M - 1)]);
    mmx[(signed long int)i][(signed long int)hmm->M]=ILogsum(return_value_ILogsum$3, return_value_ILogsum$4);
    mmx[(signed long int)i][(signed long int)hmm->M] = mmx[(signed long int)i][(signed long int)hmm->M] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)hmm->M];
    xmx[(signed long int)i][(signed long int)4] = xmx[(signed long int)(i - 1)][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1];
    xmx[(signed long int)i][(signed long int)1] = -987654321;
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
      xmx[(signed long int)i][(signed long int)1]=ILogsum(xmx[(signed long int)i][(signed long int)1], mmx[(signed long int)i][(signed long int)k] + hmm->esc[(signed long int)k]);
    xmx[(signed long int)i][(signed long int)3]=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)1], xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)1]);
    xmx[(signed long int)i][(signed long int)0]=ILogsum(xmx[(signed long int)i][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0], xmx[(signed long int)i][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)0]);
    xmx[(signed long int)i][(signed long int)2]=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1], xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0]);
  }
  sc = xmx[(signed long int)L][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)0];
  if(!(ret_mx == ((struct dpmatrix_s **)NULL)))
    *ret_mx = mx;

  else
    FreePlan7Matrix(mx);
  float return_value_Scorify$5;
  return_value_Scorify$5=Scorify(sc);
  return return_value_Scorify$5;
}

// P7FreePrior
// file prior.c line 39
extern void P7FreePrior(struct p7prior_s *pri)
{
  free((void *)pri);
}

// P7FreeTrace
// file funcs.h line 337
extern void P7FreeTrace(struct p7trace_s *tr)
{
  if(!(tr == ((struct p7trace_s *)NULL)))
  {
    free((void *)tr->pos);
    free((void *)tr->nodeidx);
    free((void *)tr->statetype);
    free((void *)tr);
  }

}

// P7Handmodelmaker
// file modelmakers.c line 100
extern void P7Handmodelmaker(struct msa_struct *msa, unsigned char **dsq, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr)
{
  signed int *matassign;
  signed int apos;
  if(msa->rf == ((char *)NULL))
    Die("Alignment must have RF annotation to hand-build an HMM");

  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("modelmakers.c", 111, sizeof(signed int) /*4ul*/  * (unsigned long int)(msa->alen + 1));
  matassign = (signed int *)return_value_sre_malloc$1;
  matassign[(signed long int)0] = 0;
  apos = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  for( ; !(apos >= msa->alen); apos = apos + 1)
  {
    matassign[(signed long int)(apos + 1)] = 0;
    if((signed int)msa->rf[(signed long int)apos] == 32)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)msa->rf[(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)msa->rf[(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)msa->rf[(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)msa->rf[(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$5)
      matassign[(signed long int)(apos + 1)] = matassign[(signed long int)(apos + 1)] | 1 << 0;

    else
      matassign[(signed long int)(apos + 1)] = matassign[(signed long int)(apos + 1)] | 1 << 3;
  }
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
  free((void *)matassign);
  goto __CPROVER_DUMP_L14;

__CPROVER_DUMP_L14:
  ;
}

// P7LaplacePrior
// file prior.c line 53
extern struct p7prior_s * P7LaplacePrior(void)
{
  struct p7prior_s *pri;
  pri=P7AllocPrior();
  pri->strategy = 0;
  pri->tnum = 1;
  pri->tq[(signed long int)0] = (float)1.;
  FSet(pri->t[(signed long int)0], 8, (float)1.);
  pri->mnum = 1;
  pri->mq[(signed long int)0] = (float)1.;
  FSet(pri->m[(signed long int)0], Alphabet_size, (float)1.);
  pri->inum = 1;
  pri->iq[(signed long int)0] = (float)1.;
  FSet(pri->i[(signed long int)0], Alphabet_size, (float)1.);
  return pri;
}

// P7Logoddsify
// file funcs.h line 223
extern void P7Logoddsify(struct plan7_s *hmm, signed int viterbi_mode)
{
  signed int k;
  signed int x;
  float accum;
  float tbm;
  float tme;
  double tmp_if_expr$2;
  double return_value_log$1;
  double tmp_if_expr$4;
  double return_value_log$3;
  double return_value_log$5;
  double tmp_if_expr$7;
  double return_value_log$6;
  double return_value_log$8;
  double tmp_if_expr$10;
  double return_value_log$9;
  double return_value_log$11;
  double return_value_floor$12;
  double tmp_if_expr$14;
  double return_value_log$13;
  double return_value_log$15;
  double tmp_if_expr$17;
  double return_value_log$16;
  double return_value_log$18;
  double tmp_if_expr$20;
  double return_value_log$19;
  signed int tmp_if_expr$22;
  double return_value_floor$21;
  if((1 & hmm->flags) == 0)
  {
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      x = 0;
      for( ; !(x >= Alphabet_size); x = x + 1)
      {
        hmm->msc[(signed long int)x][(signed long int)k]=Prob2Score(hmm->mat[(signed long int)k][(signed long int)x], hmm->null[(signed long int)x]);
        if(!(k >= hmm->M))
          hmm->isc[(signed long int)x][(signed long int)k]=Prob2Score(hmm->ins[(signed long int)k][(signed long int)x], hmm->null[(signed long int)x]);

      }
      x = Alphabet_size;
      for( ; !(x >= Alphabet_iupac); x = x + 1)
      {
        hmm->msc[(signed long int)x][(signed long int)k]=DegenerateSymbolScore(hmm->mat[(signed long int)k], hmm->null, x);
        if(!(k >= hmm->M))
          hmm->isc[(signed long int)x][(signed long int)k]=DegenerateSymbolScore(hmm->ins[(signed long int)k], hmm->null, x);

      }
    }
    k = 1;
    for( ; !(k >= hmm->M); k = k + 1)
    {
      hmm->tsc[(signed long int)0][(signed long int)k]=Prob2Score(hmm->t[(signed long int)k][(signed long int)0], hmm->p1);
      hmm->tsc[(signed long int)1][(signed long int)k]=Prob2Score(hmm->t[(signed long int)k][(signed long int)1], hmm->p1);
      hmm->tsc[(signed long int)2][(signed long int)k]=Prob2Score(hmm->t[(signed long int)k][(signed long int)2], (float)1.0);
      hmm->tsc[(signed long int)3][(signed long int)k]=Prob2Score(hmm->t[(signed long int)k][(signed long int)3], hmm->p1);
      hmm->tsc[(signed long int)4][(signed long int)k]=Prob2Score(hmm->t[(signed long int)k][(signed long int)4], hmm->p1);
      hmm->tsc[(signed long int)5][(signed long int)k]=Prob2Score(hmm->t[(signed long int)k][(signed long int)5], hmm->p1);
      hmm->tsc[(signed long int)6][(signed long int)k]=Prob2Score(hmm->t[(signed long int)k][(signed long int)6], (float)1.0);
    }
    if(hmm->tbd1 > 0.000000f)
    {
      return_value_log$1=log((double)hmm->tbd1);
      tmp_if_expr$2 = return_value_log$1;
    }

    else
      tmp_if_expr$2 = -9999.;
    accum = (float)tmp_if_expr$2;
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      if(hmm->begin[(signed long int)k] > 0.000000f)
      {
        return_value_log$3=log((double)hmm->begin[(signed long int)k]);
        tmp_if_expr$4 = return_value_log$3;
      }

      else
        tmp_if_expr$4 = -9999.;
      tbm = (float)tmp_if_expr$4;
      if(accum > -9999.000000f && k >= 2)
      {
        if(hmm->t[(signed long int)(k + -1)][5l] > 0.000000f)
        {
          if(!(viterbi_mode == 0))
          {
            return_value_log$5=log((double)hmm->t[(signed long int)(k - 1)][(signed long int)5]);
            if((double)tbm > (double)accum + return_value_log$5)
              tmp_if_expr$7 = (double)tbm;

            else
            {
              return_value_log$6=log((double)hmm->t[(signed long int)(k - 1)][(signed long int)5]);
              tmp_if_expr$7 = (double)accum + return_value_log$6;
            }
            tbm = (float)tmp_if_expr$7;
          }

          else
          {
            return_value_log$8=log((double)hmm->t[(signed long int)(k - 1)][(signed long int)5]);
            tbm=LogSum(tbm, (float)((double)accum + return_value_log$8));
          }
        }

        if(hmm->t[(signed long int)(k + -1)][6l] > 0.000000f)
        {
          return_value_log$9=log((double)hmm->t[(signed long int)(k - 1)][(signed long int)6]);
          tmp_if_expr$10 = (double)accum + return_value_log$9;
        }

        else
          tmp_if_expr$10 = -9999.;
        accum = (float)tmp_if_expr$10;
      }

      if(tbm > -9999.000000f)
      {
        return_value_log$11=log((double)hmm->p1);
        return_value_floor$12=floor(0.5 + 1000.0 * 1.44269504 * ((double)tbm - return_value_log$11));
        hmm->bsc[(signed long int)k] = (signed int)return_value_floor$12;
      }

      else
        hmm->bsc[(signed long int)k] = -987654321;
    }
    hmm->esc[(signed long int)hmm->M] = 0;
    accum = (float)0.;
    k = hmm->M - 1;
    for( ; k >= 1; k = k - 1)
    {
      if(hmm->end[(signed long int)k] > 0.000000f)
      {
        return_value_log$13=log((double)hmm->end[(signed long int)k]);
        tmp_if_expr$14 = return_value_log$13;
      }

      else
        tmp_if_expr$14 = -9999.;
      tme = (float)tmp_if_expr$14;
      if(accum > -9999.000000f)
      {
        if(hmm->t[(signed long int)k][2l] > 0.000000f)
        {
          if(!(viterbi_mode == 0))
          {
            return_value_log$15=log((double)hmm->t[(signed long int)k][(signed long int)2]);
            if((double)tme > (double)accum + return_value_log$15)
              tmp_if_expr$17 = (double)tme;

            else
            {
              return_value_log$16=log((double)hmm->t[(signed long int)k][(signed long int)2]);
              tmp_if_expr$17 = (double)accum + return_value_log$16;
            }
            tme = (float)tmp_if_expr$17;
          }

          else
          {
            return_value_log$18=log((double)hmm->t[(signed long int)k][(signed long int)2]);
            tme=LogSum(tme, (float)((double)accum + return_value_log$18));
          }
        }

        if(hmm->t[(signed long int)k][6l] > 0.000000f)
        {
          return_value_log$19=log((double)hmm->t[(signed long int)k][(signed long int)6]);
          tmp_if_expr$20 = (double)accum + return_value_log$19;
        }

        else
          tmp_if_expr$20 = -9999.;
        accum = (float)tmp_if_expr$20;
      }

      if(tme > -9999.000000f)
      {
        return_value_floor$21=floor(0.5 + 1000.0 * 1.44269504 * (double)tme);
        tmp_if_expr$22 = (signed int)return_value_floor$21;
      }

      else
        tmp_if_expr$22 = -987654321;
      hmm->esc[(signed long int)k] = tmp_if_expr$22;
    }
    hmm->xsc[(signed long int)0][(signed long int)1]=Prob2Score(hmm->xt[(signed long int)0][(signed long int)1], hmm->p1);
    hmm->xsc[(signed long int)0][(signed long int)0]=Prob2Score(hmm->xt[(signed long int)0][(signed long int)0], (float)1.0);
    hmm->xsc[(signed long int)1][(signed long int)1]=Prob2Score(hmm->xt[(signed long int)1][(signed long int)1], (float)1.0);
    hmm->xsc[(signed long int)1][(signed long int)0]=Prob2Score(hmm->xt[(signed long int)1][(signed long int)0], (float)1.0);
    hmm->xsc[(signed long int)2][(signed long int)1]=Prob2Score(hmm->xt[(signed long int)2][(signed long int)1], hmm->p1);
    hmm->xsc[(signed long int)2][(signed long int)0]=Prob2Score(hmm->xt[(signed long int)2][(signed long int)0], (float)(1. - (double)hmm->p1));
    hmm->xsc[(signed long int)3][(signed long int)1]=Prob2Score(hmm->xt[(signed long int)3][(signed long int)1], hmm->p1);
    hmm->xsc[(signed long int)3][(signed long int)0]=Prob2Score(hmm->xt[(signed long int)3][(signed long int)0], (float)1.0);
    hmm->flags = hmm->flags | 1 << 0;
  }

}

// P7Maxmodelmaker
// file modelmakers.c line 227
extern void P7Maxmodelmaker(struct msa_struct *msa, unsigned char **dsq, float maxgap, struct p7prior_s *prior, float *null, float null_p1, float mpri, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr)
{
  signed int idx;
  signed int i;
  signed int j;
  signed int x;
  float **matc;
  float cij[8l];
  float tij[8l];
  float matp[20l];
  float insp[20l];
  float insc[20l];
  float *sc;
  signed int *tbck;
  signed int *matassign;
  signed int *insopt;
  signed int first;
  signed int last;
  float bm1;
  float bm2;
  signed int est_M;
  float t_me;
  float new;
  float bestsc;
  signed int code;
  signed int ngap;
  float wgtsum;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("modelmakers.c", 255, sizeof(float *) /*8ul*/  * (unsigned long int)(msa->alen + 1));
  matc = (float **)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("modelmakers.c", 256, sizeof(float) /*4ul*/  * (unsigned long int)(msa->alen + 2));
  sc = (float *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("modelmakers.c", 257, sizeof(signed int) /*4ul*/  * (unsigned long int)(msa->alen + 2));
  tbck = (signed int *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("modelmakers.c", 258, sizeof(signed int) /*4ul*/  * (unsigned long int)(msa->alen + 1));
  matassign = (signed int *)return_value_sre_malloc$4;
  void *return_value_sre_malloc$5;
  return_value_sre_malloc$5=sre_malloc("modelmakers.c", 259, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseq);
  insopt = (signed int *)return_value_sre_malloc$5;
  i = 0;
  for( ; !(i >= msa->alen); i = i + 1)
  {
    void *return_value_sre_malloc$6;
    return_value_sre_malloc$6=sre_malloc("modelmakers.c", 261, (unsigned long int)Alphabet_size * sizeof(float) /*4ul*/ );
    matc[(signed long int)(i + 1)] = (float *)return_value_sre_malloc$6;
    FSet(matc[(signed long int)(i + 1)], Alphabet_size, (float)0.);
  }
  i = 0;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  unsigned char return_value_SymbolIndex$7;
  for( ; !(i >= msa->alen); i = i + 1)
  {
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)i] == 32)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)msa->aseq[(signed long int)idx][(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = (signed int)msa->aseq[(signed long int)idx][(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = (signed int)msa->aseq[(signed long int)idx][(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$10)
        tmp_if_expr$11 = (_Bool)1;

      else
        tmp_if_expr$11 = (signed int)msa->aseq[(signed long int)idx][(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$11)
      {
        return_value_SymbolIndex$7=SymbolIndex(msa->aseq[(signed long int)idx][(signed long int)i]);
        P7CountSymbol(matc[(signed long int)(i + 1)], return_value_SymbolIndex$7, msa->wgt[(signed long int)idx]);
      }

    }
  }
  double tmp_if_expr$13;
  double return_value_log$12;
  if(mpri > 0.000000f)
  {
    return_value_log$12=log((double)mpri);
    tmp_if_expr$13 = return_value_log$12 * 1.44269504;
  }

  else
    tmp_if_expr$13 = -9999.;
  mpri = (float)tmp_if_expr$13;
  FCopy(insp, prior->i[(signed long int)0], Alphabet_size);
  FNorm(insp, Alphabet_size);
  wgtsum=FSum(msa->wgt, msa->nseq);
  x = 0;
  double tmp_if_expr$15;
  double return_value_log$14;
  for( ; !(x >= Alphabet_size); x = x + 1)
  {
    if(insp[(signed long int)x] / null[(signed long int)x] > 0.000000f)
    {
      return_value_log$14=log((double)(insp[(signed long int)x] / null[(signed long int)x]));
      tmp_if_expr$15 = return_value_log$14 * 1.44269504;
    }

    else
      tmp_if_expr$15 = -9999.;
    insp[(signed long int)x] = (float)tmp_if_expr$15;
  }
  est_M=estimate_model_length(msa);
  t_me = (float)(0.5 / (double)(float)(est_M - 1));
  bm1 = (float)0.5;
  bm2 = (float)(0.5 / (double)(float)(est_M - 1));
  double tmp_if_expr$17;
  double return_value_log$16;
  if(bm1 / null_p1 > 0.000000f)
  {
    return_value_log$16=log((double)(bm1 / null_p1));
    tmp_if_expr$17 = return_value_log$16 * 1.44269504;
  }

  else
    tmp_if_expr$17 = -9999.;
  bm1 = (float)tmp_if_expr$17;
  double tmp_if_expr$19;
  double return_value_log$18;
  if(bm2 / null_p1 > 0.000000f)
  {
    return_value_log$18=log((double)(bm2 / null_p1));
    tmp_if_expr$19 = return_value_log$18 * 1.44269504;
  }

  else
    tmp_if_expr$19 = -9999.;
  bm2 = (float)tmp_if_expr$19;
  maxgap = (float)0.5;
  last = msa->alen;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  for( ; last >= 1; last = last - 1)
  {
    ngap = 0;
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)(last + -1)] == 32)
        tmp_if_expr$20 = (_Bool)1;

      else
        tmp_if_expr$20 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(last - 1)] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$20)
        tmp_if_expr$21 = (_Bool)1;

      else
        tmp_if_expr$21 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(last - 1)] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$21)
        tmp_if_expr$22 = (_Bool)1;

      else
        tmp_if_expr$22 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(last - 1)] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$22)
        tmp_if_expr$23 = (_Bool)1;

      else
        tmp_if_expr$23 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(last - 1)] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$23)
        ngap = ngap + 1;

    }
    if((float)ngap / (float)msa->nseq <= maxgap)
      break;

  }
  sc[(signed long int)last] = (float)0.;
  tbck[(signed long int)last] = 0;
  idx = 0;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$24;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$26;
  _Bool tmp_if_expr$27;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    i = last;
    do
    {
      if(i >= 1)
      {
        if((signed int)msa->aseq[(signed long int)idx][(signed long int)(i + -1)] == 32)
          tmp_if_expr$24 = (_Bool)1;

        else
          tmp_if_expr$24 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$24)
          tmp_if_expr$25 = (_Bool)1;

        else
          tmp_if_expr$25 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$25)
          tmp_if_expr$26 = (_Bool)1;

        else
          tmp_if_expr$26 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$26)
          tmp_if_expr$27 = (_Bool)1;

        else
          tmp_if_expr$27 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 126 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$28 = tmp_if_expr$27 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$28 = (_Bool)0;
      if(!tmp_if_expr$28)
        break;

      msa->aseq[(signed long int)idx][(signed long int)(i - 1)] = (char)95;
      i = i - 1;
    }
    while((_Bool)1);
  }
  i = last - 1;
  double tmp_if_expr$30;
  double return_value_log$29;
  double tmp_if_expr$32;
  double return_value_log$31;
  double tmp_if_expr$34;
  double return_value_log$33;
  double tmp_if_expr$36;
  double return_value_log$35;
  double tmp_if_expr$38;
  double return_value_log$37;
  double tmp_if_expr$40;
  double return_value_log$39;
  double tmp_if_expr$42;
  double return_value_log$41;
  double tmp_if_expr$44;
  double return_value_log$43;
  _Bool tmp_if_expr$47;
  _Bool tmp_if_expr$48;
  _Bool tmp_if_expr$49;
  _Bool tmp_if_expr$50;
  for( ; i >= 1; i = i - 1)
  {
    FCopy(matp, matc[(signed long int)i], Alphabet_size);
    P7PriorifyEmissionVector(matp, prior, prior->mnum, prior->mq, prior->m, (float *)(void *)0);
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
    {
      if(matp[(signed long int)x] / null[(signed long int)x] > 0.000000f)
      {
        return_value_log$29=log((double)(matp[(signed long int)x] / null[(signed long int)x]));
        tmp_if_expr$30 = return_value_log$29 * 1.44269504;
      }

      else
        tmp_if_expr$30 = -9999.;
      matp[(signed long int)x] = (float)tmp_if_expr$30;
    }
    FSet(insc, Alphabet_size, (float)0.);
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
      insopt[(signed long int)idx] = 0;
    sc[(signed long int)i] = -3.40282346638528859812e+38F;
    j = i + 1;
    for( ; last >= j; j = j + 1)
    {
      code=build_cij(msa->aseq, msa->nseq, insopt, i, j, msa->wgt, cij);
      if(code == -1)
        break;

      if(code == 1)
      {
        FCopy(tij, cij, 7);
        P7PriorifyTransitionVector(tij, prior, prior->tq);
        FNorm(tij, 3);
        if(tij[0l] / null_p1 > 0.000000f)
        {
          return_value_log$31=log((double)(tij[(signed long int)0] / null_p1));
          tmp_if_expr$32 = return_value_log$31 * 1.44269504;
        }

        else
          tmp_if_expr$32 = -9999.;
        tij[(signed long int)0] = (float)tmp_if_expr$32;
        if(tij[1l] / null_p1 > 0.000000f)
        {
          return_value_log$33=log((double)(tij[(signed long int)1] / null_p1));
          tmp_if_expr$34 = return_value_log$33 * 1.44269504;
        }

        else
          tmp_if_expr$34 = -9999.;
        tij[(signed long int)1] = (float)tmp_if_expr$34;
        if(tij[2l] > 0.000000f)
        {
          return_value_log$35=log((double)tij[(signed long int)2]);
          tmp_if_expr$36 = return_value_log$35 * 1.44269504;
        }

        else
          tmp_if_expr$36 = -9999.;
        tij[(signed long int)2] = (float)tmp_if_expr$36;
        if(tij[3l] / null_p1 > 0.000000f)
        {
          return_value_log$37=log((double)(tij[(signed long int)3] / null_p1));
          tmp_if_expr$38 = return_value_log$37 * 1.44269504;
        }

        else
          tmp_if_expr$38 = -9999.;
        tij[(signed long int)3] = (float)tmp_if_expr$38;
        if(tij[4l] / null_p1 > 0.000000f)
        {
          return_value_log$39=log((double)(tij[(signed long int)4] / null_p1));
          tmp_if_expr$40 = return_value_log$39 * 1.44269504;
        }

        else
          tmp_if_expr$40 = -9999.;
        tij[(signed long int)4] = (float)tmp_if_expr$40;
        if(tij[5l] / null_p1 > 0.000000f)
        {
          return_value_log$41=log((double)(tij[(signed long int)5] / null_p1));
          tmp_if_expr$42 = return_value_log$41 * 1.44269504;
        }

        else
          tmp_if_expr$42 = -9999.;
        tij[(signed long int)5] = (float)tmp_if_expr$42;
        if(tij[6l] > 0.000000f)
        {
          return_value_log$43=log((double)tij[(signed long int)6]);
          tmp_if_expr$44 = return_value_log$43 * 1.44269504;
        }

        else
          tmp_if_expr$44 = -9999.;
        tij[(signed long int)6] = (float)tmp_if_expr$44;
        float return_value_FDot$45;
        return_value_FDot$45=FDot(tij, cij, 7);
        float return_value_FDot$46;
        return_value_FDot$46=FDot(insp, insc, Alphabet_size);
        new = sc[(signed long int)j] + return_value_FDot$45 + return_value_FDot$46;
        if(new > sc[(signed long int)i])
        {
          sc[(signed long int)i] = new;
          tbck[(signed long int)i] = j;
        }

      }

      FAdd(insc, matc[(signed long int)j], Alphabet_size);
      idx = 0;
      for( ; !(idx >= msa->nseq); idx = idx + 1)
      {
        if((signed int)msa->aseq[(signed long int)idx][(signed long int)(j + -1)] == 32)
          tmp_if_expr$47 = (_Bool)1;

        else
          tmp_if_expr$47 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(j - 1)] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$47)
          tmp_if_expr$48 = (_Bool)1;

        else
          tmp_if_expr$48 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(j - 1)] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$48)
          tmp_if_expr$49 = (_Bool)1;

        else
          tmp_if_expr$49 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(j - 1)] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$49)
          tmp_if_expr$50 = (_Bool)1;

        else
          tmp_if_expr$50 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(j - 1)] == 126 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$50)
          insopt[(signed long int)idx] = insopt[(signed long int)idx] + 1;

      }
    }
    float return_value_FDot$51;
    return_value_FDot$51=FDot(matp, matc[(signed long int)i], Alphabet_size);
    sc[(signed long int)i] = sc[(signed long int)i] + return_value_FDot$51 + mpri * wgtsum;
  }
  bestsc = -3.40282346638528859812e+38F;
  first = 0;
  i = 1;
  _Bool tmp_if_expr$52;
  _Bool tmp_if_expr$53;
  _Bool tmp_if_expr$54;
  _Bool tmp_if_expr$55;
  for( ; last >= i; i = i + 1)
  {
    new = sc[(signed long int)i];
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)(i + -1)] == 32)
        tmp_if_expr$52 = (_Bool)1;

      else
        tmp_if_expr$52 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$52)
        tmp_if_expr$53 = (_Bool)1;

      else
        tmp_if_expr$53 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$53)
        tmp_if_expr$54 = (_Bool)1;

      else
        tmp_if_expr$54 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$54)
        tmp_if_expr$55 = (_Bool)1;

      else
        tmp_if_expr$55 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$55)
        new = new + bm2;

      else
        new = new + bm1;
    }
    if(new > bestsc)
    {
      bestsc = new;
      first = i;
    }

  }
  matassign[(signed long int)0] = 0;
  i = 1;
  for( ; msa->alen >= i; i = i + 1)
    matassign[(signed long int)i] = 1 << 3;
  i = first;
  for( ; !(i == 0); i = tbck[(signed long int)i])
  {
    matassign[(signed long int)i] = matassign[(signed long int)i] & ~(1 << 3);
    matassign[(signed long int)i] = matassign[(signed long int)i] | 1 << 0;
  }
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
  i = 1;
  for( ; msa->alen >= i; i = i + 1)
    free((void *)matc[(signed long int)i]);
  free((void *)matc);
  free((void *)sc);
  free((void *)tbck);
  free((void *)matassign);
  free((void *)insopt);
}

// P7OptimalAccuracy
// file postprob.c line 97
extern float P7OptimalAccuracy(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct p7trace_s **ret_tr)
{
  double sc;
  struct dpmatrix_s *forward;
  struct dpmatrix_s *backward;
  P7Forward(dsq, L, hmm, &forward);
  P7Backward(dsq, L, hmm, &backward);
  P7EmitterPosterior(L, hmm, forward, backward, backward);
  float return_value_P7FillOptimalAccuracy$1;
  return_value_P7FillOptimalAccuracy$1=P7FillOptimalAccuracy(L, hmm->M, backward, forward, ret_tr);
  sc = (double)return_value_P7FillOptimalAccuracy$1;
  FreePlan7Matrix(forward);
  FreePlan7Matrix(backward);
  return (float)sc;
}

// P7OptimalAccuracyTrace
// file postprob.c line 449
extern void P7OptimalAccuracyTrace(signed int L, signed int M, struct dpmatrix_s *posterior, struct dpmatrix_s *mx, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  signed int curralloc;
  signed int tpos;
  signed int i;
  signed int k;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int sc;
  curralloc = L * 2 + 6;
  P7AllocTrace(curralloc, &tr);
  xmx = mx->xmx;
  mmx = mx->mmx;
  imx = mx->imx;
  dmx = mx->dmx;
  tr->statetype[(signed long int)0] = (char)9;
  tr->nodeidx[(signed long int)0] = 0;
  tr->pos[(signed long int)0] = 0;
  tr->statetype[(signed long int)1] = (char)8;
  tr->nodeidx[(signed long int)1] = 0;
  tr->pos[(signed long int)1] = 0;
  tpos = 2;
  i = L;
  signed int return_value_ILogsum$8;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int return_value_ILogsum$7;
  signed int tmp_post$3;
  signed int return_value_ILogsum$6;
  signed int tmp_post$4;
  signed int return_value_ILogsum$5;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int return_value_ILogsum$16;
  signed int tmp_post$12;
  signed int tmp_post$13;
  signed int return_value_ILogsum$15;
  signed int tmp_post$14;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$19;
  signed int return_value_ILogsum$18;
  signed int tmp_post$17;
  signed int tmp_post$21;
  signed int tmp_post$22;
  signed int return_value_ILogsum$24;
  signed int tmp_post$23;
  signed int return_value_ILogsum$26;
  signed int tmp_post$25;
  while(!((signed int)tr->statetype[(signed long int)(tpos + -1)] == 4))
  {
    switch((signed int)tr->statetype[(signed long int)(tpos - 1)])
    {
      case 1:
      {
        sc = mmx[(signed long int)(i + 1)][(signed long int)(k + 1)];
        return_value_ILogsum$8=ILogsum(mmx[(signed long int)i][(signed long int)k], posterior->mmx[(signed long int)(i + 1)][(signed long int)(k + 1)]);
        if(sc == return_value_ILogsum$8 && i >= 1 && k >= 1)
        {
          tr->statetype[(signed long int)tpos] = (char)1;
          tmp_post$1 = k;
          k = k - 1;
          tr->nodeidx[(signed long int)tpos] = tmp_post$1;
          tmp_post$2 = i;
          i = i - 1;
          tr->pos[(signed long int)tpos] = tmp_post$2;
        }

        else
        {
          return_value_ILogsum$7=ILogsum(imx[(signed long int)i][(signed long int)k], posterior->mmx[(signed long int)(i + 1)][(signed long int)(k + 1)]);
          if(sc == return_value_ILogsum$7 && i >= 1 && k >= 1)
          {
            tr->statetype[(signed long int)tpos] = (char)3;
            tr->nodeidx[(signed long int)tpos] = k;
            tmp_post$3 = i;
            i = i - 1;
            tr->pos[(signed long int)tpos] = tmp_post$3;
          }

          else
          {
            return_value_ILogsum$6=ILogsum(dmx[(signed long int)i][(signed long int)k], posterior->mmx[(signed long int)(i + 1)][(signed long int)(k + 1)]);
            if(sc == return_value_ILogsum$6 && i >= 1 && k >= 2)
            {
              tr->statetype[(signed long int)tpos] = (char)2;
              tmp_post$4 = k;
              k = k - 1;
              tr->nodeidx[(signed long int)tpos] = tmp_post$4;
              tr->pos[(signed long int)tpos] = 0;
            }

            else
            {
              return_value_ILogsum$5=ILogsum(xmx[(signed long int)i][(signed long int)0], posterior->mmx[(signed long int)(i + 1)][(signed long int)(k + 1)]);
              if(sc == return_value_ILogsum$5)
              {
                tr->statetype[(signed long int)tpos] = (char)6;
                tr->nodeidx[(signed long int)tpos] = 0;
                tr->pos[(signed long int)tpos] = 0;
              }

              else
                Die("traceback failed");
            }
          }
        }
        break;
      }
      case 2:
      {
        if(dmx[(signed long int)i][(signed long int)(1 + k)] == mmx[(signed long int)i][(signed long int)k] && i >= 1 && k >= 1)
        {
          tr->statetype[(signed long int)tpos] = (char)1;
          tmp_post$9 = k;
          k = k - 1;
          tr->nodeidx[(signed long int)tpos] = tmp_post$9;
          tmp_post$10 = i;
          i = i - 1;
          tr->pos[(signed long int)tpos] = tmp_post$10;
        }

        else
          if(dmx[(signed long int)i][(signed long int)(1 + k)] == dmx[(signed long int)i][(signed long int)k] && k >= 2)
          {
            tr->statetype[(signed long int)tpos] = (char)2;
            tmp_post$11 = k;
            k = k - 1;
            tr->nodeidx[(signed long int)tpos] = tmp_post$11;
            tr->pos[(signed long int)tpos] = 0;
          }

          else
            Die("traceback failed");
        break;
      }
      case 3:
      {
        sc = imx[(signed long int)(i + 1)][(signed long int)k];
        return_value_ILogsum$16=ILogsum(mmx[(signed long int)i][(signed long int)k], posterior->imx[(signed long int)(i + 1)][(signed long int)k]);
        if(sc == return_value_ILogsum$16 && i >= 1 && k >= 1)
        {
          tr->statetype[(signed long int)tpos] = (char)1;
          tmp_post$12 = k;
          k = k - 1;
          tr->nodeidx[(signed long int)tpos] = tmp_post$12;
          tmp_post$13 = i;
          i = i - 1;
          tr->pos[(signed long int)tpos] = tmp_post$13;
        }

        else
        {
          return_value_ILogsum$15=ILogsum(imx[(signed long int)i][(signed long int)k], posterior->imx[(signed long int)(i + 1)][(signed long int)k]);
          if(sc == return_value_ILogsum$15 && i >= 1 && k >= 1)
          {
            tr->statetype[(signed long int)tpos] = (char)3;
            tr->nodeidx[(signed long int)tpos] = k;
            tmp_post$14 = i;
            i = i - 1;
            tr->pos[(signed long int)tpos] = tmp_post$14;
          }

          else
            Die("traceback failed");
        }
        break;
      }
      case 5:
      {
        if(i == 0)
          tmp_if_expr$20 = xmx[(signed long int)i][(signed long int)4] == -987654321 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$20 = (_Bool)0;
        if(tmp_if_expr$20)
        {
          tr->statetype[(signed long int)tpos] = (char)4;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
        }

        else
        {
          if(i >= 1)
          {
            return_value_ILogsum$18=ILogsum(xmx[(signed long int)i][(signed long int)4], posterior->xmx[(signed long int)(i + 1)][(signed long int)4]);
            tmp_if_expr$19 = xmx[(signed long int)(i + 1)][(signed long int)4] == return_value_ILogsum$18 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$19 = (_Bool)0;
          if(i >= 1 && tmp_if_expr$19)
          {
            tr->statetype[(signed long int)tpos] = (char)5;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
            tmp_post$17 = i;
            i = i - 1;
            tr->pos[(signed long int)(tpos - 1)] = tmp_post$17;
          }

          else
            Die("traceback failed");
        }
        break;
      }
      case 6:
      {
        if(*xmx[(signed long int)i] == xmx[(signed long int)i][4l])
        {
          tr->statetype[(signed long int)tpos] = (char)5;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
        }

        else
          if(*xmx[(signed long int)i] == xmx[(signed long int)i][3l])
          {
            tr->statetype[(signed long int)tpos] = (char)10;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
          }

          else
            Die("traceback failed");
        break;
      }
      case 7:
      {
        k = M;
        for( ; k >= 1; k = k - 1)
          if(xmx[(signed long int)i][1l] == mmx[(signed long int)i][(signed long int)k])
          {
            if(i >= 1)
            {
              tr->statetype[(signed long int)tpos] = (char)1;
              tmp_post$21 = k;
              k = k - 1;
              tr->nodeidx[(signed long int)tpos] = tmp_post$21;
              tmp_post$22 = i;
              i = i - 1;
              tr->pos[(signed long int)tpos] = tmp_post$22;
              break;
            }

          }

        if(!(k >= 1))
          Die("traceback failed");

        break;
      }
      case 8:
      {
        return_value_ILogsum$24=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)2], posterior->xmx[(signed long int)i][(signed long int)2]);
        if(xmx[(signed long int)i][2l] == return_value_ILogsum$24 && i >= 1)
        {
          tr->statetype[(signed long int)tpos] = (char)8;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
          tmp_post$23 = i;
          i = i - 1;
          tr->pos[(signed long int)(tpos - 1)] = tmp_post$23;
        }

        else
          if(xmx[(signed long int)i][2l] == xmx[(signed long int)i][1l])
          {
            tr->statetype[(signed long int)tpos] = (char)7;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
          }

          else
            Die("Traceback failed.");
        break;
      }
      case 10:
      {
        return_value_ILogsum$26=ILogsum(xmx[(signed long int)(i - 1)][(signed long int)3], posterior->xmx[(signed long int)i][(signed long int)3]);
        if(xmx[(signed long int)i][3l] == return_value_ILogsum$26 && i >= 1)
        {
          tr->statetype[(signed long int)tpos] = (char)10;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
          tmp_post$25 = i;
          i = i - 1;
          tr->pos[(signed long int)(tpos - 1)] = tmp_post$25;
        }

        else
          if(xmx[(signed long int)i][3l] == xmx[(signed long int)i][1l])
          {
            tr->statetype[(signed long int)tpos] = (char)7;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
          }

          else
            Die("Traceback failed.");
        break;
      }
      default:
        Die("traceback failed");
    }
    tpos = tpos + 1;
    if(tpos == curralloc)
    {
      curralloc = curralloc + L;
      P7ReallocTrace(tr, curralloc);
    }

  }
  tr->tlen = tpos;
  P7ReverseTrace(tr);
  *ret_tr = tr;
}

// P7ParsingViterbi
// file core_algorithms.c line 1128
extern float P7ParsingViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct p7trace_s **ret_tr)
{
  struct dpmatrix_s *mx;
  struct dpmatrix_s *tmx;
  struct p7trace_s *tr;
  signed int **xmx;
  signed int **mmx;
  signed int **dmx;
  signed int **imx;
  signed int **xtr;
  signed int **mtr;
  signed int **dtr;
  signed int **itr;
  signed int *btr;
  signed int *etr;
  signed int sc;
  signed int i;
  signed int k;
  signed int tpos;
  signed int cur;
  signed int prv;
  signed int curralloc;
  mx=AllocPlan7Matrix(2, hmm->M, &xmx, &mmx, &imx, &dmx);
  tmx=AllocPlan7Matrix(2, hmm->M, &xtr, &mtr, &itr, &dtr);
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("core_algorithms.c", 1147, sizeof(signed int) /*4ul*/  * (unsigned long int)(L + 1));
  btr = (signed int *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("core_algorithms.c", 1148, sizeof(signed int) /*4ul*/  * (unsigned long int)(L + 1));
  etr = (signed int *)return_value_sre_malloc$2;
  xmx[(signed long int)0][(signed long int)4] = 0;
  xmx[(signed long int)0][(signed long int)0] = hmm->xsc[(signed long int)0][(signed long int)0];
  btr[(signed long int)0] = 0;
  xmx[(signed long int)0][(signed long int)3] = -987654321;
  xmx[(signed long int)0][(signed long int)2] = xmx[(signed long int)0][(signed long int)3];
  xmx[(signed long int)0][(signed long int)1] = xmx[(signed long int)0][(signed long int)2];
  etr[(signed long int)0] = -1;
  k = 0;
  for( ; hmm->M >= k; k = k + 1)
  {
    dmx[(signed long int)0][(signed long int)k] = -987654321;
    imx[(signed long int)0][(signed long int)k] = dmx[(signed long int)0][(signed long int)k];
    mmx[(signed long int)0][(signed long int)k] = imx[(signed long int)0][(signed long int)k];
  }
  i = 1;
  for( ; L >= i; i = i + 1)
  {
    cur = i % 2;
    prv = (signed int)!(cur != 0);
    dmx[(signed long int)cur][(signed long int)0] = -987654321;
    imx[(signed long int)cur][(signed long int)0] = dmx[(signed long int)cur][(signed long int)0];
    mmx[(signed long int)cur][(signed long int)0] = imx[(signed long int)cur][(signed long int)0];
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      mmx[(signed long int)cur][(signed long int)k] = -987654321;
      sc = mmx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)];
      if(sc >= -987654320)
      {
        mmx[(signed long int)cur][(signed long int)k] = sc;
        mtr[(signed long int)cur][(signed long int)k] = mtr[(signed long int)prv][(signed long int)(k - 1)];
      }

      sc = imx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)];
      if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
      {
        mmx[(signed long int)cur][(signed long int)k] = sc;
        mtr[(signed long int)cur][(signed long int)k] = itr[(signed long int)prv][(signed long int)(k - 1)];
      }

      sc = xmx[(signed long int)prv][(signed long int)0] + hmm->bsc[(signed long int)k];
      if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
      {
        mmx[(signed long int)cur][(signed long int)k] = sc;
        mtr[(signed long int)cur][(signed long int)k] = i - 1;
      }

      sc = dmx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)];
      if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
      {
        mmx[(signed long int)cur][(signed long int)k] = sc;
        mtr[(signed long int)cur][(signed long int)k] = dtr[(signed long int)prv][(signed long int)(k - 1)];
      }

      if(!(hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k] == -987654321))
        mmx[(signed long int)cur][(signed long int)k] = mmx[(signed long int)cur][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k];

      else
        mmx[(signed long int)cur][(signed long int)k] = -987654321;
      dmx[(signed long int)cur][(signed long int)k] = -987654321;
      sc = mmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)2][(signed long int)(k - 1)];
      if(sc >= -987654320)
      {
        dmx[(signed long int)cur][(signed long int)k] = sc;
        dtr[(signed long int)cur][(signed long int)k] = mtr[(signed long int)cur][(signed long int)(k - 1)];
      }

      sc = dmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)6][(signed long int)(k - 1)];
      if(!(dmx[(signed long int)cur][(signed long int)k] >= sc))
      {
        dmx[(signed long int)cur][(signed long int)k] = sc;
        dtr[(signed long int)cur][(signed long int)k] = dtr[(signed long int)cur][(signed long int)(k - 1)];
      }

      if(!(k >= hmm->M))
      {
        imx[(signed long int)cur][(signed long int)k] = -987654321;
        sc = mmx[(signed long int)prv][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k];
        if(sc >= -987654320)
        {
          imx[(signed long int)cur][(signed long int)k] = sc;
          itr[(signed long int)cur][(signed long int)k] = mtr[(signed long int)prv][(signed long int)k];
        }

        sc = imx[(signed long int)prv][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k];
        if(!(imx[(signed long int)cur][(signed long int)k] >= sc))
        {
          imx[(signed long int)cur][(signed long int)k] = sc;
          itr[(signed long int)cur][(signed long int)k] = itr[(signed long int)prv][(signed long int)k];
        }

        if(!(hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k] == -987654321))
          imx[(signed long int)cur][(signed long int)k] = imx[(signed long int)cur][(signed long int)k] + hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k];

        else
          imx[(signed long int)cur][(signed long int)k] = -987654321;
      }

    }
    xmx[(signed long int)cur][(signed long int)4] = -987654321;
    sc = xmx[(signed long int)prv][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)4] = sc;

    xmx[(signed long int)cur][(signed long int)1] = -987654321;
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      sc = mmx[(signed long int)cur][(signed long int)k] + hmm->esc[(signed long int)k];
      if(!(xmx[(signed long int)cur][1l] >= sc))
      {
        xmx[(signed long int)cur][(signed long int)1] = sc;
        etr[(signed long int)i] = mtr[(signed long int)cur][(signed long int)k];
      }

    }
    xmx[(signed long int)cur][(signed long int)3] = -987654321;
    sc = xmx[(signed long int)prv][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)1];
    if(sc >= -987654320)
    {
      xmx[(signed long int)cur][(signed long int)3] = sc;
      xtr[(signed long int)cur][(signed long int)3] = xtr[(signed long int)prv][(signed long int)3];
    }

    sc = xmx[(signed long int)cur][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)1];
    if(!(xmx[(signed long int)cur][3l] >= sc))
    {
      xmx[(signed long int)cur][(signed long int)3] = sc;
      xtr[(signed long int)cur][(signed long int)3] = i;
    }

    xmx[(signed long int)cur][(signed long int)0] = -987654321;
    sc = xmx[(signed long int)cur][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0];
    if(sc >= -987654320)
    {
      xmx[(signed long int)cur][(signed long int)0] = sc;
      btr[(signed long int)i] = 0;
    }

    sc = xmx[(signed long int)cur][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)0];
    if(!(*xmx[(signed long int)cur] >= sc))
    {
      xmx[(signed long int)cur][(signed long int)0] = sc;
      btr[(signed long int)i] = xtr[(signed long int)cur][(signed long int)3];
    }

    xmx[(signed long int)cur][(signed long int)2] = -987654321;
    sc = xmx[(signed long int)prv][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1];
    if(sc >= -987654320)
    {
      xmx[(signed long int)cur][(signed long int)2] = sc;
      xtr[(signed long int)cur][(signed long int)2] = xtr[(signed long int)prv][(signed long int)2];
    }

    sc = xmx[(signed long int)cur][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0];
    if(!(xmx[(signed long int)cur][2l] >= sc))
    {
      xmx[(signed long int)cur][(signed long int)2] = sc;
      xtr[(signed long int)cur][(signed long int)2] = i;
    }

  }
  sc = xmx[(signed long int)cur][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)0];
  curralloc = 2;
  P7AllocTrace(curralloc, &tr);
  tpos = 0;
  tr->statetype[(signed long int)tpos] = (char)9;
  tr->pos[(signed long int)tpos] = 0;
  i = xtr[(signed long int)(L % 2)][(signed long int)2];
  for( ; i >= 1; i = btr[(signed long int)i])
  {
    curralloc = curralloc + 2;
    P7ReallocTrace(tr, curralloc);
    tpos = tpos + 1;
    tr->statetype[(signed long int)tpos] = (char)7;
    tr->pos[(signed long int)tpos] = i;
    i = etr[(signed long int)i];
    tpos = tpos + 1;
    tr->statetype[(signed long int)tpos] = (char)6;
    tr->pos[(signed long int)tpos] = i;
  }
  tpos = tpos + 1;
  tr->statetype[(signed long int)tpos] = (char)4;
  tr->pos[(signed long int)tpos] = 0;
  tr->tlen = tpos + 1;
  P7ReverseTrace(tr);
  FreePlan7Matrix(mx);
  FreePlan7Matrix(tmx);
  free((void *)btr);
  free((void *)etr);
  *ret_tr = tr;
  float return_value_Scorify$3;
  return_value_Scorify$3=Scorify(sc);
  return return_value_Scorify$3;
}

// P7PrintPrior
// file debug.c line 167
extern void P7PrintPrior(struct _IO_FILE *fp, struct p7prior_s *pri)
{
  signed int q;
  signed int x;
  if(pri->strategy == 0)
    fputs("Dirichlet\n", fp);

  else
    if(pri->strategy == 1)
      fputs("PAM\n", fp);

    else
      Die("No such strategy.");
  if(Alphabet_type == 3)
    fputs("Amino\n", fp);

  else
    if(Alphabet_type == 2)
      fputs("Nucleic\n", fp);

  fprintf(fp, "\n%d\n", pri->tnum);
  q = 0;
  for( ; !(q >= pri->tnum); q = q + 1)
  {
    fprintf(fp, "%.4f\n", pri->tq[(signed long int)q]);
    x = 0;
    for( ; !(x >= 7); x = x + 1)
      fprintf(fp, "%.4f ", pri->t[(signed long int)q][(signed long int)x]);
    fputs("\n", fp);
  }
  fprintf(fp, "\n%d\n", pri->mnum);
  q = 0;
  for( ; !(q >= pri->mnum); q = q + 1)
  {
    fprintf(fp, "%.4f\n", pri->mq[(signed long int)q]);
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      fprintf(fp, "%.4f ", pri->m[(signed long int)q][(signed long int)x]);
    fputs("\n", fp);
  }
  fprintf(fp, "\n%d\n", pri->inum);
  q = 0;
  for( ; !(q >= pri->inum); q = q + 1)
  {
    fprintf(fp, "%.4f\n", pri->iq[(signed long int)q]);
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      fprintf(fp, "%.4f ", pri->i[(signed long int)q][(signed long int)x]);
    fputs("\n", fp);
  }
}

// P7PrintTrace
// file debug.c line 89
extern void P7PrintTrace(struct _IO_FILE *fp, struct p7trace_s *tr, struct plan7_s *hmm, unsigned char *dsq)
{
  signed int tpos;
  unsigned int sym;
  signed int sc;
  signed int tmp_if_expr$4;
  signed int return_value_TransitionScoreLookup$3;
  signed int return_value_TransitionScoreLookup$5;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  if(tr == ((struct p7trace_s *)NULL))
    fprintf(fp, " [ trace is NULL ]\n");

  else
    if(hmm == ((struct plan7_s *)NULL))
    {
      fprintf(fp, "st  node   rpos  - traceback len %d\n", tr->tlen);
      fprintf(fp, "--  ---- ------\n");
      tpos = 0;
      for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
      {
        char *return_value_Statetype$1;
        return_value_Statetype$1=Statetype(tr->statetype[(signed long int)tpos]);
        fprintf(fp, "%1s  %4d %6d\n", return_value_Statetype$1, tr->nodeidx[(signed long int)tpos], tr->pos[(signed long int)tpos]);
      }
    }

    else
    {
      if((1 & hmm->flags) == 0)
        Die("oi, you can't print scores from that hmm, it's not ready.");

      sc = 0;
      fprintf(fp, "st  node   rpos  transit emission - traceback len %d\n", tr->tlen);
      fprintf(fp, "--  ---- ------  ------- --------\n");
      tpos = 0;
      for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
      {
        if(!(dsq == ((unsigned char *)NULL)))
          sym = (unsigned int)dsq[(signed long int)tr->pos[(signed long int)tpos]];

        char *return_value_Statetype$2;
        return_value_Statetype$2=Statetype(tr->statetype[(signed long int)tpos]);
        if(!(tpos >= tr->tlen + -1))
        {
          return_value_TransitionScoreLookup$3=TransitionScoreLookup(hmm, tr->statetype[(signed long int)tpos], tr->nodeidx[(signed long int)tpos], tr->statetype[(signed long int)(tpos + 1)], tr->nodeidx[(signed long int)(tpos + 1)]);
          tmp_if_expr$4 = return_value_TransitionScoreLookup$3;
        }

        else
          tmp_if_expr$4 = 0;
        fprintf(fp, "%1s  %4d %6d  %7d", return_value_Statetype$2, tr->nodeidx[(signed long int)tpos], tr->pos[(signed long int)tpos], tmp_if_expr$4);
        if(!(tpos >= tr->tlen + -1))
        {
          return_value_TransitionScoreLookup$5=TransitionScoreLookup(hmm, tr->statetype[(signed long int)tpos], tr->nodeidx[(signed long int)tpos], tr->statetype[(signed long int)(tpos + 1)], tr->nodeidx[(signed long int)(tpos + 1)]);
          sc = sc + return_value_TransitionScoreLookup$5;
        }

        if(!(dsq == ((unsigned char *)NULL)))
        {
          if((signed int)tr->statetype[(signed long int)tpos] == 1)
          {
            fprintf(fp, " %8d %c", hmm->msc[(signed long int)sym][(signed long int)tr->nodeidx[(signed long int)tpos]], Alphabet[(signed long int)sym]);
            sc = sc + hmm->msc[(signed long int)sym][(signed long int)tr->nodeidx[(signed long int)tpos]];
          }

          else
            if((signed int)tr->statetype[(signed long int)tpos] == 3)
            {
              signed int return_value_tolower$6;
              return_value_tolower$6=tolower((signed int)Alphabet[(signed long int)sym]);
              fprintf(fp, " %8d %c", hmm->isc[(signed long int)sym][(signed long int)tr->nodeidx[(signed long int)tpos]], (char)return_value_tolower$6);
              sc = sc + hmm->isc[(signed long int)sym][(signed long int)tr->nodeidx[(signed long int)tpos]];
            }

            else
            {
              if((signed int)tr->statetype[(signed long int)tpos] == 5)
                tmp_if_expr$8 = (signed int)tr->statetype[(signed long int)(tpos - 1)] == 5 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$8 = (_Bool)0;
              if(tmp_if_expr$8)
                tmp_if_expr$10 = (_Bool)1;

              else
              {
                if((signed int)tr->statetype[(signed long int)tpos] == 8)
                  tmp_if_expr$9 = (signed int)tr->statetype[(signed long int)(tpos - 1)] == 8 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$9 = (_Bool)0;
                tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$10)
                tmp_if_expr$12 = (_Bool)1;

              else
              {
                if((signed int)tr->statetype[(signed long int)tpos] == 10)
                  tmp_if_expr$11 = (signed int)tr->statetype[(signed long int)(tpos - 1)] == 10 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$11 = (_Bool)0;
                tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$12)
              {
                signed int return_value_tolower$7;
                return_value_tolower$7=tolower((signed int)Alphabet[(signed long int)sym]);
                fprintf(fp, " %8d %c", 0, (char)return_value_tolower$7);
              }

            }
        }

        else
          fprintf(fp, " %8s %c", (const void *)"-", 45);
        fputs("\n", fp);
      }
      fprintf(fp, "                 ------- --------\n");
      fprintf(fp, "           total: %6d\n\n", sc);
    }
}

// P7PriorifyEmissionVector
// file funcs.h line 274
extern void P7PriorifyEmissionVector(float *vec, struct p7prior_s *pri, signed int num, float *eq, float (*e)[20l], float *ret_mix)
{
  signed int x;
  signed int q;
  float mix[200l];
  float totc;
  float tota;
  float xi;
  mix[(signed long int)0] = (float)1.0;
  double tmp_if_expr$2;
  double return_value_log$1;
  if(pri->strategy == 0 && num >= 2)
  {
    q = 0;
    for( ; !(q >= num); q = q + 1)
    {
      if(eq[(signed long int)q] > 0.000000f)
      {
        return_value_log$1=log((double)eq[(signed long int)q]);
        tmp_if_expr$2 = return_value_log$1;
      }

      else
        tmp_if_expr$2 = -999.;
      mix[(signed long int)q] = (float)tmp_if_expr$2;
      float return_value_Logp_cvec$3;
      return_value_Logp_cvec$3=Logp_cvec(vec, Alphabet_size, e[(signed long int)q]);
      mix[(signed long int)q] = mix[(signed long int)q] + return_value_Logp_cvec$3;
    }
    LogNorm(mix, num);
  }

  else
    if(pri->strategy == 1)
    {
      if(num >= 2)
      {
        q = 0;
        for( ; !(q >= Alphabet_size); q = q + 1)
          mix[(signed long int)q] = vec[(signed long int)q];
        FNorm(mix, Alphabet_size);
      }

    }

  totc=FSum(vec, Alphabet_size);
  x = 0;
  for( ; !(x >= Alphabet_size); x = x + 1)
  {
    xi = (float)0.0;
    q = 0;
    for( ; !(q >= num); q = q + 1)
    {
      tota=FSum(e[(signed long int)q], Alphabet_size);
      xi = xi + (mix[(signed long int)q] * (vec[(signed long int)x] + e[(signed long int)q][(signed long int)x])) / (totc + tota);
    }
    vec[(signed long int)x] = xi;
  }
  FNorm(vec, Alphabet_size);
  if(!(ret_mix == ((float *)NULL)))
  {
    q = 0;
    for( ; !(q >= num); q = q + 1)
      ret_mix[(signed long int)q] = mix[(signed long int)q];
  }

}

// P7PriorifyHMM
// file prior.c line 342
extern void P7PriorifyHMM(struct plan7_s *hmm, struct p7prior_s *pri)
{
  signed int k;
  float d;
  float tq[200l];
  float mq[200l];
  float iq[200l];
  FSet(hmm->begin + (signed long int)2, hmm->M - 1, (float)0.);
  FSet(hmm->end + (signed long int)1, hmm->M - 1, (float)0.);
  d = (float)((double)(hmm->tbd1 + hmm->begin[(signed long int)1]) + 2.);
  hmm->tbd1 = (float)(((double)hmm->tbd1 + 1.) / (double)d);
  hmm->begin[(signed long int)1] = (float)(((double)hmm->begin[(signed long int)1] + 1.) / (double)d);
  hmm->end[(signed long int)hmm->M] = (float)1.0;
  k = 1;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    if(!(hmm->tpri == ((signed int *)NULL)))
      tmp_if_expr$1 = hmm->tpri[(signed long int)k] >= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(hmm->tpri[(signed long int)k] >= pri->tnum)
        Die("X-PRT annotation out of range");

      FSet(tq, pri->tnum, (float)0.0);
      tq[(signed long int)hmm->tpri[(signed long int)k]] = (float)1.0;
    }

    else
      FCopy(tq, pri->tq, pri->tnum);
    if(!(hmm->mpri == ((signed int *)NULL)))
      tmp_if_expr$2 = hmm->mpri[(signed long int)k] >= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(hmm->mpri[(signed long int)k] >= pri->mnum)
        Die("X-PRM annotation out of range");

      FSet(mq, pri->mnum, (float)0.0);
      mq[(signed long int)hmm->mpri[(signed long int)k]] = (float)1.0;
    }

    else
      FCopy(mq, pri->mq, pri->mnum);
    if(!(hmm->ipri == ((signed int *)NULL)))
      tmp_if_expr$3 = hmm->ipri[(signed long int)k] >= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      if(hmm->ipri[(signed long int)k] >= pri->inum)
        Die("X-PRI annotation out of range");

      FSet(iq, pri->inum, (float)0.0);
      iq[(signed long int)hmm->ipri[(signed long int)k]] = (float)1.0;
    }

    else
      FCopy(iq, pri->iq, pri->inum);
    P7PriorifyTransitionVector(hmm->t[(signed long int)k], pri, tq);
    P7PriorifyEmissionVector(hmm->mat[(signed long int)k], pri, pri->mnum, mq, pri->m, (float *)(void *)0);
    P7PriorifyEmissionVector(hmm->ins[(signed long int)k], pri, pri->inum, iq, pri->i, (float *)(void *)0);
  }
  _Bool tmp_if_expr$4;
  if(!(hmm->mpri == ((signed int *)NULL)))
    tmp_if_expr$4 = hmm->mpri[(signed long int)hmm->M] >= 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  if(tmp_if_expr$4)
  {
    if(hmm->mpri[(signed long int)hmm->M] >= pri->mnum)
      Die("X-PRM annotation out of range");

    FSet(mq, pri->mnum, (float)0.0);
    mq[(signed long int)hmm->mpri[(signed long int)hmm->M]] = (float)1.0;
  }

  else
    FCopy(mq, pri->mq, pri->mnum);
  P7PriorifyEmissionVector(hmm->mat[(signed long int)hmm->M], pri, pri->mnum, mq, pri->m, (float *)(void *)0);
  Plan7Renormalize(hmm);
}

// P7PriorifyTransitionVector
// file funcs.h line 272
extern void P7PriorifyTransitionVector(float *t, struct p7prior_s *prior, float *tq)
{
  signed int ts;
  signed int q;
  float mix[200l];
  float totm;
  float totd;
  float toti;
  float xi;
  mix[(signed long int)0] = (float)1.0;
  _Bool tmp_if_expr$6;
  if(prior->strategy == 0)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = prior->strategy == 1 ? (_Bool)1 : (_Bool)0;
  double tmp_if_expr$2;
  double return_value_log$1;
  if(tmp_if_expr$6)
  {
    if(prior->mnum >= 2)
    {
      q = 0;
      for( ; !(q >= prior->tnum); q = q + 1)
      {
        if(tq[(signed long int)q] > 0.000000f)
        {
          return_value_log$1=log((double)tq[(signed long int)q]);
          tmp_if_expr$2 = return_value_log$1;
        }

        else
          tmp_if_expr$2 = -999.;
        mix[(signed long int)q] = (float)tmp_if_expr$2;
        float return_value_Logp_cvec$3;
        return_value_Logp_cvec$3=Logp_cvec(t, 3, prior->t[(signed long int)q]);
        mix[(signed long int)q] = mix[(signed long int)q] + return_value_Logp_cvec$3;
        float return_value_Logp_cvec$4;
        return_value_Logp_cvec$4=Logp_cvec(t + (signed long int)3, 2, prior->t[(signed long int)q] + (signed long int)3);
        mix[(signed long int)q] = mix[(signed long int)q] + return_value_Logp_cvec$4;
        float return_value_Logp_cvec$5;
        return_value_Logp_cvec$5=Logp_cvec(t + (signed long int)5, 2, prior->t[(signed long int)q] + (signed long int)5);
        mix[(signed long int)q] = mix[(signed long int)q] + return_value_Logp_cvec$5;
      }
      LogNorm(mix, prior->tnum);
    }

  }

  totm=FSum(t, 3);
  toti = t[(signed long int)3] + t[(signed long int)4];
  totd = t[(signed long int)5] + t[(signed long int)6];
  ts = 0;
  float return_value_FSum$7;
  for( ; !(ts >= 7); ts = ts + 1)
  {
    xi = (float)0.0;
    q = 0;
    while(!(q >= prior->tnum))
      switch(ts)
      {
        case 0:

        case 1:

        case 2:
        {
          return_value_FSum$7=FSum(prior->t[(signed long int)q], 3);
          xi = xi + (mix[(signed long int)q] * (t[(signed long int)ts] + prior->t[(signed long int)q][(signed long int)ts])) / (totm + return_value_FSum$7);
          goto __CPROVER_DUMP_L13;
        }
        case 3:

        case 4:
        {
          xi = xi + (mix[(signed long int)q] * (t[(signed long int)ts] + prior->t[(signed long int)q][(signed long int)ts])) / (toti + prior->t[(signed long int)q][(signed long int)3] + prior->t[(signed long int)q][(signed long int)4]);
          goto __CPROVER_DUMP_L13;
        }
        case 5:

        case 6:
          xi = xi + (mix[(signed long int)q] * (t[(signed long int)ts] + prior->t[(signed long int)q][(signed long int)ts])) / (totd + prior->t[(signed long int)q][(signed long int)5] + prior->t[(signed long int)q][(signed long int)6]);
        default:
        {

        __CPROVER_DUMP_L13:
          ;
          q = q + 1;
        }
      }
    t[(signed long int)ts] = xi;
  }
  FNorm(t, 3);
  FNorm(t + (signed long int)3, 2);
  FNorm(t + (signed long int)5, 2);
}

// P7ReadNullModel
// file prior.c line 294
extern void P7ReadNullModel(char *rndfile, float *null, float *ret_p1)
{
  struct _IO_FILE *fp;
  char *s;
  signed int x;
  signed int type = 0;
  fp=fopen(rndfile, "r");
  if(fp == ((struct _IO_FILE *)NULL))
    Die("Failed to open null model file %s\n", rndfile);

  s=Getword(fp, 4);
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  double return_value_atof$4;
  if(!(s == ((char *)NULL)))
  {
    s2upper(s);
    return_value_strcmp$2=strcmp(s, "NUCLEIC");
    if(return_value_strcmp$2 == 0)
      type = 2;

    else
    {
      return_value_strcmp$1=strcmp(s, "AMINO");
      if(return_value_strcmp$1 == 0)
        type = 3;

      else
        goto FAILURE;
    }
    if(Alphabet_type == 0)
      SetAlphabet(type);

    else
      if(!(Alphabet_type == type))
        Die("Alphabet type conflict; null model in %s is inappropriate\n", rndfile);

    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
    {
      s=Getword(fp, 2);
      if(s == ((char *)NULL))
        goto FAILURE;

      double return_value_atof$3;
      return_value_atof$3=atof(s);
      null[(signed long int)x] = (float)return_value_atof$3;
    }
    s=Getword(fp, 2);
    if(s == ((char *)NULL))
      goto FAILURE;

    return_value_atof$4=atof(s);
    *ret_p1 = (float)return_value_atof$4;
    fclose(fp);
  }

  else
  {

  FAILURE:
    ;
    fclose(fp);
    Die("%s is not in HMMER null model file format", rndfile);
  }
}

// P7ReadPrior
// file prior.c line 97
extern struct p7prior_s * P7ReadPrior(char *prifile)
{
  struct _IO_FILE *fp;
  struct p7prior_s *pri;
  char *sptr;
  signed int q;
  signed int x;
  fp=fopen(prifile, "r");
  if(fp == ((struct _IO_FILE *)NULL))
    Die("Failed to open HMMER prior file %s\n", prifile);

  pri=P7AllocPrior();
  sptr=Getword(fp, 4);
  s2upper(sptr);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(sptr, "DIRICHLET");
  if(return_value_strcmp$1 == 0)
    pri->strategy = 0;

  else
    Die("No such prior strategy %s; failed to parse file %s", sptr, prifile);
  sptr=Getword(fp, 4);
  s2upper(sptr);
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(sptr, "AMINO");
  signed int return_value_strcmp$2;
  if(return_value_strcmp$3 == 0)
  {
    if(!(Alphabet_type == 3))
      Die("HMM and/or sequences are DNA/RNA; can't use protein prior %s", prifile);

  }

  else
  {
    return_value_strcmp$2=strcmp(sptr, "NUCLEIC");
    if(return_value_strcmp$2 == 0)
    {
      if(!(Alphabet_type == 2))
        Die("HMM and/or sequences are protein; can't use DNA/RNA prior %s", prifile);

    }

    else
      Die("Alphabet \"%s\" in prior file %s isn't valid.", sptr, prifile);
  }
  char *return_value_Getword$4;
  return_value_Getword$4=Getword(fp, 1);
  pri->tnum=atoi(return_value_Getword$4);
  if(!(pri->tnum >= 0))
    Die("%d is bad; need at least one state transition mixture component", pri->tnum);

  if(pri->tnum >= 201)
    Die("%d is bad, too many transition components (MAXDCHLET = %d)\n", 200);

  q = 0;
  char *return_value_Getword$7;
  double return_value_atof$8;
  for( ; !(q >= pri->tnum); q = q + 1)
  {
    char *return_value_Getword$5;
    return_value_Getword$5=Getword(fp, 2);
    double return_value_atof$6;
    return_value_atof$6=atof(return_value_Getword$5);
    pri->tq[(signed long int)q] = (float)return_value_atof$6;
    x = 0;
    for( ; !(x >= 7); x = x + 1)
    {
      return_value_Getword$7=Getword(fp, 2);
      return_value_atof$8=atof(return_value_Getword$7);
      pri->t[(signed long int)q][(signed long int)x] = (float)return_value_atof$8;
    }
  }
  char *return_value_Getword$9;
  return_value_Getword$9=Getword(fp, 1);
  pri->mnum=atoi(return_value_Getword$9);
  if(!(pri->mnum >= 0))
    Die("%d is bad; need at least one match emission mixture component", pri->mnum);

  if(pri->mnum >= 201)
    Die("%d is bad; too many match components (MAXDCHLET = %d)\n", pri->mnum, 200);

  q = 0;
  char *return_value_Getword$12;
  double return_value_atof$13;
  for( ; !(q >= pri->mnum); q = q + 1)
  {
    char *return_value_Getword$10;
    return_value_Getword$10=Getword(fp, 2);
    double return_value_atof$11;
    return_value_atof$11=atof(return_value_Getword$10);
    pri->mq[(signed long int)q] = (float)return_value_atof$11;
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
    {
      return_value_Getword$12=Getword(fp, 2);
      return_value_atof$13=atof(return_value_Getword$12);
      pri->m[(signed long int)q][(signed long int)x] = (float)return_value_atof$13;
    }
  }
  char *return_value_Getword$14;
  return_value_Getword$14=Getword(fp, 1);
  pri->inum=atoi(return_value_Getword$14);
  if(!(pri->inum >= 0))
    Die("%d is bad; need at least one insert emission mixture component", pri->inum);

  if(pri->inum >= 201)
    Die("%d is bad; too many insert components (MAXDCHLET = %d)\n", pri->inum, 200);

  q = 0;
  char *return_value_Getword$17;
  double return_value_atof$18;
  for( ; !(q >= pri->inum); q = q + 1)
  {
    char *return_value_Getword$15;
    return_value_Getword$15=Getword(fp, 2);
    double return_value_atof$16;
    return_value_atof$16=atof(return_value_Getword$15);
    pri->iq[(signed long int)q] = (float)return_value_atof$16;
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
    {
      return_value_Getword$17=Getword(fp, 2);
      return_value_atof$18=atof(return_value_Getword$17);
      pri->i[(signed long int)q][(signed long int)x] = (float)return_value_atof$18;
    }
  }
  fclose(fp);
  return pri;
}

// P7ReallocTrace
// file funcs.h line 336
extern void P7ReallocTrace(struct p7trace_s *tr, signed int tlen)
{
  void *return_value_sre_realloc$1;
  return_value_sre_realloc$1=sre_realloc("trace.c", 49, (void *)tr->statetype, (unsigned long int)tlen * sizeof(char) /*1ul*/ );
  tr->statetype = (char *)return_value_sre_realloc$1;
  void *return_value_sre_realloc$2;
  return_value_sre_realloc$2=sre_realloc("trace.c", 50, (void *)tr->nodeidx, (unsigned long int)tlen * sizeof(signed int) /*4ul*/ );
  tr->nodeidx = (signed int *)return_value_sre_realloc$2;
  void *return_value_sre_realloc$3;
  return_value_sre_realloc$3=sre_realloc("trace.c", 51, (void *)tr->pos, (unsigned long int)tlen * sizeof(signed int) /*4ul*/ );
  tr->pos = (signed int *)return_value_sre_realloc$3;
}

// P7ReverseTrace
// file funcs.h line 340
extern void P7ReverseTrace(struct p7trace_s *tr)
{
  char *statetype;
  signed int *nodeidx;
  signed int *pos;
  signed int opos;
  signed int npos;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("trace.c", 149, sizeof(char) /*1ul*/  * (unsigned long int)tr->tlen);
  statetype = (char *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("trace.c", 150, sizeof(signed int) /*4ul*/  * (unsigned long int)tr->tlen);
  nodeidx = (signed int *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("trace.c", 151, sizeof(signed int) /*4ul*/  * (unsigned long int)tr->tlen);
  pos = (signed int *)return_value_sre_malloc$3;
  opos = tr->tlen - 1;
  npos = 0;
  for( ; !(npos >= tr->tlen); opos = opos - 1)
  {
    statetype[(signed long int)npos] = tr->statetype[(signed long int)opos];
    nodeidx[(signed long int)npos] = tr->nodeidx[(signed long int)opos];
    pos[(signed long int)npos] = tr->pos[(signed long int)opos];
    npos = npos + 1;
  }
  free((void *)tr->statetype);
  free((void *)tr->nodeidx);
  free((void *)tr->pos);
  tr->statetype = statetype;
  tr->nodeidx = nodeidx;
  tr->pos = pos;
}

// P7SmallViterbi
// file funcs.h line 60
extern float P7SmallViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s *mx, struct p7trace_s **ret_tr)
{
  struct p7trace_s *ctr;
  struct p7trace_s *tr;
  struct p7trace_s **tarr;
  signed int ndom;
  signed int i;
  signed int pos;
  signed int tpos;
  signed int tlen;
  signed int sqlen;
  signed int totlen;
  float sc;
  signed int t2;
  sc=P7ParsingViterbi(dsq, L, hmm, &ctr);
  if(ret_tr == ((struct p7trace_s **)NULL) || ctr == ((struct p7trace_s *)NULL))
  {
    P7FreeTrace(ctr);
    return sc;
  }

  else
  {
    ndom = ctr->tlen / 2 - 1;
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("core_algorithms.c", 986, sizeof(struct p7trace_s *) /*8ul*/  * (unsigned long int)ndom);
    tarr = (struct p7trace_s **)return_value_sre_malloc$1;
    totlen = 0;
    tlen = totlen;
    i = 0;
    for( ; !(i >= ndom); i = i + 1)
    {
      sqlen = ctr->pos[(signed long int)(i * 2 + 2)] - ctr->pos[(signed long int)(i * 2 + 1)];
      signed int return_value_P7ViterbiSpaceOK$2;
      return_value_P7ViterbiSpaceOK$2=P7ViterbiSpaceOK(sqlen, hmm->M, mx);
      if(!(return_value_P7ViterbiSpaceOK$2 == 0))
        P7Viterbi(dsq + (signed long int)ctr->pos[(signed long int)(i * 2 + 1)], sqlen, hmm, mx, &tarr[(signed long int)i]);

      else
        P7WeeViterbi(dsq + (signed long int)ctr->pos[(signed long int)(i * 2 + 1)], sqlen, hmm, &tarr[(signed long int)i]);
      tlen = tlen + (tarr[(signed long int)i]->tlen - 4);
      totlen = totlen + sqlen;
    }
    tlen = tlen + 4 + (ndom - 1) + (L - totlen);
    P7AllocTrace(tlen, &tr);
    tr->tlen = tlen;
    tr->statetype[(signed long int)0] = (char)4;
    tr->nodeidx[(signed long int)0] = 0;
    tr->pos[(signed long int)0] = 0;
    tr->statetype[(signed long int)1] = (char)5;
    tr->nodeidx[(signed long int)1] = 0;
    tr->pos[(signed long int)1] = 0;
    tpos = 2;
    pos = 1;
    for( ; ctr->pos[1l] >= pos; pos = pos + 1)
    {
      tr->statetype[(signed long int)tpos] = (char)5;
      tr->nodeidx[(signed long int)tpos] = 0;
      tr->pos[(signed long int)tpos] = pos;
      tpos = tpos + 1;
    }
    i = 0;
    for( ; !(i >= ndom); i = i + 1)
    {
      t2 = 2;
      for( ; !(t2 >= tarr[(signed long int)i]->tlen + -2); t2 = t2 + 1)
      {
        tr->statetype[(signed long int)tpos] = tarr[(signed long int)i]->statetype[(signed long int)t2];
        tr->nodeidx[(signed long int)tpos] = tarr[(signed long int)i]->nodeidx[(signed long int)t2];
        if(tarr[(signed long int)i]->pos[(signed long int)t2] >= 1)
          tr->pos[(signed long int)tpos] = tarr[(signed long int)i]->pos[(signed long int)t2] + ctr->pos[(signed long int)(i * 2 + 1)];

        else
          tr->pos[(signed long int)tpos] = 0;
        tpos = tpos + 1;
      }
      tr->statetype[(signed long int)tpos] = (char)(i == ndom - 1 ? 8 : 10);
      tr->nodeidx[(signed long int)tpos] = 0;
      tr->pos[(signed long int)tpos] = 0;
      tpos = tpos + 1;
      if(!(i == ndom + -1))
      {
        pos = ctr->pos[(signed long int)(i * 2 + 2)] + 1;
        for( ; ctr->pos[(signed long int)((1 + i) * 2 + 1)] >= pos; pos = pos + 1)
        {
          tr->statetype[(signed long int)tpos] = (char)10;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = pos;
          tpos = tpos + 1;
        }
      }

    }
    pos = ctr->pos[(signed long int)(ndom * 2)] + 1;
    for( ; L >= pos; pos = pos + 1)
    {
      tr->statetype[(signed long int)tpos] = (char)8;
      tr->nodeidx[(signed long int)tpos] = 0;
      tr->pos[(signed long int)tpos] = pos;
      tpos = tpos + 1;
    }
    tr->statetype[(signed long int)tpos] = (char)9;
    tr->nodeidx[(signed long int)tpos] = 0;
    tr->pos[(signed long int)tpos] = 0;
    tpos = tpos + 1;
    i = 0;
    for( ; !(i >= ndom); i = i + 1)
      P7FreeTrace(tarr[(signed long int)i]);
    free((void *)tarr);
    P7FreeTrace(ctr);
    *ret_tr = tr;
    return sc;
  }
}

// P7SmallViterbiSize
// file core_algorithms.c line 404
extern signed int P7SmallViterbiSize(signed int L, signed int M)
{
  return (signed int)(((unsigned long int)2 * sizeof(struct dpmatrix_s) /*80ul*/  + (unsigned long int)(12 * (M + 2)) * sizeof(signed int) /*4ul*/  + (unsigned long int)16 * sizeof(signed int *) /*8ul*/  + (unsigned long int)20 * sizeof(signed int) /*4ul*/  + (unsigned long int)(2 * (L + 1)) * sizeof(signed int) /*4ul*/ ) / (unsigned long int)1000000);
}

// P7TraceCount
// file funcs.h line 341
extern void P7TraceCount(struct plan7_s *hmm, unsigned char *dsq, float wt, struct p7trace_s *tr)
{
  signed int tpos;
  signed int i;
  tpos = 0;
  for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
  {
    i = tr->pos[(signed long int)tpos];
    if((signed int)tr->statetype[(signed long int)tpos] == 1)
      P7CountSymbol(hmm->mat[(signed long int)tr->nodeidx[(signed long int)tpos]], dsq[(signed long int)i], wt);

    else
      if((signed int)tr->statetype[(signed long int)tpos] == 3)
        P7CountSymbol(hmm->ins[(signed long int)tr->nodeidx[(signed long int)tpos]], dsq[(signed long int)i], wt);

    switch((signed int)tr->statetype[(signed long int)tpos])
    {
      case 4:
        break;
      case 5:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 6:
          {
            hmm->xt[(signed long int)0][(signed long int)0] = hmm->xt[(signed long int)0][(signed long int)0] + wt;
            break;
          }
          case 5:
          {
            hmm->xt[(signed long int)0][(signed long int)1] = hmm->xt[(signed long int)0][(signed long int)1] + wt;
            break;
          }
          default:
          {
            char *return_value_Statetype$1;
            return_value_Statetype$1=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$2;
            return_value_Statetype$2=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$1, return_value_Statetype$2);
          }
        }
        break;
      }
      case 6:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 1:
          {
            hmm->begin[(signed long int)tr->nodeidx[(signed long int)(tpos + 1)]] = hmm->begin[(signed long int)tr->nodeidx[(signed long int)(tpos + 1)]] + wt;
            break;
          }
          case 2:
          {
            hmm->tbd1 = hmm->tbd1 + wt;
            break;
          }
          default:
          {
            char *return_value_Statetype$3;
            return_value_Statetype$3=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$4;
            return_value_Statetype$4=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$3, return_value_Statetype$4);
          }
        }
        break;
      }
      case 1:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 1:
          {
            hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)0] = hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)0] + wt;
            break;
          }
          case 3:
          {
            hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)1] = hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)1] + wt;
            break;
          }
          case 2:
          {
            hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)2] = hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)2] + wt;
            break;
          }
          case 7:
          {
            hmm->end[(signed long int)tr->nodeidx[(signed long int)tpos]] = hmm->end[(signed long int)tr->nodeidx[(signed long int)tpos]] + wt;
            break;
          }
          default:
          {
            char *return_value_Statetype$5;
            return_value_Statetype$5=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$6;
            return_value_Statetype$6=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$5, return_value_Statetype$6);
          }
        }
        break;
      }
      case 3:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 1:
          {
            hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)3] = hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)3] + wt;
            break;
          }
          case 3:
          {
            hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)4] = hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)4] + wt;
            break;
          }
          default:
          {
            char *return_value_Statetype$7;
            return_value_Statetype$7=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$8;
            return_value_Statetype$8=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$7, return_value_Statetype$8);
          }
        }
        break;
      }
      case 2:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 1:
          {
            hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)5] = hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)5] + wt;
            break;
          }
          case 2:
          {
            hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)6] = hmm->t[(signed long int)tr->nodeidx[(signed long int)tpos]][(signed long int)6] + wt;
            break;
          }
          case 7:
            break;
          default:
          {
            char *return_value_Statetype$9;
            return_value_Statetype$9=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$10;
            return_value_Statetype$10=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$9, return_value_Statetype$10);
          }
        }
        break;
      }
      case 7:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 8:
          {
            hmm->xt[(signed long int)1][(signed long int)0] = hmm->xt[(signed long int)1][(signed long int)0] + wt;
            break;
          }
          case 10:
          {
            hmm->xt[(signed long int)1][(signed long int)1] = hmm->xt[(signed long int)1][(signed long int)1] + wt;
            break;
          }
          default:
          {
            char *return_value_Statetype$11;
            return_value_Statetype$11=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$12;
            return_value_Statetype$12=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$11, return_value_Statetype$12);
          }
        }
        break;
      }
      case 10:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 6:
          {
            hmm->xt[(signed long int)3][(signed long int)0] = hmm->xt[(signed long int)3][(signed long int)0] + wt;
            break;
          }
          case 10:
          {
            hmm->xt[(signed long int)3][(signed long int)1] = hmm->xt[(signed long int)3][(signed long int)1] + wt;
            break;
          }
          default:
          {
            char *return_value_Statetype$13;
            return_value_Statetype$13=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$14;
            return_value_Statetype$14=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$13, return_value_Statetype$14);
          }
        }
        break;
      }
      case 8:
      {
        switch((signed int)tr->statetype[(signed long int)(tpos + 1)])
        {
          case 9:
          {
            hmm->xt[(signed long int)2][(signed long int)0] = hmm->xt[(signed long int)2][(signed long int)0] + wt;
            break;
          }
          case 8:
          {
            hmm->xt[(signed long int)2][(signed long int)1] = hmm->xt[(signed long int)2][(signed long int)1] + wt;
            break;
          }
          default:
          {
            char *return_value_Statetype$15;
            return_value_Statetype$15=Statetype(tr->statetype[(signed long int)tpos]);
            char *return_value_Statetype$16;
            return_value_Statetype$16=Statetype(tr->statetype[(signed long int)(tpos + 1)]);
            Die("illegal state transition %s->%s in traceback", return_value_Statetype$15, return_value_Statetype$16);
          }
        }
        break;
      }
      case 9:
        break;
      default:
      {
        char *return_value_Statetype$17;
        return_value_Statetype$17=Statetype(tr->statetype[(signed long int)tpos]);
        Die("illegal state %s in traceback", return_value_Statetype$17);
      }
    }
  }
}

// P7TraceScore
// file funcs.h line 343
extern float P7TraceScore(struct plan7_s *hmm, unsigned char *dsq, struct p7trace_s *tr)
{
  signed int score;
  signed int tpos;
  unsigned char sym;
  score = 0;
  tpos = 0;
  for( ; !(tpos >= tr->tlen + -1); tpos = tpos + 1)
  {
    sym = dsq[(signed long int)tr->pos[(signed long int)tpos]];
    if((signed int)tr->statetype[(signed long int)tpos] == 1)
      score = score + hmm->msc[(signed long int)sym][(signed long int)tr->nodeidx[(signed long int)tpos]];

    else
      if((signed int)tr->statetype[(signed long int)tpos] == 3)
        score = score + hmm->isc[(signed long int)sym][(signed long int)tr->nodeidx[(signed long int)tpos]];

    signed int return_value_TransitionScoreLookup$1;
    return_value_TransitionScoreLookup$1=TransitionScoreLookup(hmm, tr->statetype[(signed long int)tpos], tr->nodeidx[(signed long int)tpos], tr->statetype[(signed long int)(tpos + 1)], tr->nodeidx[(signed long int)(tpos + 1)]);
    score = score + return_value_TransitionScoreLookup$1;
  }
  float return_value_Scorify$2;
  return_value_Scorify$2=Scorify(score);
  return return_value_Scorify$2;
}

// P7Traces2Alignment
// file trace.c line 379
extern struct msa_struct * P7Traces2Alignment(unsigned char **dsq, struct seqinfo_s *sqinfo, float *wgt, signed int nseq, signed int mlen, struct p7trace_s **tr, signed int matchonly)
{
  struct msa_struct *msa;
  signed int idx;
  signed int alen;
  signed int *inserts;
  signed int *matmap;
  signed int nins;
  signed int apos;
  signed int rpos;
  signed int tpos;
  signed int statetype;
  signed int k;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("trace.c", 408, sizeof(signed int) /*4ul*/  * (unsigned long int)(mlen + 1));
  inserts = (signed int *)return_value_sre_malloc$1;
  k = 0;
  for( ; mlen >= k; k = k + 1)
    inserts[(signed long int)k] = 0;
  idx = 0;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    nins = 0;
    tpos = 0;
    for( ; !(tpos >= tr[(signed long int)idx]->tlen); tpos = tpos + 1)
      switch((signed int)tr[(signed long int)idx]->statetype[(signed long int)tpos])
      {
        case 3:
        {
          nins = nins + 1;
          break;
        }
        case 5:
        {
          if((signed int)tr[(signed long int)idx]->statetype[(signed long int)(tpos + -1)] == 5)
            nins = nins + 1;

          break;
        }
        case 8:
        {
          if((signed int)tr[(signed long int)idx]->statetype[(signed long int)(tpos + -1)] == 8)
            nins = nins + 1;

          break;
        }
        case 1:

        case 2:
        {
          if(!(inserts[(signed long int)(tr[(signed long int)idx]->nodeidx[(signed long int)tpos] + -1)] >= nins))
            inserts[(signed long int)(tr[(signed long int)idx]->nodeidx[(signed long int)tpos] - 1)] = nins;

          nins = 0;
          break;
        }
        case 6:
        {
          if(!(*inserts >= nins))
            inserts[(signed long int)0] = nins;

          nins = 0;
          break;
        }
        case 9:
        {
          if(!(inserts[(signed long int)mlen] >= nins))
            inserts[(signed long int)mlen] = nins;

          break;
        }
        case 4:

        case 7:
          break;
        case 10:
          Die("yo! you don't support J in Traces2Alignment(), remember?");
        default:
        {
          char *return_value_Statetype$2;
          return_value_Statetype$2=Statetype(tr[(signed long int)idx]->statetype[(signed long int)tpos]);
          Die("Traces2Alignment reports unrecognized statetype %c", return_value_Statetype$2);
        }
      }
  }
  if(!(matchonly == 0))
  {
    k = 0;
    for( ; mlen >= k; k = k + 1)
      if(inserts[(signed long int)k] >= 2)
        inserts[(signed long int)k] = 1;

  }

  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("trace.c", 453, sizeof(signed int) /*4ul*/  * (unsigned long int)(mlen + 1));
  matmap = (signed int *)return_value_sre_malloc$3;
  matmap[(signed long int)0] = -1;
  alen = inserts[(signed long int)0];
  k = 1;
  for( ; mlen >= k; k = k + 1)
  {
    matmap[(signed long int)k] = alen;
    alen = alen + inserts[(signed long int)k] + 1;
  }
  msa=MSAAlloc(nseq, alen);
  idx = 0;
  const unsigned short int **return_value___ctype_b_loc$6;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    apos = 0;
    for( ; !(apos >= alen); apos = apos + 1)
      msa->aseq[(signed long int)idx][(signed long int)apos] = (char)46;
    k = 1;
    for( ; mlen >= k; k = k + 1)
      msa->aseq[(signed long int)idx][(signed long int)matmap[(signed long int)k]] = (char)45;
    msa->aseq[(signed long int)idx][(signed long int)alen] = (char)0;
    apos = 0;
    tpos = 0;
    for( ; !(tpos >= tr[(signed long int)idx]->tlen); tpos = tpos + 1)
    {
      statetype = (signed int)tr[(signed long int)idx]->statetype[(signed long int)tpos];
      rpos = tr[(signed long int)idx]->pos[(signed long int)tpos];
      k = tr[(signed long int)idx]->nodeidx[(signed long int)tpos];
      if(statetype == 1)
      {
        apos = matmap[(signed long int)k];
        msa->aseq[(signed long int)idx][(signed long int)apos] = Alphabet[(signed long int)dsq[(signed long int)idx][(signed long int)rpos]];
        apos = apos + 1;
      }

      else
        if(statetype == 2)
          apos = matmap[(signed long int)k] + 1;

        else
          if(statetype == 3)
          {
            if(!(matchonly == 0))
              msa->aseq[(signed long int)idx][(signed long int)apos] = (char)42;

            else
            {
              signed int return_value_tolower$4;
              return_value_tolower$4=tolower((signed int)Alphabet[(signed long int)dsq[(signed long int)idx][(signed long int)rpos]]);
              msa->aseq[(signed long int)idx][(signed long int)apos] = (char)return_value_tolower$4;
              apos = apos + 1;
            }
          }

          else
            if(rpos >= 1 && (statetype == 5 || statetype == 8))
            {
              if(!(matchonly == 0))
                msa->aseq[(signed long int)idx][(signed long int)apos] = (char)42;

              else
              {
                signed int return_value_tolower$5;
                return_value_tolower$5=tolower((signed int)Alphabet[(signed long int)dsq[(signed long int)idx][(signed long int)rpos]]);
                msa->aseq[(signed long int)idx][(signed long int)apos] = (char)return_value_tolower$5;
                apos = apos + 1;
              }
            }

            else
              if(statetype == 7)
                apos = matmap[(signed long int)mlen] + 1;

    }
    if(matchonly == 0)
    {
      rightjustify(msa->aseq[(signed long int)idx], inserts[(signed long int)0]);
      k = 1;
      for( ; !(k >= mlen); k = k + 1)
        if(inserts[(signed long int)k] >= 2)
        {
          nins = 0;
          apos = matmap[(signed long int)k] + 1;
          do
          {
            return_value___ctype_b_loc$6=__ctype_b_loc();
            if((512 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)msa->aseq[(signed long int)idx][(signed long int)apos]]) == 0)
              break;

            nins = nins + 1;
            apos = apos + 1;
          }
          while((_Bool)1);
          nins = nins / 2;
          rightjustify(msa->aseq[(signed long int)idx] + (signed long int)matmap[(signed long int)k] + (signed long int)1 + (signed long int)nins, inserts[(signed long int)k] - nins);
        }

    }

  }
  msa->nseq = nseq;
  msa->alen = alen;
  unsigned long int return_value_strlen$7;
  return_value_strlen$7=strlen("2.3.2");
  void *return_value_sre_malloc$8;
  return_value_sre_malloc$8=sre_malloc("trace.c", 529, sizeof(char) /*1ul*/  * (return_value_strlen$7 + (unsigned long int)7));
  msa->au = (char *)return_value_sre_malloc$8;
  sprintf(msa->au, "HMMER %s", (const void *)"2.3.2");
  idx = 0;
  void *return_value_sre_malloc$9;
  void *return_value_sre_malloc$10;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    msa->sqname[(signed long int)idx]=sre_strdup((sqinfo + (signed long int)idx)->name, -1);
    if(!((4 & (sqinfo + (signed long int)idx)->flags) == 0))
      MSASetSeqAccession(msa, idx, (sqinfo + (signed long int)idx)->acc);

    if(!((8 & (sqinfo + (signed long int)idx)->flags) == 0))
      MSASetSeqDescription(msa, idx, (sqinfo + (signed long int)idx)->desc);

    if(!((512 & (sqinfo + (signed long int)idx)->flags) == 0))
    {
      if(msa->ss == ((char **)NULL))
      {
        return_value_sre_malloc$9=sre_malloc("trace.c", 541, sizeof(char *) /*8ul*/  * (unsigned long int)nseq);
        msa->ss = (char **)return_value_sre_malloc$9;
      }

      MakeAlignedString(msa->aseq[(signed long int)idx], alen, (sqinfo + (signed long int)idx)->ss, &msa->ss[(signed long int)idx]);
    }

    if(!((1024 & (sqinfo + (signed long int)idx)->flags) == 0))
    {
      if(msa->sa == ((char **)NULL))
      {
        return_value_sre_malloc$10=sre_malloc("trace.c", 546, sizeof(char *) /*8ul*/  * (unsigned long int)nseq);
        msa->sa = (char **)return_value_sre_malloc$10;
      }

      MakeAlignedString(msa->aseq[(signed long int)idx], alen, (sqinfo + (signed long int)idx)->sa, &msa->sa[(signed long int)idx]);
    }

    msa->wgt[(signed long int)idx] = wgt[(signed long int)idx];
  }
  void *return_value_sre_malloc$11;
  return_value_sre_malloc$11=sre_malloc("trace.c", 555, sizeof(char) /*1ul*/  * (unsigned long int)(alen + 1));
  msa->rf = (char *)return_value_sre_malloc$11;
  apos = 0;
  for( ; !(apos >= alen); apos = apos + 1)
    msa->rf[(signed long int)apos] = (char)46;
  k = 1;
  for( ; mlen >= k; k = k + 1)
    msa->rf[(signed long int)matmap[(signed long int)k]] = (char)120;
  msa->rf[(signed long int)alen] = (char)0;
  free((void *)inserts);
  free((void *)matmap);
  return msa;
}

// P7Viterbi
// file funcs.h line 56
extern float P7Viterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s *mx, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int i;
  signed int k;
  signed int sc;
  signed int *mc;
  signed int *dc;
  signed int *ic;
  signed int *ms;
  signed int *is;
  signed int *mpp;
  signed int *mpc;
  signed int *ip;
  signed int *bp;
  signed int *ep;
  signed int xmb;
  signed int xme;
  signed int *dpp;
  signed int *tpmm;
  signed int *tpmi;
  signed int *tpmd;
  signed int *tpim;
  signed int *tpii;
  signed int *tpdm;
  signed int *tpdd;
  signed int M;
  ResizePlan7Matrix(mx, L, hmm->M, &xmx, &mmx, &imx, &dmx);
  xmx[(signed long int)0][(signed long int)4] = 0;
  xmx[(signed long int)0][(signed long int)0] = hmm->xsc[(signed long int)0][(signed long int)0];
  xmx[(signed long int)0][(signed long int)3] = -987654321;
  xmx[(signed long int)0][(signed long int)2] = xmx[(signed long int)0][(signed long int)3];
  xmx[(signed long int)0][(signed long int)1] = xmx[(signed long int)0][(signed long int)2];
  k = 0;
  for( ; hmm->M >= k; k = k + 1)
  {
    dmx[(signed long int)0][(signed long int)k] = -987654321;
    imx[(signed long int)0][(signed long int)k] = dmx[(signed long int)0][(signed long int)k];
    mmx[(signed long int)0][(signed long int)k] = imx[(signed long int)0][(signed long int)k];
  }
  M = hmm->M;
  tpmm = hmm->tsc[(signed long int)0];
  tpim = hmm->tsc[(signed long int)3];
  tpdm = hmm->tsc[(signed long int)5];
  tpmd = hmm->tsc[(signed long int)2];
  tpdd = hmm->tsc[(signed long int)6];
  tpmi = hmm->tsc[(signed long int)1];
  tpii = hmm->tsc[(signed long int)4];
  bp = hmm->bsc;
  i = 1;
  for( ; L >= i; i = i + 1)
  {
    mc = mmx[(signed long int)i];
    dc = dmx[(signed long int)i];
    ic = imx[(signed long int)i];
    mpp = mmx[(signed long int)(i - 1)];
    dpp = dmx[(signed long int)(i - 1)];
    ip = imx[(signed long int)(i - 1)];
    xmb = xmx[(signed long int)(i - 1)][(signed long int)0];
    ms = hmm->msc[(signed long int)dsq[(signed long int)i]];
    is = hmm->isc[(signed long int)dsq[(signed long int)i]];
    mc[(signed long int)0] = -987654321;
    dc[(signed long int)0] = -987654321;
    ic[(signed long int)0] = -987654321;
    k = 1;
    for( ; M >= k; k = k + 1)
    {
      mc[(signed long int)k] = mpp[(signed long int)(k - 1)] + tpmm[(signed long int)(k - 1)];
      sc = ip[(signed long int)(k - 1)] + tpim[(signed long int)(k - 1)];
      if(!(mc[(signed long int)k] >= sc))
        mc[(signed long int)k] = sc;

      sc = dpp[(signed long int)(k - 1)] + tpdm[(signed long int)(k - 1)];
      if(!(mc[(signed long int)k] >= sc))
        mc[(signed long int)k] = sc;

      sc = xmb + bp[(signed long int)k];
      if(!(mc[(signed long int)k] >= sc))
        mc[(signed long int)k] = sc;

      mc[(signed long int)k] = mc[(signed long int)k] + ms[(signed long int)k];
      if(!(mc[(signed long int)k] >= -987654321))
        mc[(signed long int)k] = -987654321;

      dc[(signed long int)k] = dc[(signed long int)(k - 1)] + tpdd[(signed long int)(k - 1)];
      sc = mc[(signed long int)(k - 1)] + tpmd[(signed long int)(k - 1)];
      if(!(dc[(signed long int)k] >= sc))
        dc[(signed long int)k] = sc;

      if(!(dc[(signed long int)k] >= -987654321))
        dc[(signed long int)k] = -987654321;

      if(!(k >= M))
      {
        ic[(signed long int)k] = mpp[(signed long int)k] + tpmi[(signed long int)k];
        sc = ip[(signed long int)k] + tpii[(signed long int)k];
        if(!(ic[(signed long int)k] >= sc))
          ic[(signed long int)k] = sc;

        ic[(signed long int)k] = ic[(signed long int)k] + is[(signed long int)k];
        if(!(ic[(signed long int)k] >= -987654321))
          ic[(signed long int)k] = -987654321;

      }

    }
    xmx[(signed long int)i][(signed long int)4] = -987654321;
    sc = xmx[(signed long int)(i - 1)][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1];
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)4] = sc;

    xme = -987654321;
    mpc = mmx[(signed long int)i];
    ep = hmm->esc;
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      sc = mpc[(signed long int)k] + ep[(signed long int)k];
      if(!(xme >= sc))
        xme = sc;

    }
    xmx[(signed long int)i][(signed long int)1] = xme;
    xmx[(signed long int)i][(signed long int)3] = -987654321;
    sc = xmx[(signed long int)(i - 1)][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)1];
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)3] = sc;

    sc = xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)1];
    if(!(xmx[(signed long int)i][3l] >= sc))
      xmx[(signed long int)i][(signed long int)3] = sc;

    xmx[(signed long int)i][(signed long int)0] = -987654321;
    sc = xmx[(signed long int)i][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0];
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)0] = sc;

    sc = xmx[(signed long int)i][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)0];
    if(!(*xmx[(signed long int)i] >= sc))
      xmx[(signed long int)i][(signed long int)0] = sc;

    xmx[(signed long int)i][(signed long int)2] = -987654321;
    sc = xmx[(signed long int)(i - 1)][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1];
    if(sc >= -987654320)
      xmx[(signed long int)i][(signed long int)2] = sc;

    sc = xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0];
    if(!(xmx[(signed long int)i][2l] >= sc))
      xmx[(signed long int)i][(signed long int)2] = sc;

  }
  sc = xmx[(signed long int)L][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)0];
  if(!(ret_tr == ((struct p7trace_s **)NULL)))
  {
    P7ViterbiTrace(hmm, dsq, L, mx, &tr);
    *ret_tr = tr;
  }

  float return_value_Scorify$1;
  return_value_Scorify$1=Scorify(sc);
  return return_value_Scorify$1;
}

// P7ViterbiAlignAlignment
// file core_algorithms.c line 2086
extern struct p7trace_s * P7ViterbiAlignAlignment(struct msa_struct *msa, struct plan7_s *hmm)
{
  struct dpmatrix_s *mx;
  struct dpshadow_s *tb;
  struct p7trace_s *tr;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  char **xtb;
  char **mtb;
  char **itb;
  char **dtb;
  float **con;
  float *mocc;
  signed int i;
  signed int k;
  signed int idx;
  signed int sym;
  signed int sc;
  float denom;
  signed int cur;
  signed int prv;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("core_algorithms.c", 2108, sizeof(float *) /*8ul*/  * (unsigned long int)(msa->alen + 1));
  con = (float **)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("core_algorithms.c", 2109, sizeof(float) /*4ul*/  * (unsigned long int)(msa->alen + 1));
  mocc = (float *)return_value_sre_malloc$2;
  i = 1;
  for( ; msa->alen >= i; i = i + 1)
  {
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("core_algorithms.c", 2111, sizeof(float) /*4ul*/  * (unsigned long int)Alphabet_size);
    con[(signed long int)i] = (float *)return_value_sre_malloc$3;
    FSet(con[(signed long int)i], Alphabet_size, (float)0.0);
  }
  mocc[(signed long int)0] = (float)-9999.;
  denom=FSum(msa->wgt, msa->nseq);
  i = 1;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  char *return_value_strchr$4;
  for( ; msa->alen >= i; i = i + 1)
  {
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      if((signed int)msa->aseq[(signed long int)idx][(signed long int)(i + -1)] == 32)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$8)
      {
        return_value_strchr$4=strchr(Alphabet, (signed int)msa->aseq[(signed long int)idx][(signed long int)(i - 1)]);
        P7CountSymbol(con[(signed long int)i], (unsigned char)(return_value_strchr$4 - Alphabet), msa->wgt[(signed long int)idx]);
      }

    }
    FScale(con[(signed long int)i], Alphabet_size, (float)(1. / (double)denom));
    mocc[(signed long int)i]=FSum(con[(signed long int)i], Alphabet_size);
  }
  mx=AllocPlan7Matrix(2, hmm->M, &xmx, &mmx, &imx, &dmx);
  tb=AllocShadowMatrix(msa->alen + 1, hmm->M, &xtb, &mtb, &itb, &dtb);
  xmx[(signed long int)0][(signed long int)4] = 0;
  xtb[(signed long int)0][(signed long int)4] = (char)4;
  xmx[(signed long int)0][(signed long int)0] = hmm->xsc[(signed long int)0][(signed long int)0];
  xtb[(signed long int)0][(signed long int)0] = (char)5;
  xmx[(signed long int)0][(signed long int)3] = -987654321;
  xmx[(signed long int)0][(signed long int)2] = xmx[(signed long int)0][(signed long int)3];
  xmx[(signed long int)0][(signed long int)1] = xmx[(signed long int)0][(signed long int)2];
  tb->esrc[(signed long int)0] = 0;
  xtb[(signed long int)0][(signed long int)3] = (char)0;
  xtb[(signed long int)0][(signed long int)2] = xtb[(signed long int)0][(signed long int)3];
  k = 0;
  for( ; hmm->M >= k; k = k + 1)
  {
    dmx[(signed long int)0][(signed long int)k] = -987654321;
    imx[(signed long int)0][(signed long int)k] = dmx[(signed long int)0][(signed long int)k];
    mmx[(signed long int)0][(signed long int)k] = imx[(signed long int)0][(signed long int)k];
    dtb[(signed long int)0][(signed long int)k] = (char)0;
    itb[(signed long int)0][(signed long int)k] = dtb[(signed long int)0][(signed long int)k];
    mtb[(signed long int)0][(signed long int)k] = itb[(signed long int)0][(signed long int)k];
  }
  i = 1;
  for( ; msa->alen >= i; i = i + 1)
  {
    cur = i % 2;
    prv = (signed int)!(cur != 0);
    dmx[(signed long int)cur][(signed long int)0] = -987654321;
    imx[(signed long int)cur][(signed long int)0] = dmx[(signed long int)cur][(signed long int)0];
    mmx[(signed long int)cur][(signed long int)0] = imx[(signed long int)cur][(signed long int)0];
    dtb[(signed long int)i][(signed long int)0] = (char)0;
    itb[(signed long int)i][(signed long int)0] = dtb[(signed long int)i][(signed long int)0];
    mtb[(signed long int)i][(signed long int)0] = itb[(signed long int)i][(signed long int)0];
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      mmx[(signed long int)cur][(signed long int)k] = -987654321;
      mtb[(signed long int)i][(signed long int)k] = (char)0;
      if(mmx[(signed long int)prv][(signed long int)(k + -1)] >= -987654320)
      {
        if((*hmm->tsc)[(signed long int)(k + -1)] >= -987654320)
        {
          sc = mmx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)];
          if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
          {
            mmx[(signed long int)cur][(signed long int)k] = sc;
            mtb[(signed long int)i][(signed long int)k] = (char)1;
          }

        }

      }

      if(imx[(signed long int)prv][(signed long int)(k + -1)] >= -987654320)
      {
        if(hmm->tsc[3l][(signed long int)(k + -1)] >= -987654320)
        {
          sc = (signed int)((float)imx[(signed long int)prv][(signed long int)(k - 1)] + (float)hmm->tsc[(signed long int)3][(signed long int)(k - 1)] * mocc[(signed long int)(i - 1)]);
          if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
          {
            mmx[(signed long int)cur][(signed long int)k] = sc;
            mtb[(signed long int)i][(signed long int)k] = (char)3;
          }

        }

      }

      sc = xmx[(signed long int)prv][(signed long int)0] + hmm->bsc[(signed long int)k];
      if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
      {
        mmx[(signed long int)cur][(signed long int)k] = sc;
        mtb[(signed long int)i][(signed long int)k] = (char)6;
      }

      if(dmx[(signed long int)prv][(signed long int)(k + -1)] >= -987654320)
      {
        if(hmm->tsc[5l][(signed long int)(k + -1)] >= -987654320)
        {
          sc = dmx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)];
          if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
          {
            mmx[(signed long int)cur][(signed long int)k] = sc;
            mtb[(signed long int)i][(signed long int)k] = (char)2;
          }

        }

      }

      sym = 0;
      for( ; !(sym >= Alphabet_size); sym = sym + 1)
      {
        if(con[(signed long int)i][(signed long int)sym] > 0.000000f)
        {
          if(hmm->msc[(signed long int)sym][(signed long int)k] == -987654321)
          {
            mmx[(signed long int)cur][(signed long int)k] = -987654321;
            break;
          }

        }

        mmx[(signed long int)cur][(signed long int)k] = mmx[(signed long int)cur][(signed long int)k] + (signed int)((float)hmm->msc[(signed long int)sym][(signed long int)k] * con[(signed long int)i][(signed long int)sym]);
      }
      dmx[(signed long int)cur][(signed long int)k] = -987654321;
      dtb[(signed long int)i][(signed long int)k] = (char)0;
      if(mmx[(signed long int)cur][(signed long int)(k + -1)] >= -987654320)
      {
        if(hmm->tsc[2l][(signed long int)(k + -1)] >= -987654320)
        {
          sc = mmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)2][(signed long int)(k - 1)];
          if(!(dmx[(signed long int)cur][(signed long int)k] >= sc))
          {
            dmx[(signed long int)cur][(signed long int)k] = sc;
            dtb[(signed long int)i][(signed long int)k] = (char)1;
          }

        }

      }

      if(dmx[(signed long int)cur][(signed long int)(k + -1)] >= -987654320)
      {
        if(hmm->tsc[6l][(signed long int)(k + -1)] >= -987654320)
        {
          sc = dmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)6][(signed long int)(k - 1)];
          if(!(dmx[(signed long int)cur][(signed long int)k] >= sc))
          {
            dmx[(signed long int)cur][(signed long int)k] = sc;
            dtb[(signed long int)i][(signed long int)k] = (char)2;
          }

        }

      }

      if(!(k >= hmm->M))
      {
        imx[(signed long int)cur][(signed long int)k] = -987654321;
        itb[(signed long int)i][(signed long int)k] = (char)0;
        if(mmx[(signed long int)prv][(signed long int)k] >= -987654320)
        {
          if(hmm->tsc[1l][(signed long int)k] >= -987654320)
          {
            sc = (signed int)((float)mmx[(signed long int)prv][(signed long int)k] + (float)hmm->tsc[(signed long int)1][(signed long int)k] * mocc[(signed long int)i]);
            if(!(imx[(signed long int)cur][(signed long int)k] >= sc))
            {
              imx[(signed long int)cur][(signed long int)k] = sc;
              itb[(signed long int)i][(signed long int)k] = (char)1;
            }

          }

        }

        if(imx[(signed long int)prv][(signed long int)k] >= -987654320)
        {
          if(hmm->tsc[4l][(signed long int)k] >= -987654320)
          {
            sc = (signed int)((float)imx[(signed long int)prv][(signed long int)k] + (float)hmm->tsc[(signed long int)4][(signed long int)k] * mocc[(signed long int)(i - 1)] * mocc[(signed long int)i]);
            if(!(imx[(signed long int)cur][(signed long int)k] >= sc))
            {
              imx[(signed long int)cur][(signed long int)k] = sc;
              itb[(signed long int)i][(signed long int)k] = (char)3;
            }

          }

        }

        sym = 0;
        for( ; !(sym >= Alphabet_size); sym = sym + 1)
        {
          if(con[(signed long int)i][(signed long int)sym] > 0.000000f)
          {
            if(hmm->isc[(signed long int)sym][(signed long int)k] == -987654321)
            {
              imx[(signed long int)cur][(signed long int)k] = -987654321;
              break;
            }

          }

          imx[(signed long int)cur][(signed long int)k] = imx[(signed long int)cur][(signed long int)k] + (signed int)((float)hmm->isc[(signed long int)sym][(signed long int)k] * con[(signed long int)i][(signed long int)sym]);
        }
      }

    }
    xmx[(signed long int)cur][(signed long int)4] = -987654321;
    xtb[(signed long int)i][(signed long int)4] = (char)0;
    if(xmx[(signed long int)prv][4l] >= -987654320)
    {
      if(hmm->xsc[0l][1l] >= -987654320)
      {
        sc = (signed int)((float)xmx[(signed long int)prv][(signed long int)4] + (float)hmm->xsc[(signed long int)0][(signed long int)1] * mocc[(signed long int)i]);
        if(sc >= -987654320)
        {
          xmx[(signed long int)cur][(signed long int)4] = sc;
          xtb[(signed long int)i][(signed long int)4] = (char)5;
        }

      }

    }

    xmx[(signed long int)cur][(signed long int)1] = -987654321;
    xtb[(signed long int)i][(signed long int)1] = (char)0;
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
      if(mmx[(signed long int)cur][(signed long int)k] >= -987654320)
      {
        if(hmm->esc[(signed long int)k] >= -987654320)
        {
          sc = mmx[(signed long int)cur][(signed long int)k] + hmm->esc[(signed long int)k];
          if(!(xmx[(signed long int)cur][1l] >= sc))
          {
            xmx[(signed long int)cur][(signed long int)1] = sc;
            tb->esrc[(signed long int)i] = k;
          }

        }

      }

    xmx[(signed long int)cur][(signed long int)0] = -987654321;
    xtb[(signed long int)i][(signed long int)0] = (char)0;
    if(xmx[(signed long int)cur][4l] >= -987654320)
    {
      if(hmm->xsc[0l][0l] >= -987654320)
      {
        sc = xmx[(signed long int)cur][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0];
        if(!(*xmx[(signed long int)cur] >= sc))
        {
          xmx[(signed long int)cur][(signed long int)0] = sc;
          xtb[(signed long int)i][(signed long int)0] = (char)5;
        }

      }

    }

    xmx[(signed long int)cur][(signed long int)2] = -987654321;
    xtb[(signed long int)i][(signed long int)2] = (char)0;
    if(xmx[(signed long int)prv][2l] >= -987654320)
    {
      if(hmm->xsc[2l][1l] >= -987654320)
      {
        sc = (signed int)((float)xmx[(signed long int)prv][(signed long int)2] + (float)hmm->xsc[(signed long int)2][(signed long int)1] * mocc[(signed long int)i]);
        if(sc >= -987654320)
        {
          xmx[(signed long int)cur][(signed long int)2] = sc;
          xtb[(signed long int)i][(signed long int)2] = (char)8;
        }

      }

    }

    if(xmx[(signed long int)cur][1l] >= -987654320)
    {
      if(hmm->xsc[1l][0l] >= -987654320)
      {
        sc = xmx[(signed long int)cur][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0];
        if(!(xmx[(signed long int)cur][2l] >= sc))
        {
          xmx[(signed long int)cur][(signed long int)2] = sc;
          xtb[(signed long int)i][(signed long int)2] = (char)7;
        }

      }

    }

  }
  sc = xmx[(signed long int)(msa->alen % 2)][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)0];
  tr=ShadowTrace(tb, hmm, msa->alen);
  FreePlan7Matrix(mx);
  FreeShadowMatrix(tb);
  i = 1;
  for( ; msa->alen >= i; i = i + 1)
    free((void *)con[(signed long int)i]);
  free((void *)con);
  free((void *)mocc);
  return tr;
}

// P7ViterbiSize
// file core_algorithms.c line 364
extern signed int P7ViterbiSize(signed int L, signed int M)
{
  float Mbytes = (float)sizeof(struct dpmatrix_s) /*80ul*/ ;
  Mbytes = Mbytes + (float)(3. * (double)(float)(L + 1) * (double)(float)(M + 2) * (double)(float)sizeof(signed int) /*4ul*/ );
  Mbytes = Mbytes + (float)(4. * (double)(float)(L + 1) * (double)(float)sizeof(signed int *) /*8ul*/ );
  Mbytes = Mbytes + (float)(5. * (double)(float)(L + 1) * (double)(float)sizeof(signed int) /*4ul*/ );
  Mbytes = Mbytes / (float)1048576.;
  return (signed int)Mbytes;
}

// P7ViterbiSpaceOK
// file funcs.h line 50
extern signed int P7ViterbiSpaceOK(signed int L, signed int M, struct dpmatrix_s *mx)
{
  signed int newM;
  signed int newN;
  if(!(mx->maxM >= M))
    newM = M + mx->padM;

  else
    newM = mx->maxM;
  if(!(mx->maxN >= L))
    newN = L + mx->padN;

  else
    newN = mx->maxN;
  signed int return_value_P7ViterbiSize$1;
  return_value_P7ViterbiSize$1=P7ViterbiSize(newN, newM);
  if(!(return_value_P7ViterbiSize$1 >= 33))
    return 1;

  else
    return 0;
}

// P7ViterbiTrace
// file core_algorithms.c line 684
extern void P7ViterbiTrace(struct plan7_s *hmm, unsigned char *dsq, signed int N, struct dpmatrix_s *mx, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  signed int curralloc;
  signed int tpos;
  signed int i;
  signed int k;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int sc;
  curralloc = N * 2 + 6;
  P7AllocTrace(curralloc, &tr);
  xmx = mx->xmx;
  mmx = mx->mmx;
  imx = mx->imx;
  dmx = mx->dmx;
  tr->statetype[(signed long int)0] = (char)9;
  tr->nodeidx[(signed long int)0] = 0;
  tr->pos[(signed long int)0] = 0;
  tr->statetype[(signed long int)1] = (char)8;
  tr->nodeidx[(signed long int)1] = 0;
  tr->pos[(signed long int)1] = 0;
  tpos = 2;
  i = N;
  signed int tmp_post$1;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$14;
  signed int tmp_post$13;
  signed int tmp_post$17;
  signed int tmp_post$18;
  signed int tmp_post$19;
  signed int tmp_post$20;
  while(!((signed int)tr->statetype[(signed long int)(tpos + -1)] == 4))
  {
    switch((signed int)tr->statetype[(signed long int)(tpos - 1)])
    {
      case 1:
      {
        sc = mmx[(signed long int)(i + 1)][(signed long int)(k + 1)] - hmm->msc[(signed long int)dsq[(signed long int)(i + 1)]][(signed long int)(k + 1)];
        if(!(sc >= -987654320))
        {
          P7FreeTrace(tr);
          *ret_tr = (struct p7trace_s *)(void *)0;
          goto __CPROVER_DUMP_L59;
        }

        else
          if(sc == hmm->bsc[(signed long int)(1 + k)] + *xmx[(signed long int)i])
          {
            signed int return_value_Prob2Score$2;
            return_value_Prob2Score$2=Prob2Score(hmm->begin[(signed long int)(k + 1)], hmm->p1);
            if((double)return_value_Prob2Score$2 + 1000.000000 <= (double)hmm->bsc[(signed long int)(1 + k)])
              while(k >= 1)
              {
                tr->statetype[(signed long int)tpos] = (char)2;
                tmp_post$1 = k;
                k = k - 1;
                tr->nodeidx[(signed long int)tpos] = tmp_post$1;
                tr->pos[(signed long int)tpos] = 0;
                tpos = tpos + 1;
                if(tpos == curralloc)
                {
                  curralloc = curralloc + N;
                  P7ReallocTrace(tr, curralloc);
                }

              }

            tr->statetype[(signed long int)tpos] = (char)6;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
          }

          else
            if(sc == mmx[(signed long int)i][(signed long int)k] + (*hmm->tsc)[(signed long int)k])
            {
              tr->statetype[(signed long int)tpos] = (char)1;
              tmp_post$3 = k;
              k = k - 1;
              tr->nodeidx[(signed long int)tpos] = tmp_post$3;
              tmp_post$4 = i;
              i = i - 1;
              tr->pos[(signed long int)tpos] = tmp_post$4;
            }

            else
              if(sc == hmm->tsc[3l][(signed long int)k] + imx[(signed long int)i][(signed long int)k])
              {
                tr->statetype[(signed long int)tpos] = (char)3;
                tr->nodeidx[(signed long int)tpos] = k;
                tmp_post$5 = i;
                i = i - 1;
                tr->pos[(signed long int)tpos] = tmp_post$5;
              }

              else
                if(sc == hmm->tsc[5l][(signed long int)k] + dmx[(signed long int)i][(signed long int)k])
                {
                  tr->statetype[(signed long int)tpos] = (char)2;
                  tmp_post$6 = k;
                  k = k - 1;
                  tr->nodeidx[(signed long int)tpos] = tmp_post$6;
                  tr->pos[(signed long int)tpos] = 0;
                }

                else
                  Die("traceback failed");
        break;
      }
      case 2:
      {
        if(!(dmx[(signed long int)i][(signed long int)(1 + k)] >= -987654320))
        {
          P7FreeTrace(tr);
          *ret_tr = (struct p7trace_s *)(void *)0;
          goto __CPROVER_DUMP_L59;
        }

        else
          if(dmx[(signed long int)i][(signed long int)(1 + k)] == hmm->tsc[2l][(signed long int)k] + mmx[(signed long int)i][(signed long int)k])
          {
            tr->statetype[(signed long int)tpos] = (char)1;
            tmp_post$7 = k;
            k = k - 1;
            tr->nodeidx[(signed long int)tpos] = tmp_post$7;
            tmp_post$8 = i;
            i = i - 1;
            tr->pos[(signed long int)tpos] = tmp_post$8;
          }

          else
            if(dmx[(signed long int)i][(signed long int)(1 + k)] == hmm->tsc[6l][(signed long int)k] + dmx[(signed long int)i][(signed long int)k])
            {
              tr->statetype[(signed long int)tpos] = (char)2;
              tmp_post$9 = k;
              k = k - 1;
              tr->nodeidx[(signed long int)tpos] = tmp_post$9;
              tr->pos[(signed long int)tpos] = 0;
            }

            else
              Die("traceback failed");
        break;
      }
      case 3:
      {
        sc = imx[(signed long int)(i + 1)][(signed long int)k] - hmm->isc[(signed long int)dsq[(signed long int)(i + 1)]][(signed long int)k];
        if(!(sc >= -987654320))
        {
          P7FreeTrace(tr);
          *ret_tr = (struct p7trace_s *)(void *)0;
          goto __CPROVER_DUMP_L59;
        }

        else
          if(sc == hmm->tsc[1l][(signed long int)k] + mmx[(signed long int)i][(signed long int)k])
          {
            tr->statetype[(signed long int)tpos] = (char)1;
            tmp_post$10 = k;
            k = k - 1;
            tr->nodeidx[(signed long int)tpos] = tmp_post$10;
            tmp_post$11 = i;
            i = i - 1;
            tr->pos[(signed long int)tpos] = tmp_post$11;
          }

          else
            if(sc == hmm->tsc[4l][(signed long int)k] + imx[(signed long int)i][(signed long int)k])
            {
              tr->statetype[(signed long int)tpos] = (char)3;
              tr->nodeidx[(signed long int)tpos] = k;
              tmp_post$12 = i;
              i = i - 1;
              tr->pos[(signed long int)tpos] = tmp_post$12;
            }

            else
              Die("traceback failed");
        break;
      }
      case 5:
      {
        if(i == 0)
          tmp_if_expr$15 = xmx[(signed long int)i][(signed long int)4] == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$15 = (_Bool)0;
        if(tmp_if_expr$15)
        {
          tr->statetype[(signed long int)tpos] = (char)4;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
        }

        else
        {
          if(i >= 1)
            tmp_if_expr$14 = xmx[(signed long int)(i + 1)][(signed long int)4] == xmx[(signed long int)i][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$14 = (_Bool)0;
          if(tmp_if_expr$14)
          {
            tr->statetype[(signed long int)tpos] = (char)5;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
            tmp_post$13 = i;
            i = i - 1;
            tr->pos[(signed long int)(tpos - 1)] = tmp_post$13;
          }

          else
            Die("traceback failed");
        }
        break;
      }
      case 6:
      {
        if(!(*xmx[(signed long int)i] >= -987654320))
        {
          P7FreeTrace(tr);
          *ret_tr = (struct p7trace_s *)(void *)0;
          goto __CPROVER_DUMP_L59;
        }

        else
          if(*xmx[(signed long int)i] == xmx[(signed long int)i][4l] + hmm->xsc[0l][0l])
          {
            tr->statetype[(signed long int)tpos] = (char)5;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
          }

          else
            if(*xmx[(signed long int)i] == xmx[(signed long int)i][3l] + hmm->xsc[3l][0l])
            {
              tr->statetype[(signed long int)tpos] = (char)10;
              tr->nodeidx[(signed long int)tpos] = 0;
              tr->pos[(signed long int)tpos] = 0;
            }

            else
              Die("traceback failed");
        break;
      }
      case 7:
      {
        if(!(xmx[(signed long int)i][1l] >= -987654320))
        {
          P7FreeTrace(tr);
          *ret_tr = (struct p7trace_s *)(void *)0;
          goto __CPROVER_DUMP_L59;
        }

        k = hmm->M;
        for( ; k >= 1; k = k - 1)
          if(xmx[(signed long int)i][1l] == mmx[(signed long int)i][(signed long int)k] + hmm->esc[(signed long int)k])
          {
            signed int return_value_Prob2Score$16;
            return_value_Prob2Score$16=Prob2Score(hmm->end[(signed long int)k], (float)1.);
            if((double)return_value_Prob2Score$16 + 1000.000000 <= (double)hmm->esc[(signed long int)k])
            {
              signed int dk = hmm->M;
              for( ; !(k >= dk); dk = dk - 1)
              {
                tr->statetype[(signed long int)tpos] = (char)2;
                tr->nodeidx[(signed long int)tpos] = dk;
                tr->pos[(signed long int)tpos] = 0;
                tpos = tpos + 1;
                if(tpos == curralloc)
                {
                  curralloc = curralloc + N;
                  P7ReallocTrace(tr, curralloc);
                }

              }
            }

            tr->statetype[(signed long int)tpos] = (char)1;
            tmp_post$17 = k;
            k = k - 1;
            tr->nodeidx[(signed long int)tpos] = tmp_post$17;
            tmp_post$18 = i;
            i = i - 1;
            tr->pos[(signed long int)tpos] = tmp_post$18;
            break;
          }

        if(!(k >= 0))
          Die("traceback failed");

        break;
      }
      case 8:
      {
        if(!(xmx[(signed long int)i][2l] >= -987654320))
        {
          P7FreeTrace(tr);
          *ret_tr = (struct p7trace_s *)(void *)0;
          goto __CPROVER_DUMP_L59;
        }

        else
          if(xmx[(signed long int)i][2l] == xmx[(signed long int)(i + -1)][2l] + hmm->xsc[2l][1l])
          {
            tr->statetype[(signed long int)tpos] = (char)8;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
            tmp_post$19 = i;
            i = i - 1;
            tr->pos[(signed long int)(tpos - 1)] = tmp_post$19;
          }

          else
            if(xmx[(signed long int)i][2l] == xmx[(signed long int)i][1l] + hmm->xsc[1l][0l])
            {
              tr->statetype[(signed long int)tpos] = (char)7;
              tr->nodeidx[(signed long int)tpos] = 0;
              tr->pos[(signed long int)tpos] = 0;
            }

            else
              Die("Traceback failed.");
        break;
      }
      case 10:
      {
        if(!(xmx[(signed long int)i][3l] >= -987654320))
        {
          P7FreeTrace(tr);
          *ret_tr = (struct p7trace_s *)(void *)0;
          goto __CPROVER_DUMP_L59;
        }

        else
          if(xmx[(signed long int)i][3l] == xmx[(signed long int)(i + -1)][3l] + hmm->xsc[3l][1l])
          {
            tr->statetype[(signed long int)tpos] = (char)10;
            tr->nodeidx[(signed long int)tpos] = 0;
            tr->pos[(signed long int)tpos] = 0;
            tmp_post$20 = i;
            i = i - 1;
            tr->pos[(signed long int)(tpos - 1)] = tmp_post$20;
          }

          else
            if(xmx[(signed long int)i][3l] == xmx[(signed long int)i][1l] + hmm->xsc[1l][1l])
            {
              tr->statetype[(signed long int)tpos] = (char)7;
              tr->nodeidx[(signed long int)tpos] = 0;
              tr->pos[(signed long int)tpos] = 0;
            }

            else
              Die("Traceback failed.");
        break;
      }
      default:
        Die("traceback failed");
    }
    tpos = tpos + 1;
    if(tpos == curralloc)
    {
      curralloc = curralloc + N;
      P7ReallocTrace(tr, curralloc);
    }

  }
  tr->tlen = tpos;
  P7ReverseTrace(tr);
  *ret_tr = tr;

__CPROVER_DUMP_L59:
  ;
}

// P7WeeViterbi
// file core_algorithms.c line 1327
extern float P7WeeViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct p7trace_s **ret_tr)
{
  struct p7trace_s *tr;
  signed int *kassign;
  char *tassign;
  signed int *endlist;
  signed int *startlist;
  signed int lpos;
  signed int k1;
  signed int k2;
  signed int k3;
  char t1;
  char t2;
  char t3;
  signed int s1;
  signed int s2;
  signed int s3;
  float sc;
  float ret_sc;
  signed int tlen;
  signed int i;
  signed int k;
  signed int tpos;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("core_algorithms.c", 1346, sizeof(signed int) /*4ul*/  * (unsigned long int)(L + 1));
  kassign = (signed int *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("core_algorithms.c", 1347, sizeof(char) /*1ul*/  * (unsigned long int)(L + 1));
  tassign = (char *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("core_algorithms.c", 1348, sizeof(signed int) /*4ul*/  * (unsigned long int)(L + 1));
  endlist = (signed int *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("core_algorithms.c", 1349, sizeof(signed int) /*4ul*/  * (unsigned long int)(L + 1));
  startlist = (signed int *)return_value_sre_malloc$4;
  lpos = 0;
  startlist[(signed long int)lpos] = 1;
  endlist[(signed long int)lpos] = L;
  kassign[(signed long int)1] = 1;
  kassign[(signed long int)L] = hmm->M;
  tassign[(signed long int)1] = (char)4;
  tassign[(signed long int)L] = (char)9;
  while(lpos >= 0)
  {
    s1 = startlist[(signed long int)lpos];
    k1 = kassign[(signed long int)s1];
    t1 = tassign[(signed long int)s1];
    s3 = endlist[(signed long int)lpos];
    k3 = kassign[(signed long int)s3];
    t3 = tassign[(signed long int)s3];
    lpos = lpos - 1;
    sc=get_wee_midpt(hmm, dsq, L, k1, t1, s1, k3, t3, s3, &k2, &t2, &s2);
    kassign[(signed long int)s2] = k2;
    tassign[(signed long int)s2] = t2;
    if((signed int)t1 == 4 && (signed int)t3 == 9)
      ret_sc = sc;

    if(!((signed int)t2 == 5) && (s2 + -s1 >= 2 || s2 + -s1 == 1 && (signed int)t1 == 4))
    {
      lpos = lpos + 1;
      startlist[(signed long int)lpos] = s1;
      endlist[(signed long int)lpos] = s2;
    }

    if(!((signed int)t2 == 8) && (s3 + -s2 >= 2 || s3 + -s2 == 1 && (signed int)t3 == 9))
    {
      lpos = lpos + 1;
      startlist[(signed long int)lpos] = s2;
      endlist[(signed long int)lpos] = s3;
    }

    if((signed int)t2 == 5)
      for( ; s2 >= s1; s2 = s2 - 1)
      {
        kassign[(signed long int)s2] = 1;
        tassign[(signed long int)s2] = (char)5;
      }

    if((signed int)t2 == 8)
      for( ; s3 >= s2; s2 = s2 + 1)
      {
        kassign[(signed long int)s2] = hmm->M;
        tassign[(signed long int)s2] = (char)8;
      }

  }
  tlen = L + 6;
  i = 1;
  for( ; !(i >= L); i = i + 1)
  {
    if((signed int)tassign[(signed long int)i] == 1)
    {
      if((signed int)tassign[(signed long int)(1 + i)] == 1)
        tlen = tlen + ((kassign[(signed long int)(i + 1)] - kassign[(signed long int)i]) - 1);

    }

    if((signed int)tassign[(signed long int)i] == 5)
    {
      if((signed int)tassign[(signed long int)(1 + i)] == 1)
        tlen = tlen + (kassign[(signed long int)(i + 1)] - 1);

    }

    if((signed int)tassign[(signed long int)i] == 1)
    {
      if((signed int)tassign[(signed long int)(1 + i)] == 8)
        tlen = tlen + (hmm->M - kassign[(signed long int)i]);

    }

  }
  if((signed int)tassign[1l] == 1)
    tlen = tlen + (kassign[(signed long int)1] - 1);

  if((signed int)tassign[(signed long int)L] == 1)
    tlen = tlen + (hmm->M - kassign[(signed long int)L]);

  P7AllocTrace(tlen, &tr);
  tr->statetype[(signed long int)0] = (char)4;
  tr->nodeidx[(signed long int)0] = 0;
  tr->pos[(signed long int)0] = 0;
  tr->statetype[(signed long int)1] = (char)5;
  tr->nodeidx[(signed long int)1] = 0;
  tr->pos[(signed long int)1] = 0;
  tpos = 2;
  i = 1;
  _Bool tmp_if_expr$7;
  for( ; L >= i; i = i + 1)
    switch((signed int)tassign[(signed long int)i])
    {
      case 1:
      {
        if((signed int)tr->statetype[(signed long int)(tpos + -1)] == 5)
        {
          tr->statetype[(signed long int)tpos] = (char)6;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
          tpos = tpos + 1;
          signed int return_value_Prob2Score$5;
          return_value_Prob2Score$5=Prob2Score(hmm->begin[(signed long int)kassign[(signed long int)i]], hmm->p1);
          if((double)return_value_Prob2Score$5 + 1000.0 <= (double)hmm->bsc[(signed long int)kassign[(signed long int)i]])
          {
            k = 1;
            for( ; !(k >= kassign[(signed long int)i]); k = k + 1)
            {
              tr->statetype[(signed long int)tpos] = (char)2;
              tr->nodeidx[(signed long int)tpos] = k;
              tr->pos[(signed long int)tpos] = 0;
              tpos = tpos + 1;
            }
          }

        }

        tr->statetype[(signed long int)tpos] = (char)1;
        tr->nodeidx[(signed long int)tpos] = kassign[(signed long int)i];
        tr->pos[(signed long int)tpos] = i;
        tpos = tpos + 1;
        if(!(i >= L))
        {
          if((signed int)tassign[(signed long int)(1 + i)] == 1)
          {
            if(kassign[(signed long int)(1 + i)] + -kassign[(signed long int)i] >= 2)
            {
              k = kassign[(signed long int)i] + 1;
              for( ; !(k >= kassign[(signed long int)(1 + i)]); k = k + 1)
              {
                tr->statetype[(signed long int)tpos] = (char)2;
                tr->nodeidx[(signed long int)tpos] = k;
                tr->pos[(signed long int)tpos] = 0;
                tpos = tpos + 1;
              }
            }

          }

        }

        if(i == L)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)tassign[(signed long int)(i + 1)] == 8 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
        {
          signed int return_value_Prob2Score$6;
          return_value_Prob2Score$6=Prob2Score(hmm->end[(signed long int)kassign[(signed long int)(i - 1)]], (float)1.);
          if((double)return_value_Prob2Score$6 + 1000.0 <= (double)hmm->esc[(signed long int)kassign[(signed long int)(i + -1)]])
          {
            k = kassign[(signed long int)i] + 1;
            for( ; hmm->M >= k; k = k + 1)
            {
              tr->statetype[(signed long int)tpos] = (char)2;
              tr->nodeidx[(signed long int)tpos] = k;
              tr->pos[(signed long int)tpos] = 0;
              tpos = tpos + 1;
            }
          }

          tr->statetype[(signed long int)tpos] = (char)7;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
          tpos = tpos + 1;
          tr->statetype[(signed long int)tpos] = (char)8;
          tr->nodeidx[(signed long int)tpos] = 0;
          tr->pos[(signed long int)tpos] = 0;
          tpos = tpos + 1;
        }

        break;
      }
      case 3:
      {
        tr->statetype[(signed long int)tpos] = (char)3;
        tr->nodeidx[(signed long int)tpos] = kassign[(signed long int)i];
        tr->pos[(signed long int)tpos] = i;
        tpos = tpos + 1;
        break;
      }
      case 5:
      {
        tr->statetype[(signed long int)tpos] = (char)5;
        tr->nodeidx[(signed long int)tpos] = 0;
        tr->pos[(signed long int)tpos] = i;
        tpos = tpos + 1;
        break;
      }
      case 8:
      {
        tr->statetype[(signed long int)tpos] = (char)8;
        tr->nodeidx[(signed long int)tpos] = 0;
        tr->pos[(signed long int)tpos] = i;
        tpos = tpos + 1;
        break;
      }
      default:
      {
        char *return_value_Statetype$8;
        return_value_Statetype$8=Statetype(tassign[(signed long int)i]);
        Die("Bogus state %s", return_value_Statetype$8);
      }
    }
  tr->statetype[(signed long int)tpos] = (char)9;
  tr->nodeidx[(signed long int)tpos] = 0;
  tr->pos[(signed long int)tpos] = 0;
  tr->tlen = tpos + 1;
  *ret_tr = tr;
  free((void *)kassign);
  free((void *)tassign);
  free((void *)startlist);
  free((void *)endlist);
  return ret_sc;
}

// P7WeeViterbiSize
// file core_algorithms.c line 427
extern signed int P7WeeViterbiSize(signed int L, signed int M)
{
  return (signed int)(((unsigned long int)2 * sizeof(struct dpmatrix_s) /*80ul*/  + (unsigned long int)(12 * (M + 2)) * sizeof(signed int) /*4ul*/  + (unsigned long int)16 * sizeof(signed int *) /*8ul*/  + (unsigned long int)20 * sizeof(signed int) /*4ul*/  + (unsigned long int)(2 * (L + 2)) * sizeof(signed int) /*4ul*/  + (unsigned long int)(L + 2) * sizeof(signed int) /*4ul*/  + (unsigned long int)(L + 2) * sizeof(char) /*1ul*/ ) / (unsigned long int)1000000);
}

// P9AllocHMM
// file funcs.h line 240
extern struct plan9_s * P9AllocHMM(signed int M)
{
  struct plan9_s *hmm;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("plan9.c", 35, sizeof(struct plan9_s) /*152ul*/ );
  hmm = (struct plan9_s *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("plan9.c", 36, sizeof(struct basic_state) /*92ul*/  * (unsigned long int)(M + 2));
  hmm->ins = (struct basic_state *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("plan9.c", 37, sizeof(struct basic_state) /*92ul*/  * (unsigned long int)(M + 2));
  hmm->del = (struct basic_state *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("plan9.c", 38, sizeof(struct basic_state) /*92ul*/  * (unsigned long int)(M + 2));
  hmm->mat = (struct basic_state *)return_value_sre_malloc$4;
  void *return_value_sre_malloc$5;
  return_value_sre_malloc$5=sre_malloc("plan9.c", 39, (unsigned long int)(M + 2) * sizeof(char) /*1ul*/ );
  hmm->ref = (char *)return_value_sre_malloc$5;
  void *return_value_sre_malloc$6;
  return_value_sre_malloc$6=sre_malloc("plan9.c", 40, (unsigned long int)(M + 2) * sizeof(char) /*1ul*/ );
  hmm->cs = (char *)return_value_sre_malloc$6;
  void *return_value_sre_malloc$7;
  return_value_sre_malloc$7=sre_malloc("plan9.c", 41, (unsigned long int)(M + 2) * sizeof(float) /*4ul*/  * (unsigned long int)4);
  hmm->xray = (float *)return_value_sre_malloc$7;
  hmm->M = M;
  hmm->name=Strdup("unnamed");
  hmm->flags = 0;
  P9ZeroHMM(hmm);
  return hmm;
}

// P9DefaultNullModel
// file funcs.h line 244
extern void P9DefaultNullModel(float *null)
{
  signed int x;
  if(Alphabet_type == 3)
  {
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      null[(signed long int)x] = aafq[(signed long int)x];
  }

  else
    if(Alphabet_type == 2)
    {
      x = 0;
      for( ; !(x >= Alphabet_size); x = x + 1)
        null[(signed long int)x] = (float)0.25;
    }

    else
      Die("No support for non-protein, non-nucleic acid alphabets.");
}

// P9FreeHMM
// file funcs.h line 242
extern signed int P9FreeHMM(struct plan9_s *hmm)
{
  if(hmm == ((struct plan9_s *)NULL))
    return 0;

  else
  {
    free((void *)hmm->ref);
    free((void *)hmm->cs);
    free((void *)hmm->xray);
    free((void *)hmm->name);
    if(!(hmm->mat == ((struct basic_state *)NULL)))
      free((void *)hmm->mat);

    if(!(hmm->ins == ((struct basic_state *)NULL)))
      free((void *)hmm->ins);

    if(!(hmm->del == ((struct basic_state *)NULL)))
      free((void *)hmm->del);

    free((void *)hmm);
    return 1;
  }
}

// P9Renormalize
// file funcs.h line 243
extern void P9Renormalize(struct plan9_s *hmm)
{
  signed int k = 0;
  for( ; hmm->M >= k; k = k + 1)
  {
    FNorm((hmm->mat + (signed long int)k)->t, 3);
    FNorm((hmm->ins + (signed long int)k)->t, 3);
    if(k >= 1)
      FNorm((hmm->del + (signed long int)k)->t, 3);

    if(k >= 1)
      FNorm((hmm->mat + (signed long int)k)->p, Alphabet_size);

    FNorm((hmm->ins + (signed long int)k)->p, Alphabet_size);
  }
}

// P9ZeroHMM
// file plan9.c line 70
extern void P9ZeroHMM(struct plan9_s *hmm)
{
  signed int k;
  signed int ts;
  signed int idx;
  k = 0;
  for( ; 1 + hmm->M >= k; k = k + 1)
  {
    ts = 0;
    for( ; !(ts >= 3); ts = ts + 1)
    {
      (hmm->mat + (signed long int)k)->t[(signed long int)ts] = (float)0.0;
      (hmm->ins + (signed long int)k)->t[(signed long int)ts] = (float)0.0;
      (hmm->del + (signed long int)k)->t[(signed long int)ts] = (float)0.0;
    }
    idx = 0;
    for( ; !(idx >= Alphabet_size); idx = idx + 1)
    {
      (hmm->mat + (signed long int)k)->p[(signed long int)idx] = (float)0.0;
      (hmm->ins + (signed long int)k)->p[(signed long int)idx] = (float)0.0;
      (hmm->del + (signed long int)k)->p[(signed long int)idx] = (float)0.0;
    }
  }
}

// PAMPrior
// file prior.c line 214
extern void PAMPrior(char *pamfile, struct p7prior_s *pri, float wt)
{
  struct _IO_FILE *fp;
  char *blastpamfile;
  signed int **pam;
  float scale;
  signed int xi;
  signed int xj;
  signed int idx1;
  signed int idx2;
  if(!(Alphabet_type == 3))
    Die("PAM prior is only valid for protein sequences");

  if(!(pri->strategy == 0))
    Die("PAM prior may only be applied over an existing Dirichlet prior");

  if(!(pri->inum == 1))
    Die("PAM prior requires that the insert emissions be a single Dirichlet");

  blastpamfile=FileConcat("aa", pamfile);
  fp=fopen(pamfile, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    fp=EnvFileOpen(pamfile, "BLASTMAT", (char **)(void *)0);
    if(fp == ((struct _IO_FILE *)NULL))
    {
      fp=EnvFileOpen(blastpamfile, "BLASTMAT", (char **)(void *)0);
      if(fp == ((struct _IO_FILE *)NULL))
        Die("Failed to open PAM scoring matrix file %s", pamfile);

    }

  }

  signed int return_value_ParsePAMFile$1;
  return_value_ParsePAMFile$1=ParsePAMFile(fp, &pam, &scale);
  if(return_value_ParsePAMFile$1 == 0)
    Die("Failed to parse PAM scoring matrix file %s", pamfile);

  fclose(fp);
  free((void *)blastpamfile);
  pri->strategy = 1;
  pri->mnum = 20;
  xi = 0;
  for( ; !(xi >= Alphabet_size); xi = xi + 1)
  {
    xj = 0;
    for( ; !(xj >= Alphabet_size); xj = xj + 1)
    {
      idx1 = (signed int)Alphabet[(signed long int)xi] - 65;
      idx2 = (signed int)Alphabet[(signed long int)xj] - 65;
      double return_value_exp$2;
      return_value_exp$2=exp((double)((float)pam[(signed long int)idx1][(signed long int)idx2] * scale));
      pri->m[(signed long int)xi][(signed long int)xj] = (float)((double)aafq[(signed long int)xj] * return_value_exp$2);
    }
  }
  xi = 0;
  for( ; !(xi >= Alphabet_size); xi = xi + 1)
  {
    pri->mq[(signed long int)xi] = (float)(1. / (double)Alphabet_size);
    FNorm(pri->m[(signed long int)xi], Alphabet_size);
    FScale(pri->m[(signed long int)xi], Alphabet_size, wt);
  }
  Free2DArray((void **)pam, 27);
}

// PVMCheckSlaves
// file funcs.h line 286
extern void PVMCheckSlaves(signed int *slave_tid, signed int nslaves)
{
  signed int trouble;
  trouble=pvm_nrecv(-1, 3);
  if(trouble >= 1)
  {
    PVMKillSlaves(slave_tid, nslaves);
    pvm_exit();
    Die("One or more slave tasks exited prematurely. Shutting down.");
  }

  trouble=pvm_nrecv(-1, 4);
  if(trouble >= 1)
  {
    PVMKillSlaves(slave_tid, nslaves);
    pvm_exit();
    Die("One or more hosts left the PVM unexpectedly. Shutting down.");
  }

}

// PVMConfirmSlaves
// file funcs.h line 285
extern void PVMConfirmSlaves(signed int *slave_tid, signed int nslaves)
{
  signed int i;
  struct timeval tmout;
  signed int code;
  signed int bufid;
  char *slaverelease;
  tmout.tv_sec = (signed long int)5;
  tmout.tv_usec = (signed long int)0;
  i = 0;
  for( ; !(i >= nslaves); i = i + 1)
  {
    bufid=pvm_trecv(slave_tid[(signed long int)i], 2, &tmout);
    if(!(bufid >= 1))
    {
      PVMKillSlaves(slave_tid, nslaves);
      pvm_exit();
      Die("One or more slaves started but died before initializing.");
    }

    pvm_upkint(&code, 1, 1);
    slaverelease=PVMUnpackString();
    if(!(code == 0))
    {
      PVMKillSlaves(slave_tid, nslaves);
      pvm_exit();
      switch(code)
      {
        case 1:
          Die("One or more PVM slaves couldn't open hmm file. Check installation.");
        case 2:
          Die("One or more PVM slaves couldn't open SSI index for hmm file. Check installation.");
        case 3:
          Die("One or more PVM slaves reports a failure to initialize.");
      }
      Die("Unknown error code. A slave is confused.");
    }

    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(slaverelease, "2.3.2");
    if(!(return_value_strcmp$1 == 0))
    {
      PVMKillSlaves(slave_tid, nslaves);
      pvm_exit();
      Die("Slave %d reports that it's running release %s, which doesn't match the master (%s)", i, slaverelease, (const void *)"2.3.2");
    }

  }
}

// PVMKillSlaves
// file pvm.c line 236
extern void PVMKillSlaves(signed int *slave_tid, signed int nslaves)
{
  signed int i = 0;
  signed int return_value_pvm_kill$1;
  for( ; !(i >= nslaves); i = i + 1)
  {
    return_value_pvm_kill$1=pvm_kill(slave_tid[(signed long int)i]);
    if(!(return_value_pvm_kill$1 == 0))
      Warn("a slave refuses to die. how annoying");

  }
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// PVMPackHMM
// file funcs.h line 292
extern signed int PVMPackHMM(struct plan7_s *hmm)
{
  signed int k;
  signed int sendflags = hmm->flags;
  sendflags = sendflags & ~(1 << 0);
  sendflags = sendflags & ~(1 << 6);
  signed int return_value_pvm_pkint$1;
  return_value_pvm_pkint$1=pvm_pkint(&hmm->M, 1, 1);
  signed int return_value_pvm_pkfloat$12;
  signed int return_value_pvm_pkfloat$13;
  signed int return_value_pvm_pkfloat$14;
  signed int return_value_pvm_pkfloat$16;
  if(!(return_value_pvm_pkint$1 == 0))
    return 0;

  else
  {
    signed int return_value_pvm_pkint$2;
    return_value_pvm_pkint$2=pvm_pkint(&sendflags, 1, 1);
    if(!(return_value_pvm_pkint$2 == 0))
      return 0;

    else
    {
      signed int return_value_PVMPackString$3;
      return_value_PVMPackString$3=PVMPackString(hmm->name);
      if(return_value_PVMPackString$3 == 0)
        return 0;

      else
      {
        if(!((2 & hmm->flags) == 0))
        {
          signed int return_value_PVMPackString$4;
          return_value_PVMPackString$4=PVMPackString(hmm->desc);
          if(return_value_PVMPackString$4 == 0)
            return 0;

        }

        if(!((4 & hmm->flags) == 0))
        {
          signed int return_value_PVMPackString$5;
          return_value_PVMPackString$5=PVMPackString(hmm->rf);
          if(return_value_PVMPackString$5 == 0)
            return 0;

        }

        if(!((8 & hmm->flags) == 0))
        {
          signed int return_value_PVMPackString$6;
          return_value_PVMPackString$6=PVMPackString(hmm->cs);
          if(return_value_PVMPackString$6 == 0)
            return 0;

        }

        signed int return_value_PVMPackString$7;
        return_value_PVMPackString$7=PVMPackString(hmm->comlog);
        if(return_value_PVMPackString$7 == 0)
          return 0;

        else
        {
          signed int return_value_pvm_pkint$8;
          return_value_pvm_pkint$8=pvm_pkint(&hmm->nseq, 1, 1);
          if(!(return_value_pvm_pkint$8 == 0))
            return 0;

          else
          {
            signed int return_value_PVMPackString$9;
            return_value_PVMPackString$9=PVMPackString(hmm->ctime);
            if(return_value_PVMPackString$9 == 0)
              return 0;

            else
            {
              if(!((256 & hmm->flags) == 0))
              {
                signed int return_value_pvm_pkint$10;
                return_value_pvm_pkint$10=pvm_pkint(hmm->map, hmm->M + 1, 1);
                if(!(return_value_pvm_pkint$10 == 0))
                  return 0;

              }

              signed int return_value_pvm_pkint$11;
              return_value_pvm_pkint$11=pvm_pkint(&hmm->checksum, 1, 1);
              if(!(return_value_pvm_pkint$11 == 0))
                return 0;

              else
              {
                k = 1;
                for( ; !(k >= hmm->M); k = k + 1)
                {
                  return_value_pvm_pkfloat$12=pvm_pkfloat(hmm->t[(signed long int)k], 7, 1);
                  if(!(return_value_pvm_pkfloat$12 == 0))
                    return 0;

                }
                k = 1;
                for( ; hmm->M >= k; k = k + 1)
                {
                  return_value_pvm_pkfloat$13=pvm_pkfloat(hmm->mat[(signed long int)k], Alphabet_size, 1);
                  if(!(return_value_pvm_pkfloat$13 == 0))
                    return 0;

                }
                k = 1;
                for( ; !(k >= hmm->M); k = k + 1)
                {
                  return_value_pvm_pkfloat$14=pvm_pkfloat(hmm->ins[(signed long int)k], Alphabet_size, 1);
                  if(!(return_value_pvm_pkfloat$14 == 0))
                    return 0;

                }
                signed int return_value_pvm_pkfloat$15;
                return_value_pvm_pkfloat$15=pvm_pkfloat(&hmm->tbd1, 1, 1);
                if(!(return_value_pvm_pkfloat$15 == 0))
                  return 0;

                else
                {
                  k = 0;
                  for( ; !(k >= 4); k = k + 1)
                  {
                    return_value_pvm_pkfloat$16=pvm_pkfloat(hmm->xt[(signed long int)k], 2, 1);
                    if(!(return_value_pvm_pkfloat$16 == 0))
                      return 0;

                  }
                  signed int return_value_pvm_pkfloat$17;
                  return_value_pvm_pkfloat$17=pvm_pkfloat(hmm->begin, hmm->M + 1, 1);
                  if(!(return_value_pvm_pkfloat$17 == 0))
                    return 0;

                  else
                  {
                    signed int return_value_pvm_pkfloat$18;
                    return_value_pvm_pkfloat$18=pvm_pkfloat(hmm->end, hmm->M + 1, 1);
                    if(!(return_value_pvm_pkfloat$18 == 0))
                      return 0;

                    else
                    {
                      signed int return_value_pvm_pkfloat$19;
                      return_value_pvm_pkfloat$19=pvm_pkfloat(hmm->null, Alphabet_size, 1);
                      if(!(return_value_pvm_pkfloat$19 == 0))
                        return 0;

                      else
                      {
                        signed int return_value_pvm_pkfloat$20;
                        return_value_pvm_pkfloat$20=pvm_pkfloat(&hmm->p1, 1, 1);
                        if(!(return_value_pvm_pkfloat$20 == 0))
                          return 0;

                        else
                        {
                          if(!((128 & hmm->flags) == 0))
                          {
                            signed int return_value_pvm_pkfloat$21;
                            return_value_pvm_pkfloat$21=pvm_pkfloat(&hmm->mu, 1, 1);
                            if(!(return_value_pvm_pkfloat$21 == 0))
                              return 0;

                            signed int return_value_pvm_pkfloat$22;
                            return_value_pvm_pkfloat$22=pvm_pkfloat(&hmm->lambda, 1, 1);
                            if(!(return_value_pvm_pkfloat$22 == 0))
                              return 0;

                          }

                          return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// PVMPackString
// file pvm.c line 259
extern signed int PVMPackString(char *s)
{
  signed int len;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(s == ((char *)NULL))
    tmp_if_expr$2 = (unsigned long int)-1;

  else
  {
    return_value_strlen$1=strlen(s);
    tmp_if_expr$2 = return_value_strlen$1;
  }
  len = (signed int)tmp_if_expr$2;
  signed int return_value_pvm_pkint$3;
  return_value_pvm_pkint$3=pvm_pkint(&len, 1, 1);
  signed int return_value_pvm_pkstr$4;
  if(!(return_value_pvm_pkint$3 == 0))
    return 0;

  else
    if(len >= 0)
    {
      return_value_pvm_pkstr$4=pvm_pkstr(s);
      if(return_value_pvm_pkstr$4 == 0)
        goto __CPROVER_DUMP_L4;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      return 1;
    }
}

// PVMPackTrace
// file pvm.c line 306
extern signed int PVMPackTrace(struct p7trace_s *tr)
{
  signed int return_value_pvm_pkint$1;
  return_value_pvm_pkint$1=pvm_pkint(&tr->tlen, 1, 1);
  if(!(return_value_pvm_pkint$1 >= 0))
    return 0;

  else
  {
    signed int return_value_pvm_pkbyte$2;
    return_value_pvm_pkbyte$2=pvm_pkbyte(tr->statetype, tr->tlen, 1);
    if(!(return_value_pvm_pkbyte$2 >= 0))
      return 0;

    else
    {
      signed int return_value_pvm_pkint$3;
      return_value_pvm_pkint$3=pvm_pkint(tr->nodeidx, tr->tlen, 1);
      if(!(return_value_pvm_pkint$3 >= 0))
        return 0;

      else
      {
        signed int return_value_pvm_pkint$4;
        return_value_pvm_pkint$4=pvm_pkint(tr->pos, tr->tlen, 1);
        if(!(return_value_pvm_pkint$4 >= 0))
          return 0;

        else
          return 1;
      }
    }
  }
}

// PVMSpawnSlaves
// file funcs.h line 284
extern void PVMSpawnSlaves(char *slave, signed int **ret_tid, signed int *ret_nslaves)
{
  struct pvmhostinfo *hostp;
  signed int nodes;
  signed int nslaves;
  signed int ntasks;
  signed int code;
  signed int *tid;
  signed int *dtid;
  signed int i;
  signed int return_value_pvm_config$1;
  return_value_pvm_config$1=pvm_config(&nodes, (signed int *)(void *)0, &hostp);
  if(!(return_value_pvm_config$1 == 0))
    Die("PVM not responding");

  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("pvm.c", 65, sizeof(signed int) /*4ul*/  * (unsigned long int)nodes);
  dtid = (signed int *)return_value_sre_malloc$2;
  nslaves = 0;
  i = 0;
  void *return_value_sre_malloc$3;
  void *return_value_sre_realloc$4;
  for( ; !(i >= nodes); i = i + 1)
  {
    dtid[(signed long int)i] = (hostp + (signed long int)i)->hi_tid;
    ntasks = (hostp + (signed long int)i)->hi_speed / 1000;
    if(!(ntasks == 0))
    {
      if(nslaves == 0)
      {
        return_value_sre_malloc$3=sre_malloc("pvm.c", 73, sizeof(signed int) /*4ul*/  * (unsigned long int)ntasks);
        tid = (signed int *)return_value_sre_malloc$3;
      }

      else
      {
        return_value_sre_realloc$4=sre_realloc("pvm.c", 74, (void *)tid, sizeof(signed int) /*4ul*/  * (unsigned long int)(ntasks + nslaves));
        tid = (signed int *)return_value_sre_realloc$4;
      }
      code=pvm_spawn(slave, (char **)(void *)0, 1, (hostp + (signed long int)i)->hi_name, ntasks, tid + (signed long int)nslaves);
      if(!(code >= ntasks))
      {
        pvm_exit();
        if(!(tid[(signed long int)nslaves] == -2))
        {
          if(tid[(signed long int)nslaves] == -6)
            goto __CPROVER_DUMP_L6;

          if(tid[(signed long int)nslaves] == -7)
            goto __CPROVER_DUMP_L7;

          if(tid[(signed long int)nslaves] == -10)
            goto __CPROVER_DUMP_L8;

          if(tid[(signed long int)nslaves] == -14)
            goto __CPROVER_DUMP_L9;

          if(tid[(signed long int)nslaves] == -27)
            goto __CPROVER_DUMP_L10;

        }

        else
        {
          Die("pvm_spawn claims PvmBadParam - code error?");

        __CPROVER_DUMP_L6:
          ;
          Die("pvm_spawn: host %d (%s): not in virtual machine", i, (hostp + (signed long int)i)->hi_name);

        __CPROVER_DUMP_L7:
          ;
          Die("pvm_spawn: host %d (%s): %s not in path", i + 1, (hostp + (signed long int)i)->hi_name, slave);

        __CPROVER_DUMP_L8:
          ;
          Die("pvm_spawn claims that host %s has insufficient memory", (hostp + (signed long int)i)->hi_name);

        __CPROVER_DUMP_L9:
          ;
          Die("pvm_spawn: host %d (%s): pvmd not responding", i + 1, (hostp + (signed long int)i)->hi_name);

        __CPROVER_DUMP_L10:
          ;
          Die("pvm_spawn claims it is out of resources.");
        }
        Die("Spawned too few slaves on node %s; expected %d got %d\n", (hostp + (signed long int)i)->hi_name, ntasks, code);
      }

      nslaves = nslaves + ntasks;
    }

  }
  if(nslaves == 0)
  {
    pvm_exit();
    Die("No slaves were spawned");
  }

  signed int return_value_pvm_notify$5;
  return_value_pvm_notify$5=pvm_notify(1, 3, nslaves, tid);
  if(!(return_value_pvm_notify$5 == 0))
  {
    pvm_exit();
    Die("pvm_notify() unexpectedly failed");
  }

  signed int return_value_pvm_notify$6;
  return_value_pvm_notify$6=pvm_notify(2, 4, nodes, dtid);
  if(!(return_value_pvm_notify$6 == 0))
  {
    pvm_exit();
    Die("pvm_notify() unexpectedly failed");
  }

  *ret_tid = tid;
  *ret_nslaves = nslaves;
  free((void *)dtid);
  goto __CPROVER_DUMP_L18;

__CPROVER_DUMP_L18:
  ;
}

// PVMUnpackHMM
// file pvm.c line 406
extern struct plan7_s * PVMUnpackHMM(void)
{
  struct plan7_s *hmm;
  signed int k;
  signed int M;
  signed int return_value_pvm_upkint$1;
  return_value_pvm_upkint$1=pvm_upkint(&M, 1, 1);
  signed int return_value_pvm_upkfloat$6;
  signed int return_value_pvm_upkfloat$7;
  signed int return_value_pvm_upkfloat$8;
  signed int return_value_pvm_upkfloat$10;
  if(!(return_value_pvm_upkint$1 == 0))
    return (struct plan7_s *)(void *)0;

  else
  {
    hmm=AllocPlan7(M);
    signed int return_value_pvm_upkint$2;
    return_value_pvm_upkint$2=pvm_upkint(&hmm->flags, 1, 1);
    if(!(return_value_pvm_upkint$2 == 0))
      return (struct plan7_s *)(void *)0;

    else
    {
      hmm->name=PVMUnpackString();
      if(hmm->name == ((char *)NULL))
        return (struct plan7_s *)(void *)0;

      else
        if(!((2 & hmm->flags) == 0))
        {
          hmm->desc=PVMUnpackString();
          if(!(hmm->desc == ((char *)NULL)))
            goto __CPROVER_DUMP_L4;

          return (struct plan7_s *)(void *)0;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!((4 & hmm->flags) == 0))
          {
            hmm->rf=PVMUnpackString();
            if(!(hmm->rf == ((char *)NULL)))
              goto __CPROVER_DUMP_L5;

            return (struct plan7_s *)(void *)0;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            if(!((8 & hmm->flags) == 0))
            {
              hmm->cs=PVMUnpackString();
              if(!(hmm->cs == ((char *)NULL)))
                goto __CPROVER_DUMP_L6;

              return (struct plan7_s *)(void *)0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              hmm->comlog=PVMUnpackString();
              if(hmm->comlog == ((char *)NULL))
                return (struct plan7_s *)(void *)0;

              else
              {
                signed int return_value_pvm_upkint$3;
                return_value_pvm_upkint$3=pvm_upkint(&hmm->nseq, 1, 1);
                if(!(return_value_pvm_upkint$3 == 0))
                  return (struct plan7_s *)(void *)0;

                else
                {
                  hmm->ctime=PVMUnpackString();
                  if(hmm->ctime == ((char *)NULL))
                    return (struct plan7_s *)(void *)0;

                  else
                  {
                    if(!((256 & hmm->flags) == 0))
                    {
                      signed int return_value_pvm_upkint$4;
                      return_value_pvm_upkint$4=pvm_upkint(hmm->map, hmm->M + 1, 1);
                      if(!(return_value_pvm_upkint$4 == 0))
                        return (struct plan7_s *)(void *)0;

                    }

                    signed int return_value_pvm_upkint$5;
                    return_value_pvm_upkint$5=pvm_upkint(&hmm->checksum, 1, 1);
                    if(!(return_value_pvm_upkint$5 == 0))
                      return (struct plan7_s *)(void *)0;

                    else
                    {
                      k = 1;
                      for( ; !(k >= hmm->M); k = k + 1)
                      {
                        return_value_pvm_upkfloat$6=pvm_upkfloat(hmm->t[(signed long int)k], 7, 1);
                        if(!(return_value_pvm_upkfloat$6 == 0))
                          return (struct plan7_s *)(void *)0;

                      }
                      k = 1;
                      for( ; hmm->M >= k; k = k + 1)
                      {
                        return_value_pvm_upkfloat$7=pvm_upkfloat(hmm->mat[(signed long int)k], Alphabet_size, 1);
                        if(!(return_value_pvm_upkfloat$7 == 0))
                          return (struct plan7_s *)(void *)0;

                      }
                      k = 1;
                      for( ; !(k >= hmm->M); k = k + 1)
                      {
                        return_value_pvm_upkfloat$8=pvm_upkfloat(hmm->ins[(signed long int)k], Alphabet_size, 1);
                        if(!(return_value_pvm_upkfloat$8 == 0))
                          return (struct plan7_s *)(void *)0;

                      }
                      signed int return_value_pvm_upkfloat$9;
                      return_value_pvm_upkfloat$9=pvm_upkfloat(&hmm->tbd1, 1, 1);
                      if(!(return_value_pvm_upkfloat$9 == 0))
                        return (struct plan7_s *)(void *)0;

                      else
                      {
                        k = 0;
                        for( ; !(k >= 4); k = k + 1)
                        {
                          return_value_pvm_upkfloat$10=pvm_upkfloat(hmm->xt[(signed long int)k], 2, 1);
                          if(!(return_value_pvm_upkfloat$10 == 0))
                            return (struct plan7_s *)(void *)0;

                        }
                        signed int return_value_pvm_upkfloat$11;
                        return_value_pvm_upkfloat$11=pvm_upkfloat(hmm->begin, hmm->M + 1, 1);
                        if(!(return_value_pvm_upkfloat$11 == 0))
                          return (struct plan7_s *)(void *)0;

                        else
                        {
                          signed int return_value_pvm_upkfloat$12;
                          return_value_pvm_upkfloat$12=pvm_upkfloat(hmm->end, hmm->M + 1, 1);
                          if(!(return_value_pvm_upkfloat$12 == 0))
                            return (struct plan7_s *)(void *)0;

                          else
                          {
                            signed int return_value_pvm_upkfloat$13;
                            return_value_pvm_upkfloat$13=pvm_upkfloat(hmm->null, Alphabet_size, 1);
                            if(!(return_value_pvm_upkfloat$13 == 0))
                              return (struct plan7_s *)(void *)0;

                            else
                            {
                              signed int return_value_pvm_upkfloat$14;
                              return_value_pvm_upkfloat$14=pvm_upkfloat(&hmm->p1, 1, 1);
                              if(!(return_value_pvm_upkfloat$14 == 0))
                                return (struct plan7_s *)(void *)0;

                              else
                              {
                                if(!((128 & hmm->flags) == 0))
                                {
                                  signed int return_value_pvm_upkfloat$15;
                                  return_value_pvm_upkfloat$15=pvm_upkfloat(&hmm->mu, 1, 1);
                                  if(!(return_value_pvm_upkfloat$15 == 0))
                                    return (struct plan7_s *)(void *)0;

                                  signed int return_value_pvm_upkfloat$16;
                                  return_value_pvm_upkfloat$16=pvm_upkfloat(&hmm->lambda, 1, 1);
                                  if(!(return_value_pvm_upkfloat$16 == 0))
                                    return (struct plan7_s *)(void *)0;

                                }

                                return hmm;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
  }
}

// PVMUnpackString
// file pvm.c line 280
extern char * PVMUnpackString(void)
{
  signed int len;
  char *s;
  signed int return_value_pvm_upkint$1;
  return_value_pvm_upkint$1=pvm_upkint(&len, 1, 1);
  if(!(return_value_pvm_upkint$1 == 0))
    return (char *)(void *)0;

  else
    if(len == -1)
      return (char *)(void *)0;

    else
    {
      void *return_value_sre_malloc$2;
      return_value_sre_malloc$2=sre_malloc("pvm.c", 288, sizeof(char) /*1ul*/  * (unsigned long int)(len + 1));
      s = (char *)return_value_sre_malloc$2;
      signed int return_value_pvm_upkstr$3;
      return_value_pvm_upkstr$3=pvm_upkstr(s);
      if(!(return_value_pvm_upkstr$3 == 0))
        return (char *)(void *)0;

      else
        return s;
    }
}

// PVMUnpackTrace
// file pvm.c line 328
extern struct p7trace_s * PVMUnpackTrace(void)
{
  struct p7trace_s *tr;
  signed int tlen;
  pvm_upkint(&tlen, 1, 1);
  P7AllocTrace(tlen, &tr);
  signed int return_value_pvm_upkbyte$1;
  return_value_pvm_upkbyte$1=pvm_upkbyte(tr->statetype, tlen, 1);
  if(!(return_value_pvm_upkbyte$1 >= 0))
  {
    P7FreeTrace(tr);
    return (struct p7trace_s *)(void *)0;
  }

  else
  {
    signed int return_value_pvm_upkint$2;
    return_value_pvm_upkint$2=pvm_upkint(tr->nodeidx, tlen, 1);
    if(!(return_value_pvm_upkint$2 >= 0))
    {
      P7FreeTrace(tr);
      return (struct p7trace_s *)(void *)0;
    }

    else
    {
      signed int return_value_pvm_upkint$3;
      return_value_pvm_upkint$3=pvm_upkint(tr->pos, tlen, 1);
      if(!(return_value_pvm_upkint$3 >= 0))
      {
        P7FreeTrace(tr);
        return (struct p7trace_s *)(void *)0;
      }

      else
      {
        tr->tlen = tlen;
        return tr;
      }
    }
  }
}

// PValue
// file funcs.h line 177
extern double PValue(struct plan7_s *hmm, float sc)
{
  double pval;
  double pval2;
  double return_value_log$3;
  return_value_log$3=log((double)1.79769313486231570815e+308L);
  double return_value_log$2;
  double return_value_exp$1;
  if((double)sc >= return_value_log$3 * 1.44269504)
    pval = 0.0;

  else
  {
    return_value_log$2=log((double)1.79769313486231570815e+308L);
    if((double)sc <= -1.000000 * return_value_log$2 * 1.44269504)
      pval = 1.0;

    else
    {
      return_value_exp$1=exp((double)sc * 0.69314718);
      pval = 1. / (1. + return_value_exp$1);
    }
  }
  if(!(hmm == ((struct plan7_s *)NULL)))
  {
    if(!((128 & hmm->flags) == 0))
    {
      pval2=ExtremeValueP(sc, hmm->mu, hmm->lambda);
      if(pval2 < pval)
        pval = pval2;

    }

  }

  return pval;
}

// P_PvecGivenDirichlet
// file mathsupport.c line 350
extern float P_PvecGivenDirichlet(float *p, signed int n, float *alpha)
{
  float sum;
  float logp;
  signed int x;
  logp = (float)0.0;
  sum = logp;
  x = 0;
  for( ; !(x >= n); x = x + 1)
    if(p[(signed long int)x] > 0.000000f)
    {
      double return_value_log$1;
      return_value_log$1=log((double)p[(signed long int)x]);
      logp = logp + (float)(((double)alpha[(signed long int)x] - 1.0) * return_value_log$1);
      double return_value_Gammln$2;
      return_value_Gammln$2=Gammln((double)alpha[(signed long int)x]);
      logp = logp - (float)return_value_Gammln$2;
      sum = sum + alpha[(signed long int)x];
    }

  double return_value_Gammln$3;
  return_value_Gammln$3=Gammln((double)sum);
  logp = logp + (float)return_value_Gammln$3;
  return logp;
}

// PairwiseIdentity
// file aligneval.c line 401
extern float PairwiseIdentity(char *s1, char *s2)
{
  signed int idents;
  signed int len1;
  signed int len2;
  signed int x;
  len2 = 0;
  len1 = len2;
  idents = len1;
  x = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  do
  {
    if(!((signed int)s1[(signed long int)x] == 0))
      tmp_if_expr$1 = (signed int)s2[(signed long int)x] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    if((signed int)s1[(signed long int)x] == 32)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)s1[(signed long int)x] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)s1[(signed long int)x] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)s1[(signed long int)x] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)s1[(signed long int)x] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$5)
    {
      len1 = len1 + 1;
      if(s1[(signed long int)x] == s2[(signed long int)x])
        idents = idents + 1;

    }

    if((signed int)s2[(signed long int)x] == 32)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)s2[(signed long int)x] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)s2[(signed long int)x] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = (signed int)s2[(signed long int)x] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
      tmp_if_expr$9 = (_Bool)1;

    else
      tmp_if_expr$9 = (signed int)s2[(signed long int)x] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$9)
      len2 = len2 + 1;

    x = x + 1;
  }
  while((_Bool)1);
  if(!(len2 >= len1))
    len1 = len2;

  return (float)(len1 == 0 ? 0.0 : (double)((float)idents / (float)len1));
}

// Panic
// file ../squid/sqfuncs.h line 152
extern void Panic(char *file, signed int line)
{
  fprintf(stderr, "\nPANIC [%s line %d] ", file, line);
  perror("Unusual error");
  exit(1);
}

// ParsePAMFile
// file ../squid/sqfuncs.h line 70
extern signed int ParsePAMFile(struct _IO_FILE *fp, signed int ***ret_pam, float *ret_scale)
{
  signed int **pam;
  char buffer[512l];
  signed int order[27l];
  signed int nsymbols;
  char *sptr;
  signed int idx;
  signed int row;
  signed int col;
  float scale;
  signed int gotscale = 0;
  scale = (float)0.0;
  _Bool tmp_if_expr$10;
  char *return_value_strstr$8;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$11;
  void *return_value_calloc$13;
  _Bool tmp_if_expr$16;
  const unsigned short int **return_value___ctype_b_loc$15;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    squid_errno = 2;
    return 0;
  }

  else
  {
    do
    {
      char *return_value_fgets$2;
      return_value_fgets$2=fgets(buffer, 512, fp);
      if(return_value_fgets$2 == ((char *)NULL))
      {
        squid_errno = 2;
        return 0;
      }

      char *return_value_strstr$9;
      return_value_strstr$9=strstr(buffer, "BLOSUM Clustered Scoring Matrix");
      if(!(return_value_strstr$9 == ((char *)NULL)))
      {
        sptr=strchr(buffer, 47);
        tmp_if_expr$10 = sptr != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
      {
        sptr = sptr + 1l;
        const unsigned short int **return_value___ctype_b_loc$3;
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*sptr]) == 0)
        {
          squid_errno = 5;
          return 0;
        }

        double return_value_log$4;
        return_value_log$4=log(2.0);
        double return_value_atof$5;
        return_value_atof$5=atof(sptr);
        scale = (float)(return_value_log$4 / return_value_atof$5);
        gotscale = 1;
      }

      else
      {
        return_value_strstr$8=strstr(buffer, "substitution matrix,");
        if(!(return_value_strstr$8 == ((char *)NULL)))
          do
          {
            sptr=strrchr(buffer, 61);
            if(sptr == ((char *)NULL))
              break;

            sptr = sptr + (signed long int)2;
            signed int return_value_IsReal$7;
            return_value_IsReal$7=IsReal(sptr);
            if(!(return_value_IsReal$7 == 0))
            {
              double return_value_atof$6;
              return_value_atof$6=atof(sptr);
              scale = (float)return_value_atof$6;
              gotscale = 1;
              break;
            }

          }
          while((_Bool)1);

      }
      sptr=strtok(buffer, " \t\n");
      if(sptr == ((char *)NULL))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)*sptr == 35 ? (_Bool)1 : (_Bool)0;
    }
    while(tmp_if_expr$1);
    idx = 0;
    do
    {
      order[(signed long int)idx] = (signed int)*sptr - (signed int)65;
      if(!(order[(signed long int)idx] >= 0))
        tmp_if_expr$11 = (_Bool)1;

      else
        tmp_if_expr$11 = order[(signed long int)idx] > 25 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$11)
        order[(signed long int)idx] = 26;

      idx = idx + 1;
      sptr=strtok((char *)(void *)0, " \t\n");
    }
    while(!(sptr == ((char *)NULL)));
    nsymbols = idx;
    void *return_value_calloc$12;
    return_value_calloc$12=calloc((unsigned long int)27, sizeof(signed int *) /*8ul*/ );
    pam = (signed int **)return_value_calloc$12;
    if(pam == ((signed int **)NULL))
      Die("calloc failed");

    idx = 0;
    for( ; !(idx >= 27); idx = idx + 1)
    {
      return_value_calloc$13=calloc((unsigned long int)27, sizeof(signed int) /*4ul*/ );
      pam[(signed long int)idx] = (signed int *)return_value_calloc$13;
      if(pam[(signed long int)idx] == ((signed int *)NULL))
        Die("calloc failed");

    }
    row = 0;
    for( ; !(row >= nsymbols); row = row + 1)
    {
      char *return_value_fgets$14;
      return_value_fgets$14=fgets(buffer, 512, fp);
      if(return_value_fgets$14 == ((char *)NULL))
      {
        squid_errno = 2;
        return 0;
      }

      sptr=strtok(buffer, " \t\n");
      if(sptr == ((char *)NULL))
      {
        squid_errno = 2;
        return 0;
      }

      col = 0;
      for( ; !(col >= nsymbols); col = col + 1)
      {
        if(sptr == ((char *)NULL))
        {
          squid_errno = 2;
          return 0;
        }

        if((signed int)*sptr == 42)
          tmp_if_expr$16 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$15=__ctype_b_loc();
          tmp_if_expr$16 = ((signed int)(*return_value___ctype_b_loc$15)[(signed long int)(signed int)*sptr] & (signed int)(unsigned short int)1024) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$16)
          col = col - 1;

        else
          pam[(signed long int)order[(signed long int)row]][(signed long int)order[(signed long int)col]]=atoi(sptr);
        sptr=strtok((char *)(void *)0, " \t\n");
      }
    }
    if(!(ret_scale == ((float *)NULL)))
    {
      if(!(gotscale == 0))
        *ret_scale = scale;

      else
      {
        Warn("Failed to parse PAM matrix scale factor. Defaulting to ln(2)/2!");
        double return_value_log$17;
        return_value_log$17=log(2.0);
        *ret_scale = (float)(return_value_log$17 / 2.0);
      }
    }

    *ret_pam = pam;
    return 1;
  }
}

// Plan7ComlogAppend
// file funcs.h line 220
extern void Plan7ComlogAppend(struct plan7_s *hmm, signed int argc, char **argv)
{
  signed int len;
  signed int i;
  len = argc;
  i = 0;
  unsigned long int return_value_strlen$1;
  for( ; !(i >= argc); i = i + 1)
  {
    return_value_strlen$1=strlen(argv[(signed long int)i]);
    len = len + (signed int)return_value_strlen$1;
  }
  if(!(hmm->comlog == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(hmm->comlog);
    len = len + (signed int)return_value_strlen$2;
    void *return_value_sre_realloc$3;
    return_value_sre_realloc$3=sre_realloc("plan7.c", 295, (void *)hmm->comlog, sizeof(char) /*1ul*/  * (unsigned long int)(len + 1));
    hmm->comlog = (char *)return_value_sre_realloc$3;
  }

  else
  {
    void *return_value_sre_malloc$4;
    return_value_sre_malloc$4=sre_malloc("plan7.c", 299, sizeof(char) /*1ul*/  * (unsigned long int)(len + 1));
    hmm->comlog = (char *)return_value_sre_malloc$4;
    *hmm->comlog = (char)0;
  }
  strcat(hmm->comlog, "\n");
  i = 0;
  for( ; !(i >= argc); i = i + 1)
  {
    strcat(hmm->comlog, argv[(signed long int)i]);
    if(!(i >= argc + -1))
      strcat(hmm->comlog, " ");

  }
}

// Plan7ESTViterbi
// file core_algorithms.c line 1547
extern float Plan7ESTViterbi(unsigned char *dsq, signed int L, struct plan7_s *hmm, struct dpmatrix_s **ret_mx)
{
  struct dpmatrix_s *mx;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int i;
  signed int k;
  signed int sc;
  signed int codon;
  mx=AllocPlan7Matrix(L + 1, hmm->M, &xmx, &mmx, &imx, &dmx);
  xmx[(signed long int)0][(signed long int)4] = 0;
  xmx[(signed long int)0][(signed long int)0] = hmm->xsc[(signed long int)0][(signed long int)0];
  xmx[(signed long int)0][(signed long int)3] = -987654321;
  xmx[(signed long int)0][(signed long int)2] = xmx[(signed long int)0][(signed long int)3];
  xmx[(signed long int)0][(signed long int)1] = xmx[(signed long int)0][(signed long int)2];
  k = 0;
  for( ; hmm->M >= k; k = k + 1)
  {
    dmx[(signed long int)0][(signed long int)k] = -987654321;
    imx[(signed long int)0][(signed long int)k] = dmx[(signed long int)0][(signed long int)k];
    mmx[(signed long int)0][(signed long int)k] = imx[(signed long int)0][(signed long int)k];
  }
  xmx[(signed long int)1][(signed long int)4] = xmx[(signed long int)0][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1];
  xmx[(signed long int)1][(signed long int)0] = xmx[(signed long int)1][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0];
  xmx[(signed long int)0][(signed long int)3] = -987654321;
  xmx[(signed long int)0][(signed long int)2] = xmx[(signed long int)0][(signed long int)3];
  xmx[(signed long int)0][(signed long int)1] = xmx[(signed long int)0][(signed long int)2];
  k = 0;
  for( ; hmm->M >= k; k = k + 1)
  {
    dmx[(signed long int)0][(signed long int)k] = -987654321;
    imx[(signed long int)0][(signed long int)k] = dmx[(signed long int)0][(signed long int)k];
    mmx[(signed long int)0][(signed long int)k] = imx[(signed long int)0][(signed long int)k];
  }
  i = 2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  for( ; L >= i; i = i + 1)
  {
    dmx[(signed long int)i][(signed long int)0] = -987654321;
    imx[(signed long int)i][(signed long int)0] = dmx[(signed long int)i][(signed long int)0];
    mmx[(signed long int)i][(signed long int)0] = imx[(signed long int)i][(signed long int)0];
    if(i >= 3)
    {
      if(!((signed int)dsq[(signed long int)(i + -2)] >= 4))
        tmp_if_expr$1 = (signed int)dsq[(signed long int)(i - 1)] < 4 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (signed int)dsq[(signed long int)i] < 4 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        codon = (signed int)dsq[(signed long int)(i - 2)] * 16 + (signed int)dsq[(signed long int)(i - 1)] * 4 + (signed int)dsq[(signed long int)i];

      else
        codon = 64;
    }

    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      if(i >= 3)
      {
        mmx[(signed long int)i][(signed long int)k] = mmx[(signed long int)(i - 3)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)];
        sc = imx[(signed long int)(i - 3)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)];
        if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
          mmx[(signed long int)i][(signed long int)k] = sc;

        sc = xmx[(signed long int)(i - 3)][(signed long int)0] + hmm->bsc[(signed long int)k];
        if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
          mmx[(signed long int)i][(signed long int)k] = sc;

        sc = dmx[(signed long int)(i - 3)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)];
        if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
          mmx[(signed long int)i][(signed long int)k] = sc;

        mmx[(signed long int)i][(signed long int)k] = mmx[(signed long int)i][(signed long int)k] + hmm->dnam[(signed long int)codon][(signed long int)k];
      }

      sc = mmx[(signed long int)(i - 2)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)] + hmm->dna2;
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      sc = imx[(signed long int)(i - 2)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)] + hmm->dna2;
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      sc = xmx[(signed long int)(i - 2)][(signed long int)0] + hmm->bsc[(signed long int)k] + hmm->dna2;
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      sc = dmx[(signed long int)(i - 2)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)] + hmm->dna2;
      if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
        mmx[(signed long int)i][(signed long int)k] = sc;

      if(i >= 4)
      {
        sc = mmx[(signed long int)(i - 4)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)] + hmm->dna4;
        if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
          mmx[(signed long int)i][(signed long int)k] = sc;

        sc = imx[(signed long int)(i - 4)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)] + hmm->dna4;
        if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
          mmx[(signed long int)i][(signed long int)k] = sc;

        sc = xmx[(signed long int)(i - 4)][(signed long int)0] + hmm->bsc[(signed long int)k] + hmm->dna4;
        if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
          mmx[(signed long int)i][(signed long int)k] = sc;

        sc = dmx[(signed long int)(i - 4)][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)] + hmm->dna4;
        if(!(mmx[(signed long int)i][(signed long int)k] >= sc))
          mmx[(signed long int)i][(signed long int)k] = sc;

      }

      dmx[(signed long int)i][(signed long int)k] = mmx[(signed long int)i][(signed long int)(k - 1)] + hmm->tsc[(signed long int)2][(signed long int)(k - 1)];
      sc = dmx[(signed long int)i][(signed long int)(k - 1)] + hmm->tsc[(signed long int)6][(signed long int)(k - 1)];
      if(!(dmx[(signed long int)i][(signed long int)k] >= sc))
        dmx[(signed long int)i][(signed long int)k] = sc;

      if(i >= 3)
      {
        imx[(signed long int)i][(signed long int)k] = mmx[(signed long int)(i - 3)][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k];
        sc = imx[(signed long int)(i - 3)][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k];
        if(!(imx[(signed long int)i][(signed long int)k] >= sc))
          imx[(signed long int)i][(signed long int)k] = sc;

        imx[(signed long int)i][(signed long int)k] = imx[(signed long int)i][(signed long int)k] + hmm->dnai[(signed long int)codon][(signed long int)k];
      }

      sc = mmx[(signed long int)(i - 2)][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k] + hmm->dna2;
      if(!(imx[(signed long int)i][(signed long int)k] >= sc))
        imx[(signed long int)i][(signed long int)k] = sc;

      sc = imx[(signed long int)(i - 2)][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k] + hmm->dna2;
      if(!(imx[(signed long int)i][(signed long int)k] >= sc))
        imx[(signed long int)i][(signed long int)k] = sc;

      if(i >= 5)
      {
        sc = mmx[(signed long int)(i - 4)][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k] + hmm->dna4;
        if(!(imx[(signed long int)i][(signed long int)k] >= sc))
          imx[(signed long int)i][(signed long int)k] = sc;

        sc = imx[(signed long int)(i - 4)][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k] + hmm->dna4;
        if(!(imx[(signed long int)i][(signed long int)k] >= sc))
          imx[(signed long int)i][(signed long int)k] = sc;

      }

    }
    xmx[(signed long int)i][(signed long int)4] = xmx[(signed long int)(i - 1)][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1];
    xmx[(signed long int)i][(signed long int)1] = dmx[(signed long int)i][(signed long int)hmm->M];
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
    {
      sc = mmx[(signed long int)i][(signed long int)k] + hmm->esc[(signed long int)k];
      if(!(xmx[(signed long int)i][1l] >= sc))
        xmx[(signed long int)i][(signed long int)1] = sc;

    }
    xmx[(signed long int)i][(signed long int)3] = xmx[(signed long int)(i - 1)][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)1];
    sc = xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)1];
    if(!(xmx[(signed long int)i][3l] >= sc))
      xmx[(signed long int)i][(signed long int)3] = sc;

    xmx[(signed long int)i][(signed long int)0] = xmx[(signed long int)i][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0];
    sc = xmx[(signed long int)i][(signed long int)3] + hmm->xsc[(signed long int)3][(signed long int)0];
    if(!(*xmx[(signed long int)i] >= sc))
      xmx[(signed long int)i][(signed long int)0] = sc;

    xmx[(signed long int)i][(signed long int)2] = xmx[(signed long int)(i - 1)][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1];
    sc = xmx[(signed long int)i][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0];
    if(!(xmx[(signed long int)i][2l] >= sc))
      xmx[(signed long int)i][(signed long int)2] = sc;

  }
  sc = xmx[(signed long int)L][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)0];
  if(!(ret_mx == ((struct dpmatrix_s **)NULL)))
    *ret_mx = mx;

  else
    FreePlan7Matrix(mx);
  float return_value_Scorify$3;
  return_value_Scorify$3=Scorify(sc);
  return return_value_Scorify$3;
}

// Plan7FSConfig
// file plan7.c line 789
extern void Plan7FSConfig(struct plan7_s *hmm, float pentry, float pexit)
{
  float basep;
  signed int k;
  hmm->xt[(signed long int)0][(signed long int)0] = (float)1 - hmm->p1;
  hmm->xt[(signed long int)0][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)1][(signed long int)0] = (float)0.5;
  hmm->xt[(signed long int)1][(signed long int)1] = (float)0.5;
  hmm->xt[(signed long int)2][(signed long int)0] = (float)1 - hmm->p1;
  hmm->xt[(signed long int)2][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)3][(signed long int)0] = (float)(1. - (double)hmm->p1);
  hmm->xt[(signed long int)3][(signed long int)1] = hmm->p1;
  hmm->begin[(signed long int)1] = (float)((1. - (double)pentry) * (1. - (double)hmm->tbd1));
  FSet(hmm->begin + (signed long int)2, hmm->M - 1, (float)(((double)pentry * (1. - (double)hmm->tbd1)) / (double)(float)(hmm->M - 1)));
  hmm->end[(signed long int)hmm->M] = (float)1.0;
  basep = pexit / (float)(hmm->M - 1);
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
    hmm->end[(signed long int)k] = (float)((double)basep / (1. - (double)(basep * (float)(k - 1))));
  Plan7RenormalizeExits(hmm);
  hmm->flags = hmm->flags & ~(1 << 0);
}

// Plan7GlobalConfig
// file plan7.c line 665
extern void Plan7GlobalConfig(struct plan7_s *hmm)
{
  hmm->xt[(signed long int)0][(signed long int)0] = (float)(1. - (double)hmm->p1);
  hmm->xt[(signed long int)0][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)1][(signed long int)0] = (float)1.;
  hmm->xt[(signed long int)1][(signed long int)1] = (float)0.;
  hmm->xt[(signed long int)2][(signed long int)0] = (float)(1. - (double)hmm->p1);
  hmm->xt[(signed long int)2][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)3][(signed long int)0] = (float)0.;
  hmm->xt[(signed long int)3][(signed long int)1] = (float)1.;
  FSet(hmm->begin + (signed long int)2, hmm->M - 1, (float)0.);
  hmm->begin[(signed long int)1] = (float)(1. - (double)hmm->tbd1);
  FSet(hmm->end + (signed long int)1, hmm->M - 1, (float)0.);
  hmm->end[(signed long int)hmm->M] = (float)1.;
  Plan7RenormalizeExits(hmm);
  hmm->flags = hmm->flags & ~(1 << 0);
}

// Plan7LSConfig
// file funcs.h line 228
extern void Plan7LSConfig(struct plan7_s *hmm)
{
  hmm->xt[(signed long int)0][(signed long int)0] = (float)(1. - (double)hmm->p1);
  hmm->xt[(signed long int)0][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)1][(signed long int)0] = (float)0.5;
  hmm->xt[(signed long int)1][(signed long int)1] = (float)0.5;
  hmm->xt[(signed long int)2][(signed long int)0] = (float)(1. - (double)hmm->p1);
  hmm->xt[(signed long int)2][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)3][(signed long int)0] = (float)(1. - (double)hmm->p1);
  hmm->xt[(signed long int)3][(signed long int)1] = hmm->p1;
  FSet(hmm->begin + (signed long int)2, hmm->M - 1, (float)0.);
  hmm->begin[(signed long int)1] = (float)(1. - (double)hmm->tbd1);
  FSet(hmm->end + (signed long int)1, hmm->M - 1, (float)0.);
  hmm->end[(signed long int)hmm->M] = (float)1.;
  Plan7RenormalizeExits(hmm);
  hmm->flags = hmm->flags & ~(1 << 0);
}

// Plan7NakedConfig
// file plan7.c line 632
extern void Plan7NakedConfig(struct plan7_s *hmm)
{
  hmm->xt[(signed long int)0][(signed long int)0] = (float)1.;
  hmm->xt[(signed long int)0][(signed long int)1] = (float)0.;
  hmm->xt[(signed long int)1][(signed long int)0] = (float)1.;
  hmm->xt[(signed long int)1][(signed long int)1] = (float)0.;
  hmm->xt[(signed long int)2][(signed long int)0] = (float)1.;
  hmm->xt[(signed long int)2][(signed long int)1] = (float)0.;
  hmm->xt[(signed long int)3][(signed long int)0] = (float)0.;
  hmm->xt[(signed long int)3][(signed long int)1] = (float)1.;
  FSet(hmm->begin + (signed long int)2, hmm->M - 1, (float)0.);
  hmm->begin[(signed long int)1] = (float)(1. - (double)hmm->tbd1);
  FSet(hmm->end + (signed long int)1, hmm->M - 1, (float)0.);
  hmm->end[(signed long int)hmm->M] = (float)1.;
  Plan7RenormalizeExits(hmm);
  hmm->flags = hmm->flags & ~(1 << 0);
}

// Plan7Renormalize
// file funcs.h line 224
extern void Plan7Renormalize(struct plan7_s *hmm)
{
  signed int k;
  signed int st;
  float d;
  k = 1;
  for( ; hmm->M >= k; k = k + 1)
    FNorm(hmm->mat[(signed long int)k], Alphabet_size);
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
    FNorm(hmm->ins[(signed long int)k], Alphabet_size);
  float return_value_FSum$1;
  return_value_FSum$1=FSum(hmm->begin + (signed long int)1, hmm->M);
  d = return_value_FSum$1 + hmm->tbd1;
  FScale(hmm->begin + (signed long int)1, hmm->M, (float)(1. / (double)d));
  hmm->tbd1 = hmm->tbd1 / d;
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    float return_value_FSum$2;
    return_value_FSum$2=FSum(hmm->t[(signed long int)k], 3);
    d = return_value_FSum$2 + hmm->end[(signed long int)k];
    FScale(hmm->t[(signed long int)k], 3, (float)(1. / (double)d));
    hmm->end[(signed long int)k] = hmm->end[(signed long int)k] / d;
    FNorm(hmm->t[(signed long int)k] + (signed long int)3, 2);
    FNorm(hmm->t[(signed long int)k] + (signed long int)5, 2);
  }
  FNorm(hmm->null, Alphabet_size);
  st = 0;
  for( ; !(st >= 4); st = st + 1)
    FNorm(hmm->xt[(signed long int)st], 2);
  hmm->t[(signed long int)0][(signed long int)6] = (float)0.0;
  hmm->t[(signed long int)0][(signed long int)5] = hmm->t[(signed long int)0][(signed long int)6];
  hmm->flags = hmm->flags & ~(1 << 0);
  hmm->flags = hmm->flags | 1 << 5;
}

// Plan7RenormalizeExits
// file plan7.c line 580
extern void Plan7RenormalizeExits(struct plan7_s *hmm)
{
  signed int k;
  float d;
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    d=FSum(hmm->t[(signed long int)k], 3);
    FScale(hmm->t[(signed long int)k], 3, (float)(1. / (double)(d + d * hmm->end[(signed long int)k])));
  }
}

// Plan7SWConfig
// file plan7.c line 739
extern void Plan7SWConfig(struct plan7_s *hmm, float pentry, float pexit)
{
  float basep;
  signed int k;
  hmm->xt[(signed long int)0][(signed long int)0] = (float)1 - hmm->p1;
  hmm->xt[(signed long int)0][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)1][(signed long int)0] = (float)1.;
  hmm->xt[(signed long int)1][(signed long int)1] = (float)0.;
  hmm->xt[(signed long int)2][(signed long int)0] = (float)1 - hmm->p1;
  hmm->xt[(signed long int)2][(signed long int)1] = hmm->p1;
  hmm->xt[(signed long int)3][(signed long int)0] = (float)1.;
  hmm->xt[(signed long int)3][(signed long int)1] = (float)0.;
  hmm->begin[(signed long int)1] = (float)((1. - (double)pentry) * (1. - (double)hmm->tbd1));
  FSet(hmm->begin + (signed long int)2, hmm->M - 1, (float)(((double)pentry * (1. - (double)hmm->tbd1)) / (double)(float)(hmm->M - 1)));
  hmm->end[(signed long int)hmm->M] = (float)1.0;
  basep = pexit / (float)(hmm->M - 1);
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
    hmm->end[(signed long int)k] = (float)((double)basep / (1. - (double)(basep * (float)(k - 1))));
  Plan7RenormalizeExits(hmm);
  hmm->flags = hmm->flags & ~(1 << 0);
}

// Plan7SetAccession
// file funcs.h line 218
extern void Plan7SetAccession(struct plan7_s *hmm, char *acc)
{
  if(!(hmm->acc == ((char *)NULL)))
    free((void *)hmm->acc);

  hmm->acc=Strdup(acc);
  StringChop(hmm->acc);
  hmm->flags = hmm->flags | 1 << 9;
}

// Plan7SetCtime
// file funcs.h line 221
extern void Plan7SetCtime(struct plan7_s *hmm)
{
  signed long int date;
  date=time((signed long int *)(void *)0);
  if(!(hmm->ctime == ((char *)NULL)))
    free((void *)hmm->ctime);

  char *return_value_ctime$1;
  return_value_ctime$1=ctime(&date);
  hmm->ctime=Strdup(return_value_ctime$1);
  StringChop(hmm->ctime);
}

// Plan7SetDescription
// file funcs.h line 219
extern void Plan7SetDescription(struct plan7_s *hmm, char *desc)
{
  if(!(hmm->desc == ((char *)NULL)))
    free((void *)hmm->desc);

  hmm->desc=Strdup(desc);
  StringChop(hmm->desc);
  hmm->flags = hmm->flags | 1 << 1;
}

// Plan7SetName
// file funcs.h line 217
extern void Plan7SetName(struct plan7_s *hmm, char *name)
{
  if(!(hmm->name == ((char *)NULL)))
    free((void *)hmm->name);

  hmm->name=Strdup(name);
  StringChop(hmm->name);
}

// Plan7SetNullModel
// file plan7.c line 333
extern void Plan7SetNullModel(struct plan7_s *hmm, float *null, float p1)
{
  signed int x = 0;
  for( ; !(x >= Alphabet_size); x = x + 1)
    hmm->null[(signed long int)x] = null[(signed long int)x];
  hmm->p1 = p1;
}

// Plan9toPlan7
// file funcs.h line 234
extern void Plan9toPlan7(struct plan9_s *hmm, struct plan7_s **ret_plan7)
{
  struct plan7_s *plan7;
  signed int k;
  signed int x;
  plan7=AllocPlan7(hmm->M);
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    plan7->t[(signed long int)k][(signed long int)0] = (hmm->mat + (signed long int)k)->t[(signed long int)0];
    plan7->t[(signed long int)k][(signed long int)2] = (hmm->mat + (signed long int)k)->t[(signed long int)2];
    plan7->t[(signed long int)k][(signed long int)1] = (hmm->mat + (signed long int)k)->t[(signed long int)1];
    plan7->t[(signed long int)k][(signed long int)5] = (hmm->del + (signed long int)k)->t[(signed long int)0];
    plan7->t[(signed long int)k][(signed long int)6] = (hmm->del + (signed long int)k)->t[(signed long int)2];
    plan7->t[(signed long int)k][(signed long int)3] = (hmm->ins + (signed long int)k)->t[(signed long int)0];
    plan7->t[(signed long int)k][(signed long int)4] = (hmm->ins + (signed long int)k)->t[(signed long int)1];
  }
  k = 1;
  for( ; hmm->M >= k; k = k + 1)
  {
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      plan7->mat[(signed long int)k][(signed long int)x] = (hmm->mat + (signed long int)k)->p[(signed long int)x];
  }
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      plan7->ins[(signed long int)k][(signed long int)x] = (hmm->ins + (signed long int)k)->p[(signed long int)x];
  }
  plan7->tbd1 = (hmm->mat + (signed long int)0)->t[(signed long int)2] / ((hmm->mat + (signed long int)0)->t[(signed long int)2] + (hmm->mat + (signed long int)0)->t[(signed long int)0]);
  P7DefaultNullModel(plan7->null, &plan7->p1);
  x = 0;
  for( ; !(x >= Alphabet_size); x = x + 1)
    plan7->null[(signed long int)x] = hmm->null[(signed long int)x];
  if(!(hmm->name == ((char *)NULL)))
    Plan7SetName(plan7, hmm->name);

  if(!((1 & hmm->flags) == 0))
  {
    strcpy(plan7->rf, hmm->ref);
    plan7->flags = plan7->flags | 1 << 2;
  }

  if(!((2 & hmm->flags) == 0))
  {
    strcpy(plan7->cs, hmm->cs);
    plan7->flags = plan7->flags | 1 << 3;
  }

  Plan7LSConfig(plan7);
  Plan7Renormalize(plan7);
  plan7->flags = plan7->flags | 1 << 5;
  plan7->flags = plan7->flags & ~(1 << 0);
  *ret_plan7 = plan7;
}

// PopIntStack
// file sqfuncs.h line 237
extern signed int PopIntStack(struct intstack_s *stack, signed int *ret_data)
{
  struct intstack_s *old;
  if(stack->nxt == ((struct intstack_s *)NULL))
    return 0;

  else
  {
    old = stack->nxt;
    stack->nxt = old->nxt;
    *ret_data = old->data;
    free((void *)old);
    return 1;
  }
}

// PositionBasedWeights
// file weight.c line 463
extern void PositionBasedWeights(char **aseq, signed int nseq, signed int alen, float *wgt)
{
  signed int rescount[26l];
  signed int nres;
  signed int idx;
  signed int pos;
  signed int x;
  float norm;
  FSet(wgt, nseq, (float)0.0);
  pos = 0;
  const unsigned short int **return_value___ctype_b_loc$2;
  signed int return_value_toupper$1;
  const unsigned short int **return_value___ctype_b_loc$4;
  signed int return_value_toupper$3;
  for( ; !(pos >= alen); pos = pos + 1)
  {
    x = 0;
    for( ; !(x >= 26); x = x + 1)
      rescount[(signed long int)x] = 0;
    idx = 0;
    for( ; !(idx >= nseq); idx = idx + 1)
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)aseq[(signed long int)idx][(signed long int)pos]]) == 0))
      {
        return_value_toupper$1=toupper((signed int)aseq[(signed long int)idx][(signed long int)pos]);
        rescount[(signed long int)(return_value_toupper$1 - 65)] = rescount[(signed long int)(return_value_toupper$1 - 65)] + 1;
      }

    }
    nres = 0;
    x = 0;
    for( ; !(x >= 26); x = x + 1)
      if(rescount[(signed long int)x] >= 1)
        nres = nres + 1;

    idx = 0;
    for( ; !(idx >= nseq); idx = idx + 1)
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)aseq[(signed long int)idx][(signed long int)pos]]) == 0))
      {
        return_value_toupper$3=toupper((signed int)aseq[(signed long int)idx][(signed long int)pos]);
        wgt[(signed long int)idx] = wgt[(signed long int)idx] + (float)(1. / (double)(float)(nres * rescount[(signed long int)(return_value_toupper$3 - 65)]));
      }

    }
  }
  idx = 0;
  signed int return_value_DealignedLength$5;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    return_value_DealignedLength$5=DealignedLength(aseq[(signed long int)idx]);
    wgt[(signed long int)idx] = wgt[(signed long int)idx] / (float)return_value_DealignedLength$5;
  }
  float return_value_FSum$6;
  return_value_FSum$6=FSum(wgt, nseq);
  norm = (float)nseq / return_value_FSum$6;
  FScale(wgt, nseq, norm);
  goto __CPROVER_DUMP_L16;

__CPROVER_DUMP_L16:
  ;
}

// PostalCode
// file postprob.c line 685
extern char * PostalCode(signed int L, struct dpmatrix_s *mx, struct p7trace_s *tr)
{
  signed int tpos;
  signed int i;
  signed int k;
  char *postcode;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("postprob.c", 692, (unsigned long int)(L + 1) * sizeof(char) /*1ul*/ );
  postcode = (char *)return_value_sre_malloc$1;
  tpos = 0;
  for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
  {
    i = tr->pos[(signed long int)tpos];
    k = tr->nodeidx[(signed long int)tpos];
    if(!(i == 0))
      switch((signed int)tr->statetype[(signed long int)tpos])
      {
        case 1:
        {
          postcode[(signed long int)(i - 1)]=score2postcode(mx->mmx[(signed long int)i][(signed long int)k]);
          break;
        }
        case 3:
        {
          postcode[(signed long int)(i - 1)]=score2postcode(mx->imx[(signed long int)i][(signed long int)k]);
          break;
        }
        case 5:
        {
          postcode[(signed long int)(i - 1)]=score2postcode(mx->xmx[(signed long int)i][(signed long int)4]);
          break;
        }
        case 8:
        {
          postcode[(signed long int)(i - 1)]=score2postcode(mx->xmx[(signed long int)i][(signed long int)2]);
          break;
        }
        case 10:
          postcode[(signed long int)(i - 1)]=score2postcode(mx->xmx[(signed long int)i][(signed long int)3]);
      }

  }
  postcode[(signed long int)L] = (char)0;
  return postcode;
}

// PostprocessSignificantHit
// file core_algorithms.c line 2500
extern float PostprocessSignificantHit(struct tophit_s *ghit, struct tophit_s *dhit, struct p7trace_s *tr, struct plan7_s *hmm, unsigned char *dsq, signed int L, char *seqname, char *seqacc, char *seqdesc, signed int do_forward, float sc_override, signed int do_null2, struct threshold_s *thresh, signed int hmmpfam_mode)
{
  struct p7trace_s **tarr;
  struct fancyali_s *ali;
  signed int ntr;
  signed int tidx;
  signed int ndom;
  signed int didx;
  signed int k1;
  signed int k2;
  signed int i1;
  signed int i2;
  float whole_sc;
  float *score;
  signed int *usedomain;
  double whole_pval;
  double pvalue;
  double sortkey;
  float return_value_TraceScoreCorrection$3;
  char *tmp_if_expr$4;
  char *tmp_if_expr$5;
  char *tmp_if_expr$6;
  double tmp_if_expr$8;
  double return_value_log$7;
  char *tmp_if_expr$9;
  char *tmp_if_expr$10;
  char *tmp_if_expr$11;
  if(tr == ((struct p7trace_s *)NULL))
    return sc_override;

  else
  {
    TraceDecompose(tr, &tarr, &ntr);
    if(ntr == 0)
      Die("TraceDecompose() screwup");

    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("core_algorithms.c", 2544, sizeof(float) /*4ul*/  * (unsigned long int)ntr);
    score = (float *)return_value_sre_malloc$1;
    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("core_algorithms.c", 2545, sizeof(signed int) /*4ul*/  * (unsigned long int)ntr);
    usedomain = (signed int *)return_value_sre_malloc$2;
    ndom = 0;
    whole_sc = (float)0.;
    tidx = 0;
    for( ; !(tidx >= ntr); tidx = tidx + 1)
    {
      score[(signed long int)tidx]=P7TraceScore(hmm, dsq, tarr[(signed long int)tidx]);
      if(!(do_null2 == 0))
      {
        return_value_TraceScoreCorrection$3=TraceScoreCorrection(hmm, tarr[(signed long int)tidx], dsq);
        score[(signed long int)tidx] = score[(signed long int)tidx] - return_value_TraceScoreCorrection$3;
      }

      if(score[(signed long int)tidx] > 0.000000f)
      {
        usedomain[(signed long int)tidx] = 1;
        ndom = ndom + 1;
        whole_sc = whole_sc + score[(signed long int)tidx];
      }

      else
        usedomain[(signed long int)tidx] = 0;
    }
    if(ndom == 0)
    {
      tidx=FArgMax(score, ntr);
      usedomain[(signed long int)tidx] = 1;
      whole_sc = score[(signed long int)tidx];
      ndom = 1;
    }

    if(!(do_forward == 0))
      whole_sc = sc_override;

    whole_pval=PValue(hmm, whole_sc);
    tidx = 0;
    didx = 1;
    for( ; !(tidx >= ntr); tidx = tidx + 1)
      if(!(usedomain[(signed long int)tidx] == 0))
      {
        TraceSimpleBounds(tarr[(signed long int)tidx], &i1, &i2, &k1, &k2);
        pvalue=PValue(hmm, score[(signed long int)tidx]);
        if(pvalue <= thresh->domE)
        {
          if(score[(signed long int)tidx] >= thresh->domT)
          {
            ali=CreateFancyAli(tarr[(signed long int)tidx], hmm, dsq, seqname);
            if(!(hmmpfam_mode == 0))
              sortkey = -1. * (double)i1;

            else
              sortkey = (double)score[(signed long int)tidx];
            if(!(hmmpfam_mode == 0))
              tmp_if_expr$4 = hmm->name;

            else
              tmp_if_expr$4 = seqname;
            if(!(hmmpfam_mode == 0))
              tmp_if_expr$5 = hmm->acc;

            else
              tmp_if_expr$5 = seqacc;
            if(!(hmmpfam_mode == 0))
              tmp_if_expr$6 = hmm->desc;

            else
              tmp_if_expr$6 = seqdesc;
            RegisterHit(dhit, sortkey, pvalue, score[(signed long int)tidx], whole_pval, whole_sc, tmp_if_expr$4, tmp_if_expr$5, tmp_if_expr$6, i1, i2, L, k1, k2, hmm->M, didx, ndom, ali);
          }

        }

        didx = didx + 1;
      }

    if(!(hmmpfam_mode == 0))
    {
      if(whole_pval > 0.0)
      {
        return_value_log$7=log(whole_pval);
        tmp_if_expr$8 = -1. * return_value_log$7;
      }

      else
        tmp_if_expr$8 = 100000. + (double)whole_sc;
      sortkey = tmp_if_expr$8;
    }

    else
      sortkey = (double)whole_sc;
    if(whole_sc >= thresh->globT)
    {
      if(!(hmmpfam_mode == 0))
        tmp_if_expr$9 = hmm->name;

      else
        tmp_if_expr$9 = seqname;
      if(!(hmmpfam_mode == 0))
        tmp_if_expr$10 = hmm->acc;

      else
        tmp_if_expr$10 = seqacc;
      if(!(hmmpfam_mode == 0))
        tmp_if_expr$11 = hmm->desc;

      else
        tmp_if_expr$11 = seqdesc;
      RegisterHit(ghit, sortkey, whole_pval, whole_sc, 0., (float)0., tmp_if_expr$9, tmp_if_expr$10, tmp_if_expr$11, 0, 0, 0, 0, 0, 0, 0, ndom, (struct fancyali_s *)(void *)0);
    }

    tidx = 0;
    for( ; !(tidx >= ntr); tidx = tidx + 1)
      P7FreeTrace(tarr[(signed long int)tidx]);
    free((void *)tarr);
    free((void *)score);
    free((void *)usedomain);
    return whole_sc;
  }
}

// PrintASCIIHistogram
// file funcs.h line 126
extern void PrintASCIIHistogram(struct _IO_FILE *fp, struct histogram_s *h)
{
  signed int units;
  signed int maxbar;
  signed int num;
  signed int i;
  signed int idx;
  char buffer[81l];
  signed int pos;
  signed int lowbound;
  signed int lowcount;
  signed int highbound;
  signed int highcount;
  signed int emptybins = 3;
  maxbar = 0;
  i = h->lowscore - h->min;
  for( ; h->highscore + -h->min >= i; i = i + 1)
    if(!(maxbar >= h->histogram[(signed long int)i]))
    {
      maxbar = h->histogram[(signed long int)i];
      lowbound = i + h->min;
    }

  highbound = lowbound;
  num = 0;
  for( ; !(h->lowscore >= lowbound); lowbound = lowbound - 1)
  {
    i = lowbound - h->min;
    if(h->histogram[(signed long int)i] >= 1)
      num = 0;

    else
    {
      num = num + 1;
      if(num == emptybins)
      {
        lowbound = lowbound + emptybins;
        break;
      }

    }
  }
  num = 0;
  for( ; !(highbound >= h->highscore); highbound = highbound + 1)
  {
    i = highbound - h->min;
    if(h->histogram[(signed long int)i] >= 1)
      num = 0;

    else
    {
      num = num + 1;
      if(num == emptybins)
      {
        highbound = highbound - emptybins;
        break;
      }

    }
  }
  lowcount = 0;
  i = h->lowscore - h->min;
  for( ; lowbound + -h->min >= i; i = i + 1)
    lowcount = lowcount + h->histogram[(signed long int)i];
  highcount = 0;
  i = h->highscore - h->min;
  for( ; i >= highbound + -h->min; i = i - 1)
    highcount = highcount + h->histogram[(signed long int)i];
  if(!(maxbar >= lowcount))
    maxbar = lowcount;

  if(!(maxbar >= highcount))
    maxbar = highcount;

  units = (maxbar - 1) / 59 + 1;
  fprintf(fp, "%5s %6s %6s  (one = represents %d sequences)\n", (const void *)"score", (const void *)"obs", (const void *)"exp", units);
  fprintf(fp, "%5s %6s %6s\n", (const void *)"-----", (const void *)"---", (const void *)"---");
  buffer[(signed long int)80] = (char)0;
  buffer[(signed long int)79] = (char)10;
  i = h->lowscore;
  _Bool tmp_if_expr$3;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$4;
  for( ; h->highscore >= i; i = i + 1)
  {
    memset((void *)buffer, 32, (unsigned long int)79 * sizeof(char) /*1ul*/ );
    idx = i - h->min;
    if(!(i >= lowbound))
      goto __CPROVER_DUMP_L36;

    else
      if(!(highbound >= i))
        goto __CPROVER_DUMP_L36;

      else
      {
        if(i == lowbound)
          tmp_if_expr$3 = i != h->lowscore ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          sprintf(buffer, "<%4d %6d %6s|", i + 1, lowcount, (const void *)"-");
          if(lowcount >= 1)
          {
            num = 1 + (lowcount - 1) / units;
            if(num >= 61)
              Die("oops");

            pos = 20;
            for( ; num >= 1; num = num - 1)
            {
              tmp_post$1 = pos;
              pos = pos + 1;
              buffer[(signed long int)tmp_post$1] = (char)61;
            }
          }

          fputs(buffer, fp);
          goto __CPROVER_DUMP_L36;
        }

        else
          if(i == highbound)
          {
            if(!(i == h->highscore))
            {
              sprintf(buffer, ">%4d %6d %6s|", i, highcount, (const void *)"-");
              if(highcount >= 1)
              {
                num = 1 + (highcount - 1) / units;
                pos = 20;
                for( ; num >= 1; num = num - 1)
                {
                  tmp_post$2 = pos;
                  pos = pos + 1;
                  buffer[(signed long int)tmp_post$2] = (char)61;
                }
              }

              fputs(buffer, fp);
              goto __CPROVER_DUMP_L36;
            }

          }

      }
    if(!(h->fit_type == 0))
      sprintf(buffer, "%5d %6d %6d|", i, h->histogram[(signed long int)idx], (signed int)h->expect[(signed long int)idx]);

    else
      sprintf(buffer, "%5d %6d %6s|", i, h->histogram[(signed long int)idx], (const void *)"-");
    buffer[(signed long int)20] = (char)32;
    if(h->histogram[(signed long int)idx] >= 1)
    {
      num = 1 + (h->histogram[(signed long int)idx] - 1) / units;
      pos = 20;
      for( ; num >= 1; num = num - 1)
      {
        tmp_post$4 = pos;
        pos = pos + 1;
        buffer[(signed long int)tmp_post$4] = (char)61;
      }
    }

    if(!(h->fit_type == 0))
    {
      if((signed int)h->expect[(signed long int)idx] >= 1)
      {
        pos = 20 + (signed int)(h->expect[(signed long int)idx] - (float)1) / units;
        if(pos >= 78)
          pos = 78;

        buffer[(signed long int)pos] = (char)42;
      }

    }

    fputs(buffer, fp);

  __CPROVER_DUMP_L36:
    ;
  }
  switch(h->fit_type)
  {
    case 0:
    {
      fprintf(fp, "\n\n%% No statistical fit available\n");
      break;
    }
    case 1:
    {
      fprintf(fp, "\n\n%% Statistical details of theoretical EVD fit:\n");
      fprintf(fp, "              mu = %10.4f\n", h->param[(signed long int)0]);
      fprintf(fp, "          lambda = %10.4f\n", h->param[(signed long int)1]);
      fprintf(fp, "chi-sq statistic = %10.4f\n", h->chisq);
      fprintf(fp, "  P(chi-square)  = %10.4g\n", h->chip);
      break;
    }
    case 2:
    {
      fprintf(fp, "\n\n%% Statistical details of theoretical Gaussian fit:\n");
      fprintf(fp, "            mean = %10.4f\n", h->param[(signed long int)0]);
      fprintf(fp, "              sd = %10.4f\n", h->param[(signed long int)1]);
      fprintf(fp, "chi-sq statistic = %10.4f\n", h->chisq);
      fprintf(fp, "  P(chi-square)  = %10.4g\n", h->chip);
    }
  }
  goto __CPROVER_DUMP_L42;

__CPROVER_DUMP_L42:
  ;
}

// PrintFancyAli
// file trace.c line 809
extern void PrintFancyAli(struct _IO_FILE *fp, struct fancyali_s *ali)
{
  char buffer[51l];
  signed int starti;
  signed int endi;
  signed int pos;
  signed int i;
  buffer[(signed long int)50] = (char)0;
  endi = ali->sqfrom - 1;
  pos = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  for( ; !(pos >= ali->len); pos = pos + 50)
  {
    starti = endi + 1;
    i = pos;
    for( ; !((signed int)ali->aseq[(signed long int)i] == 0) && !(i >= 50 + pos); i = i + 1)
    {
      if((signed int)ali->aseq[(signed long int)i] == 32)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)ali->aseq[(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)ali->aseq[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)ali->aseq[(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)ali->aseq[(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$4)
        endi = endi + 1;

    }
    if(!(ali->csline == ((char *)NULL)))
    {
      strncpy(buffer, ali->csline + (signed long int)pos, (unsigned long int)50);
      fprintf(fp, "  %16s %s\n", (const void *)"CS", (const void *)buffer);
    }

    if(!(ali->rfline == ((char *)NULL)))
    {
      strncpy(buffer, ali->rfline + (signed long int)pos, (unsigned long int)50);
      fprintf(fp, "  %16s %s\n", (const void *)"RF", (const void *)buffer);
    }

    if(!(ali->model == ((char *)NULL)))
    {
      strncpy(buffer, ali->model + (signed long int)pos, (unsigned long int)50);
      fprintf(fp, "  %16s %s\n", (const void *)" ", (const void *)buffer);
    }

    if(!(ali->mline == ((char *)NULL)))
    {
      strncpy(buffer, ali->mline + (signed long int)pos, (unsigned long int)50);
      fprintf(fp, "  %16s %s\n", (const void *)" ", (const void *)buffer);
    }

    if(!(ali->aseq == ((char *)NULL)))
    {
      strncpy(buffer, ali->aseq + (signed long int)pos, (unsigned long int)50);
      if(endi >= starti)
        fprintf(fp, "  %10.10s %5d %s %-5d\n\n", ali->target, starti, (const void *)buffer, endi);

      else
        fprintf(fp, "  %10.10s %5s %s %-5s\n\n", ali->target, (const void *)"-", (const void *)buffer, (const void *)"-");
    }

  }
  fflush(fp);
  goto __CPROVER_DUMP_L20;

__CPROVER_DUMP_L20:
  ;
}

// PrintIscore
// file display.c line 331
void PrintIscore(signed int sc)
{
  double dsc;
  double div;
  dsc = (double)sc;
  div = 1000.0 / 0.693147180559945;
  dsc = dsc / div;
  printf("%- #11.3e", dsc);
}

// PrintNewHampshireTree
// file cluster.c line 457
extern void PrintNewHampshireTree(struct _IO_FILE *fp, struct aliinfo_s *ainfo, struct phylo_s *tree, signed int N)
{
  struct intstack_s *stack;
  signed int code;
  float *blen;
  signed int docomma;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("cluster.c", 464, sizeof(float) /*4ul*/  * (unsigned long int)(2 * N - 1));
  blen = (float *)return_value_sre_malloc$1;
  stack=InitIntStack();
  PushIntStack(stack, N);
  docomma = 0;
  signed int return_value_PopIntStack$2;
  do
  {
    return_value_PopIntStack$2=PopIntStack(stack, &code);
    if(return_value_PopIntStack$2 == 0)
      break;

    if(!(code >= N))
    {
      if(!(docomma == 0))
        fputs(",", fp);

      fprintf(fp, "%s:%.5f", (const void *)(ainfo->sqinfo + (signed long int)code)->name, blen[(signed long int)code]);
      docomma = 1;
    }

    else
      if(!(code >= 2 * N))
      {
        if(!(docomma == 0))
          fputs(",\n", fp);

        fputs("(", fp);
        PushIntStack(stack, code + N);
        PushIntStack(stack, (tree + (signed long int)(code - N))->right);
        PushIntStack(stack, (tree + (signed long int)(code - N))->left);
        blen[(signed long int)(tree + (signed long int)(code - N))->right] = (tree + (signed long int)(code - N))->rblen;
        blen[(signed long int)(tree + (signed long int)(code - N))->left] = (tree + (signed long int)(code - N))->lblen;
        docomma = 0;
      }

      else
      {
        if(code == 2 * N)
          fprintf(fp, ");\n");

        else
          fprintf(fp, "):%.5f", blen[(signed long int)(code - N)]);
        docomma = 1;
      }
  }
  while((_Bool)1);
  FreeIntStack(stack);
  free((void *)blen);
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// PrintPhylo
// file cluster.c line 520
extern void PrintPhylo(struct _IO_FILE *fp, struct aliinfo_s *ainfo, struct phylo_s *tree, signed int N)
{
  signed int idx = 0;
  signed int tmp_if_expr$1;
  char *tmp_if_expr$2;
  signed int tmp_if_expr$3;
  char *tmp_if_expr$4;
  for( ; !(idx >= N + -1); idx = idx + 1)
  {
    fprintf(fp, "Interior node %d (code %d)\n", idx, idx + N);
    fprintf(fp, "\tParent: %d (code %d)\n", (tree + (signed long int)idx)->parent - N, (tree + (signed long int)idx)->parent);
    if(!((tree + (signed long int)idx)->left >= N))
      tmp_if_expr$1 = (tree + (signed long int)idx)->left - N;

    else
      tmp_if_expr$1 = (tree + (signed long int)idx)->left;
    if(!((tree + (signed long int)idx)->left >= N))
      tmp_if_expr$2 = (ainfo->sqinfo + (signed long int)(tree + (signed long int)idx)->left)->name;

    else
      tmp_if_expr$2 = "interior";
    fprintf(fp, "\tLeft:   %d (%s) %f\n", tmp_if_expr$1, tmp_if_expr$2, (tree + (signed long int)idx)->lblen);
    if(!((tree + (signed long int)idx)->right >= N))
      tmp_if_expr$3 = (tree + (signed long int)idx)->right - N;

    else
      tmp_if_expr$3 = (tree + (signed long int)idx)->right;
    if(!((tree + (signed long int)idx)->right >= N))
      tmp_if_expr$4 = (ainfo->sqinfo + (signed long int)(tree + (signed long int)idx)->right)->name;

    else
      tmp_if_expr$4 = "interior";
    fprintf(fp, "\tRight:   %d (%s) %f\n", tmp_if_expr$3, tmp_if_expr$4, (tree + (signed long int)idx)->rblen);
    fprintf(fp, "\tHeight:  %f\n", (tree + (signed long int)idx)->diff);
    fprintf(fp, "\tIncludes:%d seqs\n", (tree + (signed long int)idx)->incnum);
  }
}

// PrintPlan7Stats
// file plan7.c line 896
extern void PrintPlan7Stats(struct _IO_FILE *fp, struct plan7_s *hmm, unsigned char **dsq, signed int nseq, struct p7trace_s **tr)
{
  signed int idx;
  float score;
  float total;
  float best;
  float worst;
  float sqsum;
  float stddev;
  P7Logoddsify(hmm, 1);
  score=P7TraceScore(hmm, dsq[(signed long int)0], tr[(signed long int)0]);
  worst = score;
  best = worst;
  total = best;
  sqsum = score * score;
  idx = 1;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    score=P7TraceScore(hmm, dsq[(signed long int)idx], tr[(signed long int)idx]);
    total = total + score;
    sqsum = sqsum + score * score;
    if(score > best)
      best = score;

    if(score < worst)
      worst = score;

  }
  double tmp_if_expr$2;
  double return_value_sqrt$1;
  if(nseq >= 2)
  {
    stddev = (float)((double)(sqsum - (total * total) / (float)nseq) / ((double)(float)nseq - 1.));
    if(stddev > 0.000000f)
    {
      return_value_sqrt$1=sqrt((double)stddev);
      tmp_if_expr$2 = return_value_sqrt$1;
    }

    else
      tmp_if_expr$2 = 0.0;
    stddev = (float)tmp_if_expr$2;
  }

  else
    stddev = (float)0.0;
  fprintf(fp, "Average score:  %10.2f bits\n", total / (float)nseq);
  fprintf(fp, "Minimum score:  %10.2f bits\n", worst);
  fprintf(fp, "Maximum score:  %10.2f bits\n", best);
  fprintf(fp, "Std. deviation: %10.2f bits\n", stddev);
}

// PrintTransition
// file display.c line 341
void PrintTransition(char src, signed int isrc, signed int ksrc, char dest, signed int idest, signed int kdest, signed int sc, struct p7trace_s **alignment, signed int *min, signed int *max, signed int *on, signed int A)
{
  char src_str[6l];
  char dest_str[6l];
  signed int j;
  signed int tpos;
  signed int tnext;
  signed int pos;
  signed int next;
  signed int near = 0;
  j = 0;
  for( ; !(j >= A); j = j + 1)
  {
    on[(signed long int)j] = 0;
    pos = 0;
    tpos = min[(signed long int)j];
    for( ; max[(signed long int)j] >= tpos; tpos = tpos + 1)
    {
      if(!(alignment[(signed long int)j]->pos[(signed long int)tpos] == 0))
        pos = alignment[(signed long int)j]->pos[(signed long int)tpos];

      if(src == alignment[(signed long int)j]->statetype[(signed long int)tpos])
      {
        if(ksrc == alignment[(signed long int)j]->nodeidx[(signed long int)tpos])
        {
          if(isrc == pos)
            near = 1;

        }

      }

      if(dest == alignment[(signed long int)j]->statetype[(signed long int)tpos])
      {
        if(kdest == alignment[(signed long int)j]->nodeidx[(signed long int)tpos])
        {
          if(idest == pos)
            near = 1;

        }

      }

      if(!(tpos >= alignment[(signed long int)j]->tlen + -1))
      {
        tnext = tpos + 1;
        if((signed int)alignment[(signed long int)j]->statetype[(signed long int)tpos] == 6)
          for( ; (signed int)alignment[(signed long int)j]->statetype[(signed long int)tnext] == 2; tnext = tnext + 1)
            if(tnext >= alignment[(signed long int)j]->tlen + -1)
              break;


        next = alignment[(signed long int)j]->pos[(signed long int)tnext];
        if(next == 0)
          next = pos;

        if(src == alignment[(signed long int)j]->statetype[(signed long int)tpos])
        {
          if(ksrc == alignment[(signed long int)j]->nodeidx[(signed long int)tpos])
          {
            if(isrc == pos)
            {
              if(dest == alignment[(signed long int)j]->statetype[(signed long int)tnext])
              {
                if(kdest == alignment[(signed long int)j]->nodeidx[(signed long int)tnext])
                {
                  if(idest == next)
                    on[(signed long int)j] = 1;

                }

              }

            }

          }

        }

      }

    }
  }
  if(!(near == 0))
  {
    switch((signed int)src)
    {
      case 1:
      {
        sprintf(src_str, "M%d", ksrc);
        break;
      }
      case 2:
      {
        sprintf(src_str, "D%d", ksrc);
        break;
      }
      case 3:
      {
        sprintf(src_str, "I%d", ksrc);
        break;
      }
      case 4:
      {
        sprintf(src_str, "S");
        break;
      }
      case 5:
      {
        sprintf(src_str, "N");
        break;
      }
      case 6:
      {
        sprintf(src_str, "B");
        break;
      }
      case 7:
      {
        sprintf(src_str, "E");
        break;
      }
      case 8:
      {
        sprintf(src_str, "C");
        break;
      }
      case 10:
      {
        sprintf(src_str, "J");
        break;
      }
      case 9:
      {
        sprintf(src_str, "T");
        break;
      }
      default:
        Die("bad transition");
    }
    switch((signed int)dest)
    {
      case 1:
      {
        sprintf(dest_str, "M%d", kdest);
        break;
      }
      case 2:
      {
        sprintf(dest_str, "D%d", kdest);
        break;
      }
      case 3:
      {
        sprintf(dest_str, "I%d", kdest);
        break;
      }
      case 4:
      {
        sprintf(dest_str, "S");
        break;
      }
      case 5:
      {
        sprintf(dest_str, "N");
        break;
      }
      case 6:
      {
        sprintf(dest_str, "B");
        break;
      }
      case 7:
      {
        sprintf(dest_str, "E");
        break;
      }
      case 8:
      {
        sprintf(dest_str, "C");
        break;
      }
      case 10:
      {
        sprintf(dest_str, "J");
        break;
      }
      case 9:
      {
        sprintf(dest_str, "T");
        break;
      }
      default:
        Die("bad transition");
    }
    float return_value_Score2Prob$1;
    return_value_Score2Prob$1=Score2Prob(sc, (float)1.);
    printf("%d\t%s\t%d\t%s\t%-14.7g\t", isrc, (const void *)src_str, idest, (const void *)dest_str, (double)return_value_Score2Prob$1);
    j = 0;
    for( ; !(j >= A); j = j + 1)
    {
      if(!(on[(signed long int)j] == 0))
        printf("*");

      if(!(j >= A + -1))
        printf("\t");

    }
    printf("\n");
  }

}

// PrintXMGRDistribution
// file histogram.c line 384
extern void PrintXMGRDistribution(struct _IO_FILE *fp, struct histogram_s *h)
{
  signed int sc;
  signed int cum;
  double val;
  cum = 0;
  sc = h->lowscore;
  for( ; h->highscore >= sc; sc = sc + 1)
  {
    cum = cum + h->histogram[(signed long int)(sc - h->min)];
    fprintf(fp, "%-6d %f\n", sc + 1, (float)cum / (float)h->total);
  }
  fprintf(fp, "&\n");
  if(!(h->fit_type == 0))
  {
    sc = h->lowscore;
    for( ; h->highscore >= sc; sc = sc + 1)
    {
      double return_value_ExtremeValueP$1;
      return_value_ExtremeValueP$1=ExtremeValueP((float)sc, h->param[(signed long int)0], h->param[(signed long int)1]);
      val = 1. - return_value_ExtremeValueP$1;
      fprintf(fp, "%-6d %f\n", sc, val);
    }
    fprintf(fp, "&\n");
  }

}

// PrintXMGRHistogram
// file histogram.c line 348
extern void PrintXMGRHistogram(struct _IO_FILE *fp, struct histogram_s *h)
{
  signed int sc;
  double val;
  sc = h->lowscore;
  for( ; h->highscore >= sc; sc = sc + 1)
    if(h->histogram[(signed long int)(sc + -h->min)] >= 1)
      fprintf(fp, "%-6d %f\n", sc, (float)h->histogram[(signed long int)(sc - h->min)] / (float)h->total);

  fprintf(fp, "&\n");
  if(!(h->fit_type == 0))
  {
    sc = h->lowscore;
    for( ; h->highscore >= sc; sc = sc + 1)
    {
      double return_value_ExtremeValueP$1;
      return_value_ExtremeValueP$1=ExtremeValueP((float)sc + (float)1, h->param[(signed long int)0], h->param[(signed long int)1]);
      double return_value_ExtremeValueP$2;
      return_value_ExtremeValueP$2=ExtremeValueP((float)sc, h->param[(signed long int)0], h->param[(signed long int)1]);
      val = (1. - return_value_ExtremeValueP$1) - (1. - return_value_ExtremeValueP$2);
      fprintf(fp, "%-6d %f\n", sc, val);
    }
    fprintf(fp, "&\n");
  }

}

// PrintXMGRRegressionLine
// file histogram.c line 423
extern void PrintXMGRRegressionLine(struct _IO_FILE *fp, struct histogram_s *h)
{
  signed int sc;
  signed int cum;
  double val;
  cum = 0;
  sc = h->lowscore;
  for( ; h->highscore >= sc; sc = sc + 1)
  {
    cum = cum + h->histogram[(signed long int)(sc - h->min)];
    double return_value_log$1;
    return_value_log$1=log((double)cum / (double)h->total);
    val=log(-1. * return_value_log$1);
    if(!(cum >= h->total))
      fprintf(fp, "%-6d %f\n", sc + 1, val);

  }
  fprintf(fp, "&\n");
  if(!(h->fit_type == 0))
  {
    sc = h->lowscore;
    for( ; h->highscore >= sc; sc = sc + 1)
    {
      double return_value_ExtremeValueP$2;
      return_value_ExtremeValueP$2=ExtremeValueP((float)sc, h->param[(signed long int)0], h->param[(signed long int)1]);
      double return_value_log$3;
      return_value_log$3=log(1. - return_value_ExtremeValueP$2);
      val=log(-1. * return_value_log$3);
      fprintf(fp, "%-6d %f\n", sc, val);
    }
    fprintf(fp, "&\n");
  }

}

// Prob2Score
// file funcs.h line 174
extern signed int Prob2Score(float p, float null)
{
  double tmp_if_expr$2;
  double return_value_log$1;
  double return_value_floor$3;
  if(IEEE_FLOAT_EQUAL((double)p, 0.0))
    return -987654321;

  else
  {
    if(p / null > 0.000000f)
    {
      return_value_log$1=log((double)(p / null));
      tmp_if_expr$2 = return_value_log$1 * 1.44269504;
    }

    else
      tmp_if_expr$2 = -9999.;
    return_value_floor$3=floor(0.5 + 1000.0 * tmp_if_expr$2);
    return (signed int)return_value_floor$3;
  }
}

// PushIntStack
// file sqfuncs.h line 236
extern void PushIntStack(struct intstack_s *stack, signed int data)
{
  struct intstack_s *new;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct intstack_s) /*16ul*/ );
  new = (struct intstack_s *)return_value_malloc$1;
  if(new == ((struct intstack_s *)NULL))
    Die("Memory allocation failure at %s line %d", (const void *)"stack.c", 52);

  new->data = data;
  new->nxt = stack->nxt;
  stack->nxt = new;
}

// QRNAShuffle
// file shuffle.c line 555
extern signed int QRNAShuffle(char *xs, char *ys, char *x, char *y)
{
  signed int L;
  signed int *xycol;
  signed int *xcol;
  signed int *ycol;
  signed int nxy;
  signed int nx;
  signed int ny;
  signed int i;
  signed int pos;
  signed int c;
  char xsym;
  char ysym;
  if(!(xs == x))
    strcpy(xs, x);

  if(!(ys == y))
    strcpy(ys, y);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(x);
  L = (signed int)return_value_strlen$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("shuffle.c", 572, sizeof(signed int) /*4ul*/  * (unsigned long int)L);
  xycol = (signed int *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("shuffle.c", 573, sizeof(signed int) /*4ul*/  * (unsigned long int)L);
  xcol = (signed int *)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("shuffle.c", 574, sizeof(signed int) /*4ul*/  * (unsigned long int)L);
  ycol = (signed int *)return_value_sre_malloc$4;
  ny = 0;
  nx = ny;
  nxy = nx;
  i = 0;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$24;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$30;
  _Bool tmp_if_expr$26;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  for( ; !(i >= L); i = i + 1)
  {
    if((signed int)x[(signed long int)i] == 32)
      tmp_if_expr$22 = (_Bool)1;

    else
      tmp_if_expr$22 = (signed int)x[(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$22)
      tmp_if_expr$23 = (_Bool)1;

    else
      tmp_if_expr$23 = (signed int)x[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$23)
      tmp_if_expr$24 = (_Bool)1;

    else
      tmp_if_expr$24 = (signed int)x[(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$24)
      tmp_if_expr$25 = (_Bool)1;

    else
      tmp_if_expr$25 = (signed int)x[(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$25)
    {
      if((signed int)y[(signed long int)i] == 32)
        tmp_if_expr$26 = (_Bool)1;

      else
        tmp_if_expr$26 = (signed int)y[(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$26)
        tmp_if_expr$27 = (_Bool)1;

      else
        tmp_if_expr$27 = (signed int)y[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$27)
        tmp_if_expr$28 = (_Bool)1;

      else
        tmp_if_expr$28 = (signed int)y[(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$28)
        tmp_if_expr$29 = (_Bool)1;

      else
        tmp_if_expr$29 = (signed int)y[(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$30 = tmp_if_expr$29 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$30 = (_Bool)0;
    if(tmp_if_expr$30)
      goto __CPROVER_DUMP_L59;

    else
    {
      if((signed int)x[(signed long int)i] == 32)
        tmp_if_expr$13 = (_Bool)1;

      else
        tmp_if_expr$13 = (signed int)x[(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$13)
        tmp_if_expr$14 = (_Bool)1;

      else
        tmp_if_expr$14 = (signed int)x[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$14)
        tmp_if_expr$15 = (_Bool)1;

      else
        tmp_if_expr$15 = (signed int)x[(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$15)
        tmp_if_expr$16 = (_Bool)1;

      else
        tmp_if_expr$16 = (signed int)x[(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$16)
      {
        if((signed int)y[(signed long int)i] == 32)
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = (signed int)y[(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = (signed int)y[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$18)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = (signed int)y[(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$19)
          tmp_if_expr$20 = (_Bool)1;

        else
          tmp_if_expr$20 = (signed int)y[(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$21 = !tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$21 = (_Bool)0;
      if(tmp_if_expr$21)
      {
        xycol[(signed long int)nxy] = i;
        nxy = nxy + 1;
      }

      else
      {
        if((signed int)x[(signed long int)i] == 32)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = (signed int)x[(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
          tmp_if_expr$10 = (_Bool)1;

        else
          tmp_if_expr$10 = (signed int)x[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$10)
          tmp_if_expr$11 = (_Bool)1;

        else
          tmp_if_expr$11 = (signed int)x[(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$11)
          tmp_if_expr$12 = (_Bool)1;

        else
          tmp_if_expr$12 = (signed int)x[(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$12)
        {
          ycol[(signed long int)ny] = i;
          ny = ny + 1;
        }

        else
        {
          if((signed int)y[(signed long int)i] == 32)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = (signed int)y[(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = (signed int)y[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$6)
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = (signed int)y[(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
            tmp_if_expr$8 = (_Bool)1;

          else
            tmp_if_expr$8 = (signed int)y[(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$8)
          {
            xcol[(signed long int)nx] = i;
            nx = nx + 1;
          }

        }
      }
    }

  __CPROVER_DUMP_L59:
    ;
  }
  for( ; nxy >= 2; nxy = nxy - 1)
  {
    double return_value_sre_random$31;
    return_value_sre_random$31=sre_random();
    pos = (signed int)(return_value_sre_random$31 * (double)nxy);
    xsym = xs[(signed long int)xycol[(signed long int)pos]];
    ysym = ys[(signed long int)xycol[(signed long int)pos]];
    c = xycol[(signed long int)pos];
    xs[(signed long int)xycol[(signed long int)pos]] = xs[(signed long int)xycol[(signed long int)(nxy - 1)]];
    ys[(signed long int)xycol[(signed long int)pos]] = ys[(signed long int)xycol[(signed long int)(nxy - 1)]];
    xycol[(signed long int)pos] = xycol[(signed long int)(nxy - 1)];
    xs[(signed long int)xycol[(signed long int)(nxy - 1)]] = xsym;
    ys[(signed long int)xycol[(signed long int)(nxy - 1)]] = ysym;
    xycol[(signed long int)pos] = xycol[(signed long int)(nxy - 1)];
  }
  for( ; nx >= 2; nx = nx - 1)
  {
    double return_value_sre_random$32;
    return_value_sre_random$32=sre_random();
    pos = (signed int)(return_value_sre_random$32 * (double)nx);
    xsym = xs[(signed long int)xcol[(signed long int)pos]];
    ysym = ys[(signed long int)xcol[(signed long int)pos]];
    c = xcol[(signed long int)pos];
    xs[(signed long int)xcol[(signed long int)pos]] = xs[(signed long int)xcol[(signed long int)(nx - 1)]];
    ys[(signed long int)xcol[(signed long int)pos]] = ys[(signed long int)xcol[(signed long int)(nx - 1)]];
    xcol[(signed long int)pos] = xcol[(signed long int)(nx - 1)];
    xs[(signed long int)xcol[(signed long int)(nx - 1)]] = xsym;
    ys[(signed long int)xcol[(signed long int)(nx - 1)]] = ysym;
    xcol[(signed long int)(nx - 1)] = c;
  }
  for( ; ny >= 2; ny = ny - 1)
  {
    double return_value_sre_random$33;
    return_value_sre_random$33=sre_random();
    pos = (signed int)(return_value_sre_random$33 * (double)ny);
    xsym = xs[(signed long int)ycol[(signed long int)pos]];
    ysym = ys[(signed long int)ycol[(signed long int)pos]];
    c = ycol[(signed long int)pos];
    xs[(signed long int)ycol[(signed long int)pos]] = xs[(signed long int)ycol[(signed long int)(ny - 1)]];
    ys[(signed long int)ycol[(signed long int)pos]] = ys[(signed long int)ycol[(signed long int)(ny - 1)]];
    ycol[(signed long int)pos] = ycol[(signed long int)(ny - 1)];
    xs[(signed long int)ycol[(signed long int)(ny - 1)]] = xsym;
    ys[(signed long int)ycol[(signed long int)(ny - 1)]] = ysym;
    ycol[(signed long int)(ny - 1)] = c;
  }
  free((void *)xycol);
  free((void *)xcol);
  free((void *)ycol);
  return 1;
}

// RandomAlignment
// file alignio.c line 514
extern signed int RandomAlignment(char **rseqs, struct seqinfo_s *sqinfo, signed int nseq, float pop, float pex, char ***ret_aseqs, struct aliinfo_s *ainfo)
{
  char **aseqs;
  signed int alen;
  signed int *rlen;
  signed int M;
  signed int **ins;
  signed int *master_ins;
  signed int apos;
  signed int rpos;
  signed int idx;
  signed int statepos;
  signed int count;
  signed int minlen;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("alignio.c", 530, sizeof(signed int) /*4ul*/  * (unsigned long int)nseq);
  rlen = (signed int *)return_value_sre_malloc$1;
  M = 0;
  minlen = 9999999;
  idx = 0;
  signed int tmp_if_expr$3;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(rseqs[(signed long int)idx]);
    rlen[(signed long int)idx] = (signed int)return_value_strlen$2;
    M = M + rlen[(signed long int)idx];
    if(!(rlen[(signed long int)idx] >= minlen))
      tmp_if_expr$3 = rlen[(signed long int)idx];

    else
      tmp_if_expr$3 = minlen;
    minlen = tmp_if_expr$3;
  }
  M = (signed int)((double)(float)M / (1.0 + (double)pop * (1.0 + 1.0 / (1.0 - (double)pex))));
  M = M / nseq;
  if(!(minlen >= M))
    M = minlen;

  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("alignio.c", 545, sizeof(signed int *) /*8ul*/  * (unsigned long int)nseq);
  ins = (signed int **)return_value_sre_malloc$4;
  void *return_value_sre_malloc$5;
  return_value_sre_malloc$5=sre_malloc("alignio.c", 546, sizeof(signed int) /*4ul*/  * (unsigned long int)(M + 1));
  master_ins = (signed int *)return_value_sre_malloc$5;
  idx = 0;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    void *return_value_sre_malloc$6;
    return_value_sre_malloc$6=sre_malloc("alignio.c", 549, sizeof(signed int) /*4ul*/  * (unsigned long int)(M + 1));
    ins[(signed long int)idx] = (signed int *)return_value_sre_malloc$6;
    rpos = 0;
    for( ; M >= rpos; rpos = rpos + 1)
      ins[(signed long int)idx][(signed long int)rpos] = 0;
  }
  pop = pop / (pop + pex);
  pex = (float)(1.0 - (double)pop);
  idx = 0;
  double return_value_sre_random$7;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    apos = -1;
    rpos = 0;
    for( ; !(rpos >= rlen[(signed long int)idx] + -M); rpos = rpos + 1)
    {
      double return_value_sre_random$8;
      return_value_sre_random$8=sre_random();
      if(return_value_sre_random$8 < (double)pop || apos == -1)
      {
        return_value_sre_random$7=sre_random();
        apos = (signed int)(return_value_sre_random$7 * (double)(M + 1));
      }

      ins[(signed long int)idx][(signed long int)apos] = ins[(signed long int)idx][(signed long int)apos] + 1;
    }
  }
  alen = M;
  apos = 0;
  for( ; M >= apos; apos = apos + 1)
  {
    master_ins[(signed long int)apos] = 0;
    idx = 0;
    for( ; !(idx >= nseq); idx = idx + 1)
      if(!(master_ins[(signed long int)apos] >= ins[(signed long int)idx][(signed long int)apos]))
        master_ins[(signed long int)apos] = ins[(signed long int)idx][(signed long int)apos];

    alen = alen + master_ins[(signed long int)apos];
  }
  void *return_value_sre_malloc$9;
  return_value_sre_malloc$9=sre_malloc("alignio.c", 581, sizeof(char *) /*8ul*/  * (unsigned long int)nseq);
  aseqs = (char **)return_value_sre_malloc$9;
  idx = 0;
  void *return_value_sre_malloc$10;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    return_value_sre_malloc$10=sre_malloc("alignio.c", 583, sizeof(char) /*1ul*/  * (unsigned long int)(alen + 1));
    aseqs[(signed long int)idx] = (char *)return_value_sre_malloc$10;
  }
  idx = 0;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$13;
  signed int tmp_post$14;
  signed int tmp_post$15;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    rpos = 0;
    apos = rpos;
    statepos = 0;
    for( ; M >= statepos; statepos = statepos + 1)
    {
      count = 0;
      for( ; !(count >= ins[(signed long int)idx][(signed long int)statepos]); count = count + 1)
      {
        tmp_post$11 = apos;
        apos = apos + 1;
        tmp_post$12 = rpos;
        rpos = rpos + 1;
        aseqs[(signed long int)idx][(signed long int)tmp_post$11] = rseqs[(signed long int)idx][(signed long int)tmp_post$12];
      }
      for( ; !(count >= master_ins[(signed long int)statepos]); count = count + 1)
      {
        tmp_post$13 = apos;
        apos = apos + 1;
        aseqs[(signed long int)idx][(signed long int)tmp_post$13] = (char)32;
      }
      if(!(statepos == M))
      {
        tmp_post$14 = apos;
        apos = apos + 1;
        tmp_post$15 = rpos;
        rpos = rpos + 1;
        aseqs[(signed long int)idx][(signed long int)tmp_post$14] = rseqs[(signed long int)idx][(signed long int)tmp_post$15];
      }

    }
    aseqs[(signed long int)idx][(signed long int)alen] = (char)0;
  }
  ainfo->flags = 0;
  ainfo->alen = alen;
  ainfo->nseq = nseq;
  void *return_value_sre_malloc$16;
  return_value_sre_malloc$16=sre_malloc("alignio.c", 603, sizeof(struct seqinfo_s) /*360ul*/  * (unsigned long int)nseq);
  ainfo->sqinfo = (struct seqinfo_s *)return_value_sre_malloc$16;
  idx = 0;
  for( ; !(idx >= nseq); idx = idx + 1)
    SeqinfoCopy(&ainfo->sqinfo[(signed long int)idx], &sqinfo[(signed long int)idx]);
  free((void *)rlen);
  free((void *)master_ins);
  Free2DArray((void **)ins, nseq);
  *ret_aseqs = aseqs;
  return 1;
}

// RandomSequence
// file ../squid/sqfuncs.h line 224
extern char * RandomSequence(char *alphabet, float *p, signed int n, signed int len)
{
  char *s;
  signed int x;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("sre_string.c", 199, sizeof(char) /*1ul*/  * (unsigned long int)(len + 1));
  s = (char *)return_value_sre_malloc$1;
  x = 0;
  signed int return_value_FChoose$2;
  for( ; !(x >= len); x = x + 1)
  {
    return_value_FChoose$2=FChoose(p, n);
    s[(signed long int)x] = alphabet[(signed long int)return_value_FChoose$2];
  }
  s[(signed long int)x] = (char)0;
  return s;
}

// ReadA2M
// file a2m.c line 40
extern struct msa_struct * ReadA2M(struct msafile_struct *afp)
{
  struct msa_struct *msa;
  char *buf;
  char *name;
  char *desc;
  char *seq;
  signed int idx;
  signed int len1;
  signed int len2;
  signed int return_value_feof$1;
  return_value_feof$1=feof(afp->f);
  if(!(return_value_feof$1 == 0))
    return (struct msa_struct *)(void *)0;

  else
  {
    name = (char *)(void *)0;
    msa=MSAAlloc(10, 0);
    idx = 0;
    do
    {
      buf=MSAFileGetLine(afp);
      if(buf == ((char *)NULL))
        break;

      if((signed int)*buf == 62)
      {
        buf = buf + 1l;
        name=sre_strtok(&buf, " \t\n", &len1);
        if(name == ((char *)NULL))
          Die("Blank name in A2M file %s (line %d)\n", afp->fname, afp->linenumber);

        desc=sre_strtok(&buf, "\n", &len2);
        idx=GKIStoreKey(msa->index, name);
        if(idx >= msa->nseqalloc)
          MSAExpand(msa);

        msa->sqname[(signed long int)idx]=sre_strdup(name, len1);
        if(!(desc == ((char *)NULL)))
          MSASetSeqDescription(msa, idx, desc);

        msa->nseq = msa->nseq + 1;
      }

      else
        if(!(name == ((char *)NULL)))
        {
          seq=sre_strtok(&buf, " \t\n", &len1);
          if(!(seq == ((char *)NULL)))
            msa->sqlen[(signed long int)idx]=sre_strcat(&msa->aseq[(signed long int)idx], msa->sqlen[(signed long int)idx], seq, len1);

        }

    }
    while((_Bool)1);
    if(name == ((char *)NULL))
    {
      MSAFree(msa);
      return (struct msa_struct *)(void *)0;
    }

    else
    {
      MSAVerifyParse(msa);
      return msa;
    }
  }
}

// ReadClustal
// file clustal.c line 79
extern struct msa_struct * ReadClustal(struct msafile_struct *afp)
{
  struct msa_struct *msa;
  char *s;
  signed int slen;
  signed int sqidx;
  char *name;
  char *seq;
  char *s2;
  signed int return_value_feof$1;
  return_value_feof$1=feof(afp->f);
  char *return_value_strstr$2;
  char *return_value_strpbrk$4;
  if(!(return_value_feof$1 == 0))
    return (struct msa_struct *)(void *)0;

  else
  {
    do
    {
      s=MSAFileGetLine(afp);
      if(s == ((char *)NULL))
        break;

      signed int return_value_strncmp$3;
      return_value_strncmp$3=strncmp(s, "CLUSTAL", (unsigned long int)7);
      if(return_value_strncmp$3 == 0)
      {
        return_value_strstr$2=strstr(s, "multiple sequence alignment");
        if(!(return_value_strstr$2 == ((char *)NULL)))
          break;

      }

    }
    while((_Bool)1);
    if(s == ((char *)NULL))
      return (struct msa_struct *)(void *)0;

    else
    {
      msa=MSAAlloc(10, 0);
      do
      {
        s=MSAFileGetLine(afp);
        if(s == ((char *)NULL))
          break;

        name=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
        if(!(name == ((char *)NULL)))
        {
          seq=sre_strtok(&s, " \t\n", &slen);
          if(!(seq == ((char *)NULL)))
          {
            s2=sre_strtok(&s, "\n", (signed int *)(void *)0);
            char *return_value_strpbrk$5;
            return_value_strpbrk$5=strpbrk(name, ".*:");
            if(!(return_value_strpbrk$5 == ((char *)NULL)))
            {
              return_value_strpbrk$4=strpbrk(seq, ".*:");
              if(!(return_value_strpbrk$4 == ((char *)NULL)))
                continue;

            }

            if(!(s2 == ((char *)NULL)))
              Die("Parse failed at line %d, file %s: possibly using spaces as gaps", afp->linenumber, afp->fname);

            sqidx=MSAGetSeqidx(msa, name, msa->lastidx + 1);
            msa->lastidx = sqidx;
            msa->sqlen[(signed long int)sqidx]=sre_strcat(&msa->aseq[(signed long int)sqidx], msa->sqlen[(signed long int)sqidx], seq, slen);
          }

        }

      }
      while((_Bool)1);
      MSAVerifyParse(msa);
      return msa;
    }
  }
}

// ReadMSF
// file msa.h line 278
extern struct msa_struct * ReadMSF(struct msafile_struct *afp)
{
  struct msa_struct *msa;
  char *s;
  signed int alleged_alen;
  signed int alleged_type;
  signed int alleged_checksum;
  char *tok;
  char *sp;
  signed int slen;
  signed int sqidx;
  char *name;
  char *seq;
  signed int return_value_feof$1;
  return_value_feof$1=feof(afp->f);
  signed int return_value_strncmp$2;
  char *return_value_strstr$5;
  signed int return_value_Strparse$4;
  signed int return_value_strncmp$9;
  const unsigned short int **return_value___ctype_b_loc$10;
  _Bool tmp_if_expr$12;
  if(!(return_value_feof$1 == 0))
    return (struct msa_struct *)(void *)0;

  else
  {
    s=MSAFileGetLine(afp);
    if(s == ((char *)NULL))
      return (struct msa_struct *)(void *)0;

    else
    {
      msa=MSAAlloc(10, 0);
      signed int return_value_strncmp$3;
      return_value_strncmp$3=strncmp(s, "!!AA_MULTIPLE_ALIGNMENT", (unsigned long int)23);
      if(return_value_strncmp$3 == 0)
      {
        msa->type = 3;
        s=MSAFileGetLine(afp);
        if(s == ((char *)NULL))
          return (struct msa_struct *)(void *)0;

      }

      else
      {
        return_value_strncmp$2=strncmp(s, "!!NA_MULTIPLE_ALIGNMENT", (unsigned long int)23);
        if(return_value_strncmp$2 == 0)
        {
          msa->type = 2;
          s=MSAFileGetLine(afp);
          if(s == ((char *)NULL))
            return (struct msa_struct *)(void *)0;

        }

      }
      do
      {
        char *return_value_strstr$6;
        return_value_strstr$6=strstr(s, "..");
        if(!(return_value_strstr$6 == ((char *)NULL)))
        {
          return_value_strstr$5=strstr(s, "MSF:");
          if(!(return_value_strstr$5 == ((char *)NULL)))
          {
            return_value_Strparse$4=Strparse("^.+MSF: +([0-9]+) +Type: +([PNX]).+Check: +([0-9]+) +\\.\\.", s, 3);
            if(!(return_value_Strparse$4 == 0))
            {
              alleged_alen=atoi(sqd_parse[(signed long int)0]);
              switch((signed int)*sqd_parse[(signed long int)1])
              {
                case 78:
                {
                  alleged_type = 2;
                  break;
                }
                case 80:
                {
                  alleged_type = 3;
                  break;
                }
                case 88:
                {
                  alleged_type = 0;
                  break;
                }
                default:
                  alleged_type = 0;
              }
              alleged_checksum=atoi(sqd_parse[(signed long int)3]);
              if(msa->type == 0)
                msa->type = alleged_type;

              break;
            }

          }

        }

        signed int return_value_IsBlankline$7;
        return_value_IsBlankline$7=IsBlankline(s);
        if(return_value_IsBlankline$7 == 0)
          MSAAddComment(msa, s);

        s=MSAFileGetLine(afp);
      }
      while(!(s == ((char *)NULL)));
      do
      {
        s=MSAFileGetLine(afp);
        if(s == ((char *)NULL))
          break;

        for( ; (_Bool)1; s = s + 1l)
        {
          if(!((signed int)*s == 32))
          {
            if(!((signed int)*s == 9))
              goto __CPROVER_DUMP_L17;

          }

          if(*s == 0)
            break;

        }

      __CPROVER_DUMP_L17:
        ;
        if((signed int)*s == 10)
          continue;

        else
          if((signed int)*s == 33)
            MSAAddComment(msa, s);

          else
          {
            sp=strstr(s, "Name:");
            if(!(sp == ((char *)NULL)))
            {
              sp = sp + (signed long int)5;
              tok=sre_strtok(&sp, " \t", &slen);
              sqidx=GKIStoreKey(msa->index, tok);
              if(sqidx >= msa->nseqalloc)
                MSAExpand(msa);

              msa->sqname[(signed long int)sqidx]=sre_strdup(tok, slen);
              msa->nseq = msa->nseq + 1;
              sp=strstr(sp, "Weight:");
              if(sp == ((char *)NULL))
                Die("No Weight: on line %d for %s in name section of MSF file %s\n", afp->linenumber, msa->sqname[(signed long int)sqidx], afp->fname);

              sp = sp + (signed long int)7;
              tok=sre_strtok(&sp, " \t", &slen);
              double return_value_atof$8;
              return_value_atof$8=atof(tok);
              msa->wgt[(signed long int)sqidx] = (float)return_value_atof$8;
              msa->flags = msa->flags | 1 << 0;
            }

            else
            {
              return_value_strncmp$9=strncmp(s, "//", (unsigned long int)2);
              if(return_value_strncmp$9 == 0)
                break;

              else
              {
                Die("Invalid line (probably %d) in name section of MSF file %s:\n%s\n", afp->linenumber, afp->fname, s);
                squid_errno = 5;
                return (struct msa_struct *)(void *)0;
              }
            }
          }
      }
      while((_Bool)1);
      do
      {
        s=MSAFileGetLine(afp);
        if(s == ((char *)NULL))
          break;

        sp = s;
        name=sre_strtok(&sp, " \t", (signed int *)(void *)0);
        if(!(name == ((char *)NULL)))
        {
          seq=sre_strtok(&sp, "\n", &slen);
          if(!(seq == ((char *)NULL)))
          {
            const unsigned short int **return_value___ctype_b_loc$11;
            return_value___ctype_b_loc$11=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)*name]) == 0))
            {
              return_value___ctype_b_loc$10=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)*seq]) == 0))
                continue;

            }

            sqidx=GKIKeyIndex(msa->index, name);
            if(sqidx >= 0)
              msa->sqlen[(signed long int)sqidx]=sre_strcat(&msa->aseq[(signed long int)sqidx], msa->sqlen[(signed long int)sqidx], seq, slen);

          }

        }

      }
      while((_Bool)1);
      sqidx = 0;
      for( ; !(sqidx >= msa->nseq); sqidx = sqidx + 1)
      {
        if(msa->aseq[(signed long int)sqidx] == ((char *)NULL))
          Die("Didn't find a sequence for %s in MSF file %s\n", msa->sqname[(signed long int)sqidx], afp->fname);

        sp = msa->aseq[(signed long int)sqidx];
        s = sp;
        for( ; !((signed int)*s == 0); s = s + 1l)
        {
          if((signed int)*s == 32)
            tmp_if_expr$12 = (_Bool)1;

          else
            tmp_if_expr$12 = (signed int)*s == 9 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$12)
            msa->sqlen[(signed long int)sqidx] = msa->sqlen[(signed long int)sqidx] - 1;

          else
          {
            *sp = *s;
            sp = sp + 1l;
          }
        }
        *sp = (char)0;
      }
      MSAVerifyParse(msa);
      return msa;
    }
  }
}

// ReadMultipleRseqs
// file sqio.c line 1712
extern signed int ReadMultipleRseqs(char *seqfile, signed int fformat, char ***ret_rseqs, struct seqinfo_s **ret_sqinfo, signed int *ret_num)
{
  struct seqinfo_s *sqinfo;
  struct ReadSeqVars *dbfp;
  char **rseqs;
  signed int numalloced;
  signed int num = 0;
  numalloced = 16;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("sqio.c", 1727, (unsigned long int)numalloced * sizeof(char *) /*8ul*/ );
  rseqs = (char **)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("sqio.c", 1728, (unsigned long int)numalloced * sizeof(struct seqinfo_s) /*360ul*/ );
  sqinfo = (struct seqinfo_s *)return_value_sre_malloc$2;
  dbfp=SeqfileOpen(seqfile, fformat, (char *)(void *)0);
  signed int return_value_ReadSeq$3;
  if(dbfp == ((struct ReadSeqVars *)NULL))
    return 0;

  else
  {
    do
    {
      return_value_ReadSeq$3=ReadSeq(dbfp, dbfp->format, &rseqs[(signed long int)num], &sqinfo[(signed long int)num]);
      if(return_value_ReadSeq$3 == 0)
        break;

      num = num + 1;
      if(num == numalloced)
      {
        numalloced = numalloced + 16;
        void *return_value_sre_realloc$4;
        return_value_sre_realloc$4=sre_realloc("sqio.c", 1737, (void *)rseqs, (unsigned long int)numalloced * sizeof(char *) /*8ul*/ );
        rseqs = (char **)return_value_sre_realloc$4;
        void *return_value_sre_realloc$5;
        return_value_sre_realloc$5=sre_realloc("sqio.c", 1738, (void *)sqinfo, (unsigned long int)numalloced * sizeof(struct seqinfo_s) /*360ul*/ );
        sqinfo = (struct seqinfo_s *)return_value_sre_realloc$5;
      }

    }
    while((_Bool)1);
    SeqfileClose(dbfp);
    *ret_rseqs = rseqs;
    *ret_sqinfo = sqinfo;
    *ret_num = num;
    return 1;
  }
}

// ReadPhylip
// file msa.h line 283
extern struct msa_struct * ReadPhylip(struct msafile_struct *afp)
{
  struct msa_struct *msa;
  char *s;
  char *s1;
  char *s2;
  char name[11l];
  signed int nseq;
  signed int alen;
  signed int idx;
  signed int slen;
  signed int nblock;
  signed int return_value_feof$1;
  return_value_feof$1=feof(afp->f);
  _Bool tmp_if_expr$4;
  signed int return_value_IsInt$3;
  if(!(return_value_feof$1 == 0))
    return (struct msa_struct *)(void *)0;

  else
  {
    nseq = 0;
    alen = 0;
    do
    {
      s=MSAFileGetLine(afp);
      if(s == ((char *)NULL))
        break;

      s1=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
      if(!(s1 == ((char *)NULL)))
      {
        s2=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
        if(s2 == ((char *)NULL))
          Die("Failed to parse nseq/alen from first line of PHYLIP file %s\n", afp->fname);

        signed int return_value_IsInt$2;
        return_value_IsInt$2=IsInt(s1);
        if(return_value_IsInt$2 == 0)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_IsInt$3=IsInt(s2);
          tmp_if_expr$4 = !(return_value_IsInt$3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          Die("nseq and/or alen not an integer in first line of PHYLIP file %s\n", afp->fname);

        nseq=atoi(s1);
        alen=atoi(s2);
        break;
      }

    }
    while((_Bool)1);
    msa=MSAAlloc(nseq, 0);
    idx = 0;
    nblock = 0;
    do
    {
      s=MSAFileGetLine(afp);
      if(s == ((char *)NULL))
        break;

      const unsigned short int **return_value___ctype_b_loc$5;
      return_value___ctype_b_loc$5=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*s]) == 0)
      {
        if(nblock == 0)
        {
          strncpy(name, s, (unsigned long int)10);
          name[(signed long int)10] = (char)0;
          GKIStoreKey(msa->index, name);
          msa->sqname[(signed long int)idx]=sre_strdup(name, -1);
          s = s + (signed long int)10;
        }

        s1=sre_strtok(&s, " \t\n", &slen);
        if(s1 == ((char *)NULL))
          Die("Failed to parse sequence at line %d of PHYLIP file %s\n", afp->linenumber, afp->fname);

        msa->sqlen[(signed long int)idx]=sre_strcat(&msa->aseq[(signed long int)idx], msa->sqlen[(signed long int)idx], s1, slen);
        idx = idx + 1;
        if(idx == nseq)
        {
          idx = 0;
          nblock = nblock + 1;
        }

      }

    }
    while((_Bool)1);
    msa->nseq = nseq;
    MSAVerifyParse(msa);
    return msa;
  }
}

// ReadSELEX
// file msa.h line 288
extern struct msa_struct * ReadSELEX(struct msafile_struct *afp)
{
  struct msa_struct *msa;
  struct _IO_FILE *fp;
  char **aseqs;
  signed int num = 0;
  char buffer[4096l];
  char bufcpy[4096l];
  /* ReadSELEX::1::tag-block_struc */
struct block_struc
{
  // lcol
  signed int lcol;
  // rcol
  signed int rcol;
};

/* */
  ;
  struct block_struc *blocks = (struct block_struc *)(void *)0;
  signed int blocknum;
  char *nptr;
  char *sptr;
  signed int currnum;
  signed int currblock;
  signed int i;
  signed int seqidx;
  signed int alen;
  signed int warn_names;
  signed int headnum;
  signed int currlen;
  signed int count;
  signed int have_cs = 0;
  signed int have_rf = 0;
  struct aliinfo_s base_ainfo;
  struct aliinfo_s *ainfo;
  signed int return_value_feof$1;
  return_value_feof$1=feof(afp->f);
  _Bool tmp_if_expr$2;
  signed int return_value_strncmp$6;
  _Bool tmp_if_expr$4;
  char *return_value_strchr$3;
  signed int return_value_feof$8;
  void *return_value_sre_malloc$9;
  void *return_value_sre_realloc$10;
  void *return_value_sre_malloc$11;
  void *return_value_sre_realloc$12;
  char *return_value_strchr$15;
  signed int return_value_strncmp$20;
  signed int return_value_strncmp$19;
  signed int return_value_strncmp$18;
  char *return_value_strchr$16;
  _Bool tmp_if_expr$23;
  char *return_value_strchr$22;
  void *return_value_sre_malloc$26;
  void *return_value_sre_malloc$27;
  void *return_value_sre_malloc$29;
  void *return_value_sre_malloc$30;
  _Bool tmp_if_expr$56;
  signed int return_value_strcmp$53;
  _Bool tmp_if_expr$54;
  signed int return_value_strcmp$51;
  _Bool tmp_if_expr$52;
  signed int return_value_strcmp$49;
  _Bool tmp_if_expr$50;
  signed int return_value_strcmp$48;
  signed int return_value_strcmp$47;
  signed int return_value_strcmp$46;
  signed int return_value_strcmp$45;
  signed int return_value_strcmp$44;
  signed int return_value_strcmp$43;
  char *return_value_strchr$42;
  signed int return_value_strcmp$70;
  signed int return_value_strcmp$69;
  signed int return_value_strcmp$68;
  signed int return_value_strncmp$67;
  _Bool tmp_if_expr$78;
  _Bool tmp_if_expr$79;
  _Bool tmp_if_expr$80;
  _Bool tmp_if_expr$81;
  _Bool tmp_if_expr$82;
  _Bool tmp_if_expr$83;
  _Bool tmp_if_expr$84;
  _Bool tmp_if_expr$85;
  _Bool tmp_if_expr$86;
  _Bool tmp_if_expr$87;
  _Bool tmp_if_expr$88;
  _Bool tmp_if_expr$89;
  if(!(return_value_feof$1 == 0))
    return (struct msa_struct *)(void *)0;

  else
  {
    if(!(afp->do_gzip == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = afp->do_stdin != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      Die("Can't read a SELEX format alignment from a pipe, stdin, or gzip'ed file");

    fp = afp->f;
    ainfo = &base_ainfo;
    InitAinfo(ainfo);
    do
    {
      char *return_value_fgets$5;
      return_value_fgets$5=fgets(buffer, 4096, fp);
      if(return_value_fgets$5 == ((char *)NULL))
      {
        squid_errno = 2;
        return ((struct msa_struct *)NULL);
      }

      strcpy(bufcpy, buffer);
      if((signed int)buffer[0l] == 35)
      {
        signed int return_value_strncmp$7;
        return_value_strncmp$7=strncmp(buffer, "#=CS", (unsigned long int)4);
        if(return_value_strncmp$7 == 0)
          have_cs = 1;

        else
        {
          return_value_strncmp$6=strncmp(buffer, "#=RF", (unsigned long int)4);
          if(return_value_strncmp$6 == 0)
            have_rf = 1;

        }
      }

      nptr=strtok(bufcpy, " \t\n");
      if(nptr == ((char *)NULL))
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_strchr$3=strchr(commentsyms, (signed int)*nptr);
        tmp_if_expr$4 = return_value_strchr$3 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
    }
    while(tmp_if_expr$4);
    blocknum = 0;
    warn_names = 0;
    do
    {
      return_value_feof$8=feof(fp);
      if(!(return_value_feof$8 == 0))
        break;

      if(blocknum == 0)
      {
        return_value_sre_malloc$9=sre_malloc("selex.c", 151, sizeof(struct block_struc) /*8ul*/ );
        blocks = (struct block_struc *)return_value_sre_malloc$9;
      }

      else
      {
        return_value_sre_realloc$10=sre_realloc("selex.c", 153, (void *)blocks, (unsigned long int)(blocknum + 1) * sizeof(struct block_struc) /*8ul*/ );
        blocks = (struct block_struc *)return_value_sre_realloc$10;
      }
      (blocks + (signed long int)blocknum)->lcol = 4096 + 1;
      (blocks + (signed long int)blocknum)->rcol = -1;
      currnum = 0;
      while(!(nptr == ((char *)NULL)))
      {
        if(blocknum == 0)
        {
          if(currnum == 0)
          {
            return_value_sre_malloc$11=sre_malloc("selex.c", 164, sizeof(struct seqinfo_s) /*360ul*/ );
            ainfo->sqinfo = (struct seqinfo_s *)return_value_sre_malloc$11;
          }

          else
          {
            return_value_sre_realloc$12=sre_realloc("selex.c", 166, (void *)ainfo->sqinfo, (unsigned long int)(currnum + 1) * sizeof(struct seqinfo_s) /*360ul*/ );
            ainfo->sqinfo = (struct seqinfo_s *)return_value_sre_realloc$12;
          }
          (ainfo->sqinfo + (signed long int)currnum)->flags = 0;
          SetSeqinfoString(&ainfo->sqinfo[(signed long int)currnum], nptr, 1 << 0);
        }

        else
        {
          signed int return_value_strcmp$13;
          return_value_strcmp$13=strcmp((ainfo->sqinfo + (signed long int)currnum)->name, nptr);
          if(!(return_value_strcmp$13 == 0))
            warn_names = 1;

        }
        currnum = currnum + 1;
        sptr=strtok((char *)(void *)0, " \t\n");
        if(!(sptr == ((char *)NULL)))
        {
          if(!(sptr - bufcpy >= (signed long int)(blocks + (signed long int)blocknum)->lcol))
            (blocks + (signed long int)blocknum)->lcol = (signed int)(sptr - bufcpy);

          unsigned long int return_value_strlen$14;
          return_value_strlen$14=strlen(buffer);
          sptr = (buffer + (signed long int)return_value_strlen$14) - (signed long int)1;
          do
          {
            return_value_strchr$15=strchr(" \t\n", (signed int)*sptr);
            if(return_value_strchr$15 == ((char *)NULL))
              break;

            sptr = sptr - 1l;
          }
          while((_Bool)1);
          if(!((signed long int)(blocks + (signed long int)blocknum)->rcol >= sptr - buffer))
            (blocks + (signed long int)blocknum)->rcol = (signed int)(sptr - buffer);

        }

        do
        {
          char *return_value_fgets$17;
          return_value_fgets$17=fgets(buffer, 4096, fp);
          if(return_value_fgets$17 == ((char *)NULL))
          {
            nptr = (char *)(void *)0;
            break;
          }

          strcpy(bufcpy, buffer);
          signed int return_value_strncmp$21;
          return_value_strncmp$21=strncmp(buffer, "#=SS", (unsigned long int)4);
          if(return_value_strncmp$21 == 0)
            (ainfo->sqinfo + (signed long int)(currnum - 1))->flags = (ainfo->sqinfo + (signed long int)(currnum - 1))->flags | 1 << 9;

          else
          {
            return_value_strncmp$20=strncmp(buffer, "#=SA", (unsigned long int)4);
            if(return_value_strncmp$20 == 0)
              (ainfo->sqinfo + (signed long int)(currnum - 1))->flags = (ainfo->sqinfo + (signed long int)(currnum - 1))->flags | 1 << 10;

            else
            {
              return_value_strncmp$19=strncmp(buffer, "#=CS", (unsigned long int)4);
              if(return_value_strncmp$19 == 0)
                have_cs = 1;

              else
              {
                return_value_strncmp$18=strncmp(buffer, "#=RF", (unsigned long int)4);
                if(return_value_strncmp$18 == 0)
                  have_rf = 1;

              }
            }
          }
          nptr=strtok(bufcpy, " \t\n");
          if(nptr == ((char *)NULL))
            break;

          return_value_strchr$16=strchr(commentsyms, (signed int)*nptr);
        }
        while(!(return_value_strchr$16 == ((char *)NULL)));
      }
      if(blocknum == 0)
        num = currnum;

      else
        if(!(currnum == num))
          Die("Parse error in ReadSELEX()");

      blocknum = blocknum + 1;
      do
      {
        char *return_value_fgets$24;
        return_value_fgets$24=fgets(buffer, 4096, fp);
        if(return_value_fgets$24 == ((char *)NULL))
        {
          nptr = (char *)(void *)0;
          break;
        }

        strcpy(bufcpy, buffer);
        nptr=strtok(bufcpy, " \t\n");
        if(nptr == ((char *)NULL))
          tmp_if_expr$23 = (_Bool)1;

        else
        {
          return_value_strchr$22=strchr(commentsyms, (signed int)*nptr);
          tmp_if_expr$23 = return_value_strchr$22 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
      }
      while(tmp_if_expr$23);
    }
    while((_Bool)1);
    alen = 0;
    currblock = 0;
    for( ; !(currblock >= blocknum); currblock = currblock + 1)
      alen = alen + ((blocks + (signed long int)currblock)->rcol - (blocks + (signed long int)currblock)->lcol) + 1;
    rewind(fp);
    void *return_value_sre_malloc$25;
    return_value_sre_malloc$25=sre_malloc("selex.c", 247, (unsigned long int)num * sizeof(char *) /*8ul*/ );
    aseqs = (char **)return_value_sre_malloc$25;
    if(!(have_cs == 0))
    {
      return_value_sre_malloc$26=sre_malloc("selex.c", 249, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
      ainfo->cs = (char *)return_value_sre_malloc$26;
    }

    if(!(have_rf == 0))
    {
      return_value_sre_malloc$27=sre_malloc("selex.c", 251, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
      ainfo->rf = (char *)return_value_sre_malloc$27;
    }

    i = 0;
    for( ; !(i >= num); i = i + 1)
    {
      void *return_value_sre_malloc$28;
      return_value_sre_malloc$28=sre_malloc("selex.c", 257, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
      aseqs[(signed long int)i] = (char *)return_value_sre_malloc$28;
      if(!((512 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
      {
        return_value_sre_malloc$29=sre_malloc("selex.c", 259, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
        (ainfo->sqinfo + (signed long int)i)->ss = (char *)return_value_sre_malloc$29;
      }

      if(!((1024 & (ainfo->sqinfo + (signed long int)i)->flags) == 0))
      {
        return_value_sre_malloc$30=sre_malloc("selex.c", 261, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
        (ainfo->sqinfo + (signed long int)i)->sa = (char *)return_value_sre_malloc$30;
      }

    }
    ainfo->alen = alen;
    ainfo->nseq = num;
    void *return_value_sre_malloc$31;
    return_value_sre_malloc$31=sre_malloc("selex.c", 266, sizeof(float) /*4ul*/  * (unsigned long int)num);
    ainfo->wgt = (float *)return_value_sre_malloc$31;
    FSet(ainfo->wgt, num, (float)1.0);
    headnum = 0;
    do
    {
      char *return_value_fgets$32;
      return_value_fgets$32=fgets(buffer, 4096, fp);
      if(return_value_fgets$32 == ((char *)NULL))
        Die("Parse error in ReadSELEX()");

      strcpy(bufcpy, buffer);
      nptr=strtok(bufcpy, " \t\n");
      if(!(nptr == ((char *)NULL)))
      {
        signed int return_value_strcmp$55;
        return_value_strcmp$55=strcmp(nptr, "#=AU");
        if(return_value_strcmp$55 == 0)
        {
          sptr=strtok((char *)(void *)0, "\n");
          tmp_if_expr$56 = sptr != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$56 = (_Bool)0;
        if(tmp_if_expr$56)
          ainfo->au=Strdup(sptr);

        else
        {
          return_value_strcmp$53=strcmp(nptr, "#=ID");
          if(return_value_strcmp$53 == 0)
          {
            sptr=strtok((char *)(void *)0, "\n");
            tmp_if_expr$54 = sptr != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$54 = (_Bool)0;
          if(tmp_if_expr$54)
            ainfo->name=Strdup(sptr);

          else
          {
            return_value_strcmp$51=strcmp(nptr, "#=AC");
            if(return_value_strcmp$51 == 0)
            {
              sptr=strtok((char *)(void *)0, "\n");
              tmp_if_expr$52 = sptr != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$52 = (_Bool)0;
            if(tmp_if_expr$52)
              ainfo->acc=Strdup(sptr);

            else
            {
              return_value_strcmp$49=strcmp(nptr, "#=DE");
              if(return_value_strcmp$49 == 0)
              {
                sptr=strtok((char *)(void *)0, "\n");
                tmp_if_expr$50 = sptr != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$50 = (_Bool)0;
              if(tmp_if_expr$50)
                ainfo->desc=Strdup(sptr);

              else
              {
                return_value_strcmp$48=strcmp(nptr, "#=GA");
                if(return_value_strcmp$48 == 0)
                {
                  sptr=strtok((char *)(void *)0, " \t\n");
                  if(sptr == ((char *)NULL))
                    Die("Parse error in #=GA line in ReadSELEX()");

                  double return_value_atof$33;
                  return_value_atof$33=atof(sptr);
                  ainfo->ga1 = (float)return_value_atof$33;
                  sptr=strtok((char *)(void *)0, " \t\n");
                  if(sptr == ((char *)NULL))
                    Die("Parse error in #=GA line in ReadSELEX()");

                  double return_value_atof$34;
                  return_value_atof$34=atof(sptr);
                  ainfo->ga2 = (float)return_value_atof$34;
                  ainfo->flags = ainfo->flags | 1 << 2;
                }

                else
                {
                  return_value_strcmp$47=strcmp(nptr, "#=TC");
                  if(return_value_strcmp$47 == 0)
                  {
                    sptr=strtok((char *)(void *)0, " \t\n");
                    if(sptr == ((char *)NULL))
                      Die("Parse error in #=TC line in ReadSELEX()");

                    double return_value_atof$35;
                    return_value_atof$35=atof(sptr);
                    ainfo->tc1 = (float)return_value_atof$35;
                    sptr=strtok((char *)(void *)0, " \t\n");
                    if(sptr == ((char *)NULL))
                      Die("Parse error in #=TC line in ReadSELEX()");

                    double return_value_atof$36;
                    return_value_atof$36=atof(sptr);
                    ainfo->tc2 = (float)return_value_atof$36;
                    ainfo->flags = ainfo->flags | 1 << 0;
                  }

                  else
                  {
                    return_value_strcmp$46=strcmp(nptr, "#=NC");
                    if(return_value_strcmp$46 == 0)
                    {
                      sptr=strtok((char *)(void *)0, " \t\n");
                      if(sptr == ((char *)NULL))
                        Die("Parse error in #=NC line in ReadSELEX()");

                      double return_value_atof$37;
                      return_value_atof$37=atof(sptr);
                      ainfo->nc1 = (float)return_value_atof$37;
                      sptr=strtok((char *)(void *)0, " \t\n");
                      if(sptr == ((char *)NULL))
                        Die("Parse error in #=NC line in ReadSELEX()");

                      double return_value_atof$38;
                      return_value_atof$38=atof(sptr);
                      ainfo->nc2 = (float)return_value_atof$38;
                      ainfo->flags = ainfo->flags | 1 << 1;
                    }

                    else
                    {
                      return_value_strcmp$45=strcmp(nptr, "#=SQ");
                      if(return_value_strcmp$45 == 0)
                      {
                        sptr=strtok((char *)(void *)0, " \t\n");
                        if(sptr == ((char *)NULL))
                          Die("Parse error in #=SQ line in ReadSELEX()");

                        signed int return_value_strcmp$39;
                        return_value_strcmp$39=strcmp(sptr, (ainfo->sqinfo + (signed long int)headnum)->name);
                        if(!(return_value_strcmp$39 == 0))
                          warn_names = 1;

                        sptr=strtok((char *)(void *)0, " \t\n");
                        if(sptr == ((char *)NULL))
                          Die("Parse error in #=SQ line in ReadSELEX()");

                        signed int return_value_IsReal$40;
                        return_value_IsReal$40=IsReal(sptr);
                        if(return_value_IsReal$40 == 0)
                          Die("Parse error in #=SQ line in ReadSELEX(): weight is not a number");

                        double return_value_atof$41;
                        return_value_atof$41=atof(sptr);
                        ainfo->wgt[(signed long int)headnum] = (float)return_value_atof$41;
                        sptr=strtok((char *)(void *)0, " \t\n");
                        if(sptr == ((char *)NULL))
                          Die("Parse error in #=SQ line in ReadSELEX(): incomplete line");

                        SetSeqinfoString(&ainfo->sqinfo[(signed long int)headnum], sptr, 1 << 1);
                        sptr=strtok((char *)(void *)0, " \t\n");
                        if(sptr == ((char *)NULL))
                          Die("Parse error in #=SQ line in ReadSELEX(): incomplete line");

                        SetSeqinfoString(&ainfo->sqinfo[(signed long int)headnum], sptr, 1 << 2);
                        sptr=strtok((char *)(void *)0, ".:");
                        if(sptr == ((char *)NULL))
                          Die("Parse error in #=SQ line in ReadSELEX(): incomplete line");

                        SetSeqinfoString(&ainfo->sqinfo[(signed long int)headnum], sptr, 1 << 4);
                        sptr=strtok((char *)(void *)0, ".:");
                        if(sptr == ((char *)NULL))
                          Die("Parse error in #=SQ line in ReadSELEX(): incomplete line");

                        SetSeqinfoString(&ainfo->sqinfo[(signed long int)headnum], sptr, 1 << 5);
                        sptr=strtok((char *)(void *)0, ":\t ");
                        if(sptr == ((char *)NULL))
                          Die("Parse error in #=SQ line in ReadSELEX(): incomplete line");

                        SetSeqinfoString(&ainfo->sqinfo[(signed long int)headnum], sptr, 1 << 8);
                        sptr=strtok((char *)(void *)0, "\n");
                        if(!(sptr == ((char *)NULL)))
                          SetSeqinfoString(&ainfo->sqinfo[(signed long int)headnum], sptr, 1 << 3);

                        headnum = headnum + 1;
                      }

                      else
                      {
                        return_value_strcmp$44=strcmp(nptr, "#=CS");
                        if(return_value_strcmp$44 == 0)
                          break;

                        else
                        {
                          return_value_strcmp$43=strcmp(nptr, "#=RF");
                          if(return_value_strcmp$43 == 0)
                            break;

                          else
                          {
                            return_value_strchr$42=strchr(commentsyms, (signed int)*nptr);
                            if(return_value_strchr$42 == ((char *)NULL))
                              break;

                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

    }
    while((_Bool)1);
    currlen = 0;
    currblock = 0;
    for( ; !(currblock >= blocknum); currblock = currblock + 1)
    {
      seqidx = 0;
      while(!(nptr == ((char *)NULL)))
      {
        signed int return_value_strcmp$71;
        return_value_strcmp$71=strcmp(nptr, "#=CS");
        if(return_value_strcmp$71 == 0)
        {
          unsigned long int return_value_strlen$57;
          return_value_strlen$57=strlen(nptr);
          signed int return_value_copy_alignment_line$58;
          return_value_copy_alignment_line$58=copy_alignment_line(ainfo->cs, currlen, (signed int)(return_value_strlen$57 - (unsigned long int)1), buffer, (blocks + (signed long int)currblock)->lcol, (blocks + (signed long int)currblock)->rcol, (char)46);
          if(return_value_copy_alignment_line$58 == 0)
            Die("Parse error in #=CS line in ReadSELEX()");

        }

        else
        {
          return_value_strcmp$70=strcmp(nptr, "#=RF");
          if(return_value_strcmp$70 == 0)
          {
            unsigned long int return_value_strlen$59;
            return_value_strlen$59=strlen(nptr);
            signed int return_value_copy_alignment_line$60;
            return_value_copy_alignment_line$60=copy_alignment_line(ainfo->rf, currlen, (signed int)(return_value_strlen$59 - (unsigned long int)1), buffer, (blocks + (signed long int)currblock)->lcol, (blocks + (signed long int)currblock)->rcol, (char)46);
            if(return_value_copy_alignment_line$60 == 0)
              Die("Parse error in #=RF line in ReadSELEX()");

          }

          else
          {
            return_value_strcmp$69=strcmp(nptr, "#=SS");
            if(return_value_strcmp$69 == 0)
            {
              unsigned long int return_value_strlen$61;
              return_value_strlen$61=strlen(nptr);
              signed int return_value_copy_alignment_line$62;
              return_value_copy_alignment_line$62=copy_alignment_line((ainfo->sqinfo + (signed long int)(seqidx - 1))->ss, currlen, (signed int)(return_value_strlen$61 - (unsigned long int)1), buffer, (blocks + (signed long int)currblock)->lcol, (blocks + (signed long int)currblock)->rcol, (char)46);
              if(return_value_copy_alignment_line$62 == 0)
                Die("Parse error in #=SS line in ReadSELEX()");

            }

            else
            {
              return_value_strcmp$68=strcmp(nptr, "#=SA");
              if(return_value_strcmp$68 == 0)
              {
                unsigned long int return_value_strlen$63;
                return_value_strlen$63=strlen(nptr);
                signed int return_value_copy_alignment_line$64;
                return_value_copy_alignment_line$64=copy_alignment_line((ainfo->sqinfo + (signed long int)(seqidx - 1))->sa, currlen, (signed int)(return_value_strlen$63 - (unsigned long int)1), buffer, (blocks + (signed long int)currblock)->lcol, (blocks + (signed long int)currblock)->rcol, (char)46);
                if(return_value_copy_alignment_line$64 == 0)
                  Die("Parse error in #=SA line in ReadSELEX()");

              }

              else
              {
                return_value_strncmp$67=strncmp(nptr, "#=", (unsigned long int)2);
                if(!(return_value_strncmp$67 == 0))
                {
                  unsigned long int return_value_strlen$65;
                  return_value_strlen$65=strlen(nptr);
                  signed int return_value_copy_alignment_line$66;
                  return_value_copy_alignment_line$66=copy_alignment_line(aseqs[(signed long int)seqidx], currlen, (signed int)(return_value_strlen$65 - (unsigned long int)1), buffer, (blocks + (signed long int)currblock)->lcol, (blocks + (signed long int)currblock)->rcol, (char)46);
                  if(return_value_copy_alignment_line$66 == 0)
                    Die("Parse error in alignment line in ReadSELEX()");

                  seqidx = seqidx + 1;
                }

              }
            }
          }
        }
        do
        {
          nptr = (char *)(void *)0;
          char *return_value_fgets$72;
          return_value_fgets$72=fgets(buffer, 4096, fp);
          if(return_value_fgets$72 == ((char *)NULL))
            break;

          strcpy(bufcpy, buffer);
          nptr=strtok(bufcpy, " \t\n");
          if(nptr == ((char *)NULL))
            break;

          signed int return_value_strncmp$73;
          return_value_strncmp$73=strncmp(buffer, "#=", (unsigned long int)2);
          if(return_value_strncmp$73 == 0)
            break;

          char *return_value_strchr$74;
          return_value_strchr$74=strchr(commentsyms, (signed int)*nptr);
          if(return_value_strchr$74 == ((char *)NULL))
            break;

        }
        while((_Bool)1);
      }
      currlen = currlen + ((blocks + (signed long int)currblock)->rcol - (blocks + (signed long int)currblock)->lcol) + 1;
      do
      {
        char *return_value_fgets$75;
        return_value_fgets$75=fgets(buffer, 4096, fp);
        if(return_value_fgets$75 == ((char *)NULL))
          break;

        strcpy(bufcpy, buffer);
        nptr=strtok(bufcpy, " \t\n");
        if(!(nptr == ((char *)NULL)))
        {
          signed int return_value_strncmp$76;
          return_value_strncmp$76=strncmp(buffer, "#=", (unsigned long int)2);
          if(return_value_strncmp$76 == 0)
            break;

          char *return_value_strchr$77;
          return_value_strchr$77=strchr(commentsyms, (signed int)*nptr);
          if(return_value_strchr$77 == ((char *)NULL))
            break;

        }

      }
      while((_Bool)1);
    }
    seqidx = 0;
    for( ; !(seqidx >= num); seqidx = seqidx + 1)
    {
      signed int apos;
      signed int rpos;
      if(!((512 & (ainfo->sqinfo + (signed long int)seqidx)->flags) == 0))
      {
        rpos = 0;
        apos = rpos;
        for( ; !(apos >= alen); apos = apos + 1)
        {
          if((signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 32)
            tmp_if_expr$78 = (_Bool)1;

          else
            tmp_if_expr$78 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$78)
            tmp_if_expr$79 = (_Bool)1;

          else
            tmp_if_expr$79 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$79)
            tmp_if_expr$80 = (_Bool)1;

          else
            tmp_if_expr$80 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$80)
            tmp_if_expr$81 = (_Bool)1;

          else
            tmp_if_expr$81 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$81)
          {
            (ainfo->sqinfo + (signed long int)seqidx)->ss[(signed long int)rpos] = (ainfo->sqinfo + (signed long int)seqidx)->ss[(signed long int)apos];
            rpos = rpos + 1;
          }

        }
        (ainfo->sqinfo + (signed long int)seqidx)->ss[(signed long int)rpos] = (char)0;
      }

      if(!((1024 & (ainfo->sqinfo + (signed long int)seqidx)->flags) == 0))
      {
        rpos = 0;
        apos = rpos;
        for( ; !(apos >= alen); apos = apos + 1)
        {
          if((signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 32)
            tmp_if_expr$82 = (_Bool)1;

          else
            tmp_if_expr$82 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$82)
            tmp_if_expr$83 = (_Bool)1;

          else
            tmp_if_expr$83 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$83)
            tmp_if_expr$84 = (_Bool)1;

          else
            tmp_if_expr$84 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$84)
            tmp_if_expr$85 = (_Bool)1;

          else
            tmp_if_expr$85 = (signed int)aseqs[(signed long int)seqidx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$85)
          {
            (ainfo->sqinfo + (signed long int)seqidx)->sa[(signed long int)rpos] = (ainfo->sqinfo + (signed long int)seqidx)->sa[(signed long int)apos];
            rpos = rpos + 1;
          }

        }
        (ainfo->sqinfo + (signed long int)seqidx)->sa[(signed long int)rpos] = (char)0;
      }

    }
    if(!(ainfo->rf == ((char *)NULL)))
      ainfo->rf[(signed long int)alen] = (char)0;

    if(!(ainfo->cs == ((char *)NULL)))
      ainfo->cs[(signed long int)alen] = (char)0;

    seqidx = 0;
    for( ; !(seqidx >= num); seqidx = seqidx + 1)
      aseqs[(signed long int)seqidx][(signed long int)alen] = (char)0;
    seqidx = 0;
    for( ; !(seqidx >= num); seqidx = seqidx + 1)
    {
      count = 0;
      sptr = aseqs[(signed long int)seqidx];
      for( ; !((signed int)*sptr == 0); sptr = sptr + 1l)
      {
        if((signed int)*sptr == 32)
          tmp_if_expr$86 = (_Bool)1;

        else
          tmp_if_expr$86 = (signed int)*sptr == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$86)
          tmp_if_expr$87 = (_Bool)1;

        else
          tmp_if_expr$87 = (signed int)*sptr == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$87)
          tmp_if_expr$88 = (_Bool)1;

        else
          tmp_if_expr$88 = (signed int)*sptr == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$88)
          tmp_if_expr$89 = (_Bool)1;

        else
          tmp_if_expr$89 = (signed int)*sptr == 126 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$89)
          count = count + 1;

      }
      (ainfo->sqinfo + (signed long int)seqidx)->len = count;
      (ainfo->sqinfo + (signed long int)seqidx)->flags = (ainfo->sqinfo + (signed long int)seqidx)->flags | 1 << 6;
    }
    free((void *)blocks);
    if(!(warn_names == 0))
      Warn("sequences may be in different orders in blocks of %s?", afp->fname);

    msa=MSAFromAINFO(aseqs, ainfo);
    MSAVerifyParse(msa);
    FreeAlignment(aseqs, ainfo);
    return msa;
  }
}

// ReadSeq
// file sqio.c line 1038
extern signed int ReadSeq(struct ReadSeqVars *V, signed int format, char **ret_seq, struct seqinfo_s *sqinfo)
{
  signed int gotuw;
  squid_errno = 0;
  signed int return_value_feof$4;
  if(V->format >= 101)
  {
    if(V->msa->lastidx >= V->msa->nseq)
    {
      MSAFree(V->msa);
      V->msa=MSAFileRead(V->afp);
      if(V->msa == ((struct msa_struct *)NULL))
        return 0;

      V->msa->lastidx = 0;
    }

    MakeDealignedString(V->msa->aseq[(signed long int)V->msa->lastidx], V->msa->alen, V->msa->aseq[(signed long int)V->msa->lastidx], &V->seq);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(V->seq);
    V->seqlen = (signed int)return_value_strlen$1;
    sqinfo->flags = 0;
    if(!(V->msa->sqname[(signed long int)V->msa->lastidx] == ((char *)NULL)))
      SetSeqinfoString(sqinfo, V->msa->sqname[(signed long int)V->msa->lastidx], 1 << 0);

    if(!(V->msa->sqacc == ((char **)NULL)))
    {
      if(!(V->msa->sqacc[(signed long int)V->msa->lastidx] == ((char *)NULL)))
        SetSeqinfoString(sqinfo, V->msa->sqacc[(signed long int)V->msa->lastidx], 1 << 2);

    }

    if(!(V->msa->sqdesc == ((char **)NULL)))
    {
      if(!(V->msa->sqdesc[(signed long int)V->msa->lastidx] == ((char *)NULL)))
        SetSeqinfoString(sqinfo, V->msa->sqdesc[(signed long int)V->msa->lastidx], 1 << 3);

    }

    if(!(V->msa->ss == ((char **)NULL)))
    {
      if(!(V->msa->ss[(signed long int)V->msa->lastidx] == ((char *)NULL)))
      {
        MakeDealignedString(V->msa->aseq[(signed long int)V->msa->lastidx], V->msa->alen, V->msa->ss[(signed long int)V->msa->lastidx], &sqinfo->ss);
        sqinfo->flags = sqinfo->flags | 1 << 9;
      }

    }

    if(!(V->msa->sa == ((char **)NULL)))
    {
      if(!(V->msa->sa[(signed long int)V->msa->lastidx] == ((char *)NULL)))
      {
        MakeDealignedString(V->msa->aseq[(signed long int)V->msa->lastidx], V->msa->alen, V->msa->sa[(signed long int)V->msa->lastidx], &sqinfo->sa);
        sqinfo->flags = sqinfo->flags | 1 << 10;
      }

    }

    V->msa->lastidx = V->msa->lastidx + 1;
  }

  else
  {
    signed int return_value_feof$2;
    return_value_feof$2=feof(V->f);
    if(!(return_value_feof$2 == 0))
      return 0;

    if(V->ssimode == -1)
    {
      void *return_value_calloc$3;
      return_value_calloc$3=calloc((unsigned long int)(500 + 1), sizeof(char) /*1ul*/ );
      V->seq = (char *)return_value_calloc$3;
      V->maxseq = 500;
    }

    else
    {
      V->seq = (char *)(void *)0;
      V->maxseq = 0;
    }
    V->seqlen = 0;
    V->sqinfo = sqinfo;
    V->sqinfo->flags = 0;
    switch(V->format)
    {
      case 1:
      {
        readIG(V);
        break;
      }
      case 6:
      {
        readStrider(V);
        break;
      }
      case 2:
      {
        readGenBank(V);
        break;
      }
      case 7:
      {
        readPearson(V);
        break;
      }
      case 4:
      {
        readEMBL(V);
        break;
      }
      case 8:
      {
        readZuker(V);
        break;
      }
      case 12:
      {
        readPIR(V);
        break;
      }
      case 16:
      {
        readGCGdata(V);
        break;
      }
      case 5:
      {
        do
        {
          char *return_value_strstr$5;
          return_value_strstr$5=strstr(V->buf, "..");
          gotuw = (signed int)(return_value_strstr$5 != (char *)(void *)0);
          if(!(gotuw == 0))
            readUWGCG(V);

          SeqfileGetLine(V);
          return_value_feof$4=feof(V->f);
        }
        while(return_value_feof$4 == 0);
        break;
      }
      case 9:

      default:
      {
        squid_errno = 5;
        free((void *)V->seq);
        return 0;
      }
    }
    if(!(V->seq == ((char *)NULL)))
      V->seq[(signed long int)V->seqlen] = (char)0;

  }
  sqinfo->len = V->seqlen;
  sqinfo->flags = sqinfo->flags | 1 << 6;
  *ret_seq = V->seq;
  if(squid_errno == 0)
    return 1;

  else
    return 0;
}

// ReadStockholm
// file msa.h line 294
extern struct msa_struct * ReadStockholm(struct msafile_struct *afp)
{
  struct msa_struct *msa;
  char *s;
  signed int status;
  signed int return_value_feof$1;
  return_value_feof$1=feof(afp->f);
  signed int return_value_IsBlankline$2;
  signed int return_value_strncmp$6;
  signed int return_value_strncmp$5;
  signed int return_value_strncmp$4;
  signed int return_value_strncmp$8;
  char *tmp_if_expr$9;
  char *tmp_if_expr$10;
  if(!(return_value_feof$1 == 0))
    return (struct msa_struct *)(void *)0;

  else
  {
    msa=MSAAlloc(10, 0);
    do
    {
      s=MSAFileGetLine(afp);
      if(s == ((char *)NULL))
      {
        MSAFree(msa);
        return (struct msa_struct *)(void *)0;
      }

      return_value_IsBlankline$2=IsBlankline(s);
    }
    while(!(return_value_IsBlankline$2 == 0));
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(s, "# STOCKHOLM 1.", (unsigned long int)14);
    if(!(return_value_strncmp$3 == 0))
      Die("File %s doesn't appear to be in Stockholm format.\nAssuming there isn't some other problem with your file (it is an\nalignment file, right?), please either:\n  a) use the Babelfish format autotranslator option (-B, usually);\n  b) specify the file's format with the --informat option; or\n  a) reformat the alignment to Stockholm format.\n", afp->fname);

    do
    {
      s=MSAFileGetLine(afp);
      if(s == ((char *)NULL))
        break;

      for( ; (_Bool)1; s = s + 1l)
        if(!((signed int)*s == 32))
        {
          if(!((signed int)*s == 9))
            goto __CPROVER_DUMP_L7;

        }


    __CPROVER_DUMP_L7:
      ;
      if((signed int)*s == 35)
      {
        signed int return_value_strncmp$7;
        return_value_strncmp$7=strncmp(s, "#=GF", (unsigned long int)4);
        if(return_value_strncmp$7 == 0)
          status=parse_gf(msa, s);

        else
        {
          return_value_strncmp$6=strncmp(s, "#=GS", (unsigned long int)4);
          if(return_value_strncmp$6 == 0)
            status=parse_gs(msa, s);

          else
          {
            return_value_strncmp$5=strncmp(s, "#=GC", (unsigned long int)4);
            if(return_value_strncmp$5 == 0)
              status=parse_gc(msa, s);

            else
            {
              return_value_strncmp$4=strncmp(s, "#=GR", (unsigned long int)4);
              if(return_value_strncmp$4 == 0)
                status=parse_gr(msa, s);

              else
                status=parse_comment(msa, s);
            }
          }
        }
      }

      else
      {
        return_value_strncmp$8=strncmp(s, "//", (unsigned long int)2);
        if(return_value_strncmp$8 == 0)
          break;

        else
          if((signed int)*s == 10)
            continue;

          else
            status=parse_sequence(msa, s);
      }
      if(status == 0)
      {
        if(msa->name == ((char *)NULL))
          tmp_if_expr$9 = "";

        else
          tmp_if_expr$9 = msa->name;
        Die("Stockholm format parse error: line %d of file %s while reading alignment %s", afp->linenumber, afp->fname, tmp_if_expr$9);
      }

    }
    while((_Bool)1);
    if(s == ((char *)NULL))
    {
      if(!(msa->nseq == 0))
      {
        if(msa->name == ((char *)NULL))
          tmp_if_expr$10 = "";

        else
          tmp_if_expr$10 = msa->name;
        Die("Didn't find // at end of alignment %s", tmp_if_expr$10);
      }

    }

    if(s == ((char *)NULL))
    {
      if(!(msa->nseq == 0))
        goto __CPROVER_DUMP_L25;

      MSAFree(msa);
      return (struct msa_struct *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L25:
      ;
      MSAVerifyParse(msa);
      return msa;
    }
  }
}

// RegisterHit
// file funcs.h line 312
extern void RegisterHit(struct tophit_s *h, double key, double pvalue, float score, double motherp, float mothersc, char *name, char *acc, char *desc, signed int sqfrom, signed int sqto, signed int sqlen, signed int hmmfrom, signed int hmmto, signed int hmmlen, signed int domidx, signed int ndom, struct fancyali_s *ali)
{
  if(h->num == h->alloc)
    GrowTophits(h);

  (h->unsrt + (signed long int)h->num)->name=Strdup(name);
  (h->unsrt + (signed long int)h->num)->acc=Strdup(acc);
  (h->unsrt + (signed long int)h->num)->desc=Strdup(desc);
  (h->unsrt + (signed long int)h->num)->sortkey = key;
  (h->unsrt + (signed long int)h->num)->pvalue = pvalue;
  (h->unsrt + (signed long int)h->num)->score = score;
  (h->unsrt + (signed long int)h->num)->motherp = motherp;
  (h->unsrt + (signed long int)h->num)->mothersc = mothersc;
  (h->unsrt + (signed long int)h->num)->sqfrom = sqfrom;
  (h->unsrt + (signed long int)h->num)->sqto = sqto;
  (h->unsrt + (signed long int)h->num)->sqlen = sqlen;
  (h->unsrt + (signed long int)h->num)->hmmfrom = hmmfrom;
  (h->unsrt + (signed long int)h->num)->hmmto = hmmto;
  (h->unsrt + (signed long int)h->num)->hmmlen = hmmlen;
  (h->unsrt + (signed long int)h->num)->domidx = domidx;
  (h->unsrt + (signed long int)h->num)->ndom = ndom;
  (h->unsrt + (signed long int)h->num)->ali = ali;
  h->num = h->num + 1;
}

// ResizePlan7Matrix
// file core_algorithms.c line 134
extern void ResizePlan7Matrix(struct dpmatrix_s *mx, signed int N, signed int M, signed int ***xmx, signed int ***mmx, signed int ***imx, signed int ***dmx)
{
  signed int i;
  if(mx->maxN >= N)
  {
    if(mx->maxM >= M)
      goto DONE;

  }

  if(!(mx->maxN >= N))
  {
    N = N + mx->padN;
    mx->maxN = N;
    void *return_value_sre_realloc$1;
    return_value_sre_realloc$1=sre_realloc("core_algorithms.c", 144, (void *)mx->xmx, sizeof(signed int *) /*8ul*/  * (unsigned long int)(mx->maxN + 1));
    mx->xmx = (signed int **)return_value_sre_realloc$1;
    void *return_value_sre_realloc$2;
    return_value_sre_realloc$2=sre_realloc("core_algorithms.c", 145, (void *)mx->mmx, sizeof(signed int *) /*8ul*/  * (unsigned long int)(mx->maxN + 1));
    mx->mmx = (signed int **)return_value_sre_realloc$2;
    void *return_value_sre_realloc$3;
    return_value_sre_realloc$3=sre_realloc("core_algorithms.c", 146, (void *)mx->imx, sizeof(signed int *) /*8ul*/  * (unsigned long int)(mx->maxN + 1));
    mx->imx = (signed int **)return_value_sre_realloc$3;
    void *return_value_sre_realloc$4;
    return_value_sre_realloc$4=sre_realloc("core_algorithms.c", 147, (void *)mx->dmx, sizeof(signed int *) /*8ul*/  * (unsigned long int)(mx->maxN + 1));
    mx->dmx = (signed int **)return_value_sre_realloc$4;
  }

  if(!(mx->maxM >= M))
  {
    M = M + mx->padM;
    mx->maxM = M;
  }

  void *return_value_sre_realloc$5;
  return_value_sre_realloc$5=sre_realloc("core_algorithms.c", 155, mx->xmx_mem, sizeof(signed int) /*4ul*/  * (unsigned long int)((mx->maxN + 1) * 5));
  mx->xmx_mem = (void *)return_value_sre_realloc$5;
  void *return_value_sre_realloc$6;
  return_value_sre_realloc$6=sre_realloc("core_algorithms.c", 156, mx->mmx_mem, sizeof(signed int) /*4ul*/  * (unsigned long int)((mx->maxN + 1) * (mx->maxM + 2)));
  mx->mmx_mem = (void *)return_value_sre_realloc$6;
  void *return_value_sre_realloc$7;
  return_value_sre_realloc$7=sre_realloc("core_algorithms.c", 157, mx->imx_mem, sizeof(signed int) /*4ul*/  * (unsigned long int)((mx->maxN + 1) * (mx->maxM + 2)));
  mx->imx_mem = (void *)return_value_sre_realloc$7;
  void *return_value_sre_realloc$8;
  return_value_sre_realloc$8=sre_realloc("core_algorithms.c", 158, mx->dmx_mem, sizeof(signed int) /*4ul*/  * (unsigned long int)((mx->maxN + 1) * (mx->maxM + 2)));
  mx->dmx_mem = (void *)return_value_sre_realloc$8;
  mx->xmx[(signed long int)0] = (signed int *)mx->xmx_mem;
  mx->mmx[(signed long int)0] = (signed int *)mx->mmx_mem;
  mx->imx[(signed long int)0] = (signed int *)mx->imx_mem;
  mx->dmx[(signed long int)0] = (signed int *)mx->dmx_mem;
  i = 1;
  for( ; mx->maxN >= i; i = i + 1)
  {
    mx->xmx[(signed long int)i] = mx->xmx[(signed long int)0] + (signed long int)(i * 5);
    mx->mmx[(signed long int)i] = mx->mmx[(signed long int)0] + (signed long int)(i * (mx->maxM + 2));
    mx->imx[(signed long int)i] = mx->imx[(signed long int)0] + (signed long int)(i * (mx->maxM + 2));
    mx->dmx[(signed long int)i] = mx->dmx[(signed long int)0] + (signed long int)(i * (mx->maxM + 2));
  }

DONE:
  ;
  if(!(xmx == ((signed int ***)NULL)))
    *xmx = mx->xmx;

  if(!(mmx == ((signed int ***)NULL)))
    *mmx = mx->mmx;

  if(!(imx == ((signed int ***)NULL)))
    *imx = mx->imx;

  if(!(dmx == ((signed int ***)NULL)))
    *dmx = mx->dmx;

}

// ReverseIntStack
// file stack.c line 75
extern void ReverseIntStack(struct intstack_s *stack)
{
  struct intstack_s *old;
  struct intstack_s *new;
  old = stack->nxt;
  stack->nxt = (struct intstack_s *)(void *)0;
  for( ; !(old == ((struct intstack_s *)NULL)); stack->nxt = new)
  {
    new = old;
    old = old->nxt;
    new->nxt = stack->nxt;
  }
}

// SAMizeAlignment
// file alignio.c line 144
extern void SAMizeAlignment(char **aseq, signed int nseq, signed int alen)
{
  signed int col;
  signed int i;
  signed int sawlower;
  signed int sawupper;
  signed int sawgap;
  char gapchar;
  col = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  for( ; !(col >= alen); col = col + 1)
  {
    sawgap = 0;
    sawupper = sawgap;
    sawlower = sawupper;
    i = 0;
    for( ; !(i >= nseq); i = i + 1)
    {
      if((signed int)aseq[(signed long int)i][(signed long int)col] == 32)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)aseq[(signed long int)i][(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)aseq[(signed long int)i][(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)aseq[(signed long int)i][(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)aseq[(signed long int)i][(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        sawgap = 1;

      else
      {
        const unsigned short int **return_value___ctype_b_loc$5;
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if(!((256 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)aseq[(signed long int)i][(signed long int)col]]) == 0))
          sawupper = 1;

        else
        {
          const unsigned short int **return_value___ctype_b_loc$6;
          return_value___ctype_b_loc$6=__ctype_b_loc();
          if(!((512 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)aseq[(signed long int)i][(signed long int)col]]) == 0))
            sawlower = 1;

        }
      }
    }
    gapchar = (char)45;
    if(sawupper == 0 && !(sawlower == 0))
      gapchar = (char)46;

    i = 0;
    for( ; !(i >= nseq); i = i + 1)
    {
      if((signed int)aseq[(signed long int)i][(signed long int)col] == 32)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)aseq[(signed long int)i][(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)aseq[(signed long int)i][(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = (signed int)aseq[(signed long int)i][(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = (signed int)aseq[(signed long int)i][(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$10)
        aseq[(signed long int)i][(signed long int)col] = gapchar;

    }
  }
}

// SAMizeAlignmentByGapFrac
// file alignio.c line 190
extern void SAMizeAlignmentByGapFrac(char **aseq, signed int nseq, signed int alen, float maxgap)
{
  signed int apos;
  signed int idx;
  signed int ngap;
  apos = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  signed int return_value_tolower$5;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  signed int return_value_toupper$10;
  for( ; !(apos >= alen); apos = apos + 1)
  {
    ngap = 0;
    idx = 0;
    for( ; !(idx >= nseq); idx = idx + 1)
    {
      if((signed int)aseq[(signed long int)idx][(signed long int)apos] == 32)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        ngap = ngap + 1;

    }
    if((float)ngap / (float)nseq > maxgap)
    {
      idx = 0;
      for( ; !(idx >= nseq); idx = idx + 1)
      {
        if((signed int)aseq[(signed long int)idx][(signed long int)apos] == 32)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
          aseq[(signed long int)idx][(signed long int)apos] = (char)46;

        else
        {
          return_value_tolower$5=tolower((signed int)aseq[(signed long int)idx][(signed long int)apos]);
          aseq[(signed long int)idx][(signed long int)apos] = (char)return_value_tolower$5;
        }
      }
    }

    else
    {
      idx = 0;
      for( ; !(idx >= nseq); idx = idx + 1)
      {
        if((signed int)aseq[(signed long int)idx][(signed long int)apos] == 32)
          tmp_if_expr$11 = (_Bool)1;

        else
          tmp_if_expr$11 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$11)
          tmp_if_expr$12 = (_Bool)1;

        else
          tmp_if_expr$12 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$12)
          tmp_if_expr$13 = (_Bool)1;

        else
          tmp_if_expr$13 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$13)
          tmp_if_expr$14 = (_Bool)1;

        else
          tmp_if_expr$14 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$14)
          aseq[(signed long int)idx][(signed long int)apos] = (char)45;

        else
        {
          return_value_toupper$10=toupper((signed int)aseq[(signed long int)idx][(signed long int)apos]);
          aseq[(signed long int)idx][(signed long int)apos] = (char)return_value_toupper$10;
        }
      }
    }
  }
}

// SSIAddFileToIndex
// file ssi.c line 623
extern signed int SSIAddFileToIndex(struct ssiindex_s *g, char *filename, signed int fmt, signed int *ret_fh)
{
  signed int n;
  if((signed int)g->nfiles >= 32767)
    return 13;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(filename);
    n = (signed int)return_value_strlen$1;
    if(!(g->flen >= 1u + (unsigned int)n))
      g->flen = (unsigned int)(n + 1);

    g->filenames[(signed long int)g->nfiles]=FileTail(filename, 0);
    g->fileformat[(signed long int)g->nfiles] = (unsigned int)fmt;
    g->bpl[(signed long int)g->nfiles] = (unsigned int)0;
    g->rpl[(signed long int)g->nfiles] = (unsigned int)0;
    *ret_fh = (signed int)g->nfiles;
    g->nfiles = g->nfiles + 1;
    if((signed int)g->nfiles % 10 == 0)
    {
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)g->filenames, sizeof(char *) /*8ul*/  * (unsigned long int)((signed int)g->nfiles + 10));
      g->filenames = (char **)return_value_realloc$2;
      if(g->filenames == ((char **)NULL))
        return 3;

      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)g->fileformat, sizeof(unsigned int) /*4ul*/  * (unsigned long int)((signed int)g->nfiles + 10));
      g->fileformat = (unsigned int *)return_value_realloc$3;
      if(g->fileformat == ((unsigned int *)NULL))
        return 3;

      void *return_value_realloc$4;
      return_value_realloc$4=realloc((void *)g->bpl, sizeof(unsigned int) /*4ul*/  * (unsigned long int)((signed int)g->nfiles + 10));
      g->bpl = (unsigned int *)return_value_realloc$4;
      if(g->bpl == ((unsigned int *)NULL))
        return 3;

      void *return_value_realloc$5;
      return_value_realloc$5=realloc((void *)g->rpl, sizeof(unsigned int) /*4ul*/  * (unsigned long int)((signed int)g->nfiles + 10));
      g->rpl = (unsigned int *)return_value_realloc$5;
      if(g->rpl == ((unsigned int *)NULL))
        return 3;

    }

    return 0;
  }
}

// SSIAddPrimaryKeyToIndex
// file ssi.c line 720
extern signed int SSIAddPrimaryKeyToIndex(struct ssiindex_s *g, char *key, signed int fh, struct ssioffset_s *r_off, struct ssioffset_s *d_off, signed int L)
{
  signed int n;
  unsigned long int return_value_current_index_size$2;
  signed int return_value_activate_external_sort$1;
  unsigned int tmp_if_expr$4;
  unsigned long int tmp_if_expr$5;
  if(fh >= 32767)
    return 13;

  else
    if((signed long int)g->nprimary >= 2147483647L)
      return 14;

    else
    {
      if(d_off == ((struct ssioffset_s *)NULL) && L >= 1)
        abort();

      if(g->external == 0)
      {
        return_value_current_index_size$2=current_index_size(g);
        if(!(return_value_current_index_size$2 >= (unsigned long int)g->max_ram))
          goto __CPROVER_DUMP_L4;

        return_value_activate_external_sort$1=activate_external_sort(g);
        if(return_value_activate_external_sort$1 == 0)
          goto __CPROVER_DUMP_L4;

        return 4;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(key);
        n = (signed int)return_value_strlen$3;
        if(!(g->plen >= 1u + (unsigned int)n))
          g->plen = (unsigned int)(n + 1);

        if(!(g->external == 0))
        {
          if(g->smode == 0)
          {
            if(d_off == ((struct ssioffset_s *)NULL))
              tmp_if_expr$4 = (unsigned int)0;

            else
              tmp_if_expr$4 = d_off->off.i32;
            fprintf(g->ptmp, "%s\t%d\t%lu\t%lu\t%lu\n", key, fh, (unsigned long int)r_off->off.i32, (unsigned long int)tmp_if_expr$4, (unsigned long int)L);
          }

          else
          {
            if(d_off == ((struct ssioffset_s *)NULL))
              tmp_if_expr$5 = (unsigned long int)0;

            else
              tmp_if_expr$5 = d_off->off.i64;
            fprintf(g->ptmp, "%s\t%d\t%llu\t%llu\t%lu\n", key, fh, (unsigned long long int)r_off->off.i64, (unsigned long long int)tmp_if_expr$5, (unsigned long int)L);
          }
          g->nprimary = g->nprimary + 1u;
          return 0;
        }

        else
        {
          (g->pkeys + (signed long int)g->nprimary)->key=sre_strdup(key, n);
          if((g->pkeys + (signed long int)g->nprimary)->key == ((char *)NULL))
            return 3;

          else
          {
            (g->pkeys + (signed long int)g->nprimary)->fnum = (unsigned short int)fh;
            (g->pkeys + (signed long int)g->nprimary)->r_off = *r_off;
            if(L >= 1 && !(d_off == ((struct ssioffset_s *)NULL)))
            {
              (g->pkeys + (signed long int)g->nprimary)->d_off = *d_off;
              (g->pkeys + (signed long int)g->nprimary)->len = (unsigned int)L;
            }

            else
            {
              (g->pkeys + (signed long int)g->nprimary)->d_off = *r_off;
              (g->pkeys + (signed long int)g->nprimary)->len = (unsigned int)0;
            }
            g->nprimary = g->nprimary + 1u;
            if(g->nprimary % 100u == 0u)
            {
              void *return_value_realloc$6;
              return_value_realloc$6=realloc((void *)g->pkeys, sizeof(struct ssipkey_s) /*56ul*/  * (unsigned long int)(g->nprimary + (unsigned int)100));
              g->pkeys = (struct ssipkey_s *)return_value_realloc$6;
              if(g->pkeys == ((struct ssipkey_s *)NULL))
                return 3;

            }

            return 0;
          }
        }
      }
    }
}

// SSIAddSecondaryKeyToIndex
// file ssi.c line 797
extern signed int SSIAddSecondaryKeyToIndex(struct ssiindex_s *g, char *key, char *pkey)
{
  signed int n;
  unsigned long int return_value_current_index_size$2;
  signed int return_value_activate_external_sort$1;
  if((signed long int)g->nsecondary >= 2147483647L)
    return 14;

  else
    if(g->external == 0)
    {
      return_value_current_index_size$2=current_index_size(g);
      if(!(return_value_current_index_size$2 >= (unsigned long int)g->max_ram))
        goto __CPROVER_DUMP_L2;

      return_value_activate_external_sort$1=activate_external_sort(g);
      if(return_value_activate_external_sort$1 == 0)
        goto __CPROVER_DUMP_L2;

      return 4;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(key);
      n = (signed int)return_value_strlen$3;
      if(!(g->slen >= 1u + (unsigned int)n))
        g->slen = (unsigned int)(n + 1);

      if(!(g->external == 0))
      {
        fprintf(g->stmp, "%s\t%s\n", key, pkey);
        g->nsecondary = g->nsecondary + 1u;
        return 0;
      }

      else
      {
        (g->skeys + (signed long int)g->nsecondary)->key=sre_strdup(key, n);
        if((g->skeys + (signed long int)g->nsecondary)->key == ((char *)NULL))
          return 3;

        else
        {
          (g->skeys + (signed long int)g->nsecondary)->pkey=sre_strdup(pkey, -1);
          if((g->skeys + (signed long int)g->nsecondary)->pkey == ((char *)NULL))
            return 3;

          else
          {
            g->nsecondary = g->nsecondary + 1u;
            if(g->nsecondary % 100u == 0u)
            {
              void *return_value_realloc$4;
              return_value_realloc$4=realloc((void *)g->skeys, sizeof(struct ssiskey_s) /*16ul*/  * (unsigned long int)(g->nsecondary + (unsigned int)100));
              g->skeys = (struct ssiskey_s *)return_value_realloc$4;
              if(g->skeys == ((struct ssiskey_s *)NULL))
                return 3;

            }

            return 0;
          }
        }
      }
    }
}

// SSIClose
// file ../squid/ssi.h line 167
extern void SSIClose(struct ssifile_s *sfp)
{
  if(!(sfp == ((struct ssifile_s *)NULL)))
  {
    clear_ssifile(sfp);
    if(!(sfp->fp == ((struct _IO_FILE *)NULL)))
      fclose(sfp->fp);

    free((void *)sfp);
  }

}

// SSICreateIndex
// file ssi.c line 509
extern struct ssiindex_s * SSICreateIndex(signed int mode)
{
  struct ssiindex_s *g = (struct ssiindex_s *)(void *)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ssiindex_s) /*120ul*/ );
  g = (struct ssiindex_s *)return_value_malloc$1;
  void *return_value_malloc$2;
  void *return_value_malloc$3;
  void *return_value_malloc$4;
  void *return_value_malloc$5;
  void *return_value_malloc$6;
  void *return_value_malloc$7;
  if(!(g == ((struct ssiindex_s *)NULL)))
  {
    g->smode = mode;
    g->imode = 0;
    g->external = 0;
    g->max_ram = 200;
    g->filenames = (char **)(void *)0;
    g->fileformat = (unsigned int *)(void *)0;
    g->bpl = (unsigned int *)(void *)0;
    g->rpl = (unsigned int *)(void *)0;
    g->flen = (unsigned int)0;
    g->nfiles = (unsigned short int)0;
    g->pkeys = (struct ssipkey_s *)(void *)0;
    g->plen = (unsigned int)0;
    g->nprimary = (unsigned int)0;
    g->ptmpfile = "tmp.ssi.1";
    g->ptmp = (struct _IO_FILE *)(void *)0;
    g->skeys = (struct ssiskey_s *)(void *)0;
    g->slen = (unsigned int)0;
    g->nsecondary = (unsigned int)0;
    g->stmpfile = "tmp.ssi.2";
    g->stmp = (struct _IO_FILE *)(void *)0;
    return_value_malloc$2=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)10);
    g->filenames = (char **)return_value_malloc$2;
    if(g->filenames == ((char **)NULL))
      goto FAILURE;

    return_value_malloc$3=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)10);
    g->fileformat = (unsigned int *)return_value_malloc$3;
    if(g->fileformat == ((unsigned int *)NULL))
      goto FAILURE;

    return_value_malloc$4=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)10);
    g->bpl = (unsigned int *)return_value_malloc$4;
    if(g->bpl == ((unsigned int *)NULL))
      goto FAILURE;

    return_value_malloc$5=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)10);
    g->rpl = (unsigned int *)return_value_malloc$5;
    if(g->rpl == ((unsigned int *)NULL))
      goto FAILURE;

    return_value_malloc$6=malloc(sizeof(struct ssipkey_s) /*56ul*/  * (unsigned long int)100);
    g->pkeys = (struct ssipkey_s *)return_value_malloc$6;
    if(g->pkeys == ((struct ssipkey_s *)NULL))
      goto FAILURE;

    return_value_malloc$7=malloc(sizeof(struct ssipkey_s) /*56ul*/  * (unsigned long int)100);
    g->skeys = (struct ssiskey_s *)return_value_malloc$7;
    if(g->skeys == ((struct ssiskey_s *)NULL))
      goto FAILURE;

    return g;
  }

  else
  {

  FAILURE:
    ;
    SSIFreeIndex(g);
    return (struct ssiindex_s *)(void *)0;
  }
}

// SSIErrorString
// file ssi.c line 1108
extern char * SSIErrorString(signed int n)
{
  switch(n)
  {
    case 0:
      return "ok (no error)";
    case 1:
      return "no data, fread() failed";
    case 2:
      return "no such key";
    case 3:
      return "out of memory, malloc() failed";
    case 4:
      return "file not found, fopen() failed";
    case 5:
      return "not a SSI file? (bad magic)";
    case 6:
      return "corrupt format? unexpected data";
    case 7:
      return "no large file support for this system";
    case 8:
      return "failed to reposition on disk";
    case 9:
      return "failed to get file position on disk";
    case 10:
      return "no fast subseq support for this seqfile";
    case 11:
      return "subseq start is out of range";
    case 12:
      return "an argument is out of range";
    case 13:
      return "number of files exceeds limit";
    case 14:
      return "number of keys exceeds limit";
    case 15:
      return "an fwrite() failed";
    case 16:
      return "some problem with external sorting";
    default:
      return "unrecognized code";
  }
}

// SSIFileInfo
// file ssi.c line 416
extern signed int SSIFileInfo(struct ssifile_s *sfp, signed int fh, char **ret_filename, signed int *ret_format)
{
  _Bool tmp_if_expr$1;
  if(!(fh >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = fh >= (signed int)sfp->nfiles ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 12;

  else
  {
    *ret_filename = sfp->filename[(signed long int)fh];
    *ret_format = (signed int)sfp->fileformat[(signed long int)fh];
    return 0;
  }
}

// SSIForceExternalSort
// file ssi.c line 1430
extern void SSIForceExternalSort(struct ssiindex_s *g)
{
  signed int return_value_activate_external_sort$1;
  return_value_activate_external_sort$1=activate_external_sort(g);
  if(!(return_value_activate_external_sort$1 == 0))
    Die("failed to turn external sorting on.");

}

// SSIFreeIndex
// file ssi.c line 1067
extern void SSIFreeIndex(struct ssiindex_s *g)
{
  signed int i;
  if(!(g == ((struct ssiindex_s *)NULL)))
  {
    if(g->external == 0)
    {
      i = 0;
      for( ; !((unsigned int)i >= g->nprimary); i = i + 1)
        free((void *)(g->pkeys + (signed long int)i)->key);
      i = 0;
      for( ; !((unsigned int)i >= g->nsecondary); i = i + 1)
        free((void *)(g->skeys + (signed long int)i)->key);
      i = 0;
      for( ; !((unsigned int)i >= g->nsecondary); i = i + 1)
        free((void *)(g->skeys + (signed long int)i)->pkey);
      if(!(g->pkeys == ((struct ssipkey_s *)NULL)))
        free((void *)g->pkeys);

      if(!(g->skeys == ((struct ssiskey_s *)NULL)))
        free((void *)g->skeys);

    }

    else
    {
      if(!(g->ptmp == ((struct _IO_FILE *)NULL)))
        fclose(g->ptmp);

      if(!(g->stmp == ((struct _IO_FILE *)NULL)))
        fclose(g->stmp);

      remove(g->ptmpfile);
      remove(g->stmpfile);
    }
    i = 0;
    for( ; !(i >= (signed int)g->nfiles); i = i + 1)
      free((void *)g->filenames[(signed long int)i]);
    if(!(g->filenames == ((char **)NULL)))
      free((void *)g->filenames);

    if(!(g->fileformat == ((unsigned int *)NULL)))
      free((void *)g->fileformat);

    if(!(g->bpl == ((unsigned int *)NULL)))
      free((void *)g->bpl);

    if(!(g->rpl == ((unsigned int *)NULL)))
      free((void *)g->rpl);

    free((void *)g);
  }

}

// SSIGetFilePosition
// file ../squid/ssi.h line 173
extern signed int SSIGetFilePosition(struct _IO_FILE *fp, signed int mode, struct ssioffset_s *ret_offset)
{
  if(mode == 0)
  {
    ret_offset->mode = (char)0;
    signed long int return_value_ftell$1;
    return_value_ftell$1=ftell(fp);
    ret_offset->off.i32 = (unsigned int)return_value_ftell$1;
    if(ret_offset->off.i32 == 4294967295u)
      return 9;

  }

  else
    if(!(mode == 1))
      abort();

    else
    {
      ret_offset->mode = (char)1;
      signed long int return_value_ftello$2;
      return_value_ftello$2=ftello(fp);
      ret_offset->off.i64 = (unsigned long int)return_value_ftello$2;
      if(ret_offset->off.i64 == 18446744073709551615ul)
        return 9;

    }
  return 0;
}

// SSIGetOffsetByName
// file ../squid/ssi.h line 158
extern signed int SSIGetOffsetByName(struct ssifile_s *sfp, char *key, signed int *ret_fh, struct ssioffset_s *ret_offset)
{
  signed int status;
  unsigned short int fnum;
  status=binary_search(sfp, key, (signed int)sfp->plen, &sfp->poffset, sfp->precsize, sfp->nprimary);
  if(status == 0)
  {
    signed int return_value_read_i16$1;
    return_value_read_i16$1=read_i16(sfp->fp, &fnum);
    if(return_value_read_i16$1 == 0)
      return 1;

    *ret_fh = (signed int)fnum;
    signed int return_value_read_offset$2;
    return_value_read_offset$2=read_offset(sfp->fp, sfp->smode, ret_offset);
    if(return_value_read_offset$2 == 0)
      return 1;

    return 0;
  }

  else
    if(status == 2)
    {
      if(sfp->nsecondary >= 1u)
      {
        char *pkey;
        status=binary_search(sfp, key, (signed int)sfp->slen, &sfp->soffset, sfp->srecsize, sfp->nsecondary);
        if(!(status == 0))
          return status;

        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(char) /*1ul*/  * (unsigned long int)sfp->plen);
        pkey = (char *)return_value_malloc$3;
        if(pkey == ((char *)NULL))
          return 3;

        unsigned long int return_value_fread$4;
        return_value_fread$4=fread((void *)pkey, sizeof(char) /*1ul*/ , (unsigned long int)sfp->plen, sfp->fp);
        if(!(return_value_fread$4 == (unsigned long int)sfp->plen))
          return 1;

        status=SSIGetOffsetByName(sfp, pkey, ret_fh, ret_offset);
        free((void *)pkey);
      }

      return status;
    }

    else
      return status;
}

// SSIGetOffsetByNumber
// file ../squid/ssi.h line 160
extern signed int SSIGetOffsetByNumber(struct ssifile_s *sfp, signed int n, signed int *ret_fh, struct ssioffset_s *ret_offset)
{
  unsigned short int fnum;
  char *pkey;
  if((unsigned int)n >= sfp->nprimary)
    return 2;

  else
  {
    signed int return_value_indexfile_position$1;
    return_value_indexfile_position$1=indexfile_position(sfp, &sfp->poffset, sfp->precsize, (unsigned int)n);
    if(!(return_value_indexfile_position$1 == 0))
      return 8;

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(char) /*1ul*/  * (unsigned long int)sfp->plen);
      pkey = (char *)return_value_malloc$2;
      if(pkey == ((char *)NULL))
        return 3;

      else
      {
        unsigned long int return_value_fread$3;
        return_value_fread$3=fread((void *)pkey, sizeof(char) /*1ul*/ , (unsigned long int)sfp->plen, sfp->fp);
        if(!(return_value_fread$3 == (unsigned long int)sfp->plen))
          return 1;

        else
        {
          signed int return_value_read_i16$4;
          return_value_read_i16$4=read_i16(sfp->fp, &fnum);
          if(return_value_read_i16$4 == 0)
            return 1;

          else
          {
            signed int return_value_read_offset$5;
            return_value_read_offset$5=read_offset(sfp->fp, sfp->smode, ret_offset);
            if(return_value_read_offset$5 == 0)
              return 1;

            else
            {
              *ret_fh = (signed int)fnum;
              free((void *)pkey);
              return 0;
            }
          }
        }
      }
    }
  }
}

// SSIGetSubseqOffset
// file ssi.c line 291
extern signed int SSIGetSubseqOffset(struct ssifile_s *sfp, char *key, signed int requested_start, signed int *ret_fh, struct ssioffset_s *record_offset, struct ssioffset_s *data_offset, signed int *ret_actual_start)
{
  signed int status;
  unsigned int len;
  signed int r;
  signed int b;
  signed int i;
  signed int l;
  status=SSIGetOffsetByName(sfp, key, ret_fh, record_offset);
  if(!(status == 0))
    return status;

  else
    if((1u & sfp->fileflags[(signed long int)*ret_fh]) == 0u)
      return 10;

    else
    {
      signed int return_value_read_offset$1;
      return_value_read_offset$1=read_offset(sfp->fp, sfp->smode, data_offset);
      if(return_value_read_offset$1 == 0)
        return 1;

      else
      {
        signed int return_value_read_i32$2;
        return_value_read_i32$2=read_i32(sfp->fp, &len);
        if(return_value_read_i32$2 == 0)
          return 1;

        else
        {
          r = (signed int)sfp->rpl[(signed long int)*ret_fh];
          b = (signed int)sfp->bpl[(signed long int)*ret_fh];
          i = requested_start;
          l = (i - 1) / r;
          if(b == 0 || r == 0)
            return 10;

          else
            if(!(i >= 0) || !(len >= (unsigned int)i))
              return 11;

            else
            {
              if(b == 1 + r)
              {
                if((signed int)sfp->smode == 0)
                {
                  data_offset->mode = (char)0;
                  data_offset->off.i32 = data_offset->off.i32 + (unsigned int)(l * b) + (unsigned int)((i - 1) % r);
                }

                else
                  if((signed int)sfp->smode == 1)
                  {
                    data_offset->mode = (char)1;
                    data_offset->off.i64 = data_offset->off.i64 + (unsigned long int)(l * b) + (unsigned long int)((i - 1) % r);
                  }

                *ret_actual_start = requested_start;
              }

              else
              {
                if((signed int)sfp->smode == 0)
                {
                  data_offset->mode = (char)0;
                  data_offset->off.i32 = data_offset->off.i32 + (unsigned int)(l * b);
                }

                else
                  if((signed int)sfp->smode == 1)
                  {
                    data_offset->mode = (char)1;
                    data_offset->off.i64 = data_offset->off.i64 + (unsigned long int)(l * b);
                  }

                *ret_actual_start = 1 + l * r;
              }
              return 0;
            }
        }
      }
    }
}

// SSIOpen
// file ../squid/ssi.h line 157
extern signed int SSIOpen(char *filename, struct ssifile_s **ret_sfp)
{
  struct ssifile_s *sfp = (struct ssifile_s *)(void *)0;
  signed int status;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ssifile_s) /*144ul*/ );
  sfp = (struct ssifile_s *)return_value_malloc$1;
  if(sfp == ((struct ssifile_s *)NULL))
    return 3;

  else
  {
    sfp->fp=fopen(filename, "rb");
    if(sfp->fp == ((struct _IO_FILE *)NULL))
    {
      free((void *)sfp);
      return 4;
    }

    else
    {
      status=load_indexfile(sfp);
      *ret_sfp = sfp;
      return status;
    }
  }
}

// SSIRecommendMode
// file ../squid/ssi.h line 171
extern signed int SSIRecommendMode(char *file)
{
  struct stat s2;
  signed int return_value_stat$1;
  return_value_stat$1=stat(file, &s2);
  if(return_value_stat$1 == 0)
  {
    if(!(s2.st_size >= 2146483648l))
      return 0;

    return 1;
  }

  else
    return -1;
}

// SSISetFileForSubseq
// file ssi.c line 676
extern signed int SSISetFileForSubseq(struct ssiindex_s *g, signed int fh, signed int bpl, signed int rpl)
{
  _Bool tmp_if_expr$1;
  if(!(fh >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = fh >= (signed int)g->nfiles ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 12;

  else
    if(!(bpl >= 1) || !(rpl >= 1))
      return 12;

    else
    {
      g->bpl[(signed long int)fh] = (unsigned int)bpl;
      g->rpl[(signed long int)fh] = (unsigned int)rpl;
      return 0;
    }
}

// SSISetFilePosition
// file ../squid/ssi.h line 165
extern signed int SSISetFilePosition(struct _IO_FILE *fp, struct ssioffset_s *offset)
{
  signed int return_value_fseeko$2;
  if((signed int)offset->mode == 0)
  {
    signed int return_value_fseek$1;
    return_value_fseek$1=fseek(fp, (signed long int)offset->off.i32, 0);
    if(!(return_value_fseek$1 == 0))
      return 8;

  }

  else
  {
    return_value_fseeko$2=fseeko(fp, (signed long int)offset->off.i64, 0);
    if(!(return_value_fseeko$2 == 0))
      return 8;

  }
  return 0;
}

// SSIWriteIndex
// file ssi.c line 872
extern signed int SSIWriteIndex(char *file, struct ssiindex_s *g)
{
  struct _IO_FILE *fp;
  signed int status;
  signed int i;
  unsigned int header_flags;
  unsigned int file_flags;
  unsigned int frecsize;
  unsigned int precsize;
  unsigned int srecsize;
  unsigned long int foffset;
  unsigned long int poffset;
  unsigned long int soffset;
  char *s;
  char *s2;
  fp=fopen(file, "wb");
  unsigned int tmp_if_expr$2;
  if(fp == ((struct _IO_FILE *)NULL))
    return 4;

  else
  {
    status = 0;
    unsigned long int return_value_current_index_size$1;
    return_value_current_index_size$1=current_index_size(g);
    if(return_value_current_index_size$1 >= 2047ul)
      g->imode = 1;

    frecsize = (unsigned int)16 + g->flen;
    if(g->smode == 1)
      tmp_if_expr$2 = (unsigned int)22 + g->plen;

    else
      tmp_if_expr$2 = (unsigned int)14 + g->plen;
    precsize = tmp_if_expr$2;
    srecsize = g->slen + g->plen;
    header_flags = (unsigned int)0;
    if(g->smode == 1)
      header_flags = header_flags | (unsigned int)(1 << 0);

    if(g->imode == 1)
      header_flags = header_flags | (unsigned int)(1 << 1);

    foffset = (unsigned long int)((header_flags & (unsigned int)(1 << 1)) != 0u ? 66 : 54);
    poffset = foffset + (unsigned long int)(frecsize * (unsigned int)g->nfiles);
    soffset = poffset + (unsigned long int)(precsize * g->nprimary);
    if(!(g->external == 0))
    {
      char cmd[1024l];
      fclose(g->ptmp);
      g->ptmp = (struct _IO_FILE *)(void *)0;
      sprintf(cmd, "env LC_ALL=POSIX sort -o %s %s\n", g->ptmpfile, g->ptmpfile);
      status=system(cmd);
      if(!(status == 0))
        return 16;

      g->ptmp=fopen(g->ptmpfile, "r");
      if(g->ptmp == ((struct _IO_FILE *)NULL))
        return 16;

      fclose(g->stmp);
      g->stmp = (struct _IO_FILE *)(void *)0;
      sprintf(cmd, "env LC_ALL=POSIX sort -o %s %s\n", g->stmpfile, g->stmpfile);
      status=system(cmd);
      if(!(status == 0))
        return 16;

      g->stmp=fopen(g->stmpfile, "r");
      if(g->stmp == ((struct _IO_FILE *)NULL))
        return 16;

    }

    else
    {
      qsort((void *)g->pkeys, (unsigned long int)g->nprimary, sizeof(struct ssipkey_s) /*56ul*/ , pkeysort);
      qsort((void *)g->skeys, (unsigned long int)g->nsecondary, sizeof(struct ssiskey_s) /*16ul*/ , skeysort);
    }
    signed int return_value_write_i32$3;
    return_value_write_i32$3=write_i32(fp, v20magic$link1);
    if(return_value_write_i32$3 == 0)
      return 15;

    else
    {
      signed int return_value_write_i32$4;
      return_value_write_i32$4=write_i32(fp, header_flags);
      if(return_value_write_i32$4 == 0)
        return 15;

      else
      {
        signed int return_value_write_i16$5;
        return_value_write_i16$5=write_i16(fp, g->nfiles);
        if(return_value_write_i16$5 == 0)
          return 15;

        else
        {
          signed int return_value_write_i32$6;
          return_value_write_i32$6=write_i32(fp, g->nprimary);
          if(return_value_write_i32$6 == 0)
            return 15;

          else
          {
            signed int return_value_write_i32$7;
            return_value_write_i32$7=write_i32(fp, g->nsecondary);
            if(return_value_write_i32$7 == 0)
              return 15;

            else
            {
              signed int return_value_write_i32$8;
              return_value_write_i32$8=write_i32(fp, g->flen);
              if(return_value_write_i32$8 == 0)
                return 15;

              else
              {
                signed int return_value_write_i32$9;
                return_value_write_i32$9=write_i32(fp, g->plen);
                if(return_value_write_i32$9 == 0)
                  return 15;

                else
                {
                  signed int return_value_write_i32$10;
                  return_value_write_i32$10=write_i32(fp, g->slen);
                  if(return_value_write_i32$10 == 0)
                    return 15;

                  else
                  {
                    signed int return_value_write_i32$11;
                    return_value_write_i32$11=write_i32(fp, frecsize);
                    if(return_value_write_i32$11 == 0)
                      return 15;

                    else
                    {
                      signed int return_value_write_i32$12;
                      return_value_write_i32$12=write_i32(fp, precsize);
                      if(return_value_write_i32$12 == 0)
                        return 15;

                      else
                      {
                        signed int return_value_write_i32$13;
                        return_value_write_i32$13=write_i32(fp, srecsize);
                        if(return_value_write_i32$13 == 0)
                          return 15;

                        else
                        {
                          if(g->imode == 0)
                          {
                            signed int return_value_write_i32$14;
                            return_value_write_i32$14=write_i32(fp, (unsigned int)foffset);
                            if(return_value_write_i32$14 == 0)
                              return 15;

                            signed int return_value_write_i32$15;
                            return_value_write_i32$15=write_i32(fp, (unsigned int)poffset);
                            if(return_value_write_i32$15 == 0)
                              return 15;

                            signed int return_value_write_i32$16;
                            return_value_write_i32$16=write_i32(fp, (unsigned int)soffset);
                            if(return_value_write_i32$16 == 0)
                              return 15;

                          }

                          else
                          {
                            signed int return_value_write_i64$17;
                            return_value_write_i64$17=write_i64(fp, foffset);
                            if(return_value_write_i64$17 == 0)
                              return 15;

                            signed int return_value_write_i64$18;
                            return_value_write_i64$18=write_i64(fp, poffset);
                            if(return_value_write_i64$18 == 0)
                              return 15;

                            signed int return_value_write_i64$19;
                            return_value_write_i64$19=write_i64(fp, soffset);
                            if(return_value_write_i64$19 == 0)
                              return 15;

                          }
                          void *return_value_malloc$20;
                          return_value_malloc$20=malloc(sizeof(char) /*1ul*/  * (unsigned long int)g->flen);
                          s = (char *)return_value_malloc$20;
                          if(s == ((char *)NULL))
                            return 3;

                          else
                          {
                            i = 0;
                            for( ; !(i >= (signed int)g->nfiles); i = i + 1)
                            {
                              file_flags = (unsigned int)0;
                              if(g->bpl[(signed long int)i] >= 1u)
                              {
                                if(g->rpl[(signed long int)i] >= 1u)
                                  file_flags = file_flags | (unsigned int)(1 << 0);

                              }

                              strcpy(s, g->filenames[(signed long int)i]);
                              unsigned long int return_value_fwrite$21;
                              return_value_fwrite$21=fwrite((const void *)s, sizeof(char) /*1ul*/ , (unsigned long int)g->flen, fp);
                              if(!(return_value_fwrite$21 == (unsigned long int)g->flen))
                                return 15;

                              signed int return_value_write_i32$22;
                              return_value_write_i32$22=write_i32(fp, g->fileformat[(signed long int)i]);
                              if(return_value_write_i32$22 == 0)
                                return 15;

                              signed int return_value_write_i32$23;
                              return_value_write_i32$23=write_i32(fp, file_flags);
                              if(return_value_write_i32$23 == 0)
                                return 15;

                              signed int return_value_write_i32$24;
                              return_value_write_i32$24=write_i32(fp, g->bpl[(signed long int)i]);
                              if(return_value_write_i32$24 == 0)
                                return 15;

                              signed int return_value_write_i32$25;
                              return_value_write_i32$25=write_i32(fp, g->rpl[(signed long int)i]);
                              if(return_value_write_i32$25 == 0)
                                return 15;

                            }
                            free((void *)s);
                            void *return_value_malloc$26;
                            return_value_malloc$26=malloc(sizeof(char) /*1ul*/  * (unsigned long int)g->plen);
                            s = (char *)return_value_malloc$26;
                            if(s == ((char *)NULL))
                              return 3;

                            else
                            {
                              if(!(g->external == 0))
                              {
                                char *buf = (char *)(void *)0;
                                signed int buflen = 0;
                                struct ssipkey_s pkey;
                                i = 0;
                                for( ; !((unsigned int)i >= g->nprimary); i = i + 1)
                                {
                                  char *return_value_sre_fgets$27;
                                  return_value_sre_fgets$27=sre_fgets(&buf, &buflen, g->ptmp);
                                  if(return_value_sre_fgets$27 == ((char *)NULL))
                                    return 1;

                                  signed int return_value_parse_pkey_info$28;
                                  return_value_parse_pkey_info$28=parse_pkey_info(buf, (char)g->smode, &pkey);
                                  if(!(return_value_parse_pkey_info$28 == 0))
                                    return 6;

                                  strcpy(s, pkey.key);
                                  unsigned long int return_value_fwrite$29;
                                  return_value_fwrite$29=fwrite((const void *)s, sizeof(char) /*1ul*/ , (unsigned long int)g->plen, fp);
                                  if(!(return_value_fwrite$29 == (unsigned long int)g->plen))
                                    return 15;

                                  signed int return_value_write_i16$30;
                                  return_value_write_i16$30=write_i16(fp, pkey.fnum);
                                  if(return_value_write_i16$30 == 0)
                                    return 15;

                                  signed int return_value_write_offset$31;
                                  return_value_write_offset$31=write_offset(fp, &pkey.r_off);
                                  if(return_value_write_offset$31 == 0)
                                    return 15;

                                  signed int return_value_write_offset$32;
                                  return_value_write_offset$32=write_offset(fp, &pkey.d_off);
                                  if(return_value_write_offset$32 == 0)
                                    return 15;

                                  signed int return_value_write_i32$33;
                                  return_value_write_i32$33=write_i32(fp, pkey.len);
                                  if(return_value_write_i32$33 == 0)
                                    return 15;

                                }
                                free((void *)buf);
                              }

                              else
                              {
                                i = 0;
                                for( ; !((unsigned int)i >= g->nprimary); i = i + 1)
                                {
                                  strcpy(s, (g->pkeys + (signed long int)i)->key);
                                  unsigned long int return_value_fwrite$34;
                                  return_value_fwrite$34=fwrite((const void *)s, sizeof(char) /*1ul*/ , (unsigned long int)g->plen, fp);
                                  if(!(return_value_fwrite$34 == (unsigned long int)g->plen))
                                    return 15;

                                  signed int return_value_write_i16$35;
                                  return_value_write_i16$35=write_i16(fp, (g->pkeys + (signed long int)i)->fnum);
                                  if(return_value_write_i16$35 == 0)
                                    return 15;

                                  signed int return_value_write_offset$36;
                                  return_value_write_offset$36=write_offset(fp, &(g->pkeys + (signed long int)i)->r_off);
                                  if(return_value_write_offset$36 == 0)
                                    return 15;

                                  signed int return_value_write_offset$37;
                                  return_value_write_offset$37=write_offset(fp, &(g->pkeys + (signed long int)i)->d_off);
                                  if(return_value_write_offset$37 == 0)
                                    return 15;

                                  signed int return_value_write_i32$38;
                                  return_value_write_i32$38=write_i32(fp, (g->pkeys + (signed long int)i)->len);
                                  if(return_value_write_i32$38 == 0)
                                    return 15;

                                }
                              }
                              if(g->nsecondary >= 1u)
                              {
                                void *return_value_malloc$39;
                                return_value_malloc$39=malloc(sizeof(char) /*1ul*/  * (unsigned long int)g->slen);
                                s2 = (char *)return_value_malloc$39;
                                if(s2 == ((char *)NULL))
                                  return 3;

                                if(!(g->external == 0))
                                {
                                  struct ssiskey_s skey;
                                  char *SSIWriteIndex$$1$$9$$1$$buf = (char *)(void *)0;
                                  signed int n = 0;
                                  i = 0;
                                  for( ; !((unsigned int)i >= g->nsecondary); i = i + 1)
                                  {
                                    char *return_value_sre_fgets$40;
                                    return_value_sre_fgets$40=sre_fgets(&SSIWriteIndex$$1$$9$$1$$buf, &n, g->stmp);
                                    if(return_value_sre_fgets$40 == ((char *)NULL))
                                      return 1;

                                    signed int return_value_parse_skey_info$41;
                                    return_value_parse_skey_info$41=parse_skey_info(SSIWriteIndex$$1$$9$$1$$buf, &skey);
                                    if(!(return_value_parse_skey_info$41 == 0))
                                      return 6;

                                    strcpy(s2, skey.key);
                                    strcpy(s, skey.pkey);
                                    unsigned long int return_value_fwrite$42;
                                    return_value_fwrite$42=fwrite((const void *)s2, sizeof(char) /*1ul*/ , (unsigned long int)g->slen, fp);
                                    if(!(return_value_fwrite$42 == (unsigned long int)g->slen))
                                      return 15;

                                    unsigned long int return_value_fwrite$43;
                                    return_value_fwrite$43=fwrite((const void *)s, sizeof(char) /*1ul*/ , (unsigned long int)g->plen, fp);
                                    if(!(return_value_fwrite$43 == (unsigned long int)g->plen))
                                      return 15;

                                  }
                                  free((void *)SSIWriteIndex$$1$$9$$1$$buf);
                                }

                                else
                                {
                                  i = 0;
                                  for( ; !((unsigned int)i >= g->nsecondary); i = i + 1)
                                  {
                                    strcpy(s2, (g->skeys + (signed long int)i)->key);
                                    strcpy(s, (g->skeys + (signed long int)i)->pkey);
                                    unsigned long int return_value_fwrite$44;
                                    return_value_fwrite$44=fwrite((const void *)s2, sizeof(char) /*1ul*/ , (unsigned long int)g->slen, fp);
                                    if(!(return_value_fwrite$44 == (unsigned long int)g->slen))
                                      return 15;

                                    unsigned long int return_value_fwrite$45;
                                    return_value_fwrite$45=fwrite((const void *)s, sizeof(char) /*1ul*/ , (unsigned long int)g->plen, fp);
                                    if(!(return_value_fwrite$45 == (unsigned long int)g->plen))
                                      return 15;

                                  }
                                }
                                free((void *)s2);
                              }

                              free((void *)s);
                              fclose(fp);
                              return status;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// SampleAlignment
// file weight.c line 587
extern void SampleAlignment(struct msa_struct *msa, signed int sample, struct msa_struct **ret_new)
{
  signed int *list;
  signed int *useme;
  signed int i;
  signed int idx;
  signed int len;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("weight.c", 596, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseq);
  list = (signed int *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("weight.c", 597, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseq);
  useme = (signed int *)return_value_sre_malloc$2;
  i = 0;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    list[(signed long int)i] = i;
    useme[(signed long int)i] = 0;
  }
  if(sample >= msa->nseq)
    sample = msa->nseq;

  len = msa->nseq;
  i = 0;
  for( ; !(i >= sample); i = i + 1)
  {
    double return_value_sre_random$3;
    return_value_sre_random$3=sre_random();
    idx = (signed int)(return_value_sre_random$3 * (double)len);
    printf("chose %d: %s\n", list[(signed long int)idx], msa->sqname[(signed long int)list[(signed long int)idx]]);
    useme[(signed long int)list[(signed long int)idx]] = 1;
    len = len - 1;
    list[(signed long int)idx] = list[(signed long int)len];
  }
  MSASmallerAlignment(msa, useme, ret_new);
  free((void *)list);
  free((void *)useme);
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// SampleCountvector
// file mathsupport.c line 330
extern void SampleCountvector(float *p, signed int n, signed int c, float *cvec)
{
  signed int i;
  FSet(cvec, n, (float)0.0);
  i = 0;
  signed int return_value_FChoose$1;
  for( ; !(i >= c); i = i + 1)
  {
    return_value_FChoose$1=FChoose(p, n);
    cvec[(signed long int)return_value_FChoose$1] = cvec[(signed long int)return_value_FChoose$1] + (float)1.0;
  }
}

// SampleDirichlet
// file mathsupport.c line 257
extern void SampleDirichlet(float *alpha, signed int n, float *p)
{
  signed int x = 0;
  for( ; !(x >= n); x = x + 1)
    p[(signed long int)x]=SampleGamma(alpha[(signed long int)x]);
  FNorm(p, n);
}

// SampleGamma
// file mathsupport.c line 281
extern float SampleGamma(float alpha)
{
  float U;
  float V;
  float X;
  float W;
  float lambda;
  if(alpha >= 1.000000f)
    while((_Bool)1)
    {
      double return_value_sqrt$1;
      return_value_sqrt$1=sqrt(2.0 * (double)alpha - 1.0);
      lambda = (float)return_value_sqrt$1;
      double return_value_sre_random$2;
      return_value_sre_random$2=sre_random();
      U = (float)return_value_sre_random$2;
      V = U / ((float)1 - U);
      double return_value_pow$3;
      return_value_pow$3=pow((double)V, (double)((float)1 / lambda));
      X = (float)((double)alpha * return_value_pow$3);
      double return_value_exp$4;
      return_value_exp$4=exp((double)(-X + alpha));
      double return_value_pow$5;
      return_value_pow$5=pow((double)V, 1.0 + (double)(alpha / lambda));
      double return_value_pow$6;
      return_value_pow$6=pow(1.0 + 1.0 / (double)V, 2.0);
      W = (float)(.25 * return_value_exp$4 * return_value_pow$5 * return_value_pow$6);
      double return_value_sre_random$7;
      return_value_sre_random$7=sre_random();
      if(return_value_sre_random$7 <= (double)W)
        return X;

    }

  else
    if(alpha > 0.000000f)
      while((_Bool)1)
      {
        double return_value_sre_random$8;
        return_value_sre_random$8=sre_random();
        U = (float)return_value_sre_random$8;
        double return_value_exp$9;
        return_value_exp$9=exp(1.0);
        V = (float)((double)U * ((double)1 + (double)alpha / return_value_exp$9));
        if(V > 1.000000f)
        {
          double return_value_exp$10;
          return_value_exp$10=exp(1.0);
          double return_value_log$11;
          return_value_log$11=log(((double)((float)1 - V) + (double)alpha / return_value_exp$10) / (double)alpha);
          X = (float)-return_value_log$11;
          double return_value_sre_random$12;
          return_value_sre_random$12=sre_random();
          double return_value_pow$13;
          return_value_pow$13=pow((double)X, (double)alpha - 1.0);
          if(return_value_sre_random$12 <= return_value_pow$13)
            return X;

        }

        else
        {
          double return_value_pow$14;
          return_value_pow$14=pow((double)V, 1.0 / (double)alpha);
          X = (float)return_value_pow$14;
          double return_value_sre_random$15;
          return_value_sre_random$15=sre_random();
          double return_value_exp$16;
          return_value_exp$16=exp((double)-X);
          if(return_value_sre_random$15 <= return_value_exp$16)
            return X;

        }
      }

  Die("Invalid argument alpha < 0.0 to SampleGamma()");
  return (float)0.0;
}

// SantaCruzCorrection
// file masks.c line 366
float SantaCruzCorrection(struct plan7_s *hmm, struct p7trace_s *tr, unsigned char *dsq)
{
  return (float)0.0;
}

// Score2Prob
// file funcs.h line 175
extern float Score2Prob(signed int sc, float null)
{
  double return_value_exp$1;
  if(sc == -987654321)
    return (float)0.;

  else
  {
    return_value_exp$1=exp(((double)(float)sc / 1000.0) * 0.69314718);
    return (float)((double)null * return_value_exp$1);
  }
}

// Scorify
// file funcs.h line 176
extern float Scorify(signed int sc)
{
  return (float)((double)(float)sc / 1000.0);
}

// SeqfileClose
// file sqio.c line 284
extern void SeqfileClose(struct ReadSeqVars *sqfp)
{
  if(!(sqfp->afp == ((struct msafile_struct *)NULL)))
  {
    if(!(sqfp->msa == ((struct msa_struct *)NULL)))
      MSAFree(sqfp->msa);

    if(!(sqfp->afp->buf == ((char *)NULL)))
      free((void *)sqfp->afp->buf);

    free((void *)sqfp->afp);
  }

  if(!(sqfp->do_gzip == 0))
    pclose(sqfp->f);

  else
    if(sqfp->do_stdin == 0)
      fclose(sqfp->f);

  if(!(sqfp->buf == ((char *)NULL)))
    free((void *)sqfp->buf);

  if(!(sqfp->fname == ((char *)NULL)))
    free((void *)sqfp->fname);

  free((void *)sqfp);
}

// SeqfileFormat
// file sqfuncs.h line 168
extern signed int SeqfileFormat(struct _IO_FILE *fp)
{
  char *buf;
  signed int len;
  signed int fmt = 0;
  signed int ndataline;
  char *bufcpy;
  char *s;
  char *s1;
  char *s2;
  signed int has_junk;
  buf = (char *)(void *)0;
  len = 0;
  ndataline = 0;
  has_junk = 0;
  char *return_value_sre_fgets$1;
  char *return_value_strstr$3;
  _Bool tmp_if_expr$7;
  signed int return_value_strncmp$6;
  char *return_value_strstr$9;
  _Bool tmp_if_expr$13;
  signed int return_value_strncmp$12;
  signed int return_value_IsInt$15;
  signed int return_value_IsInt$14;
  _Bool tmp_if_expr$18;
  signed int return_value_strncmp$17;
  _Bool tmp_if_expr$20;
  signed int return_value_strncmp$19;
  _Bool tmp_if_expr$22;
  signed int return_value_strncmp$21;
  _Bool tmp_if_expr$24;
  signed int return_value_strncmp$23;
  _Bool tmp_if_expr$26;
  signed int return_value_strncmp$25;
  _Bool tmp_if_expr$28;
  signed int return_value_strncmp$27;
  _Bool tmp_if_expr$30;
  signed int return_value_strncmp$29;
  _Bool tmp_if_expr$32;
  signed int return_value_strncmp$31;
  _Bool tmp_if_expr$34;
  signed int return_value_strncmp$33;
  _Bool tmp_if_expr$36;
  signed int return_value_strncmp$35;
  _Bool tmp_if_expr$39;
  signed int return_value_strncmp$38;
  char *return_value_strstr$41;
  char *return_value_strstr$40;
  char *return_value_strstr$43;
  _Bool tmp_if_expr$47;
  signed int return_value_strncmp$46;
  _Bool tmp_if_expr$50;
  signed int return_value_strncmp$49;
  signed int return_value_Seqtype$52;
  do
  {
    return_value_sre_fgets$1=sre_fgets(&buf, &len, fp);
    if(return_value_sre_fgets$1 == ((char *)NULL))
      break;

    signed int return_value_IsBlankline$2;
    return_value_IsBlankline$2=IsBlankline(buf);
    if(return_value_IsBlankline$2 == 0)
    {
      if(ndataline == 0)
      {
        signed int return_value_strncmp$4;
        return_value_strncmp$4=strncmp(buf, ">>>>", (unsigned long int)4);
        if(return_value_strncmp$4 == 0)
        {
          return_value_strstr$3=strstr(buf, "Len: ");
          if(!(return_value_strstr$3 == ((char *)NULL)))
          {
            fmt = 16;
            goto DONE;
          }

        }

        if((signed int)*buf == 62)
        {
          fmt = 7;
          goto DONE;
        }

        signed int return_value_strncmp$5;
        return_value_strncmp$5=strncmp(buf, "!!AA_SEQUENCE", (unsigned long int)13);
        if(return_value_strncmp$5 == 0)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_strncmp$6=strncmp(buf, "!!NA_SEQUENCE", (unsigned long int)13);
          tmp_if_expr$7 = return_value_strncmp$6 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fmt = 5;
          goto DONE;
        }

        signed int return_value_strncmp$8;
        return_value_strncmp$8=strncmp(buf, "# STOCKHOLM 1.", (unsigned long int)14);
        if(return_value_strncmp$8 == 0)
        {
          fmt = 101;
          goto DONE;
        }

        signed int return_value_strncmp$10;
        return_value_strncmp$10=strncmp(buf, "CLUSTAL", (unsigned long int)7);
        if(return_value_strncmp$10 == 0)
        {
          return_value_strstr$9=strstr(buf, "multiple sequence alignment");
          if(!(return_value_strstr$9 == ((char *)NULL)))
          {
            fmt = 104;
            goto DONE;
          }

        }

        signed int return_value_strncmp$11;
        return_value_strncmp$11=strncmp(buf, "!!AA_MULTIPLE_ALIGNMENT", (unsigned long int)23);
        if(return_value_strncmp$11 == 0)
          tmp_if_expr$13 = (_Bool)1;

        else
        {
          return_value_strncmp$12=strncmp(buf, "!!NA_MULTIPLE_ALIGNMENT", (unsigned long int)23);
          tmp_if_expr$13 = return_value_strncmp$12 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$13)
        {
          fmt = 103;
          goto DONE;
        }

        bufcpy=sre_strdup(buf, -1);
        s = bufcpy;
        s1=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
        if(!(s1 == ((char *)NULL)))
        {
          s2=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
          if(!(s2 == ((char *)NULL)))
          {
            return_value_IsInt$15=IsInt(s1);
            if(!(return_value_IsInt$15 == 0))
            {
              return_value_IsInt$14=IsInt(s2);
              if(!(return_value_IsInt$14 == 0))
              {
                free((void *)bufcpy);
                fmt = 106;
                goto DONE;
              }

            }

          }

        }

        free((void *)bufcpy);
      }

      signed int return_value_strncmp$16;
      return_value_strncmp$16=strncmp(buf, "#=AU", (unsigned long int)4);
      if(return_value_strncmp$16 == 0)
        tmp_if_expr$18 = (_Bool)1;

      else
      {
        return_value_strncmp$17=strncmp(buf, "#=ID", (unsigned long int)4);
        tmp_if_expr$18 = return_value_strncmp$17 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$18)
        tmp_if_expr$20 = (_Bool)1;

      else
      {
        return_value_strncmp$19=strncmp(buf, "#=AC", (unsigned long int)4);
        tmp_if_expr$20 = return_value_strncmp$19 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$20)
        tmp_if_expr$22 = (_Bool)1;

      else
      {
        return_value_strncmp$21=strncmp(buf, "#=DE", (unsigned long int)4);
        tmp_if_expr$22 = return_value_strncmp$21 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$22)
        tmp_if_expr$24 = (_Bool)1;

      else
      {
        return_value_strncmp$23=strncmp(buf, "#=GA", (unsigned long int)4);
        tmp_if_expr$24 = return_value_strncmp$23 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$24)
        tmp_if_expr$26 = (_Bool)1;

      else
      {
        return_value_strncmp$25=strncmp(buf, "#=TC", (unsigned long int)4);
        tmp_if_expr$26 = return_value_strncmp$25 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$26)
        tmp_if_expr$28 = (_Bool)1;

      else
      {
        return_value_strncmp$27=strncmp(buf, "#=NC", (unsigned long int)4);
        tmp_if_expr$28 = return_value_strncmp$27 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$28)
        tmp_if_expr$30 = (_Bool)1;

      else
      {
        return_value_strncmp$29=strncmp(buf, "#=SQ", (unsigned long int)4);
        tmp_if_expr$30 = return_value_strncmp$29 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$30)
        tmp_if_expr$32 = (_Bool)1;

      else
      {
        return_value_strncmp$31=strncmp(buf, "#=SS", (unsigned long int)4);
        tmp_if_expr$32 = return_value_strncmp$31 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$32)
        tmp_if_expr$34 = (_Bool)1;

      else
      {
        return_value_strncmp$33=strncmp(buf, "#=CS", (unsigned long int)4);
        tmp_if_expr$34 = return_value_strncmp$33 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$34)
        tmp_if_expr$36 = (_Bool)1;

      else
      {
        return_value_strncmp$35=strncmp(buf, "#=RF", (unsigned long int)4);
        tmp_if_expr$36 = return_value_strncmp$35 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$36)
      {
        fmt = 102;
        goto DONE;
      }

      signed int return_value_strncmp$37;
      return_value_strncmp$37=strncmp(buf, "///", (unsigned long int)3);
      if(return_value_strncmp$37 == 0)
        tmp_if_expr$39 = (_Bool)1;

      else
      {
        return_value_strncmp$38=strncmp(buf, "ENTRY ", (unsigned long int)6);
        tmp_if_expr$39 = return_value_strncmp$38 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$39)
      {
        fmt = 12;
        goto DONE;
      }

      char *return_value_strstr$42;
      return_value_strstr$42=strstr(buf, "..");
      if(!(return_value_strstr$42 == ((char *)NULL)))
      {
        return_value_strstr$41=strstr(buf, "MSF:");
        if(!(return_value_strstr$41 == ((char *)NULL)))
        {
          return_value_strstr$40=strstr(buf, "Check:");
          if(!(return_value_strstr$40 == ((char *)NULL)))
          {
            fmt = 103;
            goto DONE;
          }

        }

      }

      char *return_value_strstr$44;
      return_value_strstr$44=strstr(buf, " Check: ");
      if(!(return_value_strstr$44 == ((char *)NULL)))
      {
        return_value_strstr$43=strstr(buf, "..");
        if(!(return_value_strstr$43 == ((char *)NULL)))
        {
          fmt = 5;
          goto DONE;
        }

      }

      signed int return_value_strncmp$45;
      return_value_strncmp$45=strncmp(buf, "LOCUS ", (unsigned long int)6);
      if(return_value_strncmp$45 == 0)
        tmp_if_expr$47 = (_Bool)1;

      else
      {
        return_value_strncmp$46=strncmp(buf, "ORIGIN ", (unsigned long int)6);
        tmp_if_expr$47 = return_value_strncmp$46 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$47)
      {
        fmt = 2;
        goto DONE;
      }

      signed int return_value_strncmp$48;
      return_value_strncmp$48=strncmp(buf, "ID   ", (unsigned long int)5);
      if(return_value_strncmp$48 == 0)
        tmp_if_expr$50 = (_Bool)1;

      else
      {
        return_value_strncmp$49=strncmp(buf, "SQ   ", (unsigned long int)5);
        tmp_if_expr$50 = return_value_strncmp$49 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$50)
      {
        fmt = 4;
        goto DONE;
      }

      s = buf;
      s1=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
      if(!(s1 == ((char *)NULL)))
      {
        char *return_value_strchr$51;
        return_value_strchr$51=strchr("#%", (signed int)*s1);
        if(return_value_strchr$51 == ((char *)NULL))
        {
          s2=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
          if(s2 == ((char *)NULL))
            has_junk = 1;

          if(!(s2 == ((char *)NULL)))
          {
            return_value_Seqtype$52=Seqtype(s2);
            if(return_value_Seqtype$52 == 0)
              has_junk = 1;

          }

          ndataline = ndataline + 1;
          if(ndataline == 300)
            break;

        }

      }

    }

  }
  while((_Bool)1);
  if(ndataline == 0)
    Die("Sequence file contains no data");

  if(has_junk == 1)
    fmt = 0;

  else
    fmt = 102;

DONE:
  ;
  if(!(buf == ((char *)NULL)))
    free((void *)buf);

  rewind(fp);
  return fmt;
}

// SeqfileFormat2String
// file sqfuncs.h line 182
extern char * SeqfileFormat2String(signed int code)
{
  switch(code)
  {
    case 0:
      return "unknown";
    case 7:
      return "FASTA";
    case 2:
      return "Genbank";
    case 4:
      return "EMBL";
    case 5:
      return "GCG";
    case 16:
      return "GCG data library";
    case 13:
      return "raw";
    case 1:
      return "Intelligenetics";
    case 6:
      return "MacStrider";
    case 9:
      return "Idraw Postscript";
    case 8:
      return "Zuker";
    case 12:
      return "PIR";
    case 14:
      return "SQUID";
    case 101:
      return "Stockholm";
    case 102:
      return "SELEX";
    case 103:
      return "MSF";
    case 104:
      return "Clustal";
    case 105:
      return "a2m";
    case 106:
      return "Phylip";
    case 107:
      return "EPS";
    default:
    {
      Die("Bad code passed to MSAFormat2String()");
      return (char *)(void *)0;
    }
  }
}

// SeqfileGetLine
// file sqio.c line 317
static void SeqfileGetLine(struct ReadSeqVars *V)
{
  signed int return_value_SSIGetFilePosition$1;
  if(V->ssimode >= 0)
  {
    return_value_SSIGetFilePosition$1=SSIGetFilePosition(V->f, V->ssimode, &V->ssioffset);
    if(!(return_value_SSIGetFilePosition$1 == 0))
      Die("SSIGetFilePosition() failed");

  }

  char *return_value_sre_fgets$2;
  return_value_sre_fgets$2=sre_fgets(&V->buf, &V->buflen, V->f);
  if(return_value_sre_fgets$2 == ((char *)NULL))
    *V->buf = (char)0;

  V->linenumber = V->linenumber + 1;
}

// SeqfileLineParameters
// file sqio.c line 270
void SeqfileLineParameters(struct ReadSeqVars *V, signed int *ret_bpl, signed int *ret_rpl)
{
  _Bool tmp_if_expr$1;
  if(V->rpl >= 1)
    tmp_if_expr$1 = V->maxrpl == V->rpl ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = V->bpl > 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = V->maxbpl == V->bpl ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    *ret_bpl = V->bpl;
    *ret_rpl = V->rpl;
  }

  else
  {
    *ret_bpl = 0;
    *ret_rpl = 0;
  }
}

// SeqfileOpen
// file sqio.c line 87
extern struct ReadSeqVars * SeqfileOpen(char *filename, signed int format, char *env)
{
  struct ReadSeqVars *return_value_seqfile_open$1;
  return_value_seqfile_open$1=seqfile_open(filename, format, env, -1);
  return return_value_seqfile_open$1;
}

// SeqfileOpenForIndexing
// file sqio.c line 92
extern struct ReadSeqVars * SeqfileOpenForIndexing(char *filename, signed int format, char *env, signed int ssimode)
{
  struct ReadSeqVars *return_value_seqfile_open$1;
  return_value_seqfile_open$1=seqfile_open(filename, format, env, ssimode);
  return return_value_seqfile_open$1;
}

// SeqfilePosition
// file sqio.c line 221
extern void SeqfilePosition(struct ReadSeqVars *sqfp, struct ssioffset_s *offset)
{
  _Bool tmp_if_expr$1;
  if(!(sqfp->do_stdin == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = sqfp->do_gzip != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = sqfp->format > 100 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    Die("SeqfilePosition() failed: in a nonrewindable data file or stream");

  signed int return_value_SSISetFilePosition$3;
  return_value_SSISetFilePosition$3=SSISetFilePosition(sqfp->f, offset);
  if(!(return_value_SSISetFilePosition$3 == 0))
    Die("SSISetFilePosition failed, but that shouldn't happen.");

  SeqfileGetLine(sqfp);
}

// SeqfileRewind
// file sqio.c line 242
extern void SeqfileRewind(struct ReadSeqVars *sqfp)
{
  _Bool tmp_if_expr$1;
  if(!(sqfp->do_stdin == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = sqfp->do_gzip != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    Die("SeqfileRewind() failed: in a nonrewindable data file or stream");

  rewind(sqfp->f);
  SeqfileGetLine(sqfp);
}

// SeqinfoCopy
// file sqfuncs.h line 160
extern void SeqinfoCopy(struct seqinfo_s *sq1, struct seqinfo_s *sq2)
{
  sq1->flags = sq2->flags;
  if(!((1 & sq2->flags) == 0))
    strcpy(sq1->name, sq2->name);

  if(!((2 & sq2->flags) == 0))
    strcpy(sq1->id, sq2->id);

  if(!((4 & sq2->flags) == 0))
    strcpy(sq1->acc, sq2->acc);

  if(!((8 & sq2->flags) == 0))
    strcpy(sq1->desc, sq2->desc);

  if(!((64 & sq2->flags) == 0))
    sq1->len = sq2->len;

  if(!((16 & sq2->flags) == 0))
    sq1->start = sq2->start;

  if(!((32 & sq2->flags) == 0))
    sq1->stop = sq2->stop;

  if(!((256 & sq2->flags) == 0))
    sq1->olen = sq2->olen;

  if(!((128 & sq2->flags) == 0))
    sq1->type = sq2->type;

  if(!((512 & sq2->flags) == 0))
    sq1->ss=Strdup(sq2->ss);

  if(!((1024 & sq2->flags) == 0))
    sq1->sa=Strdup(sq2->sa);

}

// Seqtype
// file ../squid/sqfuncs.h line 179
extern signed int Seqtype(char *seq)
{
  signed int saw;
  char c;
  signed int po = 0;
  signed int nt = 0;
  signed int nu = 0;
  signed int na = 0;
  signed int aa = 0;
  signed int no = 0;
  saw = 0;
  char *return_value_strchr$4;
  char *return_value_strchr$3;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !((signed int)*seq == 0) && !(saw >= 300); seq = seq + 1l)
  {
    signed int return_value_sre_toupper$1;
    return_value_sre_toupper$1=sre_toupper((signed int)*seq);
    c = (char)return_value_sre_toupper$1;
    if(!((signed int)c == 32) && !((signed int)c == 45) && !((signed int)c == 46) && !((signed int)c == 95) && !((signed int)c == 126))
    {
      char *return_value_strchr$5;
      return_value_strchr$5=strchr(protonly, (signed int)c);
      if(!(return_value_strchr$5 == ((char *)NULL)))
        po = po + 1;

      else
      {
        return_value_strchr$4=strchr(primenuc, (signed int)c);
        if(!(return_value_strchr$4 == ((char *)NULL)))
        {
          na = na + 1;
          if((signed int)c == 84)
            nt = nt + 1;

          else
            if((signed int)c == 85)
              nu = nu + 1;

        }

        else
        {
          return_value_strchr$3=strchr(aminos, (signed int)c);
          if(!(return_value_strchr$3 == ((char *)NULL)))
            aa = aa + 1;

          else
          {
            return_value___ctype_b_loc$2=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)c]) == 0))
              no = no + 1;

          }
        }
      }
      saw = saw + 1;
    }

  }
  if(no >= 1)
    return 0;

  else
    if(po >= 1)
      return 3;

    else
      if(!(aa >= na))
      {
        if(!(nt >= nu))
          return 2;

        else
          return 1;
      }

      else
        return 3;
}

// SetAlphabet
// file alphabet.c line 88
extern void SetAlphabet(signed int type)
{
  signed int x;
  union anonymous$1 alphabet_lock;
  signed int rtn;
  rtn=pthread_mutex_init(&alphabet_lock, (const union anonymous$2 *)(void *)0);
  char *return_value_strerror$1;
  if(!(rtn == 0))
  {
    return_value_strerror$1=strerror(rtn);
    Die("pthread_mutex_init FAILED; %s\n", return_value_strerror$1);
  }

  rtn=pthread_mutex_lock(&alphabet_lock);
  char *return_value_strerror$2;
  if(!(rtn == 0))
  {
    return_value_strerror$2=strerror(rtn);
    Die("pthread_mutex_lock FAILED: %s\n", return_value_strerror$2);
  }

  char *return_value_strerror$3;
  if(!(Alphabet_type == 0))
  {
    if(!(type == Alphabet_type))
      Die("An alphabet type conflict occurred.\nYou probably mixed a DNA seq file with a protein model, or vice versa.");

    rtn=pthread_mutex_unlock(&alphabet_lock);
    if(!(rtn == 0))
    {
      return_value_strerror$3=strerror(rtn);
      Die("pthread_mutex_unlock failure: %s\n", return_value_strerror$3);
    }

    goto __CPROVER_DUMP_L19;
  }

  switch(type)
  {
    case 3:
    {
      Alphabet_type = type;
      strcpy(Alphabet, "ACDEFGHIKLMNPQRSTVWYUBZX");
      Alphabet_size = 20;
      Alphabet_iupac = 24;
      x = 0;
      for( ; !(x >= Alphabet_iupac); x = x + 1)
        memset((void *)Degenerate[(signed long int)x], 0, (unsigned long int)Alphabet_size);
      x = 0;
      for( ; !(x >= Alphabet_size); x = x + 1)
      {
        Degenerate[(signed long int)x][(signed long int)x] = (char)1;
        DegenCount[(signed long int)x] = 1;
      }
      set_degenerate((char)85, "S");
      set_degenerate((char)66, "ND");
      set_degenerate((char)90, "QE");
      set_degenerate((char)88, "ACDEFGHIKLMNPQRSTVWY");
      break;
    }
    case 2:
    {
      Alphabet_type = type;
      strcpy(Alphabet, "ACGTUNRYMKSWHBVDX");
      Alphabet_size = 4;
      Alphabet_iupac = 17;
      x = 0;
      for( ; !(x >= Alphabet_iupac); x = x + 1)
        memset((void *)Degenerate[(signed long int)x], 0, (unsigned long int)Alphabet_size);
      x = 0;
      for( ; !(x >= Alphabet_size); x = x + 1)
      {
        Degenerate[(signed long int)x][(signed long int)x] = (char)1;
        DegenCount[(signed long int)x] = 1;
      }
      set_degenerate((char)85, "T");
      set_degenerate((char)78, "ACGT");
      set_degenerate((char)88, "ACGT");
      set_degenerate((char)82, "AG");
      set_degenerate((char)89, "CT");
      set_degenerate((char)77, "AC");
      set_degenerate((char)75, "GT");
      set_degenerate((char)83, "CG");
      set_degenerate((char)87, "AT");
      set_degenerate((char)72, "ACT");
      set_degenerate((char)66, "CGT");
      set_degenerate((char)86, "ACG");
      set_degenerate((char)68, "AGT");
      break;
    }
    default:
      Die("No support for non-nucleic or protein alphabets");
  }
  rtn=pthread_mutex_unlock(&alphabet_lock);
  char *return_value_strerror$4;
  if(!(rtn == 0))
  {
    return_value_strerror$4=strerror(rtn);
    Die("pthread_mutex_unlock failure: %s\n", return_value_strerror$4);
  }


__CPROVER_DUMP_L19:
  ;
}

// SetAutocuts
// file misc.c line 158
signed int SetAutocuts(struct threshold_s *thresh, struct plan7_s *hmm)
{
  if((signed int)thresh->autocut == CUT_GA)
  {
    if((1024 & hmm->flags) == 0)
      return 0;

    thresh->globT = hmm->ga1;
    thresh->domT = hmm->ga2;
    thresh->domE = (double)3.40282346638528859812e+38F;
    thresh->globE = thresh->domE;
  }

  else
    if((signed int)thresh->autocut == CUT_NC)
    {
      if((4096 & hmm->flags) == 0)
        return 0;

      thresh->globT = hmm->nc1;
      thresh->domT = hmm->nc2;
      thresh->domE = (double)3.40282346638528859812e+38F;
      thresh->globE = thresh->domE;
    }

    else
      if((signed int)thresh->autocut == CUT_TC)
      {
        if((2048 & hmm->flags) == 0)
          return 0;

        thresh->globT = hmm->tc1;
        thresh->domT = hmm->tc2;
        thresh->domE = (double)3.40282346638528859812e+38F;
        thresh->globE = thresh->domE;
      }

  return 1;
}

// SetSeqinfoString
// file sqfuncs.h line 159
extern signed int SetSeqinfoString(struct seqinfo_s *sqinfo, char *sptr, signed int flag)
{
  signed int len;
  signed int pos;
  const unsigned short int **return_value___ctype_b_loc$2;
  signed int return_value_IsInt$4;
  signed int return_value_IsInt$5;
  signed int return_value_IsInt$6;
  if(sptr == ((char *)NULL))
    return 1;

  else
  {
    for( ; (signed int)*sptr == 32; sptr = sptr + 1l)
      ;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(sptr);
    pos = (signed int)(return_value_strlen$1 - (unsigned long int)1);
    for( ; pos >= 0; pos = pos - 1)
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)sptr[(signed long int)pos]]) == 0)
        break;

    }
    sptr[(signed long int)(pos + 1)] = (char)0;
    if(!(flag == 1))
    {
      if(flag == 2)
        goto __CPROVER_DUMP_L7;

      if(flag == 4)
        goto __CPROVER_DUMP_L9;

      if(flag == 8)
        goto __CPROVER_DUMP_L11;

      if(flag == 16)
        goto __CPROVER_DUMP_L16;

      if(flag == 32)
        goto __CPROVER_DUMP_L19;

      if(flag == 256)
        goto __CPROVER_DUMP_L22;

    }

    else
    {
      if(!((signed int)*sptr == 45))
      {
        strncpy(sqinfo->name, sptr, (unsigned long int)(64 - 1));
        sqinfo->name[(signed long int)(64 - 1)] = (char)0;
        sqinfo->flags = sqinfo->flags | 1 << 0;
      }

      goto __CPROVER_DUMP_L26;

    __CPROVER_DUMP_L7:
      ;
      if(!((signed int)*sptr == 45))
      {
        strncpy(sqinfo->id, sptr, (unsigned long int)(64 - 1));
        sqinfo->id[(signed long int)(64 - 1)] = (char)0;
        sqinfo->flags = sqinfo->flags | 1 << 1;
      }

      goto __CPROVER_DUMP_L26;

    __CPROVER_DUMP_L9:
      ;
      if(!((signed int)*sptr == 45))
      {
        strncpy(sqinfo->acc, sptr, (unsigned long int)(64 - 1));
        sqinfo->acc[(signed long int)(64 - 1)] = (char)0;
        sqinfo->flags = sqinfo->flags | 1 << 2;
      }

      goto __CPROVER_DUMP_L26;

    __CPROVER_DUMP_L11:
      ;
      if(!((signed int)*sptr == 45))
      {
        if(!((8 & sqinfo->flags) == 0))
        {
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(sqinfo->desc);
          len = (signed int)return_value_strlen$3;
          if(!(len >= 128))
          {
            strncat(sqinfo->desc, " ", (unsigned long int)((128 - 1) - len));
            len = len + 1;
            strncat(sqinfo->desc, sptr, (unsigned long int)((128 - 1) - len));
          }

        }

        else
          strncpy(sqinfo->desc, sptr, (unsigned long int)(128 - 1));
        sqinfo->desc[(signed long int)(128 - 1)] = (char)0;
        sqinfo->flags = sqinfo->flags | 1 << 3;
      }

      goto __CPROVER_DUMP_L26;

    __CPROVER_DUMP_L16:
      ;
      return_value_IsInt$4=IsInt(sptr);
      if(return_value_IsInt$4 == 0)
      {
        squid_errno = 5;
        return 0;
      }

      sqinfo->start=atoi(sptr);
      if(!(sqinfo->start == 0))
        sqinfo->flags = sqinfo->flags | 1 << 4;

      goto __CPROVER_DUMP_L26;

    __CPROVER_DUMP_L19:
      ;
      return_value_IsInt$5=IsInt(sptr);
      if(return_value_IsInt$5 == 0)
      {
        squid_errno = 5;
        return 0;
      }

      sqinfo->stop=atoi(sptr);
      if(!(sqinfo->stop == 0))
        sqinfo->flags = sqinfo->flags | 1 << 5;

      goto __CPROVER_DUMP_L26;

    __CPROVER_DUMP_L22:
      ;
      return_value_IsInt$6=IsInt(sptr);
      if(return_value_IsInt$6 == 0)
      {
        squid_errno = 5;
        return 0;
      }

      sqinfo->olen=atoi(sptr);
      if(!(sqinfo->olen == 0))
        sqinfo->flags = sqinfo->flags | 1 << 8;

      goto __CPROVER_DUMP_L26;
    }
    Die("Invalid flag %d to SetSeqinfoString()", flag);

  __CPROVER_DUMP_L26:
    ;
    return 1;
  }
}

// ShadowTrace
// file core_algorithms.c line 2277
extern struct p7trace_s * ShadowTrace(struct dpshadow_s *tb, struct plan7_s *hmm, signed int L)
{
  struct p7trace_s *tr;
  signed int curralloc;
  signed int tpos;
  signed int i;
  signed int k;
  char nxtstate;
  curralloc = L * 2 + 6;
  P7AllocTrace(curralloc, &tr);
  tr->statetype[(signed long int)0] = (char)9;
  tr->nodeidx[(signed long int)0] = 0;
  tr->pos[(signed long int)0] = 0;
  tpos = 1;
  i = L;
  k = 0;
  nxtstate = (char)8;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_if_expr$6;
  signed int tmp_post$5;
  signed int return_value_Prob2Score$8;
  signed int tmp_post$7;
  signed int tmp_if_expr$10;
  signed int tmp_post$9;
  signed int return_value_Prob2Score$11;
  signed int tmp_if_expr$13;
  signed int tmp_post$12;
  while(!((signed int)nxtstate == 4))
  {
    switch((signed int)nxtstate)
    {
      case 1:
      {
        tr->statetype[(signed long int)tpos] = (char)1;
        nxtstate = tb->mtb[(signed long int)i][(signed long int)k];
        tmp_post$1 = k;
        k = k - 1;
        tr->nodeidx[(signed long int)tpos] = tmp_post$1;
        tmp_post$2 = i;
        i = i - 1;
        tr->pos[(signed long int)tpos] = tmp_post$2;
        tpos = tpos + 1;
        break;
      }
      case 3:
      {
        tr->statetype[(signed long int)tpos] = (char)3;
        nxtstate = tb->itb[(signed long int)i][(signed long int)k];
        tr->nodeidx[(signed long int)tpos] = k;
        tmp_post$3 = i;
        i = i - 1;
        tr->pos[(signed long int)tpos] = tmp_post$3;
        tpos = tpos + 1;
        break;
      }
      case 2:
      {
        tr->statetype[(signed long int)tpos] = (char)2;
        nxtstate = tb->dtb[(signed long int)i][(signed long int)k];
        tmp_post$4 = k;
        k = k - 1;
        tr->nodeidx[(signed long int)tpos] = tmp_post$4;
        tr->pos[(signed long int)tpos] = 0;
        tpos = tpos + 1;
        break;
      }
      case 5:
      {
        tr->statetype[(signed long int)tpos] = (char)5;
        nxtstate = tb->xtb[(signed long int)i][(signed long int)4];
        tr->nodeidx[(signed long int)tpos] = 0;
        if((signed int)nxtstate == 5)
        {
          tmp_post$5 = i;
          i = i - 1;
          tmp_if_expr$6 = tmp_post$5;
        }

        else
          tmp_if_expr$6 = 0;
        tr->pos[(signed long int)tpos] = tmp_if_expr$6;
        tpos = tpos + 1;
        break;
      }
      case 6:
      {
        return_value_Prob2Score$8=Prob2Score(hmm->begin[(signed long int)(k + 1)], hmm->p1);
        if((double)return_value_Prob2Score$8 + 1000.000000 <= (double)hmm->bsc[(signed long int)(1 + k)])
          while(k >= 1)
          {
            tr->statetype[(signed long int)tpos] = (char)2;
            tmp_post$7 = k;
            k = k - 1;
            tr->nodeidx[(signed long int)tpos] = tmp_post$7;
            tr->pos[(signed long int)tpos] = 0;
            tpos = tpos + 1;
            if(tpos == curralloc)
            {
              curralloc = curralloc + L;
              P7ReallocTrace(tr, curralloc);
            }

          }

        tr->statetype[(signed long int)tpos] = (char)6;
        nxtstate = tb->xtb[(signed long int)i][(signed long int)0];
        tr->nodeidx[(signed long int)tpos] = 0;
        tr->pos[(signed long int)tpos] = 0;
        tpos = tpos + 1;
        break;
      }
      case 10:
      {
        tr->statetype[(signed long int)tpos] = (char)10;
        nxtstate = tb->xtb[(signed long int)i][(signed long int)3];
        tr->nodeidx[(signed long int)tpos] = 0;
        if((signed int)nxtstate == 10)
        {
          tmp_post$9 = i;
          i = i - 1;
          tmp_if_expr$10 = tmp_post$9;
        }

        else
          tmp_if_expr$10 = 0;
        tr->pos[(signed long int)tpos] = tmp_if_expr$10;
        tpos = tpos + 1;
        break;
      }
      case 7:
      {
        tr->statetype[(signed long int)tpos] = (char)7;
        tr->nodeidx[(signed long int)tpos] = 0;
        tr->pos[(signed long int)tpos] = 0;
        k = tb->esrc[(signed long int)i];
        nxtstate = (char)1;
        tpos = tpos + 1;
        return_value_Prob2Score$11=Prob2Score(hmm->end[(signed long int)k], (float)1.);
        if((double)return_value_Prob2Score$11 + 1000.000000 <= (double)hmm->esc[(signed long int)k])
        {
          signed int dk = hmm->M;
          for( ; !(k >= dk); dk = dk - 1)
          {
            tr->statetype[(signed long int)tpos] = (char)2;
            tr->nodeidx[(signed long int)tpos] = dk;
            tr->pos[(signed long int)tpos] = 0;
            tpos = tpos + 1;
            if(tpos == curralloc)
            {
              curralloc = curralloc + L;
              P7ReallocTrace(tr, curralloc);
            }

          }
        }

        break;
      }
      case 8:
      {
        tr->statetype[(signed long int)tpos] = (char)8;
        nxtstate = tb->xtb[(signed long int)i][(signed long int)2];
        tr->nodeidx[(signed long int)tpos] = 0;
        if((signed int)nxtstate == 8)
        {
          tmp_post$12 = i;
          i = i - 1;
          tmp_if_expr$13 = tmp_post$12;
        }

        else
          tmp_if_expr$13 = 0;
        tr->pos[(signed long int)tpos] = tmp_if_expr$13;
        tpos = tpos + 1;
        break;
      }
      default:
      {
        char *return_value_Statetype$14;
        return_value_Statetype$14=Statetype(nxtstate);
        Die("HMMER: Bad state (%s) in ShadowTrace()\n", return_value_Statetype$14);
      }
    }
    if(tpos == curralloc)
    {
      curralloc = curralloc + L;
      P7ReallocTrace(tr, curralloc);
    }

  }
  tr->statetype[(signed long int)tpos] = (char)4;
  tr->nodeidx[(signed long int)tpos] = 0;
  tr->pos[(signed long int)tpos] = 0;
  tr->tlen = tpos + 1;
  P7ReverseTrace(tr);
  return tr;
}

// SingleLinkCluster
// file weight.c line 704
extern void SingleLinkCluster(char **aseq, signed int nseq, signed int alen, float maxid, signed int **ret_c, signed int *ret_nc)
{
  signed int *a;
  signed int na;
  signed int *b;
  signed int nb;
  signed int *c;
  signed int nc;
  signed int v;
  signed int w;
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("weight.c", 716, sizeof(signed int) /*4ul*/  * (unsigned long int)nseq);
  a = (signed int *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("weight.c", 717, sizeof(signed int) /*4ul*/  * (unsigned long int)nseq);
  b = (signed int *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("weight.c", 718, sizeof(signed int) /*4ul*/  * (unsigned long int)nseq);
  c = (signed int *)return_value_sre_malloc$3;
  i = 0;
  for( ; !(i >= nseq); i = i + 1)
    a[(signed long int)i] = i;
  na = nseq;
  nb = 0;
  nc = 0;
  float return_value_simple_distance$4;
  for( ; na >= 1; nc = nc + 1)
  {
    v = a[(signed long int)(na - 1)];
    na = na - 1;
    b[(signed long int)nb] = v;
    nb = nb + 1;
    while(nb >= 1)
    {
      v = b[(signed long int)(nb - 1)];
      nb = nb - 1;
      c[(signed long int)v] = nc;
      i = na - 1;
      for( ; i >= 0; i = i - 1)
      {
        return_value_simple_distance$4=simple_distance(aseq[(signed long int)v], aseq[(signed long int)a[(signed long int)i]]);
        if((double)return_value_simple_distance$4 <= 1. + -((double)maxid))
        {
          w = a[(signed long int)i];
          a[(signed long int)i] = a[(signed long int)(na - 1)];
          na = na - 1;
          b[(signed long int)nb] = w;
          nb = nb + 1;
        }

      }
    }
  }
  free((void *)a);
  free((void *)b);
  *ret_c = c;
  *ret_nc = nc;
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// SqdBanner
// file squidcore.c line 46
extern void SqdBanner(struct _IO_FILE *fp, char *banner)
{
  fprintf(fp, "%s\n", banner);
  fprintf(fp, "SQUID %s (%s)\n", (const void *)"1.9g", (const void *)"January 2003");
  fprintf(fp, "%s\n", (const void *)"Copyright (C) 1992-2003 HHMI/Washington University School of Medicine");
  fprintf(fp, "%s\n", (const void *)"Freely distributed under the GNU General Public License (GPL)");
  fprintf(fp, "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
}

// SqdClean
// file ../squid/sqfuncs.h line 96
extern void SqdClean(void)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(sqd_parse[(signed long int)i] == ((char *)NULL)))
    {
      free((void *)sqd_parse[(signed long int)i]);
      sqd_parse[(signed long int)i] = (char *)(void *)0;
    }

}

// StateOccupancy
// file emit.c line 315
extern void StateOccupancy(struct plan7_s *hmm, float **ret_mp, float **ret_ip, float **ret_dp)
{
  float *fmp;
  float *fip;
  float *fdp;
  signed int k;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("emit.c", 322, sizeof(float) /*4ul*/  * (unsigned long int)(hmm->M + 1));
  fmp = (float *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("emit.c", 323, sizeof(float) /*4ul*/  * (unsigned long int)hmm->M);
  fip = (float *)return_value_sre_malloc$2;
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("emit.c", 324, sizeof(float) /*4ul*/  * (unsigned long int)(hmm->M + 1));
  fdp = (float *)return_value_sre_malloc$3;
  fdp[(signed long int)1] = hmm->tbd1;
  fmp[(signed long int)1] = hmm->begin[(signed long int)1];
  fip[(signed long int)1] = fmp[(signed long int)1] * hmm->t[(signed long int)1][(signed long int)1];
  k = 2;
  for( ; hmm->M >= k; k = k + 1)
  {
    fmp[(signed long int)k] = fmp[(signed long int)(k - 1)] * hmm->t[(signed long int)(k - 1)][(signed long int)0] + fip[(signed long int)(k - 1)] + fdp[(signed long int)(k - 1)] * hmm->t[(signed long int)(k - 1)][(signed long int)5] + hmm->begin[(signed long int)k];
    fdp[(signed long int)k] = fmp[(signed long int)(k - 1)] * hmm->t[(signed long int)(k - 1)][(signed long int)2] + fdp[(signed long int)(k - 1)] * hmm->t[(signed long int)(k - 1)][(signed long int)6];
    if(!(k >= hmm->M))
      fip[(signed long int)k] = fmp[(signed long int)k] * hmm->t[(signed long int)k][(signed long int)1];

    fmp[(signed long int)k] = fmp[(signed long int)k] / (fmp[(signed long int)k] + fdp[(signed long int)k]);
    fdp[(signed long int)k] = fdp[(signed long int)k] / (fmp[(signed long int)k] + fdp[(signed long int)k]);
  }
  *ret_mp = fmp;
  *ret_dp = fdp;
  *ret_ip = fip;
}

// Statetype
// file funcs.h line 80
extern char * Statetype(char st)
{
  switch((signed int)st)
  {
    case 4:
      return "S";
    case 5:
      return "N";
    case 6:
      return "B";
    case 1:
      return "M";
    case 2:
      return "D";
    case 3:
      return "I";
    case 7:
      return "E";
    case 10:
      return "J";
    case 8:
      return "C";
    case 9:
      return "T";
    default:
      return "BOGUS";
  }
}

// StopwatchCopy
// file stopwatch.c line 214
extern void StopwatchCopy(struct stopwatch_s *w1, struct stopwatch_s *w2)
{
  w1->t0 = w2->t0;
  w1->cpu0.tms_utime = w2->cpu0.tms_utime;
  w1->cpu0.tms_stime = w2->cpu0.tms_stime;
  w1->cpu0.tms_cutime = w2->cpu0.tms_cutime;
  w1->cpu0.tms_cstime = w2->cpu0.tms_cstime;
  w1->elapsed = w2->elapsed;
  w1->user = w2->user;
  w1->sys = w2->sys;
}

// StopwatchCreate
// file stopwatch.c line 200
extern struct stopwatch_s * StopwatchCreate(void)
{
  struct stopwatch_s *w;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct stopwatch_s) /*64ul*/ );
  w = (struct stopwatch_s *)return_value_malloc$1;
  return w;
}

// StopwatchDisplay
// file stopwatch.c line 252
extern void StopwatchDisplay(struct _IO_FILE *fp, char *s, struct stopwatch_s *w)
{
  char buf[128l];
  if(s == ((char *)NULL))
    fputs("CPU Time: ", fp);

  else
    fputs(s, fp);
  format_time_string(buf, w->user + w->sys, 1);
  fprintf(fp, "%.2fu %.2fs %s ", w->user, w->sys, (const void *)buf);
  format_time_string(buf, w->elapsed, 0);
  fprintf(fp, "Elapsed: %s\n", (const void *)buf);
}

// StopwatchFree
// file stopwatch.c line 230
extern void StopwatchFree(struct stopwatch_s *w)
{
  free((void *)w);
}

// StopwatchInclude
// file ../squid/stopwatch.h line 50
extern void StopwatchInclude(struct stopwatch_s *w1, struct stopwatch_s *w2)
{
  w1->user = w1->user + w2->user;
  w1->sys = w1->sys + w2->sys;
}

// StopwatchPVMPack
// file stopwatch.c line 280
extern void StopwatchPVMPack(struct stopwatch_s *w)
{
  pvm_pkdouble(&w->elapsed, 1, 1);
  pvm_pkdouble(&w->user, 1, 1);
  pvm_pkdouble(&w->sys, 1, 1);
}

// StopwatchPVMUnpack
// file ../squid/stopwatch.h line 59
extern void StopwatchPVMUnpack(struct stopwatch_s *w)
{
  pvm_upkdouble(&w->elapsed, 1, 1);
  pvm_upkdouble(&w->user, 1, 1);
  pvm_upkdouble(&w->sys, 1, 1);
}

// StopwatchStart
// file ../squid/stopwatch.h line 48
extern void StopwatchStart(struct stopwatch_s *w)
{
  w->t0=time((signed long int *)(void *)0);
  times(&w->cpu0);
  w->elapsed = 0.;
  w->user = 0.;
  w->sys = 0.;
}

// StopwatchStop
// file ../squid/stopwatch.h line 49
extern void StopwatchStop(struct stopwatch_s *w)
{
  signed long int t1;
  struct tms cpu1;
  signed long int clk_tck;
  t1=time((signed long int *)(void *)0);
  w->elapsed=difftime(t1, w->t0);
  times(&cpu1);
  clk_tck=sysconf(2);
  w->user = (double)(((cpu1.tms_utime + cpu1.tms_cutime) - w->cpu0.tms_utime) - w->cpu0.tms_cutime) / (double)clk_tck;
  w->sys = (double)(((cpu1.tms_stime + cpu1.tms_cstime) - w->cpu0.tms_stime) - w->cpu0.tms_cstime) / (double)clk_tck;
}

// StopwatchZero
// file ../squid/stopwatch.h line 52
extern void StopwatchZero(struct stopwatch_s *w)
{
  w->elapsed = 0.;
  w->user = 0.;
  w->sys = 0.;
}

// StrDPShuffle
// file shuffle.c line 100
extern signed int StrDPShuffle(char *s1, char *s2)
{
  signed int len;
  signed int pos;
  signed int x;
  signed int y;
  char **E;
  signed int *nE;
  signed int *iE;
  signed int n;
  char sf;
  char Z[26l];
  signed int keep_connecting;
  signed int is_eulerian;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s2);
  len = (signed int)return_value_strlen$1;
  pos = 0;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !(pos >= len); pos = pos + 1)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((1024 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)s2[(signed long int)pos]]) == 0)
      return 0;

  }
  void *return_value_sre_malloc$3;
  return_value_sre_malloc$3=sre_malloc("shuffle.c", 127, sizeof(char *) /*8ul*/  * (unsigned long int)26);
  E = (char **)return_value_sre_malloc$3;
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("shuffle.c", 128, sizeof(signed int) /*4ul*/  * (unsigned long int)26);
  nE = (signed int *)return_value_sre_malloc$4;
  x = 0;
  for( ; !(x >= 26); x = x + 1)
  {
    void *return_value_sre_malloc$5;
    return_value_sre_malloc$5=sre_malloc("shuffle.c", 131, sizeof(char) /*1ul*/  * (unsigned long int)(len - 1));
    E[(signed long int)x] = (char *)return_value_sre_malloc$5;
    nE[(signed long int)x] = 0;
  }
  signed int return_value_toupper$6;
  return_value_toupper$6=toupper((signed int)s2[(signed long int)0]);
  x = return_value_toupper$6 - 65;
  pos = 1;
  for( ; !(pos >= len); pos = pos + 1)
  {
    signed int return_value_toupper$7;
    return_value_toupper$7=toupper((signed int)s2[(signed long int)pos]);
    y = return_value_toupper$7 - 65;
    E[(signed long int)x][(signed long int)nE[(signed long int)x]] = (char)y;
    nE[(signed long int)x] = nE[(signed long int)x] + 1;
    x = y;
  }
  signed int return_value_toupper$8;
  return_value_toupper$8=toupper((signed int)s2[(signed long int)(len - 1)]);
  sf = (char)(return_value_toupper$8 - 65);
  is_eulerian = 0;
  while(is_eulerian == 0)
  {
    x = 0;
    for( ; !(x >= 26); x = x + 1)
      if(!(nE[(signed long int)x] == 0) && !(x == (signed int)sf))
      {
        double return_value_sre_random$9;
        return_value_sre_random$9=sre_random();
        pos = (signed int)(return_value_sre_random$9 * (double)nE[(signed long int)x]);
        y = (signed int)E[(signed long int)x][(signed long int)pos];
        E[(signed long int)x][(signed long int)pos] = E[(signed long int)x][(signed long int)(nE[(signed long int)x] - 1)];
        E[(signed long int)x][(signed long int)(nE[(signed long int)x] - 1)] = (char)y;
      }

    x = 0;
    for( ; !(x >= 26); x = x + 1)
      Z[(signed long int)x] = (char)0;
    keep_connecting = 1;
    Z[(signed long int)(signed int)sf] = (char)keep_connecting;
    while(!(keep_connecting == 0))
    {
      keep_connecting = 0;
      x = 0;
      for( ; !(x >= 26); x = x + 1)
      {
        y = (signed int)E[(signed long int)x][(signed long int)(nE[(signed long int)x] - 1)];
        if((signed int)Z[(signed long int)x] == 0)
        {
          if((signed int)Z[(signed long int)y] == 1)
          {
            Z[(signed long int)x] = (char)1;
            keep_connecting = 1;
          }

        }

      }
    }
    is_eulerian = 1;
    x = 0;
    for( ; !(x >= 26); x = x + 1)
      if(!(nE[(signed long int)x] == 0) && !(x == (signed int)sf))
      {
        if((signed int)Z[(signed long int)x] == 0)
        {
          is_eulerian = 0;
          break;
        }

      }

  }
  x = 0;
  for( ; !(x >= 26); x = x + 1)
  {
    n = nE[(signed long int)x] - 1;
    for( ; n >= 2; n = n - 1)
    {
      double return_value_sre_random$10;
      return_value_sre_random$10=sre_random();
      pos = (signed int)(return_value_sre_random$10 * (double)n);
      y = (signed int)E[(signed long int)x][(signed long int)pos];
      E[(signed long int)x][(signed long int)pos] = E[(signed long int)x][(signed long int)(n - 1)];
      E[(signed long int)x][(signed long int)(n - 1)] = (char)y;
    }
  }
  void *return_value_sre_malloc$11;
  return_value_sre_malloc$11=sre_malloc("shuffle.c", 240, sizeof(signed int) /*4ul*/  * (unsigned long int)26);
  iE = (signed int *)return_value_sre_malloc$11;
  x = 0;
  for( ; !(x >= 26); x = x + 1)
    iE[(signed long int)x] = 0;
  pos = 0;
  signed int return_value_toupper$12;
  return_value_toupper$12=toupper((signed int)s2[(signed long int)0]);
  x = return_value_toupper$12 - 65;
  signed int tmp_post$13;
  while((_Bool)1)
  {
    tmp_post$13 = pos;
    pos = pos + 1;
    s1[(signed long int)tmp_post$13] = (char)(65 + x);
    y = (signed int)E[(signed long int)x][(signed long int)iE[(signed long int)x]];
    iE[(signed long int)x] = iE[(signed long int)x] + 1;
    x = y;
    if(iE[(signed long int)x] == nE[(signed long int)x])
      break;

  }
  signed int tmp_post$14 = pos;
  pos = pos + 1;
  s1[(signed long int)tmp_post$14] = (char)(65 + (signed int)sf);
  s1[(signed long int)pos] = (char)0;
  if(!(x == (signed int)sf))
    Die("hey, you didn't end on s_f.");

  if(!(pos == len))
    Die("hey, pos (%d) != len (%d).", pos, len);

  Free2DArray((void **)E, 26);
  free((void *)nE);
  free((void *)iE);
  return 1;
}

// StrMarkov0
// file shuffle.c line 290
extern signed int StrMarkov0(char *s1, char *s2)
{
  signed int len;
  signed int pos;
  float p[26l];
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s2);
  len = (signed int)return_value_strlen$1;
  pos = 0;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !(pos >= len); pos = pos + 1)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((1024 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)s2[(signed long int)pos]]) == 0)
      return 0;

  }
  FSet(p, 26, (float)0.);
  pos = 0;
  signed int return_value_toupper$3;
  for( ; !(pos >= len); pos = pos + 1)
  {
    return_value_toupper$3=toupper((signed int)s2[(signed long int)pos]);
    p[(signed long int)(signed int)(return_value_toupper$3 - 65)] = p[(signed long int)(signed int)(return_value_toupper$3 - 65)] + (float)1.0;
  }
  FNorm(p, 26);
  pos = 0;
  signed int return_value_FChoose$4;
  for( ; !(pos >= len); pos = pos + 1)
  {
    return_value_FChoose$4=FChoose(p, 26);
    s1[(signed long int)pos] = (char)(return_value_FChoose$4 + 65);
  }
  s1[(signed long int)pos] = (char)0;
  return 1;
}

// StrMarkov1
// file shuffle.c line 335
extern signed int StrMarkov1(char *s1, char *s2)
{
  signed int len;
  signed int pos;
  signed int x;
  signed int y;
  signed int i;
  float p[26l][26l];
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s2);
  len = (signed int)return_value_strlen$1;
  pos = 0;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !(pos >= len); pos = pos + 1)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((1024 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)s2[(signed long int)pos]]) == 0)
      return 0;

  }
  x = 0;
  for( ; !(x >= 26); x = x + 1)
    FSet(p[(signed long int)x], 26, (float)0.);
  signed int return_value_toupper$3;
  return_value_toupper$3=toupper((signed int)s2[(signed long int)0]);
  x = return_value_toupper$3 - 65;
  i = x;
  pos = 1;
  for( ; !(pos >= len); pos = pos + 1)
  {
    signed int return_value_toupper$4;
    return_value_toupper$4=toupper((signed int)s2[(signed long int)pos]);
    y = return_value_toupper$4 - 65;
    p[(signed long int)x][(signed long int)y] = p[(signed long int)x][(signed long int)y] + (float)1.0;
    x = y;
  }
  x = 0;
  for( ; !(x >= 26); x = x + 1)
    FNorm(p[(signed long int)x], 26);
  x = i;
  s1[(signed long int)0] = (char)(x + 65);
  pos = 1;
  for( ; !(pos >= len); pos = pos + 1)
  {
    y=FChoose(p[(signed long int)x], 26);
    s1[(signed long int)pos] = (char)(y + 65);
    x = y;
  }
  s1[(signed long int)pos] = (char)0;
  return 1;
}

// StrRegionalShuffle
// file shuffle.c line 424
extern signed int StrRegionalShuffle(char *s1, char *s2, signed int w)
{
  signed int len;
  char c;
  signed int pos;
  signed int i;
  signed int j;
  if(!(s1 == s2))
    strcpy(s1, s2);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s1);
  len = (signed int)return_value_strlen$1;
  i = 0;
  for( ; !(i >= len); i = i + w)
  {
    j = len - 1 < (i + w) - 1 ? len - 1 : (i + w) - 1;
    for( ; !(i >= j); j = j - 1)
    {
      double return_value_sre_random$2;
      return_value_sre_random$2=sre_random();
      pos = i + (signed int)(return_value_sre_random$2 * (double)(j - i));
      c = s1[(signed long int)pos];
      s1[(signed long int)pos] = s1[(signed long int)j];
      s1[(signed long int)j] = c;
    }
  }
  return 1;
}

// StrReverse
// file sqfuncs.h line 141
extern signed int StrReverse(char *s1, char *s2)
{
  signed int len;
  signed int pos;
  char c;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s2);
  len = (signed int)return_value_strlen$1;
  pos = 0;
  for( ; !(pos >= len / 2); pos = pos + 1)
  {
    c = s2[(signed long int)((len - pos) - 1)];
    s1[(signed long int)((len - pos) - 1)] = s2[(signed long int)pos];
    s1[(signed long int)pos] = c;
  }
  if(!(len % 2 == 0))
    s1[(signed long int)pos] = s2[(signed long int)pos];

  s1[(signed long int)len] = (char)0;
  return 1;
}

// StrShuffle
// file shuffle.c line 59
extern signed int StrShuffle(char *s1, char *s2)
{
  signed int len;
  signed int pos;
  char c;
  if(!(s1 == s2))
    strcpy(s1, s2);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s1);
  len = (signed int)return_value_strlen$1;
  for( ; len >= 2; len = len - 1)
  {
    double return_value_sre_random$2;
    return_value_sre_random$2=sre_random();
    pos = (signed int)(return_value_sre_random$2 * (double)len);
    c = s1[(signed long int)pos];
    s1[(signed long int)pos] = s1[(signed long int)(len - 1)];
    s1[(signed long int)(len - 1)] = c;
  }
  return 1;
}

// Strdelete
// file sre_string.c line 82
extern signed int Strdelete(char *s1, signed int pos)
{
  char *s = s1 + (signed long int)pos;
  for( ; !(*s == 0); s = s + 1l)
    *s = s[(signed long int)1];
  return 1;
}

// Strdup
// file ../squid/sqfuncs.h line 214
extern char * Strdup(char *s)
{
  char *new;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(s);
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
    new = (char *)return_value_malloc$2;
    if(new == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      strcpy(new, s);
      return new;
    }
  }
}

// String2SeqfileFormat
// file sqio.c line 1766
extern signed int String2SeqfileFormat(char *s)
{
  char *s2;
  signed int code = 0;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$13;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    s2=sre_strdup(s, -1);
    s2upper(s2);
    signed int return_value_strcmp$19;
    return_value_strcmp$19=strcmp(s2, "FASTA");
    if(return_value_strcmp$19 == 0)
      code = 7;

    else
    {
      return_value_strcmp$18=strcmp(s2, "GENBANK");
      if(return_value_strcmp$18 == 0)
        code = 2;

      else
      {
        return_value_strcmp$17=strcmp(s2, "EMBL");
        if(return_value_strcmp$17 == 0)
          code = 4;

        else
        {
          return_value_strcmp$16=strcmp(s2, "GCG");
          if(return_value_strcmp$16 == 0)
            code = 5;

          else
          {
            return_value_strcmp$15=strcmp(s2, "GCGDATA");
            if(return_value_strcmp$15 == 0)
              code = 16;

            else
            {
              return_value_strcmp$14=strcmp(s2, "RAW");
              if(return_value_strcmp$14 == 0)
                code = 13;

              else
              {
                return_value_strcmp$13=strcmp(s2, "IG");
                if(return_value_strcmp$13 == 0)
                  code = 1;

                else
                {
                  return_value_strcmp$12=strcmp(s2, "STRIDER");
                  if(return_value_strcmp$12 == 0)
                    code = 6;

                  else
                  {
                    return_value_strcmp$11=strcmp(s2, "IDRAW");
                    if(return_value_strcmp$11 == 0)
                      code = 9;

                    else
                    {
                      return_value_strcmp$10=strcmp(s2, "ZUKER");
                      if(return_value_strcmp$10 == 0)
                        code = 8;

                      else
                      {
                        return_value_strcmp$9=strcmp(s2, "PIR");
                        if(return_value_strcmp$9 == 0)
                          code = 12;

                        else
                        {
                          return_value_strcmp$8=strcmp(s2, "SQUID");
                          if(return_value_strcmp$8 == 0)
                            code = 14;

                          else
                          {
                            return_value_strcmp$7=strcmp(s2, "STOCKHOLM");
                            if(return_value_strcmp$7 == 0)
                              code = 101;

                            else
                            {
                              return_value_strcmp$6=strcmp(s2, "SELEX");
                              if(return_value_strcmp$6 == 0)
                                code = 102;

                              else
                              {
                                return_value_strcmp$5=strcmp(s2, "MSF");
                                if(return_value_strcmp$5 == 0)
                                  code = 103;

                                else
                                {
                                  return_value_strcmp$4=strcmp(s2, "CLUSTAL");
                                  if(return_value_strcmp$4 == 0)
                                    code = 104;

                                  else
                                  {
                                    return_value_strcmp$3=strcmp(s2, "A2M");
                                    if(return_value_strcmp$3 == 0)
                                      code = 105;

                                    else
                                    {
                                      return_value_strcmp$2=strcmp(s2, "PHYLIP");
                                      if(return_value_strcmp$2 == 0)
                                        code = 106;

                                      else
                                      {
                                        return_value_strcmp$1=strcmp(s2, "EPS");
                                        if(return_value_strcmp$1 == 0)
                                          code = 107;

                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    free((void *)s2);
    return code;
  }
}

// StringChop
// file ../squid/sqfuncs.h line 215
extern void StringChop(char *s)
{
  signed int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  i = (signed int)(return_value_strlen$1 - (unsigned long int)1);
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; i >= 0; i = i - 1)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)s[(signed long int)i]]) == 0)
      break;

  }
  s[(signed long int)(i + 1)] = (char)0;
}

// Strinsert
// file sre_string.c line 61
extern signed int Strinsert(char *s1, char c, signed int pos)
{
  char oldc;
  char *s = s1 + (signed long int)pos;
  for( ; !(c == 0); s = s + 1l)
  {
    oldc = *s;
    *s = c;
    c = oldc;
  }
  *s = (char)0;
  return 1;
}

// Strparse
// file hsregex.c line 92
extern signed int Strparse(char *rexp, char *s, signed int ntok)
{
  struct sqd_regexp *pat;
  signed int code;
  signed int len;
  signed int i;
  if(ntok >= 10)
    Die("Strparse(): ntok must be <= %d", 10 - 1);

  i = 0;
  for( ; ntok >= i; i = i + 1)
    if(!(sqd_parse[(signed long int)i] == ((char *)NULL)))
    {
      free((void *)sqd_parse[(signed long int)i]);
      sqd_parse[(signed long int)i] = (char *)(void *)0;
    }

  pat=sqd_regcomp(rexp);
  if(pat == ((struct sqd_regexp *)NULL))
    Die("regexp compilation failed.");

  code=sqd_regexec(pat, s);
  if(code == 1)
  {
    i = 0;
    for( ; ntok >= i; i = i + 1)
      if(!(pat->startp[(signed long int)i] == ((char *)NULL)))
      {
        if(!(pat->endp[(signed long int)i] == ((char *)NULL)))
        {
          len = (signed int)(pat->endp[(signed long int)i] - pat->startp[(signed long int)i]);
          void *return_value_sre_malloc$1;
          return_value_sre_malloc$1=sre_malloc("hsregex.c", 124, sizeof(char) /*1ul*/  * (unsigned long int)(len + 1));
          sqd_parse[(signed long int)i] = (char *)return_value_sre_malloc$1;
          strncpy(sqd_parse[(signed long int)i], pat->startp[(signed long int)i], (unsigned long int)len);
          sqd_parse[(signed long int)i][(signed long int)len] = (char)0;
        }

      }

  }

  free((void *)pat);
  return code;
}

// SymbolIndex
// file alphabet.c line 182
extern unsigned char SymbolIndex(char sym)
{
  char *s;
  signed int return_value_toupper$1;
  return_value_toupper$1=toupper((signed int)sym);
  s=strchr(Alphabet, (signed int)(char)return_value_toupper$1);
  signed long int tmp_if_expr$2;
  if(s == ((char *)NULL))
    tmp_if_expr$2 = (signed long int)(Alphabet_iupac - 1);

  else
    tmp_if_expr$2 = s - Alphabet;
  return (unsigned char)tmp_if_expr$2;
}

// ThreadNumber
// file funcs.h line 300
extern signed int ThreadNumber(void)
{
  signed int num;
  char *env;
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(84);
  num = (signed int)return_value_sysconf$1;
  if(num == -1)
    num = 2;

  env=getenv("HMMER_NCPU");
  if(!(env == ((char *)NULL)))
    num=atoi(env);

  if(!(num >= 1))
    num = 1;

  return num;
}

// ToDNA
// file sqio.c line 444
extern void ToDNA(char *seq)
{
  for( ; !((signed int)*seq == 0); seq = seq + 1l)
    if((signed int)*seq == 85)
      *seq = (char)84;

    else
      if((signed int)*seq == 117)
        *seq = (char)116;

}

// ToIUPAC
// file sqio.c line 485
extern void ToIUPAC(char *seq, signed int is_aseq)
{
  char *return_value_strchr$5;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  char *return_value_strchr$6;
  if(!(is_aseq == 0))
    for( ; !((signed int)*seq == 0); seq = seq + 1l)
    {
      return_value_strchr$5=strchr("ACGTUNRYMKSWHBVDacgtunrymkswhbvd", (signed int)*seq);
      if(return_value_strchr$5 == ((char *)NULL))
      {
        if((signed int)*seq == 32)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)*seq == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*seq == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)*seq == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)*seq == 126 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$4)
          *seq = (char)78;

      }

    }

  else
    for( ; !((signed int)*seq == 0); seq = seq + 1l)
    {
      return_value_strchr$6=strchr("ACGTUNRYMKSWHBVDacgtunrymkswhbvd", (signed int)*seq);
      if(return_value_strchr$6 == ((char *)NULL))
        *seq = (char)78;

    }
}

// ToRNA
// file sqio.c line 459
extern void ToRNA(char *seq)
{
  for( ; !((signed int)*seq == 0); seq = seq + 1l)
    if((signed int)*seq == 84)
      *seq = (char)85;

    else
      if((signed int)*seq == 116)
        *seq = (char)117;

}

// TophitsMaxName
// file tophits.c line 253
extern signed int TophitsMaxName(struct tophit_s *h)
{
  signed int i;
  signed int len;
  signed int maxlen = 0;
  i = 0;
  for( ; !(i >= h->num); i = i + 1)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((h->unsrt + (signed long int)i)->name);
    len = (signed int)return_value_strlen$1;
    if(!(maxlen >= len))
      maxlen = len;

  }
  return maxlen;
}

// TophitsReport
// file tophits.c line 328
extern void TophitsReport(struct tophit_s *h, double E, signed int nseq)
{
  signed int i;
  signed int memused;
  signed int x;
  signed int n;
  memused = (signed int)(sizeof(struct hit_s) /*104ul*/  * (unsigned long int)h->alloc + sizeof(struct tophit_s) /*32ul*/ );
  i = 0;
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  unsigned long int return_value_strlen$4;
  unsigned long int return_value_strlen$5;
  for( ; !(i >= h->num); i = i + 1)
  {
    if(!((h->unsrt + (signed long int)i)->name == ((char *)NULL)))
    {
      return_value_strlen$1=strlen((h->unsrt + (signed long int)i)->name);
      memused = memused + (signed int)(return_value_strlen$1 + (unsigned long int)1);
    }

    if(!((h->unsrt + (signed long int)i)->acc == ((char *)NULL)))
    {
      return_value_strlen$2=strlen((h->unsrt + (signed long int)i)->acc);
      memused = memused + (signed int)(return_value_strlen$2 + (unsigned long int)1);
    }

    if(!((h->unsrt + (signed long int)i)->desc == ((char *)NULL)))
    {
      return_value_strlen$3=strlen((h->unsrt + (signed long int)i)->desc);
      memused = memused + (signed int)(return_value_strlen$3 + (unsigned long int)1);
    }

    if(!((h->unsrt + (signed long int)i)->ali == ((struct fancyali_s *)NULL)))
    {
      memused = memused + (signed int)sizeof(struct fancyali_s) /*72ul*/ ;
      x = 0;
      if(!((h->unsrt + (signed long int)i)->ali->rfline == ((char *)NULL)))
        x = x + 1;

      if(!((h->unsrt + (signed long int)i)->ali->csline == ((char *)NULL)))
        x = x + 1;

      if(!((h->unsrt + (signed long int)i)->ali->model == ((char *)NULL)))
        x = x + 1;

      if(!((h->unsrt + (signed long int)i)->ali->mline == ((char *)NULL)))
        x = x + 1;

      if(!((h->unsrt + (signed long int)i)->ali->aseq == ((char *)NULL)))
        x = x + 1;

      memused = memused + x * ((h->unsrt + (signed long int)i)->ali->len + 1);
      if(!((h->unsrt + (signed long int)i)->ali->query == ((char *)NULL)))
      {
        return_value_strlen$4=strlen((h->unsrt + (signed long int)i)->ali->query);
        memused = memused + (signed int)(return_value_strlen$4 + (unsigned long int)1);
      }

      if(!((h->unsrt + (signed long int)i)->ali->target == ((char *)NULL)))
      {
        return_value_strlen$5=strlen((h->unsrt + (signed long int)i)->ali->target);
        memused = memused + (signed int)(return_value_strlen$5 + (unsigned long int)1);
      }

    }

  }
  n = 0;
  i = 0;
  for( ; !(i >= h->num); i = i + 1)
  {
    if(h->hit[(signed long int)i]->pvalue * (double)nseq >= E)
      break;

    n = n + 1;
  }
  printf("tophits_s report:\n");
  printf("     Total hits:           %d\n", h->num);
  printf("     Satisfying E cutoff:  %d\n", n);
  printf("     Total memory:         %dK\n", memused / 1000);
}

// TraceCompare
// file debug.c line 361
extern signed int TraceCompare(struct p7trace_s *t1, struct p7trace_s *t2)
{
  signed int tpos;
  if(!(t1->tlen == t2->tlen))
    return 0;

  else
  {
    tpos = 0;
    for( ; !(tpos >= t1->tlen); tpos = tpos + 1)
    {
      if(!(t1->statetype[(signed long int)tpos] == t2->statetype[(signed long int)tpos]))
        return 0;

      if(!(t1->nodeidx[(signed long int)tpos] == t2->nodeidx[(signed long int)tpos]))
        return 0;

      if(!(t1->pos[(signed long int)tpos] == t2->pos[(signed long int)tpos]))
        return 0;

    }
    return 1;
  }
}

// TraceDecompose
// file funcs.h line 352
extern void TraceDecompose(struct p7trace_s *otr, struct p7trace_s ***ret_tr, signed int *ret_ntr)
{
  struct p7trace_s **tr;
  signed int ntr;
  signed int i;
  signed int j;
  signed int idx;
  ntr = 0;
  i = 0;
  for( ; !(i >= otr->tlen); i = i + 1)
    if((signed int)otr->statetype[(signed long int)i] == 6)
      ntr = ntr + 1;

  if(ntr == 0)
  {
    *ret_ntr = 0;
    *ret_tr = (struct p7trace_s **)(void *)0;
  }

  else
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("trace.c", 893, sizeof(struct p7trace_s *) /*8ul*/  * (unsigned long int)ntr);
    tr = (struct p7trace_s **)return_value_sre_malloc$1;
    idx = 0;
    i = 0;
    for( ; !(i >= otr->tlen); i = i + 1)
      if((signed int)otr->statetype[(signed long int)i] == 6)
      {
        j = i + 1;
        for( ; !(j >= otr->tlen); j = j + 1)
          if((signed int)otr->statetype[(signed long int)j] == 7)
            break;

        P7AllocTrace((j - i) + 5, &tr[(signed long int)idx]);
        tr[(signed long int)idx]->tlen = (j - i) + 5;
        tr[(signed long int)idx]->statetype[(signed long int)0] = (char)4;
        tr[(signed long int)idx]->nodeidx[(signed long int)0] = 0;
        tr[(signed long int)idx]->pos[(signed long int)0] = 0;
        tr[(signed long int)idx]->statetype[(signed long int)1] = (char)5;
        tr[(signed long int)idx]->nodeidx[(signed long int)1] = 0;
        tr[(signed long int)idx]->pos[(signed long int)1] = 0;
        j = 2;
        for( ; (_Bool)1; j = j + 1)
        {
          tr[(signed long int)idx]->statetype[(signed long int)j] = otr->statetype[(signed long int)i];
          tr[(signed long int)idx]->nodeidx[(signed long int)j] = otr->nodeidx[(signed long int)i];
          tr[(signed long int)idx]->pos[(signed long int)j] = otr->pos[(signed long int)i];
          if((signed int)otr->statetype[(signed long int)i] == 7)
            break;

          i = i + 1;
        }
        j = j + 1;
        tr[(signed long int)idx]->statetype[(signed long int)j] = (char)8;
        tr[(signed long int)idx]->nodeidx[(signed long int)j] = 0;
        tr[(signed long int)idx]->pos[(signed long int)j] = 0;
        j = j + 1;
        tr[(signed long int)idx]->statetype[(signed long int)j] = (char)9;
        tr[(signed long int)idx]->nodeidx[(signed long int)j] = 0;
        tr[(signed long int)idx]->pos[(signed long int)j] = 0;
        idx = idx + 1;
      }

    *ret_tr = tr;
    *ret_ntr = ntr;
    goto __CPROVER_DUMP_L12;
  }

__CPROVER_DUMP_L12:
  ;
}

// TraceDomainNumber
// file trace.c line 947
extern signed int TraceDomainNumber(struct p7trace_s *tr)
{
  signed int i;
  signed int ndom = 0;
  i = 0;
  for( ; !(i >= tr->tlen); i = i + 1)
    if((signed int)tr->statetype[(signed long int)i] == 6)
      ndom = ndom + 1;

  return ndom;
}

// TraceScoreCorrection
// file funcs.h line 169
extern float TraceScoreCorrection(struct plan7_s *hmm, struct p7trace_s *tr, unsigned char *dsq)
{
  float p[20l];
  signed int sc[24l];
  signed int x;
  signed int tpos;
  signed int score;
  _Bool tmp_if_expr$1;
  if(tr == ((struct p7trace_s *)NULL))
    return (float)0.0;

  else
  {
    FSet(p, Alphabet_size, (float)0.0);
    tpos = 0;
    for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
      if((signed int)tr->statetype[(signed long int)tpos] == 1)
        FAdd(p, hmm->mat[(signed long int)tr->nodeidx[(signed long int)tpos]], Alphabet_size);

      else
        if((signed int)tr->statetype[(signed long int)tpos] == 3)
          FAdd(p, hmm->ins[(signed long int)tr->nodeidx[(signed long int)tpos]], Alphabet_size);

    FNorm(p, Alphabet_size);
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
      sc[(signed long int)x]=Prob2Score(p[(signed long int)x], hmm->null[(signed long int)x]);
    x = Alphabet_size;
    for( ; !(x >= Alphabet_iupac); x = x + 1)
      sc[(signed long int)x]=DegenerateSymbolScore(p, hmm->null, x);
    score = 0;
    tpos = 0;
    for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
    {
      if((signed int)tr->statetype[(signed long int)tpos] == 1)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)tr->statetype[(signed long int)tpos] == 3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        score = score + sc[(signed long int)dsq[(signed long int)tr->pos[(signed long int)tpos]]];

    }
    score = score - (signed int)((double)8 * 1000.0);
    signed int return_value_ILogsum$2;
    return_value_ILogsum$2=ILogsum(0, score);
    float return_value_Scorify$3;
    return_value_Scorify$3=Scorify(return_value_ILogsum$2);
    return return_value_Scorify$3;
  }
}

// TraceSet
// file funcs.h line 338
extern void TraceSet(struct p7trace_s *tr, signed int tpos, char type, signed int idx, signed int pos)
{
  tr->statetype[(signed long int)tpos] = type;
  tr->nodeidx[(signed long int)tpos] = idx;
  tr->pos[(signed long int)tpos] = pos;
}

// TraceSimpleBounds
// file funcs.h line 355
extern void TraceSimpleBounds(struct p7trace_s *tr, signed int *ret_i1, signed int *ret_i2, signed int *ret_k1, signed int *ret_k2)
{
  signed int i1;
  signed int i2;
  signed int k1;
  signed int k2;
  signed int tpos;
  k2 = -1;
  i2 = k2;
  k1 = i2;
  i1 = k1;
  tpos = 0;
  _Bool tmp_if_expr$1;
  for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
  {
    if(k1 == -1)
    {
      if((signed int)tr->statetype[(signed long int)tpos] == 1)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)tr->statetype[(signed long int)tpos] == 2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        k1 = tr->nodeidx[(signed long int)tpos];

    }

    if((signed int)tr->statetype[(signed long int)tpos] == 1)
    {
      i1 = tr->pos[(signed long int)tpos];
      break;
    }

  }
  if(i1 == -1 || k1 == -1 || tpos == tr->tlen)
    Die("sanity check failed: didn't find a match state in trace");

  tpos = tr->tlen - 1;
  _Bool tmp_if_expr$2;
  for( ; tpos >= 0; tpos = tpos - 1)
  {
    if(k2 == -1)
    {
      if((signed int)tr->statetype[(signed long int)tpos] == 1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)tr->statetype[(signed long int)tpos] == 2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        k2 = tr->nodeidx[(signed long int)tpos];

    }

    if((signed int)tr->statetype[(signed long int)tpos] == 1)
    {
      i2 = tr->pos[(signed long int)tpos];
      break;
    }

  }
  if(i2 == -1 || k2 == -1 || tpos == tr->tlen)
    Die("sanity check failed: didn't find a match state in trace");

  *ret_k1 = k1;
  *ret_i1 = i1;
  *ret_k2 = k2;
  *ret_i2 = i2;
}

// TraceVerify
// file debug.c line 225
extern signed int TraceVerify(struct p7trace_s *tr, signed int M, signed int N)
{
  signed int tpos;
  signed int k;
  signed int i;
  signed int nn;
  signed int nc;
  signed int nj;
  signed int nm;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!((signed int)*tr->statetype == 4))
    return 0;

  else
    if(!((signed int)tr->statetype[1l] == 5))
      return 0;

    else
      if(!((signed int)tr->statetype[(signed long int)(tr->tlen + -2)] == 8))
        return 0;

      else
        if(!((signed int)tr->statetype[(signed long int)(tr->tlen + -1)] == 9))
          return 0;

        else
          if(!(tr->pos[1l] == 0))
            return 0;

          else
          {
            nm = 0;
            nj = nm;
            nc = nj;
            nn = nc;
            i = nn;
            k = i;
            tpos = 0;
            for( ; !(tpos >= tr->tlen); tpos = tpos + 1)
              switch((signed int)tr->statetype[(signed long int)tpos])
              {
                case 4:
                {
                  if(!(tr->nodeidx[(signed long int)tpos] == 0))
                    return 0;

                  if(!(tr->pos[(signed long int)tpos] == 0))
                    return 0;

                  if(!(k == 0))
                    return 0;

                  if(!(i == 0))
                    return 0;

                  if(!(tpos == 0))
                    return 0;

                  break;
                }
                case 5:
                {
                  if(!(tr->nodeidx[(signed long int)tpos] == 0))
                    return 0;

                  if(!(k == 0))
                    return 0;

                  if(nn >= 1)
                  {
                    if(!(tr->pos[(signed long int)tpos] == 1 + i))
                      return 0;

                    i = i + 1;
                  }

                  else
                  {
                    if(!(tr->pos[(signed long int)tpos] == 0))
                      return 0;

                    if(!(i == 0))
                      return 0;

                  }
                  nn = nn + 1;
                  break;
                }
                case 6:
                {
                  if(!(tr->nodeidx[(signed long int)tpos] == 0))
                    return 0;

                  if(!(tr->pos[(signed long int)tpos] == 0))
                    return 0;

                  nm = 0;
                  break;
                }
                case 1:
                {
                  if(!(tr->pos[(signed long int)tpos] == 1 + i))
                    return 0;

                  if(!(tr->nodeidx[(signed long int)tpos] >= 1))
                    tmp_if_expr$1 = (_Bool)1;

                  else
                    tmp_if_expr$1 = tr->nodeidx[(signed long int)tpos] > M ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$1)
                    return 0;

                  i = i + 1;
                  if(nm == 0)
                    k = tr->nodeidx[(signed long int)tpos];

                  else
                  {
                    if(!(tr->nodeidx[(signed long int)tpos] == 1 + k))
                      return 0;

                    k = k + 1;
                  }
                  nm = nm + 1;
                  break;
                }
                case 3:
                {
                  if(!(tr->pos[(signed long int)tpos] == 1 + i))
                    return 0;

                  if(!(tr->nodeidx[(signed long int)tpos] == k))
                    return 0;

                  if(!(tr->nodeidx[(signed long int)tpos] >= 1))
                    tmp_if_expr$2 = (_Bool)1;

                  else
                    tmp_if_expr$2 = tr->nodeidx[(signed long int)tpos] > M - 1 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$2)
                    return 0;

                  if(k >= M)
                    return 0;

                  i = i + 1;
                  break;
                }
                case 2:
                {
                  if(!(tr->pos[(signed long int)tpos] == 0))
                    return 0;

                  if(!(tr->nodeidx[(signed long int)tpos] == 1 + k))
                    return 0;

                  if(!(tr->nodeidx[(signed long int)tpos] >= 1))
                    tmp_if_expr$3 = (_Bool)1;

                  else
                    tmp_if_expr$3 = tr->nodeidx[(signed long int)tpos] > M ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$3)
                    return 0;

                  k = k + 1;
                  break;
                }
                case 7:
                {
                  if(!(tr->nodeidx[(signed long int)tpos] == 0))
                    return 0;

                  if(!(tr->pos[(signed long int)tpos] == 0))
                    return 0;

                  nj = 0;
                  break;
                }
                case 10:
                {
                  if(!(tr->nodeidx[(signed long int)tpos] == 0))
                    return 0;

                  if(nj >= 1)
                  {
                    if(!(tr->pos[(signed long int)tpos] == 1 + i))
                      return 0;

                    i = i + 1;
                  }

                  else
                    if(!(tr->pos[(signed long int)tpos] == 0))
                      return 0;

                  nj = nj + 1;
                  break;
                }
                case 8:
                {
                  if(!(tr->nodeidx[(signed long int)tpos] == 0))
                    return 0;

                  if(nc >= 1)
                  {
                    if(!(tr->pos[(signed long int)tpos] == 1 + i))
                      return 0;

                    i = i + 1;
                  }

                  else
                    if(!(tr->pos[(signed long int)tpos] == 0))
                      return 0;

                  nc = nc + 1;
                  break;
                }
                case 9:
                {
                  if(!(tpos == tr->tlen + -1))
                    return 0;

                  if(!(tr->nodeidx[(signed long int)tpos] == 0))
                    return 0;

                  if(!(tr->pos[(signed long int)tpos] == 0))
                    return 0;

                  if(!(i == N))
                    return 0;

                  break;
                }
                case 0:

                default:
                  return 0;
              }
            return 1;
          }
}

// TransitionScoreLookup
// file funcs.h line 347
extern signed int TransitionScoreLookup(struct plan7_s *hmm, char st1, signed int k1, char st2, signed int k2)
{
  signed int return_value_Prob2Score$3;
  switch((signed int)st1)
  {
    case 4:
      return 0;
    case 5:
      switch((signed int)st2)
      {
        case 6:
          return hmm->xsc[(signed long int)0][(signed long int)0];
        case 5:
          return hmm->xsc[(signed long int)0][(signed long int)1];
        default:
        {
          char *return_value_Statetype$1;
          return_value_Statetype$1=Statetype(st1);
          char *return_value_Statetype$2;
          return_value_Statetype$2=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$1, return_value_Statetype$2);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 6:
      switch((signed int)st2)
      {
        case 1:
          return hmm->bsc[(signed long int)k2];
        case 2:
        {
          return_value_Prob2Score$3=Prob2Score(hmm->tbd1, (float)1.);
          return return_value_Prob2Score$3;
        }
        default:
        {
          char *return_value_Statetype$4;
          return_value_Statetype$4=Statetype(st1);
          char *return_value_Statetype$5;
          return_value_Statetype$5=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$4, return_value_Statetype$5);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 1:
      switch((signed int)st2)
      {
        case 1:
          return hmm->tsc[(signed long int)0][(signed long int)k1];
        case 3:
          return hmm->tsc[(signed long int)1][(signed long int)k1];
        case 2:
          return hmm->tsc[(signed long int)2][(signed long int)k1];
        case 7:
          return hmm->esc[(signed long int)k1];
        default:
        {
          char *return_value_Statetype$6;
          return_value_Statetype$6=Statetype(st1);
          char *return_value_Statetype$7;
          return_value_Statetype$7=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$6, return_value_Statetype$7);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 3:
      switch((signed int)st2)
      {
        case 1:
          return hmm->tsc[(signed long int)3][(signed long int)k1];
        case 3:
          return hmm->tsc[(signed long int)4][(signed long int)k1];
        default:
        {
          char *return_value_Statetype$8;
          return_value_Statetype$8=Statetype(st1);
          char *return_value_Statetype$9;
          return_value_Statetype$9=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$8, return_value_Statetype$9);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 2:
      switch((signed int)st2)
      {
        case 1:
          return hmm->tsc[(signed long int)5][(signed long int)k1];
        case 2:
          return hmm->tsc[(signed long int)6][(signed long int)k1];
        case 7:
          return 0;
        default:
        {
          char *return_value_Statetype$10;
          return_value_Statetype$10=Statetype(st1);
          char *return_value_Statetype$11;
          return_value_Statetype$11=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$10, return_value_Statetype$11);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 7:
      switch((signed int)st2)
      {
        case 8:
          return hmm->xsc[(signed long int)1][(signed long int)0];
        case 10:
          return hmm->xsc[(signed long int)1][(signed long int)1];
        default:
        {
          char *return_value_Statetype$12;
          return_value_Statetype$12=Statetype(st1);
          char *return_value_Statetype$13;
          return_value_Statetype$13=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$12, return_value_Statetype$13);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 10:
      switch((signed int)st2)
      {
        case 6:
          return hmm->xsc[(signed long int)3][(signed long int)0];
        case 10:
          return hmm->xsc[(signed long int)3][(signed long int)1];
        default:
        {
          char *return_value_Statetype$14;
          return_value_Statetype$14=Statetype(st1);
          char *return_value_Statetype$15;
          return_value_Statetype$15=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$14, return_value_Statetype$15);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 8:
      switch((signed int)st2)
      {
        case 9:
          return hmm->xsc[(signed long int)2][(signed long int)0];
        case 8:
          return hmm->xsc[(signed long int)2][(signed long int)1];
        default:
        {
          char *return_value_Statetype$16;
          return_value_Statetype$16=Statetype(st1);
          char *return_value_Statetype$17;
          return_value_Statetype$17=Statetype(st2);
          Die("illegal %s->%s transition", return_value_Statetype$16, return_value_Statetype$17);
          goto __CPROVER_DUMP_L39;
        }
      }
    case 9:
      return 0;
    default:
    {
      char *return_value_Statetype$18;
      return_value_Statetype$18=Statetype(st1);
      Die("illegal state %s in traceback", return_value_Statetype$18);
    }
  }

__CPROVER_DUMP_L39:
  ;
  return 0;
}

// Translate
// file translate.c line 48
extern char * Translate(char *seq, char **code)
{
  signed int codon;
  char *aaseq;
  char *aaptr;
  signed int i;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(seq == ((char *)NULL))
  {
    squid_errno = 2;
    return (char *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(seq);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc(return_value_strlen$1 + (unsigned long int)1, sizeof(char) /*1ul*/ );
    aaseq = (char *)return_value_calloc$2;
    if(aaseq == ((char *)NULL))
      Die("calloc failed");

    aaptr = aaseq;
    do
    {
      if(!((signed int)*seq == 0))
        tmp_if_expr$3 = (signed int)seq[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (signed int)seq[(signed long int)2] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      codon = 0;
      i = 0;
      for( ; !(i >= 3); i = i + 1)
      {
        codon = codon * 4;
        switch((signed int)seq[(signed long int)i])
        {
          case 65:

          case 97:
            break;
          case 67:

          case 99:
          {
            codon = codon + 1;
            break;
          }
          case 71:

          case 103:
          {
            codon = codon + 2;
            break;
          }
          case 84:

          case 116:
          {
            codon = codon + 3;
            break;
          }
          case 85:

          case 117:
          {
            codon = codon + 3;
            break;
          }
          default:
            codon = 64;
        }
        if(codon == 64)
          break;

      }
      strcpy(aaptr, code[(signed long int)codon]);
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(code[(signed long int)codon]);
      aaptr = aaptr + (signed long int)return_value_strlen$5;
      seq = seq + (signed long int)3;
    }
    while((_Bool)1);
    return aaseq;
  }
}

// UnfitHistogram
// file histogram.c line 102
extern void UnfitHistogram(struct histogram_s *h)
{
  if(!(h->expect == ((float *)NULL)))
    free((void *)h->expect);

  h->expect = (float *)(void *)0;
  h->fit_type = 0;
}

// VoronoiWeights
// file weight.c line 154
extern void VoronoiWeights(char **aseq, signed int nseq, signed int alen, float *wgt)
{
  float **dmx;
  float *halfmin;
  char **psym;
  signed int *nsym;
  signed int symseen[27l];
  char *randseq;
  signed int acol;
  signed int idx;
  signed int symidx;
  signed int i;
  float min;
  float dist;
  float challenge;
  float champion;
  signed int itscale;
  signed int iteration;
  signed int best;
  void *return_value_sre_malloc$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  signed int tmp_if_expr$13;
  double return_value_sre_random$12;
  if(nseq == 1)
    wgt[(signed long int)0] = (float)1.0;

  else
  {
    itscale = 50;
    signed int return_value_simple_diffmx$1;
    return_value_simple_diffmx$1=simple_diffmx(aseq, nseq, &dmx);
    if(return_value_simple_diffmx$1 == 0)
      Die("simple_diffmx() failed");

    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("weight.c", 184, sizeof(float) /*4ul*/  * (unsigned long int)nseq);
    halfmin = (float *)return_value_sre_malloc$2;
    idx = 0;
    for( ; !(idx >= nseq); idx = idx + 1)
    {
      min = (float)1.0;
      i = 0;
      for( ; !(i >= nseq); i = i + 1)
        if(!(i == idx))
        {
          if(dmx[(signed long int)idx][(signed long int)i] < min)
            min = dmx[(signed long int)idx][(signed long int)i];

        }

      halfmin[(signed long int)idx] = (float)((double)min / 2.0);
    }
    Free2DArray((void **)dmx, nseq);
    void *return_value_sre_malloc$3;
    return_value_sre_malloc$3=sre_malloc("weight.c", 198, (unsigned long int)alen * sizeof(char *) /*8ul*/ );
    psym = (char **)return_value_sre_malloc$3;
    void *return_value_sre_malloc$4;
    return_value_sre_malloc$4=sre_malloc("weight.c", 199, (unsigned long int)alen * sizeof(signed int) /*4ul*/ );
    nsym = (signed int *)return_value_sre_malloc$4;
    acol = 0;
    for( ; !(acol >= alen); acol = acol + 1)
    {
      return_value_sre_malloc$5=sre_malloc("weight.c", 201, (unsigned long int)27 * sizeof(char) /*1ul*/ );
      psym[(signed long int)acol] = (char *)return_value_sre_malloc$5;
    }
    acol = 0;
    for( ; !(acol >= alen); acol = acol + 1)
    {
      memset((void *)symseen, 0, sizeof(signed int) /*4ul*/  * (unsigned long int)27);
      idx = 0;
      for( ; !(idx >= nseq); idx = idx + 1)
      {
        if((signed int)aseq[(signed long int)idx][(signed long int)acol] == 32)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)aseq[(signed long int)idx][(signed long int)acol] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)aseq[(signed long int)idx][(signed long int)acol] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = (signed int)aseq[(signed long int)idx][(signed long int)acol] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
          tmp_if_expr$10 = (_Bool)1;

        else
          tmp_if_expr$10 = (signed int)aseq[(signed long int)idx][(signed long int)acol] == 126 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$10)
        {
          const unsigned short int **return_value___ctype_b_loc$6;
          return_value___ctype_b_loc$6=__ctype_b_loc();
          if(!((256 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)aseq[(signed long int)idx][(signed long int)acol]]) == 0))
            symidx = (signed int)aseq[(signed long int)idx][(signed long int)acol] - 65;

          else
            symidx = (signed int)aseq[(signed long int)idx][(signed long int)acol] - 97;
          if(symidx >= 0 && !(symidx >= 26))
            symseen[(signed long int)symidx] = 1;

        }

        else
          symseen[(signed long int)26] = 1;
      }
      nsym[(signed long int)acol] = 0;
      i = 0;
      for( ; !(i >= 26); i = i + 1)
        if(!(symseen[(signed long int)i] == 0))
        {
          psym[(signed long int)acol][(signed long int)nsym[(signed long int)acol]] = (char)(65 + i);
          nsym[(signed long int)acol] = nsym[(signed long int)acol] + 1;
        }

      if(!(symseen[26l] == 0))
      {
        psym[(signed long int)acol][(signed long int)nsym[(signed long int)acol]] = (char)32;
        nsym[(signed long int)acol] = nsym[(signed long int)acol] + 1;
      }

    }
    void *return_value_sre_malloc$11;
    return_value_sre_malloc$11=sre_malloc("weight.c", 268, (unsigned long int)(alen + 1) * sizeof(char) /*1ul*/ );
    randseq = (char *)return_value_sre_malloc$11;
    best = (signed int)42.;
    FSet(wgt, nseq, (float)0.0);
    iteration = 0;
    for( ; !(iteration >= itscale * nseq); iteration = iteration + 1)
    {
      acol = 0;
      for( ; !(acol >= alen); acol = acol + 1)
      {
        if(nsym[(signed long int)acol] == 0)
          tmp_if_expr$13 = 32;

        else
        {
          return_value_sre_random$12=sre_random();
          tmp_if_expr$13 = (signed int)psym[(signed long int)acol][(signed long int)(signed int)(return_value_sre_random$12 * (double)nsym[(signed long int)acol])];
        }
        randseq[(signed long int)acol] = (char)tmp_if_expr$13;
      }
      randseq[(signed long int)acol] = (char)0;
      double return_value_sre_random$14;
      return_value_sre_random$14=sre_random();
      champion = (float)return_value_sre_random$14;
      min = (float)1.0;
      idx = 0;
      for( ; !(idx >= nseq); idx = idx + 1)
      {
        dist=simple_distance(aseq[(signed long int)idx], randseq);
        if(dist < halfmin[(signed long int)idx])
        {
          best = idx;
          break;
        }

        if(dist < min)
        {
          double return_value_sre_random$15;
          return_value_sre_random$15=sre_random();
          champion = (float)return_value_sre_random$15;
          best = idx;
          min = dist;
        }

        else
          if(IEEE_FLOAT_EQUAL(dist, min))
          {
            double return_value_sre_random$16;
            return_value_sre_random$16=sre_random();
            challenge = (float)return_value_sre_random$16;
            if(challenge > champion)
            {
              champion = challenge;
              best = idx;
              min = dist;
            }

          }

      }
      wgt[(signed long int)best] = wgt[(signed long int)best] + (float)1.0;
    }
    idx = 0;
    for( ; !(idx >= nseq); idx = idx + 1)
      wgt[(signed long int)idx] = wgt[(signed long int)idx] / (float)itscale;
    free((void *)randseq);
    free((void *)nsym);
    free((void *)halfmin);
    Free2DArray((void **)psym, alen);
  }
}

// Warn
// file ../squid/sqfuncs.h line 151
extern void Warn(char *format, ...)
{
  void **argp;
  fprintf(stderr, "WARNING: ");
  argp = (void **)&format;
  vfprintf(stderr, format, argp);
  argp = ((void **)NULL);
  fprintf(stderr, "\n");
  fflush(stderr);
}

// WeightedLinefit
// file sre_math.c line 85
extern void WeightedLinefit(float *x, float *y, float *var, signed int N, float *ret_m, float *ret_b)
{
  signed int i;
  double s;
  double sx;
  double sy;
  double sxx;
  double sxy;
  double delta;
  double m;
  double b;
  sxy = 0.;
  sxx = sxy;
  sy = sxx;
  sx = sy;
  s = sx;
  i = 0;
  for( ; !(i >= N); i = i + 1)
  {
    s = s + 1. / (double)var[(signed long int)i];
    sx = sx + (double)(x[(signed long int)i] / var[(signed long int)i]);
    sy = sy + (double)(y[(signed long int)i] / var[(signed long int)i]);
    sxx = sxx + (double)((x[(signed long int)i] * x[(signed long int)i]) / var[(signed long int)i]);
    sxy = sxy + (double)((x[(signed long int)i] * y[(signed long int)i]) / var[(signed long int)i]);
  }
  delta = s * sxx - sx * sx;
  b = (sxx * sy - sx * sxy) / delta;
  m = (s * sxy - sx * sy) / delta;
  *ret_m = (float)m;
  *ret_b = (float)b;
}

// WriteA2M
// file a2m.c line 96
extern void WriteA2M(struct _IO_FILE *fp, struct msa_struct *msa)
{
  signed int idx;
  signed int pos;
  char buf[64l];
  signed int cpl = 60;
  buf[(signed long int)cpl] = (char)0;
  idx = 0;
  _Bool tmp_if_expr$1;
  char *tmp_if_expr$2;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    if(!(msa->sqdesc == ((char **)NULL)))
      tmp_if_expr$1 = msa->sqdesc[(signed long int)idx] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = msa->sqdesc[(signed long int)idx];

    else
      tmp_if_expr$2 = "";
    fprintf(fp, ">%s %s\n", msa->sqname[(signed long int)idx], tmp_if_expr$2);
    pos = 0;
    for( ; !(pos >= msa->alen); pos = pos + cpl)
    {
      strncpy(buf, &msa->aseq[(signed long int)idx][(signed long int)pos], (unsigned long int)cpl);
      fprintf(fp, "%s\n", (const void *)buf);
    }
  }
}

// WriteAscHMM
// file funcs.h line 162
extern void WriteAscHMM(struct _IO_FILE *fp, struct plan7_s *hmm)
{
  signed int k;
  signed int x;
  signed int ts;
  fprintf(fp, "HMMER2.0  [%s]\n", (const void *)"2.3.2");
  fprintf(fp, "NAME  %s\n", hmm->name);
  if(!((512 & hmm->flags) == 0))
    fprintf(fp, "ACC   %s\n", hmm->acc);

  if(!((2 & hmm->flags) == 0))
    fprintf(fp, "DESC  %s\n", hmm->desc);

  fprintf(fp, "LENG  %d\n", hmm->M);
  fprintf(fp, "ALPH  %s\n", Alphabet_type == 3 ? "Amino" : "Nucleic");
  fprintf(fp, "RF    %s\n", (hmm->flags & 1 << 2) != 0 ? "yes" : "no");
  fprintf(fp, "CS    %s\n", (hmm->flags & 1 << 3) != 0 ? "yes" : "no");
  fprintf(fp, "MAP   %s\n", (hmm->flags & 1 << 8) != 0 ? "yes" : "no");
  multiline(fp, "COM   ", hmm->comlog);
  fprintf(fp, "NSEQ  %d\n", hmm->nseq);
  fprintf(fp, "DATE  %s\n", hmm->ctime);
  fprintf(fp, "CKSUM %d\n", hmm->checksum);
  if(!((1024 & hmm->flags) == 0))
    fprintf(fp, "GA    %.1f %.1f\n", hmm->ga1, hmm->ga2);

  if(!((2048 & hmm->flags) == 0))
    fprintf(fp, "TC    %.1f %.1f\n", hmm->tc1, hmm->tc2);

  if(!((4096 & hmm->flags) == 0))
    fprintf(fp, "NC    %.1f %.1f\n", hmm->nc1, hmm->nc2);

  fputs("XT     ", fp);
  k = 0;
  char *return_value_prob2ascii$1;
  for( ; !(k >= 4); k = k + 1)
  {
    x = 0;
    for( ; !(x >= 2); x = x + 1)
    {
      return_value_prob2ascii$1=prob2ascii(hmm->xt[(signed long int)k][(signed long int)x], (float)1.0);
      fprintf(fp, "%6s ", return_value_prob2ascii$1);
    }
  }
  fputs("\n", fp);
  fprintf(fp, "NULT  ");
  char *return_value_prob2ascii$2;
  return_value_prob2ascii$2=prob2ascii(hmm->p1, (float)1.0);
  fprintf(fp, "%6s ", return_value_prob2ascii$2);
  char *return_value_prob2ascii$3;
  return_value_prob2ascii$3=prob2ascii((float)(1.0 - (double)hmm->p1), (float)1.0);
  fprintf(fp, "%6s\n", return_value_prob2ascii$3);
  fputs("NULE  ", fp);
  x = 0;
  char *return_value_prob2ascii$4;
  for( ; !(x >= Alphabet_size); x = x + 1)
  {
    return_value_prob2ascii$4=prob2ascii(hmm->null[(signed long int)x], (float)1 / (float)Alphabet_size);
    fprintf(fp, "%6s ", return_value_prob2ascii$4);
  }
  fputs("\n", fp);
  if(!((128 & hmm->flags) == 0))
    fprintf(fp, "EVD   %10f %10f\n", hmm->mu, hmm->lambda);

  fprintf(fp, "HMM      ");
  x = 0;
  for( ; !(x >= Alphabet_size); x = x + 1)
    fprintf(fp, "  %c    ", Alphabet[(signed long int)x]);
  fprintf(fp, "\n");
  fprintf(fp, "       %6s %6s %6s %6s %6s %6s %6s %6s %6s\n", (const void *)"m->m", (const void *)"m->i", (const void *)"m->d", (const void *)"i->m", (const void *)"i->i", (const void *)"d->m", (const void *)"d->d", (const void *)"b->m", (const void *)"m->e");
  char *return_value_prob2ascii$5;
  return_value_prob2ascii$5=prob2ascii((float)1 - hmm->tbd1, (float)1.0);
  fprintf(fp, "       %6s %6s ", return_value_prob2ascii$5, (const void *)"*");
  char *return_value_prob2ascii$6;
  return_value_prob2ascii$6=prob2ascii(hmm->tbd1, (float)1.0);
  fprintf(fp, "%6s\n", return_value_prob2ascii$6);
  k = 1;
  char *return_value_prob2ascii$7;
  signed int tmp_if_expr$8;
  char *tmp_if_expr$10;
  char *return_value_prob2ascii$9;
  signed int tmp_if_expr$11;
  char *tmp_if_expr$13;
  char *return_value_prob2ascii$12;
  for( ; hmm->M >= k; k = k + 1)
  {
    fprintf(fp, " %5d ", k);
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
    {
      return_value_prob2ascii$7=prob2ascii(hmm->mat[(signed long int)k][(signed long int)x], hmm->null[(signed long int)x]);
      fprintf(fp, "%6s ", return_value_prob2ascii$7);
    }
    if(!((256 & hmm->flags) == 0))
      fprintf(fp, "%5d", hmm->map[(signed long int)k]);

    fputs("\n", fp);
    if(!((4 & hmm->flags) == 0))
      tmp_if_expr$8 = (signed int)hmm->rf[(signed long int)k];

    else
      tmp_if_expr$8 = 45;
    fprintf(fp, " %5c ", tmp_if_expr$8);
    x = 0;
    for( ; !(x >= Alphabet_size); x = x + 1)
    {
      if(!(k >= hmm->M))
      {
        return_value_prob2ascii$9=prob2ascii(hmm->ins[(signed long int)k][(signed long int)x], hmm->null[(signed long int)x]);
        tmp_if_expr$10 = return_value_prob2ascii$9;
      }

      else
        tmp_if_expr$10 = "*";
      fprintf(fp, "%6s ", tmp_if_expr$10);
    }
    fputs("\n", fp);
    if(!((8 & hmm->flags) == 0))
      tmp_if_expr$11 = (signed int)hmm->cs[(signed long int)k];

    else
      tmp_if_expr$11 = 45;
    fprintf(fp, " %5c ", tmp_if_expr$11);
    ts = 0;
    for( ; !(ts >= 7); ts = ts + 1)
    {
      if(!(k >= hmm->M))
      {
        return_value_prob2ascii$12=prob2ascii(hmm->t[(signed long int)k][(signed long int)ts], (float)1.0);
        tmp_if_expr$13 = return_value_prob2ascii$12;
      }

      else
        tmp_if_expr$13 = "*";
      fprintf(fp, "%6s ", tmp_if_expr$13);
    }
    char *return_value_prob2ascii$14;
    return_value_prob2ascii$14=prob2ascii(hmm->begin[(signed long int)k], (float)1.0);
    fprintf(fp, "%6s ", return_value_prob2ascii$14);
    char *return_value_prob2ascii$15;
    return_value_prob2ascii$15=prob2ascii(hmm->end[(signed long int)k], (float)1.0);
    fprintf(fp, "%6s ", return_value_prob2ascii$15);
    fputs("\n", fp);
  }
  fputs("//\n", fp);
}

// WriteBinHMM
// file funcs.h line 163
extern void WriteBinHMM(struct _IO_FILE *fp, struct plan7_s *hmm)
{
  signed int k;
  fwrite((const void *)(char *)&v20magic, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, fp);
  fwrite((const void *)(char *)&hmm->flags, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  write_bin_string(fp, hmm->name);
  if(!((512 & hmm->flags) == 0))
    write_bin_string(fp, hmm->acc);

  if(!((2 & hmm->flags) == 0))
    write_bin_string(fp, hmm->desc);

  fwrite((const void *)(char *)&hmm->M, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  fwrite((const void *)(char *)&Alphabet_type, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  if(!((4 & hmm->flags) == 0))
    fwrite((const void *)(char *)hmm->rf, sizeof(char) /*1ul*/ , (unsigned long int)(hmm->M + 1), fp);

  if(!((8 & hmm->flags) == 0))
    fwrite((const void *)(char *)hmm->cs, sizeof(char) /*1ul*/ , (unsigned long int)(hmm->M + 1), fp);

  if(!((256 & hmm->flags) == 0))
    fwrite((const void *)(char *)hmm->map, sizeof(signed int) /*4ul*/ , (unsigned long int)(hmm->M + 1), fp);

  write_bin_string(fp, hmm->comlog);
  fwrite((const void *)(char *)&hmm->nseq, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  write_bin_string(fp, hmm->ctime);
  fwrite((const void *)(char *)&hmm->checksum, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  if(!((1024 & hmm->flags) == 0))
  {
    fwrite((const void *)(char *)&hmm->ga1, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
    fwrite((const void *)(char *)&hmm->ga2, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
  }

  if(!((2048 & hmm->flags) == 0))
  {
    fwrite((const void *)(char *)&hmm->tc1, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
    fwrite((const void *)(char *)&hmm->tc2, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
  }

  if(!((4096 & hmm->flags) == 0))
  {
    fwrite((const void *)(char *)&hmm->nc1, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
    fwrite((const void *)(char *)&hmm->nc2, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
  }

  k = 0;
  for( ; !(k >= 4); k = k + 1)
    fwrite((const void *)(char *)hmm->xt[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)2, fp);
  fwrite((const void *)(char *)&hmm->p1, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
  fwrite((const void *)(char *)hmm->null, sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, fp);
  if(!((128 & hmm->flags) == 0))
  {
    fwrite((const void *)(char *)&hmm->mu, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
    fwrite((const void *)(char *)&hmm->lambda, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
  }

  fwrite((const void *)(char *)&hmm->tbd1, sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
  fwrite((const void *)(char *)hmm->begin, sizeof(float) /*4ul*/ , (unsigned long int)(hmm->M + 1), fp);
  fwrite((const void *)(char *)hmm->end, sizeof(float) /*4ul*/ , (unsigned long int)(hmm->M + 1), fp);
  k = 1;
  for( ; hmm->M >= k; k = k + 1)
    fwrite((const void *)(char *)hmm->mat[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, fp);
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
    fwrite((const void *)(char *)hmm->ins[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, fp);
  k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
    fwrite((const void *)(char *)hmm->t[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)7, fp);
}

// WriteClustal
// file clustal.c line 145
extern void WriteClustal(struct _IO_FILE *fp, struct msa_struct *msa)
{
  signed int idx;
  signed int len;
  signed int namelen;
  signed int pos;
  char buf[64l];
  signed int cpl = 50;
  namelen = 0;
  idx = 0;
  unsigned long int return_value_strlen$1;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    return_value_strlen$1=strlen(msa->sqname[(signed long int)idx]);
    len = (signed int)return_value_strlen$1;
    if(!(namelen >= len))
      namelen = len;

  }
  fprintf(fp, "CLUSTAL W(1.5) multiple sequence alignment\n");
  pos = 0;
  for( ; !(pos >= msa->alen); pos = pos + cpl)
  {
    fprintf(fp, "\n");
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      strncpy(buf, msa->aseq[(signed long int)idx] + (signed long int)pos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "%*s %s\n", namelen, msa->sqname[(signed long int)idx], (const void *)buf);
    }
  }
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// WriteMSF
// file msa.h line 279
extern void WriteMSF(struct _IO_FILE *fp, struct msa_struct *msa)
{
  signed long int now;
  char date[64l];
  char **gcg_aseq;
  char **gcg_sqname;
  signed int idx;
  char *s;
  signed int len;
  signed int namelen;
  signed int pos;
  char buffer[51l];
  signed int i;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("msf.c", 273, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseq);
  gcg_aseq = (char **)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("msf.c", 274, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseq);
  gcg_sqname = (char **)return_value_sre_malloc$2;
  idx = 0;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    gcg_aseq[(signed long int)idx]=sre_strdup(msa->aseq[(signed long int)idx], msa->alen);
    gcg_sqname[(signed long int)idx]=sre_strdup(msa->sqname[(signed long int)idx], -1);
  }
  idx = 0;
  const unsigned short int **return_value___ctype_b_loc$3;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    s = gcg_sqname[(signed long int)idx];
    for( ; !((signed int)*s == 0); s = s + 1l)
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*s]) == 0)
      {
        if(!((signed int)*s == 45))
        {
          if(!((signed int)*s == 95))
            *s = (char)95;

        }

      }

    }
  }
  idx = 0;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    s = gcg_aseq[(signed long int)idx];
    do
    {
      if(!((signed int)*s == 0))
      {
        if((signed int)*s == 32)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)*s == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)*s == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*s == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)*s == 126 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      if(!tmp_if_expr$8)
        break;

      *s = (char)126;
      s = s + 1l;
    }
    while((_Bool)1);
    for( ; !((signed int)*s == 0); s = s + 1l)
    {
      if((signed int)*s == 32)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = (signed int)*s == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = (signed int)*s == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$10)
        tmp_if_expr$11 = (_Bool)1;

      else
        tmp_if_expr$11 = (signed int)*s == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$11)
        tmp_if_expr$12 = (_Bool)1;

      else
        tmp_if_expr$12 = (signed int)*s == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$12)
        *s = (char)46;

    }
    pos = msa->alen - 1;
    do
    {
      if(pos >= 1)
      {
        if((signed int)gcg_aseq[(signed long int)idx][(signed long int)pos] == 32)
          tmp_if_expr$13 = (_Bool)1;

        else
          tmp_if_expr$13 = (signed int)gcg_aseq[(signed long int)idx][(signed long int)pos] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$13)
          tmp_if_expr$14 = (_Bool)1;

        else
          tmp_if_expr$14 = (signed int)gcg_aseq[(signed long int)idx][(signed long int)pos] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$14)
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = (signed int)gcg_aseq[(signed long int)idx][(signed long int)pos] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
          tmp_if_expr$16 = (_Bool)1;

        else
          tmp_if_expr$16 = (signed int)gcg_aseq[(signed long int)idx][(signed long int)pos] == 126 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$17 = tmp_if_expr$16 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$17 = (_Bool)0;
      if(!tmp_if_expr$17)
        break;

      gcg_aseq[(signed long int)idx][(signed long int)pos] = (char)126;
      pos = pos - 1;
    }
    while((_Bool)1);
  }
  namelen = 0;
  idx = 0;
  unsigned long int return_value_strlen$18;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    return_value_strlen$18=strlen(msa->sqname[(signed long int)idx]);
    len = (signed int)return_value_strlen$18;
    if(!(namelen >= len))
      namelen = len;

  }
  if(msa->type == 0)
    msa->type=GuessAlignmentSeqtype(msa->aseq, msa->nseq);

  if(msa->type == 2)
    fprintf(fp, "!!NA_MULTIPLE_ALIGNMENT 1.0\n");

  else
    if(msa->type == 1)
      fprintf(fp, "!!NA_MULTIPLE_ALIGNMENT 1.0\n");

    else
      if(msa->type == 3)
        fprintf(fp, "!!AA_MULTIPLE_ALIGNMENT 1.0\n");

      else
        if(msa->type == 0)
          Die("WriteMSF(): couldn't guess whether that alignment is RNA or protein.\n");

        else
          Die("Invalid sequence type %d in WriteMSF()\n", msa->type);
  if(msa->ncomment >= 1)
  {
    idx = 0;
    for( ; !(idx >= msa->ncomment); idx = idx + 1)
      fprintf(fp, "%s\n", msa->comment[(signed long int)idx]);
    fprintf(fp, "\n");
  }

  now=time((signed long int *)(void *)0);
  struct tm *return_value_localtime$19;
  return_value_localtime$19=localtime(&now);
  unsigned long int return_value_strftime$20;
  return_value_strftime$20=strftime(date, (unsigned long int)64, "%B %d, %Y %H:%M", return_value_localtime$19);
  if(return_value_strftime$20 == 0ul)
    Die("What time is it on earth? strftime() failed in WriteMSF().\n");

  char *tmp_if_expr$21;
  if(!(msa->name == ((char *)NULL)))
    tmp_if_expr$21 = msa->name;

  else
    tmp_if_expr$21 = "squid.msf";
  signed int return_value_GCGMultchecksum$22;
  return_value_GCGMultchecksum$22=GCGMultchecksum(gcg_aseq, msa->nseq);
  fprintf(fp, " %s  MSF: %d  Type: %c  %s  Check: %d  ..\n", tmp_if_expr$21, msa->alen, msa->type == 2 ? 78 : 80, (const void *)date, return_value_GCGMultchecksum$22);
  fprintf(fp, "\n");
  idx = 0;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    signed int return_value_GCGchecksum$23;
    return_value_GCGchecksum$23=GCGchecksum(gcg_aseq[(signed long int)idx], msa->alen);
    fprintf(fp, " Name: %-*.*s  Len:  %5d  Check: %4d  Weight: %.2f\n", namelen, namelen, gcg_sqname[(signed long int)idx], msa->alen, return_value_GCGchecksum$23, msa->wgt[(signed long int)idx]);
  }
  fprintf(fp, "\n");
  fprintf(fp, "//\n");
  pos = 0;
  signed int tmp_if_expr$24;
  for( ; !(pos >= msa->alen); pos = pos + 50)
  {
    fprintf(fp, "\n");
    if(!(msa->alen >= 50 + pos))
      tmp_if_expr$24 = msa->alen - pos;

    else
      tmp_if_expr$24 = 50;
    len = tmp_if_expr$24;
    if(len >= 11)
      fprintf(fp, "%*s  %-6d%*s%6d\n", namelen, (const void *)"", pos + 1, (len + (len - 1) / 10) - 12, (const void *)"", pos + len);

    else
      fprintf(fp, "%*s  %-6d\n", namelen, (const void *)"", pos + 1);
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      fprintf(fp, "%-*s ", namelen, gcg_sqname[(signed long int)idx]);
      strncpy(buffer, gcg_aseq[(signed long int)idx] + (signed long int)pos, (unsigned long int)50);
      buffer[(signed long int)50] = (char)0;
      i = 0;
      for( ; !(i >= len); i = i + 1)
      {
        if(i % 10 == 0)
          fputc(32, fp);

        fputc((signed int)buffer[(signed long int)i], fp);
      }
      fputc(10, fp);
    }
  }
  Free2DArray((void **)gcg_aseq, msa->nseq);
  Free2DArray((void **)gcg_sqname, msa->nseq);
  goto __CPROVER_DUMP_L72;

__CPROVER_DUMP_L72:
  ;
}

// WritePairwiseAlignment
// file alignio.c line 333
extern signed int WritePairwiseAlignment(struct _IO_FILE *ofp, char *aseq1, char *name1, signed int spos1, char *aseq2, char *name2, signed int spos2, signed int **pam, signed int indent)
{
  char sname1[11l];
  char sname2[11l];
  signed int still_going;
  char buf1[61l];
  char bufmid[61l];
  char buf2[61l];
  char *s1;
  char *s2;
  signed int count1;
  signed int count2;
  signed int rpos1;
  signed int rpos2;
  signed int rawcount1;
  signed int rawcount2;
  signed int apos;
  strncpy(sname1, name1, (unsigned long int)10);
  sname1[(signed long int)10] = (char)0;
  strtok(sname1, " \t\n");
  strncpy(sname2, name2, (unsigned long int)10);
  sname2[(signed long int)10] = (char)0;
  strtok(sname2, " \t\n");
  s1 = aseq1;
  s2 = aseq2;
  rpos1 = spos1;
  rpos2 = spos2;
  still_going = 1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$22;
  while(!(still_going == 0))
  {
    still_going = 0;
    strncpy(buf1, s1, (unsigned long int)60);
    buf1[(signed long int)60] = (char)0;
    strncpy(buf2, s2, (unsigned long int)60);
    buf2[(signed long int)60] = (char)0;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(buf1);
    count1 = (signed int)return_value_strlen$1;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf2);
    count2 = (signed int)return_value_strlen$2;
    if(count1 == 60)
      tmp_if_expr$3 = (signed int)s1[(signed long int)60] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if(count2 == 60)
        tmp_if_expr$4 = (signed int)s2[(signed long int)60] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      still_going = 1;

    s1 = s1 + (signed long int)count1;
    s2 = s2 + (signed long int)count2;
    apos = 0;
    for( ; !(apos >= count1) && !(apos >= count2); apos = apos + 1)
    {
      if((signed int)buf1[(signed long int)apos] == 32)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)buf1[(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)buf1[(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)buf1[(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = (signed int)buf1[(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$9)
      {
        if((signed int)buf2[(signed long int)apos] == 32)
          tmp_if_expr$10 = (_Bool)1;

        else
          tmp_if_expr$10 = (signed int)buf2[(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$10)
          tmp_if_expr$11 = (_Bool)1;

        else
          tmp_if_expr$11 = (signed int)buf2[(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$11)
          tmp_if_expr$12 = (_Bool)1;

        else
          tmp_if_expr$12 = (signed int)buf2[(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$12)
          tmp_if_expr$13 = (_Bool)1;

        else
          tmp_if_expr$13 = (signed int)buf2[(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$14 = !tmp_if_expr$13 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$14 = (_Bool)0;
      if(tmp_if_expr$14)
      {
        if(buf1[(signed long int)apos] == buf2[(signed long int)apos])
          bufmid[(signed long int)apos] = buf1[(signed long int)apos];

        else
          if(pam[(signed long int)((signed int)buf1[(signed long int)apos] + -65)][(signed long int)((signed int)buf2[(signed long int)apos] + -65)] >= 1)
            bufmid[(signed long int)apos] = (char)43;

          else
            bufmid[(signed long int)apos] = (char)32;
      }

      else
        bufmid[(signed long int)apos] = (char)32;
    }
    bufmid[(signed long int)apos] = (char)0;
    rawcount1 = 0;
    apos = 0;
    for( ; !(apos >= count1); apos = apos + 1)
    {
      if((signed int)buf1[(signed long int)apos] == 32)
        tmp_if_expr$15 = (_Bool)1;

      else
        tmp_if_expr$15 = (signed int)buf1[(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$15)
        tmp_if_expr$16 = (_Bool)1;

      else
        tmp_if_expr$16 = (signed int)buf1[(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$16)
        tmp_if_expr$17 = (_Bool)1;

      else
        tmp_if_expr$17 = (signed int)buf1[(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$17)
        tmp_if_expr$18 = (_Bool)1;

      else
        tmp_if_expr$18 = (signed int)buf1[(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$18)
        rawcount1 = rawcount1 + 1;

    }
    rawcount2 = 0;
    apos = 0;
    for( ; !(apos >= count2); apos = apos + 1)
    {
      if((signed int)buf2[(signed long int)apos] == 32)
        tmp_if_expr$19 = (_Bool)1;

      else
        tmp_if_expr$19 = (signed int)buf2[(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$19)
        tmp_if_expr$20 = (_Bool)1;

      else
        tmp_if_expr$20 = (signed int)buf2[(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$20)
        tmp_if_expr$21 = (_Bool)1;

      else
        tmp_if_expr$21 = (signed int)buf2[(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$21)
        tmp_if_expr$22 = (_Bool)1;

      else
        tmp_if_expr$22 = (signed int)buf2[(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$22)
        rawcount2 = rawcount2 + 1;

    }
    fprintf(ofp, "%*s%-10.10s %5d %s %5d\n", indent, (const void *)"", (const void *)sname1, rpos1, (const void *)buf1, (rpos1 + rawcount1) - 1);
    fprintf(ofp, "%*s                 %s\n", indent, (const void *)"", (const void *)bufmid);
    fprintf(ofp, "%*s%-10.10s %5d %s %5d\n", indent, (const void *)"", (const void *)sname2, rpos2, (const void *)buf2, (rpos2 + rawcount2) - 1);
    fprintf(ofp, "\n");
    rpos1 = rpos1 + rawcount1;
    rpos2 = rpos2 + rawcount2;
  }
  return 1;
}

// WritePhylip
// file msa.h line 284
extern void WritePhylip(struct _IO_FILE *fp, struct msa_struct *msa)
{
  signed int idx;
  signed int cpl = 50;
  char buf[51l];
  signed int pos;
  fprintf(fp, " %d  %d\n", msa->nseq, msa->alen);
  pos = 0;
  for( ; !(pos >= msa->alen); pos = pos + cpl)
  {
    if(pos >= 1)
      fprintf(fp, "\n");

    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
    {
      strncpy(buf, msa->aseq[(signed long int)idx] + (signed long int)pos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      if(pos >= 1)
        fprintf(fp, "%s\n", (const void *)buf);

      else
        fprintf(fp, "%-10.10s%s\n", msa->sqname[(signed long int)idx], (const void *)buf);
    }
  }
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// WriteProfile
// file emulation.c line 91
extern void WriteProfile(struct _IO_FILE *fp, struct plan7_s *hmm, signed int do_xsw)
{
  signed int k;
  signed int x;
  signed int sc;
  float nx;
  signed int gap;
  signed int len;
  signed int qgap;
  signed int qlen;
  P7Logoddsify(hmm, 1);
  if(hmm->M >= 1001)
  {
    if(do_xsw == 0)
      Warn("Profile %s will have more than 1000 positions. GCG won't read it; Compugen will.", hmm->name);

  }

  if(Alphabet_type == 3)
    fprintf(fp, "!!AA_PROFILE 1.0\n");

  else
    if(Alphabet_type == 2)
      fprintf(fp, "!!NA_PROFILE 1.0\n");

    else
      Die("No support for profiles with non-biological alphabets");
  if(Alphabet_type == 3)
    fprintf(fp, "(Peptide) ");

  else
    if(Alphabet_type == 2)
      fprintf(fp, "(Nucleotide) ");

  char *tmp_if_expr$1;
  if(!((512 & hmm->flags) == 0))
    tmp_if_expr$1 = hmm->acc;

  else
    tmp_if_expr$1 = "";
  char *tmp_if_expr$2;
  if(!((2 & hmm->flags) == 0))
    tmp_if_expr$2 = hmm->desc;

  else
    tmp_if_expr$2 = "";
  fprintf(fp, "HMMCONVERT v%s Length: %d %s|%s|%s\n", (const void *)"2.3.2", hmm->M, hmm->name, tmp_if_expr$1, tmp_if_expr$2);
  if(!(do_xsw == 0))
  {
    fprintf(fp, "   Profile converted from a profile HMM using HMMER v%s emulation.\n", (const void *)"2.3.2");
    fprintf(fp, "   Compugen XSW extended profile format.\n");
    fprintf(fp, "   Use -model=xsw.model -nonor -noave -gapop=10 -gapext=1 -qgapop=10 -qgapext=1\n");
    fprintf(fp, "      with om on the Compugen BIC to get the closest approximation to HMMER bit scores.\n");
    fprintf(fp, "   WARNING: There is a loss of information in this conversion.\n");
    fprintf(fp, "      Neither the scores nor even the rank order of hits will be precisely\n");
    fprintf(fp, "      preserved in a comparison of HMMER hmmsearch to GCG profilesearch.\n");
    fprintf(fp, "      The profile score is an approximation of the (single-hit) HMMER score.\n\n");
  }

  else
  {
    fprintf(fp, "   Profile converted from a profile HMM using HMMER v%s emulation.\n", (const void *)"2.3.2");
    fprintf(fp, "   Use -nonor -noave -gap=10 -len=1 with profilesearch and friends\n");
    fprintf(fp, "      to get the closest approximation to HMMER bit scores.\n");
    fprintf(fp, "   WARNING: There is a loss of information in this conversion.\n");
    fprintf(fp, "      Neither the scores nor even the rank order of hits will be precisely\n");
    fprintf(fp, "      preserved in a comparison of HMMER hmmsearch to GCG profilesearch.\n");
    fprintf(fp, "      The profile score is an approximation of the (single-hit) HMMER score.\n\n");
  }
  fprintf(fp, "Cons");
  x = 0;
  for( ; !(x >= Alphabet_iupac); x = x + 1)
    fprintf(fp, "    %c ", Alphabet[(signed long int)x]);
  if(!(do_xsw == 0))
    fprintf(fp, "  Gap   Len  QGap  Qlen ..\n");

  else
    fprintf(fp, "  Gap   Len ..\n");
  k = 1;
  for( ; hmm->M >= k; k = k + 1)
  {
    if((k + -1) % 10 == 0 && k >= 11)
      fprintf(fp, "! %d\n", k);

    x=FArgMax(hmm->mat[(signed long int)k], Alphabet_size);
    fprintf(fp, " %c  ", Alphabet[(signed long int)x]);
    x = 0;
    for( ; !(x >= Alphabet_iupac); x = x + 1)
    {
      sc = hmm->msc[(signed long int)x][(signed long int)k];
      if(!(k >= hmm->M))
        sc = sc + hmm->tsc[(signed long int)0][(signed long int)k];

      sc = (signed int)((double)(sc * 100) / 1000.0);
      fprintf(fp, "%5d ", sc);
    }
    if(k >= 2)
    {
      gap = -1 * (((hmm->tsc[(signed long int)1][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)]) - hmm->tsc[(signed long int)0][(signed long int)(k - 1)]) - hmm->tsc[(signed long int)4][(signed long int)(k - 1)]);
      gap = (signed int)((double)(gap * 100) / (10.0 * 1000.0));
    }

    else
      gap = 100;
    if(k >= 2)
    {
      len = -1 * hmm->tsc[(signed long int)4][(signed long int)(k - 1)];
      len = (signed int)((double)(len * 100) / (1.0 * 1000.0));
    }

    else
      len = 100;
    if(k >= 2)
    {
      qgap = -1 * (((hmm->tsc[(signed long int)5][(signed long int)(k - 1)] + hmm->tsc[(signed long int)2][(signed long int)(k - 1)]) - hmm->tsc[(signed long int)0][(signed long int)(k - 1)]) - hmm->tsc[(signed long int)6][(signed long int)(k - 1)]);
      qgap = (signed int)((double)(qgap * 100) / (10.0 * 1000.0));
    }

    else
      qgap = 100;
    if(k >= 2)
    {
      qlen = -1 * hmm->tsc[(signed long int)6][(signed long int)(k - 1)];
      qlen = (signed int)((double)(qlen * 100) / (1.0 * 1000.0));
    }

    else
      qlen = 100;
    if(!(do_xsw == 0))
      fprintf(fp, "%5d %5d %5d %5d\n", gap, len, qgap, qlen);

    else
      fprintf(fp, "%5d %5d\n", gap, len);
  }
  fprintf(fp, " *  ");
  x = 0;
  for( ; !(x >= Alphabet_size); x = x + 1)
  {
    nx = (float)0.0;
    k = 1;
    for( ; hmm->M >= k; k = k + 1)
      nx = nx + hmm->mat[(signed long int)k][(signed long int)x];
    nx = nx * (float)hmm->nseq;
    fprintf(fp, "%5d ", (signed int)nx);
  }
  for( ; !(x >= Alphabet_iupac); x = x + 1)
    fprintf(fp, "%5d ", 0);
  fprintf(fp, "\n");
  goto __CPROVER_DUMP_L38;

__CPROVER_DUMP_L38:
  ;
}

// WriteSELEX
// file msa.h line 289
extern void WriteSELEX(struct _IO_FILE *fp, struct msa_struct *msa)
{
  actually_write_selex(fp, msa, 50);
}

// WriteSELEXOneBlock
// file selex.c line 547
extern void WriteSELEXOneBlock(struct _IO_FILE *fp, struct msa_struct *msa)
{
  actually_write_selex(fp, msa, msa->alen);
}

// WriteSeq
// file sqio.c line 1507
extern signed int WriteSeq(struct _IO_FILE *outf, signed int outform, char *seq, struct seqinfo_s *sqinfo)
{
  signed int numline = 0;
  signed int lines = 0;
  signed int spacer = 0;
  signed int width = 50;
  signed int tab = 0;
  signed int i;
  signed int j;
  signed int l;
  signed int l1;
  signed int ibase;
  char endstr[10l];
  char s[100l];
  char ss[100l];
  signed int checksum = 0;
  signed int seqlen;
  signed int which_case;
  signed int dostruc;
  which_case = 0;
  dostruc = 0;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!((64 & sqinfo->flags) == 0))
    tmp_if_expr$2 = (unsigned long int)sqinfo->len;

  else
  {
    return_value_strlen$1=strlen(seq);
    tmp_if_expr$2 = return_value_strlen$1;
  }
  seqlen = (signed int)tmp_if_expr$2;
  if(outform >= 101)
    Die("Tried to write an aligned format with WriteSeq() -- bad, bad.");

  strcpy(endstr, "");
  l1 = 0;
  checksum=GCGchecksum(seq, seqlen);
  char *tmp_if_expr$3;
  char *tmp_if_expr$4;
  char *tmp_if_expr$5;
  char *tmp_if_expr$6;
  char *tmp_if_expr$7;
  char *tmp_if_expr$8;
  char *tmp_if_expr$9;
  char *tmp_if_expr$10;
  char *tmp_if_expr$11;
  signed int tmp_if_expr$12;
  signed int tmp_if_expr$13;
  signed int tmp_if_expr$14;
  char *tmp_if_expr$15;
  char *tmp_if_expr$16;
  char *tmp_if_expr$17;
  char *tmp_if_expr$18;
  char *tmp_if_expr$19;
  switch(outform)
  {
    case 0:
    {
      strcpy(endstr, "\n");
      break;
    }
    case 2:
    {
      fprintf(outf, "LOCUS       %s       %d bp\n", (const void *)sqinfo->name, seqlen);
      if(!((4 & sqinfo->flags) == 0))
        tmp_if_expr$3 = sqinfo->acc;

      else
        tmp_if_expr$3 = ".";
      fprintf(outf, "ACCESSION   %s\n", tmp_if_expr$3);
      if(!((8 & sqinfo->flags) == 0))
        tmp_if_expr$4 = sqinfo->desc;

      else
        tmp_if_expr$4 = ".";
      fprintf(outf, "DEFINITION  %s\n", tmp_if_expr$4);
      if(!((2 & sqinfo->flags) == 0))
        tmp_if_expr$5 = sqinfo->id;

      else
        tmp_if_expr$5 = ".";
      fprintf(outf, "VERSION     %s\n", tmp_if_expr$5);
      fprintf(outf, "ORIGIN      \n");
      spacer = 11;
      numline = 1;
      strcpy(endstr, "\n//");
      break;
    }
    case 16:
    {
      fprintf(outf, ">>>>%s  9/95  ASCII  Len: %d\n", (const void *)sqinfo->name, seqlen);
      if(!((8 & sqinfo->flags) == 0))
        tmp_if_expr$6 = sqinfo->desc;

      else
        tmp_if_expr$6 = "-";
      fprintf(outf, "%s\n", tmp_if_expr$6);
      break;
    }
    case 12:
    {
      if(!((2 & sqinfo->flags) == 0))
        tmp_if_expr$7 = sqinfo->id;

      else
        tmp_if_expr$7 = sqinfo->name;
      fprintf(outf, "ENTRY          %s\n", tmp_if_expr$7);
      if(!((8 & sqinfo->flags) == 0))
        tmp_if_expr$8 = sqinfo->desc;

      else
        tmp_if_expr$8 = "-";
      fprintf(outf, "TITLE          %s\n", tmp_if_expr$8);
      if(!((4 & sqinfo->flags) == 0))
        tmp_if_expr$9 = sqinfo->acc;

      else
        tmp_if_expr$9 = "-";
      fprintf(outf, "ACCESSION      %s\n", tmp_if_expr$9);
      fprintf(outf, "SUMMARY                                #Length %d  #Checksum  %d\n", sqinfo->len, checksum);
      fprintf(outf, "SEQUENCE\n");
      fprintf(outf, "                  5        10        15        20        25        30\n");
      spacer = 2;
      numline = 1;
      width = 30;
      strcpy(endstr, "\n///");
      break;
    }
    case 14:
    {
      fprintf(outf, "NAM  %s\n", (const void *)sqinfo->name);
      if(!((310 & sqinfo->flags) == 0))
      {
        if(!((2 & sqinfo->flags) == 0))
          tmp_if_expr$10 = sqinfo->id;

        else
          tmp_if_expr$10 = "-";
        if(!((4 & sqinfo->flags) == 0))
          tmp_if_expr$11 = sqinfo->acc;

        else
          tmp_if_expr$11 = "-";
        if(!((16 & sqinfo->flags) == 0))
          tmp_if_expr$12 = sqinfo->start;

        else
          tmp_if_expr$12 = 0;
        if(!((32 & sqinfo->flags) == 0))
          tmp_if_expr$13 = sqinfo->stop;

        else
          tmp_if_expr$13 = 0;
        if(!((256 & sqinfo->flags) == 0))
          tmp_if_expr$14 = sqinfo->olen;

        else
          tmp_if_expr$14 = 0;
        fprintf(outf, "SRC  %s %s %d..%d::%d\n", tmp_if_expr$10, tmp_if_expr$11, tmp_if_expr$12, tmp_if_expr$13, tmp_if_expr$14);
      }

      if(!((8 & sqinfo->flags) == 0))
        fprintf(outf, "DES  %s\n", (const void *)sqinfo->desc);

      if(!((512 & sqinfo->flags) == 0))
      {
        fprintf(outf, "SEQ  +SS\n");
        dostruc = 1;
      }

      else
        fprintf(outf, "SEQ\n");
      numline = 1;
      strcpy(endstr, "\n++");
      break;
    }
    case 4:
    {
      if(!((2 & sqinfo->flags) == 0))
        tmp_if_expr$15 = sqinfo->id;

      else
        tmp_if_expr$15 = sqinfo->name;
      fprintf(outf, "ID   %s\n", tmp_if_expr$15);
      if(!((4 & sqinfo->flags) == 0))
        tmp_if_expr$16 = sqinfo->acc;

      else
        tmp_if_expr$16 = "-";
      fprintf(outf, "AC   %s\n", tmp_if_expr$16);
      if(!((8 & sqinfo->flags) == 0))
        tmp_if_expr$17 = sqinfo->desc;

      else
        tmp_if_expr$17 = "-";
      fprintf(outf, "DE   %s\n", tmp_if_expr$17);
      fprintf(outf, "SQ             %d BP\n", seqlen);
      strcpy(endstr, "\n//");
      tab = 5;
      spacer = 11;
      break;
    }
    case 5:
    {
      fprintf(outf, "%s\n", (const void *)sqinfo->name);
      if(!((4 & sqinfo->flags) == 0))
        fprintf(outf, "ACCESSION   %s\n", (const void *)sqinfo->acc);

      if(!((8 & sqinfo->flags) == 0))
        fprintf(outf, "DEFINITION  %s\n", (const void *)sqinfo->desc);

      fprintf(outf, "    %s  Length: %d  (today)  Check: %d  ..\n", (const void *)sqinfo->name, seqlen, checksum);
      spacer = 11;
      numline = 1;
      strcpy(endstr, "\n");
      break;
    }
    case 6:
    {
      fprintf(outf, "; ### from DNA Strider ;-)\n");
      fprintf(outf, "; DNA sequence  %s, %d bases, %d checksum.\n;\n", (const void *)sqinfo->name, seqlen, checksum);
      strcpy(endstr, "\n//");
      break;
    }
    case 8:
      which_case = 1;
    case 1:
    {
      if(!((8 & sqinfo->flags) == 0))
        tmp_if_expr$18 = sqinfo->desc;

      else
        tmp_if_expr$18 = "";
      fprintf(outf, ";%s %s\n", (const void *)sqinfo->name, tmp_if_expr$18);
      fprintf(outf, "%s\n", (const void *)sqinfo->name);
      strcpy(endstr, "1");
      break;
    }
    case 13:
      break;
    case 7:

    default:
    {
      if(!((8 & sqinfo->flags) == 0))
        tmp_if_expr$19 = sqinfo->desc;

      else
        tmp_if_expr$19 = "";
      fprintf(outf, ">%s %s\n", (const void *)sqinfo->name, tmp_if_expr$19);
    }
  }
  if(which_case == 1)
    s2upper(seq);

  if(which_case == 2)
    s2lower(seq);

  width = width < 100 ? width : 100;
  i = 0;
  l = 0;
  ibase = 1;
  lines = 0;
  signed int tmp_if_expr$20;
  while(!(i >= seqlen))
  {
    if(!(l1 >= 0))
      l1 = 0;

    else
      if(l1 == 0)
      {
        if(!(numline == 0))
          fprintf(outf, "%8d ", ibase);

        j = 0;
        for( ; !(j >= tab); j = j + 1)
          fputc(32, outf);
      }

    if((1 + l) % spacer == 1 && !(spacer == 0))
    {
      s[(signed long int)l] = (char)32;
      ss[(signed long int)l] = (char)32;
      l = l + 1;
    }

    s[(signed long int)l] = seq[(signed long int)i];
    if(!((512 & sqinfo->flags) == 0))
      tmp_if_expr$20 = (signed int)sqinfo->ss[(signed long int)i];

    else
      tmp_if_expr$20 = 46;
    ss[(signed long int)l] = (char)tmp_if_expr$20;
    l = l + 1;
    i = i + 1;
    l1 = l1 + 1;
    if(i == seqlen || l1 == width)
    {
      ss[(signed long int)l] = (char)0;
      s[(signed long int)l] = ss[(signed long int)l];
      l = 0;
      l1 = 0;
      if(!(dostruc == 0))
      {
        fprintf(outf, "%s\n", (const void *)s);
        if(!(numline == 0))
          fprintf(outf, "         ");

        j = 0;
        for( ; !(j >= tab); j = j + 1)
          fputc(32, outf);
        if(i == seqlen)
          fprintf(outf, "%s%s\n", (const void *)ss, (const void *)endstr);

        else
          fprintf(outf, "%s\n", (const void *)ss);
      }

      else
        if(i == seqlen)
          fprintf(outf, "%s%s\n", (const void *)s, (const void *)endstr);

        else
          fprintf(outf, "%s\n", (const void *)s);
      lines = lines + 1;
      ibase = i + 1;
    }

  }
  return lines;
}

// WriteSimpleFASTA
// file sqio.c line 1490
extern void WriteSimpleFASTA(struct _IO_FILE *fp, char *seq, char *name, char *desc)
{
  char buf[61l];
  signed int len;
  signed int pos;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(seq);
  len = (signed int)return_value_strlen$1;
  buf[(signed long int)60] = (char)0;
  fprintf(fp, ">%s %s\n", name, desc != (char *)(void *)0 ? desc : "");
  pos = 0;
  for( ; !(pos >= len); pos = pos + 60)
  {
    strncpy(buf, seq + (signed long int)pos, (unsigned long int)60);
    fprintf(fp, "%s\n", (const void *)buf);
  }
}

// WriteStockholm
// file msa.h line 295
extern void WriteStockholm(struct _IO_FILE *fp, struct msa_struct *msa)
{
  actually_write_stockholm(fp, msa, 50);
}

// WriteStockholmOneBlock
// file msa.h line 296
extern void WriteStockholmOneBlock(struct _IO_FILE *fp, struct msa_struct *msa)
{
  actually_write_stockholm(fp, msa, msa->alen);
}

// XNU
// file masks.c line 84
extern signed int XNU(unsigned char *dsq, signed int len)
{
  signed int i;
  signed int k;
  signed int off;
  signed int sum;
  signed int beg;
  signed int end;
  signed int top;
  signed int topcut;
  signed int fallcut;
  double s0;
  signed int noff = 4;
  signed int mcut = 1;
  double pcut = 0.01;
  signed int *hit;
  double lambda = 0.346574;
  double K = 0.2;
  double H = 0.664;
  signed int xnum = 0;
  double return_value_log$3;
  double return_value_floor$4;
  if(len == 0)
    return 0;

  else
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("masks.c", 100, sizeof(signed int) /*4ul*/  * (unsigned long int)(len + 1));
    hit = (signed int *)return_value_sre_malloc$1;
    i = 1;
    for( ; len >= i; i = i + 1)
      hit[(signed long int)i] = 0;
    double return_value_log$2;
    return_value_log$2=log((pcut * H) / ((double)noff * K));
    s0 = -return_value_log$2 / lambda;
    if(s0 > 0.000000)
    {
      return_value_log$3=log(s0);
      return_value_floor$4=floor(s0 + return_value_log$3 / lambda + 0.5);
      topcut = (signed int)return_value_floor$4;
    }

    else
      topcut = 0;
    double return_value_log$5;
    return_value_log$5=log(K / 0.001);
    fallcut = (signed int)((double)(signed int)return_value_log$5 / lambda);
    off = mcut;
    for( ; noff >= off; off = off + 1)
    {
      top = 0;
      sum = top;
      beg = off;
      end = 0;
      i = off + 1;
      for( ; len >= i; i = i + 1)
      {
        sum = sum + xpam120[(signed long int)dsq[(signed long int)i]][(signed long int)dsq[(signed long int)(i - off)]];
        if(!(top >= sum))
        {
          top = sum;
          end = i;
        }

        if(top >= topcut && !(fallcut >= top + -sum))
        {
          k = beg;
          for( ; end >= k; k = k + 1)
          {
            hit[(signed long int)(k - off)] = 1;
            hit[(signed long int)k] = hit[(signed long int)(k - off)];
          }
          top = 0;
          sum = top;
          end = i + 1;
          beg = end;
        }

        else
          if(!(fallcut >= top + -sum))
          {
            top = 0;
            sum = top;
            end = i + 1;
            beg = end;
          }

        if(!(sum >= 0))
        {
          end = i + 1;
          beg = end;
          top = 0;
          sum = top;
        }

      }
      if(top >= topcut)
      {
        k = beg;
        for( ; end >= k; k = k + 1)
        {
          hit[(signed long int)(k - off)] = 1;
          hit[(signed long int)k] = hit[(signed long int)(k - off)];
        }
      }

    }
    i = 1;
    for( ; len >= i; i = i + 1)
      if(!(hit[(signed long int)i] == 0))
      {
        xnum = xnum + 1;
        dsq[(signed long int)i] = (unsigned char)(Alphabet_iupac - 1);
      }

    free((void *)hit);
    return xnum;
  }
}

// ZeroPlan7
// file funcs.h line 216
extern void ZeroPlan7(struct plan7_s *hmm)
{
  signed int k = 1;
  for( ; !(k >= hmm->M); k = k + 1)
  {
    FSet(hmm->t[(signed long int)k], 7, (float)0.);
    FSet(hmm->mat[(signed long int)k], Alphabet_size, (float)0.);
    FSet(hmm->ins[(signed long int)k], Alphabet_size, (float)0.);
  }
  FSet(hmm->mat[(signed long int)hmm->M], Alphabet_size, (float)0.);
  hmm->tbd1 = (float)0.;
  FSet(hmm->begin + (signed long int)1, hmm->M, (float)0.);
  FSet(hmm->end + (signed long int)1, hmm->M, (float)0.);
  k = 0;
  for( ; !(k >= 4); k = k + 1)
    FSet(hmm->xt[(signed long int)k], 2, (float)0.);
  hmm->flags = hmm->flags & ~(1 << 0);
  hmm->flags = hmm->flags & ~(1 << 5);
}

// activate_external_sort
// file ssi.c line 1378
static signed int activate_external_sort(struct ssiindex_s *g)
{
  signed int i;
  if(!(g->external == 0))
    return 0;

  else
  {
    signed int return_value_FileExists$1;
    return_value_FileExists$1=FileExists(g->ptmpfile);
    if(!(return_value_FileExists$1 == 0))
      return 1;

    else
    {
      signed int return_value_FileExists$2;
      return_value_FileExists$2=FileExists(g->stmpfile);
      if(!(return_value_FileExists$2 == 0))
        return 1;

      else
      {
        g->ptmp=fopen(g->ptmpfile, "w");
        if(g->ptmp == ((struct _IO_FILE *)NULL))
          return 1;

        else
        {
          g->stmp=fopen(g->stmpfile, "w");
          if(g->stmp == ((struct _IO_FILE *)NULL))
            return 1;

          else
          {
            i = 0;
            for( ; !((unsigned int)i >= g->nprimary); i = i + 1)
              if(g->smode == 0)
                fprintf(g->ptmp, "%s\t%u\t%lu\t%lu\t%lu\n", (g->pkeys + (signed long int)i)->key, (g->pkeys + (signed long int)i)->fnum, (unsigned long int)(g->pkeys + (signed long int)i)->r_off.off.i32, (unsigned long int)(g->pkeys + (signed long int)i)->d_off.off.i32, (unsigned long int)(g->pkeys + (signed long int)i)->len);

              else
                fprintf(g->ptmp, "%s\t%u\t%llu\t%llu\t%lu\n", (g->pkeys + (signed long int)i)->key, (g->pkeys + (signed long int)i)->fnum, (unsigned long long int)(g->pkeys + (signed long int)i)->r_off.off.i64, (unsigned long long int)(g->pkeys + (signed long int)i)->d_off.off.i64, (unsigned long int)(g->pkeys + (signed long int)i)->len);
            i = 0;
            for( ; !((unsigned int)i >= g->nsecondary); i = i + 1)
              fprintf(g->stmp, "%s\t%s\n", (g->skeys + (signed long int)i)->key, (g->skeys + (signed long int)i)->pkey);
            i = 0;
            for( ; !((unsigned int)i >= g->nprimary); i = i + 1)
              free((void *)(g->pkeys + (signed long int)i)->key);
            i = 0;
            for( ; !((unsigned int)i >= g->nsecondary); i = i + 1)
              free((void *)(g->skeys + (signed long int)i)->key);
            i = 0;
            for( ; !((unsigned int)i >= g->nsecondary); i = i + 1)
              free((void *)(g->skeys + (signed long int)i)->pkey);
            if(!(g->pkeys == ((struct ssipkey_s *)NULL)))
              free((void *)g->pkeys);

            if(!(g->skeys == ((struct ssiskey_s *)NULL)))
              free((void *)g->skeys);

            g->pkeys = (struct ssipkey_s *)(void *)0;
            g->skeys = (struct ssiskey_s *)(void *)0;
            g->external = 1;
            return 0;
          }
        }
      }
    }
  }
}

// actually_write_selex
// file selex.c line 568
static void actually_write_selex(struct _IO_FILE *fp, struct msa_struct *msa, signed int cpl)
{
  signed int i;
  signed int len = 0;
  signed int namewidth;
  char *buf;
  signed int currpos;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(cpl + 101));
  buf = (char *)return_value_malloc$1;
  namewidth = 0;
  i = 0;
  unsigned long int return_value_strlen$2;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    return_value_strlen$2=strlen(msa->sqname[(signed long int)i]);
    len = (signed int)return_value_strlen$2;
    if(!(namewidth >= len))
      namewidth = len;

  }
  if(!(namewidth >= 6))
    namewidth = 6;

  i = 0;
  for( ; !(i >= msa->ncomment); i = i + 1)
    fprintf(fp, "# %s\n", msa->comment[(signed long int)i]);
  if(msa->ncomment >= 1)
    fprintf(fp, "\n");

  if(!(msa->name == ((char *)NULL)))
    fprintf(fp, "#=ID %s\n", msa->name);

  if(!(msa->acc == ((char *)NULL)))
    fprintf(fp, "#=AC %s\n", msa->acc);

  if(!(msa->desc == ((char *)NULL)))
    fprintf(fp, "#=DE %s\n", msa->desc);

  if(!(msa->au == ((char *)NULL)))
    fprintf(fp, "#=AU %s\n", msa->au);

  _Bool tmp_if_expr$3;
  if(!(msa->cutoff_is_set[2l] == 0))
    tmp_if_expr$3 = msa->cutoff_is_set[(signed long int)3] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
    fprintf(fp, "#=GA %.1f %.1f\n", msa->cutoff[(signed long int)2], msa->cutoff[(signed long int)3]);

  else
    if(!(msa->cutoff_is_set[2l] == 0))
      fprintf(fp, "#=GA %.1f\n", msa->cutoff[(signed long int)2]);

  _Bool tmp_if_expr$4;
  if(!(msa->cutoff_is_set[4l] == 0))
    tmp_if_expr$4 = msa->cutoff_is_set[(signed long int)5] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  if(tmp_if_expr$4)
    fprintf(fp, "#=NC %.1f %.1f\n", msa->cutoff[(signed long int)4], msa->cutoff[(signed long int)5]);

  else
    if(!(msa->cutoff_is_set[4l] == 0))
      fprintf(fp, "#=NC %.1f\n", msa->cutoff[(signed long int)4]);

  _Bool tmp_if_expr$5;
  if(!(msa->cutoff_is_set[0l] == 0))
    tmp_if_expr$5 = msa->cutoff_is_set[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$5 = (_Bool)0;
  if(tmp_if_expr$5)
    fprintf(fp, "#=TC %.1f %.1f\n", msa->cutoff[(signed long int)0], msa->cutoff[(signed long int)1]);

  else
    if(!(msa->cutoff_is_set[0l] == 0))
      fprintf(fp, "#=TC %.1f\n", msa->cutoff[(signed long int)0]);

  i = 0;
  _Bool tmp_if_expr$6;
  char *tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  char *tmp_if_expr$9;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    if(!(msa->sqacc == ((char **)NULL)))
      tmp_if_expr$6 = msa->sqacc[(signed long int)i] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = msa->sqacc[(signed long int)i];

    else
      tmp_if_expr$7 = "-";
    if(!(msa->sqdesc == ((char **)NULL)))
      tmp_if_expr$8 = msa->sqdesc[(signed long int)i] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
      tmp_if_expr$9 = msa->sqdesc[(signed long int)i];

    else
      tmp_if_expr$9 = "-";
    fprintf(fp, "#=SQ %-*.*s %6.4f %s %s %d..%d::%d %s\n", namewidth, namewidth, msa->sqname[(signed long int)i], msa->wgt[(signed long int)i], (const void *)"-", tmp_if_expr$7, 0, 0, 0, tmp_if_expr$9);
  }
  fprintf(fp, "\n");
  currpos = 0;
  for( ; !(currpos >= msa->alen); currpos = currpos + cpl)
  {
    if(currpos >= 1)
      fprintf(fp, "\n");

    if(!(msa->ss_cons == ((char *)NULL)))
    {
      strncpy(buf, msa->ss_cons + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, (const void *)"#=CS", buf);
    }

    if(!(msa->rf == ((char *)NULL)))
    {
      strncpy(buf, msa->rf + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, (const void *)"#=RF", buf);
    }

    i = 0;
    for( ; !(i >= msa->nseq); i = i + 1)
    {
      strncpy(buf, msa->aseq[(signed long int)i] + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, msa->sqname[(signed long int)i], buf);
      if(!(msa->ss == ((char **)NULL)))
      {
        if(!(msa->ss[(signed long int)i] == ((char *)NULL)))
        {
          strncpy(buf, msa->ss[(signed long int)i] + (signed long int)currpos, (unsigned long int)cpl);
          buf[(signed long int)cpl] = (char)0;
          fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, (const void *)"#=SS", buf);
        }

      }

      if(!(msa->sa == ((char **)NULL)))
      {
        if(!(msa->sa[(signed long int)i] == ((char *)NULL)))
        {
          strncpy(buf, msa->sa[(signed long int)i] + (signed long int)currpos, (unsigned long int)cpl);
          buf[(signed long int)cpl] = (char)0;
          fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, (const void *)"#=SA", buf);
        }

      }

    }
  }
  free((void *)buf);
}

// actually_write_stockholm
// file stockholm.c line 216
static void actually_write_stockholm(struct _IO_FILE *fp, struct msa_struct *msa, signed int cpl)
{
  signed int i;
  signed int j;
  signed int len = 0;
  signed int namewidth;
  signed int typewidth = 0;
  signed int markupwidth = 0;
  char *buf;
  signed int currpos;
  char *s;
  char *tok;
  namewidth = 0;
  i = 0;
  unsigned long int return_value_strlen$1;
  for( ; !(i >= msa->nseq); i = i + 1)
  {
    return_value_strlen$1=strlen(msa->sqname[(signed long int)i]);
    len = (signed int)return_value_strlen$1;
    if(!(namewidth >= len))
      namewidth = len;

  }
  if(!(msa->ss == ((char **)NULL)))
  {
    markupwidth = 4;
    typewidth = 2;
  }

  if(!(msa->sa == ((char **)NULL)))
  {
    markupwidth = 4;
    typewidth = 2;
  }

  i = 0;
  unsigned long int return_value_strlen$2;
  for( ; !(i >= msa->ngr); i = i + 1)
  {
    return_value_strlen$2=strlen(msa->gr_tag[(signed long int)i]);
    len = (signed int)return_value_strlen$2;
    if(!(typewidth >= len))
      typewidth = len;

  }
  if(!(msa->rf == ((char *)NULL)))
  {
    markupwidth = 4;
    if(!(typewidth >= 2))
      typewidth = 2;

  }

  if(!(msa->ss_cons == ((char *)NULL)))
  {
    markupwidth = 4;
    if(!(typewidth >= 7))
      typewidth = 7;

  }

  if(!(msa->sa_cons == ((char *)NULL)))
  {
    markupwidth = 4;
    if(!(typewidth >= 7))
      typewidth = 7;

  }

  i = 0;
  unsigned long int return_value_strlen$3;
  for( ; !(i >= msa->ngc); i = i + 1)
  {
    return_value_strlen$3=strlen(msa->gc_tag[(signed long int)i]);
    len = (signed int)return_value_strlen$3;
    if(!(typewidth >= len))
      typewidth = len;

  }
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("stockholm.c", 251, sizeof(char) /*1ul*/  * (unsigned long int)(cpl + namewidth + typewidth + markupwidth + 61));
  buf = (char *)return_value_sre_malloc$4;
  fprintf(fp, "# STOCKHOLM 1.0\n");
  i = 0;
  for( ; !(i >= msa->ncomment); i = i + 1)
    fprintf(fp, "# %s\n", msa->comment[(signed long int)i]);
  if(msa->ncomment >= 1)
    fprintf(fp, "\n");

  if(!(msa->name == ((char *)NULL)))
    fprintf(fp, "#=GF ID    %s\n", msa->name);

  if(!(msa->acc == ((char *)NULL)))
    fprintf(fp, "#=GF AC    %s\n", msa->acc);

  if(!(msa->desc == ((char *)NULL)))
    fprintf(fp, "#=GF DE    %s\n", msa->desc);

  if(!(msa->au == ((char *)NULL)))
    fprintf(fp, "#=GF AU    %s\n", msa->au);

  _Bool tmp_if_expr$5;
  if(!(msa->cutoff_is_set[2l] == 0))
    tmp_if_expr$5 = msa->cutoff_is_set[(signed long int)3] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$5 = (_Bool)0;
  if(tmp_if_expr$5)
    fprintf(fp, "#=GF GA    %.1f %.1f\n", msa->cutoff[(signed long int)2], msa->cutoff[(signed long int)3]);

  else
    if(!(msa->cutoff_is_set[2l] == 0))
      fprintf(fp, "#=GF GA    %.1f\n", msa->cutoff[(signed long int)2]);

  _Bool tmp_if_expr$6;
  if(!(msa->cutoff_is_set[4l] == 0))
    tmp_if_expr$6 = msa->cutoff_is_set[(signed long int)5] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$6 = (_Bool)0;
  if(tmp_if_expr$6)
    fprintf(fp, "#=GF NC    %.1f %.1f\n", msa->cutoff[(signed long int)4], msa->cutoff[(signed long int)5]);

  else
    if(!(msa->cutoff_is_set[4l] == 0))
      fprintf(fp, "#=GF NC    %.1f\n", msa->cutoff[(signed long int)4]);

  _Bool tmp_if_expr$7;
  if(!(msa->cutoff_is_set[0l] == 0))
    tmp_if_expr$7 = msa->cutoff_is_set[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$7 = (_Bool)0;
  if(tmp_if_expr$7)
    fprintf(fp, "#=GF TC    %.1f %.1f\n", msa->cutoff[(signed long int)0], msa->cutoff[(signed long int)1]);

  else
    if(!(msa->cutoff_is_set[0l] == 0))
      fprintf(fp, "#=GF TC    %.1f\n", msa->cutoff[(signed long int)0]);

  i = 0;
  for( ; !(i >= msa->ngf); i = i + 1)
    fprintf(fp, "#=GF %-5s %s\n", msa->gf_tag[(signed long int)i], msa->gf[(signed long int)i]);
  fprintf(fp, "\n");
  if(!((1 & msa->flags) == 0))
  {
    i = 0;
    for( ; !(i >= msa->nseq); i = i + 1)
      fprintf(fp, "#=GS %-*.*s WT    %.2f\n", namewidth, namewidth, msa->sqname[(signed long int)i], msa->wgt[(signed long int)i]);
    fprintf(fp, "\n");
  }

  if(!(msa->sqacc == ((char **)NULL)))
  {
    i = 0;
    for( ; !(i >= msa->nseq); i = i + 1)
      if(!(msa->sqacc[(signed long int)i] == ((char *)NULL)))
        fprintf(fp, "#=GS %-*.*s AC    %s\n", namewidth, namewidth, msa->sqname[(signed long int)i], msa->sqacc[(signed long int)i]);

    fprintf(fp, "\n");
  }

  if(!(msa->sqdesc == ((char **)NULL)))
  {
    i = 0;
    for( ; !(i >= msa->nseq); i = i + 1)
      if(!(msa->sqdesc[(signed long int)i] == ((char *)NULL)))
        fprintf(fp, "#=GS %*.*s DE    %s\n", namewidth, namewidth, msa->sqname[(signed long int)i], msa->sqdesc[(signed long int)i]);

    fprintf(fp, "\n");
  }

  i = 0;
  for( ; !(i >= msa->ngs); i = i + 1)
  {
    j = 0;
    for( ; !(j >= msa->nseq); j = j + 1)
      if(!(msa->gs[(signed long int)i][(signed long int)j] == ((char *)NULL)))
      {
        s = msa->gs[(signed long int)i][(signed long int)j];
        do
        {
          tok=sre_strtok(&s, "\n", (signed int *)(void *)0);
          if(tok == ((char *)NULL))
            break;

          fprintf(fp, "#=GS %*.*s %5s %s\n", namewidth, namewidth, msa->sqname[(signed long int)j], msa->gs_tag[(signed long int)i], tok);
        }
        while((_Bool)1);
      }

    fprintf(fp, "\n");
  }
  currpos = 0;
  for( ; !(currpos >= msa->alen); currpos = currpos + cpl)
  {
    if(currpos >= 1)
      fprintf(fp, "\n");

    i = 0;
    for( ; !(i >= msa->nseq); i = i + 1)
    {
      strncpy(buf, msa->aseq[(signed long int)i] + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "%-*.*s  %s\n", namewidth + typewidth + markupwidth, namewidth + typewidth + markupwidth, msa->sqname[(signed long int)i], buf);
      if(!(msa->ss == ((char **)NULL)))
      {
        if(!(msa->ss[(signed long int)i] == ((char *)NULL)))
        {
          strncpy(buf, msa->ss[(signed long int)i] + (signed long int)currpos, (unsigned long int)cpl);
          buf[(signed long int)cpl] = (char)0;
          fprintf(fp, "#=GR %-*.*s SS     %s\n", namewidth, namewidth, msa->sqname[(signed long int)i], buf);
        }

      }

      if(!(msa->sa == ((char **)NULL)))
      {
        if(!(msa->sa[(signed long int)i] == ((char *)NULL)))
        {
          strncpy(buf, msa->sa[(signed long int)i] + (signed long int)currpos, (unsigned long int)cpl);
          buf[(signed long int)cpl] = (char)0;
          fprintf(fp, "#=GR %-*.*s SA     %s\n", namewidth, namewidth, msa->sqname[(signed long int)i], buf);
        }

      }

      j = 0;
      for( ; !(j >= msa->ngr); j = j + 1)
        if(!(msa->gr[(signed long int)j][(signed long int)i] == ((char *)NULL)))
        {
          strncpy(buf, msa->gr[(signed long int)j][(signed long int)i] + (signed long int)currpos, (unsigned long int)cpl);
          buf[(signed long int)cpl] = (char)0;
          fprintf(fp, "#=GR %-*.*s %5s  %s\n", namewidth, namewidth, msa->sqname[(signed long int)i], msa->gr_tag[(signed long int)j], buf);
        }

    }
    if(!(msa->ss_cons == ((char *)NULL)))
    {
      strncpy(buf, msa->ss_cons + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth, (const void *)"SS_cons", buf);
    }

    if(!(msa->sa_cons == ((char *)NULL)))
    {
      strncpy(buf, msa->sa_cons + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth, (const void *)"SA_cons", buf);
    }

    if(!(msa->rf == ((char *)NULL)))
    {
      strncpy(buf, msa->rf + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth, (const void *)"RF", buf);
    }

    j = 0;
    for( ; !(j >= msa->ngc); j = j + 1)
    {
      strncpy(buf, msa->gc[(signed long int)j] + (signed long int)currpos, (unsigned long int)cpl);
      buf[(signed long int)cpl] = (char)0;
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth, msa->gc_tag[(signed long int)j], buf);
    }
  }
  fprintf(fp, "//\n");
  free((void *)buf);
}

// addseq
// file sqio.c line 508
static void addseq(char *s, struct ReadSeqVars *V)
{
  char *s0;
  char *sq;
  signed int rpl;
  signed int bpl;
  signed int tmp_if_expr$1;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(V->ssimode == -1)
  {
    if(!(V->maxseq >= V->buflen + V->seqlen))
    {
      if(V->buflen >= 501)
        tmp_if_expr$1 = V->buflen;

      else
        tmp_if_expr$1 = 500;
      V->maxseq = V->maxseq + tmp_if_expr$1;
      void *return_value_sre_realloc$2;
      return_value_sre_realloc$2=sre_realloc("sqio.c", 523, (void *)V->seq, (unsigned long int)(V->maxseq + 1));
      V->seq = (char *)return_value_sre_realloc$2;
    }

    sq = V->seq + (signed long int)V->seqlen;
    while(!((signed int)*s == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$4;
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s]) == 0)
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*s]) == 0)
        {
          *sq = *s;
          sq = sq + 1l;
        }

      }

      s = s + 1l;
    }
    V->seqlen = (signed int)(sq - V->seq);
  }

  else
  {
    s0 = s;
    rpl = 0;
    while(!((signed int)*s == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$6;
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*s]) == 0)
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*s]) == 0)
          rpl = rpl + 1;

      }

      s = s + 1l;
    }
    V->seqlen = V->seqlen + rpl;
    bpl = (signed int)(s - s0);
    if(!(V->rpl == 0))
    {
      if(V->lastrpl >= 1)
      {
        if(V->rpl >= 1)
          tmp_if_expr$7 = V->lastrpl != V->rpl ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
          V->rpl = 0;

        else
          if(V->rpl == -1)
            V->rpl = V->lastrpl;

      }

      V->lastrpl = rpl;
      if(!(V->maxrpl >= rpl))
        V->maxrpl = rpl;

    }

    if(!(V->bpl == 0))
    {
      if(V->lastbpl >= 1)
      {
        if(V->bpl >= 1)
          tmp_if_expr$8 = V->lastbpl != V->bpl ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          V->bpl = 0;

        else
          if(V->bpl == -1)
            V->bpl = V->lastbpl;

      }

      V->lastbpl = bpl;
      if(!(V->maxbpl >= bpl))
        V->maxbpl = bpl;

    }

  }
}

// annotate_model
// file modelmakers.c line 839
static void annotate_model(struct plan7_s *hmm, signed int *matassign, struct msa_struct *msa)
{
  signed int apos;
  signed int k;
  char *pri;
  signed int tmp_post$1;
  signed int tmp_if_expr$2;
  if(!(msa->rf == ((char *)NULL)))
  {
    hmm->rf[(signed long int)0] = (char)32;
    k = 1;
    apos = k;
    for( ; msa->alen >= apos; apos = apos + 1)
      if(!((1 & matassign[(signed long int)apos]) == 0))
      {
        tmp_post$1 = k;
        k = k + 1;
        if((signed int)msa->rf[(signed long int)(apos + -1)] == 32)
          tmp_if_expr$2 = 46;

        else
          tmp_if_expr$2 = (signed int)msa->rf[(signed long int)(apos - 1)];
        hmm->rf[(signed long int)tmp_post$1] = (char)tmp_if_expr$2;
      }

    hmm->rf[(signed long int)k] = (char)0;
    hmm->flags = hmm->flags | 1 << 2;
  }

  signed int tmp_post$3;
  signed int tmp_if_expr$4;
  if(!(msa->ss_cons == ((char *)NULL)))
  {
    hmm->cs[(signed long int)0] = (char)32;
    k = 1;
    apos = k;
    for( ; msa->alen >= apos; apos = apos + 1)
      if(!((1 & matassign[(signed long int)apos]) == 0))
      {
        tmp_post$3 = k;
        k = k + 1;
        if((signed int)msa->ss_cons[(signed long int)(apos + -1)] == 32)
          tmp_if_expr$4 = 46;

        else
          tmp_if_expr$4 = (signed int)msa->ss_cons[(signed long int)(apos - 1)];
        hmm->cs[(signed long int)tmp_post$3] = (char)tmp_if_expr$4;
      }

    hmm->cs[(signed long int)k] = (char)0;
    hmm->flags = hmm->flags | 1 << 3;
  }

  signed int tmp_post$5;
  signed int tmp_if_expr$6;
  if(!(msa->sa_cons == ((char *)NULL)))
  {
    hmm->ca[(signed long int)0] = (char)32;
    k = 1;
    apos = k;
    for( ; msa->alen >= apos; apos = apos + 1)
      if(!((1 & matassign[(signed long int)apos]) == 0))
      {
        tmp_post$5 = k;
        k = k + 1;
        if((signed int)msa->sa_cons[(signed long int)(apos + -1)] == 32)
          tmp_if_expr$6 = 46;

        else
          tmp_if_expr$6 = (signed int)msa->sa_cons[(signed long int)(apos - 1)];
        hmm->ca[(signed long int)tmp_post$5] = (char)tmp_if_expr$6;
      }

    hmm->ca[(signed long int)k] = (char)0;
    hmm->flags = hmm->flags | 1 << 13;
  }

  k = 1;
  apos = k;
  signed int tmp_post$7;
  for( ; msa->alen >= apos; apos = apos + 1)
    if(!((1 & matassign[(signed long int)apos]) == 0))
    {
      tmp_post$7 = k;
      k = k + 1;
      hmm->map[(signed long int)tmp_post$7] = apos;
    }

  hmm->flags = hmm->flags | 1 << 8;
  pri=MSAGetGC(msa, "X-PRM");
  const unsigned short int **return_value___ctype_b_loc$10;
  const unsigned short int **return_value___ctype_b_loc$9;
  if(!(pri == ((char *)NULL)))
  {
    void *return_value_sre_malloc$8;
    return_value_sre_malloc$8=sre_malloc("modelmakers.c", 896, sizeof(signed int) /*4ul*/  * (unsigned long int)(hmm->M + 1));
    hmm->mpri = (signed int *)return_value_sre_malloc$8;
    k = 1;
    apos = k;
    for( ; msa->alen >= apos; apos = apos + 1)
      if(!((1 & matassign[(signed long int)apos]) == 0))
      {
        const unsigned short int **return_value___ctype_b_loc$11;
        return_value___ctype_b_loc$11=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
          hmm->mpri[(signed long int)k] = (signed int)pri[(signed long int)(apos - 1)] - 48;

        else
        {
          return_value___ctype_b_loc$10=__ctype_b_loc();
          if(!((512 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
            hmm->mpri[(signed long int)k] = ((signed int)pri[(signed long int)(apos - 1)] - 97) + 10;

          else
          {
            return_value___ctype_b_loc$9=__ctype_b_loc();
            if(!((256 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
              hmm->mpri[(signed long int)k] = ((signed int)pri[(signed long int)(apos - 1)] - 65) + 10;

            else
              hmm->mpri[(signed long int)k] = -1;
          }
        }
        k = k + 1;
      }

  }

  pri=MSAGetGC(msa, "X-PRI");
  const unsigned short int **return_value___ctype_b_loc$14;
  const unsigned short int **return_value___ctype_b_loc$13;
  if(!(pri == ((char *)NULL)))
  {
    void *return_value_sre_malloc$12;
    return_value_sre_malloc$12=sre_malloc("modelmakers.c", 911, sizeof(signed int) /*4ul*/  * (unsigned long int)(hmm->M + 1));
    hmm->ipri = (signed int *)return_value_sre_malloc$12;
    k = 1;
    apos = k;
    for( ; msa->alen >= apos; apos = apos + 1)
      if(!((1 & matassign[(signed long int)apos]) == 0))
      {
        const unsigned short int **return_value___ctype_b_loc$15;
        return_value___ctype_b_loc$15=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$15)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
          hmm->ipri[(signed long int)k] = (signed int)pri[(signed long int)(apos - 1)] - 48;

        else
        {
          return_value___ctype_b_loc$14=__ctype_b_loc();
          if(!((512 & (signed int)(*return_value___ctype_b_loc$14)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
            hmm->ipri[(signed long int)k] = ((signed int)pri[(signed long int)(apos - 1)] - 97) + 10;

          else
          {
            return_value___ctype_b_loc$13=__ctype_b_loc();
            if(!((256 & (signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
              hmm->ipri[(signed long int)k] = ((signed int)pri[(signed long int)(apos - 1)] - 65) + 10;

            else
              hmm->ipri[(signed long int)k] = -1;
          }
        }
        k = k + 1;
      }

  }

  pri=MSAGetGC(msa, "X-PRT");
  const unsigned short int **return_value___ctype_b_loc$18;
  const unsigned short int **return_value___ctype_b_loc$17;
  if(!(pri == ((char *)NULL)))
  {
    void *return_value_sre_malloc$16;
    return_value_sre_malloc$16=sre_malloc("modelmakers.c", 926, sizeof(signed int) /*4ul*/  * (unsigned long int)(hmm->M + 1));
    hmm->tpri = (signed int *)return_value_sre_malloc$16;
    k = 1;
    apos = k;
    for( ; msa->alen >= apos; apos = apos + 1)
      if(!((1 & matassign[(signed long int)apos]) == 0))
      {
        const unsigned short int **return_value___ctype_b_loc$19;
        return_value___ctype_b_loc$19=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$19)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
          hmm->tpri[(signed long int)k] = (signed int)pri[(signed long int)(apos - 1)] - 48;

        else
        {
          return_value___ctype_b_loc$18=__ctype_b_loc();
          if(!((512 & (signed int)(*return_value___ctype_b_loc$18)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
            hmm->tpri[(signed long int)k] = ((signed int)pri[(signed long int)(apos - 1)] - 97) + 10;

          else
          {
            return_value___ctype_b_loc$17=__ctype_b_loc();
            if(!((256 & (signed int)(*return_value___ctype_b_loc$17)[(signed long int)(signed int)pri[(signed long int)(apos + -1)]]) == 0))
              hmm->tpri[(signed long int)k] = ((signed int)pri[(signed long int)(apos - 1)] - 65) + 10;

            else
              hmm->tpri[(signed long int)k] = -1;
          }
        }
        k = k + 1;
      }

  }

}

// ascii2prob
// file hmmio.c line 1285
static float ascii2prob(char *s, float null)
{
  double tmp_if_expr$3;
  signed int return_value_atoi$1;
  float return_value_Score2Prob$2;
  if((signed int)*s == 42)
    tmp_if_expr$3 = 0.;

  else
  {
    return_value_atoi$1=atoi(s);
    return_value_Score2Prob$2=Score2Prob(return_value_atoi$1, null);
    tmp_if_expr$3 = (double)return_value_Score2Prob$2;
  }
  return (float)tmp_if_expr$3;
}

// binary_search
// file ssi.c line 1277
static signed int binary_search(struct ssifile_s *sfp, char *key, signed int klen, struct ssioffset_s *base, unsigned int recsize, unsigned int maxidx)
{
  char *name;
  unsigned int left;
  unsigned int right;
  unsigned int mid;
  signed int cmp;
  signed int status;
  if(maxidx == 0u)
    return 2;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)klen);
    name = (char *)return_value_malloc$1;
    if(name == ((char *)NULL))
      return 3;

    else
    {
      left = (unsigned int)0;
      right = maxidx - (unsigned int)1;
      while((_Bool)1)
      {
        mid = (left + right) / (unsigned int)2;
        status=indexfile_position(sfp, base, recsize, mid);
        if(!(status == 0))
        {
          free((void *)name);
          return status;
        }

        unsigned long int return_value_fread$2;
        return_value_fread$2=fread((void *)name, sizeof(char) /*1ul*/ , (unsigned long int)klen, sfp->fp);
        if(!(return_value_fread$2 == (unsigned long int)klen))
        {
          free((void *)name);
          return 1;
        }

        cmp=strcmp(name, key);
        if(cmp == 0)
          break;

        else
          if(left >= right)
          {
            free((void *)name);
            return 2;
          }

          else
            if(!(cmp >= 0))
              left = mid + (unsigned int)1;

            else
              if(cmp >= 1)
              {
                if(mid == 0u)
                {
                  free((void *)name);
                  return 2;
                }

                else
                  right = mid - (unsigned int)1;
              }

      }
      free((void *)name);
      return 0;
    }
  }
}

// build_cij
// file modelmakers.c line 437
static signed int build_cij(char **aseqs, signed int nseq, signed int *insopt, signed int i, signed int j, float *wgt, float *cij)
{
  signed int idx;
  i = i - 1;
  j = j - 1;
  FSet(cij, 8, (float)0.);
  idx = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    if(insopt[(signed long int)idx] >= 1)
    {
      if((signed int)aseqs[(signed long int)idx][(signed long int)i] == 32)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        return -1;

      if((signed int)aseqs[(signed long int)idx][(signed long int)j] == 32)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 126 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        return 0;

      cij[(signed long int)1] = cij[(signed long int)1] + wgt[(signed long int)idx];
      cij[(signed long int)4] = cij[(signed long int)4] + (float)(insopt[(signed long int)idx] - 1) * wgt[(signed long int)idx];
      cij[(signed long int)3] = cij[(signed long int)3] + wgt[(signed long int)idx];
    }

    else
    {
      if((signed int)aseqs[(signed long int)idx][(signed long int)i] == 32)
        tmp_if_expr$17 = (_Bool)1;

      else
        tmp_if_expr$17 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$17)
        tmp_if_expr$18 = (_Bool)1;

      else
        tmp_if_expr$18 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$18)
        tmp_if_expr$19 = (_Bool)1;

      else
        tmp_if_expr$19 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$19)
        tmp_if_expr$20 = (_Bool)1;

      else
        tmp_if_expr$20 = (signed int)aseqs[(signed long int)idx][(signed long int)i] == 126 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$20)
      {
        if(!((signed int)aseqs[(signed long int)idx][(signed long int)j] == 95))
        {
          if((signed int)aseqs[(signed long int)idx][(signed long int)j] == 32)
            tmp_if_expr$9 = (_Bool)1;

          else
            tmp_if_expr$9 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$9)
            tmp_if_expr$10 = (_Bool)1;

          else
            tmp_if_expr$10 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$10)
            tmp_if_expr$11 = (_Bool)1;

          else
            tmp_if_expr$11 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$11)
            tmp_if_expr$12 = (_Bool)1;

          else
            tmp_if_expr$12 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 126 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$12)
            cij[(signed long int)2] = cij[(signed long int)2] + wgt[(signed long int)idx];

          else
            cij[(signed long int)0] = cij[(signed long int)0] + wgt[(signed long int)idx];
        }

      }

      else
        if((signed int)aseqs[(signed long int)idx][(signed long int)j] == 95)
          goto __CPROVER_DUMP_L51;

        else
        {
          if((signed int)aseqs[(signed long int)idx][(signed long int)j] == 32)
            tmp_if_expr$13 = (_Bool)1;

          else
            tmp_if_expr$13 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$13)
            tmp_if_expr$14 = (_Bool)1;

          else
            tmp_if_expr$14 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$14)
            tmp_if_expr$15 = (_Bool)1;

          else
            tmp_if_expr$15 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$15)
            tmp_if_expr$16 = (_Bool)1;

          else
            tmp_if_expr$16 = (signed int)aseqs[(signed long int)idx][(signed long int)j] == 126 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$16)
            cij[(signed long int)6] = cij[(signed long int)6] + wgt[(signed long int)idx];

          else
            cij[(signed long int)5] = cij[(signed long int)5] + wgt[(signed long int)idx];
        }
    }

  __CPROVER_DUMP_L51:
    ;
  }
  return 1;
}

// byteswap
// file hmmio.c line 1312
static void byteswap(char *swap, signed int nbytes)
{
  signed int x;
  char byte;
  x = 0;
  for( ; !(x >= nbytes / 2); x = x + 1)
  {
    byte = swap[(signed long int)((nbytes - x) - 1)];
    swap[(signed long int)((nbytes - x) - 1)] = swap[(signed long int)x];
    swap[(signed long int)x] = byte;
  }
}

// clear_ssifile
// file ssi.c line 446
static void clear_ssifile(struct ssifile_s *sfp)
{
  signed int i;
  if(!(sfp->filename == ((char **)NULL)))
  {
    i = 0;
    for( ; !(i >= (signed int)sfp->nfiles); i = i + 1)
      if(!(sfp->filename[(signed long int)i] == ((char *)NULL)))
        free((void *)sfp->filename[(signed long int)i]);

    free((void *)sfp->filename);
  }

  if(!(sfp->fileformat == ((unsigned int *)NULL)))
    free((void *)sfp->fileformat);

  if(!(sfp->fileflags == ((unsigned int *)NULL)))
    free((void *)sfp->fileflags);

  if(!(sfp->bpl == ((unsigned int *)NULL)))
    free((void *)sfp->bpl);

  if(!(sfp->rpl == ((unsigned int *)NULL)))
    free((void *)sfp->rpl);

}

// coded_revcomp
// file seqencode.c line 98
extern signed int coded_revcomp(char *comp, char *seq)
{
  signed long int bases;
  char *bckp;
  char *fwdp;
  signed int idx;
  signed long int pos;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(seq);
  bases = (signed long int)return_value_strlen$1;
  fwdp = comp;
  bckp = (seq + bases) - (signed long int)1;
  pos = (signed long int)0;
  for( ; !(pos >= bases); pos = pos + 1l)
  {
    idx = 0;
    for( ; !(*bckp == iupac[(signed long int)idx].code) && !(idx >= 17); idx = idx + 1)
      ;
    if(idx >= 18)
    {
      *fwdp = (char)0;
      return 0;
    }

    else
      *fwdp = iupac[(signed long int)idx].comp;
    fwdp = fwdp + 1l;
    bckp = bckp - 1l;
  }
  *fwdp = (char)0;
  return 1;
}

// compare_lists
// file aligneval.c line 295
static signed int compare_lists(signed int *k1, signed int *k2, signed int *t1, signed int *t2, signed int len1, signed int len2, float *ret_sc)
{
  float id;
  float tot;
  signed int i;
  tot = (float)0.0;
  id = tot;
  i = 0;
  for( ; !(i >= len1); i = i + 1)
  {
    tot = tot + (float)1.0;
    if(t1[(signed long int)i] == k1[(signed long int)i])
      id = id + (float)1.0;

  }
  i = 0;
  for( ; !(i >= len2); i = i + 1)
  {
    tot = tot + (float)1.0;
    if(k2[(signed long int)i] == t2[(signed long int)i])
      id = id + (float)1.0;

  }
  *ret_sc = id / tot;
  return 1;
}

// copy_alignment_line
// file selex.c line 678
static signed int copy_alignment_line(char *aseq, signed int apos, signed int name_rcol, char *buffer, signed int lcol, signed int rcol, char gapsym)
{
  char *s1;
  char *s2;
  signed int i;
  s1 = aseq + (signed long int)apos;
  s2 = buffer;
  i = 0;
  for( ; !(i >= lcol); i = i + 1)
    if(!(*s2 == 0))
      s2 = s2 + 1l;

  i = lcol;
  _Bool tmp_if_expr$1;
  for( ; rcol >= i; i = i + 1)
  {
    if((signed int)*s2 == 9)
    {
      Warn("TAB characters will corrupt a SELEX alignment! Please remove them first.");
      return 0;
    }

    if(name_rcol >= i)
      *s1 = gapsym;

    else
    {
      if((signed int)*s2 == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)*s2 == 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        *s1 = gapsym;

      else
        if((signed int)*s2 == 32)
          *s1 = gapsym;

        else
          *s1 = *s2;
    }
    s1 = s1 + 1l;
    if(!(*s2 == 0))
      s2 = s2 + 1l;

  }
  return 1;
}

// current_index_size
// file ssi.c line 1349
static unsigned long int current_index_size(struct ssiindex_s *g)
{
  unsigned long int frecsize;
  unsigned long int precsize;
  unsigned long int srecsize;
  unsigned long int total;
  frecsize = (unsigned long int)((unsigned int)16 + g->flen);
  unsigned int tmp_if_expr$1;
  if(g->smode == 1)
    tmp_if_expr$1 = (unsigned int)22 + g->plen;

  else
    tmp_if_expr$1 = (unsigned int)14 + g->plen;
  precsize = (unsigned long int)tmp_if_expr$1;
  srecsize = (unsigned long int)(g->plen + g->slen);
  total = ((unsigned long int)66L + frecsize * (unsigned long int)g->nfiles + precsize * (unsigned long int)g->nprimary + srecsize * (unsigned long int)g->nsecondary) / (unsigned long int)1048576L;
  return total;
}

// default_amino_prior
// file prior.c line 579
static struct p7prior_s * default_amino_prior(void)
{
  struct p7prior_s *pri;
  signed int q;
  signed int x;
  pri=P7AllocPrior();
  pri->strategy = 0;
  pri->tnum = 1;
  pri->tq[(signed long int)0] = (float)1.0;
  pri->t[(signed long int)0][(signed long int)0] = (float)0.7939;
  pri->t[(signed long int)0][(signed long int)1] = (float)0.0278;
  pri->t[(signed long int)0][(signed long int)2] = (float)0.0135;
  pri->t[(signed long int)0][(signed long int)3] = (float)0.1551;
  pri->t[(signed long int)0][(signed long int)4] = (float)0.1331;
  pri->t[(signed long int)0][(signed long int)5] = (float)0.9002;
  pri->t[(signed long int)0][(signed long int)6] = (float)0.5630;
  pri->mnum = 9;
  q = 0;
  for( ; !(q >= pri->mnum); q = q + 1)
  {
    static float defmq[9l] = { (float)0.178091, (float)0.056591, (float)0.0960191, (float)0.0781233, (float)0.0834977, (float)0.0904123, (float)0.114468, (float)0.0682132, (float)0.234585 };
    pri->mq[(signed long int)q] = defmq[(signed long int)q];
    x = 0;
    static float defm[9l][20l] = { { (float)0.270671, (float)0.039848, (float)0.017576, (float)0.016415, (float)0.014268, (float)0.131916, (float)0.012391, (float)0.022599, (float)0.020358, (float)0.030727, (float)0.015315, (float)0.048298, (float)0.053803, (float)0.020662, (float)0.023612, (float)0.216147, (float)0.147226, (float)0.065438, (float)0.003758, (float)0.009621 }, 
    { (float)0.021465, (float)0.010300, (float)0.011741, (float)0.010883, (float)0.385651, (float)0.016416, (float)0.076196, (float)0.035329, (float)0.013921, (float)0.093517, (float)0.022034, (float)0.028593, (float)0.013086, (float)0.023011, (float)0.018866, (float)0.029156, (float)0.018153, (float)0.036100, (float)0.071770, (float)0.419641 }, 
    { (float)0.561459, (float)0.045448, (float)0.438366, (float)0.764167, (float)0.087364, (float)0.259114, (float)0.214940, (float)0.145928, (float)0.762204, (float)0.247320, (float)0.118662, (float)0.441564, (float)0.174822, (float)0.530840, (float)0.465529, (float)0.583402, (float)0.445586, (float)0.227050, (float)0.029510, (float)0.121090 }, 
    { (float)0.070143, (float)0.011140, (float)0.019479, (float)0.094657, (float)0.013162, (float)0.048038, (float)0.077000, (float)0.032939, (float)0.576639, (float)0.072293, (float)0.028240, (float)0.080372, (float)0.037661, (float)0.185037, (float)0.506783, (float)0.073732, (float)0.071587, (float)0.042532, (float)0.011254, (float)0.028723 }, 
    { (float)0.041103, (float)0.014794, (float)0.005610, (float)0.010216, (float)0.153602, (float)0.007797, (float)0.007175, (float)0.299635, (float)0.010849, (float)0.999446, (float)0.210189, (float)0.006127, (float)0.013021, (float)0.019798, (float)0.014509, (float)0.012049, (float)0.035799, (float)0.180085, (float)0.012744, (float)0.026466 }, 
    { (float)0.115607, (float)0.037381, (float)0.012414, (float)0.018179, (float)0.051778, (float)0.017255, (float)0.004911, (float)0.796882, (float)0.017074, (float)0.285858, (float)0.075811, (float)0.014548, (float)0.015092, (float)0.011382, (float)0.012696, (float)0.027535, (float)0.088333, (float)0.944340, (float)0.004373, (float)0.016741 }, 
    { (float)0.093461, (float)0.004737, (float)0.387252, (float)0.347841, (float)0.010822, (float)0.105877, (float)0.049776, (float)0.014963, (float)0.094276, (float)0.027761, (float)0.010040, (float)0.187869, (float)0.050018, (float)0.110039, (float)0.038668, (float)0.119471, (float)0.065802, (float)0.025430, (float)0.003215, (float)0.018742 }, 
    { (float)0.452171, (float)0.114613, (float)0.062460, (float)0.115702, (float)0.284246, (float)0.140204, (float)0.100358, (float)0.550230, (float)0.143995, (float)0.700649, (float)0.276580, (float)0.118569, (float)0.097470, (float)0.126673, (float)0.143634, (float)0.278983, (float)0.358482, (float)0.661750, (float)0.061533, (float)0.199373 }, 
    { (float)0.005193, (float)0.004039, (float)0.006722, (float)0.006121, (float)0.003468, (float)0.016931, (float)0.003647, (float)0.002184, (float)0.005019, (float)0.005990, (float)0.001473, (float)0.004158, (float)0.009055, (float)0.003630, (float)0.006583, (float)0.003172, (float)0.003690, (float)0.002967, (float)0.002772, (float)0.002686 } };
    for( ; !(x >= 20); x = x + 1)
      pri->m[(signed long int)q][(signed long int)x] = defm[(signed long int)q][(signed long int)x];
  }
  pri->inum = 1;
  pri->iq[(signed long int)0] = (float)1.;
  pri->i[(signed long int)0][(signed long int)0] = (float)681.;
  pri->i[(signed long int)0][(signed long int)1] = (float)120.;
  pri->i[(signed long int)0][(signed long int)2] = (float)623.;
  pri->i[(signed long int)0][(signed long int)3] = (float)651.;
  pri->i[(signed long int)0][(signed long int)4] = (float)313.;
  pri->i[(signed long int)0][(signed long int)5] = (float)902.;
  pri->i[(signed long int)0][(signed long int)6] = (float)241.;
  pri->i[(signed long int)0][(signed long int)7] = (float)371.;
  pri->i[(signed long int)0][(signed long int)8] = (float)687.;
  pri->i[(signed long int)0][(signed long int)9] = (float)676.;
  pri->i[(signed long int)0][(signed long int)10] = (float)143.;
  pri->i[(signed long int)0][(signed long int)11] = (float)548.;
  pri->i[(signed long int)0][(signed long int)12] = (float)647.;
  pri->i[(signed long int)0][(signed long int)13] = (float)415.;
  pri->i[(signed long int)0][(signed long int)14] = (float)551.;
  pri->i[(signed long int)0][(signed long int)15] = (float)926.;
  pri->i[(signed long int)0][(signed long int)16] = (float)623.;
  pri->i[(signed long int)0][(signed long int)17] = (float)505.;
  pri->i[(signed long int)0][(signed long int)18] = (float)102.;
  pri->i[(signed long int)0][(signed long int)19] = (float)269.;
  return pri;
}

// default_nucleic_prior
// file prior.c line 693
static struct p7prior_s * default_nucleic_prior(void)
{
  struct p7prior_s *pri;
  pri=P7AllocPrior();
  pri->strategy = 0;
  pri->tnum = 1;
  pri->tq[(signed long int)0] = (float)1.;
  pri->t[(signed long int)0][(signed long int)0] = (float)0.7939;
  pri->t[(signed long int)0][(signed long int)1] = (float)0.0278;
  pri->t[(signed long int)0][(signed long int)2] = (float)0.0135;
  pri->t[(signed long int)0][(signed long int)3] = (float)0.1551;
  pri->t[(signed long int)0][(signed long int)4] = (float)0.1331;
  pri->t[(signed long int)0][(signed long int)5] = (float)0.9002;
  pri->t[(signed long int)0][(signed long int)6] = (float)0.5630;
  pri->mnum = 1;
  pri->mq[(signed long int)0] = (float)1.;
  FSet(pri->m[(signed long int)0], Alphabet_size, (float)1.);
  pri->inum = 1;
  pri->iq[(signed long int)0] = (float)1.;
  FSet(pri->i[(signed long int)0], Alphabet_size, (float)1.);
  return pri;
}

// downweight
// file weight.c line 110
static void downweight(struct phylo_s *tree, signed int nseq, float *lwt, float *rwt, float *fwt, signed int node)
{
  signed int ld;
  signed int rd;
  float lnum;
  float rnum;
  ld = (tree + (signed long int)(node - nseq))->left;
  rd = (tree + (signed long int)(node - nseq))->right;
  double tmp_if_expr$1;
  double tmp_if_expr$2;
  if(lwt[(signed long int)node] + rwt[(signed long int)node] > 0.000000f)
  {
    fwt[(signed long int)ld] = fwt[(signed long int)node] * (lwt[(signed long int)node] / (lwt[(signed long int)node] + rwt[(signed long int)node]));
    fwt[(signed long int)rd] = fwt[(signed long int)node] * (rwt[(signed long int)node] / (lwt[(signed long int)node] + rwt[(signed long int)node]));
  }

  else
  {
    if(ld >= nseq)
      tmp_if_expr$1 = (double)(tree + (signed long int)(ld - nseq))->incnum;

    else
      tmp_if_expr$1 = 1.0;
    lnum = (float)tmp_if_expr$1;
    if(rd >= nseq)
      tmp_if_expr$2 = (double)(tree + (signed long int)(rd - nseq))->incnum;

    else
      tmp_if_expr$2 = 1.0;
    rnum = (float)tmp_if_expr$2;
    fwt[(signed long int)ld] = (fwt[(signed long int)node] * lnum) / (lnum + rnum);
    fwt[(signed long int)rd] = (fwt[(signed long int)node] * rnum) / (lnum + rnum);
  }
  if(ld >= nseq)
    downweight(tree, nseq, lwt, rwt, fwt, ld);

  if(rd >= nseq)
    downweight(tree, nseq, lwt, rwt, fwt, rd);

}

// endEMBL
// file sqio.c line 887
static signed int endEMBL(char *s, signed int *addend)
{
  *addend = 0;
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(s, "     ", (unsigned long int)5);
  return (signed int)(return_value_strncmp$1 != 0);
}

// endGB
// file sqio.c line 728
static signed int endGB(char *s, signed int *addend)
{
  *addend = 0;
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(s, "//");
  _Bool tmp_if_expr$3;
  char *return_value_strstr$2;
  if(!(return_value_strstr$1 == ((char *)NULL)))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strstr$2=strstr(s, "LOCUS");
    tmp_if_expr$3 = return_value_strstr$2 == s ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$3;
}

// endGCGdata
// file sqio.c line 804
static signed int endGCGdata(char *s, signed int *addend)
{
  *addend = 0;
  return (signed int)((signed int)*s == 62);
}

// endIG
// file sqio.c line 668
static signed int endIG(char *s, signed int *addend)
{
  *addend = 1;
  char *return_value_strchr$1;
  return_value_strchr$1=strchr(s, 49);
  _Bool tmp_if_expr$3;
  char *return_value_strchr$2;
  if(!(return_value_strchr$1 == ((char *)NULL)))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strchr$2=strchr(s, 50);
    tmp_if_expr$3 = return_value_strchr$2 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$3;
}

// endPIR
// file sqio.c line 611
static signed int endPIR(char *s, signed int *addend)
{
  *addend = 0;
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(s, "///", (unsigned long int)3);
  _Bool tmp_if_expr$3;
  signed int return_value_strncmp$2;
  if(return_value_strncmp$1 == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strncmp$2=strncmp(s, "ENTRY", (unsigned long int)5);
    tmp_if_expr$3 = return_value_strncmp$2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return 1;

  else
    return 0;
}

// endPearson
// file sqio.c line 853
static signed int endPearson(char *s, signed int *addend)
{
  *addend = 0;
  return (signed int)((signed int)*s == 62);
}

// endStrider
// file sqio.c line 696
static signed int endStrider(char *s, signed int *addend)
{
  *addend = 0;
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(s, "//");
  return (signed int)(return_value_strstr$1 != (char *)(void *)0);
}

// endZuker
// file sqio.c line 962
static signed int endZuker(char *s, signed int *addend)
{
  *addend = 0;
  return (signed int)((signed int)*s == 40);
}

// estimate_model_length
// file modelmakers.c line 478
static signed int estimate_model_length(struct msa_struct *msa)
{
  signed int idx;
  float total = (float)0.;
  float wgtsum = (float)0.;
  idx = 0;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
  {
    signed int return_value_DealignedLength$1;
    return_value_DealignedLength$1=DealignedLength(msa->aseq[(signed long int)idx]);
    total = total + msa->wgt[(signed long int)idx] * (float)return_value_DealignedLength$1;
    wgtsum = wgtsum + msa->wgt[(signed long int)idx];
  }
  return (signed int)(total / wgtsum);
}

// fake_tracebacks
// file modelmakers.c line 597
static void fake_tracebacks(char **aseq, signed int nseq, signed int alen, signed int *matassign, struct p7trace_s ***ret_tr)
{
  struct p7trace_s **tr;
  signed int idx;
  signed int i;
  signed int k;
  signed int apos;
  signed int tpos;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("modelmakers.c", 607, sizeof(struct p7trace_s *) /*8ul*/  * (unsigned long int)nseq);
  tr = (struct p7trace_s **)return_value_sre_malloc$1;
  idx = 0;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  for( ; !(idx >= nseq); idx = idx + 1)
  {
    P7AllocTrace(alen + 6, &tr[(signed long int)idx]);
    tr[(signed long int)idx]->statetype[(signed long int)0] = (char)4;
    tr[(signed long int)idx]->nodeidx[(signed long int)0] = 0;
    tr[(signed long int)idx]->pos[(signed long int)0] = 0;
    tr[(signed long int)idx]->statetype[(signed long int)1] = (char)5;
    tr[(signed long int)idx]->nodeidx[(signed long int)1] = 0;
    tr[(signed long int)idx]->pos[(signed long int)1] = 0;
    i = 1;
    k = 0;
    tpos = 2;
    apos = 0;
    for( ; !(apos >= alen); apos = apos + 1)
    {
      tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)0;
      if(!((2 & matassign[(signed long int)(1 + apos)]) == 0))
      {
        tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)6;
        tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = 0;
        tr[(signed long int)idx]->pos[(signed long int)tpos] = 0;
        tpos = tpos + 1;
      }

      if(!((1 & matassign[(signed long int)(1 + apos)]) == 0))
      {
        if((signed int)aseq[(signed long int)idx][(signed long int)apos] == 32)
          tmp_if_expr$16 = (_Bool)1;

        else
          tmp_if_expr$16 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$16)
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$18)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$20 = !tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$20 = (_Bool)0;
      if(tmp_if_expr$20)
      {
        k = k + 1;
        tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)1;
        tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = k;
        tr[(signed long int)idx]->pos[(signed long int)tpos] = i;
        i = i + 1;
        tpos = tpos + 1;
      }

      else
        if(!((1 & matassign[(signed long int)(1 + apos)]) == 0))
        {
          k = k + 1;
          if(!((signed int)tr[(signed long int)idx]->statetype[(signed long int)(tpos + -1)] == 6))
          {
            tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)2;
            tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = k;
            tr[(signed long int)idx]->pos[(signed long int)tpos] = 0;
            tpos = tpos + 1;
          }

        }

        else
        {
          if(!((16 & matassign[(signed long int)(1 + apos)]) == 0))
          {
            if((signed int)aseq[(signed long int)idx][(signed long int)apos] == 32)
              tmp_if_expr$11 = (_Bool)1;

            else
              tmp_if_expr$11 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$11)
              tmp_if_expr$12 = (_Bool)1;

            else
              tmp_if_expr$12 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$12)
              tmp_if_expr$13 = (_Bool)1;

            else
              tmp_if_expr$13 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$13)
              tmp_if_expr$14 = (_Bool)1;

            else
              tmp_if_expr$14 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$15 = !tmp_if_expr$14 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$15 = (_Bool)0;
          if(tmp_if_expr$15)
          {
            tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)5;
            tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = 0;
            tr[(signed long int)idx]->pos[(signed long int)tpos] = i;
            i = i + 1;
            tpos = tpos + 1;
          }

          else
          {
            if(!((32 & matassign[(signed long int)(1 + apos)]) == 0))
            {
              if((signed int)aseq[(signed long int)idx][(signed long int)apos] == 32)
                tmp_if_expr$6 = (_Bool)1;

              else
                tmp_if_expr$6 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$6)
                tmp_if_expr$7 = (_Bool)1;

              else
                tmp_if_expr$7 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$7)
                tmp_if_expr$8 = (_Bool)1;

              else
                tmp_if_expr$8 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$8)
                tmp_if_expr$9 = (_Bool)1;

              else
                tmp_if_expr$9 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr$10 = !tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$10 = (_Bool)0;
            if(tmp_if_expr$10)
            {
              tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)8;
              tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = 0;
              tr[(signed long int)idx]->pos[(signed long int)tpos] = i;
              i = i + 1;
              tpos = tpos + 1;
            }

            else
            {
              if((signed int)aseq[(signed long int)idx][(signed long int)apos] == 32)
                tmp_if_expr$2 = (_Bool)1;

              else
                tmp_if_expr$2 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 46 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$2)
                tmp_if_expr$3 = (_Bool)1;

              else
                tmp_if_expr$3 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 95 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$3)
                tmp_if_expr$4 = (_Bool)1;

              else
                tmp_if_expr$4 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 45 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$4)
                tmp_if_expr$5 = (_Bool)1;

              else
                tmp_if_expr$5 = (signed int)aseq[(signed long int)idx][(signed long int)apos] == 126 ? (_Bool)1 : (_Bool)0;
              if(!tmp_if_expr$5)
              {
                tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)3;
                tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = k;
                tr[(signed long int)idx]->pos[(signed long int)tpos] = i;
                i = i + 1;
                tpos = tpos + 1;
              }

            }
          }
        }
      if(!((4 & matassign[(signed long int)(1 + apos)]) == 0))
      {
        for( ; (signed int)tr[(signed long int)idx]->statetype[(signed long int)(tpos + -1)] == 2; tpos = tpos - 1)
          ;
        tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)7;
        tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = 0;
        tr[(signed long int)idx]->pos[(signed long int)tpos] = 0;
        tpos = tpos + 1;
        tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)8;
        tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = 0;
        tr[(signed long int)idx]->pos[(signed long int)tpos] = 0;
        tpos = tpos + 1;
      }

    }
    tr[(signed long int)idx]->statetype[(signed long int)tpos] = (char)9;
    tr[(signed long int)idx]->nodeidx[(signed long int)tpos] = 0;
    tr[(signed long int)idx]->pos[(signed long int)tpos] = 0;
    tpos = tpos + 1;
    tr[(signed long int)idx]->tlen = tpos;
    trace_doctor(tr[(signed long int)idx], k, (signed int *)(void *)0, (signed int *)(void *)0);
  }
  *ret_tr = tr;
  goto __CPROVER_DUMP_L53;

__CPROVER_DUMP_L53:
  ;
}

// format_time_string
// file stopwatch.c line 80
static void format_time_string(char *buf, double sec, signed int do_frac)
{
  signed int h;
  signed int m;
  signed int s;
  signed int hs;
  h = (signed int)(sec / 3600.);
  m = (signed int)(sec / 60.) - h * 60;
  s = ((signed int)sec - h * 3600) - m * 60;
  if(!(do_frac == 0))
  {
    hs = (((signed int)(sec * 100.) - h * 360000) - m * 6000) - s * 100;
    sprintf(buf, "%02d:%02d:%02d.%02d", h, m, s, hs);
  }

  else
    sprintf(buf, "%02d:%02d:%02d", h, m, s);
}

// get_wee_midpt
// file core_algorithms.c line 1717
static float get_wee_midpt(struct plan7_s *hmm, unsigned char *dsq, signed int L, signed int k1, char t1, signed int s1, signed int k3, char t3, signed int s3, signed int *ret_k2, char *ret_t2, signed int *ret_s2)
{
  struct dpmatrix_s *fwd;
  struct dpmatrix_s *bck;
  signed int **xmx;
  signed int **mmx;
  signed int **imx;
  signed int **dmx;
  signed int k2;
  char t2;
  signed int s2;
  signed int cur;
  signed int prv;
  signed int nxt;
  signed int i;
  signed int k;
  signed int sc;
  signed int max;
  signed int start;
  s2 = s1 + (s3 - s1) / 2;
  if(s3 + -s1 == 1 && (signed int)t1 == 4)
    s2 = s1;

  if(s3 + -s1 == 1 && (signed int)t3 == 9)
    s2 = s3;

  start = (signed int)t1 == 4 ? 0 : s1;
  fwd=AllocPlan7Matrix(2, hmm->M, &xmx, &mmx, &imx, &dmx);
  cur = start % 2;
  xmx[(signed long int)cur][(signed long int)0] = -987654321;
  xmx[(signed long int)cur][(signed long int)4] = xmx[(signed long int)cur][(signed long int)0];
  xmx[(signed long int)cur][(signed long int)2] = -987654321;
  xmx[(signed long int)cur][(signed long int)1] = xmx[(signed long int)cur][(signed long int)2];
  k = k1;
  for( ; k3 >= k; k = k + 1)
  {
    dmx[(signed long int)cur][(signed long int)k] = -987654321;
    imx[(signed long int)cur][(signed long int)k] = dmx[(signed long int)cur][(signed long int)k];
    mmx[(signed long int)cur][(signed long int)k] = imx[(signed long int)cur][(signed long int)k];
  }
  switch((signed int)t1)
  {
    case 1:
    {
      mmx[(signed long int)cur][(signed long int)k1] = 0;
      break;
    }
    case 3:
    {
      imx[(signed long int)cur][(signed long int)k1] = 0;
      break;
    }
    case 5:
    {
      xmx[(signed long int)cur][(signed long int)4] = 0;
      break;
    }
    case 8:
    {
      xmx[(signed long int)cur][(signed long int)2] = 0;
      break;
    }
    case 4:
    {
      xmx[(signed long int)cur][(signed long int)4] = 0;
      break;
    }
    default:
    {
      char *return_value_Statetype$1;
      return_value_Statetype$1=Statetype(t1);
      Die("you can't init get_wee_midpt with a %s\n", return_value_Statetype$1);
    }
  }
  if((signed int)t1 == 1)
  {
    k = k1 + 1;
    for( ; k3 >= k; k = k + 1)
    {
      dmx[(signed long int)cur][(signed long int)k] = -987654321;
      sc = mmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)2][(signed long int)(k - 1)];
      if(sc >= -987654320)
        dmx[(signed long int)cur][(signed long int)k] = sc;

      sc = dmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)6][(signed long int)(k - 1)];
      if(!(dmx[(signed long int)cur][(signed long int)k] >= sc))
        dmx[(signed long int)cur][(signed long int)k] = sc;

    }
    xmx[(signed long int)cur][(signed long int)1] = -987654321;
    sc = mmx[(signed long int)cur][(signed long int)k1] + hmm->esc[(signed long int)k1];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)1] = sc;

  }

  xmx[(signed long int)cur][(signed long int)0] = -987654321;
  sc = xmx[(signed long int)cur][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0];
  if(sc >= -987654320)
    xmx[(signed long int)cur][(signed long int)0] = sc;

  xmx[(signed long int)cur][(signed long int)2] = -987654321;
  sc = xmx[(signed long int)cur][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0];
  if(sc >= -987654320)
    xmx[(signed long int)cur][(signed long int)2] = sc;

  i = start + 1;
  _Bool tmp_if_expr$2;
  for( ; s2 >= i; i = i + 1)
  {
    cur = i % 2;
    prv = (signed int)!(cur != 0);
    dmx[(signed long int)cur][(signed long int)k1] = -987654321;
    imx[(signed long int)cur][(signed long int)k1] = dmx[(signed long int)cur][(signed long int)k1];
    mmx[(signed long int)cur][(signed long int)k1] = imx[(signed long int)cur][(signed long int)k1];
    if(!(k1 >= hmm->M))
    {
      imx[(signed long int)cur][(signed long int)k1] = -987654321;
      sc = mmx[(signed long int)prv][(signed long int)k1] + hmm->tsc[(signed long int)1][(signed long int)k1];
      if(sc >= -987654320)
        imx[(signed long int)cur][(signed long int)k1] = sc;

      sc = imx[(signed long int)prv][(signed long int)k1] + hmm->tsc[(signed long int)4][(signed long int)k1];
      if(!(imx[(signed long int)cur][(signed long int)k1] >= sc))
        imx[(signed long int)cur][(signed long int)k1] = sc;

      if(!(hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k1] == -987654321))
        imx[(signed long int)cur][(signed long int)k1] = imx[(signed long int)cur][(signed long int)k1] + hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k1];

      else
        imx[(signed long int)cur][(signed long int)k1] = -987654321;
    }

    sc = xmx[(signed long int)prv][(signed long int)0] + hmm->bsc[(signed long int)k1];
    if(sc >= -987654320)
      mmx[(signed long int)cur][(signed long int)k1] = sc;

    if(!(hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k1] == -987654321))
      mmx[(signed long int)cur][(signed long int)k1] = mmx[(signed long int)cur][(signed long int)k1] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k1];

    else
      mmx[(signed long int)cur][(signed long int)k1] = -987654321;
    k = k1 + 1;
    for( ; k3 >= k; k = k + 1)
    {
      mmx[(signed long int)cur][(signed long int)k] = -987654321;
      sc = mmx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)0][(signed long int)(k - 1)];
      if(sc >= -987654320)
        mmx[(signed long int)cur][(signed long int)k] = sc;

      sc = imx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)3][(signed long int)(k - 1)];
      if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
        mmx[(signed long int)cur][(signed long int)k] = sc;

      sc = xmx[(signed long int)prv][(signed long int)0] + hmm->bsc[(signed long int)k];
      if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
        mmx[(signed long int)cur][(signed long int)k] = sc;

      sc = dmx[(signed long int)prv][(signed long int)(k - 1)] + hmm->tsc[(signed long int)5][(signed long int)(k - 1)];
      if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
        mmx[(signed long int)cur][(signed long int)k] = sc;

      if(!(hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k] == -987654321))
        mmx[(signed long int)cur][(signed long int)k] = mmx[(signed long int)cur][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k];

      else
        mmx[(signed long int)cur][(signed long int)k] = -987654321;
      dmx[(signed long int)cur][(signed long int)k] = -987654321;
      if(!(k >= hmm->M))
      {
        sc = mmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)2][(signed long int)(k - 1)];
        if(sc >= -987654320)
          dmx[(signed long int)cur][(signed long int)k] = sc;

        sc = dmx[(signed long int)cur][(signed long int)(k - 1)] + hmm->tsc[(signed long int)6][(signed long int)(k - 1)];
        if(!(dmx[(signed long int)cur][(signed long int)k] >= sc))
          dmx[(signed long int)cur][(signed long int)k] = sc;

      }

      imx[(signed long int)cur][(signed long int)k] = -987654321;
      if(!(k >= hmm->M))
      {
        sc = mmx[(signed long int)prv][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k];
        if(sc >= -987654320)
          imx[(signed long int)cur][(signed long int)k] = sc;

        sc = imx[(signed long int)prv][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k];
        if(!(imx[(signed long int)cur][(signed long int)k] >= sc))
          imx[(signed long int)cur][(signed long int)k] = sc;

        if(!(hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k] == -987654321))
          imx[(signed long int)cur][(signed long int)k] = imx[(signed long int)cur][(signed long int)k] + hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k];

        else
          imx[(signed long int)cur][(signed long int)k] = -987654321;
      }

    }
    xmx[(signed long int)cur][(signed long int)4] = -987654321;
    sc = xmx[(signed long int)prv][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)4] = sc;

    xmx[(signed long int)cur][(signed long int)1] = -987654321;
    k = k1;
    do
    {
      if(k3 >= k)
        tmp_if_expr$2 = k <= hmm->M ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      sc = mmx[(signed long int)cur][(signed long int)k] + hmm->esc[(signed long int)k];
      if(!(xmx[(signed long int)cur][1l] >= sc))
        xmx[(signed long int)cur][(signed long int)1] = sc;

      k = k + 1;
    }
    while((_Bool)1);
    xmx[(signed long int)cur][(signed long int)0] = -987654321;
    sc = xmx[(signed long int)cur][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)0];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)0] = sc;

    xmx[(signed long int)cur][(signed long int)2] = -987654321;
    sc = xmx[(signed long int)prv][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)2] = sc;

    sc = xmx[(signed long int)cur][(signed long int)1] + hmm->xsc[(signed long int)1][(signed long int)0];
    if(!(xmx[(signed long int)cur][2l] >= sc))
      xmx[(signed long int)cur][(signed long int)2] = sc;

  }
  bck=AllocPlan7Matrix(2, hmm->M, &xmx, &mmx, &imx, &dmx);
  nxt = s3 % 2;
  xmx[(signed long int)nxt][(signed long int)0] = -987654321;
  xmx[(signed long int)nxt][(signed long int)4] = xmx[(signed long int)nxt][(signed long int)0];
  xmx[(signed long int)nxt][(signed long int)2] = -987654321;
  xmx[(signed long int)nxt][(signed long int)1] = xmx[(signed long int)nxt][(signed long int)2];
  k = k1;
  for( ; 1 + k3 >= k; k = k + 1)
  {
    dmx[(signed long int)nxt][(signed long int)k] = -987654321;
    imx[(signed long int)nxt][(signed long int)k] = dmx[(signed long int)nxt][(signed long int)k];
    mmx[(signed long int)nxt][(signed long int)k] = imx[(signed long int)nxt][(signed long int)k];
  }
  cur = (signed int)!(nxt != 0);
  dmx[(signed long int)cur][(signed long int)(k3 + 1)] = -987654321;
  imx[(signed long int)cur][(signed long int)(k3 + 1)] = dmx[(signed long int)cur][(signed long int)(k3 + 1)];
  mmx[(signed long int)cur][(signed long int)(k3 + 1)] = imx[(signed long int)cur][(signed long int)(k3 + 1)];
  switch((signed int)t3)
  {
    case 1:
    {
      mmx[(signed long int)nxt][(signed long int)k3] = 0;
      break;
    }
    case 3:
    {
      imx[(signed long int)nxt][(signed long int)k3] = 0;
      break;
    }
    case 5:
    {
      xmx[(signed long int)nxt][(signed long int)4] = 0;
      break;
    }
    case 8:
    {
      xmx[(signed long int)nxt][(signed long int)2] = 0;
      break;
    }
    case 9:
    {
      xmx[(signed long int)nxt][(signed long int)2] = hmm->xsc[(signed long int)2][(signed long int)0];
      break;
    }
    default:
    {
      char *return_value_Statetype$3;
      return_value_Statetype$3=Statetype(t3);
      Die("you can't init get_wee_midpt with a %s\n", return_value_Statetype$3);
    }
  }
  if((signed int)t3 == 9)
  {
    xmx[(signed long int)nxt][(signed long int)1] = xmx[(signed long int)nxt][(signed long int)2] + hmm->xsc[(signed long int)1][(signed long int)0];
    k = k3;
    for( ; k >= k1; k = k - 1)
    {
      mmx[(signed long int)nxt][(signed long int)k] = xmx[(signed long int)nxt][(signed long int)1] + hmm->esc[(signed long int)k];
      if(!(s3 == s2))
        mmx[(signed long int)nxt][(signed long int)k] = mmx[(signed long int)nxt][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)s3]][(signed long int)k];

    }
  }

  i = s3 - 1;
  for( ; i >= s2; i = i - 1)
  {
    cur = i % 2;
    nxt = (signed int)!(cur != 0);
    xmx[(signed long int)cur][(signed long int)2] = -987654321;
    sc = xmx[(signed long int)nxt][(signed long int)2] + hmm->xsc[(signed long int)2][(signed long int)1];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)2] = sc;

    xmx[(signed long int)cur][(signed long int)0] = -987654321;
    k = k1;
    for( ; k3 >= k; k = k + 1)
    {
      sc = mmx[(signed long int)nxt][(signed long int)k] + hmm->bsc[(signed long int)k];
      if(!(*xmx[(signed long int)cur] >= sc))
        xmx[(signed long int)cur][(signed long int)0] = sc;

    }
    xmx[(signed long int)cur][(signed long int)1] = -987654321;
    sc = xmx[(signed long int)cur][(signed long int)2] + hmm->xsc[(signed long int)1][(signed long int)0];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)1] = sc;

    xmx[(signed long int)cur][(signed long int)4] = -987654321;
    sc = xmx[(signed long int)cur][(signed long int)0] + hmm->xsc[(signed long int)0][(signed long int)0];
    if(sc >= -987654320)
      xmx[(signed long int)cur][(signed long int)4] = sc;

    sc = xmx[(signed long int)nxt][(signed long int)4] + hmm->xsc[(signed long int)0][(signed long int)1];
    if(!(xmx[(signed long int)cur][4l] >= sc))
      xmx[(signed long int)cur][(signed long int)4] = sc;

    k = k3;
    for( ; k >= k1; k = k - 1)
      if(k == hmm->M)
      {
        mmx[(signed long int)cur][(signed long int)k] = xmx[(signed long int)cur][(signed long int)1];
        dmx[(signed long int)cur][(signed long int)k] = -987654321;
        imx[(signed long int)cur][(signed long int)k] = -987654321;
        if(!(i == s2))
          mmx[(signed long int)cur][(signed long int)k] = mmx[(signed long int)cur][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k];

      }

      else
      {
        mmx[(signed long int)cur][(signed long int)k] = -987654321;
        sc = xmx[(signed long int)cur][(signed long int)1] + hmm->esc[(signed long int)k];
        if(sc >= -987654320)
          mmx[(signed long int)cur][(signed long int)k] = sc;

        sc = mmx[(signed long int)nxt][(signed long int)(k + 1)] + hmm->tsc[(signed long int)0][(signed long int)k];
        if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
          mmx[(signed long int)cur][(signed long int)k] = sc;

        sc = imx[(signed long int)nxt][(signed long int)k] + hmm->tsc[(signed long int)1][(signed long int)k];
        if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
          mmx[(signed long int)cur][(signed long int)k] = sc;

        sc = dmx[(signed long int)cur][(signed long int)(k + 1)] + hmm->tsc[(signed long int)2][(signed long int)k];
        if(!(mmx[(signed long int)cur][(signed long int)k] >= sc))
          mmx[(signed long int)cur][(signed long int)k] = sc;

        if(!(i == s2))
          mmx[(signed long int)cur][(signed long int)k] = mmx[(signed long int)cur][(signed long int)k] + hmm->msc[(signed long int)dsq[(signed long int)i]][(signed long int)k];

        dmx[(signed long int)cur][(signed long int)k] = -987654321;
        sc = mmx[(signed long int)nxt][(signed long int)(k + 1)] + hmm->tsc[(signed long int)5][(signed long int)k];
        if(sc >= -987654320)
          dmx[(signed long int)cur][(signed long int)k] = sc;

        sc = dmx[(signed long int)cur][(signed long int)(k + 1)] + hmm->tsc[(signed long int)6][(signed long int)k];
        if(!(dmx[(signed long int)cur][(signed long int)k] >= sc))
          dmx[(signed long int)cur][(signed long int)k] = sc;

        imx[(signed long int)cur][(signed long int)k] = -987654321;
        sc = mmx[(signed long int)nxt][(signed long int)(k + 1)] + hmm->tsc[(signed long int)3][(signed long int)k];
        if(sc >= -987654320)
          imx[(signed long int)cur][(signed long int)k] = sc;

        sc = imx[(signed long int)nxt][(signed long int)k] + hmm->tsc[(signed long int)4][(signed long int)k];
        if(!(imx[(signed long int)cur][(signed long int)k] >= sc))
          imx[(signed long int)cur][(signed long int)k] = sc;

        if(!(i == s2))
          imx[(signed long int)cur][(signed long int)k] = imx[(signed long int)cur][(signed long int)k] + hmm->isc[(signed long int)dsq[(signed long int)i]][(signed long int)k];

      }
  }
  cur = s2 % 2;
  max = -987654321;
  k = k1;
  for( ; k3 >= k; k = k + 1)
  {
    sc = fwd->mmx[(signed long int)cur][(signed long int)k] + bck->mmx[(signed long int)cur][(signed long int)k];
    if(!(max >= sc))
    {
      k2 = k;
      t2 = (char)1;
      max = sc;
    }

    sc = fwd->imx[(signed long int)cur][(signed long int)k] + bck->imx[(signed long int)cur][(signed long int)k];
    if(!(max >= sc))
    {
      k2 = k;
      t2 = (char)3;
      max = sc;
    }

  }
  sc = fwd->xmx[(signed long int)cur][(signed long int)4] + bck->xmx[(signed long int)cur][(signed long int)4];
  if(!(max >= sc))
  {
    k2 = 1;
    t2 = (char)5;
    max = sc;
  }

  sc = fwd->xmx[(signed long int)cur][(signed long int)2] + bck->xmx[(signed long int)cur][(signed long int)2];
  if(!(max >= sc))
  {
    k2 = hmm->M;
    t2 = (char)8;
    max = sc;
  }

  FreePlan7Matrix(fwd);
  FreePlan7Matrix(bck);
  *ret_k2 = k2;
  *ret_t2 = t2;
  *ret_s2 = s2;
  float return_value_Scorify$4;
  return_value_Scorify$4=Scorify(max);
  return return_value_Scorify$4;
}

// gki_alloc
// file gki.c line 287
static struct anonymous$0 * gki_alloc(signed int primelevel)
{
  struct anonymous$0 *hash;
  signed int i;
  if(primelevel >= 4 || !(primelevel >= 0))
    Die("bad primelevel in gki_alloc()");

  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("gki.c", 294, sizeof(struct anonymous$0) /*24ul*/ );
  hash = (struct anonymous$0 *)return_value_sre_malloc$1;
  hash->primelevel = primelevel;
  hash->nhash = gki_primes[(signed long int)hash->primelevel];
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("gki.c", 298, sizeof(struct gki_elem) /*24ul*/  * (unsigned long int)hash->nhash);
  hash->table = (struct gki_elem **)return_value_sre_malloc$2;
  i = 0;
  for( ; !(i >= hash->nhash); i = i + 1)
    hash->table[(signed long int)i] = (struct gki_elem *)(void *)0;
  hash->nkeys = 0;
  return hash;
}

// gki_hashvalue
// file gki.c line 325
static signed int gki_hashvalue(struct anonymous$0 *hash, char *key)
{
  signed int val = 0;
  for( ; !((signed int)*key == 0); key = key + 1l)
  {
    val = 128 * val + (signed int)*key;
    key = key + 1l;
    if((signed int)*key == 0)
    {
      val = val % hash->nhash;
      break;
    }

    val = (128 * val + (signed int)*key) % hash->nhash;
  }
  return val;
}

// gki_upsize
// file gki.c line 350
static signed int gki_upsize(struct anonymous$0 *old)
{
  struct anonymous$0 *new;
  signed int i;
  struct gki_elem *optr;
  struct gki_elem *nptr;
  signed int val;
  if(old->primelevel >= 4)
    return 0;

  else
  {
    new=gki_alloc(old->primelevel + 1);
    i = 0;
    for( ; !(i >= old->nhash); i = i + 1)
    {
      optr = old->table[(signed long int)i];
      for( ; !(optr == ((struct gki_elem *)NULL)); new->table[(signed long int)val]->nxt = nptr)
      {
        val=gki_hashvalue(new, optr->key);
        nptr = new->table[(signed long int)val];
        new->table[(signed long int)val] = optr;
        optr = optr->nxt;
      }
    }
    free((void *)old->table);
    old->primelevel = new->primelevel;
    old->nhash = new->nhash;
    old->table = new->table;
    free((void *)new);
    return 1;
  }
}

// gsi_keysorter
// file gsi.c line 250
static signed int gsi_keysorter(const void *k1, const void *k2)
{
  struct gsikey_s *key1;
  struct gsikey_s *key2;
  key1 = (struct gsikey_s *)k1;
  key2 = (struct gsikey_s *)k2;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(key1->key, key2->key);
  return return_value_strcmp$1;
}

// hit_comparison
// file tophits.c line 276
signed int hit_comparison(const void *vh1, const void *vh2)
{
  struct hit_s *h1 = *((struct hit_s **)vh1);
  struct hit_s *h2 = *((struct hit_s **)vh2);
  if(h1->sortkey < h2->sortkey)
    return 1;

  else
    if(h1->sortkey > h2->sortkey)
      return -1;

    else
      if(IEEE_FLOAT_EQUAL(h1->sortkey, h2->sortkey))
        return 0;

  return 0;
}

// indexfile_position
// file ssi.c line 1326
static signed int indexfile_position(struct ssifile_s *sfp, struct ssioffset_s *base, unsigned int len, unsigned int n)
{
  struct ssioffset_s pos;
  signed int status;
  if((signed int)base->mode == 0)
  {
    pos.mode = (char)0;
    pos.off.i32 = base->off.i32 + n * len;
  }

  else
    if((signed int)base->mode == 1)
    {
      pos.mode = (char)1;
      pos.off.i64 = base->off.i64 + (unsigned long int)(n * len);
    }

    else
      return 0;
  status=SSISetFilePosition(sfp->fp, &pos);
  if(!(status == 0))
    return status;

  else
    return 0;
}

// init_ilogsum
// file mathsupport.c line 149
static void init_ilogsum(void)
{
  signed int i = 0;
  double return_value_exp$1;
  double return_value_log$2;
  for( ; !(i >= 20000); i = i + 1)
  {
    return_value_exp$1=exp((0.69314718 * (double)(float)-i) / 1000.0);
    return_value_log$2=log(1. + return_value_exp$1);
    ilogsum_lookup[(signed long int)i] = (signed int)(1000.0 * 1.44269504 * return_value_log$2);
  }
}

// load_indexfile
// file ssi.c line 77
static signed int load_indexfile(struct ssifile_s *sfp)
{
  unsigned int magic;
  unsigned short int i;
  signed int status = 6;
  sfp->filename = (char **)(void *)0;
  sfp->fileformat = (unsigned int *)(void *)0;
  sfp->fileflags = (unsigned int *)(void *)0;
  sfp->bpl = (unsigned int *)(void *)0;
  sfp->rpl = (unsigned int *)(void *)0;
  sfp->nfiles = (unsigned short int)0;
  signed int return_value_read_i32$1;
  return_value_read_i32$1=read_i32(sfp->fp, &magic);
  signed int return_value_read_i32$2;
  signed int return_value_read_i16$3;
  signed int return_value_read_i32$4;
  signed int return_value_read_i32$5;
  signed int return_value_read_i32$6;
  signed int return_value_read_i32$7;
  signed int return_value_read_i32$8;
  signed int return_value_read_i32$9;
  signed int return_value_read_i32$10;
  signed int return_value_read_i32$11;
  signed int return_value_read_offset$12;
  signed int return_value_read_offset$13;
  signed int return_value_read_offset$14;
  void *return_value_malloc$15;
  void *return_value_malloc$16;
  void *return_value_malloc$17;
  void *return_value_malloc$18;
  void *return_value_malloc$19;
  if(return_value_read_i32$1 == 0)
    status = 5;

  else
    if(!(magic == v20magic$link1) && !(magic == v20swap$link1))
      status = 5;

    else
    {
      return_value_read_i32$2=read_i32(sfp->fp, &sfp->flags);
      if(!(return_value_read_i32$2 == 0))
      {
        sfp->imode = (char)((sfp->flags & (unsigned int)(1 << 1)) != 0u ? 1 : 0);
        sfp->smode = (char)((sfp->flags & (unsigned int)(1 << 0)) != 0u ? 1 : 0);
        return_value_read_i16$3=read_i16(sfp->fp, &sfp->nfiles);
        if(!(return_value_read_i16$3 == 0))
        {
          return_value_read_i32$4=read_i32(sfp->fp, &sfp->nprimary);
          if(!(return_value_read_i32$4 == 0))
          {
            return_value_read_i32$5=read_i32(sfp->fp, &sfp->nsecondary);
            if(!(return_value_read_i32$5 == 0))
            {
              return_value_read_i32$6=read_i32(sfp->fp, &sfp->flen);
              if(!(return_value_read_i32$6 == 0))
              {
                return_value_read_i32$7=read_i32(sfp->fp, &sfp->plen);
                if(!(return_value_read_i32$7 == 0))
                {
                  return_value_read_i32$8=read_i32(sfp->fp, &sfp->slen);
                  if(!(return_value_read_i32$8 == 0))
                  {
                    return_value_read_i32$9=read_i32(sfp->fp, &sfp->frecsize);
                    if(!(return_value_read_i32$9 == 0))
                    {
                      return_value_read_i32$10=read_i32(sfp->fp, &sfp->precsize);
                      if(!(return_value_read_i32$10 == 0))
                      {
                        return_value_read_i32$11=read_i32(sfp->fp, &sfp->srecsize);
                        if(!(return_value_read_i32$11 == 0))
                        {
                          return_value_read_offset$12=read_offset(sfp->fp, sfp->imode, &sfp->foffset);
                          if(!(return_value_read_offset$12 == 0))
                          {
                            return_value_read_offset$13=read_offset(sfp->fp, sfp->imode, &sfp->poffset);
                            if(!(return_value_read_offset$13 == 0))
                            {
                              return_value_read_offset$14=read_offset(sfp->fp, sfp->imode, &sfp->soffset);
                              if(!(return_value_read_offset$14 == 0))
                              {
                                if(!((signed int)sfp->nfiles == 0))
                                {
                                  return_value_malloc$15=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)sfp->nfiles);
                                  sfp->filename = (char **)return_value_malloc$15;
                                  if(sfp->filename == ((char **)NULL))
                                    status = 3;

                                  else
                                  {
                                    i = (unsigned short int)0;
                                    for( ; !((signed int)i >= (signed int)sfp->nfiles); i = i + 1)
                                      sfp->filename[(signed long int)i] = (char *)(void *)0;
                                    return_value_malloc$16=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)sfp->nfiles);
                                    sfp->fileformat = (unsigned int *)return_value_malloc$16;
                                    if(sfp->fileformat == ((unsigned int *)NULL))
                                      status = 3;

                                    else
                                    {
                                      return_value_malloc$17=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)sfp->nfiles);
                                      sfp->fileflags = (unsigned int *)return_value_malloc$17;
                                      if(sfp->fileflags == ((unsigned int *)NULL))
                                        status = 3;

                                      else
                                      {
                                        return_value_malloc$18=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)sfp->nfiles);
                                        sfp->bpl = (unsigned int *)return_value_malloc$18;
                                        if(sfp->bpl == ((unsigned int *)NULL))
                                          status = 3;

                                        else
                                        {
                                          return_value_malloc$19=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)sfp->nfiles);
                                          sfp->rpl = (unsigned int *)return_value_malloc$19;
                                          if(sfp->rpl == ((unsigned int *)NULL))
                                            status = 3;

                                          else
                                          {
                                            i = (unsigned short int)0;
                                            for( ; !((signed int)i >= (signed int)sfp->nfiles); i = i + 1)
                                            {
                                              signed int return_value_indexfile_position$20;
                                              return_value_indexfile_position$20=indexfile_position(sfp, &sfp->foffset, sfp->frecsize, (unsigned int)i);
                                              if(!(return_value_indexfile_position$20 == 0))
                                                goto FAILURE;

                                              void *return_value_malloc$21;
                                              return_value_malloc$21=malloc(sizeof(char) /*1ul*/  * (unsigned long int)sfp->flen);
                                              sfp->filename[(signed long int)i] = (char *)return_value_malloc$21;
                                              if(sfp->filename[(signed long int)i] == ((char *)NULL))
                                              {
                                                status = 3;
                                                goto FAILURE;
                                              }

                                              unsigned long int return_value_fread$22;
                                              return_value_fread$22=fread((void *)sfp->filename[(signed long int)i], sizeof(char) /*1ul*/ , (unsigned long int)sfp->flen, sfp->fp);
                                              if(!(return_value_fread$22 == (unsigned long int)sfp->flen))
                                                goto FAILURE;

                                              signed int return_value_read_i32$23;
                                              return_value_read_i32$23=read_i32(sfp->fp, &sfp->fileformat[(signed long int)i]);
                                              if(return_value_read_i32$23 == 0)
                                                goto FAILURE;

                                              signed int return_value_read_i32$24;
                                              return_value_read_i32$24=read_i32(sfp->fp, &sfp->fileflags[(signed long int)i]);
                                              if(return_value_read_i32$24 == 0)
                                                goto FAILURE;

                                              signed int return_value_read_i32$25;
                                              return_value_read_i32$25=read_i32(sfp->fp, &sfp->bpl[(signed long int)i]);
                                              if(return_value_read_i32$25 == 0)
                                                goto FAILURE;

                                              signed int return_value_read_i32$26;
                                              return_value_read_i32$26=read_i32(sfp->fp, &sfp->rpl[(signed long int)i]);
                                              if(return_value_read_i32$26 == 0)
                                                goto FAILURE;

                                            }
                                            return 0;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }

                              }

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

FAILURE:
  ;
  SSIClose(sfp);
  return status;
}

// main
// file hmmcalibrate.c line 138
signed int main(signed int argc, char **argv)
{
  char *hmmfile;
  char *tmpfile;
  struct hmmfile_s *hmmfp;
  struct _IO_FILE *outfp;
  char *mode;
  struct plan7_s *hmm;
  signed int idx;
  struct anonymous$3 blocksigs;
  signed int nhmm;
  struct histogram_s *hist;
  float max;
  char *histfile;
  struct _IO_FILE *hfp;
  struct stopwatch_s stopwatch;
  struct stopwatch_s extrawatch;
  float *mu;
  float *lambda;
  signed int mu_lumpsize;
  signed int nsample;
  signed int seed;
  signed int fixedlen;
  float lenmean;
  float lensd;
  signed int do_pvm;
  signed int pvm_lumpsize;
  signed int pvm_nslaves;
  char *optname;
  char *optarg;
  signed int optind;
  signed int num_threads;
  StopwatchStart(&stopwatch);
  StopwatchZero(&extrawatch);
  nsample = 5000;
  fixedlen = 0;
  lenmean = (float)325.;
  lensd = (float)200.;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  seed = (signed int)return_value_time$1;
  histfile = (char *)(void *)0;
  do_pvm = 0;
  pvm_lumpsize = 20;
  mu_lumpsize = 100;
  num_threads=ThreadNumber();
  signed int return_value_Getopt$2;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  double return_value_atof$3;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  double return_value_atof$4;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  do
  {
    return_value_Getopt$2=Getopt(argc, argv, OPTIONS, (signed int)(sizeof(struct opt_s [9l]) /*144ul*/  / sizeof(struct opt_s) /*16ul*/ ), usage, &optind, &optname, &optarg);
    if(return_value_Getopt$2 == 0)
      break;

    signed int return_value_strcmp$13;
    return_value_strcmp$13=strcmp(optname, "--cpu");
    if(return_value_strcmp$13 == 0)
      num_threads=atoi(optarg);

    else
    {
      return_value_strcmp$12=strcmp(optname, "--fixed");
      if(return_value_strcmp$12 == 0)
        fixedlen=atoi(optarg);

      else
      {
        return_value_strcmp$11=strcmp(optname, "--histfile");
        if(return_value_strcmp$11 == 0)
          histfile = optarg;

        else
        {
          return_value_strcmp$10=strcmp(optname, "--mean");
          if(return_value_strcmp$10 == 0)
          {
            return_value_atof$3=atof(optarg);
            lenmean = (float)return_value_atof$3;
          }

          else
          {
            return_value_strcmp$9=strcmp(optname, "--num");
            if(return_value_strcmp$9 == 0)
              nsample=atoi(optarg);

            else
            {
              return_value_strcmp$8=strcmp(optname, "--pvm");
              if(return_value_strcmp$8 == 0)
                do_pvm = 1;

              else
              {
                return_value_strcmp$7=strcmp(optname, "--sd");
                if(return_value_strcmp$7 == 0)
                {
                  return_value_atof$4=atof(optarg);
                  lensd = (float)return_value_atof$4;
                }

                else
                {
                  return_value_strcmp$6=strcmp(optname, "--seed");
                  if(return_value_strcmp$6 == 0)
                    seed=atoi(optarg);

                  else
                  {
                    return_value_strcmp$5=strcmp(optname, "-h");
                    if(return_value_strcmp$5 == 0)
                    {
                      HMMERBanner(stdout, banner);
                      puts(usage);
                      puts(experts);
                      exit(0);
                    }

                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while((_Bool)1);
  if(!(argc + -optind == 1))
    Die("Incorrect number of arguments.\n%s\n", (const void *)usage);

  signed int tmp_post$14 = optind;
  optind = optind + 1;
  hmmfile = argv[(signed long int)tmp_post$14];
  hmmfp=HMMFileOpen(hmmfile, (char *)(void *)0);
  if(hmmfp == ((struct hmmfile_s *)NULL))
    Die("failed to open HMM file %s for reading.", hmmfile);

  hfp = (struct _IO_FILE *)(void *)0;
  if(!(histfile == ((char *)NULL)))
  {
    hfp=fopen(histfile, "w");
    if(hfp == ((struct _IO_FILE *)NULL))
      Die("Failed to open histogram save file %s for writing\n", histfile);

  }

  unsigned long int return_value_strlen$15;
  return_value_strlen$15=strlen(hmmfile);
  void *return_value_sre_malloc$16;
  return_value_sre_malloc$16=sre_malloc("hmmcalibrate.c", 254, return_value_strlen$15 + (unsigned long int)5);
  tmpfile = (char *)return_value_sre_malloc$16;
  strcpy(tmpfile, hmmfile);
  strcat(tmpfile, ".xxx");
  signed int return_value_FileExists$17;
  return_value_FileExists$17=FileExists(tmpfile);
  if(!(return_value_FileExists$17 == 0))
    Die("temporary file %s already exists; please delete it first", tmpfile);

  if(!(hmmfp->is_binary == 0))
    mode = "wb";

  else
    mode = "w";
  HMMERBanner(stdout, banner);
  printf("HMM file:                 %s\n", hmmfile);
  if(!(fixedlen == 0))
    printf("Length fixed to:          %d\n", fixedlen);

  else
  {
    printf("Length distribution mean: %.0f\n", lenmean);
    printf("Length distribution s.d.: %.0f\n", lensd);
  }
  printf("Number of samples:        %d\n", nsample);
  printf("random seed:              %d\n", seed);
  printf("histogram(s) saved to:    %s\n", histfile != (char *)(void *)0 ? histfile : "[not saved]");
  if(!(do_pvm == 0))
    printf("PVM:                      ACTIVE\n");

  else
    if(num_threads >= 1)
      printf("POSIX threads:            %d\n", num_threads);

  printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n");
  nhmm = 0;
  void *return_value_sre_malloc$18;
  return_value_sre_malloc$18=sre_malloc("hmmcalibrate.c", 293, sizeof(float) /*4ul*/  * (unsigned long int)mu_lumpsize);
  mu = (float *)return_value_sre_malloc$18;
  void *return_value_sre_malloc$19;
  return_value_sre_malloc$19=sre_malloc("hmmcalibrate.c", 294, sizeof(float) /*4ul*/  * (unsigned long int)mu_lumpsize);
  lambda = (float *)return_value_sre_malloc$19;
  signed int return_value_HMMFileRead$20;
  do
  {
    return_value_HMMFileRead$20=HMMFileRead(hmmfp, &hmm);
    if(return_value_HMMFileRead$20 == 0)
      break;

    if(hmm == ((struct plan7_s *)NULL))
      Die("HMM file may be corrupt or in incorrect format; parse failed");

    if(do_pvm == 0 && num_threads == 0)
      main_loop_serial(hmm, seed, nsample, lenmean, lensd, fixedlen, &hist, &max);

    else
      if(!(do_pvm == 0))
      {
        pvm_nslaves = 0;
        main_loop_pvm(hmm, seed, nsample, pvm_lumpsize, lenmean, lensd, fixedlen, &hist, &max, &extrawatch, &pvm_nslaves);
      }

      else
        if(num_threads >= 1)
          main_loop_threaded(hmm, seed, nsample, lenmean, lensd, fixedlen, num_threads, &hist, &max, &extrawatch);

        else
          Die("wait. that can't happen. I didn't do anything.");
    signed int return_value_ExtremeValueFitHistogram$21;
    return_value_ExtremeValueFitHistogram$21=ExtremeValueFitHistogram(hist, 1, (float)9999.);
    if(return_value_ExtremeValueFitHistogram$21 == 0)
      Die("fit failed; --num may be set too small?\n");

    mu[(signed long int)nhmm] = hist->param[(signed long int)0];
    lambda[(signed long int)nhmm] = hist->param[(signed long int)1];
    nhmm = nhmm + 1;
    if(nhmm % 100 == 0)
    {
      void *return_value_sre_realloc$22;
      return_value_sre_realloc$22=sre_realloc("hmmcalibrate.c", 333, (void *)mu, sizeof(float) /*4ul*/  * (unsigned long int)(nhmm + mu_lumpsize));
      mu = (float *)return_value_sre_realloc$22;
      void *return_value_sre_realloc$23;
      return_value_sre_realloc$23=sre_realloc("hmmcalibrate.c", 334, (void *)lambda, sizeof(float) /*4ul*/  * (unsigned long int)(nhmm + mu_lumpsize));
      lambda = (float *)return_value_sre_realloc$23;
    }

    printf("HMM    : %s\n", hmm->name);
    printf("mu     : %12f\n", hist->param[(signed long int)0]);
    printf("lambda : %12f\n", hist->param[(signed long int)1]);
    printf("max    : %12f\n", max);
    printf("//\n");
    if(!(hfp == ((struct _IO_FILE *)NULL)))
    {
      fprintf(hfp, "HMM: %s\n", hmm->name);
      PrintASCIIHistogram(hfp, hist);
      fprintf(hfp, "//\n");
    }

    FreeHistogram(hist);
    FreePlan7(hmm);
  }
  while((_Bool)1);
  HMMFileRewind(hmmfp);
  signed int return_value_FileExists$24;
  return_value_FileExists$24=FileExists(tmpfile);
  if(!(return_value_FileExists$24 == 0))
    Die("Ouch. Temporary file %s appeared during the run.", tmpfile);

  outfp=fopen(tmpfile, mode);
  if(outfp == ((struct _IO_FILE *)NULL))
    Die("Ouch. Temporary file %s couldn't be opened for writing.", tmpfile);

  idx = 0;
  for( ; !(idx >= nhmm); idx = idx + 1)
  {
    signed int return_value_HMMFileRead$25;
    return_value_HMMFileRead$25=HMMFileRead(hmmfp, &hmm);
    if(return_value_HMMFileRead$25 == 0)
      Die("Ran out of HMMs too early in pass 2");

    if(hmm == ((struct plan7_s *)NULL))
      Die("HMM file %s was corrupted? Parse failed in pass 2", hmmfile);

    hmm->mu = mu[(signed long int)idx];
    hmm->lambda = lambda[(signed long int)idx];
    hmm->flags = hmm->flags | 1 << 7;
    Plan7ComlogAppend(hmm, argc, argv);
    if(!(hmmfp->is_binary == 0))
      WriteBinHMM(outfp, hmm);

    else
      WriteAscHMM(outfp, hmm);
    FreePlan7(hmm);
  }
  HMMFileClose(hmmfp);
  signed int return_value_fclose$26;
  return_value_fclose$26=fclose(outfp);
  if(!(return_value_fclose$26 == 0))
    Panic("hmmcalibrate.c", 400);

  signed int return_value_sigemptyset$27;
  return_value_sigemptyset$27=sigemptyset(&blocksigs);
  if(!(return_value_sigemptyset$27 == 0))
    Panic("hmmcalibrate.c", 402);

  signed int return_value_sigaddset$28;
  return_value_sigaddset$28=sigaddset(&blocksigs, 2);
  if(!(return_value_sigaddset$28 == 0))
    Panic("hmmcalibrate.c", 403);

  signed int return_value_sigprocmask$29;
  return_value_sigprocmask$29=sigprocmask(0, &blocksigs, (struct anonymous$3 *)(void *)0);
  if(!(return_value_sigprocmask$29 == 0))
    Panic("hmmcalibrate.c", 404);

  signed int return_value_remove$30;
  return_value_remove$30=remove(hmmfile);
  if(!(return_value_remove$30 == 0))
    Panic("hmmcalibrate.c", 405);

  signed int return_value_rename$31;
  return_value_rename$31=rename(tmpfile, hmmfile);
  if(!(return_value_rename$31 == 0))
    Panic("hmmcalibrate.c", 406);

  signed int return_value_sigprocmask$32;
  return_value_sigprocmask$32=sigprocmask(1, &blocksigs, (struct anonymous$3 *)(void *)0);
  if(!(return_value_sigprocmask$32 == 0))
    Panic("hmmcalibrate.c", 407);

  free((void *)tmpfile);
  StopwatchStop(&stopwatch);
  if(do_pvm >= 1)
  {
    printf("PVM processors used: %d\n", pvm_nslaves);
    StopwatchInclude(&stopwatch, &extrawatch);
  }

  free((void *)mu);
  free((void *)lambda);
  if(!(hfp == ((struct _IO_FILE *)NULL)))
    fclose(hfp);

  SqdClean();
  return 0;
}

// main_loop_pvm
// file hmmcalibrate.c line 816
static void main_loop_pvm(struct plan7_s *hmm, signed int seed, signed int nsample, signed int lumpsize, float lenmean, float lensd, signed int fixedlen, struct histogram_s **ret_hist, float *ret_max, struct stopwatch_s *extrawatch, signed int *ret_nslaves)
{
  struct histogram_s *hist;
  signed int master_tid;
  signed int *slave_tid;
  signed int nslaves;
  signed int nsent;
  signed int ndone;
  signed int packet;
  float max;
  signed int slaveidx;
  float *sc;
  struct stopwatch_s slavewatch;
  signed int i;
  StopwatchZero(extrawatch);
  hist=AllocHistogram(-200, 200, 100);
  max = -3.40282346638528859812e+38F;
  master_tid=pvm_mytid();
  if(!(master_tid >= 0))
    Die("pvmd not responding -- do you have PVM running?");

  PVMSpawnSlaves("hmmcalibrate-pvm", &slave_tid, &nslaves);
  pvm_initsend(0);
  pvm_pkfloat(&lenmean, 1, 1);
  pvm_pkfloat(&lensd, 1, 1);
  pvm_pkint(&fixedlen, 1, 1);
  pvm_pkint(&Alphabet_type, 1, 1);
  pvm_pkint(&seed, 1, 1);
  signed int return_value_PVMPackHMM$1;
  return_value_PVMPackHMM$1=PVMPackHMM(hmm);
  if(return_value_PVMPackHMM$1 == 0)
    Die("Failed to pack the HMM");

  pvm_mcast(slave_tid, nslaves, 0);
  PVMConfirmSlaves(slave_tid, nslaves);
  ndone = 0;
  nsent = ndone;
  slaveidx = 0;
  for( ; !(slaveidx >= nslaves); slaveidx = slaveidx + 1)
  {
    packet = nsample - nsent > lumpsize ? lumpsize : nsample - nsent;
    pvm_initsend(0);
    pvm_pkint(&packet, 1, 1);
    pvm_pkint(&slaveidx, 1, 1);
    pvm_send(slave_tid[(signed long int)slaveidx], 1);
    nsent = nsent + packet;
  }
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("hmmcalibrate.c", 881, sizeof(float) /*4ul*/  * (unsigned long int)lumpsize);
  sc = (float *)return_value_sre_malloc$2;
  for( ; !(nsent >= nsample); nsent = nsent + packet)
  {
    PVMCheckSlaves(slave_tid, nslaves);
    pvm_recv(-1, 2);
    pvm_upkint(&slaveidx, 1, 1);
    pvm_upkint(&packet, 1, 1);
    pvm_upkfloat(sc, packet, 1);
    ndone = ndone + packet;
    i = 0;
    for( ; !(i >= packet); i = i + 1)
    {
      AddToHistogram(hist, sc[(signed long int)i]);
      if(sc[(signed long int)i] > max)
        max = sc[(signed long int)i];

    }
    packet = nsample - nsent > lumpsize ? lumpsize : nsample - nsent;
    pvm_initsend(0);
    pvm_pkint(&packet, 1, 1);
    pvm_pkint(&slaveidx, 1, 1);
    pvm_send(slave_tid[(signed long int)slaveidx], 1);
  }
  while(!(ndone >= nsample))
  {
    PVMCheckSlaves(slave_tid, nslaves);
    pvm_recv(-1, 2);
    pvm_upkint(&slaveidx, 1, 1);
    pvm_upkint(&packet, 1, 1);
    pvm_upkfloat(sc, packet, 1);
    ndone = ndone + packet;
    i = 0;
    for( ; !(i >= packet); i = i + 1)
    {
      AddToHistogram(hist, sc[(signed long int)i]);
      if(sc[(signed long int)i] > max)
        max = sc[(signed long int)i];

    }
  }
  pvm_initsend(0);
  packet = -1;
  pvm_pkint(&packet, 1, 1);
  pvm_pkint(&packet, 1, 1);
  pvm_pkint(&packet, 1, 1);
  pvm_mcast(slave_tid, nslaves, 1);
  i = 0;
  for( ; !(i >= nslaves); i = i + 1)
  {
    pvm_recv(-1, 2);
    pvm_upkint(&slaveidx, 1, 1);
    StopwatchPVMUnpack(&slavewatch);
    StopwatchInclude(extrawatch, &slavewatch);
  }
  free((void *)slave_tid);
  free((void *)sc);
  pvm_exit();
  *ret_hist = hist;
  *ret_max = max;
  *ret_nslaves = nslaves;
  goto __CPROVER_DUMP_L16;

__CPROVER_DUMP_L16:
  ;
}

// main_loop_serial
// file hmmcalibrate.c line 454
static void main_loop_serial(struct plan7_s *hmm, signed int seed, signed int nsample, float lenmean, float lensd, signed int fixedlen, struct histogram_s **ret_hist, float *ret_max)
{
  struct histogram_s *hist;
  struct dpmatrix_s *mx;
  float randomseq[20l];
  float p1;
  float max;
  char *seq;
  unsigned char *dsq;
  float score;
  signed int sqlen;
  signed int idx;
  sre_srandom(seed);
  P7Logoddsify(hmm, 1);
  P7DefaultNullModel(randomseq, &p1);
  hist=AllocHistogram(-200, 200, 100);
  mx=CreatePlan7Matrix(1, hmm->M, 25, 0);
  max = -3.40282346638528859812e+38F;
  idx = 0;
  double return_value_Gaussrandom$1;
  for( ; !(idx >= nsample); idx = idx + 1)
  {
    if(!(fixedlen == 0))
      sqlen = fixedlen;

    else
      do
      {
        return_value_Gaussrandom$1=Gaussrandom((double)lenmean, (double)lensd);
        sqlen = (signed int)return_value_Gaussrandom$1;
      }
      while(!(sqlen >= 1));
    seq=RandomSequence(Alphabet, randomseq, Alphabet_size, sqlen);
    dsq=DigitizeSequence(seq, sqlen);
    signed int return_value_P7ViterbiSpaceOK$2;
    return_value_P7ViterbiSpaceOK$2=P7ViterbiSpaceOK(sqlen, hmm->M, mx);
    if(!(return_value_P7ViterbiSpaceOK$2 == 0))
      score=P7Viterbi(dsq, sqlen, hmm, mx, (struct p7trace_s **)(void *)0);

    else
      score=P7SmallViterbi(dsq, sqlen, hmm, mx, (struct p7trace_s **)(void *)0);
    AddToHistogram(hist, score);
    if(score > max)
      max = score;

    free((void *)dsq);
    free((void *)seq);
  }
  FreePlan7Matrix(mx);
  *ret_hist = hist;
  *ret_max = max;
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// main_loop_threaded
// file hmmcalibrate.c line 531
static void main_loop_threaded(struct plan7_s *hmm, signed int seed, signed int nsample, float lenmean, float lensd, signed int fixedlen, signed int nthreads, struct histogram_s **ret_hist, float *ret_max, struct stopwatch_s *twatch)
{
  struct histogram_s *hist;
  float randomseq[20l];
  float p1;
  struct workpool_s *wpool;
  sre_srandom(seed);
  P7Logoddsify(hmm, 1);
  P7DefaultNullModel(randomseq, &p1);
  hist=AllocHistogram(-200, 200, 100);
  wpool=workpool_start(hmm, lenmean, lensd, fixedlen, randomseq, nsample, hist, nthreads);
  workpool_stop(wpool);
  *ret_hist = hist;
  *ret_max = wpool->max_score;
  StopwatchInclude(twatch, &wpool->watch);
  workpool_free(wpool);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// make_alilist
// file aligneval.c line 170
static signed int make_alilist(char *s1, char *s2, signed int **ret_s1_list, signed int *ret_listlen)
{
  signed int *s1_list;
  signed int col;
  signed int r1;
  signed int r2;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s1);
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("aligneval.c", 179, sizeof(signed int) /*4ul*/  * return_value_strlen$1);
  s1_list = (signed int *)return_value_sre_malloc$2;
  r2 = 0;
  r1 = r2;
  col = 0;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  for( ; !((signed int)s1[(signed long int)col] == 0); col = col + 1)
  {
    if((signed int)s1[(signed long int)col] == 32)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)s1[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = (signed int)s1[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
      tmp_if_expr$9 = (_Bool)1;

    else
      tmp_if_expr$9 = (signed int)s1[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$9)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = (signed int)s1[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$10)
    {
      if((signed int)s2[(signed long int)col] == 32)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)s2[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)s2[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)s2[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)s2[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
      s1_list[(signed long int)r1] = tmp_if_expr$6 ? -1 : r2;
      r1 = r1 + 1;
    }

    if((signed int)s2[(signed long int)col] == 32)
      tmp_if_expr$11 = (_Bool)1;

    else
      tmp_if_expr$11 = (signed int)s2[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$11)
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = (signed int)s2[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
      tmp_if_expr$13 = (_Bool)1;

    else
      tmp_if_expr$13 = (signed int)s2[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$13)
      tmp_if_expr$14 = (_Bool)1;

    else
      tmp_if_expr$14 = (signed int)s2[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$14)
      r2 = r2 + 1;

  }
  *ret_listlen = r1;
  *ret_s1_list = s1_list;
  return 1;
}

// make_ref_alilist
// file aligneval.c line 224
static signed int make_ref_alilist(signed int *ref, char *k1, char *k2, char *s1, char *s2, signed int **ret_s1_list, signed int *ret_listlen)
{
  signed int *s1_list;
  signed int col;
  signed int r1;
  signed int r2;
  signed int *canons1;
  signed int lpos;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s1);
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("aligneval.c", 236, sizeof(signed int) /*4ul*/  * return_value_strlen$1);
  s1_list = (signed int *)return_value_sre_malloc$2;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(s1);
  void *return_value_sre_malloc$4;
  return_value_sre_malloc$4=sre_malloc("aligneval.c", 237, sizeof(signed int) /*4ul*/  * return_value_strlen$3);
  canons1 = (signed int *)return_value_sre_malloc$4;
  r1 = 0;
  col = 0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  for( ; !((signed int)k1[(signed long int)col] == 0); col = col + 1)
  {
    if((signed int)k1[(signed long int)col] == 32)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)k1[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)k1[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)k1[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = (signed int)k1[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$8)
    {
      canons1[(signed long int)r1] = ref[(signed long int)col] != 0 ? 1 : 0;
      r1 = r1 + 1;
    }

  }
  lpos = 0;
  r2 = lpos;
  r1 = r2;
  col = 0;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$24;
  for( ; !((signed int)s1[(signed long int)col] == 0); col = col + 1)
  {
    if((signed int)s1[(signed long int)col] == 32)
      tmp_if_expr$13 = (_Bool)1;

    else
      tmp_if_expr$13 = (signed int)s1[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$13)
      tmp_if_expr$14 = (_Bool)1;

    else
      tmp_if_expr$14 = (signed int)s1[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$14)
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = (signed int)s1[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
      tmp_if_expr$16 = (_Bool)1;

    else
      tmp_if_expr$16 = (signed int)s1[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$16)
    {
      if(!(canons1[(signed long int)r1] == 0))
      {
        if((signed int)s2[(signed long int)col] == 32)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = (signed int)s2[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
          tmp_if_expr$10 = (_Bool)1;

        else
          tmp_if_expr$10 = (signed int)s2[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$10)
          tmp_if_expr$11 = (_Bool)1;

        else
          tmp_if_expr$11 = (signed int)s2[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$11)
          tmp_if_expr$12 = (_Bool)1;

        else
          tmp_if_expr$12 = (signed int)s2[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
        s1_list[(signed long int)lpos] = tmp_if_expr$12 ? -1 : r2;
        lpos = lpos + 1;
      }

    }

    if((signed int)s1[(signed long int)col] == 32)
      tmp_if_expr$17 = (_Bool)1;

    else
      tmp_if_expr$17 = (signed int)s1[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$17)
      tmp_if_expr$18 = (_Bool)1;

    else
      tmp_if_expr$18 = (signed int)s1[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$18)
      tmp_if_expr$19 = (_Bool)1;

    else
      tmp_if_expr$19 = (signed int)s1[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$19)
      tmp_if_expr$20 = (_Bool)1;

    else
      tmp_if_expr$20 = (signed int)s1[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$20)
      r1 = r1 + 1;

    if((signed int)s2[(signed long int)col] == 32)
      tmp_if_expr$21 = (_Bool)1;

    else
      tmp_if_expr$21 = (signed int)s2[(signed long int)col] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$21)
      tmp_if_expr$22 = (_Bool)1;

    else
      tmp_if_expr$22 = (signed int)s2[(signed long int)col] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$22)
      tmp_if_expr$23 = (_Bool)1;

    else
      tmp_if_expr$23 = (signed int)s2[(signed long int)col] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$23)
      tmp_if_expr$24 = (_Bool)1;

    else
      tmp_if_expr$24 = (signed int)s2[(signed long int)col] == 126 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$24)
      r2 = r2 + 1;

  }
  free((void *)canons1);
  *ret_listlen = lpos;
  *ret_s1_list = s1_list;
  return 1;
}

// matassign2hmm
// file modelmakers.c line 512
static void matassign2hmm(struct msa_struct *msa, unsigned char **dsq, signed int *matassign, struct plan7_s **ret_hmm, struct p7trace_s ***ret_tr)
{
  struct plan7_s *hmm;
  struct p7trace_s **tr;
  signed int M;
  signed int idx;
  signed int apos;
  M = 0;
  apos = 1;
  for( ; msa->alen >= apos; apos = apos + 1)
    if(!((1 & matassign[(signed long int)apos]) == 0))
      M = M + 1;

  if(M == 0)
    Die("No conserved consensus columns found; aborting construction!\nThis is an unusual situation. Reexamine your sequence alignment. It is\nprobably unusually full of gaps, or lots of sequence fragments. You may be\nable to force HMMER to model it; see the --fast (and --gapmax), or --hand\noptions to hmmbuild.");

  apos = 1;
  _Bool tmp_if_expr$1;
  do
  {
    if(!((8 & matassign[(signed long int)apos]) == 0))
      tmp_if_expr$1 = apos <= msa->alen ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    matassign[(signed long int)apos] = matassign[(signed long int)apos] | 1 << 4;
    apos = apos + 1;
  }
  while((_Bool)1);
  if(msa->alen >= apos)
    matassign[(signed long int)apos] = matassign[(signed long int)apos] | 1 << 1;

  apos = msa->alen;
  for( ; apos >= 1 && !((8 & matassign[(signed long int)apos]) == 0); apos = apos - 1)
    matassign[(signed long int)apos] = matassign[(signed long int)apos] | 1 << 5;
  if(apos >= 1)
    matassign[(signed long int)apos] = matassign[(signed long int)apos] | 1 << 2;

  fake_tracebacks(msa->aseq, msa->nseq, msa->alen, matassign, &tr);
  hmm=AllocPlan7(M);
  ZeroPlan7(hmm);
  idx = 0;
  for( ; !(idx >= msa->nseq); idx = idx + 1)
    P7TraceCount(hmm, dsq[(signed long int)idx], msa->wgt[(signed long int)idx], tr[(signed long int)idx]);
  annotate_model(hmm, matassign, msa);
  if(!(msa->rf == ((char *)NULL)))
    free((void *)msa->rf);

  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("modelmakers.c", 564, sizeof(char) /*1ul*/  * (unsigned long int)(msa->alen + 1));
  msa->rf = (char *)return_value_sre_malloc$2;
  apos = 0;
  for( ; !(apos >= msa->alen); apos = apos + 1)
    msa->rf[(signed long int)apos] = (char)((matassign[(signed long int)(apos + 1)] & 1 << 0) != 0 ? 120 : 46);
  msa->rf[(signed long int)msa->alen] = (char)0;
  if(!(ret_tr == ((struct p7trace_s ***)NULL)))
    *ret_tr = tr;

  else
  {
    idx = 0;
    for( ; !(idx >= msa->nseq); idx = idx + 1)
      P7FreeTrace(tr[(signed long int)idx]);
    free((void *)tr);
  }
  if(!(ret_hmm == ((struct plan7_s **)NULL)))
    *ret_hmm = hmm;

  else
    FreePlan7(hmm);
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L24:
  ;
}

// multiline
// file hmmio.c line 1402
static void multiline(struct _IO_FILE *fp, char *pfx, char *s)
{
  char *buf;
  char *sptr;
  if(!(s == ((char *)NULL)))
  {
    buf=Strdup(s);
    sptr=strtok(buf, "\n");
    while(!(sptr == ((char *)NULL)))
    {
      fprintf(fp, "%s%s\n", pfx, sptr);
      sptr=strtok((char *)(void *)0, "\n");
    }
    free((void *)buf);
  }

}

// parse_comment
// file stockholm.c line 595
static signed int parse_comment(struct msa_struct *msa, char *buf)
{
  char *s;
  char *comment;
  s = buf + (signed long int)1;
  if((signed int)*s == 10)
  {
    *s = (char)0;
    comment = s;
  }

  else
  {
    comment=sre_strtok(&s, "\n", (signed int *)(void *)0);
    if(comment == ((char *)NULL))
      return 0;

  }
  MSAAddComment(msa, comment);
  return 1;
}

// parse_gc
// file stockholm.c line 507
static signed int parse_gc(struct msa_struct *msa, char *buf)
{
  char *gc;
  char *featurename;
  char *text;
  char *s;
  signed int len;
  s = buf;
  gc=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(gc == ((char *)NULL))
    return 0;

  else
  {
    featurename=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
    if(featurename == ((char *)NULL))
      return 0;

    else
    {
      text=sre_strtok(&s, " \t\n", &len);
      if(text == ((char *)NULL))
        return 0;

      else
      {
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp(featurename, "SS_cons");
        if(return_value_strcmp$3 == 0)
          sre_strcat(&msa->ss_cons, -1, text, len);

        else
        {
          return_value_strcmp$2=strcmp(featurename, "SA_cons");
          if(return_value_strcmp$2 == 0)
            sre_strcat(&msa->sa_cons, -1, text, len);

          else
          {
            return_value_strcmp$1=strcmp(featurename, "RF");
            if(return_value_strcmp$1 == 0)
              sre_strcat(&msa->rf, -1, text, len);

            else
              MSAAppendGC(msa, featurename, text);
          }
        }
        return 1;
      }
    }
  }
}

// parse_gf
// file stockholm.c line 399
static signed int parse_gf(struct msa_struct *msa, char *buf)
{
  char *gf;
  char *featurename;
  char *text;
  char *s = buf;
  gf=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  if(gf == ((char *)NULL))
    return 0;

  else
  {
    featurename=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
    if(featurename == ((char *)NULL))
      return 0;

    else
    {
      text=sre_strtok(&s, "\n", (signed int *)(void *)0);
      if(text == ((char *)NULL))
        return 0;

      else
      {
        for( ; !(*text == 0); text = text + 1l)
          if(!((signed int)*text == 32))
          {
            if(!((signed int)*text == 9))
              break;

          }

        signed int return_value_strcmp$13;
        return_value_strcmp$13=strcmp(featurename, "ID");
        if(return_value_strcmp$13 == 0)
          msa->name=sre_strdup(text, -1);

        else
        {
          return_value_strcmp$12=strcmp(featurename, "AC");
          if(return_value_strcmp$12 == 0)
            msa->acc=sre_strdup(text, -1);

          else
          {
            return_value_strcmp$11=strcmp(featurename, "DE");
            if(return_value_strcmp$11 == 0)
              msa->desc=sre_strdup(text, -1);

            else
            {
              return_value_strcmp$10=strcmp(featurename, "AU");
              if(return_value_strcmp$10 == 0)
                msa->au=sre_strdup(text, -1);

              else
              {
                return_value_strcmp$9=strcmp(featurename, "GA");
                if(return_value_strcmp$9 == 0)
                {
                  s = text;
                  text=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
                  if(text == ((char *)NULL))
                    return 0;

                  double return_value_atof$1;
                  return_value_atof$1=atof(text);
                  msa->cutoff[(signed long int)2] = (float)return_value_atof$1;
                  msa->cutoff_is_set[(signed long int)2] = 1;
                  text=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
                  if(!(text == ((char *)NULL)))
                  {
                    double return_value_atof$2;
                    return_value_atof$2=atof(text);
                    msa->cutoff[(signed long int)3] = (float)return_value_atof$2;
                    msa->cutoff_is_set[(signed long int)3] = 1;
                  }

                }

                else
                {
                  return_value_strcmp$8=strcmp(featurename, "NC");
                  if(return_value_strcmp$8 == 0)
                  {
                    s = text;
                    text=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
                    if(text == ((char *)NULL))
                      return 0;

                    double return_value_atof$3;
                    return_value_atof$3=atof(text);
                    msa->cutoff[(signed long int)4] = (float)return_value_atof$3;
                    msa->cutoff_is_set[(signed long int)4] = 1;
                    text=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
                    if(!(text == ((char *)NULL)))
                    {
                      double return_value_atof$4;
                      return_value_atof$4=atof(text);
                      msa->cutoff[(signed long int)5] = (float)return_value_atof$4;
                      msa->cutoff_is_set[(signed long int)5] = 1;
                    }

                  }

                  else
                  {
                    return_value_strcmp$7=strcmp(featurename, "TC");
                    if(return_value_strcmp$7 == 0)
                    {
                      s = text;
                      text=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
                      if(text == ((char *)NULL))
                        return 0;

                      double return_value_atof$5;
                      return_value_atof$5=atof(text);
                      msa->cutoff[(signed long int)0] = (float)return_value_atof$5;
                      msa->cutoff_is_set[(signed long int)0] = 1;
                      text=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
                      if(!(text == ((char *)NULL)))
                      {
                        double return_value_atof$6;
                        return_value_atof$6=atof(text);
                        msa->cutoff[(signed long int)1] = (float)return_value_atof$6;
                        msa->cutoff_is_set[(signed long int)1] = 1;
                      }

                    }

                    else
                      MSAAddGF(msa, featurename, text);
                  }
                }
              }
            }
          }
        }
        return 1;
      }
    }
  }
}

// parse_gr
// file stockholm.c line 536
static signed int parse_gr(struct msa_struct *msa, char *buf)
{
  char *gr;
  char *seqname;
  char *featurename;
  char *text;
  signed int seqidx;
  signed int len;
  signed int j;
  char *s = buf;
  gr=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
  signed int return_value_strcmp$5;
  if(gr == ((char *)NULL))
    return 0;

  else
  {
    seqname=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
    if(seqname == ((char *)NULL))
      return 0;

    else
    {
      featurename=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
      if(featurename == ((char *)NULL))
        return 0;

      else
      {
        text=sre_strtok(&s, " \t\n", &len);
        if(text == ((char *)NULL))
          return 0;

        else
        {
          seqidx=MSAGetSeqidx(msa, seqname, msa->lastidx);
          msa->lastidx = seqidx;
          signed int return_value_strcmp$6;
          return_value_strcmp$6=strcmp(featurename, "SS");
          if(return_value_strcmp$6 == 0)
          {
            if(msa->ss == ((char **)NULL))
            {
              void *return_value_sre_malloc$1;
              return_value_sre_malloc$1=sre_malloc("stockholm.c", 561, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
              msa->ss = (char **)return_value_sre_malloc$1;
              void *return_value_sre_malloc$2;
              return_value_sre_malloc$2=sre_malloc("stockholm.c", 562, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseqalloc);
              msa->sslen = (signed int *)return_value_sre_malloc$2;
              j = 0;
              for( ; !(j >= msa->nseqalloc); j = j + 1)
              {
                msa->ss[(signed long int)j] = (char *)(void *)0;
                msa->sslen[(signed long int)j] = 0;
              }
            }

            msa->sslen[(signed long int)seqidx]=sre_strcat(&msa->ss[(signed long int)seqidx], msa->sslen[(signed long int)seqidx], text, len);
          }

          else
          {
            return_value_strcmp$5=strcmp(featurename, "SA");
            if(return_value_strcmp$5 == 0)
            {
              if(msa->sa == ((char **)NULL))
              {
                void *return_value_sre_malloc$3;
                return_value_sre_malloc$3=sre_malloc("stockholm.c", 575, sizeof(char *) /*8ul*/  * (unsigned long int)msa->nseqalloc);
                msa->sa = (char **)return_value_sre_malloc$3;
                void *return_value_sre_malloc$4;
                return_value_sre_malloc$4=sre_malloc("stockholm.c", 576, sizeof(signed int) /*4ul*/  * (unsigned long int)msa->nseqalloc);
                msa->salen = (signed int *)return_value_sre_malloc$4;
                j = 0;
                for( ; !(j >= msa->nseqalloc); j = j + 1)
                {
                  msa->sa[(signed long int)j] = (char *)(void *)0;
                  msa->salen[(signed long int)j] = 0;
                }
              }

              msa->salen[(signed long int)seqidx]=sre_strcat(&msa->sa[(signed long int)seqidx], msa->salen[(signed long int)seqidx], text, len);
            }

            else
              MSAAppendGR(msa, featurename, seqidx, text);
          }
          return 1;
        }
      }
    }
  }
}

// parse_gs
// file stockholm.c line 464
static signed int parse_gs(struct msa_struct *msa, char *buf)
{
  char *gs;
  char *seqname;
  char *featurename;
  char *text;
  signed int seqidx;
  char *s = buf;
  gs=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  if(gs == ((char *)NULL))
    return 0;

  else
  {
    seqname=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
    if(seqname == ((char *)NULL))
      return 0;

    else
    {
      featurename=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
      if(featurename == ((char *)NULL))
        return 0;

      else
      {
        text=sre_strtok(&s, "\n", (signed int *)(void *)0);
        if(text == ((char *)NULL))
          return 0;

        else
        {
          for( ; !(*text == 0); text = text + 1l)
            if(!((signed int)*text == 32))
            {
              if(!((signed int)*text == 9))
                break;

            }

          seqidx=MSAGetSeqidx(msa, seqname, msa->lastidx + 1);
          msa->lastidx = seqidx;
          signed int return_value_strcmp$4;
          return_value_strcmp$4=strcmp(featurename, "WT");
          if(return_value_strcmp$4 == 0)
          {
            double return_value_atof$1;
            return_value_atof$1=atof(text);
            msa->wgt[(signed long int)seqidx] = (float)return_value_atof$1;
            msa->flags = msa->flags | 1 << 0;
          }

          else
          {
            return_value_strcmp$3=strcmp(featurename, "AC");
            if(return_value_strcmp$3 == 0)
              MSASetSeqAccession(msa, seqidx, text);

            else
            {
              return_value_strcmp$2=strcmp(featurename, "DE");
              if(return_value_strcmp$2 == 0)
                MSASetSeqDescription(msa, seqidx, text);

              else
                MSAAddGS(msa, featurename, seqidx, text);
            }
          }
          return 1;
        }
      }
    }
  }
}

// parse_pkey_info
// file ssi.c line 1202
static signed int parse_pkey_info(char *buf, char mode, struct ssipkey_s *pkey)
{
  char *s;
  char *tok;
  signed int n;
  s = buf;
  tok=sre_strtok(&s, "\t\n", &n);
  if(tok == ((char *)NULL))
    return 6;

  else
  {
    pkey->key = tok;
    tok=sre_strtok(&s, "\t\n", &n);
    if(tok == ((char *)NULL))
      return 6;

    else
    {
      signed int return_value_atoi$1;
      return_value_atoi$1=atoi(tok);
      pkey->fnum = (unsigned short int)return_value_atoi$1;
      if((signed int)mode == 0)
      {
        tok=sre_strtok(&s, "\t\n", &n);
        if(tok == ((char *)NULL))
          return 6;

        pkey->r_off.mode = mode;
        unsigned long int return_value_strtoul$2;
        return_value_strtoul$2=strtoul(tok, (char ** restrict )(void *)0, 10);
        pkey->r_off.off.i32 = (unsigned int)return_value_strtoul$2;
        tok=sre_strtok(&s, "\t\n", &n);
        if(tok == ((char *)NULL))
          return 6;

        pkey->d_off.mode = mode;
        unsigned long int return_value_strtoul$3;
        return_value_strtoul$3=strtoul(tok, (char ** restrict )(void *)0, 10);
        pkey->d_off.off.i32 = (unsigned int)return_value_strtoul$3;
      }

      else
      {
        tok=sre_strtok(&s, "\t\n", &n);
        if(tok == ((char *)NULL))
          return 6;

        pkey->r_off.mode = mode;
        unsigned long long int return_value_strtoull$4;
        return_value_strtoull$4=strtoull(tok, (char ** restrict )(void *)0, 10);
        pkey->r_off.off.i64 = (unsigned long int)return_value_strtoull$4;
        tok=sre_strtok(&s, "\t\n", &n);
        if(tok == ((char *)NULL))
          return 6;

        pkey->d_off.mode = mode;
        unsigned long long int return_value_strtoull$5;
        return_value_strtoull$5=strtoull(tok, (char ** restrict )(void *)0, 10);
        pkey->d_off.off.i64 = (unsigned long int)return_value_strtoull$5;
      }
      tok=sre_strtok(&s, "\t\n", &n);
      if(tok == ((char *)NULL))
        return 6;

      else
      {
        unsigned long int return_value_strtoul$6;
        return_value_strtoul$6=strtoul(tok, (char ** restrict )(void *)0, 10);
        pkey->len = (unsigned int)return_value_strtoul$6;
        return 0;
      }
    }
  }
}

// parse_sequence
// file stockholm.c line 609
static signed int parse_sequence(struct msa_struct *msa, char *buf)
{
  char *s;
  char *seqname;
  char *text;
  signed int seqidx;
  signed int len;
  s = buf;
  seqname=sre_strtok(&s, " \t\n", (signed int *)(void *)0);
  if(seqname == ((char *)NULL))
    return 0;

  else
  {
    text=sre_strtok(&s, " \t\n", &len);
    if(text == ((char *)NULL))
      return 0;

    else
    {
      seqidx=MSAGetSeqidx(msa, seqname, msa->lastidx + 1);
      msa->lastidx = seqidx;
      msa->sqlen[(signed long int)seqidx]=sre_strcat(&msa->aseq[(signed long int)seqidx], msa->sqlen[(signed long int)seqidx], text, len);
      return 1;
    }
  }
}

// parse_skey_info
// file ssi.c line 1241
static signed int parse_skey_info(char *buf, struct ssiskey_s *skey)
{
  char *s;
  char *tok;
  signed int n;
  s = buf;
  tok=sre_strtok(&s, "\t\n", &n);
  if(tok == ((char *)NULL))
    return 6;

  else
  {
    skey->key = tok;
    tok=sre_strtok(&s, "\t\n", &n);
    if(tok == ((char *)NULL))
      return 6;

    else
    {
      skey->pkey = tok;
      return 0;
    }
  }
}

// pkeysort
// file ssi.c line 854
static signed int pkeysort(const void *k1, const void *k2)
{
  struct ssipkey_s *key1;
  struct ssipkey_s *key2;
  key1 = (struct ssipkey_s *)k1;
  key2 = (struct ssipkey_s *)k2;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(key1->key, key2->key);
  return return_value_strcmp$1;
}

// prob2ascii
// file hmmio.c line 1270
static char * prob2ascii(float p, float null)
{
  if(IEEE_FLOAT_EQUAL((double)p, 0.0))
    return "*";

  else
  {
    signed int return_value_Prob2Score$1;
    return_value_Prob2Score$1=Prob2Score(p, null);
    static char buffer[8l];
    sprintf(buffer, "%6d", return_value_Prob2Score$1);
    return buffer;
  }
}

// readEMBL
// file sqio.c line 903
static void readEMBL(struct ReadSeqVars *V)
{
  char *sptr;
  signed int i;
  signed int return_value_feof$1;
  signed int return_value_strncmp$2;
  do
  {
    return_value_feof$1=feof(V->f);
    if(!(return_value_feof$1 == 0))
      break;

    return_value_strncmp$2=strncmp(V->buf, "ID  ", (unsigned long int)4);
    if(return_value_strncmp$2 == 0)
      break;

    SeqfileGetLine(V);
  }
  while((_Bool)1);
  if(V->ssimode >= 0)
    V->r_off = V->ssioffset;

  sptr=strtok(V->buf + (signed long int)5, "\n\t ");
  if(!(sptr == ((char *)NULL)))
  {
    SetSeqinfoString(V->sqinfo, sptr, 1 << 0);
    SetSeqinfoString(V->sqinfo, sptr, 1 << 1);
  }

  _Bool tmp_if_expr$10;
  char *return_value_strstr$9;
  signed int return_value_feof$7;
  char *return_value_strstr$6;
  signed int return_value_feof$3;
  _Bool tmp_if_expr$5;
  signed int return_value_strncmp$4;
  do
  {
    SeqfileGetLine(V);
    signed int return_value_feof$8;
    return_value_feof$8=feof(V->f);
    if(return_value_feof$8 == 0)
    {
      return_value_strstr$9=strstr(V->buf, "AC  ");
      tmp_if_expr$10 = return_value_strstr$9 == V->buf ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
    {
      sptr=strtok(V->buf + (signed long int)5, ";  \t\n");
      if(!(sptr == ((char *)NULL)))
        SetSeqinfoString(V->sqinfo, sptr, 1 << 2);

    }

    else
    {
      return_value_feof$7=feof(V->f);
      if(return_value_feof$7 == 0)
      {
        return_value_strstr$6=strstr(V->buf, "DE  ");
        if(return_value_strstr$6 == V->buf)
        {
          sptr=strtok(V->buf + (signed long int)5, "\n");
          if(!(sptr == ((char *)NULL)))
            SetSeqinfoString(V->sqinfo, sptr, 1 << 3);

        }

      }

    }
    return_value_feof$3=feof(V->f);
    if(return_value_feof$3 == 0)
    {
      return_value_strncmp$4=strncmp(V->buf, "SQ", (unsigned long int)2);
      tmp_if_expr$5 = return_value_strncmp$4 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
  }
  while(tmp_if_expr$5);
  readLoop(0, endEMBL, V);
  if(V->ssimode == -1)
  {
    i = 0;
    for( ; !(i >= V->seqlen); i = i + 1)
      if((signed int)V->seq[(signed long int)i] == 45)
        V->seq[(signed long int)i] = (char)78;

  }

  V->sqinfo->start = 1;
  V->sqinfo->stop = V->seqlen;
  V->sqinfo->olen = V->seqlen;
  V->sqinfo->flags = V->sqinfo->flags | 1 << 4 | 1 << 5 | 1 << 8;
  signed int return_value_feof$11;
  signed int return_value_strncmp$12;
  do
  {
    return_value_feof$11=feof(V->f);
    if(!(return_value_feof$11 == 0))
      break;

    return_value_strncmp$12=strncmp(V->buf, "ID  ", (unsigned long int)4);
    if(return_value_strncmp$12 == 0)
      break;

    SeqfileGetLine(V);
  }
  while((_Bool)1);
}

// readGCGdata
// file sqio.c line 811
static void readGCGdata(struct ReadSeqVars *V)
{
  signed int binary = 0;
  signed int blen = 0;
  signed int return_value_Strparse$2;
  return_value_Strparse$2=Strparse(">>>>([^ ]+) .+2BIT +Len: ([0-9]+)", V->buf, 2);
  signed int return_value_Strparse$1;
  if(!(return_value_Strparse$2 == 0))
  {
    binary = 1;
    SetSeqinfoString(V->sqinfo, sqd_parse[(signed long int)1], 1 << 0);
    blen=atoi(sqd_parse[(signed long int)2]);
  }

  else
  {
    return_value_Strparse$1=Strparse(">>>>([^ ]+) .+ASCII +Len: [0-9]+", V->buf, 1);
    if(!(return_value_Strparse$1 == 0))
      SetSeqinfoString(V->sqinfo, sqd_parse[(signed long int)1], 1 << 0);

    else
      Die("bogus GCGdata format? %s", V->buf);
  }
  SeqfileGetLine(V);
  SetSeqinfoString(V->sqinfo, V->buf, 1 << 3);
  if(!(binary == 0))
  {
    if(blen >= V->maxseq)
    {
      V->maxseq = blen;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)V->seq, sizeof(char) /*1ul*/  * (unsigned long int)(V->maxseq + 4));
      V->seq = (char *)return_value_realloc$3;
      if(V->seq == ((char *)NULL))
        Die("malloc failed");

    }

    unsigned long int return_value_fread$4;
    return_value_fread$4=fread((void *)V->seq, sizeof(char) /*1ul*/ , (unsigned long int)((blen + 3) / 4), V->f);
    if(!(return_value_fread$4 >= (unsigned long int)((3 + blen) / 4)))
      Die("fread failed");

    V->seqlen = blen;
    GCGBinaryToSequence(V->seq, blen);
  }

  else
    readLoop(0, endGCGdata, V);
  signed int return_value_feof$5;
  do
  {
    return_value_feof$5=feof(V->f);
    if(!(return_value_feof$5 == 0))
      break;

    if(!((signed int)*V->buf == 0))
    {
      if((signed int)*V->buf == 62)
        break;

    }

    SeqfileGetLine(V);
  }
  while((_Bool)1);
}

// readGenBank
// file sqio.c line 735
static void readGenBank(struct ReadSeqVars *V)
{
  char *sptr;
  signed int in_definition;
  signed int return_value_strncmp$1;
  do
  {
    return_value_strncmp$1=strncmp(V->buf, "LOCUS", (unsigned long int)5);
    if(return_value_strncmp$1 == 0)
      break;

    SeqfileGetLine(V);
  }
  while((_Bool)1);
  if(V->ssimode >= 0)
    V->r_off = V->ssioffset;

  sptr=strtok(V->buf + (signed long int)12, "\n\t ");
  if(!(sptr == ((char *)NULL)))
    SetSeqinfoString(V->sqinfo, sptr, 1 << 0);

  in_definition = 0;
  signed int return_value_feof$2;
  _Bool tmp_if_expr$12;
  char *return_value_strstr$11;
  signed int return_value_feof$7;
  _Bool tmp_if_expr$9;
  char *return_value_strstr$8;
  signed int return_value_feof$4;
  _Bool tmp_if_expr$6;
  char *return_value_strstr$5;
  signed int return_value_strncmp$3;
  do
  {
    return_value_feof$2=feof(V->f);
    if(!(return_value_feof$2 == 0))
      break;

    SeqfileGetLine(V);
    signed int return_value_feof$10;
    return_value_feof$10=feof(V->f);
    if(return_value_feof$10 == 0)
    {
      return_value_strstr$11=strstr(V->buf, "DEFINITION");
      tmp_if_expr$12 = return_value_strstr$11 == V->buf ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$12 = (_Bool)0;
    if(tmp_if_expr$12)
    {
      sptr=strtok(V->buf + (signed long int)12, "\n");
      if(!(sptr == ((char *)NULL)))
        SetSeqinfoString(V->sqinfo, sptr, 1 << 3);

      in_definition = 1;
    }

    else
    {
      return_value_feof$7=feof(V->f);
      if(return_value_feof$7 == 0)
      {
        return_value_strstr$8=strstr(V->buf, "ACCESSION");
        tmp_if_expr$9 = return_value_strstr$8 == V->buf ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        sptr=strtok(V->buf + (signed long int)12, "\n\t ");
        if(!(sptr == ((char *)NULL)))
          SetSeqinfoString(V->sqinfo, sptr, 1 << 2);

        in_definition = 0;
      }

      else
      {
        return_value_feof$4=feof(V->f);
        if(return_value_feof$4 == 0)
        {
          return_value_strstr$5=strstr(V->buf, "VERSION");
          tmp_if_expr$6 = return_value_strstr$5 == V->buf ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
        {
          sptr=strtok(V->buf + (signed long int)12, "\n\t ");
          if(!(sptr == ((char *)NULL)))
            SetSeqinfoString(V->sqinfo, sptr, 1 << 1);

          in_definition = 0;
        }

        else
        {
          return_value_strncmp$3=strncmp(V->buf, "ORIGIN", (unsigned long int)6);
          if(!(return_value_strncmp$3 == 0))
          {
            if(!(in_definition == 0))
              SetSeqinfoString(V->sqinfo, V->buf, 1 << 3);

          }

          else
            break;
        }
      }
    }
  }
  while((_Bool)1);
  readLoop(0, endGB, V);
  V->sqinfo->start = 1;
  V->sqinfo->stop = V->seqlen;
  V->sqinfo->olen = V->seqlen;
  V->sqinfo->flags = V->sqinfo->flags | 1 << 4 | 1 << 5 | 1 << 8;
  signed int return_value_feof$13;
  char *return_value_strstr$14;
  do
  {
    return_value_feof$13=feof(V->f);
    if(!(return_value_feof$13 == 0))
      break;

    if(!((signed int)*V->buf == 0))
    {
      return_value_strstr$14=strstr(V->buf, "LOCUS");
      if(return_value_strstr$14 == V->buf)
        break;

    }

    SeqfileGetLine(V);
  }
  while((_Bool)1);
  signed int return_value_feof$15;
  char *return_value_strstr$16;
  do
  {
    return_value_feof$15=feof(V->f);
    if(!(return_value_feof$15 == 0))
      break;

    return_value_strstr$16=strstr(V->buf, "LOCUS  ");
    if(return_value_strstr$16 == V->buf)
      break;

    SeqfileGetLine(V);
  }
  while((_Bool)1);
}

// readIG
// file sqio.c line 675
static void readIG(struct ReadSeqVars *V)
{
  char *nm;
  signed int return_value_feof$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  do
  {
    SeqfileGetLine(V);
    return_value_feof$1=feof(V->f);
    if(!(return_value_feof$1 == 0))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!((signed int)*V->buf == 0))
        tmp_if_expr$2 = (signed int)*V->buf != 59 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
  }
  while(!tmp_if_expr$3);
  signed int return_value_feof$4;
  return_value_feof$4=feof(V->f);
  if(return_value_feof$4 == 0)
  {
    nm=strtok(V->buf, "\n\t ");
    if(!(nm == ((char *)NULL)))
      SetSeqinfoString(V->sqinfo, nm, 1 << 0);

    readLoop(0, endIG, V);
  }

  signed int return_value_feof$5;
  do
  {
    return_value_feof$5=feof(V->f);
    if(!(return_value_feof$5 == 0))
      break;

    if(!((signed int)*V->buf == 0))
    {
      if((signed int)*V->buf == 59)
        break;

    }

    SeqfileGetLine(V);
  }
  while((_Bool)1);
}

// readLoop
// file sqio.c line 584
static void readLoop(signed int addfirst, signed int (*endTest)(char *, signed int *), struct ReadSeqVars *V)
{
  signed int addend = 0;
  signed int done = 0;
  V->seqlen = 0;
  V->lastbpl = 0;
  V->lastrpl = V->lastbpl;
  signed int return_value_SSIGetFilePosition$1;
  if(!(addfirst == 0))
  {
    if(V->ssimode >= 0)
      V->d_off = V->ssioffset;

    addseq(V->buf, V);
  }

  else
    if(V->ssimode >= 0)
    {
      return_value_SSIGetFilePosition$1=SSIGetFilePosition(V->f, V->ssimode, &V->d_off);
      if(!(return_value_SSIGetFilePosition$1 == 0))
        Die("SSIGetFilePosition() failed");

    }

  SeqfileGetLine(V);
  signed int return_value_feof$2;
  if((signed int)*V->buf == 0)
  {
    return_value_feof$2=feof(V->f);
    if(!(return_value_feof$2 == 0))
      done = 1;

  }

  signed int return_value;
  return_value=endTest(V->buf, &addend);
  done = done | return_value;
  if(done == 0 || !(addend == 0))
    addseq(V->buf, V);

}

// readPIR
// file sqio.c line 622
static void readPIR(struct ReadSeqVars *V)
{
  char *sptr;
  signed int return_value_feof$1;
  signed int return_value_strncmp$2;
  do
  {
    return_value_feof$1=feof(V->f);
    if(!(return_value_feof$1 == 0))
      break;

    return_value_strncmp$2=strncmp(V->buf, "ENTRY", (unsigned long int)5);
    if(return_value_strncmp$2 == 0)
      break;

    SeqfileGetLine(V);
  }
  while((_Bool)1);
  signed int return_value_feof$3;
  return_value_feof$3=feof(V->f);
  _Bool tmp_if_expr$11;
  signed int return_value_strncmp$10;
  signed int return_value_feof$8;
  signed int return_value_strncmp$7;
  signed int return_value_feof$4;
  _Bool tmp_if_expr$6;
  signed int return_value_strncmp$5;
  signed int return_value_feof$12;
  signed int return_value_strncmp$13;
  if(return_value_feof$3 == 0)
  {
    if(V->ssimode >= 0)
      V->r_off = V->ssioffset;

    sptr=strtok(V->buf + (signed long int)15, "\n\t ");
    if(!(sptr == ((char *)NULL)))
    {
      SetSeqinfoString(V->sqinfo, sptr, 1 << 0);
      SetSeqinfoString(V->sqinfo, sptr, 1 << 1);
    }

    do
    {
      SeqfileGetLine(V);
      signed int return_value_feof$9;
      return_value_feof$9=feof(V->f);
      if(return_value_feof$9 == 0)
      {
        return_value_strncmp$10=strncmp(V->buf, "TITLE", (unsigned long int)5);
        tmp_if_expr$11 = return_value_strncmp$10 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$11 = (_Bool)0;
      if(tmp_if_expr$11)
        SetSeqinfoString(V->sqinfo, V->buf + (signed long int)15, 1 << 3);

      else
      {
        return_value_feof$8=feof(V->f);
        if(return_value_feof$8 == 0)
        {
          return_value_strncmp$7=strncmp(V->buf, "ACCESSION", (unsigned long int)9);
          if(return_value_strncmp$7 == 0)
          {
            sptr=strtok(V->buf + (signed long int)15, " \t\n");
            if(!(sptr == ((char *)NULL)))
              SetSeqinfoString(V->sqinfo, sptr, 1 << 2);

          }

        }

      }
      return_value_feof$4=feof(V->f);
      if(return_value_feof$4 == 0)
      {
        return_value_strncmp$5=strncmp(V->buf, "SEQUENCE", (unsigned long int)8);
        tmp_if_expr$6 = return_value_strncmp$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
    }
    while(tmp_if_expr$6);
    SeqfileGetLine(V);
    readLoop(0, endPIR, V);
    V->sqinfo->start = 1;
    V->sqinfo->stop = V->seqlen;
    V->sqinfo->olen = V->seqlen;
    V->sqinfo->flags = V->sqinfo->flags | 1 << 4 | 1 << 5 | 1 << 8;
    do
    {
      return_value_feof$12=feof(V->f);
      if(!(return_value_feof$12 == 0))
        break;

      return_value_strncmp$13=strncmp(V->buf, "ENTRY", (unsigned long int)5);
      if(return_value_strncmp$13 == 0)
        break;

      SeqfileGetLine(V);
    }
    while((_Bool)1);
  }

}

// readPearson
// file sqio.c line 860
static void readPearson(struct ReadSeqVars *V)
{
  char *sptr;
  if(V->ssimode >= 0)
    V->r_off = V->ssioffset;

  if(!((signed int)*V->buf == 62))
    Die("File %s does not appear to be in FASTA format at line %d.\nYou may want to specify the file format on the command line.\nUsually this is done with an option --informat <fmt>.\n", V->fname, V->linenumber);

  sptr=strtok(V->buf + (signed long int)1, "\n\t ");
  if(!(sptr == ((char *)NULL)))
    SetSeqinfoString(V->sqinfo, sptr, 1 << 0);

  sptr=strtok((char *)(void *)0, "\n");
  if(!(sptr == ((char *)NULL)))
    SetSeqinfoString(V->sqinfo, sptr, 1 << 3);

  readLoop(0, endPearson, V);
  signed int return_value_feof$1;
  do
  {
    return_value_feof$1=feof(V->f);
    if(!(return_value_feof$1 == 0))
      break;

    if(!((signed int)*V->buf == 0))
    {
      if((signed int)*V->buf == 62)
        break;

    }

    SeqfileGetLine(V);
  }
  while((_Bool)1);
}

// readStrider
// file sqio.c line 703
static void readStrider(struct ReadSeqVars *V)
{
  char *nm;
  signed int return_value_feof$1;
  do
  {
    return_value_feof$1=feof(V->f);
    if(!(return_value_feof$1 == 0))
      break;

    if(!((signed int)*V->buf == 59))
      break;

    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(V->buf, "; DNA sequence", (unsigned long int)14);
    if(return_value_strncmp$2 == 0)
    {
      nm=strtok(V->buf + (signed long int)16, ",\n\t ");
      if(!(nm == ((char *)NULL)))
        SetSeqinfoString(V->sqinfo, nm, 1 << 0);

    }

    SeqfileGetLine(V);
  }
  while((_Bool)1);
  signed int return_value_feof$3;
  return_value_feof$3=feof(V->f);
  if(return_value_feof$3 == 0)
    readLoop(1, endStrider, V);

  signed int return_value_feof$4;
  do
  {
    return_value_feof$4=feof(V->f);
    if(!(return_value_feof$4 == 0))
      break;

    if((signed int)*V->buf == 59)
      break;

    SeqfileGetLine(V);
  }
  while((_Bool)1);
}

// readUWGCG
// file sqio.c line 988
static void readUWGCG(struct ReadSeqVars *V)
{
  char *si;
  char *sptr;
  signed int done;
  V->seqlen = 0;
  si=strstr(V->buf, "  Length: ");
  if(!(si == ((char *)NULL)))
    *si = (char)0;

  else
  {
    si=strstr(V->buf, "..");
    if(!(si == ((char *)NULL)))
      *si = (char)0;

  }
  sptr=strtok(V->buf, "\n\t ");
  if(!(sptr == ((char *)NULL)))
    SetSeqinfoString(V->sqinfo, sptr, 1 << 0);

  do
  {
    done=feof(V->f);
    SeqfileGetLine(V);
    if(done == 0)
      addseq(V->buf, V);

  }
  while(done == 0);
}

// readZuker
// file sqio.c line 969
static void readZuker(struct ReadSeqVars *V)
{
  char *sptr;
  SeqfileGetLine(V);
  sptr=strtok(V->buf + (signed long int)6, " \t\n");
  if(!(sptr == ((char *)NULL)))
    SetSeqinfoString(V->sqinfo, sptr, 1 << 0);

  sptr=strtok((char *)(void *)0, "\n");
  if(!(sptr == ((char *)NULL)))
    SetSeqinfoString(V->sqinfo, sptr, 1 << 3);

  readLoop(0, endZuker, V);
  signed int return_value_feof$1;
  do
  {
    return_value_feof$1=feof(V->f);
    if(!((return_value_feof$1 | (signed int)((signed int)*V->buf == 40 && !((signed int)*V->buf == 0))) == 0))
      break;

    SeqfileGetLine(V);
  }
  while((_Bool)1);
}

// read_asc10hmm
// file hmmio.c line 1227
static signed int read_asc10hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  Die("1.0 ASCII HMMs unsupported");
  return 1;
}

// read_asc11hmm
// file hmmio.c line 1195
static signed int read_asc11hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  Die("1.1 ASCII HMMs unsupported");
  return 1;
}

// read_asc17hmm
// file hmmio.c line 1143
static signed int read_asc17hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  struct plan7_s *hmm;
  struct plan9_s *p9hmm;
  char buffer[512l];
  signed int return_value_feof$1;
  return_value_feof$1=feof(hmmfp->f);
  _Bool tmp_if_expr$3;
  char *return_value_fgets$2;
  if(!(return_value_feof$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_fgets$2=fgets(buffer, 512, hmmfp->f);
    tmp_if_expr$3 = return_value_fgets$2 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return 0;

  else
  {
    p9hmm=read_plan9_aschmm(hmmfp->f, 6);
    if(p9hmm == ((struct plan9_s *)NULL))
    {
      *ret_hmm = (struct plan7_s *)(void *)0;
      return 1;
    }

    else
    {
      Plan9toPlan7(p9hmm, &hmm);
      hmm->comlog=Strdup("[converted from an old Plan9 HMM]");
      Plan7SetCtime(hmm);
      P9FreeHMM(p9hmm);
      Plan7Renormalize(hmm);
      *ret_hmm = hmm;
      return 1;
    }
  }
}

// read_asc19hmm
// file hmmio.c line 967
static signed int read_asc19hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  struct plan7_s *hmm;
  struct _IO_FILE *fp;
  char buffer[512l];
  char *s;
  signed int M;
  signed int k;
  signed int x;
  signed int atype;
  hmm = (struct plan7_s *)(void *)0;
  fp = hmmfp->f;
  signed int return_value_feof$1;
  return_value_feof$1=feof(fp);
  _Bool tmp_if_expr$3;
  char *return_value_fgets$2;
  if(!(return_value_feof$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_fgets$2=fgets(buffer, 512, fp);
    tmp_if_expr$3 = return_value_fgets$2 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  char *return_value_AlphabetType2String$7;
  char *return_value_AlphabetType2String$8;
  signed int return_value_strncmp$9;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$12;
  signed int return_value_feof$13;
  double tmp_if_expr$15;
  float return_value_ascii2prob$14;
  double tmp_if_expr$17;
  float return_value_ascii2prob$16;
  if(tmp_if_expr$3)
    return 0;

  else
  {
    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp(buffer, "HMMER v1.9", (unsigned long int)10);
    if(return_value_strncmp$4 == 0)
    {
      hmm=AllocPlan7Shell();
      s=Getword(fp, 1);
      if(s == ((char *)NULL))
        goto FAILURE;

      M=atoi(s);
      s=Getword(fp, 1);
      if(s == ((char *)NULL))
        goto FAILURE;

      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      Plan7SetName(hmm, s);
      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      s2upper(s);
      return_value_strcmp$6=strcmp(s, "AMINO");
      if(return_value_strcmp$6 == 0)
        atype = 3;

      else
      {
        return_value_strcmp$5=strcmp(s, "NUCLEIC");
        if(return_value_strcmp$5 == 0)
          atype = 2;

        else
          goto FAILURE;
      }
      if(Alphabet_type == 0)
        SetAlphabet(atype);

      else
        if(!(atype == Alphabet_type))
        {
          return_value_AlphabetType2String$7=AlphabetType2String(Alphabet_type);
          return_value_AlphabetType2String$8=AlphabetType2String(atype);
          Die("Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n", return_value_AlphabetType2String$7, return_value_AlphabetType2String$8);
        }

      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      return_value_strncmp$9=strncmp(s, Alphabet, (unsigned long int)Alphabet_size);
      if(!(return_value_strncmp$9 == 0))
        goto FAILURE;

      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      return_value_strcmp$10=strcmp(s, "yes");
      if(return_value_strcmp$10 == 0)
        hmm->flags = hmm->flags | 1 << 2;

      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      return_value_strcmp$11=strcmp(s, "yes");
      if(return_value_strcmp$11 == 0)
        hmm->flags = hmm->flags | 1 << 3;

      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      return_value_strcmp$12=strcmp(s, "null");
      if(!(return_value_strcmp$12 == 0))
        goto FAILURE;

      x = 0;
      for( ; !(x >= Alphabet_size); x = x + 1)
      {
        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        hmm->null[(signed long int)x]=ascii2prob(s, (float)1.0);
      }
      hmm->p1 = (float)(Alphabet_type == 3 ? 350. / 351. : 1000. / 1001.);
      return_value_feof$13=feof(hmmfp->f);
      if(!(return_value_feof$13 == 0))
        goto FAILURE;

      if(!(M >= 1))
        goto FAILURE;

      if(hmm->name == ((char *)NULL))
        goto FAILURE;

      if(Alphabet_type == 0)
        goto FAILURE;

      AllocPlan7Body(hmm, M);
      ZeroPlan7(hmm);
      Plan7LSConfig(hmm);
      s=Getword(fp, 1);
      if(s == ((char *)NULL))
        goto FAILURE;

      x = 0;
      for( ; !(x >= Alphabet_size); x = x + 1)
      {
        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

      }
      s=Getword(fp, 1);
      if(s == ((char *)NULL))
        goto FAILURE;

      hmm->begin[(signed long int)1]=ascii2prob(s, (float)1.0);
      s=Getword(fp, 1);
      if(s == ((char *)NULL))
        goto FAILURE;

      hmm->tbd1=ascii2prob(s, (float)1.0);
      hmm->begin[(signed long int)1] = hmm->begin[(signed long int)1] / (hmm->begin[(signed long int)1] + hmm->tbd1);
      hmm->tbd1 = hmm->tbd1 / (hmm->begin[(signed long int)1] + hmm->tbd1);
      x = 0;
      for( ; !(x >= 7); x = x + 1)
      {
        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

      }
      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      s=Getword(fp, 4);
      if(s == ((char *)NULL))
        goto FAILURE;

      k = 1;
      for( ; hmm->M >= k; k = k + 1)
      {
        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        x = 0;
        for( ; !(x >= Alphabet_size); x = x + 1)
        {
          s=Getword(fp, 1);
          if(s == ((char *)NULL))
            goto FAILURE;

          hmm->mat[(signed long int)k][(signed long int)x]=ascii2prob(s, hmm->null[(signed long int)x]);
        }
        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!(k >= hmm->M))
          hmm->t[(signed long int)k][(signed long int)0]=ascii2prob(s, (float)1.0);

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!(k >= hmm->M))
        {
          if(k == hmm->M)
            tmp_if_expr$15 = 0.0;

          else
          {
            return_value_ascii2prob$14=ascii2prob(s, (float)1.0);
            tmp_if_expr$15 = (double)return_value_ascii2prob$14;
          }
          hmm->t[(signed long int)k][(signed long int)2] = (float)tmp_if_expr$15;
        }

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!(k >= hmm->M))
          hmm->t[(signed long int)k][(signed long int)1]=ascii2prob(s, (float)1.0);

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!(k >= hmm->M))
          hmm->t[(signed long int)k][(signed long int)5]=ascii2prob(s, (float)1.0);

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!(k >= hmm->M))
        {
          if(k == hmm->M)
            tmp_if_expr$17 = 0.0;

          else
          {
            return_value_ascii2prob$16=ascii2prob(s, (float)1.0);
            tmp_if_expr$17 = (double)return_value_ascii2prob$16;
          }
          hmm->t[(signed long int)k][(signed long int)6] = (float)tmp_if_expr$17;
        }

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!(k >= hmm->M))
          hmm->t[(signed long int)k][(signed long int)3]=ascii2prob(s, (float)1.0);

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!(k >= hmm->M))
          hmm->t[(signed long int)k][(signed long int)4]=ascii2prob(s, (float)1.0);

        s=Getword(fp, 4);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!((4 & hmm->flags) == 0))
          hmm->rf[(signed long int)k] = *s;

        s=Getword(fp, 4);
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!((8 & hmm->flags) == 0))
          hmm->cs[(signed long int)k] = *s;

      }
      k = 0;
      for( ; hmm->M >= k; k = k + 1)
      {
        s=Getword(fp, 1);
        if(s == ((char *)NULL))
          goto FAILURE;

        x = 0;
        for( ; !(x >= Alphabet_size); x = x + 1)
        {
          s=Getword(fp, 1);
          if(s == ((char *)NULL))
            goto FAILURE;

          if(k >= 1)
          {
            if(!(k >= hmm->M))
              hmm->ins[(signed long int)k][(signed long int)x]=ascii2prob(s, hmm->null[(signed long int)x]);

          }

        }
      }
      hmm->flags = hmm->flags | 1 << 5;
      hmm->flags = hmm->flags & ~(1 << 0);
      Plan7Renormalize(hmm);
      hmm->comlog=Strdup("[converted from an old Plan9 HMM]");
      Plan7SetCtime(hmm);
      *ret_hmm = hmm;
      return 1;
    }

    else
    {

    FAILURE:
      ;
      if(!(hmm == ((struct plan7_s *)NULL)))
        FreePlan7(hmm);

      *ret_hmm = (struct plan7_s *)(void *)0;
      return 1;
    }
  }
}

// read_asc20hmm
// file hmmio.c line 566
static signed int read_asc20hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  struct plan7_s *hmm;
  char buffer[512l];
  char *s;
  signed int M;
  float p;
  signed int k;
  signed int x;
  signed int atype;
  hmm = (struct plan7_s *)(void *)0;
  signed int return_value_feof$1;
  return_value_feof$1=feof(hmmfp->f);
  _Bool tmp_if_expr$3;
  char *return_value_fgets$2;
  if(!(return_value_feof$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_fgets$2=fgets(buffer, 512, hmmfp->f);
    tmp_if_expr$3 = return_value_fgets$2 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_fgets$5;
  signed int return_value_strncmp$43;
  signed int return_value_strncmp$42;
  signed int return_value_strncmp$41;
  signed int return_value_strncmp$40;
  signed int return_value_strncmp$39;
  signed int return_value_strncmp$6;
  char *return_value_AlphabetType2String$8;
  char *return_value_AlphabetType2String$9;
  signed int return_value_strncmp$38;
  signed int return_value_strncmp$37;
  signed int return_value_strncmp$36;
  signed int return_value_strncmp$35;
  signed int return_value_strncmp$34;
  signed int return_value_strncmp$33;
  signed int return_value_strncmp$32;
  signed int return_value_strncmp$31;
  signed int return_value_strncmp$30;
  signed int return_value_strncmp$29;
  signed int return_value_strncmp$28;
  signed int return_value_strncmp$27;
  signed int return_value_strncmp$26;
  signed int return_value_strncmp$25;
  signed int return_value_feof$45;
  char *return_value_fgets$46;
  char *return_value_fgets$47;
  char *return_value_fgets$52;
  signed int return_value_strncmp$53;
  if(tmp_if_expr$3)
    return 0;

  else
  {
    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp(buffer, "HMMER2.0", (unsigned long int)8);
    if(return_value_strncmp$4 == 0)
    {
      hmm=AllocPlan7Shell();
      M = -1;
      do
      {
        return_value_fgets$5=fgets(buffer, 512, hmmfp->f);
        if(return_value_fgets$5 == ((char *)NULL))
          break;

        signed int return_value_strncmp$44;
        return_value_strncmp$44=strncmp(buffer, "NAME ", (unsigned long int)5);
        if(return_value_strncmp$44 == 0)
          Plan7SetName(hmm, buffer + (signed long int)6);

        else
        {
          return_value_strncmp$43=strncmp(buffer, "ACC  ", (unsigned long int)5);
          if(return_value_strncmp$43 == 0)
            Plan7SetAccession(hmm, buffer + (signed long int)6);

          else
          {
            return_value_strncmp$42=strncmp(buffer, "DESC ", (unsigned long int)5);
            if(return_value_strncmp$42 == 0)
              Plan7SetDescription(hmm, buffer + (signed long int)6);

            else
            {
              return_value_strncmp$41=strncmp(buffer, "LENG ", (unsigned long int)5);
              if(return_value_strncmp$41 == 0)
                M=atoi(buffer + (signed long int)6);

              else
              {
                return_value_strncmp$40=strncmp(buffer, "NSEQ ", (unsigned long int)5);
                if(return_value_strncmp$40 == 0)
                  hmm->nseq=atoi(buffer + (signed long int)6);

                else
                {
                  return_value_strncmp$39=strncmp(buffer, "ALPH ", (unsigned long int)5);
                  if(return_value_strncmp$39 == 0)
                  {
                    s2upper(buffer + (signed long int)6);
                    signed int return_value_strncmp$7;
                    return_value_strncmp$7=strncmp(buffer + (signed long int)6, "AMINO", (unsigned long int)5);
                    if(return_value_strncmp$7 == 0)
                      atype = 3;

                    else
                    {
                      return_value_strncmp$6=strncmp(buffer + (signed long int)6, "NUCLEIC", (unsigned long int)7);
                      if(return_value_strncmp$6 == 0)
                        atype = 2;

                      else
                        goto FAILURE;
                    }
                    if(Alphabet_type == 0)
                      SetAlphabet(atype);

                    else
                      if(!(atype == Alphabet_type))
                      {
                        return_value_AlphabetType2String$8=AlphabetType2String(Alphabet_type);
                        return_value_AlphabetType2String$9=AlphabetType2String(atype);
                        Die("Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n", return_value_AlphabetType2String$8, return_value_AlphabetType2String$9);
                      }

                  }

                  else
                  {
                    return_value_strncmp$38=strncmp(buffer, "RF   ", (unsigned long int)5);
                    if(return_value_strncmp$38 == 0)
                    {
                      signed int return_value_sre_toupper$10;
                      return_value_sre_toupper$10=sre_toupper((signed int)buffer[(signed long int)6]);
                      if(return_value_sre_toupper$10 == 89)
                        hmm->flags = hmm->flags | 1 << 2;

                    }

                    else
                    {
                      return_value_strncmp$37=strncmp(buffer, "CS   ", (unsigned long int)5);
                      if(return_value_strncmp$37 == 0)
                      {
                        signed int return_value_sre_toupper$11;
                        return_value_sre_toupper$11=sre_toupper((signed int)buffer[(signed long int)6]);
                        if(return_value_sre_toupper$11 == 89)
                          hmm->flags = hmm->flags | 1 << 3;

                      }

                      else
                      {
                        return_value_strncmp$36=strncmp(buffer, "MAP  ", (unsigned long int)5);
                        if(return_value_strncmp$36 == 0)
                        {
                          signed int return_value_sre_toupper$12;
                          return_value_sre_toupper$12=sre_toupper((signed int)buffer[(signed long int)6]);
                          if(return_value_sre_toupper$12 == 89)
                            hmm->flags = hmm->flags | 1 << 8;

                        }

                        else
                        {
                          return_value_strncmp$35=strncmp(buffer, "COM  ", (unsigned long int)5);
                          if(return_value_strncmp$35 == 0)
                          {
                            StringChop(buffer + (signed long int)6);
                            if(hmm->comlog == ((char *)NULL))
                              hmm->comlog=Strdup(buffer + (signed long int)6);

                            else
                            {
                              unsigned long int return_value_strlen$13;
                              return_value_strlen$13=strlen(hmm->comlog);
                              unsigned long int return_value_strlen$14;
                              return_value_strlen$14=strlen(buffer + (signed long int)6);
                              void *return_value_sre_realloc$15;
                              return_value_sre_realloc$15=sre_realloc("hmmio.c", 623, (void *)hmm->comlog, sizeof(char *) /*8ul*/  * (return_value_strlen$13 + (unsigned long int)1 + return_value_strlen$14));
                              hmm->comlog = (char *)return_value_sre_realloc$15;
                              strcat(hmm->comlog, "\n");
                              strcat(hmm->comlog, buffer + (signed long int)6);
                            }
                          }

                          else
                          {
                            return_value_strncmp$34=strncmp(buffer, "DATE ", (unsigned long int)5);
                            if(return_value_strncmp$34 == 0)
                            {
                              StringChop(buffer + (signed long int)6);
                              hmm->ctime=Strdup(buffer + (signed long int)6);
                            }

                            else
                            {
                              return_value_strncmp$33=strncmp(buffer, "GA   ", (unsigned long int)5);
                              if(return_value_strncmp$33 == 0)
                              {
                                s=strtok(buffer + (signed long int)6, " \t\n");
                                if(s == ((char *)NULL))
                                  goto FAILURE;

                                double return_value_atof$16;
                                return_value_atof$16=atof(s);
                                hmm->ga1 = (float)return_value_atof$16;
                                s=strtok((char *)(void *)0, " \t\n");
                                if(s == ((char *)NULL))
                                  goto FAILURE;

                                double return_value_atof$17;
                                return_value_atof$17=atof(s);
                                hmm->ga2 = (float)return_value_atof$17;
                                hmm->flags = hmm->flags | 1 << 10;
                              }

                              else
                              {
                                return_value_strncmp$32=strncmp(buffer, "TC   ", (unsigned long int)5);
                                if(return_value_strncmp$32 == 0)
                                {
                                  s=strtok(buffer + (signed long int)6, " \t\n");
                                  if(s == ((char *)NULL))
                                    goto FAILURE;

                                  double return_value_atof$18;
                                  return_value_atof$18=atof(s);
                                  hmm->tc1 = (float)return_value_atof$18;
                                  s=strtok((char *)(void *)0, " \t\n");
                                  if(s == ((char *)NULL))
                                    goto FAILURE;

                                  double return_value_atof$19;
                                  return_value_atof$19=atof(s);
                                  hmm->tc2 = (float)return_value_atof$19;
                                  hmm->flags = hmm->flags | 1 << 11;
                                }

                                else
                                {
                                  return_value_strncmp$31=strncmp(buffer, "NC   ", (unsigned long int)5);
                                  if(return_value_strncmp$31 == 0)
                                  {
                                    s=strtok(buffer + (signed long int)6, " \t\n");
                                    if(s == ((char *)NULL))
                                      goto FAILURE;

                                    double return_value_atof$20;
                                    return_value_atof$20=atof(s);
                                    hmm->nc1 = (float)return_value_atof$20;
                                    s=strtok((char *)(void *)0, " \t\n");
                                    if(s == ((char *)NULL))
                                      goto FAILURE;

                                    double return_value_atof$21;
                                    return_value_atof$21=atof(s);
                                    hmm->nc2 = (float)return_value_atof$21;
                                    hmm->flags = hmm->flags | 1 << 12;
                                  }

                                  else
                                  {
                                    return_value_strncmp$30=strncmp(buffer, "XT   ", (unsigned long int)5);
                                    if(return_value_strncmp$30 == 0)
                                    {
                                      s=strtok(buffer + (signed long int)6, " \t\n");
                                      if(s == ((char *)NULL))
                                        goto FAILURE;

                                      k = 0;
                                      for( ; !(k >= 4); k = k + 1)
                                      {
                                        x = 0;
                                        for( ; !(x >= 2); x = x + 1)
                                        {
                                          if(s == ((char *)NULL))
                                            goto FAILURE;

                                          hmm->xt[(signed long int)k][(signed long int)x]=ascii2prob(s, (float)1.0);
                                          s=strtok((char *)(void *)0, " \t\n");
                                        }
                                      }
                                    }

                                    else
                                    {
                                      return_value_strncmp$29=strncmp(buffer, "NULT ", (unsigned long int)5);
                                      if(return_value_strncmp$29 == 0)
                                      {
                                        s=strtok(buffer + (signed long int)6, " \t\n");
                                        if(s == ((char *)NULL))
                                          goto FAILURE;

                                        hmm->p1=ascii2prob(s, (float)1.);
                                        s=strtok((char *)(void *)0, " \t\n");
                                        if(s == ((char *)NULL))
                                          goto FAILURE;

                                        float return_value_ascii2prob$22;
                                        return_value_ascii2prob$22=ascii2prob(s, (float)1.0);
                                        hmm->p1 = hmm->p1 / (hmm->p1 + return_value_ascii2prob$22);
                                      }

                                      else
                                      {
                                        return_value_strncmp$28=strncmp(buffer, "NULE ", (unsigned long int)5);
                                        if(return_value_strncmp$28 == 0)
                                        {
                                          if(Alphabet_type == 0)
                                            Die("ALPH must precede NULE in HMM save files");

                                          s=strtok(buffer + (signed long int)6, " \t\n");
                                          x = 0;
                                          for( ; !(x >= Alphabet_size); x = x + 1)
                                          {
                                            if(s == ((char *)NULL))
                                              goto FAILURE;

                                            hmm->null[(signed long int)x]=ascii2prob(s, (float)(1. / (double)(float)Alphabet_size));
                                            s=strtok((char *)(void *)0, " \t\n");
                                          }
                                        }

                                        else
                                        {
                                          return_value_strncmp$27=strncmp(buffer, "EVD  ", (unsigned long int)5);
                                          if(return_value_strncmp$27 == 0)
                                          {
                                            hmm->flags = hmm->flags | 1 << 7;
                                            s=strtok(buffer + (signed long int)6, " \t\n");
                                            if(s == ((char *)NULL))
                                              goto FAILURE;

                                            double return_value_atof$23;
                                            return_value_atof$23=atof(s);
                                            hmm->mu = (float)return_value_atof$23;
                                            s=strtok((char *)(void *)0, " \t\n");
                                            if(s == ((char *)NULL))
                                              goto FAILURE;

                                            double return_value_atof$24;
                                            return_value_atof$24=atof(s);
                                            hmm->lambda = (float)return_value_atof$24;
                                          }

                                          else
                                          {
                                            return_value_strncmp$26=strncmp(buffer, "CKSUM", (unsigned long int)5);
                                            if(return_value_strncmp$26 == 0)
                                              hmm->checksum=atoi(buffer + (signed long int)6);

                                            else
                                            {
                                              return_value_strncmp$25=strncmp(buffer, "HMM  ", (unsigned long int)5);
                                              if(return_value_strncmp$25 == 0)
                                                break;

                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      while((_Bool)1);
      return_value_feof$45=feof(hmmfp->f);
      if(!(return_value_feof$45 == 0))
        goto FAILURE;

      if(!(M >= 1))
        goto FAILURE;

      if(hmm->name == ((char *)NULL))
        goto FAILURE;

      if(Alphabet_type == 0)
        goto FAILURE;

      AllocPlan7Body(hmm, M);
      return_value_fgets$46=fgets(buffer, 512, hmmfp->f);
      if(return_value_fgets$46 == ((char *)NULL))
        goto FAILURE;

      return_value_fgets$47=fgets(buffer, 512, hmmfp->f);
      if(return_value_fgets$47 == ((char *)NULL))
        goto FAILURE;

      s=strtok(buffer, " \t\n");
      if(s == ((char *)NULL))
        goto FAILURE;

      p=ascii2prob(s, (float)1.0);
      s=strtok((char *)(void *)0, " \t\n");
      if(s == ((char *)NULL))
        goto FAILURE;

      s=strtok((char *)(void *)0, " \t\n");
      if(s == ((char *)NULL))
        goto FAILURE;

      hmm->tbd1=ascii2prob(s, (float)1.0);
      hmm->tbd1 = hmm->tbd1 / (p + hmm->tbd1);
      k = 1;
      for( ; hmm->M >= k; k = k + 1)
      {
        char *return_value_fgets$48;
        return_value_fgets$48=fgets(buffer, 512, hmmfp->f);
        if(return_value_fgets$48 == ((char *)NULL))
          goto FAILURE;

        s=strtok(buffer, " \t\n");
        if(s == ((char *)NULL))
          goto FAILURE;

        signed int return_value_atoi$49;
        return_value_atoi$49=atoi(s);
        if(!(return_value_atoi$49 == k))
          goto FAILURE;

        x = 0;
        for( ; !(x >= Alphabet_size); x = x + 1)
        {
          s=strtok((char *)(void *)0, " \t\n");
          if(s == ((char *)NULL))
            goto FAILURE;

          hmm->mat[(signed long int)k][(signed long int)x]=ascii2prob(s, hmm->null[(signed long int)x]);
        }
        if(!((256 & hmm->flags) == 0))
        {
          s=strtok((char *)(void *)0, " \t\n");
          if(s == ((char *)NULL))
            goto FAILURE;

          hmm->map[(signed long int)k]=atoi(s);
        }

        char *return_value_fgets$50;
        return_value_fgets$50=fgets(buffer, 512, hmmfp->f);
        if(return_value_fgets$50 == ((char *)NULL))
          goto FAILURE;

        s=strtok(buffer, " \t\n");
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!((4 & hmm->flags) == 0))
          hmm->rf[(signed long int)k] = *s;

        if(!(k >= hmm->M))
        {
          x = 0;
          for( ; !(x >= Alphabet_size); x = x + 1)
          {
            s=strtok((char *)(void *)0, " \t\n");
            if(s == ((char *)NULL))
              goto FAILURE;

            hmm->ins[(signed long int)k][(signed long int)x]=ascii2prob(s, hmm->null[(signed long int)x]);
          }
        }

        char *return_value_fgets$51;
        return_value_fgets$51=fgets(buffer, 512, hmmfp->f);
        if(return_value_fgets$51 == ((char *)NULL))
          goto FAILURE;

        s=strtok(buffer, " \t\n");
        if(s == ((char *)NULL))
          goto FAILURE;

        if(!((8 & hmm->flags) == 0))
          hmm->cs[(signed long int)k] = *s;

        x = 0;
        for( ; !(x >= 7); x = x + 1)
        {
          s=strtok((char *)(void *)0, " \t\n");
          if(s == ((char *)NULL))
            goto FAILURE;

          if(!(k >= hmm->M))
            hmm->t[(signed long int)k][(signed long int)x]=ascii2prob(s, (float)1.0);

        }
        s=strtok((char *)(void *)0, " \t\n");
        if(s == ((char *)NULL))
          goto FAILURE;

        hmm->begin[(signed long int)k]=ascii2prob(s, (float)1.0);
        s=strtok((char *)(void *)0, " \t\n");
        if(s == ((char *)NULL))
          goto FAILURE;

        hmm->end[(signed long int)k]=ascii2prob(s, (float)1.0);
      }
      do
      {
        return_value_fgets$52=fgets(buffer, 512, hmmfp->f);
        if(return_value_fgets$52 == ((char *)NULL))
          break;

        return_value_strncmp$53=strncmp(buffer, "//", (unsigned long int)2);
        if(return_value_strncmp$53 == 0)
          break;

      }
      while((_Bool)1);
      Plan7Renormalize(hmm);
      hmm->flags = hmm->flags | 1 << 5;
      hmm->flags = hmm->flags & ~(1 << 0);
      *ret_hmm = hmm;
      return 1;
    }

    else
    {

    FAILURE:
      ;
      if(!(hmm == ((struct plan7_s *)NULL)))
        FreePlan7(hmm);

      *ret_hmm = (struct plan7_s *)(void *)0;
      return 1;
    }
  }
}

// read_bin10hmm
// file hmmio.c line 1234
static signed int read_bin10hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  unsigned int magic;
  struct plan7_s *hmm;
  struct plan9_s *p9hmm;
  signed int return_value_feof$1;
  return_value_feof$1=feof(hmmfp->f);
  if(!(return_value_feof$1 == 0))
    return 0;

  else
  {
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)(char *)&magic, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
    if(return_value_fread$2 == 0ul)
      return 0;

    else
    {
      p9hmm=read_plan9_binhmm(hmmfp->f, 1, hmmfp->byteswap);
      if(p9hmm == ((struct plan9_s *)NULL))
      {
        *ret_hmm = (struct plan7_s *)(void *)0;
        return 1;
      }

      else
      {
        Plan9toPlan7(p9hmm, &hmm);
        hmm->comlog=Strdup("[converted from an old Plan9 HMM]");
        Plan7SetCtime(hmm);
        P9FreeHMM(p9hmm);
        *ret_hmm = hmm;
        return 1;
      }
    }
  }
}

// read_bin11hmm
// file hmmio.c line 1201
static signed int read_bin11hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  unsigned int magic;
  struct plan7_s *hmm;
  struct plan9_s *p9hmm;
  signed int return_value_feof$1;
  return_value_feof$1=feof(hmmfp->f);
  if(!(return_value_feof$1 == 0))
    return 0;

  else
  {
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)(char *)&magic, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
    if(return_value_fread$2 == 0ul)
      return 0;

    else
    {
      p9hmm=read_plan9_binhmm(hmmfp->f, 3, hmmfp->byteswap);
      if(p9hmm == ((struct plan9_s *)NULL))
      {
        *ret_hmm = (struct plan7_s *)(void *)0;
        return 1;
      }

      else
      {
        Plan9toPlan7(p9hmm, &hmm);
        hmm->comlog=Strdup("[converted from an old Plan9 HMM]");
        Plan7SetCtime(hmm);
        P9FreeHMM(p9hmm);
        *ret_hmm = hmm;
        return 1;
      }
    }
  }
}

// read_bin17hmm
// file hmmio.c line 1169
static signed int read_bin17hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  unsigned int magic;
  struct plan7_s *hmm;
  struct plan9_s *p9hmm;
  signed int return_value_feof$1;
  return_value_feof$1=feof(hmmfp->f);
  if(!(return_value_feof$1 == 0))
    return 0;

  else
  {
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)(char *)&magic, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
    if(return_value_fread$2 == 0ul)
      return 0;

    else
    {
      p9hmm=read_plan9_binhmm(hmmfp->f, 5, hmmfp->byteswap);
      if(p9hmm == ((struct plan9_s *)NULL))
      {
        *ret_hmm = (struct plan7_s *)(void *)0;
        return 1;
      }

      else
      {
        Plan9toPlan7(p9hmm, &hmm);
        hmm->comlog=Strdup("[converted from an old Plan9 HMM]");
        Plan7SetCtime(hmm);
        P9FreeHMM(p9hmm);
        *ret_hmm = hmm;
        return 1;
      }
    }
  }
}

// read_bin19hmm
// file hmmio.c line 1118
static signed int read_bin19hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  unsigned int magic;
  struct plan7_s *hmm;
  struct plan9_s *p9hmm;
  signed int return_value_feof$1;
  return_value_feof$1=feof(hmmfp->f);
  if(!(return_value_feof$1 == 0))
    return 0;

  else
  {
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)(char *)&magic, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
    if(return_value_fread$2 == 0ul)
      return 0;

    else
    {
      p9hmm=read_plan9_binhmm(hmmfp->f, 7, hmmfp->byteswap);
      if(p9hmm == ((struct plan9_s *)NULL))
      {
        *ret_hmm = (struct plan7_s *)(void *)0;
        return 1;
      }

      else
      {
        Plan9toPlan7(p9hmm, &hmm);
        hmm->comlog=Strdup("[converted from an old Plan9 HMM]");
        Plan7SetCtime(hmm);
        P9FreeHMM(p9hmm);
        *ret_hmm = hmm;
        return 1;
      }
    }
  }
}

// read_bin20hmm
// file hmmio.c line 781
static signed int read_bin20hmm(struct hmmfile_s *hmmfp, struct plan7_s **ret_hmm)
{
  struct plan7_s *hmm;
  signed int k;
  signed int x;
  signed int type;
  unsigned int magic;
  hmm = (struct plan7_s *)(void *)0;
  signed int return_value_feof$1;
  return_value_feof$1=feof(hmmfp->f);
  unsigned long int return_value_fread$3;
  signed int return_value_read_bin_string$4;
  signed int return_value_read_bin_string$5;
  signed int return_value_read_bin_string$6;
  unsigned long int return_value_fread$7;
  unsigned long int return_value_fread$8;
  char *return_value_AlphabetType2String$9;
  char *return_value_AlphabetType2String$10;
  unsigned long int return_value_fread$11;
  unsigned long int return_value_fread$12;
  unsigned long int return_value_fread$13;
  signed int return_value_read_bin_string$14;
  unsigned long int return_value_fread$15;
  signed int return_value_read_bin_string$16;
  unsigned long int return_value_fread$17;
  unsigned long int return_value_fread$25;
  unsigned long int return_value_fread$26;
  unsigned long int return_value_fread$29;
  unsigned long int return_value_fread$30;
  unsigned long int return_value_fread$31;
  unsigned long int return_value_fread$32;
  unsigned long int return_value_fread$33;
  unsigned long int return_value_fread$34;
  if(!(return_value_feof$1 == 0))
    return 0;

  else
  {
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)(char *)&magic, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
    if(return_value_fread$2 == 0ul)
      return 0;

    else
    {
      if(!(hmmfp->byteswap == 0))
        byteswap((char *)&magic, (signed int)sizeof(unsigned int) /*4ul*/ );

      if(magic == v20magic)
      {
        hmm=AllocPlan7Shell();
        return_value_fread$3=fread((void *)(char *)&hmm->flags, sizeof(signed int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
        if(return_value_fread$3 == 0ul)
          goto FAILURE;

        if(!(hmmfp->byteswap == 0))
          byteswap((char *)&hmm->flags, (signed int)sizeof(signed int) /*4ul*/ );

        return_value_read_bin_string$4=read_bin_string(hmmfp->f, hmmfp->byteswap, &hmm->name);
        if(return_value_read_bin_string$4 == 0)
          goto FAILURE;

        if(!((512 & hmm->flags) == 0))
        {
          return_value_read_bin_string$5=read_bin_string(hmmfp->f, hmmfp->byteswap, &hmm->acc);
          if(return_value_read_bin_string$5 == 0)
            goto FAILURE;

        }

        if(!((2 & hmm->flags) == 0))
        {
          return_value_read_bin_string$6=read_bin_string(hmmfp->f, hmmfp->byteswap, &hmm->desc);
          if(return_value_read_bin_string$6 == 0)
            goto FAILURE;

        }

        return_value_fread$7=fread((void *)(char *)&hmm->M, sizeof(signed int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
        if(return_value_fread$7 == 0ul)
          goto FAILURE;

        if(!(hmmfp->byteswap == 0))
          byteswap((char *)&hmm->M, (signed int)sizeof(signed int) /*4ul*/ );

        return_value_fread$8=fread((void *)(char *)&type, sizeof(signed int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
        if(return_value_fread$8 == 0ul)
          goto FAILURE;

        if(!(hmmfp->byteswap == 0))
          byteswap((char *)&type, (signed int)sizeof(signed int) /*4ul*/ );

        if(Alphabet_type == 0)
          SetAlphabet(type);

        else
          if(!(type == Alphabet_type))
          {
            return_value_AlphabetType2String$9=AlphabetType2String(Alphabet_type);
            return_value_AlphabetType2String$10=AlphabetType2String(type);
            Die("Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n", return_value_AlphabetType2String$9, return_value_AlphabetType2String$10);
          }

        AllocPlan7Body(hmm, hmm->M);
        if(!((4 & hmm->flags) == 0))
        {
          return_value_fread$11=fread((void *)(char *)hmm->rf, sizeof(char) /*1ul*/ , (unsigned long int)(hmm->M + 1), hmmfp->f);
          if(return_value_fread$11 == 0ul)
            goto FAILURE;

        }

        hmm->rf[(signed long int)(hmm->M + 1)] = (char)0;
        if(!((8 & hmm->flags) == 0))
        {
          return_value_fread$12=fread((void *)(char *)hmm->cs, sizeof(char) /*1ul*/ , (unsigned long int)(hmm->M + 1), hmmfp->f);
          if(return_value_fread$12 == 0ul)
            goto FAILURE;

        }

        hmm->cs[(signed long int)(hmm->M + 1)] = (char)0;
        if(!((256 & hmm->flags) == 0))
        {
          return_value_fread$13=fread((void *)(char *)hmm->map, sizeof(signed int) /*4ul*/ , (unsigned long int)(hmm->M + 1), hmmfp->f);
          if(return_value_fread$13 == 0ul)
            goto FAILURE;

        }

        if(!(hmmfp->byteswap == 0))
        {
          k = 1;
          for( ; hmm->M >= k; k = k + 1)
            byteswap((char *)&hmm->map[(signed long int)k], (signed int)sizeof(signed int) /*4ul*/ );
        }

        return_value_read_bin_string$14=read_bin_string(hmmfp->f, hmmfp->byteswap, &hmm->comlog);
        if(return_value_read_bin_string$14 == 0)
          goto FAILURE;

        return_value_fread$15=fread((void *)(char *)&hmm->nseq, sizeof(signed int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
        if(return_value_fread$15 == 0ul)
          goto FAILURE;

        if(!(hmmfp->byteswap == 0))
          byteswap((char *)&hmm->nseq, (signed int)sizeof(signed int) /*4ul*/ );

        return_value_read_bin_string$16=read_bin_string(hmmfp->f, hmmfp->byteswap, &hmm->ctime);
        if(return_value_read_bin_string$16 == 0)
          goto FAILURE;

        return_value_fread$17=fread((void *)(char *)&hmm->checksum, sizeof(signed int) /*4ul*/ , (unsigned long int)1, hmmfp->f);
        if(return_value_fread$17 == 0ul)
          goto FAILURE;

        if(!(hmmfp->byteswap == 0))
          byteswap((char *)&hmm->checksum, (signed int)sizeof(signed int) /*4ul*/ );

        if(!((1024 & hmm->flags) == 0))
        {
          unsigned long int return_value_fread$18;
          return_value_fread$18=fread((void *)(char *)&hmm->ga1, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$18 == 0ul)
            goto FAILURE;

          unsigned long int return_value_fread$19;
          return_value_fread$19=fread((void *)(char *)&hmm->ga2, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$19 == 0ul)
            goto FAILURE;

          if(!(hmmfp->byteswap == 0))
          {
            byteswap((char *)&hmm->ga1, (signed int)sizeof(float) /*4ul*/ );
            byteswap((char *)&hmm->ga2, (signed int)sizeof(float) /*4ul*/ );
          }

        }

        if(!((2048 & hmm->flags) == 0))
        {
          unsigned long int return_value_fread$20;
          return_value_fread$20=fread((void *)(char *)&hmm->tc1, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$20 == 0ul)
            goto FAILURE;

          unsigned long int return_value_fread$21;
          return_value_fread$21=fread((void *)(char *)&hmm->tc2, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$21 == 0ul)
            goto FAILURE;

          if(!(hmmfp->byteswap == 0))
          {
            byteswap((char *)&hmm->tc1, (signed int)sizeof(float) /*4ul*/ );
            byteswap((char *)&hmm->tc2, (signed int)sizeof(float) /*4ul*/ );
          }

        }

        if(!((4096 & hmm->flags) == 0))
        {
          unsigned long int return_value_fread$22;
          return_value_fread$22=fread((void *)(char *)&hmm->nc1, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$22 == 0ul)
            goto FAILURE;

          unsigned long int return_value_fread$23;
          return_value_fread$23=fread((void *)(char *)&hmm->nc2, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$23 == 0ul)
            goto FAILURE;

          if(!(hmmfp->byteswap == 0))
          {
            byteswap((char *)&hmm->nc1, (signed int)sizeof(float) /*4ul*/ );
            byteswap((char *)&hmm->nc2, (signed int)sizeof(float) /*4ul*/ );
          }

        }

        k = 0;
        for( ; !(k >= 4); k = k + 1)
        {
          unsigned long int return_value_fread$24;
          return_value_fread$24=fread((void *)(char *)hmm->xt[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)2, hmmfp->f);
          if(return_value_fread$24 == 0ul)
            goto FAILURE;

          if(!(hmmfp->byteswap == 0))
          {
            x = 0;
            for( ; !(x >= 2); x = x + 1)
              byteswap((char *)&hmm->xt[(signed long int)k][(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
          }

        }
        return_value_fread$25=fread((void *)(char *)&hmm->p1, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
        if(return_value_fread$25 == 0ul)
          goto FAILURE;

        return_value_fread$26=fread((void *)(char *)hmm->null, sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, hmmfp->f);
        if(return_value_fread$26 == 0ul)
          goto FAILURE;

        if(!((128 & hmm->flags) == 0))
        {
          unsigned long int return_value_fread$27;
          return_value_fread$27=fread((void *)(char *)&hmm->mu, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$27 == 0ul)
            goto FAILURE;

          unsigned long int return_value_fread$28;
          return_value_fread$28=fread((void *)(char *)&hmm->lambda, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
          if(return_value_fread$28 == 0ul)
            goto FAILURE;

          if(!(hmmfp->byteswap == 0))
          {
            byteswap((char *)&hmm->mu, (signed int)sizeof(float) /*4ul*/ );
            byteswap((char *)&hmm->lambda, (signed int)sizeof(float) /*4ul*/ );
          }

        }

        return_value_fread$29=fread((void *)(char *)&hmm->tbd1, sizeof(float) /*4ul*/ , (unsigned long int)1, hmmfp->f);
        if(return_value_fread$29 == 0ul)
          goto FAILURE;

        return_value_fread$30=fread((void *)(char *)hmm->begin, sizeof(float) /*4ul*/ , (unsigned long int)(hmm->M + 1), hmmfp->f);
        if(return_value_fread$30 == 0ul)
          goto FAILURE;

        return_value_fread$31=fread((void *)(char *)hmm->end, sizeof(float) /*4ul*/ , (unsigned long int)(hmm->M + 1), hmmfp->f);
        if(return_value_fread$31 == 0ul)
          goto FAILURE;

        k = 1;
        for( ; hmm->M >= k; k = k + 1)
        {
          return_value_fread$32=fread((void *)(char *)hmm->mat[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, hmmfp->f);
          if(return_value_fread$32 == 0ul)
            goto FAILURE;

        }
        k = 1;
        for( ; !(k >= hmm->M); k = k + 1)
        {
          return_value_fread$33=fread((void *)(char *)hmm->ins[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, hmmfp->f);
          if(return_value_fread$33 == 0ul)
            goto FAILURE;

        }
        k = 1;
        for( ; !(k >= hmm->M); k = k + 1)
        {
          return_value_fread$34=fread((void *)(char *)hmm->t[(signed long int)k], sizeof(float) /*4ul*/ , (unsigned long int)7, hmmfp->f);
          if(return_value_fread$34 == 0ul)
            goto FAILURE;

        }
        if(!(hmmfp->byteswap == 0))
        {
          x = 0;
          for( ; !(x >= Alphabet_size); x = x + 1)
            byteswap((char *)&hmm->null[(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
          byteswap((char *)&hmm->p1, (signed int)sizeof(float) /*4ul*/ );
          byteswap((char *)&hmm->tbd1, (signed int)sizeof(float) /*4ul*/ );
          k = 1;
          for( ; hmm->M >= k; k = k + 1)
          {
            x = 0;
            for( ; !(x >= Alphabet_size); x = x + 1)
              byteswap((char *)&hmm->mat[(signed long int)k][(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
            if(!(k >= hmm->M))
            {
              x = 0;
              for( ; !(x >= Alphabet_size); x = x + 1)
                byteswap((char *)&hmm->ins[(signed long int)k][(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
            }

            byteswap((char *)&hmm->begin[(signed long int)k], (signed int)sizeof(float) /*4ul*/ );
            byteswap((char *)&hmm->end[(signed long int)k], (signed int)sizeof(float) /*4ul*/ );
            if(!(k >= hmm->M))
            {
              x = 0;
              for( ; !(x >= 7); x = x + 1)
                byteswap((char *)&hmm->t[(signed long int)k][(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
            }

          }
        }

        hmm->flags = hmm->flags | 1 << 5;
        hmm->flags = hmm->flags & ~(1 << 0);
        *ret_hmm = hmm;
        return 1;
      }

      else
      {

      FAILURE:
        ;
        if(!(hmm == ((struct plan7_s *)NULL)))
          FreePlan7(hmm);

        *ret_hmm = (struct plan7_s *)(void *)0;
        return 1;
      }
    }
  }
}

// read_bin_string
// file hmmio.c line 1362
static signed int read_bin_string(struct _IO_FILE *fp, signed int doswap, char **ret_s)
{
  char *s;
  signed int len;
  unsigned long int return_value_fread$1;
  return_value_fread$1=fread((void *)(char *)&len, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  if(return_value_fread$1 == 0ul)
    return 0;

  else
  {
    if(!(doswap == 0))
      byteswap((char *)&len, (signed int)sizeof(signed int) /*4ul*/ );

    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("hmmio.c", 1369, sizeof(char) /*1ul*/  * (unsigned long int)len);
    s = (char *)return_value_sre_malloc$2;
    unsigned long int return_value_fread$3;
    return_value_fread$3=fread((void *)(char *)s, sizeof(char) /*1ul*/ , (unsigned long int)len, fp);
    if(return_value_fread$3 == 0ul)
    {
      free((void *)s);
      return 0;
    }

    else
    {
      *ret_s = s;
      return 1;
    }
  }
}

// read_i16
// file ssi.c line 1134
static signed int read_i16(struct _IO_FILE *fp, unsigned short int *ret_result)
{
  unsigned short int result;
  unsigned long int return_value_fread$1;
  return_value_fread$1=fread((void *)&result, sizeof(unsigned short int) /*2ul*/ , (unsigned long int)1, fp);
  if(!(return_value_fread$1 == 1ul))
    return 0;

  else
  {
    *ret_result=sre_ntoh16(result);
    return 1;
  }
}

// read_i32
// file ssi.c line 1149
static signed int read_i32(struct _IO_FILE *fp, unsigned int *ret_result)
{
  unsigned int result;
  unsigned long int return_value_fread$1;
  return_value_fread$1=fread((void *)&result, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, fp);
  if(!(return_value_fread$1 == 1ul))
    return 0;

  else
  {
    *ret_result=sre_ntoh32(result);
    return 1;
  }
}

// read_i64
// file ssi.c line 1164
static signed int read_i64(struct _IO_FILE *fp, unsigned long int *ret_result)
{
  unsigned long int result;
  unsigned long int return_value_fread$1;
  return_value_fread$1=fread((void *)&result, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, fp);
  if(!(return_value_fread$1 == 1ul))
    return 0;

  else
  {
    *ret_result=sre_ntoh64(result);
    return 1;
  }
}

// read_offset
// file ssi.c line 1179
static signed int read_offset(struct _IO_FILE *fp, char mode, struct ssioffset_s *ret_offset)
{
  if((signed int)mode == 0)
  {
    ret_offset->mode = (char)0;
    signed int return_value_read_i32$1;
    return_value_read_i32$1=read_i32(fp, &ret_offset->off.i32);
    if(return_value_read_i32$1 == 0)
      return 0;

  }

  else
    if((signed int)mode == 1)
    {
      ret_offset->mode = (char)1;
      signed int return_value_read_i64$2;
      return_value_read_i64$2=read_i64(fp, &ret_offset->off.i64);
      if(return_value_read_i64$2 == 0)
        return 0;

    }

    else
      return 0;
  return 1;
}

// read_plan9_aschmm
// file hmmio.c line 1584
static struct plan9_s * read_plan9_aschmm(struct _IO_FILE *fp, signed int version)
{
  struct plan9_s *hmm;
  signed int M;
  char buffer[512l];
  char *statetype;
  char *s;
  signed int k;
  signed int i;
  signed int asize;
  signed int atype;
  char *return_value_fgets$1;
  return_value_fgets$1=fgets(buffer, 512, fp);
  char *return_value_AlphabetType2String$5;
  char *return_value_AlphabetType2String$6;
  char *return_value_fgets$10;
  char *return_value_fgets$15;
  _Bool tmp_if_expr$17;
  char *return_value_fgets$26;
  signed int return_value_strcmp$44;
  char *return_value_fgets$35;
  signed int return_value_strcmp$43;
  char *return_value_fgets$42;
  if(return_value_fgets$1 == ((char *)NULL))
    return (struct plan9_s *)(void *)0;

  else
  {
    s=strtok(buffer, " \t\n");
    if(s == ((char *)NULL))
      return (struct plan9_s *)(void *)0;

    else
    {
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*s]) == 0)
        return (struct plan9_s *)(void *)0;

      else
      {
        M=atoi(s);
        char *return_value_fgets$3;
        return_value_fgets$3=fgets(buffer, 512, fp);
        if(return_value_fgets$3 == ((char *)NULL))
          return (struct plan9_s *)(void *)0;

        else
        {
          s=strtok(buffer, " \t\n");
          if(s == ((char *)NULL))
            return (struct plan9_s *)(void *)0;

          else
          {
            const unsigned short int **return_value___ctype_b_loc$4;
            return_value___ctype_b_loc$4=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s]) == 0)
              return (struct plan9_s *)(void *)0;

            else
            {
              asize=atoi(s);
              if(asize == 4)
                atype = 2;

              else
                if(asize == 20)
                  atype = 3;

                else
                  Die("A nonbiological alphabet size of %d; so I can't convert plan9 to plan7", asize);
              if(Alphabet_type == 0)
                SetAlphabet(atype);

              else
                if(!(atype == Alphabet_type))
                {
                  return_value_AlphabetType2String$5=AlphabetType2String(Alphabet_type);
                  return_value_AlphabetType2String$6=AlphabetType2String(atype);
                  Die("Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n", return_value_AlphabetType2String$5, return_value_AlphabetType2String$6);
                }

              hmm=P9AllocHMM(M);
              if(hmm == ((struct plan9_s *)NULL))
                Die("malloc failed for reading hmm in\n");

              char *return_value_fgets$7;
              return_value_fgets$7=fgets(buffer, 512, fp);
              if(return_value_fgets$7 == ((char *)NULL))
                return (struct plan9_s *)(void *)0;

              else
              {
                s=strtok(buffer, " \t\n");
                if(s == ((char *)NULL))
                  return (struct plan9_s *)(void *)0;

                else
                {
                  const unsigned short int **return_value___ctype_b_loc$8;
                  return_value___ctype_b_loc$8=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*s]) == 0)
                    return (struct plan9_s *)(void *)0;

                  else
                  {
                    char *return_value_fgets$9;
                    return_value_fgets$9=fgets(buffer, 512, fp);
                    if(return_value_fgets$9 == ((char *)NULL))
                      return (struct plan9_s *)(void *)0;

                    else
                    {
                      s=strtok(buffer, " \t\n");
                      if(s == ((char *)NULL))
                        return (struct plan9_s *)(void *)0;

                      else
                      {
                        if(version == 2)
                        {
                          i = 0;
                          for( ; !(i >= Alphabet_size); i = i + 1)
                          {
                            return_value_fgets$10=fgets(buffer, 512, fp);
                            if(return_value_fgets$10 == ((char *)NULL))
                              return (struct plan9_s *)(void *)0;

                          }
                        }

                        if(version == 6)
                        {
                          char *return_value_fgets$11;
                          return_value_fgets$11=fgets(buffer, 512, fp);
                          if(return_value_fgets$11 == ((char *)NULL))
                            return (struct plan9_s *)(void *)0;

                          signed int return_value_strncmp$12;
                          return_value_strncmp$12=strncmp(buffer, "yes", (unsigned long int)3);
                          if(return_value_strncmp$12 == 0)
                            hmm->flags = hmm->flags | 1 << 0;

                          char *return_value_fgets$13;
                          return_value_fgets$13=fgets(buffer, 512, fp);
                          if(return_value_fgets$13 == ((char *)NULL))
                            return (struct plan9_s *)(void *)0;

                          signed int return_value_strncmp$14;
                          return_value_strncmp$14=strncmp(buffer, "yes", (unsigned long int)3);
                          if(return_value_strncmp$14 == 0)
                            hmm->flags = hmm->flags | 1 << 1;

                        }

                        do
                        {
                          return_value_fgets$15=fgets(buffer, 512, fp);
                          if(return_value_fgets$15 == ((char *)NULL))
                            break;

                          statetype=strtok(buffer, " \t\n");
                          if(statetype == ((char *)NULL))
                            return (struct plan9_s *)(void *)0;

                          s=strtok((char *)(void *)0, " \t\n");
                          if(s == ((char *)NULL))
                            return (struct plan9_s *)(void *)0;

                          const unsigned short int **return_value___ctype_b_loc$16;
                          return_value___ctype_b_loc$16=__ctype_b_loc();
                          if((2048 & (signed int)(*return_value___ctype_b_loc$16)[(signed long int)(signed int)*s]) == 0)
                            return (struct plan9_s *)(void *)0;

                          k=atoi(s);
                          if(!(k >= 0))
                            tmp_if_expr$17 = (_Bool)1;

                          else
                            tmp_if_expr$17 = k > hmm->M + 1 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$17)
                            return (struct plan9_s *)(void *)0;

                          signed int return_value_strcmp$45;
                          return_value_strcmp$45=strcmp(statetype, "###MATCH_STATE");
                          if(return_value_strcmp$45 == 0)
                          {
                            if(version == 6)
                            {
                              s=strtok((char *)(void *)0, "\n");
                              for( ; !((signed int)*s == 40); s = s + 1l)
                                if((signed int)*s == 0)
                                  break;

                              if(!((signed int)*s == 40))
                                return (struct plan9_s *)(void *)0;

                              hmm->ref[(signed long int)k] = s[(signed long int)1];
                              for( ; !((signed int)*s == 40); s = s + 1l)
                                if((signed int)*s == 0)
                                  break;

                              if(!((signed int)*s == 40))
                                return (struct plan9_s *)(void *)0;

                              hmm->cs[(signed long int)k] = s[(signed long int)1];
                            }

                            char *return_value_fgets$18;
                            return_value_fgets$18=fgets(buffer, 512, fp);
                            if(return_value_fgets$18 == ((char *)NULL))
                              return (struct plan9_s *)(void *)0;

                            s=strtok(buffer, " \t\n");
                            if(s == ((char *)NULL))
                              return (struct plan9_s *)(void *)0;

                            double return_value_atof$19;
                            return_value_atof$19=atof(s);
                            (hmm->mat + (signed long int)k)->t[(signed long int)0] = (float)return_value_atof$19;
                            char *return_value_fgets$20;
                            return_value_fgets$20=fgets(buffer, 512, fp);
                            if(return_value_fgets$20 == ((char *)NULL))
                              return (struct plan9_s *)(void *)0;

                            s=strtok(buffer, " \t\n");
                            if(s == ((char *)NULL))
                              return (struct plan9_s *)(void *)0;

                            double return_value_atof$21;
                            return_value_atof$21=atof(s);
                            (hmm->mat + (signed long int)k)->t[(signed long int)2] = (float)return_value_atof$21;
                            char *return_value_fgets$22;
                            return_value_fgets$22=fgets(buffer, 512, fp);
                            if(return_value_fgets$22 == ((char *)NULL))
                              return (struct plan9_s *)(void *)0;

                            s=strtok(buffer, " \t\n");
                            if(s == ((char *)NULL))
                              return (struct plan9_s *)(void *)0;

                            double return_value_atof$23;
                            return_value_atof$23=atof(s);
                            (hmm->mat + (signed long int)k)->t[(signed long int)1] = (float)return_value_atof$23;
                            i = 0;
                            for( ; !(i >= Alphabet_size); i = i + 1)
                            {
                              char *return_value_fgets$24;
                              return_value_fgets$24=fgets(buffer, 512, fp);
                              if(return_value_fgets$24 == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              s=strtok(buffer, " \t\n");
                              if(s == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              double return_value_atof$25;
                              return_value_atof$25=atof(s);
                              (hmm->mat + (signed long int)k)->p[(signed long int)i] = (float)return_value_atof$25;
                            }
                            if(version == 2)
                            {
                              i = 0;
                              for( ; !(i >= 3 + Alphabet_size); i = i + 1)
                              {
                                return_value_fgets$26=fgets(buffer, 512, fp);
                                if(return_value_fgets$26 == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                              }
                            }

                          }

                          else
                          {
                            return_value_strcmp$44=strcmp(statetype, "###INSERT_STATE");
                            if(return_value_strcmp$44 == 0)
                            {
                              char *return_value_fgets$27;
                              return_value_fgets$27=fgets(buffer, 512, fp);
                              if(return_value_fgets$27 == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              s=strtok(buffer, " \t\n");
                              if(s == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              double return_value_atof$28;
                              return_value_atof$28=atof(s);
                              (hmm->ins + (signed long int)k)->t[(signed long int)0] = (float)return_value_atof$28;
                              char *return_value_fgets$29;
                              return_value_fgets$29=fgets(buffer, 512, fp);
                              if(return_value_fgets$29 == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              s=strtok(buffer, " \t\n");
                              if(s == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              double return_value_atof$30;
                              return_value_atof$30=atof(s);
                              (hmm->ins + (signed long int)k)->t[(signed long int)2] = (float)return_value_atof$30;
                              char *return_value_fgets$31;
                              return_value_fgets$31=fgets(buffer, 512, fp);
                              if(return_value_fgets$31 == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              s=strtok(buffer, " \t\n");
                              if(s == ((char *)NULL))
                                return (struct plan9_s *)(void *)0;

                              double return_value_atof$32;
                              return_value_atof$32=atof(s);
                              (hmm->ins + (signed long int)k)->t[(signed long int)1] = (float)return_value_atof$32;
                              i = 0;
                              for( ; !(i >= Alphabet_size); i = i + 1)
                              {
                                char *return_value_fgets$33;
                                return_value_fgets$33=fgets(buffer, 512, fp);
                                if(return_value_fgets$33 == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                s=strtok(buffer, " \t\n");
                                if(s == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                double return_value_atof$34;
                                return_value_atof$34=atof(s);
                                (hmm->ins + (signed long int)k)->p[(signed long int)i] = (float)return_value_atof$34;
                              }
                              if(version == 2)
                              {
                                i = 0;
                                for( ; !(i >= 3 + Alphabet_size); i = i + 1)
                                {
                                  return_value_fgets$35=fgets(buffer, 512, fp);
                                  if(return_value_fgets$35 == ((char *)NULL))
                                    return (struct plan9_s *)(void *)0;

                                }
                              }

                            }

                            else
                            {
                              return_value_strcmp$43=strcmp(statetype, "###DELETE_STATE");
                              if(return_value_strcmp$43 == 0)
                              {
                                char *return_value_fgets$36;
                                return_value_fgets$36=fgets(buffer, 512, fp);
                                if(return_value_fgets$36 == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                s=strtok(buffer, " \t\n");
                                if(s == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                double return_value_atof$37;
                                return_value_atof$37=atof(s);
                                (hmm->del + (signed long int)k)->t[(signed long int)0] = (float)return_value_atof$37;
                                char *return_value_fgets$38;
                                return_value_fgets$38=fgets(buffer, 512, fp);
                                if(return_value_fgets$38 == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                s=strtok(buffer, " \t\n");
                                if(s == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                double return_value_atof$39;
                                return_value_atof$39=atof(s);
                                (hmm->del + (signed long int)k)->t[(signed long int)2] = (float)return_value_atof$39;
                                char *return_value_fgets$40;
                                return_value_fgets$40=fgets(buffer, 512, fp);
                                if(return_value_fgets$40 == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                s=strtok(buffer, " \t\n");
                                if(s == ((char *)NULL))
                                  return (struct plan9_s *)(void *)0;

                                double return_value_atof$41;
                                return_value_atof$41=atof(s);
                                (hmm->del + (signed long int)k)->t[(signed long int)1] = (float)return_value_atof$41;
                                if(version == 2)
                                {
                                  i = 0;
                                  for( ; !(i >= 3); i = i + 1)
                                  {
                                    return_value_fgets$42=fgets(buffer, 512, fp);
                                    if(return_value_fgets$42 == ((char *)NULL))
                                      return (struct plan9_s *)(void *)0;

                                  }
                                }

                              }

                              else
                                return (struct plan9_s *)(void *)0;
                            }
                          }
                        }
                        while((_Bool)1);
                        P9DefaultNullModel(hmm->null);
                        P9Renormalize(hmm);
                        return hmm;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// read_plan9_binhmm
// file hmmio.c line 1438
static struct plan9_s * read_plan9_binhmm(struct _IO_FILE *fp, signed int version, signed int swapped)
{
  struct plan9_s *hmm;
  signed int M;
  signed int k;
  signed int x;
  signed int len;
  signed int asize;
  signed int atype;
  char abet[20l];
  unsigned long int return_value_fread$1;
  return_value_fread$1=fread((void *)(char *)&M, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  char *return_value_AlphabetType2String$3;
  char *return_value_AlphabetType2String$4;
  unsigned long int return_value_fread$11;
  unsigned long int return_value_fread$12;
  if(return_value_fread$1 == 0ul)
    return (struct plan9_s *)(void *)0;

  else
  {
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)(char *)&asize, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
    if(return_value_fread$2 == 0ul)
      return (struct plan9_s *)(void *)0;

    else
    {
      if(!(swapped == 0))
      {
        byteswap((char *)&M, (signed int)sizeof(signed int) /*4ul*/ );
        byteswap((char *)&asize, (signed int)sizeof(signed int) /*4ul*/ );
      }

      if(asize == 4)
        atype = 2;

      else
        if(asize == 20)
          atype = 3;

        else
          Die("A nonbiological alphabet size of %d; so I can't convert plan9 to plan7", asize);
      if(Alphabet_type == 0)
        SetAlphabet(atype);

      else
        if(!(atype == Alphabet_type))
        {
          return_value_AlphabetType2String$3=AlphabetType2String(Alphabet_type);
          return_value_AlphabetType2String$4=AlphabetType2String(atype);
          Die("Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n", return_value_AlphabetType2String$3, return_value_AlphabetType2String$4);
        }

      hmm=P9AllocHMM(M);
      if(hmm == ((struct plan9_s *)NULL))
        Die("malloc failed for reading hmm in\n");

      if(version == 7)
      {
        unsigned long int return_value_fread$5;
        return_value_fread$5=fread((void *)(char *)&len, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
        if(return_value_fread$5 == 0ul)
          return (struct plan9_s *)(void *)0;

        if(!(swapped == 0))
          byteswap((char *)&len, (signed int)sizeof(signed int) /*4ul*/ );

        void *return_value_sre_realloc$6;
        return_value_sre_realloc$6=sre_realloc("hmmio.c", 1474, (void *)hmm->name, sizeof(char) /*1ul*/  * (unsigned long int)(len + 1));
        hmm->name = (char *)return_value_sre_realloc$6;
        unsigned long int return_value_fread$7;
        return_value_fread$7=fread((void *)(char *)hmm->name, sizeof(char) /*1ul*/ , (unsigned long int)len, fp);
        if(return_value_fread$7 == 0ul)
          return (struct plan9_s *)(void *)0;

        hmm->name[(signed long int)len] = (char)0;
      }

      unsigned long int return_value_fread$8;
      return_value_fread$8=fread((void *)(char *)&atype, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
      if(return_value_fread$8 == 0ul)
        return (struct plan9_s *)(void *)0;

      else
      {
        unsigned long int return_value_fread$9;
        return_value_fread$9=fread((void *)(char *)abet, sizeof(char) /*1ul*/ , (unsigned long int)Alphabet_size, fp);
        if(return_value_fread$9 == 0ul)
          return (struct plan9_s *)(void *)0;

        else
        {
          if(version == 1)
            fseek(fp, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)Alphabet_size), 1);

          if(version == 5 || version == 7)
          {
            unsigned long int return_value_fread$10;
            return_value_fread$10=fread((void *)(char *)&hmm->flags, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$10 == 0ul)
              return (struct plan9_s *)(void *)0;

            if(!(swapped == 0))
              byteswap((char *)&hmm->flags, (signed int)sizeof(signed int) /*4ul*/ );

            if(!((1 & hmm->flags) == 0))
            {
              return_value_fread$11=fread((void *)(char *)hmm->ref, sizeof(char) /*1ul*/ , (unsigned long int)(hmm->M + 1), fp);
              if(return_value_fread$11 == 0ul)
                return (struct plan9_s *)(void *)0;

            }

            hmm->ref[(signed long int)(hmm->M + 1)] = (char)0;
            if(!((2 & hmm->flags) == 0))
            {
              return_value_fread$12=fread((void *)(char *)hmm->cs, sizeof(char) /*1ul*/ , (unsigned long int)(hmm->M + 1), fp);
              if(return_value_fread$12 == 0ul)
                return (struct plan9_s *)(void *)0;

            }

            hmm->cs[(signed long int)(hmm->M + 1)] = (char)0;
          }

          if(version == 7)
          {
            unsigned long int return_value_fread$13;
            return_value_fread$13=fread((void *)(char *)hmm->null, sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, fp);
            if(return_value_fread$13 == 0ul)
              return (struct plan9_s *)(void *)0;

            if(!(swapped == 0))
            {
              x = 0;
              for( ; !(x >= Alphabet_size); x = x + 1)
                byteswap((char *)&hmm->null[(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
            }

          }

          else
            P9DefaultNullModel(hmm->null);
          k = 0;
          for( ; hmm->M >= k; k = k + 1)
          {
            unsigned long int return_value_fread$14;
            return_value_fread$14=fread((void *)(char *)&(hmm->mat + (signed long int)k)->t[(signed long int)0], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$14 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$15;
            return_value_fread$15=fread((void *)(char *)&(hmm->mat + (signed long int)k)->t[(signed long int)2], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$15 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$16;
            return_value_fread$16=fread((void *)(char *)&(hmm->mat + (signed long int)k)->t[(signed long int)1], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$16 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$17;
            return_value_fread$17=fread((void *)(char *)(hmm->mat + (signed long int)k)->p, sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, fp);
            if(return_value_fread$17 == 0ul)
              return (struct plan9_s *)(void *)0;

            if(!(swapped == 0))
            {
              byteswap((char *)&(hmm->mat + (signed long int)k)->t[(signed long int)0], (signed int)sizeof(float) /*4ul*/ );
              byteswap((char *)&(hmm->mat + (signed long int)k)->t[(signed long int)2], (signed int)sizeof(float) /*4ul*/ );
              byteswap((char *)&(hmm->mat + (signed long int)k)->t[(signed long int)1], (signed int)sizeof(float) /*4ul*/ );
              x = 0;
              for( ; !(x >= Alphabet_size); x = x + 1)
                byteswap((char *)&(hmm->mat + (signed long int)k)->p[(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
            }

            if(version == 1)
              fseek(fp, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)(3 + Alphabet_size)), 1);

            unsigned long int return_value_fread$18;
            return_value_fread$18=fread((void *)(char *)&(hmm->del + (signed long int)k)->t[(signed long int)0], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$18 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$19;
            return_value_fread$19=fread((void *)(char *)&(hmm->del + (signed long int)k)->t[(signed long int)2], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$19 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$20;
            return_value_fread$20=fread((void *)(char *)&(hmm->del + (signed long int)k)->t[(signed long int)1], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$20 == 0ul)
              return (struct plan9_s *)(void *)0;

            if(!(swapped == 0))
            {
              byteswap((char *)&(hmm->del + (signed long int)k)->t[(signed long int)0], (signed int)sizeof(float) /*4ul*/ );
              byteswap((char *)&(hmm->del + (signed long int)k)->t[(signed long int)2], (signed int)sizeof(float) /*4ul*/ );
              byteswap((char *)&(hmm->del + (signed long int)k)->t[(signed long int)1], (signed int)sizeof(float) /*4ul*/ );
            }

            if(version == 1)
              fseek(fp, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)3), 1);

            unsigned long int return_value_fread$21;
            return_value_fread$21=fread((void *)(char *)&(hmm->ins + (signed long int)k)->t[(signed long int)0], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$21 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$22;
            return_value_fread$22=fread((void *)(char *)&(hmm->ins + (signed long int)k)->t[(signed long int)2], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$22 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$23;
            return_value_fread$23=fread((void *)(char *)&(hmm->ins + (signed long int)k)->t[(signed long int)1], sizeof(float) /*4ul*/ , (unsigned long int)1, fp);
            if(return_value_fread$23 == 0ul)
              return (struct plan9_s *)(void *)0;

            unsigned long int return_value_fread$24;
            return_value_fread$24=fread((void *)(char *)(hmm->ins + (signed long int)k)->p, sizeof(float) /*4ul*/ , (unsigned long int)Alphabet_size, fp);
            if(return_value_fread$24 == 0ul)
              return (struct plan9_s *)(void *)0;

            if(!(swapped == 0))
            {
              byteswap((char *)&(hmm->ins + (signed long int)k)->t[(signed long int)0], (signed int)sizeof(float) /*4ul*/ );
              byteswap((char *)&(hmm->ins + (signed long int)k)->t[(signed long int)2], (signed int)sizeof(float) /*4ul*/ );
              byteswap((char *)&(hmm->ins + (signed long int)k)->t[(signed long int)1], (signed int)sizeof(float) /*4ul*/ );
              x = 0;
              for( ; !(x >= Alphabet_size); x = x + 1)
                byteswap((char *)&(hmm->ins + (signed long int)k)->p[(signed long int)x], (signed int)sizeof(float) /*4ul*/ );
            }

            if(version == 1)
              fseek(fp, (signed long int)(sizeof(float) /*4ul*/  * (unsigned long int)(3 + Alphabet_size)), 1);

          }
          P9Renormalize(hmm);
          return hmm;
        }
      }
    }
  }
}

// reg
// file hsregex.c line 423
static char * reg(struct comp *cp, signed int paren, signed int *flagp)
{
  char *ret = (char *)(void *)0;
  char *br;
  char *ender;
  signed int parno = 0;
  signed int flags;
  *flagp = 01;
  if(!(paren == 0))
  {
    if(cp->regnpar >= 10)
    {
      sqd_regerror("too many ()");
      return (char *)(void *)0;
    }

    parno = cp->regnpar;
    cp->regnpar = cp->regnpar + 1;
    ret=regnode(cp, 20 + parno);
  }

  br=regbranch(cp, &flags);
  _Bool tmp_if_expr$2;
  char *tmp_post$1;
  if(br == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(!(paren == 0))
      regtail(cp, ret, br);

    else
      ret = br;
    *flagp = *flagp & ~(~flags & 01);
    *flagp = *flagp | flags & 04;
    for( ; (signed int)*cp->regparse == 124; *flagp = *flagp | flags & 04)
    {
      cp->regparse = cp->regparse + 1l;
      br=regbranch(cp, &flags);
      if(br == ((char *)NULL))
        return (char *)(void *)0;

      regtail(cp, ret, br);
      *flagp = *flagp & ~(~flags & 01);
    }
    ender=regnode(cp, paren != 0 ? 30 + parno : 0);
    regtail(cp, ret, ender);
    br = ret;
    while(!(br == ((char *)NULL)))
    {
      regoptail(cp, br, ender);
      br=regnext(br);
    }
    if(!(paren == 0))
    {
      tmp_post$1 = cp->regparse;
      cp->regparse = cp->regparse + 1l;
      tmp_if_expr$2 = (signed int)*tmp_post$1 != 41 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      sqd_regerror("unterminated ()");
      return (char *)(void *)0;
    }

    else
      if(paren == 0)
      {
        if(!((signed int)*cp->regparse == 0))
        {
          if((signed int)*cp->regparse == 41)
          {
            sqd_regerror("unmatched ()");
            return (char *)(void *)0;
          }

          else
          {
            sqd_regerror("internal error: junk on end");
            return (char *)(void *)0;
          }
        }

      }

    return ret;
  }
}

// regatom
// file hsregex.c line 603
static char * regatom(struct comp *cp, signed int *flagp)
{
  char *ret;
  signed int flags;
  *flagp = 0;
  char *tmp_post$1 = cp->regparse;
  cp->regparse = cp->regparse + 1l;
  signed int range;
  signed int rangeend;
  signed int c;
  char *tmp_post$2;
  char *tmp_post$3;
  unsigned long int len;
  char ender;
  char *tmp_post$4;
  switch((signed int)*tmp_post$1)
  {
    case 94:
    {
      ret=regnode(cp, 1);
      break;
    }
    case 36:
    {
      ret=regnode(cp, 2);
      break;
    }
    case 46:
    {
      ret=regnode(cp, 3);
      *flagp = *flagp | 01 | 02;
      break;
    }
    case 91:
    {
      if((signed int)*cp->regparse == 94)
      {
        ret=regnode(cp, 5);
        cp->regparse = cp->regparse + 1l;
      }

      else
        ret=regnode(cp, 4);
      c = (signed int)*cp->regparse;
      if(c == 45 || c == 93)
      {
        regc(cp, c);
        cp->regparse = cp->regparse + 1l;
      }

      do
      {
        tmp_post$2 = cp->regparse;
        cp->regparse = cp->regparse + 1l;
        c = (signed int)*tmp_post$2;
        if(c == 0)
          break;

        if(c == 93)
          break;

        if(!(c == 45))
          regc(cp, c);

        else
        {
          c = (signed int)*cp->regparse;
          if(c == 0 || c == 93)
            regc(cp, 45);

          else
          {
            range = (signed int)(unsigned char)*(cp->regparse - (signed long int)2);
            rangeend = (signed int)(unsigned char)c;
            if(!(rangeend >= range))
            {
              sqd_regerror("invalid [] range");
              return (char *)(void *)0;
            }

            range = range + 1;
            for( ; rangeend >= range; range = range + 1)
              regc(cp, range);
            cp->regparse = cp->regparse + 1l;
          }
        }
      }
      while((_Bool)1);
      regc(cp, 0);
      if(!(c == 93))
      {
        sqd_regerror("unmatched []");
        return (char *)(void *)0;
      }

      *flagp = *flagp | 01 | 02;
      break;
    }
    case 40:
    {
      ret=reg(cp, 1, &flags);
      if(ret == ((char *)NULL))
        return (char *)(void *)0;

      *flagp = *flagp | flags & (01 | 04);
      break;
    }
    case 0:

    case 124:

    case 41:
    {
      sqd_regerror("internal error: \\0|) unexpected");
      return (char *)(void *)0;
    }
    case 63:

    case 43:

    case 42:
    {
      sqd_regerror("?+* follows nothing");
      return (char *)(void *)0;
    }
    case 92:
    {
      if((signed int)*cp->regparse == 0)
      {
        sqd_regerror("trailing \\");
        return (char *)(void *)0;
      }

      ret=regnode(cp, 8);
      tmp_post$3 = cp->regparse;
      cp->regparse = cp->regparse + 1l;
      regc(cp, (signed int)*tmp_post$3);
      regc(cp, 0);
      *flagp = *flagp | 01 | 02;
      break;
    }
    default:
    {
      cp->regparse = cp->regparse - 1l;
      len=strcspn(cp->regparse, "^$.[()|?+*\\");
      if(len == 0ul)
      {
        sqd_regerror("internal error: strcspn 0");
        return (char *)(void *)0;
      }

      ender = cp->regparse[(signed long int)len];
      if(len >= 2ul && ((signed int)ender == 42 || (signed int)ender == 43 || (signed int)ender == 63))
        len = len - 1ul;

      *flagp = *flagp | 01;
      if(len == 1ul)
        *flagp = *flagp | 02;

      ret=regnode(cp, 8);
      for( ; len >= 1ul; len = len - 1ul)
      {
        tmp_post$4 = cp->regparse;
        cp->regparse = cp->regparse + 1l;
        regc(cp, (signed int)*tmp_post$4);
      }
      regc(cp, 0);
    }
  }
  return ret;
}

// regbranch
// file hsregex.c line 493
static char * regbranch(struct comp *cp, signed int *flagp)
{
  char *ret;
  char *chain;
  char *latest;
  signed int flags;
  signed int c;
  *flagp = 0;
  ret=regnode(cp, 6);
  chain = (char *)(void *)0;
  do
  {
    c = (signed int)*cp->regparse;
    if(c == 0)
      break;

    if(c == 124)
      break;

    if(c == 41)
      break;

    latest=regpiece(cp, &flags);
    if(latest == ((char *)NULL))
      return (char *)(void *)0;

    *flagp = *flagp | flags & 01;
    if(chain == ((char *)NULL))
      *flagp = *flagp | flags & 04;

    else
      regtail(cp, chain, latest);
    chain = latest;
  }
  while((_Bool)1);
  if(chain == ((char *)NULL))
    regnode(cp, 9);

  return ret;
}

// regc
// file hsregex.c line 739
static void regc(struct comp *cp, char b)
{
  char *tmp_post$1;
  if(!(cp->regcode == cp->regdummy))
  {
    tmp_post$1 = cp->regcode;
    cp->regcode = cp->regcode + 1l;
    *tmp_post$1 = b;
  }

  else
    cp->regsize = cp->regsize + 1l;
}

// reginsert
// file hsregex.c line 755
static void reginsert(struct comp *cp, char op, char *opnd)
{
  char *place;
  char *tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  if(cp->regcode == cp->regdummy)
    cp->regsize = cp->regsize + (signed long int)3;

  else
  {
    memmove((void *)(opnd + (signed long int)3), (const void *)opnd, (unsigned long int)(cp->regcode - opnd));
    cp->regcode = cp->regcode + (signed long int)3;
    place = opnd;
    tmp_post$1 = place;
    place = place + 1l;
    *tmp_post$1 = op;
    tmp_post$2 = place;
    place = place + 1l;
    *tmp_post$2 = (char)0;
    tmp_post$3 = place;
    place = place + 1l;
    *tmp_post$3 = (char)0;
  }
}

// regmatch
// file hsregex.c line 937
static signed int regmatch(struct exec *ep, char *prog)
{
  char *scan;
  char *next;
  scan = prog;
  signed int return_value_strncmp$1;
  _Bool tmp_if_expr$3;
  char *return_value_strchr$2;
  _Bool tmp_if_expr$5;
  char *return_value_strchr$4;
  signed int tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  signed int return_value_regmatch$11;
  for( ; !(scan == ((char *)NULL)); scan = next)
  {
    next=regnext(scan);
    if(!((signed int)*scan == 1))
    {
      if((signed int)*scan == 2)
        goto __CPROVER_DUMP_L4;

      if((signed int)*scan == 3)
        goto __CPROVER_DUMP_L6;

      if((signed int)*scan == 8)
        goto __CPROVER_DUMP_L8;

      if((signed int)*scan == 4)
        goto __CPROVER_DUMP_L11;

      if((signed int)*scan == 5)
        goto __CPROVER_DUMP_L15;

      if((signed int)*scan == 9)
        goto __CPROVER_DUMP_L19;

      if((signed int)*scan == 7)
        goto __CPROVER_DUMP_L20;

      if((signed int)*scan == 1 || (signed int)*scan == 2 || (signed int)*scan == 3 || (signed int)*scan == 4 || (signed int)*scan == 5 || (signed int)*scan == 6 || (signed int)*scan == 7 || (signed int)*scan == 8 || (signed int)*scan == 9)
        goto __CPROVER_DUMP_L21;

      if((signed int)*scan == 1 || (signed int)*scan == 2 || (signed int)*scan == 3 || (signed int)*scan == 4 || (signed int)*scan == 5 || (signed int)*scan == 6 || (signed int)*scan == 7 || (signed int)*scan == 8 || (signed int)*scan == 9)
        goto __CPROVER_DUMP_L25;

      if((signed int)*scan == 6)
        goto __CPROVER_DUMP_L29;

      if((signed int)*scan == 10 || (signed int)*scan == 11)
        goto __CPROVER_DUMP_L34;

      if((signed int)*scan == 0)
        goto __CPROVER_DUMP_L42;

    }

    else
    {
      if(!(ep->reginput == ep->regbol))
        return 0;

      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L4:
      ;
      if(!((signed int)*ep->reginput == 0))
        return 0;

      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L6:
      ;
      if((signed int)*ep->reginput == 0)
        return 0;

      ep->reginput = ep->reginput + 1l;
      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L8:
      ;
      unsigned long int len;
      char * const opnd = scan + (signed long int)3;
      if(!(*opnd == *ep->reginput))
        return 0;

      len=strlen(opnd);
      if(len >= 2ul)
      {
        return_value_strncmp$1=strncmp(opnd, ep->reginput, len);
        if(!(return_value_strncmp$1 == 0))
          return 0;

      }

      ep->reginput = ep->reginput + (signed long int)len;
      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L11:
      ;
      if((signed int)*ep->reginput == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strchr$2=strchr(scan + (signed long int)3, (signed int)*ep->reginput);
        tmp_if_expr$3 = return_value_strchr$2 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        return 0;

      ep->reginput = ep->reginput + 1l;
      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L15:
      ;
      if((signed int)*ep->reginput == 0)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_strchr$4=strchr(scan + (signed long int)3, (signed int)*ep->reginput);
        tmp_if_expr$5 = return_value_strchr$4 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        return 0;

      ep->reginput = ep->reginput + 1l;
      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L19:
      ;
      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L20:
      ;
      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L21:
      ;
      const signed int regmatch$$1$$1$$1$$1$$2$$no = (signed int)*scan - 20;
      char * const input = ep->reginput;
      signed int return_value_regmatch$6;
      return_value_regmatch$6=regmatch(ep, next);
      if(!(return_value_regmatch$6 == 0))
      {
        if(ep->regstartp[(signed long int)regmatch$$1$$1$$1$$1$$2$$no] == ((char *)NULL))
          ep->regstartp[(signed long int)regmatch$$1$$1$$1$$1$$2$$no] = input;

        return 1;
      }

      else
        return 0;

    __CPROVER_DUMP_L25:
      ;
      const signed int regmatch$$1$$1$$1$$1$$3$$no = (signed int)*scan - 30;
      char * const regmatch$$1$$1$$1$$1$$3$$input = ep->reginput;
      signed int return_value_regmatch$7;
      return_value_regmatch$7=regmatch(ep, next);
      if(!(return_value_regmatch$7 == 0))
      {
        if(ep->regendp[(signed long int)regmatch$$1$$1$$1$$1$$3$$no] == ((char *)NULL))
          ep->regendp[(signed long int)regmatch$$1$$1$$1$$1$$3$$no] = regmatch$$1$$1$$1$$1$$3$$input;

        return 1;
      }

      else
        return 0;

    __CPROVER_DUMP_L29:
      ;
      char * const regmatch$$1$$1$$1$$1$$4$$save = ep->reginput;
      if(!((signed int)*next == 6))
        next = scan + (signed long int)3;

      else
      {
        while((signed int)*scan == 6)
        {
          signed int return_value_regmatch$8;
          return_value_regmatch$8=regmatch(ep, scan + (signed long int)3);
          if(!(return_value_regmatch$8 == 0))
            return 1;

          ep->reginput = regmatch$$1$$1$$1$$1$$4$$save;
          scan=regnext(scan);
        }
        return 0;
      }
      goto __CPROVER_DUMP_L44;

    __CPROVER_DUMP_L34:
      ;
      char nextch;
      if((signed int)*next == 8)
        tmp_if_expr$9 = (signed int)next[(signed long int)3];

      else
        tmp_if_expr$9 = 0;
      nextch = (const char)tmp_if_expr$9;
      unsigned long int no;
      char * const save = ep->reginput;
      const unsigned long int min = (const unsigned long int)((signed int)*scan == 10 ? 0 : 1);
      unsigned long int return_value_regrepeat$10;
      return_value_regrepeat$10=regrepeat(ep, scan + (signed long int)3);
      no = return_value_regrepeat$10 + (unsigned long int)1;
      for( ; !(min >= no); no = no - 1ul)
      {
        ep->reginput = (save + (signed long int)no) - (signed long int)1;
        if((signed int)nextch == 0)
          tmp_if_expr$12 = (_Bool)1;

        else
          tmp_if_expr$12 = *ep->reginput == nextch ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$12)
        {
          return_value_regmatch$11=regmatch(ep, next);
          if(!(return_value_regmatch$11 == 0))
            return 1;

        }

      }
      return 0;

    __CPROVER_DUMP_L42:
      ;
      return 1;
    }
    sqd_regerror("regexp corruption");
    return 0;

  __CPROVER_DUMP_L44:
    ;
  }
  sqd_regerror("corrupted pointers");
  return 0;
}

// regnext
// file hsregex.c line 1135
static char * regnext(char *p)
{
  const signed int offset = (((signed int)p[(signed long int)1] & 0177) << 8) + ((signed int)p[(signed long int)2] & 0377);
  if(offset == 0)
    return (char *)(void *)0;

  else
    return (signed int)*p == 7 ? p - (signed long int)offset : p + (signed long int)offset;
}

// regnode
// file hsregex.c line 714
static char * regnode(struct comp *cp, char op)
{
  char * const ret = cp->regcode;
  char *ptr;
  char *tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  if(cp->regcode == cp->regdummy)
  {
    cp->regsize = cp->regsize + (signed long int)3;
    return ret;
  }

  else
  {
    ptr = ret;
    tmp_post$1 = ptr;
    ptr = ptr + 1l;
    *tmp_post$1 = op;
    tmp_post$2 = ptr;
    ptr = ptr + 1l;
    *tmp_post$2 = (char)0;
    tmp_post$3 = ptr;
    ptr = ptr + 1l;
    *tmp_post$3 = (char)0;
    cp->regcode = ptr;
    return ret;
  }
}

// regoptail
// file hsregex.c line 805
static void regoptail(struct comp *cp, char *p, char *val)
{
  _Bool tmp_if_expr$1;
  if(cp->regcode == cp->regdummy)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*p != 6 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
    regtail(cp, p + (signed long int)3, val);

}

// regpiece
// file hsregex.c line 534
static char * regpiece(struct comp *cp, signed int *flagp)
{
  char *ret;
  char op;
  char *next;
  signed int flags;
  ret=regatom(cp, &flags);
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  if(ret == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    op = *cp->regparse;
    if(!((signed int)op == 42) && !((signed int)op == 43) && !((signed int)op == 63))
    {
      *flagp = flags;
      return ret;
    }

    else
      if((01 & flags) == 0 && !((signed int)op == 63))
      {
        sqd_regerror("*+ operand could be empty");
        return (char *)(void *)0;
      }

      else
      {
        switch((signed int)op)
        {
          case 42:
          {
            *flagp = 0 | 04;
            break;
          }
          case 43:
          {
            *flagp = 0 | 04 | 01;
            break;
          }
          case 63:
            *flagp = 0;
        }
        if((signed int)op == 42 && !((02 & flags) == 0))
          reginsert(cp, 10, ret);

        else
          if((signed int)op == 42)
          {
            reginsert(cp, 6, ret);
            char *return_value_regnode$1;
            return_value_regnode$1=regnode(cp, 7);
            regoptail(cp, ret, return_value_regnode$1);
            regoptail(cp, ret, ret);
            char *return_value_regnode$2;
            return_value_regnode$2=regnode(cp, 6);
            regtail(cp, ret, return_value_regnode$2);
            char *return_value_regnode$3;
            return_value_regnode$3=regnode(cp, 9);
            regtail(cp, ret, return_value_regnode$3);
          }

          else
            if((signed int)op == 43 && !((02 & flags) == 0))
              reginsert(cp, 11, ret);

            else
              if((signed int)op == 43)
              {
                next=regnode(cp, 6);
                regtail(cp, ret, next);
                char *return_value_regnode$4;
                return_value_regnode$4=regnode(cp, 7);
                regtail(cp, return_value_regnode$4, ret);
                char *return_value_regnode$5;
                return_value_regnode$5=regnode(cp, 6);
                regtail(cp, next, return_value_regnode$5);
                char *return_value_regnode$6;
                return_value_regnode$6=regnode(cp, 9);
                regtail(cp, ret, return_value_regnode$6);
              }

              else
                if((signed int)op == 63)
                {
                  reginsert(cp, 6, ret);
                  char *return_value_regnode$7;
                  return_value_regnode$7=regnode(cp, 6);
                  regtail(cp, ret, return_value_regnode$7);
                  next=regnode(cp, 9);
                  regtail(cp, ret, next);
                  regoptail(cp, ret, next);
                }

        cp->regparse = cp->regparse + 1l;
        if((signed int)*cp->regparse == 42)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)*cp->regparse == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = (signed int)*cp->regparse == 63 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
        {
          sqd_regerror("nested *?+");
          return (char *)(void *)0;
        }

        else
          return ret;
      }
  }
}

// regrepeat
// file hsregex.c line 1096
static unsigned long int regrepeat(struct exec *ep, char *node)
{
  unsigned long int count;
  char *scan;
  char ch;
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strspn$2;
  unsigned long int return_value_strcspn$3;
  switch((signed int)*node)
  {
    case 3:
    {
      return_value_strlen$1=strlen(ep->reginput);
      return return_value_strlen$1;
    }
    case 8:
    {
      ch = node[(signed long int)3];
      count = (unsigned long int)0;
      scan = ep->reginput;
      for( ; *scan == ch; scan = scan + 1l)
        count = count + 1ul;
      return count;
    }
    case 4:
    {
      return_value_strspn$2=strspn(ep->reginput, node + (signed long int)3);
      return return_value_strspn$2;
    }
    case 5:
    {
      return_value_strcspn$3=strcspn(ep->reginput, node + (signed long int)3);
      return return_value_strcspn$3;
    }
    default:
    {
      sqd_regerror("internal error: bad call of regrepeat");
      return (unsigned long int)0;
    }
  }
}

// regtail
// file hsregex.c line 780
static void regtail(struct comp *cp, char *p, char *val)
{
  char *scan;
  char *temp;
  signed int offset;
  if(!(cp->regcode == cp->regdummy))
  {
    scan = p;
    do
    {
      temp=regnext(scan);
      if(temp == ((char *)NULL))
        break;

      scan = temp;
    }
    while((_Bool)1);
    offset = (signed int)((signed int)*scan == 7 ? scan - val : val - scan);
    scan[(signed long int)1] = (char)(offset >> 8 & 0177);
    scan[(signed long int)2] = (char)(offset & 0377);
  }

}

// regtry
// file hsregex.c line 901
static signed int regtry(struct exec *ep, struct sqd_regexp *prog, char *string)
{
  signed int i;
  char **stp;
  char **enp;
  ep->reginput = string;
  stp = prog->startp;
  enp = prog->endp;
  i = 10;
  char **tmp_post$1;
  char **tmp_post$2;
  for( ; i >= 1; i = i - 1)
  {
    tmp_post$1 = stp;
    stp = stp + 1l;
    *tmp_post$1 = (char *)(void *)0;
    tmp_post$2 = enp;
    enp = enp + 1l;
    *tmp_post$2 = (char *)(void *)0;
  }
  signed int return_value_regmatch$3;
  return_value_regmatch$3=regmatch(ep, prog->program + (signed long int)1);
  if(!(return_value_regmatch$3 == 0))
  {
    prog->startp[(signed long int)0] = string;
    prog->endp[(signed long int)0] = ep->reginput;
    return 1;
  }

  else
    return 0;
}

// revcomp
// file revcomp.c line 35
extern char * revcomp(char *comp, char *seq)
{
  char *s;
  char c;
  signed int return_value_sre_tolower$2;
  if(comp == ((char *)NULL))
    return (char *)(void *)0;

  else
    if(seq == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      StrReverse(comp, seq);
      s = comp;
      for( ; !((signed int)*s == 0); s = s + 1l)
      {
        c = *s;
        signed int return_value_sre_toupper$1;
        return_value_sre_toupper$1=sre_toupper((signed int)c);
        c = (char)return_value_sre_toupper$1;
        switch((signed int)c)
        {
          case 65:
          {
            c = (char)84;
            break;
          }
          case 67:
          {
            c = (char)71;
            break;
          }
          case 71:
          {
            c = (char)67;
            break;
          }
          case 84:
          {
            c = (char)65;
            break;
          }
          case 85:
          {
            c = (char)65;
            break;
          }
          case 82:
          {
            c = (char)89;
            break;
          }
          case 89:
          {
            c = (char)82;
            break;
          }
          case 77:
          {
            c = (char)75;
            break;
          }
          case 75:
          {
            c = (char)77;
            break;
          }
          case 83:
          {
            c = (char)83;
            break;
          }
          case 87:
          {
            c = (char)87;
            break;
          }
          case 72:
          {
            c = (char)68;
            break;
          }
          case 68:
          {
            c = (char)72;
            break;
          }
          case 66:
          {
            c = (char)86;
            break;
          }
          case 86:
            c = (char)66;
        }
        const unsigned short int **return_value___ctype_b_loc$3;
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if(!((512 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*s]) == 0))
        {
          return_value_sre_tolower$2=sre_tolower((signed int)c);
          c = (char)return_value_sre_tolower$2;
        }

        *s = c;
      }
      return comp;
    }
}

// rightjustify
// file trace.c line 1197
static void rightjustify(char *s, signed int n)
{
  signed int npos;
  signed int opos;
  npos = n - 1;
  opos = n - 1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int tmp_post$1;
  signed int tmp_post$2;
  while(opos >= 0)
  {
    if((signed int)s[(signed long int)opos] == 32)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)s[(signed long int)opos] == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)s[(signed long int)opos] == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)s[(signed long int)opos] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)s[(signed long int)opos] == 126 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      opos = opos - 1;

    else
    {
      tmp_post$1 = npos;
      npos = npos - 1;
      tmp_post$2 = opos;
      opos = opos - 1;
      s[(signed long int)tmp_post$1] = s[(signed long int)tmp_post$2];
    }
  }
  signed int tmp_post$7;
  for( ; npos >= 0; s[(signed long int)tmp_post$7] = (char)46)
  {
    tmp_post$7 = npos;
    npos = npos - 1;
  }
}

// rkcomp
// file rk.c line 34
extern unsigned long int rkcomp(char *probe)
{
  unsigned long int hashprobe = (unsigned long int)0;
  char coded[17l];
  signed int len;
  signed int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(probe);
  len = (signed int)return_value_strlen$1;
  if((unsigned long int)len >= 17ul)
    return (unsigned long int)0;

  else
  {
    signed int return_value_seqencode$2;
    return_value_seqencode$2=seqencode(coded, probe);
    if(return_value_seqencode$2 == 0)
      return (unsigned long int)0;

    else
    {
      i = 0;
      for( ; !(i >= len); i = i + 1)
      {
        hashprobe = hashprobe << 4;
        hashprobe = hashprobe | (unsigned long int)coded[(signed long int)i];
      }
      for( ; !((unsigned long int)i >= sizeof(unsigned long int) * 2 /*16ul*/ ); i = i + 1)
      {
        hashprobe = hashprobe << 4;
        hashprobe = hashprobe | (unsigned long int)15;
      }
      return hashprobe;
    }
  }
}

// rkseq
// file rk.c line 61
extern signed int rkseq(unsigned long int hashprobe, char *sequence)
{
  signed long int i;
  signed long int pos = (signed long int)0;
  unsigned long int target = (unsigned long int)0;
  i = (signed long int)0;
  for( ; !((unsigned long int)i >= sizeof(unsigned long int) * 2 /*16ul*/ ); i = i + 1l)
  {
    if((signed int)sequence[i] == 0)
      break;

    target = target << 4;
    target = target | (unsigned long int)sequence[i];
  }
  for( ; !((signed int)sequence[pos + (signed long int)(sizeof(unsigned long int) + 7) /*15l*/ ] == 0); pos = pos + 1l)
  {
    if((target & hashprobe) == target)
      return (signed int)pos;

    target = target << 4;
    target = target | (unsigned long int)(sequence + pos)[(signed long int)(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)2)];
  }
  i = (signed long int)0;
  for( ; !((unsigned long int)i >= sizeof(unsigned long int) * 2 /*16ul*/ ); i = i + 1l)
  {
    target = target | (unsigned long int)15;
    if((target & hashprobe) == target)
      return (signed int)pos;

    target = target << 4;
    pos = pos + 1l;
  }
  return -1;
}

// s2lower
// file sqfuncs.h line 218
extern void s2lower(char *s)
{
  signed int return_value_sre_tolower$1;
  for( ; !((signed int)*s == 0); s = s + 1l)
  {
    return_value_sre_tolower$1=sre_tolower((signed int)*s);
    *s = (char)return_value_sre_tolower$1;
  }
}

// s2upper
// file ../squid/sqfuncs.h line 219
extern void s2upper(char *s)
{
  signed int return_value_sre_toupper$1;
  for( ; !((signed int)*s == 0); s = s + 1l)
  {
    return_value_sre_toupper$1=sre_toupper((signed int)*s);
    *s = (char)return_value_sre_toupper$1;
  }
}

// score2postcode
// file postprob.c line 678
static char score2postcode(signed int sc)
{
  char i;
  float return_value_Score2Prob$1;
  return_value_Score2Prob$1=Score2Prob(sc, (float)1.);
  i = (char)((double)return_value_Score2Prob$1 * 10.);
  return (char)((signed int)i > 9 ? 42 : 48 + (signed int)i);
}

// seqcmp
// file seqencode.c line 28
extern signed int seqcmp(char *s1, char *s2, signed int allow)
{
  signed int mmat = 0;
  for( ; !((signed int)*s1 == 0); s2 = s2 + 1l)
  {
    if((signed int)*s2 == 0)
      break;

    if(!(allow >= mmat))
      break;

    if(!(((signed int)*s1 & (signed int)*s2) == (signed int)*s2))
      mmat = mmat + 1;

    s1 = s1 + 1l;
  }
  char *tmp_post$1;
  do
  {
    tmp_post$1 = s1;
    s1 = s1 + 1l;
    if((signed int)*tmp_post$1 == 0)
      break;

    if(!(allow >= mmat))
      break;

    mmat = mmat + 1;
  }
  while((_Bool)1);
  return mmat;
}

// seqdecode
// file seqencode.c line 127
extern signed int seqdecode(char *str, char *codeseq)
{
  signed int idx;
  signed int pos = 0;
  for( ; !((signed int)*codeseq == 0); pos = pos + 1)
  {
    idx = 0;
    for( ; !(*codeseq == iupac[(signed long int)idx].code) && !(idx >= 17); idx = idx + 1)
      ;
    if(idx >= 18)
    {
      str[(signed long int)pos] = (char)88;
      return 0;
    }

    else
      str[(signed long int)pos] = iupac[(signed long int)idx].sym;
    codeseq = codeseq + 1l;
  }
  str[(signed long int)pos] = (char)0;
  return 1;
}

// seqencode
// file sqfuncs.h line 129
extern signed int seqencode(char *codeseq, char *str)
{
  char *ptr;
  signed int idx;
  ptr = codeseq;
  signed int return_value_toupper$1;
  while(!((signed int)*str == 0))
  {
    const unsigned short int **return_value___ctype_b_loc$2;
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if(!((512 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*str]) == 0))
    {
      return_value_toupper$1=toupper((signed int)*str);
      *str = (char)return_value_toupper$1;
    }

    idx = 0;
    for( ; !(*str == iupac[(signed long int)idx].sym) && !(idx >= 18); idx = idx + 1)
      ;
    if(idx >= 18)
    {
      *ptr = (char)0;
      return 0;
    }

    else
      *ptr = iupac[(signed long int)idx].code;
    ptr = ptr + 1l;
    str = str + 1l;
  }
  *ptr = (char)0;
  return 1;
}

// seqfile_open
// file sqio.c line 97
static struct ReadSeqVars * seqfile_open(char *filename, signed int format, char *env, signed int ssimode)
{
  struct ReadSeqVars *dbfp;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("sqio.c", 101, sizeof(struct ReadSeqVars) /*176ul*/ );
  dbfp = (struct ReadSeqVars *)return_value_sre_malloc$1;
  dbfp->ssimode = ssimode;
  dbfp->rpl = -1;
  dbfp->lastrpl = 0;
  dbfp->maxrpl = 0;
  dbfp->bpl = -1;
  dbfp->lastbpl = 0;
  dbfp->maxbpl = 0;
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(filename, "-");
  signed int return_value_Strparse$5;
  if(return_value_strcmp$6 == 0)
  {
    dbfp->f = stdin;
    dbfp->do_stdin = 1;
    dbfp->do_gzip = 0;
    dbfp->fname=sre_strdup("[STDIN]", -1);
  }

  else
  {
    return_value_Strparse$5=Strparse("^.*\\.gz$", filename, 0);
    if(!(return_value_Strparse$5 == 0))
    {
      char cmd[256l];
      signed int return_value_FileExists$2;
      return_value_FileExists$2=FileExists(filename);
      if(return_value_FileExists$2 == 0)
        Die("%s: file does not exist", filename);

      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(filename);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen("gzip -dc ");
      if(return_value_strlen$3 + return_value_strlen$4 >= 256ul)
        Die("filename > 255 char in SeqfileOpen()");

      sprintf(cmd, "gzip -dc %s", filename);
      dbfp->f=popen(cmd, "r");
      if(dbfp->f == ((struct _IO_FILE *)NULL))
        return (struct ReadSeqVars *)(void *)0;

      dbfp->do_stdin = 0;
      dbfp->do_gzip = 1;
      dbfp->fname=sre_strdup(filename, -1);
    }

    else
    {
      dbfp->f=fopen(filename, "r");
      if(dbfp->f == ((struct _IO_FILE *)NULL))
      {
        dbfp->f=EnvFileOpen(filename, env, (char **)(void *)0);
        if(dbfp->f == ((struct _IO_FILE *)NULL))
          return (struct ReadSeqVars *)(void *)0;

      }

      dbfp->do_stdin = 0;
      dbfp->do_gzip = 0;
      dbfp->fname=sre_strdup(filename, -1);
    }
  }
  _Bool tmp_if_expr$7;
  if(format == 0)
  {
    if(dbfp->do_stdin == 1)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = dbfp->do_gzip != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      Die("Can't autodetect sequence file format from a stdin or gzip pipe");

    format=SeqfileFormat(dbfp->f);
    if(format == 0)
      Die("Can't determine format of sequence file %s", dbfp->fname);

  }

  dbfp->msa = (struct msa_struct *)(void *)0;
  dbfp->afp = (struct msafile_struct *)(void *)0;
  dbfp->format = format;
  dbfp->linenumber = 0;
  dbfp->buf = (char *)(void *)0;
  dbfp->buflen = 0;
  if(format >= 101)
  {
    void *return_value_sre_malloc$8;
    return_value_sre_malloc$8=sre_malloc("sqio.c", 190, sizeof(struct msafile_struct) /*64ul*/ );
    dbfp->afp = (struct msafile_struct *)return_value_sre_malloc$8;
    dbfp->afp->f = dbfp->f;
    dbfp->afp->do_stdin = dbfp->do_stdin;
    dbfp->afp->do_gzip = dbfp->do_gzip;
    dbfp->afp->fname = dbfp->fname;
    dbfp->afp->format = dbfp->format;
    dbfp->afp->linenumber = dbfp->linenumber;
    dbfp->afp->buf = (char *)(void *)0;
    dbfp->afp->buflen = 0;
    dbfp->msa=MSAFileRead(dbfp->afp);
    if(dbfp->msa == ((struct msa_struct *)NULL))
      Die("Failed to read any alignment data from file %s", dbfp->fname);

    dbfp->msa->lastidx = 0;
    return dbfp;
  }

  SeqfileGetLine(dbfp);
  return dbfp;
}

// seqncmp
// file seqencode.c line 47
extern signed int seqncmp(char *s1, char *s2, signed int n, signed int allow)
{
  signed int mmat = 0;
  signed int tmp_post$1;
  for( ; !((signed int)*s2 == 0); s2 = s2 + 1l)
  {
    tmp_post$1 = n;
    n = n - 1;
    if(tmp_post$1 == 0)
      break;

    if(!(((signed int)*s1 & (signed int)*s2) == (signed int)*s2))
    {
      mmat = mmat + 1;
      if(!(allow >= mmat))
        return mmat;

    }

    s1 = s1 + 1l;
  }
  signed int tmp_post$2;
  char *tmp_post$3;
  do
  {
    tmp_post$2 = n;
    n = n - 1;
    if(tmp_post$2 == 0)
      break;

    tmp_post$3 = s1;
    s1 = s1 + 1l;
    if((signed int)*tmp_post$3 == 0)
      break;

    if(!(allow >= mmat))
      break;

    mmat = mmat + 1;
  }
  while((_Bool)1);
  return mmat;
}

// seqndecode
// file seqencode.c line 152
extern signed int seqndecode(char *str, char *codeseq, signed int n)
{
  signed int idx;
  signed int pos = 0;
  do
  {
    n = n - 1;
    if(!(n >= 0))
      break;

    idx = 0;
    for( ; !(*codeseq == iupac[(signed long int)idx].code) && !(idx >= 17); idx = idx + 1)
      ;
    if(idx >= 18)
    {
      str[(signed long int)pos] = (char)88;
      return 0;
    }

    else
      str[(signed long int)pos] = iupac[(signed long int)idx].sym;
    codeseq = codeseq + 1l;
    pos = pos + 1;
  }
  while((_Bool)1);
  str[(signed long int)pos] = (char)0;
  return 1;
}

// set_degenerate
// file alphabet.c line 417
static void set_degenerate(char iupac, char *syms)
{
  char *return_value_strchr$1;
  return_value_strchr$1=strchr(Alphabet, (signed int)iupac);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(syms);
  DegenCount[return_value_strchr$1 - Alphabet] = (signed int)return_value_strlen$2;
  while(!(*syms == 0))
  {
    char *return_value_strchr$3;
    return_value_strchr$3=strchr(Alphabet, (signed int)iupac);
    char *return_value_strchr$4;
    return_value_strchr$4=strchr(Alphabet, (signed int)*syms);
    Degenerate[return_value_strchr$3 - Alphabet][return_value_strchr$4 - Alphabet] = (char)1;
    syms = syms + 1l;
  }
}

// simple_diffmx
// file weight.c line 343
static signed int simple_diffmx(char **aseqs, signed int num, float ***ret_dmx)
{
  float **dmx;
  signed int i;
  signed int j;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(float *) /*8ul*/  * (unsigned long int)num);
  dmx = (float **)return_value_malloc$1;
  if(dmx == ((float **)NULL))
    Die("malloc failed");

  i = 0;
  void *return_value_malloc$2;
  for( ; !(i >= num); i = i + 1)
  {
    return_value_malloc$2=malloc(sizeof(float) /*4ul*/  * (unsigned long int)num);
    dmx[(signed long int)i] = (float *)return_value_malloc$2;
    if(dmx[(signed long int)i] == ((float *)NULL))
      Die("malloc failed");

  }
  i = 0;
  for( ; !(i >= num); i = i + 1)
  {
    j = i;
    for( ; !(j >= num); j = j + 1)
    {
      dmx[(signed long int)j][(signed long int)i]=simple_distance(aseqs[(signed long int)i], aseqs[(signed long int)j]);
      dmx[(signed long int)i][(signed long int)j] = dmx[(signed long int)j][(signed long int)i];
    }
  }
  *ret_dmx = dmx;
  return 1;
}

// simple_distance
// file weight.c line 316
static float simple_distance(char *s1, char *s2)
{
  signed int diff = 0;
  signed int valid = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  for( ; !((signed int)*s1 == 0); s2 = s2 + 1l)
  {
    if((signed int)*s1 == 32)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*s1 == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*s1 == 95 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)*s1 == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*s1 == 126 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      if((signed int)*s2 == 32)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)*s2 == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)*s2 == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)*s2 == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)*s2 == 126 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$9)
    {
      if(!(*s1 == *s2))
        diff = diff + 1;

      valid = valid + 1;
    }

    s1 = s1 + 1l;
  }
  return (float)(valid > 0 ? (double)((float)diff / (float)valid) : 0.0);
}

// skeysort
// file ssi.c line 863
static signed int skeysort(const void *k1, const void *k2)
{
  struct ssiskey_s *key1;
  struct ssiskey_s *key2;
  key1 = (struct ssiskey_s *)k1;
  key2 = (struct ssiskey_s *)k2;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(key1->key, key2->key);
  return return_value_strcmp$1;
}

// sqd_regcomp
// file hsregex.c line 334
extern struct sqd_regexp * sqd_regcomp(const char *exp)
{
  struct sqd_regexp *r;
  char *scan;
  signed int flags;
  struct comp co;
  unsigned long int return_value_strlen$4;
  if(exp == ((const char *)NULL))
  {
    sqd_regerror("NULL argument to sqd_regcomp");
    return (struct sqd_regexp *)(void *)0;
  }

  else
  {
    co.regparse = (char *)exp;
    co.regnpar = 1;
    co.regsize = 0L;
    co.regdummy[(signed long int)0] = (char)9;
    co.regdummy[(signed long int)2] = (char)0;
    co.regdummy[(signed long int)1] = co.regdummy[(signed long int)2];
    co.regcode = co.regdummy;
    regc(&co, 0234);
    char *return_value_reg$1;
    return_value_reg$1=reg(&co, 0, &flags);
    if(return_value_reg$1 == ((char *)NULL))
      return (struct sqd_regexp *)(void *)0;

    else
      if(co.regsize >= 0x7fffL)
      {
        sqd_regerror("regexp too big");
        return (struct sqd_regexp *)(void *)0;
      }

      else
      {
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(sizeof(struct sqd_regexp) /*184ul*/  + (unsigned long int)co.regsize);
        r = (struct sqd_regexp *)return_value_malloc$2;
        if(r == ((struct sqd_regexp *)NULL))
        {
          sqd_regerror("out of space");
          return (struct sqd_regexp *)(void *)0;
        }

        else
        {
          co.regparse = (char *)exp;
          co.regnpar = 1;
          co.regcode = r->program;
          regc(&co, 0234);
          char *return_value_reg$3;
          return_value_reg$3=reg(&co, 0, &flags);
          if(return_value_reg$3 == ((char *)NULL))
            return (struct sqd_regexp *)(void *)0;

          else
          {
            r->regstart = (char)0;
            r->reganch = (char)0;
            r->regmust = (char *)(void *)0;
            r->regmlen = 0;
            scan = r->program + (signed long int)1;
            char *return_value_regnext$5;
            return_value_regnext$5=regnext(scan);
            if((signed int)*return_value_regnext$5 == 0)
            {
              scan = scan + (signed long int)3;
              if((signed int)*scan == 8)
                r->regstart = scan[(signed long int)3];

              else
                if((signed int)*scan == 1)
                  r->reganch = (char)1;

              if(!((04 & flags) == 0))
              {
                char *longest = (char *)(void *)0;
                unsigned long int len = (unsigned long int)0;
                while(!(scan == ((char *)NULL)))
                {
                  if((signed int)*scan == 8)
                  {
                    return_value_strlen$4=strlen(scan + (signed long int)3);
                    if(return_value_strlen$4 >= len)
                    {
                      longest = scan + (signed long int)3;
                      len=strlen(scan + (signed long int)3);
                    }

                  }

                  scan=regnext(scan);
                }
                r->regmust = longest;
                r->regmlen = (signed int)len;
              }

            }

            return r;
          }
        }
      }
  }
}

// sqd_regerror
// file hsregex.c line 1330
extern void sqd_regerror(char *s)
{
  fprintf(stderr, "regexp(3): %s\n", s);
  exit(1);
}

// sqd_regexec
// file hsregex.c line 847
extern signed int sqd_regexec(struct sqd_regexp *prog, const char *str)
{
  char *string = (char *)str;
  char *s;
  struct exec ex;
  char *return_value_strstr$1;
  signed int return_value_regtry$2;
  signed int return_value_regtry$3;
  signed int return_value_regtry$4;
  if(string == ((char *)NULL) || prog == ((struct sqd_regexp *)NULL))
  {
    sqd_regerror("NULL argument to sqd_regexec");
    return 0;
  }

  else
    if(!((signed int)(unsigned char)prog->program[0l] == 0234))
    {
      sqd_regerror("corrupted regexp");
      return 0;
    }

    else
      if(!(prog->regmust == ((char *)NULL)))
      {
        return_value_strstr$1=strstr(string, prog->regmust);
        if(!(return_value_strstr$1 == ((char *)NULL)))
          goto __CPROVER_DUMP_L3;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        ex.regbol = string;
        ex.regstartp = prog->startp;
        ex.regendp = prog->endp;
        if(!(prog->reganch == 0))
        {
          return_value_regtry$2=regtry(&ex, prog, string);
          return return_value_regtry$2;
        }

        else
          if(!((signed int)prog->regstart == 0))
          {
            s = string;
            while(!(s == ((char *)NULL)))
            {
              return_value_regtry$3=regtry(&ex, prog, s);
              if(!(return_value_regtry$3 == 0))
                return 1;

              s=strchr(s + (signed long int)1, (signed int)prog->regstart);
            }
            return 0;
          }

          else
          {
            s = string;
            do
            {
              return_value_regtry$4=regtry(&ex, prog, s);
              if(!(return_value_regtry$4 == 0))
                break;

              if((signed int)*s == 0)
                return 0;

              s = s + 1l;
            }
            while((_Bool)1);
            return 1;
          }
      }
}

// sqd_regsub
// file hsregex.c line 1281
extern void sqd_regsub(const struct sqd_regexp *rp, const char *source, char *dest)
{
  struct sqd_regexp * const prog = (struct sqd_regexp *)rp;
  char *src = (char *)source;
  char *dst = dest;
  char c;
  signed int no;
  unsigned long int len;
  char *tmp_post$1;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  char *tmp_post$2;
  _Bool tmp_if_expr$6;
  char *tmp_post$5;
  char *tmp_post$7;
  char *tmp_post$8;
  if(dest == ((char *)NULL) || source == ((const char *)NULL) || prog == ((struct sqd_regexp *)NULL))
    sqd_regerror("NULL parameter to sqd_regsub");

  else
    if(!((signed int)(unsigned char)prog->program[0l] == 0234))
      sqd_regerror("damaged regexp");

    else
    {
      do
      {
        tmp_post$1 = src;
        src = src + 1l;
        c = *tmp_post$1;
        if((signed int)c == 0)
          break;

        if((signed int)c == 38)
          no = 0;

        else
        {
          if((signed int)c == 92)
          {
            return_value___ctype_b_loc$3=__ctype_b_loc();
            tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*src] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            tmp_post$2 = src;
            src = src + 1l;
            no = (signed int)*tmp_post$2 - 48;
          }

          else
            no = -1;
        }
        if(!(no >= 0))
        {
          if((signed int)c == 92)
          {
            if((signed int)*src == 92)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = (signed int)*src == 38 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
            {
              tmp_post$5 = src;
              src = src + 1l;
              c = *tmp_post$5;
            }

          }

          tmp_post$7 = dst;
          dst = dst + 1l;
          *tmp_post$7 = c;
        }

        else
          if(!(prog->startp[(signed long int)no] == ((char *)NULL)))
          {
            if(!(prog->endp[(signed long int)no] == ((char *)NULL)))
            {
              if(!(prog->startp[(signed long int)no] >= prog->endp[(signed long int)no]))
              {
                len = (unsigned long int)(prog->endp[(signed long int)no] - prog->startp[(signed long int)no]);
                strncpy(dst, prog->startp[(signed long int)no], len);
                dst = dst + (signed long int)len;
                if((signed int)dst[-1l] == 0)
                {
                  sqd_regerror("damaged match string");
                  goto __CPROVER_DUMP_L14;
                }

              }

            }

          }

      }
      while((_Bool)1);
      tmp_post$8 = dst;
      dst = dst + 1l;
      *tmp_post$8 = (char)0;
    }

__CPROVER_DUMP_L14:
  ;
}

// sre_fgets
// file sqfuncs.h line 225
extern char * sre_fgets(char **buf, signed int *n, struct _IO_FILE *fp)
{
  char *s;
  signed int len;
  signed int pos;
  if(*n == 0)
  {
    void *return_value_sre_malloc$1;
    return_value_sre_malloc$1=sre_malloc("sre_string.c", 253, sizeof(char) /*1ul*/  * (unsigned long int)128);
    *buf = (char *)return_value_sre_malloc$1;
    *n = 128;
  }

  char *return_value_fgets$2;
  return_value_fgets$2=fgets(*buf, *n, fp);
  if(return_value_fgets$2 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    signed int return_value_feof$3;
    return_value_feof$3=feof(fp);
    if(!(return_value_feof$3 == 0))
      return *buf;

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(*buf);
      len = (signed int)return_value_strlen$4;
      if((signed int)(*buf)[(signed long int)(len + -1)] == 10)
        return *buf;

      else
      {
        pos = *n - 1;
        while((_Bool)1)
        {
          *n = *n + 128;
          void *return_value_sre_realloc$5;
          return_value_sre_realloc$5=sre_realloc("sre_string.c", 283, (void *)*buf, sizeof(char) /*1ul*/  * (unsigned long int)*n);
          *buf = (char *)return_value_sre_realloc$5;
          s = *buf + (signed long int)pos;
          char *return_value_fgets$6;
          return_value_fgets$6=fgets(s, 129, fp);
          if(return_value_fgets$6 == ((char *)NULL))
            return *buf;

          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(s);
          len = (signed int)return_value_strlen$7;
          if((signed int)s[(signed long int)(len + -1)] == 10)
            return *buf;

          pos = pos + 128;
        }
      }
    }
  }
}

// sre_hton16
// file sqfuncs.h line 255
extern unsigned short int sre_hton16(unsigned short int hostshort)
{
  Byteswap((char *)&hostshort, 2);
  return hostshort;
}

// sre_hton32
// file sqfuncs.h line 256
extern unsigned int sre_hton32(unsigned int hostlong)
{
  Byteswap((char *)&hostlong, 4);
  return hostlong;
}

// sre_hton64
// file sqfuncs.h line 259
extern unsigned long int sre_hton64(unsigned long int host_int64)
{
  Byteswap((char *)&host_int64, 8);
  return host_int64;
}

// sre_malloc
// file ../squid/sqfuncs.h line 220
extern void * sre_malloc(char *file, signed int line, unsigned long int size)
{
  void *ptr;
  ptr=malloc(size);
  if(ptr == NULL)
    Die("malloc of %ld bytes failed: file %s line %d", size, file, line);

  return ptr;
}

// sre_ntoh16
// file sqfuncs.h line 253
extern unsigned short int sre_ntoh16(unsigned short int netshort)
{
  Byteswap((char *)&netshort, 2);
  return netshort;
}

// sre_ntoh32
// file sqfuncs.h line 254
extern unsigned int sre_ntoh32(unsigned int netlong)
{
  Byteswap((char *)&netlong, 4);
  return netlong;
}

// sre_ntoh64
// file sqfuncs.h line 258
extern unsigned long int sre_ntoh64(unsigned long int net_int64)
{
  Byteswap((char *)&net_int64, 8);
  return net_int64;
}

// sre_random
// file ../squid/sre_random.h line 8
extern double sre_random(void)
{
  signed long int x;
  signed long int y;
  signed int i;
  signed long int a1 = (signed long int)40014;
  signed long int m1 = (signed long int)2147483563;
  signed long int q1 = (signed long int)53668;
  signed long int r1 = (signed long int)12211;
  signed long int a2 = (signed long int)40692;
  signed long int m2 = (signed long int)2147483399;
  signed long int q2 = (signed long int)52774;
  signed long int r2 = (signed long int)3791;
  static signed long int tbl[64l];
  static signed long int rnd2;
  static signed long int rnd1;
  if(sre_randseed >= 1)
  {
    rnd1 = (signed long int)sre_randseed;
    rnd2 = (signed long int)sre_randseed;
    i = 0;
    for( ; !(i >= 64); i = i + 1)
    {
      x = a1 * (rnd1 % q1);
      y = r1 * (rnd1 / q1);
      rnd1 = x - y;
      if(!(rnd1 >= 0l))
        rnd1 = rnd1 + m1;

      x = a2 * (rnd2 % q2);
      y = r2 * (rnd2 / q2);
      rnd2 = x - y;
      if(!(rnd2 >= 0l))
        rnd2 = rnd2 + m2;

      tbl[(signed long int)i] = rnd1 - rnd2;
      if(!(tbl[(signed long int)i] >= 0l))
        tbl[(signed long int)i] = tbl[(signed long int)i] + m1;

    }
    sre_randseed = 0;
  }

  x = a1 * (rnd1 % q1);
  y = r1 * (rnd1 / q1);
  rnd1 = x - y;
  if(!(rnd1 >= 0l))
    rnd1 = rnd1 + m1;

  x = a2 * (rnd2 % q2);
  y = r2 * (rnd2 / q2);
  rnd2 = x - y;
  if(!(rnd2 >= 0l))
    rnd2 = rnd2 + m2;

  static signed long int rnd;
  i = (signed int)(((double)rnd / (double)m1) * 64.);
  rnd = tbl[(signed long int)i];
  tbl[(signed long int)i] = rnd1 - rnd2;
  if(!(tbl[(signed long int)i] >= 0l))
    tbl[(signed long int)i] = tbl[(signed long int)i] + m1;

  return (double)rnd / (double)m1;
}

// sre_random_positive
// file sre_random.c line 130
extern double sre_random_positive(void)
{
  double x;
  do
    x=sre_random();
  while(IEEE_FLOAT_EQUAL(x, 0.0));
  return x;
}

// sre_realloc
// file ../squid/sqfuncs.h line 221
extern void * sre_realloc(char *file, signed int line, void *p, unsigned long int size)
{
  void *ptr;
  ptr=realloc(p, size);
  if(ptr == NULL)
    Die("realloc of %ld bytes failed: file %s line %d", size, file, line);

  return ptr;
}

// sre_srandom
// file ../squid/sre_random.h line 9
extern void sre_srandom(signed int seed)
{
  if(!(seed >= 0))
    seed = -1 * seed;

  if(seed == 0)
    seed = 42;

  sre_randseed = seed;
}

// sre_strcat
// file sqfuncs.h line 226
extern signed int sre_strcat(char **dest, signed int ldest, char *src, signed int lsrc)
{
  signed int len1;
  signed int len2;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(ldest >= 0))
  {
    if(*dest == ((char *)NULL))
      tmp_if_expr$2 = (unsigned long int)0;

    else
    {
      return_value_strlen$1=strlen(*dest);
      tmp_if_expr$2 = return_value_strlen$1;
    }
    len1 = (signed int)tmp_if_expr$2;
  }

  else
    len1 = ldest;
  unsigned long int tmp_if_expr$4;
  unsigned long int return_value_strlen$3;
  if(!(lsrc >= 0))
  {
    if(src == ((char *)NULL))
      tmp_if_expr$4 = (unsigned long int)0;

    else
    {
      return_value_strlen$3=strlen(src);
      tmp_if_expr$4 = return_value_strlen$3;
    }
    len2 = (signed int)tmp_if_expr$4;
  }

  else
    len2 = lsrc;
  void *return_value_sre_malloc$5;
  void *return_value_sre_realloc$6;
  if(len2 == 0)
    return len1;

  else
  {
    if(*dest == ((char *)NULL))
    {
      return_value_sre_malloc$5=sre_malloc("sre_string.c", 344, sizeof(char) /*1ul*/  * (unsigned long int)(len2 + 1));
      *dest = (char *)return_value_sre_malloc$5;
    }

    else
    {
      return_value_sre_realloc$6=sre_realloc("sre_string.c", 345, (void *)*dest, sizeof(char) /*1ul*/  * (unsigned long int)(len1 + len2 + 1));
      *dest = (char *)return_value_sre_realloc$6;
    }
    memcpy((void *)(*dest + (signed long int)len1), (const void *)src, (unsigned long int)(len2 + 1));
    return len1 + len2;
  }
}

// sre_strdup
// file ../squid/sqfuncs.h line 228
extern char * sre_strdup(char *s, signed int n)
{
  char *new;
  unsigned long int return_value_strlen$1;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(!(n >= 0))
    {
      return_value_strlen$1=strlen(s);
      n = (signed int)return_value_strlen$1;
    }

    void *return_value_sre_malloc$2;
    return_value_sre_malloc$2=sre_malloc("sre_string.c", 442, sizeof(char) /*1ul*/  * (unsigned long int)(n + 1));
    new = (char *)return_value_sre_malloc$2;
    strcpy(new, s);
    return new;
  }
}

// sre_strncpy
// file sre_string.c line 462
extern char * sre_strncpy(char *s1, char *s2, signed int n)
{
  strncpy(s1, s2, (unsigned long int)n);
  s1[(signed long int)n] = (char)0;
  return s1;
}

// sre_strtok
// file sqfuncs.h line 227
extern char * sre_strtok(char **s, char *delim, signed int *len)
{
  char *begin;
  char *end;
  signed int n;
  begin = *s;
  unsigned long int return_value_strspn$1;
  return_value_strspn$1=strspn(begin, delim);
  begin = begin + (signed long int)return_value_strspn$1;
  if(*begin == 0)
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strcspn$2;
    return_value_strcspn$2=strcspn(begin, delim);
    n = (signed int)return_value_strcspn$2;
    end = begin + (signed long int)n;
    if((signed int)*end == 0)
      *s = end;

    else
    {
      *end = (char)0;
      *s = end + (signed long int)1;
    }
    if(!(len == ((signed int *)NULL)))
      *len = n;

    return begin;
  }
}

// sre_tolower
// file sqfuncs.h line 192
extern signed int sre_tolower(signed int c)
{
  const unsigned short int **return_value___ctype_b_loc$2;
  return_value___ctype_b_loc$2=__ctype_b_loc();
  signed int return_value_tolower$1;
  if(!((256 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)c]) == 0))
  {
    return_value_tolower$1=tolower(c);
    return return_value_tolower$1;
  }

  else
    return c;
}

// sre_toupper
// file ../squid/sqfuncs.h line 193
extern signed int sre_toupper(signed int c)
{
  const unsigned short int **return_value___ctype_b_loc$2;
  return_value___ctype_b_loc$2=__ctype_b_loc();
  signed int return_value_toupper$1;
  if(!((512 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)c]) == 0))
  {
    return_value_toupper$1=toupper(c);
    return return_value_toupper$1;
  }

  else
    return c;
}

// trace_doctor
// file modelmakers.c line 745
static void trace_doctor(struct p7trace_s *tr, signed int mlen, signed int *ret_ndi, signed int *ret_nid)
{
  signed int opos;
  signed int npos;
  signed int ndi;
  signed int nid = 0;
  ndi = nid;
  npos = 0;
  opos = npos;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  while(!(opos >= tr->tlen))
  {
    if((signed int)tr->statetype[(signed long int)opos] == 2)
      tmp_if_expr$10 = (signed int)tr->statetype[(signed long int)(opos + 1)] == 3 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
    {
      tr->statetype[(signed long int)npos] = (char)1;
      tr->nodeidx[(signed long int)npos] = tr->nodeidx[(signed long int)opos];
      tr->pos[(signed long int)npos] = tr->pos[(signed long int)(opos + 1)];
      opos = opos + 2;
      npos = npos + 1;
      ndi = ndi + 1;
    }

    else
    {
      if((signed int)tr->statetype[(signed long int)opos] == 3)
        tmp_if_expr$9 = (signed int)tr->statetype[(signed long int)(opos + 1)] == 2 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        tr->statetype[(signed long int)npos] = (char)1;
        tr->nodeidx[(signed long int)npos] = tr->nodeidx[(signed long int)(opos + 1)];
        tr->pos[(signed long int)npos] = tr->pos[(signed long int)opos];
        opos = opos + 2;
        npos = npos + 1;
        nid = nid + 1;
      }

      else
      {
        if((signed int)tr->statetype[(signed long int)opos] == 3)
          tmp_if_expr$8 = (signed int)tr->statetype[(signed long int)(opos - 1)] == 6 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
        {
          tr->statetype[(signed long int)npos] = (char)1;
          tr->nodeidx[(signed long int)npos] = tr->nodeidx[(signed long int)opos];
          tr->pos[(signed long int)npos] = tr->pos[(signed long int)opos];
          opos = opos + 1;
          npos = npos + 1;
        }

        else
        {
          if((signed int)tr->statetype[(signed long int)opos] == 3)
            tmp_if_expr$7 = (signed int)tr->statetype[(signed long int)(opos + 1)] == 7 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          if(tmp_if_expr$7)
          {
            tr->statetype[(signed long int)npos] = (char)1;
            tr->nodeidx[(signed long int)npos] = tr->nodeidx[(signed long int)opos] + 1;
            tr->pos[(signed long int)npos] = tr->pos[(signed long int)opos];
            opos = opos + 1;
            npos = npos + 1;
          }

          else
          {
            if((signed int)tr->statetype[(signed long int)opos] == 6)
              tmp_if_expr$4 = (signed int)tr->statetype[(signed long int)(opos + 1)] == 7 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(tmp_if_expr$4)
              tmp_if_expr$5 = (signed int)tr->statetype[(signed long int)(opos - 1)] == 5 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = tr->pos[(signed long int)(opos - 1)] > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$6 = (_Bool)0;
            if(tmp_if_expr$6)
            {
              tr->statetype[(signed long int)npos] = (char)1;
              tr->nodeidx[(signed long int)npos] = 1;
              tr->pos[(signed long int)npos] = tr->pos[(signed long int)(opos - 1)];
              tr->statetype[(signed long int)(npos - 1)] = (char)6;
              tr->nodeidx[(signed long int)(npos - 1)] = 0;
              tr->pos[(signed long int)(npos - 1)] = 0;
              opos = opos + 1;
              npos = npos + 1;
            }

            else
            {
              if((signed int)tr->statetype[(signed long int)opos] == 7)
                tmp_if_expr$1 = (signed int)tr->statetype[(signed long int)(opos - 1)] == 6 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$1 = (_Bool)0;
              if(tmp_if_expr$1)
                tmp_if_expr$2 = (signed int)tr->statetype[(signed long int)(opos + 1)] == 8 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$2 = (_Bool)0;
              if(tmp_if_expr$2)
                tmp_if_expr$3 = (signed int)tr->statetype[(signed long int)(opos + 2)] == 8 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
              {
                tr->statetype[(signed long int)npos] = (char)1;
                tr->nodeidx[(signed long int)npos] = mlen;
                tr->pos[(signed long int)npos] = tr->pos[(signed long int)(opos + 2)];
                tr->statetype[(signed long int)(npos + 1)] = (char)7;
                tr->nodeidx[(signed long int)(npos + 1)] = 0;
                tr->pos[(signed long int)(npos + 1)] = 0;
                tr->statetype[(signed long int)(npos + 2)] = (char)8;
                tr->nodeidx[(signed long int)(npos + 2)] = 0;
                tr->pos[(signed long int)(npos + 2)] = 0;
                opos = opos + 3;
                npos = npos + 3;
              }

              else
              {
                tr->statetype[(signed long int)npos] = tr->statetype[(signed long int)opos];
                tr->nodeidx[(signed long int)npos] = tr->nodeidx[(signed long int)opos];
                tr->pos[(signed long int)npos] = tr->pos[(signed long int)opos];
                opos = opos + 1;
                npos = npos + 1;
              }
            }
          }
        }
      }
    }
  }
  tr->tlen = npos;
  if(!(ret_ndi == ((signed int *)NULL)))
    *ret_ndi = ndi;

  if(!(ret_nid == ((signed int *)NULL)))
    *ret_nid = nid;

  goto __CPROVER_DUMP_L32;

__CPROVER_DUMP_L32:
  ;
}

// upweight
// file weight.c line 96
static void upweight(struct phylo_s *tree, signed int nseq, float *lwt, float *rwt, signed int node)
{
  signed int ld;
  signed int rd;
  ld = (tree + (signed long int)(node - nseq))->left;
  if(ld >= nseq)
    upweight(tree, nseq, lwt, rwt, ld);

  rd = (tree + (signed long int)(node - nseq))->right;
  if(rd >= nseq)
    upweight(tree, nseq, lwt, rwt, rd);

  lwt[(signed long int)node] = lwt[(signed long int)ld] + rwt[(signed long int)ld] + (tree + (signed long int)(node - nseq))->lblen;
  rwt[(signed long int)node] = lwt[(signed long int)rd] + rwt[(signed long int)rd] + (tree + (signed long int)(node - nseq))->rblen;
}

// worker_thread
// file hmmcalibrate.c line 707
static void * worker_thread(void *ptr)
{
  struct plan7_s *hmm;
  struct dpmatrix_s *mx;
  struct workpool_s *wpool;
  char *seq;
  unsigned char *dsq;
  signed int len;
  float sc;
  signed int rtn;
  struct stopwatch_s thread_watch;
  StopwatchStart(&thread_watch);
  wpool = (struct workpool_s *)ptr;
  hmm = wpool->hmm;
  mx=CreatePlan7Matrix(1, hmm->M, 25, 0);
  char *return_value_strerror$1;
  char *return_value_strerror$2;
  double return_value_Gaussrandom$3;
  char *return_value_strerror$4;
  char *return_value_strerror$6;
  char *return_value_strerror$7;
  do
  {
    rtn=pthread_mutex_lock(&wpool->input_lock);
    if(!(rtn == 0))
    {
      return_value_strerror$1=strerror(rtn);
      Die("pthread_mutex_lock failure: %s\n", return_value_strerror$1);
    }

    wpool->nseq = wpool->nseq + 1;
    if(!(wpool->nsample >= wpool->nseq))
    {
      rtn=pthread_mutex_unlock(&wpool->input_lock);
      if(!(rtn == 0))
      {
        return_value_strerror$2=strerror(rtn);
        Die("pthread_mutex_unlock failure: %s\n", return_value_strerror$2);
      }

      break;
    }

    if(!(wpool->fixedlen == 0))
      len = wpool->fixedlen;

    else
      do
      {
        return_value_Gaussrandom$3=Gaussrandom((double)wpool->lenmean, (double)wpool->lensd);
        len = (signed int)return_value_Gaussrandom$3;
      }
      while(!(len >= 1));
    seq=RandomSequence(Alphabet, wpool->randomseq, Alphabet_size, len);
    rtn=pthread_mutex_unlock(&wpool->input_lock);
    if(!(rtn == 0))
    {
      return_value_strerror$4=strerror(rtn);
      Die("pthread_mutex_unlock failure: %s\n", return_value_strerror$4);
    }

    dsq=DigitizeSequence(seq, len);
    signed int return_value_P7ViterbiSpaceOK$5;
    return_value_P7ViterbiSpaceOK$5=P7ViterbiSpaceOK(len, hmm->M, mx);
    if(!(return_value_P7ViterbiSpaceOK$5 == 0))
      sc=P7Viterbi(dsq, len, hmm, mx, (struct p7trace_s **)(void *)0);

    else
      sc=P7SmallViterbi(dsq, len, hmm, mx, (struct p7trace_s **)(void *)0);
    free((void *)dsq);
    free((void *)seq);
    rtn=pthread_mutex_lock(&wpool->output_lock);
    if(!(rtn == 0))
    {
      return_value_strerror$6=strerror(rtn);
      Die("pthread_mutex_lock failure: %s\n", return_value_strerror$6);
    }

    AddToHistogram(wpool->hist, sc);
    if(sc > wpool->max_score)
      wpool->max_score = sc;

    rtn=pthread_mutex_unlock(&wpool->output_lock);
    if(!(rtn == 0))
    {
      return_value_strerror$7=strerror(rtn);
      Die("pthread_mutex_unlock failure: %s\n", return_value_strerror$7);
    }

  }
  while((_Bool)1);
  StopwatchStop(&thread_watch);
  rtn=pthread_mutex_lock(&wpool->output_lock);
  char *return_value_strerror$8;
  if(!(rtn == 0))
  {
    return_value_strerror$8=strerror(rtn);
    Die("pthread_mutex_lock failure: %s\n", return_value_strerror$8);
  }

  StopwatchInclude(&wpool->watch, &thread_watch);
  rtn=pthread_mutex_unlock(&wpool->output_lock);
  char *return_value_strerror$9;
  if(!(rtn == 0))
  {
    return_value_strerror$9=strerror(rtn);
    Die("pthread_mutex_unlock failure: %s\n", return_value_strerror$9);
  }

  FreePlan7Matrix(mx);
  pthread_exit((void *)0);
  return (void *)0;
}

// workpool_free
// file hmmcalibrate.c line 689
static void workpool_free(struct workpool_s *wpool)
{
  free((void *)wpool->thread);
  free((void *)wpool);
}

// workpool_start
// file hmmcalibrate.c line 594
static struct workpool_s * workpool_start(struct plan7_s *hmm, float lenmean, float lensd, signed int fixedlen, float *randomseq, signed int nsample, struct histogram_s *hist, signed int num_threads)
{
  struct workpool_s *wpool;
  union pthread_attr_t attr;
  signed int i;
  signed int rtn;
  void *return_value_sre_malloc$1;
  return_value_sre_malloc$1=sre_malloc("hmmcalibrate.c", 603, sizeof(struct workpool_s) /*216ul*/ );
  wpool = (struct workpool_s *)return_value_sre_malloc$1;
  void *return_value_sre_malloc$2;
  return_value_sre_malloc$2=sre_malloc("hmmcalibrate.c", 604, (unsigned long int)num_threads * sizeof(unsigned long int) /*8ul*/ );
  wpool->thread = (unsigned long int *)return_value_sre_malloc$2;
  wpool->hmm = hmm;
  wpool->fixedlen = fixedlen;
  wpool->lenmean = lenmean;
  wpool->lensd = lensd;
  wpool->randomseq = randomseq;
  wpool->nsample = nsample;
  wpool->nseq = 0;
  wpool->hist = hist;
  wpool->max_score = -3.40282346638528859812e+38F;
  wpool->num_threads = num_threads;
  StopwatchZero(&wpool->watch);
  rtn=pthread_mutex_init(&wpool->input_lock, (const union anonymous$2 *)(void *)0);
  char *return_value_strerror$3;
  if(!(rtn == 0))
  {
    return_value_strerror$3=strerror(rtn);
    Die("pthread_mutex_init FAILED; %s\n", return_value_strerror$3);
  }

  rtn=pthread_mutex_init(&wpool->output_lock, (const union anonymous$2 *)(void *)0);
  char *return_value_strerror$4;
  if(!(rtn == 0))
  {
    return_value_strerror$4=strerror(rtn);
    Die("pthread_mutex_init FAILED; %s\n", return_value_strerror$4);
  }

  pthread_attr_init(&attr);
  pthread_attr_setscope(&attr, 0);
  i = 0;
  for( ; !(i >= num_threads); i = i + 1)
  {
    rtn=pthread_create(&wpool->thread[(signed long int)i], &attr, worker_thread, (void *)wpool);
    if(!(rtn == 0))
      Die("Failed to create thread %d; return code %d\n", i, rtn);

  }
  pthread_attr_destroy(&attr);
  return wpool;
}

// workpool_stop
// file hmmcalibrate.c line 668
static void workpool_stop(struct workpool_s *wpool)
{
  signed int i = 0;
  signed int return_value_pthread_join$1;
  for( ; !(i >= wpool->num_threads); i = i + 1)
  {
    return_value_pthread_join$1=pthread_join(wpool->thread[(signed long int)i], (void **)(void *)0);
    if(!(return_value_pthread_join$1 == 0))
      Die("pthread_join failed");

  }
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// write_bin_string
// file hmmio.c line 1333
static void write_bin_string(struct _IO_FILE *fp, char *s)
{
  signed int len;
  if(!(s == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(s);
    len = (signed int)(return_value_strlen$1 + (unsigned long int)1);
    fwrite((const void *)(char *)&len, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
    fwrite((const void *)(char *)s, sizeof(char) /*1ul*/ , (unsigned long int)len, fp);
  }

  else
  {
    len = 0;
    fwrite((const void *)(char *)&len, sizeof(signed int) /*4ul*/ , (unsigned long int)1, fp);
  }
}

// write_i16
// file ssi.c line 1142
static signed int write_i16(struct _IO_FILE *fp, unsigned short int n)
{
  n=sre_hton16(n);
  unsigned long int return_value_fwrite$1;
  return_value_fwrite$1=fwrite((const void *)&n, sizeof(unsigned short int) /*2ul*/ , (unsigned long int)1, fp);
  if(!(return_value_fwrite$1 == 1ul))
    return 0;

  else
    return 1;
}

// write_i32
// file ssi.c line 1157
static signed int write_i32(struct _IO_FILE *fp, unsigned int n)
{
  n=sre_hton32(n);
  unsigned long int return_value_fwrite$1;
  return_value_fwrite$1=fwrite((const void *)&n, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, fp);
  if(!(return_value_fwrite$1 == 1ul))
    return 0;

  else
    return 1;
}

// write_i64
// file ssi.c line 1172
static signed int write_i64(struct _IO_FILE *fp, unsigned long int n)
{
  n=sre_hton64(n);
  unsigned long int return_value_fwrite$1;
  return_value_fwrite$1=fwrite((const void *)&n, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, fp);
  if(!(return_value_fwrite$1 == 1ul))
    return 0;

  else
    return 1;
}

// write_offset
// file ssi.c line 1192
static signed int write_offset(struct _IO_FILE *fp, struct ssioffset_s *offset)
{
  signed int return_value_write_i32$1;
  signed int return_value_write_i64$2;
  if((signed int)offset->mode == 0)
  {
    return_value_write_i32$1=write_i32(fp, offset->off.i32);
    return return_value_write_i32$1;
  }

  else
    if((signed int)offset->mode == 1)
    {
      return_value_write_i64$2=write_i64(fp, offset->off.i64);
      return return_value_write_i64$2;
    }

    else
      abort();
  return 1;
}

